{"home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._already_wrapped": [[24, 26], ["constr.__name__.startswith"], "function", ["None"], ["def", "_already_wrapped", "(", "constr", ")", ":", "\n", "    ", "return", "constr", ".", "__name__", ".", "startswith", "(", "WRAPPED_PREFIX", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr": [[28, 46], ["registering._already_wrapped"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._already_wrapped"], ["", "def", "_get_plotly_constr", "(", "constr", ")", ":", "\n", "    ", "\"\"\"Return the constructor of the underlying plotly graph object and thus omit the\n    possibly wrapped :class:`AbstractFigureAggregator <plotly_resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator>`\n    instance.\n\n    Parameters\n    ----------\n    constr : callable\n        The constructor of a instantiatedplotly-object.\n\n    Returns\n    -------\n    callable\n        The constructor of a ``go.FigureWidget`` or a ``go.Figure``.\n    \"\"\"", "\n", "if", "_already_wrapped", "(", "constr", ")", ":", "\n", "        ", "return", "constr", ".", "__wrapped__", "# get the original constructor", "\n", "", "return", "constr", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._is_ipython_env": [[51, 59], ["get_ipython"], "function", ["None"], ["", "def", "_is_ipython_env", "(", ")", ":", "\n", "    ", "\"\"\"Check if we are in an IPython environment (with a kernel).\"\"\"", "\n", "try", ":", "\n", "        ", "from", "IPython", "import", "get_ipython", "\n", "\n", "return", "\"IPKernelApp\"", "in", "get_ipython", "(", ")", ".", "config", "\n", "", "except", "Exception", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._register_wrapper": [[61, 79], ["getattr", "registering._get_plotly_constr", "functools.wraps", "setattr", "pr_class", "_get_plotly_constr."], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr"], ["", "", "def", "_register_wrapper", "(", "\n", "module", ":", "type", ",", "\n", "constr_name", ":", "str", ",", "\n", "pr_class", ":", "AbstractFigureAggregator", ",", "\n", "**", "aggregator_kwargs", ",", "\n", ")", ":", "\n", "    ", "constr", "=", "getattr", "(", "module", ",", "constr_name", ")", "\n", "constr", "=", "_get_plotly_constr", "(", "constr", ")", "# get the original plotly constructor", "\n", "\n", "# print(f\"Wrapping {constr_name} with {pr_class}\")", "\n", "\n", "@", "wraps", "(", "constr", ")", "\n", "def", "wrapped_constr", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# print(f\"Executing constructor wrapper for {constr_name}\", constr)", "\n", "        ", "return", "pr_class", "(", "constr", "(", "*", "args", ",", "**", "kwargs", ")", ",", "**", "aggregator_kwargs", ")", "\n", "\n", "", "wrapped_constr", ".", "__name__", "=", "WRAPPED_PREFIX", "+", "constr_name", "\n", "setattr", "(", "module", ",", "constr_name", ",", "wrapped_constr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler": [[81, 123], ["PLOTLY_CONSTRUCTOR_WRAPPER.items", "registering._register_wrapper", "registering._is_ipython_env"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._register_wrapper", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._is_ipython_env"], ["", "def", "register_plotly_resampler", "(", "mode", "=", "\"auto\"", ",", "**", "aggregator_kwargs", ")", ":", "\n", "    ", "\"\"\"Register plotly-resampler to plotly.graph_objects.\n\n    This function results in the use of plotly-resampler under the hood.\n\n    .. Note::\n        We advise to use mode= ``widget`` when working in an IPython based environment\n        as this will just behave as a ``go.FigureWidget``, but with dynamic aggregation.\n        When using mode= ``auto`` or ``figure``; most figures will be wrapped as\n        :class:`FigureResampler <plotly_resampler.figure_resampler.FigureResampler>`,\n        on which\n        :func:`show_dash <plotly_resampler.figure_resampler.FigureResampler.show_dash>`\n        needs to be called.\n\n    Parameters\n    ----------\n    mode : str, optional\n        The mode of the plotly-resampler.\n        Possible values are: 'auto', 'figure', 'widget', None.\n        If 'auto' is used, the mode is determined based on the environment; if it is in\n        an ipython environment, the mode is 'widget', otherwise it is 'figure'.\n        If 'figure' is used, all plotly figures are wrapped as FigureResampler objects.\n        If 'widget' is used, all plotly figure widgets are wrapped as\n        FigureWidgetResampler objects (we advise to use this mode in ipython environment\n        with a kernel).\n        If None is used, wrapping is done as expected (go.Figure -> FigureResampler,\n        go.FigureWidget -> FigureWidgetResampler).\n    aggregator_kwargs : dict, optional\n        The keyword arguments to pass to the plotly-resampler decorator its constructor.\n        See more details in :class:`FigureResampler <FigureResampler>` and\n        :class:`FigureWidgetResampler <FigureWidgetResampler>`.\n\n    \"\"\"", "\n", "for", "constr_name", ",", "pr_class", "in", "PLOTLY_CONSTRUCTOR_WRAPPER", ".", "items", "(", ")", ":", "\n", "        ", "if", "(", "mode", "==", "\"auto\"", "and", "_is_ipython_env", "(", ")", ")", "or", "mode", "==", "\"widget\"", ":", "\n", "            ", "pr_class", "=", "FigureWidgetResampler", "\n", "", "elif", "mode", "==", "\"figure\"", ":", "\n", "            ", "pr_class", "=", "FigureResampler", "\n", "# else: default mode -> wrap according to PLOTLY_CONSTRUCTOR_WRAPPER", "\n", "\n", "", "for", "module", "in", "PLOTLY_MODULES", ":", "\n", "            ", "_register_wrapper", "(", "module", ",", "constr_name", ",", "pr_class", ",", "**", "aggregator_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._unregister_wrapper": [[128, 133], ["getattr", "registering._already_wrapped", "setattr"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._already_wrapped"], ["", "", "", "def", "_unregister_wrapper", "(", "module", ":", "type", ",", "constr_name", ":", "str", ")", ":", "\n", "    ", "constr", "=", "getattr", "(", "module", ",", "constr_name", ")", "\n", "if", "_already_wrapped", "(", "constr", ")", ":", "\n", "        ", "constr", "=", "constr", ".", "__wrapped__", "\n", "setattr", "(", "module", ",", "constr_name", ",", "constr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.unregister_plotly_resampler": [[135, 140], ["PLOTLY_CONSTRUCTOR_WRAPPER.keys", "registering._unregister_wrapper"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._unregister_wrapper"], ["", "", "def", "unregister_plotly_resampler", "(", ")", ":", "\n", "    ", "\"\"\"Unregister plotly-resampler from plotly.graph_objects.\"\"\"", "\n", "for", "constr", "in", "PLOTLY_CONSTRUCTOR_WRAPPER", ".", "keys", "(", ")", ":", "\n", "        ", "for", "module", "in", "PLOTLY_MODULES", ":", "\n", "            ", "_unregister_wrapper", "(", "module", ",", "constr", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.__init__": [[41, 107], ["aggregation.EfficientLTTB", "isinstance", "super().__init__", "isinstance", "figurewidget_resampler.FigureWidgetResampler.layout.on_change", "figurewidget_resampler.FigureWidgetResampler.layout.on_change", "figurewidget_resampler.FigureWidgetResampler._get_figure_class", "f.add_traces", "isinstance", "figurewidget_resampler.FigureWidgetResampler._hf_data.update", "f.add_traces", "figurewidget_resampler.FigureWidgetResampler._copy_hf_data", "figurewidget_resampler.FigureWidgetResampler.batch_update", "figurewidget_resampler.FigureWidgetResampler._get_current_graph", "figurewidget_resampler.FigureWidgetResampler._check_update_figure_dict", "figurewidget_resampler.FigureWidgetResampler.data[].update"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._get_figure_class", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._copy_hf_data", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._get_current_graph", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict"], ["def", "__init__", "(", "\n", "self", ",", "\n", "figure", ":", "BaseFigure", "|", "dict", "=", "None", ",", "\n", "convert_existing_traces", ":", "bool", "=", "True", ",", "\n", "default_n_shown_samples", ":", "int", "=", "1000", ",", "\n", "default_downsampler", ":", "AbstractSeriesAggregator", "=", "EfficientLTTB", "(", ")", ",", "\n", "resampled_trace_prefix_suffix", ":", "Tuple", "[", "str", ",", "str", "]", "=", "(", "\n", "'<b style=\"color:sandybrown\">[R]</b> '", ",", "\n", "\"\"", ",", "\n", ")", ",", "\n", "show_mean_aggregation_size", ":", "bool", "=", "True", ",", "\n", "convert_traces_kwargs", ":", "dict", "|", "None", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "# Parse the figure input before calling `super`", "\n", "        ", "f", "=", "self", ".", "_get_figure_class", "(", "go", ".", "FigureWidget", ")", "(", ")", "\n", "f", ".", "_data_validator", ".", "set_uid", "=", "False", "\n", "\n", "if", "isinstance", "(", "figure", ",", "BaseFigure", ")", ":", "# go.Figure or go.FigureWidget or AbstractFigureAggregator", "\n", "# A base figure object, we first copy the layout and grid ref", "\n", "            ", "f", ".", "layout", "=", "figure", ".", "layout", "\n", "f", ".", "_grid_ref", "=", "figure", ".", "_grid_ref", "\n", "f", ".", "add_traces", "(", "figure", ".", "data", ")", "\n", "", "elif", "isinstance", "(", "figure", ",", "(", "dict", ",", "list", ")", ")", ":", "\n", "# A single trace dict or a list of traces", "\n", "            ", "f", ".", "add_traces", "(", "figure", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "\n", "f", ",", "\n", "convert_existing_traces", ",", "\n", "default_n_shown_samples", ",", "\n", "default_downsampler", ",", "\n", "resampled_trace_prefix_suffix", ",", "\n", "show_mean_aggregation_size", ",", "\n", "convert_traces_kwargs", ",", "\n", "verbose", ",", "\n", ")", "\n", "\n", "if", "isinstance", "(", "figure", ",", "AbstractFigureAggregator", ")", ":", "\n", "# Copy the `_hf_data` if the previous figure was an AbstractFigureAggregator", "\n", "# And adjust the default max_n_samples and", "\n", "            ", "self", ".", "_hf_data", ".", "update", "(", "\n", "self", ".", "_copy_hf_data", "(", "figure", ".", "_hf_data", ",", "adjust_default_values", "=", "True", ")", "\n", ")", "\n", "\n", "# Note: This hack ensures that the this figure object initially uses", "\n", "# data of the whole view. More concretely; we create a dict", "\n", "# serialization figure and adjust the hf-traces to the whole view", "\n", "# with the check-update method (by passing no range / filter args)", "\n", "with", "self", ".", "batch_update", "(", ")", ":", "\n", "                ", "graph_dict", ":", "dict", "=", "self", ".", "_get_current_graph", "(", ")", "\n", "update_indices", "=", "self", ".", "_check_update_figure_dict", "(", "graph_dict", ")", "\n", "for", "idx", "in", "update_indices", ":", "\n", "                    ", "self", ".", "data", "[", "idx", "]", ".", "update", "(", "graph_dict", "[", "\"data\"", "]", "[", "idx", "]", ")", "\n", "\n", "", "", "", "self", ".", "_prev_layout", "=", "None", "# Contains the previous xaxis layout configuration", "\n", "\n", "# used for logging purposes to save a history of layout changes", "\n", "self", ".", "_relayout_hist", "=", "[", "]", "\n", "\n", "# Assign the the update-methods to the corresponding classes", "\n", "showspike_keys", "=", "[", "f\"{xaxis}.showspikes\"", "for", "xaxis", "in", "self", ".", "_xaxis_list", "]", "\n", "self", ".", "layout", ".", "on_change", "(", "self", ".", "_update_spike_ranges", ",", "*", "showspike_keys", ")", "\n", "\n", "x_relayout_keys", "=", "[", "f\"{xaxis}.range\"", "for", "xaxis", "in", "self", ".", "_xaxis_list", "]", "\n", "self", ".", "layout", ".", "on_change", "(", "self", ".", "_update_x_ranges", ",", "*", "x_relayout_keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_x_ranges": [[108, 171], ["zip", "len", "layout[].to_plotly_json", "figurewidget_resampler.FigureWidgetResampler.construct_update_data", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "figurewidget_resampler.FigureWidgetResampler.batch_update", "figurewidget_resampler.FigureWidgetResampler.layout.update", "dict", "updated_trace.pop", "figurewidget_resampler.FigureWidgetResampler.data[].update", "figurewidget_resampler.FigureWidgetResampler._prev_layout[].get", "zip", "figurewidget_resampler.FigureWidgetResampler.layout[].pop", "len"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.construct_update_data"], ["", "def", "_update_x_ranges", "(", "self", ",", "layout", ",", "*", "x_ranges", ",", "force_update", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Update the the go.Figure data based on changed x-ranges.\n\n        Parameters\n        ----------\n        layout : go.Layout\n            The figure's (i.e, self) layout object. Remark that this is a reference,\n            so if we change self.layout (same object reference), this object will\n            change.\n        *x_ranges: iterable\n            A iterable list of current x-ranges, where each x-range is a tuple of two\n            items, indicating the current/new (if changed) left-right x-range,\n            respectively.\n        fore_update: bool\n            Whether an update of all traces will be forced, by default False.\n        \"\"\"", "\n", "relayout_dict", "=", "{", "}", "# variable in which we aim to reconstruct the relayout", "\n", "# serialize the layout in a new dict object", "\n", "layout", "=", "{", "\n", "xaxis_str", ":", "layout", "[", "xaxis_str", "]", ".", "to_plotly_json", "(", ")", "\n", "for", "xaxis_str", "in", "self", ".", "_xaxis_list", "\n", "}", "\n", "if", "self", ".", "_prev_layout", "is", "None", ":", "\n", "            ", "self", ".", "_prev_layout", "=", "layout", "\n", "\n", "", "for", "xaxis_str", ",", "x_range", "in", "zip", "(", "self", ".", "_xaxis_list", ",", "x_ranges", ")", ":", "\n", "# We also check whether \"range\" is within the xaxis its layout otherwise", "\n", "# It is most-likely an autorange check", "\n", "            ", "if", "(", "\n", "\"range\"", "in", "layout", "[", "xaxis_str", "]", "\n", "and", "self", ".", "_prev_layout", "[", "xaxis_str", "]", ".", "get", "(", "\"range\"", ",", "[", "]", ")", "!=", "x_range", "\n", "or", "(", "force_update", "and", "x_range", "is", "not", "None", ")", "\n", ")", ":", "\n", "# a change took place -> add to the relayout dict", "\n", "                ", "relayout_dict", "[", "f\"{xaxis_str}.range[0]\"", "]", "=", "x_range", "[", "0", "]", "\n", "relayout_dict", "[", "f\"{xaxis_str}.range[1]\"", "]", "=", "x_range", "[", "1", "]", "\n", "\n", "# An update will take place for that trace", "\n", "# -> save current xaxis range to _prev_layout", "\n", "self", ".", "_prev_layout", "[", "xaxis_str", "]", "[", "\"range\"", "]", "=", "x_range", "\n", "\n", "", "", "if", "len", "(", "relayout_dict", ")", ":", "\n", "# Construct the update data", "\n", "            ", "update_data", "=", "self", ".", "construct_update_data", "(", "relayout_dict", ")", "\n", "\n", "if", "self", ".", "_print_verbose", ":", "\n", "                ", "self", ".", "_relayout_hist", ".", "append", "(", "dict", "(", "zip", "(", "self", ".", "_xaxis_list", ",", "x_ranges", ")", ")", ")", "\n", "self", ".", "_relayout_hist", ".", "append", "(", "layout", ")", "\n", "self", ".", "_relayout_hist", ".", "append", "(", "[", "\"xaxis-range-update\"", ",", "len", "(", "update_data", ")", "-", "1", "]", ")", "\n", "self", ".", "_relayout_hist", ".", "append", "(", "\"-\"", "*", "30", ")", "\n", "\n", "", "with", "self", ".", "batch_update", "(", ")", ":", "\n", "# First update the layout (first item of update_data)", "\n", "                ", "self", ".", "layout", ".", "update", "(", "update_data", "[", "0", "]", ")", "\n", "\n", "for", "xaxis_str", "in", "self", ".", "_xaxis_list", ":", "\n", "                    ", "if", "\"showspikes\"", "in", "layout", "[", "xaxis_str", "]", ":", "\n", "                        ", "self", ".", "layout", "[", "xaxis_str", "]", ".", "pop", "(", "\"showspikes\"", ")", "\n", "\n", "# Then update the data", "\n", "", "", "for", "updated_trace", "in", "update_data", "[", "1", ":", "]", ":", "\n", "                    ", "trace_idx", "=", "updated_trace", ".", "pop", "(", "\"index\"", ")", "\n", "self", ".", "data", "[", "trace_idx", "]", ".", "update", "(", "updated_trace", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_spike_ranges": [[172, 248], ["zip", "len", "layout[].to_plotly_json", "figurewidget_resampler.FigureWidgetResampler.construct_update_data", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "figurewidget_resampler.FigureWidgetResampler.batch_update", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "figurewidget_resampler.FigureWidgetResampler._relayout_hist.append", "layout[].get", "figurewidget_resampler.FigureWidgetResampler.layout.update", "figurewidget_resampler.FigureWidgetResampler.layout[].pop", "updated_trace.pop", "figurewidget_resampler.FigureWidgetResampler.data[].update", "figurewidget_resampler.FigureWidgetResampler._prev_layout[].get", "len"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.construct_update_data"], ["", "", "", "", "def", "_update_spike_ranges", "(", "self", ",", "layout", ",", "*", "showspikes", ",", "force_update", "=", "False", ")", ":", "\n", "        ", "\"\"\"Update the go.Figure based on the changed spike-ranges.\n\n        Parameters\n        ----------\n        layout : go.Layout\n            The figure's (i.e, self) layout object. Remark that this is a reference,\n            so if we change self.layout (same object reference), this object will\n            change.\n        *showspikes: iterable\n            A iterable where each item is a bool, indicating  whether showspikes is set\n            to true/false for the corresponding xaxis in ``self._xaxis_list``.\n        force_update: bool\n            Bool indicating whether the range updates need to take place. This is\n            especially useful when you have recently updated the figure its data (with\n            the hf_data property) and want to perform an autoscale, independent from\n            the current figure-layout.\n        \"\"\"", "\n", "relayout_dict", "=", "{", "}", "# variable in which we aim to reconstruct the relayout", "\n", "# serialize the layout in a new dict object", "\n", "layout", "=", "{", "\n", "xaxis_str", ":", "layout", "[", "xaxis_str", "]", ".", "to_plotly_json", "(", ")", "\n", "for", "xaxis_str", "in", "self", ".", "_xaxis_list", "\n", "}", "\n", "\n", "if", "self", ".", "_prev_layout", "is", "None", ":", "\n", "            ", "self", ".", "_prev_layout", "=", "layout", "\n", "\n", "", "for", "xaxis_str", ",", "showspike", "in", "zip", "(", "self", ".", "_xaxis_list", ",", "showspikes", ")", ":", "\n", "            ", "if", "(", "\n", "force_update", "\n", "or", "\n", "# autorange key must be set to True", "\n", "(", "\n", "layout", "[", "xaxis_str", "]", ".", "get", "(", "\"autorange\"", ",", "False", ")", "\n", "# we only perform updates for traces which have 'range' property,", "\n", "# as we do need to reconstruct the update-data for these traces", "\n", "and", "self", ".", "_prev_layout", "[", "xaxis_str", "]", ".", "get", "(", "\"range\"", ",", "None", ")", "is", "not", "None", "\n", ")", "\n", ")", ":", "\n", "                ", "relayout_dict", "[", "f\"{xaxis_str}.autorange\"", "]", "=", "True", "\n", "relayout_dict", "[", "f\"{xaxis_str}.showspikes\"", "]", "=", "showspike", "\n", "# autorange -> we pop the xaxis range", "\n", "if", "\"range\"", "in", "layout", "[", "xaxis_str", "]", ":", "\n", "                    ", "del", "layout", "[", "xaxis_str", "]", "[", "\"range\"", "]", "\n", "\n", "", "", "", "if", "len", "(", "relayout_dict", ")", ":", "\n", "# An update will take place, save current layout to _prev_layout", "\n", "            ", "self", ".", "_prev_layout", "=", "layout", "\n", "\n", "# Construct the update data", "\n", "update_data", "=", "self", ".", "construct_update_data", "(", "relayout_dict", ")", "\n", "if", "self", ".", "_print_verbose", ":", "\n", "                ", "self", ".", "_relayout_hist", ".", "append", "(", "layout", ")", "\n", "self", ".", "_relayout_hist", ".", "append", "(", "[", "\"showspikes-update\"", ",", "len", "(", "update_data", ")", "-", "1", "]", ")", "\n", "self", ".", "_relayout_hist", ".", "append", "(", "\"-\"", "*", "30", ")", "\n", "\n", "", "with", "self", ".", "batch_update", "(", ")", ":", "\n", "# First update the layout (first item of update_data)", "\n", "                ", "if", "not", "force_update", ":", "\n", "                    ", "self", ".", "layout", ".", "update", "(", "update_data", "[", "0", "]", ")", "\n", "\n", "# Also:  Remove the showspikes from the layout, otherwise the autorange", "\n", "# will not work as intended (it will not be triggered again)", "\n", "# Note: this removal causes a second trigger of this method", "\n", "# which will go in the \"else\" part below.", "\n", "", "for", "xaxis_str", "in", "self", ".", "_xaxis_list", ":", "\n", "                    ", "self", ".", "layout", "[", "xaxis_str", "]", ".", "pop", "(", "\"showspikes\"", ")", "\n", "\n", "# Then, update the data", "\n", "", "for", "updated_trace", "in", "update_data", "[", "1", ":", "]", ":", "\n", "                    ", "trace_idx", "=", "updated_trace", ".", "pop", "(", "\"index\"", ")", "\n", "self", ".", "data", "[", "trace_idx", "]", ".", "update", "(", "updated_trace", ")", "\n", "", "", "", "elif", "self", ".", "_print_verbose", ":", "\n", "            ", "self", ".", "_relayout_hist", ".", "append", "(", "[", "\"showspikes\"", ",", "\"initial call or showspikes\"", "]", ")", "\n", "self", ".", "_relayout_hist", ".", "append", "(", "\"-\"", "*", "40", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reset_axes": [[249, 263], ["figurewidget_resampler.FigureWidgetResampler._update_spike_ranges", "figurewidget_resampler.FigureWidgetResampler.update_layout", "len"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_spike_ranges"], ["", "", "def", "reset_axes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Reset the axes of the FigureWidgetResampler.\n\n        This is useful when adjusting the `hf_data` properties of the\n        ``FigureWidgetResampler``.\n        \"\"\"", "\n", "self", ".", "_update_spike_ranges", "(", "\n", "self", ".", "layout", ",", "*", "[", "False", "]", "*", "len", "(", "self", ".", "_xaxis_list", ")", ",", "force_update", "=", "True", "\n", ")", "\n", "# Reset the layout", "\n", "self", ".", "update_layout", "(", "\n", "{", "\n", "axis", ":", "{", "\"autorange\"", ":", "True", ",", "\"range\"", ":", "None", "}", "\n", "for", "axis", "in", "self", ".", "_xaxis_list", "+", "self", ".", "_yaxis_list", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data": [[266, 290], ["all", "figurewidget_resampler.FigureWidgetResampler._update_spike_ranges", "figurewidget_resampler.FigureWidgetResampler._update_x_ranges", "len"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_spike_ranges", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_x_ranges"], ["", "def", "reload_data", "(", "self", ")", ":", "\n", "        ", "\"\"\"Reload all the data of FigureWidgetResampler for the current range-view.\n\n        This is useful when adjusting the `hf_data` properties of the\n        ``FigureWidgetResampler``.\n        \"\"\"", "\n", "if", "all", "(", "\n", "self", ".", "layout", "[", "xaxis", "]", ".", "autorange", "\n", "or", "(", "\n", "self", ".", "layout", "[", "xaxis", "]", ".", "autorange", "is", "None", "\n", "and", "self", ".", "layout", "[", "xaxis", "]", ".", "range", "is", "None", "\n", ")", "\n", "for", "xaxis", "in", "self", ".", "_xaxis_list", "\n", ")", ":", "\n", "            ", "self", ".", "_update_spike_ranges", "(", "\n", "self", ".", "layout", ",", "*", "[", "False", "]", "*", "len", "(", "self", ".", "_xaxis_list", ")", ",", "force_update", "=", "True", "\n", ")", "\n", "", "else", ":", "\n", "# Resample the data for the current range-view", "\n", "            ", "self", ".", "_update_x_ranges", "(", "\n", "self", ".", "layout", ",", "\n", "# Pass the current view to trigger a resample operation", "\n", "*", "[", "self", ".", "layout", "[", "xaxis_str", "]", "[", "\"range\"", "]", "for", "xaxis_str", "in", "self", ".", "_xaxis_list", "]", ",", "\n", "force_update", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.__init__": [[40, 143], ["aggregation.EfficientLTTB", "isinstance", "figure_resampler_interface.AbstractFigureAggregator._re_matches", "figure_resampler_interface.AbstractFigureAggregator._re_matches", "figure_resampler_interface.AbstractFigureAggregator.update_layout", "len", "issubclass", "figure_resampler_interface.AbstractFigureAggregator._figure_class", "plotly.basedatatypes.BaseFigure.__init__", "figure_resampler_interface.AbstractFigureAggregator.add_traces", "plotly.basedatatypes.BaseFigure.__init__", "re.compile", "figure_resampler_interface.AbstractFigureAggregator._layout.keys", "re.compile", "figure_resampler_interface.AbstractFigureAggregator._layout.keys", "len", "type"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "figure", ":", "BaseFigure", ",", "\n", "convert_existing_traces", ":", "bool", "=", "True", ",", "\n", "default_n_shown_samples", ":", "int", "=", "1000", ",", "\n", "default_downsampler", ":", "AbstractSeriesAggregator", "=", "EfficientLTTB", "(", ")", ",", "\n", "resampled_trace_prefix_suffix", ":", "Tuple", "[", "str", ",", "str", "]", "=", "(", "\n", "'<b style=\"color:sandybrown\">[R]</b> '", ",", "\n", "\"\"", ",", "\n", ")", ",", "\n", "show_mean_aggregation_size", ":", "bool", "=", "True", ",", "\n", "convert_traces_kwargs", ":", "dict", "|", "None", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Instantiate a resampling data mirror.\n\n        Parameters\n        ----------\n        figure: BaseFigure\n            The figure that will be decorated. Can be either an empty figure\n            (e.g., ``go.Figure()``, ``make_subplots()``, ``go.FigureWidget``) or an\n            existing figure.\n        convert_existing_traces: bool\n            A bool indicating whether the high-frequency traces of the passed ``figure``\n            should be resampled, by default True. Hence, when set to False, the\n            high-frequency traces of the passed ``figure`` will not be resampled.\n        default_n_shown_samples: int, optional\n            The default number of samples that will be shown for each trace,\n            by default 1000.\\n\n            .. note::\n                * This can be overridden within the :func:`add_trace` method.\n                * If a trace withholds fewer datapoints than this parameter,\n                  the data will *not* be aggregated.\n        default_downsampler: AbstractSeriesDownsampler\n            An instance which implements the AbstractSeriesDownsampler interface and\n            will be used as default downsampler, by default ``EfficientLTTB`` with\n            _interleave_gaps_ set to True. \\n\n            .. note:: This can be overridden within the :func:`add_trace` method.\n        resampled_trace_prefix_suffix: str, optional\n            A tuple which contains the ``prefix`` and ``suffix``, respectively, which\n            will be added to the trace its legend-name when a resampled version of the\n            trace is shown. By default a bold, orange ``[R]`` is shown as prefix\n            (no suffix is shown).\n        show_mean_aggregation_size: bool, optional\n            Whether the mean aggregation bin size will be added as a suffix to the trace\n            its legend-name, by default True.\n        convert_traces_kwargs: dict, optional\n            A dict of kwargs that will be passed to the :func:`add_traces` method and\n            will be used to convert the existing traces. \\n\n            .. note::\n                This argument is only used when the passed ``figure`` contains data and\n                ``convert_existing_traces`` is set to True.\n        verbose: bool, optional\n            Whether some verbose messages will be printed or not, by default False.\n\n        \"\"\"", "\n", "self", ".", "_hf_data", ":", "Dict", "[", "str", ",", "dict", "]", "=", "{", "}", "\n", "self", ".", "_global_n_shown_samples", "=", "default_n_shown_samples", "\n", "self", ".", "_print_verbose", "=", "verbose", "\n", "self", ".", "_show_mean_aggregation_size", "=", "show_mean_aggregation_size", "\n", "\n", "assert", "len", "(", "resampled_trace_prefix_suffix", ")", "==", "2", "\n", "self", ".", "_prefix", ",", "self", ".", "_suffix", "=", "resampled_trace_prefix_suffix", "\n", "\n", "self", ".", "_global_downsampler", "=", "default_downsampler", "\n", "\n", "# Given figure should always be a BaseFigure that is not wrapped by", "\n", "# a plotly-resampler class", "\n", "assert", "isinstance", "(", "figure", ",", "BaseFigure", ")", "\n", "assert", "not", "issubclass", "(", "type", "(", "figure", ")", ",", "AbstractFigureAggregator", ")", "\n", "self", ".", "_figure_class", "=", "figure", ".", "__class__", "\n", "\n", "if", "convert_existing_traces", ":", "\n", "# call __init__ with the correct layout and set the `_grid_ref` of the", "\n", "# to-be-converted figure", "\n", "            ", "f_", "=", "self", ".", "_figure_class", "(", "layout", "=", "figure", ".", "layout", ")", "\n", "f_", ".", "_grid_ref", "=", "figure", ".", "_grid_ref", "\n", "super", "(", ")", ".", "__init__", "(", "f_", ")", "\n", "\n", "if", "convert_traces_kwargs", "is", "None", ":", "\n", "                ", "convert_traces_kwargs", "=", "{", "}", "\n", "\n", "# make sure that the UIDs of these traces do not get adjusted", "\n", "", "self", ".", "_data_validator", ".", "set_uid", "=", "False", "\n", "self", ".", "add_traces", "(", "figure", ".", "data", ",", "**", "convert_traces_kwargs", ")", "\n", "", "else", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "figure", ")", "\n", "self", ".", "_data_validator", ".", "set_uid", "=", "False", "\n", "\n", "# A list of al xaxis and yaxis string names", "\n", "# e.g., \"xaxis\", \"xaxis2\", \"xaxis3\", .... for _xaxis_list", "\n", "", "self", ".", "_xaxis_list", "=", "self", ".", "_re_matches", "(", "re", ".", "compile", "(", "\"xaxis\\d*\"", ")", ",", "self", ".", "_layout", ".", "keys", "(", ")", ")", "\n", "self", ".", "_yaxis_list", "=", "self", ".", "_re_matches", "(", "re", ".", "compile", "(", "\"yaxis\\d*\"", ")", ",", "self", ".", "_layout", ".", "keys", "(", ")", ")", "\n", "# edge case: an empty `go.Figure()` does not yet contain axes keys", "\n", "if", "not", "len", "(", "self", ".", "_xaxis_list", ")", ":", "\n", "            ", "self", ".", "_xaxis_list", "=", "[", "\"xaxis\"", "]", "\n", "self", ".", "_yaxis_list", "=", "[", "\"yaxis\"", "]", "\n", "\n", "# Make sure to reset the layout its range", "\n", "", "self", ".", "update_layout", "(", "\n", "{", "\n", "axis", ":", "{", "\"autorange\"", ":", "True", ",", "\"range\"", ":", "None", "}", "\n", "for", "axis", "in", "self", ".", "_xaxis_list", "+", "self", ".", "_yaxis_list", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._print": [[146, 150], ["print"], "methods", ["None"], ["", "def", "_print", "(", "self", ",", "*", "values", ")", ":", "\n", "        ", "\"\"\"Helper method for printing if ``verbose`` is set to True.\"\"\"", "\n", "if", "self", ".", "_print_verbose", ":", "\n", "            ", "print", "(", "*", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._query_hf_data": [[151, 174], ["figure_resampler_interface.AbstractFigureAggregator._hf_data.get", "figure_resampler_interface.AbstractFigureAggregator._print", "set().difference", "set", "trace.keys"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._print"], ["", "", "def", "_query_hf_data", "(", "self", ",", "trace", ":", "dict", ")", "->", "Optional", "[", "dict", "]", ":", "\n", "        ", "\"\"\"Query the internal ``_hf_data`` attribute and returns a match based on\n        ``uid``.\n\n        Parameters\n        ----------\n        trace : dict\n            The trace where we want to find a match for.\n\n        Returns\n        -------\n        Optional[dict]\n            The ``hf_data``-trace dict if a match is found, else ``None``.\n\n        \"\"\"", "\n", "uid", "=", "trace", "[", "\"uid\"", "]", "\n", "hf_trace_data", "=", "self", ".", "_hf_data", ".", "get", "(", "uid", ")", "\n", "if", "hf_trace_data", "is", "None", ":", "\n", "            ", "trace_props", "=", "{", "\n", "k", ":", "trace", "[", "k", "]", "for", "k", "in", "set", "(", "trace", ".", "keys", "(", ")", ")", ".", "difference", "(", "{", "\"x\"", ",", "\"y\"", "}", ")", "\n", "}", "\n", "self", ".", "_print", "(", "f\"[W] trace with {trace_props} not found\"", ")", "\n", "", "return", "hf_trace_data", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._get_current_graph": [[175, 197], ["copy.copy.copy", "copy.copy.copy", "set().difference", "set", "trace.keys"], "methods", ["None"], ["", "def", "_get_current_graph", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Create an efficient copy of the current graph by omitting the \"hovertext\",\n        \"x\", and \"y\" properties of each trace.\n\n        Returns\n        -------\n        dict\n            The current graph dict\n\n        See Also\n        --------\n        https://github.com/plotly/plotly.py/blob/2e7f322c5ea4096ce6efe3b4b9a34d9647a8be9c/packages/python/plotly/plotly/basedatatypes.py#L3278\n        \"\"\"", "\n", "return", "{", "\n", "\"data\"", ":", "[", "\n", "{", "\n", "k", ":", "copy", "(", "trace", "[", "k", "]", ")", "\n", "for", "k", "in", "set", "(", "trace", ".", "keys", "(", ")", ")", ".", "difference", "(", "{", "\"x\"", ",", "\"y\"", ",", "\"hovertext\"", "}", ")", "\n", "}", "\n", "for", "trace", "in", "self", ".", "_data", "\n", "]", ",", "\n", "\"layout\"", ":", "copy", "(", "self", ".", "_layout", ")", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_trace_data": [[199, 332], ["figure_resampler_interface.AbstractFigureAggregator._query_hf_data", "downsampler.aggregate", "figure_resampler_interface.AbstractFigureAggregator.get", "isinstance", "figure_resampler_interface.AbstractFigureAggregator.get", "isinstance", "figure_resampler_interface.AbstractFigureAggregator._print", "figure_resampler_interface.AbstractFigureAggregator._slice_time", "figure_resampler_interface.AbstractFigureAggregator._to_hf_series", "len", "trace[].split", "len", "pandas.to_datetime", "pandas.to_datetime", "figure_resampler_interface.AbstractFigureAggregator._to_hf_series", "len", "figure_resampler_interface.AbstractFigureAggregator.index.is_integer", "numpy.searchsorted", "numpy.mean", "isinstance", "len", "name.startswith", "len", "trace[].endswith", "round", "round", "name.startswith", "name.endswith", "numpy.diff", "utils.round_td_str", "utils.round_number_str", "figure_resampler_interface.AbstractFigureAggregator._to_hf_series", "figure_resampler_interface.AbstractFigureAggregator._to_hf_series", "pandas.Timedelta", "len", "len"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._query_hf_data", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._print", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._to_hf_series", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._to_hf_series", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._to_hf_series", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._to_hf_series"], ["", "def", "_check_update_trace_data", "(", "\n", "self", ",", "\n", "trace", ":", "dict", ",", "\n", "start", "=", "None", ",", "\n", "end", "=", "None", ",", "\n", ")", "->", "Optional", "[", "Union", "[", "dict", ",", "BaseTraceType", "]", "]", ":", "\n", "        ", "\"\"\"Check and update the passed ``trace`` its data properties based on the\n        slice range.\n\n        Note\n        ----\n        This is a pass by reference. The passed trace object will be updated and\n        returned if found in ``hf_data``.\n\n        Parameters\n        ----------\n        trace : BaseTraceType or dict\n             - An instances of a trace class from the ``plotly.graph_objects`` (go)\n                package (e.g, ``go.Scatter``, ``go.Bar``)\n             - or a dict where:\n\n                  - The 'type' property specifies the trace type (e.g.\n                    'scatter', 'bar', 'area', etc.). If the dict has no 'type'\n                    property then 'scatter' is assumed.\n                  - All remaining properties are passed to the constructor\n                    of the specified trace type.\n\n        start : Union[float, str], optional\n            The start index for which we want resampled data to be updated to,\n            by default None,\n        end : Union[float, str], optional\n            The end index for which we want the resampled data to be updated to,\n            by default None\n\n        Returns\n        -------\n        Optional[Union[dict, BaseTraceType]]\n            If the matching ``hf_series`` is found in ``hf_dict``, an (updated) trace\n            will be returned, otherwise None.\n\n        Note\n        ----\n        * If ``start`` and ``stop`` are strings, they most likely represent time-strings\n        * ``start`` and ``stop`` will always be of the same type (float / time-string)\n           because their underlying axis is the same.\n\n        \"\"\"", "\n", "hf_trace_data", "=", "self", ".", "_query_hf_data", "(", "trace", ")", "\n", "if", "hf_trace_data", "is", "not", "None", ":", "\n", "            ", "axis_type", "=", "hf_trace_data", "[", "\"axis_type\"", "]", "\n", "if", "axis_type", "==", "\"date\"", ":", "\n", "                ", "start", ",", "end", "=", "pd", ".", "to_datetime", "(", "start", ")", ",", "pd", ".", "to_datetime", "(", "end", ")", "\n", "hf_series", "=", "self", ".", "_slice_time", "(", "\n", "self", ".", "_to_hf_series", "(", "hf_trace_data", "[", "\"x\"", "]", ",", "hf_trace_data", "[", "\"y\"", "]", ")", ",", "\n", "start", ",", "\n", "end", ",", "\n", ")", "\n", "", "else", ":", "\n", "                ", "hf_series", "=", "self", ".", "_to_hf_series", "(", "hf_trace_data", "[", "\"x\"", "]", ",", "hf_trace_data", "[", "\"y\"", "]", ")", "\n", "if", "len", "(", "hf_series", ")", "and", "(", "start", "is", "not", "None", "or", "end", "is", "not", "None", ")", ":", "\n", "                    ", "start", "=", "hf_series", ".", "index", "[", "0", "]", "if", "start", "is", "None", "else", "start", "\n", "end", "=", "hf_series", ".", "index", "[", "-", "1", "]", "if", "end", "is", "None", "else", "end", "\n", "if", "hf_series", ".", "index", ".", "is_integer", "(", ")", ":", "\n", "                        ", "start", "=", "round", "(", "start", ")", "\n", "end", "=", "round", "(", "end", ")", "\n", "\n", "# Search the index-positions", "\n", "", "start_idx", ",", "end_idx", "=", "np", ".", "searchsorted", "(", "hf_series", ".", "index", ",", "[", "start", ",", "end", "]", ")", "\n", "hf_series", "=", "hf_series", ".", "iloc", "[", "start_idx", ":", "end_idx", "]", "\n", "\n", "# Return an invisible, single-point, trace when the sliced hf_series doesn't", "\n", "# contain any data in the current view", "\n", "", "", "if", "len", "(", "hf_series", ")", "==", "0", ":", "\n", "                ", "trace", "[", "\"x\"", "]", "=", "[", "start", "]", "\n", "trace", "[", "\"y\"", "]", "=", "[", "None", "]", "\n", "trace", "[", "\"text\"", "]", "=", "\"\"", "\n", "trace", "[", "\"hovertext\"", "]", "=", "\"\"", "\n", "return", "trace", "\n", "\n", "# Downsample the data and store it in the trace-fields", "\n", "", "downsampler", ":", "AbstractSeriesAggregator", "=", "hf_trace_data", "[", "\"downsampler\"", "]", "\n", "s_res", ":", "pd", ".", "Series", "=", "downsampler", ".", "aggregate", "(", "\n", "hf_series", ",", "hf_trace_data", "[", "\"max_n_samples\"", "]", "\n", ")", "\n", "trace", "[", "\"x\"", "]", "=", "s_res", ".", "index", "\n", "trace", "[", "\"y\"", "]", "=", "s_res", ".", "values", "\n", "# todo -> first draft & not MP safe", "\n", "\n", "agg_prefix", ",", "agg_suffix", "=", "' <i style=\"color:#fc9944\">~'", ",", "\"</i>\"", "\n", "name", ":", "str", "=", "trace", "[", "\"name\"", "]", ".", "split", "(", "agg_prefix", ")", "[", "0", "]", "\n", "\n", "if", "len", "(", "hf_series", ")", ">", "hf_trace_data", "[", "\"max_n_samples\"", "]", ":", "\n", "                ", "name", "=", "(", "\"\"", "if", "name", ".", "startswith", "(", "self", ".", "_prefix", ")", "else", "self", ".", "_prefix", ")", "+", "name", "\n", "name", "+=", "self", ".", "_suffix", "if", "not", "name", ".", "endswith", "(", "self", ".", "_suffix", ")", "else", "\"\"", "\n", "# Add the mean aggregation bin size to the trace name", "\n", "if", "self", ".", "_show_mean_aggregation_size", ":", "\n", "                    ", "agg_mean", "=", "np", ".", "mean", "(", "np", ".", "diff", "(", "s_res", ".", "index", ".", "values", ")", ")", "\n", "if", "isinstance", "(", "agg_mean", ",", "np", ".", "timedelta64", ")", ":", "\n", "                        ", "agg_mean", "=", "round_td_str", "(", "pd", ".", "Timedelta", "(", "agg_mean", ")", ")", "\n", "", "else", ":", "\n", "                        ", "agg_mean", "=", "round_number_str", "(", "agg_mean", ")", "\n", "", "name", "+=", "f\"{agg_prefix}{agg_mean}{agg_suffix}\"", "\n", "", "", "else", ":", "\n", "# When not resampled: trim prefix and/or suffix if necessary", "\n", "                ", "if", "len", "(", "self", ".", "_prefix", ")", "and", "name", ".", "startswith", "(", "self", ".", "_prefix", ")", ":", "\n", "                    ", "name", "=", "name", "[", "len", "(", "self", ".", "_prefix", ")", ":", "]", "\n", "", "if", "len", "(", "self", ".", "_suffix", ")", "and", "trace", "[", "\"name\"", "]", ".", "endswith", "(", "self", ".", "_suffix", ")", ":", "\n", "                    ", "name", "=", "name", "[", ":", "-", "len", "(", "self", ".", "_suffix", ")", "]", "\n", "", "", "trace", "[", "\"name\"", "]", "=", "name", "\n", "\n", "# Check if text also needs to be resampled", "\n", "text", "=", "hf_trace_data", ".", "get", "(", "\"text\"", ")", "\n", "if", "isinstance", "(", "text", ",", "(", "np", ".", "ndarray", ",", "pd", ".", "Series", ")", ")", ":", "\n", "# TODO -> extra logic is necessary for the detection and processing of", "\n", "# non data-point selection downsamplers", "\n", "                ", "trace", "[", "\"text\"", "]", "=", "self", ".", "_to_hf_series", "(", "x", "=", "hf_trace_data", "[", "\"x\"", "]", ",", "y", "=", "text", ")", ".", "loc", "[", "\n", "s_res", ".", "index", "\n", "]", "\n", "", "else", ":", "\n", "                ", "trace", "[", "\"text\"", "]", "=", "text", "\n", "\n", "# Check if hovertext also needs to be resampled", "\n", "", "hovertext", "=", "hf_trace_data", ".", "get", "(", "\"hovertext\"", ")", "\n", "if", "isinstance", "(", "hovertext", ",", "(", "np", ".", "ndarray", ",", "pd", ".", "Series", ")", ")", ":", "\n", "                ", "trace", "[", "\"hovertext\"", "]", "=", "self", ".", "_to_hf_series", "(", "\n", "x", "=", "hf_trace_data", "[", "\"x\"", "]", ",", "y", "=", "hovertext", "\n", ")", ".", "loc", "[", "s_res", ".", "index", "]", "\n", "", "else", ":", "\n", "                ", "trace", "[", "\"hovertext\"", "]", "=", "hovertext", "\n", "", "return", "trace", "\n", "", "else", ":", "\n", "            ", "self", ".", "_print", "(", "\"hf_data not found\"", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict": [[333, 438], ["enumerate", "figure_resampler_interface.AbstractFigureAggregator._check_update_trace_data", "xaxis_filter.lstrip", "figure[].get().get", "updated_trace_indices.append", "trace.get", "figure[].get().get", "figure[].get().get", "figure[].get", "trace.get", "figure[].get", "figure[].get", "figure[].get().get.lstrip"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_trace_data"], ["", "", "def", "_check_update_figure_dict", "(", "\n", "self", ",", "\n", "figure", ":", "dict", ",", "\n", "start", ":", "Optional", "[", "Union", "[", "float", ",", "str", "]", "]", "=", "None", ",", "\n", "stop", ":", "Optional", "[", "Union", "[", "float", ",", "str", "]", "]", "=", "None", ",", "\n", "xaxis_filter", ":", "str", "=", "None", ",", "\n", "updated_trace_indices", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "List", "[", "int", "]", ":", "\n", "        ", "\"\"\"Check and update the traces within the figure dict.\n\n        hint\n        ----\n        This method will most likely be used within a ``Dash`` callback to resample the\n        view, based on the configured number of parameters.\n\n        Note\n        ----\n        This is a pass by reference. The passed figure object will be updated.\n        No new view of this figure will be created, hence no return!\n\n        Parameters\n        ----------\n        figure : dict\n            The figure dict which will be updated.\n        start : Union[float, str], optional\n            The start time for the new resampled data view, by default None.\n        stop : Union[float, str], optional\n            The end time for the new resampled data view, by default None.\n        xaxis_filter: str, optional\n            Additional trace-update subplot filter, by default None.\n        updated_trace_indices: List[int], optional\n            List of trace indices that already have been updated, by default None.\n\n        Returns\n        -------\n        List[int]\n            A list of indices withholding the trace-data-array-index from the of data\n            modalities which are updated.\n\n        \"\"\"", "\n", "xaxis_filter_short", "=", "None", "\n", "if", "xaxis_filter", "is", "not", "None", ":", "\n", "            ", "xaxis_filter_short", "=", "\"x\"", "+", "xaxis_filter", ".", "lstrip", "(", "\"xaxis\"", ")", "\n", "\n", "", "if", "updated_trace_indices", "is", "None", ":", "\n", "            ", "updated_trace_indices", "=", "[", "]", "\n", "\n", "", "for", "idx", ",", "trace", "in", "enumerate", "(", "figure", "[", "\"data\"", "]", ")", ":", "\n", "# We skip when the trace-idx already has been updated.", "\n", "            ", "if", "idx", "in", "updated_trace_indices", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "xaxis_filter", "is", "not", "None", ":", "\n", "# the x-anchor of the trace is stored in the layout data", "\n", "                ", "if", "trace", ".", "get", "(", "\"yaxis\"", ")", "is", "None", ":", "\n", "# no yaxis -> we make the assumption that yaxis = xaxis_filter_short", "\n", "                    ", "y_axis", "=", "\"y\"", "+", "xaxis_filter", "[", "1", ":", "]", "\n", "", "else", ":", "\n", "                    ", "y_axis", "=", "\"yaxis\"", "+", "trace", ".", "get", "(", "\"yaxis\"", ")", "[", "1", ":", "]", "\n", "\n", "# Next to the x-anchor, we also fetch the xaxis which matches the", "\n", "# current trace (i.e. if this value is not None, the axis shares the", "\n", "# x-axis with one or more traces).", "\n", "# This is relevant when e.g. fig.update_traces(xaxis='x...') was called.", "\n", "", "x_anchor_trace", "=", "figure", "[", "\"layout\"", "]", ".", "get", "(", "y_axis", ",", "{", "}", ")", ".", "get", "(", "\"anchor\"", ")", "\n", "if", "x_anchor_trace", "is", "not", "None", ":", "\n", "                    ", "xaxis_matches", "=", "(", "\n", "figure", "[", "\"layout\"", "]", "\n", ".", "get", "(", "\"xaxis\"", "+", "x_anchor_trace", ".", "lstrip", "(", "\"x\"", ")", ",", "{", "}", ")", "\n", ".", "get", "(", "\"matches\"", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "xaxis_matches", "=", "figure", "[", "\"layout\"", "]", ".", "get", "(", "\"xaxis\"", ",", "{", "}", ")", ".", "get", "(", "\"matches\"", ")", "\n", "\n", "# print(", "\n", "#     f\"x_anchor: {x_anchor_trace} - xaxis_filter: {xaxis_filter} \",", "\n", "#     f\"- xaxis_matches: {xaxis_matches}\"", "\n", "# )", "\n", "\n", "# We skip when:", "\n", "# * the change was made on the first row and the trace its anchor is not", "\n", "#   in [None, 'x'] and the matching (a.k.a. shared) xaxis is not equal", "\n", "#   to the xaxis filter argument.", "\n", "#   -> why None: traces without row/col argument and stand on first row", "\n", "#      and do not have the anchor property (hence the DICT.get() method)", "\n", "# * x_axis_filter_short not in [x_anchor or xaxis matches] for", "\n", "#   NON first rows", "\n", "", "if", "(", "\n", "xaxis_filter_short", "==", "\"x\"", "\n", "and", "(", "\n", "x_anchor_trace", "not", "in", "[", "None", ",", "\"x\"", "]", "\n", "and", "xaxis_matches", "!=", "xaxis_filter_short", "\n", ")", "\n", ")", "or", "(", "\n", "xaxis_filter_short", "!=", "\"x\"", "\n", "and", "(", "xaxis_filter_short", "not", "in", "[", "x_anchor_trace", ",", "xaxis_matches", "]", ")", "\n", ")", ":", "\n", "                    ", "continue", "\n", "\n", "# If we managed to find and update the trace, it will return the trace", "\n", "# and thus not None.", "\n", "", "", "updated_trace", "=", "self", ".", "_check_update_trace_data", "(", "trace", ",", "start", "=", "start", ",", "end", "=", "stop", ")", "\n", "if", "updated_trace", "is", "not", "None", ":", "\n", "                ", "updated_trace_indices", ".", "append", "(", "idx", ")", "\n", "", "", "return", "updated_trace_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._get_figure_class": [[439, 462], ["_get_plotly_constr"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr"], ["", "@", "staticmethod", "\n", "def", "_get_figure_class", "(", "constr", ":", "type", ")", "->", "type", ":", "\n", "        ", "\"\"\"Get the plotly figure class (constructor) for the given class (constructor).\n\n        .. Note::\n            This method will always return a plotly constructor, even when the given\n            `constr` is decorated (after executing the ``register_plotly_resampler``\n            function).\n\n        Parameters\n        ----------\n        constr: type\n            The constructor class for which we want to retrieve the plotly constructor.\n\n        Returns\n        -------\n        type:\n            The plotly figure class (constructor) of the given `constr`.\n\n        \"\"\"", "\n", "from", ".", ".", "registering", "import", "_get_plotly_constr", "# To avoid ImportError", "\n", "\n", "return", "_get_plotly_constr", "(", "constr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time": [[463, 513], ["figure_resampler_interface.AbstractFigureAggregator._slice_time.to_same_tz"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_slice_time", "(", "\n", "hf_series", ":", "pd", ".", "Series", ",", "\n", "t_start", ":", "Optional", "[", "pd", ".", "Timestamp", "]", "=", "None", ",", "\n", "t_stop", ":", "Optional", "[", "pd", ".", "Timestamp", "]", "=", "None", ",", "\n", ")", "->", "pd", ".", "Series", ":", "\n", "        ", "\"\"\"Slice the time-indexed ``hf_series`` for the passed pd.Timestamps.\n\n        Note\n        ----\n        This returns a **view** of ``hf_series``!\n\n        Parameters\n        ----------\n        hf_series: pd.Series\n            The **datetime-indexed** series, which will be sliced.\n        t_start: pd.Timestamp, optional\n            The lower-time-bound of the slice, if set to None, no lower-bound threshold\n            will be applied, by default None.\n        t_stop:  pd.Timestamp, optional\n            The upper time-bound of the slice, if set to None, no upper-bound threshold\n            will be applied, by default None.\n\n        Returns\n        -------\n        pd.Series\n            The sliced **view** of the series.\n\n        \"\"\"", "\n", "\n", "def", "to_same_tz", "(", "\n", "ts", ":", "Union", "[", "pd", ".", "Timestamp", ",", "None", "]", ",", "reference_tz", "=", "hf_series", ".", "index", ".", "tz", "\n", ")", "->", "Union", "[", "pd", ".", "Timestamp", ",", "None", "]", ":", "\n", "            ", "\"\"\"Adjust `ts` its timezone to the `reference_tz`.\"\"\"", "\n", "if", "ts", "is", "None", ":", "\n", "                ", "return", "None", "\n", "", "elif", "reference_tz", "is", "not", "None", ":", "\n", "                ", "if", "ts", ".", "tz", "is", "not", "None", ":", "\n", "                    ", "assert", "ts", ".", "tz", ".", "zone", "==", "reference_tz", ".", "zone", "\n", "return", "ts", "\n", "", "else", ":", "# localize -> time remains the same", "\n", "                    ", "return", "ts", ".", "tz_localize", "(", "reference_tz", ")", "\n", "", "", "elif", "reference_tz", "is", "None", "and", "ts", ".", "tz", "is", "not", "None", ":", "\n", "                ", "return", "ts", ".", "tz_localize", "(", "None", ")", "\n", "", "return", "ts", "\n", "\n", "", "if", "t_start", "is", "not", "None", "and", "t_stop", "is", "not", "None", ":", "\n", "            ", "assert", "t_start", ".", "tz", "==", "t_stop", ".", "tz", "\n", "\n", "", "return", "hf_series", "[", "to_same_tz", "(", "t_start", ")", ":", "to_same_tz", "(", "t_stop", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.hf_data": [[514, 540], ["list", "figure_resampler_interface.AbstractFigureAggregator._hf_data.values"], "methods", ["None"], ["", "@", "property", "\n", "def", "hf_data", "(", "self", ")", ":", "\n", "        ", "\"\"\"Property to adjust the `data` component of the current graph\n\n        .. note::\n            The user has full responsibility to adjust ``hf_data`` properly.\n\n\n        Example:\n            >>> fig = FigureResampler(go.Figure())\n            >>> fig.add_trace(...)\n            >>> fig.hf_data[-1][\"y\"] = - s ** 2  # adjust the y-property of the trace added above\n            >>> fig.hf_data\n            [\n                {\n                    'max_n_samples': 1000,\n                    'x': RangeIndex(start=0, stop=11000000, step=1),\n                    'y': array([-0.01339909,  0.01390696,, ...,  0.25051913, 0.55876513]),\n                    'axis_type': 'linear',\n                    'downsampler': <plotly_resampler.aggregation.aggregators.LTTB at 0x7f786d5a9ca0>,\n                    'text': None,\n                    'hovertext': None\n                },\n            ]\n        \"\"\"", "\n", "return", "list", "(", "self", ".", "_hf_data", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._to_hf_series": [[541, 575], ["isinstance", "isinstance", "pandas.Series"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_to_hf_series", "(", "x", ":", "np", ".", "ndarray", ",", "y", ":", "np", ".", "ndarray", ")", "->", "pd", ".", "Series", ":", "\n", "        ", "\"\"\"Construct the hf-series.\n\n        By constructing the hf-series this way, users can dynamically adjust the hf\n        series argument.\n\n        Parameters\n        ----------\n        x : np.ndarray\n            The hf_series index\n        y : np.ndarray\n            The hf_series values\n\n        Returns\n        -------\n        pd.Series\n            The constructed hf_series\n        \"\"\"", "\n", "# Note this is the same behavior as plotly support", "\n", "# i.e. it also used the `values` property of the `x` and `y` parameters when", "\n", "# these are pd.Series", "\n", "if", "isinstance", "(", "x", ",", "pd", ".", "Series", ")", ":", "\n", "            ", "x", "=", "x", ".", "values", "\n", "\n", "", "if", "isinstance", "(", "y", ",", "pd", ".", "Series", ")", ":", "\n", "            ", "y", "=", "y", ".", "values", "\n", "\n", "", "return", "pd", ".", "Series", "(", "\n", "data", "=", "y", ",", "\n", "index", "=", "x", ",", "\n", "copy", "=", "False", ",", "\n", "name", "=", "\"data\"", ",", "\n", "dtype", "=", "\"category\"", "if", "y", ".", "dtype", ".", "type", "==", "np", ".", "str_", "else", "y", ".", "dtype", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._parse_get_trace_props": [[577, 714], ["numpy.asarray", "_hf_data_container", "trace[].lower", "isinstance", "isinstance", "pandas.isna().any", "figure_resampler_interface.AbstractFigureAggregator._print", "hasattr", "hasattr", "hasattr", "hasattr", "hasattr", "isinstance", "hasattr", "isinstance", "numpy.ndim", "numpy.asarray", "numpy.asarray", "isinstance", "isinstance", "str", "hf_y.astype.astype.astype", "len", "len", "isinstance", "numpy.asarray", "hasattr", "hasattr", "pandas.RangeIndex", "numpy.asarray", "numpy.ndim", "pandas.isna", "pandas.isna", "pandas.to_numeric", "len", "hf_y.astype.astype.astype"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._print"], ["", "def", "_parse_get_trace_props", "(", "\n", "self", ",", "\n", "trace", ":", "BaseTraceType", ",", "\n", "hf_x", ":", "Iterable", "=", "None", ",", "\n", "hf_y", ":", "Iterable", "=", "None", ",", "\n", "hf_text", ":", "Iterable", "=", "None", ",", "\n", "hf_hovertext", ":", "Iterable", "=", "None", ",", "\n", ")", "->", "_hf_data_container", ":", "\n", "        ", "\"\"\"Parse and capture the possibly high-frequency trace-props in a datacontainer.\n\n        Parameters\n        ----------\n        trace : BaseTraceType\n            The trace which will be parsed.\n        hf_x : Iterable, optional\n            high-frequency trace \"x\" data, overrides the current trace its x-data.\n        hf_y : Iterable, optional\n            high-frequency trace \"y\" data, overrides the current trace its y-data.\n        hf_text : Iterable, optional\n            high-frequency trace \"text\" data, overrides the current trace its text-data.\n        hf_hovertext : Iterable, optional\n            high-frequency trace \"hovertext\" data, overrides the current trace its\n            hovertext data.\n\n        Returns\n        -------\n        _hf_data_container\n            A namedtuple which serves as a datacontainer.\n\n        \"\"\"", "\n", "hf_x", "=", "(", "\n", "trace", "[", "\"x\"", "]", "\n", "if", "hasattr", "(", "trace", ",", "\"x\"", ")", "and", "hf_x", "is", "None", "\n", "else", "hf_x", ".", "values", "\n", "if", "isinstance", "(", "hf_x", ",", "pd", ".", "Series", ")", "\n", "else", "hf_x", "\n", "if", "isinstance", "(", "hf_x", ",", "pd", ".", "Index", ")", "\n", "else", "np", ".", "asarray", "(", "hf_x", ")", "\n", ")", "\n", "\n", "hf_y", "=", "(", "\n", "trace", "[", "\"y\"", "]", "\n", "if", "hasattr", "(", "trace", ",", "\"y\"", ")", "and", "hf_y", "is", "None", "\n", "else", "hf_y", ".", "values", "\n", "if", "isinstance", "(", "hf_y", ",", "(", "pd", ".", "Series", ",", "pd", ".", "Index", ")", ")", "\n", "else", "hf_y", "\n", ")", "\n", "hf_y", "=", "np", ".", "asarray", "(", "hf_y", ")", "\n", "\n", "hf_text", "=", "(", "\n", "hf_text", "\n", "if", "hf_text", "is", "not", "None", "\n", "else", "trace", "[", "\"text\"", "]", "\n", "if", "hasattr", "(", "trace", ",", "\"text\"", ")", "and", "trace", "[", "\"text\"", "]", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "\n", "hf_hovertext", "=", "(", "\n", "hf_hovertext", "\n", "if", "hf_hovertext", "is", "not", "None", "\n", "else", "trace", "[", "\"hovertext\"", "]", "\n", "if", "hasattr", "(", "trace", ",", "\"hovertext\"", ")", "and", "trace", "[", "\"hovertext\"", "]", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "\n", "if", "trace", "[", "\"type\"", "]", ".", "lower", "(", ")", "in", "self", ".", "_high_frequency_traces", ":", "\n", "            ", "if", "hf_x", "is", "None", ":", "# if no data as x or hf_x is passed", "\n", "                ", "if", "hf_y", ".", "ndim", "!=", "0", ":", "# if hf_y is an array", "\n", "                    ", "hf_x", "=", "pd", ".", "RangeIndex", "(", "0", ",", "len", "(", "hf_y", ")", ")", "# np.arange(len(hf_y))", "\n", "", "else", ":", "# if no data as y or hf_y is passed", "\n", "                    ", "hf_x", "=", "np", ".", "asarray", "(", "None", ")", "\n", "\n", "", "", "assert", "hf_y", ".", "ndim", "==", "np", ".", "ndim", "(", "hf_x", ")", ",", "(", "\n", "\"plotly-resampler requires scatter data \"", "\n", "\"(i.e., x and y, or hf_x and hf_y) to have the same dimensionality!\"", "\n", ")", "\n", "# When the x or y of a trace has more than 1 dimension, it is not at all", "\n", "# straightforward how it should be resampled.", "\n", "assert", "hf_y", ".", "ndim", "<=", "1", "and", "np", ".", "ndim", "(", "hf_x", ")", "<=", "1", ",", "(", "\n", "\"plotly-resampler requires scatter data \"", "\n", "\"(i.e., x and y, or hf_x and hf_y) to be <= 1 dimensional!\"", "\n", ")", "\n", "\n", "# Note: this also converts hf_text and hf_hovertext to a np.ndarray", "\n", "if", "isinstance", "(", "hf_text", ",", "(", "list", ",", "np", ".", "ndarray", ",", "pd", ".", "Series", ")", ")", ":", "\n", "                ", "hf_text", "=", "np", ".", "asarray", "(", "hf_text", ")", "\n", "", "if", "isinstance", "(", "hf_hovertext", ",", "(", "list", ",", "np", ".", "ndarray", ",", "pd", ".", "Series", ")", ")", ":", "\n", "                ", "hf_hovertext", "=", "np", ".", "asarray", "(", "hf_hovertext", ")", "\n", "\n", "# Remove NaNs for efficiency (storing less meaningless data)", "\n", "# NaNs introduce gaps between enclosing non-NaN data points & might distort", "\n", "# the resampling algorithms", "\n", "", "if", "pd", ".", "isna", "(", "hf_y", ")", ".", "any", "(", ")", ":", "\n", "                ", "not_nan_mask", "=", "~", "pd", ".", "isna", "(", "hf_y", ")", "\n", "hf_x", "=", "hf_x", "[", "not_nan_mask", "]", "\n", "hf_y", "=", "hf_y", "[", "not_nan_mask", "]", "\n", "if", "isinstance", "(", "hf_text", ",", "np", ".", "ndarray", ")", ":", "\n", "                    ", "hf_text", "=", "hf_text", "[", "not_nan_mask", "]", "\n", "", "if", "isinstance", "(", "hf_hovertext", ",", "np", ".", "ndarray", ")", ":", "\n", "                    ", "hf_hovertext", "=", "hf_hovertext", "[", "not_nan_mask", "]", "\n", "\n", "# If the categorical or string-like hf_y data is of type object (happens", "\n", "# when y argument is used for the trace constructor instead of hf_y), we", "\n", "# transform it to type string as such it will be sent as categorical data", "\n", "# to the downsampling algorithm", "\n", "", "", "if", "hf_y", ".", "dtype", "==", "\"object\"", ":", "\n", "# But first, we try to parse to a numeric dtype (as this is the", "\n", "# behavior that plotly supports)", "\n", "# Note that a bool array of type object will remain a bool array (and ", "\n", "# not will be transformed to an array of ints (0, 1))", "\n", "                ", "try", ":", "\n", "                    ", "hf_y", "=", "pd", ".", "to_numeric", "(", "hf_y", ",", "errors", "=", "\"raise\"", ")", "\n", "", "except", ":", "\n", "                    ", "hf_y", "=", "hf_y", ".", "astype", "(", "\"str\"", ")", "\n", "\n", "# orjson encoding doesn't like to encode with uint8 & uint16 dtype", "\n", "", "", "if", "str", "(", "hf_y", ".", "dtype", ")", "in", "[", "\"uint8\"", ",", "\"uint16\"", "]", ":", "\n", "                ", "hf_y", "=", "hf_y", ".", "astype", "(", "\"uint32\"", ")", "\n", "\n", "", "assert", "len", "(", "hf_x", ")", "==", "len", "(", "hf_y", ")", ",", "\"x and y have different length!\"", "\n", "", "else", ":", "\n", "            ", "self", ".", "_print", "(", "f\"trace {trace['type']} is not a high-frequency trace\"", ")", "\n", "\n", "# hf_x and hf_y have priority over the traces' data", "\n", "if", "hasattr", "(", "trace", ",", "\"x\"", ")", ":", "\n", "                ", "trace", "[", "\"x\"", "]", "=", "hf_x", "\n", "\n", "", "if", "hasattr", "(", "trace", ",", "\"y\"", ")", ":", "\n", "                ", "trace", "[", "\"y\"", "]", "=", "hf_y", "\n", "\n", "", "if", "hasattr", "(", "trace", ",", "\"text\"", ")", ":", "\n", "                ", "trace", "[", "\"text\"", "]", "=", "hf_text", "\n", "\n", "", "if", "hasattr", "(", "trace", ",", "\"hovertext\"", ")", ":", "\n", "                ", "trace", "[", "\"hovertext\"", "]", "=", "hf_hovertext", "\n", "\n", "", "", "return", "_hf_data_container", "(", "hf_x", ",", "hf_y", ",", "hf_text", ",", "hf_hovertext", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._construct_hf_data_dict": [[715, 784], ["figure_resampler_interface.AbstractFigureAggregator._to_hf_series", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._to_hf_series"], ["", "def", "_construct_hf_data_dict", "(", "\n", "self", ",", "\n", "dc", ":", "_hf_data_container", ",", "\n", "trace", ":", "BaseTraceType", ",", "\n", "downsampler", ":", "AbstractSeriesAggregator", "|", "None", ",", "\n", "max_n_samples", ":", "int", "|", "None", ",", "\n", "offset", "=", "0", ",", "\n", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Create the `hf_data` dict which will be put in the `_hf_data` property.\n\n        Parameters\n        ----------\n        dc : _hf_data_container\n            The hf_data container, withholding the parsed hf-data.\n        trace : BaseTraceType\n            The trace.\n        downsampler : AbstractSeriesAggregator | None\n            The downsampler which will be used.\n        max_n_samples : int | None\n            The max number of output samples.\n\n        Returns\n        -------\n        dict\n            The hf_data dict.\n        \"\"\"", "\n", "# We will re-create this each time as hf_x and hf_y withholds", "\n", "# high-frequency data and can be adjusted on the fly with the public hf_data", "\n", "# property.", "\n", "hf_series", "=", "self", ".", "_to_hf_series", "(", "x", "=", "dc", ".", "x", ",", "y", "=", "dc", ".", "y", ")", "\n", "\n", "# Checking this now avoids less interpretable `KeyError` when resampling", "\n", "assert", "hf_series", ".", "index", ".", "is_monotonic_increasing", "\n", "\n", "# As we support prefix-suffixing of downsampled data, we assure that", "\n", "# each trace has a name", "\n", "# https://github.com/plotly/plotly.py/blob/ce0ed07d872c487698bde9d52e1f1aadf17aa65f/packages/python/plotly/plotly/basedatatypes.py#L539", "\n", "# The link above indicates that the trace index is derived from `data`", "\n", "if", "trace", ".", "name", "is", "None", ":", "\n", "            ", "trace", ".", "name", "=", "f\"trace {len(self.data) + offset}\"", "\n", "\n", "# Determine (1) the axis type and (2) the downsampler instance", "\n", "# & (3) store a hf_data entry for the corresponding trace,", "\n", "# identified by its UUID", "\n", "", "axis_type", "=", "\"date\"", "if", "isinstance", "(", "dc", ".", "x", ",", "pd", ".", "DatetimeIndex", ")", "else", "\"linear\"", "\n", "\n", "default_n_samples", "=", "False", "\n", "if", "max_n_samples", "is", "None", ":", "\n", "            ", "default_n_samples", "=", "True", "\n", "max_n_samples", "=", "self", ".", "_global_n_shown_samples", "\n", "\n", "", "default_downsampler", "=", "False", "\n", "if", "downsampler", "is", "None", ":", "\n", "            ", "default_downsampler", "=", "True", "\n", "downsampler", "=", "self", ".", "_global_downsampler", "\n", "\n", "# TODO -> can't we just store the DC here (might be less duplication of", "\n", "#  code knowledge, because now, you need to know all the eligible hf_keys in", "\n", "#  dc", "\n", "", "return", "{", "\n", "\"max_n_samples\"", ":", "max_n_samples", ",", "\n", "\"default_n_samples\"", ":", "default_n_samples", ",", "\n", "\"x\"", ":", "dc", ".", "x", ",", "\n", "\"y\"", ":", "dc", ".", "y", ",", "\n", "\"axis_type\"", ":", "axis_type", ",", "\n", "\"downsampler\"", ":", "downsampler", ",", "\n", "\"default_downsampler\"", ":", "default_downsampler", ",", "\n", "\"text\"", ":", "dc", ".", "text", ",", "\n", "\"hovertext\"", ":", "dc", ".", "hovertext", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace": [[786, 958], ["isinstance", "figure_resampler_interface.AbstractFigureAggregator._parse_get_trace_props", "len", "super().add_trace", "ValueError", "isinstance", "str", "trace[].lower", "figure_resampler_interface.AbstractFigureAggregator._data_validator.validate_coerce", "uuid.uuid4", "figure_resampler_interface.AbstractFigureAggregator._print", "figure_resampler_interface.AbstractFigureAggregator._construct_hf_data_dict", "figure_resampler_interface.AbstractFigureAggregator._check_update_trace_data", "super().add_trace", "figure_resampler_interface.AbstractFigureAggregator._print", "super().add_trace", "set().difference", "set", "set", "figure_resampler_interface.AbstractFigureAggregator.keys"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._parse_get_trace_props", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._print", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._construct_hf_data_dict", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_trace_data", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._print", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "add_trace", "(", "\n", "self", ",", "\n", "trace", ":", "Union", "[", "BaseTraceType", ",", "dict", "]", ",", "\n", "max_n_samples", ":", "int", "=", "None", ",", "\n", "downsampler", ":", "AbstractSeriesAggregator", "=", "None", ",", "\n", "limit_to_view", ":", "bool", "=", "False", ",", "\n", "# Use these if you want some speedups (and are working with really large data)", "\n", "hf_x", ":", "Iterable", "=", "None", ",", "\n", "hf_y", ":", "Iterable", "=", "None", ",", "\n", "hf_text", ":", "Union", "[", "str", ",", "Iterable", "]", "=", "None", ",", "\n", "hf_hovertext", ":", "Union", "[", "str", ",", "Iterable", "]", "=", "None", ",", "\n", "**", "trace_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Add a trace to the figure.\n\n        Parameters\n        ----------\n        trace : BaseTraceType or dict\n            Either:\n\n              - An instances of a trace class from the ``plotly.graph_objects`` (go)\n                package (e.g., ``go.Scatter``, ``go.Bar``)\n              - or a dict where:\n\n                - The type property specifies the trace type (e.g. scatter, bar,\n                  area, etc.). If the dict has no 'type' property then scatter is\n                  assumed.\n                - All remaining properties are passed to the constructor\n                  of the specified trace type.\n        max_n_samples : int, optional\n            The maximum number of samples that will be shown by the trace.\\n\n            .. note::\n                If this variable is not set; ``_global_n_shown_samples`` will be used.\n        downsampler: AbstractSeriesDownsampler, optional\n            The abstract series downsampler method.\\n\n            .. note::\n                If this variable is not set, ``_global_downsampler`` will be used.\n        limit_to_view: boolean, optional\n            If set to True the trace's datapoints will be cut to the corresponding\n            front-end view, even if the total number of samples is lower than\n            ``max_n_samples``, By default False.\\n\n            Remark that setting this parameter to True ensures that low frequency traces\n            are added to the ``hf_data`` property.\n        hf_x: Iterable, optional\n            The original high frequency series positions, can be either a time-series or\n            an increasing, numerical index. If set, this has priority over the trace its\n            data.\n        hf_y: Iterable, optional\n            The original high frequency values. If set, this has priority over the\n            trace its data.\n        hf_text: Iterable, optional\n            The original high frequency text. If set, this has priority over the trace\n            its ``text`` argument.\n        hf_hovertext: Iterable, optional\n            The original high frequency hovertext. If set, this has priority over the\n            trace its ```hovertext`` argument.\n        **trace_kwargs: dict\n            Additional trace related keyword arguments.\n            e.g.: row=.., col=..., secondary_y=...\n\n            .. seealso::\n                `Figure.add_trace <https://plotly.com/python-api-reference/generated/plotly.graph_objects.Figure.html#plotly.graph_objects.Figure.add_trace>`_ docs.\n\n        Returns\n        -------\n        BaseFigure\n            The Figure on which ``add_trace`` was called on; i.e. self.\n\n        Note\n        ----\n        Constructing traces with **very large data amounts** really takes some time.\n        To speed this up; use this :func:`add_trace` method and\n\n        1. Create a trace with no data (empty lists)\n        2. pass the high frequency data to this method using the ``hf_x`` and ``hf_y``\n           parameters.\n\n        See the example below:\n\n            >>> from plotly.subplots import make_subplots\n            >>> s = pd.Series()  # a high-frequency series, with more than 1e7 samples\n            >>> fig = FigureResampler(go.Figure())\n            >>> fig.add_trace(go.Scattergl(x=[], y=[], ...), hf_x=s.index, hf_y=s)\n\n        .. todo::\n            * explain why adding x and y to a trace is so slow\n            * check and simplify the example above\n\n        Tip\n        ---\n        * If you **do not want to downsample** your data, set ``max_n_samples`` to the\n          the number of datapoints of your trace!\n\n        Attention\n        ---------\n        * The ``NaN`` values in either ``hf_y`` or ``trace.y`` will be omitted! We do\n          not allow ``NaN`` values in ``hf_x`` or ``trace.x``.\n        * ``hf_x``, ``hf_y``, ``hf_text``, and ``hf_hovertext`` are useful when you deal\n          with large amounts of data (as it can increase the speed of this add_trace()\n          method with ~30%). These arguments have priority over the trace's data and\n          (hover)text attributes.\n        * Low-frequency time-series data, i.e. traces that are not resampled, can hinder\n          the the automatic-zooming (y-scaling) as these will not be stored in the\n          back-end and thus not be scaled to the view.\n          To circumvent this, the ``limit_to_view`` argument can be set, resulting in\n          also storing the low-frequency series in the back-end.\n\n        \"\"\"", "\n", "# to comply with the plotly data input acceptance behavior", "\n", "if", "isinstance", "(", "trace", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Trace must be either a dict or a BaseTraceType\"", ")", "\n", "\n", "", "max_out_s", "=", "(", "\n", "self", ".", "_global_n_shown_samples", "if", "max_n_samples", "is", "None", "else", "max_n_samples", "\n", ")", "\n", "\n", "# Validate the trace and convert to a trace object", "\n", "if", "not", "isinstance", "(", "trace", ",", "BaseTraceType", ")", ":", "\n", "            ", "trace", "=", "self", ".", "_data_validator", ".", "validate_coerce", "(", "trace", ")", "[", "0", "]", "\n", "\n", "# First add an UUID, as each (even the non-hf_data traces), must contain this", "\n", "# key for comparison. If the trace already has an UUID, we will keep it.", "\n", "", "uuid_str", "=", "str", "(", "uuid4", "(", ")", ")", "if", "trace", ".", "uid", "is", "None", "else", "trace", ".", "uid", "\n", "trace", ".", "uid", "=", "uuid_str", "\n", "\n", "# construct the hf_data_container", "\n", "# TODO in future version -> maybe regex on kwargs which start with `hf_`", "\n", "dc", "=", "self", ".", "_parse_get_trace_props", "(", "trace", ",", "hf_x", ",", "hf_y", ",", "hf_text", ",", "hf_hovertext", ")", "\n", "\n", "n_samples", "=", "len", "(", "dc", ".", "x", ")", "\n", "# These traces will determine the autoscale RANGE!", "\n", "#   -> so also store when `limit_to_view` is set.", "\n", "if", "trace", "[", "\"type\"", "]", ".", "lower", "(", ")", "in", "self", ".", "_high_frequency_traces", ":", "\n", "            ", "if", "n_samples", ">", "max_out_s", "or", "limit_to_view", ":", "\n", "                ", "self", ".", "_print", "(", "\n", "f\"\\t[i] DOWNSAMPLE {trace['name']}\\t{n_samples}->{max_out_s}\"", "\n", ")", "\n", "\n", "self", ".", "_hf_data", "[", "uuid_str", "]", "=", "self", ".", "_construct_hf_data_dict", "(", "\n", "dc", ",", "\n", "trace", "=", "trace", ",", "\n", "downsampler", "=", "downsampler", ",", "\n", "max_n_samples", "=", "max_n_samples", ",", "\n", ")", "\n", "\n", "# Before we update the trace, we create a new pointer to that trace in", "\n", "# which the downsampled data will be stored. This way, the original", "\n", "# data of the trace to this `add_trace` method will not be altered.", "\n", "# We copy (by reference) all the non-data properties of the trace in", "\n", "# the new trace.", "\n", "trace", "=", "trace", ".", "_props", "# convert the trace into a dict", "\n", "trace", "=", "{", "\n", "k", ":", "trace", "[", "k", "]", "for", "k", "in", "set", "(", "trace", ".", "keys", "(", ")", ")", ".", "difference", "(", "set", "(", "dc", ".", "_fields", ")", ")", "\n", "}", "\n", "\n", "# NOTE:", "\n", "# If all the raw data needs to be sent to the javascript, and the trace", "\n", "# is high-frequency, this would take significant time!", "\n", "# Hence, you first downsample the trace.", "\n", "trace", "=", "self", ".", "_check_update_trace_data", "(", "trace", ")", "\n", "assert", "trace", "is", "not", "None", "\n", "return", "super", "(", "self", ".", "_figure_class", ",", "self", ")", ".", "add_trace", "(", "trace", ",", "**", "trace_kwargs", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_print", "(", "f\"[i] NOT resampling {trace['name']} - len={n_samples}\"", ")", "\n", "# TODO: can be made more generic", "\n", "trace", ".", "x", "=", "dc", ".", "x", "\n", "trace", ".", "y", "=", "dc", ".", "y", "\n", "trace", ".", "text", "=", "dc", ".", "text", "\n", "trace", ".", "hovertext", "=", "dc", ".", "hovertext", "\n", "return", "super", "(", "self", ".", "_figure_class", ",", "self", ")", ".", "add_trace", "(", "trace", ",", "**", "trace_kwargs", ")", "\n", "\n", "", "", "return", "super", "(", "self", ".", "_figure_class", ",", "self", ")", ".", "add_trace", "(", "trace", ",", "**", "trace_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces": [[959, 1080], ["isinstance", "enumerate", "super().add_traces", "isinstance", "isinstance", "isinstance", "zip", "figure_resampler_interface.AbstractFigureAggregator._parse_get_trace_props", "figure_resampler_interface.AbstractFigureAggregator._construct_hf_data_dict", "figure_resampler_interface.AbstractFigureAggregator._check_update_trace_data", "str", "len", "len", "len", "isinstance", "figure_resampler_interface.AbstractFigureAggregator._data_validator.validate_coerce", "uuid.uuid4", "figure_resampler_interface.AbstractFigureAggregator.type.lower", "figure_resampler_interface.AbstractFigureAggregator._hf_data.get", "set().difference", "len", "set", "set", "figure_resampler_interface.AbstractFigureAggregator.keys"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._parse_get_trace_props", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._construct_hf_data_dict", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_trace_data"], ["", "def", "add_traces", "(", "\n", "self", ",", "\n", "data", ":", "List", "[", "BaseTraceType", "|", "dict", "]", "|", "BaseTraceType", "|", "Dict", ",", "\n", "max_n_samples", ":", "None", "|", "List", "[", "int", "]", "|", "int", "=", "None", ",", "\n", "downsamplers", ":", "None", "\n", "|", "List", "[", "AbstractSeriesAggregator", "]", "\n", "|", "AbstractFigureAggregator", "=", "None", ",", "\n", "limit_to_views", ":", "List", "[", "bool", "]", "|", "bool", "=", "False", ",", "\n", "**", "traces_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Add traces to the figure.\n\n        .. note::\n            Make sure to look at the :func:`add_trace` function for more info about\n            **speed optimization**, and dealing with not ``high-frequency`` data, but\n            still want to resample / limit the data to the front-end view.\n\n        Parameters\n        ----------\n        data : List[BaseTraceType  |  dict]\n            A list of trace specifications to be added.\n            Trace specifications may be either:\n\n              - Instances of trace classes from the plotly.graph_objs\n                package (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar).\n              - Dicts where:\n\n                  - The 'type' property specifies the trace type (e.g.\n                    'scatter', 'bar', 'area', etc.). If the dict has no 'type'\n                    property then 'scatter' is assumed.\n                  - All remaining properties are passed to the constructor\n                    of the specified trace type.\n\n        max_n_samples : None | List[int] | int, optional\n              The maximum number of samples that will be shown for each trace.\n              If a single integer is passed, all traces will use this number. If this\n              variable is not set; ``_global_n_shown_samples`` will be used.\n        downsamplers : None | List[AbstractSeriesAggregator] | AbstractFigureAggregator, optional\n            The downsampler that will be used to aggregate the traces. If a single\n            aggregator is passed, all traces will use this aggregator.\n            If this variable is not set, ``_global_downsampler`` will be used.\n        limit_to_views : None | List[bool] | bool, optional\n            List of limit_to_view booleans for the added traces.  If set to True\n            the trace's datapoints will be cut to the corresponding front-end view,\n            even if the total number of samples is lower than ``max_n_samples``. If a\n            single boolean is passed, all to be added traces will use this value,\n            by default False.\\n\n            Remark that setting this parameter to True ensures that low frequency traces\n            are added to the ``hf_data`` property.\n        **traces_kwargs: dict\n            Additional trace related keyword arguments.\n            e.g.: rows=.., cols=..., secondary_ys=...\n\n            .. seealso::\n                `Figure.add_traces <https://plotly.com/python-api-reference/generated/plotly.graph_objects.Figure.html#plotly.graph_objects.Figure.add_traces>`_ docs.\n\n        Returns\n        -------\n        BaseFigure\n            The Figure on which ``add_traces`` was called on; i.e. self.\n\n        \"\"\"", "\n", "# note: Plotly its add_traces also a allows non list-like input e.g. a scatter", "\n", "# object; the code below is an exact copy of their internally applied parsing", "\n", "if", "not", "isinstance", "(", "data", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data", "=", "[", "data", "]", "\n", "\n", "# Convert each trace into a BaseTraceType object", "\n", "", "data", "=", "[", "\n", "self", ".", "_data_validator", ".", "validate_coerce", "(", "trace", ")", "[", "0", "]", "\n", "if", "not", "isinstance", "(", "trace", ",", "BaseTraceType", ")", "\n", "else", "trace", "\n", "for", "trace", "in", "data", "\n", "]", "\n", "\n", "# First add an UUID, as each (even the non-hf_data traces), must contain this", "\n", "# key for comparison. If the trace already has an UUID, we will keep it.", "\n", "for", "trace", "in", "data", ":", "\n", "            ", "uuid_str", "=", "str", "(", "uuid4", "(", ")", ")", "if", "trace", ".", "uid", "is", "None", "else", "trace", ".", "uid", "\n", "trace", ".", "uid", "=", "uuid_str", "\n", "\n", "# Convert the data properties", "\n", "", "if", "isinstance", "(", "max_n_samples", ",", "(", "int", ",", "np", ".", "integer", ")", ")", "or", "max_n_samples", "is", "None", ":", "\n", "            ", "max_n_samples", "=", "[", "max_n_samples", "]", "*", "len", "(", "data", ")", "\n", "", "if", "isinstance", "(", "downsamplers", ",", "AbstractSeriesAggregator", ")", "or", "downsamplers", "is", "None", ":", "\n", "            ", "downsamplers", "=", "[", "downsamplers", "]", "*", "len", "(", "data", ")", "\n", "", "if", "isinstance", "(", "limit_to_views", ",", "bool", ")", ":", "\n", "            ", "limit_to_views", "=", "[", "limit_to_views", "]", "*", "len", "(", "data", ")", "\n", "\n", "", "for", "i", ",", "(", "trace", ",", "max_out", ",", "downsampler", ",", "limit_to_view", ")", "in", "enumerate", "(", "\n", "zip", "(", "data", ",", "max_n_samples", ",", "downsamplers", ",", "limit_to_views", ")", "\n", ")", ":", "\n", "            ", "if", "(", "\n", "trace", ".", "type", ".", "lower", "(", ")", "not", "in", "self", ".", "_high_frequency_traces", "\n", "or", "self", ".", "_hf_data", ".", "get", "(", "trace", ".", "uid", ")", "is", "not", "None", "\n", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "max_out_s", "=", "self", ".", "_global_n_shown_samples", "if", "max_out", "is", "None", "else", "max_out", "\n", "if", "not", "limit_to_view", "and", "(", "trace", ".", "y", "is", "None", "or", "len", "(", "trace", ".", "y", ")", "<=", "max_out_s", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "dc", "=", "self", ".", "_parse_get_trace_props", "(", "trace", ")", "\n", "self", ".", "_hf_data", "[", "trace", ".", "uid", "]", "=", "self", ".", "_construct_hf_data_dict", "(", "\n", "dc", ",", "\n", "trace", "=", "trace", ",", "\n", "downsampler", "=", "downsampler", ",", "\n", "max_n_samples", "=", "max_out", ",", "\n", "offset", "=", "i", ",", "\n", ")", "\n", "\n", "# convert the trace into a dict, and only withholds the non-hf props", "\n", "trace", "=", "trace", ".", "_props", "\n", "trace", "=", "{", "k", ":", "trace", "[", "k", "]", "for", "k", "in", "set", "(", "trace", ".", "keys", "(", ")", ")", ".", "difference", "(", "set", "(", "dc", ".", "_fields", ")", ")", "}", "\n", "\n", "# update the trace data with the HF props", "\n", "trace", "=", "self", ".", "_check_update_trace_data", "(", "trace", ")", "\n", "assert", "trace", "is", "not", "None", "\n", "data", "[", "i", "]", "=", "trace", "\n", "\n", "", "return", "super", "(", "self", ".", "_figure_class", ",", "self", ")", ".", "add_traces", "(", "data", ",", "**", "traces_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._clear_figure": [[1081, 1088], ["None"], "methods", ["None"], ["", "def", "_clear_figure", "(", "self", ")", ":", "\n", "        ", "\"\"\"Clear the current figure object it's data and layout.\"\"\"", "\n", "self", ".", "_hf_data", "=", "{", "}", "\n", "self", ".", "data", "=", "[", "]", "\n", "self", ".", "_data", "=", "[", "]", "\n", "self", ".", "_layout", "=", "{", "}", "\n", "self", ".", "layout", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._copy_hf_data": [[1089, 1121], ["hf_data_cp.values", "hf_data.items", "hf_props.get", "hf_props.get", "set", "hf_dict.keys"], "methods", ["None"], ["", "def", "_copy_hf_data", "(", "self", ",", "hf_data", ":", "dict", ",", "adjust_default_values", ":", "bool", "=", "False", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Copy (i.e. create a new key reference, not a deep copy) of a hf_data dict.\n\n        Parameters\n        ----------\n        hf_data : dict\n            The hf_data dict, having the trace 'uid' as key and the\n            hf-data, together with its aggregation properties as dict-values\n        adjust_default_values: bool\n            Whether the default values (of the downsampler, max # shown samples) will\n            be adjusted according to the values of this object, by default False\n\n        Returns\n        -------\n        dict\n            The copied (& default values adjusted) output dict.\n\n        \"\"\"", "\n", "hf_data_cp", "=", "{", "\n", "uid", ":", "{", "k", ":", "hf_dict", "[", "k", "]", "for", "k", "in", "set", "(", "hf_dict", ".", "keys", "(", ")", ")", "}", "\n", "for", "uid", ",", "hf_dict", "in", "hf_data", ".", "items", "(", ")", "\n", "}", "\n", "\n", "# Adjust the default arguments to the current argument values", "\n", "if", "adjust_default_values", ":", "\n", "            ", "for", "hf_props", "in", "hf_data_cp", ".", "values", "(", ")", ":", "\n", "                ", "if", "hf_props", ".", "get", "(", "\"default_downsampler\"", ",", "False", ")", ":", "\n", "                    ", "hf_props", "[", "\"downsampler\"", "]", "=", "self", ".", "_global_downsampler", "\n", "", "if", "hf_props", ".", "get", "(", "\"default_n_samples\"", ",", "False", ")", ":", "\n", "                    ", "hf_props", "[", "\"max_n_samples\"", "]", "=", "self", ".", "_global_n_shown_samples", "\n", "\n", "", "", "", "return", "hf_data_cp", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace": [[1122, 1141], ["figure_resampler_interface.AbstractFigureAggregator._clear_figure", "figure_resampler_interface.AbstractFigureAggregator.__init__"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._clear_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["", "def", "replace", "(", "self", ",", "figure", ":", "go", ".", "Figure", ",", "convert_existing_traces", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"Replace the current figure layout with the passed figure object.\n\n        Parameters\n        ----------\n        figure: go.Figure\n            The figure object which will replace the existing figure.\n        convert_existing_traces: bool, Optional\n            A bool indicating whether the traces of the passed ``figure`` should be\n            resampled, by default True.\n\n        \"\"\"", "\n", "self", ".", "_clear_figure", "(", ")", "\n", "self", ".", "__init__", "(", "\n", "figure", "=", "figure", ",", "\n", "convert_existing_traces", "=", "convert_existing_traces", ",", "\n", "default_n_shown_samples", "=", "self", ".", "_global_n_shown_samples", ",", "\n", "default_downsampler", "=", "self", ".", "_global_downsampler", ",", "\n", "resampled_trace_prefix_suffix", "=", "(", "self", ".", "_prefix", ",", "self", ".", "_suffix", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.construct_update_data": [[1143, 1249], ["figure_resampler_interface.AbstractFigureAggregator._get_current_graph", "figure_resampler_interface.AbstractFigureAggregator._re_matches", "layout_traces_list.append", "figure_resampler_interface.AbstractFigureAggregator._print", "relayout_data.keys", "figure_resampler_interface.AbstractFigureAggregator._re_matches", "figure_resampler_interface.AbstractFigureAggregator._re_matches", "figure_resampler_interface.AbstractFigureAggregator._re_matches", "figure_resampler_interface.AbstractFigureAggregator._re_matches", "len", "re.compile", "trace_reduced.update", "layout_traces_list.append", "re.compile", "re.compile", "len", "len", "zip", "re.compile", "re.compile", "len", "len", "range_change_axis.split", "figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict", "len", "t_start_key.split", "figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict", "len", "t_stop_key.split", "autorange_key.split"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._get_current_graph", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._print", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict"], ["", "def", "construct_update_data", "(", "self", ",", "relayout_data", ":", "dict", ")", "->", "List", "[", "dict", "]", ":", "\n", "        ", "\"\"\"Construct the to-be-updated front-end data, based on the layout change.\n\n        Attention\n        ---------\n        This method is tightly coupled with Dash app callbacks. It takes the front-end\n        figure its ``relayoutData`` as input and returns the data which needs to be\n        sent tot the ``TraceUpdater`` its ``updateData`` property for that corresponding\n        graph.\n\n        Parameters\n        ----------\n        relayout_data: dict\n            A dict containing the ``relayout``-data (a.k.a. changed layout data) of\n            the corresponding front-end graph.\n\n        Returns\n        -------\n        List[dict]:\n            A list of dicts, where each dict-item is a representation of a trace its\n            *data* properties which are affected by the front-end layout change. |br|\n            In other words, only traces which need to be updated will be sent to the\n            front-end. Additionally, each trace-dict withholds the *index* of its\n            corresponding position in the ``figure[data]`` array with the ``index``-key\n            in each dict.\n\n        \"\"\"", "\n", "current_graph", "=", "self", ".", "_get_current_graph", "(", ")", "\n", "updated_trace_indices", ",", "cl_k", "=", "[", "]", ",", "[", "]", "\n", "if", "relayout_data", ":", "\n", "            ", "self", ".", "_print", "(", "\"-\"", "*", "100", "+", "\"\\n\"", ",", "\"changed layout\"", ",", "relayout_data", ")", "\n", "\n", "cl_k", "=", "relayout_data", ".", "keys", "(", ")", "\n", "\n", "# ------------------ HF DATA aggregation ---------------------", "\n", "# 1. Base case - there is a x-range specified in the front-end", "\n", "start_matches", "=", "self", ".", "_re_matches", "(", "re", ".", "compile", "(", "r\"xaxis\\d*.range\\[0]\"", ")", ",", "cl_k", ")", "\n", "stop_matches", "=", "self", ".", "_re_matches", "(", "re", ".", "compile", "(", "r\"xaxis\\d*.range\\[1]\"", ")", ",", "cl_k", ")", "\n", "if", "len", "(", "start_matches", ")", "and", "len", "(", "stop_matches", ")", ":", "\n", "                ", "for", "t_start_key", ",", "t_stop_key", "in", "zip", "(", "start_matches", ",", "stop_matches", ")", ":", "\n", "# Check if the xaxis<NUMB> part of xaxis<NUMB>.[0-1] matches", "\n", "                    ", "xaxis", "=", "t_start_key", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "assert", "xaxis", "==", "t_stop_key", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "# -> we want to copy the layout on the back-end", "\n", "updated_trace_indices", "=", "self", ".", "_check_update_figure_dict", "(", "\n", "current_graph", ",", "\n", "start", "=", "relayout_data", "[", "t_start_key", "]", ",", "\n", "stop", "=", "relayout_data", "[", "t_stop_key", "]", ",", "\n", "xaxis_filter", "=", "xaxis", ",", "\n", "updated_trace_indices", "=", "updated_trace_indices", ",", "\n", ")", "\n", "\n", "# 2. The user clicked on either autorange | reset axes", "\n", "", "", "autorange_matches", "=", "self", ".", "_re_matches", "(", "\n", "re", ".", "compile", "(", "r\"xaxis\\d*.autorange\"", ")", ",", "cl_k", "\n", ")", "\n", "spike_matches", "=", "self", ".", "_re_matches", "(", "re", ".", "compile", "(", "r\"xaxis\\d*.showspikes\"", ")", ",", "cl_k", ")", "\n", "# 2.1 Reset-axes -> autorange & reset to the global data view", "\n", "if", "len", "(", "autorange_matches", ")", "and", "len", "(", "spike_matches", ")", ":", "\n", "                ", "for", "autorange_key", "in", "autorange_matches", ":", "\n", "                    ", "if", "relayout_data", "[", "autorange_key", "]", ":", "\n", "                        ", "xaxis", "=", "autorange_key", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "updated_trace_indices", "=", "self", ".", "_check_update_figure_dict", "(", "\n", "current_graph", ",", "\n", "xaxis_filter", "=", "xaxis", ",", "\n", "updated_trace_indices", "=", "updated_trace_indices", ",", "\n", ")", "\n", "# 2.1. Autorange -> do nothing, the autorange will be applied on the", "\n", "#      current front-end view", "\n", "", "", "", "elif", "len", "(", "autorange_matches", ")", "and", "not", "len", "(", "spike_matches", ")", ":", "\n", "# PreventUpdate returns a 204 status code response on the", "\n", "# relayout post request", "\n", "                ", "return", "dash", ".", "no_update", "\n", "\n", "# If we do not have any traces to be updated, we will return an empty", "\n", "# request response", "\n", "", "", "if", "len", "(", "updated_trace_indices", ")", "==", "0", ":", "\n", "# PreventUpdate returns a 204 status-code response on the relayout post", "\n", "# request", "\n", "            ", "return", "dash", ".", "no_update", "\n", "\n", "# -------------------- construct callback data --------------------------", "\n", "", "layout_traces_list", ":", "List", "[", "dict", "]", "=", "[", "]", "# the data", "\n", "\n", "# 1. Create a new dict with additional layout updates for the front-end", "\n", "extra_layout_updates", "=", "{", "}", "\n", "\n", "# 1.1. Set autorange to False for each layout item with a specified x-range", "\n", "xy_matches", "=", "self", ".", "_re_matches", "(", "re", ".", "compile", "(", "r\"[xy]axis\\d*.range\\[\\d+]\"", ")", ",", "cl_k", ")", "\n", "for", "range_change_axis", "in", "xy_matches", ":", "\n", "            ", "axis", "=", "range_change_axis", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "extra_layout_updates", "[", "f\"{axis}.autorange\"", "]", "=", "False", "\n", "", "layout_traces_list", ".", "append", "(", "extra_layout_updates", ")", "\n", "\n", "# 2. Create the additional trace data for the frond-end", "\n", "relevant_keys", "=", "[", "\"x\"", ",", "\"y\"", ",", "\"text\"", ",", "\"hovertext\"", ",", "\"name\"", "]", "# TODO - marker color", "\n", "# Note that only updated trace-data will be sent to the client", "\n", "for", "idx", "in", "updated_trace_indices", ":", "\n", "            ", "trace", "=", "current_graph", "[", "\"data\"", "]", "[", "idx", "]", "\n", "trace_reduced", "=", "{", "k", ":", "trace", "[", "k", "]", "for", "k", "in", "relevant_keys", "if", "k", "in", "trace", "}", "\n", "\n", "# Store the index into the corresponding to-be-sent trace-data so", "\n", "# the client front-end can know which trace needs to be updated", "\n", "trace_reduced", ".", "update", "(", "{", "\"index\"", ":", "idx", "}", ")", "\n", "layout_traces_list", ".", "append", "(", "trace_reduced", ")", "\n", "", "return", "layout_traces_list", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches": [[1250, 1259], ["sorted", "regex.match", "matches.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_re_matches", "(", "regex", ":", "re", ".", "Pattern", ",", "strings", ":", "Iterable", "[", "str", "]", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"Returns all the items in ``strings`` which regex.match(es) ``regex``.\"\"\"", "\n", "matches", "=", "[", "]", "\n", "for", "item", "in", "strings", ":", "\n", "            ", "m", "=", "regex", ".", "match", "(", "item", ")", "\n", "if", "m", "is", "not", "None", ":", "\n", "                ", "matches", ".", "append", "(", "m", ".", "string", ")", "\n", "", "", "return", "sorted", "(", "matches", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure": [[14, 34], ["isinstance", "isinstance"], "function", ["None"], ["def", "is_figure", "(", "figure", ":", "Any", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Check if the figure is a plotly go.Figure or a FigureResampler.\n\n    .. Note::\n        This method does not use isinstance(figure, go.Figure) as this will not work\n        when go.Figure is decorated (after executing the\n        ``register_plotly_resampler`` function).\n\n    Parameters\n    ----------\n    figure : Any\n        The figure to check.\n\n    Returns\n    -------\n    bool\n        True if the figure is a plotly go.Figure or a FigureResampler.\n    \"\"\"", "\n", "\n", "return", "isinstance", "(", "figure", ",", "BaseFigure", ")", "and", "(", "not", "isinstance", "(", "figure", ",", "BaseFigureWidget", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget": [[36, 55], ["isinstance"], "function", ["None"], ["", "def", "is_figurewidget", "(", "figure", ":", "Any", ")", ":", "\n", "    ", "\"\"\"Check if the figure is a plotly go.FigureWidget or a FigureWidgetResampler.\n\n    .. Note::\n        This method does not use isinstance(figure, go.FigureWidget) as this will not\n        work when go.FigureWidget is decorated (after executing the\n        ``register_plotly_resampler`` function).\n\n    Parameters\n    ----------\n    figure : Any\n        The figure to check.\n\n    Returns\n    -------\n    bool\n        True if the figure is a plotly go.FigureWidget or a FigureWidgetResampler.\n    \"\"\"", "\n", "return", "isinstance", "(", "figure", ",", "BaseFigureWidget", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr": [[57, 76], ["isinstance"], "function", ["None"], ["", "def", "is_fr", "(", "figure", ":", "Any", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Check if the figure is a FigureResampler.\n\n    .. Note::\n        This method will not return True if the figure is a plotly go.Figure.\n\n    Parameters\n    ----------\n    figure : Any\n        The figure to check.\n\n    Returns\n    -------\n    bool\n        True if the figure is a FigureResampler.\n    \"\"\"", "\n", "from", "plotly_resampler", "import", "FigureResampler", "\n", "\n", "return", "isinstance", "(", "figure", ",", "FigureResampler", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr": [[78, 97], ["isinstance"], "function", ["None"], ["", "def", "is_fwr", "(", "figure", ":", "Any", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Check if the figure is a FigureWidgetResampler.\n\n    .. Note::\n        This method will not return True if the figure is a plotly go.FigureWidget.\n\n    Parameters\n    ----------\n    figure : Any\n        The figure to check.\n\n    Returns\n    -------\n    bool\n        True if the figure is a FigureWidgetResampler.\n    \"\"\"", "\n", "from", "plotly_resampler", "import", "FigureWidgetResampler", "\n", "\n", "return", "isinstance", "(", "figure", ",", "FigureWidgetResampler", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.timedelta_to_str": [[102, 148], ["pandas.Timedelta", "len", "str", "str", "[].rstrip", "str", "str().split", "str"], "function", ["None"], ["", "def", "timedelta_to_str", "(", "td", ":", "pd", ".", "Timedelta", ")", "->", "str", ":", "\n", "    ", "\"\"\"Construct a tight string representation for the given timedelta arg.\n\n    Parameters\n    ----------\n    td: pd.Timedelta\n        The timedelta for which the string representation is constructed\n\n    Returns\n    -------\n    str:\n        The tight string bounds of format '$d-$h$m$s.$ms'.\n\n    \"\"\"", "\n", "out_str", "=", "\"\"", "\n", "\n", "# Edge case if we deal with negative", "\n", "if", "td", "<", "pd", ".", "Timedelta", "(", "seconds", "=", "0", ")", ":", "\n", "        ", "td", "*=", "-", "1", "\n", "out_str", "+=", "\"NEG\"", "\n", "\n", "# Note: this must happen after the *= -1", "\n", "", "c", "=", "td", ".", "components", "\n", "if", "c", ".", "days", ">", "0", ":", "\n", "        ", "out_str", "+=", "f\"{c.days}D\"", "\n", "", "if", "c", ".", "hours", ">", "0", "or", "c", ".", "minutes", ">", "0", "or", "c", ".", "seconds", ">", "0", "or", "c", ".", "milliseconds", ">", "0", ":", "\n", "        ", "out_str", "+=", "\"_\"", "if", "len", "(", "out_str", ")", "else", "\"\"", "\n", "\n", "", "if", "c", ".", "hours", ">", "0", ":", "\n", "        ", "out_str", "+=", "f\"{c.hours}h\"", "\n", "", "if", "c", ".", "minutes", ">", "0", ":", "\n", "        ", "out_str", "+=", "f\"{c.minutes}m\"", "\n", "", "if", "c", ".", "seconds", ">", "0", ":", "\n", "        ", "if", "c", ".", "milliseconds", ":", "\n", "            ", "out_str", "+=", "(", "\n", "f\"{c.seconds}.{str(c.milliseconds / 1000).split('.')[-1].rstrip('0')}s\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "out_str", "+=", "f\"{c.seconds}s\"", "\n", "", "", "elif", "c", ".", "milliseconds", ">", "0", ":", "\n", "        ", "out_str", "+=", "f\"{str(c.milliseconds)}ms\"", "\n", "", "if", "c", ".", "microseconds", ">", "0", ":", "\n", "        ", "out_str", "+=", "f\"{str(c.microseconds)}us\"", "\n", "", "if", "c", ".", "nanoseconds", ">", "0", ":", "\n", "        ", "out_str", "+=", "f\"{str(c.nanoseconds)}ns\"", "\n", "", "return", "out_str", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str": [[150, 159], ["utils.timedelta_to_str", "pandas.Timedelta", "td.round"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.timedelta_to_str"], ["", "def", "round_td_str", "(", "td", ":", "pd", ".", "Timedelta", ")", "->", "str", ":", "\n", "    ", "\"\"\"Round a timedelta to the nearest unit and convert to a string.\n\n    .. seealso::\n        :func:`timedelta_to_str`\n    \"\"\"", "\n", "for", "t_s", "in", "[", "\"D\"", ",", "\"H\"", ",", "\"min\"", ",", "\"s\"", ",", "\"ms\"", ",", "\"us\"", ",", "\"ns\"", "]", ":", "\n", "        ", "if", "td", ">", "0.95", "*", "pd", ".", "Timedelta", "(", "f\"1{t_s}\"", ")", ":", "\n", "            ", "return", "timedelta_to_str", "(", "td", ".", "round", "(", "t_s", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str": [[161, 169], ["str", "str", "round", "round", "int", "int", "abs", "int", "round", "math.log10"], "function", ["None"], ["", "", "", "def", "round_number_str", "(", "number", ":", "float", ")", "->", "str", ":", "\n", "    ", "if", "number", ">", "0.95", ":", "\n", "        ", "for", "unit", ",", "scaling", "in", "[", "(", "\"M\"", ",", "int", "(", "1e6", ")", ")", ",", "(", "\"k\"", ",", "int", "(", "1e3", ")", ")", "]", ":", "\n", "            ", "if", "number", "/", "scaling", ">", "0.95", ":", "\n", "                ", "return", "f\"{round(number / scaling)}{unit}\"", "\n", "", "", "return", "str", "(", "round", "(", "number", ")", ")", "\n", "# we have a number < 1 --> round till nearest non-zero digit", "\n", "", "return", "str", "(", "round", "(", "number", ",", "1", "+", "abs", "(", "int", "(", "math", ".", "log10", "(", "number", ")", ")", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.__init__": [[31, 96], ["aggregation.EfficientLTTB", "super().__init__", "isinstance", "utils.is_figure", "isinstance", "figure_resampler.FigureResampler._hf_data.update", "utils.is_fr", "figure_resampler.FigureResampler._get_figure_class", "f.add_traces", "isinstance", "figure_resampler.FigureResampler._copy_hf_data", "figure_resampler.FigureResampler.batch_update", "figure_resampler.FigureResampler._get_current_graph", "figure_resampler.FigureResampler._check_update_figure_dict", "f.add_traces", "figure_resampler.FigureResampler.data[].update"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._get_figure_class", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._copy_hf_data", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._get_current_graph", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces"], ["def", "__init__", "(", "\n", "self", ",", "\n", "figure", ":", "BaseFigure", "|", "dict", "=", "None", ",", "\n", "convert_existing_traces", ":", "bool", "=", "True", ",", "\n", "default_n_shown_samples", ":", "int", "=", "1000", ",", "\n", "default_downsampler", ":", "AbstractSeriesAggregator", "=", "EfficientLTTB", "(", ")", ",", "\n", "resampled_trace_prefix_suffix", ":", "Tuple", "[", "str", ",", "str", "]", "=", "(", "\n", "'<b style=\"color:sandybrown\">[R]</b> '", ",", "\n", "\"\"", ",", "\n", ")", ",", "\n", "show_mean_aggregation_size", ":", "bool", "=", "True", ",", "\n", "convert_traces_kwargs", ":", "dict", "|", "None", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "# Parse the figure input before calling `super`", "\n", "        ", "if", "is_figure", "(", "figure", ")", "and", "not", "is_fr", "(", "figure", ")", ":", "# go.Figure", "\n", "# Base case, the figure does not need to be adjusted", "\n", "            ", "f", "=", "figure", "\n", "", "else", ":", "\n", "# Create a new figure object and make sure that the trace uid will not get", "\n", "# adjusted when they are added.", "\n", "            ", "f", "=", "self", ".", "_get_figure_class", "(", "go", ".", "Figure", ")", "(", ")", "\n", "f", ".", "_data_validator", ".", "set_uid", "=", "False", "\n", "\n", "if", "isinstance", "(", "figure", ",", "BaseFigure", ")", ":", "# go.FigureWidget or AbstractFigureAggregator", "\n", "# A base figure object, we first copy the layout and grid ref", "\n", "                ", "f", ".", "layout", "=", "figure", ".", "layout", "\n", "f", ".", "_grid_ref", "=", "figure", ".", "_grid_ref", "\n", "f", ".", "add_traces", "(", "figure", ".", "data", ")", "\n", "", "elif", "isinstance", "(", "figure", ",", "(", "dict", ",", "list", ")", ")", ":", "\n", "# A single trace dict or a list of traces", "\n", "                ", "f", ".", "add_traces", "(", "figure", ")", "\n", "\n", "", "", "super", "(", ")", ".", "__init__", "(", "\n", "f", ",", "\n", "convert_existing_traces", ",", "\n", "default_n_shown_samples", ",", "\n", "default_downsampler", ",", "\n", "resampled_trace_prefix_suffix", ",", "\n", "show_mean_aggregation_size", ",", "\n", "convert_traces_kwargs", ",", "\n", "verbose", ",", "\n", ")", "\n", "\n", "if", "isinstance", "(", "figure", ",", "AbstractFigureAggregator", ")", ":", "\n", "# Copy the `_hf_data` if the previous figure was an AbstractFigureAggregator", "\n", "# and adjust the default `max_n_samples` and `downsampler`", "\n", "            ", "self", ".", "_hf_data", ".", "update", "(", "\n", "self", ".", "_copy_hf_data", "(", "figure", ".", "_hf_data", ",", "adjust_default_values", "=", "True", ")", "\n", ")", "\n", "\n", "# Note: This hack ensures that the this figure object initially uses", "\n", "# data of the whole view. More concretely; we create a dict", "\n", "# serialization figure and adjust the hf-traces to the whole view", "\n", "# with the check-update method (by passing no range / filter args)", "\n", "with", "self", ".", "batch_update", "(", ")", ":", "\n", "                ", "graph_dict", ":", "dict", "=", "self", ".", "_get_current_graph", "(", ")", "\n", "update_indices", "=", "self", ".", "_check_update_figure_dict", "(", "graph_dict", ")", "\n", "for", "idx", "in", "update_indices", ":", "\n", "                    ", "self", ".", "data", "[", "idx", "]", ".", "update", "(", "graph_dict", "[", "\"data\"", "]", "[", "idx", "]", ")", "\n", "\n", "# The FigureResampler needs a dash app", "\n", "", "", "", "self", ".", "_app", ":", "JupyterDash", "|", "Dash", "|", "None", "=", "None", "\n", "self", ".", "_port", ":", "int", "|", "None", "=", "None", "\n", "self", ".", "_host", ":", "str", "|", "None", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.show_dash": [[97, 166], ["jupyter_dash.JupyterDash", "dash.html.Div", "figure_resampler.FigureResampler.register_update_graph_callback", "kwargs.get", "kwargs.get", "jupyter_dash.JupyterDash.run_server", "graph_properties.keys", "dash.dcc.Graph", "trace_updater.TraceUpdater"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.register_update_graph_callback"], ["", "def", "show_dash", "(", "\n", "self", ",", "\n", "mode", "=", "None", ",", "\n", "config", ":", "dict", "|", "None", "=", "None", ",", "\n", "graph_properties", ":", "dict", "|", "None", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Registers the :func:`update_graph` callback & show the figure in a dash app.\n\n        Parameters\n        ----------\n        mode: str, optional\n            Display mode. One of:\\n\n              * ``\"external\"``: The URL of the app will be displayed in the notebook\n                output cell. Clicking this URL will open the app in the default\n                web browser.\n              * ``\"inline\"``: The app will be displayed inline in the notebook output\n                cell in an iframe.\n              * ``\"jupyterlab\"``: The app will be displayed in a dedicated tab in the\n                JupyterLab interface. Requires JupyterLab and the ``jupyterlab-dash``\n                extension.\n            By default None, which will result in the same behavior as ``\"external\"``.\n        config: dict, optional\n            The configuration options for displaying this figure, by default None.\n            This ``config`` parameter is the same as the dict that you would pass as\n            ``config`` argument to the `show` method.\n            See more https://plotly.com/python/configuration-options/\n        graph_properties: dict, optional\n            Dictionary of (keyword, value) for the properties that should be passed to\n            the dcc.Graph, by default None.\n            e.g.: {\"style\": {\"width\": \"50%\"}}\n            Note: \"config\" is not allowed as key in this dict, as there is a distinct\n            ``config`` parameter for this property in this method.\n            See more https://dash.plotly.com/dash-core-components/graph\n        **kwargs: dict\n            Additional app.run_server() kwargs. e.g.: port\n\n        \"\"\"", "\n", "graph_properties", "=", "{", "}", "if", "graph_properties", "is", "None", "else", "graph_properties", "\n", "assert", "\"config\"", "not", "in", "graph_properties", ".", "keys", "(", ")", "# There is a param for config", "\n", "# 1. Construct the Dash app layout", "\n", "app", "=", "JupyterDash", "(", "\"local_app\"", ")", "\n", "app", ".", "layout", "=", "dash", ".", "html", ".", "Div", "(", "\n", "[", "\n", "dash", ".", "dcc", ".", "Graph", "(", "\n", "id", "=", "\"resample-figure\"", ",", "figure", "=", "self", ",", "config", "=", "config", ",", "**", "graph_properties", "\n", ")", ",", "\n", "TraceUpdater", "(", "\n", "id", "=", "\"trace-updater\"", ",", "gdID", "=", "\"resample-figure\"", ",", "sequentialUpdate", "=", "False", "\n", ")", ",", "\n", "]", "\n", ")", "\n", "self", ".", "register_update_graph_callback", "(", "app", ",", "\"resample-figure\"", ",", "\"trace-updater\"", ")", "\n", "\n", "# 2. Run the app", "\n", "if", "(", "\n", "self", ".", "layout", ".", "height", "is", "not", "None", "\n", "and", "mode", "==", "\"inline\"", "\n", "and", "\"height\"", "not", "in", "kwargs", "\n", ")", ":", "\n", "# If figure height is specified -> re-use is for inline dash app height", "\n", "            ", "kwargs", "[", "\"height\"", "]", "=", "self", ".", "layout", ".", "height", "+", "18", "\n", "\n", "# store the app information, so it can be killed", "\n", "", "self", ".", "_app", "=", "app", "\n", "self", ".", "_host", "=", "kwargs", ".", "get", "(", "\"host\"", ",", "\"127.0.0.1\"", ")", "\n", "self", ".", "_port", "=", "kwargs", ".", "get", "(", "\"port\"", ",", "\"8050\"", ")", "\n", "\n", "app", ".", "run_server", "(", "mode", "=", "mode", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.stop_server": [[167, 190], ["figure_resampler.FigureResampler._app._server_threads.get", "figure_resampler.FigureResampler.kill", "figure_resampler.FigureResampler.join", "warnings.warn"], "methods", ["None"], ["", "def", "stop_server", "(", "self", ",", "warn", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"Stop the running dash-app.\n\n        Parameters\n        ----------\n        warn: bool\n            Whether a warning message will be shown or  not, by default True.\n\n        .. attention::\n            This only works if the dash-app was started with :func:`show_dash`.\n        \"\"\"", "\n", "if", "self", ".", "_app", "is", "not", "None", ":", "\n", "\n", "            ", "old_server", "=", "self", ".", "_app", ".", "_server_threads", ".", "get", "(", "(", "self", ".", "_host", ",", "self", ".", "_port", ")", ")", "\n", "if", "old_server", ":", "\n", "                ", "old_server", ".", "kill", "(", ")", "\n", "old_server", ".", "join", "(", ")", "\n", "del", "self", ".", "_app", ".", "_server_threads", "[", "(", "self", ".", "_host", ",", "self", ".", "_port", ")", "]", "\n", "", "", "elif", "warn", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Could not stop the server, either the \\n\"", "\n", "+", "\"\\t- 'show-dash' method was not called, or \\n\"", "\n", "+", "\"\\t- the dash-server wasn't started with 'show_dash'\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.register_update_graph_callback": [[192, 216], ["app.callback", "dash.dependencies.Output", "dash.dependencies.Input"], "methods", ["None"], ["", "", "def", "register_update_graph_callback", "(", "\n", "self", ",", "app", ":", "dash", ".", "Dash", ",", "graph_id", ":", "str", ",", "trace_updater_id", ":", "str", "\n", ")", ":", "\n", "        ", "\"\"\"Register the :func:`construct_update_data` method as callback function to\n        the passed dash-app.\n\n        Parameters\n        ----------\n        app: Union[dash.Dash, JupyterDash]\n            The app in which the callback will be registered.\n        graph_id:\n            The id of the ``dcc.Graph``-component which withholds the to-be resampled\n            Figure.\n        trace_updater_id\n            The id of the ``TraceUpdater`` component. This component is leveraged by\n            ``FigureResampler`` to efficiently POST the to-be-updated data to the\n            front-end.\n\n        \"\"\"", "\n", "app", ".", "callback", "(", "\n", "dash", ".", "dependencies", ".", "Output", "(", "trace_updater_id", ",", "\"updateData\"", ")", ",", "\n", "dash", ".", "dependencies", ".", "Input", "(", "graph_id", ",", "\"relayoutData\"", ")", ",", "\n", "prevent_initial_call", "=", "True", ",", "\n", ")", "(", "self", ".", "construct_update_data", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.LTTB.__init__": [[47, 73], ["aggregation.aggregation_interface.AbstractSeriesAggregator.__init__"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["def", "__init__", "(", "self", ",", "interleave_gaps", ":", "bool", "=", "True", ",", "nan_position", "=", "\"end\"", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        interleave_gaps: bool, optional\n            Whether None values should be added when there are gaps / irregularly\n            sampled data. A quantile-based approach is used to determine the gaps /\n            irregularly sampled data. By default, True.\n        nan_position: str, optional\n            Indicates where nans must be placed when gaps are detected. \\n\n            If ``'end'``, the first point after a gap will be replaced with a\n            nan-value \\n\n            If ``'begin'``, the last point before a gap will be replaced with a\n            nan-value \\n\n            If ``'both'``, both the encompassing gap datapoints are replaced with\n            nan-values \\n\n            .. note::\n                This parameter only has an effect when ``interleave_gaps`` is set\n                to *True*.\n\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "interleave_gaps", ",", "\n", "nan_position", ",", "\n", "dtype_regex_list", "=", "[", "rf\"{dtype}\\d*\"", "for", "dtype", "in", "[", "\"float\"", ",", "\"int\"", ",", "\"uint\"", "]", "]", "\n", "+", "[", "\"category\"", ",", "\"bool\"", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.LTTB._aggregate": [[75, 112], ["pandas.Series", "s_i[].astype", "lttbc.downsample", "pandas.to_datetime().tz_convert", "lttbc.downsample", "idx.astype.astype.astype", "str", "data.astype.astype.astype", "str", "numpy.vectorize", "data.astype.astype.astype", "str", "pandas.to_datetime", "s_i.astype", "idx.astype.astype.astype"], "methods", ["None"], ["", "def", "_aggregate", "(", "self", ",", "s", ":", "pd", ".", "Series", ",", "n_out", ":", "int", ")", "->", "pd", ".", "Series", ":", "\n", "# if we have categorical data, LTTB will convert the categorical values into", "\n", "# their numeric codes, i.e., the index position of the category array", "\n", "        ", "s_v", "=", "s", ".", "cat", ".", "codes", ".", "values", "if", "str", "(", "s", ".", "dtype", ")", "==", "\"category\"", "else", "s", ".", "values", "\n", "s_i", "=", "s", ".", "index", ".", "values", "\n", "\n", "if", "s_i", ".", "dtype", ".", "type", "==", "np", ".", "datetime64", ":", "\n", "# lttbc does not support this datatype -> convert to int", "\n", "# (where the time is represented in ns)", "\n", "# REMARK:", "\n", "#   -> additional logic is needed to mitigate rounding errors ", "\n", "#   First, the start offset is subtracted, after which the input series", "\n", "#   is set in the already requested format, i.e. np.float64", "\n", "\n", "# NOTE -> Rounding errors can still persist, but this approach is already", "\n", "#         significantly less prone to it than the previos implementation.", "\n", "            ", "s_i0", "=", "s_i", "[", "0", "]", ".", "astype", "(", "np", ".", "int64", ")", "\n", "idx", ",", "data", "=", "lttbc", ".", "downsample", "(", "\n", "(", "s_i", ".", "astype", "(", "np", ".", "int64", ")", "-", "s_i0", ")", ".", "astype", "(", "np", ".", "float64", ")", ",", "s_v", ",", "n_out", "\n", ")", "\n", "\n", "# add the start-offset and convert back to datetime", "\n", "idx", "=", "pd", ".", "to_datetime", "(", "\n", "idx", ".", "astype", "(", "np", ".", "int64", ")", "+", "s_i0", ",", "unit", "=", "\"ns\"", ",", "utc", "=", "True", "\n", ")", ".", "tz_convert", "(", "s", ".", "index", ".", "tz", ")", "\n", "", "else", ":", "\n", "            ", "idx", ",", "data", "=", "lttbc", ".", "downsample", "(", "s_i", ",", "s_v", ",", "n_out", ")", "\n", "idx", "=", "idx", ".", "astype", "(", "s_i", ".", "dtype", ")", "\n", "\n", "", "if", "str", "(", "s", ".", "dtype", ")", "==", "\"category\"", ":", "\n", "# reconvert the downsampled numeric codes to the category array", "\n", "            ", "data", "=", "np", ".", "vectorize", "(", "s", ".", "dtype", ".", "categories", ".", "values", ".", "item", ")", "(", "data", ".", "astype", "(", "s_v", ".", "dtype", ")", ")", "\n", "", "else", ":", "\n", "# default case, use the series it's dtype as return type", "\n", "            ", "data", "=", "data", ".", "astype", "(", "s", ".", "dtype", ")", "\n", "\n", "", "return", "pd", ".", "Series", "(", "index", "=", "idx", ",", "data", "=", "data", ",", "name", "=", "str", "(", "s", ".", "name", ")", ",", "copy", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.MinMaxOverlapAggregator.__init__": [[131, 154], ["aggregation.aggregation_interface.AbstractSeriesAggregator.__init__"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["def", "__init__", "(", "self", ",", "interleave_gaps", ":", "bool", "=", "True", ",", "nan_position", "=", "\"end\"", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        interleave_gaps: bool, optional\n            Whether None values should be added when there are gaps / irregularly\n            sampled data. A quantile-based approach is used to determine the gaps /\n            irregularly sampled data. By default, True.\n        nan_position: str, optional\n            Indicates where nans must be placed when gaps are detected. \\n\n            If ``'end'``, the first point after a gap will be replaced with a\n            nan-value \\n\n            If ``'begin'``, the last point before a gap will be replaced with a\n            nan-value \\n\n            If ``'both'``, both the encompassing gap datapoints are replaced with\n            nan-values \\n\n            .. note::\n                This parameter only has an effect when ``interleave_gaps`` is set\n                to *True*.\n\n        \"\"\"", "\n", "# this downsampler supports all pd.Series dtypes", "\n", "super", "(", ")", ".", "__init__", "(", "interleave_gaps", ",", "nan_position", ",", "dtype_regex_list", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.MinMaxOverlapAggregator._aggregate": [[155, 184], ["math.ceil", "numpy.arange", "s.iloc[].values.reshape().argmin", "s.iloc[].values.reshape().argmax", "numpy.unique", "s.iloc[].values.reshape", "numpy.concatenate", "s.iloc[].values.reshape"], "methods", ["None"], ["", "def", "_aggregate", "(", "self", ",", "s", ":", "pd", ".", "Series", ",", "n_out", ":", "int", ")", "->", "pd", ".", "Series", ":", "\n", "# The block size 2x the bin size we also perform the ceil-operation", "\n", "# to ensure that the block_size =", "\n", "        ", "block_size", "=", "math", ".", "ceil", "(", "s", ".", "shape", "[", "0", "]", "/", "(", "n_out", "+", "1", ")", "*", "2", ")", "\n", "argmax_offset", "=", "block_size", "//", "2", "\n", "\n", "# Calculate the offset range which will be added to the argmin and argmax pos", "\n", "offset", "=", "np", ".", "arange", "(", "\n", "0", ",", "stop", "=", "s", ".", "shape", "[", "0", "]", "-", "block_size", "-", "argmax_offset", ",", "step", "=", "block_size", "\n", ")", "\n", "\n", "# Calculate the argmin & argmax on the reshaped view of `s` &", "\n", "# add the corresponding offset", "\n", "argmin", "=", "(", "\n", "s", ".", "iloc", "[", ":", "block_size", "*", "offset", ".", "shape", "[", "0", "]", "]", "\n", ".", "values", ".", "reshape", "(", "-", "1", ",", "block_size", ")", "\n", ".", "argmin", "(", "axis", "=", "1", ")", "\n", "+", "offset", "\n", ")", "\n", "argmax", "=", "(", "\n", "s", ".", "iloc", "[", "argmax_offset", ":", "block_size", "*", "offset", ".", "shape", "[", "0", "]", "+", "argmax_offset", "]", "\n", ".", "values", ".", "reshape", "(", "-", "1", ",", "block_size", ")", "\n", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "+", "offset", "\n", "+", "argmax_offset", "\n", ")", "\n", "# Sort the argmin & argmax (where we append the first and last index item)", "\n", "# and then slice the original series on these indexes.", "\n", "return", "s", ".", "iloc", "[", "np", ".", "unique", "(", "np", ".", "concatenate", "(", "(", "argmin", ",", "argmax", ",", "[", "0", ",", "s", ".", "shape", "[", "0", "]", "-", "1", "]", ")", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.MinMaxAggregator.__init__": [[198, 222], ["aggregation.aggregation_interface.AbstractSeriesAggregator.__init__"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["def", "__init__", "(", "self", ",", "interleave_gaps", ":", "bool", "=", "True", ",", "nan_position", "=", "\"end\"", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        interleave_gaps: bool, optional\n            Whether None values should be added when there are gaps / irregularly\n            sampled data. A quantile-based approach is used to determine the gaps /\n            irregularly sampled data. By default, True.\n        nan_position: str, optional\n            Indicates where nans must be placed when gaps are detected. \\n\n            If ``'end'``, the first point after a gap will be replaced with a\n            nan-value \\n\n            If ``'begin'``, the last point before a gap will be replaced with a\n            nan-value \\n\n            If ``'both'``, both the encompassing gap datapoints are replaced with\n            nan-values \\n\n            .. note::\n                This parameter only has an effect when ``interleave_gaps`` is set\n                to *True*.\n        dtype_regex_list: List[str], optional\n            List containing the regex matching the supported datatypes, by default None.\n        \"\"\"", "\n", "# this downsampler supports all pd.Series dtypes", "\n", "super", "(", ")", ".", "__init__", "(", "interleave_gaps", ",", "nan_position", ",", "dtype_regex_list", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.MinMaxAggregator._aggregate": [[223, 261], ["math.ceil", "numpy.arange", "s.iloc[].values.reshape().argmin", "s.iloc[].values.reshape().argmax", "numpy.unique", "s.iloc[].values.reshape", "s.iloc[].values.reshape", "numpy.concatenate"], "methods", ["None"], ["", "def", "_aggregate", "(", "self", ",", "s", ":", "pd", ".", "Series", ",", "n_out", ":", "int", ")", "->", "pd", ".", "Series", ":", "\n", "# The block size 2x the bin size we also perform the ceil-operation", "\n", "# to ensure that the block_size =", "\n", "        ", "block_size", "=", "math", ".", "ceil", "(", "s", ".", "shape", "[", "0", "]", "/", "n_out", "*", "2", ")", "\n", "\n", "# Calculate the offset range which will be added to the argmin and argmax pos", "\n", "offset", "=", "np", ".", "arange", "(", "0", ",", "stop", "=", "s", ".", "shape", "[", "0", "]", "-", "block_size", ",", "step", "=", "block_size", ")", "\n", "\n", "# Calculate the argmin & argmax on the reshaped view of `s` &", "\n", "# add the corresponding offset", "\n", "argmin", "=", "(", "\n", "s", ".", "iloc", "[", ":", "block_size", "*", "offset", ".", "shape", "[", "0", "]", "]", "\n", ".", "values", ".", "reshape", "(", "-", "1", ",", "block_size", ")", "\n", ".", "argmin", "(", "axis", "=", "1", ")", "\n", "+", "offset", "\n", ")", "\n", "argmax", "=", "(", "\n", "s", ".", "iloc", "[", ":", "block_size", "*", "offset", ".", "shape", "[", "0", "]", "]", "\n", ".", "values", ".", "reshape", "(", "-", "1", ",", "block_size", ")", "\n", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "+", "offset", "\n", ")", "\n", "\n", "# Note: the implementation below flips the array to search from", "\n", "# right-to left (as min or max will always usee the first same minimum item,", "\n", "# i.e. the most left item)", "\n", "# This however creates a large computational overhead -> we do not use this", "\n", "# implementation and suggest using the minmaxaggregator.", "\n", "# argmax = (", "\n", "#     (block_size - 1)", "\n", "#     - np.fliplr(", "\n", "#         s[: block_size * offset.shape[0]].values.reshape(-1, block_size)", "\n", "#     ).argmax(axis=1)", "\n", "# ) + offset", "\n", "\n", "# Sort the argmin & argmax (where we append the first and last index item)", "\n", "# and then slice the original series on these indexes.", "\n", "return", "s", ".", "iloc", "[", "np", ".", "unique", "(", "np", ".", "concatenate", "(", "(", "argmin", ",", "argmax", ",", "[", "0", ",", "s", ".", "shape", "[", "0", "]", "-", "1", "]", ")", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.EfficientLTTB.__init__": [[269, 297], ["aggregators.LTTB", "aggregators.MinMaxOverlapAggregator", "aggregation.aggregation_interface.AbstractSeriesAggregator.__init__"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["def", "__init__", "(", "self", ",", "interleave_gaps", ":", "bool", "=", "True", ",", "nan_position", "=", "\"end\"", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        interleave_gaps: bool, optional\n            Whether None values should be added when there are gaps / irregularly\n            sampled data. A quantile-based approach is used to determine the gaps /\n            irregularly sampled data. By default, True.\n        nan_position: str, optional\n            Indicates where nans must be placed when gaps are detected. \\n\n            If ``'end'``, the first point after a gap will be replaced with a\n            nan-value \\n\n            If ``'begin'``, the last point before a gap will be replaced with a\n            nan-value \\n\n            If ``'both'``, both the encompassing gap datapoints are replaced with\n            nan-values \\n\n            .. note::\n                This parameter only has an effect when ``interleave_gaps`` is set\n                to *True*.\n\n        \"\"\"", "\n", "self", ".", "lttb", "=", "LTTB", "(", "interleave_gaps", "=", "False", ")", "\n", "self", ".", "minmax", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "False", ")", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "interleave_gaps", ",", "\n", "nan_position", ",", "\n", "dtype_regex_list", "=", "[", "rf\"{dtype}\\d*\"", "for", "dtype", "in", "[", "\"float\"", ",", "\"int\"", ",", "\"uint\"", "]", "]", "\n", "+", "[", "\"category\"", ",", "\"bool\"", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.EfficientLTTB._aggregate": [[299, 303], ["aggregators.EfficientLTTB.lttb._aggregate", "aggregators.EfficientLTTB.minmax._aggregate"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._aggregate"], ["", "def", "_aggregate", "(", "self", ",", "s", ":", "pd", ".", "Series", ",", "n_out", ":", "int", ")", "->", "pd", ".", "Series", ":", "\n", "        ", "if", "s", ".", "shape", "[", "0", "]", ">", "n_out", "*", "1_000", ":", "\n", "            ", "s", "=", "self", ".", "minmax", ".", "_aggregate", "(", "s", ",", "n_out", "*", "50", ")", "\n", "", "return", "self", ".", "lttb", ".", "_aggregate", "(", "s", ",", "n_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.EveryNthPoint.__init__": [[308, 331], ["aggregation.aggregation_interface.AbstractSeriesAggregator.__init__"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["def", "__init__", "(", "self", ",", "interleave_gaps", ":", "bool", "=", "True", ",", "nan_position", "=", "\"end\"", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        interleave_gaps: bool, optional\n            Whether None values should be added when there are gaps / irregularly\n            sampled data. A quantile-based approach is used to determine the gaps /\n            irregularly sampled data. By default, True.\n        nan_position: str, optional\n            Indicates where nans must be placed when gaps are detected. \\n\n            If ``'end'``, the first point after a gap will be replaced with a\n            nan-value \\n\n            If ``'begin'``, the last point before a gap will be replaced with a\n            nan-value \\n\n            If ``'both'``, both the encompassing gap datapoints are replaced with\n            nan-values \\n\n            .. note::\n                This parameter only has an effect when ``interleave_gaps`` is set\n                to *True*.\n\n        \"\"\"", "\n", "# this downsampler supports all pd.Series dtypes", "\n", "super", "(", ")", ".", "__init__", "(", "interleave_gaps", ",", "nan_position", ",", "dtype_regex_list", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.EveryNthPoint._aggregate": [[332, 334], ["max", "math.ceil", "len"], "methods", ["None"], ["", "def", "_aggregate", "(", "self", ",", "s", ":", "pd", ".", "Series", ",", "n_out", ":", "int", ")", "->", "pd", ".", "Series", ":", "\n", "        ", "return", "s", "[", ":", ":", "max", "(", "1", ",", "math", ".", "ceil", "(", "len", "(", "s", ")", "/", "n_out", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.FuncAggregator.__init__": [[346, 379], ["aggregation.aggregation_interface.AbstractSeriesAggregator.__init__"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "aggregation_func", ",", "\n", "interleave_gaps", ":", "bool", "=", "True", ",", "\n", "nan_position", "=", "\"end\"", ",", "\n", "dtype_regex_list", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        aggregation_func: Callable\n            The aggregation function which will be applied on each pin.\n        interleave_gaps: bool, optional\n            Whether None values should be added when there are gaps / irregularly\n            sampled data. A quantile-based approach is used to determine the gaps /\n            irregularly sampled data. By default, True.\n        nan_position: str, optional\n            Indicates where nans must be placed when gaps are detected. \\n\n            If ``'end'``, the first point after a gap will be replaced with a\n            nan-value \\n\n            If ``'begin'``, the last point before a gap will be replaced with a\n            nan-value \\n\n            If ``'both'``, both the encompassing gap datapoints are replaced with\n            nan-values \\n\n            .. note::\n                This parameter only has an effect when ``interleave_gaps`` is set\n                to *True*.\n        dtype_regex_list: List[str], optional\n            List containing the regex matching the supported datatypes, by default None.\n\n        \"\"\"", "\n", "self", ".", "aggregation_func", "=", "aggregation_func", "\n", "super", "(", ")", ".", "__init__", "(", "interleave_gaps", ",", "nan_position", ",", "dtype_regex_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregators.FuncAggregator._aggregate": [[380, 409], ["isinstance", "max", "s.groupby().agg().dropna", "pandas.Series", "s.resample().apply().dropna", "numpy.ceil", "len", "s.groupby().agg", "numpy.arange", "s.iloc[].index.astype", "str", "s.resample().apply", "len", "len", "len", "s.groupby", "s.resample", "numpy.repeat", "idx_locs.astype", "numpy.arange", "len"], "methods", ["None"], ["", "def", "_aggregate", "(", "self", ",", "s", ":", "pd", ".", "Series", ",", "n_out", ":", "int", ")", "->", "pd", ".", "Series", ":", "\n", "        ", "if", "isinstance", "(", "s", ".", "index", ",", "pd", ".", "DatetimeIndex", ")", ":", "\n", "            ", "t_start", ",", "t_end", "=", "s", ".", "index", "[", ":", ":", "len", "(", "s", ")", "-", "1", "]", "\n", "rate", "=", "(", "t_end", "-", "t_start", ")", "/", "n_out", "\n", "return", "s", ".", "resample", "(", "rate", ")", ".", "apply", "(", "self", ".", "aggregation_func", ")", ".", "dropna", "(", ")", "\n", "\n", "# no time index -> use the every nth heuristic", "\n", "", "group_size", "=", "max", "(", "1", ",", "np", ".", "ceil", "(", "len", "(", "s", ")", "/", "n_out", ")", ")", "\n", "s_out", "=", "(", "\n", "s", ".", "groupby", "(", "\n", "# create an array of [0, 0, 0, ...., n_out, n_out]", "\n", "# where each value is repeated based $len(s)/n_out$ times", "\n", "by", "=", "np", ".", "repeat", "(", "np", ".", "arange", "(", "n_out", ")", ",", "group_size", ")", "[", ":", "len", "(", "s", ")", "]", "\n", ")", "\n", ".", "agg", "(", "self", ".", "aggregation_func", ")", "\n", ".", "dropna", "(", ")", "\n", ")", "\n", "# Create an index-estimation for real-time data", "\n", "# Add one to the index so it's pointed at the end of the window", "\n", "# Note: this can be adjusted to .5 to center the data", "\n", "# Multiply it with the group size to get the real index-position", "\n", "# TODO: add option to select start / middle / end as index", "\n", "idx_locs", "=", "(", "np", ".", "arange", "(", "len", "(", "s_out", ")", ")", "+", "1", ")", "*", "group_size", "\n", "idx_locs", "[", "-", "1", "]", "=", "len", "(", "s", ")", "-", "1", "\n", "return", "pd", ".", "Series", "(", "\n", "index", "=", "s", ".", "iloc", "[", "idx_locs", ".", "astype", "(", "s", ".", "index", ".", "dtype", ")", "]", ".", "index", ".", "astype", "(", "s", ".", "index", ".", "dtype", ")", ",", "\n", "data", "=", "s_out", ".", "values", ",", "\n", "name", "=", "str", "(", "s", ".", "name", ")", ",", "\n", "copy", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.__init__": [[16, 49], ["nan_position.lower", "abc.ABC.__init__"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "interleave_gaps", ":", "bool", "=", "True", ",", "\n", "nan_position", ":", "str", "=", "\"end\"", ",", "\n", "dtype_regex_list", ":", "List", "[", "str", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Constructor of AbstractSeriesAggregator.\n\n        Parameters\n        ----------\n        interleave_gaps: bool, optional\n            Whether None values should be added when there are gaps / irregularly\n            sampled data. A quantile-based approach is used to determine the gaps /\n            irregularly sampled data. By default, True.\n        nan_position: str, optional\n            Indicates where nans must be placed when gaps are detected. \\n\n            If ``'end'``, the first point after a gap will be replaced with a \n            nan-value \\n\n            If ``'begin'``, the last point before a gap will be replaced with a \n            nan-value \\n\n            If ``'both'``, both the encompassing gap datapoints are replaced with \n            nan-values \\n\n            .. note::\n                This parameter only has an effect when ``interleave_gaps`` is set \n                to *True*.\n        dtype_regex_list: List[str], optional\n            List containing the regex matching the supported datatypes, by default None.\n\n        \"\"\"", "\n", "self", ".", "interleave_gaps", "=", "interleave_gaps", "\n", "self", ".", "dtype_regex_list", "=", "dtype_regex_list", "\n", "self", ".", "nan_position", "=", "nan_position", ".", "lower", "(", ")", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._aggregate": [[50, 53], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_aggregate", "(", "self", ",", "s", ":", "pd", ".", "Series", ",", "n_out", ":", "int", ")", "->", "pd", ".", "Series", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._supports_dtype": [[54, 65], ["ValueError", "re.compile().match", "str", "re.compile"], "methods", ["None"], ["", "def", "_supports_dtype", "(", "self", ",", "s", ":", "pd", ".", "Series", ")", ":", "\n", "# base case", "\n", "        ", "if", "self", ".", "dtype_regex_list", "is", "None", ":", "\n", "            ", "return", "\n", "\n", "", "for", "dtype_regex_str", "in", "self", ".", "dtype_regex_list", ":", "\n", "            ", "m", "=", "re", ".", "compile", "(", "dtype_regex_str", ")", ".", "match", "(", "str", "(", "s", ".", "dtype", ")", ")", "\n", "if", "m", "is", "not", "None", ":", "# a match is found", "\n", "                ", "return", "\n", "", "", "raise", "ValueError", "(", "\n", "f\"{s.dtype} doesn't match with any regex in {self.dtype_regex_list}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._calc_med_diff": [[67, 89], ["numpy.diff", "s_idx_diff[].reshape", "numpy.median", "numpy.median", "numpy.mean"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_calc_med_diff", "(", "s", ":", "pd", ".", "Series", ")", "->", "Tuple", "[", "float", ",", "np", ".", "ndarray", "]", ":", "\n", "# ----- divide and conquer heuristic to calculate the median diff ------", "\n", "# remark: thanks to the prepend -> s_idx_diff.shape === len(s)", "\n", "        ", "siv", "=", "s", ".", "index", ".", "values", "\n", "s_idx_diff", "=", "np", ".", "diff", "(", "s", ".", "index", ".", "values", ",", "prepend", "=", "siv", "[", "0", "]", ")", "\n", "\n", "# To do so - use a quantile-based (median) approach where we reshape the data", "\n", "# into `n_blocks` blocks and calculate the min", "\n", "n_blcks", "=", "128", "\n", "if", "s", ".", "shape", "[", "0", "]", ">", "5", "*", "n_blcks", ":", "\n", "            ", "blck_size", "=", "s_idx_diff", ".", "shape", "[", "0", "]", "//", "n_blcks", "\n", "\n", "# convert the index series index diff into a reshaped view (i.e., sid_v)", "\n", "sid_v", ":", "np", ".", "ndarray", "=", "s_idx_diff", "[", ":", "blck_size", "*", "n_blcks", "]", ".", "reshape", "(", "n_blcks", ",", "-", "1", ")", "\n", "\n", "# calculate the min and max and calculate the median on that", "\n", "med_diff", "=", "np", ".", "median", "(", "np", ".", "mean", "(", "sid_v", ",", "axis", "=", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "med_diff", "=", "np", ".", "median", "(", "s_idx_diff", ")", "\n", "\n", "", "return", "med_diff", ",", "s_idx_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._insert_gap_none": [[90, 116], ["aggregation_interface.AbstractSeriesAggregator._calc_med_diff", "len", "pandas.Series", "isinstance", "pandas.concat().sort_index", "pandas.Series.index.tz_localize().tz_convert", "pandas.concat", "pandas.Series.index.tz_localize"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._calc_med_diff"], ["", "def", "_insert_gap_none", "(", "self", ",", "s", ":", "pd", ".", "Series", ")", "->", "pd", ".", "Series", ":", "\n", "# ------- INSERT None between gaps / irregularly sampled data -------", "\n", "        ", "med_diff", ",", "s_idx_diff", "=", "self", ".", "_calc_med_diff", "(", "s", ")", "\n", "# add None data-points in-between the gaps", "\n", "if", "med_diff", "is", "not", "None", ":", "\n", "            ", "df_gap_idx", "=", "s", ".", "index", ".", "values", "[", "s_idx_diff", ">", "3", "*", "med_diff", "]", "\n", "if", "len", "(", "df_gap_idx", ")", ":", "\n", "                ", "df_res_gap", "=", "pd", ".", "Series", "(", "\n", "index", "=", "df_gap_idx", ",", "data", "=", "None", ",", "name", "=", "s", ".", "name", ",", "copy", "=", "False", "\n", ")", "\n", "\n", "if", "isinstance", "(", "df_res_gap", ".", "index", ",", "pd", ".", "DatetimeIndex", ")", ":", "\n", "# Due to the s.index`.values` cast, df_res_gap has lost", "\n", "# time-information, so now we restore it", "\n", "                    ", "df_res_gap", ".", "index", "=", "df_res_gap", ".", "index", ".", "tz_localize", "(", "\"UTC\"", ")", ".", "tz_convert", "(", "\n", "s", ".", "index", ".", "tz", "\n", ")", "\n", "\n", "# Note:", "\n", "#  * the order of pd.concat is important for correct visualization", "\n", "#  * we also need a stable algorithm for sorting, i.e., the equal-index", "\n", "#    data-entries their order will be maintained.", "\n", "", "s", "=", "pd", ".", "concat", "(", "[", "df_res_gap", ",", "s", "]", ",", "ignore_index", "=", "False", ")", ".", "sort_index", "(", "\n", "kind", "=", "\"mergesort\"", "\n", ")", "\n", "", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._replace_gap_end_none": [[117, 132], ["aggregation_interface.AbstractSeriesAggregator._calc_med_diff", "numpy.roll", "numpy.roll"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._calc_med_diff"], ["", "def", "_replace_gap_end_none", "(", "self", ",", "s", ":", "pd", ".", "Series", ")", "->", "pd", ".", "Series", ":", "\n", "# ------- REPLACE None where a gap ends -------", "\n", "        ", "med_diff", ",", "s_idx_diff", "=", "self", ".", "_calc_med_diff", "(", "s", ")", "\n", "if", "med_diff", "is", "not", "None", ":", "\n", "# Replace data-points with None where the gaps occur", "\n", "# The default is the end of a gap", "\n", "            ", "nan_mask", "=", "s_idx_diff", ">", "4", "*", "med_diff", "\n", "if", "self", ".", "nan_position", "==", "\"begin\"", ":", "\n", "# Replace the last non-gap datapoint (begin of gap) with Nan", "\n", "                ", "nan_mask", "=", "np", ".", "roll", "(", "nan_mask", ",", "-", "1", ")", "\n", "", "elif", "self", ".", "nan_position", "==", "\"both\"", ":", "\n", "# Replace the encompassing gap datapoints with Nan", "\n", "                ", "nan_mask", "|=", "np", ".", "roll", "(", "nan_mask", ",", "-", "1", ")", "\n", "", "s", ".", "loc", "[", "nan_mask", "]", "=", "None", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate": [[133, 173], ["aggregation_interface.AbstractSeriesAggregator._supports_dtype", "len", "aggregation_interface.AbstractSeriesAggregator._aggregate", "aggregation_interface.AbstractSeriesAggregator._replace_gap_end_none", "aggregation_interface.AbstractSeriesAggregator._insert_gap_none"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._supports_dtype", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._replace_gap_end_none", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._insert_gap_none"], ["", "def", "aggregate", "(", "self", ",", "s", ":", "pd", ".", "Series", ",", "n_out", ":", "int", ")", "->", "pd", ".", "Series", ":", "\n", "        ", "\"\"\"Aggregate (downsample) the given input series to the given n_out samples.\n\n        Parameters\n        ----------\n        s: pd.Series\n            The series that has to be aggregated.\n        n_out: int\n            The number of samples that the downsampled series should contain.\n\n        Returns\n        -------\n        pd.Series\n            The aggregated series.\n\n        \"\"\"", "\n", "# base case: the passed series is empty", "\n", "if", "s", ".", "empty", ":", "\n", "            ", "return", "s", "\n", "\n", "", "self", ".", "_supports_dtype", "(", "s", ")", "\n", "\n", "if", "len", "(", "s", ")", ">", "n_out", ":", "\n", "# More samples that n_out -> perform data aggregation", "\n", "            ", "s", "=", "self", ".", "_aggregate", "(", "s", ",", "n_out", "=", "n_out", ")", "\n", "\n", "# When data aggregation is performed -> we do not \"insert\" gaps but replace", "\n", "# The end of gap periods (i.e. the first non-gap sample) with None to", "\n", "# induce such gaps", "\n", "if", "self", ".", "interleave_gaps", ":", "\n", "                ", "s", "=", "self", ".", "_replace_gap_end_none", "(", "s", ")", "\n", "", "", "else", ":", "\n", "# Less samples than n_out -> no data aggregation need to be performed", "\n", "\n", "# on the raw data -> gaps are inserted instead of replaced; i.e., we show", "\n", "# all data points and do not omit data-points with None", "\n", "            ", "if", "self", ".", "interleave_gaps", ":", "\n", "                ", "s", "=", "self", ".", "_insert_gap_none", "(", "s", ")", "\n", "\n", "", "", "return", "s", "\n", "", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.examples.helper.groupby_consecutive": [[6, 56], ["pandas.DataFrame().reset_index", "pd.DataFrame().reset_index.start.shift().fillna", "type", "df.to_frame.to_frame", "pandas.DataFrame", "pd.DataFrame().reset_index.start.shift", "[].first", "[].last", "df_cum.groupby().size", "[].first", "df_cum.groupby", "df_cum.groupby", "df_cum.groupby", "df_cum.groupby", "df[].diff"], "function", ["None"], ["def", "groupby_consecutive", "(", "\n", "df", ":", "Union", "[", "pd", ".", "Series", ",", "pd", ".", "DataFrame", "]", ",", "col_name", ":", "str", "=", "None", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "\"\"\"Merges consecutive `column_name` values in a single dataframe.\n\n    This is especially useful if you want to represent sparse data in a more\n    compact format.\n\n    Parameters\n    ----------\n    df : Union[pd.Series, pd.DataFrame]\n        Must be time-indexed!\n    col_name : str, optional\n        If a dataFrame is passed, you will need to specify the `col_name` on which\n        the consecutive-grouping will need to take plase.\n\n    Returns\n    -------\n    pd.DataFrame\n        A new `DataFrame` view, with columns:\n        [`start`, `end`, `n_consecutive`, `col_name`], representing the\n        start- and endtime of the consecutive range, the number of consecutive samples,\n        and the col_name's consecutive values.\n    \"\"\"", "\n", "if", "type", "(", "df", ")", "==", "pd", ".", "Series", ":", "\n", "        ", "col_name", "=", "df", ".", "name", "\n", "df", "=", "df", ".", "to_frame", "(", ")", "\n", "\n", "", "assert", "col_name", "in", "df", ".", "columns", "\n", "\n", "df_cum", "=", "(", "\n", "(", "df", "[", "col_name", "]", ".", "diff", "(", "1", ")", "!=", "0", ")", "\n", ".", "astype", "(", "\"int\"", ")", "\n", ".", "cumsum", "(", ")", "\n", ".", "rename", "(", "\"value_grp\"", ")", "\n", ".", "to_frame", "(", ")", "\n", ")", "\n", "df_cum", "[", "\"sequence_idx\"", "]", "=", "df", ".", "index", "\n", "df_cum", "[", "col_name", "]", "=", "df", "[", "col_name", "]", "\n", "\n", "df_grouped", "=", "pd", ".", "DataFrame", "(", "\n", "{", "\n", "\"start\"", ":", "df_cum", ".", "groupby", "(", "\"value_grp\"", ")", "[", "\"sequence_idx\"", "]", ".", "first", "(", ")", ",", "\n", "\"end\"", ":", "df_cum", ".", "groupby", "(", "\"value_grp\"", ")", "[", "\"sequence_idx\"", "]", ".", "last", "(", ")", ",", "\n", "\"n_consecutive\"", ":", "df_cum", ".", "groupby", "(", "\"value_grp\"", ")", ".", "size", "(", ")", ",", "\n", "col_name", ":", "df_cum", ".", "groupby", "(", "\"value_grp\"", ")", "[", "col_name", "]", ".", "first", "(", ")", ",", "\n", "}", "\n", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "df_grouped", "[", "\"next_start\"", "]", "=", "df_grouped", ".", "start", ".", "shift", "(", "-", "1", ")", ".", "fillna", "(", "df_grouped", "[", "\"end\"", "]", ")", "\n", "return", "df_grouped", "\n", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app.serve_layout": [[52, 89], ["dash_bootstrap_components.Container", "dash_bootstrap_components.Container", "dash.html.Hr", "dash_bootstrap_components.Row", "dash.html.H1", "dash_bootstrap_components.Col", "dash_bootstrap_components.Col", "callback_helpers.multiple_folder_file_selector", "dash.dcc.Graph", "trace_updater.TraceUpdater", "plotly.Figure"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.callback_helpers.multiple_folder_file_selector"], ["def", "serve_layout", "(", ")", "->", "dbc", ".", "Container", ":", "\n", "    ", "\"\"\"Constructs the app's layout.\n\n    Returns\n    -------\n    dbc.Container\n        A Container withholding the layout.\n\n    \"\"\"", "\n", "return", "dbc", ".", "Container", "(", "\n", "[", "\n", "dbc", ".", "Container", "(", "\n", "html", ".", "H1", "(", "\"Data loading and visualization dashboard\"", ")", ",", "\n", "style", "=", "{", "\"textAlign\"", ":", "\"center\"", "}", ",", "\n", ")", ",", "\n", "html", ".", "Hr", "(", ")", ",", "\n", "dbc", ".", "Row", "(", "\n", "[", "\n", "# Add file selection layout (+ assign callbacks)", "\n", "dbc", ".", "Col", "(", "multiple_folder_file_selector", "(", "app", ",", "name_folder_list", ")", ",", "md", "=", "2", ")", ",", "\n", "# Add the graph and the trace updater component", "\n", "dbc", ".", "Col", "(", "\n", "[", "\n", "dcc", ".", "Graph", "(", "id", "=", "\"graph-id\"", ",", "figure", "=", "go", ".", "Figure", "(", ")", ")", ",", "\n", "trace_updater", ".", "TraceUpdater", "(", "\n", "id", "=", "\"trace-updater\"", ",", "\n", "gdID", "=", "\"graph-id\"", ",", "\n", "sequentialUpdate", "=", "False", ",", "\n", ")", ",", "\n", "]", ",", "\n", "md", "=", "10", ",", "\n", ")", ",", "\n", "]", ",", "\n", "align", "=", "\"center\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", "fluid", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app.plot_multiple_files": [[102, 132], ["fig.replace", "fig.update_layout", "enumerate", "plotly.subplots.make_subplots", "pandas.read_parquet", "min", "df.set_index.set_index", "fig.add_trace", "len", "plotly.Scattergl", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["def", "plot_multiple_files", "(", "file_list", ":", "List", "[", "Union", "[", "str", ",", "Path", "]", "]", ")", "->", "FigureResampler", ":", "\n", "    ", "\"\"\"Code to create the visualizations.\n\n    Parameters\n    ----------\n    file_list: List[Union[str, Path]]\n\n    Returns\n    -------\n    FigureResampler\n        Returns a view of the existing, global FigureResampler object.\n\n    \"\"\"", "\n", "global", "fig", "\n", "\n", "# NOTE, we do not construct a new FigureResampler object, but replace the figure of ", "\n", "# the figureResampler object. Otherwise the coupled callbacks would be lost and it", "\n", "# is not (straightforward) to construct dynamic callbacks in dash.", "\n", "\n", "fig", ".", "replace", "(", "make_subplots", "(", "rows", "=", "len", "(", "file_list", ")", ",", "shared_xaxes", "=", "False", ")", ")", "\n", "fig", ".", "update_layout", "(", "height", "=", "min", "(", "900", ",", "350", "*", "len", "(", "file_list", ")", ")", ")", "\n", "\n", "for", "i", ",", "f", "in", "enumerate", "(", "file_list", ",", "1", ")", ":", "\n", "        ", "df", "=", "pd", ".", "read_parquet", "(", "f", ")", "# should be replaced by more generic data loading code", "\n", "if", "\"timestamp\"", "in", "df", ".", "columns", ":", "\n", "            ", "df", "=", "df", ".", "set_index", "(", "\"timestamp\"", ")", "\n", "\n", "", "for", "c", "in", "df", ".", "columns", ":", "\n", "            ", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "c", ")", ",", "hf_x", "=", "df", ".", "index", ",", "hf_y", "=", "df", "[", "c", "]", ",", "row", "=", "i", ",", "col", "=", "1", ")", "\n", "", "", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app.plot_graph": [[149, 173], ["app.callback", "iter", "zip", "dash.Output", "len", "len", "dash.exceptions.PreventUpdate", "dash.Input", "all", "dash_app.plot_multiple_files", "file_list.append", "pathlib.Path().joinpath", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app_coarse_fine.plot_multiple_files"], ["@", "app", ".", "callback", "(", "\n", "Output", "(", "\"graph-id\"", ",", "\"figure\"", ")", ",", "\n", "[", "Input", "(", "\"plot-button\"", ",", "\"n_clicks\"", ")", ",", "*", "selector_states", "]", ",", "\n", "prevent_initial_call", "=", "True", ",", "\n", ")", "\n", "def", "plot_graph", "(", "\n", "n_clicks", ",", "\n", "*", "folder_list", ",", "\n", ")", ":", "\n", "    ", "it", "=", "iter", "(", "folder_list", ")", "\n", "file_list", ":", "List", "[", "Path", "]", "=", "[", "]", "\n", "for", "folder", ",", "files", "in", "zip", "(", "it", ",", "it", ")", ":", "\n", "        ", "if", "not", "all", "(", "(", "folder", ",", "files", ")", ")", ":", "\n", "            ", "continue", "\n", "", "else", ":", "\n", "            ", "for", "file", "in", "files", ":", "\n", "                ", "file_list", ".", "append", "(", "(", "Path", "(", "folder", ")", ".", "joinpath", "(", "file", ")", ")", ")", "\n", "\n", "", "", "", "ctx", "=", "dash", ".", "callback_context", "\n", "if", "len", "(", "ctx", ".", "triggered", ")", "and", "\"plot-button\"", "in", "ctx", ".", "triggered", "[", "0", "]", "[", "\"prop_id\"", "]", ":", "\n", "        ", "if", "len", "(", "file_list", ")", ":", "\n", "            ", "return", "plot_multiple_files", "(", "file_list", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "dash", ".", "exceptions", ".", "PreventUpdate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app_coarse_fine.serve_layout": [[57, 105], ["dash_bootstrap_components.Container", "dash_bootstrap_components.Container", "dash.html.Hr", "dash_bootstrap_components.Row", "dash.html.H1", "dash_bootstrap_components.Col", "dash_bootstrap_components.Col", "callback_helpers.multiple_folder_file_selector", "dash.dcc.Graph", "dash.dcc.Graph", "trace_updater.TraceUpdater", "plotly.Figure", "plotly.Figure"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.callback_helpers.multiple_folder_file_selector"], ["def", "serve_layout", "(", ")", "->", "dbc", ".", "Container", ":", "\n", "    ", "\"\"\"Constructs the app's layout.\n\n    Returns\n    -------\n    dbc.Container\n        A Container withholding the layout.\n\n    \"\"\"", "\n", "return", "dbc", ".", "Container", "(", "\n", "[", "\n", "dbc", ".", "Container", "(", "\n", "html", ".", "H1", "(", "\"Data visualization - coarse & dynamic graph\"", ")", ",", "\n", "style", "=", "{", "\"textAlign\"", ":", "\"center\"", "}", ",", "\n", ")", ",", "\n", "html", ".", "Hr", "(", ")", ",", "\n", "dbc", ".", "Row", "(", "\n", "[", "\n", "# Add file selection layout (+ assign callbacks)", "\n", "dbc", ".", "Col", "(", "\n", "multiple_folder_file_selector", "(", "\n", "app", ",", "name_folder_list", ",", "multi", "=", "False", "\n", ")", ",", "\n", "md", "=", "2", ",", "\n", ")", ",", "\n", "# Add the graphs and the trace updater component", "\n", "dbc", ".", "Col", "(", "\n", "[", "\n", "# The coarse graph whose updates will fetch data for the", "\n", "# broad graph", "\n", "dcc", ".", "Graph", "(", "\n", "id", "=", "\"coarse-graph\"", ",", "\n", "figure", "=", "go", ".", "Figure", "(", ")", ",", "\n", "config", "=", "{", "\"modeBarButtonsToAdd\"", ":", "[", "\"drawrect\"", "]", "}", ",", "\n", ")", ",", "\n", "dcc", ".", "Graph", "(", "id", "=", "\"plotly-resampler-graph\"", ",", "figure", "=", "go", ".", "Figure", "(", ")", ")", ",", "\n", "# The broad graph", "\n", "trace_updater", ".", "TraceUpdater", "(", "\n", "id", "=", "\"trace-updater\"", ",", "gdID", "=", "\"plotly-resampler-graph\"", "\n", ")", ",", "\n", "]", ",", "\n", "md", "=", "10", ",", "\n", ")", ",", "\n", "]", ",", "\n", "align", "=", "\"center\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", "fluid", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app_coarse_fine.update_dynamic_fig": [[112, 136], ["app.callback", "dash.Output", "dash.Input", "dash.Input", "ctx.triggered[].get().split", "fr_fig.construct_update_data", "coarse_grained_relayout.keys", "fr_fig._re_matches", "len", "ctx.triggered[].get", "print", "re.compile", "fr_fig.construct_update_data"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.construct_update_data", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._re_matches", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.construct_update_data"], ["@", "app", ".", "callback", "(", "\n", "Output", "(", "\"trace-updater\"", ",", "\"updateData\"", ")", ",", "\n", "Input", "(", "\"coarse-graph\"", ",", "\"relayoutData\"", ")", ",", "\n", "Input", "(", "\"plotly-resampler-graph\"", ",", "\"relayoutData\"", ")", ",", "\n", "prevent_initial_call", "=", "True", ",", "\n", ")", "\n", "def", "update_dynamic_fig", "(", "coarse_grained_relayout", ",", "fine_grained_relayout", ")", ":", "\n", "    ", "global", "fr_fig", "\n", "\n", "ctx", "=", "dash", ".", "callback_context", "\n", "trigger_id", "=", "ctx", ".", "triggered", "[", "0", "]", ".", "get", "(", "\"prop_id\"", ",", "\"\"", ")", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "\n", "if", "trigger_id", "==", "\"plotly-resampler-graph\"", ":", "\n", "        ", "return", "fr_fig", ".", "construct_update_data", "(", "fine_grained_relayout", ")", "\n", "", "elif", "trigger_id", "==", "\"coarse-graph\"", ":", "\n", "        ", "if", "\"shapes\"", "in", "coarse_grained_relayout", ":", "\n", "            ", "print", "(", "coarse_grained_relayout", ")", "\n", "", "cl_k", "=", "coarse_grained_relayout", ".", "keys", "(", ")", "\n", "# We do not resample when and autorange / autosize event takes place", "\n", "matches", "=", "fr_fig", ".", "_re_matches", "(", "re", ".", "compile", "(", "r\"xaxis\\d*.range\\[0]\"", ")", ",", "cl_k", ")", "\n", "if", "len", "(", "matches", ")", ":", "\n", "            ", "return", "fr_fig", ".", "construct_update_data", "(", "coarse_grained_relayout", ")", "\n", "\n", "", "", "return", "dash", ".", "no_update", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app_coarse_fine.plot_multiple_files": [[139, 169], ["fr_fig.replace", "fr_fig.update_layout", "plotly.Figure", "pandas.read_parquet", "min", "df.set_index.set_index", "fr_fig.add_trace", "plotly.Scatter", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "plot_multiple_files", "(", "file_list", ":", "List", "[", "Union", "[", "str", ",", "Path", "]", "]", ")", "->", "FigureResampler", ":", "\n", "    ", "\"\"\"Code to create the visualizations.\n\n    Parameters\n    ----------\n    file_list: List[Union[str, Path]]\n\n    Returns\n    -------\n    FigureResampler\n        Returns a view of the existing, global FigureResampler object.\n\n    \"\"\"", "\n", "global", "fr_fig", "\n", "\n", "# NOTE, we do not construct a new FigureResampler object, but replace the figure of", "\n", "# the figureResampler object. Otherwise the coupled callbacks would be lost and it", "\n", "# is not (straightforward) to construct dynamic callbacks in dash.", "\n", "fr_fig", ".", "_global_n_shown_samples", "=", "3000", "\n", "fr_fig", ".", "replace", "(", "go", ".", "Figure", "(", ")", ")", "\n", "fr_fig", ".", "update_layout", "(", "height", "=", "min", "(", "900", ",", "350", "*", "len", "(", "file_list", ")", ")", ")", "\n", "\n", "for", "f", "in", "file_list", ":", "\n", "        ", "df", "=", "pd", ".", "read_parquet", "(", "f", ")", "# should be replaced by more generic data loading code", "\n", "if", "\"timestamp\"", "in", "df", ".", "columns", ":", "\n", "            ", "df", "=", "df", ".", "set_index", "(", "\"timestamp\"", ")", "\n", "\n", "", "for", "c", "in", "df", ".", "columns", ":", "\n", "            ", "fr_fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "name", "=", "c", ")", ",", "hf_x", "=", "df", ".", "index", ",", "hf_y", "=", "df", "[", "c", "]", ")", "\n", "", "", "return", "fr_fig", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app_coarse_fine.plot_graph": [[186, 231], ["app.callback", "iter", "zip", "dash.Output", "dash.Output", "len", "len", "dash.exceptions.PreventUpdate", "dash.Input", "all", "dash_app_coarse_fine.plot_multiple_files", "plotly.Figure", "go.Figure.update_layout", "go.Figure.update_layout", "go.Figure.update_layout", "go.Figure._config.update", "plot_multiple_files.update_layout", "plot_multiple_files.update_layout", "plot_multiple_files.update_layout", "file_list.append", "isinstance", "pathlib.Path().joinpath", "dict", "dict", "dict", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.dash_app_coarse_fine.plot_multiple_files"], ["@", "app", ".", "callback", "(", "\n", "Output", "(", "\"coarse-graph\"", ",", "\"figure\"", ")", ",", "\n", "Output", "(", "\"plotly-resampler-graph\"", ",", "\"figure\"", ")", ",", "\n", "[", "Input", "(", "\"plot-button\"", ",", "\"n_clicks\"", ")", ",", "*", "selector_states", "]", ",", "\n", "prevent_initial_call", "=", "True", ",", "\n", ")", "\n", "def", "plot_graph", "(", "\n", "n_clicks", ",", "\n", "*", "folder_list", ",", "\n", ")", ":", "\n", "    ", "it", "=", "iter", "(", "folder_list", ")", "\n", "file_list", ":", "List", "[", "Path", "]", "=", "[", "]", "\n", "for", "folder", ",", "files", "in", "zip", "(", "it", ",", "it", ")", ":", "\n", "        ", "if", "not", "all", "(", "(", "folder", ",", "files", ")", ")", ":", "\n", "            ", "continue", "\n", "", "else", ":", "\n", "            ", "files", "=", "[", "files", "]", "if", "not", "isinstance", "(", "files", ",", "list", ")", "else", "file_list", "\n", "for", "file", "in", "files", ":", "\n", "                ", "file_list", ".", "append", "(", "(", "Path", "(", "folder", ")", ".", "joinpath", "(", "file", ")", ")", ")", "\n", "\n", "", "", "", "ctx", "=", "dash", ".", "callback_context", "\n", "if", "len", "(", "ctx", ".", "triggered", ")", "and", "\"plot-button\"", "in", "ctx", ".", "triggered", "[", "0", "]", "[", "\"prop_id\"", "]", ":", "\n", "        ", "if", "len", "(", "file_list", ")", ":", "\n", "            ", "dynamic_fig", "=", "plot_multiple_files", "(", "file_list", ")", "\n", "coarse_fig", "=", "go", ".", "Figure", "(", "dynamic_fig", ")", "\n", "coarse_fig", ".", "update_layout", "(", "title", "=", "\"<b>coarse view</b>\"", ",", "height", "=", "250", ")", "\n", "coarse_fig", ".", "update_layout", "(", "margin", "=", "dict", "(", "l", "=", "0", ",", "r", "=", "0", ",", "b", "=", "0", ",", "t", "=", "40", ",", "pad", "=", "10", ")", ")", "\n", "coarse_fig", ".", "update_layout", "(", "showlegend", "=", "False", ")", "\n", "coarse_fig", ".", "_config", "=", "coarse_fig", ".", "_config", ".", "update", "(", "\n", "{", "\"modeBarButtonsToAdd\"", ":", "[", "\"drawrect\"", "]", "}", "\n", ")", "\n", "\n", "dynamic_fig", ".", "_global_n_shown_samples", "=", "1000", "\n", "dynamic_fig", ".", "update_layout", "(", "title", "=", "\"<b>dynamic view<b>\"", ",", "height", "=", "450", ")", "\n", "dynamic_fig", ".", "update_layout", "(", "margin", "=", "dict", "(", "l", "=", "0", ",", "r", "=", "0", ",", "b", "=", "40", ",", "t", "=", "40", ",", "pad", "=", "10", ")", ")", "\n", "dynamic_fig", ".", "update_layout", "(", "\n", "legend", "=", "dict", "(", "\n", "orientation", "=", "\"h\"", ",", "y", "=", "-", "0.11", ",", "xanchor", "=", "\"right\"", ",", "x", "=", "1", ",", "font_size", "=", "18", "\n", ")", "\n", ")", "\n", "\n", "# coarse_fig['layout'].update(dict(title='coarse view', title_x=0.5, height=250))", "\n", "return", "coarse_fig", ",", "dynamic_fig", "\n", "", "", "else", ":", "\n", "        ", "raise", "dash", ".", "exceptions", ".", "PreventUpdate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.construct_dynamic_figures.add_or_remove_graph": [[85, 145], ["app.callback", "len", "any", "numpy.arange", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.update_layout", "str", "dash.Output", "dash.Input", "dash.Input", "dash.exceptions.PreventUpdate", "range", "graph_dict.pop", "plotly.Figure", "plotly.Scattergl", "uuid.uuid4", "dash.dcc.Graph", "trace_updater.TraceUpdater", "dash.State", "dash.State", "dash.State", "_gc.append", "_gc.append", "len", "dash.exceptions.PreventUpdate", "gc[].__getattribute__", "numpy.sin", "dict", "len", "dash.dcc.Graph", "trace_updater.TraceUpdater", "numpy.random.randn", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["@", "app", ".", "callback", "(", "\n", "Output", "(", "\"graph-container\"", ",", "\"children\"", ")", ",", "\n", "Input", "(", "\"add-graph-btn\"", ",", "\"n_clicks\"", ")", ",", "\n", "Input", "(", "\"remove-graph-btn\"", ",", "\"n_clicks\"", ")", ",", "\n", "[", "\n", "State", "(", "\"nbr-datapoints\"", ",", "\"value\"", ")", ",", "\n", "State", "(", "\"expansion-factor\"", ",", "\"value\"", ")", ",", "\n", "State", "(", "\"graph-container\"", ",", "\"children\"", ")", ",", "\n", "]", ",", "\n", "prevent_initial_call", "=", "True", ",", "\n", ")", "\n", "def", "add_or_remove_graph", "(", "add_graph", ",", "remove_graph", ",", "n", ",", "exp", ",", "gc", ")", ":", "\n", "    ", "if", "(", "add_graph", "is", "None", "or", "n", "is", "None", "or", "exp", "is", "None", ")", "and", "(", "remove_graph", "is", "None", ")", ":", "\n", "        ", "raise", "PreventUpdate", "(", ")", "\n", "\n", "# Transform the graph data to a figure", "\n", "", "gc", "=", "[", "]", "if", "gc", "is", "None", "else", "gc", "# list of existing Graphs and their TraceUpdaters", "\n", "if", "len", "(", "gc", ")", ":", "\n", "        ", "_gc", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "gc", ")", "//", "2", ")", ":", "\n", "            ", "_gc", ".", "append", "(", "dcc", ".", "Graph", "(", "**", "gc", "[", "i", "*", "2", "]", "[", "\"props\"", "]", ")", ")", "\n", "_gc", ".", "append", "(", "\n", "TraceUpdater", "(", "**", "{", "k", ":", "gc", "[", "i", "*", "2", "+", "1", "]", "[", "\"props\"", "]", "[", "k", "]", "for", "k", "in", "[", "\"id\"", ",", "\"gdID\"", "]", "}", ")", "\n", ")", "\n", "", "gc", "=", "_gc", "\n", "\n", "# Check if we need to remove a graph", "\n", "", "clicked_btns", "=", "[", "p", "[", "\"prop_id\"", "]", "for", "p", "in", "dash", ".", "callback_context", ".", "triggered", "]", "\n", "if", "any", "(", "\"remove-graph\"", "in", "btn_name", "for", "btn_name", "in", "clicked_btns", ")", ":", "\n", "        ", "if", "not", "len", "(", "gc", ")", ":", "\n", "            ", "raise", "PreventUpdate", "(", ")", "\n", "\n", "", "graph_dict", ".", "pop", "(", "gc", "[", "-", "1", "]", ".", "__getattribute__", "(", "\"gdID\"", ")", ")", "\n", "return", "[", "*", "gc", "[", ":", "-", "2", "]", "]", "\n", "\n", "# No graph needs to be removed -> create a new graph", "\n", "", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "expansion_scaling", "=", "exp", "**", "x", "\n", "y", "=", "np", ".", "sin", "(", "x", "/", "10", ")", "*", "expansion_scaling", "+", "np", ".", "random", ".", "randn", "(", "n", ")", "/", "10", "*", "expansion_scaling", "\n", "\n", "fr", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ",", "verbose", "=", "True", ")", "\n", "fr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"sin\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "fr", ".", "update_layout", "(", "\n", "height", "=", "350", ",", "\n", "showlegend", "=", "True", ",", "\n", "legend", "=", "dict", "(", "orientation", "=", "\"h\"", ",", "y", "=", "1.12", ",", "xanchor", "=", "\"right\"", ",", "x", "=", "1", ")", ",", "\n", "template", "=", "\"plotly_white\"", ",", "\n", "title", "=", "f\"graph {len(graph_dict) + 1} - n={n:,} pow={exp}\"", ",", "\n", "title_x", "=", "0.5", ",", "\n", ")", "\n", "\n", "# Create a uuid for the graph and add it to the global graph dict,", "\n", "uid", "=", "str", "(", "uuid4", "(", ")", ")", "\n", "graph_dict", "[", "uid", "]", "=", "fr", "\n", "\n", "# Add the graph to the existing output", "\n", "return", "[", "\n", "*", "gc", ",", "# the existing Graphs and their TraceUpdaters", "\n", "dcc", ".", "Graph", "(", "figure", "=", "fr", ",", "id", "=", "{", "\"type\"", ":", "\"dynamic-graph\"", ",", "\"index\"", ":", "uid", "}", ")", ",", "\n", "TraceUpdater", "(", "id", "=", "{", "\"type\"", ":", "\"dynamic-updater\"", ",", "\"index\"", ":", "uid", "}", ",", "gdID", "=", "uid", ")", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.construct_dynamic_figures.update_figure": [[150, 158], ["app.callback", "graph_dict.get().construct_update_data", "dash.Output", "dash.Input", "dash.State", "graph_dict.get"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.construct_update_data"], ["", "@", "app", ".", "callback", "(", "\n", "Output", "(", "{", "\"type\"", ":", "\"dynamic-updater\"", ",", "\"index\"", ":", "MATCH", "}", ",", "\"updateData\"", ")", ",", "\n", "Input", "(", "{", "\"type\"", ":", "\"dynamic-graph\"", ",", "\"index\"", ":", "MATCH", "}", ",", "\"relayoutData\"", ")", ",", "\n", "State", "(", "{", "\"type\"", ":", "\"dynamic-graph\"", ",", "\"index\"", ":", "MATCH", "}", ",", "\"id\"", ")", ",", "\n", "prevent_initial_call", "=", "True", ",", "\n", ")", "\n", "def", "update_figure", "(", "relayoutdata", ":", "dict", ",", "graph_id_dict", ":", "dict", ")", ":", "\n", "    ", "return", "graph_dict", ".", "get", "(", "graph_id_dict", "[", "\"index\"", "]", ")", ".", "construct_update_data", "(", "relayoutdata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.callback_helpers._update_file_widget": [[14, 25], ["sorted", "set", "list", "functional.seq().filter().map", "functional.seq().filter", "functional.seq", "pathlib.Path().iterdir", "x.is_file", "x.name.endswith", "pathlib.Path"], "function", ["None"], ["def", "_update_file_widget", "(", "folder", ")", ":", "\n", "    ", "if", "folder", "is", "None", ":", "\n", "        ", "return", "[", "]", "\n", "", "return", "[", "\n", "{", "\"label\"", ":", "filename", ",", "\"value\"", ":", "filename", "}", "\n", "for", "filename", "in", "sorted", "(", "\n", "set", "(", "\n", "list", "(", "\n", "seq", "(", "Path", "(", "folder", ")", ".", "iterdir", "(", ")", ")", "\n", ".", "filter", "(", "lambda", "x", ":", "x", ".", "is_file", "(", ")", "and", "x", ".", "name", ".", "endswith", "(", "\"parquet\"", ")", ")", "\n", ".", "map", "(", "lambda", "x", ":", "x", ".", "name", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.callback_helpers._register_selection_callbacks": [[31, 41], ["app.callback", "dash.Output", "dash.Input"], "function", ["None"], ["", "def", "_register_selection_callbacks", "(", "app", ",", "ids", "=", "None", ")", ":", "\n", "    ", "if", "ids", "is", "None", ":", "\n", "        ", "ids", "=", "[", "\"\"", "]", "\n", "\n", "", "for", "id", "in", "ids", ":", "\n", "\n", "        ", "app", ".", "callback", "(", "\n", "Output", "(", "f\"file-selector{id}\"", ",", "\"options\"", ")", ",", "\n", "[", "Input", "(", "f\"folder-selector{id}\"", ",", "\"value\"", ")", "]", ",", "\n", ")", "(", "_update_file_widget", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.callback_helpers.multiple_folder_file_selector": [[43, 110], ["dash_bootstrap_components.Card", "callback_helpers._register_selection_callbacks", "range", "dash_bootstrap_components.Card", "dash_bootstrap_components.Card", "enumerate", "dash_bootstrap_components.Col", "len", "dash_bootstrap_components.Col", "dash.html.Br", "dash_bootstrap_components.Button", "dash_bootstrap_components.Label", "dash.dcc.Dropdown", "dash_bootstrap_components.Label", "dash.dcc.Dropdown", "dash.html.Br", "str", "name_folders.items"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.dash_apps.callback_helpers._register_selection_callbacks"], ["", "", "def", "multiple_folder_file_selector", "(", "\n", "app", ",", "name_folders_list", ":", "List", "[", "Dict", "[", "str", ",", "dict", "]", "]", ",", "multi", "=", "True", "\n", ")", "->", "dbc", ".", "Card", ":", "\n", "    ", "\"\"\"Constructs a folder user date selector\n\n    Creates a `dbc.Card` component which can be\n\n    Parameters\n    ----------\n    app:\n        The dash application.\n    name_folders_list:List[Dict[str, Union[Path, str]]]\n         A dict with key, the display-key and values the correspondign path.\n\n    Returns\n    -------\n    A bootstrap card component\n    \"\"\"", "\n", "selector", "=", "dbc", ".", "Card", "(", "\n", "[", "\n", "dbc", ".", "Card", "(", "\n", "[", "\n", "dbc", ".", "Col", "(", "\n", "[", "\n", "dbc", ".", "Label", "(", "\"folder\"", ")", ",", "\n", "dcc", ".", "Dropdown", "(", "\n", "id", "=", "f\"folder-selector{i}\"", ",", "\n", "options", "=", "[", "\n", "{", "\"label\"", ":", "l", ",", "\"value\"", ":", "str", "(", "f", "[", "\"folder\"", "]", ")", "}", "\n", "for", "(", "l", ",", "f", ")", "in", "name_folders", ".", "items", "(", ")", "\n", "]", ",", "\n", "clearable", "=", "False", ",", "\n", ")", ",", "\n", "dbc", ".", "Label", "(", "\"file\"", ")", ",", "\n", "dcc", ".", "Dropdown", "(", "\n", "id", "=", "f\"file-selector{i}\"", ",", "\n", "options", "=", "[", "]", ",", "\n", "clearable", "=", "True", ",", "\n", "multi", "=", "multi", ",", "\n", ")", ",", "\n", "html", ".", "Br", "(", ")", ",", "\n", "]", "\n", ")", ",", "\n", "]", "\n", ")", "\n", "for", "i", ",", "name_folders", "in", "enumerate", "(", "name_folders_list", ",", "1", ")", "\n", "]", "\n", "+", "[", "\n", "dbc", ".", "Card", "(", "\n", "dbc", ".", "Col", "(", "\n", "[", "\n", "html", ".", "Br", "(", ")", ",", "\n", "dbc", ".", "Button", "(", "\n", "\"create figure\"", ",", "\n", "id", "=", "\"plot-button\"", ",", "\n", "color", "=", "\"primary\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", "style", "=", "{", "\"textAlign\"", ":", "\"center\"", "}", ",", "\n", ")", ",", "\n", ")", "\n", "]", ",", "\n", "body", "=", "True", ",", "\n", ")", "\n", "\n", "_register_selection_callbacks", "(", "app", "=", "app", ",", "ids", "=", "range", "(", "1", ",", "len", "(", "name_folders_list", ")", "+", "1", ")", ")", "\n", "return", "selector", "\n", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler_selenium.test_multiple_tz": [[9, 75], ["cleanup_on_sigterm", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "fr_selenium.FigureResamplerGUITests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.reset_axes", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.autoscale", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "multiprocessing.Process.terminate", "multiple_tz_figure.stop_server", "dict", "fr_selenium.FigureResamplerGUITests.get_requests", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.autoscale", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.stop_server", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests"], ["def", "test_multiple_tz", "(", "driver", ",", "multiple_tz_figure", ")", ":", "\n", "    ", "from", "pytest_cov", ".", "embed", "import", "cleanup_on_sigterm", "\n", "\n", "cleanup_on_sigterm", "(", ")", "\n", "\n", "port", "=", "9012", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "\n", "target", "=", "multiple_tz_figure", ".", "show_dash", ",", "kwargs", "=", "dict", "(", "mode", "=", "\"external\"", ",", "port", "=", "port", ")", "\n", ")", "\n", "proc", ".", "start", "(", ")", "\n", "try", ":", "\n", "        ", "time", ".", "sleep", "(", "1", ")", "\n", "fr", "=", "FigureResamplerGUITests", "(", "driver", ",", "port", "=", "port", ")", "\n", "\n", "# First, apply some box based zooms", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.25", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.3", ",", "x1", "=", "0.7", ",", "y0", "=", "0.1", ",", "y1", "=", "1", ")", "\n", "\n", "# Clear the requests till now", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "# Perform a zoom operation, and capture the request output", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.2", ",", "y1", "=", "0.2", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "# 1. Verify the fetch data request", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ",", "relayout_keys", "=", "[", "\"xaxis2.range[0]\"", ",", "\"xaxis2.range[1]\"", "]", ",", "n_updated_traces", "=", "5", "\n", ")", "\n", "\n", "# The reset axes autoscales AND resets tot he global data view -> all data", "\n", "# will be updated.", "\n", "fr", ".", "clear_requests", "(", ")", "\n", "fr", ".", "reset_axes", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ",", "\n", "relayout_keys", "=", "[", "\n", "\"xaxis.autorange\"", ",", "\n", "\"xaxis2.autorange\"", ",", "\n", "\"xaxis3.autorange\"", ",", "\n", "\"xaxis4.autorange\"", ",", "\n", "\"xaxis5.autorange\"", ",", "\n", "\"yaxis.autorange\"", ",", "\n", "\"yaxis2.autorange\"", ",", "\n", "\"yaxis3.autorange\"", ",", "\n", "\"yaxis4.autorange\"", ",", "\n", "\"yaxis5.autorange\"", ",", "\n", "]", ",", "\n", "n_updated_traces", "=", "5", ",", "\n", ")", "\n", "\n", "# we autoscale to the current front-end view, no updated dat will be sent from", "\n", "# the server to the front-end, however, a callback will still be made, but", "\n", "# will return a 204 response status (no content), as we do not need new data", "\n", "# to autoscale to the current front-end view.", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "autoscale", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "autoscale_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "autoscale_requests", ")", "==", "1", "\n", "assert", "autoscale_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "raise", "e", "\n", "", "finally", ":", "\n", "        ", "proc", ".", "terminate", "(", ")", "\n", "multiple_tz_figure", ".", "stop_server", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler_selenium.test_basic_example_gui": [[77, 176], ["cleanup_on_sigterm", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "fr_selenium.FigureResamplerGUITests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.click_legend_item", "time.sleep", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.click_legend_item", "fr_selenium.FigureResamplerGUITests.click_legend_item", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.autoscale", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.reset_axes", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "multiprocessing.Process.terminate", "dict", "len", "fr_selenium.FigureResamplerGUITests.get_requests", "len", "fr_selenium.FigureResamplerGUITests.get_requests", "len", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.get_requests"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.autoscale", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests"], ["", "", "def", "test_basic_example_gui", "(", "driver", ",", "example_figure", ")", ":", "\n", "    ", "from", "pytest_cov", ".", "embed", "import", "cleanup_on_sigterm", "\n", "\n", "cleanup_on_sigterm", "(", ")", "\n", "\n", "port", "=", "9012", "\n", "config", "=", "{", "\"displayModeBar\"", ":", "True", "}", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "\n", "target", "=", "example_figure", ".", "show_dash", ",", "\n", "kwargs", "=", "dict", "(", "mode", "=", "\"external\"", ",", "port", "=", "port", ",", "config", "=", "config", ")", ",", "\n", ")", "\n", "proc", ".", "start", "(", ")", "\n", "try", ":", "\n", "        ", "time", ".", "sleep", "(", "1", ")", "\n", "fr", "=", "FigureResamplerGUITests", "(", "driver", ",", "port", "=", "port", ")", "\n", "\n", "# First, apply some box based zooms", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.25", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.3", ",", "x1", "=", "0.7", ",", "y0", "=", "0.1", ",", "y1", "=", "1", ")", "\n", "\n", "# Clear the requests till now", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "# Perform a zoom operation, and capture the request output", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.2", ",", "y1", "=", "0.2", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "# 1. Verify the fetch data request", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ",", "relayout_keys", "=", "[", "\"xaxis2.range[0]\"", ",", "\"xaxis2.range[1]\"", "]", ",", "n_updated_traces", "=", "1", "\n", ")", "\n", "\n", "# A legend toggle operation", "\n", "# This does not trigger the relayout callback, no new requests should be made", "\n", "fr", ".", "clear_requests", "(", ")", "\n", "fr", ".", "click_legend_item", "(", "\"room 3\"", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "assert", "len", "(", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", ")", "==", "0", "\n", "\n", "# y remains the same - zoom horizontally", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.3", ",", "y1", "=", "0.3", ")", "\n", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y3\"", ",", "x0", "=", "0.4", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ",", "relayout_keys", "=", "[", "\"xaxis3.range[0]\"", ",", "\"xaxis3.range[1]\"", "]", ",", "n_updated_traces", "=", "3", "\n", ")", "\n", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.3", ",", "x1", "=", "0.7", ",", "y0", "=", "0.1", ",", "y1", "=", "1", ")", "\n", "\n", "# y remains the same - zoom horizontally", "\n", "fr", ".", "click_legend_item", "(", "\"room 3\"", ")", "\n", "fr", ".", "click_legend_item", "(", "\"room 2\"", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y3\"", ",", "x0", "=", "0.4", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y3\"", ",", "x0", "=", "0.95", ",", "x1", "=", "0.5", ",", "y0", "=", "0.95", ",", "y1", "=", "0.95", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y3\"", ",", "x0", "=", "0.05", ",", "x1", "=", "0.5", ",", "y0", "=", "0.95", ",", "y1", "=", "0.95", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.05", ",", "x1", "=", "0.5", ",", "y0", "=", "0.95", ",", "y1", "=", "0.95", ")", "\n", "\n", "# scale vertically -", "\n", "# This will trigger a relayout callback, however as only y-values are updated,", "\n", "# no new data points will be send to the front-end and a - NO CONTENT response", "\n", "# will be returned.", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.5", ",", "x1", "=", "0.5", ",", "y0", "=", "0.1", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "vertical_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "vertical_requests", ")", "==", "1", "\n", "assert", "vertical_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "# we autoscale to the current front-end view, no updated dat will be sent from", "\n", "# the server to the front-end, however, a callback will still be made, but", "\n", "# will return a 204 response status (no content), as we do not need new data", "\n", "# to autoscale to the current front-end view.", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "autoscale", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "autoscale_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "autoscale_requests", ")", "==", "1", "\n", "assert", "autoscale_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "# The reset axes autoscales AND resets tot he global data view -> all data", "\n", "# will be updated.", "\n", "fr", ".", "clear_requests", "(", ")", "\n", "fr", ".", "reset_axes", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ",", "\n", "relayout_keys", "=", "[", "\n", "\"xaxis.autorange\"", ",", "\n", "\"xaxis2.autorange\"", ",", "\n", "\"xaxis3.autorange\"", ",", "\n", "\"xaxis.showspikes\"", ",", "\n", "]", ",", "\n", "n_updated_traces", "=", "5", ",", "\n", ")", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "raise", "e", "\n", "", "finally", ":", "\n", "        ", "proc", ".", "terminate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler_selenium.test_basic_example_gui_existing": [[178, 281], ["cleanup_on_sigterm", "plotly_resampler.figure_resampler.FigureResampler", "plotly_resampler.figure_resampler.FigureResampler.replace", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "fr_selenium.FigureResamplerGUITests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.click_legend_item", "time.sleep", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.click_legend_item", "fr_selenium.FigureResamplerGUITests.click_legend_item", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.autoscale", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.reset_axes", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "multiprocessing.Process.terminate", "dict", "len", "fr_selenium.FigureResamplerGUITests.get_requests", "len", "fr_selenium.FigureResamplerGUITests.get_requests", "len", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.get_requests"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.autoscale", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests"], ["", "", "def", "test_basic_example_gui_existing", "(", "driver", ",", "example_figure_fig", ")", ":", "\n", "    ", "from", "pytest_cov", ".", "embed", "import", "cleanup_on_sigterm", "\n", "\n", "cleanup_on_sigterm", "(", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", "\n", "resampled_trace_prefix_suffix", "=", "(", "\n", "'<b style=\"color:sandybrown\">[R]</b>'", ",", "\n", "'<b style=\"color:darkcyan\">[R]</b>'", ",", "\n", ")", "\n", ")", "\n", "fig", ".", "replace", "(", "example_figure_fig", ")", "\n", "\n", "port", "=", "9012", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "\n", "target", "=", "fig", ".", "show_dash", ",", "kwargs", "=", "dict", "(", "mode", "=", "\"external\"", ",", "port", "=", "port", ")", "\n", ")", "\n", "proc", ".", "start", "(", ")", "\n", "try", ":", "\n", "        ", "time", ".", "sleep", "(", "1", ")", "\n", "fr", "=", "FigureResamplerGUITests", "(", "driver", ",", "port", "=", "port", ")", "\n", "\n", "# First, apply some box based zooms", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.25", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.3", ",", "x1", "=", "0.7", ",", "y0", "=", "0.1", ",", "y1", "=", "1", ")", "\n", "\n", "# Clear the requests till now", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "# Perform a zoom operation, and capture the request output", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.2", ",", "y1", "=", "0.2", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "# 1. Verify the fetch data request", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ",", "relayout_keys", "=", "[", "\"xaxis2.range[0]\"", ",", "\"xaxis2.range[1]\"", "]", ",", "n_updated_traces", "=", "1", "\n", ")", "\n", "\n", "# A legend toggle operation", "\n", "# This does not trigger the relayout callback, no new requests should be made", "\n", "fr", ".", "clear_requests", "(", ")", "\n", "fr", ".", "click_legend_item", "(", "\"room 3\"", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "assert", "len", "(", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", ")", "==", "0", "\n", "\n", "# y remains the same - zoom horizontally", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.3", ",", "y1", "=", "0.3", ")", "\n", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y3\"", ",", "x0", "=", "0.4", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ",", "relayout_keys", "=", "[", "\"xaxis3.range[0]\"", ",", "\"xaxis3.range[1]\"", "]", ",", "n_updated_traces", "=", "3", "\n", ")", "\n", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.3", ",", "x1", "=", "0.7", ",", "y0", "=", "0.1", ",", "y1", "=", "1", ")", "\n", "\n", "# y remains the same - zoom horizontally", "\n", "fr", ".", "click_legend_item", "(", "\"room 3\"", ")", "\n", "fr", ".", "click_legend_item", "(", "\"room 2\"", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y3\"", ",", "x0", "=", "0.4", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y3\"", ",", "x0", "=", "0.05", ",", "x1", "=", "0.5", ",", "y0", "=", "0.95", ",", "y1", "=", "0.95", ")", "\n", "\n", "# scale vertically -", "\n", "# This will trigger a relayout callback, however as only y-values are updated,", "\n", "# no new data points will be send to the front-end and a - NO CONTENT response", "\n", "# will be returned.", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.5", ",", "x1", "=", "0.5", ",", "y0", "=", "0.1", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "vertical_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "vertical_requests", ")", "==", "1", "\n", "assert", "vertical_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "# we autoscale to the current front-end view, no updated dat will be sent from", "\n", "# the server to the front-end, however, a callback will still be made, but", "\n", "# will return a 204 response status (no content), as we do not need new data", "\n", "# to autoscale to the current front-end view.", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "autoscale", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "autoscale_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "autoscale_requests", ")", "==", "1", "\n", "assert", "autoscale_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "# The reset axes autoscales AND resets tot he global data view -> all data", "\n", "# will be updated.", "\n", "fr", ".", "clear_requests", "(", ")", "\n", "fr", ".", "reset_axes", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ",", "\n", "relayout_keys", "=", "[", "\n", "\"xaxis.autorange\"", ",", "\n", "\"xaxis2.autorange\"", ",", "\n", "\"xaxis3.autorange\"", ",", "\n", "\"xaxis.showspikes\"", ",", "\n", "]", ",", "\n", "n_updated_traces", "=", "5", ",", "\n", ")", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "raise", "e", "\n", "", "finally", ":", "\n", "        ", "proc", ".", "terminate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler_selenium.test_gsr_gui": [[283, 381], ["cleanup_on_sigterm", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "fr_selenium.FigureResamplerGUITests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.click_legend_item", "time.sleep", "fr_selenium.FigureResamplerGUITests.click_legend_item", "time.sleep", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.reset_axes", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.click_legend_item", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.autoscale", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.reset_axes", "time.sleep", "multiprocessing.Process.terminate", "dict", "len", "fr_selenium.FigureResamplerGUITests.get_requests", "len", "fr_selenium.FigureResamplerGUITests.get_requests", "len", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.get_requests"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.autoscale", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests"], ["", "", "def", "test_gsr_gui", "(", "driver", ",", "gsr_figure", ")", ":", "\n", "    ", "from", "pytest_cov", ".", "embed", "import", "cleanup_on_sigterm", "\n", "\n", "cleanup_on_sigterm", "(", ")", "\n", "\n", "port", "=", "9032", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "\n", "target", "=", "gsr_figure", ".", "show_dash", ",", "kwargs", "=", "dict", "(", "mode", "=", "\"external\"", ",", "port", "=", "port", ")", "\n", ")", "\n", "proc", ".", "start", "(", ")", "\n", "\n", "try", ":", "\n", "        ", "time", ".", "sleep", "(", "1", ")", "\n", "fr", "=", "FigureResamplerGUITests", "(", "driver", ",", "port", "=", "port", ")", "\n", "\n", "# box based zooms", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.25", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y3\"", ",", "x0", "=", "0.3", ",", "x1", "=", "0.7", ",", "y0", "=", "0.1", ",", "y1", "=", "1", ")", "\n", "\n", "# Note: we have shared-xaxes so all traces will be updated using this command", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y3\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.2", ",", "y1", "=", "0.2", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\n", "\"xaxis.range[0]\"", ",", "\n", "\"xaxis.range[1]\"", ",", "\n", "\"xaxis2.range[0]\"", ",", "\n", "\"xaxis2.range[1]\"", ",", "\n", "]", ",", "\n", "n_updated_traces", "=", "7", ",", "\n", ")", "\n", "\n", "# A toggle operation", "\n", "# This does not trigger the relayout callback, no new requests should be made", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "click_legend_item", "(", "\"EDA_Phasic\"", ")", "\n", "time", ".", "sleep", "(", "0.2", ")", "\n", "fr", ".", "click_legend_item", "(", "\"SCR peaks\"", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "assert", "len", "(", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", ")", "==", "0", "\n", "\n", "# A reset axes operation resets the front-end view to the global data view", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "reset_axes", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\n", "\"xaxis.autorange\"", ",", "\n", "\"xaxis2.autorange\"", ",", "\n", "\"xaxis.showspikes\"", ",", "\n", "\"xaxis2.showspikes\"", ",", "\n", "]", ",", "\n", "n_updated_traces", "=", "7", ",", "\n", ")", "\n", "\n", "# y remains the same - zoom horizontally", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y3\"", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.3", ",", "y1", "=", "0.3", ")", "\n", "\n", "# y remains the same - zom horizontally", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.4", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y3\"", ",", "x0", "=", "0.95", ",", "x1", "=", "0.5", ",", "y0", "=", "0.95", ",", "y1", "=", "0.95", ")", "\n", "fr", ".", "click_legend_item", "(", "\"EDA_lf_cleaned_tonic\"", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.05", ",", "x1", "=", "0.5", ",", "y0", "=", "0.95", ",", "y1", "=", "0.95", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y3\"", ",", "x0", "=", "0.05", ",", "x1", "=", "0.5", ",", "y0", "=", "0.95", ",", "y1", "=", "0.95", ")", "\n", "\n", "# scale vertically", "\n", "# This will trigger a relayout callback, however as only y-values are updated,", "\n", "# no new data points will be send to the front-end and a - NO CONTENT response", "\n", "# will be returned.", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y3\"", ",", "x0", "=", "0.2", ",", "x1", "=", "0.2", ",", "y0", "=", "0.1", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "vertical_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "vertical_requests", ")", "==", "1", "\n", "assert", "vertical_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "# autoscale", "\n", "# we autoscale to the current front-end view, no updated dat will be sent from", "\n", "# the server to the front-end, however, a callback will still be made, but", "\n", "# will return a 204 response status (no content), as we do not need new data", "\n", "# to autoscale to the current front-end view.", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "autoscale", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "autoscale_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "autoscale_requests", ")", "==", "1", "\n", "assert", "autoscale_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "fr", ".", "reset_axes", "(", ")", "\n", "time", ".", "sleep", "(", "0.2", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "raise", "e", "\n", "", "finally", ":", "\n", "        ", "proc", ".", "terminate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler_selenium.test_cat_gui": [[383, 453], ["cleanup_on_sigterm", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "fr_selenium.FigureResamplerGUITests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.autoscale", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.reset_axes", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "multiprocessing.Process.terminate", "dict", "fr_selenium.FigureResamplerGUITests.get_requests", "len", "fr_selenium.FigureResamplerGUITests.get_requests", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.autoscale", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests"], ["", "", "def", "test_cat_gui", "(", "driver", ",", "cat_series_box_hist_figure", ")", ":", "\n", "    ", "from", "pytest_cov", ".", "embed", "import", "cleanup_on_sigterm", "\n", "\n", "cleanup_on_sigterm", "(", ")", "\n", "\n", "port", "=", "9034", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "\n", "target", "=", "cat_series_box_hist_figure", ".", "show_dash", ",", "\n", "kwargs", "=", "dict", "(", "mode", "=", "\"external\"", ",", "port", "=", "port", ")", ",", "\n", ")", "\n", "proc", ".", "start", "(", ")", "\n", "try", ":", "\n", "        ", "time", ".", "sleep", "(", "1", ")", "\n", "fr", "=", "FigureResamplerGUITests", "(", "driver", ",", "port", "=", "port", ")", "\n", "\n", "# First, apply some horizontal based zooms", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\"xaxis.range[0]\"", ",", "\"xaxis.range[1]\"", "]", ",", "\n", "n_updated_traces", "=", "1", ",", "\n", ")", "\n", "\n", "# The right top subplot withholds a boxplot, which is NOT a high-freq trace", "\n", "# so no new data should be send from the server to the client -> 204 status code", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x2y2\"", ",", "x0", "=", "0.3", ",", "x1", "=", "0.7", ",", "y0", "=", "0.2", ",", "y1", "=", "0.8", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "vertical_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "vertical_requests", ")", "==", "1", "\n", "assert", "vertical_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "autoscale", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "autoscale_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "autoscale_requests", ")", "==", "1", "\n", "assert", "autoscale_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "# Note: as there is only 1 hf-scatter-trace, the reset axes command will only", "\n", "# update a single trace", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "reset_axes", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\n", "\"xaxis.autorange\"", ",", "\n", "\"xaxis.showspikes\"", ",", "\n", "\"xaxis2.autorange\"", ",", "\n", "\"xaxis2.showspikes\"", ",", "\n", "\"xaxis3.autorange\"", ",", "\n", "\"xaxis3.showspikes\"", ",", "\n", "\"yaxis.autorange\"", ",", "\n", "\"yaxis.showspikes\"", ",", "\n", "\"yaxis2.autorange\"", ",", "\n", "\"yaxis2.showspikes\"", ",", "\n", "\"yaxis3.autorange\"", ",", "\n", "\"yaxis3.showspikes\"", ",", "\n", "]", ",", "\n", "n_updated_traces", "=", "1", ",", "\n", ")", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "raise", "e", "\n", "", "finally", ":", "\n", "        ", "proc", ".", "terminate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler_selenium.test_shared_hover_gui": [[455, 526], ["cleanup_on_sigterm", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "fr_selenium.FigureResamplerGUITests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.reset_axes", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.autoscale", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "multiprocessing.Process.terminate", "dict", "fr_selenium.FigureResamplerGUITests.get_requests", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.autoscale", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests"], ["", "", "def", "test_shared_hover_gui", "(", "driver", ",", "shared_hover_figure", ")", ":", "\n", "    ", "from", "pytest_cov", ".", "embed", "import", "cleanup_on_sigterm", "\n", "\n", "cleanup_on_sigterm", "(", ")", "\n", "\n", "port", "=", "9038", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "\n", "target", "=", "shared_hover_figure", ".", "show_dash", ",", "\n", "kwargs", "=", "dict", "(", "mode", "=", "\"external\"", ",", "port", "=", "port", ")", ",", "\n", ")", "\n", "proc", ".", "start", "(", ")", "\n", "try", ":", "\n", "        ", "time", ".", "sleep", "(", "1", ")", "\n", "fr", "=", "FigureResamplerGUITests", "(", "driver", ",", "port", "=", "port", ")", "\n", "\n", "# First, apply some horizontal based zooms", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "# As all axes are shared, we expect at least 3 updated", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\"xaxis3.range[0]\"", ",", "\"xaxis3.range[1]\"", "]", ",", "\n", "n_updated_traces", "=", "3", ",", "\n", ")", "\n", "\n", "# Note: as there is only 1 hf-scatter-trace, the reset axes command will only", "\n", "# update a single trace", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "reset_axes", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\n", "\"xaxis3.autorange\"", ",", "\n", "\"xaxis3.showspikes\"", ",", "\n", "\"yaxis.autorange\"", ",", "\n", "\"yaxis.showspikes\"", ",", "\n", "\"yaxis2.autorange\"", ",", "\n", "\"yaxis2.showspikes\"", ",", "\n", "\"yaxis3.autorange\"", ",", "\n", "\"yaxis3.showspikes\"", ",", "\n", "]", ",", "\n", "n_updated_traces", "=", "3", ",", "\n", ")", "\n", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y2\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "\n", "# First, apply some horizontal based zooms", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"x3y3\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "# As all axes are shared, we expect at least 3 updated", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\"xaxis3.range[0]\"", ",", "\"xaxis3.range[1]\"", "]", ",", "\n", "n_updated_traces", "=", "3", ",", "\n", ")", "\n", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "autoscale", "(", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "autoscale_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "autoscale_requests", ")", "==", "1", "\n", "assert", "autoscale_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "raise", "e", "\n", "", "finally", ":", "\n", "        ", "proc", ".", "terminate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler_selenium.test_multi_trace_go_figure": [[528, 596], ["cleanup_on_sigterm", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "fr_selenium.FigureResamplerGUITests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.reset_axes", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.drag_and_zoom", "time.sleep", "fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "fr_selenium.FigureResamplerGUITests.clear_requests", "fr_selenium.FigureResamplerGUITests.autoscale", "time.sleep", "fr_selenium.RequestParser.filter_callback_requests", "multiprocessing.Process.terminate", "dict", "fr_selenium.FigureResamplerGUITests.get_requests", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.autoscale", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests"], ["", "", "def", "test_multi_trace_go_figure", "(", "driver", ",", "multi_trace_go_figure", ")", ":", "\n", "    ", "from", "pytest_cov", ".", "embed", "import", "cleanup_on_sigterm", "\n", "\n", "cleanup_on_sigterm", "(", ")", "\n", "\n", "port", "=", "9038", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "\n", "target", "=", "multi_trace_go_figure", ".", "show_dash", ",", "\n", "kwargs", "=", "dict", "(", "mode", "=", "\"external\"", ",", "port", "=", "port", ")", ",", "\n", ")", "\n", "proc", ".", "start", "(", ")", "\n", "try", ":", "\n", "        ", "time", ".", "sleep", "(", "1", ")", "\n", "fr", "=", "FigureResamplerGUITests", "(", "driver", ",", "port", "=", "port", ")", "\n", "\n", "# First, apply some horizontal based zooms", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "3", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.5", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "3", ")", "\n", "# As all axes are shared, we expect at least 3 updated", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\"xaxis.range[0]\"", ",", "\"xaxis.range[1]\"", "]", ",", "\n", "n_updated_traces", "=", "30", ",", "\n", ")", "\n", "\n", "# Note: as there is only 1 hf-scatter-trace, the reset axes command will only", "\n", "# update a single trace", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "reset_axes", "(", ")", "\n", "time", ".", "sleep", "(", "3", ")", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\n", "\"xaxis.autorange\"", ",", "\n", "\"xaxis.showspikes\"", ",", "\n", "\"yaxis.autorange\"", ",", "\n", "\"yaxis.showspikes\"", ",", "\n", "]", ",", "\n", "n_updated_traces", "=", "30", ",", "\n", ")", "\n", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.3", ",", "y0", "=", "0.6", ",", "y1", "=", "0.9", ")", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "3", ")", "\n", "\n", "# First, apply some horizontal based zooms", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "1", ")", "\n", "fr", ".", "drag_and_zoom", "(", "\"xy\"", ",", "x0", "=", "0.1", ",", "x1", "=", "0.2", ",", "y0", "=", "0.5", ",", "y1", "=", "0.5", ")", "\n", "time", ".", "sleep", "(", "3", ")", "\n", "# As all axes are shared, we expect at least 3 updated", "\n", "RequestParser", ".", "browser_independent_single_callback_request_assert", "(", "\n", "fr", "=", "fr", ",", "\n", "relayout_keys", "=", "[", "\"xaxis.range[0]\"", ",", "\"xaxis.range[1]\"", "]", ",", "\n", "n_updated_traces", "=", "30", ",", "\n", ")", "\n", "\n", "fr", ".", "clear_requests", "(", "sleep_time_s", "=", "3", ")", "\n", "fr", ".", "autoscale", "(", ")", "\n", "time", ".", "sleep", "(", "3", ")", "\n", "autoscale_requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "assert", "len", "(", "autoscale_requests", ")", "==", "1", "\n", "assert", "autoscale_requests", "[", "0", "]", ".", "response", ".", "status_code", "==", "204", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "raise", "e", "\n", "", "finally", ":", "\n", "        ", "proc", ".", "terminate", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_registering.test_get_plotly_const": [[19, 46], ["issubclass", "issubclass", "plotly_resampler.registering.register_plotly_resampler", "isinstance", "isinstance", "issubclass", "issubclass", "plotly_resampler.registering.unregister_plotly_resampler", "issubclass", "issubclass", "issubclass", "issubclass", "inspect.isfunction", "inspect.isfunction", "plotly.Figure", "plotly.FigureWidget", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "issubclass", "inspect.isfunction", "inspect.isfunction", "plotly_resampler.registering._get_plotly_constr", "plotly_resampler.registering._get_plotly_constr", "plotly_resampler.registering._get_plotly_constr", "plotly_resampler.registering._get_plotly_constr", "inspect.isfunction", "inspect.isfunction", "plotly_resampler.registering._get_plotly_constr", "plotly_resampler.registering._get_plotly_constr"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.unregister_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering._get_plotly_constr"], ["def", "test_get_plotly_const", "(", "registering_cleanup", ")", ":", "\n", "# Check the basi(c)s", "\n", "    ", "assert", "issubclass", "(", "FigureResampler", ",", "AbstractFigureAggregator", ")", "\n", "assert", "issubclass", "(", "FigureWidgetResampler", ",", "AbstractFigureAggregator", ")", "\n", "\n", "# Is unregistered now", "\n", "assert", "not", "(", "isfunction", "(", "go", ".", "Figure", ")", "or", "isfunction", "(", "go", ".", "FigureWidget", ")", ")", "\n", "assert", "not", "issubclass", "(", "go", ".", "Figure", ",", "AbstractFigureAggregator", ")", "\n", "assert", "not", "issubclass", "(", "go", ".", "FigureWidget", ",", "AbstractFigureAggregator", ")", "\n", "assert", "not", "issubclass", "(", "_get_plotly_constr", "(", "go", ".", "Figure", ")", ",", "AbstractFigureAggregator", ")", "\n", "assert", "not", "issubclass", "(", "_get_plotly_constr", "(", "go", ".", "FigureWidget", ")", ",", "AbstractFigureAggregator", ")", "\n", "\n", "register_plotly_resampler", "(", ")", "\n", "assert", "isfunction", "(", "go", ".", "Figure", ")", "and", "isfunction", "(", "go", ".", "FigureWidget", ")", "\n", "assert", "isinstance", "(", "go", ".", "Figure", "(", ")", ",", "AbstractFigureAggregator", ")", "\n", "assert", "isinstance", "(", "go", ".", "FigureWidget", "(", ")", ",", "AbstractFigureAggregator", ")", "\n", "assert", "issubclass", "(", "FigureResampler", ",", "AbstractFigureAggregator", ")", "\n", "assert", "issubclass", "(", "FigureWidgetResampler", ",", "AbstractFigureAggregator", ")", "\n", "assert", "not", "issubclass", "(", "_get_plotly_constr", "(", "go", ".", "Figure", ")", ",", "AbstractFigureAggregator", ")", "\n", "assert", "not", "issubclass", "(", "_get_plotly_constr", "(", "go", ".", "FigureWidget", ")", ",", "AbstractFigureAggregator", ")", "\n", "\n", "unregister_plotly_resampler", "(", ")", "\n", "assert", "not", "(", "isfunction", "(", "go", ".", "Figure", ")", "or", "isfunction", "(", "go", ".", "FigureWidget", ")", ")", "\n", "assert", "not", "issubclass", "(", "go", ".", "Figure", ",", "AbstractFigureAggregator", ")", "\n", "assert", "not", "issubclass", "(", "go", ".", "FigureWidget", ",", "AbstractFigureAggregator", ")", "\n", "assert", "not", "issubclass", "(", "_get_plotly_constr", "(", "go", ".", "Figure", ")", ",", "AbstractFigureAggregator", ")", "\n", "assert", "not", "issubclass", "(", "_get_plotly_constr", "(", "go", ".", "FigureWidget", ")", ",", "AbstractFigureAggregator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_registering.test_register_and_unregister_graph_objects": [[48, 75], ["go_.Figure", "go_.FigureWidget", "plotly_resampler.registering.register_plotly_resampler", "go_.Figure", "isinstance", "isinstance", "go_.FigureWidget", "isinstance", "isinstance", "plotly_resampler.registering.unregister_plotly_resampler", "go_.Figure", "go_.FigureWidget", "isinstance", "isinstance", "inspect.isfunction", "inspect.isfunction", "isinstance", "isinstance", "isinstance", "isinstance", "inspect.isfunction", "inspect.isfunction", "inspect.isfunction", "inspect.isfunction"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.unregister_plotly_resampler"], ["", "def", "test_register_and_unregister_graph_objects", "(", "registering_cleanup", ")", ":", "\n", "    ", "import", "plotly", ".", "graph_objects", "as", "go_", "\n", "\n", "# Is unregistered now", "\n", "assert", "not", "(", "isfunction", "(", "go_", ".", "Figure", ")", "or", "isfunction", "(", "go_", ".", "FigureWidget", ")", ")", "\n", "fig", "=", "go_", ".", "Figure", "(", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "fig", "=", "go_", ".", "FigureWidget", "(", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "\n", "register_plotly_resampler", "(", ")", "\n", "assert", "isfunction", "(", "go_", ".", "Figure", ")", "and", "isfunction", "(", "go_", ".", "FigureWidget", ")", "\n", "fig", "=", "go_", ".", "Figure", "(", ")", "\n", "assert", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "assert", "isinstance", "(", "fig", ",", "FigureResampler", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "FigureWidgetResampler", ")", "\n", "fig", "=", "go_", ".", "FigureWidget", "(", ")", "\n", "assert", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "assert", "isinstance", "(", "fig", ",", "FigureWidgetResampler", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "FigureResampler", ")", "\n", "\n", "unregister_plotly_resampler", "(", ")", "\n", "assert", "not", "(", "isfunction", "(", "go_", ".", "Figure", ")", "or", "isfunction", "(", "go_", ".", "FigureWidget", ")", ")", "\n", "fig", "=", "go_", ".", "Figure", "(", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "fig", "=", "go_", ".", "FigureWidget", "(", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_registering.test_register_and_unregister_graph_objs": [[77, 104], ["go_.Figure", "go_.FigureWidget", "plotly_resampler.registering.register_plotly_resampler", "go_.Figure", "isinstance", "isinstance", "go_.FigureWidget", "isinstance", "isinstance", "plotly_resampler.registering.unregister_plotly_resampler", "go_.Figure", "go_.FigureWidget", "isinstance", "isinstance", "inspect.isfunction", "inspect.isfunction", "isinstance", "isinstance", "isinstance", "isinstance", "inspect.isfunction", "inspect.isfunction", "inspect.isfunction", "inspect.isfunction"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.unregister_plotly_resampler"], ["", "def", "test_register_and_unregister_graph_objs", "(", "registering_cleanup", ")", ":", "\n", "    ", "import", "plotly", ".", "graph_objs", "as", "go_", "\n", "\n", "# Is unregistered now", "\n", "assert", "not", "(", "isfunction", "(", "go_", ".", "Figure", ")", "or", "isfunction", "(", "go_", ".", "FigureWidget", ")", ")", "\n", "fig", "=", "go_", ".", "Figure", "(", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "fig", "=", "go_", ".", "FigureWidget", "(", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "\n", "register_plotly_resampler", "(", ")", "\n", "assert", "isfunction", "(", "go_", ".", "Figure", ")", "and", "isfunction", "(", "go_", ".", "FigureWidget", ")", "\n", "fig", "=", "go_", ".", "Figure", "(", ")", "\n", "assert", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "assert", "isinstance", "(", "fig", ",", "FigureResampler", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "FigureWidgetResampler", ")", "\n", "fig", "=", "go_", ".", "FigureWidget", "(", ")", "\n", "assert", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "assert", "isinstance", "(", "fig", ",", "FigureWidgetResampler", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "FigureResampler", ")", "\n", "\n", "unregister_plotly_resampler", "(", ")", "\n", "assert", "not", "(", "isfunction", "(", "go_", ".", "Figure", ")", "or", "isfunction", "(", "go_", ".", "FigureWidget", ")", ")", "\n", "fig", "=", "go_", ".", "Figure", "(", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "fig", "=", "go_", ".", "FigureWidget", "(", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_registering.test_registering_modes": [[106, 121], ["plotly_resampler.registering.register_plotly_resampler", "isinstance", "isinstance", "plotly_resampler.registering.register_plotly_resampler", "isinstance", "isinstance", "plotly_resampler.registering.register_plotly_resampler", "isinstance", "isinstance", "plotly.Figure", "plotly.FigureWidget", "plotly.Figure", "plotly.FigureWidget", "plotly.Figure", "plotly.FigureWidget"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler"], ["", "def", "test_registering_modes", "(", "registering_cleanup", ")", ":", "\n", "    ", "register_plotly_resampler", "(", "mode", "=", "\"auto\"", ")", "\n", "# Should be default", "\n", "assert", "isinstance", "(", "go", ".", "Figure", "(", ")", ",", "FigureResampler", ")", "\n", "assert", "isinstance", "(", "go", ".", "FigureWidget", "(", ")", ",", "FigureWidgetResampler", ")", "\n", "\n", "register_plotly_resampler", "(", "mode", "=", "\"figure\"", ")", "\n", "# Should be all FigureResampler", "\n", "assert", "isinstance", "(", "go", ".", "Figure", "(", ")", ",", "FigureResampler", ")", "\n", "assert", "isinstance", "(", "go", ".", "FigureWidget", "(", ")", ",", "FigureResampler", ")", "\n", "\n", "register_plotly_resampler", "(", "mode", "=", "\"widget\"", ")", "\n", "# Should be all FigureWidgetResampler", "\n", "assert", "isinstance", "(", "go", ".", "Figure", "(", ")", ",", "FigureWidgetResampler", ")", "\n", "assert", "isinstance", "(", "go", ".", "FigureWidget", "(", ")", ",", "FigureWidgetResampler", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_registering.test_registering_plotly_express_and_kwargs": [[123, 151], ["plotly.scatter", "plotly_resampler.registering.register_plotly_resampler", "plotly.scatter", "isinstance", "plotly_resampler.registering.register_plotly_resampler", "plotly.scatter", "isinstance", "plotly_resampler.registering.unregister_plotly_resampler", "plotly.scatter", "isinstance", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "isinstance", "len", "len", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.unregister_plotly_resampler"], ["", "def", "test_registering_plotly_express_and_kwargs", "(", "registering_cleanup", ")", ":", "\n", "# Is unregistered now", "\n", "    ", "fig", "=", "px", ".", "scatter", "(", "y", "=", "np", ".", "arange", "(", "500", ")", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "assert", "len", "(", "fig", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "==", "500", "\n", "\n", "register_plotly_resampler", "(", "default_n_shown_samples", "=", "50", ")", "\n", "fig", "=", "px", ".", "scatter", "(", "y", "=", "np", ".", "arange", "(", "500", ")", ")", "\n", "assert", "isinstance", "(", "fig", ",", "FigureResampler", ")", "\n", "assert", "len", "(", "fig", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "==", "50", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "500", "\n", "\n", "register_plotly_resampler", "(", ")", "\n", "fig", "=", "px", ".", "scatter", "(", "y", "=", "np", ".", "arange", "(", "5000", ")", ")", "\n", "assert", "isinstance", "(", "fig", ",", "FigureResampler", ")", "\n", "assert", "len", "(", "fig", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "==", "1000", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "5000", "\n", "\n", "unregister_plotly_resampler", "(", ")", "\n", "fig", "=", "px", ".", "scatter", "(", "y", "=", "np", ".", "arange", "(", "500", ")", ")", "\n", "assert", "not", "isinstance", "(", "fig", ",", "AbstractFigureAggregator", ")", "\n", "assert", "len", "(", "fig", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "==", "500", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_registering.test_compasibility_when_registered": [[153, 204], ["plotly.scatter", "plotly.FigureWidget", "plotly_resampler.registering.register_plotly_resampler", "plotly.scatter", "plotly.FigureWidget", "fr", "fr", "fr", "fwr", "fwr", "fwr", "fr", "fr", "fr", "fwr", "fwr", "fwr", "numpy.arange", "numpy.arange", "fwr", "fr", "isinstance", "fr", "fwr", "isinstance", "numpy.arange", "numpy.arange", "fwr", "fr", "isinstance", "fr", "fwr", "isinstance", "fr", "len", "len", "len", "len", "fwr", "len", "len", "len", "len", "fr", "len", "len", "len", "len", "fwr", "len", "len", "len", "len", "fr", "fwr", "fr", "fwr", "fwr", "fr", "fwr", "fr", "fwr", "fr", "fwr", "fr", "fr", "fwr", "fr", "fwr", "fwr", "fr", "fwr", "fr", "fr", "fwr", "fr", "fwr"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.register_plotly_resampler"], ["", "def", "test_compasibility_when_registered", "(", "registering_cleanup", ")", ":", "\n", "    ", "fr", "=", "FigureResampler", "\n", "fwr", "=", "FigureWidgetResampler", "\n", "\n", "fig_orig_1", "=", "px", ".", "scatter", "(", "y", "=", "np", ".", "arange", "(", "1_005", ")", ")", "\n", "fig_orig_2", "=", "go", ".", "FigureWidget", "(", "{", "\"type\"", ":", "\"scatter\"", ",", "\"y\"", ":", "np", ".", "arange", "(", "1_005", ")", "}", ")", "\n", "for", "fig", "in", "[", "fig_orig_1", ",", "fig_orig_2", "]", ":", "\n", "        ", "fig1", "=", "fr", "(", "fig", ")", "\n", "fig2", "=", "fr", "(", "fwr", "(", "fig", ")", ")", "\n", "fig3", "=", "fr", "(", "fr", "(", "fr", "(", "fr", "(", "fwr", "(", "fwr", "(", "fr", "(", "fwr", "(", "fr", "(", "fig", ")", ")", ")", ")", ")", ")", ")", ")", ")", "\n", "for", "f", "in", "[", "fig1", ",", "fig2", ",", "fig3", "]", ":", "\n", "            ", "assert", "isinstance", "(", "f", ",", "FigureResampler", ")", "\n", "assert", "len", "(", "f", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "f", ".", "data", "[", "0", "]", ".", "y", ")", "==", "1000", "\n", "assert", "len", "(", "f", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "f", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "1005", "\n", "\n", "", "fig1", "=", "fwr", "(", "fig", ")", "\n", "fig2", "=", "fwr", "(", "fr", "(", "fig", ")", ")", "\n", "fig3", "=", "fwr", "(", "fwr", "(", "fwr", "(", "fwr", "(", "fr", "(", "fr", "(", "fwr", "(", "fr", "(", "fwr", "(", "fig", ")", ")", ")", ")", ")", ")", ")", ")", ")", "\n", "for", "f", "in", "[", "fig1", ",", "fig2", ",", "fig3", "]", ":", "\n", "            ", "assert", "isinstance", "(", "f", ",", "FigureWidgetResampler", ")", "\n", "assert", "len", "(", "f", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "f", ".", "data", "[", "0", "]", ".", "y", ")", "==", "1000", "\n", "assert", "len", "(", "f", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "f", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "1005", "\n", "\n", "", "", "register_plotly_resampler", "(", ")", "\n", "\n", "fig_orig_1", "=", "px", ".", "scatter", "(", "y", "=", "np", ".", "arange", "(", "1_005", ")", ")", "\n", "fig_orig_2", "=", "go", ".", "FigureWidget", "(", "{", "\"type\"", ":", "\"scatter\"", ",", "\"y\"", ":", "np", ".", "arange", "(", "1_005", ")", "}", ")", "\n", "for", "fig", "in", "[", "fig_orig_1", ",", "fig_orig_2", "]", ":", "\n", "        ", "fig1", "=", "fr", "(", "fig", ")", "\n", "fig2", "=", "fr", "(", "fwr", "(", "fig", ")", ")", "\n", "fig3", "=", "fr", "(", "fr", "(", "fr", "(", "fr", "(", "fwr", "(", "fwr", "(", "fr", "(", "fwr", "(", "fr", "(", "fig", ")", ")", ")", ")", ")", ")", ")", ")", ")", "\n", "for", "f", "in", "[", "fig1", ",", "fig2", ",", "fig3", "]", ":", "\n", "            ", "assert", "isinstance", "(", "f", ",", "FigureResampler", ")", "\n", "assert", "len", "(", "f", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "f", ".", "data", "[", "0", "]", ".", "y", ")", "==", "1000", "\n", "assert", "len", "(", "f", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "f", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "1005", "\n", "\n", "", "fig1", "=", "fwr", "(", "fig", ")", "\n", "fig2", "=", "fwr", "(", "fr", "(", "fig", ")", ")", "\n", "fig3", "=", "fwr", "(", "fwr", "(", "fwr", "(", "fwr", "(", "fr", "(", "fr", "(", "fwr", "(", "fr", "(", "fwr", "(", "fig", ")", ")", ")", ")", ")", ")", ")", ")", ")", "\n", "for", "f", "in", "[", "fig1", ",", "fig2", ",", "fig3", "]", ":", "\n", "            ", "assert", "isinstance", "(", "f", ",", "FigureWidgetResampler", ")", "\n", "assert", "len", "(", "f", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "f", ".", "data", "[", "0", "]", ".", "y", ")", "==", "1000", "\n", "assert", "len", "(", "f", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "f", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "1005", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_add_trace_kwarg_space": [[16, 61], ["plotly.subplots.make_subplots", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.LTTB", "tuple", "plotly.Scatter", "plotly.Scatter", "plotly.Scattergl", "plotly_resampler.EveryNthPoint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["def", "test_add_trace_kwarg_space", "(", "float_series", ",", "bool_series", ",", "cat_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "kwarg_space_list", "=", "[", "\n", "{", "}", ",", "\n", "{", "\n", "\"default_downsampler\"", ":", "LTTB", "(", "interleave_gaps", "=", "True", ")", ",", "\n", "\"resampled_trace_prefix_suffix\"", ":", "tuple", "(", "[", "\"<b>[r]</b>\"", ",", "\"~~\"", "]", ")", ",", "\n", "\"verbose\"", ":", "True", ",", "\n", "}", ",", "\n", "]", "\n", "for", "kwarg_space", "in", "kwarg_space_list", ":", "\n", "        ", "fig", "=", "FigureResampler", "(", "base_fig", ",", "**", "kwarg_space", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "limit_to_view", "=", "False", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "text", "=", "\"text\"", ",", "name", "=", "\"bool_series\"", ")", ",", "\n", "hf_x", "=", "bool_series", ".", "index", ",", "\n", "hf_y", "=", "bool_series", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "2", ",", "\n", "limit_to_view", "=", "True", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "text", "=", "\"text\"", ",", "name", "=", "\"cat_series\"", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", "downsampler", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ",", "\n", "hf_x", "=", "cat_series", ".", "index", ",", "\n", "hf_y", "=", "cat_series", ",", "\n", "limit_to_view", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_add_trace_not_resampling": [[64, 93], ["plotly.subplots.make_subplots", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly.Scatter", "plotly.Scatter"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "", "def", "test_add_trace_not_resampling", "(", "float_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "float_series", ".", "index", "[", ":", "800", "]", ",", "y", "=", "float_series", "[", ":", "800", "]", ",", "name", "=", "\"float_series\"", "\n", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"float_series\"", ")", ",", "\n", "limit_to_view", "=", "False", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_x", "=", "float_series", ".", "index", "[", "-", "800", ":", "]", ",", "\n", "hf_y", "=", "float_series", "[", "-", "800", ":", "]", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_add_scatter_trace_no_data": [[96, 101], ["plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly.Scatter"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_add_scatter_trace_no_data", "(", ")", ":", "\n", "    ", "fig", "=", "FigureResampler", "(", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "# no x and y data", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_add_scatter_trace_no_x": [[103, 109], ["plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly.Figure", "plotly.Scatter", "plotly.Scatter"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_add_scatter_trace_no_x", "(", ")", ":", "\n", "    ", "fig", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "# no x data", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "y", "=", "[", "2", ",", "1", ",", "4", ",", "3", "]", ",", "name", "=", "\"s1\"", ")", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "name", "=", "\"s2\"", ")", ",", "hf_y", "=", "[", "2", ",", "1", ",", "4", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_add_not_a_hf_trace": [[111, 139], ["plotly.subplots.make_subplots", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly.Scatter", "plotly.Histogram"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_add_not_a_hf_trace", "(", "float_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "float_series", ".", "index", "[", ":", "800", "]", ",", "y", "=", "float_series", "[", ":", "800", "]", ",", "name", "=", "\"float_series\"", "\n", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "# add a not hf-trace", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Histogram", "(", "\n", "x", "=", "float_series", ",", "\n", "name", "=", "\"float_series\"", ",", "\n", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_box_histogram": [[142, 172], ["plotly.subplots.make_subplots", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly.Scattergl", "plotly.Box", "plotly.Box", "plotly.Histogram"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_box_histogram", "(", "float_series", ")", ":", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", ",", "name", "=", "\"float_series\"", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", ",", "name", "=", "\"float_series\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", "**", "2", ",", "name", "=", "\"float_series**2\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", "\n", ")", "\n", "\n", "# add a not hf-trace", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Histogram", "(", "\n", "x", "=", "float_series", ",", "\n", "name", "=", "\"float_series\"", ",", "\n", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_cat_box_histogram": [[175, 213], ["numpy.array", "pandas.Series", "plotly.subplots.make_subplots", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.update_layout", "list", "plotly.Scattergl", "plotly.Box", "plotly.Box", "plotly.Histogram", "numpy.random.choice", "numpy.random.choice", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_cat_box_histogram", "(", "float_series", ")", ":", "\n", "# Create a categorical series, with mostly a's, but a few sparse b's and c's", "\n", "    ", "cats_list", "=", "np", ".", "array", "(", "list", "(", "\"aaaaaaaaaa\"", "*", "1000", ")", ")", "\n", "cats_list", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "cats_list", ")", ",", "100", ",", "replace", "=", "False", ")", "]", "=", "\"b\"", "\n", "cats_list", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "cats_list", ")", ",", "50", ",", "replace", "=", "False", ")", "]", "=", "\"c\"", "\n", "cat_series", "=", "pd", ".", "Series", "(", "cats_list", ",", "dtype", "=", "\"category\"", ")", "\n", "\n", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "\"cat_series\"", ",", "x", "=", "cat_series", ".", "index", ",", "y", "=", "cat_series", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", ",", "name", "=", "\"float_box_pow\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", "**", "2", ",", "name", "=", "\"float_box_pow_2\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", "\n", ")", "\n", "\n", "# add a not hf-trace", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Histogram", "(", "\n", "x", "=", "float_series", ",", "\n", "name", "=", "\"float_hist\"", ",", "\n", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "\n", "fig", ".", "update_layout", "(", "height", "=", "700", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_replace_figure": [[215, 242], ["plotly.subplots.make_subplots", "plotly_resampler.FigureResampler", "plotly.Figure", "go.Figure.add_trace", "plotly_resampler.FigureResampler.replace", "plotly_resampler.FigureResampler.replace", "plotly.Scattergl", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace"], ["", "def", "test_replace_figure", "(", "float_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fr_fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "go_fig", "=", "go", ".", "Figure", "(", ")", "\n", "go_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", ",", "name", "=", "\"fs\"", ")", ")", "\n", "\n", "fr_fig", ".", "replace", "(", "go_fig", ",", "convert_existing_traces", "=", "False", ")", "\n", "# assert len(fr_fig.data) == 1", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "len", "(", "float_series", ")", "\n", "# the orig float series data must still be the orig shape (we passed a view so", "\n", "# we must check this)", "\n", "assert", "len", "(", "go_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "len", "(", "float_series", ")", "\n", "\n", "fr_fig", ".", "replace", "(", "go_fig", ",", "convert_existing_traces", "=", "True", ")", "\n", "# assert len(fr_fig.data) == 1", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1000", "\n", "\n", "# the orig float series data must still be the orig shape (we passed a view so", "\n", "# we must check this)", "\n", "assert", "len", "(", "go_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "len", "(", "float_series", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_nan_removed_input": [[244, 291], ["plotly.subplots.make_subplots", "plotly_resampler.FigureResampler", "float_series.copy.copy", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly.Scatter", "plotly.Scatter", "plotly.Scattergl", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "len", "len", "float_series.copy.rolling().mean().round().astype", "len", "float_series.copy.rolling().mean().round().astype", "float_series.copy.rolling().mean().round", "float_series.copy.rolling().mean().round", "float_series.copy.rolling().mean", "float_series.copy.rolling().mean", "float_series.copy.rolling", "float_series.copy.rolling"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_nan_removed_input", "(", "float_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", "\n", "base_fig", ",", "\n", "default_n_shown_samples", "=", "1000", ",", "\n", "resampled_trace_prefix_suffix", "=", "(", "\n", "'<b style=\"color:sandybrown\">[R]</b>'", ",", "\n", "'<b style=\"color:sandybrown\">[R]</b>'", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "float_series", "=", "float_series", ".", "copy", "(", ")", "\n", "float_series", ".", "iloc", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "float_series", ")", ",", "100", ")", "]", "=", "np", ".", "nan", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", ",", "name", "=", "\"float_series\"", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "# here we test whether we are able to deal with not-nan output", "\n", "float_series", ".", "iloc", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "float_series", ")", ",", "100", ")", "]", "=", "np", ".", "nan", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", "\n", ")", ",", "# we explicitly do not add a name", "\n", "hf_hovertext", "=", "\"mean\"", "+", "float_series", ".", "rolling", "(", "10", ")", ".", "mean", "(", ")", ".", "round", "(", "2", ")", ".", "astype", "(", "\"str\"", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "\n", "float_series", ".", "iloc", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "float_series", ")", ",", "100", ")", "]", "=", "np", ".", "nan", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "\n", "x", "=", "float_series", ".", "index", ",", "\n", "y", "=", "float_series", ",", "\n", "text", "=", "\"mean\"", "+", "float_series", ".", "rolling", "(", "10", ")", ".", "mean", "(", ")", ".", "round", "(", "2", ")", ".", "astype", "(", "\"str\"", ")", ",", "\n", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_hf_text": [[294, 319], ["numpy.arange", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "numpy.all", "numpy.all", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "numpy.all", "numpy.all", "plotly.Scatter", "len", "plotly.Scatter", "len", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype().astype", "np.arange.astype", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype().astype", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype", "plotly_resampler.FigureResampler.data[].y.astype"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_hf_text", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "arange", "(", "10_000", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ",", "text", "=", "y", ".", "astype", "(", "str", ")", ")", ",", "\n", "hf_y", "=", "y", ",", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "is", "None", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "text", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "is", "None", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ")", ",", "hf_y", "=", "y", ",", "hf_text", "=", "y", ".", "astype", "(", "str", ")", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "is", "None", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "text", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_hf_hovertext": [[321, 346], ["numpy.arange", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "numpy.all", "numpy.all", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "numpy.all", "numpy.all", "plotly.Scatter", "len", "plotly.Scatter", "len", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype().astype", "np.arange.astype", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype().astype", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype", "plotly_resampler.FigureResampler.data[].y.astype"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_hf_hovertext", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "arange", "(", "10_000", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ",", "hovertext", "=", "y", ".", "astype", "(", "str", ")", ")", ",", "\n", "hf_y", "=", "y", ",", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "is", "None", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "data", "[", "0", "]", ".", "text", "is", "None", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ")", ",", "hf_y", "=", "y", ",", "hf_hovertext", "=", "y", ".", "astype", "(", "str", ")", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "is", "None", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "data", "[", "0", "]", ".", "text", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_hf_text_and_hf_hovertext": [[348, 381], ["numpy.arange", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "plotly.Scatter", "len", "plotly.Scatter", "len", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype().astype", "np.arange.astype", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype().astype", "np.arange.astype", "np.arange.astype", "np.arange.astype", "np.arange.astype", "np.arange.astype", "plotly_resampler.FigureResampler.data[].y.astype", "plotly_resampler.FigureResampler.data[].y.astype"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_hf_text_and_hf_hovertext", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "arange", "(", "10_000", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ",", "text", "=", "y", ".", "astype", "(", "str", ")", ",", "hovertext", "=", "y", ".", "astype", "(", "str", ")", "[", ":", ":", "-", "1", "]", ")", ",", "\n", "hf_y", "=", "y", ",", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "==", "y", ".", "astype", "(", "str", ")", "[", ":", ":", "-", "1", "]", ")", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "text", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "np", ".", "all", "(", "\n", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "==", "(", "9_999", "-", "fig", ".", "data", "[", "0", "]", ".", "y", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ")", ",", "\n", "hf_y", "=", "y", ",", "\n", "hf_text", "=", "y", ".", "astype", "(", "str", ")", ",", "\n", "hf_hovertext", "=", "y", ".", "astype", "(", "str", ")", "[", ":", ":", "-", "1", "]", ",", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "==", "y", ".", "astype", "(", "str", ")", "[", ":", ":", "-", "1", "]", ")", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "text", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "np", ".", "all", "(", "\n", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "==", "(", "9_999", "-", "fig", ".", "data", "[", "0", "]", ".", "y", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_multiple_timezones": [[384, 413], ["pandas.date_range", "numpy.random.randn", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.update_layout", "enumerate", "pd.date_range.tz_localize().tz_localize", "pd.date_range.tz_convert", "pd.date_range.tz_convert", "pd.date_range.tz_convert", "plotly.subplots.make_subplots", "plotly_resampler.FigureResampler.add_trace", "min", "plotly.Scattergl", "pd.date_range.tz_localize", "len", "len", "date_range.dtype.name.split"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_multiple_timezones", "(", ")", ":", "\n", "    ", "n", "=", "5_050", "\n", "\n", "dr", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", "\n", "dr_v", "=", "np", ".", "random", ".", "randn", "(", "n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fr_fig", "=", "FigureResampler", "(", "\n", "make_subplots", "(", "rows", "=", "len", "(", "cs", ")", ",", "cols", "=", "1", ",", "shared_xaxes", "=", "True", ")", ",", "\n", "default_n_shown_samples", "=", "500", ",", "\n", "convert_existing_traces", "=", "False", ",", "\n", "verbose", "=", "True", ",", "\n", ")", "\n", "fr_fig", ".", "update_layout", "(", "height", "=", "min", "(", "300", ",", "250", "*", "len", "(", "cs", ")", ")", ")", "\n", "\n", "for", "i", ",", "date_range", "in", "enumerate", "(", "cs", ",", "1", ")", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "date_range", ".", "dtype", ".", "name", ".", "split", "(", "\", \"", ")", "[", "-", "1", "]", ")", ",", "\n", "hf_x", "=", "date_range", ",", "\n", "hf_y", "=", "dr_v", ",", "\n", "row", "=", "i", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_proper_copy_of_wrapped_fig": [[416, 435], ["plotly.Figure", "go.Figure.add_trace", "plotly_resampler.FigureResampler", "all", "all", "plotly.Scatter", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "", "def", "test_proper_copy_of_wrapped_fig", "(", "float_series", ")", ":", "\n", "    ", "plotly_fig", "=", "go", ".", "Figure", "(", ")", "\n", "plotly_fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "float_series", ".", "index", ",", "\n", "y", "=", "float_series", ",", "\n", ")", "\n", ")", "\n", "\n", "plotly_resampler_fig", "=", "FigureResampler", "(", "plotly_fig", ",", "default_n_shown_samples", "=", "500", ")", "\n", "\n", "assert", "len", "(", "plotly_fig", ".", "data", ")", "==", "1", "\n", "assert", "all", "(", "plotly_fig", ".", "data", "[", "0", "]", ".", "x", "==", "float_series", ".", "index", ")", "\n", "assert", "all", "(", "plotly_fig", ".", "data", "[", "0", "]", ".", "y", "==", "float_series", ".", "values", ")", "\n", "assert", "(", "len", "(", "plotly_fig", ".", "data", "[", "0", "]", ".", "x", ")", ">", "500", ")", "&", "(", "len", "(", "plotly_fig", ".", "data", "[", "0", "]", ".", "y", ")", ">", "500", ")", "\n", "\n", "assert", "len", "(", "plotly_resampler_fig", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "plotly_resampler_fig", ".", "data", "[", "0", "]", ".", "x", ")", "==", "500", "\n", "assert", "len", "(", "plotly_resampler_fig", ".", "data", "[", "0", "]", ".", "y", ")", "==", "500", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_2d_input_y": [[437, 458], ["pandas.DataFrame", "plotly.Figure", "go.Figure.add_trace", "plotly.Scatter", "pytest.raises", "plotly_resampler.FigureResampler", "numpy.arange", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_2d_input_y", "(", ")", ":", "\n", "# Create some dummy dataframe with a nan", "\n", "    ", "df", "=", "pd", ".", "DataFrame", "(", "\n", "index", "=", "np", ".", "arange", "(", "5_000", ")", ",", "data", "=", "{", "\"a\"", ":", "np", ".", "arange", "(", "5_000", ")", ",", "\"b\"", ":", "np", ".", "arange", "(", "5_000", ")", "}", "\n", ")", "\n", "df", ".", "iloc", "[", "42", "]", "=", "np", ".", "nan", "\n", "\n", "plotly_fig", "=", "go", ".", "Figure", "(", ")", "\n", "plotly_fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "df", ".", "index", ",", "\n", "y", "=", "df", "[", "[", "\"a\"", "]", "]", ",", "# (100, 1) shape", "\n", ")", "\n", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", "as", "e_info", ":", "\n", "        ", "_", "=", "FigureResampler", "(", "# does not alter plotly_fig", "\n", "plotly_fig", ",", "\n", "default_n_shown_samples", "=", "500", ",", "\n", ")", "\n", "assert", "\"1 dimensional\"", "in", "e_info", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_time_tz_slicing": [[460, 483], ["pandas.Series", "plotly_resampler.FigureResampler", "pd.Series.tz_localize", "pd.Series.tz_localize().tz_localize", "pd.Series.tz_convert", "pd.Series.tz_convert", "pd.Series.tz_convert", "plotly.Figure", "sorted", "plotly_resampler.FigureResampler._slice_time", "pandas.date_range", "numpy.random.randn", "pandas.Timedelta", "pandas.Timedelta", "pd.Series.tz_localize", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time"], ["", "", "def", "test_time_tz_slicing", "(", ")", ":", "\n", "    ", "n", "=", "5050", "\n", "dr", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", ",", "\n", "data", "=", "np", ".", "random", ".", "randn", "(", "n", ")", ",", "\n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fig", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "\n", "for", "s", "in", "cs", ":", "\n", "        ", "t_start", ",", "t_stop", "=", "sorted", "(", "s", ".", "iloc", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "n", ",", "2", ")", "]", ".", "index", ")", "\n", "out", "=", "fig", ".", "_slice_time", "(", "s", ",", "t_start", ",", "t_stop", ")", "\n", "assert", "(", "out", ".", "index", "[", "0", "]", "-", "t_start", ")", "<=", "pd", ".", "Timedelta", "(", "seconds", "=", "1", ")", "\n", "assert", "(", "out", ".", "index", "[", "-", "1", "]", "-", "t_stop", ")", "<=", "pd", ".", "Timedelta", "(", "seconds", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_time_tz_slicing_different_timestamp": [[485, 512], ["pandas.Series", "plotly_resampler.FigureResampler", "enumerate", "pd.Series.tz_localize().tz_localize", "pd.Series.tz_convert", "pd.Series.tz_convert", "pd.Series.tz_convert", "plotly.Figure", "sorted", "t_start.tz_convert.tz_convert", "t_stop.tz_convert.tz_convert", "pandas.date_range", "numpy.random.randn", "pytest.raises", "plotly_resampler.FigureResampler._slice_time", "pd.Series.tz_localize", "numpy.random.randint", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time"], ["", "", "def", "test_time_tz_slicing_different_timestamp", "(", ")", ":", "\n", "# construct a time indexed series with UTC timezone", "\n", "    ", "n", "=", "60", "*", "60", "*", "24", "*", "3", "\n", "dr", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", ",", "\n", "data", "=", "np", ".", "random", ".", "randn", "(", "n", ")", ",", "\n", ")", "\n", "\n", "# create multiple other time zones", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fig", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "cs", ")", ":", "\n", "        ", "t_start", ",", "t_stop", "=", "sorted", "(", "s", ".", "iloc", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "n", ",", "2", ")", "]", ".", "index", ")", "\n", "t_start", "=", "t_start", ".", "tz_convert", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "t_stop", "=", "t_stop", ".", "tz_convert", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "\n", "# As each timezone in CS tz aware, using other timezones in `t_start` & `t_stop`", "\n", "# will raise an AssertionError", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "fig", ".", "_slice_time", "(", "s", ",", "t_start", ",", "t_stop", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_different_tz_no_tz_series_slicing": [[514, 548], ["pandas.Series", "plotly_resampler.FigureResampler", "enumerate", "pd.Series.tz_localize", "pd.Series.tz_localize().tz_localize", "pd.Series.tz_convert", "pd.Series.tz_convert", "pd.Series.tz_convert", "plotly.Figure", "sorted", "t_start.tz_localize.tz_localize", "t_stop.tz_localize.tz_localize", "plotly_resampler.FigureResampler._slice_time", "pandas.date_range", "numpy.random.randn", "s.tz_localize", "pandas.Timedelta", "pandas.Timedelta", "pd.Series.tz_localize", "fig._slice_time.index[].tz_localize", "fig._slice_time.index[].tz_localize", "s.tz_localize", "numpy.random.randint", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time"], ["", "", "", "def", "test_different_tz_no_tz_series_slicing", "(", ")", ":", "\n", "    ", "n", "=", "60", "*", "60", "*", "24", "*", "3", "\n", "dr", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", ",", "\n", "data", "=", "np", ".", "random", ".", "randn", "(", "n", ")", ",", "\n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fig", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "cs", ")", ":", "\n", "        ", "t_start", ",", "t_stop", "=", "sorted", "(", "\n", "s", ".", "tz_localize", "(", "None", ")", ".", "iloc", "[", "np", ".", "random", ".", "randint", "(", "n", "/", "2", ",", "n", ",", "2", ")", "]", ".", "index", "\n", ")", "\n", "# both timestamps now have the same tz", "\n", "t_start", "=", "t_start", ".", "tz_localize", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "t_stop", "=", "t_stop", ".", "tz_localize", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "\n", "# the s has no time-info -> assumption is made that s has the same time-zone", "\n", "# the timestamps", "\n", "out", "=", "fig", ".", "_slice_time", "(", "s", ".", "tz_localize", "(", "None", ")", ",", "t_start", ",", "t_stop", ")", "\n", "assert", "(", "out", ".", "index", "[", "0", "]", ".", "tz_localize", "(", "t_start", ".", "tz", ")", "-", "t_start", ")", "<=", "pd", ".", "Timedelta", "(", "\n", "seconds", "=", "1", "\n", ")", "\n", "assert", "(", "out", ".", "index", "[", "-", "1", "]", ".", "tz_localize", "(", "t_stop", ".", "tz", ")", "-", "t_stop", ")", "<=", "pd", ".", "Timedelta", "(", "\n", "seconds", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_multiple_tz_no_tz_series_slicing": [[551, 581], ["pandas.Series", "plotly_resampler.FigureResampler", "enumerate", "pd.Series.tz_localize", "pd.Series.tz_localize().tz_localize", "pd.Series.tz_convert", "pd.Series.tz_convert", "pd.Series.tz_convert", "plotly.Figure", "sorted", "t_start.tz_localize.tz_localize", "t_stop.tz_localize.tz_localize", "pandas.date_range", "numpy.random.randn", "pytest.raises", "plotly_resampler.FigureResampler._slice_time", "pd.Series.tz_localize", "s.tz_localize", "s.tz_localize", "numpy.random.randint", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time"], ["", "", "def", "test_multiple_tz_no_tz_series_slicing", "(", ")", ":", "\n", "    ", "n", "=", "60", "*", "60", "*", "24", "*", "3", "\n", "dr", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", ",", "\n", "data", "=", "np", ".", "random", ".", "randn", "(", "n", ")", ",", "\n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fig", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "cs", ")", ":", "\n", "        ", "t_start", ",", "t_stop", "=", "sorted", "(", "\n", "s", ".", "tz_localize", "(", "None", ")", ".", "iloc", "[", "np", ".", "random", ".", "randint", "(", "n", "/", "2", ",", "n", ",", "2", ")", "]", ".", "index", "\n", ")", "\n", "# both timestamps now have the a different tz", "\n", "t_start", "=", "t_start", ".", "tz_localize", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "t_stop", "=", "t_stop", ".", "tz_localize", "(", "cs", "[", "(", "i", "+", "2", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "\n", "# Now the assumption cannot be made that s has the same time-zone as the", "\n", "# timestamps -> AssertionError will be raised.", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "fig", ".", "_slice_time", "(", "s", ".", "tz_localize", "(", "None", ")", ",", "t_start", ",", "t_stop", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_check_update_figure_dict": [[583, 592], ["plotly_resampler.FigureResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler._check_update_figure_dict", "plotly.Figure", "plotly.Scattergl", "plotly_resampler.FigureResampler.to_dict"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict"], ["", "", "", "def", "test_check_update_figure_dict", "(", ")", ":", "\n", "# mostly written to test the check_update_figure_dict with", "\n", "# \"updated_trace_indices\" = None", "\n", "    ", "fr", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "fr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "fr", ".", "_check_update_figure_dict", "(", "fr", ".", "to_dict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_stop_server_inline": [[594, 611], ["plotly_resampler.FigureResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.update_layout", "plotly_resampler.FigureResampler.stop_server", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "plotly_resampler.FigureResampler.stop_server", "multiprocessing.Process.terminate", "plotly.Figure", "plotly.Scattergl", "dict"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.stop_server", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.stop_server"], ["", "def", "test_stop_server_inline", "(", ")", ":", "\n", "# mostly written to test the check_update_figure_dict whether the inline + height", "\n", "# line option triggers", "\n", "    ", "fr", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "fr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "fr", ".", "update_layout", "(", "height", "=", "900", ")", "\n", "fr", ".", "stop_server", "(", ")", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "target", "=", "fr", ".", "show_dash", ",", "kwargs", "=", "dict", "(", "mode", "=", "\"inline\"", ")", ")", "\n", "proc", ".", "start", "(", ")", "\n", "import", "time", "\n", "\n", "time", ".", "sleep", "(", "3", ")", "\n", "fr", ".", "stop_server", "(", ")", "\n", "proc", ".", "terminate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_stop_server_external": [[613, 628], ["plotly_resampler.FigureResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.update_layout", "plotly_resampler.FigureResampler.stop_server", "multiprocessing.Process", "multiprocessing.Process.start", "time.sleep", "plotly_resampler.FigureResampler.stop_server", "multiprocessing.Process.terminate", "plotly.Figure", "plotly.Scattergl", "dict"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.stop_server", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler.FigureResampler.stop_server"], ["", "def", "test_stop_server_external", "(", ")", ":", "\n", "    ", "fr", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "fr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "fr", ".", "update_layout", "(", "height", "=", "900", ")", "\n", "fr", ".", "stop_server", "(", ")", "\n", "proc", "=", "multiprocessing", ".", "Process", "(", "target", "=", "fr", ".", "show_dash", ",", "kwargs", "=", "dict", "(", "mode", "=", "\"external\"", ")", ")", "\n", "proc", ".", "start", "(", ")", "\n", "import", "time", "\n", "\n", "time", ".", "sleep", "(", "3", ")", "\n", "fr", ".", "stop_server", "(", ")", "\n", "proc", ".", "terminate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_hf_data_property": [[630, 640], ["plotly_resampler.FigureResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureResampler.add_trace", "plotly.Figure", "len", "plotly.Scattergl", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_hf_data_property", "(", ")", ":", "\n", "    ", "fr", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ",", "default_n_shown_samples", "=", "2_000", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "assert", "len", "(", "fr", ".", "hf_data", ")", "==", "0", "\n", "fr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "assert", "len", "(", "fr", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "fr", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "n", "\n", "fr", ".", "hf_data", "[", "0", "]", "=", "-", "2", "*", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_add_empty_trace": [[642, 649], ["plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly.Figure", "plotly.Scattergl", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fr_add_empty_trace", "(", ")", ":", "\n", "    ", "fig", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"Test\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "0", "\n", "assert", "len", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_from_dict": [[651, 669], ["numpy.array", "plotly_resampler.FigureResampler", "len", "len", "len"], "function", ["None"], ["", "def", "test_fr_from_dict", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "array", "(", "[", "1", "]", "*", "10_000", ")", "\n", "base_fig", "=", "{", "\n", "\"type\"", ":", "\"scatter\"", ",", "\n", "\"y\"", ":", "y", ",", "\n", "}", "\n", "\n", "fr_fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "y", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "[", "1", "]", "*", "1_000", ")", ".", "all", "(", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "# this is a proxy for assuring that the dynamic aggregation should work", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_empty_list": [[671, 676], ["plotly_resampler.FigureResampler", "len", "len"], "function", ["None"], ["", "def", "test_fr_empty_list", "(", ")", ":", "\n", "# and empty list -> so no concrete traces were added", "\n", "    ", "fr_fig", "=", "FigureResampler", "(", "[", "]", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "0", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_empty_dict": [[678, 683], ["plotly_resampler.FigureResampler", "len", "len"], "function", ["None"], ["", "def", "test_fr_empty_dict", "(", ")", ":", "\n", "# a dict is a concrete trace so 1 trace should be added", "\n", "    ", "fr_fig", "=", "FigureResampler", "(", "{", "}", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "0", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_wrong_keys": [[685, 691], ["pytest.raises", "plotly_resampler.FigureResampler"], "function", ["None"], ["", "def", "test_fr_wrong_keys", "(", "float_series", ")", ":", "\n", "    ", "base_fig", "=", "[", "\n", "{", "\"ydata\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ",", "\n", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_from_list_dict": [[693, 718], ["plotly_resampler.FigureResampler", "base_fig.append", "plotly_resampler.FigureResampler", "len", "len", "len", "len", "len"], "function", ["None"], ["", "", "def", "test_fr_from_list_dict", "(", "float_series", ")", ":", "\n", "    ", "base_fig", ":", "List", "[", "dict", "]", "=", "[", "\n", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ",", "\n", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ",", "\n", "]", "\n", "\n", "fr_fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "# both traces are HF traces so should be aggregated", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "float_series", "+", "2", ")", ".", "all", "(", ")", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "==", "float_series", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "assert", "fr_fig", ".", "data", "[", "1", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n", "# redo the exercise with a new low-freq trace", "\n", "base_fig", ".", "append", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_no_agg\"", "}", ")", "\n", "fr_fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_list_dict_add_traces": [[720, 756], ["plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_traces", "plotly_resampler.FigureResampler.add_traces", "plotly_resampler.FigureResampler.add_traces", "plotly_resampler.FigureResampler.add_traces", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces"], ["", "def", "test_fr_list_dict_add_traces", "(", "float_series", ")", ":", "\n", "    ", "fr_fig", "=", "FigureResampler", "(", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "traces", ":", "List", "[", "dict", "]", "=", "[", "\n", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ",", "\n", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ",", "\n", "]", "\n", "fr_fig", ".", "add_traces", "(", "traces", ")", "\n", "# both traces are HF traces so should be aggregated", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "float_series", "+", "2", ")", ".", "all", "(", ")", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "==", "float_series", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "assert", "fr_fig", ".", "data", "[", "1", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n", "# redo the exercise with a new low-freq trace", "\n", "fr_fig", ".", "add_traces", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_no_agg\"", "}", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "3", "\n", "\n", "# add low-freq trace but set limit_to_view to True", "\n", "fr_fig", ".", "add_traces", "(", "[", "{", "\"y\"", ":", "float_series", "[", ":", "100", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", "]", ",", "limit_to_views", "=", "True", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "3", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "4", "\n", "\n", "# add a low-freq trace but adjust max_n_samples", "\n", "# note that we use a tuple as input here", "\n", "fr_fig", ".", "add_traces", "(", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", ",", ")", ",", "max_n_samples", "=", "999", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "4", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_list_dict_add_trace": [[758, 803], ["plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "len", "len", "len", "len", "len", "len", "len", "pytest.raises", "plotly_resampler.FigureResampler.add_trace", "pytest.raises", "plotly_resampler.FigureResampler.add_trace", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fr_list_dict_add_trace", "(", "float_series", ")", ":", "\n", "    ", "fr_fig", "=", "FigureResampler", "(", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "traces", ":", "List", "[", "dict", "]", "=", "[", "\n", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ",", "\n", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ",", "\n", "]", "\n", "for", "trace", "in", "traces", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "trace", ")", "\n", "\n", "# both traces are HF traces so should be aggregated", "\n", "", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "float_series", "+", "2", ")", ".", "all", "(", ")", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "==", "float_series", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "assert", "fr_fig", ".", "data", "[", "1", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n", "# redo the exercise with a new low-freq trace", "\n", "fr_fig", ".", "add_trace", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_no_agg\"", "}", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "3", "\n", "\n", "# add low-freq trace but set limit_to_view to True", "\n", "fr_fig", ".", "add_trace", "(", "{", "\"y\"", ":", "float_series", "[", ":", "100", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", ",", "limit_to_view", "=", "True", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "3", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "4", "\n", "\n", "# add a low-freq trace but adjust max_n_samples", "\n", "lf_series", "=", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", "\n", "# plotly its default behavior raises a ValueError when a list or tuple is passed", "\n", "# to add_trace", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "[", "lf_series", "]", ",", "max_n_samples", "=", "999", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "(", "lf_series", ",", ")", ",", "max_n_samples", "=", "999", ")", "\n", "\n", "", "fr_fig", ".", "add_trace", "(", "lf_series", ",", "max_n_samples", "=", "999", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "4", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_list_scatter_add_traces": [[805, 842], ["plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_traces", "plotly_resampler.FigureResampler.add_traces", "plotly_resampler.FigureResampler.add_traces", "plotly_resampler.FigureResampler.add_traces", "plotly.Scattergl", "plotly.Scatter", "tuple", "len", "len", "len", "len", "len", "plotly.Scattergl", "len", "len", "plotly.Scatter", "len", "len", "plotly.Scattergl"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces"], ["", "def", "test_fr_list_scatter_add_traces", "(", "float_series", ")", ":", "\n", "    ", "fr_fig", "=", "FigureResampler", "(", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "traces", ":", "List", "[", "dict", "]", "=", "[", "\n", "go", ".", "Scattergl", "(", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ")", ",", "\n", "go", ".", "Scatter", "(", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ")", ",", "\n", "]", "\n", "fr_fig", ".", "add_traces", "(", "tuple", "(", "traces", ")", ")", "\n", "# both traces are HF traces so should be aggregated", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "float_series", "+", "2", ")", ".", "all", "(", ")", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "==", "float_series", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "assert", "fr_fig", ".", "data", "[", "1", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n", "# redo the exercise with a new low-freq trace", "\n", "fr_fig", ".", "add_traces", "(", "[", "go", ".", "Scattergl", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_no_agg\"", "}", ")", "]", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "3", "\n", "\n", "# add low-freq trace but set limit_to_view to True", "\n", "fr_fig", ".", "add_traces", "(", "go", ".", "Scattergl", "(", ")", ",", "limit_to_views", "=", "True", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "3", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "4", "\n", "\n", "# add a low-freq trace but adjust max_n_samples", "\n", "fr_fig", ".", "add_traces", "(", "\n", "go", ".", "Scatter", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", ")", ",", "max_n_samples", "=", "999", "\n", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "4", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_add_scatter": [[844, 855], ["plotly.Figure().add_scatter", "plotly_resampler.FigureResampler().add_scatter", "numpy.all", "len", "len", "len", "plotly.Figure", "numpy.arange", "plotly_resampler.FigureResampler", "numpy.arange", "len", "len"], "function", ["None"], ["", "def", "test_fr_add_scatter", "(", ")", ":", "\n", "# Checks whether the add_scatter method works as expected", "\n", "# .add_scatter calls `add_traces` under the hood", "\n", "    ", "f_orig", "=", "go", ".", "Figure", "(", ")", ".", "add_scatter", "(", "y", "=", "np", ".", "arange", "(", "2_000", ")", ")", "\n", "f_pr", "=", "FigureResampler", "(", ")", ".", "add_scatter", "(", "y", "=", "np", ".", "arange", "(", "2_000", ")", ")", "\n", "\n", "assert", "len", "(", "f_orig", ".", "data", ")", "==", "1", "\n", "assert", "(", "len", "(", "f_pr", ".", "data", ")", "==", "1", ")", "&", "(", "len", "(", "f_pr", ".", "hf_data", ")", "==", "1", ")", "\n", "assert", "len", "(", "f_orig", ".", "data", "[", "0", "]", ".", "y", ")", "==", "2_000", "\n", "assert", "len", "(", "f_pr", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "1_000", "\n", "assert", "np", ".", "all", "(", "f_orig", ".", "data", "[", "0", "]", ".", "y", "==", "f_pr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_copy_hf_data": [[857, 875], ["plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_traces", "plotly_resampler.FigureResampler()._copy_hf_data", "numpy.arange", "plotly.Scattergl", "plotly.Scatter", "tuple", "list", "len", "len", "len", "len", "plotly_resampler.FigureResampler", "FigureResampler()._copy_hf_data.keys"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._copy_hf_data"], ["", "def", "test_fr_copy_hf_data", "(", "float_series", ")", ":", "\n", "    ", "fr_fig", "=", "FigureResampler", "(", "default_n_shown_samples", "=", "2000", ")", "\n", "traces", ":", "List", "[", "dict", "]", "=", "[", "\n", "go", ".", "Scattergl", "(", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ")", ",", "\n", "go", ".", "Scatter", "(", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ")", ",", "\n", "]", "\n", "fr_fig", ".", "add_traces", "(", "tuple", "(", "traces", ")", ")", "\n", "\n", "hf_data_cp", "=", "FigureResampler", "(", ")", ".", "_copy_hf_data", "(", "fr_fig", ".", "_hf_data", ")", "\n", "uid", "=", "list", "(", "hf_data_cp", ".", "keys", "(", ")", ")", "[", "0", "]", "\n", "\n", "hf_data_cp", "[", "uid", "]", "[", "\"x\"", "]", "=", "np", ".", "arange", "(", "1000", ")", "\n", "hf_data_cp", "[", "uid", "]", "[", "\"y\"", "]", "=", "float_series", "[", ":", "1000", "]", "\n", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "10_000", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "10_000", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"x\"", "]", ")", "==", "10_000", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", ")", "==", "10_000", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_object_hf_data": [[877, 886], ["float_series.astype", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fr_object_hf_data", "(", "float_series", ")", ":", "\n", "    ", "float_series_o", "=", "float_series", ".", "astype", "(", "object", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "float_series_o", ")", "\n", "assert", "float_series_o", ".", "dtype", "==", "object", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"float64\"", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"float64\"", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_object_bool_data": [[888, 907], ["plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "bool_series.astype", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fr_object_bool_data", "(", "bool_series", ")", ":", "\n", "# First try with the original non-object bool series", "\n", "    ", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "bool_series", ")", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"bool\"", "\n", "# plotly internally ocnverts this to object", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"object\"", "\n", "\n", "# Now try with the object bool series", "\n", "bool_series_o", "=", "bool_series", ".", "astype", "(", "object", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "bool_series_o", ")", "\n", "assert", "bool_series_o", ".", "dtype", "==", "object", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"bool\"", "\n", "# plotly internally converts this to object", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"object\"", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figure_resampler.test_fr_object_binary_data": [[909, 930], ["numpy.array", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "numpy.all", "np.array.astype", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "numpy.all", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fr_object_binary_data", "(", ")", ":", "\n", "    ", "binary_series", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", "*", "20", ")", "# as this is << max_n_samples -> limit_to_view", "\n", "\n", "# First try with the original non-object binary series", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "binary_series", ",", "limit_to_view", "=", "True", ")", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"int64\"", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"int64\"", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "binary_series", ")", "\n", "\n", "# Now try with the object binary series", "\n", "binary_series_o", "=", "binary_series", ".", "astype", "(", "object", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "binary_series_o", ",", "limit_to_view", "=", "True", ")", "\n", "assert", "binary_series_o", ".", "dtype", "==", "object", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"int64\"", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"int64\"", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "binary_series", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_utils.test_is_figure": [[15, 27], ["plotly_resampler.figure_resampler.utils.is_figure", "plotly_resampler.figure_resampler.utils.is_figure", "plotly_resampler.figure_resampler.utils.is_figure", "plotly_resampler.figure_resampler.utils.is_figure", "plotly.Figure", "plotly.Figure", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler", "plotly_resampler.figure_resampler.utils.is_figure", "plotly_resampler.figure_resampler.utils.is_figure", "plotly_resampler.figure_resampler.utils.is_figure", "plotly_resampler.figure_resampler.utils.is_figure", "plotly_resampler.figure_resampler.utils.is_figure", "plotly_resampler.figure_resampler.utils.is_figure", "plotly.FigureWidget", "plotly.Scatter", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figure"], ["def", "test_is_figure", "(", ")", ":", "\n", "    ", "fig_dict", "=", "{", "\"type\"", ":", "\"scatter\"", ",", "\"y\"", ":", "[", "1", ",", "2", ",", "3", "]", "}", "\n", "assert", "is_figure", "(", "go", ".", "Figure", "(", ")", ")", "\n", "assert", "is_figure", "(", "go", ".", "Figure", "(", "fig_dict", ")", ")", "\n", "assert", "is_figure", "(", "FigureResampler", "(", ")", ")", "\n", "assert", "is_figure", "(", "FigureResampler", "(", "fig_dict", ")", ")", "\n", "assert", "not", "is_figure", "(", "go", ".", "FigureWidget", "(", ")", ")", "\n", "assert", "not", "is_figure", "(", "None", ")", "\n", "assert", "not", "is_figure", "(", "fig_dict", ")", "\n", "assert", "not", "is_figure", "(", "go", ".", "Scatter", "(", "y", "=", "[", "1", ",", "2", ",", "3", "]", ")", ")", "\n", "assert", "not", "is_figure", "(", "FigureWidgetResampler", "(", ")", ")", "\n", "assert", "not", "is_figure", "(", "FigureWidgetResampler", "(", "fig_dict", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_utils.test_is_fr": [[29, 41], ["plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler", "plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.figure_resampler.utils.is_fr", "plotly_resampler.figure_resampler.utils.is_fr", "plotly.Figure", "plotly.Figure", "plotly.FigureWidget", "plotly.Scatter", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fr"], ["", "def", "test_is_fr", "(", ")", ":", "\n", "    ", "fig_dict", "=", "{", "\"type\"", ":", "\"scatter\"", ",", "\"y\"", ":", "[", "1", ",", "2", ",", "3", "]", "}", "\n", "assert", "is_fr", "(", "FigureResampler", "(", ")", ")", "\n", "assert", "is_fr", "(", "FigureResampler", "(", "fig_dict", ")", ")", "\n", "assert", "not", "is_fr", "(", "go", ".", "Figure", "(", ")", ")", "\n", "assert", "not", "is_fr", "(", "go", ".", "Figure", "(", "fig_dict", ")", ")", "\n", "assert", "not", "is_fr", "(", "go", ".", "FigureWidget", "(", ")", ")", "\n", "assert", "not", "is_fr", "(", "None", ")", "\n", "assert", "not", "is_fr", "(", "fig_dict", ")", "\n", "assert", "not", "is_fr", "(", "go", ".", "Scatter", "(", "y", "=", "[", "1", ",", "2", ",", "3", "]", ")", ")", "\n", "assert", "not", "is_fr", "(", "FigureWidgetResampler", "(", ")", ")", "\n", "assert", "not", "is_fr", "(", "FigureWidgetResampler", "(", "fig_dict", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_utils.test_is_figurewidget": [[43, 55], ["plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly.FigureWidget", "plotly.FigureWidget", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly_resampler.figure_resampler.utils.is_figurewidget", "plotly.Figure", "plotly.Scatter", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_figurewidget"], ["", "def", "test_is_figurewidget", "(", ")", ":", "\n", "    ", "fig_dict", "=", "{", "\"type\"", ":", "\"scatter\"", ",", "\"y\"", ":", "[", "1", ",", "2", ",", "3", "]", "}", "\n", "assert", "is_figurewidget", "(", "go", ".", "FigureWidget", "(", ")", ")", "\n", "assert", "is_figurewidget", "(", "go", ".", "FigureWidget", "(", "fig_dict", ")", ")", "\n", "assert", "is_figurewidget", "(", "FigureWidgetResampler", "(", ")", ")", "\n", "assert", "is_figurewidget", "(", "FigureWidgetResampler", "(", "fig_dict", ")", ")", "\n", "assert", "not", "is_figurewidget", "(", "go", ".", "Figure", "(", ")", ")", "\n", "assert", "not", "is_figurewidget", "(", "None", ")", "\n", "assert", "not", "is_figurewidget", "(", "fig_dict", ")", "\n", "assert", "not", "is_figurewidget", "(", "go", ".", "Scatter", "(", "y", "=", "[", "1", ",", "2", ",", "3", "]", ")", ")", "\n", "assert", "not", "is_figurewidget", "(", "FigureResampler", "(", ")", ")", "\n", "assert", "not", "is_figurewidget", "(", "FigureResampler", "(", "fig_dict", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_utils.test_is_fwr": [[57, 69], ["plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly_resampler.figure_resampler.utils.is_fwr", "plotly.FigureWidget", "plotly.FigureWidget", "plotly.Figure", "plotly.Scatter", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.is_fwr"], ["", "def", "test_is_fwr", "(", ")", ":", "\n", "    ", "fig_dict", "=", "{", "\"type\"", ":", "\"scatter\"", ",", "\"y\"", ":", "[", "1", ",", "2", ",", "3", "]", "}", "\n", "assert", "is_fwr", "(", "FigureWidgetResampler", "(", ")", ")", "\n", "assert", "is_fwr", "(", "FigureWidgetResampler", "(", "fig_dict", ")", ")", "\n", "assert", "not", "is_fwr", "(", "go", ".", "FigureWidget", "(", ")", ")", "\n", "assert", "not", "is_fwr", "(", "go", ".", "FigureWidget", "(", "fig_dict", ")", ")", "\n", "assert", "not", "is_fwr", "(", "go", ".", "Figure", "(", ")", ")", "\n", "assert", "not", "is_fwr", "(", "None", ")", "\n", "assert", "not", "is_fwr", "(", "fig_dict", ")", "\n", "assert", "not", "is_fwr", "(", "go", ".", "Scatter", "(", "y", "=", "[", "1", ",", "2", ",", "3", "]", ")", ")", "\n", "assert", "not", "is_fwr", "(", "FigureResampler", "(", ")", ")", "\n", "assert", "not", "is_fwr", "(", "FigureResampler", "(", "fig_dict", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_utils.test_timedelta_to_str": [[71, 88], ["plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.timedelta_to_str", "plotly_resampler.figure_resampler.utils.timedelta_to_str", "plotly_resampler.figure_resampler.utils.timedelta_to_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "plotly_resampler.figure_resampler.utils.round_td_str", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta", "pandas.Timedelta"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.timedelta_to_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.timedelta_to_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.timedelta_to_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_td_str"], ["", "def", "test_timedelta_to_str", "(", ")", ":", "\n", "    ", "assert", "(", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"1W\"", ")", ")", ")", "==", "\"7D\"", "\n", "assert", "(", "timedelta_to_str", "(", "pd", ".", "Timedelta", "(", "\"1W\"", ")", ")", ")", "==", "\"7D\"", "\n", "assert", "(", "timedelta_to_str", "(", "pd", ".", "Timedelta", "(", "\"1W\"", ")", "*", "-", "1", ")", ")", "==", "\"NEG7D\"", "\n", "assert", "timedelta_to_str", "(", "pd", ".", "Timedelta", "(", "\"1s 114ms\"", ")", ")", "==", "\"1.114s\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"14.4ms\"", ")", ")", "==", "\"14ms\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"501ms\"", ")", ")", "==", "\"501ms\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"951ms\"", ")", ")", "==", "\"1s\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"950ms\"", ")", ")", "==", "\"950ms\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"949ms\"", ")", ")", "==", "\"949ms\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"500ms\"", ")", ")", "==", "\"500ms\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"14.4ms\"", ")", ")", "==", "\"14ms\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"14.6ms\"", ")", ")", "==", "\"15ms\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"1h 14.4us\"", ")", ")", "==", "\"1h\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"1128.9us\"", ")", ")", "==", "\"1ms\"", "\n", "assert", "round_td_str", "(", "pd", ".", "Timedelta", "(", "\"128.9us\"", ")", ")", "==", "\"129us\"", "\n", "assert", "round_td_str", "(", "(", "pd", ".", "Timedelta", "(", "\"14ns\"", ")", ")", ")", "==", "\"14ns\"", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_utils.test_round_int_str": [[90, 111], ["plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str", "plotly_resampler.figure_resampler.utils.round_number_str"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.utils.round_number_str"], ["", "def", "test_round_int_str", "(", ")", ":", "\n", "    ", "assert", "round_number_str", "(", "0.951", ")", "==", "\"1\"", "\n", "assert", "round_number_str", "(", "0.95", ")", "==", "\"0.9\"", "\n", "assert", "round_number_str", "(", "0.949", ")", "==", "\"0.9\"", "\n", "assert", "round_number_str", "(", "0.00949", ")", "==", "\"0.009\"", "\n", "assert", "round_number_str", "(", "0.00950", ")", "==", "\"0.009\"", "\n", "assert", "round_number_str", "(", "0.00951", ")", "==", "\"0.01\"", "\n", "assert", "round_number_str", "(", "0.0044", ")", "==", "\"0.004\"", "\n", "assert", "round_number_str", "(", "0.00451", ")", "==", "\"0.005\"", "\n", "assert", "round_number_str", "(", "0.0001", ")", "==", "\"0.0001\"", "\n", "assert", "round_number_str", "(", "0.00001", ")", "==", "\"1e-05\"", "\n", "assert", "round_number_str", "(", "0.000000321", ")", "==", "\"3e-07\"", "\n", "assert", "round_number_str", "(", "12_000", ")", "==", "\"12k\"", "\n", "assert", "round_number_str", "(", "13_340", ")", "==", "\"13k\"", "\n", "assert", "round_number_str", "(", "13_540", ")", "==", "\"14k\"", "\n", "assert", "round_number_str", "(", "559_540", ")", "==", "\"560k\"", "\n", "assert", "round_number_str", "(", "949_000", ")", "==", "\"949k\"", "\n", "assert", "round_number_str", "(", "950_000", ")", "==", "\"950k\"", "\n", "assert", "round_number_str", "(", "950_001", ")", "==", "\"1M\"", "\n", "assert", "round_number_str", "(", "1_950_001", ")", "==", "\"2M\"", "\n", "assert", "round_number_str", "(", "111_950_001", ")", "==", "\"112M\"", "\n", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests": [[33, 46], ["valid_requests.append", "r.method.upper", "r.url.endswith"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "filter_callback_requests", "(", "requests", ":", "List", "[", "Request", "]", ")", "->", "List", "[", "Request", "]", ":", "\n", "        ", "valid_requests", "=", "[", "]", "\n", "for", "r", "in", "requests", ":", "\n", "            ", "if", "r", ".", "method", ".", "upper", "(", ")", "!=", "\"POST\"", ":", "\n", "# note; the `_reload_hash` GET request will thus be filtered out", "\n", "                ", "continue", "\n", "\n", "", "if", "not", "r", ".", "url", ".", "endswith", "(", "\"_dash-update-component\"", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "valid_requests", ".", "append", "(", "r", ")", "\n", "", "return", "valid_requests", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.assert_fetch_data_request": [[47, 85], ["json.loads", "all", "range", "json.loads", "len", "len"], "methods", ["None"], ["", "def", "assert_fetch_data_request", "(", "\n", "data_request", ":", "Request", ",", "relayout_keys", ":", "List", "[", "str", "]", ",", "n_updated_traces", ":", "int", "\n", ")", ":", "\n", "        ", "\"\"\"Withholds checks for the relayout-data fetch request\n\n        Parameters\n        ----------\n        data_request : Request\n            The relayout data fetch request, with\n            * Request body: the relayout changes\n            * Response body: a list of dicts with first tiem\n        relayout_keys : List[str]\n            The expected keys to be found in the relayout command\n        n_updated_traces : int\n            The expected amount of traces which will be updated.\n\n        \"\"\"", "\n", "fetch_data_body", "=", "json", ".", "loads", "(", "data_request", ".", "body", ")", "\n", "assert", "\"inputs\"", "in", "fetch_data_body", "and", "len", "(", "fetch_data_body", "[", "\"inputs\"", "]", ")", "==", "1", "\n", "assert", "fetch_data_body", "[", "\"inputs\"", "]", "[", "0", "]", "[", "\"id\"", "]", "==", "\"resample-figure\"", "\n", "assert", "fetch_data_body", "[", "\"inputs\"", "]", "[", "0", "]", "[", "\"property\"", "]", "==", "\"relayoutData\"", "\n", "assert", "all", "(", "k", "in", "fetch_data_body", "[", "\"inputs\"", "]", "[", "0", "]", "[", "\"value\"", "]", "for", "k", "in", "relayout_keys", ")", "\n", "fetch_data_response_body", "=", "json", ".", "loads", "(", "data_request", ".", "response", ".", "body", ")", "[", "\"response\"", "]", "\n", "updateData", "=", "fetch_data_response_body", "[", "\"trace-updater\"", "]", "[", "\"updateData\"", "]", "\n", "# in this case; the length of updateData is 2 as", "\n", "# (1) only the sin-wave is updated \u00c1ND (2) relayout data is always sent first", "\n", "assert", "len", "(", "updateData", ")", "==", "1", "+", "n_updated_traces", "\n", "# verify that the layout update does not contain trace props", "\n", "assert", "\"x\"", "not", "in", "updateData", "[", "0", "]", "\n", "assert", "\"y\"", "not", "in", "updateData", "[", "0", "]", "\n", "\n", "# verify that the trace-update does not contain layout update props", "\n", "for", "i", "in", "range", "(", "1", ",", "n_updated_traces", "+", "1", ")", ":", "\n", "            ", "assert", "\"x\"", "in", "updateData", "[", "i", "]", "\n", "assert", "\"y\"", "in", "updateData", "[", "i", "]", "\n", "# As identifier, we always send the trace-index", "\n", "# (i.e. the the position of the trace in the `trace-list`)", "\n", "assert", "\"index\"", "in", "updateData", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.assert_front_end_relayout_request": [[86, 102], ["json.loads", "all", "json.loads", "len", "len"], "methods", ["None"], ["", "", "def", "assert_front_end_relayout_request", "(", "relayout_request", ":", "Request", ")", ":", "\n", "        ", "relayout_body", "=", "json", ".", "loads", "(", "relayout_request", ".", "body", ")", "\n", "assert", "\"inputs\"", "in", "relayout_body", "and", "len", "(", "relayout_body", "[", "\"inputs\"", "]", ")", "==", "1", "\n", "assert", "relayout_body", "[", "\"inputs\"", "]", "[", "0", "]", "[", "\"id\"", "]", "==", "\"resample-figure\"", "\n", "assert", "relayout_body", "[", "\"inputs\"", "]", "[", "0", "]", "[", "\"property\"", "]", "==", "\"relayoutData\"", "\n", "assert", "all", "(", "\n", "k", "in", "relayout_body", "[", "\"inputs\"", "]", "[", "0", "]", "[", "\"value\"", "]", "\n", "for", "k", "in", "[", "\"annotations\"", ",", "\"template\"", ",", "\"title\"", ",", "\"legend\"", ",", "\"xaxis\"", ",", "\"yaxis\"", "]", "\n", ")", "\n", "\n", "relayout_response_body", "=", "json", ".", "loads", "(", "relayout_request", ".", "response", ".", "body", ")", "[", "\"response\"", "]", "\n", "# the relayout response its updateData should be an empty dict", "\n", "# { \"response\": { \"trace-updater\": { \"updateData\": [ {} ] } } }", "\n", "updateData", "=", "relayout_response_body", "[", "\"trace-updater\"", "]", "[", "\"updateData\"", "]", "\n", "assert", "len", "(", "updateData", ")", "==", "1", "\n", "assert", "updateData", "[", "0", "]", "==", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.browser_independent_single_callback_request_assert": [[103, 146], ["fr_selenium.RequestParser.filter_callback_requests", "fr_selenium.RequestParser.assert_fetch_data_request", "fr.get_requests", "len", "len", "ValueError", "len"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.filter_callback_requests", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.RequestParser.assert_fetch_data_request", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests"], ["", "def", "browser_independent_single_callback_request_assert", "(", "\n", "fr", ":", "FigureResamplerGUITests", ",", "relayout_keys", ":", "List", "[", "str", "]", ",", "n_updated_traces", ":", "int", "\n", ")", ":", "\n", "        ", "\"\"\"Verifies the callback requests on a browser-independent manner\n\n        fr: FigureResamplerGUITests\n            used for determining the browser-type.\n        requests: List[Request]\n            The captured requests of a SINGLE INTERACTION CALLBACK\n        relayout_keys : List[str]\n            The expected keys to be found in the relayout command\n        n_updated_traces : int\n            The expected amount of traces which will be updated.\n\n        \"\"\"", "\n", "# First, filter the requests to only retain the relevant ones", "\n", "requests", "=", "RequestParser", ".", "filter_callback_requests", "(", "fr", ".", "get_requests", "(", ")", ")", "\n", "\n", "browser_name", "=", "fr", ".", "driver", ".", "capabilities", "[", "\"browserName\"", "]", "\n", "if", "browser_name", "==", "\"firefox\"", ":", "\n", "# There are 2 requests which are send", "\n", "# 1. first: changed-layout to server -> new data to back-end request", "\n", "# 2. the front-end relayout request", "\n", "            ", "assert", "len", "(", "requests", ")", ">=", "1", "\n", "if", "len", "(", "requests", ")", "==", "2", ":", "\n", "                ", "fetch_data_request", ",", "relayout_request", "=", "requests", "\n", "# RequestParser.assert_front_end_relayout_request(relayout_request)", "\n", "", "else", ":", "\n", "                ", "fetch_data_request", "=", "requests", "[", "0", "]", "\n", "\n", "", "", "elif", "browser_name", "==", "\"chrome\"", ":", "\n", "# for some, yet unknown reason, chrome does not seem to capture the", "\n", "# second front-end request.", "\n", "            ", "assert", "len", "(", "requests", ")", "==", "1", "\n", "fetch_data_request", "=", "requests", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"invalid browser name {browser_name}\"", ")", "\n", "\n", "# Validate the update-data-callback request", "\n", "", "RequestParser", ".", "assert_fetch_data_request", "(", "\n", "fetch_data_request", ",", "\n", "relayout_keys", "=", "relayout_keys", ",", "\n", "n_updated_traces", "=", "n_updated_traces", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__init__": [[152, 170], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "driver", ":", "webdriver", ",", "port", ":", "int", ")", ":", "\n", "        ", "\"\"\"Construct an instance of A firefox selenium driver to fetch wearable data.\n\n        Parameters\n        ----------\n        username : str\n            The e4connect login username.\n        password : str\n            The e4connect password.\n        save_dir : str\n            The directory in which the data elements will be saved.\n        headless: bool, default: True\n            If set to `True` the driver will be ran in a headless mode.\n\n        \"\"\"", "\n", "self", ".", "port", "=", "port", "\n", "self", ".", "driver", ":", "Union", "[", "webdriver", ".", "Firefox", ",", "webdriver", ".", "Chrome", "]", "=", "driver", "\n", "self", ".", "on_page", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.go_to_page": [[171, 176], ["time.sleep", "fr_selenium.FigureResamplerGUITests.driver.get"], "methods", ["None"], ["", "def", "go_to_page", "(", "self", ")", ":", "\n", "        ", "\"\"\"Navigate to FigureResampler page.\"\"\"", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "self", ".", "driver", ".", "get", "(", "\"http://localhost:{}\"", ".", "format", "(", "self", ".", "port", ")", ")", "\n", "self", ".", "on_page", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests": [[177, 180], ["time.sleep"], "methods", ["None"], ["", "def", "clear_requests", "(", "self", ",", "sleep_time_s", "=", "1", ")", ":", "\n", "        ", "time", ".", "sleep", "(", "1", ")", "\n", "del", "self", ".", "driver", ".", "requests", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.get_requests": [[181, 187], ["fr_selenium.FigureResamplerGUITests.clear_requests"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.clear_requests"], ["", "def", "get_requests", "(", "self", ",", "delete", ":", "bool", "=", "True", ")", ":", "\n", "        ", "requests", "=", "self", ".", "driver", ".", "requests", "\n", "if", "delete", ":", "\n", "            ", "self", ".", "clear_requests", "(", ")", "\n", "\n", "", "return", "requests", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.drag_and_zoom": [[188, 226], ["selenium.webdriver.support.ui.WebDriverWait().until", "fr_selenium.FigureResamplerGUITests.driver.find_element", "selenium.webdriver.common.action_chains.ActionChains", "selenium.webdriver.common.action_chains.ActionChains.move_to_element_with_offset", "selenium.webdriver.common.action_chains.ActionChains.click_and_hold", "selenium.webdriver.common.action_chains.ActionChains.pause", "selenium.webdriver.common.action_chains.ActionChains.move_by_offset", "selenium.webdriver.common.action_chains.ActionChains.pause", "selenium.webdriver.common.action_chains.ActionChains.release", "selenium.webdriver.common.action_chains.ActionChains.pause", "selenium.webdriver.common.action_chains.ActionChains.perform", "fr_selenium.FigureResamplerGUITests.go_to_page", "selenium.webdriver.support.expected_conditions.presence_of_element_located", "selenium.webdriver.support.ui.WebDriverWait"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.go_to_page"], ["", "def", "drag_and_zoom", "(", "self", ",", "div_classname", ",", "x0", "=", "0.25", ",", "x1", "=", "0.5", ",", "y0", "=", "0.25", ",", "y1", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        Drags and zooms the div with the given classname.\n\n        Parameters\n        ----------\n        div_classname : str\n            The classname of the div to be dragged and zoomed.\n        x0 : float, default: 0.5\n            The relative x-coordinate of the upper left corner of the div.\n        x1 : float, default: 0.5\n            The relative x-coordinate of the lower right corner of the div.\n        y0 : float, default: 0.5\n            The relative y-coordinate of the upper left corner of the div.\n        y1 : float, default: 0.5\n            The relative y-coordinate of the lower right corner of the div.\n\n        \"\"\"", "\n", "if", "not", "self", ".", "on_page", ":", "\n", "            ", "self", ".", "go_to_page", "(", ")", "\n", "\n", "", "WebDriverWait", "(", "self", ".", "driver", ",", "3", ")", ".", "until", "(", "\n", "EC", ".", "presence_of_element_located", "(", "(", "By", ".", "CLASS_NAME", ",", "div_classname", ")", ")", "\n", ")", "\n", "\n", "subplot", "=", "self", ".", "driver", ".", "find_element", "(", "By", ".", "CLASS_NAME", ",", "div_classname", ")", "\n", "size", "=", "subplot", ".", "size", "\n", "w", ",", "h", "=", "size", "[", "\"width\"", "]", ",", "size", "[", "\"height\"", "]", "\n", "\n", "actions", "=", "ActionChains", "(", "self", ".", "driver", ")", "\n", "actions", ".", "move_to_element_with_offset", "(", "subplot", ",", "xoffset", "=", "w", "*", "x0", ",", "yoffset", "=", "h", "*", "y0", ")", "\n", "actions", ".", "click_and_hold", "(", ")", "\n", "actions", ".", "pause", "(", "0.2", ")", "\n", "actions", ".", "move_by_offset", "(", "xoffset", "=", "w", "*", "(", "x1", "-", "x0", ")", ",", "yoffset", "=", "h", "*", "(", "y1", "-", "y0", ")", ")", "\n", "actions", ".", "pause", "(", "0.2", ")", "\n", "actions", ".", "release", "(", ")", "\n", "actions", ".", "pause", "(", "0.2", ")", "\n", "actions", ".", "perform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests._get_modebar_btns": [[227, 235], ["selenium.webdriver.support.ui.WebDriverWait().until", "fr_selenium.FigureResamplerGUITests.driver.find_elements", "fr_selenium.FigureResamplerGUITests.go_to_page", "selenium.webdriver.support.expected_conditions.presence_of_element_located", "selenium.webdriver.support.ui.WebDriverWait"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.go_to_page"], ["", "def", "_get_modebar_btns", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "on_page", ":", "\n", "            ", "self", ".", "go_to_page", "(", ")", "\n", "\n", "", "WebDriverWait", "(", "self", ".", "driver", ",", "3", ")", ".", "until", "(", "\n", "EC", ".", "presence_of_element_located", "(", "(", "By", ".", "CLASS_NAME", ",", "\"modebar-group\"", ")", ")", "\n", ")", "\n", "return", "self", ".", "driver", ".", "find_elements", "(", "By", ".", "CLASS_NAME", ",", "\"modebar-btn\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.autoscale": [[236, 242], ["fr_selenium.FigureResamplerGUITests._get_modebar_btns", "btn.get_attribute", "selenium.webdriver.common.action_chains.ActionChains().move_to_element().click().perform", "selenium.webdriver.common.action_chains.ActionChains().move_to_element().click", "selenium.webdriver.common.action_chains.ActionChains().move_to_element", "selenium.webdriver.common.action_chains.ActionChains"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests._get_modebar_btns"], ["", "def", "autoscale", "(", "self", ")", ":", "\n", "        ", "for", "btn", "in", "self", ".", "_get_modebar_btns", "(", ")", ":", "\n", "            ", "data_title", "=", "btn", ".", "get_attribute", "(", "\"data-title\"", ")", "\n", "if", "data_title", "==", "\"Autoscale\"", ":", "\n", "                ", "ActionChains", "(", "self", ".", "driver", ")", ".", "move_to_element", "(", "btn", ")", ".", "click", "(", ")", ".", "perform", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes": [[243, 249], ["fr_selenium.FigureResamplerGUITests._get_modebar_btns", "btn.get_attribute", "selenium.webdriver.common.action_chains.ActionChains().move_to_element().click().perform", "selenium.webdriver.common.action_chains.ActionChains().move_to_element().click", "selenium.webdriver.common.action_chains.ActionChains().move_to_element", "selenium.webdriver.common.action_chains.ActionChains"], "methods", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests._get_modebar_btns"], ["", "", "", "def", "reset_axes", "(", "self", ")", ":", "\n", "        ", "for", "btn", "in", "self", ".", "_get_modebar_btns", "(", ")", ":", "\n", "            ", "data_title", "=", "btn", ".", "get_attribute", "(", "\"data-title\"", ")", "\n", "if", "data_title", "==", "\"Reset axes\"", ":", "\n", "                ", "ActionChains", "(", "self", ".", "driver", ")", ".", "move_to_element", "(", "btn", ")", ".", "click", "(", ")", ".", "perform", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.click_legend_item": [[250, 265], ["selenium.webdriver.support.ui.WebDriverWait().until", "fr_selenium.FigureResamplerGUITests.driver.find_elements", "selenium.webdriver.support.expected_conditions.presence_of_element_located", "selenium.webdriver.support.ui.WebDriverWait", "legend_item.get_attribute", "selenium.webdriver.common.action_chains.ActionChains().move_to_element().pause().click().perform", "selenium.webdriver.common.action_chains.ActionChains().move_to_element().pause().click", "selenium.webdriver.common.action_chains.ActionChains().move_to_element().pause", "selenium.webdriver.common.action_chains.ActionChains().move_to_element", "selenium.webdriver.common.action_chains.ActionChains"], "methods", ["None"], ["", "", "", "def", "click_legend_item", "(", "self", ",", "legend_name", ")", ":", "\n", "        ", "WebDriverWait", "(", "self", ".", "driver", ",", "3", ")", ".", "until", "(", "\n", "EC", ".", "presence_of_element_located", "(", "(", "By", ".", "CLASS_NAME", ",", "\"modebar-group\"", ")", ")", "\n", ")", "\n", "for", "legend_item", "in", "self", ".", "driver", ".", "find_elements", "(", "By", ".", "CLASS_NAME", ",", "\"legendtext\"", ")", ":", "\n", "            ", "if", "legend_name", "in", "legend_item", ".", "get_attribute", "(", "\"data-unformatted\"", ")", ":", "\n", "# move to the center of the item and click it", "\n", "                ", "(", "\n", "ActionChains", "(", "self", ".", "driver", ")", "\n", ".", "move_to_element", "(", "legend_item", ")", "\n", ".", "pause", "(", "0.1", ")", "\n", ".", "click", "(", ")", "\n", ".", "perform", "(", ")", "\n", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.__del__": [[267, 269], ["fr_selenium.FigureResamplerGUITests.driver.close"], "methods", ["None"], ["", "", "", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "self", ".", "driver", ".", "close", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.registering_cleanup": [[21, 27], ["plotly_resampler.unregister_plotly_resampler", "plotly_resampler.unregister_plotly_resampler"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.unregister_plotly_resampler", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.plotly_resampler.registering.unregister_plotly_resampler"], ["@", "pytest", ".", "fixture", "\n", "def", "registering_cleanup", "(", ")", ":", "\n", "# Cleans up the registering before and after each test", "\n", "    ", "unregister_plotly_resampler", "(", ")", "\n", "yield", "\n", "unregister_plotly_resampler", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.driver": [[29, 52], ["Options", "webdriver.Chrome", "Options.add_argument", "webdriver.Chrome", "Options.add_argument", "ChromeDriverManager().install", "ChromeDriverManager"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "driver", "(", ")", ":", "\n", "    ", "from", "seleniumwire", "import", "webdriver", "\n", "from", "webdriver_manager", ".", "chrome", "import", "ChromeDriverManager", ",", "ChromeType", "\n", "from", "selenium", ".", "webdriver", ".", "chrome", ".", "options", "import", "Options", "\n", "\n", "options", "=", "Options", "(", ")", "\n", "if", "not", "TESTING_LOCAL", ":", "\n", "        ", "if", "headless", ":", "\n", "            ", "options", ".", "add_argument", "(", "\"--headless\"", ")", "\n", "# options.add_argument(\"--no=sandbox\")", "\n", "", "driver", "=", "webdriver", ".", "Chrome", "(", "\n", "ChromeDriverManager", "(", "chrome_type", "=", "ChromeType", ".", "GOOGLE", ")", ".", "install", "(", ")", ",", "\n", "options", "=", "options", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "options", ".", "add_argument", "(", "\"--remote-debugging-port=9222\"", ")", "\n", "driver", "=", "webdriver", ".", "Chrome", "(", "\n", "options", "=", "options", ",", "\n", "# executable_path=\"/home/jonas/git/gIDLaB/plotly-dynamic-resampling/chromedriver\",", "\n", ")", "\n", "# driver = webdriver.Firefox(executable_path='/home/jonas/git/gIDLaB/plotly-dynamic-resampling/geckodriver')", "\n", "", "return", "driver", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.float_series": [[54, 59], ["numpy.arange().astype", "pandas.Series", "numpy.sin().astype", "numpy.arange", "numpy.random.randn", "numpy.sin"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "float_series", "(", ")", "->", "pd", ".", "Series", ":", "\n", "    ", "x", "=", "np", ".", "arange", "(", "_nb_samples", ")", ".", "astype", "(", "np", ".", "uint32", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", "/", "50", ")", ".", "astype", "(", "np", ".", "float32", ")", "+", "np", ".", "random", ".", "randn", "(", "_nb_samples", ")", "/", "5", "\n", "return", "pd", ".", "Series", "(", "index", "=", "x", ",", "data", "=", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.cat_series": [[61, 70], ["numpy.random.randint", "numpy.random.randint", "len", "len", "pandas.Series", "len"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "cat_series", "(", ")", "->", "pd", ".", "Series", ":", "\n", "    ", "cats_list", "=", "[", "\"a\"", ",", "\"a\"", ",", "\"a\"", ",", "\"a\"", "]", "*", "2000", "\n", "for", "i", "in", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "cats_list", ")", ",", "3", ")", ":", "\n", "        ", "cats_list", "[", "i", "]", "=", "\"b\"", "\n", "", "for", "i", "in", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "cats_list", ")", ",", "3", ")", ":", "\n", "        ", "cats_list", "[", "i", "]", "=", "\"c\"", "\n", "", "return", "pd", ".", "Series", "(", "cats_list", "*", "(", "_nb_samples", "//", "len", "(", "cats_list", ")", "+", "1", ")", ",", "dtype", "=", "\"category\"", ")", "[", "\n", ":", "_nb_samples", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.bool_series": [[73, 78], ["pandas.Series", "len"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "bool_series", "(", ")", "->", "pd", ".", "Series", ":", "\n", "    ", "bool_list", "=", "[", "True", ",", "False", ",", "True", ",", "True", ",", "True", ",", "True", "]", "+", "[", "True", "]", "*", "1000", "\n", "return", "pd", ".", "Series", "(", "bool_list", "*", "(", "_nb_samples", "//", "len", "(", "bool_list", ")", "+", "1", ")", ",", "dtype", "=", "\"bool\"", ")", "[", "\n", ":", "_nb_samples", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.example_figure": [[81, 161], ["pandas.read_parquet", "pandas.read_parquet", "numpy.array", "numpy.arange", "plotly_resampler.FigureResampler", "df_gusb[].last().dropna", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.update_yaxes", "plotly_resampler.FigureResampler.add_trace", "df_data_pc.last.last", "enumerate", "plotly_resampler.FigureResampler.update_layout", "plotly_resampler.FigureResampler.update_yaxes", "plotly_resampler.FigureResampler.update_layout", "len", "plotly.subplots.make_subplots", "plotly.Scattergl", "plotly.Scattergl", "plotly_resampler.FigureResampler.add_trace", "df_gusb[].last", "plotly_resampler.EveryNthPoint", "plotly.Scattergl", "numpy.arange", "df_gusb[].last().dropna.astype", "df_gusb[].last().dropna.rolling().mean().astype().astype", "plotly_resampler.LTTB", "numpy.sin", "numpy.random.randn", "df_gusb[].last().dropna.rolling().mean().astype", "numpy.arange", "df_gusb[].last().dropna.rolling().mean", "df_gusb[].last().dropna.rolling"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "@", "pytest", ".", "fixture", "\n", "def", "example_figure", "(", ")", "->", "FigureResampler", ":", "\n", "    ", "df_gusb", "=", "pd", ".", "read_parquet", "(", "f\"{data_dir}df_gusb.parquet\"", ")", "\n", "df_data_pc", "=", "pd", ".", "read_parquet", "(", "f\"{data_dir}df_pc_test.parquet\"", ")", "\n", "\n", "n", "=", "110_000", "# _000", "\n", "np_series", "=", "np", ".", "array", "(", "\n", "(", "3", "+", "np", ".", "sin", "(", "np", ".", "arange", "(", "n", ")", "/", "200_000", ")", "+", "np", ".", "random", ".", "randn", "(", "n", ")", "/", "10", ")", "\n", "*", "np", ".", "arange", "(", "n", ")", "\n", "/", "100_000", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", "x", "=", "np", ".", "arange", "(", "len", "(", "np_series", ")", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", "\n", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", "subplot_titles", "=", "(", "\n", "\"GUSB swimming pool\"", ",", "\n", "\"Generated sine\"", ",", "\n", "\"Power consumption\"", ",", "\n", ")", ",", "\n", "vertical_spacing", "=", "0.12", ",", "\n", ")", ",", "\n", "default_n_shown_samples", "=", "1_000", ",", "\n", "verbose", "=", "False", ",", "\n", ")", "\n", "\n", "# ------------ swimming pool data -----------", "\n", "df_gusb_pool", "=", "df_gusb", "[", "\"zwembad\"", "]", ".", "last", "(", "\"4D\"", ")", ".", "dropna", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "\n", "x", "=", "df_gusb_pool", ".", "index", ",", "\n", "y", "=", "df_gusb_pool", ".", "astype", "(", "\"uint16\"", ")", ",", "\n", "mode", "=", "\"markers\"", ",", "\n", "marker_size", "=", "5", ",", "\n", "name", "=", "\"occupancy\"", ",", "\n", "showlegend", "=", "True", ",", "\n", ")", ",", "\n", "hf_hovertext", "=", "\"mean last hour: \"", "\n", "+", "df_gusb_pool", ".", "rolling", "(", "\"1h\"", ")", ".", "mean", "(", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ",", "\n", "downsampler", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "False", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "fig", ".", "update_yaxes", "(", "title_text", "=", "\"Occupancy\"", ",", "row", "=", "1", ",", "col", "=", "1", ")", "\n", "\n", "# ----------------- generated sine -----------", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "\"sin\"", ",", "line_color", "=", "\"#26b2e0\"", ")", ",", "\n", "hf_x", "=", "x", ",", "\n", "hf_y", "=", "np_series", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "2", ",", "\n", ")", "\n", "\n", "# ------------- Power consumption data -------------", "\n", "df_data_pc", "=", "df_data_pc", ".", "last", "(", "\"190D\"", ")", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "df_data_pc", ".", "columns", ")", ":", "\n", "        ", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "\n", "name", "=", "f\"room {i+1}\"", ",", "\n", ")", ",", "\n", "hf_x", "=", "df_data_pc", ".", "index", ",", "\n", "hf_y", "=", "df_data_pc", "[", "c", "]", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", "downsampler", "=", "LTTB", "(", "interleave_gaps", "=", "True", ")", ",", "\n", ")", "\n", "\n", "", "fig", ".", "update_layout", "(", "height", "=", "600", ")", "\n", "fig", ".", "update_yaxes", "(", "title_text", "=", "\"Watt/hour\"", ",", "row", "=", "2", ",", "col", "=", "1", ")", "\n", "fig", ".", "update_layout", "(", "\n", "title", "=", "\"<b>Plotly-Resampler demo</b>\"", ",", "\n", "title_x", "=", "0.5", ",", "\n", "legend_traceorder", "=", "\"normal\"", ",", "\n", ")", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.example_figure_fig": [[163, 233], ["pandas.read_parquet", "pandas.read_parquet", "numpy.array", "numpy.arange", "plotly.subplots.make_subplots", "df_gusb[].last().dropna", "plotly.subplots.make_subplots.add_trace", "plotly.subplots.make_subplots.update_yaxes", "plotly.subplots.make_subplots.add_trace", "df_data_pc.last.last", "enumerate", "plotly.subplots.make_subplots.update_layout", "plotly.subplots.make_subplots.update_yaxes", "plotly.subplots.make_subplots.update_layout", "len", "plotly.Scattergl", "plotly.Scattergl", "plotly.subplots.make_subplots.add_trace", "df_gusb[].last", "plotly.Scattergl", "numpy.arange", "df_gusb[].last().dropna.rolling().mean().astype().astype", "numpy.sin", "numpy.random.randn", "df_gusb[].last().dropna.rolling().mean().astype", "numpy.arange", "df_gusb[].last().dropna.rolling().mean", "df_gusb[].last().dropna.rolling"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "@", "pytest", ".", "fixture", "\n", "def", "example_figure_fig", "(", ")", "->", "go", ".", "Figure", ":", "\n", "    ", "df_gusb", "=", "pd", ".", "read_parquet", "(", "f\"{data_dir}df_gusb.parquet\"", ")", "\n", "df_data_pc", "=", "pd", ".", "read_parquet", "(", "f\"{data_dir}df_pc_test.parquet\"", ")", "\n", "\n", "n", "=", "110_000", "# _000", "\n", "np_series", "=", "np", ".", "array", "(", "\n", "(", "3", "+", "np", ".", "sin", "(", "np", ".", "arange", "(", "n", ")", "/", "200_000", ")", "+", "np", ".", "random", ".", "randn", "(", "n", ")", "/", "10", ")", "\n", "*", "np", ".", "arange", "(", "n", ")", "\n", "/", "100_000", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", "x", "=", "np", ".", "arange", "(", "len", "(", "np_series", ")", ")", "\n", "\n", "# construct a normal figure object instead of a figureResample object", "\n", "fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", "subplot_titles", "=", "(", "\"GUSB swimming pool\"", ",", "\"Generated sine\"", ",", "\"Power consumption\"", ")", ",", "\n", "vertical_spacing", "=", "0.12", ",", "\n", ")", "\n", "\n", "# ------------ swimming pool data -----------", "\n", "df_gusb_pool", "=", "df_gusb", "[", "\"zwembad\"", "]", ".", "last", "(", "\"4D\"", ")", ".", "dropna", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "\n", "x", "=", "df_gusb_pool", ".", "index", ",", "\n", "y", "=", "df_gusb_pool", ",", "# .astype(\"uint16\"),", "\n", "mode", "=", "\"markers\"", ",", "\n", "marker_size", "=", "5", ",", "\n", "name", "=", "\"occupancy\"", ",", "\n", "showlegend", "=", "True", ",", "\n", "hovertext", "=", "\"mean last hour: \"", "\n", "+", "df_gusb_pool", ".", "rolling", "(", "\"1h\"", ")", ".", "mean", "(", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ",", "\n", ")", ",", "\n", "# downsampler=EveryNthPoint(interleave_gaps=False),", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "fig", ".", "update_yaxes", "(", "title_text", "=", "\"Occupancy\"", ",", "row", "=", "1", ",", "col", "=", "1", ")", "\n", "\n", "# ----------------- generated sine -----------", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "\"sin\"", ",", "line_color", "=", "\"#26b2e0\"", ",", "x", "=", "x", ",", "y", "=", "np_series", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "2", ",", "\n", ")", "\n", "\n", "# ------------- Power consumption data -------------", "\n", "df_data_pc", "=", "df_data_pc", ".", "last", "(", "\"190D\"", ")", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "df_data_pc", ".", "columns", ")", ":", "\n", "        ", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "\n", "name", "=", "f\"room {i+1}\"", ",", "\n", "x", "=", "df_data_pc", ".", "index", ",", "\n", "y", "=", "df_data_pc", "[", "c", "]", ",", "\n", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "\n", "", "fig", ".", "update_layout", "(", "height", "=", "600", ")", "\n", "fig", ".", "update_yaxes", "(", "title_text", "=", "\"Watt/hour\"", ",", "row", "=", "2", ",", "col", "=", "1", ")", "\n", "fig", ".", "update_layout", "(", "\n", "title", "=", "\"<b>Plotly-Resampler demo - fig base</b>\"", ",", "\n", "title_x", "=", "0.5", ",", "\n", "legend_traceorder", "=", "\"normal\"", ",", "\n", ")", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.gsr_figure": [[235, 363], ["pandas.read_parquet", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.update_layout", "plotly_resampler.FigureResampler.add_trace", "conftest.gsr_figure.groupby_consecutive"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.examples.helper.groupby_consecutive"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gsr_figure", "(", ")", "->", "FigureResampler", ":", "\n", "    ", "def", "groupby_consecutive", "(", "\n", "df", ":", "Union", "[", "pd", ".", "Series", ",", "pd", ".", "DataFrame", "]", ",", "col_name", ":", "str", "=", "None", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "\"\"\"Merges consecutive `column_name` values in a single dataframe.\n\n        This is especially useful if you want to represent sparse data in a more\n        compact format.\n\n        Parameters\n        ----------\n        df : Union[pd.Series, pd.DataFrame]\n            Must be time-indexed!\n        col_name : str, optional\n            If a dataFrame is passed, you will need to specify the `col_name` on which\n            the consecutive-grouping will need to take plase.\n\n        Returns\n        -------\n        pd.DataFrame\n            A new `DataFrame` view, with columns:\n            [`start`, `end`, `n_consecutive`, `col_name`], representing the\n            start- and endtime of the consecutive range, the number of consecutive samples,\n            and the col_name's consecutive values.\n        \"\"\"", "\n", "if", "type", "(", "df", ")", "==", "pd", ".", "Series", ":", "\n", "            ", "col_name", "=", "df", ".", "name", "\n", "df", "=", "df", ".", "to_frame", "(", ")", "\n", "\n", "", "assert", "col_name", "in", "df", ".", "columns", "\n", "\n", "df_cum", "=", "(", "\n", "(", "df", "[", "col_name", "]", ".", "diff", "(", "1", ")", "!=", "0", ")", "\n", ".", "astype", "(", "\"int\"", ")", "\n", ".", "cumsum", "(", ")", "\n", ".", "rename", "(", "\"value_grp\"", ")", "\n", ".", "to_frame", "(", ")", "\n", ")", "\n", "df_cum", "[", "\"sequence_idx\"", "]", "=", "df", ".", "index", "\n", "df_cum", "[", "col_name", "]", "=", "df", "[", "col_name", "]", "\n", "\n", "df_grouped", "=", "pd", ".", "DataFrame", "(", "\n", "{", "\n", "\"start\"", ":", "df_cum", ".", "groupby", "(", "\"value_grp\"", ")", "[", "\"sequence_idx\"", "]", ".", "first", "(", ")", ",", "\n", "\"end\"", ":", "df_cum", ".", "groupby", "(", "\"value_grp\"", ")", "[", "\"sequence_idx\"", "]", ".", "last", "(", ")", ",", "\n", "\"n_consecutive\"", ":", "df_cum", ".", "groupby", "(", "\"value_grp\"", ")", ".", "size", "(", ")", ",", "\n", "col_name", ":", "df_cum", ".", "groupby", "(", "\"value_grp\"", ")", "[", "col_name", "]", ".", "first", "(", ")", ",", "\n", "}", "\n", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "df_grouped", "[", "\"next_start\"", "]", "=", "df_grouped", ".", "start", ".", "shift", "(", "-", "1", ")", ".", "fillna", "(", "df_grouped", "[", "\"end\"", "]", ")", "\n", "return", "df_grouped", "\n", "\n", "", "df_gsr", "=", "pd", ".", "read_parquet", "(", "f\"{data_dir}processed_gsr.parquet\"", ")", "\n", "\n", "fig", "=", "FigureResampler", "(", "\n", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "1", ",", "\n", "specs", "=", "[", "[", "{", "\"secondary_y\"", ":", "True", "}", "]", ",", "[", "{", "}", "]", "]", ",", "\n", "shared_xaxes", "=", "True", ",", "\n", ")", ",", "\n", "default_n_shown_samples", "=", "1_000", ",", "\n", "resampled_trace_prefix_suffix", "=", "(", "\n", "'<b style=\"color:blue\">[R]</b> '", ",", "\n", "' <b style=\"color:red\">[R]</b>'", ",", "\n", ")", ",", "\n", "verbose", "=", "False", ",", "\n", "show_mean_aggregation_size", "=", "True", ",", "\n", ")", "\n", "fig", ".", "update_layout", "(", "height", "=", "700", ")", "\n", "\n", "for", "c", "in", "[", "\"EDA\"", ",", "\"EDA_lf_cleaned\"", ",", "\"EDA_lf_cleaned_tonic\"", "]", ":", "\n", "        ", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "c", ")", ",", "hf_x", "=", "df_gsr", ".", "index", ",", "hf_y", "=", "df_gsr", "[", "c", "]", ",", "row", "=", "1", ",", "col", "=", "1", "\n", ")", "\n", "\n", "", "df_peaks", "=", "df_gsr", "[", "df_gsr", "[", "\"SCR_Peaks_neurokit_reduced_acc\"", "]", "==", "1", "]", "\n", "fig", ".", "add_trace", "(", "\n", "trace", "=", "go", ".", "Scattergl", "(", "\n", "x", "=", "df_peaks", ".", "index", ",", "\n", "y", "=", "df_peaks", "[", "\"EDA_lf_cleaned\"", "]", ",", "\n", "visible", "=", "\"legendonly\"", ",", "\n", "mode", "=", "\"markers\"", ",", "\n", "marker_symbol", "=", "\"cross\"", ",", "\n", "marker_size", "=", "15", ",", "\n", "marker_color", "=", "\"red\"", ",", "\n", "name", "=", "\"SCR peaks\"", ",", "\n", ")", ",", "\n", "limit_to_view", "=", "True", ",", "\n", ")", "\n", "\n", "df_grouped", "=", "groupby_consecutive", "(", "df_gsr", "[", "\"EDA_SQI\"", "]", ")", "\n", "df_grouped", "[", "\"EDA_SQI\"", "]", "=", "df_grouped", "[", "\"EDA_SQI\"", "]", ".", "map", "(", "bool", ")", "\n", "df_grouped", "[", "\"good_sqi\"", "]", "=", "df_grouped", "[", "\"EDA_SQI\"", "]", ".", "map", "(", "int", ")", "\n", "df_grouped", "[", "\"bad_sqi\"", "]", "=", "(", "~", "df_grouped", "[", "\"EDA_SQI\"", "]", ")", ".", "map", "(", "int", ")", "\n", "for", "sqi_col", ",", "col_or", "in", "[", "\n", "(", "\"good_sqi\"", ",", "\"#2ca02c\"", ")", ",", "\n", "(", "\"bad_sqi\"", ",", "\"#d62728\"", ")", ",", "\n", "]", ":", "\n", "        ", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "\n", "x", "=", "df_grouped", "[", "\"start\"", "]", ",", "\n", "y", "=", "df_grouped", "[", "sqi_col", "]", ",", "\n", "mode", "=", "\"lines\"", ",", "\n", "line_width", "=", "0", ",", "\n", "fill", "=", "\"tozeroy\"", ",", "\n", "fillcolor", "=", "col_or", ",", "\n", "opacity", "=", "0.1", "if", "\"good\"", "in", "sqi_col", "else", "0.2", ",", "\n", "line_shape", "=", "\"hv\"", ",", "\n", "name", "=", "sqi_col", ",", "\n", "showlegend", "=", "False", ",", "\n", ")", ",", "\n", "max_n_samples", "=", "len", "(", "df_grouped", ")", "+", "1", ",", "\n", "downsampler", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "False", ")", ",", "\n", "limit_to_view", "=", "True", ",", "\n", "secondary_y", "=", "True", ",", "\n", ")", "\n", "\n", "", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "\"EDA_Phasic\"", ",", "visible", "=", "\"legendonly\"", ")", ",", "\n", "hf_x", "=", "df_gsr", ".", "index", ",", "\n", "hf_y", "=", "df_gsr", "[", "\"EDA_Phasic\"", "]", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.multiple_tz_figure": [[365, 398], ["pandas.date_range", "numpy.random.randn", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.update_layout", "enumerate", "pd.date_range.tz_localize().tz_localize", "pd.date_range.tz_convert", "pd.date_range.tz_convert", "pd.date_range.tz_convert", "plotly.subplots.make_subplots", "plotly_resampler.FigureResampler.add_trace", "min", "plotly.Scattergl", "pd.date_range.tz_localize", "len", "len", "date_range.dtype.name.split"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "@", "pytest", ".", "fixture", "\n", "def", "multiple_tz_figure", "(", ")", "->", "FigureResampler", ":", "\n", "    ", "n", "=", "5_050", "\n", "\n", "dr", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", "\n", "dr_v", "=", "np", ".", "random", ".", "randn", "(", "n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fr_fig", "=", "FigureResampler", "(", "\n", "make_subplots", "(", "rows", "=", "len", "(", "cs", ")", ",", "cols", "=", "1", ",", "shared_xaxes", "=", "True", ")", ",", "\n", "default_n_shown_samples", "=", "500", ",", "\n", "convert_existing_traces", "=", "False", ",", "\n", "verbose", "=", "True", ",", "\n", "show_mean_aggregation_size", "=", "False", ",", "\n", ")", "\n", "fr_fig", ".", "update_layout", "(", "height", "=", "min", "(", "700", ",", "250", "*", "len", "(", "cs", ")", ")", ")", "\n", "\n", "for", "i", ",", "date_range", "in", "enumerate", "(", "cs", ",", "1", ")", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "date_range", ".", "dtype", ".", "name", ".", "split", "(", "\", \"", ")", "[", "-", "1", "]", ")", ",", "\n", "hf_x", "=", "date_range", ",", "\n", "hf_y", "=", "dr_v", ",", "\n", "row", "=", "i", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "", "return", "fr_fig", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.cat_series_box_hist_figure": [[400, 441], ["numpy.array", "pandas.Series", "numpy.arange().astype", "pandas.Series", "plotly.subplots.make_subplots", "plotly_resampler.FigureResampler", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "plotly_resampler.FigureResampler.add_trace", "list", "numpy.sin().astype", "plotly.Scattergl", "plotly.Box", "plotly.Box", "plotly.Histogram", "numpy.random.choice", "numpy.random.choice", "numpy.arange", "numpy.random.randn", "len", "len", "numpy.sin"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "@", "pytest", ".", "fixture", "\n", "def", "cat_series_box_hist_figure", "(", ")", "->", "FigureResampler", ":", "\n", "# Create a categorical series, with mostly a's, but a few sparse b's and c's", "\n", "    ", "cats_list", "=", "np", ".", "array", "(", "list", "(", "\"aaaaaaaaaa\"", "*", "1000", ")", ")", "\n", "cats_list", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "cats_list", ")", ",", "100", ",", "replace", "=", "False", ")", "]", "=", "\"b\"", "\n", "cats_list", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "cats_list", ")", ",", "50", ",", "replace", "=", "False", ")", "]", "=", "\"c\"", "\n", "cat_series", "=", "pd", ".", "Series", "(", "cats_list", ",", "dtype", "=", "\"category\"", ")", "\n", "\n", "x", "=", "np", ".", "arange", "(", "_nb_samples", ")", ".", "astype", "(", "np", ".", "uint32", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", "/", "300", ")", ".", "astype", "(", "np", ".", "float32", ")", "+", "np", ".", "random", ".", "randn", "(", "_nb_samples", ")", "/", "5", "\n", "float_series", "=", "pd", ".", "Series", "(", "index", "=", "x", ",", "data", "=", "y", ")", "\n", "\n", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "fig", "=", "FigureResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "\"cat_series\"", ",", "x", "=", "cat_series", ".", "index", ",", "y", "=", "cat_series", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_hovertext", "=", "\"text\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", ",", "name", "=", "\"float_series\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", "**", "2", ",", "name", "=", "\"float_series**2\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", "\n", ")", "\n", "\n", "# add a not hf-trace", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Histogram", "(", "\n", "x", "=", "float_series", ",", "\n", "name", "=", "\"float_series\"", ",", "\n", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.shared_hover_figure": [[443, 458], ["plotly_resampler.FigureResampler", "numpy.array", "range", "plotly_resampler.FigureResampler.update_layout", "plotly_resampler.FigureResampler.update_traces", "plotly_resampler.FigureResampler.update_xaxes", "plotly.subplots.make_subplots", "range", "numpy.sin", "plotly_resampler.FigureResampler.add_trace", "numpy.random.random", "plotly.Scatter", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "@", "pytest", ".", "fixture", "\n", "def", "shared_hover_figure", "(", ")", "->", "FigureResampler", ":", "\n", "    ", "fig", "=", "FigureResampler", "(", "make_subplots", "(", "rows", "=", "3", ",", "cols", "=", "1", ",", "shared_xaxes", "=", "True", ")", ",", "verbose", "=", "1", ")", "\n", "\n", "x", "=", "np", ".", "array", "(", "range", "(", "100_000", ")", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", "/", "120", ")", "+", "np", ".", "random", ".", "random", "(", "len", "(", "x", ")", ")", "/", "10", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "4", ")", ":", "\n", "        ", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ",", "row", "=", "i", ",", "col", "=", "1", ")", "\n", "\n", "", "fig", ".", "update_layout", "(", "template", "=", "\"plotly_white\"", ",", "height", "=", "900", ")", "\n", "fig", ".", "update_traces", "(", "xaxis", "=", "\"x3\"", ")", "\n", "fig", ".", "update_xaxes", "(", "spikemode", "=", "\"across\"", ",", "showspikes", "=", "True", ")", "\n", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.conftest.multi_trace_go_figure": [[460, 476], ["plotly_resampler.FigureResampler", "numpy.arange", "range", "plotly_resampler.FigureResampler.update_layout", "plotly.Figure", "numpy.sin", "plotly_resampler.FigureResampler.add_trace", "numpy.random.random", "plotly.Scattergl", "len", "str"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "@", "pytest", ".", "fixture", "\n", "def", "multi_trace_go_figure", "(", ")", "->", "FigureResampler", ":", "\n", "    ", "fig", "=", "FigureResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "\n", "n", "=", "500_000", "# nb points per sensor", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", "/", "20", ")", "+", "np", ".", "random", ".", "random", "(", "len", "(", "x", ")", ")", "/", "10", "\n", "\n", "for", "i", "in", "range", "(", "30", ")", ":", "# 30 sensors", "\n", "        ", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "str", "(", "i", ")", ")", ",", "\n", "hf_x", "=", "x", ",", "\n", "hf_y", "=", "y", "+", "i", ",", "\n", ")", "\n", "", "fig", ".", "update_layout", "(", "height", "=", "800", ")", "\n", "return", "fig", "\n", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_add_trace_kwarg_space": [[18, 63], ["plotly.subplots.make_subplots", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.EfficientLTTB", "tuple", "plotly.Scatter", "plotly.Scatter", "plotly.Scattergl", "plotly_resampler.EveryNthPoint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["def", "test_add_trace_kwarg_space", "(", "float_series", ",", "bool_series", ",", "cat_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "kwarg_space_list", "=", "[", "\n", "{", "}", ",", "\n", "{", "\n", "\"default_downsampler\"", ":", "EfficientLTTB", "(", "interleave_gaps", "=", "True", ")", ",", "\n", "\"resampled_trace_prefix_suffix\"", ":", "tuple", "(", "[", "\"<b>[r]</b>\"", ",", "\"~~\"", "]", ")", ",", "\n", "\"verbose\"", ":", "True", ",", "\n", "}", ",", "\n", "]", "\n", "for", "kwarg_space", "in", "kwarg_space_list", ":", "\n", "        ", "fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "**", "kwarg_space", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "limit_to_view", "=", "False", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "text", "=", "\"text\"", ",", "name", "=", "\"bool_series\"", ")", ",", "\n", "hf_x", "=", "bool_series", ".", "index", ",", "\n", "hf_y", "=", "bool_series", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "2", ",", "\n", "limit_to_view", "=", "True", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "text", "=", "\"text\"", ",", "name", "=", "\"cat_series\"", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", "downsampler", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ",", "\n", "hf_x", "=", "cat_series", ".", "index", ",", "\n", "hf_y", "=", "cat_series", ",", "\n", "limit_to_view", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_add_trace_not_resampling": [[66, 95], ["plotly.subplots.make_subplots", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly.Scatter", "plotly.Scatter"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "", "def", "test_add_trace_not_resampling", "(", "float_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "float_series", ".", "index", "[", ":", "800", "]", ",", "y", "=", "float_series", "[", ":", "800", "]", ",", "name", "=", "\"float_series\"", "\n", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"float_series\"", ")", ",", "\n", "limit_to_view", "=", "False", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_x", "=", "float_series", ".", "index", "[", "-", "800", ":", "]", ",", "\n", "hf_y", "=", "float_series", "[", "-", "800", ":", "]", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_add_scatter_trace_no_data": [[98, 103], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly.Scatter"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_add_scatter_trace_no_data", "(", ")", ":", "\n", "    ", "fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "# no x and y data", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_add_scatter_trace_no_x": [[105, 111], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly.Figure", "plotly.Scatter", "plotly.Scatter"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_add_scatter_trace_no_x", "(", ")", ":", "\n", "    ", "fig", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "# no x data", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "y", "=", "[", "2", ",", "1", ",", "4", ",", "3", "]", ",", "name", "=", "\"s1\"", ")", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "name", "=", "\"s2\"", ")", ",", "hf_y", "=", "[", "2", ",", "1", ",", "4", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_add_not_a_hf_trace": [[113, 141], ["plotly.subplots.make_subplots", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly.Scatter", "plotly.Histogram"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_add_not_a_hf_trace", "(", "float_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "float_series", ".", "index", "[", ":", "800", "]", ",", "y", "=", "float_series", "[", ":", "800", "]", ",", "name", "=", "\"float_series\"", "\n", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "# add a not hf-trace", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Histogram", "(", "\n", "x", "=", "float_series", ",", "\n", "name", "=", "\"float_series\"", ",", "\n", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_box_histogram": [[144, 174], ["plotly.subplots.make_subplots", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly.Scattergl", "plotly.Box", "plotly.Box", "plotly.Histogram"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_box_histogram", "(", "float_series", ")", ":", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", ",", "name", "=", "\"float_series\"", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", ",", "name", "=", "\"float_series\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", "**", "2", ",", "name", "=", "\"float_series**2\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", "\n", ")", "\n", "\n", "# add a not hf-trace", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Histogram", "(", "\n", "x", "=", "float_series", ",", "\n", "name", "=", "\"float_series\"", ",", "\n", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_cat_box_histogram": [[177, 215], ["numpy.array", "pandas.Series", "plotly.subplots.make_subplots", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.update_layout", "list", "plotly.Scattergl", "plotly.Box", "plotly.Box", "plotly.Histogram", "numpy.random.choice", "numpy.random.choice", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_cat_box_histogram", "(", "float_series", ")", ":", "\n", "# Create a categorical series, with mostly a's, but a few sparse b's and c's", "\n", "    ", "cats_list", "=", "np", ".", "array", "(", "list", "(", "\"aaaaaaaaaa\"", "*", "1000", ")", ")", "\n", "cats_list", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "cats_list", ")", ",", "100", ",", "replace", "=", "False", ")", "]", "=", "\"b\"", "\n", "cats_list", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "cats_list", ")", ",", "50", ",", "replace", "=", "False", ")", "]", "=", "\"c\"", "\n", "cat_series", "=", "pd", ".", "Series", "(", "cats_list", ",", "dtype", "=", "\"category\"", ")", "\n", "\n", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "\"cat_series\"", ",", "x", "=", "cat_series", ".", "index", ",", "y", "=", "cat_series", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", ",", "name", "=", "\"float_box_pow\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Box", "(", "x", "=", "float_series", ".", "values", "**", "2", ",", "name", "=", "\"float_box_pow_2\"", ")", ",", "row", "=", "1", ",", "col", "=", "2", "\n", ")", "\n", "\n", "# add a not hf-trace", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Histogram", "(", "\n", "x", "=", "float_series", ",", "\n", "name", "=", "\"float_hist\"", ",", "\n", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "\n", "fig", ".", "update_layout", "(", "height", "=", "700", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_replace_figure": [[217, 244], ["plotly.subplots.make_subplots", "plotly_resampler.FigureWidgetResampler", "plotly.Figure", "go.Figure.add_trace", "plotly_resampler.FigureWidgetResampler.replace", "plotly_resampler.FigureWidgetResampler.replace", "plotly.Scattergl", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace"], ["", "def", "test_replace_figure", "(", "float_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fr_fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "go_fig", "=", "go", ".", "Figure", "(", ")", "\n", "go_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", ",", "name", "=", "\"fs\"", ")", ")", "\n", "\n", "fr_fig", ".", "replace", "(", "go_fig", ",", "convert_existing_traces", "=", "False", ")", "\n", "# assert len(fr_fig.data) == 1", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "len", "(", "float_series", ")", "\n", "# the orig float series data must still be the orig shape (we passed a view so", "\n", "# we must check this)", "\n", "assert", "len", "(", "go_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "len", "(", "float_series", ")", "\n", "\n", "fr_fig", ".", "replace", "(", "go_fig", ",", "convert_existing_traces", "=", "True", ")", "\n", "# assert len(fr_fig.data) == 1", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1000", "\n", "\n", "# the orig float series data must still be the orig shape (we passed a view so", "\n", "# we must check this)", "\n", "assert", "len", "(", "go_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "len", "(", "float_series", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_nan_removed_input": [[246, 293], ["plotly.subplots.make_subplots", "plotly_resampler.FigureWidgetResampler", "float_series.copy.copy", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly.Scatter", "plotly.Scatter", "plotly.Scattergl", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "len", "len", "float_series.copy.rolling().mean().round().astype", "len", "float_series.copy.rolling().mean().round().astype", "float_series.copy.rolling().mean().round", "float_series.copy.rolling().mean().round", "float_series.copy.rolling().mean", "float_series.copy.rolling().mean", "float_series.copy.rolling", "float_series.copy.rolling"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_nan_removed_input", "(", "float_series", ")", ":", "\n", "# see: https://plotly.com/python/subplots/#custom-sized-subplot-with-subplot-titles", "\n", "    ", "base_fig", "=", "make_subplots", "(", "\n", "rows", "=", "2", ",", "\n", "cols", "=", "2", ",", "\n", "specs", "=", "[", "[", "{", "}", ",", "{", "}", "]", ",", "[", "{", "\"colspan\"", ":", "2", "}", ",", "None", "]", "]", ",", "\n", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", "\n", "base_fig", ",", "\n", "default_n_shown_samples", "=", "1000", ",", "\n", "resampled_trace_prefix_suffix", "=", "(", "\n", "'<b style=\"color:sandybrown\">[R]</b>'", ",", "\n", "'<b style=\"color:sandybrown\">[R]</b>'", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "float_series", "=", "float_series", ".", "copy", "(", ")", "\n", "float_series", ".", "iloc", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "float_series", ")", ",", "100", ")", "]", "=", "np", ".", "nan", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", ",", "name", "=", "\"float_series\"", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "1", ",", "\n", "hf_text", "=", "\"text\"", ",", "\n", "hf_hovertext", "=", "\"hovertext\"", ",", "\n", ")", "\n", "\n", "# here we test whether we are able to deal with not-nan output", "\n", "float_series", ".", "iloc", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "float_series", ")", ",", "100", ")", "]", "=", "np", ".", "nan", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "float_series", ".", "index", ",", "y", "=", "float_series", "\n", ")", ",", "# we explicitly do not add a name", "\n", "hf_hovertext", "=", "\"mean\"", "+", "float_series", ".", "rolling", "(", "10", ")", ".", "mean", "(", ")", ".", "round", "(", "2", ")", ".", "astype", "(", "\"str\"", ")", ",", "\n", "row", "=", "2", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n", "\n", "float_series", ".", "iloc", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "float_series", ")", ",", "100", ")", "]", "=", "np", ".", "nan", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "\n", "x", "=", "float_series", ".", "index", ",", "\n", "y", "=", "float_series", ",", "\n", "text", "=", "\"mean\"", "+", "float_series", ".", "rolling", "(", "10", ")", ".", "mean", "(", ")", ".", "round", "(", "2", ")", ".", "astype", "(", "\"str\"", ")", ",", "\n", ")", ",", "\n", "row", "=", "1", ",", "\n", "col", "=", "2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_hf_text": [[296, 321], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "numpy.all", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "numpy.all", "plotly.Scatter", "len", "plotly.Scatter", "len", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype().astype", "np.arange.astype", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype().astype", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_hf_text", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "arange", "(", "10_000", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ",", "text", "=", "y", ".", "astype", "(", "str", ")", ")", ",", "\n", "hf_y", "=", "y", ",", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "is", "None", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "text", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "is", "None", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ")", ",", "hf_y", "=", "y", ",", "hf_text", "=", "y", ".", "astype", "(", "str", ")", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "is", "None", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "text", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_hf_hovertext": [[323, 348], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "numpy.all", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "numpy.all", "plotly.Scatter", "len", "plotly.Scatter", "len", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype().astype", "np.arange.astype", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype().astype", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_hf_hovertext", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "arange", "(", "10_000", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ",", "hovertext", "=", "y", ".", "astype", "(", "str", ")", ")", ",", "\n", "hf_y", "=", "y", ",", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "is", "None", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "data", "[", "0", "]", ".", "text", "is", "None", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ")", ",", "hf_y", "=", "y", ",", "hf_hovertext", "=", "y", ".", "astype", "(", "str", ")", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "is", "None", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "fig", ".", "data", "[", "0", "]", ".", "text", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_hf_text_and_hf_hovertext": [[350, 383], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "plotly.Scatter", "len", "plotly.Scatter", "len", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype().astype", "np.arange.astype", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype().astype", "np.arange.astype", "np.arange.astype", "np.arange.astype", "np.arange.astype", "np.arange.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype", "plotly_resampler.FigureWidgetResampler.data[].y.astype"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_hf_text_and_hf_hovertext", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "arange", "(", "10_000", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ",", "text", "=", "y", ".", "astype", "(", "str", ")", ",", "hovertext", "=", "y", ".", "astype", "(", "str", ")", "[", ":", ":", "-", "1", "]", ")", ",", "\n", "hf_y", "=", "y", ",", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "==", "y", ".", "astype", "(", "str", ")", "[", ":", ":", "-", "1", "]", ")", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "text", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "np", ".", "all", "(", "\n", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "==", "(", "9_999", "-", "fig", ".", "data", "[", "0", "]", ".", "y", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"blabla\"", ")", ",", "\n", "hf_y", "=", "y", ",", "\n", "hf_text", "=", "y", ".", "astype", "(", "str", ")", ",", "\n", "hf_hovertext", "=", "y", ".", "astype", "(", "str", ")", "[", ":", ":", "-", "1", "]", ",", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "==", "y", ".", "astype", "(", "str", ")", ")", "\n", "assert", "np", ".", "all", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "==", "y", ".", "astype", "(", "str", ")", "[", ":", ":", "-", "1", "]", ")", "\n", "\n", "assert", "len", "(", "fig", ".", "data", "[", "0", "]", ".", "y", ")", "<", "5_000", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", ".", "text", "==", "fig", ".", "data", "[", "0", "]", ".", "y", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", ")", "\n", "assert", "np", ".", "all", "(", "\n", "fig", ".", "data", "[", "0", "]", ".", "hovertext", "==", "(", "9_999", "-", "fig", ".", "data", "[", "0", "]", ".", "y", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_multiple_timezones": [[386, 415], ["pandas.date_range", "numpy.random.randn", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.update_layout", "enumerate", "pd.date_range.tz_localize().tz_localize", "pd.date_range.tz_convert", "pd.date_range.tz_convert", "pd.date_range.tz_convert", "plotly.subplots.make_subplots", "plotly_resampler.FigureWidgetResampler.add_trace", "min", "plotly.Scattergl", "pd.date_range.tz_localize", "len", "len", "date_range.dtype.name.split"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_multiple_timezones", "(", ")", ":", "\n", "    ", "n", "=", "5_050", "\n", "\n", "dr", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", "\n", "dr_v", "=", "np", ".", "random", ".", "randn", "(", "n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fr_fig", "=", "FigureWidgetResampler", "(", "\n", "make_subplots", "(", "rows", "=", "len", "(", "cs", ")", ",", "cols", "=", "1", ",", "shared_xaxes", "=", "True", ")", ",", "\n", "default_n_shown_samples", "=", "500", ",", "\n", "convert_existing_traces", "=", "False", ",", "\n", "verbose", "=", "True", ",", "\n", ")", "\n", "fr_fig", ".", "update_layout", "(", "height", "=", "min", "(", "300", ",", "250", "*", "len", "(", "cs", ")", ")", ")", "\n", "\n", "for", "i", ",", "date_range", "in", "enumerate", "(", "cs", ",", "1", ")", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "date_range", ".", "dtype", ".", "name", ".", "split", "(", "\", \"", ")", "[", "-", "1", "]", ")", ",", "\n", "hf_x", "=", "date_range", ",", "\n", "hf_y", "=", "dr_v", ",", "\n", "row", "=", "i", ",", "\n", "col", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_proper_copy_of_wrapped_fig": [[418, 439], ["plotly.Figure", "go.Figure.add_trace", "plotly_resampler.FigureWidgetResampler", "all", "all", "plotly.Scatter", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "", "def", "test_proper_copy_of_wrapped_fig", "(", "float_series", ")", ":", "\n", "    ", "plotly_fig", "=", "go", ".", "Figure", "(", ")", "\n", "plotly_fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "float_series", ".", "index", ",", "\n", "y", "=", "float_series", ",", "\n", ")", "\n", ")", "\n", "\n", "plotly_resampler_fig", "=", "FigureWidgetResampler", "(", "\n", "plotly_fig", ",", "default_n_shown_samples", "=", "500", "\n", ")", "\n", "\n", "assert", "len", "(", "plotly_fig", ".", "data", ")", "==", "1", "\n", "assert", "all", "(", "plotly_fig", ".", "data", "[", "0", "]", ".", "x", "==", "float_series", ".", "index", ")", "\n", "assert", "all", "(", "plotly_fig", ".", "data", "[", "0", "]", ".", "y", "==", "float_series", ".", "values", ")", "\n", "assert", "(", "len", "(", "plotly_fig", ".", "data", "[", "0", "]", ".", "x", ")", ">", "500", ")", "&", "(", "len", "(", "plotly_fig", ".", "data", "[", "0", "]", ".", "y", ")", ">", "500", ")", "\n", "\n", "assert", "len", "(", "plotly_resampler_fig", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "plotly_resampler_fig", ".", "data", "[", "0", "]", ".", "x", ")", "==", "500", "\n", "assert", "len", "(", "plotly_resampler_fig", ".", "data", "[", "0", "]", ".", "y", ")", "==", "500", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_2d_input_y": [[441, 462], ["pandas.DataFrame", "plotly.Figure", "go.Figure.add_trace", "plotly.Scatter", "pytest.raises", "plotly_resampler.FigureWidgetResampler", "numpy.arange", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_2d_input_y", "(", ")", ":", "\n", "# Create some dummy dataframe with a nan", "\n", "    ", "df", "=", "pd", ".", "DataFrame", "(", "\n", "index", "=", "np", ".", "arange", "(", "5_000", ")", ",", "data", "=", "{", "\"a\"", ":", "np", ".", "arange", "(", "5_000", ")", ",", "\"b\"", ":", "np", ".", "arange", "(", "5_000", ")", "}", "\n", ")", "\n", "df", ".", "iloc", "[", "42", "]", "=", "np", ".", "nan", "\n", "\n", "plotly_fig", "=", "go", ".", "Figure", "(", ")", "\n", "plotly_fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "\n", "x", "=", "df", ".", "index", ",", "\n", "y", "=", "df", "[", "[", "\"a\"", "]", "]", ",", "# (100, 1) shape", "\n", ")", "\n", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", "as", "e_info", ":", "\n", "        ", "_", "=", "FigureWidgetResampler", "(", "# does not alter plotly_fig", "\n", "plotly_fig", ",", "\n", "default_n_shown_samples", "=", "500", ",", "\n", ")", "\n", "assert", "\"1 dimensional\"", "in", "e_info", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_time_tz_slicing": [[464, 487], ["pandas.Series", "plotly_resampler.FigureWidgetResampler", "pd.Series.tz_localize", "pd.Series.tz_localize().tz_localize", "pd.Series.tz_convert", "pd.Series.tz_convert", "pd.Series.tz_convert", "plotly.Figure", "sorted", "plotly_resampler.FigureWidgetResampler._slice_time", "pandas.date_range", "numpy.random.randn", "pandas.Timedelta", "pandas.Timedelta", "pd.Series.tz_localize", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time"], ["", "", "def", "test_time_tz_slicing", "(", ")", ":", "\n", "    ", "n", "=", "5050", "\n", "dr", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", ",", "\n", "data", "=", "np", ".", "random", ".", "randn", "(", "n", ")", ",", "\n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "\n", "for", "s", "in", "cs", ":", "\n", "        ", "t_start", ",", "t_stop", "=", "sorted", "(", "s", ".", "iloc", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "n", ",", "2", ")", "]", ".", "index", ")", "\n", "out", "=", "fig", ".", "_slice_time", "(", "s", ",", "t_start", ",", "t_stop", ")", "\n", "assert", "(", "out", ".", "index", "[", "0", "]", "-", "t_start", ")", "<=", "pd", ".", "Timedelta", "(", "seconds", "=", "1", ")", "\n", "assert", "(", "out", ".", "index", "[", "-", "1", "]", "-", "t_stop", ")", "<=", "pd", ".", "Timedelta", "(", "seconds", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_time_tz_slicing_different_timestamp": [[489, 516], ["pandas.Series", "plotly_resampler.FigureWidgetResampler", "enumerate", "pd.Series.tz_localize().tz_localize", "pd.Series.tz_convert", "pd.Series.tz_convert", "pd.Series.tz_convert", "plotly.Figure", "sorted", "t_start.tz_convert.tz_convert", "t_stop.tz_convert.tz_convert", "pandas.date_range", "numpy.random.randn", "pytest.raises", "plotly_resampler.FigureWidgetResampler._slice_time", "pd.Series.tz_localize", "numpy.random.randint", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time"], ["", "", "def", "test_time_tz_slicing_different_timestamp", "(", ")", ":", "\n", "# construct a time indexed series with UTC timezone", "\n", "    ", "n", "=", "60", "*", "60", "*", "24", "*", "3", "\n", "dr", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", ",", "\n", "data", "=", "np", ".", "random", ".", "randn", "(", "n", ")", ",", "\n", ")", "\n", "\n", "# create multiple other time zones", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "cs", ")", ":", "\n", "        ", "t_start", ",", "t_stop", "=", "sorted", "(", "s", ".", "iloc", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "n", ",", "2", ")", "]", ".", "index", ")", "\n", "t_start", "=", "t_start", ".", "tz_convert", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "t_stop", "=", "t_stop", ".", "tz_convert", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "\n", "# As each timezone in CS tz aware, using other timezones in `t_start` & `t_stop`", "\n", "# will raise an AssertionError", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "fig", ".", "_slice_time", "(", "s", ",", "t_start", ",", "t_stop", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_different_tz_no_tz_series_slicing": [[518, 552], ["pandas.Series", "plotly_resampler.FigureWidgetResampler", "enumerate", "pd.Series.tz_localize", "pd.Series.tz_localize().tz_localize", "pd.Series.tz_convert", "pd.Series.tz_convert", "pd.Series.tz_convert", "plotly.Figure", "sorted", "t_start.tz_localize.tz_localize", "t_stop.tz_localize.tz_localize", "plotly_resampler.FigureWidgetResampler._slice_time", "pandas.date_range", "numpy.random.randn", "s.tz_localize", "pandas.Timedelta", "pandas.Timedelta", "pd.Series.tz_localize", "fig._slice_time.index[].tz_localize", "fig._slice_time.index[].tz_localize", "s.tz_localize", "numpy.random.randint", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time"], ["", "", "", "def", "test_different_tz_no_tz_series_slicing", "(", ")", ":", "\n", "    ", "n", "=", "60", "*", "60", "*", "24", "*", "3", "\n", "dr", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", ",", "\n", "data", "=", "np", ".", "random", ".", "randn", "(", "n", ")", ",", "\n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "cs", ")", ":", "\n", "        ", "t_start", ",", "t_stop", "=", "sorted", "(", "\n", "s", ".", "tz_localize", "(", "None", ")", ".", "iloc", "[", "np", ".", "random", ".", "randint", "(", "n", "/", "2", ",", "n", ",", "2", ")", "]", ".", "index", "\n", ")", "\n", "# both timestamps now have the same tz", "\n", "t_start", "=", "t_start", ".", "tz_localize", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "t_stop", "=", "t_stop", ".", "tz_localize", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "\n", "# the s has no time-info -> assumption is made that s has the same time-zone", "\n", "# the timestamps", "\n", "out", "=", "fig", ".", "_slice_time", "(", "s", ".", "tz_localize", "(", "None", ")", ",", "t_start", ",", "t_stop", ")", "\n", "assert", "(", "out", ".", "index", "[", "0", "]", ".", "tz_localize", "(", "t_start", ".", "tz", ")", "-", "t_start", ")", "<=", "pd", ".", "Timedelta", "(", "\n", "seconds", "=", "1", "\n", ")", "\n", "assert", "(", "out", ".", "index", "[", "-", "1", "]", ".", "tz_localize", "(", "t_stop", ".", "tz", ")", "-", "t_stop", ")", "<=", "pd", ".", "Timedelta", "(", "\n", "seconds", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_multiple_tz_no_tz_series_slicing": [[555, 585], ["pandas.Series", "plotly_resampler.FigureWidgetResampler", "enumerate", "pd.Series.tz_localize", "pd.Series.tz_localize().tz_localize", "pd.Series.tz_convert", "pd.Series.tz_convert", "pd.Series.tz_convert", "plotly.Figure", "sorted", "t_start.tz_localize.tz_localize", "t_stop.tz_localize.tz_localize", "pandas.date_range", "numpy.random.randn", "pytest.raises", "plotly_resampler.FigureWidgetResampler._slice_time", "pd.Series.tz_localize", "s.tz_localize", "s.tz_localize", "numpy.random.randint", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._slice_time"], ["", "", "def", "test_multiple_tz_no_tz_series_slicing", "(", ")", ":", "\n", "    ", "n", "=", "60", "*", "60", "*", "24", "*", "3", "\n", "dr", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\"2022-02-14\"", ",", "freq", "=", "\"s\"", ",", "periods", "=", "n", ",", "tz", "=", "\"UTC\"", ")", ",", "\n", "data", "=", "np", ".", "random", ".", "randn", "(", "n", ")", ",", "\n", ")", "\n", "\n", "cs", "=", "[", "\n", "dr", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ",", "\n", "dr", ".", "tz_localize", "(", "None", ")", ".", "tz_localize", "(", "\"Europe/Amsterdam\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Europe/Brussels\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Perth\"", ")", ",", "\n", "dr", ".", "tz_convert", "(", "\"Australia/Canberra\"", ")", ",", "\n", "]", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "cs", ")", ":", "\n", "        ", "t_start", ",", "t_stop", "=", "sorted", "(", "\n", "s", ".", "tz_localize", "(", "None", ")", ".", "iloc", "[", "np", ".", "random", ".", "randint", "(", "n", "/", "2", ",", "n", ",", "2", ")", "]", ".", "index", "\n", ")", "\n", "# both timestamps now have the a different tz", "\n", "t_start", "=", "t_start", ".", "tz_localize", "(", "cs", "[", "(", "i", "+", "1", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "t_stop", "=", "t_stop", ".", "tz_localize", "(", "cs", "[", "(", "i", "+", "2", ")", "%", "len", "(", "cs", ")", "]", ".", "index", ".", "tz", ")", "\n", "\n", "# Now the assumption cannot be made that s has the same time-zone as the", "\n", "# timestamps -> AssertionError will be raised.", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "fig", ".", "_slice_time", "(", "s", ".", "tz_localize", "(", "None", ")", ",", "t_start", ",", "t_stop", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_check_update_figure_dict": [[587, 596], ["plotly_resampler.FigureWidgetResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._check_update_figure_dict", "plotly.Figure", "plotly.Scattergl", "plotly_resampler.FigureWidgetResampler.to_dict"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator._check_update_figure_dict"], ["", "", "", "def", "test_check_update_figure_dict", "(", ")", ":", "\n", "# mostly written to test the check_update_figure_dict with", "\n", "# \"updated_trace_indices\" = None", "\n", "    ", "fr", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "fr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "fr", ".", "_check_update_figure_dict", "(", "fr", ".", "to_dict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_hf_data_property": [[598, 611], ["plotly_resampler.FigureWidgetResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "numpy.all", "plotly.Figure", "len", "plotly.Scattergl", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_hf_data_property", "(", ")", ":", "\n", "    ", "fwr", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ",", "default_n_shown_samples", "=", "2_000", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "0", "\n", "fwr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "n", "\n", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "x", "\n", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "-", "2", "*", "y", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "==", "x", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "y", "*", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_hf_data_property_reset_axes": [[613, 638], ["plotly_resampler.FigureWidgetResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.layout.update", "numpy.all", "plotly_resampler.FigureWidgetResampler.reset_axes", "numpy.all", "plotly.Figure", "len", "plotly.Scattergl", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes"], ["", "def", "test_hf_data_property_reset_axes", "(", ")", ":", "\n", "    ", "fwr", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ",", "default_n_shown_samples", "=", "2_000", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "0", "\n", "fwr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "\n", "fwr", ".", "layout", ".", "update", "(", "\n", "{", "\"xaxis\"", ":", "{", "\"range\"", ":", "[", "10_000", ",", "20_000", "]", "}", ",", "\"yaxis\"", ":", "{", "\"range\"", ":", "[", "-", "20", ",", "3", "]", "}", "}", ",", "\n", "overwrite", "=", "False", ",", "\n", ")", "\n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "n", "\n", "new_y", "=", "-", "2", "*", "y", "\n", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "new_y", "\n", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", ")", "\n", "\n", "fwr", ".", "reset_axes", "(", ")", "\n", "assert", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", "<=", "100", ")", "&", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", ">=", "99_900", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", "[", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "]", ")", "\n", "assert", "fwr", ".", "layout", "[", "\"yaxis\"", "]", ".", "range", "is", "None", "or", "fwr", ".", "layout", "[", "\"yaxis\"", "]", ".", "range", "[", "0", "]", "<", "-", "100", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_hf_data_property_reload_data": [[640, 665], ["plotly_resampler.FigureWidgetResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.layout.update", "numpy.all", "plotly_resampler.FigureWidgetResampler.reload_data", "numpy.all", "plotly.Figure", "len", "plotly.Scattergl", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "def", "test_hf_data_property_reload_data", "(", ")", ":", "\n", "    ", "fwr", "=", "FigureWidgetResampler", "(", "go", ".", "Figure", "(", ")", ",", "default_n_shown_samples", "=", "2_000", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "0", "\n", "fwr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ")", "\n", "\n", "fwr", ".", "layout", ".", "update", "(", "\n", "{", "\"xaxis\"", ":", "{", "\"range\"", ":", "[", "10_000", ",", "20_000", "]", "}", ",", "\"yaxis\"", ":", "{", "\"range\"", ":", "[", "-", "20", ",", "3", "]", "}", "}", ",", "\n", "overwrite", "=", "False", ",", "\n", ")", "\n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "n", "\n", "new_y", "=", "-", "2", "*", "y", "\n", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "new_y", "\n", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", ")", "\n", "\n", "fwr", ".", "reload_data", "(", ")", "\n", "assert", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "10_000", ")", "&", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<=", "20_000", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", "[", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "]", ")", "\n", "assert", "(", "fwr", ".", "layout", "[", "\"yaxis\"", "]", ".", "range", "[", "0", "]", "==", "-", "20", ")", "&", "(", "fwr", ".", "layout", "[", "\"yaxis\"", "]", ".", "range", "[", "-", "1", "]", "==", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_hf_data_property_subplots_reset_axes": [[667, 704], ["plotly_resampler.FigureWidgetResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.layout.update", "numpy.all", "numpy.all", "plotly_resampler.FigureWidgetResampler.reset_axes", "numpy.all", "numpy.all", "plotly.subplots.make_subplots", "len", "plotly.Scattergl", "plotly.Scattergl", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.fr_selenium.FigureResamplerGUITests.reset_axes"], ["", "def", "test_hf_data_property_subplots_reset_axes", "(", ")", ":", "\n", "    ", "fwr", "=", "FigureWidgetResampler", "(", "make_subplots", "(", "rows", "=", "2", ",", "cols", "=", "1", ",", "shared_xaxes", "=", "False", ")", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "0", "\n", "fwr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ",", "row", "=", "1", ",", "col", "=", "1", ")", "\n", "fwr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ",", "row", "=", "2", ",", "col", "=", "1", ")", "\n", "\n", "fwr", ".", "layout", ".", "update", "(", "\n", "{", "\n", "\"xaxis\"", ":", "{", "\"range\"", ":", "[", "10_000", ",", "20_000", "]", "}", ",", "\n", "\"yaxis\"", ":", "{", "\"range\"", ":", "[", "-", "20", ",", "3", "]", "}", ",", "\n", "\"xaxis2\"", ":", "{", "\"range\"", ":", "[", "40_000", ",", "60_000", "]", "}", ",", "\n", "\"yaxis2\"", ":", "{", "\"range\"", ":", "[", "-", "10", ",", "3", "]", "}", ",", "\n", "}", ",", "\n", "overwrite", "=", "False", ",", "\n", ")", "\n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", "[", "1", "]", "[", "\"x\"", "]", ")", "==", "n", "\n", "new_y", "=", "-", "2", "*", "y", "\n", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "new_y", "\n", "fwr", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "=", "new_y", "\n", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", ")", "\n", "\n", "fwr", ".", "reset_axes", "(", ")", "\n", "assert", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", "<=", "100", ")", "&", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", ">=", "99_900", ")", "\n", "assert", "(", "fwr", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", "<=", "100", ")", "&", "(", "fwr", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", ">=", "99_900", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", "[", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "]", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "data", "[", "1", "]", "[", "\"y\"", "]", "==", "new_y", "[", "fwr", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "]", ")", "\n", "assert", "fwr", ".", "layout", "[", "\"yaxis\"", "]", ".", "range", "is", "None", "or", "fwr", ".", "layout", "[", "\"yaxis\"", "]", ".", "range", "[", "0", "]", "<", "-", "100", "\n", "assert", "fwr", ".", "layout", "[", "\"yaxis2\"", "]", ".", "range", "is", "None", "or", "fwr", ".", "layout", "[", "\"yaxis2\"", "]", ".", "range", "[", "0", "]", "<", "-", "100", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_hf_data_property_subplots_reload_data": [[706, 744], ["plotly_resampler.FigureWidgetResampler", "numpy.arange", "numpy.sin", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.layout.update", "numpy.all", "numpy.all", "plotly_resampler.FigureWidgetResampler.reload_data", "numpy.all", "numpy.all", "plotly.subplots.make_subplots", "len", "plotly.Scattergl", "plotly.Scattergl", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "def", "test_hf_data_property_subplots_reload_data", "(", ")", ":", "\n", "    ", "fwr", "=", "FigureWidgetResampler", "(", "make_subplots", "(", "rows", "=", "2", ",", "cols", "=", "1", ",", "shared_xaxes", "=", "False", ")", ")", "\n", "n", "=", "100_000", "\n", "x", "=", "np", ".", "arange", "(", "n", ")", "\n", "y", "=", "np", ".", "sin", "(", "x", ")", "\n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "0", "\n", "fwr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ",", "row", "=", "1", ",", "col", "=", "1", ")", "\n", "fwr", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"test\"", ")", ",", "hf_x", "=", "x", ",", "hf_y", "=", "y", ",", "row", "=", "2", ",", "col", "=", "1", ")", "\n", "\n", "fwr", ".", "layout", ".", "update", "(", "\n", "{", "\n", "\"xaxis\"", ":", "{", "\"range\"", ":", "[", "10_000", ",", "20_000", "]", "}", ",", "\n", "\"yaxis\"", ":", "{", "\"range\"", ":", "[", "-", "20", ",", "3", "]", "}", ",", "\n", "\"xaxis2\"", ":", "{", "\"range\"", ":", "[", "40_000", ",", "60_000", "]", "}", ",", "\n", "\"yaxis2\"", ":", "{", "\"range\"", ":", "[", "-", "10", ",", "3", "]", "}", ",", "\n", "}", ",", "\n", "overwrite", "=", "False", ",", "\n", ")", "\n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "n", "\n", "assert", "len", "(", "fwr", ".", "hf_data", "[", "1", "]", "[", "\"x\"", "]", ")", "==", "n", "\n", "new_y", "=", "-", "2", "*", "y", "\n", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "new_y", "\n", "fwr", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "=", "new_y", "\n", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", ")", "\n", "\n", "fwr", ".", "reload_data", "(", ")", "\n", "assert", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "10_000", ")", "&", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<=", "20_000", ")", "\n", "assert", "(", "fwr", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "40_000", ")", "&", "(", "fwr", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<=", "60_000", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "new_y", "[", "fwr", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "]", ")", "\n", "assert", "np", ".", "all", "(", "fwr", ".", "data", "[", "1", "]", "[", "\"y\"", "]", "==", "new_y", "[", "fwr", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "]", ")", "\n", "assert", "(", "fwr", ".", "layout", "[", "\"yaxis\"", "]", ".", "range", "[", "0", "]", "==", "-", "20", ")", "&", "(", "fwr", ".", "layout", "[", "\"yaxis\"", "]", ".", "range", "[", "-", "1", "]", "==", "3", ")", "\n", "assert", "(", "fwr", ".", "layout", "[", "\"yaxis2\"", "]", ".", "range", "[", "0", "]", "==", "-", "10", ")", "&", "(", "\n", "fwr", ".", "layout", "[", "\"yaxis2\"", "]", ".", "range", "[", "-", "1", "]", "==", "3", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_updates_two_traces": [[747, 833], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.update_layout", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler.layout.update", "numpy.sin", "plotly.subplots.make_subplots", "plotly.Scattergl", "plotly.Scattergl", "len", "sum", "sum", "len", "sum", "sum", "sum", "numpy.random.rand", "numpy.arange", "isinstance", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_updates_two_traces", "(", ")", ":", "\n", "    ", "n", "=", "1_000_000", "\n", "X", "=", "np", ".", "arange", "(", "n", ")", "\n", "Y", "=", "np", ".", "random", ".", "rand", "(", "n", ")", "/", "5", "+", "np", ".", "sin", "(", "np", ".", "arange", "(", "n", ")", "/", "10000", ")", "\n", "\n", "fw_fig", "=", "FigureWidgetResampler", "(", "\n", "make_subplots", "(", "rows", "=", "2", ",", "shared_xaxes", "=", "False", ")", ",", "verbose", "=", "True", "\n", ")", "\n", "fw_fig", ".", "update_layout", "(", "height", "=", "400", ",", "showlegend", "=", "True", ")", "\n", "\n", "fw_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", ")", ",", "hf_x", "=", "X", ",", "hf_y", "=", "(", "Y", "+", "90", ")", "*", "X", "/", "2000", ",", "row", "=", "1", ",", "col", "=", "1", ")", "\n", "fw_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", ")", ",", "hf_x", "=", "X", ",", "hf_y", "=", "(", "Y", "+", "3", ")", "*", "0.99999", "**", "X", ",", "row", "=", "2", ",", "col", "=", "1", ")", "\n", "\n", "# we do not want to have an relayout update", "\n", "assert", "len", "(", "fw_fig", ".", "_relayout_hist", ")", "==", "0", "\n", "\n", "# zoom in on both traces", "\n", "fw_fig", ".", "layout", ".", "update", "(", "\n", "{", "\"xaxis\"", ":", "{", "\"range\"", ":", "[", "10_000", ",", "200_000", "]", "}", ",", "\"xaxis2\"", ":", "{", "\"range\"", ":", "[", "0", ",", "200_000", "]", "}", "}", ",", "\n", "overwrite", "=", "False", ",", "\n", ")", "\n", "\n", "# check whether the two traces were updated with the xaxis-range method", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "2", "]", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "sum", "(", "[", "[", "\"xaxis-range-update\"", ",", "2", "]", "==", "rh", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "]", ")", "==", "1", "\n", "# check whether the showspikes update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"showspikes-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "# apply an autorange, see whether an update takes place", "\n", "fw_fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "fw_fig", ".", "layout", ".", "update", "(", "{", "\"xaxis\"", ":", "{", "\"autorange\"", ":", "True", "}", "}", ")", "\n", "fw_fig", ".", "layout", ".", "update", "(", "{", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", "}", "}", ")", "\n", "\n", "assert", "len", "(", "fw_fig", ".", "_relayout_hist", ")", "==", "0", "\n", "\n", "# Perform a reset axis update", "\n", "fw_fig", ".", "layout", ".", "update", "(", "\n", "{", "\n", "\"xaxis\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# check whether the two traces were updated with the showspike method", "\n", "assert", "[", "\"showspikes-update\"", ",", "2", "]", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "sum", "(", "[", "[", "\"showspikes-update\"", ",", "2", "]", "==", "rh", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "]", ")", "==", "1", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "# RE-perform a reset axis update", "\n", "fw_fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "fw_fig", ".", "layout", ".", "update", "(", "\n", "{", "\n", "\"xaxis\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# check whether none of the traces we updated with the showspike method", "\n", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "[", "\"showspikes-update\"", ",", "2", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_updates_two_traces_single_trace_adjust": [[836, 928], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.update_layout", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler.layout.update", "numpy.sin", "plotly.subplots.make_subplots", "plotly.Scattergl", "plotly.Scattergl", "len", "sum", "sum", "len", "sum", "sum", "sum", "numpy.random.rand", "numpy.arange", "isinstance", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_updates_two_traces_single_trace_adjust", "(", ")", ":", "\n", "    ", "n", "=", "1_000_000", "\n", "X", "=", "np", ".", "arange", "(", "n", ")", "\n", "Y", "=", "np", ".", "random", ".", "rand", "(", "n", ")", "/", "5", "+", "np", ".", "sin", "(", "np", ".", "arange", "(", "n", ")", "/", "10000", ")", "\n", "\n", "fw_fig", "=", "FigureWidgetResampler", "(", "\n", "make_subplots", "(", "rows", "=", "2", ",", "shared_xaxes", "=", "False", ")", ",", "verbose", "=", "True", "\n", ")", "\n", "fw_fig", ".", "update_layout", "(", "height", "=", "400", ",", "showlegend", "=", "True", ")", "\n", "\n", "fw_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", ")", ",", "hf_x", "=", "X", ",", "hf_y", "=", "(", "Y", "+", "90", ")", "*", "X", "/", "2000", ",", "row", "=", "1", ",", "col", "=", "1", ")", "\n", "fw_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", ")", ",", "hf_x", "=", "X", ",", "hf_y", "=", "(", "Y", "+", "3", ")", "*", "0.99999", "**", "X", ",", "row", "=", "2", ",", "col", "=", "1", ")", "\n", "\n", "# we do not want to have an relayout update", "\n", "assert", "len", "(", "fw_fig", ".", "_relayout_hist", ")", "==", "0", "\n", "\n", "# zoom in on both traces", "\n", "fw_fig", ".", "layout", ".", "update", "(", "\n", "{", "\"xaxis2\"", ":", "{", "\"range\"", ":", "[", "0", ",", "200_000", "]", "}", "}", ",", "\n", "overwrite", "=", "False", ",", "\n", ")", "\n", "\n", "# check whether the single traces were updated with the xaxis-range method", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "1", "]", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "2", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "sum", "(", "[", "[", "\"xaxis-range-update\"", ",", "1", "]", "==", "rh", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "]", ")", "==", "1", "\n", "\n", "# check whether the showspikes update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"showspikes-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "fw_fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "# apply an autorange, see whether an update takes place", "\n", "fw_fig", ".", "layout", ".", "update", "(", "{", "\"xaxis\"", ":", "{", "\"autorange\"", ":", "True", "}", "}", ")", "\n", "fw_fig", ".", "layout", ".", "update", "(", "{", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", "}", "}", ")", "\n", "\n", "assert", "len", "(", "fw_fig", ".", "_relayout_hist", ")", "==", "0", "\n", "\n", "# Perform a reset axis update", "\n", "fw_fig", ".", "layout", ".", "update", "(", "\n", "{", "\n", "\"xaxis\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# check whether the single traces was updated with the showspike method", "\n", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "not", "[", "\"showspikes-update\"", ",", "2", "]", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "sum", "(", "[", "[", "\"showspikes-update\"", ",", "1", "]", "==", "rh", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "]", ")", "==", "1", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "fw_fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "# RE-perform a reset axis update", "\n", "#", "\n", "fw_fig", ".", "layout", ".", "update", "(", "\n", "{", "\n", "\"xaxis\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# check whether none of the traces we updated with the showspike method", "\n", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "[", "\"showspikes-update\"", ",", "2", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_update_direct_reset_axis": [[931, 968], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.update_layout", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.layout.update", "numpy.sin", "plotly.subplots.make_subplots", "plotly.Scattergl", "plotly.Scattergl", "len", "sum", "sum", "numpy.random.rand", "numpy.arange", "isinstance"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_update_direct_reset_axis", "(", ")", ":", "\n", "    ", "n", "=", "1_000_000", "\n", "X", "=", "np", ".", "arange", "(", "n", ")", "\n", "Y", "=", "np", ".", "random", ".", "rand", "(", "n", ")", "/", "5", "+", "np", ".", "sin", "(", "np", ".", "arange", "(", "n", ")", "/", "10000", ")", "\n", "\n", "fw_fig", "=", "FigureWidgetResampler", "(", "\n", "make_subplots", "(", "rows", "=", "2", ",", "shared_xaxes", "=", "False", ")", ",", "verbose", "=", "True", "\n", ")", "\n", "fw_fig", ".", "update_layout", "(", "height", "=", "400", ",", "showlegend", "=", "True", ")", "\n", "\n", "fw_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", ")", ",", "hf_x", "=", "X", ",", "hf_y", "=", "(", "Y", "+", "90", ")", "*", "X", "/", "2000", ",", "row", "=", "1", ",", "col", "=", "1", ")", "\n", "fw_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", ")", ",", "hf_x", "=", "X", ",", "hf_y", "=", "(", "Y", "+", "3", ")", "*", "0.99999", "**", "X", ",", "row", "=", "2", ",", "col", "=", "1", ")", "\n", "\n", "# we do not want to have an relayout update", "\n", "assert", "len", "(", "fw_fig", ".", "_relayout_hist", ")", "==", "0", "\n", "\n", "# Perform a reset_axis", "\n", "fw_fig", ".", "layout", ".", "update", "(", "\n", "{", "\n", "\"xaxis\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# check whether the two traces was updated with the showspike method", "\n", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "[", "\"showspikes-update\"", ",", "2", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "sum", "(", "[", "[", "\"showspikes-update\"", ",", "1", "]", "==", "rh", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "]", ")", "==", "0", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_bare_update_methods": [[971, 1087], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.update_layout", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._update_spike_ranges", "plotly_resampler.FigureWidgetResampler._update_spike_ranges", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler._update_x_ranges", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler._update_x_ranges", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler._update_spike_ranges", "numpy.sin", "plotly.subplots.make_subplots", "plotly.Scattergl", "plotly.Scattergl", "sum", "sum", "copy.copy().update", "sum", "sum", "copy.copy().update", "sum", "len", "len", "sum", "numpy.random.rand", "len", "len", "numpy.arange", "copy.copy", "copy.copy", "isinstance", "isinstance", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_spike_ranges", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_spike_ranges", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_x_ranges", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_x_ranges", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_spike_ranges"], ["", "def", "test_bare_update_methods", "(", ")", ":", "\n", "    ", "n", "=", "1_000_000", "\n", "X", "=", "np", ".", "arange", "(", "n", ")", "\n", "Y", "=", "np", ".", "random", ".", "rand", "(", "n", ")", "/", "5", "+", "np", ".", "sin", "(", "np", ".", "arange", "(", "n", ")", "/", "10000", ")", "\n", "\n", "fw_fig", "=", "FigureWidgetResampler", "(", "\n", "make_subplots", "(", "rows", "=", "2", ",", "shared_xaxes", "=", "False", ")", ",", "verbose", "=", "True", "\n", ")", "\n", "fw_fig", ".", "update_layout", "(", "height", "=", "400", ",", "showlegend", "=", "True", ")", "\n", "\n", "fw_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", ")", ",", "hf_x", "=", "X", ",", "hf_y", "=", "(", "Y", "+", "90", ")", "*", "X", "/", "2000", ",", "row", "=", "1", ",", "col", "=", "1", ")", "\n", "fw_fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", ")", ",", "hf_x", "=", "X", ",", "hf_y", "=", "(", "Y", "+", "3", ")", "*", "0.99999", "**", "X", ",", "row", "=", "2", ",", "col", "=", "1", ")", "\n", "\n", "# equivalent of calling the reset-axis dict update", "\n", "fw_fig", ".", "_update_spike_ranges", "(", "fw_fig", ".", "layout", ",", "False", ",", "False", ")", "\n", "fw_fig", ".", "_update_spike_ranges", "(", "fw_fig", ".", "layout", ",", "False", ",", "False", ")", "\n", "\n", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "[", "\"showspikes-update\"", ",", "2", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "sum", "(", "[", "[", "\"showspikes-update\"", ",", "1", "]", "==", "rh", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "]", ")", "==", "0", "\n", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "fw_fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "# Zoom in on the xaxis2", "\n", "fw_fig", ".", "_update_x_ranges", "(", "\n", "copy", "(", "fw_fig", ".", "layout", ")", ".", "update", "(", "\n", "{", "\"xaxis2\"", ":", "{", "\"range\"", ":", "[", "0", ",", "200_000", "]", "}", "}", ",", "\n", "overwrite", "=", "True", ",", "\n", ")", ",", "\n", "(", "0", ",", "len", "(", "X", ")", ")", ",", "\n", "(", "0", ",", "200_000", ")", ",", "\n", ")", "\n", "\n", "# check whether the single traces were updated with the xaxis-range method", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "1", "]", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "2", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "sum", "(", "[", "[", "\"xaxis-range-update\"", ",", "1", "]", "==", "rh", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "]", ")", "==", "1", "\n", "\n", "# check whether the showspikes update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"showspikes-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "# check whether the new update call (on the same range) does nothing", "\n", "fw_fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "fw_fig", ".", "_update_x_ranges", "(", "\n", "copy", "(", "fw_fig", ".", "layout", ")", ".", "update", "(", "\n", "{", "\"xaxis2\"", ":", "{", "\"range\"", ":", "[", "0", ",", "200_000", "]", "}", "}", ",", "\n", "overwrite", "=", "True", ",", "\n", ")", ",", "\n", "(", "0", ",", "len", "(", "X", ")", ")", ",", "\n", "(", "0", ",", "200_000", ")", ",", "\n", ")", "\n", "\n", "# check whether none of the traces we updated with the showspike method", "\n", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "[", "\"showspikes-update\"", ",", "2", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "# Perform an autorange update -> assert that the range i", "\n", "fw_fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "fw_fig", ".", "layout", ".", "update", "(", "{", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", "}", ",", "\"yaxis2\"", ":", "{", "\"autorange\"", ":", "True", "}", "}", ")", "\n", "assert", "len", "(", "fw_fig", ".", "_relayout_hist", ")", "==", "0", "\n", "\n", "fw_fig", ".", "layout", ".", "update", "(", "{", "\"yaxis2\"", ":", "{", "\"range\"", ":", "[", "0", ",", "2", "]", "}", "}", ")", "\n", "assert", "len", "(", "fw_fig", ".", "_relayout_hist", ")", "==", "0", "\n", "\n", "# perform an reset axis", "\n", "fw_fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "l", "=", "fw_fig", ".", "layout", ".", "update", "(", "\n", "{", "\n", "\"xaxis\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "\"xaxis2\"", ":", "{", "\"autorange\"", ":", "True", ",", "\"showspikes\"", ":", "False", "}", ",", "\n", "}", ",", "\n", "overwrite", "=", "True", ",", "# by setting this to true -> the update call will not takte clear", "\n", ")", "\n", "fw_fig", ".", "_update_spike_ranges", "(", "l", ",", "False", ",", "False", ")", "\n", "\n", "# Assert that only a single trace was updated", "\n", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "in", "fw_fig", ".", "_relayout_hist", "\n", "assert", "[", "\"showspikes-update\"", ",", "2", "]", "not", "in", "fw_fig", ".", "_relayout_hist", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fw_fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_add_empty_trace": [[1090, 1097], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly.FigureWidget", "plotly.Scattergl", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fwr_add_empty_trace", "(", ")", ":", "\n", "    ", "fig", "=", "FigureWidgetResampler", "(", "go", ".", "FigureWidget", "(", ")", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"Test\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "len", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "0", "\n", "assert", "len", "(", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_update_trace_data_zoom": [[1099, 1195], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "numpy.random.randn", "numpy.arange", "plotly_resampler.FigureWidgetResampler.reload_data", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler._update_x_ranges", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler.reload_data", "plotly_resampler.FigureWidgetResampler.layout.update", "plotly_resampler.FigureWidgetResampler._update_x_ranges", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly_resampler.FigureWidgetResampler.reload_data", "plotly.FigureWidget", "plotly.Scattergl", "plotly.Scattergl", "numpy.arange", "sum", "sum", "sum", "plotly.subplots.make_subplots", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "len", "isinstance", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_x_ranges", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler._update_x_ranges", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "def", "test_fwr_update_trace_data_zoom", "(", ")", ":", "\n", "    ", "k", "=", "50_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "\n", "go", ".", "FigureWidget", "(", "make_subplots", "(", "rows", "=", "2", ",", "cols", "=", "1", ")", ")", ",", "verbose", "=", "True", "\n", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "\"A\"", ",", "line_color", "=", "\"red\"", ")", ",", "limit_to_view", "=", "True", ",", "row", "=", "1", ",", "col", "=", "1", "\n", ")", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scattergl", "(", "name", "=", "\"B\"", ",", "line_color", "=", "\"green\"", ")", ",", "limit_to_view", "=", "True", ",", "row", "=", "2", ",", "col", "=", "1", "\n", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "A", "=", "np", ".", "random", ".", "randn", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "np", ".", "arange", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "np", ".", "arange", "(", "k", ")", "+", "A", "*", "300", "*", "20", "\n", "\n", "fig", ".", "hf_data", "[", "1", "]", "[", "\"x\"", "]", "=", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "\n", "fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "=", "-", "np", ".", "arange", "(", "k", ")", "+", "A", "*", "300", "*", "40", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n", "# In the current implementation -> reload data will update all traces", "\n", "# Since there was no zoom-in event -> the `showspikes-update` will be called", "\n", "assert", "[", "\"showspikes-update\"", ",", "2", "]", "in", "fig", ".", "_relayout_hist", "\n", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"xaxis-range-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "# zoom in on the first row it's xaxis and perform a layout update", "\n", "l", "=", "fig", ".", "layout", ".", "update", "(", "\n", "{", "\"xaxis\"", ":", "{", "\"range\"", ":", "[", "0", ",", "100_000", "]", "}", "}", ",", "\n", "overwrite", "=", "True", ",", "\n", ")", "\n", "fig", ".", "_update_x_ranges", "(", "\n", "l", ",", "(", "0", ",", "100_000", ")", ",", "(", "fig", ".", "hf_data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ",", "fig", ".", "hf_data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", ")", "\n", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "fig", ".", "hf_data", "[", "1", "]", "[", "\"x\"", "]", "=", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "\n", "fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "=", "-", "np", ".", "arange", "(", "k", ")", "+", "A", "*", "300", "*", "10", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n", "# In the current implementation -> reload data will update all traces", "\n", "# As we have performed a zoom event -> the`update showspikes` `will be called", "\n", "# TODO -> for some reason this assert does not succeed when not showing the graph", "\n", "# data", "\n", "# assert [\"xaxis-range-update\", len(fig.hf_data)] in fig._relayout_hist", "\n", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"showspikes-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "# zoom in on the second row it's xaxis and perform a layout update", "\n", "l", "=", "fig", ".", "layout", ".", "update", "(", "\n", "{", "\"xaxis2\"", ":", "{", "\"range\"", ":", "[", "200_000", ",", "500_000", "]", "}", "}", ",", "\n", "overwrite", "=", "True", ",", "\n", ")", "\n", "fig", ".", "_update_x_ranges", "(", "l", ",", "(", "0", ",", "100_000", ")", ",", "(", "200_000", ",", "500_000", ")", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "-", "np", ".", "arange", "(", "k", ")", "+", "A", "*", "300", "*", "39", "\n", "fig", ".", "hf_data", "[", "1", "]", "[", "\"x\"", "]", "=", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "\n", "fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "=", "-", "np", ".", "arange", "(", "k", ")", "+", "A", "*", "300", "*", "25", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n", "# In the current implementation -> reload data will update all traces", "\n", "# As we have performed a zoom event -> the`update showspikes` `will be called", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "len", "(", "fig", ".", "hf_data", ")", "]", "in", "fig", ".", "_relayout_hist", "\n", "\n", "# check whether the xaxis-range-update was did not enter the update state", "\n", "assert", "(", "\n", "sum", "(", "\n", "[", "\n", "\"showspikes-update\"", "in", "rh", "if", "isinstance", "(", "rh", ",", "list", ")", "else", "False", "\n", "for", "rh", "in", "fig", ".", "_relayout_hist", "\n", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_text_update": [[1198, 1219], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "numpy.random.randn", "numpy.arange", "plotly_resampler.FigureWidgetResampler.reload_data", "[].astype", "plotly.Scattergl", "numpy.arange", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "def", "test_fwr_text_update", "(", ")", ":", "\n", "    ", "k", "=", "10_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"A\"", ",", "line_color", "=", "\"red\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "A", "=", "np", ".", "random", ".", "randn", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "np", ".", "arange", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "np", ".", "arange", "(", "k", ")", "+", "A", "*", "300", "*", "20", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "=", "(", "-", "A", "*", "20", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "in", "fig", ".", "_relayout_hist", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "1", "]", "not", "in", "fig", ".", "_relayout_hist", "\n", "\n", "text", "=", "fig", ".", "data", "[", "0", "]", "[", "\"text\"", "]", ".", "astype", "(", "int", ")", "\n", "hovertext", "=", "fig", ".", "data", "[", "0", "]", "[", "\"hovertext\"", "]", "\n", "\n", "assert", "len", "(", "text", ")", "==", "1000", "\n", "assert", "hovertext", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_hovertext_update": [[1221, 1243], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "[].astype", "plotly.Scattergl", "plotly_resampler.FigureWidgetResampler.batch_update", "numpy.random.randn", "numpy.arange", "plotly_resampler.FigureWidgetResampler.reload_data", "len", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "def", "test_fwr_hovertext_update", "(", ")", ":", "\n", "    ", "k", "=", "10_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"B\"", ",", "line_color", "=", "\"red\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "with", "fig", ".", "batch_update", "(", ")", ":", "\n", "        ", "A", "=", "np", ".", "random", ".", "randn", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "np", ".", "arange", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "np", ".", "arange", "(", "k", ")", "+", "A", "*", "300", "*", "20", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "=", "(", "-", "A", "*", "20", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n", "", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "in", "fig", ".", "_relayout_hist", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "1", "]", "not", "in", "fig", ".", "_relayout_hist", "\n", "\n", "text", "=", "fig", ".", "data", "[", "0", "]", "[", "\"text\"", "]", "\n", "hovertext", "=", "fig", ".", "data", "[", "0", "]", "[", "\"hovertext\"", "]", ".", "astype", "(", "int", ")", "\n", "\n", "assert", "len", "(", "hovertext", ")", "==", "1000", "\n", "assert", "text", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_text_hovertext_update": [[1245, 1271], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "[].astype", "[].astype", "plotly.Scattergl", "plotly_resampler.FigureWidgetResampler.batch_update", "numpy.random.randn", "numpy.arange", "plotly_resampler.FigureWidgetResampler.reload_data", "len", "len", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "def", "test_fwr_text_hovertext_update", "(", ")", ":", "\n", "    ", "k", "=", "10_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"B\"", ",", "line_color", "=", "\"red\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "with", "fig", ".", "batch_update", "(", ")", ":", "\n", "        ", "A", "=", "np", ".", "random", ".", "randn", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "np", ".", "arange", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "np", ".", "arange", "(", "k", ")", "+", "A", "*", "300", "*", "20", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "=", "(", "-", "A", "*", "20", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "=", "(", "A", "*", "20", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n", "", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "in", "fig", ".", "_relayout_hist", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "1", "]", "not", "in", "fig", ".", "_relayout_hist", "\n", "\n", "text", "=", "fig", ".", "data", "[", "0", "]", "[", "\"text\"", "]", ".", "astype", "(", "int", ")", "\n", "hovertext", "=", "fig", ".", "data", "[", "0", "]", "[", "\"hovertext\"", "]", ".", "astype", "(", "int", ")", "\n", "\n", "assert", "len", "(", "hovertext", ")", "==", "1000", "\n", "assert", "len", "(", "text", ")", "==", "1000", "\n", "\n", "# text === -hovertext -> so the sum should their length", "\n", "assert", "(", "text", "==", "-", "hovertext", ")", ".", "sum", "(", ")", "==", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_adjust_text_unequal_length": [[1273, 1286], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly.Scattergl", "pytest.raises", "numpy.random.randn", "numpy.arange", "plotly_resampler.FigureWidgetResampler.reload_data", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "def", "test_fwr_adjust_text_unequal_length", "(", ")", ":", "\n", "    ", "k", "=", "10_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"A\"", ",", "line_color", "=", "\"red\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "A", "=", "np", ".", "random", ".", "randn", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "np", ".", "arange", "(", "k", "+", "100", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "np", ".", "arange", "(", "k", "+", "100", ")", "+", "A", "*", "300", "*", "20", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "=", "(", "-", "A", "*", "20", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_hovertext_adjust_unequal_length": [[1303, 1316], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly.Scattergl", "pytest.raises", "numpy.random.randn", "pandas.Series", "plotly_resampler.FigureWidgetResampler.reload_data", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "", "def", "test_fwr_hovertext_adjust_unequal_length", "(", ")", ":", "\n", "    ", "k", "=", "10_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"A\"", ",", "line_color", "=", "\"red\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "A", "=", "np", ".", "random", ".", "randn", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "pd", ".", "Series", "(", "np", ".", "arange", "(", "k", "-", "500", ")", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "np", ".", "arange", "(", "k", "-", "500", ")", "+", "A", "*", "300", "*", "20", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "=", "(", "-", "A", "*", "20", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_adjust_series_input": [[1318, 1341], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "plotly.Scattergl", "plotly_resampler.FigureWidgetResampler.batch_update", "numpy.random.randn", "pandas.Series", "pandas.Series", "plotly_resampler.FigureWidgetResampler.reload_data", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "", "def", "test_fwr_adjust_series_input", "(", ")", ":", "\n", "    ", "k", "=", "10_000", "\n", "a_k", "=", "np", ".", "arange", "(", "k", ")", "\n", "fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"A\"", ",", "line_color", "=", "\"red\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "with", "fig", ".", "batch_update", "(", ")", ":", "\n", "        ", "A", "=", "np", ".", "random", ".", "randn", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "pd", ".", "Series", "(", "index", "=", "a_k", "+", "1_000_000", ",", "data", "=", "a_k", "-", "2000", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "pd", ".", "Series", "(", "index", "=", "a_k", "-", "9999", ",", "data", "=", "a_k", "+", "5", "+", "np", ".", "abs", "(", "A", ")", "*", "50", ")", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n", "", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "in", "fig", ".", "_relayout_hist", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "1", "]", "not", "in", "fig", ".", "_relayout_hist", "\n", "\n", "x", "=", "fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "\n", "y", "=", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "\n", "\n", "# assert that hf x and y its values are used and not its index", "\n", "assert", "x", "[", "0", "]", "==", "-", "2000", "\n", "assert", "y", "[", "0", "]", ">=", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_adjust_series_text_input": [[1343, 1381], ["numpy.arange", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler._relayout_hist.clear", "[].astype", "[].astype", "plotly.Scattergl", "plotly_resampler.FigureWidgetResampler.batch_update", "numpy.random.randn", "pandas.Series", "pandas.Series", "pandas.Series", "pandas.Series", "plotly_resampler.FigureWidgetResampler.reload_data", "len", "len", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figurewidget_resampler.FigureWidgetResampler.reload_data"], ["", "def", "test_fwr_adjust_series_text_input", "(", ")", ":", "\n", "    ", "k", "=", "10_000", "\n", "a_k", "=", "np", ".", "arange", "(", "k", ")", "\n", "fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ")", "\n", "fig", ".", "add_trace", "(", "go", ".", "Scattergl", "(", "name", "=", "\"A\"", ",", "line_color", "=", "\"red\"", ")", ",", "limit_to_view", "=", "True", ")", "\n", "\n", "fig", ".", "_relayout_hist", ".", "clear", "(", ")", "\n", "\n", "with", "fig", ".", "batch_update", "(", ")", ":", "\n", "        ", "A", "=", "np", ".", "random", ".", "randn", "(", "k", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"x\"", "]", "=", "pd", ".", "Series", "(", "index", "=", "a_k", "+", "10_000", ",", "data", "=", "a_k", "-", "2000", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "=", "pd", ".", "Series", "(", "index", "=", "a_k", ",", "data", "=", "a_k", "+", "10", "+", "np", ".", "abs", "(", "A", ")", "*", "50", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"hovertext\"", "]", "=", "pd", ".", "Series", "(", "\n", "index", "=", "a_k", "-", "1_000_000", ",", "data", "=", "(", "-", "A", "*", "20", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", ")", "\n", "fig", ".", "hf_data", "[", "0", "]", "[", "\"text\"", "]", "=", "pd", ".", "Series", "(", "\n", "index", "=", "a_k", "+", "1_000_000", ",", "data", "=", "(", "A", "*", "20", ")", ".", "astype", "(", "int", ")", ".", "astype", "(", "str", ")", "\n", ")", "\n", "fig", ".", "reload_data", "(", ")", "\n", "\n", "", "assert", "[", "\"showspikes-update\"", ",", "1", "]", "in", "fig", ".", "_relayout_hist", "\n", "assert", "[", "\"xaxis-range-update\"", ",", "1", "]", "not", "in", "fig", ".", "_relayout_hist", "\n", "\n", "x", "=", "fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "\n", "y", "=", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "\n", "\n", "# assert that hf x and y its values are used and not its index", "\n", "assert", "x", "[", "0", "]", "==", "-", "2000", "\n", "assert", "y", "[", "0", "]", ">=", "10", "\n", "\n", "text", "=", "fig", ".", "data", "[", "0", "]", "[", "\"text\"", "]", ".", "astype", "(", "int", ")", "\n", "hovertext", "=", "fig", ".", "data", "[", "0", "]", "[", "\"hovertext\"", "]", ".", "astype", "(", "int", ")", "\n", "\n", "assert", "len", "(", "hovertext", ")", "==", "1000", "\n", "assert", "len", "(", "text", ")", "==", "1000", "\n", "\n", "# text === -hovertext -> so the sum should their length", "\n", "assert", "(", "text", "==", "-", "hovertext", ")", ".", "sum", "(", ")", "==", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_time_based_data_ns": [[1383, 1419], ["plotly_resampler.FigureWidgetResampler", "range", "pandas.Series", "plotly_resampler.FigureWidgetResampler.add_trace", "[].astype", "[].astype", "plotly_resampler.EfficientLTTB", "plotly.Scatter", "len", "len", "len", "len", "pandas.date_range", "numpy.arange", "pd.Series.astype", "datetime.datetime.now", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fwr_time_based_data_ns", "(", ")", ":", "\n", "    ", "n", "=", "100_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "\n", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ",", "default_downsampler", "=", "EfficientLTTB", "(", ")", "\n", ")", "\n", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "s", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\n", "datetime", ".", "now", "(", ")", ",", "freq", "=", "f\"{np.random.randint(5,100_000)}ns\"", ",", "periods", "=", "n", "\n", ")", ",", "\n", "data", "=", "np", ".", "arange", "(", "n", ")", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"hf_text\"", ")", ",", "\n", "hf_x", "=", "s", ".", "index", ",", "\n", "hf_y", "=", "s", ",", "\n", "hf_text", "=", "s", ".", "astype", "(", "str", ")", ",", "\n", "hf_hovertext", "=", "(", "-", "s", ")", ".", "astype", "(", "str", ")", ",", "\n", ")", "\n", "\n", "x", "=", "fig", ".", "data", "[", "i", "]", "[", "\"x\"", "]", "\n", "y", "=", "fig", ".", "data", "[", "i", "]", "[", "\"y\"", "]", "\n", "\n", "assert", "len", "(", "x", ")", "==", "1000", "\n", "assert", "len", "(", "y", ")", "==", "1000", "\n", "\n", "text", "=", "fig", ".", "data", "[", "i", "]", "[", "\"text\"", "]", ".", "astype", "(", "int", ")", "\n", "hovertext", "=", "fig", ".", "data", "[", "i", "]", "[", "\"hovertext\"", "]", ".", "astype", "(", "int", ")", "\n", "\n", "assert", "len", "(", "hovertext", ")", "==", "1000", "\n", "assert", "len", "(", "text", ")", "==", "1000", "\n", "\n", "# text === -hovertext -> so the sum should their length", "\n", "assert", "(", "text", "==", "-", "hovertext", ")", ".", "sum", "(", ")", "==", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_time_based_data_us": [[1421, 1457], ["plotly_resampler.FigureWidgetResampler", "range", "pandas.Series", "plotly_resampler.FigureWidgetResampler.add_trace", "[].astype", "[].astype", "plotly_resampler.EfficientLTTB", "plotly.Scatter", "len", "len", "len", "len", "pandas.date_range", "numpy.arange", "pd.Series.astype", "datetime.datetime.now", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "", "def", "test_fwr_time_based_data_us", "(", ")", ":", "\n", "    ", "n", "=", "100_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "\n", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ",", "default_downsampler", "=", "EfficientLTTB", "(", ")", "\n", ")", "\n", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "s", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\n", "datetime", ".", "now", "(", ")", ",", "freq", "=", "f\"{np.random.randint(5,100_000)}us\"", ",", "periods", "=", "n", "\n", ")", ",", "\n", "data", "=", "np", ".", "arange", "(", "n", ")", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"hf_text\"", ")", ",", "\n", "hf_x", "=", "s", ".", "index", ",", "\n", "hf_y", "=", "s", ",", "\n", "hf_text", "=", "s", ".", "astype", "(", "str", ")", ",", "\n", "hf_hovertext", "=", "(", "-", "s", ")", ".", "astype", "(", "str", ")", ",", "\n", ")", "\n", "\n", "x", "=", "fig", ".", "data", "[", "i", "]", "[", "\"x\"", "]", "\n", "y", "=", "fig", ".", "data", "[", "i", "]", "[", "\"y\"", "]", "\n", "\n", "assert", "len", "(", "x", ")", "==", "1000", "\n", "assert", "len", "(", "y", ")", "==", "1000", "\n", "\n", "text", "=", "fig", ".", "data", "[", "i", "]", "[", "\"text\"", "]", ".", "astype", "(", "int", ")", "\n", "hovertext", "=", "fig", ".", "data", "[", "i", "]", "[", "\"hovertext\"", "]", ".", "astype", "(", "int", ")", "\n", "\n", "assert", "len", "(", "hovertext", ")", "==", "1000", "\n", "assert", "len", "(", "text", ")", "==", "1000", "\n", "\n", "# text === -hovertext -> so the sum should their length", "\n", "assert", "(", "text", "==", "-", "hovertext", ")", ".", "sum", "(", ")", "==", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_time_based_data_ms": [[1459, 1495], ["plotly_resampler.FigureWidgetResampler", "range", "pandas.Series", "plotly_resampler.FigureWidgetResampler.add_trace", "[].astype", "[].astype", "plotly_resampler.EfficientLTTB", "plotly.Scatter", "len", "len", "len", "len", "pandas.date_range", "numpy.arange", "pd.Series.astype", "datetime.datetime.now", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "", "def", "test_fwr_time_based_data_ms", "(", ")", ":", "\n", "    ", "n", "=", "100_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "\n", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ",", "default_downsampler", "=", "EfficientLTTB", "(", ")", "\n", ")", "\n", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "s", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\n", "datetime", ".", "now", "(", ")", ",", "freq", "=", "f\"{np.random.randint(5,10_000)}ms\"", ",", "periods", "=", "n", "\n", ")", ",", "\n", "data", "=", "np", ".", "arange", "(", "n", ")", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"hf_text\"", ")", ",", "\n", "hf_x", "=", "s", ".", "index", ",", "\n", "hf_y", "=", "s", ",", "\n", "hf_text", "=", "s", ".", "astype", "(", "str", ")", ",", "\n", "hf_hovertext", "=", "(", "-", "s", ")", ".", "astype", "(", "str", ")", ",", "\n", ")", "\n", "\n", "x", "=", "fig", ".", "data", "[", "i", "]", "[", "\"x\"", "]", "\n", "y", "=", "fig", ".", "data", "[", "i", "]", "[", "\"y\"", "]", "\n", "\n", "assert", "len", "(", "x", ")", "==", "1000", "\n", "assert", "len", "(", "y", ")", "==", "1000", "\n", "\n", "text", "=", "fig", ".", "data", "[", "i", "]", "[", "\"text\"", "]", ".", "astype", "(", "int", ")", "\n", "hovertext", "=", "fig", ".", "data", "[", "i", "]", "[", "\"hovertext\"", "]", ".", "astype", "(", "int", ")", "\n", "\n", "assert", "len", "(", "hovertext", ")", "==", "1000", "\n", "assert", "len", "(", "text", ")", "==", "1000", "\n", "\n", "# text === -hovertext -> so the sum should their length", "\n", "assert", "(", "text", "==", "-", "hovertext", ")", ".", "sum", "(", ")", "==", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_time_based_data_s": [[1497, 1535], ["plotly_resampler.FigureWidgetResampler", "range", "pandas.Series", "plotly_resampler.FigureWidgetResampler.add_trace", "[].astype", "[].astype", "plotly_resampler.EfficientLTTB", "plotly.Scatter", "len", "len", "len", "len", "pandas.date_range", "numpy.arange", "pd.Series.astype", "datetime.datetime.now", "pandas.Timedelta", "round", "numpy.abs", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "", "def", "test_fwr_time_based_data_s", "(", ")", ":", "\n", "    ", "n", "=", "100_000", "\n", "fig", "=", "FigureWidgetResampler", "(", "\n", "default_n_shown_samples", "=", "1000", ",", "verbose", "=", "True", ",", "default_downsampler", "=", "EfficientLTTB", "(", ")", "\n", ")", "\n", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "s", "=", "pd", ".", "Series", "(", "\n", "index", "=", "pd", ".", "date_range", "(", "\n", "datetime", ".", "now", "(", ")", ",", "\n", "freq", "=", "pd", ".", "Timedelta", "(", "f\"{round(np.abs(np.random.randn()) * 1000, 4)}s\"", ")", ",", "\n", "periods", "=", "n", ",", "\n", ")", ",", "\n", "data", "=", "np", ".", "arange", "(", "n", ")", ",", "\n", ")", "\n", "\n", "fig", ".", "add_trace", "(", "\n", "go", ".", "Scatter", "(", "name", "=", "\"hf_text\"", ")", ",", "\n", "hf_x", "=", "s", ".", "index", ",", "\n", "hf_y", "=", "s", ",", "\n", "hf_text", "=", "s", ".", "astype", "(", "str", ")", ",", "\n", "hf_hovertext", "=", "(", "-", "s", ")", ".", "astype", "(", "str", ")", ",", "\n", ")", "\n", "\n", "x", "=", "fig", ".", "data", "[", "i", "]", "[", "\"x\"", "]", "\n", "y", "=", "fig", ".", "data", "[", "i", "]", "[", "\"y\"", "]", "\n", "\n", "assert", "len", "(", "x", ")", "==", "1000", "\n", "assert", "len", "(", "y", ")", "==", "1000", "\n", "\n", "text", "=", "fig", ".", "data", "[", "i", "]", "[", "\"text\"", "]", ".", "astype", "(", "int", ")", "\n", "hovertext", "=", "fig", ".", "data", "[", "i", "]", "[", "\"hovertext\"", "]", ".", "astype", "(", "int", ")", "\n", "\n", "assert", "len", "(", "hovertext", ")", "==", "1000", "\n", "assert", "len", "(", "text", ")", "==", "1000", "\n", "\n", "# text === -hovertext -> so the sum should their length", "\n", "assert", "(", "text", "==", "-", "hovertext", ")", ".", "sum", "(", ")", "==", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_from_dict": [[1537, 1555], ["numpy.array", "plotly_resampler.FigureWidgetResampler", "len", "len", "len"], "function", ["None"], ["", "", "def", "test_fwr_from_dict", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "array", "(", "[", "1", "]", "*", "10_000", ")", "\n", "base_fig", "=", "{", "\n", "\"type\"", ":", "\"scatter\"", ",", "\n", "\"y\"", ":", "y", ",", "\n", "}", "\n", "\n", "fr_fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "y", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "1", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "[", "1", "]", "*", "1_000", ")", ".", "all", "(", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "# this is a proxy for assuring that the dynamic aggregation should work", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_empty_list": [[1557, 1562], ["plotly_resampler.FigureWidgetResampler", "len", "len"], "function", ["None"], ["", "def", "test_fwr_empty_list", "(", ")", ":", "\n", "# and empty list -> so no concrete traces were added", "\n", "    ", "fr_fig", "=", "FigureWidgetResampler", "(", "[", "]", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "0", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_empty_dict": [[1564, 1569], ["plotly_resampler.FigureWidgetResampler", "len", "len"], "function", ["None"], ["", "def", "test_fwr_empty_dict", "(", ")", ":", "\n", "# a dict is a concrete trace so 1 trace should be added", "\n", "    ", "fr_fig", "=", "FigureWidgetResampler", "(", "{", "}", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "_hf_data", ")", "==", "0", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_wrong_keys": [[1571, 1577], ["pytest.raises", "plotly_resampler.FigureWidgetResampler"], "function", ["None"], ["", "def", "test_fwr_wrong_keys", "(", "float_series", ")", ":", "\n", "    ", "base_fig", "=", "[", "\n", "{", "\"ydata\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ",", "\n", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_from_list_dict": [[1579, 1603], ["plotly_resampler.FigureWidgetResampler", "base_fig.append", "plotly_resampler.FigureWidgetResampler", "len", "len", "len", "len", "len"], "function", ["None"], ["", "", "def", "test_fwr_from_list_dict", "(", "float_series", ")", ":", "\n", "    ", "base_fig", ":", "List", "[", "dict", "]", "=", "[", "\n", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ",", "\n", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ",", "\n", "]", "\n", "\n", "fr_fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "float_series", "+", "2", ")", ".", "all", "(", ")", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "==", "float_series", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "assert", "fr_fig", ".", "data", "[", "1", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n", "# redo the exercise with a new low-freq trace", "\n", "base_fig", ".", "append", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_no_agg\"", "}", ")", "\n", "fr_fig", "=", "FigureWidgetResampler", "(", "base_fig", ",", "default_n_shown_samples", "=", "1000", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_list_dict_add_trace": [[1605, 1650], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "plotly_resampler.FigureWidgetResampler.add_trace", "len", "len", "len", "len", "len", "len", "len", "pytest.raises", "plotly_resampler.FigureWidgetResampler.add_trace", "pytest.raises", "plotly_resampler.FigureWidgetResampler.add_trace", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fwr_list_dict_add_trace", "(", "float_series", ")", ":", "\n", "    ", "fr_fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "traces", ":", "List", "[", "dict", "]", "=", "[", "\n", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ",", "\n", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ",", "\n", "]", "\n", "for", "trace", "in", "traces", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "trace", ")", "\n", "\n", "# both traces are HF traces so should be aggregated", "\n", "", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "float_series", "+", "2", ")", ".", "all", "(", ")", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "==", "float_series", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "assert", "fr_fig", ".", "data", "[", "1", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n", "# redo the exercise with a new low-freq trace", "\n", "fr_fig", ".", "add_trace", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_no_agg\"", "}", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "3", "\n", "\n", "# add low-freq trace but set limit_to_view to True", "\n", "fr_fig", ".", "add_trace", "(", "{", "\"y\"", ":", "float_series", "[", ":", "100", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", ",", "limit_to_view", "=", "True", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "3", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "4", "\n", "\n", "# add a low-freq trace but adjust max_n_samples", "\n", "lf_series", "=", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", "\n", "# plotly its default behavior raises a ValueError when a list or tuple is passed", "\n", "# to add_trace", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "[", "lf_series", "]", ",", "max_n_samples", "=", "999", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "fr_fig", ".", "add_trace", "(", "(", "lf_series", ",", ")", ",", "max_n_samples", "=", "999", ")", "\n", "\n", "", "fr_fig", ".", "add_trace", "(", "lf_series", ",", "max_n_samples", "=", "999", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "4", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_list_dict_add_traces": [[1652, 1689], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_traces", "plotly_resampler.FigureWidgetResampler.add_traces", "plotly_resampler.FigureWidgetResampler.add_traces", "plotly_resampler.FigureWidgetResampler.add_traces", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces"], ["", "def", "test_fwr_list_dict_add_traces", "(", "float_series", ")", ":", "\n", "    ", "fr_fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "traces", ":", "List", "[", "dict", "]", "=", "[", "\n", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ",", "\n", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ",", "\n", "]", "\n", "fr_fig", ".", "add_traces", "(", "traces", ")", "\n", "# both traces are HF traces so should be aggregated", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "float_series", "+", "2", ")", ".", "all", "(", ")", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "==", "float_series", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "assert", "fr_fig", ".", "data", "[", "1", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n", "# redo the exercise with a new low-freq trace", "\n", "# plotly also allows a dict or a scatter object as input", "\n", "fr_fig", ".", "add_traces", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_no_agg\"", "}", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "3", "\n", "\n", "# add low-freq trace but set limit_to_view to True", "\n", "fr_fig", ".", "add_traces", "(", "[", "{", "\"y\"", ":", "float_series", "[", ":", "100", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", "]", ",", "limit_to_views", "=", "True", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "3", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "4", "\n", "\n", "# add a low-freq trace but adjust max_n_samples", "\n", "# note that we use tuple as input", "\n", "fr_fig", ".", "add_traces", "(", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", ",", ")", ",", "max_n_samples", "=", "999", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "4", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_list_scatter_add_traces": [[1691, 1729], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_traces", "plotly_resampler.FigureWidgetResampler.add_traces", "plotly_resampler.FigureWidgetResampler.add_traces", "plotly_resampler.FigureWidgetResampler.add_traces", "plotly.Scattergl", "plotly.Scatter", "tuple", "len", "len", "len", "len", "len", "plotly.Scattergl", "len", "len", "plotly.Scatter", "len", "len", "plotly.Scattergl"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces"], ["", "def", "test_fwr_list_scatter_add_traces", "(", "float_series", ")", ":", "\n", "    ", "fr_fig", "=", "FigureWidgetResampler", "(", "default_n_shown_samples", "=", "1000", ")", "\n", "\n", "traces", ":", "List", "[", "dict", "]", "=", "[", "\n", "go", ".", "Scattergl", "(", "{", "\"y\"", ":", "float_series", ".", "values", "+", "2", ",", "\"name\"", ":", "\"sp2\"", "}", ")", ",", "\n", "go", ".", "Scatter", "(", "{", "\"y\"", ":", "float_series", ".", "values", ",", "\"name\"", ":", "\"s\"", "}", ")", ",", "\n", "]", "\n", "fr_fig", ".", "add_traces", "(", "tuple", "(", "traces", ")", ")", "\n", "# both traces are HF traces so should be aggregated", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", "==", "float_series", "+", "2", ")", ".", "all", "(", ")", "\n", "assert", "(", "fr_fig", ".", "hf_data", "[", "1", "]", "[", "\"y\"", "]", "==", "float_series", ")", ".", "all", "(", ")", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", ")", "==", "1_000", "\n", "assert", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "0", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "assert", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "0", "]", ">=", "0", ")", "&", "(", "fr_fig", ".", "data", "[", "1", "]", "[", "\"x\"", "]", "[", "-", "1", "]", "<", "10_000", ")", "\n", "\n", "# assert that all the uuids of data and hf_data match", "\n", "assert", "fr_fig", ".", "data", "[", "0", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "assert", "fr_fig", ".", "data", "[", "1", "]", ".", "uid", "in", "fr_fig", ".", "_hf_data", "\n", "\n", "# redo the exercise with a new low-freq trace", "\n", "fr_fig", ".", "add_traces", "(", "[", "go", ".", "Scattergl", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_no_agg\"", "}", ")", "]", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "2", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "3", "\n", "\n", "# add low-freq trace but set limit_to_view to True", "\n", "# note how the scatter object is not encapsulated within a list", "\n", "fr_fig", ".", "add_traces", "(", "go", ".", "Scattergl", "(", ")", ",", "limit_to_views", "=", "True", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "3", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "4", "\n", "\n", "# add a low-freq trace but adjust max_n_samples", "\n", "fr_fig", ".", "add_traces", "(", "\n", "go", ".", "Scatter", "(", "{", "\"y\"", ":", "float_series", "[", ":", "1000", "]", ",", "\"name\"", ":", "\"s_agg\"", "}", ")", ",", "max_n_samples", "=", "999", "\n", ")", "\n", "assert", "len", "(", "fr_fig", ".", "hf_data", ")", "==", "4", "\n", "assert", "len", "(", "fr_fig", ".", "data", ")", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_add_scatter": [[1731, 1742], ["plotly.FigureWidget().add_scatter", "plotly_resampler.FigureWidgetResampler().add_scatter", "numpy.all", "len", "len", "len", "plotly.FigureWidget", "numpy.arange", "plotly_resampler.FigureWidgetResampler", "numpy.arange", "len", "len"], "function", ["None"], ["", "def", "test_fwr_add_scatter", "(", ")", ":", "\n", "# Checks whether the add_scatter method works as expected", "\n", "# .add_scatter calls `add_traces` under the hood", "\n", "    ", "fw_orig", "=", "go", ".", "FigureWidget", "(", ")", ".", "add_scatter", "(", "y", "=", "np", ".", "arange", "(", "2_000", ")", ")", "\n", "fw_pr", "=", "FigureWidgetResampler", "(", ")", ".", "add_scatter", "(", "y", "=", "np", ".", "arange", "(", "2_000", ")", ")", "\n", "\n", "assert", "len", "(", "fw_orig", ".", "data", ")", "==", "1", "\n", "assert", "(", "len", "(", "fw_pr", ".", "data", ")", "==", "1", ")", "&", "(", "len", "(", "fw_pr", ".", "hf_data", ")", "==", "1", ")", "\n", "assert", "len", "(", "fw_orig", ".", "data", "[", "0", "]", ".", "y", ")", "==", "2_000", "\n", "assert", "len", "(", "fw_pr", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ")", "==", "1_000", "\n", "assert", "np", ".", "all", "(", "fw_orig", ".", "data", "[", "0", "]", ".", "y", "==", "fw_pr", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_object_hf_data": [[1744, 1755], ["float_series.astype", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fwr_object_hf_data", "(", "\n", "float_series", ",", "\n", ")", ":", "\n", "    ", "float_series_o", "=", "float_series", ".", "astype", "(", "object", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "float_series_o", ")", "\n", "assert", "float_series_o", ".", "dtype", "==", "object", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"float64\"", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"float64\"", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_object_bool_data": [[1757, 1776], ["plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "bool_series.astype", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fwr_object_bool_data", "(", "bool_series", ")", ":", "\n", "# First try with the original non-object bool series", "\n", "    ", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "bool_series", ")", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"bool\"", "\n", "# plotly internally ocnverts this to object", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"object\"", "\n", "\n", "# Now try with the object bool series", "\n", "bool_series_o", "=", "bool_series", ".", "astype", "(", "object", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "bool_series_o", ")", "\n", "assert", "bool_series_o", ".", "dtype", "==", "object", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"bool\"", "\n", "# plotly internally ocnverts this to object", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"object\"", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_figurewidget_resampler.test_fwr_object_binary_data": [[1778, 1799], ["numpy.array", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "np.array.astype", "plotly_resampler.FigureWidgetResampler", "plotly_resampler.FigureWidgetResampler.add_trace", "numpy.all", "len", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace"], ["", "def", "test_fwr_object_binary_data", "(", ")", ":", "\n", "    ", "binary_series", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", "*", "20", ")", "# as this is << max_n_samples -> limit_to_view", "\n", "\n", "# First try with the original non-object binary series", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "binary_series", ",", "limit_to_view", "=", "True", ")", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"int64\"", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"int64\"", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "binary_series", ")", "\n", "\n", "# Now try with the object binary series", "\n", "binary_series_o", "=", "binary_series", ".", "astype", "(", "object", ")", "\n", "\n", "fig", "=", "FigureWidgetResampler", "(", ")", "\n", "fig", ".", "add_trace", "(", "{", "\"name\"", ":", "\"s0\"", "}", ",", "hf_y", "=", "binary_series_o", ",", "limit_to_view", "=", "True", ")", "\n", "assert", "binary_series_o", ".", "dtype", "==", "object", "\n", "assert", "len", "(", "fig", ".", "hf_data", ")", "==", "1", "\n", "assert", "fig", ".", "hf_data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"int64\"", "\n", "assert", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", ".", "dtype", "==", "\"int64\"", "\n", "assert", "np", ".", "all", "(", "fig", ".", "data", "[", "0", "]", "[", "\"y\"", "]", "==", "binary_series", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_every_nth_point_float_time_data": [[14, 26], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "len", "EveryNthPoint().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint", "EveryNthPoint().aggregate.notna", "EveryNthPoint().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["def", "test_every_nth_point_float_time_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "pd", ".", "date_range", "(", "\n", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "float_series", ")", ",", "freq", "=", "\"1ms\"", "\n", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_every_nth_point_float_sequence_data": [[28, 38], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "EveryNthPoint().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint", "EveryNthPoint().aggregate.notna", "EveryNthPoint().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_every_nth_point_float_sequence_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "float_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_every_nth_point_categorical_time_data": [[40, 50], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "len", "EveryNthPoint().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint", "EveryNthPoint().aggregate.notna", "EveryNthPoint().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_every_nth_point_categorical_time_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2023\"", ",", "periods", "=", "len", "(", "cat_series", ")", ",", "freq", "=", "\"10us\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_every_nth_point_categorical_sequence_data": [[52, 63], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "EveryNthPoint().aggregate.isna().any", "len", "len", "EveryNthPoint().aggregate.isna().any", "len", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint", "EveryNthPoint().aggregate.isna", "EveryNthPoint().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_every_nth_point_categorical_sequence_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "cat_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_every_nth_point_bool_time_data": [[65, 76], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "len", "EveryNthPoint().aggregate.isna().any", "len", "len", "EveryNthPoint().aggregate.isna().any", "len", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint", "EveryNthPoint().aggregate.isna", "EveryNthPoint().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_every_nth_point_bool_time_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "bool_series", ")", ",", "freq", "=", "\"1ms\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_every_nth_point_bool_sequence_data": [[78, 88], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "EveryNthPoint().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint", "EveryNthPoint().aggregate.notna", "EveryNthPoint().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_every_nth_point_bool_sequence_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "bool_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_every_nth_point_empty_series": [[90, 94], ["pandas.Series", "plotly_resampler.aggregation.EveryNthPoint().aggregate", "EveryNthPoint().aggregate.equals", "plotly_resampler.aggregation.EveryNthPoint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_every_nth_point_empty_series", "(", ")", ":", "\n", "    ", "empty_series", "=", "pd", ".", "Series", "(", "name", "=", "\"empty\"", ",", "dtype", "=", "'float32'", ")", "\n", "out", "=", "EveryNthPoint", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "empty_series", ",", "n_out", "=", "1_000", ")", "\n", "assert", "out", ".", "equals", "(", "empty_series", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_every_nth_point_nan_position": [[97, 128], ["float_series.copy", "fs.dropna.dropna", "len", "len", "len", "len", "plotly_resampler.aggregation.EveryNthPoint()._replace_gap_end_none().isna", "plotly_resampler.aggregation.EveryNthPoint()._replace_gap_end_none().isna", "plotly_resampler.aggregation.EveryNthPoint()._replace_gap_end_none().isna", "plotly_resampler.aggregation.EveryNthPoint()._replace_gap_end_none().isna", "plotly_resampler.aggregation.EveryNthPoint()._replace_gap_end_none", "plotly_resampler.aggregation.EveryNthPoint()._replace_gap_end_none", "plotly_resampler.aggregation.EveryNthPoint()._replace_gap_end_none", "plotly_resampler.aggregation.EveryNthPoint()._replace_gap_end_none", "fs.dropna.copy", "fs.dropna.copy", "fs.dropna.copy", "fs.dropna.copy", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint", "plotly_resampler.aggregation.EveryNthPoint"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._replace_gap_end_none", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._replace_gap_end_none", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._replace_gap_end_none", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator._replace_gap_end_none"], ["", "def", "test_every_nth_point_nan_position", "(", "float_series", ")", ":", "\n", "    ", "fs", "=", "float_series", ".", "copy", "(", ")", "\n", "fs", "[", "100", ":", "200", "]", "=", "None", "\n", "fs", "=", "fs", ".", "dropna", "(", ")", "\n", "\n", "# BEGIN", "\n", "nan_idx", "=", "fs", ".", "index", "[", "\n", "EveryNthPoint", "(", "nan_position", "=", "\"begin\"", ")", ".", "_replace_gap_end_none", "(", "fs", ".", "copy", "(", ")", ")", ".", "isna", "(", ")", "\n", "]", ".", "values", "\n", "assert", "len", "(", "nan_idx", ")", "==", "1", "\n", "assert", "nan_idx", "[", "0", "]", "==", "99", "\n", "\n", "# END", "\n", "nan_idx", "=", "fs", ".", "index", "[", "\n", "EveryNthPoint", "(", "nan_position", "=", "\"end\"", ")", ".", "_replace_gap_end_none", "(", "fs", ".", "copy", "(", ")", ")", ".", "isna", "(", ")", "\n", "]", ".", "values", "\n", "assert", "len", "(", "nan_idx", ")", "==", "1", "\n", "assert", "nan_idx", "[", "0", "]", "==", "200", "\n", "\n", "# BOTH", "\n", "nan_idx", "=", "fs", ".", "index", "[", "\n", "EveryNthPoint", "(", "nan_position", "=", "\"both\"", ")", ".", "_replace_gap_end_none", "(", "fs", ".", "copy", "(", ")", ")", ".", "isna", "(", ")", "\n", "]", ".", "values", "\n", "assert", "len", "(", "nan_idx", ")", "==", "2", "\n", "assert", "nan_idx", "[", "0", "]", "==", "99", "\n", "assert", "nan_idx", "[", "1", "]", "==", "200", "\n", "\n", "# DEFAULT argument -> end", "\n", "nan_idx", "=", "fs", ".", "index", "[", "EveryNthPoint", "(", ")", ".", "_replace_gap_end_none", "(", "fs", ".", "copy", "(", ")", ")", ".", "isna", "(", ")", "]", ".", "values", "\n", "assert", "len", "(", "nan_idx", ")", "==", "1", "\n", "assert", "nan_idx", "[", "0", "]", "==", "200", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mmo_float_time_data": [[131, 147], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "len", "MinMaxOverlapAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "MinMaxOverlapAggregator().aggregate.notna", "MinMaxOverlapAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "def", "test_mmo_float_time_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "pd", ".", "date_range", "(", "\n", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "float_series", ")", ",", "freq", "=", "\"1ms\"", "\n", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "\n", "float_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "\n", "float_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mmo_float_sequence_data": [[149, 163], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "MinMaxOverlapAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "MinMaxOverlapAggregator().aggregate.notna", "MinMaxOverlapAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mmo_float_sequence_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "float_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "\n", "float_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "\n", "float_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mmo_categorical_time_data": [[165, 179], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "len", "MinMaxOverlapAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "MinMaxOverlapAggregator().aggregate.notna", "MinMaxOverlapAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mmo_categorical_time_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2023\"", ",", "periods", "=", "len", "(", "cat_series", ")", ",", "freq", "=", "\"10us\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "\n", "cat_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "\n", "cat_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mmo_categorical_sequence_data": [[181, 196], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "MinMaxOverlapAggregator().aggregate.isna().any", "len", "len", "out[].isna().any", "len", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "MinMaxOverlapAggregator().aggregate.isna", "out[].isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mmo_categorical_sequence_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "cat_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "\n", "cat_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "30", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "\n", "cat_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", "[", "2", ":", "-", "2", "]", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mmo_bool_time_data": [[198, 213], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "len", "MinMaxOverlapAggregator().aggregate.isna().any", "len", "len", "out[].isna().any", "len", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "MinMaxOverlapAggregator().aggregate.isna", "out[].isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mmo_bool_time_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "bool_series", ")", ",", "freq", "=", "\"1ms\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "\n", "bool_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "\n", "bool_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", "[", "2", ":", "-", "2", "]", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mmo_bool_sequence_data": [[215, 230], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "MinMaxOverlapAggregator().aggregate.isna().any", "len", "len", "out[].isna().any", "sum", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "plotly_resampler.aggregation.MinMaxOverlapAggregator", "MinMaxOverlapAggregator().aggregate.notna", "MinMaxOverlapAggregator().aggregate.isna", "out[].isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mmo_bool_sequence_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "bool_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "200", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "\n", "bool_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "200", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "\n", "bool_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", "[", "2", ":", "-", "2", "]", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mmo_empty_series": [[232, 238], ["pandas.Series", "plotly_resampler.aggregation.MinMaxOverlapAggregator().aggregate", "MinMaxOverlapAggregator().aggregate.equals", "plotly_resampler.aggregation.MinMaxOverlapAggregator"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mmo_empty_series", "(", ")", ":", "\n", "    ", "empty_series", "=", "pd", ".", "Series", "(", "name", "=", "\"empty\"", ",", "dtype", "=", "'float32'", ")", "\n", "out", "=", "MinMaxOverlapAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "\n", "empty_series", ",", "n_out", "=", "1_000", "\n", ")", "\n", "assert", "out", ".", "equals", "(", "empty_series", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mm_float_time_data": [[241, 254], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "len", "MinMaxAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.MinMaxAggregator", "plotly_resampler.aggregation.MinMaxAggregator", "MinMaxAggregator().aggregate.notna", "MinMaxAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "def", "test_mm_float_time_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "pd", ".", "date_range", "(", "\n", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "float_series", ")", ",", "freq", "=", "\"1ms\"", "\n", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "# assert not out[2:-2].isna().any()", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mm_float_sequence_data": [[256, 266], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "len", "len", "sum", "plotly_resampler.aggregation.MinMaxAggregator", "plotly_resampler.aggregation.MinMaxAggregator", "MinMaxAggregator().aggregate.notna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mm_float_sequence_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "float_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "# assert not out.isna().any()", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mm_categorical_time_data": [[268, 278], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "len", "MinMaxAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.MinMaxAggregator", "plotly_resampler.aggregation.MinMaxAggregator", "MinMaxAggregator().aggregate.notna", "MinMaxAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mm_categorical_time_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2023\"", ",", "periods", "=", "len", "(", "cat_series", ")", ",", "freq", "=", "\"10us\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mm_categorical_sequence_data": [[280, 291], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "MinMaxAggregator().aggregate.isna().any", "len", "len", "len", "plotly_resampler.aggregation.MinMaxAggregator", "plotly_resampler.aggregation.MinMaxAggregator", "MinMaxAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mm_categorical_sequence_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "cat_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "5", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "# assert not out[2:-2].isna().any()", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mm_bool_time_data": [[293, 304], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "len", "MinMaxAggregator().aggregate.isna().any", "len", "len", "out[].isna().any", "len", "plotly_resampler.aggregation.MinMaxAggregator", "plotly_resampler.aggregation.MinMaxAggregator", "MinMaxAggregator().aggregate.isna", "out[].isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mm_bool_time_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "bool_series", ")", ",", "freq", "=", "\"1ms\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "200", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "200", ",", "len", "(", "bool_series", ")", "/", "5", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", "[", "2", ":", "-", "2", "]", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_mm_bool_sequence_data": [[306, 316], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "plotly_resampler.aggregation.MinMaxAggregator().aggregate", "MinMaxAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.MinMaxAggregator", "plotly_resampler.aggregation.MinMaxAggregator", "MinMaxAggregator().aggregate.notna", "MinMaxAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_mm_bool_sequence_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "bool_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "200", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "200", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "MinMaxAggregator", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_lttb_float_time_data": [[319, 331], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.LTTB().aggregate", "plotly_resampler.aggregation.LTTB().aggregate", "len", "LTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.LTTB", "plotly_resampler.aggregation.LTTB", "LTTB().aggregate.notna", "LTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_lttb_float_time_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "pd", ".", "date_range", "(", "\n", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "float_series", ")", ",", "freq", "=", "\"1ms\"", "\n", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_lttb_float_sequence_data": [[333, 343], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.LTTB().aggregate", "plotly_resampler.aggregation.LTTB().aggregate", "LTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.LTTB", "plotly_resampler.aggregation.LTTB", "LTTB().aggregate.notna", "LTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_lttb_float_sequence_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "float_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_lttb_categorical_time_data": [[345, 357], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.LTTB().aggregate", "plotly_resampler.aggregation.LTTB().aggregate", "len", "LTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.LTTB", "plotly_resampler.aggregation.LTTB", "LTTB().aggregate.notna", "LTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_lttb_categorical_time_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/5/2022\"", ",", "periods", "=", "len", "(", "cat_series", ")", ",", "freq", "=", "\"10s\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "# LTTB uses the first and last value by default -> so it might add a none", "\n", "# between these two positions when not a lot of samples are chosen", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_lttb_categorical_sequence_data": [[359, 373], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.LTTB().aggregate", "plotly_resampler.aggregation.LTTB().aggregate", "LTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.LTTB", "plotly_resampler.aggregation.LTTB", "LTTB().aggregate.notna", "LTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_lttb_categorical_sequence_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "cat_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "# LTTB uses the first and last value by default -> so it might add a none", "\n", "# between these two positions when not a lot of samples are chosen", "\n", "# Since we changed the insert NAN to the replace NAN position -> the notna", "\n", "# sum must be <= `n`", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_lttb_bool_time_data": [[375, 385], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.LTTB().aggregate", "plotly_resampler.aggregation.LTTB().aggregate", "len", "LTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.LTTB", "plotly_resampler.aggregation.LTTB", "LTTB().aggregate.notna", "LTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_lttb_bool_time_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "bool_series", ")", ",", "freq", "=", "\"1s\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_lttb_bool_sequence_data": [[387, 397], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.LTTB().aggregate", "plotly_resampler.aggregation.LTTB().aggregate", "LTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.LTTB", "plotly_resampler.aggregation.LTTB", "LTTB().aggregate.notna", "LTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_lttb_bool_sequence_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "bool_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "LTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_lttb_invalid_input_data": [[399, 412], ["pandas.Series", "pandas.date_range", "pandas.Series", "pytest.raises", "plotly_resampler.aggregation.LTTB().aggregate", "pytest.raises", "plotly_resampler.aggregation.LTTB().aggregate", "plotly_resampler.aggregation.LTTB", "plotly_resampler.aggregation.LTTB", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_lttb_invalid_input_data", "(", ")", ":", "\n", "# string data", "\n", "    ", "nb_samples", "=", "10_000", "\n", "string_arr", "=", "[", "\"a\"", ",", "\"bdc\"", ",", "\"ef\"", ",", "\"gh\"", ",", "\"ijklkm\"", ",", "\"nopq\"", "]", "\n", "s", "=", "pd", ".", "Series", "(", "data", "=", "string_arr", "*", "(", "nb_samples", "//", "len", "(", "string_arr", ")", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "LTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "s", ",", "n_out", "=", "100", ")", "\n", "\n", "# time data", "\n", "", "time_arr", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "nb_samples", ",", "freq", "=", "\"1s\"", ")", "\n", "s", "=", "pd", ".", "Series", "(", "data", "=", "time_arr", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "LTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "s", ",", "n_out", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_efficient_lttb_float_time_data": [[418, 430], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "len", "EfficientLTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EfficientLTTB", "plotly_resampler.aggregation.EfficientLTTB", "EfficientLTTB().aggregate.notna", "EfficientLTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_efficient_lttb_float_time_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "pd", ".", "date_range", "(", "\n", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "float_series", ")", ",", "freq", "=", "\"1ms\"", "\n", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_efficient_lttb_float_sequence_data": [[432, 442], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "EfficientLTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EfficientLTTB", "plotly_resampler.aggregation.EfficientLTTB", "EfficientLTTB().aggregate.notna", "EfficientLTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_efficient_lttb_float_sequence_data", "(", "float_series", ")", ":", "\n", "    ", "float_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "float_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "float_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_efficient_lttb_categorical_time_data": [[444, 456], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "len", "EfficientLTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EfficientLTTB", "plotly_resampler.aggregation.EfficientLTTB", "EfficientLTTB().aggregate.notna", "EfficientLTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_efficient_lttb_categorical_time_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/5/2022\"", ",", "periods", "=", "len", "(", "cat_series", ")", ",", "freq", "=", "\"10s\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "# EfficientLTTB uses the first and last value by default -> so it might add a none", "\n", "# between these two positions when not a lot of samples are chosen", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_efficient_lttb_categorical_sequence_data": [[458, 472], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "EfficientLTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EfficientLTTB", "plotly_resampler.aggregation.EfficientLTTB", "EfficientLTTB().aggregate.notna", "EfficientLTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_efficient_lttb_categorical_sequence_data", "(", "cat_series", ")", ":", "\n", "    ", "cat_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "cat_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "# EfficientLTTB uses the first and last value by default -> so it might add a none", "\n", "# between these two positions when not a lot of samples are chosen", "\n", "# Since we changed the insert NAN to the replace NAN position -> the notna", "\n", "# sum must be <= `n`", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_efficient_lttb_bool_time_data": [[474, 484], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "len", "EfficientLTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EfficientLTTB", "plotly_resampler.aggregation.EfficientLTTB", "EfficientLTTB().aggregate.notna", "EfficientLTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_efficient_lttb_bool_time_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "bool_series", ")", ",", "freq", "=", "\"1s\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_efficient_lttb_bool_sequence_data": [[486, 496], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "EfficientLTTB().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.EfficientLTTB", "plotly_resampler.aggregation.EfficientLTTB", "EfficientLTTB().aggregate.notna", "EfficientLTTB().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_efficient_lttb_bool_sequence_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "bool_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "==", "n", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "EfficientLTTB", "(", "interleave_gaps", "=", "True", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_efficient_lttb_invalid_input_data": [[498, 511], ["pandas.Series", "pandas.date_range", "pandas.Series", "pytest.raises", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "pytest.raises", "plotly_resampler.aggregation.EfficientLTTB().aggregate", "plotly_resampler.aggregation.EfficientLTTB", "plotly_resampler.aggregation.EfficientLTTB", "len"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_efficient_lttb_invalid_input_data", "(", ")", ":", "\n", "# string data", "\n", "    ", "nb_samples", "=", "10_000", "\n", "string_arr", "=", "[", "\"a\"", ",", "\"bdc\"", ",", "\"ef\"", ",", "\"gh\"", ",", "\"ijklkm\"", ",", "\"nopq\"", "]", "\n", "s", "=", "pd", ".", "Series", "(", "data", "=", "string_arr", "*", "(", "nb_samples", "//", "len", "(", "string_arr", ")", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "EfficientLTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "s", ",", "n_out", "=", "100", ")", "\n", "\n", "# time data", "\n", "", "time_arr", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "nb_samples", ",", "freq", "=", "\"1s\"", ")", "\n", "s", "=", "pd", ".", "Series", "(", "data", "=", "time_arr", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "EfficientLTTB", "(", "interleave_gaps", "=", "False", ")", ".", "aggregate", "(", "s", ",", "n_out", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_func_aggregator_float_time_data": [[516, 531], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.FuncAggregator().aggregate", "plotly_resampler.aggregation.FuncAggregator().aggregate", "len", "FuncAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.FuncAggregator", "plotly_resampler.aggregation.FuncAggregator", "FuncAggregator().aggregate.notna", "FuncAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_func_aggregator_float_time_data", "(", "float_series", ")", ":", "\n", "# TIME indexed data -> resampled output should be same size as n_out", "\n", "    ", "float_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "float_series", ")", ",", "freq", "=", "\"1s\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "interleave_gaps", "=", "False", ",", "aggregation_func", "=", "sum", ")", ".", "aggregate", "(", "\n", "float_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "interleave_gaps", "=", "True", ",", "aggregation_func", "=", "np", ".", "mean", ")", ".", "aggregate", "(", "\n", "float_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_func_aggregator_float_sequence_data": [[533, 548], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.FuncAggregator().aggregate", "plotly_resampler.aggregation.FuncAggregator().aggregate", "FuncAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.FuncAggregator", "plotly_resampler.aggregation.FuncAggregator", "FuncAggregator().aggregate.notna", "FuncAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_func_aggregator_float_sequence_data", "(", "float_series", ")", ":", "\n", "# No time-index => we use every nth heuristic", "\n", "    ", "float_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "float_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "interleave_gaps", "=", "False", ",", "aggregation_func", "=", "sum", ")", ".", "aggregate", "(", "\n", "float_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "float_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "interleave_gaps", "=", "True", ",", "aggregation_func", "=", "np", ".", "mean", ")", ".", "aggregate", "(", "\n", "float_series", ",", "n_out", "=", "n", "\n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_func_aggregator_categorical_time_data": [[550, 569], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.FuncAggregator().aggregate", "plotly_resampler.aggregation.FuncAggregator().aggregate", "len", "numpy.unique", "FuncAggregator().aggregate.isna().any", "len", "len", "sum", "plotly_resampler.aggregation.FuncAggregator", "plotly_resampler.aggregation.FuncAggregator", "FuncAggregator().aggregate.notna", "FuncAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_func_aggregator_categorical_time_data", "(", "cat_series", ")", ":", "\n", "# TIME indexed data -> resampled output should be same size as n_out", "\n", "    ", "cat_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "cat_series", ")", ",", "freq", "=", "\"1s\"", ")", "\n", "\n", "def", "cat_count", "(", "x", ")", ":", "\n", "        ", "return", "len", "(", "np", ".", "unique", "(", "x", ")", ")", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "False", ",", "aggregation_func", "=", "cat_count", "\n", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "True", ",", "aggregation_func", "=", "cat_count", "\n", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_func_aggregator_categorical_sequence_data": [[571, 591], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "len", "plotly_resampler.aggregation.FuncAggregator().aggregate", "plotly_resampler.aggregation.FuncAggregator().aggregate", "FuncAggregator().aggregate.isna().any", "len", "len", "sum", "len", "plotly_resampler.aggregation.FuncAggregator", "plotly_resampler.aggregation.FuncAggregator", "FuncAggregator().aggregate.notna", "x.value_counts", "FuncAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_func_aggregator_categorical_sequence_data", "(", "cat_series", ")", ":", "\n", "# TIME indexed data -> resampled output should be same size as n_out", "\n", "    ", "cat_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "cat_series", ")", ",", "dtype", "=", "\"uint32\"", ")", "\n", "cat_series", "=", "cat_series", "[", ":", "len", "(", "cat_series", ")", "//", "4", "]", "\n", "# note this method takes a long time - so we only test a small number of samples", "\n", "def", "most_common", "(", "x", ")", ":", "\n", "        ", "return", "x", ".", "value_counts", "(", ")", ".", "index", ".", "values", "[", "0", "]", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "False", ",", "aggregation_func", "=", "most_common", "\n", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "True", ",", "aggregation_func", "=", "most_common", "\n", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_func_aggregator_bool_time_data": [[593, 611], ["pandas.date_range", "numpy.random.randint", "numpy.random.randint", "plotly_resampler.aggregation.FuncAggregator().aggregate", "plotly_resampler.aggregation.FuncAggregator().aggregate", "len", "len", "FuncAggregator().aggregate.isna().any", "len", "len", "sum", "sum", "len", "plotly_resampler.aggregation.FuncAggregator", "plotly_resampler.aggregation.FuncAggregator", "FuncAggregator().aggregate.notna", "FuncAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_func_aggregator_bool_time_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "pd", ".", "date_range", "(", "\"1/1/2020\"", ",", "periods", "=", "len", "(", "bool_series", ")", ",", "freq", "=", "\"1s\"", ")", "\n", "\n", "def", "most_common", "(", "x", ")", ":", "\n", "        ", "return", "sum", "(", "x", ")", "/", "len", "(", "x", ")", ">=", "0.5", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "2", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "False", ",", "aggregation_func", "=", "most_common", "\n", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "True", ",", "aggregation_func", "=", "most_common", "\n", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_func_aggregator_bool_sequence_data": [[613, 631], ["numpy.arange", "numpy.random.randint", "numpy.random.randint", "len", "plotly_resampler.aggregation.FuncAggregator().aggregate", "plotly_resampler.aggregation.FuncAggregator().aggregate", "len", "FuncAggregator().aggregate.isna().any", "len", "len", "sum", "sum", "len", "plotly_resampler.aggregation.FuncAggregator", "plotly_resampler.aggregation.FuncAggregator", "FuncAggregator().aggregate.notna", "FuncAggregator().aggregate.isna"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate", "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_func_aggregator_bool_sequence_data", "(", "bool_series", ")", ":", "\n", "    ", "bool_series", ".", "index", "=", "np", ".", "arange", "(", "len", "(", "bool_series", ")", ",", "step", "=", "1", ",", "dtype", "=", "\"uint32\"", ")", "\n", "\n", "def", "most_common", "(", "x", ")", ":", "\n", "        ", "return", "sum", "(", "x", ")", "/", "len", "(", "x", ")", ">=", "0.5", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "2", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "False", ",", "aggregation_func", "=", "most_common", "\n", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "not", "out", ".", "isna", "(", ")", ".", "any", "(", ")", "\n", "assert", "len", "(", "out", ")", "<=", "n", "+", "1", "\n", "\n", "", "for", "n", "in", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "bool_series", ")", "/", "3", ",", "3", ")", ":", "\n", "        ", "out", "=", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "True", ",", "aggregation_func", "=", "most_common", "\n", ")", ".", "aggregate", "(", "bool_series", ",", "n_out", "=", "n", ")", "\n", "assert", "sum", "(", "out", ".", "notna", "(", ")", ")", "<=", "n", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.tests.test_aggregators.test_func_aggregator_invalid_input_data": [[633, 643], ["numpy.random.randint", "numpy.sum", "pytest.raises", "plotly_resampler.aggregation.FuncAggregator().aggregate", "len", "plotly_resampler.aggregation.FuncAggregator"], "function", ["home.repos.pwc.inspect_result.predict-idlab_plotly-resampler.aggregation.aggregation_interface.AbstractSeriesAggregator.aggregate"], ["", "", "def", "test_func_aggregator_invalid_input_data", "(", "cat_series", ")", ":", "\n", "# note: it is the user's responsibility to ensure that the input data is valid", "\n", "    ", "def", "treat_string_as_numeric_data", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "sum", "(", "x", ")", "\n", "\n", "", "n", "=", "np", ".", "random", ".", "randint", "(", "100", ",", "len", "(", "cat_series", ")", "/", "3", ")", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "        ", "FuncAggregator", "(", "\n", "interleave_gaps", "=", "True", ",", "aggregation_func", "=", "treat_string_as_numeric_data", "\n", ")", ".", "aggregate", "(", "cat_series", ",", "n_out", "=", "n", ")", "\n", "", "", ""]]}