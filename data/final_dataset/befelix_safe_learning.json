{"home.repos.pwc.inspect_result.befelix_safe_learning.None.setup.PyTest.initialize_options": [[9, 12], ["setuptools.command.test.test.initialize_options"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.None.setup.PyTest.initialize_options"], ["def", "initialize_options", "(", "self", ")", ":", "\n", "        ", "TestCommand", ".", "initialize_options", "(", "self", ")", "\n", "self", ".", "pytest_args", "=", "''", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.None.setup.PyTest.run_tests": [[13, 19], ["pytest.main", "sys.exit", "shlex.split"], "methods", ["None"], ["", "def", "run_tests", "(", "self", ")", ":", "\n", "        ", "import", "shlex", "\n", "#import here, cause outside the eggs aren't loaded", "\n", "import", "pytest", "\n", "errno", "=", "pytest", ".", "main", "(", "shlex", ".", "split", "(", "self", ".", "pytest_args", ")", ")", "\n", "sys", ".", "exit", "(", "errno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.__init__": [[46, 64], ["object.__init__", "tensorflow.stack", "utilities.get_feed_dict", "tensorflow.get_default_graph"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict"], ["def", "__init__", "(", "self", ",", "policy", ",", "dynamics", ",", "reward_function", ",", "value_function", ",", "\n", "gamma", "=", "0.98", ")", ":", "\n", "        ", "\"\"\"Initialization.\n\n        See `PolicyIteration` for details.\n        \"\"\"", "\n", "super", "(", "PolicyIteration", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dynamics", "=", "dynamics", "\n", "self", ".", "reward_function", "=", "reward_function", "\n", "self", ".", "value_function", "=", "value_function", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n", "state_space", "=", "self", ".", "value_function", ".", "discretization", ".", "all_points", "\n", "self", ".", "state_space", "=", "tf", ".", "stack", "(", "state_space", ",", "name", "=", "'state_space'", ")", "\n", "\n", "self", ".", "policy", "=", "policy", "\n", "self", ".", "feed_dict", "=", "get_feed_dict", "(", "tf", ".", "get_default_graph", "(", ")", ")", "\n", "self", ".", "_storage", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.future_values": [[65, 115], ["utilities.with_scope", "reinforcement_learning.PolicyIteration.dynamics", "reinforcement_learning.PolicyIteration.reward_function", "isinstance", "reinforcement_learning.PolicyIteration.value_function", "policy", "lyapunov.v_decrease_bound", "lyapunov.threshold"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.v_decrease_bound", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.threshold"], ["", "@", "with_scope", "(", "'future_values'", ")", "\n", "def", "future_values", "(", "self", ",", "states", ",", "policy", "=", "None", ",", "actions", "=", "None", ",", "lyapunov", "=", "None", ",", "\n", "lagrange_multiplier", "=", "1.", ")", ":", "\n", "        ", "\"\"\"Return the value at the current states.\n\n        Parameters\n        ----------\n        states : ndarray\n            The states at which to compute future values.\n        policy : callable, optional\n            The policy for which to evaluate. Defaults to `self.policy`. This\n            argument is ignored if actions is not None.\n        actions : array or tensor, optional\n            The actions to be taken for the states.\n        lyapunov : instance of `Lyapunov`\n            A Lyapunov function that acts as a constraint for the optimization.\n        lagrange_multiplier: float\n            A scaling factor for the `slack` of the optimization problem.\n\n        Returns\n        -------\n        The expected long term reward when taking an action according to the\n        policy and then taking the value of self.value_function.\n        \"\"\"", "\n", "if", "actions", "is", "None", ":", "\n", "            ", "if", "policy", "is", "None", ":", "\n", "                ", "policy", "=", "self", ".", "policy", "\n", "", "actions", "=", "policy", "(", "states", ")", "\n", "\n", "", "next_states", "=", "self", ".", "dynamics", "(", "states", ",", "actions", ")", "\n", "rewards", "=", "self", ".", "reward_function", "(", "states", ",", "actions", ")", "\n", "\n", "# Only use the mean dynamics", "\n", "if", "isinstance", "(", "next_states", ",", "tuple", ")", ":", "\n", "            ", "next_states", ",", "var", "=", "next_states", "\n", "\n", "", "expected_values", "=", "self", ".", "value_function", "(", "next_states", ")", "\n", "\n", "# Perform value update", "\n", "updated_values", "=", "rewards", "+", "self", ".", "gamma", "*", "expected_values", "\n", "\n", "# Adjust the cost for the Lyapunov decrease", "\n", "if", "lyapunov", "is", "not", "None", ":", "\n", "            ", "decrease", "=", "lyapunov", ".", "v_decrease_bound", "(", "states", ",", "(", "next_states", ",", "var", ")", ")", "\n", "\n", "# Want to enfore `constraint <= 0`", "\n", "constraint", "=", "decrease", "-", "lyapunov", ".", "threshold", "(", "states", ")", "\n", "updated_values", "-=", "lagrange_multiplier", "*", "constraint", "\n", "\n", "", "return", "updated_values", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.bellmann_error": [[116, 134], ["utilities.with_scope", "tensorflow.stop_gradient", "tensorflow.reduce_sum", "reinforcement_learning.PolicyIteration.future_values", "tensorflow.square", "reinforcement_learning.PolicyIteration.value_function"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.future_values"], ["", "@", "with_scope", "(", "'bellmann_error'", ")", "\n", "def", "bellmann_error", "(", "self", ",", "states", ")", ":", "\n", "        ", "\"\"\"Compute the squared bellmann error.\n\n        Parameters\n        ----------\n        states : array\n\n        Returns\n        -------\n        error : float\n        \"\"\"", "\n", "# Make sure we do not compute the gradient with respect to the", "\n", "# training target.", "\n", "target", "=", "tf", ".", "stop_gradient", "(", "self", ".", "future_values", "(", "states", ")", ")", "\n", "# Squared bellmann error", "\n", "return", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "target", "-", "self", ".", "value_function", "(", "states", ")", ")", ",", "\n", "name", "=", "'bellmann_error'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.value_iteration": [[135, 141], ["utilities.with_scope", "reinforcement_learning.PolicyIteration.future_values", "tensorflow.assign"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.future_values"], ["", "@", "with_scope", "(", "'value_iteration'", ")", "\n", "def", "value_iteration", "(", "self", ")", ":", "\n", "        ", "\"\"\"Perform one step of value iteration.\"\"\"", "\n", "future_values", "=", "self", ".", "future_values", "(", "self", ".", "state_space", ")", "\n", "return", "tf", ".", "assign", "(", "self", ".", "value_function", ".", "parameters", "[", "0", "]", ",", "future_values", ",", "\n", "name", "=", "'value_iteration_update'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration._run_cvx_optimization": [[142, 179], ["utilities.make_tf_fun", "cvxpy.Variable", "reinforcement_learning.PolicyIteration.value_function.tri.parameter_derivative", "cvxpy.Constant", "cvxpy.Maximize", "cvxpy.Problem", "cvxpy.Problem.solve", "numpy.array", "cvxpy.sum", "reinforcement_learning.OptimizationError"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.make_tf_fun", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.parameter_derivative"], ["", "@", "make_tf_fun", "(", "tf", ".", "float64", ")", "\n", "def", "_run_cvx_optimization", "(", "self", ",", "next_states", ",", "rewards", ",", "**", "solver_options", ")", ":", "\n", "        ", "\"\"\"Tensorflow wrapper around a cvxpy value function optimization.\n\n        Parameters\n        ----------\n        next_states : ndarray\n        rewards : ndarray\n\n        Returns\n        -------\n        values : ndarray\n            The optimal values at the states.\n        \"\"\"", "\n", "# Define random variables; convert index from np.int64 to regular", "\n", "# python int to avoid strange cvxpy error; see:", "\n", "# https://github.com/cvxgrp/cvxpy/issues/380", "\n", "values", "=", "cvxpy", ".", "Variable", "(", "rewards", ".", "shape", ")", "\n", "\n", "value_matrix", "=", "self", ".", "value_function", ".", "tri", ".", "parameter_derivative", "(", "\n", "next_states", ")", "\n", "# Make cvxpy work with sparse matrices", "\n", "value_matrix", "=", "cvxpy", ".", "Constant", "(", "value_matrix", ")", "\n", "\n", "objective", "=", "cvxpy", ".", "Maximize", "(", "cvxpy", ".", "sum", "(", "values", ")", ")", "\n", "constraints", "=", "[", "values", "<=", "rewards", "+", "self", ".", "gamma", "*", "value_matrix", "*", "values", "]", "\n", "prob", "=", "cvxpy", ".", "Problem", "(", "objective", ",", "constraints", ")", "\n", "\n", "# Solve optimization problem", "\n", "prob", ".", "solve", "(", "**", "solver_options", ")", "\n", "\n", "# Some error checking", "\n", "if", "not", "prob", ".", "status", "==", "cvxpy", ".", "OPTIMAL", ":", "\n", "            ", "raise", "OptimizationError", "(", "'Optimization problem is {}'", "\n", ".", "format", "(", "prob", ".", "status", ")", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "values", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.optimize_value_function": [[180, 212], ["utilities.with_scope", "reinforcement_learning.PolicyIteration.policy", "reinforcement_learning.PolicyIteration.dynamics", "isinstance", "reinforcement_learning.PolicyIteration.reward_function", "reinforcement_learning.PolicyIteration._run_cvx_optimization", "tensorflow.assign", "isinstance"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration._run_cvx_optimization"], ["", "@", "with_scope", "(", "'optimize_value_function'", ")", "\n", "def", "optimize_value_function", "(", "self", ",", "**", "solver_options", ")", ":", "\n", "        ", "\"\"\"Optimize the value function using cvx.\n\n        Parameters\n        ----------\n        solver_options : kwargs, optional\n            Additional solver options passes to cvxpy.Problem.solve.\n\n        Returns\n        -------\n        assign_op : tf.Tensor\n            An assign operation that updates the value function.\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "cvxpy", ",", "ModuleType", ")", ":", "\n", "            ", "raise", "cvxpy", "\n", "\n", "", "actions", "=", "self", ".", "policy", "(", "self", ".", "state_space", ")", "\n", "next_states", "=", "self", ".", "dynamics", "(", "self", ".", "state_space", ",", "actions", ")", "\n", "\n", "# Only use the mean dynamics", "\n", "if", "isinstance", "(", "next_states", ",", "tuple", ")", ":", "\n", "            ", "next_states", ",", "var", "=", "next_states", "\n", "\n", "", "rewards", "=", "self", ".", "reward_function", "(", "self", ".", "state_space", ",", "\n", "actions", ")", "\n", "\n", "values", "=", "self", ".", "_run_cvx_optimization", "(", "next_states", ",", "\n", "rewards", ",", "\n", "**", "solver_options", ")", "\n", "\n", "return", "tf", ".", "assign", "(", "self", ".", "value_function", ".", "parameters", "[", "0", "]", ",", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.discrete_policy_optimization": [[213, 280], ["utilities.with_scope", "numpy.empty", "numpy.broadcast_to", "utilities.get_storage", "enumerate", "tensorflow.assign.eval", "numpy.zeros", "tensorflow.placeholder", "reinforcement_learning.PolicyIteration.future_values", "tensorflow.placeholder", "tensorflow.assign", "utilities.set_storage", "utilities.get_storage.values", "reinforcement_learning.PolicyIteration.eval", "numpy.argmax", "constraint"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.future_values", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.set_storage"], ["", "@", "with_scope", "(", "'discrete_policy_optimization'", ")", "\n", "def", "discrete_policy_optimization", "(", "self", ",", "action_space", ",", "constraint", "=", "None", ")", ":", "\n", "        ", "\"\"\"Optimize the policy for a given value function.\n\n        Parameters\n        ----------\n        action_space : ndarray\n            The parameter value to evaluate (for each parameter). This is\n            geared towards piecewise linear functions.\n        constraint : callable\n            A function that can be called with a policy. Returns the slack of\n            the safety constraint for each state. A policy is safe if the slack\n            is >=0 for all constraints.\n        \"\"\"", "\n", "states", "=", "self", ".", "policy", ".", "discretization", ".", "all_points", "\n", "n_states", "=", "states", ".", "shape", "[", "0", "]", "\n", "n_options", ",", "n_actions", "=", "action_space", ".", "shape", "\n", "\n", "# Initialize", "\n", "values", "=", "np", ".", "empty", "(", "(", "n_states", ",", "n_options", ")", ",", "dtype", "=", "config", ".", "np_dtype", ")", "\n", "action_array", "=", "np", ".", "broadcast_to", "(", "np", ".", "zeros", "(", "n_actions", ",", "\n", "dtype", "=", "config", ".", "np_dtype", ")", ",", "\n", "(", "n_states", ",", "n_actions", ")", ")", "\n", "\n", "# Create tensorflow operations, but reuse previous graph elements", "\n", "storage", "=", "get_storage", "(", "self", ".", "_storage", ")", "\n", "\n", "if", "storage", "is", "None", ":", "\n", "# Computation of future values", "\n", "            ", "actions", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "\n", "shape", "=", "action_array", ".", "shape", ",", "\n", "name", "=", "'actions'", ")", "\n", "future_values", "=", "self", ".", "future_values", "(", "states", ",", "\n", "actions", "=", "actions", ")", "\n", "\n", "# Assigning new parameters", "\n", "parameters", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "action_array", ".", "shape", ")", "\n", "assign_op", "=", "tf", ".", "assign", "(", "self", ".", "policy", ".", "parameters", "[", "0", "]", ",", "parameters", ")", "\n", "\n", "# Put things into storage", "\n", "storage", "=", "[", "(", "'actions'", ",", "actions", ")", ",", "\n", "(", "'future_values'", ",", "future_values", ")", ",", "\n", "(", "'parameters'", ",", "parameters", ")", ",", "\n", "(", "'assign_op'", ",", "assign_op", ")", "]", "\n", "set_storage", "(", "self", ".", "_storage", ",", "storage", ")", "\n", "", "else", ":", "\n", "# Get items out of storage", "\n", "            ", "actions", ",", "future_values", ",", "parameters", ",", "assign_op", "=", "storage", ".", "values", "(", ")", "\n", "\n", "", "feed_dict", "=", "self", ".", "feed_dict", "\n", "feed_dict", "[", "actions", "]", "=", "action_array", "\n", "\n", "# Compute values for each action", "\n", "for", "i", ",", "action", "in", "enumerate", "(", "action_space", ")", ":", "\n", "# Update feed dict", "\n", "            ", "action_array", ".", "base", "[", ":", "]", "=", "action", "\n", "# Compute values", "\n", "values", "[", ":", ",", "i", "]", "=", "future_values", ".", "eval", "(", "feed_dict", "=", "feed_dict", ")", "[", ":", ",", "0", "]", "\n", "\n", "if", "constraint", "is", "not", "None", ":", "\n", "# TODO: optimize safety if unsafe", "\n", "                ", "unsafe", "=", "constraint", "(", "action_array", ")", "<", "0", "\n", "values", "[", "unsafe", ",", "i", "]", "=", "-", "np", ".", "inf", "\n", "\n", "# Select best action for policy", "\n", "", "", "best_actions", "=", "action_space", "[", "np", ".", "argmax", "(", "values", ",", "axis", "=", "1", ")", "]", "\n", "assign_op", ".", "eval", "(", "{", "parameters", ":", "best_actions", "}", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.make_tf_fun": [[37, 92], ["function.__name__.lstrip", "functools.wraps", "functools.wraps", "tensorflow.get_default_graph", "tf.get_default_graph.unique_name", "functools.partial", "functools.partial", "tensorflow.py_func", "tensorflow.RegisterGradient", "tf.get_default_graph.gradient_override_map", "tensorflow.py_func"], "function", ["None"], ["def", "make_tf_fun", "(", "return_type", ",", "gradient", "=", "None", ",", "stateful", "=", "True", ")", ":", "\n", "    ", "\"\"\"Convert a python function to a tensorflow function.\n\n    Parameters\n    ----------\n    return_type : list\n        A list of tensorflow return types. Needs to match with the gradient.\n    gradient : callable, optional\n        A function that provides the gradient. It takes `op` and one gradient\n        per output of the function as inputs and returns one gradient for each\n        input of the function. If stateful is `False` then tensorflow does not\n        seem to compute gradients at all.\n\n    Returns\n    -------\n    A tensorflow function with gradients registered.\n    \"\"\"", "\n", "def", "wrap", "(", "function", ")", ":", "\n", "        ", "\"\"\"Create a new function.\"\"\"", "\n", "# Function name with stipped underscore (not allowed by tensorflow)", "\n", "name", "=", "function", ".", "__name__", ".", "lstrip", "(", "'_'", ")", "\n", "\n", "# Without gradients we can take the short route here", "\n", "if", "gradient", "is", "None", ":", "\n", "            ", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "                ", "method", "=", "partial", "(", "function", ",", "self", ",", "**", "kwargs", ")", "\n", "return", "tf", ".", "py_func", "(", "method", ",", "args", ",", "return_type", ",", "\n", "stateful", "=", "stateful", ",", "name", "=", "name", ")", "\n", "\n", "", "return", "wrapped_function", "\n", "\n", "# Name for the gradient operation", "\n", "", "grad_name", "=", "name", "+", "'_gradient'", "\n", "\n", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "self", ",", "*", "args", ")", ":", "\n", "# Overwrite the gradient", "\n", "            ", "graph", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "\n", "# Make sure the name we specify is unique", "\n", "unique_grad_name", "=", "graph", ".", "unique_name", "(", "grad_name", ")", "\n", "\n", "# Register the new gradient method with tensorflow", "\n", "tf", ".", "RegisterGradient", "(", "unique_grad_name", ")", "(", "gradient", ")", "\n", "\n", "# Remove self: Tensorflow does not allow for non-tensor inputs", "\n", "method", "=", "partial", "(", "function", ",", "self", ")", "\n", "\n", "with", "graph", ".", "gradient_override_map", "(", "{", "\"PyFunc\"", ":", "unique_grad_name", "}", ")", ":", "\n", "                ", "return", "tf", ".", "py_func", "(", "method", ",", "args", ",", "return_type", ",", "\n", "stateful", "=", "stateful", ",", "name", "=", "name", ")", "\n", "\n", "", "", "return", "wrapped_function", "\n", "", "return", "wrap", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope": [[94, 112], ["functools.wraps", "tensorflow.name_scope", "function"], "function", ["None"], ["", "def", "with_scope", "(", "name", ")", ":", "\n", "    ", "\"\"\"Set the tensorflow scope for the function.\n\n    Parameters\n    ----------\n    name : string, optional\n\n    Returns\n    -------\n    The tensorflow function with scope name.\n    \"\"\"", "\n", "def", "wrap", "(", "function", ")", ":", "\n", "        ", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "with", "tf", ".", "name_scope", "(", "name", ")", ":", "\n", "                ", "return", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", "return", "wrapped_function", "\n", "", "return", "wrap", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.use_parent_scope": [[114, 121], ["functools.wraps", "tensorflow.variable_scope", "function"], "function", ["None"], ["", "def", "use_parent_scope", "(", "function", ")", ":", "\n", "    ", "\"\"\"Use the parent scope for tensorflow.\"\"\"", "\n", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope_name", ")", ":", "\n", "            ", "return", "function", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", "return", "wrapped_function", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs": [[123, 160], ["functools.wraps", "any", "len", "function", "map", "function", "isinstance", "function", "tuple", "tensorflow.concat", "numpy.hstack"], "function", ["None"], ["", "def", "concatenate_inputs", "(", "start", "=", "0", ")", ":", "\n", "    ", "\"\"\"Concatenate the numpy array inputs to the functions.\n\n    Parameters\n    ----------\n    start : int, optional\n        The attribute number at which to start concatenating.\n    \"\"\"", "\n", "def", "wrap", "(", "function", ")", ":", "\n", "        ", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "\"\"\"Concatenate the input arguments.\"\"\"", "\n", "nargs", "=", "len", "(", "args", ")", "-", "start", "\n", "# Check for tensorflow objects", "\n", "tf_objects", "=", "(", "tf", ".", "Tensor", ",", "tf", ".", "Variable", ")", "\n", "if", "any", "(", "isinstance", "(", "arg", ",", "tf_objects", ")", "for", "arg", "in", "args", "[", "start", ":", "]", ")", ":", "\n", "# reduce number of function calls in graph", "\n", "                ", "if", "nargs", "==", "1", ":", "\n", "                    ", "return", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# concatenate extra arguments", "\n", "", "args", "=", "args", "[", ":", "start", "]", "+", "(", "tf", ".", "concat", "(", "args", "[", "start", ":", "]", ",", "axis", "=", "1", ")", ",", ")", "\n", "return", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# Map to 2D objects", "\n", "                ", "to_concatenate", "=", "map", "(", "np", ".", "atleast_2d", ",", "args", "[", "start", ":", "]", ")", "\n", "\n", "if", "nargs", "==", "1", ":", "\n", "                    ", "concatenated", "=", "tuple", "(", "to_concatenate", ")", "\n", "", "else", ":", "\n", "                    ", "concatenated", "=", "(", "np", ".", "hstack", "(", "to_concatenate", ")", ",", ")", "\n", "\n", "", "args", "=", "args", "[", ":", "start", "]", "+", "concatenated", "\n", "return", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapped_function", "\n", "\n", "", "return", "wrap", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.add_weight_constraint": [[162, 187], ["tensorflow.control_dependencies", "future.builtins.zip", "tensorflow.clip_by_value", "tensorflow.assign", "new_list.append"], "function", ["None"], ["", "def", "add_weight_constraint", "(", "optimization", ",", "var_list", ",", "bound_list", ")", ":", "\n", "    ", "\"\"\"Add weight constraints to an optimization step.\n\n    Parameters\n    ----------\n    optimization : tf.Tensor\n        The optimization routine that updates the parameters.\n    var_list : list\n        A list of variables that should be bounded.\n    bound_list : list\n        A list of bounds (lower, upper) for each variable in var_list.\n\n    Returns\n    -------\n    assign_operations : list\n        A list of assign operations that correspond to one step of the\n        constrained optimization.\n    \"\"\"", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "optimization", "]", ")", ":", "\n", "        ", "new_list", "=", "[", "]", "\n", "for", "var", ",", "bound", "in", "zip", "(", "var_list", ",", "bound_list", ")", ":", "\n", "            ", "clipped_var", "=", "tf", ".", "clip_by_value", "(", "var", ",", "bound", "[", "0", "]", ",", "bound", "[", "1", "]", ")", "\n", "assign", "=", "tf", ".", "assign", "(", "var", ",", "clipped_var", ")", "\n", "new_list", ".", "append", "(", "assign", ")", "\n", "", "", "return", "new_list", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.gradient_clipping": [[189, 222], ["optimizer.compute_gradients", "optimizer.apply_gradients", "tensorflow.clip_by_value", "future.builtins.zip"], "function", ["None"], ["", "def", "gradient_clipping", "(", "optimizer", ",", "loss", ",", "var_list", ",", "limits", ")", ":", "\n", "    ", "\"\"\"Clip the gradients for the optimization problem.\n\n    Parameters\n    ----------\n    optimizer : instance of tensorflow optimizer\n    loss : tf.Tensor\n        The loss that we want to optimize.\n    var_list : tuple\n        A list of variables for which we want to compute gradients.\n    limits : tuple\n        A list of tuples with lower/upper bounds for each variable.\n\n    Returns\n    -------\n    opt : tf.Tensor\n        One optimization step with clipped gradients.\n\n    Examples\n    --------\n    >>> from safe_learning.utilities import gradient_clipping\n    >>> var = tf.Variable(1.)\n    >>> loss = tf.square(var - 1.)\n    >>> optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.01)\n    >>> opt_loss = gradient_clipping(optimizer, loss, [var], [(-1, 1)])\n    \"\"\"", "\n", "gradients", "=", "optimizer", ".", "compute_gradients", "(", "loss", ",", "var_list", "=", "var_list", ")", "\n", "\n", "clipped_gradients", "=", "[", "(", "tf", ".", "clip_by_value", "(", "grad", ",", "low", ",", "up", ")", ",", "var", ")", "\n", "for", "(", "grad", ",", "var", ")", ",", "(", "low", ",", "up", ")", "in", "zip", "(", "gradients", ",", "limits", ")", "]", "\n", "\n", "# Return optimization step", "\n", "return", "optimizer", ".", "apply_gradients", "(", "clipped_gradients", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.batchify": [[224, 250], ["future.builtins.zip", "isinstance", "itertools.count", "itertools.count"], "function", ["None"], ["", "def", "batchify", "(", "arrays", ",", "batch_size", ")", ":", "\n", "    ", "\"\"\"Yield the arrays in batches and in order.\n\n    The last batch might be smaller than batch_size.\n\n    Parameters\n    ----------\n    arrays : list of ndarray\n        The arrays that we want to convert to batches.\n    batch_size : int\n        The size of each individual batch.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "arrays", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "arrays", "=", "(", "arrays", ",", ")", "\n", "\n", "# Iterate over array in batches", "\n", "", "for", "i", ",", "i_next", "in", "zip", "(", "itertools", ".", "count", "(", "start", "=", "0", ",", "step", "=", "batch_size", ")", ",", "\n", "itertools", ".", "count", "(", "start", "=", "batch_size", ",", "step", "=", "batch_size", ")", ")", ":", "\n", "\n", "        ", "batches", "=", "[", "array", "[", "i", ":", "i_next", "]", "for", "array", "in", "arrays", "]", "\n", "\n", "# Break if there are no points left", "\n", "if", "batches", "[", "0", "]", ".", "size", ":", "\n", "            ", "yield", "i", ",", "batches", "\n", "", "else", ":", "\n", "            ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.combinations": [[252, 265], ["numpy.array().T.reshape", "len", "numpy.array", "numpy.meshgrid"], "function", ["None"], ["", "", "", "def", "combinations", "(", "arrays", ")", ":", "\n", "    ", "\"\"\"Return a single array with combinations of parameters.\n\n    Parameters\n    ----------\n    arrays : list of np.array\n\n    Returns\n    -------\n    array : np.array\n        An array that contains all combinations of the input arrays\n    \"\"\"", "\n", "return", "np", ".", "array", "(", "np", ".", "meshgrid", "(", "*", "arrays", ")", ")", ".", "T", ".", "reshape", "(", "-", "1", ",", "len", "(", "arrays", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.linearly_spaced_combinations": [[267, 297], ["numpy.atleast_2d", "len", "numpy.broadcast_to", "utilities.combinations", "numpy.linspace", "future.builtins.zip"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.combinations"], ["", "def", "linearly_spaced_combinations", "(", "bounds", ",", "num_samples", ")", ":", "\n", "    ", "\"\"\"\n    Return 2-D array with all linearly spaced combinations with the bounds.\n\n    Parameters\n    ----------\n    bounds : sequence of tuples\n        The bounds for the variables, [(x1_min, x1_max), (x2_min, x2_max), ...]\n    num_samples : integer or array_likem\n        Number of samples to use for every dimension. Can be a constant if\n        the same number should be used for all, or an array to fine-tune\n        precision. Total number of data points is num_samples ** len(bounds).\n\n    Returns\n    -------\n    combinations : 2-d array\n        A 2-d arrray. If d = len(bounds) and l = prod(num_samples) then it\n        is of size l x d, that is, every row contains one combination of\n        inputs.\n    \"\"\"", "\n", "bounds", "=", "np", ".", "atleast_2d", "(", "bounds", ")", "\n", "num_vars", "=", "len", "(", "bounds", ")", "\n", "num_samples", "=", "np", ".", "broadcast_to", "(", "num_samples", ",", "num_vars", ")", "\n", "\n", "# Create linearly spaced test inputs", "\n", "inputs", "=", "[", "np", ".", "linspace", "(", "b", "[", "0", "]", ",", "b", "[", "1", "]", ",", "n", ")", "for", "b", ",", "n", "in", "zip", "(", "bounds", ",", "\n", "num_samples", ")", "]", "\n", "\n", "# Convert to 2-D array", "\n", "return", "combinations", "(", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.lqr": [[299, 325], ["map", "scipy.linalg.solve_continuous_are", "scipy.linalg.solve_continuous_are", "numpy.linalg.solve", "b.T.dot"], "function", ["None"], ["", "def", "lqr", "(", "a", ",", "b", ",", "q", ",", "r", ")", ":", "\n", "    ", "\"\"\"Compute the continuous time LQR-controller.\n\n    The optimal control input is `u = -k.dot(x)`.\n\n    Parameters\n    ----------\n    a : np.array\n    b : np.array\n    q : np.array\n    r : np.array\n\n    Returns\n    -------\n    k : np.array\n        Controller matrix\n    p : np.array\n        Cost to go matrix\n    \"\"\"", "\n", "a", ",", "b", ",", "q", ",", "r", "=", "map", "(", "np", ".", "atleast_2d", ",", "(", "a", ",", "b", ",", "q", ",", "r", ")", ")", "\n", "p", "=", "scipy", ".", "linalg", ".", "solve_continuous_are", "(", "a", ",", "b", ",", "q", ",", "r", ")", "\n", "\n", "# LQR gain", "\n", "k", "=", "np", ".", "linalg", ".", "solve", "(", "r", ",", "b", ".", "T", ".", "dot", "(", "p", ")", ")", "\n", "\n", "return", "k", ",", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.dlqr": [[327, 358], ["map", "scipy.linalg.solve_discrete_are", "scipy.linalg.solve_discrete_are", "b.T.dot", "b.T.dot.dot", "b.T.dot.dot", "numpy.linalg.solve"], "function", ["None"], ["", "def", "dlqr", "(", "a", ",", "b", ",", "q", ",", "r", ")", ":", "\n", "    ", "\"\"\"Compute the discrete-time LQR controller.\n\n    The optimal control input is `u = -k.dot(x)`.\n\n    Parameters\n    ----------\n    a : np.array\n    b : np.array\n    q : np.array\n    r : np.array\n\n    Returns\n    -------\n    k : np.array\n        Controller matrix\n    p : np.array\n        Cost to go matrix\n    \"\"\"", "\n", "a", ",", "b", ",", "q", ",", "r", "=", "map", "(", "np", ".", "atleast_2d", ",", "(", "a", ",", "b", ",", "q", ",", "r", ")", ")", "\n", "p", "=", "scipy", ".", "linalg", ".", "solve_discrete_are", "(", "a", ",", "b", ",", "q", ",", "r", ")", "\n", "\n", "# LQR gain", "\n", "# k = (b.T * p * b + r)^-1 * (b.T * p * a)", "\n", "bp", "=", "b", ".", "T", ".", "dot", "(", "p", ")", "\n", "tmp1", "=", "bp", ".", "dot", "(", "b", ")", "\n", "tmp1", "+=", "r", "\n", "tmp2", "=", "bp", ".", "dot", "(", "a", ")", "\n", "k", "=", "np", ".", "linalg", ".", "solve", "(", "tmp1", ",", "tmp2", ")", "\n", "\n", "return", "k", ",", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.ellipse_bounds": [[360, 409], ["numpy.linalg.eig", "numpy.sqrt", "numpy.arctan", "numpy.linspace", "numpy.cos", "numpy.sin"], "function", ["None"], ["", "def", "ellipse_bounds", "(", "P", ",", "level", ",", "n", "=", "100", ")", ":", "\n", "    ", "\"\"\"Compute the bounds of a 2D ellipse.\n\n    The levelset of the ellipsoid is given by\n    level = x' P x. Given the coordinates of the first\n    dimension, this function computes the corresponding\n    lower and upper values of the second dimension and\n    removes any values of x0 that are outside of the ellipse.\n\n    Parameters\n    ----------\n    P : np.array\n        The matrix of the ellipsoid\n    level : float\n        The value of the levelset\n    n : int\n        Number of data points\n\n    Returns\n    -------\n    x : np.array\n        1D array of x positions of the ellipse\n    yu : np.array\n        The upper bound of the ellipse\n    yl : np.array\n        The lower bound of the ellipse\n\n    Notes\n    -----\n    This can be used as\n    ```plt.fill_between(*ellipse_bounds(P, level))```\n    \"\"\"", "\n", "# Round up to multiple of 2", "\n", "n", "+=", "n", "%", "2", "\n", "\n", "# Principal axes of ellipsoid", "\n", "eigval", ",", "eigvec", "=", "np", ".", "linalg", ".", "eig", "(", "P", ")", "\n", "eigvec", "*=", "np", ".", "sqrt", "(", "level", "/", "eigval", ")", "\n", "\n", "# set zero angle at maximum x", "\n", "angle", "=", "np", ".", "linspace", "(", "0", ",", "2", "*", "np", ".", "pi", ",", "n", ")", "[", ":", ",", "None", "]", "\n", "angle", "+=", "np", ".", "arctan", "(", "eigvec", "[", "0", ",", "1", "]", "/", "eigvec", "[", "0", ",", "0", "]", ")", "\n", "\n", "# Compute positions", "\n", "pos", "=", "np", ".", "cos", "(", "angle", ")", "*", "eigvec", "[", ":", ",", "0", "]", "+", "np", ".", "sin", "(", "angle", ")", "*", "eigvec", "[", ":", ",", "1", "]", "\n", "n", "/=", "2", "\n", "\n", "# Return x-position (symmetric) and upper/lower bounds", "\n", "return", "pos", "[", ":", "n", ",", "0", "]", ",", "pos", "[", ":", "n", ",", "1", "]", ",", "pos", "[", ":", "n", "-", "1", ":", "-", "1", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_storage": [[411, 443], ["inspect.currentframe", "dictionary.get", "inspect.getframeinfo"], "function", ["None"], ["", "def", "get_storage", "(", "dictionary", ",", "index", "=", "None", ")", ":", "\n", "    ", "\"\"\"Get a unique storage point within a class method.\n\n    Parameters\n    ----------\n    dictionary : dict\n        A dictionary used for storage.\n    index : hashable\n        An index under which to store the element. Needs to be hashable.\n        This is useful for functions which might be accessed with multiple\n        different arguments.\n\n    Returns\n    -------\n    storage : OrderedDict\n        The storage object. Is None if no storage exists. Otherwise it\n        returns the OrderedDict that was previously put in the storage.\n    \"\"\"", "\n", "# Use function name as storage name", "\n", "frame", "=", "inspect", ".", "currentframe", "(", ")", "\n", "storage_name", "=", "inspect", ".", "getframeinfo", "(", "frame", ".", "f_back", ")", ".", "function", "\n", "\n", "storage", "=", "dictionary", ".", "get", "(", "storage_name", ")", "\n", "\n", "if", "index", "is", "None", ":", "\n", "        ", "return", "storage", "\n", "", "elif", "storage", "is", "not", "None", ":", "\n", "# Return directly the indexed object", "\n", "        ", "try", ":", "\n", "            ", "return", "storage", "[", "index", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.set_storage": [[445, 473], ["inspect.currentframe", "future.backports.OrderedDict", "inspect.getframeinfo"], "function", ["None"], ["", "", "", "def", "set_storage", "(", "dictionary", ",", "name_value", ",", "index", "=", "None", ")", ":", "\n", "    ", "\"\"\"Set the storage point within a class method.\n\n    Parameters\n    ----------\n    dictionary : dict\n    name_value : tuple\n        A list of tuples, where each tuple contains a string with the name\n        of the storage object and the corresponding value that is to be put\n        in storage. These are stored as OrderedDicts.\n    index : hashable\n        An index under which to store the element. Needs to be hashable.\n        This is useful for functions which might be accessed with multiple\n        different arguements.\n    \"\"\"", "\n", "# Use function name as storage name", "\n", "frame", "=", "inspect", ".", "currentframe", "(", ")", "\n", "storage_name", "=", "inspect", ".", "getframeinfo", "(", "frame", ".", "f_back", ")", ".", "function", "\n", "\n", "storage", "=", "OrderedDict", "(", "name_value", ")", "\n", "if", "index", "is", "None", ":", "\n", "        ", "dictionary", "[", "storage_name", "]", "=", "storage", "\n", "", "else", ":", "\n", "# Make sure the storage is initialized", "\n", "        ", "if", "storage_name", "not", "in", "dictionary", ":", "\n", "            ", "dictionary", "[", "storage_name", "]", "=", "{", "}", "\n", "# Set the indexed storage", "\n", "", "dictionary", "[", "storage_name", "]", "[", "index", "]", "=", "storage", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict": [[475, 494], ["None"], "function", ["None"], ["", "", "def", "get_feed_dict", "(", "graph", ")", ":", "\n", "    ", "\"\"\"Return the global feed_dict used for this graph.\n\n    Parameters\n    ----------\n    graph : tf.Graph\n\n    Returns\n    -------\n    feed_dict : dict\n        The feed_dict for this graph.\n    \"\"\"", "\n", "try", ":", "\n", "# Just return the feed_dict", "\n", "        ", "return", "graph", ".", "feed_dict_sl", "\n", "", "except", "AttributeError", ":", "\n", "# Create a new feed_dict for this graph", "\n", "        ", "graph", ".", "feed_dict_sl", "=", "{", "}", "\n", "return", "graph", ".", "feed_dict_sl", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.unique_rows": [[496, 517], ["numpy.ascontiguousarray", "numpy.dtype", "np.ascontiguousarray.view", "numpy.unique"], "function", ["None"], ["", "", "def", "unique_rows", "(", "array", ")", ":", "\n", "    ", "\"\"\"Return the unique rows of the array.\n\n    Parameters\n    ----------\n    array : ndarray\n        A 2D numpy array.\n\n    Returns\n    -------\n    unique_array : ndarray\n        A 2D numpy array that contains all the unique rows of array.\n    \"\"\"", "\n", "array", "=", "np", ".", "ascontiguousarray", "(", "array", ")", "\n", "# Combine all the rows into a single element of the flexible void datatype", "\n", "dtype", "=", "np", ".", "dtype", "(", "(", "np", ".", "void", ",", "array", ".", "dtype", ".", "itemsize", "*", "array", ".", "shape", "[", "1", "]", ")", ")", "\n", "combined_array", "=", "array", ".", "view", "(", "dtype", "=", "dtype", ")", "\n", "# Get all the unique rows of the combined array", "\n", "_", ",", "idx", "=", "np", ".", "unique", "(", "combined_array", ",", "return_index", "=", "True", ")", "\n", "\n", "return", "array", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.compute_trajectory": [[519, 584], ["numpy.atleast_2d", "utilities.get_storage", "numpy.empty", "numpy.empty", "tensorflow.get_default_session", "utilities.get_feed_dict", "future.builtins.range", "tensorflow.placeholder", "policy", "dynamics", "utilities.set_storage", "get_storage.values", "tf.get_default_session.run"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.set_storage"], ["", "def", "compute_trajectory", "(", "dynamics", ",", "policy", ",", "initial_state", ",", "num_steps", ")", ":", "\n", "    ", "\"\"\"Compute a state trajectory given dynamics and a policy.\n\n    Parameters\n    ----------\n    dynamics : callable\n        A function that takes the current state and action as input and returns\n        the next state.\n    policy : callable\n        A function that takes the current state as input and returns the\n        action.\n    initial_state : Tensor or ndarray\n        The initial state at which to start simulating.\n    num_steps : int\n        The number of steps for which to simulate the system.\n\n    Returns\n    -------\n    states : ndarray\n        A (num_steps x state_dim) array with one state on each row.\n    actions : ndarray\n        A (num_steps x action_dim) array with the corresponding action on each\n        row.\n    \"\"\"", "\n", "initial_state", "=", "np", ".", "atleast_2d", "(", "initial_state", ")", "\n", "state_dim", "=", "initial_state", ".", "shape", "[", "1", "]", "\n", "\n", "# Get storage (indexed by dynamics and policy)", "\n", "index", "=", "(", "dynamics", ",", "policy", ")", "\n", "storage", "=", "get_storage", "(", "_STORAGE", ",", "index", "=", "index", ")", "\n", "\n", "if", "storage", "is", "None", ":", "\n", "# Compute next state under the policy", "\n", "        ", "tf_state", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "[", "1", ",", "state_dim", "]", ")", "\n", "tf_action", "=", "policy", "(", "tf_state", ")", "\n", "tf_next_state", "=", "dynamics", "(", "tf_state", ",", "tf_action", ")", "\n", "\n", "storage", "=", "[", "(", "'tf_state'", ",", "tf_state", ")", ",", "\n", "(", "'tf_action'", ",", "tf_action", ")", ",", "\n", "(", "'tf_next_state'", ",", "tf_next_state", ")", "]", "\n", "\n", "set_storage", "(", "_STORAGE", ",", "storage", ",", "index", "=", "index", ")", "\n", "", "else", ":", "\n", "        ", "tf_state", ",", "tf_action", ",", "tf_next_state", "=", "storage", ".", "values", "(", ")", "\n", "\n", "# Initialize", "\n", "", "dtype", "=", "config", ".", "np_dtype", "\n", "states", "=", "np", ".", "empty", "(", "(", "num_steps", ",", "state_dim", ")", ",", "dtype", "=", "dtype", ")", "\n", "actions", "=", "np", ".", "empty", "(", "(", "num_steps", "-", "1", ",", "policy", ".", "output_dim", ")", ",", "dtype", "=", "dtype", ")", "\n", "\n", "states", "[", "0", ",", ":", "]", "=", "initial_state", "\n", "\n", "# Get the feed dict", "\n", "session", "=", "tf", ".", "get_default_session", "(", ")", "\n", "feed_dict", "=", "get_feed_dict", "(", "session", ".", "graph", ")", "\n", "\n", "next_data", "=", "[", "tf_next_state", ",", "tf_action", "]", "\n", "\n", "# Run simulation", "\n", "for", "i", "in", "range", "(", "num_steps", "-", "1", ")", ":", "\n", "        ", "feed_dict", "[", "tf_state", "]", "=", "states", "[", "[", "i", "]", ",", ":", "]", "\n", "states", "[", "i", "+", "1", ",", ":", "]", ",", "actions", "[", "i", ",", ":", "]", "=", "session", ".", "run", "(", "next_data", ",", "\n", "feed_dict", "=", "feed_dict", ")", "\n", "\n", "", "return", "states", ",", "actions", "\n", "", ""]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.__init__": [[38, 52], ["object.__init__", "utilities.get_feed_dict", "tensorflow.make_template", "tensorflow.get_default_graph", "tensorflow.variable_scope"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict"], ["def", "__init__", "(", "self", ",", "name", "=", "'function'", ")", ":", "\n", "        ", "super", "(", "Function", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "feed_dict", "=", "get_feed_dict", "(", "tf", ".", "get_default_graph", "(", ")", ")", "\n", "\n", "# Reserve the TensorFlow scope immediately to avoid problems with", "\n", "# Function instances with the same `name`", "\n", "with", "tf", ".", "variable_scope", "(", "name", ")", "as", "scope", ":", "\n", "            ", "self", ".", "_scope", "=", "scope", "\n", "\n", "# Use `original_name_scope` explicitly in case `scope_name` method is", "\n", "# overridden in a child class", "\n", "", "self", ".", "_template", "=", "tf", ".", "make_template", "(", "self", ".", "_scope", ".", "original_name_scope", ",", "\n", "self", ".", "build_evaluation", ",", "\n", "create_scope_now_", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.scope_name": [[53, 56], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "scope_name", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_scope", ".", "original_name_scope", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.parameters": [[57, 62], ["tensorflow.get_collection"], "methods", ["None"], ["", "@", "property", "\n", "def", "parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the variables within the current scope.\"\"\"", "\n", "return", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "TRAINABLE_VARIABLES", ",", "\n", "scope", "=", "self", ".", "scope_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.__call__": [[63, 83], ["tensorflow.name_scope", "functions.Function._template"], "methods", ["None"], ["", "@", "use_parent_scope", "\n", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Evaluate the function using the template to ensure variable sharing.\n\n        Parameters\n        ----------\n        args : list\n            The input arguments to the function.\n        kwargs : dict, optional\n            The keyword arguments to the function.\n\n        Returns\n        -------\n        outputs : list\n            The output arguments of the function as given by evaluate.\n\n        \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "'evaluate'", ")", ":", "\n", "            ", "outputs", "=", "self", ".", "_template", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.build_evaluation": [[84, 98], ["NotImplementedError"], "methods", ["None"], ["", "def", "build_evaluation", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Build the function evaluation tree.\n\n        Parameters\n        ----------\n        args : list\n        kwargs : dict, optional\n\n        Returns\n        -------\n        outputs : list\n\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "'This function has to be implemented by the'", "\n", "'child class.'", ")", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.copy_parameters": [[100, 111], ["future.builtins.zip", "tensorflow.get_default_session", "tensorflow.get_default_session.run", "tensorflow.assign", "assign_ops.append"], "methods", ["None"], ["", "def", "copy_parameters", "(", "self", ",", "other_instance", ")", ":", "\n", "        ", "\"\"\"Copy over the parameters of another instance.\"\"\"", "\n", "assign_ops", "=", "[", "]", "\n", "for", "param", ",", "other_param", "in", "zip", "(", "self", ".", "parameters", ",", "\n", "other_instance", ".", "parameters", ")", ":", "\n", "            ", "op", "=", "tf", ".", "assign", "(", "param", ",", "other_param", ",", "validate_shape", "=", "True", ",", "\n", "name", "=", "'copy_op'", ")", "\n", "assign_ops", ".", "append", "(", "op", ")", "\n", "\n", "", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "sess", ".", "run", "(", "assign_ops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.__add__": [[112, 115], ["functions.AddedFunction"], "methods", ["None"], ["", "def", "__add__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Add this function to another.\"\"\"", "\n", "return", "AddedFunction", "(", "self", ",", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.__mul__": [[116, 119], ["functions.MultipliedFunction"], "methods", ["None"], ["", "def", "__mul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Multiply this function with another.\"\"\"", "\n", "return", "MultipliedFunction", "(", "self", ",", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Function.__neg__": [[120, 123], ["functions.MultipliedFunction"], "methods", ["None"], ["", "def", "__neg__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Negate the function.\"\"\"", "\n", "return", "MultipliedFunction", "(", "self", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.AddedFunction.__init__": [[135, 146], ["functions.Function.__init__", "isinstance", "functions.ConstantFunction", "isinstance", "functions.ConstantFunction"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "fun1", ",", "fun2", ")", ":", "\n", "        ", "\"\"\"Initialization, see `AddedFunction`.\"\"\"", "\n", "super", "(", "AddedFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "fun1", ",", "Function", ")", ":", "\n", "            ", "fun1", "=", "ConstantFunction", "(", "fun1", ")", "\n", "", "if", "not", "isinstance", "(", "fun2", ",", "Function", ")", ":", "\n", "            ", "fun2", "=", "ConstantFunction", "(", "fun2", ")", "\n", "\n", "", "self", ".", "fun1", "=", "fun1", "\n", "self", ".", "fun2", "=", "fun2", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.AddedFunction.parameters": [[147, 151], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the parameters.\"\"\"", "\n", "return", "self", ".", "fun1", ".", "parameters", "+", "self", ".", "fun2", ".", "parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.AddedFunction.copy_parameters": [[152, 156], ["functions.AddedFunction", "functions.AddedFunction.fun1.copy_parameters", "functions.AddedFunction.fun2.copy_parameters"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.copy_parameters", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.copy_parameters"], ["", "def", "copy_parameters", "(", "self", ",", "other_instance", ")", ":", "\n", "        ", "\"\"\"Return a copy of the function (new tf variables with same values.\"\"\"", "\n", "return", "AddedFunction", "(", "self", ".", "fun1", ".", "copy_parameters", "(", "other_instance", ".", "fun1", ")", ",", "\n", "self", ".", "fun2", ".", "copy_parameters", "(", "other_instance", ".", "fun1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.AddedFunction.build_evaluation": [[157, 161], ["utilities.concatenate_inputs", "functions.AddedFunction.fun1", "functions.AddedFunction.fun2"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs"], ["", "@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Evaluate the function.\"\"\"", "\n", "return", "self", ".", "fun1", "(", "points", ")", "+", "self", ".", "fun2", "(", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.MultipliedFunction.__init__": [[173, 184], ["functions.Function.__init__", "isinstance", "functions.ConstantFunction", "isinstance", "functions.ConstantFunction"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "fun1", ",", "fun2", ")", ":", "\n", "        ", "\"\"\"Initialization, see `AddedFunction`.\"\"\"", "\n", "super", "(", "MultipliedFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "fun1", ",", "Function", ")", ":", "\n", "            ", "fun1", "=", "ConstantFunction", "(", "fun1", ")", "\n", "", "if", "not", "isinstance", "(", "fun2", ",", "Function", ")", ":", "\n", "            ", "fun2", "=", "ConstantFunction", "(", "fun2", ")", "\n", "\n", "", "self", ".", "fun1", "=", "fun1", "\n", "self", ".", "fun2", "=", "fun2", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.MultipliedFunction.parameters": [[185, 189], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the parameters.\"\"\"", "\n", "return", "self", ".", "fun1", ".", "parameters", "+", "self", ".", "fun2", ".", "parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.MultipliedFunction.copy_parameters": [[190, 195], ["functions.MultipliedFunction.fun1.copy_parameters", "functions.MultipliedFunction.fun2.copy_parameters", "functions.MultipliedFunction"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.copy_parameters", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.copy_parameters"], ["", "def", "copy_parameters", "(", "self", ",", "other_instance", ")", ":", "\n", "        ", "\"\"\"Return a copy of the function (copies parameters).\"\"\"", "\n", "copied_fun1", "=", "self", ".", "fun1", ".", "copy_parameters", "(", "other_instance", ".", "fun1", ")", "\n", "copied_fun2", "=", "self", ".", "fun2", ".", "copy_parameters", "(", "other_instance", ".", "fun2", ")", "\n", "return", "MultipliedFunction", "(", "copied_fun1", ",", "copied_fun2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.MultipliedFunction.build_evaluation": [[196, 200], ["utilities.concatenate_inputs", "functions.MultipliedFunction.fun1", "functions.MultipliedFunction.fun2"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs"], ["", "@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Evaluate the function.\"\"\"", "\n", "return", "self", ".", "fun1", "(", "points", ")", "*", "self", ".", "fun2", "(", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.UncertainFunction.__init__": [[205, 208], ["functions.Function.__init__"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialization, see `UncertainFunction`.\"\"\"", "\n", "super", "(", "UncertainFunction", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.UncertainFunction.to_mean_function": [[209, 231], ["functions.UncertainFunction.to_mean_function._only_first_output"], "methods", ["None"], ["", "def", "to_mean_function", "(", "self", ")", ":", "\n", "        ", "\"\"\"Turn the uncertain function into a deterministic 'mean' function.\"\"\"", "\n", "def", "_only_first_output", "(", "function", ")", ":", "\n", "            ", "\"\"\"Remove all but the first output of a function.\n\n            Parameters\n            ----------\n            function : callable\n\n            Returns\n            -------\n            function : callable\n                The modified function.\n\n            \"\"\"", "\n", "def", "new_function", "(", "*", "points", ")", ":", "\n", "                ", "return", "function", "(", "*", "points", ")", "[", "0", "]", "\n", "", "return", "new_function", "\n", "\n", "", "new_evaluate", "=", "_only_first_output", "(", "self", ".", "build_evaluation", ")", "\n", "\n", "return", "new_evaluate", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.DeterministicFunction.__init__": [[236, 239], ["functions.Function.__init__"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Initialization, see `Function` for details.\"\"\"", "\n", "super", "(", "DeterministicFunction", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.ConstantFunction.__init__": [[244, 248], ["functions.DeterministicFunction.__init__"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "constant", ",", "name", "=", "'constant_function'", ")", ":", "\n", "        ", "\"\"\"Initialize, see `ConstantFunction`.\"\"\"", "\n", "super", "(", "ConstantFunction", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "constant", "=", "constant", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.ConstantFunction.build_evaluation": [[249, 252], ["utilities.concatenate_inputs"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs"], ["", "@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "return", "self", ".", "constant", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.FunctionStack.__init__": [[264, 272], ["functions.UncertainFunction.__init__", "len", "sum"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "functions", ",", "name", "=", "'function_stack'", ")", ":", "\n", "        ", "\"\"\"Initialization, see `FunctionStack`.\"\"\"", "\n", "super", "(", "FunctionStack", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "functions", "=", "functions", "\n", "self", ".", "num_fun", "=", "len", "(", "self", ".", "functions", ")", "\n", "\n", "self", ".", "input_dim", "=", "self", ".", "functions", "[", "0", "]", ".", "input_dim", "\n", "self", ".", "output_dim", "=", "sum", "(", "fun", ".", "output_dim", "for", "fun", "in", "self", ".", "functions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.FunctionStack.parameters": [[273, 277], ["sum"], "methods", ["None"], ["", "@", "property", "\n", "def", "parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the parameters.\"\"\"", "\n", "return", "sum", "(", "fun", ".", "parameters", "for", "fun", "in", "self", ".", "functions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.FunctionStack.build_evaluation": [[278, 292], ["utilities.concatenate_inputs", "tensorflow.concat", "tensorflow.concat", "fun", "means.append", "errors.append"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs", "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.fun"], ["", "@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Evaluation, see `UncertainFunction.evaluate`.\"\"\"", "\n", "means", "=", "[", "]", "\n", "errors", "=", "[", "]", "\n", "for", "fun", "in", "self", ".", "functions", ":", "\n", "            ", "mean", ",", "error", "=", "fun", "(", "points", ")", "\n", "means", ".", "append", "(", "mean", ")", "\n", "errors", ".", "append", "(", "error", ")", "\n", "\n", "", "mean", "=", "tf", ".", "concat", "(", "means", ",", "axis", "=", "1", ",", "name", "=", "'stacked_mean'", ")", "\n", "error", "=", "tf", ".", "concat", "(", "errors", ",", "axis", "=", "1", ",", "name", "=", "'stacked_error'", ")", "\n", "\n", "return", "mean", ",", "error", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.FunctionStack.add_data_point": [[293, 308], ["future.builtins.zip", "y.squeeze", "fun.add_data_point"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.add_data_point"], ["", "def", "add_data_point", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "\"\"\"Add data points to the GP model and update cholesky.\n\n        Parameters\n        ----------\n        x : ndarray\n            A 2d array with the new states to add to the GP model. Each new\n            state is on a new row.\n        y : ndarray\n            A 2d array with the new measurements to add to the GP model.\n            Each measurements is on a new row.\n\n        \"\"\"", "\n", "for", "fun", ",", "yi", "in", "zip", "(", "self", ".", "functions", ",", "y", ".", "squeeze", "(", ")", ")", ":", "\n", "            ", "fun", ".", "add_data_point", "(", "x", ",", "yi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.__init__": [[323, 338], ["functions.DeterministicFunction.__init__", "dir", "setattr", "par.startswith", "hasattr", "eval"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "fun", ",", "lower", ",", "upper", ",", "name", "=", "'saturation'", ")", ":", "\n", "        ", "\"\"\"Initialization. See `Saturation`.\"\"\"", "\n", "super", "(", "Saturation", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "fun", "=", "fun", "\n", "self", ".", "lower", "=", "lower", "\n", "self", ".", "upper", "=", "upper", "\n", "\n", "self", ".", "input_dim", "=", "self", ".", "fun", ".", "input_dim", "\n", "self", ".", "output_dim", "=", "self", ".", "fun", ".", "output_dim", "\n", "\n", "# Copy over attributes and functions from fun", "\n", "for", "par", "in", "dir", "(", "self", ".", "fun", ")", ":", "\n", "            ", "if", "par", ".", "startswith", "(", "'__'", ")", "or", "hasattr", "(", "self", ",", "par", ")", ":", "\n", "                ", "continue", "\n", "", "setattr", "(", "self", ",", "par", ",", "eval", "(", "'self.fun.'", "+", "par", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.scope_name": [[339, 343], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "scope_name", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the scope name of the wrapped function.\"\"\"", "\n", "return", "self", ".", "fun", ".", "scope_name", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.copy_parameters": [[344, 348], ["functions.Saturation", "functions.Saturation.fun.copy_parameters"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.copy_parameters"], ["", "def", "copy_parameters", "(", "self", ",", "other_instance", ")", ":", "\n", "        ", "\"\"\"Return a copy of the function (copies parameters).\"\"\"", "\n", "return", "Saturation", "(", "self", ".", "fun", ".", "copy_parameters", "(", "other_instance", ".", "fun", ")", ",", "\n", "self", ".", "lower", ",", "self", ".", "upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.build_evaluation": [[349, 355], ["functions.Saturation.fun.build_evaluation", "tensorflow.minimum", "tensorflow.maximum"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.build_evaluation"], ["", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Evaluation, see `DeterministicFunction.evaluate`.\"\"\"", "\n", "res", "=", "self", ".", "fun", ".", "build_evaluation", "(", "points", ")", "\n", "\n", "# Broadcasting in tf.clip_by_value not available in TensorFlow >= 1.6.0", "\n", "return", "tf", ".", "minimum", "(", "tf", ".", "maximum", "(", "res", ",", "self", ".", "lower", ")", ",", "self", ".", "upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached.__init__": [[374, 394], ["gpflow.mean_functions.Zero", "gpflow.gpr.GPR.__init__", "gpflow.param.DataHolder", "gpflow.param.DataHolder", "functions.GPRCached.update_cache", "isinstance", "numpy.empty", "numpy.empty"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached.update_cache"], ["def", "__init__", "(", "self", ",", "x", ",", "y", ",", "kern", ",", "mean_function", "=", "gpflow", ".", "mean_functions", ".", "Zero", "(", ")", ",", "\n", "scale", "=", "1.", ",", "name", "=", "'GPRCached'", ")", ":", "\n", "        ", "\"\"\"Initialize GP and cholesky decomposition.\"\"\"", "\n", "# Make sure gpflow is imported", "\n", "if", "not", "isinstance", "(", "gpflow", ",", "ModuleType", ")", ":", "\n", "            ", "raise", "gpflow", "\n", "\n", "# self.scope_name = scope.original_name_scope", "\n", "", "gpflow", ".", "gpr", ".", "GPR", ".", "__init__", "(", "self", ",", "x", ",", "y", ",", "kern", ",", "mean_function", ",", "name", ")", "\n", "\n", "# Create new dataholders for the cached data", "\n", "# TODO zero-dim dataholders cause strange allocator errors in", "\n", "# tensorflow with MKL", "\n", "dtype", "=", "config", ".", "np_dtype", "\n", "self", ".", "cholesky", "=", "gpflow", ".", "param", ".", "DataHolder", "(", "np", ".", "empty", "(", "(", "0", ",", "0", ")", ",", "dtype", "=", "dtype", ")", ",", "\n", "on_shape_change", "=", "'pass'", ")", "\n", "self", ".", "alpha", "=", "gpflow", ".", "param", ".", "DataHolder", "(", "np", ".", "empty", "(", "(", "0", ",", "0", ")", ",", "dtype", "=", "dtype", ")", ",", "\n", "on_shape_change", "=", "'pass'", ")", "\n", "self", ".", "_scale", "=", "scale", "\n", "self", ".", "update_cache", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached._compute_cache": [[395, 412], ["utilities.with_scope", "gpflow.param.AutoFlow", "tensorflow.eye", "tensorflow.cholesky", "tensorflow.matrix_triangular_solve", "functions.GPRCached.kern.K", "tensorflow.shape", "functions.GPRCached.mean_function"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope"], ["", "@", "with_scope", "(", "'compute_cache'", ")", "\n", "@", "gpflow", ".", "param", ".", "AutoFlow", "(", ")", "\n", "def", "_compute_cache", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compute cache.\"\"\"", "\n", "# Scaled kernel", "\n", "identity", "=", "tf", ".", "eye", "(", "tf", ".", "shape", "(", "self", ".", "X", ")", "[", "0", "]", ",", "dtype", "=", "config", ".", "dtype", ")", "\n", "kernel", "=", "self", ".", "kern", ".", "K", "(", "self", ".", "X", ")", "+", "identity", "*", "self", ".", "likelihood", ".", "variance", "\n", "kernel", "*=", "(", "self", ".", "_scale", "**", "2", ")", "\n", "\n", "# Scaled target", "\n", "target", "=", "self", ".", "_scale", "*", "(", "self", ".", "Y", "-", "self", ".", "mean_function", "(", "self", ".", "X", ")", ")", "\n", "\n", "# Cholesky decomposition", "\n", "cholesky", "=", "tf", ".", "cholesky", "(", "kernel", ",", "name", "=", "'gp_cholesky'", ")", "\n", "alpha", "=", "tf", ".", "matrix_triangular_solve", "(", "cholesky", ",", "target", ",", "name", "=", "'gp_alpha'", ")", "\n", "\n", "return", "cholesky", ",", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached.update_cache": [[413, 416], ["functions.GPRCached._compute_cache"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached._compute_cache"], ["", "def", "update_cache", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update the cache after adding data points.\"\"\"", "\n", "self", ".", "cholesky", ",", "self", ".", "alpha", "=", "self", ".", "_compute_cache", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached.build_predict": [[417, 459], ["utilities.with_scope", "tensorflow.matrix_triangular_solve", "functions.GPRCached.kern.K", "functions.GPRCached.mean_function", "tensorflow.matmul", "tensorflow.stack", "tensorflow.tile", "tensorflow.tile", "functions.GPRCached.kern.K", "tensorflow.matmul", "tensorflow.expand_dims", "functions.GPRCached.kern.Kdiag", "tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.square", "tensorflow.shape", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope"], ["", "@", "with_scope", "(", "'build_predict'", ")", "\n", "def", "build_predict", "(", "self", ",", "Xnew", ",", "full_cov", "=", "False", ")", ":", "\n", "        ", "\"\"\"Predict mean and variance of the GP at locations in Xnew.\n\n        Parameters\n        ----------\n        Xnew : ndarray\n            The points at which to evaluate the function. One row for each\n            data points.\n        full_cov : bool\n            if False returns only the diagonal of the covariance matrix\n\n        Returns\n        -------\n        mean : ndarray\n            The expected function values at the points.\n        error_bounds : ndarray\n            Diagonal of the covariance matrix (or full matrix).\n\n        \"\"\"", "\n", "# Scaled kernel and mean", "\n", "Kx", "=", "(", "self", ".", "_scale", "**", "2", ")", "*", "self", ".", "kern", ".", "K", "(", "self", ".", "X", ",", "Xnew", ")", "\n", "mx", "=", "self", ".", "_scale", "*", "self", ".", "mean_function", "(", "Xnew", ")", "\n", "\n", "a", "=", "tf", ".", "matrix_triangular_solve", "(", "self", ".", "cholesky", ",", "Kx", ",", "lower", "=", "True", ")", "\n", "fmean", "=", "(", "tf", ".", "matmul", "(", "a", ",", "self", ".", "alpha", ",", "transpose_a", "=", "True", ")", "+", "mx", ")", "\n", "\n", "if", "full_cov", ":", "\n", "            ", "Knew", "=", "(", "self", ".", "_scale", "**", "2", ")", "*", "self", ".", "kern", ".", "K", "(", "Xnew", ")", "\n", "fvar", "=", "Knew", "-", "tf", ".", "matmul", "(", "a", ",", "a", ",", "transpose_a", "=", "True", ")", "\n", "shape", "=", "tf", ".", "stack", "(", "[", "1", ",", "1", ",", "tf", ".", "shape", "(", "self", ".", "Y", ")", "[", "1", "]", "]", ")", "\n", "fvar", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "fvar", ",", "2", ")", ",", "shape", ")", "\n", "", "else", ":", "\n", "            ", "Knew", "=", "(", "self", ".", "_scale", "**", "2", ")", "*", "self", ".", "kern", ".", "Kdiag", "(", "Xnew", ")", "\n", "fvar", "=", "Knew", "-", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "a", ")", ",", "0", ")", "\n", "fvar", "=", "tf", ".", "tile", "(", "tf", ".", "reshape", "(", "fvar", ",", "(", "-", "1", ",", "1", ")", ")", ",", "[", "1", ",", "tf", ".", "shape", "(", "self", ".", "Y", ")", "[", "1", "]", "]", ")", "\n", "\n", "# Apply inverse-scaling to mean and variance before returning", "\n", "", "fmean", "/=", "self", ".", "_scale", "\n", "fvar", "/=", "(", "self", ".", "_scale", "**", "2", ")", "\n", "\n", "return", "fmean", ",", "fvar", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.__init__": [[480, 496], ["functions.UncertainFunction.__init__", "tensorflow.variable_scope", "float", "functions.GaussianProcess.gaussian_process.make_tf_array", "functions.GaussianProcess.update_feed_dict", "tensorflow.placeholder"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.update_feed_dict"], ["def", "__init__", "(", "self", ",", "gaussian_process", ",", "beta", "=", "2.", ",", "name", "=", "'gaussian_process'", ")", ":", "\n", "        ", "\"\"\"Initialization.\"\"\"", "\n", "super", "(", "GaussianProcess", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope_name", ")", ":", "\n", "            ", "self", ".", "n_dim", "=", "gaussian_process", ".", "X", ".", "shape", "[", "-", "1", "]", "\n", "self", ".", "gaussian_process", "=", "gaussian_process", "\n", "self", ".", "beta", "=", "float", "(", "beta", ")", "\n", "\n", "self", ".", "input_dim", "=", "gaussian_process", ".", "X", ".", "shape", "[", "1", "]", "\n", "self", ".", "output_dim", "=", "gaussian_process", ".", "Y", ".", "shape", "[", "1", "]", "\n", "\n", "self", ".", "hyperparameters", "=", "[", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "[", "None", "]", ")", "]", "\n", "self", ".", "gaussian_process", ".", "make_tf_array", "(", "self", ".", "hyperparameters", "[", "0", "]", ")", "\n", "\n", "self", ".", "update_feed_dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.X": [[497, 501], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "\"\"\"Input location of observed data. One observation per row.\"\"\"", "\n", "return", "self", ".", "gaussian_process", ".", "X", ".", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.Y": [[502, 506], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "\"\"\"Observed output. One observation per row.\"\"\"", "\n", "return", "self", ".", "gaussian_process", ".", "Y", ".", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.build_evaluation": [[507, 516], ["utilities.concatenate_inputs", "functions.GaussianProcess.gaussian_process.tf_mode", "functions.GaussianProcess.gaussian_process.build_predict", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached.build_predict"], ["", "@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Evaluate the model, but return tensorflow tensors.\"\"\"", "\n", "# Build normal prediction", "\n", "with", "self", ".", "gaussian_process", ".", "tf_mode", "(", ")", ":", "\n", "            ", "mean", ",", "var", "=", "self", ".", "gaussian_process", ".", "build_predict", "(", "points", ")", "\n", "# Construct confidence intervals", "\n", "", "std", "=", "self", ".", "beta", "*", "tf", ".", "sqrt", "(", "var", ",", "name", "=", "'standard_deviation'", ")", "\n", "return", "mean", ",", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.update_feed_dict": [[517, 524], ["gp.update_feed_dict", "gp.get_free_state", "gp.get_feed_dict_keys"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.update_feed_dict"], ["", "def", "update_feed_dict", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update the feed dictionary for tensorflow.\"\"\"", "\n", "gp", "=", "self", ".", "gaussian_process", "\n", "feed_dict", "=", "self", ".", "feed_dict", "\n", "\n", "gp", ".", "update_feed_dict", "(", "gp", ".", "get_feed_dict_keys", "(", ")", ",", "feed_dict", ")", "\n", "feed_dict", "[", "self", ".", "hyperparameters", "[", "0", "]", "]", "=", "gp", ".", "get_free_state", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.add_data_point": [[525, 547], ["utilities.with_scope", "numpy.vstack", "numpy.vstack", "hasattr", "functions.GaussianProcess.update_feed_dict", "gp.update_cache", "numpy.atleast_2d", "numpy.atleast_2d"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.update_feed_dict", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached.update_cache"], ["", "@", "use_parent_scope", "\n", "@", "with_scope", "(", "'add_data_point'", ")", "\n", "def", "add_data_point", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "\"\"\"Add data points to the GP model and update cholesky.\n\n        Parameters\n        ----------\n        x : ndarray\n            A 2d array with the new states to add to the GP model. Each new\n            state is on a new row.\n        y : ndarray\n            A 2d array with the new measurements to add to the GP model.\n            Each measurements is on a new row.\n\n        \"\"\"", "\n", "gp", "=", "self", ".", "gaussian_process", "\n", "gp", ".", "X", "=", "np", ".", "vstack", "(", "(", "self", ".", "X", ",", "np", ".", "atleast_2d", "(", "x", ")", ")", ")", "\n", "gp", ".", "Y", "=", "np", ".", "vstack", "(", "(", "self", ".", "Y", ",", "np", ".", "atleast_2d", "(", "y", ")", ")", ")", "\n", "\n", "if", "hasattr", "(", "gp", ",", "'update_cache'", ")", ":", "\n", "            ", "gp", ".", "update_cache", "(", ")", "\n", "", "self", ".", "update_feed_dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.ScipyDelaunay.__init__": [[565, 573], ["numpy.asarray", "numpy.meshgrid", "scipy.spatial.Delaunay.__init__", "numpy.linspace", "numpy.array", "future.builtins.zip", "par.ravel"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "limits", ",", "num_points", ")", ":", "\n", "        ", "self", ".", "numpoints", "=", "num_points", "\n", "self", ".", "limits", "=", "np", ".", "asarray", "(", "limits", ",", "dtype", "=", "config", ".", "np_dtype", ")", "\n", "params", "=", "[", "np", ".", "linspace", "(", "limit", "[", "0", "]", ",", "limit", "[", "1", "]", ",", "n", ")", "for", "limit", ",", "n", "in", "\n", "zip", "(", "limits", ",", "num_points", ")", "]", "\n", "output", "=", "np", ".", "meshgrid", "(", "*", "params", ")", "\n", "points", "=", "np", ".", "array", "(", "[", "par", ".", "ravel", "(", ")", "for", "par", "in", "output", "]", ")", ".", "T", "\n", "super", "(", "ScipyDelaunay", ",", "self", ")", ".", "__init__", "(", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.__init__": [[591, 621], ["object.__init__", "numpy.atleast_2d().astype", "numpy.broadcast_to", "numpy.broadcast_to.astype", "numpy.any", "numpy.stack", "numpy.prod", "numpy.prod", "len", "len", "functions.DimensionError", "numpy.linspace", "numpy.atleast_2d", "numpy.zeros_like", "future.builtins.zip"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "limits", ",", "num_points", ")", ":", "\n", "        ", "\"\"\"Initialization, see `GridWorld`.\"\"\"", "\n", "super", "(", "GridWorld", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "limits", "=", "np", ".", "atleast_2d", "(", "limits", ")", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "num_points", "=", "np", ".", "broadcast_to", "(", "num_points", ",", "len", "(", "self", ".", "limits", ")", ")", "\n", "self", ".", "num_points", "=", "num_points", ".", "astype", "(", "np", ".", "int", ",", "copy", "=", "False", ")", "\n", "\n", "if", "np", ".", "any", "(", "self", ".", "num_points", "<", "2", ")", ":", "\n", "            ", "raise", "DimensionError", "(", "'There must be at least 2 points in each '", "\n", "'dimension.'", ")", "\n", "\n", "# Compute offset and unit hyperrectangle", "\n", "", "self", ".", "offset", "=", "self", ".", "limits", "[", ":", ",", "0", "]", "\n", "self", ".", "unit_maxes", "=", "(", "(", "self", ".", "limits", "[", ":", ",", "1", "]", "-", "self", ".", "offset", ")", "\n", "/", "(", "self", ".", "num_points", "-", "1", ")", ")", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "self", ".", "offset_limits", "=", "np", ".", "stack", "(", "(", "np", ".", "zeros_like", "(", "self", ".", "limits", "[", ":", ",", "0", "]", ")", ",", "\n", "self", ".", "limits", "[", ":", ",", "1", "]", "-", "self", ".", "offset", ")", ",", "\n", "axis", "=", "1", ")", "\n", "\n", "# Statistics about the grid", "\n", "self", ".", "discrete_points", "=", "[", "np", ".", "linspace", "(", "low", ",", "up", ",", "n", ",", "dtype", "=", "config", ".", "np_dtype", ")", "\n", "for", "(", "low", ",", "up", ")", ",", "n", "in", "zip", "(", "self", ".", "limits", ",", "\n", "self", ".", "num_points", ")", "]", "\n", "\n", "self", ".", "nrectangles", "=", "np", ".", "prod", "(", "self", ".", "num_points", "-", "1", ")", "\n", "self", ".", "nindex", "=", "np", ".", "prod", "(", "self", ".", "num_points", ")", "\n", "\n", "self", ".", "ndim", "=", "len", "(", "self", ".", "limits", ")", "\n", "self", ".", "_all_points", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.all_points": [[622, 639], ["numpy.meshgrid", "numpy.column_stack", "numpy.column_stack.astype", "col.ravel"], "methods", ["None"], ["", "@", "property", "\n", "def", "all_points", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return all the discrete points of the discretization.\n\n        Returns\n        -------\n        points : ndarray\n            An array with all the discrete points with size\n            (self.nindex, self.ndim).\n\n        \"\"\"", "\n", "if", "self", ".", "_all_points", "is", "None", ":", "\n", "            ", "mesh", "=", "np", ".", "meshgrid", "(", "*", "self", ".", "discrete_points", ",", "indexing", "=", "'ij'", ")", "\n", "points", "=", "np", ".", "column_stack", "(", "col", ".", "ravel", "(", ")", "for", "col", "in", "mesh", ")", "\n", "self", ".", "_all_points", "=", "points", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "\n", "", "return", "self", ".", "_all_points", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.__len__": [[640, 643], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of points in the discretization.\"\"\"", "\n", "return", "self", ".", "nindex", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.sample_continuous": [[644, 660], ["numpy.random.uniform", "numpy.diff"], "methods", ["None"], ["", "def", "sample_continuous", "(", "self", ",", "num_samples", ")", ":", "\n", "        ", "\"\"\"Sample uniformly at random from the continuous domain.\n\n        Parameters\n        ----------\n        num_samples : int\n\n        Returns\n        -------\n        points : ndarray\n            Random points on the continuous rectangle.\n\n        \"\"\"", "\n", "limits", "=", "self", ".", "limits", "\n", "rand", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "size", "=", "(", "num_samples", ",", "self", ".", "ndim", ")", ")", "\n", "return", "rand", "*", "np", ".", "diff", "(", "limits", ",", "axis", "=", "1", ")", ".", "T", "+", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.sample_discrete": [[661, 678], ["numpy.random.choice", "functions.GridWorld.index_to_state"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state"], ["", "def", "sample_discrete", "(", "self", ",", "num_samples", ",", "replace", "=", "False", ")", ":", "\n", "        ", "\"\"\"Sample uniformly at random from the discrete domain.\n\n        Parameters\n        ----------\n        num_samples : int\n        replace : bool, optional\n            Whether to sample with replacement.\n\n        Returns\n        -------\n        points : ndarray\n            Random points on the continuous rectangle.\n\n        \"\"\"", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "nindex", ",", "size", "=", "num_samples", ",", "replace", "=", "replace", ")", "\n", "return", "self", ".", "index_to_state", "(", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld._check_dimensions": [[679, 689], ["functions.DimensionError"], "methods", ["None"], ["", "def", "_check_dimensions", "(", "self", ",", "states", ")", ":", "\n", "        ", "\"\"\"Raise an error if the states have the wrong dimension.\n\n        Parameters\n        ----------\n        states : ndarray\n\n        \"\"\"", "\n", "if", "not", "states", ".", "shape", "[", "1", "]", "==", "self", ".", "ndim", ":", "\n", "            ", "raise", "DimensionError", "(", "'the input argument has the wrong '", "\n", "'dimensions.'", ")", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld._center_states": [[691, 713], ["numpy.atleast_2d().astype", "numpy.clip", "numpy.atleast_2d"], "methods", ["None"], ["", "", "def", "_center_states", "(", "self", ",", "states", ",", "clip", "=", "True", ")", ":", "\n", "        ", "\"\"\"Center the states to the interval [0, x].\n\n        Parameters\n        ----------\n        states : np.array\n        clip : bool, optinal\n            If False the data is not clipped to lie within the limits.\n\n        Returns\n        -------\n        offset_states : ndarray\n\n        \"\"\"", "\n", "states", "=", "np", ".", "atleast_2d", "(", "states", ")", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "states", "=", "states", "-", "self", ".", "offset", "[", "None", ",", ":", "]", "\n", "if", "clip", ":", "\n", "            ", "np", ".", "clip", "(", "states", ",", "\n", "self", ".", "offset_limits", "[", ":", ",", "0", "]", "+", "2", "*", "_EPS", ",", "\n", "self", ".", "offset_limits", "[", ":", ",", "1", "]", "-", "2", "*", "_EPS", ",", "\n", "out", "=", "states", ")", "\n", "", "return", "states", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state": [[714, 732], ["numpy.atleast_1d", "ijk_index.astype.astype.astype", "numpy.vstack", "numpy.unravel_index"], "methods", ["None"], ["", "def", "index_to_state", "(", "self", ",", "indices", ")", ":", "\n", "        ", "\"\"\"Convert indices to physical states.\n\n        Parameters\n        ----------\n        indices : ndarray (int)\n            The indices of points on the discretization.\n\n        Returns\n        -------\n        states : ndarray\n            The states with physical units that correspond to the indices.\n\n        \"\"\"", "\n", "indices", "=", "np", ".", "atleast_1d", "(", "indices", ")", "\n", "ijk_index", "=", "np", ".", "vstack", "(", "np", ".", "unravel_index", "(", "indices", ",", "self", ".", "num_points", ")", ")", ".", "T", "\n", "ijk_index", "=", "ijk_index", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "return", "ijk_index", "*", "self", ".", "unit_maxes", "+", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index": [[733, 753], ["numpy.atleast_2d", "functions.GridWorld._check_dimensions", "numpy.clip", "numpy.rint().astype", "numpy.ravel_multi_index", "numpy.rint"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld._check_dimensions"], ["", "def", "state_to_index", "(", "self", ",", "states", ")", ":", "\n", "        ", "\"\"\"Convert physical states to indices.\n\n        Parameters\n        ----------\n        states: ndarray\n            Physical states on the discretization.\n\n        Returns\n        -------\n        indices: ndarray (int)\n            The indices that correspond to the physical states.\n\n        \"\"\"", "\n", "states", "=", "np", ".", "atleast_2d", "(", "states", ")", "\n", "self", ".", "_check_dimensions", "(", "states", ")", "\n", "states", "=", "np", ".", "clip", "(", "states", ",", "self", ".", "limits", "[", ":", ",", "0", "]", ",", "self", ".", "limits", "[", ":", ",", "1", "]", ")", "\n", "states", "=", "(", "states", "-", "self", ".", "offset", ")", "*", "(", "1.", "/", "self", ".", "unit_maxes", ")", "\n", "ijk_index", "=", "np", ".", "rint", "(", "states", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "return", "np", ".", "ravel_multi_index", "(", "ijk_index", ".", "T", ",", "self", ".", "num_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_rectangle": [[754, 777], ["enumerate", "numpy.ravel_multi_index", "future.builtins.zip", "numpy.digitize", "numpy.clip", "ind.append"], "methods", ["None"], ["", "def", "state_to_rectangle", "(", "self", ",", "states", ")", ":", "\n", "        ", "\"\"\"Convert physical states to its closest rectangle index.\n\n        Parameters\n        ----------\n        states : ndarray\n            Physical states on the discretization.\n\n        Returns\n        -------\n        rectangles : ndarray (int)\n            The indices that correspond to rectangles of the physical states.\n\n        \"\"\"", "\n", "ind", "=", "[", "]", "\n", "for", "i", ",", "(", "discrete", ",", "num_points", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "discrete_points", ",", "\n", "self", ".", "num_points", ")", ")", ":", "\n", "            ", "idx", "=", "np", ".", "digitize", "(", "states", "[", ":", ",", "i", "]", ",", "discrete", ")", "\n", "idx", "-=", "1", "\n", "np", ".", "clip", "(", "idx", ",", "0", ",", "num_points", "-", "2", ",", "out", "=", "idx", ")", "\n", "\n", "ind", ".", "append", "(", "idx", ")", "\n", "", "return", "np", ".", "ravel_multi_index", "(", "ind", ",", "self", ".", "num_points", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.rectangle_to_state": [[778, 799], ["numpy.atleast_1d", "numpy.vstack", "ijk_index.astype.astype.astype", "numpy.unravel_index"], "methods", ["None"], ["", "def", "rectangle_to_state", "(", "self", ",", "rectangles", ")", ":", "\n", "        ", "\"\"\"\n        Convert rectangle indices to the states of the bottem-left corners.\n\n        Parameters\n        ----------\n        rectangles : ndarray (int)\n            The indices of the rectangles\n\n        Returns\n        -------\n        states : ndarray\n            The states that correspond to the bottom-left corners of the\n            corresponding rectangles.\n\n        \"\"\"", "\n", "rectangles", "=", "np", ".", "atleast_1d", "(", "rectangles", ")", "\n", "ijk_index", "=", "np", ".", "vstack", "(", "np", ".", "unravel_index", "(", "rectangles", ",", "\n", "self", ".", "num_points", "-", "1", ")", ")", "\n", "ijk_index", "=", "ijk_index", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "return", "(", "ijk_index", ".", "T", "*", "self", ".", "unit_maxes", ")", "+", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.rectangle_corner_index": [[800, 818], ["numpy.vstack", "numpy.ravel_multi_index", "numpy.unravel_index", "numpy.atleast_2d"], "methods", ["None"], ["", "def", "rectangle_corner_index", "(", "self", ",", "rectangles", ")", ":", "\n", "        ", "\"\"\"Return the index of the bottom-left corner of the rectangle.\n\n        Parameters\n        ----------\n        rectangles: ndarray\n            The indices of the rectangles.\n\n        Returns\n        -------\n        corners : ndarray (int)\n            The indices of the bottom-left corners of the rectangles.\n\n        \"\"\"", "\n", "ijk_index", "=", "np", ".", "vstack", "(", "np", ".", "unravel_index", "(", "rectangles", ",", "\n", "self", ".", "num_points", "-", "1", ")", ")", "\n", "return", "np", ".", "ravel_multi_index", "(", "np", ".", "atleast_2d", "(", "ijk_index", ")", ",", "\n", "self", ".", "num_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.PiecewiseConstant.__init__": [[832, 841], ["functions.DeterministicFunction.__init__"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "discretization", ",", "vertex_values", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialization, see `PiecewiseConstant`.\"\"\"", "\n", "super", "(", "PiecewiseConstant", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "discretization", "=", "discretization", "\n", "self", ".", "_parameters", "=", "None", "\n", "self", ".", "parameters", "=", "vertex_values", "\n", "\n", "self", ".", "input_dim", "=", "discretization", ".", "ndim", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.PiecewiseConstant.output_dim": [[842, 847], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the output dimensions of the function.\"\"\"", "\n", "if", "self", ".", "parameters", "is", "not", "None", ":", "\n", "            ", "return", "self", ".", "parameters", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.PiecewiseConstant.parameters": [[853, 860], ["numpy.asarray().reshape", "numpy.asarray"], "methods", ["None"], ["", "@", "parameters", ".", "setter", "\n", "def", "parameters", "(", "self", ",", "values", ")", ":", "\n", "        ", "\"\"\"Set the vertex values.\"\"\"", "\n", "if", "values", "is", "None", ":", "\n", "            ", "self", ".", "_parameters", "=", "values", "\n", "", "else", ":", "\n", "            ", "self", ".", "_parameters", "=", "np", ".", "asarray", "(", "values", ")", ".", "reshape", "(", "self", ".", "nindex", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.PiecewiseConstant.limits": [[861, 865], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "limits", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the discretization limits.\"\"\"", "\n", "return", "self", ".", "discretization", ".", "limits", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.PiecewiseConstant.nindex": [[866, 870], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "nindex", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of discretization indices.\"\"\"", "\n", "return", "self", ".", "discretization", ".", "nindex", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.PiecewiseConstant.build_evaluation": [[871, 888], ["functions.PiecewiseConstant.discretization.state_to_index"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index"], ["", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Return the function values.\n\n        Parameters\n        ----------\n        points : ndarray\n            The points at which to evaluate the function. One row for each\n            data points.\n\n        Returns\n        -------\n        values : ndarray\n            The function values at the points.\n\n        \"\"\"", "\n", "nodes", "=", "self", ".", "discretization", ".", "state_to_index", "(", "points", ")", "\n", "return", "self", ".", "parameters", "[", "nodes", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.PiecewiseConstant.parameter_derivative": [[889, 914], ["len", "numpy.ones", "numpy.arange", "functions.PiecewiseConstant.discretization.state_to_index", "scipy.sparse.coo_matrix"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index"], ["", "def", "parameter_derivative", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"\n        Obtain function values at points from triangulation.\n\n        This function returns a sparse matrix that, when multiplied\n        with the vector with all the function values on the vertices,\n        returns the function values at points.\n\n        Parameters\n        ----------\n        points : ndarray\n            A 2d array where each row represents one point.\n\n        Returns\n        -------\n        values\n            A sparse matrix B so that evaluate(points) = B.dot(parameters).\n\n        \"\"\"", "\n", "npoints", "=", "len", "(", "points", ")", "\n", "weights", "=", "np", ".", "ones", "(", "npoints", ",", "dtype", "=", "np", ".", "int", ")", "\n", "rows", "=", "np", ".", "arange", "(", "npoints", ")", "\n", "cols", "=", "self", ".", "discretization", ".", "state_to_index", "(", "points", ")", "\n", "return", "sparse", ".", "coo_matrix", "(", "(", "weights", ",", "(", "rows", ",", "cols", ")", ")", ",", "\n", "shape", "=", "(", "npoints", ",", "self", ".", "nindex", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.PiecewiseConstant.gradient": [[915, 933], ["numpy.broadcast_to", "len"], "methods", ["None"], ["", "def", "gradient", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Return the gradient.\n\n        The gradient is always zero for piecewise constant functions!\n\n        Parameters\n        ----------\n        points : ndarray\n            The points at which to evaluate the function. One row for each\n            data points.\n\n        Returns\n        -------\n        gradient : ndarray\n            The function gradient at the points.\n\n        \"\"\"", "\n", "return", "np", ".", "broadcast_to", "(", "0", ",", "(", "len", "(", "points", ")", ",", "self", ".", "input_dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Delaunay1D.__init__": [[945, 959], ["numpy.min", "numpy.max", "numpy.array", "AttributeError", "AttributeError", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Initialization, see `_Delaunay1D`.\"\"\"", "\n", "if", "points", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "            ", "raise", "AttributeError", "(", "'This only works for 1D inputs.'", ")", "\n", "", "if", "points", ".", "shape", "[", "0", "]", ">", "2", ":", "\n", "            ", "raise", "AttributeError", "(", "'This only works for two points'", ")", "\n", "\n", "", "self", ".", "points", "=", "points", "\n", "self", ".", "nsimplex", "=", "len", "(", "points", ")", "-", "1", "\n", "\n", "self", ".", "_min", "=", "np", ".", "min", "(", "points", ")", "\n", "self", ".", "_max", "=", "np", ".", "max", "(", "points", ")", "\n", "\n", "self", ".", "simplices", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Delaunay1D.find_simplex": [[960, 979], ["points.squeeze.squeeze.squeeze", "numpy.where"], "methods", ["None"], ["", "def", "find_simplex", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Find the simplices containing the given points.\n\n        Parameters\n        ----------\n        points : ndarray\n            2D array of coordinates of points for which to find simplices.\n\n        Returns\n        -------\n        indices : ndarray\n            Indices of simplices containing each point. Points outside the\n            triangulation get the value -1.\n\n        \"\"\"", "\n", "points", "=", "points", ".", "squeeze", "(", ")", "\n", "out_of_bounds", "=", "points", ">", "self", ".", "_max", "\n", "out_of_bounds", "|=", "points", "<", "self", ".", "_min", "\n", "return", "np", ".", "where", "(", "out_of_bounds", ",", "-", "1", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.__init__": [[1002, 1033], ["functions.DeterministicFunction.__init__", "functions._Triangulation._triangulation_simplex_indices", "functions._Triangulation._update_hyperplanes", "len", "numpy.array", "functions._Delaunay1D", "itertools.product", "numpy.array", "scipy.spatial.Delaunay", "list", "numpy.diag"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._triangulation_simplex_indices", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._update_hyperplanes"], ["def", "__init__", "(", "self", ",", "discretization", ",", "vertex_values", "=", "None", ",", "project", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization.\"\"\"", "\n", "super", "(", "_Triangulation", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "discretization", "=", "discretization", "\n", "self", ".", "input_dim", "=", "discretization", ".", "ndim", "\n", "\n", "self", ".", "_parameters", "=", "None", "\n", "self", ".", "parameters", "=", "vertex_values", "\n", "\n", "disc", "=", "self", ".", "discretization", "\n", "\n", "# Get triangulation", "\n", "if", "len", "(", "disc", ".", "limits", ")", "==", "1", ":", "\n", "            ", "corners", "=", "np", ".", "array", "(", "[", "[", "0", "]", ",", "disc", ".", "unit_maxes", "]", ")", "\n", "self", ".", "triangulation", "=", "_Delaunay1D", "(", "corners", ")", "\n", "", "else", ":", "\n", "            ", "product", "=", "cartesian", "(", "*", "np", ".", "diag", "(", "disc", ".", "unit_maxes", ")", ")", "\n", "hyperrectangle_corners", "=", "np", ".", "array", "(", "list", "(", "product", ")", ",", "\n", "dtype", "=", "config", ".", "np_dtype", ")", "\n", "self", ".", "triangulation", "=", "spatial", ".", "Delaunay", "(", "hyperrectangle_corners", ")", "\n", "", "self", ".", "unit_simplices", "=", "self", ".", "_triangulation_simplex_indices", "(", ")", "\n", "\n", "# Some statistics about the triangulation", "\n", "self", ".", "nsimplex", "=", "self", ".", "triangulation", ".", "nsimplex", "*", "disc", ".", "nrectangles", "\n", "\n", "# Parameters for the hyperplanes of the triangulation", "\n", "self", ".", "hyperplanes", "=", "None", "\n", "self", ".", "_update_hyperplanes", "(", ")", "\n", "\n", "self", ".", "project", "=", "project", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.output_dim": [[1034, 1039], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the output dimensions of the function.\"\"\"", "\n", "if", "self", ".", "parameters", "is", "not", "None", ":", "\n", "            ", "return", "self", ".", "parameters", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.parameters": [[1045, 1053], ["numpy.asarray().reshape", "numpy.asarray"], "methods", ["None"], ["", "@", "parameters", ".", "setter", "\n", "def", "parameters", "(", "self", ",", "values", ")", ":", "\n", "        ", "\"\"\"Set the vertex values.\"\"\"", "\n", "if", "values", "is", "None", ":", "\n", "            ", "self", ".", "_parameters", "=", "values", "\n", "", "else", ":", "\n", "            ", "values", "=", "np", ".", "asarray", "(", "values", ")", ".", "reshape", "(", "self", ".", "nindex", ",", "-", "1", ")", "\n", "self", ".", "_parameters", "=", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.limits": [[1054, 1058], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "limits", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the discretization limits.\"\"\"", "\n", "return", "self", ".", "discretization", ".", "limits", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.nindex": [[1059, 1063], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "nindex", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of discretization indices.\"\"\"", "\n", "return", "self", ".", "discretization", ".", "nindex", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._triangulation_simplex_indices": [[1064, 1089], ["numpy.empty_like", "disc.state_to_index", "enumerate"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index"], ["", "def", "_triangulation_simplex_indices", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the simplex indices in our coordinates.\n\n        Returns\n        -------\n        simplices: ndarray (int)\n            The simplices array in our extended coordinate system.\n\n        Notes\n        -----\n        This is only used once in the initialization.\n\n        \"\"\"", "\n", "disc", "=", "self", ".", "discretization", "\n", "simplices", "=", "self", ".", "triangulation", ".", "simplices", "\n", "new_simplices", "=", "np", ".", "empty_like", "(", "simplices", ")", "\n", "\n", "# Convert the points to out indices", "\n", "index_mapping", "=", "disc", ".", "state_to_index", "(", "self", ".", "triangulation", ".", "points", "+", "\n", "disc", ".", "offset", ")", "\n", "\n", "# Replace each index with out new_index in index_mapping", "\n", "for", "i", ",", "new_index", "in", "enumerate", "(", "index_mapping", ")", ":", "\n", "            ", "new_simplices", "[", "simplices", "==", "i", "]", "=", "new_index", "\n", "", "return", "new_simplices", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._update_hyperplanes": [[1090, 1102], ["numpy.empty", "enumerate", "functions._Triangulation.discretization.index_to_state", "numpy.linalg.inv"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state"], ["", "def", "_update_hyperplanes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compute the simplex hyperplane parameters on the triangulation.\"\"\"", "\n", "self", ".", "hyperplanes", "=", "np", ".", "empty", "(", "(", "self", ".", "triangulation", ".", "nsimplex", ",", "\n", "self", ".", "input_dim", ",", "self", ".", "input_dim", ")", ",", "\n", "dtype", "=", "config", ".", "np_dtype", ")", "\n", "\n", "# Use that the bottom-left rectangle has the index zero, so that the", "\n", "# index numbers of scipy correspond to ours.", "\n", "for", "i", ",", "simplex", "in", "enumerate", "(", "self", ".", "unit_simplices", ")", ":", "\n", "            ", "simplex_points", "=", "self", ".", "discretization", ".", "index_to_state", "(", "simplex", ")", "\n", "self", ".", "hyperplanes", "[", "i", "]", "=", "np", ".", "linalg", ".", "inv", "(", "simplex_points", "[", "1", ":", "]", "-", "\n", "simplex_points", "[", ":", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex": [[1103, 1131], ["disc.state_to_rectangle", "disc._center_states", "functions._Triangulation.triangulation.find_simplex", "numpy.atleast_1d"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_rectangle", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld._center_states", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex"], ["", "", "def", "find_simplex", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Find the simplices corresponding to points.\n\n        Parameters\n        ----------\n        points : 2darray\n\n        Returns\n        -------\n        simplices : np.array (int)\n            The indices of the simplices\n\n        \"\"\"", "\n", "disc", "=", "self", ".", "discretization", "\n", "rectangles", "=", "disc", ".", "state_to_rectangle", "(", "points", ")", "\n", "\n", "# Convert to unit coordinates", "\n", "points", "=", "disc", ".", "_center_states", "(", "points", ",", "clip", "=", "True", ")", "\n", "\n", "# Convert to basic hyperrectangle coordinates and find simplex", "\n", "unit_coordinates", "=", "points", "%", "disc", ".", "unit_maxes", "\n", "simplex_ids", "=", "self", ".", "triangulation", ".", "find_simplex", "(", "unit_coordinates", ")", "\n", "simplex_ids", "=", "np", ".", "atleast_1d", "(", "simplex_ids", ")", "\n", "\n", "# Adjust for the hyperrectangle index", "\n", "simplex_ids", "+=", "rectangles", "*", "self", ".", "triangulation", ".", "nsimplex", "\n", "\n", "return", "simplex_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.simplices": [[1132, 1159], ["numpy.remainder", "functions._Triangulation.unit_simplices[].copy", "numpy.floor_divide", "functions._Triangulation.discretization.rectangle_corner_index"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.rectangle_corner_index"], ["", "def", "simplices", "(", "self", ",", "indices", ")", ":", "\n", "        ", "\"\"\"Return the simplices corresponding to the simplex index.\n\n        Parameters\n        ----------\n        indices : ndarray\n            The indices of the simpleces\n\n        Returns\n        -------\n        simplices : ndarray\n            Each row consists of the indices of the simplex corners.\n\n        \"\"\"", "\n", "# Get the indices inside the unit rectangle", "\n", "unit_indices", "=", "np", ".", "remainder", "(", "indices", ",", "self", ".", "triangulation", ".", "nsimplex", ")", "\n", "simplices", "=", "self", ".", "unit_simplices", "[", "unit_indices", "]", ".", "copy", "(", ")", "\n", "\n", "# Shift indices to corresponding rectangle", "\n", "rectangles", "=", "np", ".", "floor_divide", "(", "indices", ",", "self", ".", "triangulation", ".", "nsimplex", ")", "\n", "corner_index", "=", "self", ".", "discretization", ".", "rectangle_corner_index", "(", "rectangles", ")", "\n", "\n", "if", "simplices", ".", "ndim", ">", "1", ":", "\n", "            ", "corner_index", "=", "corner_index", "[", ":", ",", "None", "]", "\n", "\n", "", "simplices", "+=", "corner_index", "\n", "return", "simplices", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._get_weights": [[1160, 1203], ["functions._Triangulation.find_simplex", "functions._Triangulation.simplices", "disc.index_to_state", "len", "numpy.empty", "numpy.sum", "numpy.clip", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.simplices", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state"], ["", "def", "_get_weights", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Return the linear weights associated with points.\n\n        Parameters\n        ----------\n        points : 2d array\n            Each row represents one point\n\n        Returns\n        -------\n        weights : ndarray\n            An array that contains the linear weights for each point.\n        simplices : ndarray\n            The indices of the simplices associated with each points\n\n        \"\"\"", "\n", "disc", "=", "self", ".", "discretization", "\n", "simplex_ids", "=", "self", ".", "find_simplex", "(", "points", ")", "\n", "\n", "simplices", "=", "self", ".", "simplices", "(", "simplex_ids", ")", "\n", "origins", "=", "disc", ".", "index_to_state", "(", "simplices", "[", ":", ",", "0", "]", ")", "\n", "\n", "# Get hyperplane equations", "\n", "simplex_ids", "%=", "self", ".", "triangulation", ".", "nsimplex", "\n", "hyperplanes", "=", "self", ".", "hyperplanes", "[", "simplex_ids", "]", "\n", "\n", "# Some numbers for convenience", "\n", "nsimp", "=", "self", ".", "input_dim", "+", "1", "\n", "npoints", "=", "len", "(", "points", ")", "\n", "\n", "if", "self", ".", "project", ":", "\n", "            ", "points", "=", "np", ".", "clip", "(", "points", ",", "disc", ".", "limits", "[", ":", ",", "0", "]", ",", "disc", ".", "limits", "[", ":", ",", "1", "]", ")", "\n", "\n", "", "weights", "=", "np", ".", "empty", "(", "(", "npoints", ",", "nsimp", ")", ",", "dtype", "=", "config", ".", "np_dtype", ")", "\n", "\n", "# Pre-multiply each hyperplane by (point - origin)", "\n", "offset", "=", "points", "-", "origins", "\n", "np", ".", "sum", "(", "offset", "[", ":", ",", ":", ",", "None", "]", "*", "hyperplanes", ",", "axis", "=", "1", ",", "out", "=", "weights", "[", ":", ",", "1", ":", "]", ")", "\n", "\n", "# The weights have to add up to one", "\n", "weights", "[", ":", ",", "0", "]", "=", "1", "-", "np", ".", "sum", "(", "weights", "[", ":", ",", "1", ":", "]", ",", "axis", "=", "1", ")", "\n", "\n", "return", "weights", ",", "simplices", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.build_evaluation": [[1204, 1227], ["numpy.atleast_2d", "functions._Triangulation._get_weights", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._get_weights"], ["", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Return the function values.\n\n        Parameters\n        ----------\n        points : ndarray\n            The points at which to evaluate the function. One row for each\n            data points.\n\n        Returns\n        -------\n        values : ndarray\n            The function values at the points.\n\n        \"\"\"", "\n", "points", "=", "np", ".", "atleast_2d", "(", "points", ")", "\n", "weights", ",", "simplices", "=", "self", ".", "_get_weights", "(", "points", ")", "\n", "\n", "# Return function values", "\n", "parameter_vector", "=", "self", ".", "parameters", "[", "simplices", "]", "\n", "\n", "# Broadcast the weights along output dimensions", "\n", "return", "np", ".", "sum", "(", "weights", "[", ":", ",", ":", ",", "None", "]", "*", "parameter_vector", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.parameter_derivative": [[1228, 1260], ["numpy.atleast_2d", "functions._Triangulation._get_weights", "len", "numpy.repeat", "simplices.ravel", "scipy.sparse.coo_matrix", "numpy.arange", "len", "weights.ravel"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._get_weights"], ["", "def", "parameter_derivative", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"\n        Obtain function values at points from triangulation.\n\n        This function returns a sparse matrix that, when multiplied\n        with the vector with all the function values on the vertices,\n        returns the function values at points.\n\n        Parameters\n        ----------\n        points : 2d array\n            Each row represents one point.\n\n        Returns\n        -------\n        values\n            A sparse matrix B so that evaluate(points) = B.dot(parameters).\n\n        \"\"\"", "\n", "points", "=", "np", ".", "atleast_2d", "(", "points", ")", "\n", "weights", ",", "simplices", "=", "self", ".", "_get_weights", "(", "points", ")", "\n", "# Construct sparse matrix for optimization", "\n", "\n", "nsimp", "=", "self", ".", "input_dim", "+", "1", "\n", "npoints", "=", "len", "(", "simplices", ")", "\n", "# Indices of constraints (nsimp points per simplex, so we have nsimp", "\n", "# values in each row; one for each simplex)", "\n", "rows", "=", "np", ".", "repeat", "(", "np", ".", "arange", "(", "len", "(", "points", ")", ")", ",", "nsimp", ")", "\n", "cols", "=", "simplices", ".", "ravel", "(", ")", "\n", "\n", "return", "sparse", ".", "coo_matrix", "(", "(", "weights", ".", "ravel", "(", ")", ",", "(", "rows", ",", "cols", ")", ")", ",", "\n", "shape", "=", "(", "npoints", ",", "self", ".", "discretization", ".", "nindex", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._get_weights_gradient": [[1261, 1301], ["functions._Triangulation.simplices", "len", "numpy.empty", "numpy.atleast_1d", "numpy.sum", "functions._Triangulation.find_simplex", "TypeError"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.simplices", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex"], ["", "def", "_get_weights_gradient", "(", "self", ",", "points", "=", "None", ",", "indices", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the linear gradient weights associated with points.\n\n        Parameters\n        ----------\n        points : ndarray\n            Each row represents one point.\n        indices : ndarray\n            Each row represents one index. Ignored if points\n\n        Returns\n        -------\n        weights : ndarray\n            An array that contains the linear weights for each point.\n        simplices : ndarray\n            The indices of the simplices associated with each points\n\n        \"\"\"", "\n", "if", "points", "is", "None", ":", "\n", "            ", "simplex_ids", "=", "np", ".", "atleast_1d", "(", "indices", ")", "\n", "", "elif", "indices", "is", "None", ":", "\n", "            ", "simplex_ids", "=", "self", ".", "find_simplex", "(", "points", ")", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'Need to provide at least one input argument.'", ")", "\n", "", "simplices", "=", "self", ".", "simplices", "(", "simplex_ids", ")", "\n", "\n", "# Get hyperplane equations", "\n", "simplex_ids", "%=", "self", ".", "triangulation", ".", "nsimplex", "\n", "\n", "# Some numbers for convenience", "\n", "nsimp", "=", "self", ".", "input_dim", "+", "1", "\n", "npoints", "=", "len", "(", "simplex_ids", ")", "\n", "\n", "# weights", "\n", "weights", "=", "np", ".", "empty", "(", "(", "npoints", ",", "self", ".", "input_dim", ",", "nsimp", ")", ",", "\n", "dtype", "=", "config", ".", "np_dtype", ")", "\n", "\n", "weights", "[", ":", ",", ":", ",", "1", ":", "]", "=", "self", ".", "hyperplanes", "[", "simplex_ids", "]", "\n", "weights", "[", ":", ",", ":", ",", "0", "]", "=", "-", "np", ".", "sum", "(", "weights", "[", ":", ",", ":", ",", "1", ":", "]", ",", "axis", "=", "2", ")", "\n", "return", "weights", ",", "simplices", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.gradient": [[1302, 1327], ["numpy.atleast_2d", "functions._Triangulation._get_weights_gradient", "numpy.einsum", "res.squeeze.squeeze.squeeze"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._get_weights_gradient"], ["", "def", "gradient", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Return the gradient.\n\n        Parameters\n        ----------\n        points : ndarray\n            The points at which to evaluate the function. One row for each\n            data points.\n\n        Returns\n        -------\n        gradient : ndarray\n            The function gradient at the points. A 3D array with the gradient\n            at the i-th data points for the j-th output with regard to the k-th\n            dimension stored at (i, j, k). The j-th dimension is squeezed out\n            for 1D functions.\n\n        \"\"\"", "\n", "points", "=", "np", ".", "atleast_2d", "(", "points", ")", "\n", "weights", ",", "simplices", "=", "self", ".", "_get_weights_gradient", "(", "points", ")", "\n", "# Return function values if desired", "\n", "res", "=", "np", ".", "einsum", "(", "'ijk,ikl->ilj'", ",", "weights", ",", "self", ".", "parameters", "[", "simplices", ",", ":", "]", ")", "\n", "if", "res", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "            ", "res", "=", "res", ".", "squeeze", "(", "axis", "=", "1", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.gradient_parameter_derivative": [[1328, 1370], ["functions._Triangulation._get_weights_gradient", "len", "numpy.repeat", "numpy.tile().ravel", "scipy.sparse.coo_matrix", "numpy.arange", "numpy.tile", "weights.ravel"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation._get_weights_gradient"], ["", "def", "gradient_parameter_derivative", "(", "self", ",", "points", "=", "None", ",", "indices", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Return the gradients at the respective points.\n\n        This function returns a sparse matrix that, when multiplied\n        with the vector of all the function values on the vertices,\n        returns the gradients. Note that after the product you have to call\n        ```np.reshape(grad, (ndim, -1))``` in order to obtain a proper\n        gradient matrix.\n\n        Parameters\n        ----------\n        points : ndarray\n            Each row contains one state at which to evaluate the gradient.\n        indices : ndarray\n            The simplex indices. Ignored if points are provided.\n\n        Returns\n        -------\n        gradient : scipy.sparse.coo_matrix\n            A sparse matrix so that\n            `grad(points) = B.dot(vertex_val).reshape(ndim, -1)` corresponds\n            to the true gradients\n\n        \"\"\"", "\n", "weights", ",", "simplices", "=", "self", ".", "_get_weights_gradient", "(", "points", "=", "points", ",", "\n", "indices", "=", "indices", ")", "\n", "\n", "# Some numbers for convenience", "\n", "nsimp", "=", "self", ".", "input_dim", "+", "1", "\n", "npoints", "=", "len", "(", "simplices", ")", "\n", "\n", "# Construct sparse matrix for optimization", "\n", "\n", "# Indices of constraints (ndim gradients for each point, which each", "\n", "# depend on the nsimp vertices of the simplex.", "\n", "rows", "=", "np", ".", "repeat", "(", "np", ".", "arange", "(", "npoints", "*", "self", ".", "input_dim", ")", ",", "nsimp", ")", "\n", "cols", "=", "np", ".", "tile", "(", "simplices", ",", "(", "1", ",", "self", ".", "input_dim", ")", ")", ".", "ravel", "(", ")", "\n", "\n", "return", "sparse", ".", "coo_matrix", "(", "(", "weights", ".", "ravel", "(", ")", ",", "(", "rows", ",", "cols", ")", ")", ",", "\n", "shape", "=", "(", "self", ".", "input_dim", "*", "npoints", ",", "\n", "self", ".", "discretization", ".", "nindex", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation.__init__": [[1397, 1421], ["functions.DeterministicFunction.__init__", "tensorflow.variable_scope", "functions._Triangulation", "tensorflow.Variable", "tensorflow.get_default_session", "isinstance", "functions.Triangulation.tri.parameters.astype", "tensorflow.variables_initializer", "tensorflow.get_default_session().run", "tensorflow.get_default_session"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "discretization", ",", "vertex_values", ",", "project", "=", "False", ",", "\n", "name", "=", "'triangulation'", ")", ":", "\n", "        ", "\"\"\"Initialization.\"\"\"", "\n", "super", "(", "Triangulation", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope_name", ")", ":", "\n", "            ", "self", ".", "tri", "=", "_Triangulation", "(", "discretization", ",", "\n", "project", "=", "project", ")", "\n", "\n", "# Make sure the variable has the correct size", "\n", "if", "not", "isinstance", "(", "vertex_values", ",", "tf", ".", "Variable", ")", ":", "\n", "                ", "self", ".", "tri", ".", "parameters", "=", "vertex_values", "\n", "vertex_values", "=", "self", ".", "tri", ".", "parameters", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "", "vertex_values", "=", "tf", ".", "Variable", "(", "vertex_values", ",", "\n", "name", "=", "'vertex_values'", ")", "\n", "\n", "# Initialize parameters", "\n", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "if", "sess", "is", "not", "None", ":", "\n", "                ", "init", "=", "tf", ".", "variables_initializer", "(", "self", ".", "parameters", ")", "\n", "tf", ".", "get_default_session", "(", ")", ".", "run", "(", "init", ")", "\n", "\n", "", "self", ".", "input_dim", "=", "self", ".", "tri", ".", "input_dim", "\n", "self", ".", "output_dim", "=", "self", ".", "tri", ".", "output_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation.project": [[1427, 1431], ["None"], "methods", ["None"], ["", "@", "project", ".", "setter", "\n", "def", "project", "(", "self", ",", "value", ")", ":", "\n", "        ", "\"\"\"Setter for the project parameter.\"\"\"", "\n", "self", ".", "tri", ".", "project", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation.discretization": [[1432, 1436], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "discretization", "(", "self", ")", ":", "\n", "        ", "\"\"\"Getter for the discretization.\"\"\"", "\n", "return", "self", ".", "tri", ".", "discretization", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation.nindex": [[1437, 1441], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "nindex", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the number of parameters.\"\"\"", "\n", "return", "self", ".", "tri", ".", "nindex", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation._get_hyperplanes": [[1442, 1472], ["utilities.make_tf_fun", "functions.Triangulation.tri.find_simplex", "functions.Triangulation.tri.simplices().astype", "functions.Triangulation.tri.discretization.index_to_state", "functions.Triangulation.tri.simplices"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.make_tf_fun", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.simplices"], ["", "@", "make_tf_fun", "(", "[", "config", ".", "dtype", ",", "config", ".", "dtype", ",", "tf", ".", "int64", "]", ",", "stateful", "=", "False", ")", "\n", "def", "_get_hyperplanes", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Return the linear weights associated with points.\n\n        Parameters\n        ----------\n        points : 2d array\n            Each row represents one point\n\n        Returns\n        -------\n        weights : ndarray\n            An array that contains the linear weights for each point.\n        hyperplanes : ndarray\n            The corresponding hyperplane objects.\n        simplices : ndarray\n            The indices of the simplices associated with each points\n\n        \"\"\"", "\n", "simplex_ids", "=", "self", ".", "tri", ".", "find_simplex", "(", "points", ")", "\n", "\n", "simplices", "=", "self", ".", "tri", ".", "simplices", "(", "simplex_ids", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "origins", "=", "self", ".", "tri", ".", "discretization", ".", "index_to_state", "(", "simplices", "[", ":", ",", "0", "]", ")", "\n", "\n", "# Get hyperplane equations", "\n", "simplex_ids", "%=", "self", ".", "tri", ".", "triangulation", ".", "nsimplex", "\n", "hyperplanes", "=", "self", ".", "tri", ".", "hyperplanes", "[", "simplex_ids", "]", "\n", "\n", "# Pre-multiply each hyperplane by (point - origin)", "\n", "return", "origins", ",", "hyperplanes", ",", "simplices", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation.build_evaluation": [[1473, 1500], ["functions.Triangulation._get_hyperplanes", "tensorflow.reduce_sum", "tensorflow.concat", "tensorflow.gather", "tensorflow.reduce_sum", "tensorflow.minimum", "tensorflow.reduce_sum", "tensorflow.maximum"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation._get_hyperplanes"], ["", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Evaluate using tensorflow.\"\"\"", "\n", "# Get the appropriate hyperplane", "\n", "origins", ",", "hyperplanes", ",", "simplices", "=", "self", ".", "_get_hyperplanes", "(", "points", ")", "\n", "\n", "# Project points onto the grid of triangles.", "\n", "if", "self", ".", "project", ":", "\n", "            ", "clip_min", "=", "self", ".", "tri", ".", "limits", "[", ":", ",", "0", "]", "\n", "clip_max", "=", "self", ".", "tri", ".", "limits", "[", ":", ",", "1", "]", "\n", "\n", "# Broadcasting in tf.clip_by_value not available in", "\n", "# TensorFlow >= 1.6.0", "\n", "points", "=", "tf", ".", "minimum", "(", "tf", ".", "maximum", "(", "points", ",", "clip_min", ")", ",", "clip_max", ")", "\n", "\n", "# Compute weights (barycentric coordinates)", "\n", "", "offset", "=", "points", "-", "origins", "\n", "w1", "=", "tf", ".", "reduce_sum", "(", "offset", "[", ":", ",", ":", ",", "None", "]", "*", "hyperplanes", ",", "axis", "=", "1", ")", "\n", "w0", "=", "1", "-", "tf", ".", "reduce_sum", "(", "w1", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "weights", "=", "tf", ".", "concat", "(", "(", "w0", ",", "w1", ")", ",", "axis", "=", "1", ")", "\n", "\n", "# Collect the value on the vertices", "\n", "parameter_vector", "=", "tf", ".", "gather", "(", "self", ".", "parameters", "[", "0", "]", ",", "\n", "indices", "=", "simplices", ",", "\n", "validate_indices", "=", "False", ")", "\n", "\n", "# Compute the values", "\n", "return", "tf", ".", "reduce_sum", "(", "weights", "[", ":", ",", ":", ",", "None", "]", "*", "parameter_vector", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation._get_gradients": [[1501, 1505], ["utilities.make_tf_fun", "functions.Triangulation.tri.gradient"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.make_tf_fun", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.gradient"], ["", "@", "make_tf_fun", "(", "[", "config", ".", "dtype", "]", ",", "stateful", "=", "False", ")", "\n", "def", "_get_gradients", "(", "self", ",", "points", ",", "parameters", ")", ":", "\n", "        ", "self", ".", "tri", ".", "parameters", "=", "parameters", "\n", "return", "self", ".", "tri", ".", "gradient", "(", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation.gradient": [[1506, 1511], ["utilities.with_scope", "functions.Triangulation._get_gradients"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Triangulation._get_gradients"], ["", "@", "use_parent_scope", "\n", "@", "with_scope", "(", "'derivative'", ")", "\n", "def", "gradient", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Compute derivatives using tensorflow.\"\"\"", "\n", "return", "self", ".", "_get_gradients", "(", "points", ",", "self", ".", "parameters", "[", "0", "]", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.__init__": [[1525, 1531], ["functions.DeterministicFunction.__init__", "numpy.atleast_2d().astype", "numpy.atleast_2d"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "matrix", ",", "name", "=", "'quadratic'", ")", ":", "\n", "        ", "\"\"\"Initialization, see `QuadraticLyapunovFunction`.\"\"\"", "\n", "super", "(", "QuadraticFunction", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "\n", "self", ".", "matrix", "=", "np", ".", "atleast_2d", "(", "matrix", ")", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "self", ".", "ndim", "=", "self", ".", "matrix", ".", "shape", "[", "0", "]", "\n", "# with tf.variable_scope(self.scope_name):", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.build_evaluation": [[1534, 1540], ["utilities.concatenate_inputs", "tensorflow.matmul", "tensorflow.reduce_sum"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs"], ["", "@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Like evaluate, but returns a tensorflow tensor instead.\"\"\"", "\n", "linear_form", "=", "tf", ".", "matmul", "(", "points", ",", "self", ".", "matrix", ")", "\n", "quadratic", "=", "linear_form", "*", "points", "\n", "return", "tf", ".", "reduce_sum", "(", "quadratic", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.gradient": [[1541, 1544], ["tensorflow.matmul"], "methods", ["None"], ["", "def", "gradient", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Return the gradient of the function.\"\"\"", "\n", "return", "tf", ".", "matmul", "(", "points", ",", "self", ".", "matrix", "+", "self", ".", "matrix", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.LinearSystem.__init__": [[1559, 1566], ["functions.DeterministicFunction.__init__", "numpy.hstack", "numpy.atleast_2d().astype", "map", "numpy.atleast_2d"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "matrices", ",", "name", "=", "'linear_system'", ")", ":", "\n", "        ", "\"\"\"Initialize.\"\"\"", "\n", "super", "(", "LinearSystem", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "fun", "=", "lambda", "x", ":", "np", ".", "atleast_2d", "(", "x", ")", ".", "astype", "(", "config", ".", "np_dtype", ")", "\n", "self", ".", "matrix", "=", "np", ".", "hstack", "(", "map", "(", "fun", ",", "matrices", ")", ")", "\n", "\n", "self", ".", "output_dim", ",", "self", ".", "input_dim", "=", "self", ".", "matrix", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.LinearSystem.build_evaluation": [[1567, 1584], ["utilities.concatenate_inputs", "tensorflow.matmul"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs"], ["", "@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Return the function values.\n\n        Parameters\n        ----------\n        points : ndarray\n            The points at which to evaluate the function. One row for each\n            data points.\n\n        Returns\n        -------\n        values : tf.Tensor\n            A 2D array with the function values at the points.\n\n        \"\"\"", "\n", "return", "tf", ".", "matmul", "(", "points", ",", "self", ".", "matrix", ".", "T", ",", "transpose_b", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.NeuralNetwork.__init__": [[1689, 1701], ["functions.DeterministicFunction.__init__"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ",", "layers", ",", "nonlinearities", ",", "output_scale", "=", "1.", ",", "use_bias", "=", "True", ",", "\n", "name", "=", "'neural_network'", ")", ":", "\n", "        ", "\"\"\"Initialization, see `NeuralNetwork`.\"\"\"", "\n", "super", "(", "NeuralNetwork", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "\n", "self", ".", "layers", "=", "layers", "\n", "self", ".", "nonlinearities", "=", "nonlinearities", "\n", "self", ".", "output_scale", "=", "output_scale", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "\n", "self", ".", "input_dim", "=", "layers", "[", "0", "]", "\n", "self", ".", "output_dim", "=", "layers", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.NeuralNetwork.build_evaluation": [[1702, 1730], ["isinstance", "tensorflow.contrib.layers.xavier_initializer", "enumerate", "tensorflow.layers.dense", "tensorflow.multiply", "tensorflow.constant", "future.builtins.zip", "tensorflow.layers.dense"], "methods", ["None"], ["", "def", "build_evaluation", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Build the evaluation graph.\"\"\"", "\n", "net", "=", "points", "\n", "if", "isinstance", "(", "net", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "net", "=", "tf", ".", "constant", "(", "net", ")", "\n", "\n", "", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", "\n", "\n", "for", "i", ",", "(", "layer", ",", "activation", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "layers", "[", ":", "-", "1", "]", ",", "\n", "self", ".", "nonlinearities", "[", ":", "-", "1", "]", ")", ")", ":", "\n", "            ", "net", "=", "tf", ".", "layers", ".", "dense", "(", "net", ",", "\n", "units", "=", "layer", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "self", ".", "use_bias", ",", "\n", "kernel_initializer", "=", "initializer", ",", "\n", "name", "=", "'layer_{}'", ".", "format", "(", "i", ")", ")", "\n", "\n", "# Output layer", "\n", "", "net", "=", "tf", ".", "layers", ".", "dense", "(", "net", ",", "\n", "units", "=", "self", ".", "layers", "[", "-", "1", "]", ",", "\n", "activation", "=", "self", ".", "nonlinearities", "[", "-", "1", "]", ",", "\n", "use_bias", "=", "False", ",", "\n", "kernel_initializer", "=", "initializer", ",", "\n", "name", "=", "'output'", ")", "\n", "\n", "# Scale output range", "\n", "out", "=", "tf", ".", "multiply", "(", "net", ",", "self", ".", "output_scale", ",", "name", "=", "'output_scale'", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.NeuralNetwork._parameter_iter": [[1731, 1741], ["iter", "future.builtins.zip"], "methods", ["None"], ["", "def", "_parameter_iter", "(", "self", ")", ":", "\n", "        ", "\"\"\"Iterate over parameters in (W, b) tuples.\"\"\"", "\n", "# By defining parameters as an iterable zip(parameters, parameters)", "\n", "# returns the next two elements as a group.", "\n", "parameters", "=", "iter", "(", "self", ".", "parameters", ")", "\n", "for", "W", ",", "b", "in", "zip", "(", "parameters", ",", "parameters", ")", ":", "\n", "            ", "yield", "W", ",", "b", "\n", "\n", "# Yield parameters of the output layer", "\n", "", "yield", "self", ".", "parameters", "[", "-", "1", "]", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.NeuralNetwork.lipschitz": [[1742, 1763], ["utilities.with_scope", "tensorflow.constant", "functions.NeuralNetwork._parameter_iter", "tensorflow.reduce_max", "functions.NeuralNetwork._svd"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.NeuralNetwork._parameter_iter", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.NeuralNetwork._svd"], ["", "@", "use_parent_scope", "\n", "@", "with_scope", "(", "'lipschitz_constant'", ")", "\n", "def", "lipschitz", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the Lipschitz constant as a Tensor.\n\n        This assumes that only contractive nonlinearities are used! Examples\n        are ReLUs and Sigmoids.\n\n        Returns\n        -------\n        lipschitz : Tensor\n            The Lipschitz constant of the neural network.\n\n        \"\"\"", "\n", "lipschitz", "=", "tf", ".", "constant", "(", "1", ",", "config", ".", "dtype", ")", "\n", "\n", "for", "W", ",", "b", "in", "self", ".", "_parameter_iter", "(", ")", ":", "\n", "# lipschitz *= tf.reduce_max(tf.svd(W, compute_uv=False))", "\n", "            ", "lipschitz", "*=", "tf", ".", "reduce_max", "(", "self", ".", "_svd", "(", "W", ")", ")", "\n", "\n", "", "return", "lipschitz", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.NeuralNetwork._svd": [[1764, 1787], ["map", "tensorflow.matmul", "tensorflow.matrix_diag_part", "tensorflow.svd", "tensorflow.matmul"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_svd", "(", "A", ",", "name", "=", "None", ")", ":", "\n", "        ", "\"\"\"Tensorflow svd with gradient.\n\n        Parameters\n        ----------\n        A : Tensor\n            The matrix for which to compute singular values.\n        name : string, optional\n\n        Returns\n        -------\n        s : Tensor\n            The singular values of A.\n\n        \"\"\"", "\n", "S0", ",", "U0", ",", "V0", "=", "map", "(", "tf", ".", "stop_gradient", ",", "\n", "tf", ".", "svd", "(", "A", ",", "full_matrices", "=", "True", ",", "name", "=", "name", ")", ")", "\n", "# A = U * S * V.T", "\n", "# S = inv(U) * A * inv(V.T) = U.T * A * V  (orthogonal matrices)", "\n", "S", "=", "tf", ".", "matmul", "(", "U0", ",", "tf", ".", "matmul", "(", "A", ",", "V0", ")", ",", "\n", "transpose_a", "=", "True", ")", "\n", "return", "tf", ".", "matrix_diag_part", "(", "S", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.sample_gp_function": [[1586, 1663], ["utilities.with_scope", "isinstance", "tensorflow.get_default_session", "tf.get_default_session.run", "mean.squeeze.squeeze", "cov.squeeze.squeeze", "numpy.random.multivariate_normal", "scipy.linalg.cho_factor", "utilities.concatenate_inputs", "future.builtins.range", "gp.tf_mode", "gp.build_predict", "numpy.eye", "scipy.linalg.cho_solve", "functools.partial", "functions.append", "len", "gp.tf_mode", "gp.kern.K", "gp.mean_function", "tensorflow.matmul", "tensorflow.sqrt", "tensorflow.random_normal", "tensorflow.shape"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GPRCached.build_predict"], ["", "", "@", "with_scope", "(", "'sample_gp_function'", ")", "\n", "def", "sample_gp_function", "(", "discretization", ",", "gpfun", ",", "number", "=", "1", ",", "return_function", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Sample a function from a gp with corresponding kernel within its bounds.\n\n    Parameters\n    ----------\n    discretization : ndarray\n        The discretization on which to draw a sample from the GP. Can be\n        obtained, for example, from GridWorld.all_points.\n    gpfun : instance of safe_learning.GaussianProcess\n        The GP from which to draw a sample.\n    number : int\n        The number of functions to sample.\n    return_function : bool, optional\n        Whether to return a function or the sampled data only.\n\n    Returns\n    -------\n    function : list of functions or ndarray\n        function(x, noise=True)\n        A function that takes as inputs new locations x to be evaluated and\n        returns the corresponding noisy function values as a tensor. If\n        noise=False is set the true function values are returned (useful for\n        plotting).\n\n    \"\"\"", "\n", "if", "isinstance", "(", "discretization", ",", "GridWorld", ")", ":", "\n", "        ", "discretization", "=", "discretization", ".", "all_points", "\n", "\n", "", "gp", "=", "gpfun", ".", "gaussian_process", "\n", "\n", "with", "gp", ".", "tf_mode", "(", ")", ":", "\n", "        ", "mean", ",", "cov", "=", "gp", ".", "build_predict", "(", "discretization", ",", "full_cov", "=", "True", ")", "\n", "\n", "# Evaluate", "\n", "", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "mean", ",", "cov", "=", "sess", ".", "run", "(", "[", "mean", ",", "cov", "]", ",", "feed_dict", "=", "gpfun", ".", "feed_dict", ")", "\n", "\n", "# Turn mean and covariance into 1D and 2D arrays", "\n", "mean", "=", "mean", ".", "squeeze", "(", "-", "1", ")", "\n", "cov", "=", "cov", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "# Make sure the covariance is positive definite", "\n", "cov", "+=", "np", ".", "eye", "(", "len", "(", "cov", ")", ")", "*", "1E-8", "\n", "\n", "# Draw a sample", "\n", "output", "=", "np", ".", "random", ".", "multivariate_normal", "(", "mean", ",", "cov", ",", "size", "=", "number", ")", "\n", "\n", "if", "not", "return_function", ":", "\n", "        ", "return", "output", "\n", "\n", "# cholesky", "\n", "", "cho_factor", "=", "linalg", ".", "cho_factor", "(", "cov", ",", "lower", "=", "True", ")", "\n", "\n", "@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "gp_sample", "(", "alpha", ",", "x", ",", "noise", "=", "True", ")", ":", "\n", "        ", "with", "gp", ".", "tf_mode", "(", ")", ":", "\n", "            ", "k", "=", "gp", ".", "kern", ".", "K", "(", "x", ",", "discretization", ")", "\n", "y", "=", "gp", ".", "mean_function", "(", "x", ")", "+", "tf", ".", "matmul", "(", "k", ",", "alpha", ")", "\n", "if", "noise", ":", "\n", "                ", "y", "+=", "(", "tf", ".", "sqrt", "(", "gp", ".", "likelihood", ".", "variance", ")", "\n", "*", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "y", ")", ",", "dtype", "=", "tf", ".", "float64", ")", ")", "\n", "", "", "return", "y", "\n", "\n", "# Now let's plug in the alpha to generate samples", "\n", "", "functions", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "number", ")", ":", "\n", "        ", "alpha", "=", "linalg", ".", "cho_solve", "(", "cho_factor", ",", "output", "[", "[", "i", "]", ",", ":", "]", ".", "T", ")", "\n", "fun", "=", "partial", "(", "gp_sample", ",", "alpha", ")", "\n", "\n", "# Attach the feed_dict for ease of use", "\n", "fun", ".", "feed_dict", "=", "gpfun", ".", "feed_dict", "\n", "\n", "functions", ".", "append", "(", "fun", ")", "\n", "\n", "", "return", "functions", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.__init__": [[177, 226], ["object.__init__", "numpy.zeros", "dict", "utilities.get_feed_dict", "tensorflow.placeholder", "lyapunov.Lyapunov.update_values", "numpy.zeros", "numpy.prod", "tensorflow.get_default_graph"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.update_values"], ["def", "__init__", "(", "self", ",", "discretization", ",", "lyapunov_function", ",", "dynamics", ",", "\n", "lipschitz_dynamics", ",", "lipschitz_lyapunov", ",", "\n", "tau", ",", "policy", ",", "initial_set", "=", "None", ",", "adaptive", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialization, see `Lyapunov` for details.\"\"\"", "\n", "super", "(", "Lyapunov", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "discretization", "=", "discretization", "\n", "self", ".", "policy", "=", "policy", "\n", "\n", "# Keep track of the safe sets", "\n", "self", ".", "safe_set", "=", "np", ".", "zeros", "(", "np", ".", "prod", "(", "discretization", ".", "num_points", ")", ",", "\n", "dtype", "=", "bool", ")", "\n", "\n", "self", ".", "initial_safe_set", "=", "initial_set", "\n", "if", "initial_set", "is", "not", "None", ":", "\n", "            ", "self", ".", "safe_set", "[", "initial_set", "]", "=", "True", "\n", "\n", "# Discretization constant", "\n", "", "self", ".", "tau", "=", "tau", "\n", "\n", "# Make sure dynamics are of standard framework", "\n", "self", ".", "dynamics", "=", "dynamics", "\n", "\n", "# Make sure Lyapunov fits into standard framework", "\n", "self", ".", "lyapunov_function", "=", "lyapunov_function", "\n", "\n", "# Storage for graph", "\n", "self", ".", "_storage", "=", "dict", "(", ")", "\n", "self", ".", "feed_dict", "=", "get_feed_dict", "(", "tf", ".", "get_default_graph", "(", ")", ")", "\n", "\n", "# Lyapunov values", "\n", "self", ".", "values", "=", "None", "\n", "\n", "self", ".", "c_max", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "shape", "=", "(", ")", ")", "\n", "self", ".", "feed_dict", "[", "self", ".", "c_max", "]", "=", "0.", "\n", "\n", "self", ".", "_lipschitz_dynamics", "=", "lipschitz_dynamics", "\n", "self", ".", "_lipschitz_lyapunov", "=", "lipschitz_lyapunov", "\n", "\n", "self", ".", "update_values", "(", ")", "\n", "\n", "self", ".", "adaptive", "=", "adaptive", "\n", "\n", "# Keep track of the refinement `N(x)` used around each state `x` in", "\n", "# the adaptive discretization; `N(x) = 0` by convention if `x` is", "\n", "# unsafe", "\n", "self", ".", "_refinement", "=", "np", ".", "zeros", "(", "discretization", ".", "nindex", ",", "dtype", "=", "int", ")", "\n", "if", "initial_set", "is", "not", "None", ":", "\n", "            ", "self", ".", "_refinement", "[", "initial_set", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.lipschitz_dynamics": [[227, 245], ["hasattr", "lyapunov.Lyapunov._lipschitz_dynamics"], "methods", ["None"], ["", "", "def", "lipschitz_dynamics", "(", "self", ",", "states", ")", ":", "\n", "        ", "\"\"\"Return the Lipschitz constant for given states and actions.\n\n        Parameters\n        ----------\n        states : ndarray or Tensor\n\n        Returns\n        -------\n        lipschitz : float, ndarray or Tensor\n            If lipschitz_dynamics is a callable then returns local Lipschitz\n            constants. Otherwise returns the Lipschitz constant as a scalar.\n\n        \"\"\"", "\n", "if", "hasattr", "(", "self", ".", "_lipschitz_dynamics", ",", "'__call__'", ")", ":", "\n", "            ", "return", "self", ".", "_lipschitz_dynamics", "(", "states", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_lipschitz_dynamics", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.lipschitz_lyapunov": [[246, 264], ["hasattr", "lyapunov.Lyapunov._lipschitz_lyapunov"], "methods", ["None"], ["", "", "def", "lipschitz_lyapunov", "(", "self", ",", "states", ")", ":", "\n", "        ", "\"\"\"Return the local Lipschitz constant at a given state.\n\n        Parameters\n        ----------\n        states : ndarray or Tensor\n\n        Returns\n        -------\n        lipschitz : float, ndarray or Tensor\n            If lipschitz_lyapunov is a callable then returns local Lipschitz\n            constants. Otherwise returns the Lipschitz constant as a scalar.\n\n        \"\"\"", "\n", "if", "hasattr", "(", "self", ".", "_lipschitz_lyapunov", ",", "'__call__'", ")", ":", "\n", "            ", "return", "self", ".", "_lipschitz_lyapunov", "(", "states", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_lipschitz_lyapunov", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.threshold": [[265, 289], ["lyapunov.Lyapunov.lipschitz_lyapunov", "lyapunov.Lyapunov.lipschitz_dynamics", "hasattr", "tensorflow.norm"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.lipschitz_lyapunov", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.lipschitz_dynamics"], ["", "", "def", "threshold", "(", "self", ",", "states", ",", "tau", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the safety threshold for the Lyapunov condition.\n\n        Parameters\n        ----------\n        states : ndarray or Tensor\n\n        tau : float or Tensor, optional\n            Discretization constant to consider.\n\n        Returns\n        -------\n        lipschitz : float, ndarray or Tensor\n            Either the scalar threshold or local thresholds, depending on\n            whether lipschitz_lyapunov and lipschitz_dynamics are local or not.\n\n        \"\"\"", "\n", "if", "tau", "is", "None", ":", "\n", "            ", "tau", "=", "self", ".", "tau", "\n", "", "lv", "=", "self", ".", "lipschitz_lyapunov", "(", "states", ")", "\n", "if", "hasattr", "(", "self", ".", "_lipschitz_lyapunov", ",", "'__call__'", ")", "and", "lv", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "            ", "lv", "=", "tf", ".", "norm", "(", "lv", ",", "ord", "=", "1", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "", "lf", "=", "self", ".", "lipschitz_dynamics", "(", "states", ")", "\n", "return", "-", "lv", "*", "(", "1.", "+", "lf", ")", "*", "tau", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.is_safe": [[290, 304], ["lyapunov.Lyapunov.discretization.state_to_index"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index"], ["", "def", "is_safe", "(", "self", ",", "state", ")", ":", "\n", "        ", "\"\"\"Return a boolean array that indicates whether the state is safe.\n\n        Parameters\n        ----------\n        state : ndarray\n\n        Returns\n        -------\n        safe : boolean\n            Is true if the corresponding state is inside the safe set.\n\n        \"\"\"", "\n", "return", "self", ".", "safe_set", "[", "self", ".", "discretization", ".", "state_to_index", "(", "state", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.update_values": [[305, 323], ["utilities.get_storage", "lyapunov.Lyapunov.eval().squeeze", "tensorflow.placeholder", "lyapunov.Lyapunov.lyapunov_function", "utilities.set_storage", "utilities.get_storage.values", "lyapunov.Lyapunov.eval"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.set_storage"], ["", "def", "update_values", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update the discretized values when the Lyapunov function changes.\"\"\"", "\n", "# Use a placeholder to avoid loading a large discretization into the", "\n", "# TensorFlow graph", "\n", "storage", "=", "get_storage", "(", "self", ".", "_storage", ")", "\n", "if", "storage", "is", "None", ":", "\n", "            ", "tf_points", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "\n", "shape", "=", "[", "None", ",", "self", ".", "discretization", ".", "ndim", "]", ",", "\n", "name", "=", "'discretization_points'", ")", "\n", "tf_values", "=", "self", ".", "lyapunov_function", "(", "tf_points", ")", "\n", "storage", "=", "[", "(", "'points'", ",", "tf_points", ")", ",", "(", "'values'", ",", "tf_values", ")", "]", "\n", "set_storage", "(", "self", ".", "_storage", ",", "storage", ")", "\n", "", "else", ":", "\n", "            ", "tf_points", ",", "tf_values", "=", "storage", ".", "values", "(", ")", "\n", "\n", "", "feed_dict", "=", "self", ".", "feed_dict", "\n", "feed_dict", "[", "tf_points", "]", "=", "self", ".", "discretization", ".", "all_points", "\n", "self", ".", "values", "=", "tf_values", ".", "eval", "(", "feed_dict", ")", ".", "squeeze", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.v_decrease_confidence": [[324, 355], ["isinstance", "lyapunov.Lyapunov.lipschitz_lyapunov", "tensorflow.reduce_sum", "tensorflow.constant", "lyapunov.Lyapunov.lyapunov_function", "lyapunov.Lyapunov.lyapunov_function"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.lipschitz_lyapunov"], ["", "def", "v_decrease_confidence", "(", "self", ",", "states", ",", "next_states", ")", ":", "\n", "        ", "\"\"\"Compute confidence intervals for the decrease along Lyapunov function.\n\n        Parameters\n        ----------\n        states : np.array\n            The states at which to start (could be equal to discretization).\n        next_states : np.array\n            The dynamics evaluated at each point on the discretization. If\n            the dynamics are uncertain then next_states is a tuple with mean\n            and error bounds.\n\n        Returns\n        -------\n        mean : np.array\n            The expected decrease in values at each grid point.\n        error_bounds : np.array\n            The error bounds for the decrease at each grid point\n\n        \"\"\"", "\n", "if", "isinstance", "(", "next_states", ",", "Sequence", ")", ":", "\n", "            ", "next_states", ",", "error_bounds", "=", "next_states", "\n", "lv", "=", "self", ".", "lipschitz_lyapunov", "(", "next_states", ")", "\n", "bound", "=", "tf", ".", "reduce_sum", "(", "lv", "*", "error_bounds", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "bound", "=", "tf", ".", "constant", "(", "0.", ",", "dtype", "=", "config", ".", "dtype", ")", "\n", "\n", "", "v_decrease", "=", "(", "self", ".", "lyapunov_function", "(", "next_states", ")", "\n", "-", "self", ".", "lyapunov_function", "(", "states", ")", ")", "\n", "\n", "return", "v_decrease", ",", "bound", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.v_decrease_bound": [[356, 377], ["lyapunov.Lyapunov.v_decrease_confidence"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.v_decrease_confidence"], ["", "def", "v_decrease_bound", "(", "self", ",", "states", ",", "next_states", ")", ":", "\n", "        ", "\"\"\"Compute confidence intervals for the decrease along Lyapunov function.\n\n        Parameters\n        ----------\n        states : np.array\n            The states at which to start (could be equal to discretization).\n        next_states : np.array or tuple\n            The dynamics evaluated at each point on the discretization. If\n            the dynamics are uncertain then next_states is a tuple with mean\n            and error bounds.\n\n        Returns\n        -------\n        upper_bound : np.array\n            The upper bound on the change in values at each grid point.\n\n        \"\"\"", "\n", "v_dot", ",", "v_dot_error", "=", "self", ".", "v_decrease_confidence", "(", "states", ",", "next_states", ")", "\n", "\n", "return", "v_dot", "+", "v_dot_error", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.safety_constraint": [[378, 406], ["lyapunov.Lyapunov.dynamics", "lyapunov.Lyapunov.v_decrease_bound"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.v_decrease_bound"], ["", "def", "safety_constraint", "(", "self", ",", "policy", ",", "include_initial", "=", "True", ")", ":", "\n", "        ", "\"\"\"Return the safe set for a given policy.\n\n        Parameters\n        ----------\n        policy : ndarray\n            The policy used at each discretization point.\n        include_initial : bool, optional\n            Whether to include the initial safe set.\n\n        Returns\n        -------\n        constraint : ndarray\n            A boolean array indicating where the safety constraint is\n            fulfilled.\n\n        \"\"\"", "\n", "prediction", "=", "self", ".", "dynamics", "(", "self", ".", "discretization", ",", "policy", ")", "\n", "v_dot_bound", "=", "self", ".", "v_decrease_bound", "(", "self", ".", "discretization", ",", "prediction", ")", "\n", "\n", "# Update the safe set", "\n", "v_dot_negative", "=", "v_dot_bound", "<", "self", ".", "threshold", "\n", "\n", "# Make sure initial safe set is included", "\n", "if", "include_initial", "and", "self", ".", "initial_safe_set", "is", "not", "None", ":", "\n", "            ", "v_dot_negative", "[", "self", ".", "initial_safe_set", "]", "=", "True", "\n", "\n", "", "return", "v_dot_negative", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.update_safe_set": [[407, 607], ["utilities.with_scope", "numpy.maximum", "utilities.get_storage", "numpy.argsort", "utilities.batchify", "tensorflow.placeholder", "lyapunov.Lyapunov.policy", "lyapunov.Lyapunov.dynamics", "lyapunov.Lyapunov.v_decrease_bound", "lyapunov.Lyapunov.threshold", "tensorflow.squeeze", "utilities.set_storage", "numpy.zeros_like", "numpy.zeros_like", "index_to_state", "tensorflow.squeeze.eval", "numpy.argmin", "tensorflow.less", "tensorflow.where", "tensorflow.ceil", "int", "lyapunov.Lyapunov.discretization.unit_maxes.reshape", "tensorflow.placeholder", "tensorflow.concat", "tensorflow.map_fn", "utilities.get_storage.values", "utilities.get_storage.values", "tensorflow.is_nan", "tensorflow.zeros_like", "tensorflow.maximum", "tensorflow.reshape", "tensorflow.cast", "tensorflow.constant", "tensorflow.reshape", "tensorflow.meshgrid", "tensorflow.stack", "lyapunov.Lyapunov.threshold", "tensorflow.less", "tensorflow.reduce_all", "tensorflow.ceil.eval().ravel", "numpy.logical_or", "numpy.logical_and", "numpy.all", "tensorflow.linspace", "tensorflow.tile", "tensorflow.cast", "len", "numpy.argmin", "tensorflow.map_fn.eval", "numpy.all", "tensorflow.unstack", "tensorflow.reshape", "tensorflow.ceil.eval", "len", "numpy.argmin", "len"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.batchify", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.v_decrease_bound", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.threshold", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.set_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.threshold"], ["", "@", "with_scope", "(", "'update_safe_set'", ")", "\n", "def", "update_safe_set", "(", "self", ",", "can_shrink", "=", "True", ",", "max_refinement", "=", "1", ",", "\n", "safety_factor", "=", "1.", ",", "parallel_iterations", "=", "1", ")", ":", "\n", "        ", "\"\"\"Compute and update the safe set.\n\n        Parameters\n        ----------\n        can_shrink : bool, optional\n            A boolean determining whether previously safe states other than the\n            initial safe set must be verified again (i.e., can the safe set\n            shrink in volume?)\n        max_refinement : int, optional\n            The maximum integer divisor used for adaptive discretization.\n        safety_factor : float, optional\n            A multiplicative factor greater than 1 used to conservatively\n            estimate the required adaptive discretization.\n        parallel_iterations : int, optional\n            The number of parallel iterations to use for safety verification in\n            the adaptive case. Passed to `tf.map_fn`.\n\n        \"\"\"", "\n", "safety_factor", "=", "np", ".", "maximum", "(", "safety_factor", ",", "1.", ")", "\n", "storage", "=", "get_storage", "(", "self", ".", "_storage", ")", "\n", "\n", "if", "storage", "is", "None", ":", "\n", "# Placeholder for states to evaluate for safety", "\n", "            ", "tf_states", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "\n", "shape", "=", "[", "None", ",", "self", ".", "discretization", ".", "ndim", "]", ",", "\n", "name", "=", "'verification_states'", ")", "\n", "actions", "=", "self", ".", "policy", "(", "tf_states", ")", "\n", "next_states", "=", "self", ".", "dynamics", "(", "tf_states", ",", "actions", ")", "\n", "\n", "decrease", "=", "self", ".", "v_decrease_bound", "(", "tf_states", ",", "next_states", ")", "\n", "threshold", "=", "self", ".", "threshold", "(", "tf_states", ",", "self", ".", "tau", ")", "\n", "tf_negative", "=", "tf", ".", "squeeze", "(", "tf", ".", "less", "(", "decrease", ",", "threshold", ")", ",", "axis", "=", "1", ")", "\n", "\n", "storage", "=", "[", "(", "'states'", ",", "tf_states", ")", ",", "(", "'negative'", ",", "tf_negative", ")", "]", "\n", "\n", "if", "self", ".", "adaptive", ":", "\n", "# Compute an integer n such that dv < threshold for tau / n", "\n", "                ", "ratio", "=", "safety_factor", "*", "threshold", "/", "decrease", "\n", "# If dv = 0, check for nan values, and clip to n = 0", "\n", "tf_n_req", "=", "tf", ".", "where", "(", "tf", ".", "is_nan", "(", "ratio", ")", ",", "\n", "tf", ".", "zeros_like", "(", "ratio", ")", ",", "ratio", ")", "\n", "# Edge case: ratio = 1 should correspond to n = 2", "\n", "# TODO", "\n", "# If dv < 0, also clip to n = 0", "\n", "tf_n_req", "=", "tf", ".", "ceil", "(", "tf", ".", "maximum", "(", "tf_n_req", ",", "0", ")", ")", "\n", "\n", "dim", "=", "int", "(", "self", ".", "discretization", ".", "ndim", ")", "\n", "lengths", "=", "self", ".", "discretization", ".", "unit_maxes", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "def", "refined_safety_check", "(", "data", ")", ":", "\n", "                    ", "\"\"\"Verify decrease condition in a locally refined grid.\"\"\"", "\n", "center", "=", "tf", ".", "reshape", "(", "data", "[", ":", "-", "1", "]", ",", "[", "1", ",", "dim", "]", ")", "\n", "n_req", "=", "tf", ".", "cast", "(", "data", "[", "-", "1", "]", ",", "tf", ".", "int32", ")", "\n", "\n", "start", "=", "tf", ".", "constant", "(", "-", "1.", ",", "dtype", "=", "config", ".", "dtype", ")", "\n", "spacing", "=", "tf", ".", "reshape", "(", "tf", ".", "linspace", "(", "start", ",", "1.", ",", "n_req", ")", ",", "\n", "[", "1", ",", "-", "1", "]", ")", "\n", "border", "=", "(", "0.5", "*", "(", "1", "-", "1", "/", "n_req", ")", "*", "lengths", "*", "\n", "tf", ".", "tile", "(", "spacing", ",", "[", "dim", ",", "1", "]", ")", ")", "\n", "mesh", "=", "tf", ".", "meshgrid", "(", "*", "tf", ".", "unstack", "(", "border", ")", ",", "indexing", "=", "'ij'", ")", "\n", "points", "=", "tf", ".", "stack", "(", "[", "tf", ".", "reshape", "(", "col", ",", "[", "-", "1", "]", ")", "for", "col", "in", "mesh", "]", ",", "\n", "axis", "=", "1", ")", "\n", "points", "+=", "center", "\n", "\n", "refined_threshold", "=", "self", ".", "threshold", "(", "center", ",", "\n", "self", ".", "tau", "/", "n_req", ")", "\n", "negative", "=", "tf", ".", "less", "(", "decrease", ",", "refined_threshold", ")", "\n", "refined_negative", "=", "tf", ".", "reduce_all", "(", "negative", ")", "\n", "return", "refined_negative", "\n", "\n", "", "tf_refinement", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "None", ",", "1", "]", ",", "\n", "'refinement'", ")", "\n", "data", "=", "tf", ".", "concat", "(", "[", "tf_states", ",", "tf", ".", "cast", "(", "tf_refinement", ",", "\n", "config", ".", "dtype", ")", "]", ",", "axis", "=", "1", ")", "\n", "tf_refined_negative", "=", "tf", ".", "map_fn", "(", "refined_safety_check", ",", "data", ",", "\n", "tf", ".", "bool", ",", "parallel_iterations", ")", "\n", "storage", "+=", "[", "(", "'n_req'", ",", "tf_n_req", ")", ",", "(", "'refinement'", ",", "tf_refinement", ")", ",", "\n", "(", "'refined_negative'", ",", "tf_refined_negative", ")", "]", "\n", "\n", "", "set_storage", "(", "self", ".", "_storage", ",", "storage", ")", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "adaptive", ":", "\n", "                ", "(", "tf_states", ",", "tf_negative", ",", "tf_n_req", ",", "tf_refinement", ",", "\n", "tf_refined_negative", ")", "=", "storage", ".", "values", "(", ")", "\n", "", "else", ":", "\n", "                ", "tf_states", ",", "tf_negative", "=", "storage", ".", "values", "(", ")", "\n", "\n", "# Get relevant properties", "\n", "", "", "feed_dict", "=", "self", ".", "feed_dict", "\n", "\n", "if", "can_shrink", ":", "\n", "# Reset the safe set and adaptive discretization", "\n", "            ", "safe_set", "=", "np", ".", "zeros_like", "(", "self", ".", "safe_set", ",", "dtype", "=", "bool", ")", "\n", "refinement", "=", "np", ".", "zeros_like", "(", "self", ".", "_refinement", ",", "dtype", "=", "int", ")", "\n", "if", "self", ".", "initial_safe_set", "is", "not", "None", ":", "\n", "                ", "safe_set", "[", "self", ".", "initial_safe_set", "]", "=", "True", "\n", "refinement", "[", "self", ".", "initial_safe_set", "]", "=", "1", "\n", "", "", "else", ":", "\n", "# Assume safe set cannot shrink", "\n", "            ", "safe_set", "=", "self", ".", "safe_set", "\n", "refinement", "=", "self", ".", "_refinement", "\n", "\n", "", "value_order", "=", "np", ".", "argsort", "(", "self", ".", "values", ")", "\n", "safe_set", "=", "safe_set", "[", "value_order", "]", "\n", "refinement", "=", "refinement", "[", "value_order", "]", "\n", "\n", "# Verify safety in batches", "\n", "batch_size", "=", "config", ".", "gp_batch_size", "\n", "batch_generator", "=", "batchify", "(", "(", "value_order", ",", "safe_set", ",", "refinement", ")", ",", "\n", "batch_size", ")", "\n", "index_to_state", "=", "self", ".", "discretization", ".", "index_to_state", "\n", "\n", "#######################################################################", "\n", "\n", "for", "i", ",", "(", "indices", ",", "safe_batch", ",", "refine_batch", ")", "in", "batch_generator", ":", "\n", "            ", "states", "=", "index_to_state", "(", "indices", ")", "\n", "feed_dict", "[", "tf_states", "]", "=", "states", "\n", "\n", "# Update the safety with the safe_batch result", "\n", "negative", "=", "tf_negative", ".", "eval", "(", "feed_dict", ")", "\n", "safe_batch", "|=", "negative", "\n", "refine_batch", "[", "negative", "]", "=", "1", "\n", "\n", "# Boolean array: argmin returns first element that is False", "\n", "# If all are safe then it returns 0", "\n", "bound", "=", "np", ".", "argmin", "(", "safe_batch", ")", "\n", "refine_bound", "=", "0", "\n", "\n", "# Check if there are unsafe elements in the batch", "\n", "if", "bound", ">", "0", "or", "not", "safe_batch", "[", "0", "]", ":", "\n", "                ", "if", "self", ".", "adaptive", "and", "max_refinement", ">", "1", ":", "\n", "# Compute required adaptive refinement", "\n", "                    ", "feed_dict", "[", "tf_states", "]", "=", "states", "[", "bound", ":", "]", "\n", "refine_batch", "[", "bound", ":", "]", "=", "tf_n_req", ".", "eval", "(", "feed_dict", ")", ".", "ravel", "(", ")", "\n", "\n", "# We do not need to refine cells that correspond to known", "\n", "# safe states", "\n", "idx_safe", "=", "np", ".", "logical_or", "(", "negative", ",", "\n", "self", ".", "initial_safe_set", "[", "indices", "]", ")", "\n", "refine_batch", "[", "idx_safe", "]", "=", "1", "\n", "\n", "# Identify cells to refine", "\n", "states_to_check", "=", "np", ".", "logical_and", "(", "refine_batch", ">=", "1", ",", "\n", "refine_batch", "<=", "\n", "max_refinement", ")", "\n", "states_to_check", "=", "states_to_check", "[", "bound", ":", "]", "\n", "\n", "if", "np", ".", "all", "(", "states_to_check", ")", ":", "\n", "                        ", "stop", "=", "len", "(", "states_to_check", ")", "\n", "", "else", ":", "\n", "                        ", "stop", "=", "np", ".", "argmin", "(", "states_to_check", ")", "\n", "\n", "", "if", "stop", ">", "0", ":", "\n", "                        ", "feed_dict", "[", "tf_states", "]", "=", "states", "[", "bound", ":", "bound", "+", "stop", "]", "\n", "feed_dict", "[", "tf_refinement", "]", "=", "refine_batch", "[", "bound", ":", "\n", "bound", "+", "stop", ",", "\n", "None", "]", "\n", "refined_safe", "=", "tf_refined_negative", ".", "eval", "(", "feed_dict", ")", "\n", "\n", "# Determine which states are safe under the refined", "\n", "# discretization", "\n", "if", "np", ".", "all", "(", "refined_safe", ")", ":", "\n", "                            ", "refine_bound", "=", "len", "(", "refined_safe", ")", "\n", "", "else", ":", "\n", "                            ", "refine_bound", "=", "np", ".", "argmin", "(", "refined_safe", ")", "\n", "", "safe_batch", "[", "bound", ":", "bound", "+", "refine_bound", "]", "=", "True", "\n", "\n", "# Break if the refined discretization does not work for all", "\n", "# states after `bound`", "\n", "", "if", "stop", "<", "len", "(", "states_to_check", ")", "or", "refine_bound", "<", "stop", ":", "\n", "                        ", "safe_batch", "[", "bound", "+", "refine_bound", ":", "]", "=", "False", "\n", "refine_batch", "[", "bound", "+", "refine_bound", ":", "]", "=", "0", "\n", "break", "\n", "", "", "else", ":", "\n", "# Make sure all following points are labeled as unsafe", "\n", "                    ", "safe_batch", "[", "bound", ":", "]", "=", "False", "\n", "refine_batch", "[", "bound", ":", "]", "=", "0", "\n", "break", "\n", "\n", "# The largest index of a safe value", "\n", "", "", "", "max_index", "=", "i", "+", "bound", "+", "refine_bound", "-", "1", "\n", "\n", "#######################################################################", "\n", "\n", "# Set placeholder for c_max to the corresponding value", "\n", "feed_dict", "[", "self", ".", "c_max", "]", "=", "self", ".", "values", "[", "value_order", "[", "max_index", "]", "]", "\n", "\n", "# Restore the order of the safe set and adaptive refinement", "\n", "safe_nodes", "=", "value_order", "[", "safe_set", "]", "\n", "self", ".", "safe_set", "[", ":", "]", "=", "False", "\n", "self", ".", "safe_set", "[", "safe_nodes", "]", "=", "True", "\n", "self", ".", "_refinement", "[", "value_order", "]", "=", "refinement", "\n", "\n", "# Ensure the initial safe set is kept", "\n", "if", "self", ".", "initial_safe_set", "is", "not", "None", ":", "\n", "            ", "self", ".", "safe_set", "[", "self", ".", "initial_safe_set", "]", "=", "True", "\n", "self", ".", "_refinement", "[", "self", ".", "initial_safe_set", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.smallest_boundary_value": [[22, 57], ["utilities.get_feed_dict", "future.builtins.range", "tensorflow.get_default_graph", "list", "numpy.column_stack", "tensorflow.reduce_min", "min", "x.ravel", "fun", "tf.reduce_min.eval", "numpy.meshgrid"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict", "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.fun"], ["def", "smallest_boundary_value", "(", "fun", ",", "discretization", ")", ":", "\n", "    ", "\"\"\"Determine the smallest value of a function on its boundary.\n\n    Parameters\n    ----------\n    fun : callable\n        A tensorflow function that we want to evaluate.\n    discretization : instance of `GridWorld`\n        The discretization. If None, then the function is assumed to be\n        defined on a discretization already.\n\n    Returns\n    -------\n    min_value : float\n        The smallest value on the boundary.\n\n    \"\"\"", "\n", "min_value", "=", "np", ".", "inf", "\n", "feed_dict", "=", "get_feed_dict", "(", "tf", ".", "get_default_graph", "(", ")", ")", "\n", "\n", "# Check boundaries for each axis", "\n", "for", "i", "in", "range", "(", "discretization", ".", "ndim", ")", ":", "\n", "# Use boundary values only for the ith element", "\n", "        ", "tmp", "=", "list", "(", "discretization", ".", "discrete_points", ")", "\n", "tmp", "[", "i", "]", "=", "discretization", ".", "discrete_points", "[", "i", "]", "[", "[", "0", ",", "-", "1", "]", "]", "\n", "\n", "# Generate all points", "\n", "columns", "=", "(", "x", ".", "ravel", "(", ")", "for", "x", "in", "np", ".", "meshgrid", "(", "*", "tmp", ",", "indexing", "=", "'ij'", ")", ")", "\n", "all_points", "=", "np", ".", "column_stack", "(", "columns", ")", "\n", "\n", "# Update the minimum value", "\n", "smallest", "=", "tf", ".", "reduce_min", "(", "fun", "(", "all_points", ")", ")", "\n", "min_value", "=", "min", "(", "min_value", ",", "smallest", ".", "eval", "(", "feed_dict", "=", "feed_dict", ")", ")", "\n", "\n", "", "return", "min_value", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.get_lyapunov_region": [[59, 140], ["lyapunov().eval", "lyapunov().eval.reshape", "itertools.product", "numpy.array", "numpy.zeros", "itertools.count", "heapq.heappop", "lyapunov", "tuple", "itertools.count.next", "numpy.any", "numpy.any", "numpy.split", "future.builtins.zip", "heapq.heappush", "tuple", "future.builtins.range", "tuple", "numpy.split", "next"], "function", ["None"], ["", "def", "get_lyapunov_region", "(", "lyapunov", ",", "discretization", ",", "init_node", ")", ":", "\n", "    ", "\"\"\"Get the region within which a function is a Lyapunov function.\n\n    Parameters\n    ----------\n    lyapunov : callable\n        A tensorflow function.\n    discretization : instance of `GridWorld`\n        The discretization on which to check the increasing property.\n    init_node : tuple\n        The node at which to start the verification.\n\n    Returns\n    -------\n    region : ndarray\n        A boolean array that contains all the states for which lyapunov is a\n        Lyapunov function that can be used for stability verification.\n\n    \"\"\"", "\n", "# Turn values into a multi-dim array", "\n", "feed_dict", "=", "lyapunov", ".", "feed_dict", "\n", "\n", "values", "=", "lyapunov", "(", "discretization", ".", "all_points", ")", ".", "eval", "(", "feed_dict", "=", "feed_dict", ")", "\n", "lyapunov_values", "=", "values", ".", "reshape", "(", "discretization", ".", "num_points", ")", "\n", "\n", "# Starting point for the verification", "\n", "init_value", "=", "lyapunov_values", "[", "init_node", "]", "\n", "\n", "ndim", "=", "discretization", ".", "ndim", "\n", "num_points", "=", "discretization", ".", "num_points", "\n", "\n", "# Indices for generating neighbors", "\n", "index_generator", "=", "itertools", ".", "product", "(", "*", "[", "(", "0", ",", "-", "1", ",", "1", ")", "for", "_", "in", "range", "(", "ndim", ")", "]", ")", "\n", "neighbor_indeces", "=", "np", ".", "array", "(", "tuple", "(", "index_generator", ")", "[", "1", ":", "]", ")", "\n", "\n", "# Array keeping track of visited nodes", "\n", "visited", "=", "np", ".", "zeros", "(", "discretization", ".", "num_points", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "visited", "[", "init_node", "]", "=", "True", "\n", "\n", "# Create priority queue", "\n", "tiebreaker", "=", "itertools", ".", "count", "(", ")", "\n", "last_value", "=", "init_value", "\n", "priority_queue", "=", "[", "(", "init_value", ",", "tiebreaker", ".", "next", "(", ")", ",", "init_node", ")", "]", "\n", "\n", "while", "priority_queue", ":", "\n", "        ", "value", ",", "_", ",", "next_node", "=", "heappop", "(", "priority_queue", ")", "\n", "\n", "# Check if we reached the boundary of the discretization", "\n", "if", "np", ".", "any", "(", "0", "==", "next_node", ")", "or", "np", ".", "any", "(", "next_node", "==", "num_points", "-", "1", ")", ":", "\n", "            ", "visited", "[", "tuple", "(", "next_node", ")", "]", "=", "False", "\n", "break", "\n", "\n", "# Make sure we are in the positive definite part of the function.", "\n", "", "if", "value", "<", "last_value", ":", "\n", "            ", "break", "\n", "\n", "", "last_value", "=", "value", "\n", "\n", "# Get all neighbors", "\n", "neighbors", "=", "next_node", "+", "neighbor_indeces", "\n", "\n", "# Remove neighbors that are already part of the visited set", "\n", "is_new", "=", "~", "visited", "[", "np", ".", "split", "(", "neighbors", ".", "T", ",", "ndim", ")", "]", "\n", "neighbors", "=", "neighbors", "[", "is_new", "[", "0", "]", "]", "\n", "\n", "if", "neighbors", ".", "size", ":", "\n", "            ", "indices", "=", "np", ".", "split", "(", "neighbors", ".", "T", ",", "ndim", ")", "\n", "# add to visited set", "\n", "visited", "[", "indices", "]", "=", "True", "\n", "# get values", "\n", "values", "=", "lyapunov_values", "[", "indices", "]", "[", "0", "]", "\n", "\n", "# add to priority queue", "\n", "for", "value", ",", "neighbor", "in", "zip", "(", "values", ",", "neighbors", ")", ":", "\n", "                ", "heappush", "(", "priority_queue", ",", "(", "value", ",", "next", "(", "tiebreaker", ")", ",", "neighbor", ")", ")", "\n", "\n", "# Prune nodes that were neighbors, but haven't been visited", "\n", "", "", "", "for", "_", ",", "_", ",", "node", "in", "priority_queue", ":", "\n", "        ", "visited", "[", "tuple", "(", "node", ")", "]", "=", "False", "\n", "\n", "", "return", "visited", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.perturb_actions": [[609, 652], ["numpy.repeat", "numpy.column_stack", "len", "numpy.repeat", "numpy.tile", "numpy.clip", "utilities.unique_rows", "len"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.unique_rows"], ["", "", "", "def", "perturb_actions", "(", "states", ",", "actions", ",", "perturbations", ",", "limits", "=", "None", ")", ":", "\n", "    ", "\"\"\"Create state-action pairs by perturbing the actions.\n\n    Parameters\n    ----------\n    states : ndarray\n        An (N x n) array of states at which we want to generate state-action\n        pairs.\n    actions : ndarray\n        An (N x m) array of baseline actions at these states. These\n        corresponds to the actions taken by the current policy.\n    perturbations : ndarray\n        An (X x m) array of policy perturbations that are to be applied to\n        each state-action pair.\n    limits : list\n        List of action-limit tuples.\n\n    Returns\n    -------\n    state-actions : ndarray\n        An (N*X x n+m) array of state-actions pairs, where for each state\n        the corresponding action is perturbed by the perturbations.\n\n    \"\"\"", "\n", "num_states", ",", "state_dim", "=", "states", ".", "shape", "\n", "\n", "# repeat states", "\n", "states_new", "=", "np", ".", "repeat", "(", "states", ",", "len", "(", "perturbations", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# generate perturbations from perturbations around baseline policy", "\n", "actions_new", "=", "(", "np", ".", "repeat", "(", "actions", ",", "len", "(", "perturbations", ")", ",", "axis", "=", "0", ")", "\n", "+", "np", ".", "tile", "(", "perturbations", ",", "(", "num_states", ",", "1", ")", ")", ")", "\n", "\n", "state_actions", "=", "np", ".", "column_stack", "(", "(", "states_new", ",", "actions_new", ")", ")", "\n", "\n", "if", "limits", "is", "not", "None", ":", "\n", "# Clip the actions", "\n", "        ", "perturbations", "=", "state_actions", "[", ":", ",", "state_dim", ":", "]", "\n", "np", ".", "clip", "(", "perturbations", ",", "limits", "[", ":", ",", "0", "]", ",", "limits", "[", ":", ",", "1", "]", ",", "out", "=", "perturbations", ")", "\n", "# Remove rows that are not unique", "\n", "state_actions", "=", "unique_rows", "(", "state_actions", ")", "\n", "\n", "", "return", "state_actions", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.get_safe_sample": [[657, 798], ["utilities.with_scope", "utilities.get_storage", "numpy.where", "lyapunov.discretization.index_to_state", "tensorflow.get_default_session", "tf.get_default_session.run", "maps_inside.squeeze.squeeze", "tensorflow.placeholder", "lyapunov.policy", "tensorflow.placeholder", "lyapunov.dynamics", "tensorflow.reduce_sum", "lyapunov.lipschitz_lyapunov", "tensorflow.reduce_sum", "lyapunov.lyapunov_function", "tensorflow.less", "utilities.set_storage", "utilities.get_storage.values", "numpy.random.choice", "numpy.column_stack", "lyapunov.policy.eval", "lyapunov.perturb_actions", "lyapunov.discretization.state_to_index", "len", "warnings.warn", "numpy.array", "lyapunov.perturb_actions", "tf.get_default_session.run", "numpy.argmax", "bound[].squeeze", "numpy.argmax", "bound_safe[].squeeze", "len", "len", "arr.ravel", "numpy.meshgrid"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.lipschitz_lyapunov", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.set_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.perturb_actions", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.perturb_actions"], ["@", "with_scope", "(", "'get_safe_sample'", ")", "\n", "def", "get_safe_sample", "(", "lyapunov", ",", "perturbations", "=", "None", ",", "limits", "=", "None", ",", "positive", "=", "False", ",", "\n", "num_samples", "=", "None", ",", "actions", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute a safe state-action pair for sampling.\n\n    This function returns the most uncertain state-action pair close to the\n    current policy (as a result of the perturbations) that is safe (maps\n    back into the region of attraction).\n\n    Parameters\n    ----------\n    lyapunov : instance of `Lyapunov'\n        A Lyapunov instance with an up-to-date safe set.\n    perturbations : ndarray\n        An array that, on each row, has a perturbation that is added to the\n        baseline policy in `lyapunov.policy`.\n    limits : ndarray, optional\n        The actuator limits. Of the form [(u_1_min, u_1_max), (u_2_min,..)...].\n        If provided, state-action pairs are clipped to ensure the limits.\n    positive : bool\n        Whether the Lyapunov function is positive-definite (radially\n        increasing). If not, additional checks are carried out to ensure\n        safety of samples.\n    num_samples : int, optional\n        Number of samples to select (uniformly at random) from the safe\n        states within lyapunov.discretization as testing points.\n    actions : ndarray\n        A list of actions to evaluate for each state. Ignored if perturbations\n        is not None.\n\n    Returns\n    -------\n    state-action : ndarray\n        A row-vector that contains a safe state-action pair that is\n        promising for obtaining future observations.\n    var : float\n        The uncertainty remaining at this state.\n\n    \"\"\"", "\n", "state_dim", "=", "lyapunov", ".", "discretization", ".", "ndim", "\n", "if", "perturbations", "is", "None", ":", "\n", "        ", "action_dim", "=", "actions", ".", "shape", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "action_dim", "=", "perturbations", ".", "shape", "[", "1", "]", "\n", "", "action_limits", "=", "limits", "\n", "\n", "storage", "=", "get_storage", "(", "_STORAGE", ",", "index", "=", "lyapunov", ")", "\n", "\n", "if", "storage", "is", "None", ":", "\n", "        ", "tf_states", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "shape", "=", "[", "None", ",", "state_dim", "]", ")", "\n", "tf_actions", "=", "lyapunov", ".", "policy", "(", "tf_states", ")", "\n", "\n", "# Placeholder for state-actions to evaluate", "\n", "tf_state_actions", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "\n", "shape", "=", "[", "None", ",", "state_dim", "+", "action_dim", "]", ")", "\n", "\n", "# Account for deviations of the next value due to uncertainty", "\n", "tf_mean", ",", "tf_std", "=", "lyapunov", ".", "dynamics", "(", "tf_state_actions", ")", "\n", "tf_bound", "=", "tf", ".", "reduce_sum", "(", "tf_std", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "tf_lv", "=", "lyapunov", ".", "lipschitz_lyapunov", "(", "tf_mean", ")", "\n", "tf_error", "=", "tf", ".", "reduce_sum", "(", "tf_lv", "*", "tf_std", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "tf_mean_future_values", "=", "lyapunov", ".", "lyapunov_function", "(", "tf_mean", ")", "\n", "\n", "# Check whether the value is below c_max", "\n", "tf_future_values", "=", "tf_mean_future_values", "+", "tf_error", "\n", "tf_maps_inside", "=", "tf", ".", "less", "(", "tf_future_values", ",", "lyapunov", ".", "c_max", ",", "\n", "name", "=", "'maps_inside_levelset'", ")", "\n", "\n", "# Put everything into storage", "\n", "storage", "=", "[", "(", "'tf_states'", ",", "tf_states", ")", ",", "\n", "(", "'tf_actions'", ",", "tf_actions", ")", ",", "\n", "(", "'tf_state_actions'", ",", "tf_state_actions", ")", ",", "\n", "(", "'tf_mean'", ",", "tf_mean", ")", ",", "\n", "(", "'tf_bound'", ",", "tf_bound", ")", ",", "\n", "(", "'tf_maps_inside'", ",", "tf_maps_inside", ")", "]", "\n", "set_storage", "(", "_STORAGE", ",", "storage", ",", "index", "=", "lyapunov", ")", "\n", "", "else", ":", "\n", "        ", "(", "tf_states", ",", "tf_actions", ",", "tf_state_actions", ",", "tf_mean", ",", "tf_bound", ",", "\n", "tf_maps_inside", ")", "=", "storage", ".", "values", "(", ")", "\n", "\n", "# Subsample from all safe states within the discretization", "\n", "", "safe_idx", "=", "np", ".", "where", "(", "lyapunov", ".", "safe_set", ")", "\n", "safe_states", "=", "lyapunov", ".", "discretization", ".", "index_to_state", "(", "safe_idx", ")", "\n", "if", "num_samples", "is", "not", "None", "and", "len", "(", "safe_states", ")", ">", "num_samples", ":", "\n", "        ", "idx", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "safe_states", ")", ",", "num_samples", ",", "replace", "=", "True", ")", "\n", "safe_states", "=", "safe_states", "[", "idx", "]", "\n", "\n", "# Update the feed_dict accordingly", "\n", "", "feed_dict", "=", "lyapunov", ".", "feed_dict", "\n", "feed_dict", "[", "tf_states", "]", "=", "safe_states", "\n", "\n", "if", "perturbations", "is", "None", ":", "\n", "# Generate all state-action pairs", "\n", "        ", "arrays", "=", "[", "arr", ".", "ravel", "(", ")", "for", "arr", "in", "np", ".", "meshgrid", "(", "safe_states", ",", "\n", "actions", ",", "\n", "indexing", "=", "'ij'", ")", "]", "\n", "state_actions", "=", "np", ".", "column_stack", "(", "arrays", ")", "\n", "", "else", ":", "\n", "# Generate state-action pairs around the current policy", "\n", "        ", "safe_actions", "=", "tf_actions", ".", "eval", "(", "feed_dict", "=", "feed_dict", ")", "\n", "state_actions", "=", "perturb_actions", "(", "safe_states", ",", "\n", "safe_actions", ",", "\n", "perturbations", "=", "perturbations", ",", "\n", "limits", "=", "action_limits", ")", "\n", "\n", "# Update feed value", "\n", "", "lyapunov", ".", "feed_dict", "[", "tf_state_actions", "]", "=", "state_actions", "\n", "\n", "# Evaluate the safety of the proposed state-action pairs", "\n", "session", "=", "tf", ".", "get_default_session", "(", ")", "\n", "(", "maps_inside", ",", "mean", ",", "bound", ")", "=", "session", ".", "run", "(", "[", "tf_maps_inside", ",", "tf_mean", ",", "\n", "tf_bound", "]", ",", "\n", "feed_dict", "=", "lyapunov", ".", "feed_dict", ")", "\n", "maps_inside", "=", "maps_inside", ".", "squeeze", "(", "axis", "=", "1", ")", "\n", "\n", "# Check whether states map back to the safe set in expectation", "\n", "if", "not", "positive", ":", "\n", "        ", "next_state_index", "=", "lyapunov", ".", "discretization", ".", "state_to_index", "(", "mean", ")", "\n", "safe_in_expectation", "=", "lyapunov", ".", "safe_set", "[", "next_state_index", "]", "\n", "maps_inside", "&=", "safe_in_expectation", "\n", "\n", "# Return only state-actions pairs that are safe", "\n", "", "bound_safe", "=", "bound", "[", "maps_inside", "]", "\n", "if", "len", "(", "bound_safe", ")", "==", "0", ":", "\n", "# Nothing is safe, so revert to backup policy", "\n", "        ", "msg", "=", "\"No safe state-action pairs found! Using backup policy ...\"", "\n", "warnings", ".", "warn", "(", "msg", ",", "RuntimeWarning", ")", "\n", "zero_perturbation", "=", "np", ".", "array", "(", "[", "[", "0.", "]", "]", ",", "dtype", "=", "config", ".", "np_dtype", ")", "\n", "state_actions", "=", "perturb_actions", "(", "safe_states", ",", "\n", "safe_actions", ",", "\n", "perturbations", "=", "zero_perturbation", ",", "\n", "limits", "=", "action_limits", ")", "\n", "lyapunov", ".", "feed_dict", "[", "tf_state_actions", "]", "=", "state_actions", "\n", "bound", "=", "session", ".", "run", "(", "tf_bound", ",", "feed_dict", "=", "lyapunov", ".", "feed_dict", ")", "\n", "max_id", "=", "np", ".", "argmax", "(", "bound", ")", "\n", "max_bound", "=", "bound", "[", "max_id", "]", ".", "squeeze", "(", ")", "\n", "return", "state_actions", "[", "[", "max_id", "]", "]", ",", "max_bound", "\n", "", "else", ":", "\n", "        ", "max_id", "=", "np", ".", "argmax", "(", "bound_safe", ")", "\n", "max_bound", "=", "bound_safe", "[", "max_id", "]", ".", "squeeze", "(", ")", "\n", "return", "state_actions", "[", "maps_inside", ",", ":", "]", "[", "[", "max_id", "]", "]", ",", "max_bound", "\n", "", "", ""]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.configuration.Configuration.__init__": [[11, 20], ["object.__init__"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialization.\"\"\"", "\n", "super", "(", "Configuration", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Dtype for computations", "\n", "self", ".", "dtype", "=", "tf", ".", "float64", "\n", "\n", "# Batch size for stability verification", "\n", "self", ".", "gp_batch_size", "=", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.configuration.Configuration.np_dtype": [[21, 25], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "np_dtype", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the numpy dtype.\"\"\"", "\n", "return", "self", ".", "dtype", ".", "as_numpy_dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.configuration.Configuration.__repr__": [[26, 33], ["configuration.Configuration.__dict__.items", "params.append", "value.__repr__"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.configuration.Configuration.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Print the parameters.\"\"\"", "\n", "params", "=", "[", "'Configuration parameters:'", ",", "''", "]", "\n", "for", "param", ",", "value", "in", "self", ".", "__dict__", ".", "items", "(", ")", ":", "\n", "            ", "params", ".", "append", "(", "'{}: {}'", ".", "format", "(", "param", ",", "value", ".", "__repr__", "(", ")", ")", ")", "\n", "\n", "", "return", "'\\n'", ".", "join", "(", "params", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestFunction.testing_class": [[27, 42], ["pytest.fixture", "tensorflow.Session", "object.__init__", "tensorflow.variable_scope", "tensorflow.Variable", "tensorflow.get_default_session", "tensorflow.get_default_session.run", "tensorflow.variables_initializer"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "'class'", ")", "\n", "def", "testing_class", "(", "self", ")", ":", "\n", "        ", "class", "A", "(", "DeterministicFunction", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ",", "value", ",", "name", "=", "'a'", ")", ":", "\n", "                ", "super", "(", "A", ",", "self", ")", ".", "__init__", "(", ")", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope_name", ")", ":", "\n", "                    ", "self", ".", "variable", "=", "tf", ".", "Variable", "(", "value", ")", "\n", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "sess", ".", "run", "(", "tf", ".", "variables_initializer", "(", "[", "self", ".", "variable", "]", ")", ")", "\n", "\n", "", "", "def", "build_evaluation", "(", "self", ",", "point", ")", ":", "\n", "                ", "return", "self", ".", "variable", "*", "point", "\n", "\n", "", "", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "return", "A", ",", "sess", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestFunction.test_class": [[43, 56], ["sess.as_default", "A", "numpy.array", "A.", "numpy.testing.assert_allclose", "A.", "numpy.testing.assert_allclose", "A.eval", "A.eval"], "methods", ["None"], ["", "def", "test_class", "(", "self", ",", "testing_class", ")", ":", "\n", "        ", "\"\"\"Test that the class is working.\"\"\"", "\n", "A", ",", "sess", "=", "testing_class", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "            ", "a", "=", "A", "(", "2.", ")", "\n", "input", "=", "np", ".", "array", "(", "1.", ")", "\n", "\n", "output", "=", "a", "(", "input", ")", "\n", "assert_allclose", "(", "2.", "*", "input", ",", "output", ".", "eval", "(", ")", ")", "\n", "\n", "# Test double output", "\n", "output2", "=", "a", "(", "input", ")", "\n", "assert_allclose", "(", "2.", "*", "input", ",", "output2", ".", "eval", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestFunction.test_add": [[57, 73], ["sess.as_default", "A", "A", "numpy.array", "a", "numpy.testing.assert_allclose", "a.eval"], "methods", ["None"], ["", "", "def", "test_add", "(", "self", ",", "testing_class", ")", ":", "\n", "        ", "\"\"\"Test adding functions.\"\"\"", "\n", "A", ",", "sess", "=", "testing_class", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "            ", "a1", "=", "A", "(", "3.", ")", "\n", "a2", "=", "A", "(", "2.", ")", "\n", "\n", "a", "=", "a1", "+", "a2", "\n", "\n", "input", "=", "np", ".", "array", "(", "1.", ")", "\n", "output", "=", "a", "(", "input", ")", "\n", "\n", "assert_allclose", "(", "5.", "*", "input", ",", "output", ".", "eval", "(", ")", ")", "\n", "\n", "assert", "a1", ".", "parameters", "[", "0", "]", "in", "a", ".", "parameters", "\n", "assert", "a2", ".", "parameters", "[", "0", "]", "in", "a", ".", "parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestFunction.test_mult": [[74, 95], ["sess.as_default", "A", "A", "numpy.array", "a", "numpy.testing.assert_allclose", "a", "numpy.testing.assert_allclose", "a.eval", "a.eval"], "methods", ["None"], ["", "", "def", "test_mult", "(", "self", ",", "testing_class", ")", ":", "\n", "        ", "\"\"\"Test multiplying functions.\"\"\"", "\n", "A", ",", "sess", "=", "testing_class", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "            ", "a1", "=", "A", "(", "3.", ")", "\n", "a2", "=", "A", "(", "2.", ")", "\n", "\n", "a", "=", "a1", "*", "a2", "\n", "\n", "input", "=", "np", ".", "array", "(", "1.", ")", "\n", "output", "=", "a", "(", "input", ")", "\n", "\n", "assert_allclose", "(", "6.", "*", "input", ",", "output", ".", "eval", "(", ")", ")", "\n", "\n", "assert", "a1", ".", "parameters", "[", "0", "]", "in", "a", ".", "parameters", "\n", "assert", "a2", ".", "parameters", "[", "0", "]", "in", "a", ".", "parameters", "\n", "\n", "# Test multiplying with constant", "\n", "a", "=", "a1", "*", "2.", "\n", "output", "=", "a", "(", "input", ")", "\n", "assert_allclose", "(", "6.", "*", "input", ",", "output", ".", "eval", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestFunction.test_neg": [[96, 109], ["sess.as_default", "A", "numpy.array", "b", "numpy.testing.assert_allclose", "b.eval"], "methods", ["None"], ["", "", "def", "test_neg", "(", "self", ",", "testing_class", ")", ":", "\n", "        ", "\"\"\"Test multiplying functions.\"\"\"", "\n", "A", ",", "sess", "=", "testing_class", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "            ", "a", "=", "A", "(", "3.", ")", "\n", "b", "=", "-", "a", "\n", "\n", "input", "=", "np", ".", "array", "(", "2.", ")", "\n", "output", "=", "b", "(", "input", ")", "\n", "\n", "assert_allclose", "(", "-", "3.", "*", "input", ",", "output", ".", "eval", "(", ")", ")", "\n", "\n", "assert", "a", ".", "parameters", "[", "0", "]", "is", "b", ".", "parameters", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestFunction.test_copy": [[110, 123], ["sess.as_default", "A", "A", "A.copy_parameters", "p1.eval", "p2.eval"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.Saturation.copy_parameters"], ["", "", "def", "test_copy", "(", "self", ",", "testing_class", ")", ":", "\n", "        ", "\"\"\"Test copying.\"\"\"", "\n", "A", ",", "sess", "=", "testing_class", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "            ", "a", "=", "A", "(", "2.", ")", "\n", "b", "=", "A", "(", "3.", ")", "\n", "b", ".", "copy_parameters", "(", "a", ")", "\n", "\n", "p1", "=", "a", ".", "parameters", "[", "0", "]", "\n", "p2", "=", "b", ".", "parameters", "[", "0", "]", "\n", "\n", "assert", "p1", ".", "eval", "(", ")", "==", "p2", ".", "eval", "(", ")", "\n", "assert", "p1", "is", "not", "p2", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestDeterministicFuction.test_errors": [[128, 132], ["safe_learning.functions.DeterministicFunction", "pytest.raises"], "methods", ["None"], ["def", "test_errors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check notImplemented error.\"\"\"", "\n", "f", "=", "DeterministicFunction", "(", ")", "\n", "pytest", ".", "raises", "(", "NotImplementedError", ",", "f", ".", "build_evaluation", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestUncertainFunction.test_errors": [[137, 141], ["safe_learning.functions.UncertainFunction", "pytest.raises"], "methods", ["None"], ["def", "test_errors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check notImplemented error.\"\"\"", "\n", "f", "=", "UncertainFunction", "(", ")", "\n", "pytest", ".", "raises", "(", "NotImplementedError", ",", "f", ".", "build_evaluation", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestUncertainFunction.test_mean_function": [[142, 148], ["safe_learning.functions.UncertainFunction", "safe_learning.functions.UncertainFunction.to_mean_function", "safe_learning.functions.UncertainFunction.to_mean_function."], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.UncertainFunction.to_mean_function"], ["", "def", "test_mean_function", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the conversion to a deterministic function.\"\"\"", "\n", "f", "=", "UncertainFunction", "(", ")", "\n", "f", ".", "build_evaluation", "=", "lambda", "x", ":", "(", "1", ",", "2", ")", "\n", "fd", "=", "f", ".", "to_mean_function", "(", ")", "\n", "assert", "(", "fd", "(", "None", ")", "==", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestGPRCached.gps": [[154, 163], ["pytest.fixture", "numpy.array", "numpy.array", "gpflow.kernels.RBF", "gpflow.gpr.GPR", "safe_learning.functions.GPRCached"], "methods", ["None"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "\"class\"", ")", "\n", "def", "gps", "(", "self", ")", ":", "\n", "        ", "\"\"\"Create cached and uncached gpflow models and GPy model.\"\"\"", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "1", "]", "]", ",", "dtype", "=", "float", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "1", "]", "]", ",", "dtype", "=", "float", ")", "\n", "kernel", "=", "gpflow", ".", "kernels", ".", "RBF", "(", "2", ")", "\n", "gp", "=", "gpflow", ".", "gpr", ".", "GPR", "(", "x", ",", "y", ",", "kernel", ")", "\n", "gp_cached", "=", "GPRCached", "(", "x", ",", "y", ",", "kernel", ")", "\n", "return", "gp", ",", "gp_cached", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestGPRCached.test_adding_data": [[164, 189], ["numpy.array", "safe_learning.functions.GaussianProcess", "safe_learning.functions.GaussianProcess", "numpy.array", "numpy.array", "safe_learning.functions.GaussianProcess.add_data_point", "safe_learning.functions.GaussianProcess.", "safe_learning.functions.GaussianProcess.add_data_point", "safe_learning.functions.GaussianProcess.", "safe_learning.functions.GaussianProcess.feed_dict.copy", "safe_learning.functions.GaussianProcess.feed_dict.copy.update", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "tensorflow.Session", "sess.run"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.add_data_point", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.add_data_point"], ["", "def", "test_adding_data", "(", "self", ",", "gps", ")", ":", "\n", "        ", "\"\"\"Test that adding data works.\"\"\"", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "0.9", ",", "0.1", "]", ",", "[", "3.", ",", "2", "]", "]", ")", "\n", "\n", "gp", ",", "gp_cached", "=", "gps", "\n", "gpfun", "=", "GaussianProcess", "(", "gp", ")", "\n", "gpfun_cached", "=", "GaussianProcess", "(", "gp_cached", ")", "\n", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "1.2", ",", "2.3", "]", "]", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "[", "2.4", "]", "]", ")", "\n", "\n", "gpfun", ".", "add_data_point", "(", "x", ",", "y", ")", "\n", "m1", ",", "v1", "=", "gpfun", "(", "test_points", ")", "\n", "\n", "gpfun_cached", ".", "add_data_point", "(", "x", ",", "y", ")", "\n", "m2", ",", "v2", "=", "gpfun_cached", "(", "test_points", ")", "\n", "\n", "feed_dict", "=", "gpfun", ".", "feed_dict", ".", "copy", "(", ")", "\n", "feed_dict", ".", "update", "(", "gpfun_cached", ".", "feed_dict", ")", "\n", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "            ", "m1", ",", "v1", ",", "m2", ",", "v2", "=", "sess", ".", "run", "(", "[", "m1", ",", "v1", ",", "m2", ",", "v2", "]", ",", "feed_dict", "=", "feed_dict", ")", "\n", "\n", "", "assert_allclose", "(", "m1", ",", "m2", ")", "\n", "assert_allclose", "(", "v1", ",", "v2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestGPRCached.test_predict_f": [[190, 200], ["numpy.array", "gp_cached.predict_f", "gp.predict_f", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose"], "methods", ["None"], ["", "def", "test_predict_f", "(", "self", ",", "gps", ")", ":", "\n", "        ", "\"\"\"Make sure predictions is same as in uncached case.\"\"\"", "\n", "# Note that this messes things up terribly due to caching. So this", "\n", "# must be the last test that we run.", "\n", "gp", ",", "gp_cached", "=", "gps", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "0.9", ",", "0.1", "]", ",", "[", "3.", ",", "2", "]", "]", ")", "\n", "a1", ",", "b1", "=", "gp_cached", ".", "predict_f", "(", "test_points", ")", "\n", "a2", ",", "b2", "=", "gp", ".", "predict_f", "(", "test_points", ")", "\n", "assert_allclose", "(", "a1", ",", "a2", ")", "\n", "assert_allclose", "(", "b1", ",", "b2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.Testgpflow.setup": [[206, 215], ["pytest.fixture", "tensorflow.Session", "numpy.array", "numpy.array", "gpflow.kernels.RBF", "gpflow.gpr.GPR"], "methods", ["None"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "\"class\"", ")", "\n", "def", "setup", "(", "self", ")", ":", "\n", "        ", "\"\"\"Create GP model with gpflow and GPy.\"\"\"", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "            ", "x", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "1", "]", "]", ",", "dtype", "=", "float", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "1", "]", "]", ",", "dtype", "=", "float", ")", "\n", "kernel", "=", "gpflow", ".", "kernels", ".", "RBF", "(", "2", ")", "\n", "gp", "=", "gpflow", ".", "gpr", ".", "GPR", "(", "x", ",", "y", ",", "kernel", ")", "\n", "yield", "sess", ",", "gp", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.Testgpflow.test_evaluation": [[216, 236], ["numpy.array", "safe_learning.functions.GaussianProcess", "safe_learning.functions.GaussianProcess.", "sess.run", "safe_learning.functions.GaussianProcess.", "sess.run", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose"], "methods", ["None"], ["", "", "def", "test_evaluation", "(", "self", ",", "setup", ")", ":", "\n", "        ", "\"\"\"Make sure evaluation works.\"\"\"", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "0.9", ",", "0.1", "]", ",", "[", "3.", ",", "2", "]", "]", ")", "\n", "beta", "=", "3.0", "\n", "sess", ",", "gp", "=", "setup", "\n", "\n", "ufun", "=", "GaussianProcess", "(", "gp", ",", "beta", "=", "beta", ")", "\n", "\n", "# Evaluate GP", "\n", "mean_1", ",", "error_1", "=", "ufun", "(", "test_points", ")", "\n", "mean_1", ",", "error_1", "=", "sess", ".", "run", "(", "[", "mean_1", ",", "error_1", "]", ",", "\n", "feed_dict", "=", "ufun", ".", "feed_dict", ")", "\n", "\n", "# Test multiple inputs", "\n", "mean_2", ",", "error_2", "=", "ufun", "(", "test_points", "[", ":", ",", "[", "0", "]", "]", ",", "\n", "test_points", "[", ":", ",", "[", "1", "]", "]", ")", "\n", "mean_2", ",", "error_2", "=", "sess", ".", "run", "(", "[", "mean_2", ",", "error_2", "]", ",", "feed_dict", "=", "ufun", ".", "feed_dict", ")", "\n", "\n", "assert_allclose", "(", "mean_1", ",", "mean_2", ")", "\n", "assert_allclose", "(", "error_1", ",", "error_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.Testgpflow.test_new_data": [[237, 262], ["numpy.array", "safe_learning.functions.GaussianProcess", "numpy.array", "numpy.array", "safe_learning.functions.GaussianProcess.add_data_point", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "safe_learning.functions.GaussianProcess.", "sess.run", "numpy.array", "numpy.array", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GaussianProcess.add_data_point"], ["", "def", "test_new_data", "(", "self", ",", "setup", ")", ":", "\n", "        ", "\"\"\"Test adding data points to the GP.\"\"\"", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "0.9", ",", "0.1", "]", ",", "[", "3.", ",", "2", "]", "]", ")", "\n", "sess", ",", "gp", "=", "setup", "\n", "\n", "ufun", "=", "GaussianProcess", "(", "gp", ")", "\n", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "1.2", ",", "2.3", "]", "]", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "[", "2.4", "]", "]", ")", "\n", "\n", "ufun", ".", "add_data_point", "(", "x", ",", "y", ")", "\n", "\n", "assert_allclose", "(", "ufun", ".", "X", ",", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "[", "1.2", ",", "2.3", "]", "]", ")", ")", "\n", "assert_allclose", "(", "ufun", ".", "Y", ",", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "1", "]", ",", "[", "2.4", "]", "]", ")", ")", "\n", "\n", "# Check prediction is correct after adding data (cholesky update)", "\n", "a1", ",", "b1", "=", "ufun", "(", "test_points", ")", "\n", "a1", ",", "b1", "=", "sess", ".", "run", "(", "[", "a1", ",", "b1", "]", ",", "feed_dict", "=", "ufun", ".", "feed_dict", ")", "\n", "\n", "a1_true", "=", "np", ".", "array", "(", "[", "[", "0.16371139", "]", ",", "[", "0.22048311", "]", "]", ")", "\n", "b1_true", "=", "np", ".", "array", "(", "[", "[", "1.37678679", "]", ",", "[", "1.98183191", "]", "]", ")", "\n", "assert_allclose", "(", "a1", ",", "a1_true", ")", "\n", "assert_allclose", "(", "b1", ",", "b1_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestQuadraticFunction.test_evaluate": [[267, 283], ["numpy.array", "numpy.array", "safe_learning.functions.QuadraticFunction", "numpy.testing.assert_allclose", "numpy.array", "tensorflow.Session", "safe_learning.functions.QuadraticFunction.", "safe_learning.functions.QuadraticFunction.eval"], "methods", ["None"], ["def", "test_evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"Setup testing environment for quadratic.\"\"\"", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", "]", "]", ",", "dtype", "=", "np", ".", "float", ")", "\n", "P", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0.1", "]", ",", "\n", "[", "0.2", ",", "2.", "]", "]", ")", "\n", "quad", "=", "QuadraticFunction", "(", "P", ")", "\n", "true_fval", "=", "np", ".", "array", "(", "[", "[", "0.", ",", "2.", ",", "1.", ",", "3.3", "]", "]", ")", ".", "T", "\n", "\n", "with", "tf", ".", "Session", "(", ")", ":", "\n", "            ", "tf_res", "=", "quad", "(", "points", ")", "\n", "res", "=", "tf_res", ".", "eval", "(", ")", "\n", "\n", "", "assert_allclose", "(", "true_fval", ",", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestGridworld.test_dimensions_error": [[301, 312], ["safe_learning.functions.GridWorld", "pytest.raises", "pytest.raises", "numpy.array", "numpy.array"], "methods", ["None"], ["def", "test_dimensions_error", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test dimension errors.\"\"\"", "\n", "limits", "=", "[", "[", "-", "1.1", ",", "1.5", "]", ",", "[", "2.2", ",", "2.4", "]", "]", "\n", "num_points", "=", "[", "7", ",", "8", "]", "\n", "grid", "=", "GridWorld", "(", "limits", ",", "num_points", ")", "\n", "\n", "pytest", ".", "raises", "(", "DimensionError", ",", "grid", ".", "_check_dimensions", ",", "\n", "np", ".", "array", "(", "[", "[", "1", ",", "2", ",", "3", "]", "]", ")", ")", "\n", "\n", "pytest", ".", "raises", "(", "DimensionError", ",", "grid", ".", "_check_dimensions", ",", "\n", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestGridworld.test_index_state_conversion": [[313, 351], ["safe_learning.functions.GridWorld", "numpy.arange", "safe_learning.functions.GridWorld.index_to_state", "safe_learning.functions.GridWorld.state_to_index", "numpy.testing.assert_equal", "safe_learning.functions.GridWorld.state_to_index", "safe_learning.functions.GridWorld.index_to_state", "numpy.arange", "safe_learning.functions.GridWorld.rectangle_to_state", "safe_learning.functions.GridWorld.state_to_rectangle", "numpy.testing.assert_equal", "safe_learning.functions.GridWorld.state_to_rectangle", "numpy.testing.assert_equal", "safe_learning.functions.GridWorld.state_to_rectangle", "numpy.testing.assert_equal", "safe_learning.functions.GridWorld.rectangle_corner_index", "safe_learning.functions.GridWorld.rectangle_to_state", "safe_learning.functions.GridWorld.state_to_index", "numpy.testing.assert_equal", "numpy.array", "safe_learning.functions.GridWorld.state_to_index", "numpy.testing.assert_equal", "numpy.ones", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.rectangle_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_rectangle", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_rectangle", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_rectangle", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.rectangle_corner_index", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.rectangle_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index"], ["", "def", "test_index_state_conversion", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test all index conversions.\"\"\"", "\n", "limits", "=", "[", "[", "-", "1.1", ",", "1.5", "]", ",", "[", "2.2", ",", "2.4", "]", "]", "\n", "num_points", "=", "[", "7", ",", "8", "]", "\n", "grid", "=", "GridWorld", "(", "limits", ",", "num_points", ")", "\n", "\n", "# Forward and backwards convert all indeces", "\n", "indeces", "=", "np", ".", "arange", "(", "grid", ".", "nindex", ")", "\n", "states", "=", "grid", ".", "index_to_state", "(", "indeces", ")", "\n", "indeces2", "=", "grid", ".", "state_to_index", "(", "states", ")", "\n", "assert_equal", "(", "indeces", ",", "indeces2", ")", "\n", "\n", "# test 1D input", "\n", "grid", ".", "state_to_index", "(", "[", "0", ",", "2.3", "]", ")", "\n", "grid", ".", "index_to_state", "(", "1", ")", "\n", "\n", "# Test rectangles", "\n", "rectangles", "=", "np", ".", "arange", "(", "grid", ".", "nrectangles", ")", "\n", "states", "=", "grid", ".", "rectangle_to_state", "(", "rectangles", ")", "\n", "rectangles2", "=", "grid", ".", "state_to_rectangle", "(", "states", "+", "grid", ".", "unit_maxes", "/", "2", ")", "\n", "assert_equal", "(", "rectangles", ",", "rectangles2", ")", "\n", "\n", "rectangle", "=", "grid", ".", "state_to_rectangle", "(", "100", "*", "np", ".", "ones", "(", "(", "1", ",", "2", ")", ")", ")", "\n", "assert_equal", "(", "rectangle", ",", "grid", ".", "nrectangles", "-", "1", ")", "\n", "\n", "rectangle", "=", "grid", ".", "state_to_rectangle", "(", "-", "100", "*", "np", ".", "ones", "(", "(", "1", ",", "2", ")", ")", ")", "\n", "assert_equal", "(", "rectangle", ",", "0", ")", "\n", "\n", "# Test rectangle corners", "\n", "corners", "=", "grid", ".", "rectangle_corner_index", "(", "rectangles", ")", "\n", "corner_states", "=", "grid", ".", "rectangle_to_state", "(", "rectangles", ")", "\n", "corners2", "=", "grid", ".", "state_to_index", "(", "corner_states", ")", "\n", "assert_equal", "(", "corners", ",", "corners2", ")", "\n", "\n", "# Test point outside grid", "\n", "test_point", "=", "np", ".", "array", "(", "[", "[", "-", "1.2", ",", "2.", "]", "]", ")", "\n", "index", "=", "grid", ".", "state_to_index", "(", "test_point", ")", "\n", "assert_equal", "(", "index", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestGridworld.test_integer_numpoints": [[352, 356], ["safe_learning.functions.GridWorld", "numpy.testing.assert_equal", "numpy.array"], "methods", ["None"], ["", "def", "test_integer_numpoints", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check integer numpoints argument.\"\"\"", "\n", "grid", "=", "GridWorld", "(", "[", "[", "1", ",", "2", "]", ",", "[", "3", ",", "4", "]", "]", ",", "2", ")", "\n", "assert_equal", "(", "grid", ".", "num_points", ",", "np", ".", "array", "(", "[", "2", ",", "2", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestGridworld.test_0d": [[357, 368], ["safe_learning.functions.GridWorld", "numpy.array", "numpy.testing.assert_allclose", "numpy.array", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.array", "safe_learning.functions.GridWorld.state_to_index", "safe_learning.functions.GridWorld.state_to_rectangle", "safe_learning.functions.GridWorld.rectangle_to_state"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_rectangle", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.rectangle_to_state"], ["", "def", "test_0d", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check that initialization works for 1d-discretization.\"\"\"", "\n", "grid", "=", "GridWorld", "(", "[", "[", "0", ",", "1", "]", "]", ",", "3", ")", "\n", "\n", "test", "=", "np", ".", "array", "(", "[", "[", "0.1", ",", "0.4", ",", "0.9", "]", "]", ")", ".", "T", "\n", "res", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "assert_allclose", "(", "grid", ".", "state_to_index", "(", "test", ")", ",", "res", ")", "\n", "\n", "res", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", "\n", "assert_allclose", "(", "grid", ".", "state_to_rectangle", "(", "test", ")", ",", "res", ")", "\n", "assert_allclose", "(", "grid", ".", "rectangle_to_state", "(", "res", ")", ",", "res", "[", ":", ",", "None", "]", "*", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.fun": [[373, 377], ["safe_learning.utilities.concatenate_inputs"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs"], ["@", "concatenate_inputs", "(", "start", "=", "1", ")", "\n", "def", "fun", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Test function.\"\"\"", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.test_concatenate_numpy": [[378, 386], ["numpy.arange().reshape", "numpy.hstack", "test_functions.TestConcatenateDecorator.fun", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "test_functions.TestConcatenateDecorator.fun", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.fun", "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.fun"], ["", "def", "test_concatenate_numpy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test concatenation of inputs for numpy.\"\"\"", "\n", "x", "=", "np", ".", "arange", "(", "4", ")", ".", "reshape", "(", "2", ",", "2", ")", "\n", "y", "=", "x", "+", "4", "\n", "true_res", "=", "np", ".", "hstack", "(", "(", "x", ",", "y", ")", ")", "\n", "res", "=", "self", ".", "fun", "(", "x", ",", "y", ")", "\n", "assert_allclose", "(", "res", ",", "true_res", ")", "\n", "assert_allclose", "(", "self", ".", "fun", "(", "x", ")", ",", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.test_concatenate_tensorflow": [[387, 406], ["numpy.arange().reshape().astype", "numpy.hstack", "tensorflow.placeholder", "test_functions.TestConcatenateDecorator.fun", "test_functions.TestConcatenateDecorator.fun", "isinstance", "isinstance", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "tensorflow.Session", "sess.run", "numpy.arange().reshape", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.fun", "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestConcatenateDecorator.fun"], ["", "def", "test_concatenate_tensorflow", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test concatenation of inputs for tensorflow.\"\"\"", "\n", "x_data", "=", "np", ".", "arange", "(", "4", ")", ".", "reshape", "(", "2", ",", "2", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "true_res", "=", "np", ".", "hstack", "(", "(", "x_data", ",", "x_data", "+", "4", ")", ")", "\n", "x", "=", "tf", ".", "placeholder", "(", "dtype", "=", "tf", ".", "float32", ",", "shape", "=", "[", "2", ",", "2", "]", ")", "\n", "y", "=", "x", "+", "4", "\n", "\n", "fun_x", "=", "self", ".", "fun", "(", "x", ")", "\n", "fun_xy", "=", "self", ".", "fun", "(", "x", ",", "y", ")", "\n", "\n", "assert", "isinstance", "(", "fun_x", ",", "tf", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "fun_xy", ",", "tf", ".", "Tensor", ")", "\n", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "            ", "res_x", ",", "res_both", "=", "sess", ".", "run", "(", "[", "fun_x", ",", "fun_xy", "]", ",", "\n", "{", "x", ":", "x_data", "}", ")", "\n", "\n", "", "assert_allclose", "(", "res_both", ",", "true_res", ")", "\n", "assert_allclose", "(", "res_x", ",", "x_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestPiecewiseConstant.test_init": [[411, 418], ["safe_learning.functions.GridWorld", "safe_learning.functions.PiecewiseConstant", "numpy.testing.assert_allclose", "numpy.arange", "numpy.arange"], "methods", ["None"], ["def", "test_init", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test initialisation.\"\"\"", "\n", "limits", "=", "[", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "1", "]", "]", "\n", "npoints", "=", "4", "\n", "discretization", "=", "GridWorld", "(", "limits", ",", "npoints", ")", "\n", "pwc", "=", "PiecewiseConstant", "(", "discretization", ",", "np", ".", "arange", "(", "16", ")", ")", "\n", "assert_allclose", "(", "pwc", ".", "parameters", ",", "np", ".", "arange", "(", "16", ")", "[", ":", ",", "None", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestPiecewiseConstant.test_evaluation": [[419, 442], ["safe_learning.functions.GridWorld", "safe_learning.functions.PiecewiseConstant", "safe_learning.functions.PiecewiseConstant.discretization.index_to_state", "numpy.sum", "safe_learning.functions.PiecewiseConstant.", "numpy.testing.assert_allclose", "numpy.array", "safe_learning.functions.PiecewiseConstant.", "numpy.testing.assert_allclose", "safe_learning.functions.PiecewiseConstant.parameter_derivative", "test2.toarray().dot.toarray().dot.toarray().dot", "numpy.testing.assert_allclose", "numpy.arange", "numpy.array", "test2.toarray().dot.toarray().dot.toarray"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.parameter_derivative"], ["", "def", "test_evaluation", "(", "self", ")", ":", "\n", "        ", "\"\"\"Evaluation tests for piecewise constant function.\"\"\"", "\n", "limits", "=", "[", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "1", "]", "]", "\n", "npoints", "=", "3", "\n", "discretization", "=", "GridWorld", "(", "limits", ",", "npoints", ")", "\n", "pwc", "=", "PiecewiseConstant", "(", "discretization", ")", "\n", "\n", "vertex_points", "=", "pwc", ".", "discretization", ".", "index_to_state", "(", "\n", "np", ".", "arange", "(", "pwc", ".", "nindex", ")", ")", "\n", "vertex_values", "=", "np", ".", "sum", "(", "vertex_points", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "pwc", ".", "parameters", "=", "vertex_values", "\n", "\n", "test", "=", "pwc", "(", "vertex_points", ")", "\n", "assert_allclose", "(", "test", ",", "vertex_values", ")", "\n", "\n", "outside_point", "=", "np", ".", "array", "(", "[", "[", "-", "1.5", ",", "-", "1.5", "]", "]", ")", "\n", "test1", "=", "pwc", "(", "outside_point", ")", "\n", "assert_allclose", "(", "test1", ",", "np", ".", "array", "(", "[", "[", "-", "2", "]", "]", ")", ")", "\n", "\n", "# Test constraint evaluation", "\n", "test2", "=", "pwc", ".", "parameter_derivative", "(", "vertex_points", ")", "\n", "test2", "=", "test2", ".", "toarray", "(", ")", ".", "dot", "(", "vertex_values", ")", "\n", "assert_allclose", "(", "test2", ",", "vertex_values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestPiecewiseConstant.test_gradient": [[443, 452], ["safe_learning.functions.GridWorld", "safe_learning.functions.PiecewiseConstant", "safe_learning.functions.PiecewiseConstant.discretization.index_to_state", "safe_learning.functions.PiecewiseConstant.gradient", "numpy.testing.assert_allclose", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.gradient"], ["", "def", "test_gradient", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the gradient.\"\"\"", "\n", "limits", "=", "[", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "1", "]", "]", "\n", "npoints", "=", "3", "\n", "discretization", "=", "GridWorld", "(", "limits", ",", "npoints", ")", "\n", "pwc", "=", "PiecewiseConstant", "(", "discretization", ")", "\n", "test_points", "=", "pwc", ".", "discretization", ".", "index_to_state", "(", "np", ".", "arange", "(", "pwc", ".", "nindex", ")", ")", "\n", "gradient", "=", "pwc", ".", "gradient", "(", "test_points", ")", "\n", "assert_allclose", "(", "gradient", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulationNumpy.test_find_simplex": [[457, 500], ["safe_learning.functions.GridWorld", "safe_learning.functions._Triangulation", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "safe_learning.functions._Triangulation.triangulation.find_simplex().squeeze", "numpy.array", "numpy.array", "safe_learning.functions._Triangulation.find_simplex", "numpy.testing.assert_allclose", "safe_learning.functions._Triangulation.simplices", "numpy.array", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.array", "numpy.array", "numpy.sort", "safe_learning.functions._Triangulation.find_simplex", "safe_learning.functions._Triangulation.find_simplex", "numpy.array", "safe_learning.functions._Triangulation.triangulation.find_simplex", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.simplices", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex"], ["def", "test_find_simplex", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the simplices on the grid.\"\"\"", "\n", "limits", "=", "[", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "2", "]", "]", "\n", "num_points", "=", "[", "3", ",", "7", "]", "\n", "discretization", "=", "GridWorld", "(", "limits", ",", "num_points", ")", "\n", "delaunay", "=", "_Triangulation", "(", "discretization", ")", "\n", "\n", "# Test the basic properties", "\n", "assert_equal", "(", "delaunay", ".", "discretization", ".", "nrectangles", ",", "2", "*", "6", ")", "\n", "assert_equal", "(", "delaunay", ".", "input_dim", ",", "2", ")", "\n", "assert_equal", "(", "delaunay", ".", "nsimplex", ",", "2", "*", "2", "*", "6", ")", "\n", "assert_equal", "(", "delaunay", ".", "discretization", ".", "offset", ",", "np", ".", "array", "(", "[", "-", "1", ",", "-", "1", "]", ")", ")", "\n", "assert_equal", "(", "delaunay", ".", "discretization", ".", "unit_maxes", ",", "\n", "np", ".", "array", "(", "[", "2", ",", "3", "]", ")", "/", "(", "np", ".", "array", "(", "num_points", ")", "-", "1", ")", ")", "\n", "\n", "# test the simplex indices", "\n", "lower", "=", "delaunay", ".", "triangulation", ".", "find_simplex", "(", "np", ".", "array", "(", "[", "0", ",", "0", "]", ")", ")", ".", "squeeze", "(", ")", "\n", "upper", "=", "1", "-", "lower", "\n", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "\n", "[", "0.9", ",", "0.45", "]", ",", "\n", "[", "1.1", ",", "0", "]", ",", "\n", "[", "1.9", ",", "2.9", "]", "]", ")", "\n", "\n", "test_points", "+=", "np", ".", "array", "(", "limits", ")", "[", ":", ",", "0", "]", "\n", "\n", "true_result", "=", "np", ".", "array", "(", "[", "lower", ",", "upper", ",", "6", "*", "2", "+", "lower", ",", "11", "*", "2", "+", "upper", "]", ")", "\n", "result", "=", "delaunay", ".", "find_simplex", "(", "test_points", ")", "\n", "\n", "assert_allclose", "(", "result", ",", "true_result", ")", "\n", "\n", "# Test the ability to find simplices", "\n", "simplices", "=", "delaunay", ".", "simplices", "(", "result", ")", "\n", "true_simplices", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "7", "]", ",", "\n", "[", "1", ",", "7", ",", "8", "]", ",", "\n", "[", "7", ",", "8", ",", "14", "]", ",", "\n", "[", "13", ",", "19", ",", "20", "]", "]", ")", "\n", "assert_equal", "(", "np", ".", "sort", "(", "simplices", ",", "axis", "=", "1", ")", ",", "true_simplices", ")", "\n", "\n", "# Test point ouside domain (should map to bottom left and top right)", "\n", "assert_equal", "(", "lower", ",", "delaunay", ".", "find_simplex", "(", "np", ".", "array", "(", "[", "[", "-", "100.", ",", "-", "100.", "]", "]", ")", ")", ")", "\n", "assert_equal", "(", "delaunay", ".", "nsimplex", "-", "1", "-", "lower", ",", "\n", "delaunay", ".", "find_simplex", "(", "np", ".", "array", "(", "[", "[", "100.", ",", "100.", "]", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulationNumpy.test_values": [[501, 547], ["safe_learning.functions.GridWorld", "safe_learning.functions._Triangulation", "numpy.array", "safe_learning.functions._Triangulation.discretization.state_to_index", "safe_learning.functions._Triangulation.parameter_derivative().toarray", "numpy.zeros", "numpy.testing.assert_allclose", "numpy.random.rand", "safe_learning.functions._Triangulation.", "numpy.testing.assert_allclose", "numpy.array", "numpy.array", "safe_learning.functions._Triangulation.", "safe_learning.functions._Triangulation.", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.array", "safe_learning.functions._Triangulation.parameter_derivative().toarray.dot", "numpy.array", "numpy.array", "safe_learning.functions._Triangulation.parameter_derivative", "len"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.parameter_derivative"], ["", "def", "test_values", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the evaluation function.\"\"\"", "\n", "eps", "=", "1e-10", "\n", "\n", "discretization", "=", "GridWorld", "(", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", "]", ",", "[", "2", ",", "2", "]", ")", "\n", "delaunay", "=", "_Triangulation", "(", "discretization", ")", "\n", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "\n", "[", "1", "-", "eps", ",", "0", "]", ",", "\n", "[", "0", ",", "1", "-", "eps", "]", ",", "\n", "[", "0.5", "-", "eps", ",", "0.5", "-", "eps", "]", ",", "\n", "[", "0", ",", "0.5", "]", ",", "\n", "[", "0.5", ",", "0", "]", "]", ")", "\n", "nodes", "=", "delaunay", ".", "discretization", ".", "state_to_index", "(", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "1", "]", "]", ")", ")", "\n", "\n", "H", "=", "delaunay", ".", "parameter_derivative", "(", "test_points", ")", ".", "toarray", "(", ")", "\n", "\n", "true_H", "=", "np", ".", "zeros", "(", "(", "len", "(", "test_points", ")", ",", "delaunay", ".", "nindex", ")", ",", "\n", "dtype", "=", "np", ".", "float", ")", "\n", "true_H", "[", "0", ",", "nodes", "[", "0", "]", "]", "=", "1", "\n", "true_H", "[", "1", ",", "nodes", "[", "1", "]", "]", "=", "1", "\n", "true_H", "[", "2", ",", "nodes", "[", "2", "]", "]", "=", "1", "\n", "true_H", "[", "3", ",", "nodes", "[", "[", "1", ",", "2", "]", "]", "]", "=", "0.5", "\n", "true_H", "[", "4", ",", "nodes", "[", "[", "0", ",", "2", "]", "]", "]", "=", "0.5", "\n", "true_H", "[", "5", ",", "nodes", "[", "[", "0", ",", "1", "]", "]", "]", "=", "0.5", "\n", "\n", "assert_allclose", "(", "H", ",", "true_H", ",", "atol", "=", "1e-7", ")", "\n", "\n", "# Test value property", "\n", "values", "=", "np", ".", "random", ".", "rand", "(", "delaunay", ".", "nindex", ")", "\n", "delaunay", ".", "parameters", "=", "values", "\n", "v1", "=", "H", ".", "dot", "(", "values", ")", "[", ":", ",", "None", "]", "\n", "v2", "=", "delaunay", "(", "test_points", ")", "\n", "assert_allclose", "(", "v1", ",", "v2", ")", "\n", "\n", "# Test the projections", "\n", "test_point", "=", "np", ".", "array", "(", "[", "[", "-", "0.5", ",", "-", "0.5", "]", "]", ")", "\n", "delaunay", ".", "parameters", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "unprojected", "=", "delaunay", "(", "test_point", ")", "\n", "delaunay", ".", "project", "=", "True", "\n", "projected", "=", "delaunay", "(", "test_point", ")", "\n", "\n", "assert_allclose", "(", "projected", ",", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", ")", "\n", "assert_allclose", "(", "unprojected", ",", "np", ".", "array", "(", "[", "[", "-", "1", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulationNumpy.test_multiple_dimensions": [[548, 581], ["safe_learning.functions.GridWorld", "safe_learning.functions._Triangulation", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.array", "numpy.vstack", "numpy.hstack", "safe_learning.functions._Triangulation.", "numpy.testing.assert_allclose", "numpy.math.factorial", "numpy.sum", "numpy.sum", "safe_learning.functions._Triangulation.discretization.index_to_state", "numpy.array", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.index_to_state"], ["", "def", "test_multiple_dimensions", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test delaunay in three dimensions.\"\"\"", "\n", "limits", "=", "[", "[", "0", ",", "1", "]", "]", "*", "3", "\n", "discretization", "=", "GridWorld", "(", "limits", ",", "[", "2", "]", "*", "3", ")", "\n", "delaunay", "=", "_Triangulation", "(", "discretization", ")", "\n", "assert_equal", "(", "delaunay", ".", "input_dim", ",", "3", ")", "\n", "assert_equal", "(", "delaunay", ".", "discretization", ".", "nrectangles", ",", "1", ")", "\n", "assert_equal", "(", "delaunay", ".", "nsimplex", ",", "np", ".", "math", ".", "factorial", "(", "3", ")", ")", "\n", "\n", "corner_points", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "1", "]", "]", ",", "dtype", "=", "np", ".", "float", ")", "\n", "\n", "values", "=", "np", ".", "sum", "(", "delaunay", ".", "discretization", ".", "index_to_state", "(", "np", ".", "arange", "(", "8", ")", ")", ",", "\n", "axis", "=", "1", ")", "/", "3", "\n", "\n", "test_points", "=", "np", ".", "vstack", "(", "(", "corner_points", ",", "\n", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0.5", "]", ",", "\n", "[", "0.5", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0.5", ",", "0", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "0.5", "]", "]", ")", ")", ")", "\n", "corner_values", "=", "np", ".", "sum", "(", "corner_points", ",", "axis", "=", "1", ")", "/", "3", "\n", "true_values", "=", "np", ".", "hstack", "(", "(", "corner_values", ",", "\n", "np", ".", "array", "(", "[", "1", "/", "6", ",", "1", "/", "6", ",", "1", "/", "6", ",", "1", "/", "2", "]", ")", ")", ")", "\n", "\n", "delaunay", ".", "parameters", "=", "values", "\n", "result", "=", "delaunay", "(", "test_points", ")", "\n", "assert_allclose", "(", "result", ",", "true_values", "[", ":", ",", "None", "]", ",", "atol", "=", "1e-5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulationNumpy.test_gradient": [[582, 625], ["safe_learning.functions.GridWorld", "safe_learning.functions._Triangulation", "numpy.array", "safe_learning.functions._Triangulation.discretization.state_to_index", "numpy.zeros", "numpy.array", "numpy.array", "numpy.zeros", "safe_learning.functions._Triangulation.gradient_parameter_derivative().toarray", "safe_learning.functions._Triangulation.gradient", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "safe_learning.functions._Triangulation.gradient_parameter_derivative().toarray.dot().reshape", "safe_learning.functions._Triangulation.gradient_parameter_derivative", "safe_learning.functions._Triangulation.gradient_parameter_derivative().toarray.dot"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.GridWorld.state_to_index", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.gradient", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.gradient_parameter_derivative"], ["", "def", "test_gradient", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the gradient_at function.\"\"\"", "\n", "discretization", "=", "GridWorld", "(", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", "]", ",", "[", "2", ",", "2", "]", ")", "\n", "delaunay", "=", "_Triangulation", "(", "discretization", ")", "\n", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "1", "]", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "nodes", "=", "delaunay", ".", "discretization", ".", "state_to_index", "(", "points", ")", "\n", "\n", "# Simplex with node values:", "\n", "# 3 - 1", "\n", "# | \\ |", "\n", "# 1 - 2", "\n", "# --> x", "\n", "\n", "values", "=", "np", ".", "zeros", "(", "delaunay", ".", "nindex", ")", "\n", "values", "[", "nodes", "]", "=", "[", "1", ",", "2", ",", "3", ",", "1", "]", "\n", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "0.01", ",", "0.01", "]", ",", "\n", "[", "0.99", ",", "0.99", "]", "]", ")", "\n", "\n", "true_grad", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", "]", ",", "[", "-", "2", ",", "-", "1", "]", "]", ")", "\n", "\n", "# Construct true H (gradient as function of values)", "\n", "true_H", "=", "np", ".", "zeros", "(", "(", "2", "*", "delaunay", ".", "input_dim", ",", "delaunay", ".", "nindex", ")", ")", "\n", "\n", "true_H", "[", "0", ",", "nodes", "[", "[", "0", ",", "1", "]", "]", "]", "=", "[", "-", "1", ",", "1", "]", "\n", "true_H", "[", "1", ",", "nodes", "[", "[", "0", ",", "2", "]", "]", "]", "=", "[", "-", "1", ",", "1", "]", "\n", "true_H", "[", "2", ",", "nodes", "[", "[", "2", ",", "3", "]", "]", "]", "=", "[", "-", "1", ",", "1", "]", "\n", "true_H", "[", "3", ",", "nodes", "[", "[", "1", ",", "3", "]", "]", "]", "=", "[", "-", "1", ",", "1", "]", "\n", "\n", "# Evaluate gradient with and without values", "\n", "H", "=", "delaunay", ".", "gradient_parameter_derivative", "(", "test_points", ")", ".", "toarray", "(", ")", "\n", "delaunay", ".", "parameters", "=", "values", "\n", "grad", "=", "delaunay", ".", "gradient", "(", "test_points", ")", "\n", "\n", "# Compare", "\n", "assert_allclose", "(", "grad", ",", "true_grad", ")", "\n", "assert_allclose", "(", "H", ",", "true_H", ")", "\n", "assert_allclose", "(", "true_grad", ",", "\n", "H", ".", "dot", "(", "values", ")", ".", "reshape", "(", "-", "1", ",", "delaunay", ".", "input_dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulationNumpy.test_1d": [[626, 656], ["safe_learning.functions.GridWorld", "safe_learning.functions._Triangulation", "safe_learning.functions._Triangulation.find_simplex", "numpy.array", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "safe_learning.functions._Triangulation.", "numpy.testing.assert_allclose", "safe_learning.functions._Triangulation.parameter_derivative", "safe_learning.functions._Triangulation.parameter_derivative.toarray().dot", "numpy.testing.assert_allclose", "safe_learning.functions._Triangulation.gradient", "numpy.testing.assert_allclose", "safe_learning.functions._Triangulation.gradient_parameter_derivative", "safe_learning.functions._Triangulation.gradient_parameter_derivative.toarray().dot", "numpy.testing.assert_allclose", "numpy.array", "safe_learning.functions._Triangulation.find_simplex", "numpy.array", "numpy.array", "delaunay.gradient_parameter_derivative.toarray().dot.reshape", "safe_learning.functions._Triangulation.parameter_derivative.toarray", "safe_learning.functions._Triangulation.gradient_parameter_derivative.toarray"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.parameter_derivative", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.gradient", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.gradient_parameter_derivative", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex"], ["", "def", "test_1d", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the triangulation for 1D inputs.\"\"\"", "\n", "discretization", "=", "GridWorld", "(", "[", "[", "0", ",", "1", "]", "]", ",", "3", ")", "\n", "delaunay", "=", "_Triangulation", "(", "discretization", ",", "vertex_values", "=", "[", "0", ",", "0.5", ",", "0", "]", ")", "\n", "vertex_values", "=", "delaunay", ".", "parameters", "\n", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0.2", ",", "0.5", ",", "0.6", ",", "0.9", ",", "1.", "]", "]", ")", ".", "T", "\n", "test_point", "=", "test_points", "[", "[", "0", "]", ",", ":", "]", "\n", "\n", "simplices", "=", "delaunay", ".", "find_simplex", "(", "test_points", ")", "\n", "true_simplices", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "assert_allclose", "(", "simplices", ",", "true_simplices", ")", "\n", "assert_allclose", "(", "delaunay", ".", "find_simplex", "(", "test_point", ")", ",", "\n", "true_simplices", "[", "[", "0", "]", "]", ")", "\n", "\n", "values", "=", "delaunay", "(", "test_points", ")", "\n", "true_values", "=", "np", ".", "array", "(", "[", "0", ",", "0.2", ",", "0.5", ",", "0.4", ",", "0.1", ",", "0", "]", ")", "[", ":", ",", "None", "]", "\n", "assert_allclose", "(", "values", ",", "true_values", ")", "\n", "\n", "value_constraint", "=", "delaunay", ".", "parameter_derivative", "(", "test_points", ")", "\n", "values", "=", "value_constraint", ".", "toarray", "(", ")", ".", "dot", "(", "vertex_values", ")", "\n", "assert_allclose", "(", "values", ",", "true_values", ")", "\n", "\n", "gradient", "=", "delaunay", ".", "gradient", "(", "test_points", ")", "\n", "true_gradient", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", "]", ")", "[", ":", ",", "None", "]", "\n", "assert_allclose", "(", "gradient", ",", "true_gradient", ")", "\n", "\n", "gradient_deriv", "=", "delaunay", ".", "gradient_parameter_derivative", "(", "test_points", ")", "\n", "gradient", "=", "gradient_deriv", ".", "toarray", "(", ")", ".", "dot", "(", "vertex_values", ")", "\n", "assert_allclose", "(", "gradient", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "true_gradient", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulation.setup": [[661, 684], ["pytest.fixture", "tensorflow.Session", "safe_learning.functions.GridWorld", "numpy.sum", "safe_learning.functions._Triangulation", "safe_learning.functions.Triangulation", "numpy.array", "sess.run", "tensorflow.global_variables_initializer", "tensorflow.Graph"], "methods", ["None"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "\"class\"", ")", "\n", "def", "setup", "(", "self", ")", ":", "\n", "        ", "\"\"\"Create testing environment.\"\"\"", "\n", "with", "tf", ".", "Session", "(", "graph", "=", "tf", ".", "Graph", "(", ")", ")", "as", "sess", ":", "\n", "            ", "npoints", "=", "3", "\n", "\n", "discretization", "=", "GridWorld", "(", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", "]", ",", "npoints", ")", "\n", "parameters", "=", "np", ".", "sum", "(", "discretization", ".", "all_points", "**", "2", ",", "\n", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "trinp", "=", "_Triangulation", "(", "discretization", ",", "vertex_values", "=", "parameters", ")", "\n", "\n", "tri", "=", "Triangulation", "(", "discretization", ",", "vertex_values", "=", "parameters", ")", "\n", "\n", "test_points", "=", "np", ".", "array", "(", "[", "[", "-", "10", ",", "-", "10", "]", ",", "\n", "[", "0.2", ",", "0.7", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "1", "]", ",", "\n", "[", "-", "0.2", ",", "0.5", "]", ",", "\n", "[", "0.43", ",", "0.21", "]", "]", ")", "\n", "\n", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "yield", "sess", ",", "tri", ",", "trinp", ",", "test_points", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulation.test_evaluate": [[685, 691], ["sess.run", "numpy.testing.assert_allclose", "tri", "trinp"], "methods", ["None"], ["", "", "def", "test_evaluate", "(", "self", ",", "setup", ")", ":", "\n", "        ", "\"\"\"Test the evaluations.\"\"\"", "\n", "sess", ",", "tri", ",", "trinp", ",", "test_points", "=", "setup", "\n", "# with tf.Session() as sess:", "\n", "res", "=", "sess", ".", "run", "(", "tri", "(", "test_points", ")", ")", "\n", "assert_allclose", "(", "res", ",", "trinp", "(", "test_points", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulation.test_projected_evaluate": [[692, 702], ["sess.run", "numpy.testing.assert_allclose", "tri", "trinp"], "methods", ["None"], ["", "def", "test_projected_evaluate", "(", "self", ",", "setup", ")", ":", "\n", "        ", "\"\"\"Test evaluations with enabled projection.\"\"\"", "\n", "sess", ",", "tri", ",", "trinp", ",", "test_points", "=", "setup", "\n", "\n", "# Enable project", "\n", "trinp", ".", "project", "=", "True", "\n", "tri", ".", "project", "=", "True", "\n", "\n", "res", "=", "sess", ".", "run", "(", "tri", "(", "test_points", ")", ")", "\n", "assert_allclose", "(", "res", ",", "trinp", "(", "test_points", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulation.test_gradient_x": [[703, 739], ["tensorflow.placeholder", "tri", "sess.run", "numpy.testing.assert_allclose", "tensorflow.gradients", "numpy.testing.assert_allclose", "tri", "tensorflow.gradients", "numpy.testing.assert_allclose", "trinp", "sess.run", "trinp.gradient", "numpy.all", "numpy.all", "sess.run", "trinp.gradient"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.gradient", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.QuadraticFunction.gradient"], ["", "def", "test_gradient_x", "(", "self", ",", "setup", ")", ":", "\n", "        ", "\"\"\"Test the gradients with respect to the inputs.\"\"\"", "\n", "sess", ",", "tri", ",", "trinp", ",", "test_points", "=", "setup", "\n", "\n", "points", "=", "tf", ".", "placeholder", "(", "tf", ".", "float64", ",", "[", "None", ",", "None", "]", ")", "\n", "feed_dict", "=", "{", "points", ":", "test_points", "}", "\n", "\n", "# Dsiable project", "\n", "trinp", ".", "project", "=", "False", "\n", "tri", ".", "project", "=", "False", "\n", "\n", "# Just another run test", "\n", "y", "=", "tri", "(", "points", ")", "\n", "res", "=", "sess", ".", "run", "(", "y", ",", "feed_dict", "=", "feed_dict", ")", "\n", "assert_allclose", "(", "res", ",", "trinp", "(", "test_points", ")", ")", "\n", "\n", "# Test gradients", "\n", "grad", "=", "tf", ".", "gradients", "(", "y", ",", "points", ")", "\n", "res", "=", "sess", ".", "run", "(", "grad", ",", "feed_dict", "=", "feed_dict", ")", "[", "0", "]", "\n", "assert_allclose", "(", "res", ",", "trinp", ".", "gradient", "(", "test_points", ")", ")", "\n", "\n", "# Enable project", "\n", "trinp", ".", "project", "=", "True", "\n", "tri", ".", "project", "=", "True", "\n", "\n", "# Results are different outside of the projection.", "\n", "inside", "=", "(", "np", ".", "all", "(", "test_points", "<", "trinp", ".", "limits", "[", ":", ",", "[", "1", "]", "]", ".", "T", ",", "axis", "=", "1", ")", "\n", "&", "np", ".", "all", "(", "test_points", ">", "trinp", ".", "limits", "[", ":", ",", "[", "0", "]", "]", ".", "T", ",", "axis", "=", "1", ")", ")", "\n", "\n", "test_points", "=", "test_points", "[", "inside", "]", "\n", "\n", "# Test gradients projected", "\n", "y", "=", "tri", "(", "points", ")", "\n", "grad", "=", "tf", ".", "gradients", "(", "y", ",", "points", ")", "\n", "res", "=", "sess", ".", "run", "(", "grad", ",", "feed_dict", "=", "feed_dict", ")", "[", "0", "]", "\n", "assert_allclose", "(", "res", "[", "inside", "]", ",", "trinp", ".", "gradient", "(", "test_points", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.TestTriangulation.test_gradient_param": [[740, 762], ["tensorflow.placeholder", "trinp.parameter_derivative", "numpy.array", "tri", "numpy.zeros", "enumerate", "numpy.array.todense", "tensorflow.gradients", "sess.run", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.parameter_derivative"], ["", "def", "test_gradient_param", "(", "self", ",", "setup", ")", ":", "\n", "        ", "\"\"\"Test the gradients with respect to the parameters.\"\"\"", "\n", "sess", ",", "tri", ",", "trinp", ",", "test_points", "=", "setup", "\n", "\n", "# Disable project", "\n", "trinp", ".", "project", "=", "True", "\n", "tri", ".", "project", "=", "True", "\n", "\n", "x", "=", "tf", ".", "placeholder", "(", "tf", ".", "float64", ",", "[", "1", ",", "2", "]", ")", "\n", "\n", "true_gradient", "=", "trinp", ".", "parameter_derivative", "(", "test_points", ")", "\n", "true_gradient", "=", "np", ".", "array", "(", "true_gradient", ".", "todense", "(", ")", ")", "\n", "\n", "y", "=", "tri", "(", "x", ")", "\n", "grad_tf", "=", "tf", ".", "gradients", "(", "y", ",", "tri", ".", "parameters", ")", "[", "0", "]", "\n", "dense_gradient", "=", "np", ".", "zeros", "(", "true_gradient", "[", "0", "]", ".", "shape", ",", "dtype", "=", "np", ".", "float", ")", "\n", "\n", "for", "i", ",", "test", "in", "enumerate", "(", "test_points", ")", ":", "\n", "            ", "gradient", "=", "sess", ".", "run", "(", "grad_tf", ",", "feed_dict", "=", "{", "x", ":", "test", "[", "None", ",", ":", "]", "}", ")", "\n", "dense_gradient", "[", ":", "]", "=", "0.", "\n", "dense_gradient", "[", "gradient", ".", "indices", "]", "=", "gradient", ".", "values", "[", ":", ",", "0", "]", "\n", "assert_allclose", "(", "dense_gradient", ",", "true_gradient", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.test_scipy_delaunay": [[285, 296], ["safe_learning.functions.GridWorld", "safe_learning.functions.ScipyDelaunay", "safe_learning.functions._Triangulation", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "safe_learning.functions.ScipyDelaunay.find_simplex", "numpy.array"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.find_simplex"], ["", "", "def", "test_scipy_delaunay", "(", ")", ":", "\n", "    ", "\"\"\"Test the fake replacement for Scipy.\"\"\"", "\n", "limits", "=", "[", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "2", "]", "]", "\n", "num_points", "=", "[", "2", ",", "6", "]", "\n", "discretization", "=", "GridWorld", "(", "limits", ",", "num_points", ")", "\n", "sp_delaunay", "=", "ScipyDelaunay", "(", "limits", ",", "num_points", ")", "\n", "delaunay", "=", "_Triangulation", "(", "discretization", ")", "\n", "\n", "assert_equal", "(", "delaunay", ".", "nsimplex", ",", "sp_delaunay", ".", "nsimplex", ")", "\n", "assert_equal", "(", "delaunay", ".", "input_dim", ",", "sp_delaunay", ".", "ndim", ")", "\n", "sp_delaunay", ".", "find_simplex", "(", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_functions.test_neural_network": [[764, 778], ["tensorflow.Session", "safe_learning.functions.NeuralNetwork", "safe_learning.functions.NeuralNetwork.", "sess.run", "sess.run", "numpy.random.rand", "tensorflow.global_variables_initializer", "safe_learning.functions.NeuralNetwork.lipschitz"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions.NeuralNetwork.lipschitz"], ["", "", "", "def", "test_neural_network", "(", ")", ":", "\n", "    ", "\"\"\"Test the NeuralNetwork class init.\"\"\"", "\n", "relu", "=", "tf", ".", "nn", ".", "relu", "\n", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "        ", "nn", "=", "NeuralNetwork", "(", "layers", "=", "[", "2", ",", "3", ",", "1", "]", ",", "\n", "nonlinearities", "=", "[", "relu", ",", "relu", ",", "None", "]", ")", "\n", "\n", "# x = tf.placeholder()", "\n", "res", "=", "nn", "(", "np", ".", "random", ".", "rand", "(", "4", ",", "2", ")", ")", "\n", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "res", ",", "lipschitz", "=", "sess", ".", "run", "(", "[", "res", ",", "nn", ".", "lipschitz", "(", ")", "]", ")", "\n", "\n", "", "assert", "lipschitz", ">", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_utilities.TestStorage.sample_class": [[34, 51], ["A", "object.__init__", "safe_learning.utilities.get_storage", "safe_learning.utilities.set_storage"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.set_storage"], ["@", "pytest", ".", "fixture", "\n", "def", "sample_class", "(", "self", ")", ":", "\n", "        ", "\"\"\"Sample class for testing.\"\"\"", "\n", "class", "A", "(", "object", ")", ":", "\n", "            ", "\"\"\"Some class.\"\"\"", "\n", "\n", "def", "__init__", "(", "self", ")", ":", "\n", "                ", "\"\"\"Initialize.\"\"\"", "\n", "super", "(", "A", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "storage", "=", "{", "}", "\n", "\n", "", "def", "method", "(", "self", ",", "value", ",", "index", "=", "None", ")", ":", "\n", "                ", "storage", "=", "get_storage", "(", "self", ".", "storage", ",", "index", "=", "index", ")", "\n", "set_storage", "(", "self", ".", "storage", ",", "[", "(", "'value'", ",", "value", ")", "]", ",", "index", "=", "index", ")", "\n", "return", "storage", "\n", "\n", "", "", "return", "A", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_utilities.TestStorage.test_storage": [[52, 70], ["sample_class.method", "sample_class.method", "sample_class.method", "sample_class.method", "sample_class.method", "sample_class.method", "sample_class.method"], "methods", ["None"], ["", "def", "test_storage", "(", "self", ",", "sample_class", ")", ":", "\n", "        ", "\"\"\"Test the storage.\"\"\"", "\n", "storage", "=", "sample_class", ".", "method", "(", "5", ")", "\n", "assert", "storage", "is", "None", "\n", "storage", "=", "sample_class", ".", "method", "(", "4", ")", "\n", "assert", "storage", "[", "'value'", "]", "==", "5", "\n", "storage", "=", "sample_class", ".", "method", "(", "None", ")", "\n", "assert", "storage", "[", "'value'", "]", "==", "4", "\n", "\n", "# Test index", "\n", "storage", "=", "sample_class", ".", "method", "(", "3", ",", "index", "=", "'test'", ")", "\n", "assert", "storage", "is", "None", "\n", "storage", "=", "sample_class", ".", "method", "(", "4", ",", "index", "=", "'test'", ")", "\n", "assert", "storage", "[", "'value'", "]", "==", "3", "\n", "storage", "=", "sample_class", ".", "method", "(", "3", ",", "index", "=", "'test2'", ")", "\n", "assert", "storage", "is", "None", "\n", "storage", "=", "sample_class", ".", "method", "(", "3", ",", "index", "=", "'test'", ")", "\n", "assert", "storage", "[", "'value'", "]", "is", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_utilities.test_dlqr": [[17, 29], ["numpy.array", "numpy.array", "safe_learning.utilities.dlqr", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "safe_learning.utilities.dlqr", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.dlqr", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.dlqr"], ["def", "test_dlqr", "(", ")", ":", "\n", "    ", "\"\"\"Test the dlqr function.\"\"\"", "\n", "true_k", "=", "np", ".", "array", "(", "[", "[", "0.61803399", "]", "]", ")", "\n", "true_p", "=", "np", ".", "array", "(", "[", "[", "1.61803399", "]", "]", ")", "\n", "\n", "k", ",", "p", "=", "dlqr", "(", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "assert_allclose", "(", "k", ",", "true_k", ")", "\n", "assert_allclose", "(", "p", ",", "true_p", ")", "\n", "\n", "k", ",", "p", "=", "dlqr", "(", "[", "[", "1", "]", "]", ",", "[", "[", "1", "]", "]", ",", "[", "[", "1", "]", "]", ",", "[", "[", "1", "]", "]", ")", "\n", "assert_allclose", "(", "k", ",", "true_k", ")", "\n", "assert_allclose", "(", "p", ",", "true_p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_utilities.test_get_feed_dict": [[72, 84], ["tensorflow.Graph", "safe_learning.utilities.get_feed_dict", "safe_learning.utilities.get_feed_dict"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict"], ["", "", "def", "test_get_feed_dict", "(", ")", ":", "\n", "    ", "\"\"\"Test the global get_feed_dict method.\"\"\"", "\n", "graph", "=", "tf", ".", "Graph", "(", ")", "\n", "feed_dict", "=", "get_feed_dict", "(", "graph", ")", "\n", "# Initialized new dictionary", "\n", "assert", "feed_dict", "==", "{", "}", "\n", "\n", "# Test assignment", "\n", "feed_dict", "[", "'test'", "]", "=", "5", "\n", "\n", "# Make sure we keep getting the same object", "\n", "assert", "feed_dict", "is", "get_feed_dict", "(", "graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_utilities.test_unique_rows": [[86, 92], ["numpy.array", "numpy.array", "numpy.testing.assert_allclose", "safe_learning.utilities.unique_rows"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.unique_rows"], ["", "def", "test_unique_rows", "(", ")", ":", "\n", "    ", "\"\"\"Test the unique_rows function.\"\"\"", "\n", "a", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "2", "]", ",", "[", "1", ",", "3", "]", ",", "[", "1", ",", "2", "]", ",", "[", "1", ",", "3", "]", ",", "[", "1", ",", "4", "]", ",", "[", "2", ",", "3", "]", "]", ")", "\n", "uniques", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "2", "]", ",", "[", "1", ",", "3", "]", ",", "[", "1", ",", "4", "]", ",", "[", "2", ",", "3", "]", "]", ")", "\n", "\n", "assert_allclose", "(", "unique_rows", "(", "a", ")", ",", "uniques", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_utilities.test_compute_trajectory": [[94, 115], ["numpy.array", "numpy.array", "safe_learning.LinearSystem", "numpy.diag", "numpy.array", "safe_learning.utilities.dlqr", "safe_learning.LinearSystem", "numpy.array", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "tensorflow.Session", "safe_learning.utilities.compute_trajectory", "numpy.array", "states[].dot"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.dlqr", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.compute_trajectory"], ["", "def", "test_compute_trajectory", "(", ")", ":", "\n", "    ", "\"\"\"Test the compute_trajectory function.\"\"\"", "\n", "A", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0.1", "]", ",", "\n", "[", "0.", ",", "1.", "]", "]", ")", "\n", "B", "=", "np", ".", "array", "(", "[", "[", "0.01", "]", ",", "\n", "[", "0.1", "]", "]", ")", "\n", "\n", "dynamics", "=", "LinearSystem", "(", "(", "A", ",", "B", ")", ")", "\n", "Q", "=", "np", ".", "diag", "(", "[", "1.", ",", "0.01", "]", ")", "\n", "R", "=", "np", ".", "array", "(", "[", "[", "0.01", "]", "]", ")", "\n", "K", ",", "_", "=", "dlqr", "(", "A", ",", "B", ",", "Q", ",", "R", ")", "\n", "policy", "=", "LinearSystem", "(", "[", "-", "K", "]", ")", "\n", "\n", "x0", "=", "np", ".", "array", "(", "[", "[", "0.1", ",", "0.", "]", "]", ")", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "        ", "res", "=", "compute_trajectory", "(", "dynamics", ",", "policy", ",", "x0", ",", "num_steps", "=", "20", ")", "\n", "\n", "", "states", ",", "actions", "=", "res", "\n", "assert_allclose", "(", "states", "[", "[", "0", "]", ",", ":", "]", ",", "x0", ")", "\n", "assert_allclose", "(", "states", "[", "-", "1", ",", ":", "]", ",", "np", ".", "array", "(", "[", "0.", ",", "0.", "]", ")", ",", "atol", "=", "0.01", ")", "\n", "assert_allclose", "(", "actions", ",", "states", "[", ":", "-", "1", "]", ".", "dot", "(", "-", "K", ".", "T", ")", ")", "", "", ""]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_rl.TestPolicyIteration.test_integration": [[29, 78], ["numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "tensorflow.Session", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "safe_learning.utilities.dlqr", "safe_learning.QuadraticFunction", "safe_learning.GridWorld", "safe_learning.Triangulation", "safe_learning.LinearSystem", "safe_learning.GridWorld", "safe_learning.Triangulation", "safe_learning.QuadraticFunction", "safe_learning.PolicyIteration", "safe_learning.PolicyIteration.value_iteration", "tensorflow.train.GradientDescentOptimizer", "tensorflow.train.GradientDescentOptimizer.minimize", "sess.run", "range", "safe_learning.PolicyIteration.value_function.parameters[].eval", "safe_learning.QuadraticFunction.eval", "safe_learning.PolicyIteration.policy.parameters[].eval", "tensorflow.reduce_sum", "tensorflow.global_variables_initializer", "sess.run", "range", "tensorflow.Graph", "scipy.linalg.block_diag", "safe_learning.PolicyIteration.future_values", "sess.run", "safe_learning.QuadraticFunction."], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.dlqr", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.value_iteration", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.future_values"], ["def", "test_integration", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the values.\"\"\"", "\n", "with", "tf", ".", "Session", "(", "graph", "=", "tf", ".", "Graph", "(", ")", ")", "as", "sess", ":", "\n", "            ", "a", "=", "np", ".", "array", "(", "[", "[", "1.2", "]", "]", ")", "\n", "b", "=", "np", ".", "array", "(", "[", "[", "0.9", "]", "]", ")", "\n", "q", "=", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", "\n", "r", "=", "np", ".", "array", "(", "[", "[", "0.1", "]", "]", ")", "\n", "\n", "k", ",", "p", "=", "dlqr", "(", "a", ",", "b", ",", "q", ",", "r", ")", "\n", "true_value", "=", "QuadraticFunction", "(", "-", "p", ")", "\n", "\n", "discretization", "=", "GridWorld", "(", "[", "[", "-", "1", ",", "1", "]", "]", ",", "19", ")", "\n", "value_function", "=", "Triangulation", "(", "discretization", ",", "\n", "0.", "*", "discretization", ".", "all_points", ",", "\n", "project", "=", "True", ")", "\n", "\n", "dynamics", "=", "LinearSystem", "(", "(", "a", ",", "b", ")", ")", "\n", "\n", "policy_discretization", "=", "GridWorld", "(", "[", "-", "1", ",", "1", "]", ",", "5", ")", "\n", "policy", "=", "Triangulation", "(", "policy_discretization", ",", "\n", "-", "k", "/", "2", "*", "policy_discretization", ".", "all_points", ")", "\n", "reward_function", "=", "QuadraticFunction", "(", "-", "scipy", ".", "linalg", ".", "block_diag", "(", "q", ",", "r", ")", ")", "\n", "\n", "rl", "=", "PolicyIteration", "(", "policy", ",", "\n", "dynamics", ",", "\n", "reward_function", ",", "\n", "value_function", ")", "\n", "\n", "value_iter", "=", "rl", ".", "value_iteration", "(", ")", "\n", "\n", "loss", "=", "-", "tf", ".", "reduce_sum", "(", "rl", ".", "future_values", "(", "rl", ".", "state_space", ")", ")", "\n", "optimizer", "=", "tf", ".", "train", ".", "GradientDescentOptimizer", "(", "0.01", ")", "\n", "adapt_policy", "=", "optimizer", ".", "minimize", "(", "loss", ",", "\n", "var_list", "=", "rl", ".", "policy", ".", "parameters", ")", "\n", "\n", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "\n", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "                ", "sess", ".", "run", "(", "value_iter", ")", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "                    ", "sess", ".", "run", "(", "adapt_policy", ")", "\n", "\n", "", "", "values", "=", "rl", ".", "value_function", ".", "parameters", "[", "0", "]", ".", "eval", "(", ")", "\n", "true_values", "=", "true_value", "(", "rl", ".", "state_space", ")", ".", "eval", "(", ")", "\n", "policy_values", "=", "rl", ".", "policy", ".", "parameters", "[", "0", "]", ".", "eval", "(", ")", "\n", "\n", "", "assert_allclose", "(", "values", ",", "true_values", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "policy_values", ",", "-", "k", "*", "policy_discretization", ".", "all_points", ",", "\n", "atol", "=", "0.1", ")", "\n", "#", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_rl.TestPolicyIteration.test_optimization": [[82, 128], ["pytest.mark.skipif", "mock.Mock", "mock.Mock", "numpy.array", "mock.Mock", "mock.Mock", "safe_learning.PolicyIteration", "numpy.testing.assert_allclose", "mock.Mock.assert_called_with", "mock.Mock.assert_called_with", "numpy.arange", "numpy.arange", "tensorflow.Variable", "numpy.arange", "numpy.linalg.solve", "tensorflow.Session", "sess.run", "sess.run", "safe_learning.PolicyIteration.value_function.parameters[].eval", "numpy.zeros", "mock.Mock.return_value.ravel", "tensorflow.variables_initializer", "safe_learning.PolicyIteration.optimize_value_function", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.optimize_value_function"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "cvxpy", "is", "None", ",", "reason", "=", "'Cvxpy is not installed.'", ")", "\n", "def", "test_optimization", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the value function optimization.\"\"\"", "\n", "dynamics", "=", "mock", ".", "Mock", "(", ")", "\n", "dynamics", ".", "return_value", "=", "np", ".", "arange", "(", "4", ",", "dtype", "=", "np", ".", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "rewards", "=", "mock", ".", "Mock", "(", ")", "\n", "rewards", ".", "return_value", "=", "np", ".", "arange", "(", "4", ",", "dtype", "=", "np", ".", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "# transition probabilities", "\n", "trans_probs", "=", "np", ".", "array", "(", "[", "[", "0", ",", ".5", ",", ".5", ",", "0", "]", ",", "\n", "[", ".2", ",", ".1", ",", ".3", ",", ".5", "]", ",", "\n", "[", ".3", ",", ".2", ",", ".4", ",", ".1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float", ")", "\n", "\n", "value_function", "=", "mock", ".", "Mock", "(", ")", "\n", "value_function", ".", "tri", ".", "parameter_derivative", ".", "return_value", "=", "trans_probs", "\n", "value_function", ".", "nindex", "=", "4", "\n", "value_function", ".", "parameters", "=", "[", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "(", "4", ",", "1", ")", ",", "\n", "dtype", "=", "np", ".", "float", ")", ")", "]", "\n", "\n", "states", "=", "np", ".", "arange", "(", "4", ",", "dtype", "=", "np", ".", "float", ")", "[", ":", ",", "None", "]", "\n", "value_function", ".", "discretization", ".", "all_points", "=", "states", "\n", "\n", "policy", "=", "mock", ".", "Mock", "(", ")", "\n", "policy", ".", "return_value", "=", "'actions'", "\n", "\n", "rl", "=", "PolicyIteration", "(", "policy", ",", "\n", "dynamics", ",", "\n", "rewards", ",", "\n", "value_function", ")", "\n", "\n", "true_values", "=", "np", ".", "linalg", ".", "solve", "(", "np", ".", "eye", "(", "4", ")", "-", "rl", ".", "gamma", "*", "trans_probs", ",", "\n", "rewards", ".", "return_value", ".", "ravel", "(", ")", ")", "[", ":", ",", "None", "]", "\n", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "            ", "sess", ".", "run", "(", "tf", ".", "variables_initializer", "(", "value_function", ".", "parameters", ")", ")", "\n", "sess", ".", "run", "(", "rl", ".", "optimize_value_function", "(", ")", ")", "\n", "values", "=", "rl", ".", "value_function", ".", "parameters", "[", "0", "]", ".", "eval", "(", ")", "\n", "\n", "# Confirm result", "\n", "", "assert_allclose", "(", "values", ",", "true_values", ")", "\n", "\n", "dynamics", ".", "assert_called_with", "(", "rl", ".", "state_space", ",", "'actions'", ")", "\n", "rewards", ".", "assert_called_with", "(", "rl", ".", "state_space", ",", "'actions'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_rl.TestPolicyIteration.test_future_values": [[145, 173], ["mock.Mock", "mock.Mock", "mock.Mock", "mock.Mock", "safe_learning.PolicyIteration", "safe_learning.PolicyIteration.future_values", "mock.Mock.assert_called_with", "mock.Mock.assert_called_with", "numpy.testing.assert_allclose", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.reinforcement_learning.PolicyIteration.future_values"], ["", "def", "test_future_values", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test future values.\"\"\"", "\n", "dynamics", "=", "mock", ".", "Mock", "(", ")", "\n", "dynamics", ".", "return_value", "=", "'next_states'", "\n", "\n", "rewards", "=", "mock", ".", "Mock", "(", ")", "\n", "rewards", ".", "return_value", "=", "np", ".", "arange", "(", "4", ",", "dtype", "=", "np", ".", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "value_function", "=", "mock", ".", "Mock", "(", ")", "\n", "value_function", ".", "return_value", "=", "np", ".", "arange", "(", "4", ",", "dtype", "=", "np", ".", "float", ")", "[", ":", ",", "None", "]", "\n", "value_function", ".", "discretization", ".", "all_points", "=", "np", ".", "arange", "(", "4", ",", "dtype", "=", "np", ".", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "policy", "=", "mock", ".", "Mock", "(", ")", "\n", "policy", ".", "return_value", "=", "'actions'", "\n", "\n", "rl", "=", "PolicyIteration", "(", "policy", ",", "\n", "dynamics", ",", "\n", "rewards", ",", "\n", "value_function", ")", "\n", "\n", "true_values", "=", "np", ".", "arange", "(", "4", ",", "dtype", "=", "np", ".", "float", ")", "[", ":", ",", "None", "]", "*", "(", "1", "+", "rl", ".", "gamma", ")", "\n", "\n", "future_values", "=", "rl", ".", "future_values", "(", "'states'", ")", "\n", "\n", "dynamics", ".", "assert_called_with", "(", "'states'", ",", "'actions'", ")", "\n", "rewards", ".", "assert_called_with", "(", "'states'", ",", "'actions'", ")", "\n", "assert_allclose", "(", "future_values", ",", "true_values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_lyapunov.TestLyapunov.test_safe_set_init": [[24, 47], ["tensorflow.Session", "safe_learning.functions.GridWorld", "safe_learning.functions.LinearSystem", "safe_learning.lyapunov.Lyapunov", "safe_learning.lyapunov.Lyapunov", "numpy.array", "numpy.testing.assert_equal", "tensorflow.reduce_sum", "numpy.array", "tensorflow.square"], "methods", ["None"], ["def", "test_safe_set_init", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the safe set initialization.\"\"\"", "\n", "with", "tf", ".", "Session", "(", ")", ":", "\n", "            ", "discretization", "=", "GridWorld", "(", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", "]", ",", "3", ")", "\n", "lyap_fun", "=", "lambda", "x", ":", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "x", ")", ",", "axis", "=", "1", ")", "\n", "\n", "dynamics", "=", "LinearSystem", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0.01", "]", ",", "\n", "[", "0.", ",", "1.", "]", "]", ")", ")", "\n", "lf", "=", "0.4", "\n", "lv", "=", "0.3", "\n", "eps", "=", "0.5", "\n", "\n", "policy", "=", "lambda", "x", ":", "0.", "*", "x", "\n", "lyap", "=", "Lyapunov", "(", "discretization", ",", "lyap_fun", ",", "dynamics", ",", "lf", ",", "lv", ",", "\n", "eps", ",", "policy", ")", "\n", "\n", "initial_set", "=", "[", "1", ",", "3", "]", "\n", "lyap", "=", "Lyapunov", "(", "discretization", ",", "lyap_fun", ",", "dynamics", ",", "lf", ",", "lv", ",", "\n", "eps", ",", "policy", ",", "initial_set", "=", "initial_set", ")", "\n", "\n", "initial_set", "=", "np", ".", "array", "(", "[", "False", ",", "True", ",", "False", ",", "True", ",", "False", ",", "\n", "False", ",", "False", ",", "False", ",", "False", "]", ")", "\n", "assert_equal", "(", "initial_set", ",", "lyap", ".", "safe_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_lyapunov.TestLyapunov.test_update": [[48, 75], ["tensorflow.Session", "safe_learning.functions.GridWorld", "safe_learning.functions.LinearSystem", "safe_learning.lyapunov.Lyapunov", "safe_learning.lyapunov.Lyapunov.update_safe_set", "numpy.testing.assert_equal", "safe_learning.lyapunov.Lyapunov", "safe_learning.lyapunov.Lyapunov.update_safe_set", "numpy.testing.assert_equal", "tensorflow.reduce_sum", "numpy.array", "numpy.array", "numpy.ones", "tensorflow.square"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.update_safe_set", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.update_safe_set"], ["", "", "def", "test_update", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the update step.\"\"\"", "\n", "with", "tf", ".", "Session", "(", ")", ":", "\n", "            ", "discretization", "=", "GridWorld", "(", "[", "[", "-", "1", ",", "1", "]", "]", ",", "3", ")", "\n", "lyap_fun", "=", "lambda", "x", ":", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "x", ")", ",", "\n", "axis", "=", "1", ",", "\n", "keep_dims", "=", "True", ")", "\n", "policy", "=", "lambda", "x", ":", "-", ".1", "*", "x", "\n", "\n", "dynamics", "=", "LinearSystem", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1.", "]", "]", ")", ")", "\n", "lf", "=", "0.4", "\n", "lv", "=", "0.3", "\n", "eps", "=", ".5", "\n", "\n", "initial_set", "=", "[", "1", "]", "\n", "\n", "lyap", "=", "Lyapunov", "(", "discretization", ",", "lyap_fun", ",", "dynamics", ",", "lf", ",", "lv", ",", "\n", "eps", ",", "policy", ",", "initial_set", "=", "initial_set", ")", "\n", "\n", "lyap", ".", "update_safe_set", "(", ")", "\n", "assert_equal", "(", "lyap", ".", "safe_set", ",", "np", ".", "array", "(", "[", "False", ",", "True", ",", "False", "]", ")", ")", "\n", "\n", "eps", "=", "0.", "\n", "lyap", "=", "Lyapunov", "(", "discretization", ",", "lyap_fun", ",", "dynamics", ",", "lf", ",", "lv", ",", "\n", "eps", ",", "policy", ",", "initial_set", "=", "initial_set", ")", "\n", "lyap", ".", "update_safe_set", "(", ")", "\n", "assert_equal", "(", "lyap", ".", "safe_set", ",", "np", ".", "ones", "(", "3", ",", "dtype", "=", "np", ".", "bool", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.tests.test_lyapunov.test_smallest_boundary_value": [[77, 84], ["tensorflow.Session", "safe_learning.functions.GridWorld", "safe_learning.lyapunov.smallest_boundary_value", "tensorflow.reduce_sum", "tensorflow.abs"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.smallest_boundary_value"], ["", "", "", "def", "test_smallest_boundary_value", "(", ")", ":", "\n", "    ", "\"\"\"Test the boundary value function.\"\"\"", "\n", "with", "tf", ".", "Session", "(", ")", ":", "\n", "        ", "fun", "=", "lambda", "x", ":", "2", "*", "tf", ".", "reduce_sum", "(", "tf", ".", "abs", "(", "x", ")", ",", "axis", "=", "1", ")", "\n", "discretization", "=", "GridWorld", "(", "[", "[", "-", "1.5", ",", "1", "]", ",", "[", "-", "1", ",", "1.5", "]", "]", ",", "[", "3", ",", "3", "]", ")", "\n", "min_value", "=", "smallest_boundary_value", "(", "fun", ",", "discretization", ")", "\n", "assert", "min_value", "==", "2.5", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.plotting.plot_lyapunov_1d": [[18, 134], ["safe_learning.utilities.with_scope", "tensorflow.get_default_session", "safe_learning.utilities.get_feed_dict", "safe_learning.utilities.get_storage", "lyapunov.threshold", "matplotlib.subplots", "axes[].set_title", "axes[].set_xlim", "axes[].set_xlim", "axes[].set_xlabel", "axes[].set_ylabel", "axes[].set_title", "axes[].plot", "tf.get_default_session.run", "axes[].fill_between", "hasattr", "tf.get_default_session.run", "print", "print", "matplotlib.fill_between", "matplotlib.plot", "delta_v_true.eval", "axes[].plot", "axes[].twinx", "axes[].twinx.set_ylabel", "axes[].twinx.set_xlim", "numpy.ma.masked_where", "numpy.ma.masked_where", "axes[].twinx.plot", "axes[].twinx.plot", "numpy.any", "matplotlib.show", "lyapunov.policy", "lyapunov.dynamics", "lyapunov.v_decrease_confidence", "true_dynamics", "lyapunov.v_decrease_confidence", "safe_learning.utilities.set_storage", "safe_learning.utilities.get_storage.values", "numpy.min", "numpy.max", "true_dynamics.eval", "axes[].plot", "matplotlib.legend", "numpy.argmax", "axes[].get_ylim", "axes[].plot", "axes[].plot", "x.get_label"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.with_scope", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_feed_dict", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.get_storage", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.threshold", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.v_decrease_confidence", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.lyapunov.Lyapunov.v_decrease_confidence", "home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.set_storage"], ["@", "with_scope", "(", "'plot_lyapunov_1d'", ")", "\n", "def", "plot_lyapunov_1d", "(", "lyapunov", ",", "true_dynamics", ",", "legend", "=", "False", ")", ":", "\n", "    ", "\"\"\"Plot the lyapunov function of a 1D system\n\n    Parameters\n    ----------\n    lyapunov : instance of `Lyapunov`\n    true_dynamics : callable\n    legend : bool, optional\n    \"\"\"", "\n", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "feed_dict", "=", "get_feed_dict", "(", "sess", ".", "graph", ")", "\n", "\n", "# Get the storage (specific to the lyapunov function)", "\n", "storage", "=", "get_storage", "(", "_STORAGE", ",", "index", "=", "lyapunov", ")", "\n", "\n", "if", "storage", "is", "None", ":", "\n", "# Lyapunov function", "\n", "        ", "states", "=", "lyapunov", ".", "discretization", ".", "all_points", "\n", "actions", "=", "lyapunov", ".", "policy", "(", "states", ")", "\n", "next_states", "=", "lyapunov", ".", "dynamics", "(", "states", ",", "actions", ")", "\n", "v_bounds", "=", "lyapunov", ".", "v_decrease_confidence", "(", "states", ",", "next_states", ")", "\n", "true_next_states", "=", "true_dynamics", "(", "states", ",", "actions", ",", "noise", "=", "False", ")", "\n", "delta_v_true", ",", "_", "=", "lyapunov", ".", "v_decrease_confidence", "(", "states", ",", "\n", "true_next_states", ")", "\n", "\n", "storage", "=", "[", "(", "'states'", ",", "states", ")", ",", "\n", "(", "'next_states'", ",", "next_states", ")", ",", "\n", "(", "'v_bounds'", ",", "v_bounds", ")", ",", "\n", "(", "'true_next_states'", ",", "true_next_states", ")", ",", "\n", "(", "'delta_v_true'", ",", "delta_v_true", ")", "]", "\n", "set_storage", "(", "_STORAGE", ",", "storage", ",", "index", "=", "lyapunov", ")", "\n", "", "else", ":", "\n", "        ", "(", "states", ",", "next_states", ",", "v_bounds", ",", "\n", "true_next_states", ",", "delta_v_true", ")", "=", "storage", ".", "values", "(", ")", "\n", "\n", "", "extent", "=", "[", "np", ".", "min", "(", "states", ")", ",", "np", ".", "max", "(", "states", ")", "]", "\n", "safe_set", "=", "lyapunov", ".", "safe_set", "\n", "threshold", "=", "lyapunov", ".", "threshold", "(", "states", ")", "\n", "\n", "# Create figure axes", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "2", ",", "1", ",", "figsize", "=", "(", "10", ",", "12", ")", ")", "\n", "\n", "# Format axes", "\n", "axes", "[", "0", "]", ".", "set_title", "(", "'GP model of the dynamics'", ")", "\n", "axes", "[", "0", "]", ".", "set_xlim", "(", "extent", ")", "\n", "axes", "[", "1", "]", ".", "set_xlim", "(", "extent", ")", "\n", "axes", "[", "1", "]", ".", "set_xlabel", "(", "'$x$'", ")", "\n", "axes", "[", "1", "]", ".", "set_ylabel", "(", "r'Upper bound of $\\Delta V(x)$'", ")", "\n", "axes", "[", "1", "]", ".", "set_title", "(", "r'Determining stability with $\\Delta V(x)$'", ")", "\n", "\n", "# Plot dynamics", "\n", "axes", "[", "0", "]", ".", "plot", "(", "states", ",", "\n", "true_next_states", ".", "eval", "(", "feed_dict", "=", "feed_dict", ")", ",", "\n", "color", "=", "'black'", ",", "alpha", "=", "0.8", ")", "\n", "\n", "mean", ",", "bound", "=", "sess", ".", "run", "(", "next_states", ",", "feed_dict", "=", "feed_dict", ")", "\n", "axes", "[", "0", "]", ".", "fill_between", "(", "states", "[", ":", ",", "0", "]", ",", "\n", "mean", "[", ":", ",", "0", "]", "-", "bound", "[", ":", ",", "0", "]", ",", "\n", "mean", "[", ":", ",", "0", "]", "+", "bound", "[", ":", ",", "0", "]", ",", "\n", "color", "=", "(", "0.8", ",", "0.8", ",", "1", ")", ")", "\n", "\n", "if", "hasattr", "(", "lyapunov", ".", "dynamics", ",", "'X'", ")", ":", "\n", "        ", "axes", "[", "0", "]", ".", "plot", "(", "lyapunov", ".", "dynamics", ".", "X", "[", ":", ",", "0", "]", ",", "\n", "lyapunov", ".", "dynamics", ".", "Y", "[", ":", ",", "0", "]", ",", "\n", "'x'", ",", "ms", "=", "8", ",", "mew", "=", "2", ")", "\n", "\n", "", "v_dot_mean", ",", "v_dot_bound", "=", "sess", ".", "run", "(", "v_bounds", ",", "feed_dict", "=", "feed_dict", ")", "\n", "# # Plot V_dot", "\n", "print", "(", "v_dot_mean", ".", "shape", ")", "\n", "print", "(", "v_dot_bound", ".", "shape", ")", "\n", "plt", ".", "fill_between", "(", "states", "[", ":", ",", "0", "]", ",", "\n", "v_dot_mean", "[", ":", ",", "0", "]", "-", "v_dot_bound", "[", ":", ",", "0", "]", ",", "\n", "v_dot_mean", "[", ":", ",", "0", "]", "+", "v_dot_bound", "[", ":", ",", "0", "]", ",", "\n", "color", "=", "(", "0.8", ",", "0.8", ",", "1", ")", ")", "\n", "\n", "threshold_plot", "=", "plt", ".", "plot", "(", "extent", ",", "[", "threshold", ",", "threshold", "]", ",", "\n", "'k-.'", ",", "label", "=", "r'Safety threshold ($L \\tau$ )'", ")", "\n", "\n", "# # Plot the true V_dot or Delta_V", "\n", "delta_v", "=", "delta_v_true", ".", "eval", "(", "feed_dict", "=", "feed_dict", ")", "\n", "v_dot_true_plot", "=", "axes", "[", "1", "]", ".", "plot", "(", "states", "[", ":", ",", "0", "]", ",", "\n", "delta_v", ",", "\n", "color", "=", "'k'", ",", "\n", "label", "=", "r'True $\\Delta V(x)$'", ")", "\n", "\n", "# # Create twin axis", "\n", "ax2", "=", "axes", "[", "1", "]", ".", "twinx", "(", ")", "\n", "ax2", ".", "set_ylabel", "(", "r'$V(x)$'", ")", "\n", "ax2", ".", "set_xlim", "(", "extent", ")", "\n", "\n", "# # Plot Lyapunov function", "\n", "V_unsafe", "=", "np", ".", "ma", ".", "masked_where", "(", "safe_set", ",", "lyapunov", ".", "values", ")", "\n", "V_safe", "=", "np", ".", "ma", ".", "masked_where", "(", "~", "safe_set", ",", "lyapunov", ".", "values", ")", "\n", "unsafe_plot", "=", "ax2", ".", "plot", "(", "states", ",", "V_unsafe", ",", "\n", "color", "=", "'b'", ",", "\n", "label", "=", "r'$V(x)$ (unsafe, $\\Delta V(x) > L \\tau$)'", ")", "\n", "safe_plot", "=", "ax2", ".", "plot", "(", "states", ",", "V_safe", ",", "\n", "color", "=", "'r'", ",", "\n", "label", "=", "r'$V(x)$ (safe, $\\Delta V(x) \\leq L \\tau$)'", ")", "\n", "\n", "if", "legend", ":", "\n", "        ", "lns", "=", "unsafe_plot", "+", "safe_plot", "+", "threshold_plot", "+", "v_dot_true_plot", "\n", "labels", "=", "[", "x", ".", "get_label", "(", ")", "for", "x", "in", "lns", "]", "\n", "plt", ".", "legend", "(", "lns", ",", "labels", ",", "loc", "=", "4", ",", "fancybox", "=", "True", ",", "framealpha", "=", "0.75", ")", "\n", "\n", "# Create helper lines", "\n", "", "if", "np", ".", "any", "(", "safe_set", ")", ":", "\n", "        ", "max_id", "=", "np", ".", "argmax", "(", "lyapunov", ".", "values", "[", "safe_set", "]", ")", "\n", "x_safe", "=", "states", "[", "safe_set", "]", "[", "max_id", "]", "\n", "y_range", "=", "axes", "[", "1", "]", ".", "get_ylim", "(", ")", "\n", "axes", "[", "1", "]", ".", "plot", "(", "[", "x_safe", ",", "x_safe", "]", ",", "y_range", ",", "'k-.'", ")", "\n", "axes", "[", "1", "]", ".", "plot", "(", "[", "-", "x_safe", ",", "-", "x_safe", "]", ",", "y_range", ",", "'k-.'", ")", "\n", "\n", "# Show plot", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.plotting.plot_triangulation": [[136, 190], ["triangulation.parameters[].eval", "delaunay.simplices", "plt.figure().gca.plot_trisurf", "matplotlib.colorbar", "triangulation.discretization.limits.tolist", "matplotlib.imshow", "matplotlib.colorbar", "plt.figure().gca.set_xlabel", "plt.figure().gca.set_ylabel", "plt.colorbar.set_label", "mpl_toolkits.mplot3d.Axes3D", "numpy.arange", "matplotlib.figure().gca", "matplotlib.figure", "delaunay.simplices.copy", "triangulation.parameters[].eval.reshape", "matplotlib.figure"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.functions._Triangulation.simplices"], ["", "def", "plot_triangulation", "(", "triangulation", ",", "axis", "=", "None", ",", "three_dimensional", "=", "False", ",", "\n", "xlabel", "=", "None", ",", "ylabel", "=", "None", ",", "zlabel", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot a triangulation.\n    \n    Parameters\n    ----------\n    values: ndarray\n    axis: optional\n    three_dimensional: bool, optional\n        Whether to plot 3D\n        \n    Returns\n    -------\n    axis:\n        The axis on which we plotted.\n    \"\"\"", "\n", "values", "=", "triangulation", ".", "parameters", "[", "0", "]", ".", "eval", "(", ")", "\n", "\n", "if", "three_dimensional", ":", "\n", "        ", "if", "axis", "is", "None", ":", "\n", "            ", "axis", "=", "Axes3D", "(", "plt", ".", "figure", "(", ")", ")", "\n", "\n", "# Get the simplices and plot", "\n", "", "delaunay", "=", "triangulation", ".", "tri", "\n", "state_space", "=", "triangulation", ".", "discretization", ".", "all_points", "\n", "\n", "simplices", "=", "delaunay", ".", "simplices", "(", "np", ".", "arange", "(", "delaunay", ".", "nsimplex", ")", ")", "\n", "c", "=", "axis", ".", "plot_trisurf", "(", "state_space", "[", ":", ",", "0", "]", ",", "state_space", "[", ":", ",", "1", "]", ",", "values", "[", ":", ",", "0", "]", ",", "\n", "triangles", "=", "simplices", ".", "copy", "(", ")", ",", "\n", "cmap", "=", "'viridis'", ",", "lw", "=", "0.1", ",", "**", "kwargs", ")", "\n", "cbar", "=", "plt", ".", "colorbar", "(", "c", ")", "\n", "", "else", ":", "\n", "        ", "if", "axis", "is", "None", ":", "\n", "            ", "axis", "=", "plt", ".", "figure", "(", ")", ".", "gca", "(", ")", "\n", "\n", "", "domain", "=", "triangulation", ".", "discretization", ".", "limits", ".", "tolist", "(", ")", "\n", "num_points", "=", "triangulation", ".", "discretization", ".", "num_points", "\n", "\n", "# Some magic reshaping to go to physical coordinates", "\n", "vals", "=", "values", ".", "reshape", "(", "num_points", "[", "0", "]", ",", "num_points", "[", "1", "]", ")", ".", "T", "[", ":", ":", "-", "1", "]", "\n", "axis", "=", "plt", ".", "imshow", "(", "vals", ",", "origin", "=", "'upper'", ",", "\n", "extent", "=", "domain", "[", "0", "]", "+", "domain", "[", "1", "]", ",", "\n", "aspect", "=", "'auto'", ",", "cmap", "=", "'viridis'", ",", "interpolation", "=", "'bilinear'", ",", "**", "kwargs", ")", "\n", "cbar", "=", "plt", ".", "colorbar", "(", "axis", ")", "\n", "axis", "=", "axis", ".", "axes", "\n", "\n", "", "if", "xlabel", "is", "not", "None", ":", "\n", "        ", "axis", ".", "set_xlabel", "(", "xlabel", ")", "\n", "", "if", "ylabel", "is", "not", "None", ":", "\n", "        ", "axis", ".", "set_ylabel", "(", "ylabel", ")", "\n", "", "if", "zlabel", "is", "not", "None", ":", "\n", "        ", "cbar", ".", "set_label", "(", "zlabel", ")", "\n", "\n", "", "return", "axis", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.plotting.strip_consts": [[192, 209], ["tensorflow.GraphDef", "tf.GraphDef.node.add", "strip_def.node.add.MergeFrom", "len", "str.encode"], "function", ["None"], ["", "def", "strip_consts", "(", "graph_def", ",", "max_const_size", "=", "32", ")", ":", "\n", "    ", "\"\"\"Strip large constant values from graph_def.\n\n    Taken from\n    http://stackoverflow.com/questions/38189119/simple-way-to-visualize-a-\n    tensorflow-graph-in-jupyter\n    \"\"\"", "\n", "strip_def", "=", "tf", ".", "GraphDef", "(", ")", "\n", "for", "n0", "in", "graph_def", ".", "node", ":", "\n", "        ", "n", "=", "strip_def", ".", "node", ".", "add", "(", ")", "\n", "n", ".", "MergeFrom", "(", "n0", ")", "\n", "if", "n", ".", "op", "==", "'Const'", ":", "\n", "            ", "tensor", "=", "n", ".", "attr", "[", "'value'", "]", ".", "tensor", "\n", "size", "=", "len", "(", "tensor", ".", "tensor_content", ")", "\n", "if", "size", ">", "max_const_size", ":", "\n", "                ", "tensor", ".", "tensor_content", "=", "str", ".", "encode", "(", "\"<stripped %d bytes>\"", "%", "size", ")", "\n", "", "", "", "return", "strip_def", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.plotting.show_graph": [[211, 239], ["hasattr", "plotting.strip_consts", "IPython.display.display", "graph_def.as_graph_def.as_graph_def", "code.replace", "IPython.display.HTML", "repr", "str", "str", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.plotting.strip_consts"], ["", "def", "show_graph", "(", "graph_def", ",", "max_const_size", "=", "32", ")", ":", "\n", "    ", "\"\"\"Visualize TensorFlow graph.\n\n    Taken from\n    http://stackoverflow.com/questions/38189119/simple-way-to-visualize-a-\n    tensorflow-graph-in-jupyter\n    \"\"\"", "\n", "if", "hasattr", "(", "graph_def", ",", "'as_graph_def'", ")", ":", "\n", "        ", "graph_def", "=", "graph_def", ".", "as_graph_def", "(", ")", "\n", "", "strip_def", "=", "strip_consts", "(", "graph_def", ",", "max_const_size", "=", "max_const_size", ")", "\n", "code", "=", "\"\"\"\n        <script src=\"//cdnjs.cloudflare.com/ajax/libs/polymer/0.3.3/platform.js\"></script>\n        <script>\n          function load() {{\n            document.getElementById(\"{id}\").pbtxt = {data};\n          }}\n        </script>\n        <link rel=\"import\" href=\"https://tensorboard.appspot.com/tf-graph-basic.build.html\" onload=load()>\n        <div style=\"height:600px\">\n          <tf-graph-basic id=\"{id}\"></tf-graph-basic>\n        </div>\n    \"\"\"", ".", "format", "(", "data", "=", "repr", "(", "str", "(", "strip_def", ")", ")", ",", "\n", "id", "=", "'graph'", "+", "str", "(", "np", ".", "random", ".", "rand", "(", ")", ")", ")", "\n", "\n", "iframe", "=", "\"\"\"\n        <iframe seamless style=\"width:100%;height:620px;border:0\" srcdoc=\"{}\"></iframe>\n    \"\"\"", ".", "format", "(", "code", ".", "replace", "(", "'\"'", ",", "'&quot;'", ")", ")", "\n", "display", "(", "HTML", "(", "iframe", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.LyapunovNetwork.__init__": [[51, 84], ["tensorflow.contrib.layers.xavier_initializer", "safe_learning.DeterministicFunction.__init__", "len", "numpy.all", "numpy.zeros", "range", "numpy.zeros", "enumerate", "ValueError", "ValueError", "numpy.ceil().astype", "numpy.diff", "numpy.diff", "numpy.concatenate", "numpy.ceil"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["\n", "def", "wrap", "(", "function", ")", ":", "\n", "        ", "\"\"\"Create a new function.\"\"\"", "\n", "# Function name with stipped underscore (not allowed by tensorflow)", "\n", "name", "=", "function", ".", "__name__", ".", "lstrip", "(", "'_'", ")", "\n", "\n", "# Without gradients we can take the short route here", "\n", "if", "gradient", "is", "None", ":", "\n", "            ", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "                ", "method", "=", "partial", "(", "function", ",", "self", ",", "**", "kwargs", ")", "\n", "return", "tf", ".", "py_func", "(", "method", ",", "args", ",", "return_type", ",", "\n", "stateful", "=", "stateful", ",", "name", "=", "name", ")", "\n", "\n", "", "return", "wrapped_function", "\n", "\n", "# Name for the gradient operation", "\n", "", "grad_name", "=", "name", "+", "'_gradient'", "\n", "\n", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "self", ",", "*", "args", ")", ":", "\n", "# Overwrite the gradient", "\n", "            ", "graph", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "\n", "# Make sure the name we specify is unique", "\n", "unique_grad_name", "=", "graph", ".", "unique_name", "(", "grad_name", ")", "\n", "\n", "# Register the new gradient method with tensorflow", "\n", "tf", ".", "RegisterGradient", "(", "unique_grad_name", ")", "(", "gradient", ")", "\n", "\n", "# Remove self: Tensorflow does not allow for non-tensor inputs", "\n", "method", "=", "partial", "(", "function", ",", "self", ")", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.LyapunovNetwork.build_evaluation": [[85, 105], ["isinstance", "range", "tensorflow.reduce_sum", "tensorflow.constant", "tensorflow.get_variable", "tensorflow.matmul", "tensorflow.square", "tensorflow.matmul", "tensorflow.get_variable", "tensorflow.concat", "tensorflow.eye"], "methods", ["None"], ["\n", "with", "graph", ".", "gradient_override_map", "(", "{", "\"PyFunc\"", ":", "unique_grad_name", "}", ")", ":", "\n", "                ", "return", "tf", ".", "py_func", "(", "method", ",", "args", ",", "return_type", ",", "\n", "stateful", "=", "stateful", ",", "name", "=", "name", ")", "\n", "\n", "", "", "return", "wrapped_function", "\n", "", "return", "wrap", "\n", "\n", "\n", "", "def", "with_scope", "(", "name", ")", ":", "\n", "    ", "\"\"\"Set the tensorflow scope for the function.\n\n    Parameters\n    ----------\n    name : string, optional\n\n    Returns\n    -------\n    The tensorflow function with scope name.\n    \"\"\"", "\n", "def", "wrap", "(", "function", ")", ":", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.LyapunovNetwork.print_params": [[106, 121], ["utilities.LyapunovNetwork.parameters.eval", "enumerate", "numpy.diff", "print", "print", "numpy.linalg.eig", "print", "numpy.concatenate", "print", "W0.T.dot", "numpy.eye"], "methods", ["None"], ["        ", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "with", "tf", ".", "name_scope", "(", "name", ")", ":", "\n", "                ", "return", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", "return", "wrapped_function", "\n", "", "return", "wrap", "\n", "\n", "\n", "", "def", "use_parent_scope", "(", "function", ")", ":", "\n", "    ", "\"\"\"Use the parent scope for tensorflow.\"\"\"", "\n", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope_name", ")", ":", "\n", "            ", "return", "function", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", "return", "wrapped_function", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.RBFNetwork.__init__": [[124, 135], ["tensorflow.contrib.layers.xavier_initializer", "safe_learning.DeterministicFunction.__init__", "safe_learning.GridWorld", "numpy.reshape", "numpy.min"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["    ", "\"\"\"Concatenate the numpy array inputs to the functions.\n\n    Parameters\n    ----------\n    start : int, optional\n        The attribute number at which to start concatenating.\n    \"\"\"", "\n", "def", "wrap", "(", "function", ")", ":", "\n", "        ", "@", "wraps", "(", "function", ")", "\n", "def", "wrapped_function", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "\"\"\"Concatenate the input arguments.\"\"\"", "\n", "nargs", "=", "len", "(", "args", ")", "-", "start", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.RBFNetwork.build_evaluation": [[136, 142], ["tensorflow.get_variable", "tensorflow.expand_dims", "tensorflow.exp", "tensorflow.matmul", "tensorflow.reduce_sum", "tensorflow.square"], "methods", ["None"], ["# Check for tensorflow objects", "\n", "tf_objects", "=", "(", "tf", ".", "Tensor", ",", "tf", ".", "Variable", ")", "\n", "if", "any", "(", "isinstance", "(", "arg", ",", "tf_objects", ")", "for", "arg", "in", "args", "[", "start", ":", "]", ")", ":", "\n", "# reduce number of function calls in graph", "\n", "                ", "if", "nargs", "==", "1", ":", "\n", "                    ", "return", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# concatenate extra arguments", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.InvertedPendulum.__init__": [[160, 175], ["safe_learning.DeterministicFunction.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["\n", "\n", "", "def", "add_weight_constraint", "(", "optimization", ",", "var_list", ",", "bound_list", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.InvertedPendulum.inertia": [[176, 180], ["None"], "methods", ["None"], ["\n", "with", "tf", ".", "control_dependencies", "(", "[", "optimization", "]", ")", ":", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.InvertedPendulum.normalize": [[181, 193], ["map", "tensorflow.matmul", "tensorflow.matmul"], "methods", ["None"], ["        ", "new_list", "=", "[", "]", "\n", "for", "var", ",", "bound", "in", "zip", "(", "var_list", ",", "bound_list", ")", ":", "\n", "            ", "clipped_var", "=", "tf", ".", "clip_by_value", "(", "var", ",", "bound", "[", "0", "]", ",", "bound", "[", "1", "]", ")", "\n", "assign", "=", "tf", ".", "assign", "(", "var", ",", "clipped_var", ")", "\n", "new_list", ".", "append", "(", "assign", ")", "\n", "", "", "return", "new_list", "\n", "\n", "\n", "", "def", "gradient_clipping", "(", "optimizer", ",", "loss", ",", "var_list", ",", "limits", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.InvertedPendulum.denormalize": [[194, 206], ["map", "tensorflow.matmul", "tensorflow.matmul"], "methods", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.InvertedPendulum.linearize": [[207, 241], ["numpy.array", "numpy.array", "scipy.signal.StateSpace", "scipy.signal.StateSpace.to_discrete", "map", "map", "numpy.linalg.multi_dot", "numpy.linalg.multi_dot", "numpy.eye", "numpy.zeros"], "methods", ["None"], ["\n", "gradients", "=", "optimizer", ".", "compute_gradients", "(", "loss", ",", "var_list", "=", "var_list", ")", "\n", "\n", "clipped_gradients", "=", "[", "(", "tf", ".", "clip_by_value", "(", "grad", ",", "low", ",", "up", ")", ",", "var", ")", "\n", "for", "(", "grad", ",", "var", ")", ",", "(", "low", ",", "up", ")", "in", "zip", "(", "gradients", ",", "limits", ")", "]", "\n", "\n", "# Return optimization step", "\n", "return", "optimizer", ".", "apply_gradients", "(", "clipped_gradients", ")", "\n", "\n", "\n", "", "def", "batchify", "(", "arrays", ",", "batch_size", ")", ":", "\n", "    ", "\"\"\"Yield the arrays in batches and in order.\n\n    The last batch might be smaller than batch_size.\n\n    Parameters\n    ----------\n    arrays : list of ndarray\n        The arrays that we want to convert to batches.\n    batch_size : int\n        The size of each individual batch.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "arrays", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "arrays", "=", "(", "arrays", ",", ")", "\n", "\n", "# Iterate over array in batches", "\n", "", "for", "i", ",", "i_next", "in", "zip", "(", "itertools", ".", "count", "(", "start", "=", "0", ",", "step", "=", "batch_size", ")", ",", "\n", "itertools", ".", "count", "(", "start", "=", "batch_size", ",", "step", "=", "batch_size", ")", ")", ":", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.InvertedPendulum.build_evaluation": [[242, 256], ["safe_learning.utilities.concatenate_inputs", "tensorflow.split", "utilities.InvertedPendulum.denormalize", "range", "utilities.InvertedPendulum.ode", "utilities.InvertedPendulum.normalize"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.denormalize", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.ode", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.normalize"], ["\n", "        ", "batches", "=", "[", "array", "[", "i", ":", "i_next", "]", "for", "array", "in", "arrays", "]", "\n", "\n", "# Break if there are no points left", "\n", "if", "batches", "[", "0", "]", ".", "size", ":", "\n", "            ", "yield", "i", ",", "batches", "\n", "", "else", ":", "\n", "            ", "break", "\n", "\n", "\n", "", "", "", "def", "combinations", "(", "arrays", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.InvertedPendulum.ode": [[257, 290], ["tensorflow.split", "tensorflow.concat", "tensorflow.sin"], "methods", ["None"], ["\n", "return", "np", ".", "array", "(", "np", ".", "meshgrid", "(", "*", "arrays", ")", ")", ".", "T", ".", "reshape", "(", "-", "1", ",", "len", "(", "arrays", ")", ")", "\n", "\n", "\n", "", "def", "linearly_spaced_combinations", "(", "bounds", ",", "num_samples", ")", ":", "\n", "    ", "\"\"\"\n    Return 2-D array with all linearly spaced combinations with the bounds.\n\n    Parameters\n    ----------\n    bounds : sequence of tuples\n        The bounds for the variables, [(x1_min, x1_max), (x2_min, x2_max), ...]\n    num_samples : integer or array_likem\n        Number of samples to use for every dimension. Can be a constant if\n        the same number should be used for all, or an array to fine-tune\n        precision. Total number of data points is num_samples ** len(bounds).\n\n    Returns\n    -------\n    combinations : 2-d array\n        A 2-d arrray. If d = len(bounds) and l = prod(num_samples) then it\n        is of size l x d, that is, every row contains one combination of\n        inputs.\n    \"\"\"", "\n", "bounds", "=", "np", ".", "atleast_2d", "(", "bounds", ")", "\n", "num_vars", "=", "len", "(", "bounds", ")", "\n", "num_samples", "=", "np", ".", "broadcast_to", "(", "num_samples", ",", "num_vars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.CartPole.__init__": [[308, 325], ["safe_learning.DeterministicFunction.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["\n", "a", ",", "b", ",", "q", ",", "r", "=", "map", "(", "np", ".", "atleast_2d", ",", "(", "a", ",", "b", ",", "q", ",", "r", ")", ")", "\n", "p", "=", "scipy", ".", "linalg", ".", "solve_continuous_are", "(", "a", ",", "b", ",", "q", ",", "r", ")", "\n", "\n", "# LQR gain", "\n", "k", "=", "np", ".", "linalg", ".", "solve", "(", "r", ",", "b", ".", "T", ".", "dot", "(", "p", ")", ")", "\n", "\n", "return", "k", ",", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.CartPole.normalize": [[326, 338], ["map", "tensorflow.matmul", "tensorflow.matmul"], "methods", ["None"], ["\n", "", "def", "dlqr", "(", "a", ",", "b", ",", "q", ",", "r", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.CartPole.denormalize": [[339, 351], ["map", "tensorflow.matmul", "tensorflow.matmul"], "methods", ["None"], ["\n", "a", ",", "b", ",", "q", ",", "r", "=", "map", "(", "np", ".", "atleast_2d", ",", "(", "a", ",", "b", ",", "q", ",", "r", ")", ")", "\n", "p", "=", "scipy", ".", "linalg", ".", "solve_discrete_are", "(", "a", ",", "b", ",", "q", ",", "r", ")", "\n", "\n", "# LQR gain", "\n", "# k = (b.T * p * b + r)^-1 * (b.T * p * a)", "\n", "bp", "=", "b", ".", "T", ".", "dot", "(", "p", ")", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.CartPole.linearize": [[352, 386], ["numpy.array", "numpy.array().reshape", "scipy.signal.cont2discrete", "map", "map", "numpy.linalg.multi_dot", "numpy.linalg.multi_dot", "numpy.array"], "methods", ["None"], ["tmp1", "=", "bp", ".", "dot", "(", "b", ")", "\n", "tmp1", "+=", "r", "\n", "tmp2", "=", "bp", ".", "dot", "(", "a", ")", "\n", "k", "=", "np", ".", "linalg", ".", "solve", "(", "tmp1", ",", "tmp2", ")", "\n", "\n", "return", "k", ",", "p", "\n", "\n", "\n", "", "def", "ellipse_bounds", "(", "P", ",", "level", ",", "n", "=", "100", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.CartPole.build_evaluation": [[387, 401], ["safe_learning.utilities.concatenate_inputs", "tensorflow.split", "utilities.CartPole.denormalize", "range", "utilities.CartPole.ode", "utilities.CartPole.normalize"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.denormalize", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.ode", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.normalize"], ["\n", "# Round up to multiple of 2", "\n", "n", "+=", "n", "%", "2", "\n", "\n", "# Principal axes of ellipsoid", "\n", "eigval", ",", "eigvec", "=", "np", ".", "linalg", ".", "eig", "(", "P", ")", "\n", "eigvec", "*=", "np", ".", "sqrt", "(", "level", "/", "eigval", ")", "\n", "\n", "# set zero angle at maximum x", "\n", "angle", "=", "np", ".", "linspace", "(", "0", ",", "2", "*", "np", ".", "pi", ",", "n", ")", "[", ":", ",", "None", "]", "\n", "angle", "+=", "np", ".", "arctan", "(", "eigvec", "[", "0", ",", "1", "]", "/", "eigvec", "[", "0", ",", "0", "]", ")", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.CartPole.ode": [[402, 438], ["tensorflow.split", "tensorflow.concat", "tensorflow.square", "tensorflow.sin", "tensorflow.sin", "tensorflow.sin", "tensorflow.cos", "tensorflow.cos", "tensorflow.sin", "tensorflow.sin", "tensorflow.square", "tensorflow.square"], "methods", ["None"], ["\n", "# Compute positions", "\n", "pos", "=", "np", ".", "cos", "(", "angle", ")", "*", "eigvec", "[", ":", ",", "0", "]", "+", "np", ".", "sin", "(", "angle", ")", "*", "eigvec", "[", ":", ",", "1", "]", "\n", "n", "/=", "2", "\n", "\n", "# Return x-position (symmetric) and upper/lower bounds", "\n", "return", "pos", "[", ":", "n", ",", "0", "]", ",", "pos", "[", ":", "n", ",", "1", "]", ",", "pos", "[", ":", "n", "-", "1", ":", "-", "1", ",", "1", "]", "\n", "\n", "\n", "", "def", "get_storage", "(", "dictionary", ",", "index", "=", "None", ")", ":", "\n", "    ", "\"\"\"Get a unique storage point within a class method.\n\n    Parameters\n    ----------\n    dictionary : dict\n        A dictionary used for storage.\n    index : hashable\n        An index under which to store the element. Needs to be hashable.\n        This is useful for functions which might be accessed with multiple\n        different arguments.\n\n    Returns\n    -------\n    storage : OrderedDict\n        The storage object. Is None if no storage exists. Otherwise it\n        returns the OrderedDict that was previously put in the storage.\n    \"\"\"", "\n", "# Use function name as storage name", "\n", "frame", "=", "inspect", ".", "currentframe", "(", ")", "\n", "storage_name", "=", "inspect", ".", "getframeinfo", "(", "frame", ".", "f_back", ")", ".", "function", "\n", "\n", "storage", "=", "dictionary", ".", "get", "(", "storage_name", ")", "\n", "\n", "if", "index", "is", "None", ":", "\n", "        ", "return", "storage", "\n", "", "elif", "storage", "is", "not", "None", ":", "\n", "# Return directly the indexed object", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__": [[443, 454], ["safe_learning.DeterministicFunction.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.__init__"], ["\n", "\n", "", "", "", "def", "set_storage", "(", "dictionary", ",", "name_value", ",", "index", "=", "None", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.normalize": [[455, 462], ["numpy.diag", "tensorflow.matmul"], "methods", ["None"], ["\n", "# Use function name as storage name", "\n", "frame", "=", "inspect", ".", "currentframe", "(", ")", "\n", "storage_name", "=", "inspect", ".", "getframeinfo", "(", "frame", ".", "f_back", ")", ".", "function", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.denormalize": [[463, 470], ["numpy.diag", "tensorflow.matmul"], "methods", ["None"], ["\n", "storage", "=", "OrderedDict", "(", "name_value", ")", "\n", "if", "index", "is", "None", ":", "\n", "        ", "dictionary", "[", "storage_name", "]", "=", "storage", "\n", "", "else", ":", "\n", "# Make sure the storage is initialized", "\n", "        ", "if", "storage_name", "not", "in", "dictionary", ":", "\n", "            ", "dictionary", "[", "storage_name", "]", "=", "{", "}", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.linearize": [[471, 488], ["numpy.array", "numpy.zeros", "scipy.signal.cont2discrete", "numpy.diag", "numpy.diag", "numpy.linalg.multi_dot"], "methods", ["None"], ["# Set the indexed storage", "\n", "", "dictionary", "[", "storage_name", "]", "[", "index", "]", "=", "storage", "\n", "\n", "\n", "", "", "def", "get_feed_dict", "(", "graph", ")", ":", "\n", "    ", "\"\"\"Return the global feed_dict used for this graph.\n\n    Parameters\n    ----------\n    graph : tf.Graph\n\n    Returns\n    -------\n    feed_dict : dict\n        The feed_dict for this graph.\n    \"\"\"", "\n", "try", ":", "\n", "# Just return the feed_dict", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.build_evaluation": [[489, 500], ["safe_learning.utilities.concatenate_inputs", "tensorflow.split", "utilities.VanDerPol.denormalize", "range", "utilities.VanDerPol.normalize", "utilities.VanDerPol.ode"], "methods", ["home.repos.pwc.inspect_result.befelix_safe_learning.safe_learning.utilities.concatenate_inputs", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.denormalize", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.normalize", "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.ode"], ["        ", "return", "graph", ".", "feed_dict_sl", "\n", "", "except", "AttributeError", ":", "\n", "# Create a new feed_dict for this graph", "\n", "        ", "graph", ".", "feed_dict_sl", "=", "{", "}", "\n", "return", "graph", ".", "feed_dict_sl", "\n", "\n", "\n", "", "", "def", "unique_rows", "(", "array", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.VanDerPol.ode": [[501, 520], ["tensorflow.split", "tensorflow.concat"], "methods", ["None"], ["\n", "array", "=", "np", ".", "ascontiguousarray", "(", "array", ")", "\n", "# Combine all the rows into a single element of the flexible void datatype", "\n", "dtype", "=", "np", ".", "dtype", "(", "(", "np", ".", "void", ",", "array", ".", "dtype", ".", "itemsize", "*", "array", ".", "shape", "[", "1", "]", ")", ")", "\n", "combined_array", "=", "array", ".", "view", "(", "dtype", "=", "dtype", ")", "\n", "# Get all the unique rows of the combined array", "\n", "_", ",", "idx", "=", "np", ".", "unique", "(", "combined_array", ",", "return_index", "=", "True", ")", "\n", "\n", "return", "array", "[", "idx", "]", "\n", "\n", "\n", "", "def", "compute_trajectory", "(", "dynamics", ",", "policy", ",", "initial_state", ",", "num_steps", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.import_from_directory": [[23, 46], ["importlib.import_module", "os.path.abspath", "imp.find_module", "imp.load_module", "sys.path.append", "importlib.import_module"], "function", ["None"], ["from", "future", ".", "backports", "import", "OrderedDict", "\n", "\n", "from", "safe_learning", "import", "config", "\n", "\n", "__all__", "=", "[", "'combinations'", ",", "'linearly_spaced_combinations'", ",", "'lqr'", ",", "'dlqr'", ",", "\n", "'ellipse_bounds'", ",", "'concatenate_inputs'", ",", "'make_tf_fun'", ",", "\n", "'with_scope'", ",", "'use_parent_scope'", ",", "'add_weight_constraint'", ",", "\n", "'batchify'", ",", "'get_storage'", ",", "'set_storage'", ",", "'unique_rows'", ",", "\n", "'gradient_clipping'", "]", "\n", "\n", "\n", "_STORAGE", "=", "{", "}", "\n", "\n", "\n", "def", "make_tf_fun", "(", "return_type", ",", "gradient", "=", "None", ",", "stateful", "=", "True", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.reward_rollout": [[522, 546], ["isinstance", "numpy.zeros", "range", "closed_loop_dynamics", "print", "print", "reward_function().ravel", "numpy.max", "numpy.abs", "reward_function"], "function", ["None"], ["\n", "initial_state", "=", "np", ".", "atleast_2d", "(", "initial_state", ")", "\n", "state_dim", "=", "initial_state", ".", "shape", "[", "1", "]", "\n", "\n", "# Get storage (indexed by dynamics and policy)", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.constrained_batch_sampler": [[548, 568], ["tensorflow.random_uniform", "policy", "dynamics", "tensorflow.reduce_all", "tensorflow.squeeze", "tensorflow.gather", "tensorflow.logical_and", "tensorflow.where", "numpy.abs", "tensorflow.reduce_all", "tensorflow.squeeze", "tensorflow.gather", "tensorflow.zeros", "tensorflow.constant", "tensorflow.pad", "int", "tensorflow.logical_and", "tensorflow.where", "tf.pad.get_shape", "int"], "function", ["None"], ["storage", "=", "get_storage", "(", "_STORAGE", ",", "index", "=", "index", ")", "\n", "\n", "if", "storage", "is", "None", ":", "\n", "# Compute next state under the policy", "\n", "        ", "tf_state", "=", "tf", ".", "placeholder", "(", "config", ".", "dtype", ",", "[", "1", ",", "state_dim", "]", ")", "\n", "tf_action", "=", "policy", "(", "tf_state", ")", "\n", "tf_next_state", "=", "dynamics", "(", "tf_state", ",", "tf_action", ")", "\n", "\n", "storage", "=", "[", "(", "'tf_state'", ",", "tf_state", ")", ",", "\n", "(", "'tf_action'", ",", "tf_action", ")", ",", "\n", "(", "'tf_next_state'", ",", "tf_next_state", ")", "]", "\n", "\n", "set_storage", "(", "_STORAGE", ",", "storage", ",", "index", "=", "index", ")", "\n", "", "else", ":", "\n", "        ", "tf_state", ",", "tf_action", ",", "tf_next_state", "=", "storage", ".", "values", "(", ")", "\n", "\n", "# Initialize", "\n", "", "dtype", "=", "config", ".", "np_dtype", "\n", "states", "=", "np", ".", "empty", "(", "(", "num_steps", ",", "state_dim", ")", ",", "dtype", "=", "dtype", ")", "\n", "actions", "=", "np", ".", "empty", "(", "(", "num_steps", "-", "1", ",", "policy", ".", "output_dim", ")", ",", "dtype", "=", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.get_parameter_change": [[570, 600], ["numpy.concatenate", "numpy.concatenate", "numpy.linalg.norm", "param.ravel", "param.ravel"], "function", ["None"], ["\n", "# Get the feed dict", "\n", "session", "=", "tf", ".", "get_default_session", "(", ")", "\n", "feed_dict", "=", "get_feed_dict", "(", "session", ".", "graph", ")", "\n", "\n", "next_data", "=", "[", "tf_next_state", ",", "tf_action", "]", "\n", "\n", "# Run simulation", "\n", "for", "i", "in", "range", "(", "num_steps", "-", "1", ")", ":", "\n", "        ", "feed_dict", "[", "tf_state", "]", "=", "states", "[", "[", "i", "]", ",", ":", "]", "\n", "states", "[", "i", "+", "1", ",", ":", "]", ",", "actions", "[", "i", ",", ":", "]", "=", "session", ".", "run", "(", "next_data", ",", "\n", "feed_dict", "=", "feed_dict", ")", "\n", "\n", "", "return", "states", ",", "actions", "\n", "", ""]], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.compute_closedloop_response": [[602, 637], ["numpy.zeros", "numpy.zeros", "tensorflow.get_default_session", "range", "tf.get_default_session.run", "numpy.zeros", "numpy.arange().reshape", "numpy.asarray().reshape", "tensorflow.name_scope", "tensorflow.placeholder", "tensorflow.placeholder", "policy", "dynamics", "tf.get_default_session.run", "numpy.ones", "numpy.ones", "numpy.zeros", "numpy.arange", "numpy.asarray"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.gridify": [[639, 652], ["numpy.asarray().ravel", "numpy.column_stack", "isinstance", "safe_learning.GridWorld", "numpy.asarray().ravel", "numpy.asarray", "len", "numpy.asarray"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.compute_roa": [[654, 687], ["isinstance", "numpy.linalg.norm().ravel", "range", "numpy.empty", "range", "numpy.zeros", "closed_loop_dynamics", "closed_loop_dynamics", "numpy.linalg.norm"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.binary_cmap": [[689, 701], ["matplotlib.colors.ListedColormap"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.find_nearest": [[703, 711], ["numpy.searchsorted", "numpy.sort", "len", "numpy.abs", "numpy.abs"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.balanced_confusion_weights": [[713, 735], ["y.astype.astype", "y_true.astype.astype", "numpy.array", "numpy.ones_like"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.balanced_class_weights": [[737, 751], ["y_true.astype", "y_true.astype.sum", "numpy.array", "numpy.ones_like", "y_true.astype.sum"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.monomials": [[753, 783], ["numpy.atleast_2d", "numpy.copy", "numpy.empty", "numpy.hstack", "numpy.empty", "numpy.hstack", "numpy.empty", "numpy.hstack", "len", "len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.examples.utilities.derivative_monomials": [[785, 812], ["numpy.atleast_2d", "numpy.zeros", "numpy.copy", "numpy.zeros", "numpy.concatenate", "numpy.zeros", "numpy.concatenate", "len", "len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.befelix_safe_learning.scripts.jupyter_output.scrub_output_pre_save": [[1, 15], ["None"], "function", ["None"], ["def", "scrub_output_pre_save", "(", "model", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"scrub output before saving notebooks\"\"\"", "\n", "# only run on notebooks", "\n", "if", "model", "[", "'type'", "]", "!=", "'notebook'", ":", "\n", "        ", "return", "\n", "# only run on nbformat v4", "\n", "", "if", "model", "[", "'content'", "]", "[", "'nbformat'", "]", "!=", "4", ":", "\n", "        ", "return", "\n", "\n", "", "for", "cell", "in", "model", "[", "'content'", "]", "[", "'cells'", "]", ":", "\n", "        ", "if", "cell", "[", "'cell_type'", "]", "!=", "'code'", ":", "\n", "            ", "continue", "\n", "", "cell", "[", "'outputs'", "]", "=", "[", "]", "\n", "cell", "[", "'execution_count'", "]", "=", "None", "\n", "\n"]]}