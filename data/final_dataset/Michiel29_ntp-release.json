{"home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.gen_relationships": [[17, 40], ["scipy.special.comb", "list", "range", "numpy.random.choice", "set", "scipy.special.comb", "range", "numpy.random.choice", "range", "range", "len"], "function", ["None"], ["def", "gen_relationships", "(", "n_pred", ",", "n_rel", ",", "body_predicates", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Generates random relationships between predicates of the form goal predicate <-- {set of body predicates}. \n    Goal predicates have a higher number than body predicates. \n    \n    Args:\n        n_pred: number of total predicates\n        n_rel: number of relationships\n        body_predicates: number of body predicates for each relationship\n    Returns:\n        Dict, entries where keys are goal predicates and values are list of body predicates\n    \"\"\"", "\n", "\n", "relationship_dict", "=", "{", "}", "\n", "n_rel_possible", "=", "comb", "(", "n_pred", ",", "body_predicates", "+", "1", ")", "\n", "pred_probs", "=", "[", "comb", "(", "i", ",", "body_predicates", ")", "/", "n_rel_possible", "for", "i", "in", "range", "(", "n_pred", ")", "]", "\n", "relationship_head_array", "=", "list", "(", "rd", ".", "choice", "(", "n_pred", ",", "size", "=", "n_rel", ",", "replace", "=", "False", ",", "p", "=", "pred_probs", ")", ")", "\n", "relationship_body_array", "=", "[", "set", "(", "rd", ".", "choice", "(", "range", "(", "relationship_head_array", "[", "i", "]", ")", ",", "size", "=", "body_predicates", ",", "replace", "=", "False", ")", ")", "for", "i", "in", "range", "(", "len", "(", "relationship_head_array", ")", ")", "]", "\n", "\n", "for", "i", "in", "range", "(", "n_rel", ")", ":", "\n", "        ", "relationship_dict", "[", "relationship_head_array", "[", "i", "]", "]", "=", "relationship_body_array", "[", "i", "]", "\n", "\n", "", "return", "relationship_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.gen_simple": [[42, 78], ["numpy.zeros", "range", "itertools.product", "numpy.random.binomial", "generate.gen_simple.body_holds"], "function", ["None"], ["", "def", "gen_simple", "(", "n_pred", ",", "relationship_dict", ",", "p_normal", ",", "p_relationship", ",", "n_constants", ",", "order", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Generates random truth values for predicates for a set number of constants, and given some relationships\n    Args:\n        n_pred: number of total predicates\n        relationship_dict: Dict of relationships\n        p_normal: probability of predicate truth given no relationship/relationship body not true\n        p_relationship: probability of goal predicate truth given body predicate truth\n        n_constants: number of constants\n        order: order of predicate (unary, binary)\n    Returns:\n        Numpy array where value j, i corresponds to the truth value of predicate i for constant j\n    \"\"\"", "\n", "\n", "# Checks whether body predicates for a particular relationship hold for a particular constant", "\n", "def", "body_holds", "(", "data", ",", "body_predicates", ",", "constant", ")", ":", "\n", "        ", "holds", "=", "True", "\n", "for", "predicate", "in", "body_predicates", ":", "\n", "            ", "if", "data", "[", "index", "+", "(", "predicate", ",", ")", "]", "!=", "1", ":", "\n", "                ", "holds", "=", "False", "\n", "break", "\n", "", "", "return", "holds", "\n", "\n", "", "data", "=", "np", ".", "zeros", "(", "[", "n_constants", "]", "*", "order", "+", "[", "n_pred", "]", ")", "\n", "\n", "\n", "for", "predicate", "in", "range", "(", "n_pred", ")", ":", "\n", "        ", "for", "index", "in", "product", "(", "*", "[", "range", "(", "n_constants", ")", "for", "i", "in", "range", "(", "order", ")", "]", ")", ":", "\n", "            ", "if", "predicate", "in", "relationship_dict", ":", "\n", "                ", "if", "body_holds", "(", "data", ",", "relationship_dict", "[", "predicate", "]", ",", "index", ")", ":", "\n", "                    ", "data", "[", "index", "+", "(", "predicate", ",", ")", "]", "=", "rd", ".", "binomial", "(", "1", ",", "p_relationship", ")", "\n", "continue", "\n", "\n", "# Set variable normally if predicate from relationship doesn't hold", "\n", "", "", "data", "[", "index", "+", "(", "predicate", ",", ")", "]", "=", "rd", ".", "binomial", "(", "1", ",", "p_normal", ")", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.write_data": [[79, 92], ["numpy.shape", "range", "itertools.product", "text_list.append", "range", "str", "str"], "function", ["None"], ["", "def", "write_data", "(", "data", ")", ":", "\n", "    ", "\"\"\"Convert numpy array of data into list of strings that the ntp algorithm can read\"\"\"", "\n", "shape", "=", "np", ".", "shape", "(", "data", ")", "\n", "text_list", "=", "[", "]", "\n", "for", "pred", "in", "range", "(", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "for", "index", "in", "product", "(", "*", "[", "range", "(", "dim_size", ")", "for", "dim_size", "in", "shape", "[", ":", "-", "1", "]", "]", ")", ":", "\n", "            ", "if", "data", "[", "index", "+", "(", "pred", ",", ")", "]", "==", "1", ":", "\n", "                ", "write_string", "=", "\"Predicate\"", "+", "str", "(", "pred", ")", "+", "\"(\"", "\n", "for", "const", "in", "index", ":", "\n", "                    ", "write_string", "+=", "\"Constant\"", "+", "str", "(", "const", ")", "+", "\",\"", "\n", "", "write_string", "=", "write_string", "[", ":", "-", "1", "]", "+", "\").\\n\"", "\n", "text_list", ".", "append", "(", "write_string", ")", "\n", "", "", "", "return", "text_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.write_relationships": [[94, 100], ["open", "json.dump"], "function", ["None"], ["", "def", "write_relationships", "(", "relationships", ",", "path", ")", ":", "\n", "    ", "\"\"\"write relationship dict to file\"\"\"", "\n", "\n", "with", "open", "(", "path", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "relationships", ",", "f", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.write_simple_templates": [[102, 118], ["range", "text_list.append", "range", "chr", "ord", "str"], "function", ["None"], ["", "def", "write_simple_templates", "(", "n_rules", ",", "body_predicates", "=", "1", ",", "order", "=", "1", ")", ":", "\n", "    ", "\"\"\"Generate rule template of form C < A ^ B of varying size and order\"\"\"", "\n", "text_list", "=", "[", "]", "\n", "\n", "const_term", "=", "\"(\"", "\n", "for", "i", "in", "range", "(", "order", ")", ":", "\n", "        ", "const_term", "+=", "chr", "(", "ord", "(", "'X'", ")", "+", "i", ")", "+", "\",\"", "\n", "", "const_term", "=", "const_term", "[", ":", "-", "1", "]", "+", "\")\"", "\n", "\n", "write_string", "=", "\"{0} #1{1} :- #2{1}\"", ".", "format", "(", "n_rules", ",", "const_term", ")", "\n", "if", "body_predicates", ">", "1", ":", "\n", "        ", "for", "i", "in", "range", "(", "body_predicates", "-", "1", ")", ":", "\n", "            ", "write_string", "+=", "\", #\"", "+", "str", "(", "i", "+", "3", ")", "+", "const_term", "\n", "\n", "", "", "text_list", ".", "append", "(", "write_string", ")", "\n", "return", "text_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.gen_transitivity": [[121, 152], ["numpy.random.binomial", "set", "list", "numpy.random.binomial", "generate.write_data", "set", "range", "range", "tuple", "numpy.transpose"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.write_data"], ["", "def", "gen_transitivity", "(", "n_preds", ",", "n_rules", ",", "n_constants", ",", "p_base", ",", "max_iterations", "=", "1", ")", ":", "\n", "    ", "\"\"\"Generate data with transitivity relationships, and also rule templates\"\"\"", "\n", "# active predicate is predicate 0 WLOG", "\n", "active_values", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "p_base", ",", "size", "=", "[", "n_constants", ",", "n_constants", "]", ")", "\n", "\n", "edges", "=", "[", "(", "i", ",", "j", ")", "for", "i", "in", "range", "(", "n_constants", ")", "for", "j", "in", "range", "(", "n_constants", ")", "if", "active_values", "[", "i", ",", "j", "]", "==", "1", "]", "\n", "\n", "closure", "=", "set", "(", "edges", ")", "\n", "\n", "while", "True", ":", "\n", "        ", "new_edges", "=", "set", "(", "(", "x", ",", "w", ")", "for", "x", ",", "y", "in", "closure", "for", "q", ",", "w", "in", "closure", "if", "q", "==", "y", ")", "\n", "\n", "closure_until_now", "=", "closure", "|", "new_edges", "\n", "\n", "if", "closure_until_now", "==", "closure", ":", "\n", "            ", "break", "\n", "\n", "", "closure", "=", "closure_until_now", "\n", "\n", "", "edges", "=", "list", "(", "closure", ")", "\n", "\n", "active_values", "[", "tuple", "(", "np", ".", "transpose", "(", "edges", ")", ")", "]", "=", "1", "\n", "\n", "values", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "p_base", ",", "size", "=", "[", "n_constants", ",", "n_constants", ",", "n_preds", "]", ")", "\n", "values", "[", ":", ",", ":", ",", "0", "]", "=", "active_values", "\n", "\n", "fact_list", "=", "write_data", "(", "values", ")", "\n", "\n", "template", "=", "\"{0} #1(X, Z) :- #1(X, Y), #1(Y, Z).\"", ".", "format", "(", "n_rules", ")", "\n", "\n", "return", "fact_list", ",", "template", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.text_to_id": [[155, 162], ["re.sub", "tuple", "int", "tuple", "re.split", "int"], "function", ["None"], ["", "def", "text_to_id", "(", "fact", ")", ":", "\n", "    ", "\"\"\"Given a fact in text form, convert to predicate and constant numbers\"\"\"", "\n", "reduced", "=", "re", ".", "sub", "(", "\"[^0-9\\(,]\"", ",", "''", ",", "fact", ")", "\n", "reduced_split", "=", "tuple", "(", "re", ".", "split", "(", "\"[\\(,]\"", ",", "reduced", ")", ")", "\n", "predicate", "=", "int", "(", "reduced_split", "[", "0", "]", ")", "\n", "constants", "=", "tuple", "(", "[", "int", "(", "constant_text", ")", "for", "constant_text", "in", "reduced_split", "[", "1", ":", "]", "]", ")", "\n", "return", "predicate", ",", "constants", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.gen_constant_dict": [[163, 173], ["generate.text_to_id", "set", "constant_dict[].add"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.text_to_id"], ["", "def", "gen_constant_dict", "(", "train_list", ")", ":", "\n", "    ", "\"\"\"Convert list of facts in text form to a dictionary of predicate truth values by constant\"\"\"", "\n", "constant_dict", "=", "{", "}", "\n", "for", "fact", "in", "train_list", ":", "\n", "        ", "predicate", ",", "constants", "=", "text_to_id", "(", "fact", ")", "\n", "if", "not", "constants", "in", "constant_dict", ":", "\n", "            ", "constant_dict", "[", "constants", "]", "=", "set", "(", "[", "predicate", "]", ")", "\n", "", "else", ":", "\n", "            ", "constant_dict", "[", "constants", "]", ".", "add", "(", "predicate", ")", "\n", "", "", "return", "constant_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.test_fact_active": [[174, 180], ["all"], "function", ["None"], ["", "def", "test_fact_active", "(", "constant_dict", ",", "constants", ",", "predicate", ",", "relationships", ")", ":", "\n", "    ", "\"\"\"Given relationships, determine whether the truth value of a fact could be predicted by a relationship\"\"\"", "\n", "if", "predicate", "in", "relationships", ":", "\n", "        ", "if", "all", "(", "body_pred", "in", "constant_dict", "[", "constants", "]", "for", "body_pred", "in", "relationships", "[", "predicate", "]", ")", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.count_active": [[181, 189], ["constant_dict.items", "all"], "function", ["None"], ["", "def", "count_active", "(", "constant_dict", ",", "relationships", ")", ":", "\n", "    ", "\"\"\"Given relationships and a dataset of constants, determine for how many facts the truth value could be predicted by a relationship\"\"\"", "\n", "active_facts", "=", "0", "\n", "for", "constants", ",", "predicates", "in", "constant_dict", ".", "items", "(", ")", ":", "\n", "        ", "for", "predicate", "in", "relationships", ":", "\n", "            ", "if", "predicate", "in", "predicates", "and", "all", "(", "body_pred", "in", "predicates", "for", "body_pred", "in", "relationships", "[", "predicate", "]", ")", ":", "\n", "                ", "active_facts", "+=", "1", "\n", "", "", "", "return", "active_facts", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.gen_test_kb": [[190, 216], ["generate.gen_constant_dict", "random.shuffle", "numpy.random.shuffle", "set", "ntp.util.util_kb.load_from_list", "generate.text_to_id", "new_train_list.append", "generate.test_fact_active", "test_list.append", "all", "test_list.append", "len", "len", "set.add"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.gen_constant_dict", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.load_from_list", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.text_to_id", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.test_fact_active"], ["", "def", "gen_test_kb", "(", "train_list", ",", "n_test", ",", "test_active_only", "=", "False", ",", "relationships", "=", "None", ")", ":", "\n", "    ", "\"\"\"Given a list of facts, choose some facts to be split off to a test dataset in such a way that there is at least one training fact left for each constant\"\"\"", "\n", "constant_dict", "=", "gen_constant_dict", "(", "train_list", ")", "\n", "random", ".", "shuffle", "(", "train_list", ")", "\n", "constant_set", "=", "set", "(", ")", "\n", "new_train_list", "=", "[", "]", "\n", "test_list", "=", "[", "]", "\n", "for", "fact", "in", "train_list", ":", "\n", "        ", "predicate", ",", "constants", "=", "text_to_id", "(", "fact", ")", "\n", "\n", "if", "test_active_only", ":", "\n", "            ", "if", "test_fact_active", "(", "constant_dict", ",", "constants", ",", "predicate", ",", "relationships", ")", "and", "len", "(", "test_list", ")", "<", "n_test", ":", "\n", "                ", "test_list", ".", "append", "(", "fact", ")", "\n", "continue", "\n", "", "", "else", ":", "\n", "            ", "if", "all", "(", "constant", "in", "constant_set", "for", "constant", "in", "constants", ")", "and", "len", "(", "test_list", ")", "<", "n_test", ":", "\n", "                ", "test_list", ".", "append", "(", "fact", ")", "\n", "continue", "\n", "", "else", ":", "\n", "                ", "for", "constant", "in", "constants", ":", "\n", "                    ", "constant_set", ".", "add", "(", "constant", ")", "\n", "", "", "", "new_train_list", ".", "append", "(", "fact", ")", "\n", "\n", "", "train_list", "=", "new_train_list", "\n", "test_kb", "=", "load_from_list", "(", "test_list", ")", "\n", "return", "test_kb", ",", "train_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.rule2struct": [[14, 41], ["tuple", "atom_struct.append", "struct.append", "ntp.util.util_kb.is_variable", "tuple", "str", "atom_struct.append", "atom_struct.append", "len", "str", "len"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable"], ["def", "rule2struct", "(", "rule", ")", ":", "\n", "    ", "\"\"\"\n    Returns the structure of a rule used to partition a knowledge base\n    Args:\n        rule: rule \n    Returns: a tuple representing the structure of the rule\n    \"\"\"", "\n", "predicates", "=", "{", "}", "\n", "constants", "=", "{", "}", "\n", "variables", "=", "{", "}", "\n", "struct", "=", "[", "]", "\n", "for", "predicate", ",", "args", "in", "rule", ":", "\n", "        ", "atom_struct", "=", "[", "]", "\n", "if", "predicate", "not", "in", "predicates", ":", "\n", "            ", "predicates", "[", "predicate", "]", "=", "\"p\"", "+", "str", "(", "len", "(", "predicates", ")", ")", "\n", "", "atom_struct", ".", "append", "(", "predicates", "[", "predicate", "]", ")", "\n", "for", "arg", "in", "args", ":", "\n", "            ", "if", "is_variable", "(", "arg", ")", ":", "\n", "                ", "if", "arg", "not", "in", "variables", ":", "\n", "                    ", "variables", "[", "arg", "]", "=", "\"X\"", "+", "str", "(", "len", "(", "variables", ")", ")", "\n", "", "atom_struct", ".", "append", "(", "variables", "[", "arg", "]", ")", "\n", "", "else", ":", "\n", "                ", "if", "arg", "not", "in", "constants", ":", "\n", "                    ", "constants", "[", "arg", "]", "=", "\"c\"", "\n", "", "atom_struct", ".", "append", "(", "constants", "[", "arg", "]", ")", "\n", "", "", "struct", ".", "append", "(", "tuple", "(", "atom_struct", ")", ")", "\n", "", "return", "tuple", "(", "struct", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.augment_with_templates": [[43, 66], ["copy.deepcopy", "enumerate", "range", "ntp.util.util_kb.is_parameter", "copy.deepcopy.append", "new_rule.append", "new_rule.append", "kb.augment_with_templates.suffix_rule_parameters"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_parameter"], ["", "def", "augment_with_templates", "(", "kb", ",", "rule_templates", ")", ":", "\n", "    ", "\"\"\"\n    Adds templates to kb\n    Args:\n        kb: a knowledge base with symbolic representations\n    Returns: knowledge base agumented with parameterized rule templates\n    \"\"\"", "\n", "kb_copy", "=", "copy", ".", "deepcopy", "(", "kb", ")", "\n", "\n", "def", "suffix_rule_parameters", "(", "rule", ",", "num_rule", ",", "num_copy", ")", ":", "\n", "        ", "new_rule", "=", "[", "]", "\n", "for", "predicate", ",", "args", "in", "rule", ":", "\n", "            ", "if", "is_parameter", "(", "predicate", ")", ":", "\n", "                ", "new_rule", ".", "append", "(", "Atom", "(", "\"%s_%d_%d\"", "%", "\n", "(", "predicate", ",", "num_rule", ",", "num_copy", ")", ",", "args", ")", ")", "\n", "", "else", ":", "\n", "                ", "new_rule", ".", "append", "(", "Atom", "(", "predicate", ",", "args", ")", ")", "\n", "", "", "return", "new_rule", "\n", "\n", "", "for", "i", ",", "(", "rule_template", ",", "num", ")", "in", "enumerate", "(", "rule_templates", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num", ")", ":", "\n", "            ", "kb_copy", ".", "append", "(", "suffix_rule_parameters", "(", "rule_template", ",", "i", ",", "j", ")", ")", "\n", "", "", "return", "kb_copy", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.partition": [[68, 83], ["collections.OrderedDict", "kb.rule2struct", "kb_partitioned[].append"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.rule2struct"], ["", "def", "partition", "(", "kb", ")", ":", "\n", "    ", "\"\"\"\n    Creates kb dictionary with rule type as keys\n    Args:\n        kb: a knowledge base with symbolic representations\n    Returns: dictionary kb with rule type as keys\n    \"\"\"", "\n", "kb_partitioned", "=", "OrderedDict", "(", ")", "\n", "for", "rule", "in", "kb", ":", "\n", "        ", "struct", "=", "rule2struct", "(", "rule", ")", "\n", "if", "struct", "not", "in", "kb_partitioned", ":", "\n", "            ", "kb_partitioned", "[", "struct", "]", "=", "[", "rule", "]", "\n", "", "else", ":", "\n", "            ", "kb_partitioned", "[", "struct", "]", ".", "append", "(", "rule", ")", "\n", "", "", "return", "kb_partitioned", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2ids": [[85, 127], ["collections.OrderedDict", "ntp.util.util_data.Vocab", "enumerate", "enumerate", "enumerate", "enumerate", "len", "kb_stacked.append", "[].append", "ntp.util.util_kb.is_variable", "numpy.hstack", "len", "ntp.util.util_kb.is_variable", "len", "kb_stacked[].append", "ntp.util.util_data.Vocab.", "len", "predicate_ids[].append", "ntp.util.util_data.Vocab.", "constant_ids.append", "ntp.util.util_data.Vocab.", "len"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable"], ["", "def", "kb2ids", "(", "kb", ")", ":", "\n", "    ", "\"\"\"Transforms non-variable symbols to ids in the kb\"\"\"", "\n", "\n", "kb_ids", "=", "OrderedDict", "(", ")", "\n", "\n", "vocab", "=", "Vocab", "(", ")", "\n", "\n", "predicate_ids", "=", "{", "}", "\n", "constant_ids", "=", "[", "]", "\n", "\n", "for", "struct", "in", "kb", ":", "\n", "        ", "rules", "=", "kb", "[", "struct", "]", "\n", "kb_stacked", "=", "[", "]", "\n", "\n", "for", "rule", "in", "rules", ":", "\n", "            ", "for", "i", ",", "(", "predicate", ",", "args", ")", "in", "enumerate", "(", "rule", ")", ":", "\n", "                ", "if", "not", "len", "(", "args", ")", "in", "predicate_ids", ":", "\n", "                    ", "predicate_ids", "[", "len", "(", "args", ")", "]", "=", "[", "]", "\n", "", "if", "len", "(", "kb_stacked", ")", "<", "i", "+", "1", ":", "\n", "                    ", "kb_stacked", ".", "append", "(", "[", "]", ")", "\n", "", "symbols", "=", "[", "x", "for", "x", "in", "[", "predicate", "]", "+", "args", "]", "\n", "for", "j", ",", "sym", "in", "enumerate", "(", "symbols", ")", ":", "\n", "                    ", "if", "not", "is_variable", "(", "sym", ")", ":", "\n", "                        ", "if", "j", "==", "0", "and", "sym", "not", "in", "vocab", ":", "\n", "                            ", "predicate_ids", "[", "len", "(", "args", ")", "]", ".", "append", "(", "vocab", "(", "sym", ")", ")", "\n", "", "elif", "j", ">", "0", "and", "sym", "not", "in", "vocab", ":", "\n", "                            ", "constant_ids", ".", "append", "(", "vocab", "(", "sym", ")", ")", "\n", "\n", "", "", "if", "len", "(", "kb_stacked", "[", "i", "]", ")", "<", "j", "+", "1", ":", "\n", "                        ", "kb_stacked", "[", "i", "]", ".", "append", "(", "[", "]", ")", "\n", "", "kb_stacked", "[", "i", "]", "[", "j", "]", ".", "append", "(", "sym", ")", "\n", "\n", "# mapping to ids and stacking as numpy array", "\n", "", "", "", "for", "i", ",", "atom", "in", "enumerate", "(", "kb_stacked", ")", ":", "\n", "            ", "for", "j", ",", "symbols", "in", "enumerate", "(", "atom", ")", ":", "\n", "                ", "if", "not", "is_variable", "(", "symbols", "[", "0", "]", ")", ":", "\n", "                    ", "kb_stacked", "[", "i", "]", "[", "j", "]", "=", "np", ".", "hstack", "(", "vocab", "(", "symbols", ")", ")", "\n", "", "else", ":", "\n", "                    ", "kb_stacked", "[", "i", "]", "[", "j", "]", "=", "symbols", "\n", "\n", "", "", "", "kb_ids", "[", "struct", "]", "=", "kb_stacked", "\n", "", "return", "kb_ids", ",", "vocab", ",", "predicate_ids", ",", "constant_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb_ids2known_facts": [[128, 139], ["set", "len", "range", "set.add", "tuple"], "function", ["None"], ["", "def", "kb_ids2known_facts", "(", "kb_ids", ")", ":", "\n", "    ", "\"\"\"Creates list of all known facts from kb dict\"\"\"", "\n", "\n", "facts", "=", "set", "(", ")", "\n", "for", "struct", "in", "kb_ids", ":", "\n", "        ", "arrays", "=", "kb_ids", "[", "struct", "]", "[", "0", "]", "\n", "num_facts", "=", "len", "(", "arrays", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "num_facts", ")", ":", "\n", "            ", "fact", "=", "[", "x", "[", "i", "]", "for", "x", "in", "arrays", "]", "\n", "facts", ".", "add", "(", "tuple", "(", "fact", ")", ")", "\n", "", "", "return", "facts", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2nkb": [[140, 163], ["collections.OrderedDict", "enumerate", "enumerate", "range", "atoms_embedded.append", "len", "isinstance", "atom_embedded.append", "isinstance", "tensorflow.nn.embedding_lookup", "atom_embedded.append"], "function", ["None"], ["", "def", "kb2nkb", "(", "kb_ids", ",", "emb", ")", ":", "\n", "    ", "\"\"\"\n    Creates nkb dict matching structs to embeddings from embedding tensor\"\"\"", "\n", "\n", "nkb", "=", "OrderedDict", "(", ")", "\n", "for", "ix", ",", "struct", "in", "enumerate", "(", "kb_ids", ")", ":", "\n", "        ", "kb_stacked", "=", "kb_ids", "[", "struct", "]", "\n", "\n", "atoms_embedded", "=", "[", "]", "\n", "for", "i", ",", "atom", "in", "enumerate", "(", "kb_stacked", ")", ":", "\n", "            ", "atom_embedded", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "kb_stacked", "[", "i", "]", ")", ")", ":", "\n", "                ", "symbol", "=", "kb_stacked", "[", "i", "]", "[", "j", "]", "\n", "if", "isinstance", "(", "symbol", ",", "np", ".", "ndarray", ")", ":", "\n", "                    ", "atom_embedded", ".", "append", "(", "tf", ".", "nn", ".", "embedding_lookup", "(", "emb", ",", "symbol", ")", ")", "\n", "", "else", ":", "\n", "                    ", "if", "isinstance", "(", "symbol", ",", "list", ")", ":", "\n", "                        ", "atom_embedded", ".", "append", "(", "\"%s%d\"", "%", "(", "symbol", "[", "0", "]", "[", "0", "]", ",", "ix", ")", ")", "\n", "# atom_embedded.append(symbol)", "\n", "", "", "", "atoms_embedded", ".", "append", "(", "atom_embedded", ")", "\n", "", "nkb", "[", "struct", "]", "=", "atoms_embedded", "\n", "\n", "", "return", "nkb", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.initialize_nkb": [[164, 191], ["kb.partition", "kb.kb2ids", "tensorflow.random_uniform", "tensorflow.Variable", "kb.kb2nkb", "len"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.partition", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2ids", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2nkb"], ["", "def", "initialize_nkb", "(", "kb", ",", "input_size", "=", "10", ",", "init", "=", "(", "-", "1.0", ",", "1.0", ")", ")", ":", "\n", "    ", "\"\"\"\n    Given list of rules and facts in symbol form, create kb dict in id form, and instantiate embeddings for symbols\n    Args: \n        kb: list of facts in text form\n        input_size: symbol embedding size\n        init: initialization range\n    Returns:\n        nkb: dict matching structs to relevant parts of embedding tensor\n        kb_ids: dict matching structs to lists of symbol ids\n        vocab: contains dicts matching symbols to text\n        embedding_matrix: tensor of symbol embeddings\n        predicate_ids: list of all predicate symbol ids\n        constant_ids: list of all constant symbol ids\n    \"\"\"", "\n", "\n", "\n", "kb_partitioned", "=", "partition", "(", "kb", ")", "\n", "\n", "kb_ids", ",", "vocab", ",", "predicate_ids", ",", "constant_ids", "=", "kb2ids", "(", "kb_partitioned", ")", "\n", "init_values", "=", "tf", ".", "random_uniform", "(", "[", "len", "(", "vocab", ")", ",", "input_size", "]", ",", "minval", "=", "init", "[", "0", "]", ",", "maxval", "=", "init", "[", "1", "]", ")", "\n", "\n", "embedding_matrix", "=", "tf", ".", "Variable", "(", "init_values", ",", "name", "=", "\"embeddings\"", ")", "\n", "\n", "nkb", "=", "kb2nkb", "(", "kb_ids", ",", "embedding_matrix", ")", "\n", "\n", "return", "nkb", ",", "kb_ids", ",", "vocab", ",", "embedding_matrix", ",", "predicate_ids", ",", "constant_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.auc_helper": [[17, 46], ["relationships.items", "enumerate", "targets.append", "targets.append", "scores.append", "run_rules.index", "scores.append", "scores.append"], "function", ["None"], ["def", "auc_helper", "(", "relationships", ",", "run_rules", ",", "run_confidences", ")", ":", "\n", "    ", "\"\"\"\n    Calculates auc-roc measuring the recall and precision of learned rules relative to a set of existing relationships\n    \"\"\"", "\n", "targets", "=", "[", "]", "\n", "scores", "=", "[", "]", "\n", "\n", "for", "head", ",", "body", "in", "relationships", ".", "items", "(", ")", ":", "\n", "        ", "targets", ".", "append", "(", "1.0", ")", "\n", "if", "[", "head", ",", "body", "]", "in", "run_rules", ":", "\n", "            ", "index", "=", "run_rules", ".", "index", "(", "[", "head", ",", "body", "]", ")", "\n", "scores", ".", "append", "(", "run_confidences", "[", "index", "]", ")", "\n", "", "else", ":", "\n", "            ", "scores", ".", "append", "(", "0.0", ")", "\n", "\n", "\n", "", "", "for", "j", ",", "rule", "in", "enumerate", "(", "run_rules", ")", ":", "\n", "        ", "if", "rule", "[", "0", "]", "in", "rule", "[", "1", "]", ":", "\n", "            ", "continue", "\n", "\n", "# Append incorrect rules with score of 0", "\n", "", "if", "rule", "[", "0", "]", "in", "relationships", ":", "\n", "            ", "if", "relationships", "[", "rule", "[", "0", "]", "]", "==", "rule", "[", "1", "]", ":", "\n", "                ", "continue", "\n", "\n", "", "", "targets", ".", "append", "(", "0.0", ")", "\n", "scores", ".", "append", "(", "run_confidences", "[", "j", "]", ")", "\n", "\n", "", "return", "targets", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.prop_rules": [[47, 66], ["relationships.items", "len", "run_rules.index", "run_rules.index", "len"], "function", ["None"], ["", "def", "prop_rules", "(", "relationships", ",", "run_rules", ",", "run_confidences", ",", "threshold", "=", "0.0", ",", "allow_reverse", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    From a list of rules, calculates the proportion of relationships injected into the data that are present in the list of learned rules\n    \"\"\"", "\n", "\n", "relationships_found", "=", "0", "\n", "\n", "for", "head", ",", "body", "in", "relationships", ".", "items", "(", ")", ":", "\n", "        ", "if", "[", "head", ",", "body", "]", "in", "run_rules", ":", "\n", "# This finds the first such rule, rules should be sorted by confidence to make sure it's the highest confidence of those rules. ", "\n", "            ", "index", "=", "run_rules", ".", "index", "(", "[", "head", ",", "body", "]", ")", "\n", "if", "run_confidences", "[", "index", "]", ">", "threshold", ":", "\n", "                ", "relationships_found", "+=", "1", "\n", "", "", "elif", "allow_reverse", "==", "True", "and", "len", "(", "body", ")", "==", "1", "and", "[", "head", ",", "body", "]", "in", "run_rules", ":", "\n", "            ", "index", "=", "run_rules", ".", "index", "(", "[", "head", ",", "body", "]", ")", "\n", "if", "run_confidences", "[", "index", "]", ">", "threshold", ":", "\n", "                ", "relationships_found", "+=", "1", "\n", "\n", "", "", "", "return", "relationships_found", "/", "len", "(", "relationships", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_prop_rules": [[67, 93], ["relationships.items", "len", "run_rules.index", "run_rules.index", "len"], "function", ["None"], ["", "def", "weighted_prop_rules", "(", "relationships", ",", "run_rules", ",", "run_confidences", ",", "threshold", "=", "0.0", ",", "allow_reverse", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    From a list of rules and confidences, calculates the proportion of relationships injected into the data that are present in the list of learned rules, weighted by rule confidence\n    Args:\n        relationships: relationships injected into the data\n        run_rules: learned rules \n        run_confidences: confidences corresponding to those rules. Rules should be sorted by confidence, from high to low. \n        threshold: minimum confidence under which a rule is not considered\n        allow_reverse: whether or not a rule 1>0 is accepted if the true rule is 0>1\n    Returns: \n        Proportion of relationships injected into the data that are present in the list of learned rules, weighted by confidence\n    \"\"\"", "\n", "relationships_found", "=", "0", "\n", "\n", "for", "head", ",", "body", "in", "relationships", ".", "items", "(", ")", ":", "\n", "        ", "if", "[", "head", ",", "body", "]", "in", "run_rules", ":", "\n", "# This finds the first such rule, rules should be sorted by confidence to make sure it's the highest confidence of those rules. ", "\n", "            ", "index", "=", "run_rules", ".", "index", "(", "[", "head", ",", "body", "]", ")", "\n", "if", "run_confidences", "[", "index", "]", ">", "threshold", ":", "\n", "                ", "relationships_found", "+=", "run_confidences", "[", "index", "]", "\n", "", "", "elif", "allow_reverse", "==", "True", "and", "len", "(", "body", ")", "==", "1", "and", "[", "head", ",", "body", "]", "in", "run_rules", ":", "\n", "            ", "index", "=", "run_rules", ".", "index", "(", "[", "head", ",", "body", "]", ")", "\n", "if", "run_confidences", "[", "index", "]", ">", "threshold", ":", "\n", "                ", "relationships_found", "+=", "run_confidences", "[", "index", "]", "\n", "\n", "", "", "", "return", "relationships_found", "/", "len", "(", "relationships", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_precision": [[95, 133], ["enumerate", "len", "list", "len"], "function", ["None"], ["", "def", "weighted_precision", "(", "relationships", ",", "run_rules", ",", "run_confidences", ",", "threshold", "=", "0.0", ",", "allow_reverse", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    From a list of rules and confidences, calculates the proportion of those rules that match relationships injected into the data, weighted by confidence.\n    \"\"\"", "\n", "wrong_relationship_weight", "=", "0", "\n", "total_relationship_weight", "=", "0", "\n", "\n", "for", "j", ",", "rule", "in", "enumerate", "(", "run_rules", ")", ":", "\n", "\n", "# Skip rules with confidence below threshold", "\n", "\n", "        ", "if", "run_confidences", "[", "j", "]", "<", "threshold", "or", "rule", "[", "0", "]", "in", "rule", "[", "1", "]", ":", "\n", "            ", "continue", "\n", "\n", "", "total_relationship_weight", "+=", "run_confidences", "[", "j", "]", "\n", "\n", "# Check if rule is correct", "\n", "if", "rule", "[", "0", "]", "in", "relationships", ":", "\n", "            ", "if", "relationships", "[", "rule", "[", "0", "]", "]", "==", "rule", "[", "1", "]", ":", "\n", "                ", "continue", "\n", "\n", "", "", "if", "len", "(", "rule", "[", "1", "]", ")", "==", "1", ":", "\n", "            ", "body_pred", "=", "list", "(", "rule", "[", "1", "]", ")", "[", "0", "]", "\n", "\n", "# If learning reverse rule is acceptable, check for reverse rule for rules with only one body predicate", "\n", "if", "allow_reverse", "and", "body_pred", "in", "relationships", "and", "relationships", "[", "body_pred", "]", "==", "{", "rule", "[", "0", "]", "}", ":", "\n", "                ", "continue", "\n", "\n", "# Learning x-->x is not wrong, technically", "\n", "", "elif", "len", "(", "rule", ")", "==", "2", "and", "rule", "[", "0", "]", "==", "body_pred", ":", "\n", "                ", "continue", "\n", "\n", "", "", "wrong_relationship_weight", "+=", "run_confidences", "[", "j", "]", "\n", "\n", "", "if", "total_relationship_weight", "!=", "0", ":", "\n", "        ", "return", "(", "total_relationship_weight", "-", "wrong_relationship_weight", ")", "/", "total_relationship_weight", "\n", "", "else", ":", "\n", "        ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.confidence_accuracy": [[135, 165], ["enumerate", "len", "list"], "function", ["None"], ["", "", "def", "confidence_accuracy", "(", "relationships", ",", "run_rules", ",", "run_confidences", ",", "threshold", "=", "0.0", ",", "allow_reverse", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    From a list of rules and confidences, calculates 'confidence accuracy', giving positive points for being confident and right and negative points for confident and wrong\n    \"\"\"", "\n", "\n", "score", "=", "0", "\n", "for", "j", ",", "rule", "in", "enumerate", "(", "run_rules", ")", ":", "\n", "# Skip rules with confidence below threshold", "\n", "        ", "if", "run_confidences", "[", "j", "]", "<", "threshold", ":", "\n", "            ", "continue", "\n", "", "if", "rule", "[", "0", "]", "in", "relationships", ":", "\n", "            ", "if", "relationships", "[", "rule", "[", "0", "]", "]", "==", "rule", "[", "1", "]", ":", "\n", "                ", "score", "+=", "run_confidences", "[", "j", "]", "\n", "continue", "\n", "\n", "", "", "if", "len", "(", "rule", ")", "==", "2", ":", "\n", "            ", "body_pred", "=", "list", "(", "rule", "[", "1", "]", ")", "[", "0", "]", "\n", "\n", "if", "allow_reverse", "and", "relationships", "[", "body_pred", "]", "==", "rule", "[", "0", "]", ":", "\n", "                ", "score", "+=", "run_confidences", "[", "j", "]", "\n", "continue", "\n", "\n", "# skip identity", "\n", "", "if", "rule", "[", "0", "]", "==", "body_pred", ":", "\n", "                ", "continue", "\n", "\n", "# if rule was not correct, add negative confidence", "\n", "", "", "score", "-=", "run_confidences", "[", "j", "]", "\n", "\n", "", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_batch": [[166, 184], ["copy.deepcopy", "ntp.modules.kb.kb2nkb", "ntp.modules.prover.prove", "numpy.squeeze", "target.numpy.numpy", "numpy.mean", "numpy.mean", "ntp.modules.gradient.retrieve_top_k().numpy", "row.numpy", "range", "len", "ntp.modules.gradient.retrieve_top_k"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2nkb", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.prove", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k"], ["", "def", "eval_batch", "(", "goal", ",", "target", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "goal_struct", ",", "batch_mask", ",", "k_max", ",", "max_depth", ")", ":", "\n", "    ", "\"\"\"Retrieve accuracy of batch of facts relative to target, given kb of training facts\"\"\"", "\n", "kb_goal", "=", "copy", ".", "deepcopy", "(", "kb_ids", ")", "\n", "kb_goal", "[", "'goal'", "]", "=", "[", "[", "row", ".", "numpy", "(", ")", "for", "row", "in", "goal", "]", "]", "\n", "nkb", "=", "kb2nkb", "(", "kb_goal", ",", "emb", ")", "\n", "\n", "goal", "=", "[", "{", "'struct'", ":", "'goal'", ",", "'atom'", ":", "0", ",", "'symbol'", ":", "i", "}", "for", "i", "in", "range", "(", "len", "(", "goal_struct", "[", "0", "]", ")", ")", "]", "\n", "\n", "proofs", "=", "prove", "(", "nkb", ",", "goal", ",", "goal_struct", ",", "batch_mask", ",", "\n", "k_max", "=", "k_max", ",", "max_depth", "=", "max_depth", ",", "vocab", "=", "vocab", ")", "\n", "\n", "score", "=", "np", ".", "squeeze", "(", "retrieve_top_k", "(", "proofs", ")", ".", "numpy", "(", ")", ")", "\n", "target", "=", "target", ".", "numpy", "(", ")", "\n", "result", "=", "score", ">", "0.5", "\n", "accuracy", "=", "np", ".", "mean", "(", "result", "==", "target", ")", "\n", "weighted_accuracy", "=", "np", ".", "mean", "(", "(", "target", "==", "1", ")", "*", "(", "1", "*", "result", ")", "+", "(", "target", "==", "0", ")", "*", "(", "-", "1", "*", "result", ")", ")", "\n", "\n", "return", "accuracy", ",", "weighted_accuracy", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_fact_accuracy": [[185, 207], ["enumerate", "tensorflow.constant", "tensorflow.constant", "accuracy_list.append", "weighted_accuracy_list.append", "numpy.mean", "numpy.mean", "tensorflow.device", "tensorflow.constant", "tensorflow.ones", "tensorflow.transpose", "eval.eval_batch", "tensorflow.ones", "tensorflow.constant", "len", "tensorflow.scatter_nd"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_batch"], ["", "def", "eval_fact_accuracy", "(", "batch_list", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "k_max", ",", "max_depth", ")", ":", "\n", "    ", "\"\"\"Retrieve average accuracy of list of _train_ fact batches, given kb of training facts. \"\"\"", "\n", "\n", "accuracy_list", "=", "[", "]", "\n", "weighted_accuracy_list", "=", "[", "]", "\n", "\n", "for", "j", ",", "batch", "in", "enumerate", "(", "batch_list", ")", ":", "\n", "\n", "        ", "goal", "=", "tf", ".", "constant", "(", "batch", "[", "\"goal\"", "]", ")", "\n", "mask_indices", "=", "tf", ".", "constant", "(", "batch", "[", "\"mask_indices\"", "]", ")", "\n", "\n", "with", "tf", ".", "device", "(", "\"/device:GPU:0\"", ")", ":", "\n", "            ", "target", "=", "tf", ".", "constant", "(", "batch", "[", "\"target\"", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "base_mask", "=", "tf", ".", "ones", "(", "[", "batch", "[", "\"n_facts_struct\"", "]", ",", "batch", "[", "\"batch_size\"", "]", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "updates", "=", "-", "1.0", "*", "tf", ".", "ones", "(", "len", "(", "batch", "[", "\"mask_indices\"", "]", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "batch_mask", "=", "tf", ".", "transpose", "(", "tf", ".", "constant", "(", "\n", "base_mask", "+", "tf", ".", "scatter_nd", "(", "mask_indices", ",", "updates", ",", "base_mask", ".", "shape", ")", ")", ")", "\n", "batch_accuracy", ",", "weighted_accuracy", "=", "eval_batch", "(", "goal", ",", "target", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "batch", "[", "\"struct\"", "]", ",", "batch_mask", ",", "k_max", ",", "max_depth", ")", "\n", "", "accuracy_list", ".", "append", "(", "batch_accuracy", ")", "\n", "weighted_accuracy_list", ".", "append", "(", "weighted_accuracy", ")", "\n", "\n", "", "return", "np", ".", "mean", "(", "accuracy_list", ")", ",", "np", ".", "mean", "(", "weighted_accuracy_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_rule_accuracy": [[208, 213], ["ntp.util.util_eval.decode_rules", "eval.weighted_prop_rules"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.decode_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_prop_rules"], ["", "def", "eval_rule_accuracy", "(", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "relationships", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate proportion of relationships that are part of the decoded rules, weighted by confidence of those rules\"\"\"", "\n", "rules", ",", "confidences", "=", "decode_rules", "(", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ")", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "        ", "return", "weighted_prop_rules", "(", "relationships", ",", "rules", ",", "confidences", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score": [[214, 246], ["emb.numpy", "relationships.items", "numpy.mean", "best_scores.append", "len", "range", "itertools.permutations", "min", "enumerate", "ntp.modules.nunify.l2_sim_np", "numpy.expand_dims", "numpy.expand_dims", "ntp.modules.nunify.l2_sim_np", "numpy.expand_dims", "numpy.expand_dims"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.nunify.l2_sim_np", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.nunify.l2_sim_np"], ["", "", "def", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", ":", "\n", "    ", "\"\"\"Calculate score of best rule for each relationship and average. \n    Ignores whether there is an even better decoding for a particular rule.\"\"\"", "\n", "emb_np", "=", "emb", ".", "numpy", "(", ")", "\n", "best_scores", "=", "[", "]", "\n", "for", "head", ",", "body", "in", "relationships", ".", "items", "(", ")", ":", "\n", "        ", "head_id", "=", "vocab", ".", "sym2id", "[", "head", "]", "\n", "body_ids", "=", "[", "vocab", ".", "sym2id", "[", "body_pred", "]", "for", "body_pred", "in", "body", "]", "\n", "best_score", "=", "0", "\n", "for", "struct", "in", "kb_ids", ":", "\n", "            ", "if", "struct", "in", "fact_structs", ":", "\n", "                ", "continue", "\n", "", "struct_ids", "=", "kb_ids", "[", "struct", "]", "\n", "n_struct", "=", "len", "(", "struct_ids", "[", "0", "]", "[", "0", "]", ")", "\n", "for", "rule_nr", "in", "range", "(", "n_struct", ")", ":", "\n", "                ", "head_score", "=", "l2_sim_np", "(", "np", ".", "expand_dims", "(", "emb_np", "[", "head_id", "]", ",", "axis", "=", "0", ")", ",", "np", ".", "expand_dims", "(", "emb_np", "[", "struct_ids", "[", "0", "]", "[", "0", "]", "[", "rule_nr", "]", "]", ",", "axis", "=", "0", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "body_score", "=", "0", "\n", "for", "permutation", "in", "itertools", ".", "permutations", "(", "body_ids", ")", ":", "\n", "                    ", "perm_score", "=", "1", "\n", "for", "body_atom", ",", "elem", "in", "enumerate", "(", "permutation", ")", ":", "\n", "                        ", "elem_score", "=", "l2_sim_np", "(", "np", ".", "expand_dims", "(", "emb_np", "[", "elem", "]", ",", "axis", "=", "0", ")", ",", "np", ".", "expand_dims", "(", "emb_np", "[", "struct_ids", "[", "1", "+", "body_atom", "]", "[", "0", "]", "[", "rule_nr", "]", "]", ",", "axis", "=", "0", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "if", "elem_score", "<", "perm_score", ":", "\n", "                            ", "perm_score", "=", "elem_score", "\n", "", "", "if", "perm_score", ">", "body_score", ":", "\n", "                        ", "body_score", "=", "perm_score", "\n", "", "", "rule_score", "=", "min", "(", "body_score", ",", "head_score", ")", "\n", "if", "rule_score", ">", "best_score", ":", "\n", "                    ", "best_score", "=", "rule_score", "\n", "", "", "", "best_scores", ".", "append", "(", "best_score", ")", "\n", "\n", "", "average_score_closest", "=", "np", ".", "mean", "(", "best_scores", ")", "\n", "return", "average_score_closest", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_rank": [[248, 342], ["sklearn.metrics.roc_auc_score", "print", "ntp.modules.kb.kb2ids", "len", "range", "ntp.modules.kb.partition", "len", "numpy.array", "range", "str", "copy.deepcopy", "len", "batches.append", "targets.extend", "auc_scores.extend", "sorted", "range", "batches.append", "copy.deepcopy", "ntp.modules.kb.kb2nkb", "len", "len", "tensorflow.ones", "ntp.modules.prover.prove", "ntp.modules.gradient.retrieve_top_k().numpy().squeeze", "sorted.extend", "reversed_scores.index", "len", "sorted.index", "ntp.util.util_eval.harmonic", "len", "range", "tuple", "range", "range", "range", "list", "len", "fact_corruptions[].append", "range", "numpy.array", "range", "ntp.modules.gradient.retrieve_top_k().numpy", "len", "len", "len", "ntp.modules.gradient.retrieve_top_k"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2ids", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.partition", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2nkb", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.prove", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.harmonic", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k"], ["", "def", "eval_rank", "(", "emb", ",", "kb_ids", ",", "test_kb", ",", "known_facts", ",", "vocab", ",", "constant_ids", ",", "batch_size", ",", "k_max", ",", "max_depth", ",", "eval_dict", ")", ":", "\n", "    ", "\"\"\"For a set of true test facts, corrupt those test facts in every possible way that is not in the training set. \n    Calculate the scores of all such facts, and calculate ranking measures of the true test fact in that list of corrupted facts\"\"\"", "\n", "\n", "id_dict", "=", "kb2ids", "(", "partition", "(", "test_kb", ")", ")", "[", "0", "]", "\n", "\n", "\n", "counter", ",", "MRR", ",", "randomMRR", "=", "0", ",", "0", ",", "0", "\n", "targets", ",", "auc_scores", "=", "[", "]", ",", "[", "]", "\n", "\n", "for", "struct", "in", "id_dict", ":", "\n", "        ", "struct_ids", "=", "id_dict", "[", "struct", "]", "[", "0", "]", "\n", "n_test_struct", "=", "len", "(", "struct_ids", "[", "0", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_test_struct", ")", ":", "\n", "            ", "symbols_in_fact", "=", "len", "(", "struct_ids", ")", "\n", "fact", "=", "np", ".", "array", "(", "[", "struct_ids", "[", "k", "]", "[", "i", "]", "for", "k", "in", "range", "(", "symbols_in_fact", ")", "]", ")", "\n", "fact_corruptions", "=", "[", "[", "]", "for", "q", "in", "range", "(", "symbols_in_fact", ")", "]", "\n", "for", "k", "in", "range", "(", "1", ",", "symbols_in_fact", ")", ":", "\n", "                ", "corrupt_fact", "=", "copy", ".", "deepcopy", "(", "fact", ")", "\n", "for", "constant", "in", "constant_ids", ":", "\n", "                    ", "corrupt_fact", "[", "k", "]", "=", "constant", "\n", "if", "tuple", "(", "corrupt_fact", ")", "not", "in", "known_facts", ":", "\n", "                        ", "for", "j", "in", "range", "(", "symbols_in_fact", ")", ":", "\n", "                            ", "fact_corruptions", "[", "j", "]", ".", "append", "(", "corrupt_fact", "[", "j", "]", ")", "\n", "", "", "else", ":", "\n", "                        ", "continue", "\n", "\n", "\n", "", "", "combined", "=", "[", "[", "fact", "[", "q", "]", "]", "+", "fact_corruptions", "[", "q", "]", "for", "q", "in", "range", "(", "symbols_in_fact", ")", "]", "\n", "n_combined", "=", "len", "(", "combined", "[", "0", "]", ")", "\n", "batches", "=", "[", "]", "\n", "\n", "batch_pos", "=", "0", "\n", "while", "batch_pos", "+", "batch_size", "+", "1", "<=", "n_combined", ":", "\n", "                    ", "new_batch", "=", "[", "combined", "[", "q", "]", "[", "batch_pos", ":", "batch_pos", "+", "batch_size", "]", "for", "q", "in", "range", "(", "symbols_in_fact", ")", "]", "\n", "batches", ".", "append", "(", "new_batch", ")", "\n", "batch_pos", "+=", "batch_size", "\n", "\n", "", "new_batch", "=", "[", "combined", "[", "q", "]", "[", "batch_pos", ":", "]", "for", "q", "in", "range", "(", "symbols_in_fact", ")", "]", "\n", "batches", ".", "append", "(", "new_batch", ")", "\n", "scores", "=", "[", "]", "\n", "\n", "for", "batch", "in", "batches", ":", "\n", "\n", "                    ", "kb_goal", "=", "copy", ".", "deepcopy", "(", "kb_ids", ")", "\n", "kb_goal", "[", "'goal'", "]", "=", "[", "[", "np", ".", "array", "(", "row", ")", "for", "row", "in", "batch", "]", "]", "\n", "nkb", "=", "kb2nkb", "(", "kb_goal", ",", "emb", ")", "\n", "\n", "goal", "=", "[", "{", "'struct'", ":", "'goal'", ",", "'atom'", ":", "0", ",", "'symbol'", ":", "i", "}", "for", "i", "in", "range", "(", "symbols_in_fact", ")", "]", "\n", "\n", "cur_batch_size", "=", "len", "(", "batch", "[", "0", "]", ")", "\n", "n_struct", "=", "len", "(", "kb_ids", "[", "struct", "]", "[", "0", "]", "[", "0", "]", ")", "\n", "\n", "test_mask", "=", "tf", ".", "ones", "(", "[", "cur_batch_size", ",", "n_struct", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "proofs", "=", "prove", "(", "nkb", ",", "goal", ",", "struct", ",", "test_mask", ",", "\n", "k_max", "=", "k_max", ",", "max_depth", "=", "max_depth", ",", "vocab", "=", "vocab", ")", "\n", "\n", "batch_scores", "=", "retrieve_top_k", "(", "proofs", ")", ".", "numpy", "(", ")", ".", "squeeze", "(", ")", "\n", "if", "batch_scores", ".", "size", "==", "1", ":", "\n", "                        ", "batch_scores", "=", "[", "batch_scores", "]", "\n", "", "else", ":", "\n", "                        ", "batch_scores", "=", "list", "(", "batch_scores", ")", "\n", "", "scores", ".", "extend", "(", "batch_scores", ")", "\n", "\n", "\n", "", "fact_score", "=", "scores", "[", "0", "]", "\n", "\n", "# Duplicate real fact for each corruption", "\n", "targets", ".", "extend", "(", "[", "1.0", "]", "*", "(", "len", "(", "scores", ")", "-", "1", ")", "+", "[", "0.0", "]", "*", "(", "len", "(", "scores", ")", "-", "1", ")", ")", "\n", "auc_scores", ".", "extend", "(", "[", "fact_score", "]", "*", "(", "len", "(", "scores", ")", "-", "1", ")", "+", "scores", "[", "1", ":", "]", ")", "\n", "\n", "scores", "=", "sorted", "(", "scores", ")", "\n", "reversed_scores", "=", "scores", "[", ":", ":", "-", "1", "]", "\n", "\n", "# This model frequently has ties. We resolve those by taking the average of optimistic and", "\n", "# pessimistic tiebreaking.", "\n", "rank", "=", "reversed_scores", ".", "index", "(", "fact_score", ")", "+", "1", "\n", "rank_pess", "=", "len", "(", "scores", ")", "-", "scores", ".", "index", "(", "fact_score", ")", "\n", "rank", "=", "0.5", "*", "(", "rank", "+", "rank_pess", ")", "\n", "\n", "counter", "+=", "1.0", "\n", "MRR", "+=", "1.0", "/", "rank", "\n", "randomMRR", "+=", "harmonic", "(", "len", "(", "scores", ")", ")", "/", "len", "(", "scores", ")", "\n", "\n", "", "", "", "MRR", "/=", "counter", "\n", "randomMRR", "/=", "counter", "\n", "\n", "roc_auc", "=", "metrics", ".", "roc_auc_score", "(", "targets", ",", "auc_scores", ")", "\n", "\n", "print", "(", "\"roc-auc: \"", "+", "str", "(", "roc_auc", ")", ")", "\n", "\n", "return", "MRR", ",", "randomMRR", ",", "roc_auc", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.train.corrupt_goal": [[23, 41], ["print", "copy.deepcopy", "tuple", "train.corrupt_goal", "random.randint", "len"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.train.corrupt_goal"], ["def", "corrupt_goal", "(", "goal", ",", "constant_ids", ",", "known_facts", ",", "args", "=", "[", "1", "]", ",", "tries", "=", "100", ")", ":", "\n", "    ", "\"\"\"Given a fact from the training set, change an input constant at a given position \n    to another randomly chosen constant in such a way that the resulting fact is not in the training set\"\"\"", "\n", "\n", "if", "tries", "==", "0", ":", "\n", "        ", "print", "(", "\"WARNING: Could not corrupt\"", ",", "goal", ")", "\n", "return", "None", "\n", "", "else", ":", "\n", "        ", "goal_corrupted", "=", "copy", ".", "deepcopy", "(", "goal", ")", "\n", "for", "arg", "in", "args", ":", "\n", "            ", "corrupt", "=", "constant_ids", "[", "random", ".", "randint", "(", "\n", "0", ",", "len", "(", "constant_ids", ")", "-", "1", ")", "]", "\n", "goal_corrupted", "[", "arg", "]", "=", "corrupt", "\n", "\n", "", "if", "tuple", "(", "goal_corrupted", ")", "in", "known_facts", ":", "\n", "            ", "return", "corrupt_goal", "(", "goal", ",", "constant_ids", ",", "known_facts", ",", "args", ",", "tries", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "return", "goal_corrupted", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.train.gen_train_batches": [[43, 106], ["len", "list", "random.shuffle", "len", "len", "range", "all_facts.append", "targets.append", "mask_indices.append", "range", "train.gen_train_batches.gen_batch"], "function", ["None"], ["", "", "", "def", "gen_train_batches", "(", "fact_structs", ",", "kb_ids", ",", "batch_size", ",", "num_corruptions", ",", "constant_ids", ",", "known_facts", ")", ":", "\n", "    ", "\"\"\"From list of training facts, generate training batches. \n    In terms of symbol ids, not embeddings, so very cheap to precompute\"\"\"", "\n", "train_batches", "=", "[", "]", "\n", "\n", "for", "struct", "in", "fact_structs", ":", "\n", "        ", "struct_batches", "=", "[", "]", "\n", "struct_order", "=", "len", "(", "struct", "[", "0", "]", ")", "-", "1", "\n", "facts", "=", "kb_ids", "[", "struct", "]", "[", "0", "]", "\n", "n_facts", "=", "len", "(", "facts", "[", "0", "]", ")", "\n", "fact_ids", "=", "list", "(", "range", "(", "0", ",", "n_facts", ")", ")", "\n", "\n", "random", ".", "shuffle", "(", "fact_ids", ")", "\n", "\n", "facts", "=", "[", "[", "facts", "[", "i", "]", "[", "j", "]", "for", "i", "in", "range", "(", "struct_order", "+", "1", ")", "]", "for", "j", "in", "range", "(", "n_facts", ")", "]", "\n", "\n", "all_facts", "=", "[", "]", "\n", "targets", "=", "[", "]", "\n", "mask_indices", "=", "[", "]", "\n", "\n", "for", "fact_id", "in", "fact_ids", ":", "\n", "            ", "fact", "=", "facts", "[", "fact_id", "]", "\n", "all_facts", ".", "append", "(", "fact", ")", "\n", "targets", ".", "append", "(", "1.0", ")", "\n", "# Mark location of goal facts present in kb so they can be masked by prover", "\n", "mask_indices", ".", "append", "(", "[", "fact_id", ",", "len", "(", "mask_indices", ")", "%", "batch_size", "]", ")", "\n", "\n", "\n", "for", "constant_pos", "in", "range", "(", "struct_order", ")", ":", "\n", "                ", "for", "i", "in", "range", "(", "num_corruptions", ")", ":", "\n", "                    ", "corrupted_fact", "=", "corrupt_goal", "(", "fact", ",", "constant_ids", ",", "known_facts", ",", "args", "=", "[", "constant_pos", "+", "1", "]", ")", "\n", "if", "corrupted_fact", "is", "not", "None", ":", "\n", "                        ", "all_facts", ".", "append", "(", "corrupted_fact", ")", "\n", "targets", ".", "append", "(", "0.0", ")", "\n", "mask_indices", ".", "append", "(", "None", ")", "\n", "\n", "", "", "", "", "n_facts_total", "=", "len", "(", "all_facts", ")", "\n", "\n", "def", "gen_batch", "(", "list_dict", ",", "slice", ")", ":", "\n", "            ", "batch", "=", "{", "key", ":", "value", "[", "slice", "]", "for", "key", ",", "value", "in", "list_dict", ".", "items", "(", ")", "}", "\n", "return", "batch", "\n", "\n", "", "list_dict", "=", "{", "\"goal\"", ":", "all_facts", ",", "\"target\"", ":", "targets", ",", "\"mask_indices\"", ":", "mask_indices", "}", "\n", "\n", "facts_processed", "=", "0", "\n", "while", "facts_processed", "+", "batch_size", "<", "n_facts_total", ":", "\n", "            ", "batch", "=", "gen_batch", "(", "list_dict", ",", "slice", "(", "facts_processed", ",", "facts_processed", "+", "batch_size", ")", ")", "\n", "struct_batches", ".", "append", "(", "batch", ")", "\n", "facts_processed", "+=", "batch_size", "\n", "\n", "", "if", "facts_processed", "<", "n_facts_total", ":", "\n", "            ", "batch", "=", "gen_batch", "(", "list_dict", ",", "slice", "(", "facts_processed", ",", "n_facts_total", ")", ")", "\n", "struct_batches", ".", "append", "(", "batch", ")", "\n", "\n", "", "for", "batch", "in", "struct_batches", ":", "\n", "            ", "batch", "[", "\"goal\"", "]", "=", "[", "[", "fact", "[", "k", "]", "for", "fact", "in", "batch", "[", "\"goal\"", "]", "]", "for", "k", "in", "range", "(", "struct_order", "+", "1", ")", "]", "\n", "batch", "[", "\"mask_indices\"", "]", "=", "[", "value", "for", "value", "in", "batch", "[", "\"mask_indices\"", "]", "if", "value", "is", "not", "None", "]", "\n", "batch", "[", "\"batch_size\"", "]", "=", "len", "(", "batch", "[", "\"goal\"", "]", "[", "0", "]", ")", "\n", "batch", "[", "\"struct\"", "]", "=", "struct", "\n", "batch", "[", "\"n_facts_struct\"", "]", "=", "n_facts", "\n", "\n", "", "train_batches", "+=", "struct_batches", "\n", "", "return", "train_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.train.train_model": [[107, 250], ["ntp.modules.kb.augment_with_templates", "ntp.modules.kb.initialize_nkb", "ntp.modules.kb.kb_ids2known_facts", "ntp.util.util_training.TrainingState", "tensorflow.train.AdamOptimizer", "tensorflow.contrib.summary.create_file_writer", "timeit.default_timer", "range", "collections.OrderedDict", "ntp.util.util_eval.decode_rules", "tensorflow.reset_default_graph", "tensorflow.set_random_seed", "train.gen_train_batches", "enumerate", "print", "print", "ntp.modules.eval.prop_rules", "ntp.modules.eval.weighted_prop_rules", "ntp.modules.eval.weighted_precision", "ntp.modules.eval.auc_helper", "ntp.modules.eval.eval_rank", "tf.contrib.summary.create_file_writer.as_default", "tensorflow.contrib.summary.always_record_summaries", "predicate_ids.items", "print", "collections.OrderedDict", "ntp.modules.eval.eval_fact_accuracy", "tensorflow.constant", "tensorflow.constant", "tf.train.AdamOptimizer.apply_gradients", "ntp.util.util_training.TrainingState.update_iteration", "tensorflow.contrib.summary.scalar", "len", "ntp.modules.eval.eval_rule_accuracy", "ntp.modules.eval.closest_rule_score", "ntp.util.util_diag.closest_unification_score", "tf.contrib.summary.create_file_writer.as_default", "tensorflow.contrib.summary.always_record_summaries", "timeit.default_timer", "print", "timeit.default_timer", "tensorflow.device", "tensorflow.constant", "tensorflow.ones", "tensorflow.transpose", "ntp.modules.gradient.auto_gradient", "tensorflow.clip_by_value", "str", "str", "ntp.util.util_kb.is_parameter", "str", "tensorflow.contrib.summary.scalar", "print", "tensorflow.ones", "tensorflow.constant", "ntp.modules.eval.closest_rule_score", "ntp.util.util_diag.closest_unification_score", "str", "len", "str", "tensorflow.scatter_nd"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.augment_with_templates", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.initialize_nkb", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb_ids2known_facts", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.decode_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.train.gen_train_batches", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.prop_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_prop_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_precision", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.auc_helper", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_rank", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_fact_accuracy", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_training.TrainingState.update_iteration", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_rule_accuracy", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.auto_gradient", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_parameter", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score"], ["", "def", "train_model", "(", "kb", ",", "rule_templates", ",", "conf", ",", "relationships", "=", "None", ",", "test_kb", "=", "None", ")", ":", "\n", "    ", "\"\"\"Main function in the repository. Given a kb of facts and templates, train NTP model. \n\n    Args:\n        kb: list of training facts\n        rule_templates: list of rule templates\n        conf: dict that contains configuration information\n        relationships: gold relationship structure\n        test_kb: list of test facts\n    Returns: \n        Rules, confidences, and a dict of evaluation metrics (recall, etc)\n    \"\"\"", "\n", "\n", "if", "\"seed\"", "in", "conf", "[", "\"training\"", "]", ":", "\n", "        ", "tf", ".", "set_random_seed", "(", "conf", "[", "\"training\"", "]", "[", "\"seed\"", "]", ")", "\n", "\n", "", "input_size", "=", "conf", "[", "\"model\"", "]", "[", "\"input_size\"", "]", "\n", "l2", "=", "conf", "[", "\"model\"", "]", "[", "\"l2\"", "]", "\n", "k_max", "=", "conf", "[", "\"model\"", "]", "[", "\"k_max\"", "]", "\n", "max_depth", "=", "conf", "[", "\"model\"", "]", "[", "\"max_depth\"", "]", "\n", "loss_type", "=", "conf", "[", "\"model\"", "]", "[", "\"loss_type\"", "]", "\n", "loss_parameters", "=", "conf", "[", "\"model\"", "]", "[", "\"loss_parameters\"", "]", "\n", "\n", "report_interval", "=", "conf", "[", "\"logging\"", "]", "[", "\"report_interval\"", "]", "\n", "log_dir", "=", "conf", "[", "\"logging\"", "]", "[", "\"log_dir\"", "]", "\n", "verbose", "=", "conf", "[", "\"logging\"", "]", "[", "\"verbose\"", "]", "\n", "\n", "num_epochs", "=", "conf", "[", "\"training\"", "]", "[", "\"num_epochs\"", "]", "\n", "clip", "=", "conf", "[", "\"training\"", "]", "[", "\"clip\"", "]", "\n", "learning_rate", "=", "conf", "[", "\"training\"", "]", "[", "\"learning_rate\"", "]", "\n", "lr_decay_type", "=", "conf", "[", "\"training\"", "]", "[", "\"lr_decay_type\"", "]", "\n", "lr_decay_rate", "=", "conf", "[", "\"training\"", "]", "[", "\"lr_decay_rate\"", "]", "\n", "epsilon", "=", "conf", "[", "\"training\"", "]", "[", "\"epsilon\"", "]", "\n", "\n", "num_corruptions", "=", "conf", "[", "\"training\"", "]", "[", "\"num_corruptions\"", "]", "\n", "batch_size", "=", "conf", "[", "\"training\"", "]", "[", "\"batch_size\"", "]", "\n", "\n", "kb", "=", "augment_with_templates", "(", "kb", ",", "rule_templates", ")", "\n", "nkb", ",", "kb_ids", ",", "vocab", ",", "emb", ",", "predicate_ids", ",", "constant_ids", "=", "initialize_nkb", "(", "kb", ",", "input_size", ")", "\n", "\n", "true_predicate_ids", "=", "{", "order", ":", "[", "pred", "for", "pred", "in", "pred_order_ids", "if", "not", "is_parameter", "(", "vocab", ".", "id2sym", "[", "pred", "]", ")", "]", "for", "(", "order", ",", "pred_order_ids", ")", "in", "predicate_ids", ".", "items", "(", ")", "}", "\n", "\n", "known_facts", "=", "kb_ids2known_facts", "(", "kb_ids", ")", "\n", "\n", "fact_structs", "=", "[", "rule", "for", "rule", "in", "kb_ids", "if", "len", "(", "rule", ")", "==", "1", "]", "\n", "\n", "training_state", "=", "TrainingState", "(", "learning_rate", ",", "lr_decay_type", ",", "lr_decay_rate", ")", "\n", "\n", "optim", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "training_state", ".", "lr_variable", ",", "\n", "epsilon", "=", "epsilon", ")", "\n", "\n", "loss_function", "=", "loss_dict", "[", "loss_type", "]", "\n", "\n", "summary_writer", "=", "tf", ".", "contrib", ".", "summary", ".", "create_file_writer", "(", "log_dir", ")", "\n", "\n", "start_time", "=", "timer", "(", ")", "\n", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "        ", "train_batches", "=", "gen_train_batches", "(", "fact_structs", ",", "kb_ids", ",", "batch_size", ",", "num_corruptions", ",", "constant_ids", ",", "known_facts", ")", "\n", "\n", "\n", "if", "epoch", "%", "report_interval", "==", "0", "or", "epoch", "==", "num_epochs", "-", "1", ":", "\n", "            ", "print", "(", "\"epoch\"", "+", "str", "(", "epoch", ")", ")", "\n", "\n", "log_dict", "=", "OrderedDict", "(", ")", "\n", "log_dict", "[", "\"fact_accuracy\"", "]", "=", "eval_fact_accuracy", "(", "train_batches", ",", "emb", ",", "kb_ids", ",", "\n", "vocab", ",", "k_max", ",", "max_depth", ")", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "                ", "log_dict", "[", "\"rule_recall\"", "]", "=", "eval_rule_accuracy", "(", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "relationships", ")", "\n", "log_dict", "[", "\"closest_rule_score\"", "]", "=", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", "\n", "log_dict", "[", "\"closest_unification_score\"", "]", "=", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", "\n", "\n", "", "with", "summary_writer", ".", "as_default", "(", ")", ",", "tf", ".", "contrib", ".", "summary", ".", "always_record_summaries", "(", ")", ":", "\n", "                ", "for", "key", "in", "log_dict", ":", "\n", "                    ", "tf", ".", "contrib", ".", "summary", ".", "scalar", "(", "key", ",", "log_dict", "[", "key", "]", ",", "step", "=", "epoch", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "                ", "end_time", "=", "timer", "(", ")", "\n", "\n", "for", "key", "in", "log_dict", ":", "\n", "                    ", "print", "(", "key", "+", "\": \"", "+", "str", "(", "log_dict", "[", "key", "]", ")", ")", "\n", "", "print", "(", "\"time per epoch: \"", "+", "str", "(", "(", "end_time", "-", "start_time", ")", "/", "report_interval", ")", ")", "\n", "start_time", "=", "timer", "(", ")", "\n", "\n", "\n", "", "", "for", "j", ",", "batch", "in", "enumerate", "(", "train_batches", ")", ":", "\n", "\n", "            ", "goal", "=", "tf", ".", "constant", "(", "batch", "[", "\"goal\"", "]", ")", "\n", "\n", "mask_indices", "=", "tf", ".", "constant", "(", "batch", "[", "\"mask_indices\"", "]", ")", "\n", "loss_parameters", "[", "\"epoch\"", "]", "=", "epoch", "\n", "\n", "with", "tf", ".", "device", "(", "\"/device:GPU:0\"", ")", ":", "\n", "# 1 for facts from training set, 0 for corruptions", "\n", "                ", "target", "=", "tf", ".", "constant", "(", "batch", "[", "\"target\"", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "# Mask is necessary to hide the goal fact (which is part of the training set) from the prover", "\n", "base_mask", "=", "tf", ".", "ones", "(", "[", "batch", "[", "\"n_facts_struct\"", "]", ",", "batch", "[", "\"batch_size\"", "]", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "updates", "=", "-", "1.0", "*", "tf", ".", "ones", "(", "len", "(", "batch", "[", "\"mask_indices\"", "]", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "batch_mask", "=", "tf", ".", "transpose", "(", "tf", ".", "constant", "(", "\n", "base_mask", "+", "tf", ".", "scatter_nd", "(", "mask_indices", ",", "updates", ",", "base_mask", ".", "shape", ")", ")", ")", "\n", "\n", "grad", "=", "auto_gradient", "(", "loss_function", ",", "goal", ",", "target", ",", "emb", ",", "kb_ids", ",", "\n", "vocab", ",", "batch", "[", "\"struct\"", "]", ",", "batch_mask", ",", "l2", ",", "k_max", ",", "max_depth", ",", "epsilon", ",", "loss_parameters", ")", "\n", "\n", "", "if", "clip", "is", "not", "None", ":", "\n", "                ", "capped_gradients", "=", "tf", ".", "clip_by_value", "(", "grad", ",", "clip", "[", "0", "]", ",", "clip", "[", "1", "]", ")", "\n", "\n", "", "grad_and_var", "=", "[", "(", "capped_gradients", ",", "emb", ")", "]", "\n", "\n", "optim", ".", "apply_gradients", "(", "grad_and_var", ")", "\n", "\n", "training_state", ".", "update_iteration", "(", ")", "\n", "\n", "", "", "eval_dict", "=", "OrderedDict", "(", ")", "\n", "\n", "rules", ",", "confidences", "=", "decode_rules", "(", "\n", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "verbose", "=", "verbose", ",", "print_k", "=", "20", ")", "\n", "\n", "# if relationships are known, can calculate relationship learning accuracy", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "\n", "        ", "print", "(", "\"closest rule score: \"", "+", "str", "(", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", ")", ")", "\n", "print", "(", "\"closest unification score: \"", "+", "str", "(", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", ")", ")", "\n", "\n", "eval_dict", "[", "\"prop_rules\"", "]", "=", "prop_rules", "(", "relationships", ",", "rules", ",", "confidences", ")", "\n", "eval_dict", "[", "\"weighted_prop_rules\"", "]", "=", "weighted_prop_rules", "(", "\n", "relationships", ",", "rules", ",", "confidences", ")", "\n", "eval_dict", "[", "\"weighted_precision\"", "]", "=", "weighted_precision", "(", "\n", "relationships", ",", "rules", ",", "confidences", ")", "\n", "eval_dict", "[", "\"auc_helper\"", "]", "=", "auc_helper", "(", "relationships", ",", "rules", ",", "confidences", ")", "\n", "\n", "", "if", "test_kb", "is", "not", "None", ":", "\n", "\n", "        ", "eval_dict", "[", "\"MRR\"", "]", ",", "eval_dict", "[", "\"randomMRR\"", "]", ",", "eval_dict", "[", "\"fact-roc-auc\"", "]", "=", "eval_rank", "(", "emb", ",", "kb_ids", ",", "test_kb", ",", "known_facts", ",", "vocab", ",", "constant_ids", ",", "batch_size", ",", "k_max", ",", "max_depth", ",", "eval_dict", ")", "\n", "\n", "", "tf", ".", "reset_default_graph", "(", ")", "\n", "\n", "with", "summary_writer", ".", "as_default", "(", ")", ",", "tf", ".", "contrib", ".", "summary", ".", "always_record_summaries", "(", ")", ":", "\n", "        ", "for", "key", "in", "eval_dict", ":", "\n", "            ", "tf", ".", "contrib", ".", "summary", ".", "scalar", "(", "key", ",", "eval_dict", "[", "key", "]", ",", "step", "=", "num_epochs", ")", "\n", "\n", "", "", "return", "rules", ",", "confidences", ",", "eval_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.is_variables_list": [[30, 36], ["isinstance", "all", "ntp.util.util_kb.is_variable"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable"], ["def", "is_variables_list", "(", "xs", ")", ":", "\n", "    ", "\"\"\"check whether all elements in a list are variables\"\"\"", "\n", "if", "isinstance", "(", "xs", ",", "list", ")", ":", "\n", "        ", "return", "all", "(", "[", "is_variable", "(", "x", ")", "for", "x", "in", "xs", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.consists_variables": [[37, 43], ["isinstance", "all", "ntp.util.util_kb.is_variable", "ntp.util.util_kb.is_variable"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable"], ["", "", "def", "consists_variables", "(", "value", ")", ":", "\n", "    ", "\"\"\"check whether all elements in input are variables\"\"\"", "\n", "if", "isinstance", "(", "value", ",", "list", ")", ":", "\n", "        ", "return", "all", "(", "[", "is_variable", "(", "x", ")", "for", "x", "in", "value", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "is_variable", "(", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.is_tensor": [[44, 46], ["isinstance"], "function", ["None"], ["", "", "def", "is_tensor", "(", "arg", ")", ":", "\n", "    ", "return", "isinstance", "(", "arg", ",", "tf", ".", "Tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.detect_cycle": [[47, 60], ["isinstance", "tuple", "isinstance"], "function", ["None"], ["", "def", "detect_cycle", "(", "variable", ",", "substitutions", ")", ":", "\n", "    ", "\"\"\"check whether variable has been substituted before\"\"\"", "\n", "# cycle detection", "\n", "if", "not", "isinstance", "(", "variable", ",", "list", ")", "and", "variable", "in", "substitutions", ":", "\n", "        ", "return", "True", "\n", "", "elif", "tuple", "(", "variable", ")", "in", "substitutions", ":", "\n", "        ", "return", "True", "\n", "", "else", ":", "\n", "        ", "has_cycle", "=", "False", "\n", "for", "key", "in", "substitutions", ":", "\n", "            ", "if", "isinstance", "(", "key", ",", "list", ")", "and", "variable", "in", "key", ":", "\n", "                ", "has_cycle", "=", "True", "\n", "", "", "return", "has_cycle", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.rule_struct_form": [[61, 82], ["enumerate", "enumerate", "rule_value.append", "atom_value.append"], "function", ["None"], ["", "", "def", "rule_struct_form", "(", "rule", ",", "struct", ")", ":", "\n", "    ", "\"\"\"convert from 'kb form' to 'rule form'\n    kb form is [[symbol tensor for position in atom] for atom in rule]\n    rule form is [[dict of struct/atom_nr/term_nr for position in atom] for atom in rule] \n    The motivation for doing this is that you can keep track of what groups of logical terms are being unified, not\n    just the tensors\n    Args: \n        rule: list of atoms\n        struct: name of rule\n    Returns: \n        rule in rule form\n    \"\"\"", "\n", "\n", "rule_value", "=", "[", "]", "\n", "for", "atom_nr", ",", "atom", "in", "enumerate", "(", "rule", ")", ":", "\n", "        ", "atom_value", "=", "[", "]", "\n", "for", "term_nr", ",", "_", "in", "enumerate", "(", "atom", ")", ":", "\n", "            ", "term_value", "=", "{", "'struct'", ":", "struct", ",", "'atom'", ":", "atom_nr", ",", "'symbol'", ":", "term_nr", "}", "\n", "atom_value", ".", "append", "(", "term_value", ")", "\n", "", "rule_value", ".", "append", "(", "atom_value", ")", "\n", "", "return", "rule_value", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form": [[83, 93], ["isinstance", "prover.kb_form.kb_form_single"], "function", ["None"], ["", "def", "kb_form", "(", "struct_form", ",", "kb", ")", ":", "\n", "    ", "\"\"\"Convert from rule form back to kb form when you need the tensor\"\"\"", "\n", "\n", "def", "kb_form_single", "(", "term", ",", "kb", ")", ":", "\n", "        ", "return", "kb", "[", "term", "[", "'struct'", "]", "]", "[", "term", "[", "'atom'", "]", "]", "[", "term", "[", "'symbol'", "]", "]", "\n", "\n", "", "if", "isinstance", "(", "struct_form", ",", "list", ")", ":", "\n", "        ", "return", "[", "kb_form_single", "(", "term", ",", "kb", ")", "for", "term", "in", "struct_form", "]", "\n", "", "else", ":", "\n", "        ", "return", "kb_form_single", "(", "struct_form", ",", "kb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.unify_variables": [[94, 123], ["prover.detect_cycle", "len", "isinstance", "enumerate", "copy.deepcopy", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.detect_cycle"], ["", "", "def", "unify_variables", "(", "variables", ",", "values", ",", "substitutions", ",", "depth", "=", "0", ",", "goals_var", "=", "False", ")", ":", "\n", "    ", "\"\"\"Called when variables are unified with values. Stores variable value in substitution dict\n    Args:\n        variables: variables being unified\n        values: values variables are unified with\n        substitutions: dict of substitutions\n        depth: current depth of proof\n        goals_var: true if the goal is the variable, as opposed to the body\n    \"\"\"", "\n", "\n", "# store at what point in the proof the variable was substituted in order to calculate unification score", "\n", "# correctly if the same variable comes up at other stages of the proof", "\n", "success_subposition", "=", "len", "(", "substitutions", "[", "'HISTORY'", "]", ")", "-", "1", "\n", "if", "goals_var", ":", "\n", "        ", "success_subposition", "+=", "1", "\n", "\n", "", "if", "detect_cycle", "(", "variables", ",", "substitutions", ")", ":", "\n", "        ", "return", "'FAILURE'", "\n", "", "else", ":", "\n", "        ", "if", "isinstance", "(", "variables", ",", "list", ")", ":", "\n", "            ", "for", "i", ",", "value", "in", "enumerate", "(", "values", ")", ":", "\n", "                ", "value", "=", "copy", ".", "deepcopy", "(", "value", ")", "\n", "value", "[", "'sub_position'", "]", "=", "success_subposition", "\n", "substitutions", "[", "'VARSUBS'", "]", "[", "variables", "[", "i", "]", "]", "=", "value", "\n", "", "", "else", ":", "\n", "            ", "values", "=", "copy", ".", "deepcopy", "(", "values", ")", "\n", "values", "[", "'sub_position'", "]", "=", "success_subposition", "\n", "substitutions", "[", "'VARSUBS'", "]", "[", "variables", "]", "=", "values", "\n", "", "return", "substitutions", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.find_goal_position": [[124, 134], ["range", "len"], "function", ["None"], ["", "", "def", "find_goal_position", "(", "history", ",", "depth", ")", ":", "\n", "    ", "\"\"\"When batch unifying the embeddings of a goal symbol and a body symbol, the goal symbol is part of some logical atom.  \n    This function finds the position of that atom in the current proof. \n    Works by finding the first position in the proof history where the depth is equal to current depth.\"\"\"", "\n", "if", "depth", "==", "0", ":", "\n", "        ", "return", "0", "\n", "", "else", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "history", ")", ")", ":", "\n", "            ", "if", "history", "[", "i", "]", "[", "1", "]", "==", "depth", ":", "\n", "                ", "return", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.batch_unify": [[135, 205], ["prover.kb_form", "prover.kb_form", "ntp.modules.nunify.representation_match", "tf.expand_dims.get_shape", "tensorflow.minimum", "substitutions[].append", "current_unifications.append", "len", "tensorflow.expand_dims", "tf.expand_dims.get_shape", "len", "range", "current_unifications.append", "prover.find_goal_position", "range", "current_unifications.append", "tensorflow.gather", "tf.expand_dims.get_shape", "range", "len", "tf.expand_dims.get_shape", "tensorflow.expand_dims", "tensorflow.expand_dims", "len", "len", "tensorflow.expand_dims", "len", "tf.expand_dims.get_shape", "len", "tf.expand_dims.get_shape"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.nunify.representation_match", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.find_goal_position"], ["", "", "", "", "def", "batch_unify", "(", "rhs", ",", "goals", ",", "substitutions", ",", "kb", ",", "depth", "=", "0", ",", "mask", "=", "None", ",", "transpose", "=", "False", ",", "inner_tiling", "=", "True", ")", ":", "\n", "    ", "\"\"\"Given goal and rhs unification, calculate unification score and update the proof state with that score\"\"\"", "\n", "\n", "# If the goal contains a value that results from a variable substitution, the goal will contain information on", "\n", "# at what stage of the proof the substitution occurred. Want to update the unification at that position. ", "\n", "sub_position", "=", "-", "1", "\n", "if", "'sub_position'", "in", "goals", ":", "\n", "        ", "sub_position", "=", "goals", "[", "'sub_position'", "]", "\n", "\n", "", "rhs_tensor", "=", "kb_form", "(", "rhs", ",", "kb", ")", "# Transform lists of symbol ids to tensors", "\n", "goal_tensor", "=", "kb_form", "(", "goals", ",", "kb", ")", "\n", "\n", "current_success", "=", "representation_match", "(", "goal_tensor", ",", "rhs_tensor", ")", "\n", "current_unifications", "=", "[", "goals", ",", "rhs", "]", "\n", "\n", "if", "'SUCCESS'", "in", "substitutions", ":", "\n", "\n", "        ", "old_success", "=", "substitutions", "[", "'SUCCESS'", "]", "\n", "old_shape", "=", "old_success", ".", "get_shape", "(", ")", "\n", "\n", "# If unification is moving to the next atom, as opposed to another symbol in the same atom, add a dimension", "\n", "# to unification score tensor", "\n", "if", "len", "(", "old_shape", ")", "-", "1", "<", "len", "(", "substitutions", "[", "'HISTORY'", "]", ")", ":", "\n", "            ", "old_success", "=", "tf", ".", "expand_dims", "(", "old_success", ",", "axis", "=", "-", "1", ")", "\n", "old_shape", "=", "old_success", ".", "get_shape", "(", ")", "\n", "\n", "", "current_position", "=", "len", "(", "old_success", ".", "get_shape", "(", ")", ")", "-", "1", "\n", "\n", "if", "sub_position", "!=", "-", "1", ":", "\n", "# If current goal was result of substitution, expand dimensions to match position of goal in current success with appropriate position in old_success", "\n", "# Necessary because we want to update the unification scores at the correct proof tree paths             ", "\n", "            ", "pos_difference", "=", "len", "(", "old_shape", ")", "-", "sub_position", "-", "2", "\n", "for", "i", "in", "range", "(", "pos_difference", ")", ":", "\n", "                ", "current_success", "=", "tf", ".", "expand_dims", "(", "current_success", ",", "axis", "=", "1", ")", "\n", "\n", "", "current_unifications", ".", "append", "(", "[", "sub_position", ",", "len", "(", "old_success", ".", "get_shape", "(", ")", ")", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "# Find position of goal, and expand dimensions to match position of goal in current_success with appropriate position in old_success", "\n", "# Necessary in case there are multiple body atoms at the same depth, and we have to 'skip' a previous body atom", "\n", "            ", "goal_position", "=", "find_goal_position", "(", "substitutions", "[", "'HISTORY'", "]", ",", "depth", ")", "\n", "for", "i", "in", "range", "(", "current_position", "-", "goal_position", "-", "1", ")", ":", "\n", "                ", "current_success", "=", "tf", ".", "expand_dims", "(", "current_success", ",", "axis", "=", "1", ")", "\n", "", "current_unifications", ".", "append", "(", "[", "goal_position", ",", "current_position", "]", ")", "\n", "\n", "# If we are only using k_max proofs, we retrieve that subset from all current succes scores", "\n", "", "if", "'subset'", "in", "goals", ":", "\n", "            ", "subset", "=", "goals", "[", "'subset'", "]", "\n", "current_success", "=", "tf", ".", "gather", "(", "current_success", ",", "subset", ")", "\n", "\n", "", "current_success", "=", "tf", ".", "minimum", "(", "old_success", ",", "current_success", ")", "\n", "\n", "# Expand dimensions so that the mask broadcasts with the new success tensor", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask_shape", "=", "mask", ".", "get_shape", "(", ")", "\n", "dim_dif", "=", "len", "(", "current_success", ".", "get_shape", "(", ")", ")", "-", "len", "(", "mask_shape", ")", "\n", "for", "i", "in", "range", "(", "dim_dif", ")", ":", "\n", "# Expand in the middle because goal dimension is rank 0 and the last dimension is the fact dimension", "\n", "                ", "mask", "=", "tf", ".", "expand_dims", "(", "mask", ",", "axis", "=", "1", ")", "\n", "\n", "", "", "", "if", "mask", "is", "not", "None", ":", "\n", "        ", "current_success", "=", "current_success", "*", "mask", "\n", "\n", "", "substitutions", "[", "'SUCCESS'", "]", "=", "current_success", "\n", "\n", "if", "'UNIFICATIONS'", "in", "substitutions", ":", "\n", "        ", "substitutions", "[", "'UNIFICATIONS'", "]", ".", "append", "(", "current_unifications", ")", "\n", "", "else", ":", "\n", "        ", "current_unifications", ".", "append", "(", "[", "0", ",", "1", "]", ")", "\n", "substitutions", "[", "'UNIFICATIONS'", "]", "=", "[", "current_unifications", "]", "\n", "", "return", "substitutions", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.unify": [[207, 237], ["prover.kb_form", "prover.kb_form", "copy.copy", "len", "prover.consists_variables", "prover.unify_variables", "prover.consists_variables", "prover.unify_variables", "isinstance", "isinstance", "prover.unify", "prover.is_tensor", "len", "len", "prover.unify", "prover.batch_unify"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.consists_variables", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.unify_variables", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.consists_variables", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.unify_variables", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.unify", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.is_tensor", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.unify", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.batch_unify"], ["", "def", "unify", "(", "rhs", ",", "goals", ",", "substitutions", ",", "kb", ",", "depth", "=", "0", ",", "mask_id", "=", "None", ",", "transpose", "=", "False", ",", "inner_tiling", "=", "True", ")", ":", "\n", "    ", "\"\"\"Unifies goal with the head of a struct, updating the substitutions dict with any variable substitutions \n    and updating the unification score tensor with the current unification\"\"\"", "\n", "\n", "\n", "if", "len", "(", "goals", ")", "==", "1", ":", "\n", "        ", "goals", "=", "goals", "[", "0", "]", "\n", "rhs", "=", "rhs", "[", "0", "]", "\n", "\n", "", "if", "goals", "==", "rhs", ":", "\n", "        ", "return", "substitutions", "\n", "\n", "", "goals_kb", "=", "kb_form", "(", "goals", ",", "kb", ")", "\n", "rhs_kb", "=", "kb_form", "(", "rhs", ",", "kb", ")", "\n", "\n", "substitutions_copy", "=", "copy", ".", "copy", "(", "substitutions", ")", "\n", "if", "substitutions_copy", "==", "'FAILURE'", ":", "\n", "        ", "return", "substitutions_copy", "\n", "", "elif", "consists_variables", "(", "rhs_kb", ")", ":", "\n", "        ", "return", "unify_variables", "(", "rhs_kb", ",", "goals", ",", "substitutions_copy", ",", "depth", ")", "\n", "", "elif", "consists_variables", "(", "goals_kb", ")", ":", "\n", "        ", "return", "unify_variables", "(", "goals_kb", ",", "rhs", ",", "substitutions_copy", ",", "depth", ",", "goals_var", "=", "True", ")", "\n", "", "elif", "isinstance", "(", "rhs_kb", ",", "list", ")", "and", "isinstance", "(", "goals_kb", ",", "list", ")", "and", "len", "(", "rhs_kb", ")", "==", "len", "(", "goals_kb", ")", ":", "\n", "        ", "return", "unify", "(", "rhs", "[", "0", "]", ",", "goals", "[", "0", "]", ",", "\n", "unify", "(", "rhs", "[", "1", ":", "]", ",", "goals", "[", "1", ":", "]", ",", "substitutions_copy", ",", "kb", ",", "depth", ",", "\n", "mask_id", ",", "transpose", ",", "inner_tiling", ")", ",", "kb", ",", "\n", "depth", ",", "mask_id", ",", "transpose", ",", "inner_tiling", ")", "\n", "", "elif", "is_tensor", "(", "goals_kb", ")", ":", "\n", "        ", "return", "batch_unify", "(", "rhs", ",", "goals", ",", "substitutions", ",", "kb", ",", "depth", ",", "mask_id", ",", "transpose", ",", "inner_tiling", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.substitute": [[239, 258], ["prover.kb_form", "enumerate", "prover.consists_variables", "new_goal.append", "isinstance"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.consists_variables"], ["", "", "def", "substitute", "(", "goals", ",", "substitutions", ",", "kb", ")", ":", "\n", "    ", "\"\"\"Check if goal contains any variables for which we have already have substitutions, and if so, replace the variables with corresponding values.\"\"\"", "\n", "\n", "goals_kb", "=", "kb_form", "(", "goals", ",", "kb", ")", "\n", "\n", "new_goal", "=", "[", "]", "\n", "for", "arg_nr", ",", "arg", "in", "enumerate", "(", "goals_kb", ")", ":", "\n", "        ", "new_arg", "=", "goals", "[", "arg_nr", "]", "\n", "if", "consists_variables", "(", "arg", ")", ":", "\n", "            ", "if", "isinstance", "(", "arg", ",", "list", ")", ":", "\n", "                ", "var", "=", "arg", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "var", "=", "arg", "\n", "", "if", "var", "in", "substitutions", "[", "'VARSUBS'", "]", ":", "\n", "                ", "new_arg", "=", "substitutions", "[", "'VARSUBS'", "]", "[", "var", "]", "\n", "\n", "", "", "new_goal", ".", "append", "(", "new_arg", ")", "\n", "\n", "", "return", "new_goal", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.flatten_proofs": [[259, 271], ["list", "prover.flatten_proofs.flatten"], "function", ["None"], ["", "def", "flatten_proofs", "(", "proofs", ")", ":", "\n", "    ", "def", "flatten", "(", "xs", ")", ":", "\n", "        ", "for", "x", "in", "xs", ":", "\n", "            ", "if", "isinstance", "(", "x", ",", "collections", ".", "Iterable", ")", "and", "not", "isinstance", "(", "x", ",", "str", ")", "and", "not", "isinstance", "(", "x", ",", "dict", ")", ":", "\n", "                ", "for", "sub", "in", "flatten", "(", "x", ")", ":", "\n", "                    ", "yield", "sub", "\n", "", "", "else", ":", "\n", "                ", "yield", "x", "\n", "\n", "", "", "", "return", "list", "(", "flatten", "(", "proofs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.applied_before": [[273, 279], ["prover.kb_form", "any", "ntp.util.util_kb.is_variable"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable"], ["", "def", "applied_before", "(", "rule", ",", "substitutions", ",", "kb", ")", ":", "\n", "    ", "\"\"\"Check if a rule has already been applied earlier in the proof tree\"\"\"", "\n", "head", "=", "kb_form", "(", "rule", "[", "0", "]", ",", "kb", ")", "\n", "head_vars", "=", "[", "x", "for", "x", "in", "head", "if", "is_variable", "(", "x", ")", "]", "\n", "\n", "return", "any", "(", "[", "x", "for", "x", "in", "head_vars", "if", "x", "in", "substitutions", "[", "'VARSUBS'", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.or_": [[281, 358], ["dict", "prover.flatten_proofs", "prover.rule_struct_form", "prover.substitute", "copy.deepcopy", "substitutions_copy[].append", "prover.unify", "len", "len", "all", "prover.applied_before", "tensorflow.nn.top_k", "substitutions_[].values", "prover.and_", "len", "isinstance", "prover.flatten_proofs", "proofs.append", "ntp.util.util_kb.is_variable"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.flatten_proofs", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.rule_struct_form", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.substitute", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.unify", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.applied_before", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.and_", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.flatten_proofs", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable"], ["", "def", "or_", "(", "kb", ",", "goals", ",", "substitutions", "=", "dict", "(", ")", ",", "depth", "=", "0", ",", "mask", "=", "None", ",", "\n", "k_max", "=", "None", ",", "max_depth", "=", "1", ")", ":", "\n", "    ", "\"\"\"Base function of prover, called recursively. \n    Calls and_, which in turn calls or_, in order to recursively calculate scores for every possible proof in proof\n    tree. \n    Args:\n        kb: dict of facts / rules\n        goals: goal to be proved\n        substitutions: dict which contains current variable substitutions and scores of current proof path\n        depth: current proof depth\n        mask: mask to apply so that goal facts (which are drawn from kb) cannot be proved by unifying with themselves\n        k_max: number of fact unifications to retain from unifications with all facts in kb\n        max_depth: maximum allowed proof depth before termination\n    Returns:\n        List of proof paths of goal with corresponding scores\n    \"\"\"", "\n", "proofs", "=", "[", "]", "\n", "\n", "# initialize history and substitutions as empty", "\n", "if", "substitutions", "==", "{", "}", ":", "\n", "        ", "substitutions", "[", "'VARSUBS'", "]", "=", "{", "}", "\n", "substitutions", "[", "'HISTORY'", "]", "=", "[", "]", "\n", "\n", "\n", "", "for", "struct", "in", "kb", ":", "\n", "# avoid fake added struct", "\n", "        ", "if", "struct", "==", "'goal'", ":", "\n", "            ", "continue", "\n", "\n", "# Check if struct order matches", "\n", "", "if", "len", "(", "struct", "[", "0", "]", ")", "!=", "len", "(", "goals", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "rule", "=", "rule_struct_form", "(", "kb", "[", "struct", "]", ",", "struct", ")", "\n", "head", "=", "substitute", "(", "rule", "[", "0", "]", ",", "substitutions", ",", "kb", ")", "\n", "body", "=", "rule", "[", "1", ":", "]", "\n", "mask_id", "=", "None", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask_key", ",", "mask_id", "=", "mask", "\n", "mask_id", "=", "mask_id", "if", "mask_key", "==", "struct", "else", "None", "\n", "\n", "", "is_fact", "=", "len", "(", "struct", ")", "==", "1", "and", "all", "(", "[", "not", "is_variable", "(", "x", ")", "\n", "for", "x", "in", "struct", "[", "0", "]", "]", ")", "\n", "\n", "if", "not", "is_fact", "and", "depth", "==", "max_depth", ":", "\n", "# maximum depth reached", "\n", "            ", "continue", "\n", "\n", "# rule has been applied before", "\n", "", "elif", "applied_before", "(", "rule", ",", "substitutions", ",", "kb", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "substitutions_copy", "=", "copy", ".", "deepcopy", "(", "substitutions", ")", "\n", "substitutions_copy", "[", "'HISTORY'", "]", ".", "append", "(", "[", "struct", ",", "depth", "]", ")", "\n", "substitutions_", "=", "unify", "(", "head", ",", "goals", ",", "substitutions_copy", ",", "kb", ",", "depth", ",", "mask_id", ",", "\n", "transpose", "=", "is_fact", ")", "\n", "\n", "\n", "if", "is_fact", "and", "k_max", "is", "not", "None", ":", "\n", "            ", "new_success", ",", "success_indices", "=", "tf", ".", "nn", ".", "top_k", "(", "substitutions_", "[", "\"SUCCESS\"", "]", ",", "k_max", ")", "\n", "substitutions_", "[", "\"SUCCESS\"", "]", "=", "new_success", "\n", "for", "value", "in", "substitutions_", "[", "'VARSUBS'", "]", ".", "values", "(", ")", ":", "\n", "                ", "if", "value", "[", "'struct'", "]", "!=", "'goal'", "and", "not", "'subset'", "in", "value", ":", "\n", "                    ", "value", "[", "'subset'", "]", "=", "success_indices", "\n", "\n", "", "", "", "if", "substitutions_", "!=", "'FAILURE'", ":", "\n", "            ", "proof", "=", "and_", "(", "kb", ",", "body", ",", "substitutions_", ",", "depth", ",", "mask", ",", "k_max", "=", "k_max", ",", "max_depth", "=", "max_depth", ")", "\n", "\n", "if", "not", "isinstance", "(", "proof", ",", "list", ")", ":", "\n", "                ", "proof", "=", "[", "proof", "]", "\n", "", "else", ":", "\n", "                ", "proof", "=", "flatten_proofs", "(", "proof", ")", "\n", "\n", "", "for", "proof_substitutions", "in", "proof", ":", "\n", "                ", "if", "proof_substitutions", "!=", "'FAILURE'", ":", "\n", "                    ", "proofs", ".", "append", "(", "proof_substitutions", ")", "\n", "", "", "", "", "return", "flatten_proofs", "(", "proofs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.and_": [[360, 382], ["len", "prover.substitute", "prover.or_", "proofs.append", "prover.and_"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.substitute", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.or_", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.and_"], ["", "def", "and_", "(", "kb", ",", "subgoals", ",", "substitutions", ",", "depth", "=", "0", ",", "mask", "=", "None", ",", "in_body", "=", "False", ",", "k_max", "=", "None", ",", "\n", "max_depth", "=", "1", ")", ":", "\n", "    ", "\"\"\"Generate new goals consisting of the body of the struct that previous goal was unified with and calls or_ to prove new goals\"\"\"", "\n", "if", "len", "(", "subgoals", ")", "==", "0", ":", "\n", "        ", "return", "substitutions", "\n", "", "elif", "depth", "==", "max_depth", ":", "# maximum depth", "\n", "        ", "return", "'FAILURE'", "\n", "", "else", ":", "\n", "        ", "head", "=", "subgoals", "[", "0", "]", "\n", "body", "=", "subgoals", "[", "1", ":", "]", "\n", "\n", "proofs", "=", "[", "]", "\n", "\n", "new_goal", "=", "substitute", "(", "head", ",", "substitutions", ",", "kb", ")", "\n", "\n", "new_body", "=", "body", "\n", "\n", "for", "substitutions_", "in", "or_", "(", "kb", ",", "new_goal", ",", "substitutions", ",", "depth", "+", "1", ",", "mask", ",", "\n", "k_max", "=", "k_max", ",", "max_depth", "=", "max_depth", ")", ":", "\n", "            ", "proofs", ".", "append", "(", "and_", "(", "kb", ",", "new_body", ",", "substitutions_", ",", "depth", ",", "mask", ",", "in_body", "=", "True", ",", "k_max", "=", "k_max", ",", "\n", "max_depth", "=", "max_depth", ")", ")", "\n", "", "return", "proofs", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.prove": [[384, 392], ["prover.or_"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.or_"], ["", "", "def", "prove", "(", "kb", ",", "goals", ",", "mask_structure", ",", "mask_var", ",", "\n", "k_max", "=", "None", ",", "max_depth", "=", "1", ",", "vocab", "=", "None", ")", ":", "\n", "\n", "    ", "proofs", "=", "or_", "(", "kb", ",", "goals", ",", "\n", "mask", "=", "(", "mask_structure", ",", "mask_var", ")", ",", "\n", "k_max", "=", "k_max", ",", "max_depth", "=", "max_depth", ")", "\n", "\n", "return", "proofs", "\n", "", ""]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.nunify.representation_match": [[6, 31], ["tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.clip_by_value", "tensorflow.sqrt", "tensorflow.matmul", "tensorflow.square", "tensorflow.square", "tensorflow.exp", "tensorflow.exp", "tensorflow.transpose", "tensorflow.transpose"], "function", ["None"], ["def", "representation_match", "(", "a", ",", "b", ",", "slope", "=", "1.0", ")", ":", "\n", "\n", "    ", "\"\"\"\n    Calculates negative exponent of L2 distance between tensors\n    Args:\n    a: [N x k] tensor\n    b: [M x k] tensor\n    slope: coefficient on L2 distance in exponent\n    Returns:\n    sim: [N x M] tensor of negative exponent of L2 distances\n    \"\"\"", "\n", "\n", "c", "=", "-", "2", "*", "tf", ".", "matmul", "(", "a", ",", "tf", ".", "transpose", "(", "b", ")", ")", "\n", "na", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "a", ")", ",", "1", ",", "keep_dims", "=", "True", ")", "\n", "nb", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "b", ")", ",", "1", ",", "keep_dims", "=", "True", ")", "\n", "\n", "l2", "=", "(", "c", "+", "tf", ".", "transpose", "(", "nb", ")", ")", "+", "na", "\n", "l2", "=", "tf", ".", "clip_by_value", "(", "l2", ",", "1e-6", ",", "1000", ")", "\n", "l2", "=", "tf", ".", "sqrt", "(", "l2", ")", "\n", "if", "slope", "!=", "1.0", ":", "\n", "        ", "sim", "=", "tf", ".", "exp", "(", "-", "l2", "*", "slope", ")", "\n", "", "else", ":", "\n", "        ", "sim", "=", "tf", ".", "exp", "(", "-", "l2", ")", "\n", "\n", "", "return", "sim", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.nunify.l2_sim_np": [[32, 44], ["numpy.sum", "numpy.sum", "numpy.clip", "numpy.sqrt", "numpy.exp", "numpy.matmul", "numpy.transpose", "numpy.transpose"], "function", ["None"], ["", "def", "l2_sim_np", "(", "a", ",", "b", ")", ":", "\n", "    ", "\"\"\"Calculates negative exponent of L2 distances using numpy\"\"\"", "\n", "c", "=", "-", "2", "*", "np", ".", "matmul", "(", "a", ",", "np", ".", "transpose", "(", "b", ")", ")", "\n", "na", "=", "np", ".", "sum", "(", "a", "*", "a", ",", "axis", "=", "1", ")", "\n", "nb", "=", "np", ".", "sum", "(", "b", "*", "b", ",", "axis", "=", "1", ")", "\n", "# this is broadcasting!", "\n", "l2", "=", "(", "c", "+", "np", ".", "transpose", "(", "nb", ")", ")", "+", "na", "\n", "l2", "=", "np", ".", "clip", "(", "l2", ",", "1e-6", ",", "1000", ")", "\n", "l2", "=", "np", ".", "sqrt", "(", "l2", ")", "\n", "sim", "=", "np", ".", "exp", "(", "-", "l2", ")", "\n", "\n", "return", "sim", "\n", "", ""]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.auto_gradient": [[12, 30], ["tensorflow.GradientTape", "copy.deepcopy", "ntp.modules.kb.kb2nkb", "ntp.modules.prover.prove", "loss_function", "tape.gradient", "tensorflow.nn.l2_loss", "row.numpy", "range"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2nkb", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.prove"], ["def", "auto_gradient", "(", "loss_function", ",", "goal", ",", "target", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "goal_struct", ",", "batch_mask", ",", "l2", ",", "k_max", ",", "max_depth", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Automatically calculate gradient using gradient tape. Can be significantly slower than calculating manually\"\"\"", "\n", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "        ", "kb_goal", "=", "copy", ".", "deepcopy", "(", "kb_ids", ")", "\n", "kb_goal", "[", "'goal'", "]", "=", "[", "[", "row", ".", "numpy", "(", ")", "for", "row", "in", "goal", "]", "]", "\n", "nkb", "=", "kb2nkb", "(", "kb_goal", ",", "emb", ")", "\n", "\n", "goal", "=", "[", "{", "'struct'", ":", "'goal'", ",", "'atom'", ":", "0", ",", "'symbol'", ":", "i", "}", "for", "i", "in", "range", "(", "goal", ".", "ndim", ")", "]", "\n", "\n", "proofs", "=", "prove", "(", "nkb", ",", "goal", ",", "goal_struct", ",", "batch_mask", ",", "\n", "k_max", "=", "k_max", ",", "max_depth", "=", "max_depth", ",", "vocab", "=", "vocab", ")", "\n", "\n", "loss", "=", "loss_function", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", "\n", "loss", "+=", "tf", ".", "nn", ".", "l2_loss", "(", "emb", ")", "*", "l2", "\n", "grad", "=", "tape", ".", "gradient", "(", "loss", ",", "emb", ")", "\n", "\n", "", "return", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.standard_loss": [[31, 36], ["tensorflow.squeeze", "gradient.loss_from_proof", "gradient.retrieve_top_k"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.loss_from_proof", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k"], ["", "def", "standard_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Loss given by score of best proof\"\"\"", "\n", "success", "=", "tf", ".", "squeeze", "(", "retrieve_top_k", "(", "proofs", ")", ")", "\n", "loss", "=", "loss_from_proof", "(", "success", ",", "target", ",", "epsilon", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.all_type_loss": [[37, 45], ["tensorflow.squeeze", "gradient.loss_from_proof", "gradient.retrieve_top_k"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.loss_from_proof", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k"], ["", "def", "all_type_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Loss given by sum of scores of best proofs of each type\"\"\"", "\n", "loss", "=", "0", "\n", "for", "proof", "in", "proofs", ":", "\n", "        ", "success", "=", "tf", ".", "squeeze", "(", "retrieve_top_k", "(", "[", "proof", "]", ")", ")", "\n", "temp_loss", "=", "loss_from_proof", "(", "success", ",", "target", ",", "epsilon", ")", "\n", "loss", "+=", "temp_loss", "\n", "", "return", "loss", "*", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.top_k_loss": [[46, 57], ["gradient.retrieve_top_k", "tensorflow.split", "tensorflow.squeeze", "gradient.loss_from_proof"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.loss_from_proof"], ["", "def", "top_k_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Loss given by sum of scores of top-k proofs\"\"\"", "\n", "k", "=", "loss_parameters", "[", "\"k\"", "]", "\n", "success", "=", "retrieve_top_k", "(", "proofs", ",", "k", ")", "\n", "success_split", "=", "tf", ".", "split", "(", "success", ",", "k", ",", "axis", "=", "-", "1", ")", "\n", "loss", "=", "0", "\n", "for", "sub_success", "in", "success_split", ":", "\n", "        ", "sub_success", "=", "tf", ".", "squeeze", "(", "sub_success", ")", "\n", "temp_loss", "=", "loss_from_proof", "(", "sub_success", ",", "target", ",", "epsilon", ")", "\n", "loss", "+=", "temp_loss", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.top_k_all_type_loss": [[58, 70], ["gradient.retrieve_top_k", "tensorflow.split", "tensorflow.squeeze", "gradient.loss_from_proof"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.loss_from_proof"], ["", "def", "top_k_all_type_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Loss given by sum of scores of top-k proofs for each proof path\"\"\"", "\n", "k", "=", "loss_parameters", "[", "\"k\"", "]", "\n", "loss", "=", "0", "\n", "for", "proof", "in", "proofs", ":", "\n", "        ", "success", "=", "retrieve_top_k", "(", "[", "proof", "]", ",", "k", ")", "\n", "success_split", "=", "tf", ".", "split", "(", "success", ",", "k", ",", "axis", "=", "-", "1", ")", "\n", "for", "sub_success", "in", "success_split", ":", "\n", "            ", "sub_success", "=", "tf", ".", "squeeze", "(", "sub_success", ")", "\n", "temp_loss", "=", "loss_from_proof", "(", "sub_success", ",", "target", ",", "epsilon", ")", "\n", "loss", "+=", "temp_loss", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.top_k_all_anneal_loss": [[71, 85], ["regime_function", "numpy.digitize"], "function", ["None"], ["", "def", "top_k_all_anneal_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Choose loss function based on epoch in training, annealing from all-path to normal or top-k to top-1\"\"\"", "\n", "epoch", "=", "loss_parameters", "[", "\"epoch\"", "]", "\n", "regime_thresholds", "=", "loss_parameters", "[", "\"regime_thresholds\"", "]", "\n", "regime_types", "=", "loss_parameters", "[", "\"regime_types\"", "]", "\n", "k_values", "=", "loss_parameters", "[", "\"k_values\"", "]", "\n", "\n", "regime", "=", "np", ".", "digitize", "(", "epoch", ",", "regime_thresholds", ")", "-", "1", "\n", "\n", "new_parameters", "=", "{", "\"k\"", ":", "k_values", "[", "regime", "]", "}", "\n", "regime_function", "=", "loss_dict", "[", "regime_types", "[", "regime", "]", "]", "\n", "\n", "\n", "return", "regime_function", "(", "proofs", ",", "target", ",", "epsilon", ",", "new_parameters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.top_k_kernel_anneal_loss": [[86, 106], ["tensorflow.concat", "tensorflow.split", "enumerate", "gradient.retrieve_top_k", "successes.append", "tensorflow.nn.top_k", "tensorflow.squeeze", "gradient.loss_from_proof", "retrieve_top_k.get_shape", "retrieve_top_k.get_shape"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.loss_from_proof"], ["", "def", "top_k_kernel_anneal_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Take weighted average over top-k proofs, placing more weight on the best proof as training progresses\"\"\"", "\n", "epoch", "=", "loss_parameters", "[", "\"epoch\"", "]", "\n", "\n", "k", "=", "loss_parameters", "[", "\"k\"", "]", "\n", "loss", "=", "0", "\n", "successes", "=", "[", "]", "\n", "for", "proof", "in", "proofs", ":", "\n", "        ", "success", "=", "retrieve_top_k", "(", "[", "proof", "]", ",", "k", ")", "\n", "successes", ".", "append", "(", "success", ")", "\n", "\n", "", "success", "=", "tf", ".", "concat", "(", "successes", ",", "axis", "=", "1", ")", "\n", "success", "=", "tf", ".", "nn", ".", "top_k", "(", "success", ",", "success", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", "[", "0", "]", "\n", "success_split", "=", "tf", ".", "split", "(", "success", ",", "success", ".", "get_shape", "(", ")", "[", "-", "1", "]", ",", "axis", "=", "-", "1", ")", "\n", "for", "j", ",", "sub_success", "in", "enumerate", "(", "success_split", ")", ":", "\n", "        ", "sub_success", "=", "tf", ".", "squeeze", "(", "sub_success", ")", "\n", "temp_loss", "=", "loss_from_proof", "(", "sub_success", ",", "target", ",", "epsilon", ")", "\n", "loss", "+=", "(", "50", "/", "(", "50", "+", "epoch", ")", ")", "**", "j", "*", "temp_loss", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.top_k_score_anneal_loss": [[107, 141], ["tensorflow.squeeze", "numpy.max", "numpy.zeros", "range", "tensorflow.convert_to_tensor", "tensorflow.expand_dims", "tensorflow.reduce_sum", "gradient.retrieve_top_k", "numpy.digitize", "gradient.retrieve_top_k", "gradient.standard_loss", "retrieve_top_k.get_shape", "range", "tensorflow.log", "tensorflow.log", "len", "tensorflow.clip_by_value", "tensorflow.clip_by_value"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.standard_loss"], ["", "def", "top_k_score_anneal_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Choose loss function based on score of best proof, using more proofs as the certainty of the model decreases\"\"\"", "\n", "\n", "success", "=", "tf", ".", "squeeze", "(", "retrieve_top_k", "(", "proofs", ")", ")", "\n", "regime_thresholds", "=", "loss_parameters", "[", "\"regime_thresholds\"", "]", "\n", "\n", "regimes", "=", "np", ".", "digitize", "(", "success", ",", "regime_thresholds", ")", "-", "1", "\n", "k_values", "=", "[", "loss_parameters", "[", "\"k_values\"", "]", "[", "regimes", "[", "i", "]", "]", "for", "i", "in", "range", "(", "len", "(", "regimes", ")", ")", "]", "\n", "\n", "max_k", "=", "np", ".", "max", "(", "k_values", ")", "\n", "\n", "if", "max_k", ">", "1", ":", "\n", "        ", "success", "=", "retrieve_top_k", "(", "proofs", ",", "k", "=", "max_k", ")", "\n", "", "else", ":", "\n", "        ", "return", "standard_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", "\n", "\n", "", "n_goals", "=", "success", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "n_goals", ",", "max_k", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_goals", ")", ":", "\n", "        ", "mask", "[", "i", ",", ":", "k_values", "[", "i", "]", "]", "+=", "1", "\n", "\n", "", "mask", "=", "tf", ".", "convert_to_tensor", "(", "mask", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "x", "=", "success", "\n", "z", "=", "tf", ".", "expand_dims", "(", "target", ",", "axis", "=", "-", "1", ")", "\n", "loss_tensor", "=", "-", "z", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "x", ",", "epsilon", ",", "1.0", ")", ")", "-", "(", "1", "-", "z", ")", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "1", "-", "x", ",", "epsilon", ",", "1.0", ")", ")", "\n", "\n", "loss", "=", "mask", "*", "loss_tensor", "\n", "\n", "total_loss", "=", "tf", ".", "reduce_sum", "(", "loss", ")", "\n", "\n", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.top_k_score_anneal_all_loss": [[143, 191], ["tensorflow.squeeze", "gradient.retrieve_top_k", "numpy.zeros", "range", "tensorflow.expand_dims", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.expand_dims", "tensorflow.reduce_sum", "gradient.retrieve_top_k", "numpy.digitize", "gradient.retrieve_top_k", "retrieve_top_k.get_shape", "tensorflow.convert_to_tensor", "tensorflow.reduce_sum", "range", "range", "tensorflow.log", "tensorflow.log", "len", "len", "tensorflow.clip_by_value", "tensorflow.clip_by_value", "tensorflow.log", "tensorflow.log", "tensorflow.clip_by_value", "tensorflow.clip_by_value"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k"], ["", "def", "top_k_score_anneal_all_loss", "(", "proofs", ",", "target", ",", "epsilon", ",", "loss_parameters", ")", ":", "\n", "    ", "\"\"\"Choose loss function based on score of best proof, using more proofs and of more types as the certainty of the model decreases\"\"\"", "\n", "\n", "success", "=", "tf", ".", "squeeze", "(", "retrieve_top_k", "(", "proofs", ")", ")", "\n", "regime_thresholds", "=", "loss_parameters", "[", "\"regime_thresholds\"", "]", "\n", "\n", "regimes", "=", "np", ".", "digitize", "(", "success", ",", "regime_thresholds", ")", "-", "1", "\n", "k_values", "=", "[", "loss_parameters", "[", "\"k_values\"", "]", "[", "regimes", "[", "i", "]", "]", "for", "i", "in", "range", "(", "len", "(", "regimes", ")", ")", "]", "\n", "all_type", "=", "[", "loss_parameters", "[", "\"all_type\"", "]", "[", "regimes", "[", "i", "]", "]", "for", "i", "in", "range", "(", "len", "(", "regimes", ")", ")", "]", "\n", "\n", "max_k", "=", "loss_parameters", "[", "\"max_k\"", "]", "\n", "\n", "success", "=", "retrieve_top_k", "(", "proofs", ",", "k", "=", "max_k", ")", "\n", "proof_successes", "=", "[", "retrieve_top_k", "(", "[", "proof", "]", ",", "k", "=", "max_k", ")", "for", "proof", "in", "proofs", "]", "\n", "\n", "\n", "n_goals", "=", "success", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "\n", "k_mask", "=", "np", ".", "zeros", "(", "(", "n_goals", ",", "max_k", ")", ")", "\n", "for", "i", "in", "range", "(", "n_goals", ")", ":", "\n", "        ", "k_mask", "[", "i", ",", ":", "k_values", "[", "i", "]", "]", "+=", "1", "\n", "\n", "", "type_mask", "=", "tf", ".", "expand_dims", "(", "tf", ".", "convert_to_tensor", "(", "all_type", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "axis", "=", "-", "1", ")", "\n", "base_mask", "=", "k_mask", "*", "(", "1", "-", "type_mask", ")", "\n", "all_mask", "=", "k_mask", "*", "type_mask", "\n", "\n", "base_mask", "=", "tf", ".", "convert_to_tensor", "(", "base_mask", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "all_mask", "=", "tf", ".", "convert_to_tensor", "(", "all_mask", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "x", "=", "success", "\n", "z", "=", "tf", ".", "expand_dims", "(", "target", ",", "axis", "=", "-", "1", ")", "\n", "loss_tensor", "=", "-", "z", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "x", ",", "epsilon", ",", "1.0", ")", ")", "-", "(", "1", "-", "z", ")", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "1", "-", "x", ",", "epsilon", ",", "1.0", ")", ")", "\n", "\n", "loss", "=", "base_mask", "*", "loss_tensor", "\n", "\n", "total_loss", "=", "tf", ".", "reduce_sum", "(", "loss", ")", "\n", "\n", "for", "proof_success", "in", "proof_successes", ":", "\n", "        ", "x", "=", "proof_success", "\n", "loss_tensor", "=", "-", "z", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "x", ",", "epsilon", ",", "1.0", ")", ")", "-", "(", "1", "-", "z", ")", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "1", "-", "x", ",", "epsilon", ",", "1.0", ")", ")", "\n", "\n", "loss", "=", "all_mask", "*", "loss_tensor", "\n", "\n", "total_loss", "+=", "tf", ".", "reduce_sum", "(", "loss", ")", "\n", "\n", "", "return", "total_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.retrieve_top_k": [[205, 222], ["enumerate", "tensorflow.nn.top_k", "tensor.get_shape", "tensorflow.reshape", "len", "tensorflow.concat"], "function", ["None"], ["def", "retrieve_top_k", "(", "proofs", ",", "k", "=", "1", ")", ":", "\n", "    ", "\"\"\"Given a list of proofs, find the k overall best proofs\"\"\"", "\n", "tensors", "=", "[", "proof", "[", "\"SUCCESS\"", "]", "for", "proof", "in", "proofs", "]", "\n", "\n", "for", "i", ",", "tensor", "in", "enumerate", "(", "tensors", ")", ":", "\n", "        ", "proof_shape", "=", "tensor", ".", "get_shape", "(", ")", "\n", "num_goals", "=", "proof_shape", "[", "0", "]", "\n", "success_per_proof", "=", "tf", ".", "reshape", "(", "tensor", ",", "[", "num_goals", ",", "-", "1", "]", ")", "\n", "tensors", "[", "i", "]", "=", "success_per_proof", "\n", "", "if", "len", "(", "tensors", ")", ">", "1", ":", "\n", "        ", "success_per_proof", "=", "tf", ".", "concat", "(", "tensors", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "success_per_proof", "=", "tensors", "[", "0", "]", "\n", "\n", "", "top_k", "=", "tf", ".", "nn", ".", "top_k", "(", "success_per_proof", ",", "k", ")", "\n", "\n", "return", "top_k", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.loss_from_proof": [[223, 231], ["tensorflow.reduce_sum", "tensorflow.log", "tensorflow.log", "tensorflow.clip_by_value", "tensorflow.clip_by_value"], "function", ["None"], ["", "def", "loss_from_proof", "(", "success", ",", "target", ",", "epsilon", ")", ":", "\n", "    ", "\"\"\"Given success of a proof, a target and epsilon, calculate loss from just that proof\"\"\"", "\n", "x", "=", "success", "\n", "z", "=", "target", "\n", "loss", "=", "-", "z", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "x", ",", "epsilon", ",", "1.0", ")", ")", "-", "(", "1", "-", "z", ")", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "1", "-", "x", ",", "epsilon", ",", "1.0", ")", ")", "\n", "loss", "=", "tf", ".", "reduce_sum", "(", "loss", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.manual_gradient": [[236, 257], ["copy.deepcopy", "ntp.modules.kb.kb2nkb", "ntp.modules.prover.prove", "emb.numpy", "gradient.calculate_gradient", "tensorflow.convert_to_tensor", "target.numpy", "row.numpy", "range", "len"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb2nkb", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.prove", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.calculate_gradient"], ["", "def", "manual_gradient", "(", "goal", ",", "target", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "goal_struct", ",", "batch_mask", ",", "l2", ",", "k_max", ",", "max_depth", ",", "n_facts", ")", ":", "\n", "    ", "\"\"\"Use simple structure of model to calculate gradient manually given goal, training facts, and embedding. \"\"\"", "\n", "\n", "# Get nkb that includes 'fake' struct consisting of goal", "\n", "kb_goal", "=", "copy", ".", "deepcopy", "(", "kb_ids", ")", "\n", "kb_goal", "[", "'goal'", "]", "=", "[", "[", "row", ".", "numpy", "(", ")", "for", "row", "in", "goal", "]", "]", "\n", "nkb", "=", "kb2nkb", "(", "kb_goal", ",", "emb", ")", "\n", "\n", "goal", "=", "[", "{", "'struct'", ":", "'goal'", ",", "'atom'", ":", "0", ",", "'symbol'", ":", "i", "}", "for", "i", "in", "range", "(", "len", "(", "goal_struct", "[", "0", "]", ")", ")", "]", "\n", "\n", "proofs", "=", "prove", "(", "nkb", ",", "goal", ",", "goal_struct", ",", "batch_mask", ",", "\n", "k_max", "=", "k_max", ",", "max_depth", "=", "max_depth", ",", "vocab", "=", "vocab", ")", "\n", "\n", "emb_np", "=", "emb", ".", "numpy", "(", ")", "\n", "shape", "=", "emb_np", ".", "shape", "\n", "\n", "grad", "=", "calculate_gradient", "(", "proofs", ",", "nkb", ",", "kb_goal", ",", "emb", ",", "target", ".", "numpy", "(", ")", ",", "shape", ",", "n_facts", ")", "\n", "grad", "=", "tf", ".", "convert_to_tensor", "(", "grad", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "grad", "+=", "l2", "*", "emb", "\n", "\n", "return", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.calculate_gradient": [[258, 358], ["numpy.array", "numpy.argmax", "len", "range", "tensorflow.constant", "tensorflow.constant", "tensorflow.nn.embedding_lookup", "tensorflow.nn.embedding_lookup", "tensorflow.exp", "tensorflow.split", "range", "tensorflow.gather", "tensorflow.stack", "tensorflow.split", "tensorflow.expand_dims", "tensorflow.expand_dims", "gradient_values.numpy.numpy", "numpy.zeros", "range", "proof[].numpy", "numpy.reshape", "numpy.argmax", "numpy.unravel_index", "goal_shapes.append", "cumulative_shape.append", "numpy.argmin", "value.numpy", "tensorflow.reduce_min", "numpy.max", "len", "tf.constant.append", "tf.constant.append", "tensorflow.norm", "len", "range", "range", "tensorflow.log", "tensorflow.log", "len", "len", "ntp.modules.prover.kb_form", "ntp.modules.prover.kb_form"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.prover.kb_form"], ["", "def", "calculate_gradient", "(", "proofs", ",", "nkb", ",", "kb_ids", ",", "emb", ",", "targets", ",", "shape", ",", "n_facts", ")", ":", "\n", "    ", "\"\"\"\n    Calculates the gradient for a particular proof manually from the array that stores active (worst) unifications per proof. \n    Args:\n        proofs: list of proofs, each proof is a dict with information about a proof type\n        emb: embedding matrix\n        targets: 1/0 depending on whether goal is corrupted or not\n        shape: shape of emb (and therefore gradient)\n        n_facts: facts in kb\n        kb_ids: Contains facts of kb, with symbol ids\n        goal_struct: struct of goal, i.e. ('p', 'c')\n    Returns:\n        gradient\n    \"\"\"", "\n", "\n", "proof_successes", "=", "[", "proof", "[", "'SUCCESS'", "]", ".", "numpy", "(", ")", "for", "proof", "in", "proofs", "]", "\n", "success_reshaped", "=", "[", "np", ".", "reshape", "(", "\n", "success", ",", "(", "success", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "for", "success", "in", "proof_successes", "]", "\n", "\n", "success_max", "=", "np", ".", "array", "(", "[", "np", ".", "max", "(", "success", ",", "axis", "=", "1", ")", "for", "success", "in", "success_reshaped", "]", ")", "\n", "best_proof_indices", "=", "np", ".", "argmax", "(", "success_max", ",", "axis", "=", "0", ")", "\n", "\n", "n_goal", "=", "len", "(", "best_proof_indices", ")", "\n", "\n", "unifications", "=", "[", "proof", "[", "'UNIFICATIONS'", "]", "for", "proof", "in", "proofs", "]", "\n", "\n", "indices_a", "=", "[", "]", "\n", "indices_b", "=", "[", "]", "\n", "\n", "goal_shapes", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "n_goal", ")", ":", "\n", "\n", "        ", "best_proof_index", "=", "best_proof_indices", "[", "i", "]", "\n", "best_indices_reshaped", "=", "np", ".", "argmax", "(", "success_reshaped", "[", "best_proof_index", "]", "[", "i", "]", ")", "\n", "best_indices", "=", "np", ".", "unravel_index", "(", "best_indices_reshaped", ",", "proof_successes", "[", "best_proof_index", "]", ".", "shape", "[", "1", ":", "]", ")", "\n", "\n", "best_indices", "=", "[", "i", "]", "+", "[", "value", "for", "value", "in", "best_indices", "]", "\n", "\n", "goal_shapes", ".", "append", "(", "len", "(", "unifications", "[", "best_proof_indices", "[", "i", "]", "]", ")", ")", "\n", "\n", "goal_unifications", "=", "unifications", "[", "best_proof_indices", "[", "i", "]", "]", "\n", "\n", "for", "unification", "in", "goal_unifications", ":", "\n", "\n", "            ", "position_a", "=", "unification", "[", "2", "]", "[", "0", "]", "\n", "position_b", "=", "unification", "[", "2", "]", "[", "1", "]", "\n", "\n", "index_a", "=", "best_indices", "[", "position_a", "]", "\n", "index_b", "=", "best_indices", "[", "position_b", "]", "\n", "\n", "indices_a", ".", "append", "(", "kb_form", "(", "unification", "[", "0", "]", ",", "kb_ids", ")", "[", "index_a", "]", ")", "\n", "indices_b", ".", "append", "(", "kb_form", "(", "unification", "[", "1", "]", ",", "kb_ids", ")", "[", "index_b", "]", ")", "\n", "\n", "\n", "", "", "indices_a", "=", "tf", ".", "constant", "(", "indices_a", ")", "\n", "indices_b", "=", "tf", ".", "constant", "(", "indices_b", ")", "\n", "\n", "tensor_a", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "emb", ",", "indices_a", ")", "\n", "tensor_b", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "emb", ",", "indices_b", ")", "\n", "\n", "tensor_dif", "=", "tensor_b", "-", "tensor_a", "\n", "scores", "=", "tf", ".", "exp", "(", "-", "tf", ".", "norm", "(", "tensor_dif", ",", "axis", "=", "1", ")", ")", "\n", "\n", "reshaped_scores", "=", "tf", ".", "split", "(", "scores", ",", "goal_shapes", ",", "axis", "=", "0", ")", "\n", "\n", "cumulative_shape", "=", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "goal_shapes", ")", "-", "1", ")", ":", "\n", "        ", "cumulative_shape", ".", "append", "(", "cumulative_shape", "[", "-", "1", "]", "+", "goal_shapes", "[", "i", "]", ")", "\n", "\n", "", "argmin_scores", "=", "[", "np", ".", "argmin", "(", "scores", ")", "for", "scores", "in", "reshaped_scores", "]", "\n", "\n", "\n", "dif_indices", "=", "[", "cumulative_shape", "[", "i", "]", "+", "argmin_scores", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "goal_shapes", ")", ")", "]", "\n", "\n", "tensor_dif", "=", "tf", ".", "gather", "(", "tensor_dif", ",", "dif_indices", ")", "\n", "\n", "reshaped_indices", "=", "tf", ".", "stack", "(", "(", "indices_a", ",", "indices_b", ")", ",", "axis", "=", "1", ")", "\n", "reshaped_indices", "=", "tf", ".", "split", "(", "reshaped_indices", ",", "goal_shapes", ",", "axis", "=", "0", ")", "\n", "reshaped_indices", "=", "[", "value", ".", "numpy", "(", ")", "for", "value", "in", "reshaped_indices", "]", "\n", "\n", "active_indices", "=", "[", "reshaped_indices", "[", "i", "]", "[", "argmin_scores", "[", "i", "]", "]", "for", "i", "in", "range", "(", "len", "(", "argmin_scores", ")", ")", "]", "\n", "active_scores", "=", "[", "tf", ".", "reduce_min", "(", "scores", ")", "for", "scores", "in", "reshaped_scores", "]", "\n", "\n", "active_scores", "=", "tf", ".", "expand_dims", "(", "active_scores", ",", "axis", "=", "1", ")", "\n", "targets", "=", "tf", ".", "expand_dims", "(", "targets", ",", "axis", "=", "1", ")", "\n", "\n", "gradient_values", "=", "targets", "*", "tensor_dif", "/", "tf", ".", "log", "(", "active_scores", ")", "+", "(", "1", "-", "targets", ")", "*", "active_scores", "/", "(", "1", "-", "active_scores", ")", "*", "-", "tensor_dif", "/", "tf", ".", "log", "(", "active_scores", ")", "\n", "\n", "gradient_values", "=", "gradient_values", ".", "numpy", "(", ")", "\n", "\n", "gradient", "=", "np", ".", "zeros", "(", "shape", ")", "\n", "\n", "\n", "for", "i", "in", "range", "(", "n_goal", ")", ":", "\n", "        ", "gradient", "[", "active_indices", "[", "i", "]", "[", "0", "]", "]", "+=", "gradient_values", "[", "i", "]", "\n", "gradient", "[", "active_indices", "[", "i", "]", "[", "1", "]", "]", "-=", "gradient_values", "[", "i", "]", "\n", "\n", "", "return", "gradient", "\n", "", ""]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.scripts.experiment.run_experiment": [[13, 116], ["range", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.std", "numpy.sqrt", "collections.defaultdict", "print", "print", "print", "print", "print", "print", "ntp.modules.generate.gen_unary_relationships", "ntp.modules.generate.gen_unary", "ntp.modules.generate.gen_unary", "ntp.modules.generate.write_data", "ntp.modules.generate.write_data", "ntp.modules.generate.write_relationships", "ntp.modules.generate.write_unary_templates", "range", "prop_rules_list.append", "weighted_prop_list.append", "weighted_precision_list.append", "print", "print", "print", "print", "numpy.mean", "open", "csv.writer", "csv.writer.writerow", "print", "print", "ntp.scripts.learn.train_model", "draw_prop_rules.append", "draw_weighted_prop.append", "draw_weighted_precision.append", "csv.writer.writerow", "ntp.modules.eval_functions.prop_rules", "ntp.modules.eval_functions.weighted_prop_rules", "ntp.modules.eval_functions.weighted_precision", "numpy.var", "os.stat", "range", "len"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.write_data", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.write_data", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.generate.write_relationships", "home.repos.pwc.inspect_result.Michiel29_ntp-release.init_experiments.rule_unification_correlation.train_model", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.prop_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_prop_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_precision"], ["def", "run_experiment", "(", "conf", ")", ":", "\n", "\n", "    ", "n_draws", "=", "conf", "[", "\"experiment\"", "]", "[", "\"n_draws\"", "]", "\n", "runs_per_draw", "=", "conf", "[", "\"experiment\"", "]", "[", "\"runs_per_draw\"", "]", "\n", "n_pred", "=", "conf", "[", "\"experiment\"", "]", "[", "\"n_pred\"", "]", "\n", "n_constants", "=", "conf", "[", "\"experiment\"", "]", "[", "\"n_constants\"", "]", "\n", "test_constants", "=", "conf", "[", "\"experiment\"", "]", "[", "\"test_constants\"", "]", "\n", "n_rel", "=", "conf", "[", "\"experiment\"", "]", "[", "\"n_rel\"", "]", "\n", "n_rules", "=", "conf", "[", "\"experiment\"", "]", "[", "\"n_rules\"", "]", "\n", "p_normal", "=", "conf", "[", "\"experiment\"", "]", "[", "\"p_normal\"", "]", "\n", "p_relationship", "=", "conf", "[", "\"experiment\"", "]", "[", "\"p_relationship\"", "]", "\n", "allow_reverse", "=", "conf", "[", "\"experiment\"", "]", "[", "\"allow_reverse\"", "]", "\n", "\n", "prop_rules_list", "=", "[", "]", "\n", "weighted_prop_list", "=", "[", "]", "\n", "weighted_precision_list", "=", "[", "]", "\n", "\n", "for", "draw", "in", "range", "(", "n_draws", ")", ":", "\n", "\n", "        ", "draw_prop_rules", "=", "[", "]", "\n", "draw_weighted_prop", "=", "[", "]", "\n", "draw_weighted_precision", "=", "[", "]", "\n", "\n", "relationships", "=", "gen_unary_relationships", "(", "n_pred", ",", "n_rel", ")", "\n", "train_data", "=", "gen_unary", "(", "n_pred", ",", "relationships", ",", "p_normal", ",", "p_relationship", ",", "n_constants", ")", "\n", "test_data", "=", "gen_unary", "(", "n_pred", ",", "relationships", ",", "p_normal", ",", "p_relationship", ",", "test_constants", ")", "\n", "\n", "write_data", "(", "train_data", ",", "base_data_path", "+", "\"_train.nl\"", ")", "\n", "write_data", "(", "test_data", ",", "base_data_path", "+", "\"_test.nl\"", ")", "\n", "write_relationships", "(", "relationships", ",", "base_data_path", "+", "\"_relationships.json\"", ")", "\n", "write_unary_templates", "(", "n_rules", ",", "base_data_path", "+", "\"_templates.nlt\"", ")", "\n", "\n", "\n", "for", "run", "in", "range", "(", "runs_per_draw", ")", ":", "\n", "            ", "print", "(", "\"Starting run {0} in draw {1}\"", ".", "format", "(", "run", "+", "1", ",", "draw", "+", "1", ")", ")", "\n", "print", "(", "\"\\n\"", ")", "\n", "rules", ",", "confidences", "=", "train_model", "(", "conf", ",", "rules_experiment", "=", "True", ")", "\n", "\n", "draw_prop_rules", ".", "append", "(", "prop_rules", "(", "relationships", ",", "rules", ",", "allow_reverse", "=", "allow_reverse", ")", ")", "\n", "draw_weighted_prop", ".", "append", "(", "weighted_prop_rules", "(", "relationships", ",", "rules", ",", "confidences", ",", "allow_reverse", "=", "allow_reverse", ")", ")", "\n", "draw_weighted_precision", ".", "append", "(", "weighted_precision", "(", "relationships", ",", "rules", ",", "confidences", ",", "allow_reverse", "=", "allow_reverse", ")", ")", "\n", "\n", "", "prop_rules_list", ".", "append", "(", "draw_prop_rules", ")", "\n", "weighted_prop_list", ".", "append", "(", "draw_weighted_prop", ")", "\n", "weighted_precision_list", ".", "append", "(", "draw_weighted_precision", ")", "\n", "\n", "print", "(", "\"\\n\"", ")", "\n", "print", "(", "\"Proportion rules learned: {}\"", ".", "format", "(", "draw_prop_rules", ")", ")", "\n", "print", "(", "\"Weighted by confidence proportion rules learned: {}\"", ".", "format", "(", "draw_weighted_prop", ")", ")", "\n", "print", "(", "\"Weighted precision: {}\"", ".", "format", "(", "draw_weighted_precision", ")", ")", "\n", "\n", "\n", "", "avg_prop_rules", "=", "np", ".", "mean", "(", "prop_rules_list", ")", "\n", "avg_weighted_prop", "=", "np", ".", "mean", "(", "weighted_prop_list", ")", "\n", "avg_weighted_precision", "=", "np", ".", "mean", "(", "weighted_precision_list", ")", "\n", "\n", "weighted_prop_std", "=", "np", ".", "std", "(", "weighted_prop_list", ")", "\n", "weighted_prop_std_within", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "[", "np", ".", "var", "(", "weighted_prop_list", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "weighted_prop_list", ")", ")", "]", ")", ")", "\n", "\n", "columns", "=", "[", "\"experiment_category\"", ",", "\"ruleprop\"", ",", "\"wruleprop\"", ",", "\"wprecision\"", ",", "\"wruleprop_std\"", ",", "\"wruleprop_std_within\"", ",", "\n", "\"predicates\"", ",", "\"constants\"", ",", "\"relationships\"", ",", "\"p_default\"", ",", "\"p_rel\"", ",", "\n", "\"rules\"", ",", "\"epochs\"", ",", "\"units\"", ",", "\"batch_size\"", ",", "\"corruption_ratio\"", ",", "\"lr\"", ",", "\"draws\"", ",", "\"runs\"", ",", "\"allow_reverse\"", ",", "\"custom1\"", ",", "\"custom2\"", ",", "\"custom3\"", "]", "\n", "\n", "\n", "value_dict", "=", "defaultdict", "(", "str", ",", "{", "\"experiment_category\"", ":", "experiment_category", ",", "\n", "\"ruleprop\"", ":", "avg_prop_rules", ",", "\n", "\"wruleprop\"", ":", "avg_weighted_prop", ",", "\n", "\"wprecision\"", ":", "avg_weighted_precision", ",", "\n", "\"wruleprop_std\"", ":", "weighted_prop_std", ",", "\n", "\"wruleprop_std_within\"", ":", "weighted_prop_std_within", ",", "\n", "\"predicates\"", ":", "n_pred", ",", "\n", "\"constants\"", ":", "n_constants", ",", "\n", "\"relationships\"", ":", "n_rel", ",", "\n", "\"p_default\"", ":", "p_normal", ",", "\n", "\"p_rel\"", ":", "p_relationship", ",", "\n", "\"rules\"", ":", "n_rules", ",", "\n", "\"epochs\"", ":", "conf", "[", "\"training\"", "]", "[", "\"num_epochs\"", "]", ",", "\n", "\"units\"", ":", "conf", "[", "\"model\"", "]", "[", "\"input_size\"", "]", ",", "\n", "\"batch_size\"", ":", "conf", "[", "\"training\"", "]", "[", "\"pos_per_batch\"", "]", "*", "conf", "[", "\"training\"", "]", "[", "\"num_corruptions\"", "]", ",", "\n", "\"corruption_ratio\"", ":", "conf", "[", "\"training\"", "]", "[", "\"num_corruptions\"", "]", ",", "\n", "\"lr\"", ":", "conf", "[", "\"training\"", "]", "[", "\"learning_rate\"", "]", ",", "\n", "\"draws\"", ":", "n_draws", ",", "\n", "\"runs\"", ":", "runs_per_draw", ",", "\n", "\"allow_reverse\"", ":", "allow_reverse", "\n", "}", "\n", ")", "\n", "\n", "with", "open", "(", "output_path", ",", "\"a+\"", ")", "as", "output_file", ":", "\n", "\n", "        ", "result_writer", "=", "csv", ".", "writer", "(", "output_file", ",", "delimiter", "=", "','", ")", "\n", "\n", "if", "os", ".", "stat", "(", "output_path", ")", ".", "st_size", "==", "0", ":", "\n", "            ", "result_writer", ".", "writerow", "(", "columns", ")", "\n", "\n", "", "result_writer", ".", "writerow", "(", "[", "value_dict", "[", "column", "]", "for", "column", "in", "columns", "]", ")", "\n", "\n", "\n", "", "print", "(", "\"\\n\"", ")", "\n", "print", "(", "\"Final proportion rules learned: {}\"", ".", "format", "(", "avg_prop_rules", ")", ")", "\n", "print", "(", "\"Final weighted by confidence proportion rules learned: {}\"", ".", "format", "(", "avg_weighted_prop", ")", ")", "\n", "print", "(", "\"Final weighted precision: {}\"", ".", "format", "(", "avg_weighted_precision", ")", ")", "\n", "print", "(", "\"Std weighted proportion rules learned: {}\"", ".", "format", "(", "weighted_prop_std", ")", ")", "\n", "print", "(", "\"Std within data draw weighted proportion rules learned: {}\"", ".", "format", "(", "weighted_prop_std_within", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.init_experiments.r_experiment.train_model": [[34, 190], ["ntp.modules.kb.augment_with_templates", "ntp.modules.kb.initialize_nkb", "ntp.modules.kb.kb_ids2known_facts", "emb.numpy", "len", "len", "range", "range", "emb.assign", "ntp.util.util_training.TrainingState", "tensorflow.train.AdamOptimizer", "tensorflow.contrib.summary.create_file_writer", "timeit.default_timer", "range", "collections.OrderedDict", "ntp.util.util_eval.decode_rules", "tensorflow.reset_default_graph", "tensorflow.set_random_seed", "numpy.expand_dims", "numpy.min", "ntp.modules.train.gen_train_batches", "enumerate", "print", "print", "ntp.modules.eval.prop_rules", "ntp.modules.eval.weighted_prop_rules", "ntp.modules.eval.weighted_precision", "ntp.modules.eval.auc_helper", "ntp.modules.eval.eval_rank", "predicate_ids.items", "range", "numpy.expand_dims", "tensorflow.squeeze", "print", "collections.OrderedDict", "ntp.modules.eval.eval_fact_accuracy", "tensorflow.constant", "tensorflow.constant", "tf.train.AdamOptimizer.apply_gradients", "ntp.util.util_training.TrainingState.update_iteration", "len", "relationships.items", "range", "ntp.modules.nunify.l2_sim_np", "ntp.modules.eval.eval_rule_accuracy", "ntp.modules.eval.closest_rule_score", "ntp.util.util_diag.closest_unification_score", "tf.contrib.summary.create_file_writer.as_default", "tensorflow.contrib.summary.always_record_summaries", "timeit.default_timer", "print", "timeit.default_timer", "tensorflow.device", "tensorflow.constant", "tensorflow.ones", "tensorflow.transpose", "ntp.modules.gradient.auto_gradient", "tensorflow.clip_by_value", "str", "str", "ntp.util.util_kb.is_parameter", "len", "range", "str", "tensorflow.contrib.summary.scalar", "print", "tensorflow.ones", "tensorflow.constant", "ntp.modules.eval.closest_rule_score", "ntp.util.util_diag.closest_unification_score", "str", "len", "str", "tensorflow.scatter_nd"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.augment_with_templates", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.initialize_nkb", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb_ids2known_facts", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.decode_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.train.gen_train_batches", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.prop_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_prop_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.weighted_precision", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.auc_helper", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_rank", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_fact_accuracy", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_training.TrainingState.update_iteration", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.nunify.l2_sim_np", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_rule_accuracy", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.auto_gradient", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_parameter", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score"], ["def", "train_model", "(", "kb", ",", "rule_templates", ",", "conf", ",", "relationships", "=", "None", ",", "test_kb", "=", "None", ",", "r", "=", "1.0", ")", ":", "\n", "\n", "    ", "if", "\"seed\"", "in", "conf", "[", "\"training\"", "]", ":", "\n", "        ", "tf", ".", "set_random_seed", "(", "conf", "[", "\"training\"", "]", "[", "\"seed\"", "]", ")", "\n", "\n", "", "input_size", "=", "conf", "[", "\"model\"", "]", "[", "\"input_size\"", "]", "\n", "l2", "=", "conf", "[", "\"model\"", "]", "[", "\"l2\"", "]", "\n", "k_max", "=", "conf", "[", "\"model\"", "]", "[", "\"k_max\"", "]", "\n", "max_depth", "=", "conf", "[", "\"model\"", "]", "[", "\"max_depth\"", "]", "\n", "loss_type", "=", "conf", "[", "\"model\"", "]", "[", "\"loss_type\"", "]", "\n", "loss_parameters", "=", "conf", "[", "\"model\"", "]", "[", "\"loss_parameters\"", "]", "\n", "\n", "\n", "num_epochs", "=", "conf", "[", "\"training\"", "]", "[", "\"num_epochs\"", "]", "\n", "clip", "=", "conf", "[", "\"training\"", "]", "[", "\"clip\"", "]", "\n", "learning_rate", "=", "conf", "[", "\"training\"", "]", "[", "\"learning_rate\"", "]", "\n", "lr_decay_type", "=", "conf", "[", "\"training\"", "]", "[", "\"lr_decay_type\"", "]", "\n", "lr_decay_rate", "=", "conf", "[", "\"training\"", "]", "[", "\"lr_decay_rate\"", "]", "\n", "epsilon", "=", "conf", "[", "\"training\"", "]", "[", "\"epsilon\"", "]", "\n", "\n", "report_interval", "=", "conf", "[", "\"logging\"", "]", "[", "\"report_interval\"", "]", "\n", "log_dir", "=", "conf", "[", "\"logging\"", "]", "[", "\"log_dir\"", "]", "\n", "verbose", "=", "conf", "[", "\"logging\"", "]", "[", "\"verbose\"", "]", "\n", "\n", "num_corruptions", "=", "conf", "[", "\"training\"", "]", "[", "\"num_corruptions\"", "]", "\n", "batch_size", "=", "conf", "[", "\"training\"", "]", "[", "\"batch_size\"", "]", "\n", "\n", "kb", "=", "augment_with_templates", "(", "kb", ",", "rule_templates", ")", "\n", "nkb", ",", "kb_ids", ",", "vocab", ",", "emb", ",", "predicate_ids", ",", "constant_ids", "=", "initialize_nkb", "(", "kb", ",", "input_size", ")", "\n", "true_predicate_ids", "=", "{", "order", ":", "[", "pred", "for", "pred", "in", "pred_order_ids", "if", "not", "is_parameter", "(", "vocab", ".", "id2sym", "[", "pred", "]", ")", "]", "for", "(", "order", ",", "pred_order_ids", ")", "in", "predicate_ids", ".", "items", "(", ")", "}", "\n", "\n", "known_facts", "=", "kb_ids2known_facts", "(", "kb_ids", ")", "\n", "\n", "fact_structs", "=", "[", "rule", "for", "rule", "in", "kb_ids", "if", "len", "(", "rule", ")", "==", "1", "]", "\n", "\n", "emb_np", "=", "emb", ".", "numpy", "(", ")", "\n", "\n", "# We're only doing this experiment with one rule template and relationship", "\n", "rule_struct", "=", "[", "rule", "for", "rule", "in", "kb_ids", "if", "len", "(", "rule", ")", ">", "1", "]", "[", "0", "]", "\n", "relationship", "=", "[", "(", "head", ",", "body", ")", "for", "head", ",", "body", "in", "relationships", ".", "items", "(", ")", "]", "[", "0", "]", "\n", "head_id", "=", "[", "vocab", ".", "sym2id", "[", "relationship", "[", "0", "]", "]", "]", "\n", "body_ids", "=", "[", "vocab", ".", "sym2id", "[", "body_pred", "]", "for", "body_pred", "in", "relationship", "[", "1", "]", "]", "\n", "\n", "relationship_ids", "=", "head_id", "+", "body_ids", "\n", "rule_ids", "=", "kb_ids", "[", "rule_struct", "]", "\n", "rule_size", "=", "len", "(", "relationship_ids", ")", "\n", "n_rules", "=", "len", "(", "rule_ids", "[", "0", "]", "[", "0", "]", ")", "\n", "\n", "rule_pred_ids", "=", "[", "[", "rule_ids", "[", "atom", "]", "[", "0", "]", "[", "rule_nr", "]", "for", "atom", "in", "range", "(", "rule_size", ")", "]", "for", "rule_nr", "in", "range", "(", "n_rules", ")", "]", "\n", "\n", "relationship_embs", "=", "[", "np", ".", "expand_dims", "(", "emb_np", "[", "relationship_id", "]", ",", "axis", "=", "0", ")", "for", "relationship_id", "in", "relationship_ids", "]", "\n", "rule_embs", "=", "[", "[", "np", ".", "expand_dims", "(", "emb_np", "[", "pred_id", "]", ",", "axis", "=", "0", ")", "for", "pred_id", "in", "rule", "]", "for", "rule", "in", "rule_pred_ids", "]", "\n", "\n", "best_rule", "=", "-", "1", "\n", "max_rule_score", "=", "0", "\n", "\n", "for", "rule_nr", "in", "range", "(", "n_rules", ")", ":", "\n", "        ", "rule_score", "=", "np", ".", "min", "(", "[", "l2_sim_np", "(", "relationship_embs", "[", "i", "]", ",", "rule_embs", "[", "rule_nr", "]", "[", "i", "]", ")", "for", "i", "in", "range", "(", "rule_size", ")", "]", ")", "\n", "if", "rule_score", ">", "max_rule_score", ":", "\n", "            ", "best_rule", "=", "rule_nr", "\n", "max_rule_score", "=", "rule_score", "\n", "\n", "", "", "for", "atom", "in", "range", "(", "rule_size", ")", ":", "\n", "        ", "emb_dif", "=", "rule_embs", "[", "best_rule", "]", "[", "atom", "]", "-", "relationship_embs", "[", "atom", "]", "\n", "emb_np", "[", "rule_pred_ids", "[", "best_rule", "]", "[", "atom", "]", "]", "+=", "(", "r", "-", "1.0", ")", "*", "tf", ".", "squeeze", "(", "emb_dif", ")", "\n", "\n", "", "emb", ".", "assign", "(", "emb_np", ")", "\n", "\n", "training_state", "=", "TrainingState", "(", "learning_rate", ",", "lr_decay_type", ",", "lr_decay_rate", ")", "\n", "\n", "optim", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "training_state", ".", "lr_variable", ",", "\n", "epsilon", "=", "epsilon", ")", "\n", "\n", "loss_function", "=", "loss_dict", "[", "loss_type", "]", "\n", "\n", "summary_writer", "=", "tf", ".", "contrib", ".", "summary", ".", "create_file_writer", "(", "log_dir", ")", "\n", "\n", "start_time", "=", "timer", "(", ")", "\n", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "        ", "train_batches", "=", "gen_train_batches", "(", "fact_structs", ",", "kb_ids", ",", "batch_size", ",", "num_corruptions", ",", "constant_ids", ",", "known_facts", ")", "\n", "\n", "if", "epoch", "%", "report_interval", "==", "0", "or", "epoch", "==", "num_epochs", "-", "1", ":", "\n", "            ", "print", "(", "\"epoch\"", "+", "str", "(", "epoch", ")", ")", "\n", "\n", "log_dict", "=", "OrderedDict", "(", ")", "\n", "log_dict", "[", "\"fact_accuracy\"", "]", "=", "eval_fact_accuracy", "(", "train_batches", ",", "emb", ",", "kb_ids", ",", "\n", "vocab", ",", "k_max", ",", "max_depth", ")", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "                ", "log_dict", "[", "\"rule_recall\"", "]", "=", "eval_rule_accuracy", "(", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "relationships", ")", "\n", "log_dict", "[", "\"closest_rule_score\"", "]", "=", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", "\n", "log_dict", "[", "\"closest_unification_score\"", "]", "=", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", "\n", "\n", "", "with", "summary_writer", ".", "as_default", "(", ")", ",", "tf", ".", "contrib", ".", "summary", ".", "always_record_summaries", "(", ")", ":", "\n", "                ", "for", "key", "in", "log_dict", ":", "\n", "                    ", "tf", ".", "contrib", ".", "summary", ".", "scalar", "(", "key", ",", "log_dict", "[", "key", "]", ",", "step", "=", "epoch", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "                ", "end_time", "=", "timer", "(", ")", "\n", "\n", "for", "key", "in", "log_dict", ":", "\n", "                    ", "print", "(", "key", "+", "\": \"", "+", "str", "(", "log_dict", "[", "key", "]", ")", ")", "\n", "", "print", "(", "\"time per epoch: \"", "+", "str", "(", "(", "end_time", "-", "start_time", ")", "/", "report_interval", ")", ")", "\n", "start_time", "=", "timer", "(", ")", "\n", "\n", "", "", "for", "j", ",", "batch", "in", "enumerate", "(", "train_batches", ")", ":", "\n", "\n", "            ", "goal", "=", "tf", ".", "constant", "(", "batch", "[", "\"goal\"", "]", ")", "\n", "\n", "mask_indices", "=", "tf", ".", "constant", "(", "batch", "[", "\"mask_indices\"", "]", ")", "\n", "loss_parameters", "[", "\"epoch\"", "]", "=", "i", "\n", "\n", "with", "tf", ".", "device", "(", "\"/device:GPU:0\"", ")", ":", "\n", "                ", "target", "=", "tf", ".", "constant", "(", "batch", "[", "\"target\"", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "base_mask", "=", "tf", ".", "ones", "(", "[", "batch", "[", "\"n_facts_struct\"", "]", ",", "batch", "[", "\"batch_size\"", "]", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "updates", "=", "-", "1.0", "*", "tf", ".", "ones", "(", "len", "(", "batch", "[", "\"mask_indices\"", "]", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "batch_mask", "=", "tf", ".", "transpose", "(", "tf", ".", "constant", "(", "\n", "base_mask", "+", "tf", ".", "scatter_nd", "(", "mask_indices", ",", "updates", ",", "base_mask", ".", "shape", ")", ")", ")", "\n", "\n", "grad", "=", "auto_gradient", "(", "loss_function", ",", "goal", ",", "target", ",", "emb", ",", "kb_ids", ",", "\n", "vocab", ",", "batch", "[", "\"struct\"", "]", ",", "batch_mask", ",", "l2", ",", "k_max", ",", "max_depth", ",", "epsilon", ",", "loss_parameters", ")", "\n", "\n", "", "if", "clip", "is", "not", "None", ":", "\n", "                ", "capped_gradients", "=", "tf", ".", "clip_by_value", "(", "grad", ",", "clip", "[", "0", "]", ",", "clip", "[", "1", "]", ")", "\n", "\n", "", "grad_and_var", "=", "[", "(", "capped_gradients", ",", "emb", ")", "]", "\n", "\n", "optim", ".", "apply_gradients", "(", "grad_and_var", ")", "\n", "\n", "training_state", ".", "update_iteration", "(", ")", "\n", "\n", "", "", "eval_dict", "=", "OrderedDict", "(", ")", "\n", "\n", "rules", ",", "confidences", "=", "decode_rules", "(", "\n", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "verbose", "=", "True", ",", "print_k", "=", "20", ")", "\n", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "\n", "\n", "        ", "print", "(", "\"closest rule score: \"", "+", "str", "(", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", ")", ")", "\n", "print", "(", "\"closest unification score: \"", "+", "str", "(", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", ")", ")", "\n", "\n", "eval_dict", "[", "\"prop_rules\"", "]", "=", "prop_rules", "(", "relationships", ",", "rules", ",", "confidences", ")", "\n", "eval_dict", "[", "\"weighted_prop_rules\"", "]", "=", "weighted_prop_rules", "(", "\n", "relationships", ",", "rules", ",", "confidences", ")", "\n", "eval_dict", "[", "\"weighted_precision\"", "]", "=", "weighted_precision", "(", "\n", "relationships", ",", "rules", ",", "confidences", ")", "\n", "eval_dict", "[", "\"auc_helper\"", "]", "=", "auc_helper", "(", "relationships", ",", "rules", ",", "confidences", ")", "\n", "\n", "", "if", "test_kb", "is", "not", "None", ":", "\n", "\n", "        ", "eval_dict", "[", "\"MRR\"", "]", ",", "eval_dict", "[", "\"randomMRR\"", "]", ",", "eval_dict", "[", "\"fact-roc-auc\"", "]", "=", "eval_rank", "(", "emb", ",", "kb_ids", ",", "test_kb", ",", "known_facts", ",", "vocab", ",", "constant_ids", ",", "batch_size", ",", "k_max", ",", "max_depth", ",", "eval_dict", ")", "\n", "\n", "", "tf", ".", "reset_default_graph", "(", ")", "\n", "return", "rules", ",", "confidences", ",", "eval_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.init_experiments.rule_unification_graph.train_model": [[34, 142], ["ntp.modules.kb.augment_with_templates", "ntp.modules.kb.initialize_nkb", "ntp.modules.kb.kb_ids2known_facts", "ntp.util.util_training.TrainingState", "tensorflow.train.AdamOptimizer", "tensorflow.contrib.summary.create_file_writer", "range", "ntp.util.util_eval.decode_rules", "tensorflow.reset_default_graph", "tensorflow.set_random_seed", "ntp.modules.train.gen_train_batches", "closest_rule_scores.append", "closest_unification_scores.append", "enumerate", "ntp.modules.eval.prop_rules", "print", "predicate_ids.items", "ntp.modules.eval.closest_rule_score", "ntp.util.util_diag.closest_unification_score", "print", "tensorflow.constant", "tensorflow.constant", "tf.train.AdamOptimizer.apply_gradients", "ntp.util.util_training.TrainingState.update_iteration", "len", "collections.OrderedDict", "ntp.modules.eval.eval_fact_accuracy", "tensorflow.device", "tensorflow.constant", "tensorflow.ones", "tensorflow.transpose", "ntp.modules.gradient.auto_gradient", "tensorflow.clip_by_value", "str", "ntp.util.util_kb.is_parameter", "str", "ntp.modules.eval.eval_rule_accuracy", "ntp.modules.eval.closest_rule_score", "ntp.util.util_diag.closest_unification_score", "tf.contrib.summary.create_file_writer.as_default", "tensorflow.contrib.summary.always_record_summaries", "tensorflow.ones", "tensorflow.constant", "tensorflow.contrib.summary.scalar", "len", "tensorflow.scatter_nd"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.augment_with_templates", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.initialize_nkb", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb_ids2known_facts", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.decode_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.train.gen_train_batches", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.prop_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_training.TrainingState.update_iteration", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_fact_accuracy", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.auto_gradient", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_parameter", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_rule_accuracy", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score"], ["def", "train_model", "(", "kb", ",", "rule_templates", ",", "conf", ",", "diagnostic", "=", "False", ",", "relationships", "=", "None", ",", "test_kb", "=", "None", ")", ":", "\n", "\n", "    ", "if", "\"seed\"", "in", "conf", "[", "\"training\"", "]", ":", "\n", "        ", "tf", ".", "set_random_seed", "(", "conf", "[", "\"training\"", "]", "[", "\"seed\"", "]", ")", "\n", "\n", "", "input_size", "=", "conf", "[", "\"model\"", "]", "[", "\"input_size\"", "]", "\n", "l2", "=", "conf", "[", "\"model\"", "]", "[", "\"l2\"", "]", "\n", "k_max", "=", "conf", "[", "\"model\"", "]", "[", "\"k_max\"", "]", "\n", "max_depth", "=", "conf", "[", "\"model\"", "]", "[", "\"max_depth\"", "]", "\n", "loss_type", "=", "conf", "[", "\"model\"", "]", "[", "\"loss_type\"", "]", "\n", "loss_parameters", "=", "conf", "[", "\"model\"", "]", "[", "\"loss_parameters\"", "]", "\n", "\n", "num_epochs", "=", "conf", "[", "\"training\"", "]", "[", "\"num_epochs\"", "]", "\n", "clip", "=", "conf", "[", "\"training\"", "]", "[", "\"clip\"", "]", "\n", "learning_rate", "=", "conf", "[", "\"training\"", "]", "[", "\"learning_rate\"", "]", "\n", "lr_decay_type", "=", "conf", "[", "\"training\"", "]", "[", "\"lr_decay_type\"", "]", "\n", "lr_decay_rate", "=", "conf", "[", "\"training\"", "]", "[", "\"lr_decay_rate\"", "]", "\n", "epsilon", "=", "conf", "[", "\"training\"", "]", "[", "\"epsilon\"", "]", "\n", "\n", "num_corruptions", "=", "conf", "[", "\"training\"", "]", "[", "\"num_corruptions\"", "]", "\n", "batch_size", "=", "conf", "[", "\"training\"", "]", "[", "\"batch_size\"", "]", "\n", "\n", "report_interval", "=", "conf", "[", "\"logging\"", "]", "[", "\"report_interval\"", "]", "\n", "log_dir", "=", "conf", "[", "\"logging\"", "]", "[", "\"log_dir\"", "]", "\n", "verbose", "=", "conf", "[", "\"logging\"", "]", "[", "\"verbose\"", "]", "\n", "\n", "kb", "=", "augment_with_templates", "(", "kb", ",", "rule_templates", ")", "\n", "nkb", ",", "kb_ids", ",", "vocab", ",", "emb", ",", "predicate_ids", ",", "constant_ids", "=", "initialize_nkb", "(", "kb", ",", "input_size", ")", "\n", "\n", "true_predicate_ids", "=", "{", "order", ":", "[", "pred", "for", "pred", "in", "pred_order_ids", "if", "not", "is_parameter", "(", "vocab", ".", "id2sym", "[", "pred", "]", ")", "]", "for", "(", "order", ",", "pred_order_ids", ")", "in", "predicate_ids", ".", "items", "(", ")", "}", "\n", "\n", "known_facts", "=", "kb_ids2known_facts", "(", "kb_ids", ")", "\n", "\n", "fact_structs", "=", "[", "rule", "for", "rule", "in", "kb_ids", "if", "len", "(", "rule", ")", "==", "1", "]", "\n", "\n", "training_state", "=", "TrainingState", "(", "learning_rate", ",", "lr_decay_type", ",", "lr_decay_rate", ")", "\n", "\n", "optim", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "training_state", ".", "lr_variable", ",", "\n", "epsilon", "=", "epsilon", ")", "\n", "\n", "\n", "summary_writer", "=", "tf", ".", "contrib", ".", "summary", ".", "create_file_writer", "(", "log_dir", ")", "\n", "\n", "loss_function", "=", "loss_dict", "[", "loss_type", "]", "\n", "\n", "closest_rule_scores", "=", "[", "]", "\n", "closest_unification_scores", "=", "[", "]", "\n", "\n", "for", "epoch", "in", "range", "(", "1", ",", "num_epochs", "+", "1", ")", ":", "\n", "\n", "        ", "train_batches", "=", "gen_train_batches", "(", "fact_structs", ",", "kb_ids", ",", "batch_size", ",", "num_corruptions", ",", "constant_ids", ",", "known_facts", ")", "\n", "\n", "closest_rule_scores", ".", "append", "(", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", ")", "\n", "closest_unification_scores", ".", "append", "(", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", ")", "\n", "\n", "if", "epoch", "%", "report_interval", "==", "0", ":", "\n", "            ", "print", "(", "\"epoch\"", "+", "str", "(", "epoch", ")", ")", "\n", "if", "verbose", ":", "\n", "\n", "                ", "log_dict", "=", "OrderedDict", "(", ")", "\n", "log_dict", "[", "\"fact_accuracy\"", "]", "=", "eval_fact_accuracy", "(", "train_batches", ",", "emb", ",", "kb_ids", ",", "\n", "vocab", ",", "k_max", ",", "max_depth", ")", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "                    ", "log_dict", "[", "\"rule_recall\"", "]", "=", "eval_rule_accuracy", "(", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "relationships", ")", "\n", "log_dict", "[", "\"closest_rule_score\"", "]", "=", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", "\n", "log_dict", "[", "\"closest_unification_score\"", "]", "=", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", "\n", "\n", "", "with", "summary_writer", ".", "as_default", "(", ")", ",", "tf", ".", "contrib", ".", "summary", ".", "always_record_summaries", "(", ")", ":", "\n", "                    ", "for", "key", "in", "log_dict", ":", "\n", "                        ", "tf", ".", "contrib", ".", "summary", ".", "scalar", "(", "key", ",", "log_dict", "[", "key", "]", ",", "step", "=", "epoch", ")", "\n", "\n", "", "", "", "", "for", "j", ",", "batch", "in", "enumerate", "(", "train_batches", ")", ":", "\n", "\n", "            ", "goal", "=", "tf", ".", "constant", "(", "batch", "[", "\"goal\"", "]", ")", "\n", "\n", "mask_indices", "=", "tf", ".", "constant", "(", "batch", "[", "\"mask_indices\"", "]", ")", "\n", "loss_parameters", "[", "\"epoch\"", "]", "=", "epoch", "\n", "\n", "with", "tf", ".", "device", "(", "\"/device:GPU:0\"", ")", ":", "\n", "                ", "target", "=", "tf", ".", "constant", "(", "batch", "[", "\"target\"", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "base_mask", "=", "tf", ".", "ones", "(", "[", "batch", "[", "\"n_facts_struct\"", "]", ",", "batch", "[", "\"batch_size\"", "]", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "updates", "=", "-", "1.0", "*", "tf", ".", "ones", "(", "len", "(", "batch", "[", "\"mask_indices\"", "]", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "batch_mask", "=", "tf", ".", "transpose", "(", "tf", ".", "constant", "(", "\n", "base_mask", "+", "tf", ".", "scatter_nd", "(", "mask_indices", ",", "updates", ",", "base_mask", ".", "shape", ")", ")", ")", "\n", "\n", "grad", "=", "auto_gradient", "(", "loss_function", ",", "goal", ",", "target", ",", "emb", ",", "kb_ids", ",", "\n", "vocab", ",", "batch", "[", "\"struct\"", "]", ",", "batch_mask", ",", "l2", ",", "k_max", ",", "max_depth", ",", "epsilon", ",", "loss_parameters", ")", "\n", "\n", "", "if", "clip", "is", "not", "None", ":", "\n", "                ", "capped_gradients", "=", "tf", ".", "clip_by_value", "(", "grad", ",", "clip", "[", "0", "]", ",", "clip", "[", "1", "]", ")", "\n", "\n", "", "grad_and_var", "=", "[", "(", "capped_gradients", ",", "emb", ")", "]", "\n", "\n", "optim", ".", "apply_gradients", "(", "grad_and_var", ")", "\n", "\n", "training_state", ".", "update_iteration", "(", ")", "\n", "\n", "", "", "rules", ",", "confidences", "=", "decode_rules", "(", "\n", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "verbose", "=", "verbose", ",", "print_k", "=", "20", ")", "\n", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "\n", "        ", "recall", "=", "prop_rules", "(", "relationships", ",", "rules", ",", "confidences", ")", "\n", "print", "(", "\"recall: \"", "+", "str", "(", "recall", ")", ")", "\n", "\n", "", "tf", ".", "reset_default_graph", "(", ")", "\n", "return", "recall", ",", "closest_rule_scores", ",", "closest_unification_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.init_experiments.rule_unification_correlation.train_model": [[32, 137], ["ntp.modules.kb.augment_with_templates", "ntp.modules.kb.initialize_nkb", "ntp.modules.kb.kb_ids2known_facts", "ntp.util.util_training.TrainingState", "tensorflow.train.AdamOptimizer", "tensorflow.contrib.summary.create_file_writer", "range", "ntp.util.util_eval.decode_rules", "ntp.modules.eval.closest_rule_score", "ntp.util.util_diag.closest_unification_score", "tensorflow.reset_default_graph", "tensorflow.set_random_seed", "ntp.modules.train.gen_train_batches", "enumerate", "ntp.modules.eval.prop_rules", "print", "predicate_ids.items", "print", "tensorflow.constant", "tensorflow.constant", "tf.train.AdamOptimizer.apply_gradients", "ntp.util.util_training.TrainingState.update_iteration", "len", "collections.OrderedDict", "ntp.modules.eval.eval_fact_accuracy", "tensorflow.device", "tensorflow.constant", "tensorflow.ones", "tensorflow.transpose", "ntp.modules.gradient.auto_gradient", "tensorflow.clip_by_value", "str", "ntp.util.util_kb.is_parameter", "str", "ntp.modules.eval.eval_rule_accuracy", "ntp.modules.eval.closest_rule_score", "ntp.util.util_diag.closest_unification_score", "tf.contrib.summary.create_file_writer.as_default", "tensorflow.contrib.summary.always_record_summaries", "tensorflow.ones", "tensorflow.constant", "tensorflow.contrib.summary.scalar", "len", "tensorflow.scatter_nd"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.augment_with_templates", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.initialize_nkb", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.kb.kb_ids2known_facts", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.decode_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.train.gen_train_batches", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.prop_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_training.TrainingState.update_iteration", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_fact_accuracy", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.gradient.auto_gradient", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_parameter", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.eval_rule_accuracy", "home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.eval.closest_rule_score", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score"], ["def", "train_model", "(", "kb", ",", "rule_templates", ",", "conf", ",", "relationships", "=", "None", ",", "test_kb", "=", "None", ")", ":", "\n", "\n", "    ", "if", "\"seed\"", "in", "conf", "[", "\"training\"", "]", ":", "\n", "        ", "tf", ".", "set_random_seed", "(", "conf", "[", "\"training\"", "]", "[", "\"seed\"", "]", ")", "\n", "\n", "", "input_size", "=", "conf", "[", "\"model\"", "]", "[", "\"input_size\"", "]", "\n", "l2", "=", "conf", "[", "\"model\"", "]", "[", "\"l2\"", "]", "\n", "k_max", "=", "conf", "[", "\"model\"", "]", "[", "\"k_max\"", "]", "\n", "max_depth", "=", "conf", "[", "\"model\"", "]", "[", "\"max_depth\"", "]", "\n", "loss_type", "=", "conf", "[", "\"model\"", "]", "[", "\"loss_type\"", "]", "\n", "loss_parameters", "=", "conf", "[", "\"model\"", "]", "[", "\"loss_parameters\"", "]", "\n", "\n", "num_epochs", "=", "conf", "[", "\"training\"", "]", "[", "\"num_epochs\"", "]", "\n", "clip", "=", "conf", "[", "\"training\"", "]", "[", "\"clip\"", "]", "\n", "learning_rate", "=", "conf", "[", "\"training\"", "]", "[", "\"learning_rate\"", "]", "\n", "lr_decay_type", "=", "conf", "[", "\"training\"", "]", "[", "\"lr_decay_type\"", "]", "\n", "lr_decay_rate", "=", "conf", "[", "\"training\"", "]", "[", "\"lr_decay_rate\"", "]", "\n", "epsilon", "=", "conf", "[", "\"training\"", "]", "[", "\"epsilon\"", "]", "\n", "\n", "num_corruptions", "=", "conf", "[", "\"training\"", "]", "[", "\"num_corruptions\"", "]", "\n", "batch_size", "=", "conf", "[", "\"training\"", "]", "[", "\"batch_size\"", "]", "\n", "\n", "report_interval", "=", "conf", "[", "\"logging\"", "]", "[", "\"report_interval\"", "]", "\n", "log_dir", "=", "conf", "[", "\"logging\"", "]", "[", "\"log_dir\"", "]", "\n", "verbose", "=", "conf", "[", "\"logging\"", "]", "[", "\"verbose\"", "]", "\n", "\n", "kb", "=", "augment_with_templates", "(", "kb", ",", "rule_templates", ")", "\n", "nkb", ",", "kb_ids", ",", "vocab", ",", "emb", ",", "predicate_ids", ",", "constant_ids", "=", "initialize_nkb", "(", "kb", ",", "input_size", ")", "\n", "\n", "true_predicate_ids", "=", "{", "order", ":", "[", "pred", "for", "pred", "in", "pred_order_ids", "if", "not", "is_parameter", "(", "vocab", ".", "id2sym", "[", "pred", "]", ")", "]", "for", "(", "order", ",", "pred_order_ids", ")", "in", "predicate_ids", ".", "items", "(", ")", "}", "\n", "\n", "known_facts", "=", "kb_ids2known_facts", "(", "kb_ids", ")", "\n", "\n", "fact_structs", "=", "[", "rule", "for", "rule", "in", "kb_ids", "if", "len", "(", "rule", ")", "==", "1", "]", "\n", "\n", "training_state", "=", "TrainingState", "(", "learning_rate", ",", "lr_decay_type", ",", "lr_decay_rate", ")", "\n", "\n", "optim", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "training_state", ".", "lr_variable", ",", "\n", "epsilon", "=", "epsilon", ")", "\n", "\n", "summary_writer", "=", "tf", ".", "contrib", ".", "summary", ".", "create_file_writer", "(", "log_dir", ")", "\n", "\n", "loss_function", "=", "loss_dict", "[", "loss_type", "]", "\n", "\n", "for", "epoch", "in", "range", "(", "1", ",", "num_epochs", "+", "1", ")", ":", "\n", "        ", "train_batches", "=", "gen_train_batches", "(", "fact_structs", ",", "kb_ids", ",", "batch_size", ",", "num_corruptions", ",", "constant_ids", ",", "known_facts", ")", "\n", "\n", "if", "epoch", "%", "report_interval", "==", "0", ":", "\n", "            ", "print", "(", "\"epoch\"", "+", "str", "(", "i", ")", ")", "\n", "if", "verbose", ":", "\n", "\n", "                ", "log_dict", "=", "OrderedDict", "(", ")", "\n", "log_dict", "[", "\"fact_accuracy\"", "]", "=", "eval_fact_accuracy", "(", "train_batches", ",", "emb", ",", "kb_ids", ",", "\n", "vocab", ",", "k_max", ",", "max_depth", ")", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "                    ", "log_dict", "[", "\"rule_recall\"", "]", "=", "eval_rule_accuracy", "(", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "relationships", ")", "\n", "log_dict", "[", "\"closest_rule_score\"", "]", "=", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", "\n", "log_dict", "[", "\"closest_unification_score\"", "]", "=", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", "\n", "\n", "", "with", "summary_writer", ".", "as_default", "(", ")", ",", "tf", ".", "contrib", ".", "summary", ".", "always_record_summaries", "(", ")", ":", "\n", "                    ", "for", "key", "in", "log_dict", ":", "\n", "                        ", "tf", ".", "contrib", ".", "summary", ".", "scalar", "(", "key", ",", "log_dict", "[", "key", "]", ",", "step", "=", "epoch", ")", "\n", "\n", "", "", "", "", "for", "j", ",", "batch", "in", "enumerate", "(", "train_batches", ")", ":", "\n", "\n", "            ", "goal", "=", "tf", ".", "constant", "(", "batch", "[", "\"goal\"", "]", ")", "\n", "\n", "mask_indices", "=", "tf", ".", "constant", "(", "batch", "[", "\"mask_indices\"", "]", ")", "\n", "loss_parameters", "[", "\"epoch\"", "]", "=", "epoch", "\n", "\n", "with", "tf", ".", "device", "(", "\"/device:GPU:0\"", ")", ":", "\n", "                ", "target", "=", "tf", ".", "constant", "(", "batch", "[", "\"target\"", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "base_mask", "=", "tf", ".", "ones", "(", "[", "batch", "[", "\"n_facts_struct\"", "]", ",", "batch", "[", "\"batch_size\"", "]", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "updates", "=", "-", "1.0", "*", "tf", ".", "ones", "(", "len", "(", "batch", "[", "\"mask_indices\"", "]", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "batch_mask", "=", "tf", ".", "transpose", "(", "tf", ".", "constant", "(", "\n", "base_mask", "+", "tf", ".", "scatter_nd", "(", "mask_indices", ",", "updates", ",", "base_mask", ".", "shape", ")", ")", ")", "\n", "\n", "grad", "=", "auto_gradient", "(", "loss_function", ",", "goal", ",", "target", ",", "emb", ",", "kb_ids", ",", "\n", "vocab", ",", "batch", "[", "\"struct\"", "]", ",", "batch_mask", ",", "l2", ",", "k_max", ",", "max_depth", ",", "epsilon", ",", "loss_parameters", ")", "\n", "\n", "", "if", "clip", "is", "not", "None", ":", "\n", "                ", "capped_gradients", "=", "tf", ".", "clip_by_value", "(", "grad", ",", "clip", "[", "0", "]", ",", "clip", "[", "1", "]", ")", "\n", "\n", "", "grad_and_var", "=", "[", "(", "capped_gradients", ",", "emb", ")", "]", "\n", "\n", "optim", ".", "apply_gradients", "(", "grad_and_var", ")", "\n", "\n", "training_state", ".", "update_iteration", "(", ")", "\n", "\n", "", "", "rules", ",", "confidences", "=", "decode_rules", "(", "\n", "kb_ids", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "verbose", "=", "verbose", ",", "print_k", "=", "20", ")", "\n", "\n", "\n", "closest_rule_score_value", "=", "closest_rule_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ",", "fact_structs", ")", "\n", "closest_unification_score_value", "=", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", "\n", "\n", "\n", "if", "relationships", "is", "not", "None", ":", "\n", "\n", "        ", "recall", "=", "prop_rules", "(", "relationships", ",", "rules", ",", "confidences", ")", "\n", "print", "(", "\"recall: \"", "+", "str", "(", "recall", ")", ")", "\n", "\n", "", "tf", ".", "reset_default_graph", "(", ")", "\n", "return", "recall", ",", "closest_rule_score_value", ",", "closest_unification_score_value", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_training.TrainingState.__init__": [[8, 18], ["tensorflow.Variable"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "initial_lr", ",", "decay_type", ",", "decay_rate", ")", ":", "\n", "\n", "        ", "self", ".", "decay_type_dict", "=", "{", "\n", "\"exp\"", ":", "self", ".", "exponential_decay", "\n", "}", "\n", "\n", "self", ".", "decay_type", "=", "decay_type", "\n", "self", ".", "decay_rate", "=", "decay_rate", "\n", "self", ".", "iterations", "=", "0", "\n", "self", ".", "lr_variable", "=", "tf", ".", "Variable", "(", "initial_lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_training.TrainingState.update_iteration": [[19, 23], ["None"], "methods", ["None"], ["", "def", "update_iteration", "(", "self", ")", ":", "\n", "        ", "self", ".", "iterations", "+=", "1", "\n", "if", "self", ".", "decay_type", "is", "not", "None", ":", "\n", "            ", "self", ".", "decay_type_dict", "[", "self", ".", "decay_type", "]", "(", "self", ".", "iterations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_training.TrainingState.exponential_decay": [[24, 27], ["util_training.TrainingState.lr_variable.assign", "tensorflow.exp"], "methods", ["None"], ["", "", "def", "exponential_decay", "(", "self", ",", "iterations", ")", ":", "\n", "        ", "new_value", "=", "self", ".", "lr_variable", "*", "tf", ".", "exp", "(", "-", "self", ".", "decay_rate", ")", "\n", "self", ".", "lr_variable", ".", "assign", "(", "new_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.decode_rules": [[11, 57], ["len", "util_eval.unstack_rules", "unstack_rules.sort", "range", "enumerate", "rule_sym.append", "len", "rules_preds.append", "confidences.append", "ntp.modules.kb.Atom", "set", "print", "ntp.util.util_kb.is_variable", "atom_sym.append", "atom_sym.append", "range", "ntp.util.util_kb.rule2string", "util_eval.decode", "len", "len"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.unstack_rules", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.rule2string", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.decode"], ["def", "decode_rules", "(", "kb", ",", "true_predicate_ids", ",", "constant_ids", ",", "emb", ",", "vocab", ",", "verbose", "=", "False", ",", "print_k", "=", "3", ")", ":", "\n", "    ", "\"\"\"\n    Takes in kb and trained embedding matrix, and returns decodings of the rules in the kb\n    Args:\n        kb: knowledge base of facts and rules\n        true_predicate_ids: list of ids that correspond to 'real' (i.e. non-rule) predicates\n        constant_ids: list of ids that correspond to constants\n        emb: embedding matrix\n        vocab: vocab object that contains mapping between symbol ids and symbols\n    Returns: \n        List of rules and corresponding confidences\n    \"\"\"", "\n", "rules_preds", "=", "[", "]", "\n", "confidences", "=", "[", "]", "\n", "\n", "for", "struct", "in", "kb", ":", "\n", "# it's a rule", "\n", "        ", "if", "len", "(", "struct", ")", ">", "1", ":", "\n", "            ", "rule", "=", "kb", "[", "struct", "]", "\n", "rule_sym", "=", "[", "]", "\n", "for", "atom", "in", "rule", ":", "\n", "                ", "atom_sym", "=", "[", "]", "\n", "for", "i", ",", "sym", "in", "enumerate", "(", "atom", ")", ":", "\n", "                    ", "if", "not", "is_variable", "(", "sym", "[", "0", "]", ")", ":", "\n", "                        ", "valid_ids", "=", "true_predicate_ids", "[", "len", "(", "atom", ")", "-", "1", "]", "if", "i", "==", "0", "else", "constant_ids", "\n", "atom_sym", ".", "append", "(", "decode", "(", "sym", ",", "emb", ",", "vocab", ",", "valid_ids", ")", ")", "\n", "", "else", ":", "\n", "                        ", "atom_sym", ".", "append", "(", "sym", "[", "0", "]", ")", "\n", "", "", "rule_sym", ".", "append", "(", "Atom", "(", "atom_sym", "[", "0", "]", ",", "atom_sym", "[", "1", ":", "]", ")", ")", "\n", "\n", "", "rules", "=", "unstack_rules", "(", "rule_sym", ")", "\n", "\n", "rules", ".", "sort", "(", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "rules", ")", ")", ":", "\n", "                ", "rule", ",", "confidence", "=", "rules", "[", "j", "]", "\n", "preds", "=", "[", "rule", "[", "i", "]", "[", "0", "]", "for", "i", "in", "range", "(", "len", "(", "rule", ")", ")", "]", "\n", "# pred_text = [rule[i][0] for i in range(len(rule))]", "\n", "# preds = [int(text[-1]) for text in pred_text]", "\n", "preds_formatted", "=", "[", "preds", "[", "0", "]", ",", "set", "(", "preds", "[", "1", ":", "]", ")", "]", "\n", "rules_preds", ".", "append", "(", "preds_formatted", ")", "\n", "\n", "confidences", ".", "append", "(", "confidence", ")", "\n", "if", "verbose", "and", "j", "<", "print_k", ":", "\n", "                    ", "print", "(", "confidence", ",", "rule2string", "(", "rule", ")", ")", "\n", "", "", "", "", "return", "rules_preds", ",", "confidences", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.decode": [[58, 102], ["set", "len", "int", "numpy.ones", "range", "tensorflow.tile", "tensorflow.nn.embedding_lookup", "ntp.modules.prover.representation_match", "tensorflow.nn.top_k", "enumerate", "len", "tensorflow.expand_dims", "row[].numpy", "[].numpy", "syms.append", "emb.get_shape"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.nunify.representation_match"], ["", "def", "decode", "(", "x", ",", "emb", ",", "vocab", ",", "valid_ids", ")", ":", "\n", "    ", "\"\"\"\n    Takes in embedding and returns closest matching symbols in embedding matrix\n    Args:\n        x: array of symbol ids\n        emb: embedding matrix\n        vocab: vocab object that contains mapping between symbol ids and symbols\n        valid_ids: the set of ids in the embedding matrix that the input may be matched against (i.e. predicates with predicates)\n    Returns: \n        List of (symbol, success) tuples. Each symbol is selected from the embedding matrix as the closest symbol to the corresponding input symbol, \n        and the success is a decreasing function of that distance. \n    \"\"\"", "\n", "valid_ids", "=", "set", "(", "valid_ids", ")", "\n", "\n", "num_rules", "=", "len", "(", "x", ")", "\n", "num_symbols", "=", "int", "(", "emb", ".", "get_shape", "(", ")", "[", "0", "]", ")", "\n", "\n", "mask", "=", "np", ".", "ones", "(", "[", "num_symbols", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "vocab", ")", ")", ":", "\n", "        ", "if", "i", "not", "in", "valid_ids", ":", "# or i == vocab.sym2id[vocab.unk]:", "\n", "            ", "mask", "[", "i", "]", "=", "0", "# np.zeros([input_size], dtype=np.float32)", "\n", "\n", "# -- num_rules x num_symbols", "\n", "", "", "mask", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "mask", ",", "0", ")", ",", "[", "num_rules", ",", "1", "]", ")", "\n", "\n", "# Retrieve embedding", "\n", "x_tensor", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "emb", ",", "x", ")", "\n", "\n", "# -- num_rules x num_symbols", "\n", "match", "=", "representation_match", "(", "x_tensor", ",", "emb", ")", "\n", "success_masked", "=", "match", "*", "mask", "\n", "\n", "success_val", ",", "ix_val", "=", "tf", ".", "nn", ".", "top_k", "(", "success_masked", ",", "1", ")", "\n", "# success_val, ix_val = sess.run([success, ix], {})", "\n", "\n", "syms", "=", "[", "]", "\n", "for", "i", ",", "row", "in", "enumerate", "(", "ix_val", ")", ":", "\n", "        ", "sym_id", "=", "row", "[", "0", "]", ".", "numpy", "(", ")", "\n", "sym_success", "=", "success_val", "[", "i", "]", "[", "0", "]", ".", "numpy", "(", ")", "\n", "sym", "=", "vocab", ".", "id2sym", "[", "sym_id", "]", "\n", "\n", "syms", ".", "append", "(", "(", "sym", ",", "sym_success", ")", ")", "\n", "\n", "", "return", "syms", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.unstack_rules": [[103, 133], ["len", "range", "rules.append", "isinstance", "current_rule.append", "min", "isinstance", "ntp.modules.kb.Atom", "arguments.append", "min", "arguments.append"], "function", ["None"], ["", "def", "unstack_rules", "(", "rule", ")", ":", "\n", "    ", "\"\"\"\n    Takes in rule array, unstacks the rule array, \n    and calculates the confidence for each rule from the success of the underlying atom unifications with symbols in the embedding matrix\n    Args:\n        rule: stacked rule array\n    Returns: \n        List of rules with corresponding confidence\n    \"\"\"", "\n", "rules", "=", "[", "]", "\n", "num_rules", "=", "len", "(", "rule", "[", "0", "]", ".", "predicate", ")", "\n", "for", "i", "in", "range", "(", "num_rules", ")", ":", "\n", "        ", "current_rule", "=", "[", "]", "\n", "confidence", "=", "1.0", "\n", "for", "atom", "in", "rule", ":", "\n", "            ", "predicate", "=", "atom", ".", "predicate", "\n", "if", "isinstance", "(", "predicate", ",", "list", ")", ":", "\n", "                ", "predicate", ",", "success", "=", "predicate", "[", "i", "]", "\n", "confidence", "=", "min", "(", "confidence", ",", "success", ")", "\n", "", "arguments", "=", "[", "]", "\n", "for", "argument", "in", "atom", ".", "arguments", ":", "\n", "                ", "if", "isinstance", "(", "argument", ",", "list", ")", ":", "\n", "                    ", "argument", ",", "success", "=", "argument", "[", "i", "]", "\n", "arguments", ".", "append", "(", "argument", ")", "\n", "confidence", "=", "min", "(", "confidence", ",", "success", ")", "\n", "", "else", ":", "\n", "                    ", "arguments", ".", "append", "(", "argument", ")", "\n", "", "", "current_rule", ".", "append", "(", "Atom", "(", "predicate", ",", "arguments", ")", ")", "\n", "", "rules", ".", "append", "(", "(", "current_rule", ",", "confidence", ")", ")", "\n", "", "return", "rules", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_eval.harmonic": [[135, 138], ["sum", "range"], "function", ["None"], ["", "def", "harmonic", "(", "n_numbers", ")", ":", "\n", "    ", "\"\"\"Calculate harmonic series, used for calculating MRR\"\"\"", "\n", "return", "sum", "(", "[", "1.0", "/", "(", "i", "+", "1", ")", "for", "i", "in", "range", "(", "n_numbers", ")", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.Vocab.__init__": [[63, 84], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Creates Vocab object. Used as a dictionary between symbols and symbol ids\n        \"\"\"", "\n", "self", ".", "next_neg", "=", "-", "1", "\n", "self", ".", "unk", "=", "\"<UNK>\"", "\n", "self", ".", "emb", "=", "lambda", "_", ":", "None", "#if emb is None: same behavior as for o-o-v words", "\n", "\n", "self", ".", "sym2id", "=", "{", "}", "\n", "# with pos and neg indices", "\n", "self", ".", "id2sym", "=", "{", "}", "\n", "self", ".", "next_pos", "=", "0", "\n", "self", ".", "sym2freqs", "=", "{", "}", "\n", "\n", "self", ".", "sym2id", "[", "self", ".", "unk", "]", "=", "0", "\n", "# with pos and neg indices", "\n", "self", ".", "id2sym", "[", "0", "]", "=", "self", ".", "unk", "\n", "self", ".", "next_pos", "=", "1", "\n", "self", ".", "sym2freqs", "[", "self", ".", "unk", "]", "=", "0", "\n", "\n", "self", ".", "emb_length", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.Vocab.get_id": [[86, 117], ["util_data.Vocab.emb", "isinstance", "len"], "methods", ["None"], ["", "def", "get_id", "(", "self", ",", "sym", ")", ":", "\n", "        ", "\"\"\"\n        returns internal id, that is, positive for out-of-vocab symbol, negative for symbol found in `self.emb`. \n        If `sym` is a new symbol, it is added to the Vocab.\n        Args:\n            `sym`: symbol (e.g., token)\n        \"\"\"", "\n", "\n", "vec", "=", "self", ".", "emb", "(", "sym", ")", "\n", "if", "self", ".", "emb_length", "is", "None", "and", "vec", "is", "not", "None", ":", "\n", "            ", "self", ".", "emb_length", "=", "len", "(", "vec", ")", "if", "isinstance", "(", "vec", ",", "list", ")", "else", "vec", ".", "shape", "[", "0", "]", "\n", "", "if", "sym", "not", "in", "self", ".", "sym2id", ":", "\n", "            ", "if", "vec", "is", "None", ":", "\n", "                ", "self", ".", "sym2id", "[", "sym", "]", "=", "self", ".", "next_pos", "\n", "self", ".", "id2sym", "[", "self", ".", "next_pos", "]", "=", "sym", "\n", "self", ".", "next_pos", "+=", "1", "\n", "", "else", ":", "\n", "                ", "self", ".", "sym2id", "[", "sym", "]", "=", "self", ".", "next_neg", "\n", "self", ".", "id2sym", "[", "self", ".", "next_neg", "]", "=", "sym", "\n", "self", ".", "next_neg", "-=", "1", "\n", "", "self", ".", "sym2freqs", "[", "sym", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "sym2freqs", "[", "sym", "]", "+=", "1", "\n", "", "if", "sym", "in", "self", ".", "sym2id", ":", "\n", "            ", "return", "self", ".", "sym2id", "[", "sym", "]", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "unk", "in", "self", ".", "sym2id", ":", "\n", "                ", "return", "self", ".", "sym2id", "[", "self", ".", "unk", "]", "\n", "# can happen for `Vocab` initialized with `unk` argument set to `None`", "\n", "", "else", ":", "\n", "                ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.Vocab.__call__": [[118, 132], ["len", "isinstance", "util_data.Vocab.get_id", "util_data.Vocab.get_id"], "methods", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.Vocab.get_id", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.Vocab.get_id"], ["", "", "", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        calls the `get_id` function for the provided symbol(s), which adds symbols to the Vocab if needed and allowed,\n        and returns their id(s).\n        Args:\n            *args: a single symbol, a list of symbols, or multiple symbols\n        \"\"\"", "\n", "symbols", "=", "args", "\n", "if", "len", "(", "args", ")", "==", "1", ":", "\n", "            ", "if", "isinstance", "(", "args", "[", "0", "]", ",", "list", ")", ":", "\n", "                ", "symbols", "=", "args", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "return", "self", ".", "get_id", "(", "args", "[", "0", "]", ")", "\n", "", "", "return", "[", "self", ".", "get_id", "(", "sym", ")", "for", "sym", "in", "symbols", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.Vocab.__contains__": [[133, 136], ["None"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "sym", ")", ":", "\n", "        ", "\"\"\"checks if `sym` already in the Vocab object\"\"\"", "\n", "return", "sym", "in", "self", ".", "sym2id", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.Vocab.__len__": [[137, 140], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"returns number of unique symbols (including the unknown symbol)\"\"\"", "\n", "return", "len", "(", "self", ".", "id2sym", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.save_conf": [[11, 19], ["open", "path.split", "json.dump", "f_out.close"], "function", ["None"], ["def", "save_conf", "(", "path", ",", "conf", ")", ":", "\n", "    ", "\"\"\"save conf file in path\"\"\"", "\n", "with", "open", "(", "path", ",", "\"w\"", ")", "as", "f_out", ":", "\n", "        ", "splits", "=", "path", ".", "split", "(", "\"/\"", ")", "\n", "dir", "=", "\"/\"", ".", "join", "(", "splits", "[", ":", "-", "1", "]", ")", "+", "\"/\"", "\n", "conf", "[", "\"meta\"", "]", "[", "\"experiment_dir\"", "]", "=", "dir", "\n", "json", ".", "dump", "(", "conf", ",", "f_out", ",", "indent", "=", "4", ",", "sort_keys", "=", "True", ")", "\n", "f_out", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.deep_merge": [[21, 36], ["isinstance", "isinstance", "util_data.deep_merge"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.deep_merge"], ["", "", "def", "deep_merge", "(", "dict1", ",", "dict2", ")", ":", "\n", "    ", "\"\"\"overrides entries in dict1 with entries in dict2 recursively\"\"\"", "\n", "if", "isinstance", "(", "dict1", ",", "dict", ")", "and", "isinstance", "(", "dict2", ",", "dict", ")", ":", "\n", "        ", "tmp", "=", "{", "}", "\n", "for", "key", "in", "dict1", ":", "\n", "            ", "if", "key", "not", "in", "dict2", ":", "\n", "                ", "tmp", "[", "key", "]", "=", "dict1", "[", "key", "]", "\n", "", "else", ":", "\n", "                ", "tmp", "[", "key", "]", "=", "deep_merge", "(", "dict1", "[", "key", "]", ",", "dict2", "[", "key", "]", ")", "\n", "", "", "for", "key", "in", "dict2", ":", "\n", "            ", "if", "key", "not", "in", "dict1", ":", "\n", "                ", "tmp", "[", "key", "]", "=", "dict2", "[", "key", "]", "\n", "", "", "return", "tmp", "\n", "", "else", ":", "\n", "        ", "return", "dict2", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.load_conf": [[38, 60], ["path.split", "open", "eval", "f.close", "f.read", "file_name.split", "util_data.load_conf", "util_data.deep_merge"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.load_conf", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_data.deep_merge"], ["", "", "def", "load_conf", "(", "path", ")", ":", "\n", "    ", "\"\"\"load conf file from path\"\"\"", "\n", "file_name", "=", "path", ".", "split", "(", "\"/\"", ")", "[", "-", "1", "]", "\n", "\n", "with", "open", "(", "path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "conf", "=", "eval", "(", "f", ".", "read", "(", ")", ")", "\n", "\n", "if", "\"meta\"", "not", "in", "conf", ":", "\n", "            ", "conf", "[", "\"meta\"", "]", "=", "{", "}", "\n", "\n", "", "conf", "[", "\"meta\"", "]", "[", "\"conf\"", "]", "=", "path", "\n", "conf", "[", "\"meta\"", "]", "[", "\"name\"", "]", "=", "file_name", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "conf", "[", "\"meta\"", "]", "[", "\"file_name\"", "]", "=", "file_name", "\n", "\n", "# load parent dict, override with highest level dict", "\n", "if", "\"parent\"", "in", "conf", "[", "\"meta\"", "]", "and", "conf", "[", "\"meta\"", "]", "[", "\"parent\"", "]", "is", "not", "None", ":", "\n", "            ", "parent", "=", "load_conf", "(", "conf", "[", "\"meta\"", "]", "[", "\"parent\"", "]", ")", "\n", "conf", "=", "deep_merge", "(", "parent", ",", "conf", ")", "# {**parent, **conf}", "\n", "\n", "", "f", ".", "close", "(", ")", "\n", "\n", "return", "conf", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.trim": [[10, 16], ["re.sub"], "function", ["None"], ["def", "trim", "(", "string", ")", ":", "\n", "    ", "\"\"\"\n    :param string: an input string\n    :return: the string without trailing whitespaces\n    \"\"\"", "\n", "return", "re", ".", "sub", "(", "\"\\A\\s+|\\s+\\Z\"", ",", "\"\"", ",", "string", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_atom": [[18, 20], ["isinstance"], "function", ["None"], ["", "def", "is_atom", "(", "arg", ")", ":", "\n", "    ", "return", "isinstance", "(", "arg", ",", "Atom", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable": [[22, 27], ["isinstance", "arg.isupper"], "function", ["None"], ["", "def", "is_variable", "(", "arg", ")", ":", "\n", "    ", "if", "isinstance", "(", "arg", ",", "str", ")", ":", "\n", "        ", "return", "arg", ".", "isupper", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_list": [[29, 31], ["isinstance"], "function", ["None"], ["", "", "def", "is_list", "(", "arg", ")", ":", "\n", "    ", "return", "isinstance", "(", "arg", ",", "list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_array": [[33, 35], ["isinstance"], "function", ["None"], ["", "def", "is_array", "(", "arg", ")", ":", "\n", "    ", "return", "isinstance", "(", "arg", ",", "np", ".", "ndarray", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_constant": [[37, 42], ["isinstance", "arg.islower"], "function", ["None"], ["", "def", "is_constant", "(", "arg", ")", ":", "\n", "    ", "if", "isinstance", "(", "arg", ",", "str", ")", ":", "\n", "        ", "return", "arg", ".", "islower", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_parameter": [[44, 49], ["isinstance"], "function", ["None"], ["", "", "def", "is_parameter", "(", "predicate", ")", ":", "\n", "    ", "if", "isinstance", "(", "predicate", ",", "str", ")", ":", "\n", "        ", "return", "predicate", "[", "0", "]", "==", "\"#\"", "\n", "", "else", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.atom2string": [[51, 53], ["None"], "function", ["None"], ["", "", "def", "atom2string", "(", "atom", ")", ":", "\n", "    ", "return", "\"%s(%s)\"", "%", "(", "atom", ".", "predicate", ",", "\",\"", ".", "join", "(", "atom", ".", "arguments", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.rule2string": [[55, 62], ["util_kb.atom2string", "util_kb.atom2string", "len"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.atom2string", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.atom2string"], ["", "def", "rule2string", "(", "rule", ")", ":", "\n", "    ", "head", "=", "atom2string", "(", "rule", "[", "0", "]", ")", "\n", "body", "=", "[", "atom2string", "(", "x", ")", "for", "x", "in", "rule", "[", "1", ":", "]", "]", "\n", "if", "len", "(", "rule", ")", "==", "1", ":", "\n", "        ", "return", "\"%s.\"", "%", "head", "\n", "", "else", ":", "\n", "        ", "return", "\"%s :- %s.\"", "%", "(", "head", ",", "\", \"", ".", "join", "(", "body", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.subs2string": [[64, 67], ["substitutions.items"], "function", ["None"], ["", "", "def", "subs2string", "(", "substitutions", ")", ":", "\n", "    ", "return", "\"{%s}\"", "%", "\", \"", ".", "join", "(", "[", "key", "+", "\"/\"", "+", "val", "for", "\n", "key", ",", "val", "in", "substitutions", ".", "items", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_ground_atom": [[69, 74], ["util_kb.is_atom", "len", "util_kb.is_variable"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_atom", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable"], ["", "def", "is_ground_atom", "(", "atom", ")", ":", "\n", "    ", "if", "is_atom", "(", "atom", ")", ":", "\n", "        ", "return", "len", "(", "[", "x", "for", "x", "in", "atom", ".", "arguments", "if", "is_variable", "(", "x", ")", "]", ")", "==", "0", "\n", "", "else", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.has_free_variables": [[76, 78], ["len", "util_kb.is_ground_atom"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_ground_atom"], ["", "", "def", "has_free_variables", "(", "rule", ")", ":", "\n", "    ", "return", "len", "(", "[", "atom", "for", "atom", "in", "rule", "if", "not", "is_ground_atom", "(", "atom", ")", "]", ")", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.parse_rules": [[80, 109], ["re.sub", "re.sub", "re.split", "int", "util_kb.trim", "len", "re.sub.split", "atom.split", "atoms.append", "kb.append", "kb.append", "Atom", "re.split"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.trim"], ["", "def", "parse_rules", "(", "rules", ",", "delimiter", "=", "\"#####\"", ",", "rule_template", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    :param rules:\n    :param delimiter:\n    :return:\n    \"\"\"", "\n", "kb", "=", "[", "]", "\n", "for", "rule", "in", "rules", ":", "\n", "        ", "if", "rule_template", ":", "\n", "            ", "splits", "=", "re", ".", "split", "(", "\"\\A\\n?([0-9]?[0-9]+)\"", ",", "rule", ")", "\n", "# fixme: should be 0 and 1 respectively", "\n", "num", "=", "int", "(", "splits", "[", "1", "]", ")", "\n", "rule", "=", "splits", "[", "2", "]", "\n", "", "rule", "=", "re", ".", "sub", "(", "\":-\"", ",", "delimiter", ",", "rule", ")", "\n", "rule", "=", "re", ".", "sub", "(", "\"\\),\"", ",", "\")\"", "+", "delimiter", ",", "rule", ")", "\n", "rule", "=", "[", "trim", "(", "x", ")", "for", "x", "in", "rule", ".", "split", "(", "delimiter", ")", "]", "\n", "rule", "=", "[", "x", "for", "x", "in", "rule", "if", "x", "!=", "\"\"", "]", "\n", "if", "len", "(", "rule", ")", ">", "0", ":", "\n", "            ", "atoms", "=", "[", "]", "\n", "for", "atom", "in", "rule", ":", "\n", "                ", "splits", "=", "atom", ".", "split", "(", "\"(\"", ")", "\n", "predicate", "=", "splits", "[", "0", "]", "\n", "args", "=", "[", "x", "for", "x", "in", "re", ".", "split", "(", "\"\\s?,\\s?|\\)\"", ",", "splits", "[", "1", "]", ")", "if", "x", "!=", "\"\"", "]", "\n", "atoms", ".", "append", "(", "Atom", "(", "predicate", ",", "args", ")", ")", "\n", "", "if", "rule_template", ":", "\n", "                ", "kb", ".", "append", "(", "(", "atoms", ",", "num", ")", ")", "\n", "", "else", ":", "\n", "                ", "kb", ".", "append", "(", "atoms", ")", "\n", "", "", "", "return", "kb", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.load_from_file": [[111, 121], ["open", "f.readlines", "util_kb.parse_rules", "re.split", "x.startswith", "x.strip", "x.startswith"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.parse_rules"], ["", "def", "load_from_file", "(", "path", ",", "rule_template", "=", "False", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "text", "=", "f", ".", "readlines", "(", ")", "\n", "text", "=", "[", "x", "for", "x", "in", "text", "if", "not", "x", ".", "startswith", "(", "\"%\"", ")", "and", "x", ".", "strip", "(", ")", "!=", "\"\"", "]", "\n", "text", "=", "\"\"", ".", "join", "(", "text", ")", "\n", "rules", "=", "[", "x", "for", "x", "in", "re", ".", "split", "(", "\"\\.\\n|\\.\\Z\"", ",", "text", ")", "if", "x", "!=", "\"\"", "and", "\n", "x", "!=", "\"\\n\"", "and", "not", "x", ".", "startswith", "(", "\"%\"", ")", "]", "\n", "kb", "=", "parse_rules", "(", "rules", ",", "rule_template", "=", "rule_template", ")", "\n", "\n", "", "return", "kb", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.load_from_list": [[122, 129], ["util_kb.parse_rules", "re.split", "x.startswith", "x.strip", "x.startswith"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.parse_rules"], ["", "def", "load_from_list", "(", "text", ",", "rule_template", "=", "False", ")", ":", "\n", "    ", "text", "=", "[", "x", "for", "x", "in", "text", "if", "not", "x", ".", "startswith", "(", "\"%\"", ")", "and", "x", ".", "strip", "(", ")", "!=", "\"\"", "]", "\n", "text", "=", "\"\"", ".", "join", "(", "text", ")", "\n", "rules", "=", "[", "x", "for", "x", "in", "re", ".", "split", "(", "\"\\.\\n|\\.\\Z\"", ",", "text", ")", "if", "x", "!=", "\"\"", "and", "\n", "x", "!=", "\"\\n\"", "and", "not", "x", ".", "startswith", "(", "\"%\"", ")", "]", "\n", "kb", "=", "parse_rules", "(", "rules", ",", "rule_template", "=", "rule_template", ")", "\n", "return", "kb", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.normalize": [[130, 151], ["Atom", "util_kb.has_free_variables", "util_kb.is_variable", "normalized_kb.append", "normalized_kb.append", "new_args.append", "new_args.append", "util_kb.normalize.suffix_variables"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.has_free_variables", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.is_variable"], ["", "def", "normalize", "(", "kb", ")", ":", "\n", "    ", "counter", "=", "0", "\n", "normalized_kb", "=", "[", "]", "\n", "\n", "def", "suffix_variables", "(", "atom", ",", "suffix", ")", ":", "\n", "        ", "new_args", "=", "[", "]", "\n", "for", "arg", "in", "atom", ".", "arguments", ":", "\n", "            ", "if", "is_variable", "(", "arg", ")", ":", "\n", "                ", "new_args", ".", "append", "(", "arg", "+", "suffix", ")", "\n", "", "else", ":", "\n", "                ", "new_args", ".", "append", "(", "arg", ")", "\n", "", "", "return", "Atom", "(", "atom", ".", "predicate", ",", "new_args", ")", "\n", "\n", "", "for", "rule", "in", "kb", ":", "\n", "        ", "if", "has_free_variables", "(", "rule", ")", ":", "\n", "            ", "normalized_kb", ".", "append", "(", "[", "suffix_variables", "(", "atom", ",", "str", "(", "counter", ")", ")", "\n", "for", "atom", "in", "rule", "]", ")", "\n", "counter", "+=", "1", "\n", "", "else", ":", "\n", "            ", "normalized_kb", ".", "append", "(", "rule", ")", "\n", "", "", "return", "normalized_kb", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_kb.relationship_id_to_symbol": [[152, 157], ["relationships.items", "set", "str", "str"], "function", ["None"], ["", "def", "relationship_id_to_symbol", "(", "relationships", ")", ":", "\n", "    ", "symbol_relationships", "=", "{", "}", "\n", "for", "head", ",", "body", "in", "relationships", ".", "items", "(", ")", ":", "\n", "        ", "symbol_relationships", "[", "\"Predicate\"", "+", "str", "(", "head", ")", "]", "=", "set", "(", "[", "\"Predicate\"", "+", "str", "(", "body_pred", ")", "for", "body_pred", "in", "body", "]", ")", "\n", "", "return", "symbol_relationships", "", "", ""]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.closest_unification_score": [[8, 23], ["emb.numpy", "relationships.items", "numpy.mean", "best_scores.append", "ntp.modules.nunify.l2_sim_np", "numpy.expand_dims", "numpy.expand_dims"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.modules.nunify.l2_sim_np"], ["def", "closest_unification_score", "(", "relationships", ",", "emb", ",", "kb_ids", ",", "vocab", ")", ":", "\n", "    ", "\"\"\"Calculate best score, averaged over all relationships, of directly unifying head fact with one of the body facts\"\"\"", "\n", "emb_np", "=", "emb", ".", "numpy", "(", ")", "\n", "best_scores", "=", "[", "]", "\n", "for", "head", ",", "body", "in", "relationships", ".", "items", "(", ")", ":", "\n", "        ", "head_id", "=", "vocab", ".", "sym2id", "[", "head", "]", "\n", "body_ids", "=", "[", "vocab", ".", "sym2id", "[", "body_pred", "]", "for", "body_pred", "in", "body", "]", "\n", "best_score", "=", "0", "\n", "for", "body_id", "in", "body_ids", ":", "\n", "            ", "id_score", "=", "l2_sim_np", "(", "np", ".", "expand_dims", "(", "emb_np", "[", "head_id", "]", ",", "axis", "=", "0", ")", ",", "np", ".", "expand_dims", "(", "emb_np", "[", "body_id", "]", ",", "axis", "=", "0", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "if", "id_score", ">", "best_score", ":", "\n", "                ", "best_score", "=", "id_score", "\n", "", "", "best_scores", ".", "append", "(", "best_score", ")", "\n", "", "average_score_closest", "=", "np", ".", "mean", "(", "best_scores", ")", "\n", "return", "average_score_closest", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.identify_relevant_goals": [[28, 41], ["goal[].numpy", "goal[].numpy", "enumerate", "numpy.array", "active_indices.append"], "function", ["None"], ["", "def", "identify_relevant_goals", "(", "goal", ",", "relationship_ids", ",", "fact_dict", ")", ":", "\n", "\n", "    ", "predicates", "=", "goal", "[", "0", "]", ".", "numpy", "(", ")", "\n", "constants", "=", "goal", "[", "1", "]", ".", "numpy", "(", ")", "\n", "\n", "active_indices", "=", "[", "]", "\n", "\n", "for", "i", ",", "predicate", "in", "enumerate", "(", "predicates", ")", ":", "\n", "        ", "if", "predicate", "in", "relationship_ids", ":", "\n", "            ", "if", "relationship_ids", "[", "predicate", "]", "in", "fact_dict", "[", "constants", "[", "i", "]", "]", ":", "\n", "                ", "active_indices", ".", "append", "(", "i", ")", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "active_indices", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.decode_proof": [[42, 58], ["decoding.append", "int", "decoding.append", "decoding.append", "str"], "function", ["None"], ["", "def", "decode_proof", "(", "index", ",", "kb", ",", "n_facts", ")", ":", "\n", "\n", "    ", "decoding", "=", "[", "]", "\n", "if", "index", "<", "n_facts", ":", "\n", "        ", "decoding", ".", "append", "(", "kb", "[", "index", "]", "[", "0", "]", ".", "predicate", "+", "\"(\"", "+", "kb", "[", "index", "]", "[", "0", "]", ".", "arguments", "[", "0", "]", "+", "\")\"", ")", "\n", "", "else", ":", "\n", "\n", "        ", "proof_index", "=", "index", "-", "n_facts", "\n", "\n", "fact_id", "=", "proof_index", "%", "n_facts", "\n", "rule_id", "=", "int", "(", "(", "proof_index", "-", "fact_id", ")", "/", "n_facts", ")", "\n", "\n", "decoding", ".", "append", "(", "kb", "[", "fact_id", "]", "[", "0", "]", ".", "predicate", "+", "\"(\"", "+", "kb", "[", "fact_id", "]", "[", "0", "]", ".", "arguments", "[", "0", "]", "+", "\")\"", ")", "\n", "decoding", ".", "append", "(", "\"Rule \"", "+", "str", "(", "rule_id", ")", ")", "\n", "\n", "", "return", "decoding", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.decode_proofs": [[60, 63], ["util_diag.decode_proof"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.decode_proof"], ["", "def", "decode_proofs", "(", "indices", ",", "kb", ",", "n_facts", ")", ":", "\n", "    ", "decoded_proofs", "=", "[", "decode_proof", "(", "index", ",", "kb", ",", "n_facts", ")", "for", "index", "in", "indices", "]", "\n", "return", "decoded_proofs", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.find_correct_proof_indices": [[66, 80], ["goal[].numpy", "goal[].numpy", "tensorflow.size", "numpy.zeros", "range", "range", "range", "range", "int"], "function", ["None"], ["", "def", "find_correct_proof_indices", "(", "goal", ",", "n_rules", ",", "n_facts", ",", "relationship_ids", ",", "inverse_kb", ")", ":", "\n", "    ", "predicates", "=", "goal", "[", "0", "]", ".", "numpy", "(", ")", "\n", "constants", "=", "goal", "[", "1", "]", ".", "numpy", "(", ")", "\n", "\n", "n_goals", "=", "tf", ".", "size", "(", "predicates", ")", "\n", "base_predicates", "=", "[", "relationship_ids", "[", "predicates", "[", "i", "]", "]", "[", "0", "]", "for", "i", "in", "range", "(", "n_goals", ")", "]", "\n", "fact_indices", "=", "[", "inverse_kb", "[", "(", "base_predicates", "[", "i", "]", ",", "constants", "[", "i", "]", ")", "]", "for", "i", "in", "range", "(", "n_goals", ")", "]", "\n", "\n", "correct_indices", "=", "np", ".", "zeros", "(", "(", "n_rules", ",", "n_goals", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_goals", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_rules", ")", ":", "\n", "            ", "correct_indices", "[", "j", ",", "i", "]", "=", "int", "(", "(", "j", "+", "1", ")", "*", "n_facts", "+", "fact_indices", "[", "i", "]", ")", "\n", "", "", "return", "correct_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.calc_proof_gradient": [[82, 90], ["numpy.log", "numpy.log"], "function", ["None"], ["", "def", "calc_proof_gradient", "(", "emb1", ",", "emb2", ",", "score", ",", "target", ")", ":", "\n", "\n", "        ", "if", "target", "==", "1.0", ":", "\n", "            ", "proof_gradient", "=", "-", "(", "emb1", "-", "emb2", ")", "/", "np", ".", "log", "(", "score", ")", "\n", "", "elif", "target", "==", "0.0", ":", "\n", "            ", "proof_gradient", "=", "score", "/", "(", "1", "-", "score", ")", "*", "(", "emb1", "-", "emb2", ")", "/", "np", ".", "log", "(", "score", ")", "\n", "\n", "", "return", "proof_gradient", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.calculate_gradient": [[92, 153], ["numpy.zeros", "enumerate", "numpy.exp", "numpy.exp", "numpy.exp", "numpy.exp", "numpy.argmin", "numpy.linalg.norm", "util_diag.calc_proof_gradient", "util_diag.calc_proof_gradient", "int", "util_diag.calc_proof_gradient", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "util_diag.calc_proof_gradient", "util_diag.calc_proof_gradient"], "function", ["home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.calc_proof_gradient", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.calc_proof_gradient", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.calc_proof_gradient", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.calc_proof_gradient", "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.calc_proof_gradient"], ["", "def", "calculate_gradient", "(", "predicates", ",", "constants", ",", "indices", ",", "emb", ",", "targets", ",", "shape", ",", "n_facts", ",", "kb_ids", ",", "goal_struct", ")", ":", "\n", "\n", "    ", "rule_struct", "=", "(", "(", "'p0'", ",", "'X0'", ")", ",", "(", "'p1'", ",", "'X0'", ")", ")", "\n", "\n", "gradient", "=", "np", ".", "zeros", "(", "shape", ")", "\n", "\n", "for", "i", ",", "index", "in", "enumerate", "(", "indices", ")", ":", "\n", "        ", "fact_id", "=", "index", "%", "n_facts", "\n", "\n", "fact_predicate_id", "=", "kb_ids", "[", "goal_struct", "]", "[", "0", "]", "[", "0", "]", "[", "fact_id", "]", "\n", "fact_constant_id", "=", "kb_ids", "[", "goal_struct", "]", "[", "0", "]", "[", "1", "]", "[", "fact_id", "]", "\n", "\n", "fact_predicate_embedding", "=", "emb", "[", "fact_predicate_id", "]", "\n", "fact_constant_embedding", "=", "emb", "[", "fact_constant_id", "]", "\n", "\n", "goal_predicate_embedding", "=", "emb", "[", "predicates", "[", "i", "]", "]", "\n", "goal_constant_embedding", "=", "emb", "[", "constants", "[", "i", "]", "]", "\n", "\n", "constant_score", "=", "np", ".", "exp", "(", "-", "np", ".", "linalg", ".", "norm", "(", "fact_constant_embedding", "-", "goal_constant_embedding", ")", ")", "\n", "\n", "if", "index", "<", "n_facts", ":", "\n", "\n", "            ", "pred_score", "=", "np", ".", "exp", "(", "-", "np", ".", "linalg", ".", "norm", "(", "fact_predicate_embedding", "-", "goal_predicate_embedding", ")", ")", "\n", "\n", "if", "pred_score", ">", "constant_score", ":", "\n", "                ", "proof_grad", "=", "calc_proof_gradient", "(", "fact_constant_embedding", ",", "goal_constant_embedding", ",", "constant_score", ",", "targets", "[", "i", "]", ")", "\n", "gradient", "[", "fact_constant_id", ",", ":", "]", "+=", "proof_grad", "\n", "gradient", "[", "constants", "[", "i", "]", ",", ":", "]", "-=", "proof_grad", "\n", "\n", "", "else", ":", "\n", "                ", "proof_grad", "=", "calc_proof_gradient", "(", "fact_predicate_embedding", ",", "goal_predicate_embedding", ",", "pred_score", ",", "targets", "[", "i", "]", ")", "\n", "gradient", "[", "fact_predicate_id", ",", ":", "]", "+=", "proof_grad", "\n", "gradient", "[", "predicates", "[", "i", "]", ",", ":", "]", "-=", "proof_grad", "\n", "\n", "", "", "else", ":", "\n", "\n", "            ", "rule_id", "=", "int", "(", "(", "index", "-", "fact_id", ")", "/", "n_facts", ")", "-", "1", "\n", "rule_goal_predicate_id", "=", "kb_ids", "[", "rule_struct", "]", "[", "0", "]", "[", "0", "]", "[", "rule_id", "]", "\n", "rule_body_predicate_id", "=", "kb_ids", "[", "rule_struct", "]", "[", "1", "]", "[", "0", "]", "[", "rule_id", "]", "\n", "\n", "rule_goal_predicate_embedding", "=", "emb", "[", "rule_goal_predicate_id", "]", "\n", "rule_body_predicate_embedding", "=", "emb", "[", "rule_body_predicate_id", "]", "\n", "\n", "pred_score_1", "=", "np", ".", "exp", "(", "-", "np", ".", "linalg", ".", "norm", "(", "fact_predicate_embedding", "-", "rule_body_predicate_embedding", ")", ")", "\n", "pred_score_2", "=", "np", ".", "exp", "(", "-", "np", ".", "linalg", ".", "norm", "(", "goal_predicate_embedding", "-", "rule_goal_predicate_embedding", ")", ")", "\n", "\n", "worst_unification", "=", "np", ".", "argmin", "(", "[", "constant_score", ",", "pred_score_1", ",", "pred_score_2", "]", ")", "\n", "if", "worst_unification", "==", "0", ":", "\n", "                ", "proof_grad", "=", "calc_proof_gradient", "(", "fact_constant_embedding", ",", "goal_constant_embedding", ",", "constant_score", ",", "targets", "[", "i", "]", ")", "\n", "gradient", "[", "fact_constant_id", ",", ":", "]", "+=", "proof_grad", "\n", "gradient", "[", "constants", "[", "i", "]", "]", "-=", "proof_grad", "\n", "", "elif", "worst_unification", "==", "1", ":", "\n", "                ", "proof_grad", "=", "calc_proof_gradient", "(", "fact_predicate_embedding", ",", "rule_body_predicate_embedding", ",", "pred_score_1", ",", "targets", "[", "i", "]", ")", "\n", "gradient", "[", "fact_predicate_id", ",", ":", "]", "+=", "proof_grad", "\n", "gradient", "[", "rule_body_predicate_id", ",", ":", "]", "-=", "proof_grad", "\n", "", "elif", "worst_unification", "==", "2", ":", "\n", "                ", "proof_grad", "=", "calc_proof_gradient", "(", "goal_predicate_embedding", ",", "rule_goal_predicate_embedding", ",", "pred_score_2", ",", "targets", "[", "i", "]", ")", "\n", "gradient", "[", "predicates", "[", "i", "]", ",", ":", "]", "+=", "proof_grad", "\n", "gradient", "[", "rule_goal_predicate_id", ",", ":", "]", "-=", "proof_grad", "\n", "\n", "", "", "", "return", "gradient", "\n", "\n"]], "home.repos.pwc.inspect_result.Michiel29_ntp-release.util.util_diag.score_proof": [[154, 192], ["numpy.exp", "numpy.exp", "numpy.min", "numpy.exp", "numpy.exp", "numpy.min", "numpy.linalg.norm", "int", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm"], "function", ["None"], ["", "def", "score_proof", "(", "index", ",", "predicate", ",", "constant", ",", "emb", ",", "kb_ids", ",", "n_facts", ",", "goal_struct", ")", ":", "\n", "\n", "    ", "rule_struct", "=", "(", "(", "'p0'", ",", "'X0'", ")", ",", "(", "'p1'", ",", "'X0'", ")", ")", "\n", "\n", "fact_id", "=", "index", "%", "n_facts", "\n", "\n", "fact_predicate_id", "=", "kb_ids", "[", "goal_struct", "]", "[", "0", "]", "[", "0", "]", "[", "fact_id", "]", "\n", "fact_constant_id", "=", "kb_ids", "[", "goal_struct", "]", "[", "0", "]", "[", "1", "]", "[", "fact_id", "]", "\n", "\n", "fact_predicate_embedding", "=", "emb", "[", "fact_predicate_id", "]", "\n", "fact_constant_embedding", "=", "emb", "[", "fact_constant_id", "]", "\n", "\n", "goal_predicate_embedding", "=", "emb", "[", "predicate", "]", "\n", "goal_constant_embedding", "=", "emb", "[", "constant", "]", "\n", "\n", "constant_score", "=", "np", ".", "exp", "(", "-", "np", ".", "linalg", ".", "norm", "(", "fact_constant_embedding", "-", "goal_constant_embedding", ")", ")", "\n", "\n", "if", "index", "<", "n_facts", ":", "\n", "\n", "        ", "pred_score", "=", "np", ".", "exp", "(", "-", "np", ".", "linalg", ".", "norm", "(", "fact_predicate_embedding", "-", "goal_predicate_embedding", ")", ")", "\n", "proof_score", "=", "np", ".", "min", "(", "[", "constant_score", ",", "pred_score", "]", ")", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "rule_id", "=", "int", "(", "(", "index", "-", "fact_id", ")", "/", "n_facts", ")", "-", "1", "\n", "rule_goal_predicate_id", "=", "kb_ids", "[", "rule_struct", "]", "[", "0", "]", "[", "0", "]", "[", "rule_id", "]", "\n", "rule_body_predicate_id", "=", "kb_ids", "[", "rule_struct", "]", "[", "1", "]", "[", "0", "]", "[", "rule_id", "]", "\n", "\n", "rule_goal_predicate_embedding", "=", "emb", "[", "rule_goal_predicate_id", "]", "\n", "rule_body_predicate_embedding", "=", "emb", "[", "rule_body_predicate_id", "]", "\n", "\n", "pred_score_1", "=", "np", ".", "exp", "(", "-", "np", ".", "linalg", ".", "norm", "(", "fact_predicate_embedding", "-", "rule_body_predicate_embedding", ")", ")", "\n", "pred_score_2", "=", "np", ".", "exp", "(", "-", "np", ".", "linalg", ".", "norm", "(", "goal_predicate_embedding", "-", "rule_goal_predicate_embedding", ")", ")", "\n", "\n", "\n", "proof_score", "=", "np", ".", "min", "(", "[", "constant_score", ",", "pred_score_1", ",", "pred_score_2", "]", ")", "\n", "\n", "", "return", "proof_score", "", "", ""]]}