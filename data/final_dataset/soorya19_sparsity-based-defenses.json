{"home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.linear_svm.sp_func_svm.sp_frontend": [[7, 33], ["images.copy", "numpy.floor().astype", "images.copy.astype", "numpy.argpartition", "numpy.floor", "numpy.abs", "numpy.clip().reshape", "numpy.arange", "numpy.clip"], "function", ["None"], ["def", "sp_frontend", "(", "images", ",", "rho", ",", "psi", ")", ":", "\n", "    ", "\"\"\"\n    Sparsifies images in the wavelet basis and returns reconstruction.\n\n    Inputs:\n        images - Numpy array of shape [batch_size, dim] and in the range [-1, 1] \n        rho    - Sparsity level in the range [0, 1]\n        psi    - Orthonormal basis to sparsify in. Numpy array of shape [dim, dim]\n\n    Output:\n        images_sp - Sparsified images. Numpy array of same shape as images\n    \"\"\"", "\n", "batch_size", "=", "images", ".", "shape", "[", "0", "]", "\n", "dim", "=", "images", ".", "shape", "[", "1", "]", "\n", "images_sp", "=", "images", ".", "copy", "(", ")", "\n", "\n", "coeffs", "=", "(", "0.5", "*", "images_sp", "+", "0.5", ")", "@", "psi", ".", "T", "\n", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "dim", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "dim", "-", "k", "\n", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ",", "axis", "=", "1", ")", "[", ":", ",", ":", "n", "]", "\n", "coeffs", "[", "np", ".", "arange", "(", "batch_size", ")", "[", ":", ",", "None", "]", ",", "indices", "]", "=", "0", "\n", "\n", "images_sp", "=", "2.0", "*", "np", ".", "clip", "(", "coeffs", "@", "psi", ",", "0.", ",", "1.", ")", ".", "reshape", "(", "[", "batch_size", ",", "dim", "]", ")", "-", "1.0", "\n", "\n", "return", "images_sp", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.linear_svm.sp_func_svm.sp_project": [[34, 63], ["x.copy", "w.copy", "numpy.floor().astype", "w.copy.astype", "numpy.argpartition", "numpy.floor", "numpy.abs", "numpy.arange"], "function", ["None"], ["", "def", "sp_project", "(", "x", ",", "w", ",", "rho", ",", "psi", ")", ":", "\n", "    ", "\"\"\"\n    Projects w onto the top rho% of the support of x (in the wavelet basis).\n\n    Inputs:\n        x   - Numpy array of shape [batch_size, dim] and in the range [-1, 1] \n        w   - Numpy array of same shape as x\n        rho - Sparsity level in the range [0, 1]\n        psi - Orthonormal basis to sparsify in. Numpy array of shape [dim, dim]\n\n    Output:\n        weights - Projected version of w. Same shape as w\n    \"\"\"", "\n", "images", "=", "x", ".", "copy", "(", ")", "\n", "weights", "=", "w", ".", "copy", "(", ")", "\n", "batch_size", "=", "images", ".", "shape", "[", "0", "]", "\n", "dim", "=", "images", ".", "shape", "[", "1", "]", "\n", "\n", "coeffs", "=", "(", "0.5", "*", "images", "+", "0.5", ")", "@", "psi", ".", "T", "\n", "coeffs_w", "=", "weights", "@", "psi", ".", "T", "\n", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "dim", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "dim", "-", "k", "\n", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ",", "axis", "=", "1", ")", "[", ":", ",", ":", "n", "]", "\n", "coeffs_w", "[", "np", ".", "arange", "(", "batch_size", ")", "[", ":", ",", "None", "]", ",", "indices", "]", "=", "0", "\n", "\n", "weights", "=", "(", "coeffs_w", "@", "psi", ")", ".", "reshape", "(", "[", "batch_size", ",", "dim", "]", ")", "\n", "\n", "return", "weights", ".", "astype", "(", "np", ".", "float32", ")", "", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.linear_svm.mnist_workaround.fetch_mnist": [[11, 22], ["sklearn.datasets.base.get_data_home", "os.path.join", "os.path.join", "os.path.exists", "os.makedirs", "os.path.exists", "six.moves.urllib.request.urlopen", "open", "shutil.copyfileobj"], "function", ["None"], ["def", "fetch_mnist", "(", ")", ":", "\n", "\t", "mnist_alternative_url", "=", "\"https://github.com/amplab/datascience-sp14/raw/master/lab7/mldata/mnist-original.mat\"", "\n", "data_home", "=", "get_data_home", "(", ")", "\n", "data_home", "=", "os", ".", "path", ".", "join", "(", "data_home", ",", "'mldata'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "data_home", ")", ":", "\n", "\t    ", "os", ".", "makedirs", "(", "data_home", ")", "\n", "", "mnist_save_path", "=", "os", ".", "path", ".", "join", "(", "data_home", ",", "\"mnist-original.mat\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "mnist_save_path", ")", ":", "\n", "\t    ", "mnist_url", "=", "urllib", ".", "request", ".", "urlopen", "(", "mnist_alternative_url", ")", "\n", "with", "open", "(", "mnist_save_path", ",", "\"wb\"", ")", "as", "matlab_file", ":", "\n", "\t        ", "copyfileobj", "(", "mnist_url", ",", "matlab_file", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_isit.sp_func_svm.sp_frontend": [[9, 42], ["numpy.int", "images.copy", "range", "numpy.sqrt", "pywt.WaveletPacket2D", "numpy.floor().astype", "numpy.zeros", "range", "range", "pywt.WaveletPacket2D.reconstruct().astype", "wp.reconstruct().astype.flatten", "wp[].data.flatten", "numpy.argpartition", "coeffs[].reshape", "images[].reshape", "pywt.WaveletPacket2D.get_level", "numpy.floor", "numpy.abs", "pywt.WaveletPacket2D.reconstruct", "numpy.clip"], "function", ["None"], ["\n", "batch_size", "=", "images", ".", "shape", "[", "0", "]", "\n", "dim", "=", "images", ".", "shape", "[", "1", "]", "\n", "images_sp", "=", "images", ".", "copy", "(", ")", "\n", "\n", "coeffs", "=", "(", "0.5", "*", "images_sp", "+", "0.5", ")", "@", "psi", ".", "T", "\n", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "dim", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "dim", "-", "k", "\n", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ",", "axis", "=", "1", ")", "[", ":", ",", ":", "n", "]", "\n", "coeffs", "[", "np", ".", "arange", "(", "batch_size", ")", "[", ":", ",", "None", "]", ",", "indices", "]", "=", "0", "\n", "\n", "images_sp", "=", "2.0", "*", "np", ".", "clip", "(", "coeffs", "@", "psi", ",", "0.", ",", "1.", ")", ".", "reshape", "(", "[", "batch_size", ",", "dim", "]", ")", "-", "1.0", "\n", "\n", "return", "images_sp", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "", "def", "sp_project", "(", "x", ",", "w", ",", "rho", ",", "psi", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_isit.sp_func_svm.sp_project": [[43, 79], ["numpy.int", "pywt.WaveletPacket2D", "numpy.floor().astype", "numpy.zeros", "range", "pywt.WaveletPacket2D", "numpy.zeros", "range", "np.zeros.copy", "range", "pywt.WaveletPacket2D.reconstruct().astype().flatten", "numpy.sqrt", "wp[].data.flatten", "numpy.argpartition", "weights.reshape", "wp_w[].data.flatten", "coeffs_w_proj[].reshape", "image.reshape", "pywt.WaveletPacket2D.get_level", "numpy.floor", "numpy.abs", "pywt.WaveletPacket2D.get_level", "pywt.WaveletPacket2D.reconstruct().astype", "pywt.WaveletPacket2D.reconstruct"], "function", ["None"], ["\n", "images", "=", "x", ".", "copy", "(", ")", "\n", "weights", "=", "w", ".", "copy", "(", ")", "\n", "batch_size", "=", "images", ".", "shape", "[", "0", "]", "\n", "dim", "=", "images", ".", "shape", "[", "1", "]", "\n", "\n", "coeffs", "=", "(", "0.5", "*", "images", "+", "0.5", ")", "@", "psi", ".", "T", "\n", "coeffs_w", "=", "weights", "@", "psi", ".", "T", "\n", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "dim", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "dim", "-", "k", "\n", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ",", "axis", "=", "1", ")", "[", ":", ",", ":", "n", "]", "\n", "coeffs_w", "[", "np", ".", "arange", "(", "batch_size", ")", "[", ":", ",", "None", "]", ",", "indices", "]", "=", "0", "\n", "\n", "weights", "=", "(", "coeffs_w", "@", "psi", ")", ".", "reshape", "(", "[", "batch_size", ",", "dim", "]", ")", "\n", "\n", "return", "weights", ".", "astype", "(", "np", ".", "float32", ")", "", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_isit.mnist_workaround.fetch_mnist": [[11, 22], ["sklearn.datasets.base.get_data_home", "os.path.join", "os.path.join", "os.path.exists", "os.makedirs", "os.path.exists", "six.moves.urllib.request.urlopen", "open", "shutil.copyfileobj"], "function", ["None"], ["def", "fetch_mnist", "(", ")", ":", "\n", "\t", "mnist_alternative_url", "=", "\"https://github.com/amplab/datascience-sp14/raw/master/lab7/mldata/mnist-original.mat\"", "\n", "data_home", "=", "get_data_home", "(", ")", "\n", "data_home", "=", "os", ".", "path", ".", "join", "(", "data_home", ",", "'mldata'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "data_home", ")", ":", "\n", "\t    ", "os", ".", "makedirs", "(", "data_home", ")", "\n", "", "mnist_save_path", "=", "os", ".", "path", ".", "join", "(", "data_home", ",", "\"mnist-original.mat\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "mnist_save_path", ")", ":", "\n", "\t    ", "mnist_url", "=", "urllib", ".", "request", ".", "urlopen", "(", "mnist_alternative_url", ")", "\n", "with", "open", "(", "mnist_save_path", ",", "\"wb\"", ")", "as", "matlab_file", ":", "\n", "\t        ", "copyfileobj", "(", "mnist_url", ",", "matlab_file", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.DataSet.__init__": [[102, 139], ["tensorflow.python.framework.random_seed.get_seed", "numpy.random.seed", "tensorflow.python.framework.dtypes.as_dtype", "TypeError", "numpy.multiply.reshape", "numpy.multiply.astype", "numpy.multiply"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "\n", "images", ",", "\n", "labels", ",", "\n", "dtype", "=", "dtypes", ".", "float32", ",", "\n", "reshape", "=", "True", ",", "\n", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"Construct a DataSet.\n    one_hot arg is used only if fake_data is true.  `dtype` can be either\n    `uint8` to leave the input as `[0, 255]`, or `float32` to rescale into\n    `[0, 1]`.  Seed arg provides for convenient deterministic testing.\n    \"\"\"", "\n", "seed1", ",", "seed2", "=", "random_seed", ".", "get_seed", "(", "seed", ")", "\n", "# If op level seed is not set, use whatever graph level seed is returned", "\n", "numpy", ".", "random", ".", "seed", "(", "seed1", "if", "seed", "is", "None", "else", "seed2", ")", "\n", "dtype", "=", "dtypes", ".", "as_dtype", "(", "dtype", ")", ".", "base_dtype", "\n", "if", "dtype", "not", "in", "(", "dtypes", ".", "uint8", ",", "dtypes", ".", "float32", ")", ":", "\n", "      ", "raise", "TypeError", "(", "'Invalid image dtype %r, expected uint8 or float32'", "%", "\n", "dtype", ")", "\n", "\n", "", "assert", "images", ".", "shape", "[", "0", "]", "==", "labels", ".", "shape", "[", "0", "]", ",", "(", "\n", "'images.shape: %s labels.shape: %s'", "%", "(", "images", ".", "shape", ",", "labels", ".", "shape", ")", ")", "\n", "self", ".", "_num_examples", "=", "images", ".", "shape", "[", "0", "]", "\n", "\n", "# Convert shape from [num examples, rows, columns, depth]", "\n", "# to [num examples, rows*columns] (assuming depth == 1)", "\n", "if", "reshape", ":", "\n", "      ", "assert", "images", ".", "shape", "[", "3", "]", "==", "1", "\n", "images", "=", "images", ".", "reshape", "(", "images", ".", "shape", "[", "0", "]", ",", "\n", "images", ".", "shape", "[", "1", "]", "*", "images", ".", "shape", "[", "2", "]", ")", "\n", "", "if", "dtype", "==", "dtypes", ".", "float32", ":", "\n", "# Convert from [0, 255] -> [0.0, 1.0].", "\n", "      ", "images", "=", "images", ".", "astype", "(", "numpy", ".", "float32", ")", "\n", "images", "=", "numpy", ".", "multiply", "(", "images", ",", "1.0", "/", "255.0", ")", "\n", "", "self", ".", "_images", "=", "images", "\n", "self", ".", "_labels", "=", "labels", "\n", "self", ".", "_epochs_completed", "=", "0", "\n", "self", ".", "_index_in_epoch", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.DataSet.images": [[140, 143], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "images", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_images", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.DataSet.labels": [[144, 147], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "labels", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.DataSet.num_examples": [[148, 151], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_examples", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_num_examples", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.DataSet.epochs_completed": [[152, 155], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "epochs_completed", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_epochs_completed", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.DataSet.next_batch": [[156, 190], ["numpy.arange", "numpy.random.shuffle", "numpy.arange", "numpy.random.shuffle", "numpy.concatenate", "numpy.concatenate"], "methods", ["None"], ["", "def", "next_batch", "(", "self", ",", "batch_size", ",", "shuffle", "=", "True", ")", ":", "\n", "    ", "\"\"\"Return the next `batch_size` examples from this data set.\"\"\"", "\n", "start", "=", "self", ".", "_index_in_epoch", "\n", "# Shuffle for the first epoch", "\n", "if", "self", ".", "_epochs_completed", "==", "0", "and", "start", "==", "0", "and", "shuffle", ":", "\n", "      ", "perm0", "=", "numpy", ".", "arange", "(", "self", ".", "_num_examples", ")", "\n", "numpy", ".", "random", ".", "shuffle", "(", "perm0", ")", "\n", "self", ".", "_images", "=", "self", ".", "images", "[", "perm0", "]", "\n", "self", ".", "_labels", "=", "self", ".", "labels", "[", "perm0", "]", "\n", "# Go to the next epoch", "\n", "", "if", "start", "+", "batch_size", ">", "self", ".", "_num_examples", ":", "\n", "# Finished epoch", "\n", "      ", "self", ".", "_epochs_completed", "+=", "1", "\n", "# Get the rest examples in this epoch", "\n", "rest_num_examples", "=", "self", ".", "_num_examples", "-", "start", "\n", "images_rest_part", "=", "self", ".", "_images", "[", "start", ":", "self", ".", "_num_examples", "]", "\n", "labels_rest_part", "=", "self", ".", "_labels", "[", "start", ":", "self", ".", "_num_examples", "]", "\n", "# Shuffle the data", "\n", "if", "shuffle", ":", "\n", "        ", "perm", "=", "numpy", ".", "arange", "(", "self", ".", "_num_examples", ")", "\n", "numpy", ".", "random", ".", "shuffle", "(", "perm", ")", "\n", "self", ".", "_images", "=", "self", ".", "images", "[", "perm", "]", "\n", "self", ".", "_labels", "=", "self", ".", "labels", "[", "perm", "]", "\n", "# Start next epoch", "\n", "", "start", "=", "0", "\n", "self", ".", "_index_in_epoch", "=", "batch_size", "-", "rest_num_examples", "\n", "end", "=", "self", ".", "_index_in_epoch", "\n", "images_new_part", "=", "self", ".", "_images", "[", "start", ":", "end", "]", "\n", "labels_new_part", "=", "self", ".", "_labels", "[", "start", ":", "end", "]", "\n", "return", "numpy", ".", "concatenate", "(", "(", "images_rest_part", ",", "images_new_part", ")", ",", "axis", "=", "0", ")", ",", "numpy", ".", "concatenate", "(", "(", "labels_rest_part", ",", "labels_new_part", ")", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "_index_in_epoch", "+=", "batch_size", "\n", "end", "=", "self", ".", "_index_in_epoch", "\n", "return", "self", ".", "_images", "[", "start", ":", "end", "]", ",", "self", ".", "_labels", "[", "start", ":", "end", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair._read32": [[41, 44], ["numpy.dtype().newbyteorder", "numpy.frombuffer", "numpy.dtype", "bytestream.read"], "function", ["None"], ["def", "_read32", "(", "bytestream", ")", ":", "\n", "  ", "dt", "=", "numpy", ".", "dtype", "(", "numpy", ".", "uint32", ")", ".", "newbyteorder", "(", "'>'", ")", "\n", "return", "numpy", ".", "frombuffer", "(", "bytestream", ".", "read", "(", "4", ")", ",", "dtype", "=", "dt", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.extract_images": [[46, 72], ["gzip.GzipFile", "mnist_data_pair._read32", "mnist_data_pair._read32", "mnist_data_pair._read32", "mnist_data_pair._read32", "bytestream.read", "numpy.frombuffer", "data.reshape.reshape", "ValueError"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair._read32", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair._read32", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair._read32", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair._read32"], ["", "def", "extract_images", "(", "f", ")", ":", "\n", "  ", "\"\"\"Extract the images into a 4D uint8 numpy array [index, y, x, depth].\n\n  Args:\n    f: A file object that can be passed into a gzip reader.\n\n  Returns:\n    data: A 4D uint8 numpy array [index, y, x, depth].\n\n  Raises:\n    ValueError: If the bytestream does not start with 2051.\n\n  \"\"\"", "\n", "# print('Extracting', f.name)", "\n", "with", "gzip", ".", "GzipFile", "(", "fileobj", "=", "f", ")", "as", "bytestream", ":", "\n", "    ", "magic", "=", "_read32", "(", "bytestream", ")", "\n", "if", "magic", "!=", "2051", ":", "\n", "      ", "raise", "ValueError", "(", "'Invalid magic number %d in MNIST image file: %s'", "%", "\n", "(", "magic", ",", "f", ".", "name", ")", ")", "\n", "", "num_images", "=", "_read32", "(", "bytestream", ")", "\n", "rows", "=", "_read32", "(", "bytestream", ")", "\n", "cols", "=", "_read32", "(", "bytestream", ")", "\n", "buf", "=", "bytestream", ".", "read", "(", "rows", "*", "cols", "*", "num_images", ")", "\n", "data", "=", "numpy", ".", "frombuffer", "(", "buf", ",", "dtype", "=", "numpy", ".", "uint8", ")", "\n", "data", "=", "data", ".", "reshape", "(", "num_images", ",", "rows", ",", "cols", ",", "1", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.extract_labels": [[74, 98], ["gzip.GzipFile", "mnist_data_pair._read32", "mnist_data_pair._read32", "bytestream.read", "numpy.frombuffer", "ValueError"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair._read32", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair._read32"], ["", "", "def", "extract_labels", "(", "f", ",", "num_classes", "=", "10", ")", ":", "\n", "  ", "\"\"\"Extract the labels into a 1D uint8 numpy array [index].\n\n  Args:\n    f: A file object that can be passed into a gzip reader.\n    one_hot: Does one hot encoding for the result.\n    num_classes: Number of classes for the one hot encoding.\n\n  Returns:\n    labels: a 1D uint8 numpy array.\n\n  Raises:\n    ValueError: If the bystream doesn't start with 2049.\n  \"\"\"", "\n", "# print('Extracting', f.name)", "\n", "with", "gzip", ".", "GzipFile", "(", "fileobj", "=", "f", ")", "as", "bytestream", ":", "\n", "    ", "magic", "=", "_read32", "(", "bytestream", ")", "\n", "if", "magic", "!=", "2049", ":", "\n", "      ", "raise", "ValueError", "(", "'Invalid magic number %d in MNIST label file: %s'", "%", "\n", "(", "magic", ",", "f", ".", "name", ")", ")", "\n", "", "num_items", "=", "_read32", "(", "bytestream", ")", "\n", "buf", "=", "bytestream", ".", "read", "(", "num_items", ")", "\n", "labels", "=", "numpy", ".", "frombuffer", "(", "buf", ",", "dtype", "=", "numpy", ".", "uint8", ")", "\n", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.read_data_sets": [[192, 284], ["numpy.concatenate", "numpy.concatenate", "numpy.zeros", "numpy.ones", "numpy.arange", "numpy.random.RandomState", "numpy.random.RandomState.shuffle", "numpy.arange", "numpy.random.RandomState", "numpy.random.RandomState.shuffle", "numpy.int", "numpy.int", "numpy.int", "numpy.int", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.arange", "numpy.random.RandomState", "numpy.random.RandomState.shuffle", "numpy.arange", "numpy.random.RandomState", "numpy.random.RandomState.shuffle", "numpy.arange", "numpy.random.RandomState", "numpy.random.RandomState.shuffle", "dict", "mnist_data_pair.DataSet", "mnist_data_pair.DataSet", "mnist_data_pair.DataSet", "tensorflow.contrib.learn.python.learn.datasets.base.Datasets", "open", "mnist_data_pair.extract_images", "open", "mnist_data_pair.extract_labels", "open", "mnist_data_pair.extract_images", "open", "mnist_data_pair.extract_labels", "numpy.where", "numpy.where", "labels_1[].reshape", "labels_2[].reshape", "labels_1[].reshape", "labels_2[].reshape", "labels_1[].reshape", "labels_2[].reshape"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.extract_images", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.extract_labels", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.extract_images", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.mnist_data_pair.extract_labels"], ["", "", "", "def", "read_data_sets", "(", "train_dir", ",", "\n", "dtype", "=", "dtypes", ".", "float32", ",", "\n", "reshape", "=", "True", ",", "\n", "digit1", "=", "3", ",", "\n", "digit2", "=", "7", ",", "\n", "test_ratio", "=", "0.25", ",", "\n", "validation_ratio", "=", "0.1", ",", "\n", "seed", "=", "None", ")", ":", "\n", "\n", "  ", "TRAIN_IMAGES", "=", "'/train-images-idx3-ubyte.gz'", "\n", "TRAIN_LABELS", "=", "'/train-labels-idx1-ubyte.gz'", "\n", "TEST_IMAGES", "=", "'/t10k-images-idx3-ubyte.gz'", "\n", "TEST_LABELS", "=", "'/t10k-labels-idx1-ubyte.gz'", "\n", "\n", "# local_file = base.maybe_download(TRAIN_IMAGES, train_dir,", "\n", "# SOURCE_URL + TRAIN_IMAGES)", "\n", "with", "open", "(", "train_dir", "+", "TRAIN_IMAGES", ",", "'rb'", ")", "as", "f", ":", "\n", "    ", "train_images_all", "=", "extract_images", "(", "f", ")", "\n", "\n", "# local_file = base.maybe_download(TRAIN_LABELS, train_dir,", "\n", "# SOURCE_URL + TRAIN_LABELS)", "\n", "", "with", "open", "(", "train_dir", "+", "TRAIN_LABELS", ",", "'rb'", ")", "as", "f", ":", "\n", "    ", "train_labels_all", "=", "extract_labels", "(", "f", ")", "\n", "\n", "# local_file = base.maybe_download(TEST_IMAGES, train_dir,", "\n", "# SOURCE_URL + TEST_IMAGES)", "\n", "", "with", "open", "(", "train_dir", "+", "TEST_IMAGES", ",", "'rb'", ")", "as", "f", ":", "\n", "    ", "test_images_all", "=", "extract_images", "(", "f", ")", "\n", "\n", "# local_file = base.maybe_download(TEST_LABELS, train_dir,", "\n", "# SOURCE_URL + TEST_LABELS)", "\n", "", "with", "open", "(", "train_dir", "+", "TEST_LABELS", ",", "'rb'", ")", "as", "f", ":", "\n", "    ", "test_labels_all", "=", "extract_labels", "(", "f", ")", "\n", "\n", "", "images_all", "=", "numpy", ".", "concatenate", "(", "(", "train_images_all", ",", "test_images_all", ")", ")", "\n", "labels_all", "=", "numpy", ".", "concatenate", "(", "(", "train_labels_all", ",", "test_labels_all", ")", ")", "\n", "ind1", "=", "numpy", ".", "where", "(", "labels_all", "==", "digit1", ")", "[", "0", "]", "\n", "ind2", "=", "numpy", ".", "where", "(", "labels_all", "==", "digit2", ")", "[", "0", "]", "\n", "images_1", "=", "images_all", "[", "ind1", "]", "\n", "images_2", "=", "images_all", "[", "ind2", "]", "\n", "labels_1", "=", "numpy", ".", "zeros", "(", "[", "images_1", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "\n", "labels_2", "=", "numpy", ".", "ones", "(", "[", "images_2", ".", "shape", "[", "0", "]", ",", "2", "]", ")", "\n", "\n", "perm1", "=", "numpy", ".", "arange", "(", "images_1", ".", "shape", "[", "0", "]", ")", "\n", "prng1", "=", "RandomState", "(", "42", ")", "\n", "prng1", ".", "shuffle", "(", "perm1", ")", "\n", "images_1", "=", "images_1", "[", "perm1", "]", "\n", "labels_1", "=", "labels_1", "[", "perm1", "]", "\n", "\n", "perm2", "=", "numpy", ".", "arange", "(", "images_2", ".", "shape", "[", "0", "]", ")", "\n", "prng2", "=", "RandomState", "(", "43", ")", "\n", "prng2", ".", "shuffle", "(", "perm2", ")", "\n", "images_2", "=", "images_2", "[", "perm2", "]", "\n", "labels_2", "=", "labels_2", "[", "perm2", "]", "\n", "\n", "train_size_1", "=", "numpy", ".", "int", "(", "(", "1", "-", "test_ratio", ")", "*", "(", "1", "-", "validation_ratio", ")", "*", "images_1", ".", "shape", "[", "0", "]", ")", "\n", "train_size_2", "=", "numpy", ".", "int", "(", "(", "1", "-", "test_ratio", ")", "*", "(", "1", "-", "validation_ratio", ")", "*", "images_2", ".", "shape", "[", "0", "]", ")", "\n", "test_size_1", "=", "numpy", ".", "int", "(", "test_ratio", "*", "images_1", ".", "shape", "[", "0", "]", ")", "\n", "test_size_2", "=", "numpy", ".", "int", "(", "test_ratio", "*", "images_2", ".", "shape", "[", "0", "]", ")", "\n", "\n", "train_images", "=", "numpy", ".", "concatenate", "(", "(", "images_1", "[", ":", "train_size_1", "]", ",", "images_2", "[", ":", "train_size_2", "]", ")", ")", "\n", "train_labels", "=", "numpy", ".", "concatenate", "(", "(", "labels_1", "[", ":", "train_size_1", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "labels_2", "[", ":", "train_size_2", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ")", ")", "\n", "validation_images", "=", "numpy", ".", "concatenate", "(", "(", "images_1", "[", "train_size_1", ":", "-", "test_size_1", "]", ",", "images_2", "[", "train_size_2", ":", "-", "test_size_2", "]", ")", ")", "\n", "validation_labels", "=", "numpy", ".", "concatenate", "(", "(", "labels_1", "[", "train_size_1", ":", "-", "test_size_1", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "labels_2", "[", "train_size_2", ":", "-", "test_size_2", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ")", ")", "\n", "test_images", "=", "numpy", ".", "concatenate", "(", "(", "images_1", "[", "-", "test_size_1", ":", "]", ",", "images_2", "[", "-", "test_size_2", ":", "]", ")", ")", "\n", "test_labels", "=", "numpy", ".", "concatenate", "(", "(", "labels_1", "[", "-", "test_size_1", ":", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "labels_2", "[", "-", "test_size_2", ":", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ")", ")", "\n", "\n", "perm3", "=", "numpy", ".", "arange", "(", "train_images", ".", "shape", "[", "0", "]", ")", "\n", "prng", "=", "RandomState", "(", "44", ")", "\n", "prng", ".", "shuffle", "(", "perm3", ")", "\n", "train_images", "=", "train_images", "[", "perm3", "]", "\n", "train_labels", "=", "train_labels", "[", "perm3", "]", "\n", "\n", "perm4", "=", "numpy", ".", "arange", "(", "test_images", ".", "shape", "[", "0", "]", ")", "\n", "prng", "=", "RandomState", "(", "45", ")", "\n", "prng", ".", "shuffle", "(", "perm4", ")", "\n", "test_images", "=", "test_images", "[", "perm4", "]", "\n", "test_labels", "=", "test_labels", "[", "perm4", "]", "\n", "\n", "perm5", "=", "numpy", ".", "arange", "(", "validation_images", ".", "shape", "[", "0", "]", ")", "\n", "prng", "=", "RandomState", "(", "46", ")", "\n", "prng", ".", "shuffle", "(", "perm5", ")", "\n", "validation_images", "=", "validation_images", "[", "perm5", "]", "\n", "validation_labels", "=", "validation_labels", "[", "perm5", "]", "\n", "\n", "options", "=", "dict", "(", "dtype", "=", "dtype", ",", "reshape", "=", "reshape", ",", "seed", "=", "seed", ")", "\n", "\n", "train", "=", "DataSet", "(", "train_images", ",", "train_labels", ",", "**", "options", ")", "\n", "validation", "=", "DataSet", "(", "validation_images", ",", "validation_labels", ",", "**", "options", ")", "\n", "test", "=", "DataSet", "(", "test_images", ",", "test_labels", ",", "**", "options", ")", "\n", "\n", "return", "base", ".", "Datasets", "(", "train", "=", "train", ",", "validation", "=", "validation", ",", "test", "=", "test", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.FourLayerModel.__init__": [[12, 19], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "def_params", ")", ":", "\n", "        ", "self", ".", "layer_names", "=", "[", "'layer1'", ",", "'layer2'", ",", "'layer3'", ",", "'layer4'", ",", "'logits'", "]", "\n", "self", ".", "nb_classes", "=", "10", "\n", "self", ".", "num_channels", "=", "1", "\n", "self", ".", "image_size", "=", "28", "\n", "self", ".", "num_labels", "=", "10", "\n", "self", ".", "def_params", "=", "def_params", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.FourLayerModel.fprop": [[20, 25], ["sp_func_nn.tf_sp_frontend", "tensorflow.reshape", "models.four_layer_cnn"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.tf_sp_frontend", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.test_defense_cnn.four_layer_cnn"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "tf_sp_frontend", "(", "x", ",", "**", "self", ".", "def_params", ")", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", ",", "self", ".", "image_size", ",", "self", ".", "image_size", ",", "self", ".", "num_channels", "]", ")", "\n", "_", ",", "end_points", "=", "four_layer_cnn", "(", "x", ",", "phase", "=", "False", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", "\n", "return", "end_points", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.FourLayerModel.predict": [[26, 28], ["models.FourLayerModel.fprop"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.test_defense_cnn.FourLayerModel.fprop"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "fprop", "(", "x", ")", "[", "'logits'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.FourLayerModelPlain.__init__": [[34, 40], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "layer_names", "=", "[", "'layer1'", ",", "'layer2'", ",", "'layer3'", ",", "'layer4'", ",", "'logits'", "]", "\n", "self", ".", "nb_classes", "=", "10", "\n", "self", ".", "num_channels", "=", "1", "\n", "self", ".", "image_size", "=", "28", "\n", "self", ".", "num_labels", "=", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.FourLayerModelPlain.fprop": [[41, 44], ["models.four_layer_cnn"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.test_defense_cnn.four_layer_cnn"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "        ", "_", ",", "end_points", "=", "four_layer_cnn", "(", "x", ",", "phase", "=", "False", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", "\n", "return", "end_points", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.FourLayerModelPlain.predict": [[45, 47], ["models.FourLayerModelPlain.fprop"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.test_defense_cnn.FourLayerModel.fprop"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "fprop", "(", "x", ")", "[", "'logits'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.TwoLayerModel.__init__": [[53, 57], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "def_params", ")", ":", "\n", "        ", "self", ".", "layer_names", "=", "[", "'layer1'", ",", "'logits'", "]", "\n", "self", ".", "def_params", "=", "def_params", "\n", "self", ".", "dim", "=", "784", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.TwoLayerModel.fprop": [[58, 63], ["sp_func_nn.tf_sp_frontend_binary", "tensorflow.reshape", "models.two_layer_nn"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.tf_sp_frontend_binary", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.two_layer_nn"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "tf_sp_frontend_binary", "(", "x", ",", "**", "self", ".", "def_params", ")", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", ",", "self", ".", "dim", "]", ")", "\n", "_", ",", "end_points", "=", "two_layer_nn", "(", "x", ",", "phase", "=", "False", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", "\n", "return", "end_points", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.TwoLayerModelPlain.__init__": [[69, 71], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "layer_names", "=", "[", "'layer1'", ",", "'logits'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.TwoLayerModelPlain.fprop": [[72, 75], ["models.two_layer_nn"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.two_layer_nn"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "        ", "_", ",", "end_points", "=", "two_layer_nn", "(", "x", ",", "phase", "=", "False", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", "\n", "return", "end_points", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.four_layer_cnn": [[77, 114], ["tensorflow.variable_scope", "tensorflow.contrib.slim.conv2d", "tensorflow.contrib.slim.max_pool2d", "tensorflow.contrib.slim.conv2d", "tensorflow.contrib.slim.max_pool2d", "tensorflow.reshape", "tensorflow.contrib.slim.fully_connected", "tensorflow.contrib.slim.dropout", "tensorflow.contrib.slim.fully_connected", "tensorflow.contrib.slim.dropout", "tensorflow.contrib.slim.fully_connected", "tensorflow.contrib.slim.dropout"], "function", ["None"], ["", "", "def", "four_layer_cnn", "(", "inputs", ",", "phase", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ",", "scope", "=", "'four_layer_cnn'", ")", ":", "\n", "    ", "\"\"\"\n    Four layer CNN from http://neuralnetworksanddeeplearning.com/chap6.html/. \n    TensorFlow-Slim implementation adapted from https://github.com/initialized/tensorflow-tutorial/.\n\n    Layer 1: Convolutional, with a 5x5 receptive field and 20 feature maps. \n    Layer 2: Convolutional, with a 5x5 receptive field and 40 feature maps.\n    Layer 3: Fully connected, with 1000 neurons.\n    Layer 4: Fully connected, with 1000 neurons.\n\n    inputs - Should be of shape [num_samples, 28, 28, 1].\n    phase  - If TRUE, dropout is switched on in layers 3 and 4.\n    \"\"\"", "\n", "end_points", "=", "{", "}", "\n", "with", "tf", ".", "variable_scope", "(", "scope", ",", "reuse", "=", "reuse", ")", ":", "\n", "        ", "net", "=", "slim", ".", "conv2d", "(", "inputs", ",", "20", ",", "[", "5", ",", "5", "]", ",", "padding", "=", "'SAME'", ",", "scope", "=", "'layer1-conv'", ")", "\n", "net", "=", "slim", ".", "max_pool2d", "(", "net", ",", "2", ",", "stride", "=", "2", ",", "scope", "=", "'layer1-max-pool'", ")", "\n", "end_points", "[", "'layer1'", "]", "=", "net", "\n", "\n", "net", "=", "slim", ".", "conv2d", "(", "net", ",", "40", ",", "[", "5", ",", "5", "]", ",", "padding", "=", "'VALID'", ",", "scope", "=", "'layer2-conv'", ")", "\n", "net", "=", "slim", ".", "max_pool2d", "(", "net", ",", "2", ",", "stride", "=", "2", ",", "scope", "=", "'layer2-max-pool'", ")", "\n", "net", "=", "tf", ".", "reshape", "(", "net", ",", "[", "-", "1", ",", "5", "*", "5", "*", "40", "]", ")", "\n", "end_points", "[", "'layer2'", "]", "=", "net", "\n", "\n", "net", "=", "slim", ".", "fully_connected", "(", "net", ",", "1000", ",", "scope", "=", "'layer3'", ")", "\n", "net", "=", "slim", ".", "dropout", "(", "net", ",", "is_training", "=", "phase", ",", "scope", "=", "'layer3-dropout'", ")", "\n", "end_points", "[", "'layer3'", "]", "=", "net", "\n", "\n", "net", "=", "slim", ".", "fully_connected", "(", "net", ",", "1000", ",", "scope", "=", "'layer4'", ")", "\n", "net", "=", "slim", ".", "dropout", "(", "net", ",", "is_training", "=", "phase", ",", "scope", "=", "'layer4-dropout'", ")", "\n", "end_points", "[", "'layer4'", "]", "=", "net", "\n", "\n", "net", "=", "slim", ".", "fully_connected", "(", "net", ",", "10", ",", "scope", "=", "'logits'", ",", "activation_fn", "=", "None", ")", "\n", "logits", "=", "slim", ".", "dropout", "(", "net", ",", "is_training", "=", "phase", ",", "scope", "=", "'logits-dropout'", ")", "\n", "end_points", "[", "'logits'", "]", "=", "logits", "\n", "\n", "return", "logits", ",", "end_points", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.models.two_layer_nn": [[115, 133], ["tensorflow.variable_scope", "tensorflow.contrib.slim.arg_scope", "tensorflow.contrib.slim.fully_connected", "tensorflow.contrib.slim.fully_connected", "tensorflow.contrib.slim.l2_regularizer"], "function", ["None"], ["", "", "def", "two_layer_nn", "(", "inputs", ",", "phase", ",", "reuse", "=", "None", ",", "scope", "=", "'two_layer_nn'", ")", ":", "\n", "    ", "\"\"\"\n    Fully connected NN with 1 hidden layer (10 neurons) for binary classif.\n    \"\"\"", "\n", "end_points", "=", "{", "}", "\n", "with", "tf", ".", "variable_scope", "(", "scope", ",", "reuse", "=", "reuse", ")", ":", "\n", "# Set the default weight _regularizer and activation for each fully_connected layer.", "\n", "        ", "with", "slim", ".", "arg_scope", "(", "[", "slim", ".", "fully_connected", "]", ",", "\n", "weights_regularizer", "=", "slim", ".", "l2_regularizer", "(", "0.001", ")", ")", ":", "\n", "# First layer: 10x1", "\n", "            ", "net", "=", "slim", ".", "fully_connected", "(", "inputs", ",", "10", ",", "scope", "=", "'layer1'", ")", "\n", "end_points", "[", "'layer1'", "]", "=", "net", "\n", "\n", "# Output layer: 1x1", "\n", "logits", "=", "slim", ".", "fully_connected", "(", "net", ",", "1", ",", "scope", "=", "'logits'", ",", "activation_fn", "=", "None", ")", "\n", "end_points", "[", "'logits'", "]", "=", "logits", "\n", "\n", "return", "logits", ",", "end_points", "", "", "", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.sp_frontend": [[9, 37], ["images.copy", "numpy.floor().astype", "numpy.clip().reshape", "np.clip().reshape.astype", "np.clip().reshape.reshape", "numpy.argpartition", "numpy.floor", "numpy.abs", "numpy.clip", "numpy.arange"], "function", ["None"], ["def", "sp_frontend", "(", "images", ",", "rho", ",", "psi", ")", ":", "\n", "    ", "\"\"\"\n    Sparsifies images in the wavelet basis and returns reconstruction.\n\n    Inputs:\n        images - Numpy array of shape [batch_size, num_features, num_features, 1] and in the range [0, 1] \n        rho    - Sparsity level in the range [0, 1]\n        psi    - Orthonormal basis to sparsify in. Numpy array of shape \n                 [num_features*num_features, num_features*num_features]\n\n    Output:\n        images_sp - Sparsified images. Numpy array of same shape as images\n    \"\"\"", "\n", "batch_size", "=", "images", ".", "shape", "[", "0", "]", "\n", "num_features", "=", "images", ".", "shape", "[", "1", "]", "\n", "dim", "=", "num_features", "*", "num_features", "\n", "images_sp", "=", "images", ".", "copy", "(", ")", "\n", "\n", "coeffs", "=", "images_sp", ".", "reshape", "(", "[", "batch_size", ",", "dim", "]", ")", "@", "psi", ".", "T", "\n", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "dim", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "dim", "-", "k", "\n", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ",", "axis", "=", "1", ")", "[", ":", ",", ":", "n", "]", "\n", "coeffs", "[", "np", ".", "arange", "(", "batch_size", ")", "[", ":", ",", "None", "]", ",", "indices", "]", "=", "0", "\n", "\n", "images_sp", "=", "np", ".", "clip", "(", "coeffs", "@", "psi", ",", "0.", ",", "1.", ")", ".", "reshape", "(", "[", "batch_size", ",", "num_features", ",", "num_features", ",", "1", "]", ")", "\n", "\n", "return", "images_sp", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.sp_project": [[38, 69], ["x.copy", "w.copy", "numpy.floor().astype", "w.copy.astype", "x.copy.reshape", "w.copy.reshape", "numpy.argpartition", "numpy.floor", "numpy.abs", "numpy.arange"], "function", ["None"], ["", "def", "sp_project", "(", "x", ",", "w", ",", "rho", ",", "psi", ")", ":", "\n", "    ", "\"\"\"\n    Projects w onto the top rho% of the support of x (in the wavelet basis).\n\n    Inputs:\n        x   - Numpy array of shape [batch_size, num_features, num_features, 1] and in the range [0, 1] \n        w   - Numpy array of same shape as x\n        rho - Sparsity level in the range [0, 1]\n        psi - Orthonormal basis to sparsify in. Numpy array of shape \n              [num_features*num_features, num_features*num_features]\n\n    Output:\n        weights - Projected version of w. Same shape as w\n    \"\"\"", "\n", "images", "=", "x", ".", "copy", "(", ")", "\n", "weights", "=", "w", ".", "copy", "(", ")", "\n", "batch_size", "=", "images", ".", "shape", "[", "0", "]", "\n", "num_features", "=", "images", ".", "shape", "[", "1", "]", "\n", "dim", "=", "num_features", "*", "num_features", "\n", "\n", "coeffs", "=", "images", ".", "reshape", "(", "[", "batch_size", ",", "dim", "]", ")", "@", "psi", ".", "T", "\n", "coeffs_w", "=", "weights", ".", "reshape", "(", "[", "batch_size", ",", "dim", "]", ")", "@", "psi", ".", "T", "\n", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "dim", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "dim", "-", "k", "\n", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ",", "axis", "=", "1", ")", "[", ":", ",", ":", "n", "]", "\n", "coeffs_w", "[", "np", ".", "arange", "(", "batch_size", ")", "[", ":", ",", "None", "]", ",", "indices", "]", "=", "0", "\n", "\n", "weights", "=", "(", "coeffs_w", "@", "psi", ")", ".", "reshape", "(", "[", "batch_size", ",", "num_features", ",", "num_features", ",", "1", "]", ")", "\n", "\n", "return", "weights", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.py_func": [[70, 81], ["tensorflow.get_default_graph", "str", "tensorflow.RegisterGradient", "tf.get_default_graph.gradient_override_map", "tensorflow.py_func", "numpy.random.randint", "sp_func_nn.sp_frontend", "sp_func_nn.sp_frontend_binary"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.py_func", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.sp_func_cnn.sp_frontend", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.sp_frontend_binary"], ["", "def", "py_func", "(", "func", ",", "inp", ",", "Tout", ",", "stateful", "=", "True", ",", "name", "=", "None", ",", "grad", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    tf.py_func with custom gradient\n    \"\"\"", "\n", "# Need to generate a unique name to avoid duplicates:", "\n", "rnd_name", "=", "'PyFuncGrad'", "+", "str", "(", "np", ".", "random", ".", "randint", "(", "0", ",", "1E+8", ")", ")", "\n", "\n", "tf", ".", "RegisterGradient", "(", "rnd_name", ")", "(", "grad", ")", "\n", "g", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "with", "g", ".", "gradient_override_map", "(", "{", "\"PyFunc\"", ":", "rnd_name", "}", ")", ":", "\n", "        ", "return", "tf", ".", "py_func", "(", "func", ",", "inp", ",", "Tout", ",", "stateful", "=", "stateful", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.grad_sp_frontend": [[82, 89], ["None"], "function", ["None"], ["", "", "def", "grad_sp_frontend", "(", "op", ",", "grad", ")", ":", "\n", "    ", "\"\"\"\n    Returns the propagated gradient with respect to the first, second and third \n    argument of tf_sp_frontend.\n    Uses BPDA of 1 for gradient of front end.\n    \"\"\"", "\n", "return", "[", "grad", ",", "None", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.tf_sp_frontend": [[90, 101], ["tensorflow.name_scope", "sp_func_nn.py_func"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.py_func"], ["", "def", "tf_sp_frontend", "(", "images", ",", "rho", ",", "psi", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    tf.py_func version of sp_frontend\n    \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "None", ",", "\"mod\"", ",", "[", "images", ",", "rho", ",", "psi", "]", ")", "as", "name", ":", "\n", "        ", "z", "=", "py_func", "(", "sp_frontend", ",", "\n", "[", "images", ",", "rho", ",", "psi", "]", ",", "\n", "[", "tf", ".", "float32", "]", ",", "\n", "name", "=", "name", ",", "\n", "grad", "=", "grad_sp_frontend", ")", "# <-- here's the call to the gradient", "\n", "return", "z", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.sp_frontend_binary": [[106, 132], ["images.copy", "numpy.floor().astype", "numpy.clip", "np.clip.astype", "numpy.argpartition", "numpy.floor", "numpy.abs", "numpy.arange"], "function", ["None"], ["", "", "def", "sp_frontend_binary", "(", "images", ",", "rho", ",", "psi", ")", ":", "\n", "    ", "\"\"\"\n    Sparsifies images in the wavelet basis and returns reconstruction.\n\n    Inputs:\n        images - Numpy array of shape [batch_size, dim] and in the range [0, 1] \n        rho    - Sparsity level in the range [0, 1]\n        psi    - Orthonormal basis to sparsify in. Numpy array of shape [dim, dim]\n\n    Output:\n        images_sp - Sparsified images. Numpy array of same shape as images\n    \"\"\"", "\n", "batch_size", "=", "images", ".", "shape", "[", "0", "]", "\n", "dim", "=", "images", ".", "shape", "[", "1", "]", "\n", "images_sp", "=", "images", ".", "copy", "(", ")", "\n", "\n", "coeffs", "=", "images_sp", "@", "psi", ".", "T", "\n", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "dim", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "dim", "-", "k", "\n", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ",", "axis", "=", "1", ")", "[", ":", ",", ":", "n", "]", "\n", "coeffs", "[", "np", ".", "arange", "(", "batch_size", ")", "[", ":", ",", "None", "]", ",", "indices", "]", "=", "0", "\n", "\n", "images_sp", "=", "np", ".", "clip", "(", "coeffs", "@", "psi", ",", "0.", ",", "1.", ")", "\n", "\n", "return", "images_sp", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.sp_project_binary": [[133, 162], ["x.copy", "w.copy", "numpy.floor().astype", "w.copy.astype", "numpy.argpartition", "numpy.floor", "numpy.abs", "numpy.arange"], "function", ["None"], ["", "def", "sp_project_binary", "(", "x", ",", "w", ",", "rho", ",", "psi", ")", ":", "\n", "    ", "\"\"\"\n    Projects w onto the top rho% of the support of x (in the wavelet basis).\n\n    Inputs:\n        x   - Numpy array of shape [batch_size, dim] and in the range [0, 1] \n        w   - Numpy array of same shape as x\n        rho - Sparsity level in the range [0, 1]\n        psi - Orthonormal basis to sparsify in. Numpy array of shape [dim, dim]\n\n    Output:\n        weights - Projected version of w. Same shape as w\n    \"\"\"", "\n", "images", "=", "x", ".", "copy", "(", ")", "\n", "weights", "=", "w", ".", "copy", "(", ")", "\n", "batch_size", "=", "images", ".", "shape", "[", "0", "]", "\n", "dim", "=", "images", ".", "shape", "[", "1", "]", "\n", "\n", "coeffs", "=", "images", "@", "psi", ".", "T", "\n", "coeffs_w", "=", "weights", "@", "psi", ".", "T", "\n", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "dim", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "dim", "-", "k", "\n", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ",", "axis", "=", "1", ")", "[", ":", ",", ":", "n", "]", "\n", "coeffs_w", "[", "np", ".", "arange", "(", "batch_size", ")", "[", ":", ",", "None", "]", ",", "indices", "]", "=", "0", "\n", "\n", "weights", "=", "coeffs_w", "@", "psi", "\n", "\n", "return", "weights", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.grad_sp_frontend_binary": [[163, 170], ["None"], "function", ["None"], ["", "def", "grad_sp_frontend_binary", "(", "op", ",", "grad", ")", ":", "\n", "    ", "\"\"\"\n    Returns the propagated gradient with respect to the first, second and third \n    argument of tf_sp_frontend_binary.\n    Uses BPDA of 1 for gradient of front end.\n    \"\"\"", "\n", "return", "[", "grad", ",", "None", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.tf_sp_frontend_binary": [[171, 182], ["tensorflow.name_scope", "sp_func_nn.py_func"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.py_func"], ["", "def", "tf_sp_frontend_binary", "(", "images", ",", "rho", ",", "psi", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    tf.py_func version of sp_frontend_binary\n    \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "None", ",", "\"mod\"", ",", "[", "images", ",", "rho", ",", "psi", "]", ")", "as", "name", ":", "\n", "        ", "z", "=", "py_func", "(", "sp_frontend_binary", ",", "\n", "[", "images", ",", "rho", ",", "psi", "]", ",", "\n", "[", "tf", ".", "float32", "]", ",", "\n", "name", "=", "name", ",", "\n", "grad", "=", "grad_sp_frontend_binary", ")", "# <-- here's the call to the gradient", "\n", "return", "z", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.LocLinearAttack.__init__": [[18, 30], ["isinstance", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", ")", ":", "\n", "        ", "\"\"\"\n        Inputs:\n            model   - An instance of the cleverhans.model.Model class.\n            sess    - The tf.Session to run graphs in.\n        \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'The model argument should be an instance of the cleverhans.model.Model class.'", ")", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "sess", "=", "sess", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.LocLinearAttack.run": [[31, 99], ["tensorflow.placeholder", "attacks.LocLinearAttack.model.get_logits", "x.copy", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.argmax", "range", "range", "range", "range", "range", "tensorflow.placeholder", "tensorflow.gradients", "numpy.clip", "numpy.zeros.argmax", "numpy.int", "tqdm.tqdm.tqdm", "tqdm.tqdm.tqdm", "range", "attacks.LocLinearAttack.sess.run", "slice", "attacks.LocLinearAttack.sess.run", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run"], ["", "def", "run", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "eps", "=", "0.2", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, num_rows, num_cols, num_channels]\n            y           - True labels, one-hot encoded. Must be a Numpy array of shape\n                          [num_images, num_classes]\n            eps         - L-inf budget for the attack.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n        \"\"\"", "\n", "\n", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "\n", "num_classes", "=", "y", ".", "shape", "[", "1", "]", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "x_adv_t", "=", "np", ".", "zeros", "(", "[", "num_classes", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "weq_t", "=", "np", ".", "zeros", "(", "[", "num_classes", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "logits_t", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "num_classes", "]", ")", "\n", "labels", "=", "np", ".", "argmax", "(", "y", ",", "axis", "=", "1", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "seq_images", "=", "range", "(", "num_images", ")", "\n", "seq_targets", "=", "range", "(", "num_classes", ")", "\n", "seq_images_2", "=", "range", "(", "num_images", ")", "\n", "seq_targets_2", "=", "range", "(", "num_classes", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_targets", "=", "tqdm", "(", "seq_targets", ")", "\n", "seq_targets_2", "=", "tqdm", "(", "seq_targets_2", ")", "\n", "\n", "", "t_", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "shape", "=", "(", ")", ")", "\n", "grad_t", ",", "=", "tf", ".", "gradients", "(", "logits", "[", ":", ",", "t_", "]", ",", "x_inp", ")", "\n", "\n", "for", "t", "in", "seq_targets", ":", "\n", "            ", "for", "i", "in", "seq_batches", ":", "\n", "                ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq_t", "[", "t", ",", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad_t", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv", "[", "batch", "]", ",", "t_", ":", "t", "}", ")", "\n", "\n", "", "", "for", "i", "in", "seq_images", ":", "\n", "            ", "l", "=", "labels", "[", "i", "]", "\n", "for", "t", "in", "range", "(", "num_classes", ")", ":", "\n", "                ", "x_adv_t", "[", "t", ",", "i", "]", "=", "x", "[", "i", "]", "+", "eps", "*", "np", ".", "sign", "(", "weq_t", "[", "t", ",", "i", "]", "-", "weq_t", "[", "l", ",", "i", "]", ")", "\n", "", "", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "for", "t", "in", "seq_targets_2", ":", "\n", "            ", "logits_all", "=", "self", ".", "sess", ".", "run", "(", "logits", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv_t", "[", "t", "]", "}", ")", "\n", "logits_t", "[", ":", ",", "t", "]", "=", "logits_all", "[", ":", ",", "t", "]", "\n", "for", "i", "in", "seq_images", ":", "\n", "                ", "l", "=", "labels", "[", "i", "]", "\n", "logits_t", "[", "i", ",", "t", "]", "-=", "logits_all", "[", "i", ",", "l", "]", "\n", "logits_t", "[", "i", ",", "l", "]", "=", "-", "np", ".", "inf", "\n", "\n", "", "", "targets", "=", "logits_t", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "for", "i", "in", "seq_images_2", ":", "\n", "            ", "x_adv", "[", "i", "]", "=", "x_adv_t", "[", "targets", "[", "i", "]", ",", "i", "]", "\n", "\n", "", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.LocLinearAttack.run_proj": [[100, 185], ["tensorflow.placeholder", "attacks.LocLinearAttack.model.get_logits", "x.copy", "numpy.tile", "numpy.zeros", "numpy.zeros", "numpy.argmax", "range", "range", "range", "range", "tensorflow.placeholder", "tensorflow.gradients", "numpy.clip", "numpy.zeros", "tqdm.tqdm.tqdm", "numpy.zeros.argmax", "numpy.int", "tqdm.tqdm.tqdm", "range", "range", "range", "numpy.clip", "tqdm.tqdm.tqdm", "attacks.LocLinearAttack.sess.run", "slice", "attacks.LocLinearAttack.sess.run", "sp_func_nn.sp_project", "range", "numpy.sign", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.sp_func_cnn.sp_project"], ["", "def", "run_proj", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "niter_proj", ",", "\n", "def_params", ",", "\n", "eps", "=", "0.2", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        LocLinearAttack with iterated projections for gradient of front end\n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, num_rows, num_cols, num_channels]\n            y           - True labels, one-hot encoded. Must be a Numpy array of shape\n                          [num_images, num_classes]\n            niter_proj  - No of iterations for projection refinement\n            def_params  - Defense parameters to pass to sp_project\n            eps         - L-inf budget for the attack.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n        \"\"\"", "\n", "\n", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "\n", "num_classes", "=", "y", ".", "shape", "[", "1", "]", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "x_adv_t", "=", "np", ".", "tile", "(", "x", "[", "None", ",", "...", "]", ",", "[", "num_classes", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "# x_adv_t = np.zeros([num_classes, num_images, num_rows, num_cols, num_channels])", "\n", "weq_t", "=", "np", ".", "zeros", "(", "[", "num_classes", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "logits_t", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "num_classes", "]", ")", "\n", "labels", "=", "np", ".", "argmax", "(", "y", ",", "axis", "=", "1", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "seq_images", "=", "range", "(", "num_images", ")", "\n", "seq_targets", "=", "range", "(", "num_classes", ")", "\n", "seq_targets_2", "=", "range", "(", "num_classes", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_targets", "=", "tqdm", "(", "seq_targets", ")", "\n", "\n", "", "t_", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "shape", "=", "(", ")", ")", "\n", "grad_t", ",", "=", "tf", ".", "gradients", "(", "logits", "[", ":", ",", "t_", "]", ",", "x_inp", ")", "\n", "\n", "for", "t", "in", "seq_targets", ":", "\n", "            ", "for", "i", "in", "seq_batches", ":", "\n", "                ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq_t", "[", "t", ",", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad_t", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv", "[", "batch", "]", ",", "t_", ":", "t", "}", ")", "\n", "\n", "", "", "for", "i", "in", "seq_images", ":", "\n", "            ", "l", "=", "labels", "[", "i", "]", "\n", "for", "t", "in", "range", "(", "num_classes", ")", ":", "\n", "                ", "x_adv_t", "[", "t", ",", "i", "]", "=", "x", "[", "i", "]", "+", "eps", "*", "np", ".", "sign", "(", "weq_t", "[", "t", ",", "i", "]", "-", "weq_t", "[", "l", ",", "i", "]", ")", "\n", "", "", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "weq_t_proj", "=", "np", ".", "zeros", "(", "[", "num_classes", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "niter_proj", ")", ")", ":", "\n", "            ", "for", "t", "in", "range", "(", "num_classes", ")", ":", "\n", "                ", "weq_t_proj", "[", "t", "]", "=", "sp_project", "(", "x_adv_t", "[", "t", "]", ",", "weq_t", "[", "t", "]", ",", "**", "def_params", ")", "\n", "", "for", "i", "in", "seq_images", ":", "\n", "                ", "l", "=", "labels", "[", "i", "]", "\n", "for", "t", "in", "range", "(", "num_classes", ")", ":", "\n", "                    ", "x_adv_t", "[", "t", ",", "i", "]", "=", "x", "[", "i", "]", "+", "eps", "*", "np", ".", "sign", "(", "weq_t_proj", "[", "t", ",", "i", "]", "-", "weq_t_proj", "[", "l", ",", "i", "]", ")", "\n", "", "", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "if", "progress", "is", "True", ":", "\n", "            ", "seq_targets_2", "=", "tqdm", "(", "seq_targets_2", ")", "\n", "", "for", "t", "in", "seq_targets_2", ":", "\n", "            ", "logits_all", "=", "self", ".", "sess", ".", "run", "(", "logits", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv_t", "[", "t", "]", "}", ")", "\n", "logits_t", "[", ":", ",", "t", "]", "=", "logits_all", "[", ":", ",", "t", "]", "\n", "for", "i", "in", "seq_images", ":", "\n", "                ", "l", "=", "labels", "[", "i", "]", "\n", "logits_t", "[", "i", ",", "t", "]", "-=", "logits_all", "[", "i", ",", "l", "]", "\n", "logits_t", "[", "i", ",", "l", "]", "=", "-", "np", ".", "inf", "\n", "\n", "", "", "targets", "=", "logits_t", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "for", "i", "in", "seq_images", ":", "\n", "            ", "x_adv", "[", "i", "]", "=", "x_adv_t", "[", "targets", "[", "i", "]", ",", "i", "]", "\n", "\n", "", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.LocLinearAttack.run_binary": [[186, 231], ["tensorflow.placeholder", "attacks.LocLinearAttack.model.get_logits", "tensorflow.gradients", "range", "numpy.zeros", "numpy.clip", "numpy.int", "tqdm.tqdm.tqdm", "slice", "attacks.LocLinearAttack.sess.run", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run"], ["", "def", "run_binary", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "eps", "=", "0.2", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        LocLinearAttack for binary (sigmoid) classification with fully connected layers\n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, dim]\n            y           - True labels, either 0 or 1. Must be a Numpy array of shape\n                          [num_images]\n            eps         - L-inf budget for the attack.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n        \"\"\"", "\n", "\n", "num_images", ",", "dim", "=", "x", ".", "shape", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "dim", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "grad", ",", "=", "tf", ".", "gradients", "(", "logits", ",", "x_inp", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_batches", "=", "tqdm", "(", "seq_batches", ")", "\n", "\n", "", "weq", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "dim", "]", ")", "\n", "for", "i", "in", "seq_batches", ":", "\n", "            ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad", ",", "feed_dict", "=", "{", "x_inp", ":", "x", "[", "batch", "]", "}", ")", "\n", "\n", "# weq = self.sess.run(grad, feed_dict={x_inp: x})", "\n", "\n", "", "sgn_y", "=", "1.0", "-", "2.0", "*", "y", "\n", "# sgn_y = - np.sign(2.0*y - 1.0)", "\n", "x_adv", "=", "x", "+", "eps", "*", "np", ".", "sign", "(", "weq", ")", "*", "sgn_y", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.LocLinearAttack.run_binary_proj": [[232, 287], ["tensorflow.placeholder", "attacks.LocLinearAttack.model.get_logits", "tensorflow.gradients", "range", "numpy.zeros", "numpy.clip", "tqdm.tqdm.tqdm", "numpy.int", "tqdm.tqdm.tqdm", "slice", "attacks.LocLinearAttack.sess.run", "range", "sp_func_nn.sp_project_binary", "numpy.clip", "numpy.sign", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.sp_project_binary"], ["", "def", "run_binary_proj", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "niter_proj", ",", "\n", "def_params", ",", "\n", "eps", "=", "0.2", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        LocLinearAttack for binary (sigmoid) classification with fully connected layers, \n        using iterated projections for gradient of front end\n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, dim]\n            y           - True labels, either 0 or 1. Must be a Numpy array of shape\n                          [num_images]\n            niter_proj  - No of iterations for projection refinement\n            def_params  - Defense parameters to pass to sp_project\n            eps         - L-inf budget for the attack.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n        \"\"\"", "\n", "\n", "num_images", ",", "dim", "=", "x", ".", "shape", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "dim", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "grad", ",", "=", "tf", ".", "gradients", "(", "logits", ",", "x_inp", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_batches", "=", "tqdm", "(", "seq_batches", ")", "\n", "\n", "", "weq", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "dim", "]", ")", "\n", "for", "i", "in", "seq_batches", ":", "\n", "            ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad", ",", "feed_dict", "=", "{", "x_inp", ":", "x", "[", "batch", "]", "}", ")", "\n", "\n", "# weq = self.sess.run(grad, feed_dict={x_inp: x})", "\n", "\n", "", "sgn_y", "=", "1.0", "-", "2.0", "*", "y", "\n", "\n", "x_adv", "=", "x", "+", "eps", "*", "np", ".", "sign", "(", "weq", ")", "*", "sgn_y", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "niter_proj", ")", ")", ":", "\n", "            ", "weq_proj", "=", "sp_project_binary", "(", "x_adv", ",", "weq", ",", "**", "def_params", ")", "\n", "x_adv", "=", "x", "+", "eps", "*", "np", ".", "sign", "(", "weq_proj", ")", "*", "sgn_y", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.__init__": [[297, 309], ["isinstance", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", ")", ":", "\n", "        ", "\"\"\"\n        Inputs:\n            model   - An instance of the cleverhans.model.Model class.\n            sess    - The tf.Session to run graphs in.\n        \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'The model argument should be an instance of the cleverhans.model.Model class.'", ")", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "sess", "=", "sess", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run": [[310, 404], ["tensorflow.placeholder", "attacks.IterLocLinearAttack.model.get_logits", "x.copy", "range", "x.copy", "numpy.tile", "numpy.tile.copy", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.argmax", "range", "range", "range", "range", "range", "tensorflow.placeholder", "tensorflow.gradients", "numpy.zeros.argmax", "numpy.int", "tqdm.tqdm.tqdm", "range", "numpy.clip", "numpy.clip", "tqdm.tqdm.tqdm", "tqdm.tqdm.tqdm", "range", "range", "slice", "attacks.IterLocLinearAttack.sess.run", "range", "slice", "attacks.IterLocLinearAttack.sess.run", "numpy.sign", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run"], ["", "def", "run", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "eps", "=", "0.2", ",", "\n", "delta", "=", "0.01", ",", "\n", "niter", "=", "1000", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, num_rows, num_cols, num_channels]\n            y           - True labels, one-hot encoded. Must be a Numpy array of shape\n                          [num_images, num_classes]\n            eps         - Overall L-inf budget for the attack.\n            delta       - L-inf budget for each attack iteration.\n            niter       - Number of attack iterations.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n        \"\"\"", "\n", "\n", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "\n", "num_classes", "=", "y", ".", "shape", "[", "1", "]", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "x_tiled", "=", "np", ".", "tile", "(", "x", "[", "None", ",", "...", "]", ",", "[", "num_classes", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "x_adv_t", "=", "x_tiled", ".", "copy", "(", ")", "\n", "weq_t", "=", "np", ".", "zeros", "(", "[", "num_classes", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "logits_all", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "num_classes", "]", ")", "\n", "logits_t", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "num_classes", "]", ")", "\n", "labels", "=", "np", ".", "argmax", "(", "y", ",", "axis", "=", "1", ")", "\n", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "seq_images", "=", "range", "(", "num_images", ")", "\n", "seq_targets", "=", "range", "(", "num_classes", ")", "\n", "seq_targets_2", "=", "range", "(", "num_classes", ")", "\n", "\n", "t_", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "shape", "=", "(", ")", ")", "\n", "grad_t", ",", "=", "tf", ".", "gradients", "(", "logits", "[", ":", ",", "t_", "]", ",", "x_inp", ")", "\n", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_niter", "=", "tqdm", "(", "seq_niter", ")", "\n", "\n", "", "for", "n", "in", "seq_niter", ":", "\n", "            ", "if", "progress", "is", "True", ":", "\n", "                ", "seq_targets", "=", "tqdm", "(", "range", "(", "num_classes", ")", ")", "\n", "\n", "", "for", "t", "in", "seq_targets", ":", "\n", "# grad_t, = tf.gradients(logits[:, t], x_inp)", "\n", "                ", "for", "i", "in", "seq_batches", ":", "\n", "                    ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq_t", "[", "t", ",", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad_t", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv_t", "[", "t", ",", "batch", "]", ",", "t_", ":", "t", "}", ")", "\n", "\n", "", "", "for", "i", "in", "seq_images", ":", "\n", "                ", "l", "=", "labels", "[", "i", "]", "\n", "for", "t", "in", "range", "(", "num_classes", ")", ":", "\n", "                    ", "x_adv_t", "[", "t", ",", "i", "]", "+=", "delta", "*", "np", ".", "sign", "(", "weq_t", "[", "t", ",", "i", "]", "-", "weq_t", "[", "l", ",", "i", "]", ")", "\n", "\n", "", "", "for", "t", "in", "range", "(", "num_classes", ")", ":", "\n", "                ", "for", "i", "in", "seq_images", ":", "\n", "                    ", "l", "=", "labels", "[", "i", "]", "\n", "x_adv_t", "[", "t", ",", "i", "]", "+=", "delta", "*", "np", ".", "sign", "(", "weq_t", "[", "t", ",", "i", "]", "-", "weq_t", "[", "l", ",", "i", "]", ")", "\n", "\n", "", "", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "x_tiled", "-", "eps", ",", "x_tiled", "+", "eps", ")", "\n", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "if", "progress", "is", "True", ":", "\n", "            ", "seq_targets_2", "=", "tqdm", "(", "range", "(", "num_classes", ")", ")", "\n", "\n", "", "for", "t", "in", "seq_targets_2", ":", "\n", "            ", "for", "i", "in", "seq_batches", ":", "\n", "                ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "logits_all", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "logits", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv_t", "[", "t", ",", "batch", "]", "}", ")", "\n", "", "logits_t", "[", ":", ",", "t", "]", "=", "logits_all", "[", ":", ",", "t", "]", "\n", "for", "i", "in", "seq_images", ":", "\n", "                ", "l", "=", "labels", "[", "i", "]", "\n", "logits_t", "[", "i", ",", "t", "]", "-=", "logits_all", "[", "i", ",", "l", "]", "\n", "logits_t", "[", "i", ",", "l", "]", "=", "-", "np", ".", "inf", "\n", "\n", "", "", "targets", "=", "logits_t", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "for", "i", "in", "seq_images", ":", "\n", "            ", "x_adv", "[", "i", "]", "=", "x_adv_t", "[", "targets", "[", "i", "]", ",", "i", "]", "\n", "\n", "", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run_proj": [[405, 507], ["tensorflow.placeholder", "attacks.IterLocLinearAttack.model.get_logits", "x.copy", "range", "x.copy", "numpy.tile", "numpy.tile.copy", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.argmax", "range", "range", "range", "range", "range", "range", "tensorflow.placeholder", "tensorflow.gradients", "numpy.zeros", "numpy.zeros.argmax", "numpy.int", "tqdm.tqdm.tqdm", "numpy.clip.copy", "tqdm.tqdm.tqdm", "numpy.clip", "numpy.clip", "tqdm.tqdm.tqdm", "tqdm.tqdm.tqdm", "range", "range", "range", "tqdm.tqdm.tqdm", "numpy.clip", "numpy.clip", "range", "slice", "attacks.IterLocLinearAttack.sess.run", "slice", "attacks.IterLocLinearAttack.sess.run", "range", "sp_func_nn.sp_project", "range", "numpy.sign", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.sp_func_cnn.sp_project"], ["", "def", "run_proj", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "niter_proj", ",", "\n", "def_params", ",", "\n", "eps", "=", "0.2", ",", "\n", "delta", "=", "0.01", ",", "\n", "niter", "=", "1000", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        IterLocLinearAttack with iterated projections for gradient of front end\n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, num_rows, num_cols, num_channels]\n            y           - True labels, one-hot encoded. Must be a Numpy array of shape\n                          [num_images, num_classes]\n            niter_proj  - No of iterations for projection refinement\n            def_params  - Defense parameters to pass to sp_project\n            eps         - L-inf budget for the attack.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n        \"\"\"", "\n", "\n", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "\n", "num_classes", "=", "y", ".", "shape", "[", "1", "]", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "x_tiled", "=", "np", ".", "tile", "(", "x", "[", "None", ",", "...", "]", ",", "[", "num_classes", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "x_adv_t", "=", "x_tiled", ".", "copy", "(", ")", "\n", "weq_t", "=", "np", ".", "zeros", "(", "[", "num_classes", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "logits_all", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "num_classes", "]", ")", "\n", "logits_t", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "num_classes", "]", ")", "\n", "labels", "=", "np", ".", "argmax", "(", "y", ",", "axis", "=", "1", ")", "\n", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "seq_images", "=", "range", "(", "num_images", ")", "\n", "seq_targets", "=", "range", "(", "num_classes", ")", "\n", "seq_images_2", "=", "range", "(", "num_images", ")", "\n", "seq_targets_2", "=", "range", "(", "num_classes", ")", "\n", "\n", "t_", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "shape", "=", "(", ")", ")", "\n", "grad_t", ",", "=", "tf", ".", "gradients", "(", "logits", "[", ":", ",", "t_", "]", ",", "x_inp", ")", "\n", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_niter", "=", "tqdm", "(", "seq_niter", ")", "\n", "\n", "", "weq_t_proj", "=", "np", ".", "zeros", "(", "[", "num_classes", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "for", "n", "in", "seq_niter", ":", "\n", "            ", "x_adv_t_current", "=", "x_adv_t", ".", "copy", "(", ")", "\n", "\n", "for", "t", "in", "tqdm", "(", "range", "(", "num_classes", ")", ")", ":", "\n", "                ", "for", "i", "in", "seq_batches", ":", "\n", "                    ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq_t", "[", "t", ",", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad_t", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv_t", "[", "t", ",", "batch", "]", ",", "t_", ":", "t", "}", ")", "\n", "\n", "", "", "for", "i", "in", "seq_images", ":", "\n", "                ", "l", "=", "labels", "[", "i", "]", "\n", "for", "t", "in", "range", "(", "num_classes", ")", ":", "\n", "                    ", "x_adv_t", "[", "t", ",", "i", "]", "+=", "delta", "*", "np", ".", "sign", "(", "weq_t", "[", "t", ",", "i", "]", "-", "weq_t", "[", "l", ",", "i", "]", ")", "\n", "", "", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "x_tiled", "-", "eps", ",", "x_tiled", "+", "eps", ")", "\n", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "niter_proj", ")", ")", ":", "\n", "                ", "for", "t", "in", "tqdm", "(", "range", "(", "num_classes", ")", ")", ":", "\n", "                    ", "weq_t_proj", "[", "t", "]", "=", "sp_project", "(", "x_adv_t", "[", "t", "]", ",", "weq_t", "[", "t", "]", ",", "**", "def_params", ")", "\n", "", "for", "i", "in", "seq_images", ":", "\n", "                    ", "l", "=", "labels", "[", "i", "]", "\n", "for", "t", "in", "range", "(", "num_classes", ")", ":", "\n", "                        ", "x_adv_t", "[", "t", ",", "i", "]", "=", "x_adv_t_current", "[", "t", ",", "i", "]", "+", "delta", "*", "np", ".", "sign", "(", "weq_t_proj", "[", "t", ",", "i", "]", "-", "weq_t_proj", "[", "l", ",", "i", "]", ")", "\n", "", "", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "x_tiled", "-", "eps", ",", "x_tiled", "+", "eps", ")", "\n", "x_adv_t", "=", "np", ".", "clip", "(", "x_adv_t", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "", "if", "progress", "is", "True", ":", "\n", "            ", "seq_targets_2", "=", "tqdm", "(", "range", "(", "num_classes", ")", ")", "\n", "\n", "", "for", "t", "in", "seq_targets_2", ":", "\n", "            ", "for", "i", "in", "seq_batches", ":", "\n", "                ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "logits_all", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "logits", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv_t", "[", "t", ",", "batch", "]", "}", ")", "\n", "", "logits_t", "[", ":", ",", "t", "]", "=", "logits_all", "[", ":", ",", "t", "]", "\n", "for", "i", "in", "seq_images", ":", "\n", "                ", "l", "=", "labels", "[", "i", "]", "\n", "logits_t", "[", "i", ",", "t", "]", "-=", "logits_all", "[", "i", ",", "l", "]", "\n", "logits_t", "[", "i", ",", "l", "]", "=", "-", "np", ".", "inf", "\n", "\n", "", "", "targets", "=", "logits_t", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "for", "i", "in", "seq_images_2", ":", "\n", "            ", "x_adv", "[", "i", "]", "=", "x_adv_t", "[", "targets", "[", "i", "]", ",", "i", "]", "\n", "\n", "", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run_debug_single": [[508, 556], ["tensorflow.placeholder", "attacks.IterLocLinearAttack.model.get_logits", "tensorflow.gradients", "tensorflow.gradients", "x.copy", "numpy.zeros", "numpy.zeros", "trange", "attacks.IterLocLinearAttack.sess.run", "numpy.clip", "numpy.clip", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run"], ["", "def", "run_debug_single", "(", "self", ",", "x", ",", "num_classes", ",", "l", ",", "t", ",", "eps", "=", "0.2", ",", "\n", "delta", "=", "0.01", ",", "\n", "niter", "=", "1000", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ")", ":", "\n", "        ", "\"\"\"\n        Debug mode - works with a single image and target label\n\n        Inputs:\n            x           - Image to be perturbed. Must be a Numpy array of shape \n                          [1, num_rows, num_cols, num_channels]\n            num_classes - Number of classes\n            l           - Source label. Must be in the range [0, num_classes-1]\n            t           - Target label. Must be in the range [0, num_classes-1]           \n            eps         - Overall L-inf budget for the attack.\n            delta       - L-inf budget for each attack iteration.\n            niter       - Number of attack iterations.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n            logits_iter - Contains history of logit values after each iteration. \n                          Numpy array of size [niter, num_classes]\n            e_iter      - Contains history of attacks after each iteration.\n                          Numpy array of size [niter, 1, num_rows, num_cols, num_channels]\n        \"\"\"", "\n", "\n", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "[", "1", ":", "]", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "1", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "grad_t", ",", "=", "tf", ".", "gradients", "(", "logits", "[", ":", ",", "t", "]", ",", "x_inp", ")", "\n", "grad_l", ",", "=", "tf", ".", "gradients", "(", "logits", "[", ":", ",", "l", "]", ",", "x_inp", ")", "\n", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "logits_iter", "=", "np", ".", "zeros", "(", "niter", ",", "num_classes", ")", "\n", "e_iter", "=", "np", ".", "zeros", "(", "niter", ",", "1", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", "\n", "\n", "for", "n", "in", "trange", "(", "niter", ")", ":", "\n", "            ", "weq_t", ",", "weq_l", ",", "logits_iter", "[", "n", "]", "=", "self", ".", "sess", ".", "run", "(", "[", "grad_t", ",", "weq_l", ",", "grad_l", "]", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv", "}", ")", "\n", "x_adv", "+=", "delta", "*", "np", ".", "sign", "(", "weq_t", "-", "weq_l", ")", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "x", "-", "eps", ",", "x", "+", "eps", ")", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "e_iter", "[", "n", "]", "=", "x_adv", "-", "x", "\n", "\n", "", "return", "x_adv", ",", "logits_iter", ",", "e_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run_binary": [[557, 608], ["tensorflow.placeholder", "attacks.IterLocLinearAttack.model.get_logits", "tensorflow.gradients", "range", "range", "numpy.zeros", "x.copy", "numpy.int", "tqdm.tqdm.tqdm", "numpy.clip", "numpy.clip", "slice", "attacks.IterLocLinearAttack.sess.run", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run"], ["", "def", "run_binary", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "eps", "=", "0.2", ",", "\n", "delta", "=", "0.01", ",", "\n", "niter", "=", "1000", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        IterLocLinearAttack for binary (sigmoid) classification with fully connected layers\n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, dim]\n            y           - True labels, binarized. Must be a Numpy array of shape\n                          [num_images]\n            eps         - Overall L-inf budget for the attack.\n            delta       - L-inf budget for each attack iteration.\n            niter       - Number of attack iterations.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n        \"\"\"", "\n", "\n", "num_images", ",", "dim", "=", "x", ".", "shape", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "dim", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "grad", ",", "=", "tf", ".", "gradients", "(", "logits", ",", "x_inp", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_niter", "=", "tqdm", "(", "seq_niter", ")", "\n", "\n", "", "weq", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "dim", "]", ")", "\n", "\n", "sgn_y", "=", "1.0", "-", "2.0", "*", "y", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "for", "n", "in", "seq_niter", ":", "\n", "            ", "for", "i", "in", "seq_batches", ":", "\n", "                ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv", "[", "batch", "]", "}", ")", "\n", "\n", "", "x_adv", "+=", "delta", "*", "np", ".", "sign", "(", "weq", ")", "*", "sgn_y", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "x", "-", "eps", ",", "x", "+", "eps", ")", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run_binary_proj": [[609, 679], ["tensorflow.placeholder", "attacks.IterLocLinearAttack.model.get_logits", "tensorflow.gradients", "range", "range", "numpy.zeros", "x.copy", "numpy.clip", "numpy.clip", "numpy.int", "tqdm.tqdm.tqdm", "slice", "attacks.IterLocLinearAttack.sess.run", "numpy.clip.copy", "numpy.clip", "numpy.clip", "tqdm.tqdm.tqdm", "numpy.sign", "slice", "attacks.IterLocLinearAttack.sess.run", "range", "sp_func_nn.sp_project_binary", "numpy.clip", "numpy.clip", "numpy.sign", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.sp_project_binary"], ["", "def", "run_binary_proj", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "niter_proj", ",", "\n", "def_params", ",", "\n", "eps", "=", "0.2", ",", "\n", "delta", "=", "0.01", ",", "\n", "niter", "=", "1000", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        IterLocLinearAttack for binary (sigmoid) classification with fully connected layers, \n        using iterated projections for gradient of front end\n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, dim]\n            y           - True labels, binarized. Must be a Numpy array of shape\n                          [num_images]\n            niter_proj  - No of iterations for projection refinement\n            def_params  - Defense parameters to pass to sp_project\n            eps         - Overall L-inf budget for the attack.\n            delta       - L-inf budget for each attack iteration.\n            niter       - Number of attack iterations.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_adv       - Perturbed image. Numpy array of same shape as x.\n        \"\"\"", "\n", "\n", "num_images", ",", "dim", "=", "x", ".", "shape", "\n", "\n", "# Create graph", "\n", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "dim", ")", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "grad", ",", "=", "tf", ".", "gradients", "(", "logits", ",", "x_inp", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_niter", "=", "tqdm", "(", "seq_niter", ")", "\n", "\n", "", "weq", "=", "np", ".", "zeros", "(", "[", "num_images", ",", "dim", "]", ")", "\n", "\n", "sgn_y", "=", "1.0", "-", "2.0", "*", "y", "\n", "x_adv", "=", "x", ".", "copy", "(", ")", "\n", "\n", "for", "i", "in", "seq_batches", ":", "\n", "            ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv", "[", "batch", "]", "}", ")", "\n", "", "x_adv", "+=", "delta", "*", "np", ".", "sign", "(", "weq", ")", "*", "sgn_y", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "x", "-", "eps", ",", "x", "+", "eps", ")", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "for", "n", "in", "seq_niter", ":", "\n", "            ", "x_adv_current", "=", "x_adv", ".", "copy", "(", ")", "\n", "for", "i", "in", "seq_batches", ":", "\n", "                ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "weq", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "grad", ",", "feed_dict", "=", "{", "x_inp", ":", "x_adv", "[", "batch", "]", "}", ")", "\n", "", "x_adv", "=", "x_adv_current", "+", "delta", "*", "np", ".", "sign", "(", "weq", ")", "*", "sgn_y", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "x", "-", "eps", ",", "x", "+", "eps", ")", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "niter_proj", ")", ")", ":", "\n", "                ", "weq_proj", "=", "sp_project_binary", "(", "x_adv", ",", "weq", ",", "**", "def_params", ")", "\n", "x_adv", "=", "x_adv_current", "+", "delta", "*", "np", ".", "sign", "(", "weq", ")", "*", "sgn_y", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "x", "-", "eps", ",", "x", "+", "eps", ")", "\n", "x_adv", "=", "np", ".", "clip", "(", "x_adv", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.FGSMAttack.__init__": [[685, 697], ["isinstance", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", ")", ":", "\n", "        ", "\"\"\"\n        Inputs:\n            model   - An instance of the cleverhans.model.Model class.\n            sess    - The tf.Session to run graphs in.\n        \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'The model argument should be an instance of the cleverhans.model.Model class.'", ")", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "sess", "=", "sess", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.FGSMAttack.run_proj": [[698, 757], ["tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.stop_gradient", "attacks.FGSMAttack.model.get_logits", "tensorflow.nn.softmax_cross_entropy_with_logits_v2", "tensorflow.gradients", "x.copy", "range", "ValueError", "numpy.int", "tqdm.tqdm.tqdm", "slice", "attacks.FGSMAttack.sess.run", "numpy.clip", "tqdm.tqdm.tqdm", "range", "sp_func_nn.sp_project", "numpy.clip", "numpy.sign", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.sp_func_cnn.sp_project"], ["", "def", "run_proj", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "niter_proj", ",", "\n", "def_params", ",", "\n", "eps", "=", "0.2", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        FGSM with iterated projections for gradient of front end\n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, num_rows, num_cols, num_channels]\n            y           - True labels, one-hot encoded. Must be a Numpy array of shape\n                          [num_images, num_classes]\n            batch_size  - Number of attacks to run simultaneously.\n            niter_proj  - No of iterations for projection refinement\n            def_params  - Defense parameters to pass to sp_project\n            eps         - Overall L-inf budget for the attack.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_pgd   - Perturbed images. Numpy array of same shape as x.\n\n        \"\"\"", "\n", "\n", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "\n", "num_classes", "=", "y", ".", "shape", "[", "1", "]", "\n", "\n", "if", "num_images", "%", "batch_size", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Batch size must be a submultiple of data size'", ")", "\n", "\n", "# Create graph", "\n", "", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "batch_size", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "y_true", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "batch_size", ",", "num_classes", ")", ")", "\n", "y_true", "=", "tf", ".", "stop_gradient", "(", "y_true", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "loss", "=", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits_v2", "(", "logits", "=", "logits", ",", "labels", "=", "y_true", ")", "\n", "gradient", ",", "=", "tf", ".", "gradients", "(", "loss", ",", "x_inp", ")", "\n", "\n", "x_fgsm", "=", "x", ".", "copy", "(", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_batches", "=", "tqdm", "(", "seq_batches", ")", "\n", "\n", "", "for", "i", "in", "seq_batches", ":", "\n", "            ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "grad_batch", "=", "self", ".", "sess", ".", "run", "(", "gradient", ",", "feed_dict", "=", "{", "x_inp", ":", "x_fgsm", "[", "batch", "]", ",", "\n", "y_true", ":", "y", "[", "batch", "]", "}", ")", "\n", "x_fgsm", "[", "batch", "]", "=", "x", "[", "batch", "]", "+", "eps", "*", "np", ".", "sign", "(", "grad_batch", ")", "\n", "x_fgsm", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_fgsm", "[", "batch", "]", ",", "clip_min", ",", "clip_max", ")", "\n", "for", "n", "in", "tqdm", "(", "range", "(", "niter_proj", ")", ")", ":", "\n", "                ", "grad_batch_proj", "=", "sp_project", "(", "x_fgsm", "[", "batch", "]", ",", "grad_batch", ",", "**", "def_params", ")", "\n", "x_fgsm", "[", "batch", "]", "=", "x", "[", "batch", "]", "+", "eps", "*", "np", ".", "sign", "(", "grad_batch_proj", ")", "\n", "x_fgsm", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_fgsm", "[", "batch", "]", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "", "return", "x_fgsm", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.PGDAttack.__init__": [[763, 775], ["isinstance", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", ")", ":", "\n", "        ", "\"\"\"\n        Inputs:\n            model   - An instance of the cleverhans.model.Model class.\n            sess    - The tf.Session to run graphs in.\n        \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'The model argument should be an instance of the cleverhans.model.Model class.'", ")", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "sess", "=", "sess", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.PGDAttack.run_multiple": [[776, 873], ["tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.stop_gradient", "attacks.PGDAttack.model.get_logits", "tensorflow.nn.softmax_cross_entropy_with_logits_v2", "tensorflow.gradients", "numpy.tile", "numpy.tile", "numpy.random.RandomState", "numpy.clip", "range", "range", "x_pgd.reshape.reshape.reshape", "ValueError", "ValueError", "numpy.random.RandomState.uniform", "numpy.int", "tqdm.tqdm.tqdm", "slice", "tensorflow.equal", "range", "numpy.zeros", "preds.reshape.reshape.reshape", "print", "tqdm.tqdm.tqdm", "attacks.PGDAttack.sess.run", "numpy.clip", "numpy.clip", "tensorflow.argmax", "tensorflow.argmax", "numpy.int", "slice", "attacks.PGDAttack.sess.run", "preds.reshape.reshape.min().mean", "range", "numpy.sign", "preds.reshape.reshape.min"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run"], ["", "def", "run_multiple", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "\n", "num_runs", "=", "100", ",", "\n", "eps", "=", "0.2", ",", "\n", "delta", "=", "0.05", ",", "\n", "niter", "=", "100", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "rand_init", "=", "True", ",", "\n", "rand_seed", "=", "None", ",", "\n", "progress", "=", "True", ",", "\n", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Run multiple runs of PGD with different random initializations, and report the \n        accuracy over the most successful run(s) for *each* image.\n\n        For a faster attack, set batch_size > num_images. Note that batch_size needs to \n        be a submultiple of num_runs*num_images. \n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, num_rows, num_cols, num_channels].\n            y           - True labels, one-hot encoded. Must be a Numpy array of shape\n                          [num_images, num_classes].\n            batch_size  - Number of attacks to run simultaneously. This must be a \n                          submultiple of num_images*num_runs.\n            num_runs    - Number of runs with different random initializations.\n            eps         - Overall L-inf budget for the attack.\n            delta       - L-inf budget for each attack iteration.\n            niter       - Number of attack iterations.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            rand_init   - Whether to use random initialization.\n            rand_seed   - Seed for random number generator.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_pgd       - Perturbed images. Numpy array of shape\n                          [num_runs, num_images, num_rows, num_cols, num_channels]\n\n        \"\"\"", "\n", "\n", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "\n", "num_classes", "=", "y", ".", "shape", "[", "1", "]", "\n", "\n", "if", "(", "num_images", "*", "num_runs", ")", "%", "batch_size", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Batch size must be a submultiple of num_images*num_runs '", ")", "\n", "\n", "", "if", "rand_init", "is", "False", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot run multiple runs without random initialization'", ")", "\n", "\n", "# Create graph", "\n", "", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "y_true", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "num_classes", ")", ")", "\n", "y_true", "=", "tf", ".", "stop_gradient", "(", "y_true", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "loss", "=", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits_v2", "(", "logits", "=", "logits", ",", "labels", "=", "y_true", ")", "\n", "gradient", ",", "=", "tf", ".", "gradients", "(", "loss", ",", "x_inp", ")", "\n", "\n", "x_tiled", "=", "np", ".", "tile", "(", "x", ",", "[", "num_runs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "y_tiled", "=", "np", ".", "tile", "(", "y", ",", "[", "num_runs", ",", "1", "]", ")", "\n", "\n", "rng", "=", "RandomState", "(", "rand_seed", ")", "\n", "x_pgd", "=", "x_tiled", "+", "rng", ".", "uniform", "(", "low", "=", "-", "eps", ",", "high", "=", "eps", ",", "size", "=", "x_tiled", ".", "shape", ")", "\n", "x_pgd", "=", "np", ".", "clip", "(", "x_pgd", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "*", "num_runs", "/", "batch_size", ")", ")", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_batches", "=", "tqdm", "(", "seq_batches", ")", "\n", "", "for", "i", "in", "seq_batches", ":", "\n", "            ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "if", "progress", "is", "True", ":", "\n", "                ", "seq_niter", "=", "tqdm", "(", "range", "(", "niter", ")", ")", "\n", "", "for", "n", "in", "seq_niter", ":", "\n", "                ", "grad_batch", "=", "self", ".", "sess", ".", "run", "(", "gradient", ",", "feed_dict", "=", "{", "x_inp", ":", "x_pgd", "[", "batch", "]", ",", "\n", "y_true", ":", "y_tiled", "[", "batch", "]", "}", ")", "\n", "x_pgd", "[", "batch", "]", "+=", "delta", "*", "np", ".", "sign", "(", "grad_batch", ")", "\n", "x_pgd", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_pgd", "[", "batch", "]", ",", "x_tiled", "[", "batch", "]", "-", "eps", ",", "x_tiled", "[", "batch", "]", "+", "eps", ")", "\n", "x_pgd", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_pgd", "[", "batch", "]", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "", "if", "verbose", "is", "True", ":", "\n", "            ", "correct_prediction", "=", "tf", ".", "equal", "(", "tf", ".", "argmax", "(", "logits", ",", "1", ")", ",", "tf", ".", "argmax", "(", "y_true", ",", "1", ")", ")", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "*", "num_runs", "/", "batch_size", ")", ")", "\n", "preds", "=", "np", ".", "zeros", "(", "[", "num_runs", "*", "num_images", "]", ")", "\n", "for", "i", "in", "seq_batches", ":", "\n", "                ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "preds", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "correct_prediction", ",", "\n", "feed_dict", "=", "{", "x_inp", ":", "x_pgd", "[", "batch", "]", ",", "\n", "y_true", ":", "y_tiled", "[", "batch", "]", "}", ")", "\n", "", "preds", "=", "preds", ".", "reshape", "(", "[", "num_runs", ",", "num_images", "]", ")", "\n", "acc", "=", "100", "*", "preds", ".", "min", "(", "axis", "=", "0", ")", ".", "mean", "(", ")", "\n", "print", "(", "'PGD accuracy: {:.2f}%\\n'", ".", "format", "(", "acc", ")", ")", "\n", "\n", "", "x_pgd", "=", "x_pgd", ".", "reshape", "(", "[", "num_runs", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "\n", "return", "x_pgd", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.PGDAttack.run_multiple_proj": [[874, 976], ["tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.stop_gradient", "attacks.PGDAttack.model.get_logits", "tensorflow.nn.softmax_cross_entropy_with_logits_v2", "tensorflow.gradients", "numpy.tile", "numpy.tile", "numpy.random.RandomState", "numpy.clip", "range", "range", "x_pgd.reshape.reshape.copy", "x_pgd.reshape.reshape.reshape", "ValueError", "ValueError", "numpy.random.RandomState.uniform", "numpy.int", "tqdm.tqdm.tqdm", "slice", "tensorflow.equal", "range", "numpy.zeros", "preds.reshape.reshape.reshape", "print", "tqdm.tqdm.tqdm", "x_pgd[].copy", "attacks.PGDAttack.sess.run", "numpy.clip", "numpy.clip", "tqdm.tqdm.tqdm", "tensorflow.argmax", "tensorflow.argmax", "numpy.int", "slice", "attacks.PGDAttack.sess.run", "preds.reshape.reshape.min().mean", "range", "numpy.sign", "range", "sp_func_nn.sp_project", "numpy.clip", "numpy.clip", "preds.reshape.reshape.min", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.sp_func_cnn.sp_project"], ["", "def", "run_multiple_proj", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "niter_proj", ",", "def_params", ",", "\n", "num_runs", "=", "100", ",", "\n", "eps", "=", "0.2", ",", "\n", "delta", "=", "0.05", ",", "\n", "niter", "=", "100", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "rand_init", "=", "True", ",", "\n", "rand_seed", "=", "None", ",", "\n", "progress", "=", "True", ",", "\n", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        PGD with multiple random restarts, using iterated projections for gradient of front end\n\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, num_rows, num_cols, num_channels]\n            y           - True labels, one-hot encoded. Must be a Numpy array of shape\n                          [num_images, num_classes]\n            batch_size  - Number of attacks to run simultaneously.\n            niter_proj  - No of iterations for projection refinement\n            def_params  - Defense parameters to pass to sp_project\n            num_runs    - Number of runs with different random initializations\n            eps         - Overall L-inf budget for the attack.\n            delta       - L-inf budget for each attack iteration.\n            niter       - Number of attack iterations.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            rand_init   - Whether to use random initialization.\n            rand_seed   - Seed for random number generator.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_pgd       - Perturbed images. Numpy array of shape\n                          [num_images, num_rows, num_cols, num_channels]\n\n        \"\"\"", "\n", "\n", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "\n", "num_classes", "=", "y", ".", "shape", "[", "1", "]", "\n", "\n", "if", "(", "num_images", "*", "num_runs", ")", "%", "batch_size", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Batch size must be a submultiple of num_images*num_runs '", ")", "\n", "\n", "", "if", "rand_init", "is", "False", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot run multiple runs without random initialization'", ")", "\n", "\n", "# Create graph", "\n", "", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "y_true", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "num_classes", ")", ")", "\n", "y_true", "=", "tf", ".", "stop_gradient", "(", "y_true", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "loss", "=", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits_v2", "(", "logits", "=", "logits", ",", "labels", "=", "y_true", ")", "\n", "gradient", ",", "=", "tf", ".", "gradients", "(", "loss", ",", "x_inp", ")", "\n", "\n", "x_tiled", "=", "np", ".", "tile", "(", "x", ",", "[", "num_runs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "y_tiled", "=", "np", ".", "tile", "(", "y", ",", "[", "num_runs", ",", "1", "]", ")", "\n", "\n", "rng", "=", "RandomState", "(", "rand_seed", ")", "\n", "x_pgd", "=", "x_tiled", "+", "rng", ".", "uniform", "(", "low", "=", "-", "eps", ",", "high", "=", "eps", ",", "size", "=", "x_tiled", ".", "shape", ")", "\n", "x_pgd", "=", "np", ".", "clip", "(", "x_pgd", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "# seq_batches = range(np.int(num_images/batch_size))", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "*", "num_runs", "/", "batch_size", ")", ")", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "\n", "x_pgd_current", "=", "x_pgd", ".", "copy", "(", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_batches", "=", "tqdm", "(", "seq_batches", ")", "\n", "", "for", "i", "in", "seq_batches", ":", "\n", "            ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "if", "progress", "is", "True", ":", "\n", "                ", "seq_niter", "=", "tqdm", "(", "range", "(", "niter", ")", ")", "\n", "", "for", "n", "in", "seq_niter", ":", "\n", "                ", "x_pgd_current", "[", "batch", "]", "=", "x_pgd", "[", "batch", "]", ".", "copy", "(", ")", "\n", "grad_batch", "=", "self", ".", "sess", ".", "run", "(", "gradient", ",", "feed_dict", "=", "{", "x_inp", ":", "x_pgd", "[", "batch", "]", ",", "\n", "y_true", ":", "y_tiled", "[", "batch", "]", "}", ")", "\n", "x_pgd", "[", "batch", "]", "+=", "delta", "*", "np", ".", "sign", "(", "grad_batch", ")", "\n", "x_pgd", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_pgd", "[", "batch", "]", ",", "x_tiled", "[", "batch", "]", "-", "eps", ",", "x_tiled", "[", "batch", "]", "+", "eps", ")", "\n", "x_pgd", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_pgd", "[", "batch", "]", ",", "clip_min", ",", "clip_max", ")", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "niter_proj", ")", ")", ":", "\n", "                    ", "grad_batch_proj", "=", "sp_project", "(", "x_pgd", "[", "batch", "]", ",", "grad_batch", ",", "**", "def_params", ")", "\n", "x_pgd", "[", "batch", "]", "=", "x_pgd_current", "[", "batch", "]", "+", "delta", "*", "np", ".", "sign", "(", "grad_batch_proj", ")", "\n", "x_pgd", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_pgd", "[", "batch", "]", ",", "x_tiled", "[", "batch", "]", "-", "eps", ",", "x_tiled", "[", "batch", "]", "+", "eps", ")", "\n", "x_pgd", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_pgd", "[", "batch", "]", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "", "", "if", "verbose", "is", "True", ":", "\n", "            ", "correct_prediction", "=", "tf", ".", "equal", "(", "tf", ".", "argmax", "(", "logits", ",", "1", ")", ",", "tf", ".", "argmax", "(", "y_true", ",", "1", ")", ")", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "*", "num_runs", "/", "batch_size", ")", ")", "\n", "preds", "=", "np", ".", "zeros", "(", "[", "num_runs", "*", "num_images", "]", ")", "\n", "for", "i", "in", "seq_batches", ":", "\n", "                ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "preds", "[", "batch", "]", "=", "self", ".", "sess", ".", "run", "(", "correct_prediction", ",", "\n", "feed_dict", "=", "{", "x_inp", ":", "x_pgd", "[", "batch", "]", ",", "\n", "y_true", ":", "y_tiled", "[", "batch", "]", "}", ")", "\n", "", "preds", "=", "preds", ".", "reshape", "(", "[", "num_runs", ",", "num_images", "]", ")", "\n", "acc", "=", "100", "*", "preds", ".", "min", "(", "axis", "=", "0", ")", ".", "mean", "(", ")", "\n", "print", "(", "'PGD accuracy: {:.2f}%\\n'", ".", "format", "(", "acc", ")", ")", "\n", "\n", "", "x_pgd", "=", "x_pgd", ".", "reshape", "(", "[", "num_runs", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "\n", "return", "x_pgd", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.PGDAttack.run_debug": [[977, 1047], ["tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.stop_gradient", "attacks.PGDAttack.model.get_logits", "tensorflow.nn.softmax_cross_entropy_with_logits_v2", "tensorflow.gradients", "numpy.zeros", "range", "range", "ValueError", "numpy.random.RandomState", "numpy.clip", "x.copy", "numpy.int", "tqdm.tqdm.tqdm", "slice", "numpy.random.RandomState.uniform", "tqdm.tqdm.tqdm", "attacks.PGDAttack.sess.run", "numpy.clip", "numpy.clip", "range", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.attacks.IterLocLinearAttack.run"], ["", "def", "run_debug", "(", "self", ",", "x", ",", "y", ",", "batch_size", ",", "eps", "=", "8.", ",", "\n", "delta", "=", "1.", ",", "\n", "niter", "=", "100", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "255.", ",", "\n", "rand_init", "=", "False", ",", "\n", "rand_seed", "=", "None", ",", "\n", "progress", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Inputs:\n            x           - Images to be perturbed. Must be a Numpy array of shape \n                          [num_images, num_rows, num_cols, num_channels]\n            y           - True labels, one-hot encoded. Must be a Numpy array of shape\n                          [num_images, num_classes]\n            batch_size  - Number of attacks to run simultaneously.\n            eps         - Overall L-inf budget for the attack.\n            delta       - L-inf budget for each attack iteration.\n            niter       - Number of attack iterations.\n            clip_min    - Minimum input component value.\n            clip_max    - Maximum input component value.\n            rand_init   - Whether to use random initialization.\n            rand_seed   - Seed for random number generator.\n            progress    - Whether to display progress bars\n\n        Output:\n            x_pgd   - Perturbed images. Numpy array of same shape as x.\n\n        \"\"\"", "\n", "\n", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "=", "x", ".", "shape", "\n", "num_classes", "=", "y", ".", "shape", "[", "1", "]", "\n", "\n", "if", "num_images", "%", "batch_size", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Batch size must be a submultiple of data size'", ")", "\n", "\n", "# Create graph", "\n", "", "x_inp", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "batch_size", ",", "num_rows", ",", "num_cols", ",", "num_channels", ")", ")", "\n", "y_true", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "batch_size", ",", "num_classes", ")", ")", "\n", "y_true", "=", "tf", ".", "stop_gradient", "(", "y_true", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x_inp", ")", "\n", "loss", "=", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits_v2", "(", "logits", "=", "logits", ",", "labels", "=", "y_true", ")", "\n", "gradient", ",", "=", "tf", ".", "gradients", "(", "loss", ",", "x_inp", ")", "\n", "\n", "if", "rand_init", "is", "True", ":", "\n", "            ", "rng", "=", "RandomState", "(", "rand_seed", ")", "\n", "x_pgd", "=", "x", "+", "rng", ".", "uniform", "(", "low", "=", "-", "eps", ",", "high", "=", "eps", ",", "size", "=", "x", ".", "shape", ")", "\n", "x_pgd", "=", "np", ".", "clip", "(", "x_pgd", ",", "clip_min", ",", "clip_max", ")", "\n", "", "else", ":", "\n", "            ", "x_pgd", "=", "x", ".", "copy", "(", ")", "\n", "\n", "", "x_pgd_iter", "=", "np", ".", "zeros", "(", "[", "niter", ",", "num_images", ",", "num_rows", ",", "num_cols", ",", "num_channels", "]", ")", "\n", "\n", "seq_batches", "=", "range", "(", "np", ".", "int", "(", "num_images", "/", "batch_size", ")", ")", "\n", "seq_niter", "=", "range", "(", "niter", ")", "\n", "if", "progress", "is", "True", ":", "\n", "            ", "seq_batches", "=", "tqdm", "(", "seq_batches", ")", "\n", "\n", "", "for", "i", "in", "seq_batches", ":", "\n", "            ", "batch", "=", "slice", "(", "i", "*", "batch_size", ",", "(", "i", "+", "1", ")", "*", "batch_size", ")", "\n", "if", "progress", "is", "True", ":", "\n", "                ", "seq_niter", "=", "tqdm", "(", "range", "(", "niter", ")", ")", "\n", "", "for", "n", "in", "seq_niter", ":", "\n", "                ", "grad_batch", "=", "self", ".", "sess", ".", "run", "(", "gradient", ",", "feed_dict", "=", "{", "x_inp", ":", "x_pgd", "[", "batch", "]", ",", "\n", "y_true", ":", "y", "[", "batch", "]", "}", ")", "\n", "x_pgd", "[", "batch", "]", "+=", "delta", "*", "np", ".", "sign", "(", "grad_batch", ")", "\n", "x_pgd", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_pgd", "[", "batch", "]", ",", "x", "[", "batch", "]", "-", "eps", ",", "x", "[", "batch", "]", "+", "eps", ")", "\n", "x_pgd", "[", "batch", "]", "=", "np", ".", "clip", "(", "x_pgd", "[", "batch", "]", ",", "clip_min", ",", "clip_max", ")", "\n", "x_pgd_iter", "[", "n", ",", "batch", "]", "=", "x_pgd", "[", "batch", "]", "\n", "\n", "", "", "return", "x_pgd", ",", "x_pgd_iter", "", "", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.sp_func_cnn.sp_frontend": [[9, 41], ["images.copy", "range", "images[].reshape", "pywt.WaveletPacket2D", "numpy.floor().astype", "numpy.zeros", "range", "range", "pywt.WaveletPacket2D.reconstruct().astype", "numpy.clip", "wp[].data.flatten", "numpy.argpartition", "coeffs[].reshape", "pywt.WaveletPacket2D.get_level", "numpy.floor", "numpy.abs", "pywt.WaveletPacket2D.reconstruct"], "function", ["None"], ["def", "sp_frontend", "(", "images", ",", "rho", "=", "0.03", ",", "wavelet", "=", "'bior4.4'", ",", "mode", "=", "'periodization'", ",", "max_lev", "=", "1", ")", ":", "\n", "\t", "\"\"\"\n\tSparsifies input in the wavelet basis (using the PyWavelets package) and returns reconstruction.\n\n\t:param images: Should be in the range [0, 1] and of shape [num_samples, num_features, num_features, 1].\n\t:param rho: Sparsity level, in the range [0, 1].\n\t:param wavelet: Wavelet to use in the transform. See https://pywavelets.readthedocs.io/ for more details.\n\t:param mode: Signal extension mode. See https://pywavelets.readthedocs.io/ for more details.\n\t:param max_lev: Maximum allowed level of decomposition.\n\t\"\"\"", "\n", "num_samples", "=", "images", ".", "shape", "[", "0", "]", "\n", "num_features", "=", "images", ".", "shape", "[", "1", "]", "\n", "images_sp", "=", "images", ".", "copy", "(", ")", "\n", "for", "i", "in", "range", "(", "num_samples", ")", ":", "\n", "\t\t", "image", "=", "images", "[", "i", "]", ".", "reshape", "(", "num_features", ",", "num_features", ")", "\n", "wp", "=", "pywt", ".", "WaveletPacket2D", "(", "image", ",", "wavelet", ",", "mode", ",", "max_lev", ")", "\n", "paths", "=", "[", "node", ".", "path", "for", "node", "in", "wp", ".", "get_level", "(", "max_lev", ")", "]", "\n", "m", "=", "wp", "[", "paths", "[", "0", "]", "]", ".", "data", ".", "shape", "[", "0", "]", "\n", "l", "=", "(", "4", "**", "max_lev", ")", "*", "m", "*", "m", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "l", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "l", "-", "k", "\n", "coeffs", "=", "np", ".", "zeros", "(", "l", ")", "\n", "for", "j", "in", "range", "(", "4", "**", "max_lev", ")", ":", "\n", "\t\t\t", "coeffs", "[", "j", "*", "m", "*", "m", ":", "(", "j", "+", "1", ")", "*", "m", "*", "m", "]", "=", "wp", "[", "paths", "[", "j", "]", "]", ".", "data", ".", "flatten", "(", ")", "\n", "", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ")", "[", ":", "n", "]", "\n", "coeffs", "[", "indices", "]", "=", "0", "\n", "for", "j", "in", "range", "(", "4", "**", "max_lev", ")", ":", "\n", "\t\t\t", "wp", "[", "paths", "[", "j", "]", "]", ".", "data", "=", "coeffs", "[", "j", "*", "m", "*", "m", ":", "(", "j", "+", "1", ")", "*", "m", "*", "m", "]", ".", "reshape", "(", "[", "m", ",", "m", "]", ")", "\n", "", "image_r", "=", "wp", ".", "reconstruct", "(", "update", "=", "False", ")", ".", "astype", "(", "'float32'", ")", "\n", "image_r", "=", "np", ".", "clip", "(", "image_r", ",", "0.0", ",", "1.0", ")", "\n", "images_sp", "[", "i", ",", ":", ",", ":", ",", "0", "]", "=", "image_r", "\n", "", "return", "images_sp", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.sp_func_cnn.sp_project": [[42, 77], ["numpy.array().reshape", "pywt.WaveletPacket2D", "numpy.floor().astype", "numpy.zeros", "range", "np.array().reshape.reshape", "pywt.WaveletPacket2D", "numpy.zeros", "range", "range", "pywt.WaveletPacket2D.reconstruct().astype", "image.reshape", "wp[].data.flatten", "numpy.argpartition", "weights_proj.reshape.reshape", "wp_w[].data.flatten", "coeffs_w[].reshape", "numpy.array", "pywt.WaveletPacket2D.get_level", "numpy.floor", "numpy.abs", "pywt.WaveletPacket2D.get_level", "pywt.WaveletPacket2D.reconstruct"], "function", ["None"], ["", "def", "sp_project", "(", "image", ",", "weights", ",", "wavelet", "=", "'bior4.4'", ",", "mode", "=", "'periodization'", ",", "max_lev", "=", "1", ",", "rho", "=", "0.03", ")", ":", "\n", "\t", "\"\"\"\n\tProjects weights onto top rho% of the support of image (in the wavelet basis).\n\n\t:param image: Should be in the range [0, 1], and resizable to shape [num_features, num_features]\n\t:param weights: Should be resizable to shape [num_features, num_features].\n\t:param rho: Sparsity level, in the range [0, 1].\n\t:param wavelet: Wavelet to use in the transform. See https://pywavelets.readthedocs.io/ for more details.\n\t:param mode: Signal extension mode. See https://pywavelets.readthedocs.io/ for more details.\n\t:param max_lev: Maximum allowed level of decomposition.\n\t\"\"\"", "\n", "num_features", "=", "image", ".", "shape", "[", "1", "]", "\n", "weights_proj", "=", "np", ".", "array", "(", "weights", ")", ".", "reshape", "(", "[", "1", ",", "num_features", ",", "num_features", ",", "1", "]", ")", "\n", "wp", "=", "pywt", ".", "WaveletPacket2D", "(", "image", ".", "reshape", "(", "num_features", ",", "num_features", ")", ",", "wavelet", ",", "mode", ",", "max_lev", ")", "\n", "paths", "=", "[", "node", ".", "path", "for", "node", "in", "wp", ".", "get_level", "(", "max_lev", ")", "]", "\n", "m", "=", "wp", "[", "paths", "[", "0", "]", "]", ".", "data", ".", "shape", "[", "0", "]", "\n", "l", "=", "(", "4", "**", "max_lev", ")", "*", "m", "*", "m", "\n", "k", "=", "np", ".", "floor", "(", "rho", "*", "l", ")", ".", "astype", "(", "'int'", ")", "\n", "n", "=", "l", "-", "k", "\n", "coeffs", "=", "np", ".", "zeros", "(", "l", ")", "\n", "for", "j", "in", "range", "(", "4", "**", "max_lev", ")", ":", "\n", "\t\t", "coeffs", "[", "j", "*", "m", "*", "m", ":", "(", "j", "+", "1", ")", "*", "m", "*", "m", "]", "=", "wp", "[", "paths", "[", "j", "]", "]", ".", "data", ".", "flatten", "(", ")", "\n", "", "indices", "=", "np", ".", "argpartition", "(", "np", ".", "abs", "(", "coeffs", ")", ",", "n", ")", "[", ":", "n", "]", "\n", "\n", "weight", "=", "weights_proj", ".", "reshape", "(", "num_features", ",", "num_features", ")", "\n", "wp_w", "=", "pywt", ".", "WaveletPacket2D", "(", "weight", ".", "reshape", "(", "num_features", ",", "num_features", ")", ",", "wavelet", ",", "mode", ",", "max_lev", ")", "\n", "paths_w", "=", "[", "node", ".", "path", "for", "node", "in", "wp_w", ".", "get_level", "(", "max_lev", ")", "]", "\n", "coeffs_w", "=", "np", ".", "zeros", "(", "l", ")", "\n", "for", "j", "in", "range", "(", "4", "**", "max_lev", ")", ":", "\n", "\t\t", "coeffs_w", "[", "j", "*", "m", "*", "m", ":", "(", "j", "+", "1", ")", "*", "m", "*", "m", "]", "=", "wp_w", "[", "paths_w", "[", "j", "]", "]", ".", "data", ".", "flatten", "(", ")", "\n", "", "coeffs_w", "[", "indices", "]", "=", "0", "\n", "for", "j", "in", "range", "(", "4", "**", "max_lev", ")", ":", "\n", "\t\t", "wp_w", "[", "paths_w", "[", "j", "]", "]", ".", "data", "=", "coeffs_w", "[", "j", "*", "m", "*", "m", ":", "(", "j", "+", "1", ")", "*", "m", "*", "m", "]", ".", "reshape", "(", "[", "m", ",", "m", "]", ")", "\n", "", "weights_proj", "[", "0", ",", ":", ",", ":", ",", "0", "]", "=", "wp_w", ".", "reconstruct", "(", "update", "=", "False", ")", ".", "astype", "(", "'float32'", ")", "\n", "return", "weights_proj", "\n", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.locally_linear_attacks.semi_white_box": [[9, 27], ["numpy.arange().astype", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.nn.top_k", "tensorflow.cond", "locally_linear_attacks.semi_white_box_each", "tensorflow.reshape", "tensorflow.equal", "numpy.arange", "model.get_logits", "model.get_logits"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.locally_linear_attacks.semi_white_box_each"], ["def", "semi_white_box", "(", "x", ",", "source", ",", "model", ",", "eps", "=", "0.25", ")", ":", "\n", "\t", "\"\"\"\n\tLocally linear semi-white box attack. Given L labels and the true label l, it finds the locally linear attacks required to target each of the L-1 false labels by calculating epsilon*sgn(weq_i - weq_l). It then picks the attack with the highest output distortion.\n\n\t:param x: Should be in the range [0, 1] and of shape [1, num_features, num_features, 1].\n\t:param source: True label.\n\t:param model: Model to attack. Should be an instance of cleverhans.model.Model.\n\t:param eps: L-infinity attack budget.\n\t\"\"\"", "\n", "func", "=", "lambda", "target", ":", "semi_white_box_each", "(", "x", ",", "source", ",", "target", ",", "model", ",", "eps", ")", "\n", "targets", "=", "np", ".", "arange", "(", "10", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "x_sw_temp", "=", "tf", ".", "map_fn", "(", "func", ",", "targets", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "func2", "=", "lambda", "target", ":", "model", ".", "get_logits", "(", "x_sw_temp", "[", "target", "]", ")", "[", ":", ",", "target", "]", "[", "0", "]", "-", "model", ".", "get_logits", "(", "x_sw_temp", "[", "target", "]", ")", "[", ":", ",", "source", "]", "[", "0", "]", "\n", "output_temp", "=", "tf", ".", "map_fn", "(", "func2", ",", "targets", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "val", ",", "ind", "=", "tf", ".", "nn", ".", "top_k", "(", "tf", ".", "reshape", "(", "output_temp", ",", "[", "10", "]", ")", ",", "k", "=", "2", ")", "\n", "target", "=", "tf", ".", "cond", "(", "tf", ".", "equal", "(", "ind", "[", "0", "]", ",", "source", ")", ",", "lambda", ":", "ind", "[", "1", "]", ",", "lambda", ":", "ind", "[", "0", "]", ")", "\n", "x_sw", "=", "x_sw_temp", "[", "target", "]", "\n", "return", "x_sw", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.locally_linear_attacks.white_box": [[28, 46], ["numpy.arange().astype", "tensorflow.map_fn", "tensorflow.map_fn", "tensorflow.nn.top_k", "tensorflow.cond", "locally_linear_attacks.white_box_each", "tensorflow.reshape", "tensorflow.equal", "numpy.arange", "model.get_logits", "model.get_logits"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.locally_linear_attacks.white_box_each"], ["", "def", "white_box", "(", "x", ",", "source", ",", "model", ",", "eps", "=", "0.25", ")", ":", "\n", "\t", "\"\"\"\n\tLocally linear white box attack. Similar to the semi white box attack, but instead of using the equivalent weights directly, it uses the projection of the weights on the input.\n\n\t:param x: Should be in the range [0, 1] and of shape [1, num_features, num_features, 1].\n\t:param source: True label.\n\t:param model: Model to attack; should be an instance of cleverhans.model.Model.\n\t:param eps: L-infinity attack budget.\n\t\"\"\"", "\n", "func", "=", "lambda", "target", ":", "white_box_each", "(", "x", ",", "source", ",", "target", ",", "model", ",", "eps", ")", "\n", "targets", "=", "np", ".", "arange", "(", "10", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "x_w_temp", "=", "tf", ".", "map_fn", "(", "func", ",", "targets", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "func2", "=", "lambda", "target", ":", "model", ".", "get_logits", "(", "x_w_temp", "[", "target", "]", ")", "[", ":", ",", "target", "]", "[", "0", "]", "-", "model", ".", "get_logits", "(", "x_w_temp", "[", "target", "]", ")", "[", ":", ",", "source", "]", "[", "0", "]", "\n", "output_temp", "=", "tf", ".", "map_fn", "(", "func2", ",", "targets", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "val", ",", "ind", "=", "tf", ".", "nn", ".", "top_k", "(", "tf", ".", "reshape", "(", "output_temp", ",", "[", "10", "]", ")", ",", "k", "=", "2", ")", "\n", "target", "=", "tf", ".", "cond", "(", "tf", ".", "equal", "(", "ind", "[", "0", "]", ",", "source", ")", ",", "lambda", ":", "ind", "[", "1", "]", ",", "lambda", ":", "ind", "[", "0", "]", ")", "\n", "x_w", "=", "x_w_temp", "[", "target", "]", "\n", "return", "x_w", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.locally_linear_attacks.semi_white_box_each": [[47, 57], ["model.get_logits", "tensorflow.reshape", "tensorflow.clip_by_value", "tensorflow.gradients", "tensorflow.gradients", "tensorflow.sign", "tensorflow.subtract"], "function", ["None"], ["", "def", "semi_white_box_each", "(", "x", ",", "source", ",", "target", ",", "model", ",", "eps", "=", "0.25", ")", ":", "\n", "\t", "\"\"\"\n\tHelper function used in semi_white_box(.)\n\t\"\"\"", "\n", "output", "=", "model", ".", "get_logits", "(", "x", ")", "\n", "weq_source", "=", "tf", ".", "gradients", "(", "output", "[", ":", ",", "source", "]", ",", "x", ")", "[", "0", "]", "\n", "weq_target", "=", "tf", ".", "gradients", "(", "output", "[", ":", ",", "target", "]", ",", "x", ")", "[", "0", "]", "\n", "sweq", "=", "tf", ".", "reshape", "(", "tf", ".", "sign", "(", "tf", ".", "subtract", "(", "weq_target", ",", "weq_source", ")", ")", ",", "[", "-", "1", ",", "28", ",", "28", ",", "1", "]", ")", "\n", "x_sw_each", "=", "tf", ".", "clip_by_value", "(", "x", "+", "eps", "*", "sweq", ",", "0.", ",", "1.", ")", "\n", "return", "x_sw_each", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.locally_linear_attacks.white_box_each": [[58, 70], ["model.get_logits", "tensorflow.py_func", "tensorflow.py_func", "tensorflow.reshape", "tensorflow.clip_by_value", "tensorflow.gradients", "tensorflow.gradients", "tensorflow.sign", "tensorflow.subtract"], "function", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.py_func", "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.neural_nets.sp_func_nn.py_func"], ["", "def", "white_box_each", "(", "x", ",", "source", ",", "target", ",", "model", ",", "eps", "=", "0.25", ")", ":", "\n", "\t", "\"\"\"\n\tHelper function used in white_box(.)\n\t\"\"\"", "\n", "output", "=", "model", ".", "get_logits", "(", "x", ")", "\n", "weq_source", "=", "tf", ".", "gradients", "(", "output", "[", ":", ",", "source", "]", ",", "x", ")", "[", "0", "]", "\n", "weq_source_proj", "=", "tf", ".", "py_func", "(", "sp_project", ",", "[", "x", ",", "weq_source", "]", ",", "tf", ".", "float32", ")", "\n", "weq_target", "=", "tf", ".", "gradients", "(", "output", "[", ":", ",", "target", "]", ",", "x", ")", "[", "0", "]", "\n", "weq_target_proj", "=", "tf", ".", "py_func", "(", "sp_project", ",", "[", "x", ",", "weq_target", "]", ",", "tf", ".", "float32", ")", "\n", "sweq", "=", "tf", ".", "reshape", "(", "tf", ".", "sign", "(", "tf", ".", "subtract", "(", "weq_target_proj", ",", "weq_source_proj", ")", ")", ",", "[", "-", "1", ",", "28", ",", "28", ",", "1", "]", ")", "\n", "x_w_each", "=", "tf", ".", "clip_by_value", "(", "x", "+", "eps", "*", "sweq", ",", "0.", ",", "1.", ")", "\n", "return", "x_w_each", "\n", "", ""]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.test_defense_cnn.FourLayerModel.__init__": [[61, 65], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mu", ",", "sigma", ")", ":", "\n", "        ", "self", ".", "mu", "=", "mu", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "layer_names", "=", "[", "'layer1'", ",", "'layer2'", ",", "'layer3'", ",", "'layer4'", ",", "'logits'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.test_defense_cnn.FourLayerModel.fprop": [[66, 70], ["test_defense_cnn.four_layer_cnn"], "methods", ["home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.test_defense_cnn.four_layer_cnn"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "        ", "x_norm", "=", "(", "x", "-", "self", ".", "mu", ")", "/", "self", ".", "sigma", "\n", "_", ",", "end_points", "=", "four_layer_cnn", "(", "x_norm", ",", "phase", "=", "False", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", "\n", "return", "end_points", "\n", "\n"]], "home.repos.pwc.inspect_result.soorya19_sparsity-based-defenses.old_workshop.test_defense_cnn.four_layer_cnn": [[20, 56], ["tensorflow.variable_scope", "tensorflow.contrib.slim.conv2d", "tensorflow.contrib.slim.max_pool2d", "tensorflow.contrib.slim.conv2d", "tensorflow.contrib.slim.max_pool2d", "tensorflow.reshape", "tensorflow.contrib.slim.fully_connected", "tensorflow.contrib.slim.dropout", "tensorflow.contrib.slim.fully_connected", "tensorflow.contrib.slim.dropout", "tensorflow.contrib.slim.fully_connected", "tensorflow.contrib.slim.dropout"], "function", ["None"], ["def", "four_layer_cnn", "(", "inputs", ",", "phase", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ",", "scope", "=", "'four_layer_cnn'", ")", ":", "\n", "    ", "\"\"\"\n    Four layer CNN from Chapter 6 of the textbook 'Neural Networks and Deep Learning' by Michael A. Nielsen, Determination Press, 2015 (http://neuralnetworksanddeeplearning.com/chap6.html/). TensorFlow-Slim implementation adapted from https://github.com/initialized/tensorflow-tutorial/.\n\n    Layer 1: Convolutional, with a 5x5 receptive field and 20 feature maps. \n    Layer 2: Convolutional, with a 5x5 receptive field and 40 feature maps.\n    Layer 3: Fully connected, with 1000 neurons.\n    Layer 4: Fully connected, with 1000 neurons.\n\n    :param inputs: Should be of shape [num_samples, 28, 28, 1].\n    :param phase: If TRUE, dropout is switched on in layers 3 and 4.\n    \"\"\"", "\n", "end_points", "=", "{", "}", "\n", "with", "tf", ".", "variable_scope", "(", "scope", ",", "reuse", "=", "reuse", ")", ":", "\n", "        ", "net", "=", "slim", ".", "conv2d", "(", "inputs", ",", "20", ",", "[", "5", ",", "5", "]", ",", "padding", "=", "'SAME'", ",", "scope", "=", "'layer1-conv'", ")", "\n", "net", "=", "slim", ".", "max_pool2d", "(", "net", ",", "2", ",", "stride", "=", "2", ",", "scope", "=", "'layer1-max-pool'", ")", "\n", "end_points", "[", "'layer1'", "]", "=", "net", "\n", "\n", "net", "=", "slim", ".", "conv2d", "(", "net", ",", "40", ",", "[", "5", ",", "5", "]", ",", "padding", "=", "'VALID'", ",", "scope", "=", "'layer2-conv'", ")", "\n", "net", "=", "slim", ".", "max_pool2d", "(", "net", ",", "2", ",", "stride", "=", "2", ",", "scope", "=", "'layer2-max-pool'", ")", "\n", "net", "=", "tf", ".", "reshape", "(", "net", ",", "[", "-", "1", ",", "5", "*", "5", "*", "40", "]", ")", "\n", "end_points", "[", "'layer2'", "]", "=", "net", "\n", "\n", "net", "=", "slim", ".", "fully_connected", "(", "net", ",", "1000", ",", "scope", "=", "'layer3'", ")", "\n", "net", "=", "slim", ".", "dropout", "(", "net", ",", "is_training", "=", "phase", ",", "scope", "=", "'layer3-dropout'", ")", "\n", "end_points", "[", "'layer3'", "]", "=", "net", "\n", "\n", "net", "=", "slim", ".", "fully_connected", "(", "net", ",", "1000", ",", "scope", "=", "'layer4'", ")", "\n", "net", "=", "slim", ".", "dropout", "(", "net", ",", "is_training", "=", "phase", ",", "scope", "=", "'layer4-dropout'", ")", "\n", "end_points", "[", "'layer4'", "]", "=", "net", "\n", "\n", "net", "=", "slim", ".", "fully_connected", "(", "net", ",", "10", ",", "scope", "=", "'logits'", ",", "activation_fn", "=", "None", ")", "\n", "logits", "=", "slim", ".", "dropout", "(", "net", ",", "is_training", "=", "phase", ",", "scope", "=", "'logits-dropout'", ")", "\n", "end_points", "[", "'logits'", "]", "=", "logits", "\n", "\n", "return", "logits", ",", "end_points", "\n", "\n"]]}