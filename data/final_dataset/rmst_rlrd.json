{"home.repos.pwc.inspect_result.rmst_rlrd.tests.training.TestMlp.act": [[12, 14], ["obs.copy"], "methods", ["None"], ["\t", "def", "act", "(", "self", ",", "obs", ":", "torch", ".", "tensor", ",", "r", ",", "done", ",", "info", ")", ":", "\n", "\t\t", "return", "obs", ".", "copy", "(", ")", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.tests.training.TestEnv.__post_init__": [[22, 25], ["gym.spaces.Box", "gym.spaces.Box"], "methods", ["None"], ["def", "__post_init__", "(", "self", ",", "seed_val", ")", ":", "\n", "\t\t", "self", ".", "observation_space", "=", "gym", ".", "spaces", ".", "Box", "(", "0", ",", "self", ".", "high", ",", "shape", "=", "[", "1", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "action_space", "=", "gym", ".", "spaces", ".", "Box", "(", "0", ",", "self", ".", "high", ",", "shape", "=", "[", "1", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.tests.training.TestEnv.reset": [[26, 29], ["numpy.zeros"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "state", "=", "np", ".", "zeros", "(", "[", "1", "]", ",", "np", ".", "float32", ")", "\n", "return", "self", ".", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.tests.training.TestEnv.step": [[30, 34], ["float", "numpy.asarray", "numpy.float32"], "methods", ["None"], ["", "def", "step", "(", "self", ",", "action", ":", "np", ".", "ndarray", ")", ":", "\n", "\t\t", "reward", "=", "float", "(", "self", ".", "state", "[", "0", "]", ")", "\n", "self", ".", "state", "=", "np", ".", "asarray", "(", "(", "self", ".", "state", "[", "0", "]", "+", "np", ".", "float32", "(", "1", ")", ",", ")", ")", "\n", "return", "self", ".", "state", ",", "reward", ",", "self", ".", "state", "[", "0", "]", ">", "self", ".", "high", ",", "{", "\"reset\"", ":", "False", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.tests.run_fs.callx": [[16, 19], ["print", "subprocess.check_call"], "function", ["None"], ["def", "callx", "(", "args", ")", ":", "\n", "\t", "print", "(", "\"$\"", ",", "*", "args", ")", "\n", "check_call", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RealTimeWrapper.__init__": [[12, 18], ["gym.Wrapper.__init__", "gym.spaces.Tuple", "isinstance"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "observation_space", "=", "gym", ".", "spaces", ".", "Tuple", "(", "(", "env", ".", "observation_space", ",", "env", ".", "action_space", ")", ")", "\n", "# self.initial_action = env.action_space.sample()", "\n", "assert", "isinstance", "(", "env", ".", "action_space", ",", "gym", ".", "spaces", ".", "Box", ")", "\n", "self", ".", "initial_action", "=", "env", ".", "action_space", ".", "high", "*", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RealTimeWrapper.reset": [[19, 22], ["super().reset"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "previous_action", "=", "self", ".", "initial_action", "\n", "return", "super", "(", ")", ".", "reset", "(", ")", ",", "self", ".", "previous_action", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RealTimeWrapper.step": [[23, 27], ["super().step"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "observation", ",", "reward", ",", "done", ",", "info", "=", "super", "(", ")", ".", "step", "(", "self", ".", "previous_action", ")", "\n", "self", ".", "previous_action", "=", "action", "\n", "return", "(", "observation", ",", "action", ")", ",", "reward", ",", "done", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.PreviousActionWrapper.__init__": [[30, 36], ["gym.Wrapper.__init__", "gym.spaces.Tuple", "isinstance"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "observation_space", "=", "gym", ".", "spaces", ".", "Tuple", "(", "(", "env", ".", "observation_space", ",", "env", ".", "action_space", ")", ")", "\n", "# self.initial_action = env.action_space.sample()", "\n", "assert", "isinstance", "(", "env", ".", "action_space", ",", "gym", ".", "spaces", ".", "Box", ")", "\n", "self", ".", "initial_action", "=", "env", ".", "action_space", ".", "high", "*", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.PreviousActionWrapper.reset": [[37, 40], ["super().reset"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "previous_action", "=", "self", ".", "initial_action", "\n", "return", "super", "(", ")", ".", "reset", "(", ")", ",", "self", ".", "previous_action", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.PreviousActionWrapper.step": [[41, 45], ["super().step"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "observation", ",", "reward", ",", "done", ",", "info", "=", "super", "(", ")", ".", "step", "(", "action", ")", "# this line is different from RealTimeWrapper", "\n", "self", ".", "previous_action", "=", "action", "\n", "return", "(", "observation", ",", "action", ")", ",", "reward", ",", "done", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.StatsWrapper.__init__": [[50, 55], ["gym.Wrapper.__init__", "collections.deque", "collections.deque"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["def", "__init__", "(", "self", ",", "env", ",", "window", "=", "100", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "reward_hist", "=", "deque", "(", "[", "0", "]", ",", "maxlen", "=", "window", "+", "1", ")", "\n", "self", ".", "done_hist", "=", "deque", "(", "[", "1", "]", ",", "maxlen", "=", "window", "+", "1", ")", "\n", "self", ".", "total_steps", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.StatsWrapper.reset": [[56, 58], ["super().reset"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "reset", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.StatsWrapper.step": [[59, 65], ["super().step", "wrappers.StatsWrapper.reward_hist.append", "wrappers.StatsWrapper.done_hist.append"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "m", ",", "r", ",", "d", ",", "info", "=", "super", "(", ")", ".", "step", "(", "action", ")", "\n", "self", ".", "reward_hist", ".", "append", "(", "r", ")", "\n", "self", ".", "done_hist", ".", "append", "(", "d", ")", "\n", "self", ".", "total_steps", "+=", "1", "\n", "return", "m", ",", "r", ",", "d", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.StatsWrapper.stats": [[66, 83], ["zip", "dict", "returns.append", "steps.append", "len", "numpy.mean", "len", "numpy.mean", "len", "numpy.mean", "tuple"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append"], ["", "def", "stats", "(", "self", ")", ":", "\n", "        ", "returns", "=", "[", "0", "]", "\n", "steps", "=", "[", "0", "]", "\n", "for", "reward", ",", "done", "in", "zip", "(", "self", ".", "reward_hist", ",", "self", ".", "done_hist", ")", ":", "\n", "            ", "returns", "[", "-", "1", "]", "+=", "reward", "\n", "steps", "[", "-", "1", "]", "+=", "1", "\n", "if", "done", ":", "\n", "                ", "returns", ".", "append", "(", "0", ")", "\n", "steps", ".", "append", "(", "0", ")", "\n", "", "", "returns", "=", "returns", "[", "1", ":", "-", "1", "]", "# first and last episodes are incomplete", "\n", "steps", "=", "steps", "[", "1", ":", "-", "1", "]", "\n", "\n", "return", "dict", "(", "\n", "episodes", "=", "len", "(", "returns", ")", ",", "\n", "episode_length", "=", "np", ".", "mean", "(", "steps", ")", "if", "len", "(", "steps", ")", "else", "np", ".", "nan", ",", "\n", "returns", "=", "np", ".", "mean", "(", "returns", ")", "if", "len", "(", "returns", ")", "else", "np", ".", "nan", ",", "\n", "average_reward", "=", "np", ".", "mean", "(", "tuple", "(", "self", ".", "reward_hist", ")", "[", "1", ":", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.DictObservationWrapper.__init__": [[87, 91], ["gym.ObservationWrapper.__init__", "gym.spaces.Dict"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "key", "=", "'vector'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "key", "=", "key", "\n", "self", ".", "observation_space", "=", "gym", ".", "spaces", ".", "Dict", "(", "{", "self", ".", "key", ":", "env", ".", "observation_space", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.DictObservationWrapper.observation": [[92, 94], ["None"], "methods", ["None"], ["", "def", "observation", "(", "self", ",", "observation", ")", ":", "\n", "        ", "return", "{", "self", ".", "key", ":", "observation", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.TupleObservationWrapper.__init__": [[97, 100], ["gym.ObservationWrapper.__init__", "gym.spaces.Tuple"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "observation_space", "=", "gym", ".", "spaces", ".", "Tuple", "(", "(", "env", ".", "observation_space", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.TupleObservationWrapper.observation": [[101, 103], ["None"], "methods", ["None"], ["", "def", "observation", "(", "self", ",", "observation", ")", ":", "\n", "        ", "return", "observation", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.DictActionWrapper.__init__": [[106, 110], ["gym.Wrapper.__init__", "gym.spaces.Dict"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "key", "=", "'value'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "key", "=", "key", "\n", "self", ".", "action_space", "=", "gym", ".", "spaces", ".", "Dict", "(", "{", "self", ".", "key", ":", "env", ".", "action_space", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.DictActionWrapper.step": [[111, 113], ["wrappers.DictActionWrapper.env.step"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "step", "(", "self", ",", "action", ":", "dict", ")", ":", "\n", "        ", "return", "self", ".", "env", ".", "step", "(", "action", "[", "'value'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.AffineObservationWrapper.__init__": [[116, 122], ["gym.ObservationWrapper.__init__", "isinstance", "gym.spaces.Box", "wrappers.AffineObservationWrapper.observation", "wrappers.AffineObservationWrapper.observation"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.observation"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "shift", ",", "scale", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "assert", "isinstance", "(", "env", ".", "observation_space", ",", "gym", ".", "spaces", ".", "Box", ")", "\n", "self", ".", "shift", "=", "shift", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "observation_space", "=", "gym", ".", "spaces", ".", "Box", "(", "self", ".", "observation", "(", "env", ".", "observation_space", ".", "low", ")", ",", "self", ".", "observation", "(", "env", ".", "observation_space", ".", "high", ")", ",", "dtype", "=", "env", ".", "observation_space", ".", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.AffineObservationWrapper.observation": [[123, 125], ["None"], "methods", ["None"], ["", "def", "observation", "(", "self", ",", "obs", ")", ":", "\n", "        ", "return", "(", "obs", "+", "self", ".", "shift", ")", "*", "self", ".", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.AffineRewardWrapper.__init__": [[128, 132], ["gym.RewardWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "shift", ",", "scale", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "shift", "=", "shift", "\n", "self", ".", "scale", "=", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.AffineRewardWrapper.reward": [[133, 135], ["None"], "methods", ["None"], ["", "def", "reward", "(", "self", ",", "reward", ")", ":", "\n", "        ", "return", "(", "reward", "+", "self", ".", "shift", ")", "/", "self", ".", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.NormalizeActionWrapper.__init__": [[138, 143], ["gym.Wrapper.__init__", "gym.spaces.Box", "numpy.ones_like", "numpy.ones_like"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "scale", "=", "env", ".", "action_space", ".", "high", "-", "env", ".", "action_space", ".", "low", "\n", "self", ".", "shift", "=", "env", ".", "action_space", ".", "low", "\n", "self", ".", "action_space", "=", "gym", ".", "spaces", ".", "Box", "(", "-", "np", ".", "ones_like", "(", "self", ".", "shift", ")", ",", "np", ".", "ones_like", "(", "self", ".", "shift", ")", ",", "dtype", "=", "env", ".", "action_space", ".", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.NormalizeActionWrapper.reset": [[144, 146], ["wrappers.NormalizeActionWrapper.env.reset"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.NormalizeActionWrapper.step": [[147, 151], ["wrappers.NormalizeActionWrapper.env.step"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "action", "=", "action", "/", "2", "+", "0.5", "# 0 < a < 1", "\n", "action", "=", "action", "*", "self", ".", "scale", "+", "self", ".", "shift", "\n", "return", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.TimeLimitResetWrapper.__init__": [[157, 169], ["gym.Wrapper.__init__", "bool", "wrappers.get_wrapper_by_class"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.get_wrapper_by_class"], ["def", "__init__", "(", "self", ",", "env", ",", "max_steps", "=", "None", ",", "key", "=", "'reset'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "reset_key", "=", "key", "\n", "from", "gym", ".", "wrappers", "import", "TimeLimit", "\n", "self", ".", "enforce", "=", "bool", "(", "max_steps", ")", "\n", "if", "max_steps", "is", "None", ":", "\n", "            ", "tl", "=", "get_wrapper_by_class", "(", "env", ",", "TimeLimit", ")", "\n", "max_steps", "=", "1", "<<", "31", "if", "tl", "is", "None", "else", "tl", ".", "_max_episode_steps", "\n", "# print(\"TimeLimitResetWrapper.max_steps =\", max_steps)", "\n", "\n", "", "self", ".", "max_steps", "=", "max_steps", "\n", "self", ".", "t", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.TimeLimitResetWrapper.reset": [[170, 174], ["wrappers.TimeLimitResetWrapper.env.reset"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "m", "=", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "self", ".", "t", "=", "0", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.TimeLimitResetWrapper.step": [[175, 187], ["wrappers.TimeLimitResetWrapper.env.step", "info.get"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "m", ",", "r", ",", "d", ",", "info", "=", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "\n", "reset", "=", "(", "self", ".", "t", "==", "self", ".", "max_steps", "-", "1", ")", "or", "info", ".", "get", "(", "self", ".", "reset_key", ",", "False", ")", "\n", "if", "not", "self", ".", "enforce", ":", "\n", "            ", "if", "reset", ":", "\n", "                ", "assert", "d", ",", "f\"something went wrong t={self.t}, max_steps={self.max_steps}, info={info}\"", "\n", "", "", "else", ":", "\n", "            ", "d", "=", "d", "or", "reset", "\n", "", "info", "=", "{", "**", "info", ",", "self", ".", "reset_key", ":", "reset", "}", "\n", "self", ".", "t", "+=", "1", "\n", "return", "m", ",", "r", ",", "d", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.Float64ToFloat32.observation": [[193, 196], ["wrappers.deepmap"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.deepmap"], ["def", "observation", "(", "self", ",", "observation", ")", ":", "\n", "        ", "observation", "=", "deepmap", "(", "{", "np", ".", "ndarray", ":", "float64_to_float32", "}", ",", "observation", ")", "\n", "return", "observation", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.Float64ToFloat32.step": [[197, 200], ["super().step"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "s", ",", "r", ",", "d", ",", "info", "=", "super", "(", ")", ".", "step", "(", "action", ")", "\n", "return", "s", ",", "r", ",", "d", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.FrameSkip.__init__": [[203, 208], ["gym.Wrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "n", ",", "rs", "=", "1", ")", ":", "\n", "        ", "assert", "n", ">=", "1", "\n", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "frame_skip", "=", "n", "\n", "self", ".", "reward_scale", "=", "rs", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.FrameSkip.step": [[209, 217], ["range", "wrappers.FrameSkip.env.step"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "reward", "=", "0", "\n", "for", "i", "in", "range", "(", "self", ".", "frame_skip", ")", ":", "\n", "            ", "m", ",", "r", ",", "d", ",", "info", "=", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "reward", "+=", "r", "\n", "if", "d", ":", "\n", "                ", "break", "\n", "", "", "return", "m", ",", "reward", "*", "self", ".", "reward_scale", ",", "d", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RandomDelayWrapper.__init__": [[225, 246], ["range", "range", "gym.Wrapper.__init__", "gym.spaces.Tuple", "collections.deque", "collections.deque", "collections.deque", "collections.deque", "gym.spaces.Tuple", "gym.spaces.Discrete", "gym.spaces.Discrete"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["def", "__init__", "(", "self", ",", "env", ",", "obs_delay_range", "=", "range", "(", "0", ",", "8", ")", ",", "act_delay_range", "=", "range", "(", "0", ",", "2", ")", ",", "instant_rewards", ":", "bool", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "act_delay_range", "=", "act_delay_range", "\n", "self", ".", "obs_delay_range", "=", "obs_delay_range", "\n", "self", ".", "instant_rewards", "=", "instant_rewards", "\n", "\n", "self", ".", "observation_space", "=", "Tuple", "(", "(", "\n", "env", ".", "observation_space", ",", "# most recent observation", "\n", "Tuple", "(", "[", "env", ".", "action_space", "]", "*", "(", "obs_delay_range", ".", "stop", "+", "act_delay_range", ".", "stop", "-", "1", ")", ")", ",", "# action buffer", "\n", "Discrete", "(", "obs_delay_range", ".", "stop", ")", ",", "# observation delay int64", "\n", "Discrete", "(", "act_delay_range", ".", "stop", ")", ",", "# action delay int64", "\n", ")", ")", "\n", "\n", "self", ".", "past_actions", "=", "deque", "(", "maxlen", "=", "obs_delay_range", ".", "stop", "+", "act_delay_range", ".", "stop", "-", "1", ")", "\n", "self", ".", "past_observations", "=", "deque", "(", "maxlen", "=", "obs_delay_range", ".", "stop", ")", "\n", "self", ".", "arrival_times_actions", "=", "deque", "(", "maxlen", "=", "act_delay_range", ".", "stop", ")", "\n", "self", ".", "arrival_times_observations", "=", "deque", "(", "maxlen", "=", "obs_delay_range", ".", "stop", ")", "\n", "\n", "self", ".", "t", "=", "0", "\n", "self", ".", "done_signal_sent", "=", "False", "\n", "self", ".", "current_action", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RandomDelayWrapper.reset": [[247, 261], ["super().reset", "wrappers.RandomDelayWrapper.receive_observation", "wrappers.RandomDelayWrapper.send_action", "wrappers.RandomDelayWrapper.send_observation", "wrappers.RandomDelayWrapper.action_space.sample"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "done_signal_sent", "=", "False", "\n", "first_observation", "=", "super", "(", ")", ".", "reset", "(", "**", "kwargs", ")", "\n", "\n", "# fill up buffers", "\n", "self", ".", "t", "=", "-", "(", "self", ".", "obs_delay_range", ".", "stop", "+", "self", ".", "act_delay_range", ".", "stop", ")", "\n", "while", "self", ".", "t", "<", "0", ":", "\n", "            ", "self", ".", "send_action", "(", "self", ".", "action_space", ".", "sample", "(", ")", ")", "\n", "self", ".", "send_observation", "(", "(", "first_observation", ",", "0.", ",", "False", ",", "{", "}", ",", "0", ")", ")", "\n", "self", ".", "t", "+=", "1", "\n", "\n", "", "assert", "self", ".", "t", "==", "0", "\n", "received_observation", ",", "*", "_", "=", "self", ".", "receive_observation", "(", ")", "\n", "return", "received_observation", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RandomDelayWrapper.step": [[262, 285], ["wrappers.RandomDelayWrapper.send_action", "wrappers.RandomDelayWrapper.receive_observation", "wrappers.RandomDelayWrapper.receive_action", "wrappers.RandomDelayWrapper.send_observation", "wrappers.RandomDelayWrapper.env.step", "wrappers.RandomDelayWrapper.receive_action", "wrappers.RandomDelayWrapper.send_observation"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_observation"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "# at the brain", "\n", "        ", "self", ".", "send_action", "(", "action", ")", "\n", "\n", "# at the remote actor", "\n", "if", "self", ".", "t", "<", "self", ".", "act_delay_range", ".", "stop", ":", "\n", "# do nothing until the brain's first actions arrive at the remote actor", "\n", "            ", "self", ".", "receive_action", "(", ")", "\n", "aux", "=", "0", ",", "False", ",", "{", "}", "\n", "", "elif", "self", ".", "done_signal_sent", ":", "\n", "# just resend the last observation until the brain gets it", "\n", "            ", "self", ".", "send_observation", "(", "self", ".", "past_observations", "[", "0", "]", ")", "\n", "aux", "=", "0", ",", "False", ",", "{", "}", "\n", "", "else", ":", "\n", "            ", "m", ",", "*", "aux", "=", "self", ".", "env", ".", "step", "(", "self", ".", "current_action", ")", "\n", "action_delay", "=", "self", ".", "receive_action", "(", ")", "\n", "self", ".", "send_observation", "(", "(", "m", ",", "*", "aux", ",", "action_delay", ")", ")", "\n", "\n", "# at the brain again", "\n", "", "m", ",", "*", "delayed_aux", "=", "self", ".", "receive_observation", "(", ")", "\n", "aux", "=", "aux", "if", "self", ".", "instant_rewards", "else", "delayed_aux", "\n", "self", ".", "t", "+=", "1", "\n", "return", "(", "m", ",", "*", "aux", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RandomDelayWrapper.send_action": [[286, 291], ["random.sample", "wrappers.RandomDelayWrapper.arrival_times_actions.appendleft", "wrappers.RandomDelayWrapper.past_actions.appendleft"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample"], ["", "def", "send_action", "(", "self", ",", "action", ")", ":", "\n", "# at the brain", "\n", "        ", "delay", ",", "=", "sample", "(", "self", ".", "act_delay_range", ",", "1", ")", "\n", "self", ".", "arrival_times_actions", ".", "appendleft", "(", "self", ".", "t", "+", "delay", ")", "\n", "self", ".", "past_actions", ".", "appendleft", "(", "action", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RandomDelayWrapper.receive_action": [[292, 296], ["next", "enumerate"], "methods", ["None"], ["", "def", "receive_action", "(", "self", ")", ":", "\n", "        ", "action_delay", "=", "next", "(", "i", "for", "i", ",", "t", "in", "enumerate", "(", "self", ".", "arrival_times_actions", ")", "if", "t", "<=", "self", ".", "t", ")", "\n", "self", ".", "current_action", "=", "self", ".", "past_actions", "[", "action_delay", "]", "\n", "return", "action_delay", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RandomDelayWrapper.send_observation": [[297, 302], ["random.sample", "wrappers.RandomDelayWrapper.arrival_times_observations.appendleft", "wrappers.RandomDelayWrapper.past_observations.appendleft"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample"], ["", "def", "send_observation", "(", "self", ",", "obs", ")", ":", "\n", "# at the remote actor", "\n", "        ", "delay", ",", "=", "sample", "(", "self", ".", "obs_delay_range", ",", "1", ")", "\n", "self", ".", "arrival_times_observations", ".", "appendleft", "(", "self", ".", "t", "+", "delay", ")", "\n", "self", ".", "past_observations", ".", "appendleft", "(", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.RandomDelayWrapper.receive_observation": [[303, 308], ["next", "tuple", "enumerate"], "methods", ["None"], ["", "def", "receive_observation", "(", "self", ")", ":", "\n", "# at the brain", "\n", "        ", "observation_delay", "=", "next", "(", "i", "for", "i", ",", "t", "in", "enumerate", "(", "self", ".", "arrival_times_observations", ")", "if", "t", "<=", "self", ".", "t", ")", "\n", "m", ",", "r", ",", "d", ",", "info", ",", "action_delay", "=", "self", ".", "past_observations", "[", "observation_delay", "]", "\n", "return", "(", "m", ",", "tuple", "(", "self", ".", "past_actions", ")", ",", "observation_delay", ",", "action_delay", ")", ",", "r", ",", "d", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.get_wrapper_by_class": [[312, 317], ["isinstance", "isinstance", "wrappers.get_wrapper_by_class", "gym.wrappers.TimeLimit"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.get_wrapper_by_class"], ["", "", "def", "get_wrapper_by_class", "(", "env", ",", "cls", ")", ":", "\n", "    ", "if", "isinstance", "(", "env", ",", "cls", ")", ":", "\n", "        ", "return", "env", "\n", "", "elif", "isinstance", "(", "env", ",", "gym", ".", "Wrapper", ")", ":", "\n", "        ", "return", "get_wrapper_by_class", "(", "env", ".", "env", ",", "cls", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.deepmap": [[319, 331], ["isinstance", "isinstance", "isinstance", "type", "AttributeError", "wrappers.deepmap", "type", "wrappers.deepmap"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.deepmap", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.deepmap"], ["", "", "def", "deepmap", "(", "f", ",", "m", ")", ":", "\n", "    ", "\"\"\"Apply functions to the leaves of a dictionary or list, depending type of the leaf value.\n    Example: deepmap({torch.Tensor: lambda t: t.detach()}, x).\"\"\"", "\n", "for", "cls", "in", "f", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "cls", ")", ":", "\n", "            ", "return", "f", "[", "cls", "]", "(", "m", ")", "\n", "", "", "if", "isinstance", "(", "m", ",", "Sequence", ")", ":", "\n", "        ", "return", "type", "(", "m", ")", "(", "deepmap", "(", "f", ",", "x", ")", "for", "x", "in", "m", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "Mapping", ")", ":", "\n", "        ", "return", "type", "(", "m", ")", "(", "(", "k", ",", "deepmap", "(", "f", ",", "m", "[", "k", "]", ")", ")", "for", "k", "in", "m", ")", "\n", "", "else", ":", "\n", "        ", "raise", "AttributeError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.float64_to_float32": [[333, 335], ["numpy.asarray"], "function", ["None"], ["", "", "def", "float64_to_float32", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "asarray", "(", "x", ",", "np", ".", "float32", ")", "if", "x", ".", "dtype", "==", "np", ".", "float64", "else", "x", "\n", "", ""]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac_models.DelayedMlpModule.__init__": [[10, 41], ["torch.nn.Module.__init__", "isinstance", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ":", "int", "=", "256", ",", "obs_delay", "=", "True", ",", "act_delay", "=", "True", ")", ":", "# FIXME: action_space param is useless", "\n", "        ", "\"\"\"\n        Args:\n            observation_space:\n                Tuple((\n                    obs_space,  # most recent observation\n                    Tuple([act_space] * (obs_delay_range.stop + act_delay_range.stop)),  # action buffer\n                    Discrete(obs_delay_range.stop),  # observation delay int64\n                    Discrete(act_delay_range.stop),  # action delay int64\n                ))\n            action_space\n            is_Q_network: bool: if True, the input of forward() expects the action to be appended at the end of the input\n            hidden_units: number of output units of this module\n            (optional) obs_delay: bool (default True): if False, the observation delay of observation_space will be ignored (e.g. unknown)\n            (optional) act_delay: bool (default True): if False, the action delay of observation_space will be ignored (e.g. unknown)\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "observation_space", ",", "gym", ".", "spaces", ".", "Tuple", ")", "\n", "self", ".", "act_delay", "=", "act_delay", "\n", "self", ".", "obs_delay", "=", "obs_delay", "\n", "self", ".", "obs_dim", "=", "observation_space", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "self", ".", "buf_size", "=", "len", "(", "observation_space", "[", "1", "]", ")", "\n", "# print(f\"DEBUG: MLP self.buf_size: {self.buf_size}\")", "\n", "self", ".", "act_dim", "=", "observation_space", "[", "1", "]", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "assert", "self", ".", "act_dim", "==", "action_space", ".", "shape", "[", "0", "]", ",", "f\"action spaces mismatch: {self.act_dim} and {action_space.shape[0]}\"", "\n", "if", "self", ".", "act_delay", "and", "self", ".", "obs_delay", ":", "\n", "            ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "(", "self", ".", "act_dim", "+", "2", ")", "*", "self", ".", "buf_size", ",", "hidden_units", ")", "\n", "", "elif", "self", ".", "act_delay", "or", "self", ".", "obs_delay", ":", "\n", "            ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "(", "self", ".", "act_dim", "+", "1", ")", "*", "self", ".", "buf_size", ",", "hidden_units", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "self", ".", "act_dim", "*", "self", ".", "buf_size", ",", "hidden_units", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac_models.DelayedMlpModule.forward": [[42, 58], ["isinstance", "torch.cat", "torch.cat", "dcac_models.DelayedMlpModule.lin", "torch.zeros().scatter_", "torch.cat", "torch.zeros().scatter_", "torch.cat", "obs_del.unsqueeze().long", "act_del.unsqueeze().long", "torch.zeros", "torch.zeros", "obs_del.unsqueeze", "act_del.unsqueeze"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "isinstance", "(", "x", ",", "tuple", ")", ",", "f\"x is not a tuple: {x}\"", "\n", "obs", "=", "x", "[", "0", "]", "\n", "act_buf", "=", "torch", ".", "cat", "(", "x", "[", "1", "]", ",", "dim", "=", "1", ")", "\n", "input", "=", "torch", ".", "cat", "(", "(", "obs", ",", "act_buf", ")", ",", "dim", "=", "1", ")", "\n", "batch_size", "=", "obs", ".", "shape", "[", "0", "]", "\n", "if", "self", ".", "obs_delay", ":", "\n", "            ", "obs_del", "=", "x", "[", "2", "]", "\n", "obs_one_hot", "=", "torch", ".", "zeros", "(", "batch_size", ",", "self", ".", "buf_size", ",", "device", "=", "input", ".", "device", ")", ".", "scatter_", "(", "1", ",", "obs_del", ".", "unsqueeze", "(", "1", ")", ".", "long", "(", ")", ",", "1.0", ")", "\n", "input", "=", "torch", ".", "cat", "(", "(", "input", ",", "obs_one_hot", ")", ",", "dim", "=", "1", ")", "\n", "", "if", "self", ".", "act_delay", ":", "\n", "            ", "act_del", "=", "x", "[", "3", "]", "\n", "act_one_hot", "=", "torch", ".", "zeros", "(", "batch_size", ",", "self", ".", "buf_size", ",", "device", "=", "input", ".", "device", ")", ".", "scatter_", "(", "1", ",", "act_del", ".", "unsqueeze", "(", "1", ")", ".", "long", "(", ")", ",", "1.0", ")", "\n", "input", "=", "torch", ".", "cat", "(", "(", "input", ",", "act_one_hot", ")", ",", "dim", "=", "1", ")", "\n", "", "h", "=", "self", ".", "lin", "(", "input", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac_models.MlpStateValue.__init__": [[61, 66], ["torch.nn.Sequential.__init__", "dcac_models.DelayedMlpModule", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ",", "act_delay", "=", "True", ",", "obs_delay", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "DelayedMlpModule", "(", "observation_space", ",", "action_space", ",", "act_delay", "=", "act_delay", ",", "obs_delay", "=", "obs_delay", ")", ",", "ReLU", "(", ")", ",", "\n", "Linear", "(", "hidden_units", ",", "hidden_units", ")", ",", "ReLU", "(", ")", ",", "\n", "Linear", "(", "hidden_units", ",", "1", ")", "# reward and entropy not predicted separately", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac_models.MlpStateValue.forward": [[69, 71], ["super().forward"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward"], ["", "def", "forward", "(", "self", ",", "obs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "forward", "(", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac_models.MlpPolicy.__init__": [[74, 79], ["torch.nn.Sequential.__init__", "dcac_models.DelayedMlpModule", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "rlrd.nn.TanhNormalLayer"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ",", "act_delay", "=", "True", ",", "obs_delay", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "DelayedMlpModule", "(", "observation_space", ",", "action_space", ",", "act_delay", "=", "act_delay", ",", "obs_delay", "=", "obs_delay", ")", ",", "ReLU", "(", ")", ",", "\n", "Linear", "(", "hidden_units", ",", "hidden_units", ")", ",", "ReLU", "(", ")", ",", "\n", "TanhNormalLayer", "(", "hidden_units", ",", "action_space", ".", "shape", "[", "0", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac_models.MlpPolicy.forward": [[82, 84], ["super().forward"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward"], ["", "def", "forward", "(", "self", ",", "obs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "forward", "(", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac_models.Mlp.__init__": [[87, 93], ["rlrd.sac_models.ActorModule.__init__", "isinstance", "torch.nn.ModuleList", "dcac_models.MlpPolicy", "dcac_models.MlpStateValue", "range"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ":", "int", "=", "256", ",", "num_critics", ":", "int", "=", "2", ",", "act_delay", ":", "bool", "=", "True", ",", "obs_delay", ":", "bool", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "observation_space", ",", "gym", ".", "spaces", ".", "Tuple", ")", "\n", "self", ".", "critics", "=", "ModuleList", "(", "MlpStateValue", "(", "observation_space", ",", "action_space", ",", "hidden_units", ",", "act_delay", "=", "act_delay", ",", "obs_delay", "=", "obs_delay", ")", "for", "_", "in", "range", "(", "num_critics", ")", ")", "\n", "self", ".", "actor", "=", "MlpPolicy", "(", "observation_space", ",", "action_space", ",", "hidden_units", ",", "act_delay", "=", "act_delay", ",", "obs_delay", "=", "obs_delay", ")", "\n", "self", ".", "critic_output_layers", "=", "[", "c", "[", "-", "1", "]", "for", "c", "in", "self", ".", "critics", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.__init__": [[26, 52], ["range", "range", "gym.Wrapper.__init__", "gym.spaces.Tuple", "collections.deque", "collections.deque", "collections.deque", "collections.deque", "gym.spaces.Tuple", "gym.spaces.Discrete", "gym.spaces.Discrete"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["def", "__init__", "(", "self", ",", "env", ",", "obs_delay_range", "=", "range", "(", "0", ",", "8", ")", ",", "act_delay_range", "=", "range", "(", "0", ",", "2", ")", ",", "initial_action", "=", "None", ",", "skip_initial_actions", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "wrapped_env", "=", "env", "\n", "self", ".", "obs_delay_range", "=", "obs_delay_range", "\n", "self", ".", "act_delay_range", "=", "act_delay_range", "\n", "\n", "self", ".", "observation_space", "=", "Tuple", "(", "(", "\n", "env", ".", "observation_space", ",", "# most recent observation", "\n", "Tuple", "(", "[", "env", ".", "action_space", "]", "*", "(", "obs_delay_range", ".", "stop", "+", "act_delay_range", ".", "stop", "-", "1", ")", ")", ",", "# action buffer", "\n", "Discrete", "(", "obs_delay_range", ".", "stop", ")", ",", "# observation delay int64", "\n", "Discrete", "(", "act_delay_range", ".", "stop", ")", ",", "# action delay int64", "\n", ")", ")", "\n", "\n", "self", ".", "initial_action", "=", "initial_action", "\n", "self", ".", "skip_initial_actions", "=", "skip_initial_actions", "\n", "self", ".", "past_actions", "=", "deque", "(", "maxlen", "=", "obs_delay_range", ".", "stop", "+", "act_delay_range", ".", "stop", ")", "\n", "self", ".", "past_observations", "=", "deque", "(", "maxlen", "=", "obs_delay_range", ".", "stop", ")", "\n", "self", ".", "arrival_times_actions", "=", "deque", "(", "maxlen", "=", "act_delay_range", ".", "stop", ")", "\n", "self", ".", "arrival_times_observations", "=", "deque", "(", "maxlen", "=", "obs_delay_range", ".", "stop", ")", "\n", "\n", "self", ".", "t", "=", "0", "\n", "self", ".", "done_signal_sent", "=", "False", "\n", "self", ".", "next_action", "=", "None", "\n", "self", ".", "cum_rew_actor", "=", "0.", "\n", "self", ".", "cum_rew_brain", "=", "0.", "\n", "self", ".", "prev_action_idx", "=", "0", "# TODO : initialize this better", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.reset": [[53, 79], ["super().reset", "wrappers_rd.RandomDelayWrapper.receive_action", "wrappers_rd.RandomDelayWrapper.receive_observation", "wrappers_rd.RandomDelayWrapper.send_action", "wrappers_rd.RandomDelayWrapper.send_observation", "wrappers_rd.RandomDelayWrapper.action_space.sample"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "cum_rew_actor", "=", "0.", "\n", "self", ".", "cum_rew_brain", "=", "0.", "\n", "self", ".", "prev_action_idx", "=", "0", "# TODO : initialize this better", "\n", "self", ".", "done_signal_sent", "=", "False", "\n", "first_observation", "=", "super", "(", ")", ".", "reset", "(", "**", "kwargs", ")", "\n", "\n", "# fill up buffers", "\n", "self", ".", "t", "=", "-", "(", "self", ".", "obs_delay_range", ".", "stop", "+", "self", ".", "act_delay_range", ".", "stop", ")", "# this is <= -2", "\n", "while", "self", ".", "t", "<", "0", ":", "\n", "            ", "act", "=", "self", ".", "action_space", ".", "sample", "(", ")", "if", "self", ".", "initial_action", "is", "None", "else", "self", ".", "initial_action", "\n", "self", ".", "send_action", "(", "act", ",", "init", "=", "True", ")", "# TODO : initialize this better", "\n", "self", ".", "send_observation", "(", "(", "first_observation", ",", "0.", ",", "False", ",", "{", "}", ",", "0", ",", "1", ")", ")", "# TODO : initialize this better", "\n", "self", ".", "t", "+=", "1", "\n", "", "self", ".", "receive_action", "(", ")", "# an action has to be applied", "\n", "\n", "assert", "self", ".", "t", "==", "0", "\n", "received_observation", ",", "*", "_", "=", "self", ".", "receive_observation", "(", ")", "\n", "# print(\"DEBUG: end of reset ---\")", "\n", "# print(f\"DEBUG: self.past_actions:{self.past_actions}\")", "\n", "# print(f\"DEBUG: self.past_observations:{self.past_observations}\")", "\n", "# print(f\"DEBUG: self.arrival_times_actions:{self.arrival_times_actions}\")", "\n", "# print(f\"DEBUG: self.arrival_times_observations:{self.arrival_times_observations}\")", "\n", "# print(f\"DEBUG: self.t:{self.t}\")", "\n", "# print(\"DEBUG: ---\")", "\n", "return", "received_observation", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.step": [[80, 119], ["wrappers_rd.RandomDelayWrapper.send_action", "wrappers_rd.RandomDelayWrapper.receive_observation", "wrappers_rd.RandomDelayWrapper.receive_action", "wrappers_rd.RandomDelayWrapper.send_observation", "wrappers_rd.RandomDelayWrapper.env.step", "wrappers_rd.RandomDelayWrapper.receive_action", "wrappers_rd.RandomDelayWrapper.send_observation"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_action", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_observation"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "\"\"\"\n        When kappa is 0 and alpha is 0, this is equivalent to the RTRL setting\n        (The inference time is NOT considered part of beta or kappa)\n        \"\"\"", "\n", "\n", "# at the brain", "\n", "self", ".", "send_action", "(", "action", ")", "\n", "\n", "# at the remote actor", "\n", "if", "self", ".", "t", "<", "self", ".", "act_delay_range", ".", "stop", "and", "self", ".", "skip_initial_actions", ":", "\n", "# assert False, \"skip_initial_actions==True is not supported\"", "\n", "# do nothing until the brain's first actions arrive at the remote actor", "\n", "            ", "self", ".", "receive_action", "(", ")", "\n", "", "elif", "self", ".", "done_signal_sent", ":", "\n", "# just resend the last observation until the brain gets it", "\n", "            ", "self", ".", "send_observation", "(", "self", ".", "past_observations", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "m", ",", "r", ",", "d", ",", "info", "=", "self", ".", "env", ".", "step", "(", "self", ".", "next_action", ")", "# before receive_action (e.g. rtrl setting with 0 delays)", "\n", "kappa", ",", "beta", "=", "self", ".", "receive_action", "(", ")", "\n", "self", ".", "cum_rew_actor", "+=", "r", "\n", "self", ".", "done_signal_sent", "=", "d", "\n", "self", ".", "send_observation", "(", "(", "m", ",", "self", ".", "cum_rew_actor", ",", "d", ",", "info", ",", "kappa", ",", "beta", ")", ")", "\n", "\n", "# at the brain again", "\n", "", "m", ",", "cum_rew_actor_delayed", ",", "d", ",", "info", "=", "self", ".", "receive_observation", "(", ")", "\n", "r", "=", "cum_rew_actor_delayed", "-", "self", ".", "cum_rew_brain", "\n", "self", ".", "cum_rew_brain", "=", "cum_rew_actor_delayed", "\n", "\n", "self", ".", "t", "+=", "1", "\n", "\n", "# print(\"DEBUG: end of step ---\")", "\n", "# print(f\"DEBUG: self.past_actions:{self.past_actions}\")", "\n", "# print(f\"DEBUG: self.past_observations:{self.past_observations}\")", "\n", "# print(f\"DEBUG: self.arrival_times_actions:{self.arrival_times_actions}\")", "\n", "# print(f\"DEBUG: self.arrival_times_observations:{self.arrival_times_observations}\")", "\n", "# print(f\"DEBUG: self.t:{self.t}\")", "\n", "# print(\"DEBUG: ---\")", "\n", "return", "m", ",", "r", ",", "d", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.send_action": [[120, 129], ["wrappers_rd.RandomDelayWrapper.arrival_times_actions.appendleft", "wrappers_rd.RandomDelayWrapper.past_actions.appendleft", "random.sample"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample"], ["", "def", "send_action", "(", "self", ",", "action", ",", "init", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Appends action to the left of self.past_actions\n        Simulates the time at which it will reach the agent and stores it on the left of self.arrival_times_actions\n        \"\"\"", "\n", "# at the brain", "\n", "kappa", ",", "=", "sample", "(", "self", ".", "act_delay_range", ",", "1", ")", "if", "not", "init", "else", "[", "0", ",", "]", "# TODO: change this if we implement a different initialization", "\n", "self", ".", "arrival_times_actions", ".", "appendleft", "(", "self", ".", "t", "+", "kappa", ")", "\n", "self", ".", "past_actions", ".", "appendleft", "(", "action", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_action": [[130, 145], ["next", "enumerate"], "methods", ["None"], ["", "def", "receive_action", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Looks for the last created action that has arrived before t at the agent\n        NB: since it is the most recently created action that the agent got, this is the one that is to be applied\n        Returns:\n            next_action_idx: int: the index of the action that is going to be applied\n            prev_action_idx: int: the index of the action previously being applied (i.e. of the action that influenced the observation since it is retrieved instantaneously in usual Gym envs)\n        \"\"\"", "\n", "# CAUTION: from the brain point of view, the \"previous action\"'s age (kappa_t) is not like the previous \"next action\"'s age (beta_{t-1}) (e.g. repeated observations)", "\n", "prev_action_idx", "=", "self", ".", "prev_action_idx", "+", "1", "# + 1 is to account for the fact that this was the right idx 1 time-step before", "\n", "next_action_idx", "=", "next", "(", "i", "for", "i", ",", "t", "in", "enumerate", "(", "self", ".", "arrival_times_actions", ")", "if", "t", "<=", "self", ".", "t", ")", "\n", "self", ".", "prev_action_idx", "=", "next_action_idx", "\n", "self", ".", "next_action", "=", "self", ".", "past_actions", "[", "next_action_idx", "]", "\n", "# print(f\"DEBUG: next_action_idx:{next_action_idx}, prev_action_idx:{prev_action_idx}\")", "\n", "return", "next_action_idx", ",", "prev_action_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.send_observation": [[146, 155], ["random.sample", "wrappers_rd.RandomDelayWrapper.arrival_times_observations.appendleft", "wrappers_rd.RandomDelayWrapper.past_observations.appendleft"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample"], ["", "def", "send_observation", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"\n        Appends obs to the left of self.past_observations\n        Simulates the time at which it will reach the brain and appends it in self.arrival_times_observations\n        \"\"\"", "\n", "# at the remote actor", "\n", "alpha", ",", "=", "sample", "(", "self", ".", "obs_delay_range", ",", "1", ")", "\n", "self", ".", "arrival_times_observations", ".", "appendleft", "(", "self", ".", "t", "+", "alpha", ")", "\n", "self", ".", "past_observations", ".", "appendleft", "(", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.RandomDelayWrapper.receive_observation": [[156, 175], ["next", "tuple", "enumerate", "itertools.islice"], "methods", ["None"], ["", "def", "receive_observation", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Looks for the last created observation at the agent/observer that reached the brain at time t\n        NB: since this is the most recently created observation that the brain got, this is the one currently being considered as the last observation\n        Returns:\n            augmented_obs: tuple:\n                m: object: last observation that reached the brain\n                past_actions: tuple: the history of actions that the brain sent so far\n                alpha: int: number of micro time steps it took the last observation to travel from the agent/observer to the brain\n                kappa: int: action travel delay + number of micro time-steps for which the next action has been applied at the agent\n                beta: int: action travel delay + number of micro time-steps for which the previous action has been applied at the agent\n            r: float: delayed reward corresponding to the transition that created m\n            d: bool: delayed done corresponding to the transition that created m\n            info: dict: delayed info corresponding to the transition that created m\n        \"\"\"", "\n", "# at the brain", "\n", "alpha", "=", "next", "(", "i", "for", "i", ",", "t", "in", "enumerate", "(", "self", ".", "arrival_times_observations", ")", "if", "t", "<=", "self", ".", "t", ")", "\n", "m", ",", "r", ",", "d", ",", "info", ",", "kappa", ",", "beta", "=", "self", ".", "past_observations", "[", "alpha", "]", "\n", "return", "(", "m", ",", "tuple", "(", "itertools", ".", "islice", "(", "self", ".", "past_actions", ",", "0", ",", "self", ".", "past_actions", ".", "maxlen", "-", "1", ")", ")", ",", "alpha", ",", "kappa", ",", "beta", ")", ",", "r", ",", "d", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.UnseenRandomDelayWrapper.__init__": [[183, 186], ["wrappers_rd.RandomDelayWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["def", "__init__", "(", "self", ",", "env", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ",", "**", "kwargs", ")", "\n", "self", ".", "observation_space", "=", "env", ".", "observation_space", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.UnseenRandomDelayWrapper.reset": [[187, 190], ["wrappers_rd.RandomDelayWrapper.reset"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "t", "=", "super", "(", ")", ".", "reset", "(", "**", "kwargs", ")", "# t: (m, tuple(self.past_actions), alpha, kappa, beta)", "\n", "return", "t", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.UnseenRandomDelayWrapper.step": [[191, 194], ["wrappers_rd.RandomDelayWrapper.step"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "t", ",", "*", "aux", "=", "super", "(", ")", ".", "step", "(", "action", ")", "# t: (m, tuple(self.past_actions), alpha, kappa, beta)", "\n", "return", "(", "t", "[", "0", "]", ",", "*", "aux", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper1.__init__": [[211, 213], ["wrappers_rd.RandomDelayWrapper.__init__", "range", "range"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["def", "__init__", "(", "self", ",", "env", ",", "initial_action", "=", "None", ",", "skip_initial_actions", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ",", "obs_delay_range", "=", "range", "(", "0", ",", "7", ")", ",", "act_delay_range", "=", "range", "(", "0", ",", "7", ")", ",", "initial_action", "=", "initial_action", ",", "skip_initial_actions", "=", "skip_initial_actions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper1.send_observation": [[214, 219], ["wrappers_rd.simple_wifi_sampler1", "wrappers_rd.WifiDelayWrapper1.arrival_times_observations.appendleft", "wrappers_rd.WifiDelayWrapper1.past_observations.appendleft"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.simple_wifi_sampler1"], ["", "def", "send_observation", "(", "self", ",", "obs", ")", ":", "\n", "# at the remote actor", "\n", "        ", "alpha", "=", "simple_wifi_sampler1", "(", ")", "\n", "self", ".", "arrival_times_observations", ".", "appendleft", "(", "self", ".", "t", "+", "alpha", ")", "\n", "self", ".", "past_observations", ".", "appendleft", "(", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper1.send_action": [[220, 225], ["wrappers_rd.WifiDelayWrapper1.arrival_times_actions.appendleft", "wrappers_rd.WifiDelayWrapper1.past_actions.appendleft", "wrappers_rd.simple_wifi_sampler1"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.simple_wifi_sampler1"], ["", "def", "send_action", "(", "self", ",", "action", ",", "init", "=", "False", ")", ":", "\n", "# at the brain", "\n", "        ", "kappa", "=", "simple_wifi_sampler1", "(", ")", "if", "not", "init", "else", "0", "# TODO: change this if we implement a different initialization", "\n", "self", ".", "arrival_times_actions", ".", "appendleft", "(", "self", ".", "t", "+", "kappa", ")", "\n", "self", ".", "past_actions", ".", "appendleft", "(", "action", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.__init__": [[234, 236], ["wrappers_rd.RandomDelayWrapper.__init__", "range", "range"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["def", "__init__", "(", "self", ",", "env", ",", "initial_action", "=", "None", ",", "skip_initial_actions", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ",", "obs_delay_range", "=", "range", "(", "0", ",", "5", ")", ",", "act_delay_range", "=", "range", "(", "0", ",", "5", ")", ",", "initial_action", "=", "initial_action", ",", "skip_initial_actions", "=", "skip_initial_actions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_observation": [[237, 242], ["wrappers_rd.simple_wifi_sampler2", "wrappers_rd.WifiDelayWrapper2.arrival_times_observations.appendleft", "wrappers_rd.WifiDelayWrapper2.past_observations.appendleft"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.simple_wifi_sampler2"], ["", "def", "send_observation", "(", "self", ",", "obs", ")", ":", "\n", "# at the remote actor", "\n", "        ", "alpha", "=", "simple_wifi_sampler2", "(", ")", "\n", "self", ".", "arrival_times_observations", ".", "appendleft", "(", "self", ".", "t", "+", "alpha", ")", "\n", "self", ".", "past_observations", ".", "appendleft", "(", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.WifiDelayWrapper2.send_action": [[243, 248], ["wrappers_rd.WifiDelayWrapper2.arrival_times_actions.appendleft", "wrappers_rd.WifiDelayWrapper2.past_actions.appendleft", "wrappers_rd.simple_wifi_sampler2"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.simple_wifi_sampler2"], ["", "def", "send_action", "(", "self", ",", "action", ",", "init", "=", "False", ")", ":", "\n", "# at the brain", "\n", "        ", "kappa", "=", "simple_wifi_sampler2", "(", ")", "if", "not", "init", "else", "0", "# TODO: change this if we implement a different initialization", "\n", "self", ".", "arrival_times_actions", ".", "appendleft", "(", "self", ".", "t", "+", "kappa", ")", "\n", "self", ".", "past_actions", ".", "appendleft", "(", "action", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.simple_wifi_sampler1": [[196, 198], ["numpy.random.choice"], "function", ["None"], ["", "", "def", "simple_wifi_sampler1", "(", ")", ":", "\n", "    ", "return", "np", ".", "random", ".", "choice", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", "]", ",", "p", "=", "[", "0.3082", ",", "0.5927", ",", "0.0829", ",", "0.0075", ",", "0.0031", ",", "0.0056", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers_rd.simple_wifi_sampler2": [[200, 202], ["numpy.random.choice"], "function", ["None"], ["", "def", "simple_wifi_sampler2", "(", ")", ":", "\n", "    ", "return", "np", ".", "random", ".", "choice", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ",", "p", "=", "[", "0.3082", ",", "0.5927", ",", "0.0829", ",", "0.0162", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac.Agent.__post_init__": [[23, 51], ["dcac.Agent.Model", "dcac.Agent.to", "rlrd.nn.no_grad", "dcac.Agent.OutputNorm", "dcac.Agent.OutputNorm", "torch.optim.Adam", "rlrd.memory.TrajMemoryNoHidden", "Env", "copy.deepcopy", "copy.deepcopy", "dcac.Agent.model.parameters"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad"], ["def", "__post_init__", "(", "self", ",", "Env", ")", ":", "\n", "        ", "with", "Env", "(", ")", "as", "env", ":", "\n", "            ", "observation_space", ",", "action_space", "=", "env", ".", "observation_space", ",", "env", ".", "action_space", "\n", "self", ".", "sup_obs_delay", "=", "env", ".", "obs_delay_range", ".", "stop", "\n", "self", ".", "sup_act_delay", "=", "env", ".", "act_delay_range", ".", "stop", "\n", "self", ".", "act_buf_size", "=", "self", ".", "sup_obs_delay", "+", "self", ".", "sup_act_delay", "-", "1", "\n", "self", ".", "old_act_buf_size", "=", "deepcopy", "(", "self", ".", "act_buf_size", ")", "\n", "if", "self", ".", "rtac", ":", "\n", "                ", "self", ".", "act_buf_size", "=", "1", "\n", "\n", "", "", "assert", "self", ".", "device", "is", "not", "None", "\n", "device", "=", "self", ".", "device", "# or (\"cuda\" if torch.cuda.is_available() else \"cpu\")", "\n", "model", "=", "self", ".", "Model", "(", "observation_space", ",", "action_space", ")", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "self", ".", "model_target", "=", "no_grad", "(", "deepcopy", "(", "self", ".", "model", ")", ")", "\n", "\n", "self", ".", "outputnorm", "=", "self", ".", "OutputNorm", "(", "self", ".", "model", ".", "critic_output_layers", ")", "\n", "self", ".", "outputnorm_target", "=", "self", ".", "OutputNorm", "(", "self", ".", "model_target", ".", "critic_output_layers", ")", "\n", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "self", ".", "memory", "=", "TrajMemoryNoHidden", "(", "self", ".", "memory_size", ",", "self", ".", "batchsize", ",", "device", ",", "history", "=", "self", ".", "act_buf_size", ")", "\n", "self", ".", "traj_new_actions", "=", "[", "None", ",", "]", "*", "self", ".", "act_buf_size", "\n", "self", ".", "traj_new_actions_detach", "=", "[", "None", ",", "]", "*", "self", ".", "act_buf_size", "\n", "self", ".", "traj_new_actions_log_prob", "=", "[", "None", ",", "]", "*", "self", ".", "act_buf_size", "\n", "self", ".", "traj_new_actions_log_prob_detach", "=", "[", "None", ",", "]", "*", "self", ".", "act_buf_size", "\n", "self", ".", "traj_new_augm_obs", "=", "[", "None", ",", "]", "*", "(", "self", ".", "act_buf_size", "+", "1", ")", "\n", "\n", "self", ".", "is_training", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.dcac.Agent.train": [[52, 175], ["dcac.Agent.memory.sample", "torch.ones", "range", "torch.stack", "tuple", "torch.stack", "torch.stack", "tuple", "sum", "functools.reduce().squeeze", "torch.zeros", "torch.zeros", "reversed", "dcac.Agent.optimizer.zero_grad", "loss_total.backward", "dcac.Agent.optimizer.step", "rlrd.nn.exponential_moving_average", "dict", "c().squeeze", "reversed", "torch.max", "torch.min", "torch.zeros().scatter_", "torch.zeros", "torch.max", "torch.zeros().scatter_", "torch.no_grad", "functools.reduce().squeeze", "torch.zeros", "torch.zeros", "reversed", "c", "range", "torch.zeros.mean", "dcac.Agent.model_target.parameters", "dcac.Agent.model.parameters", "range", "torch.where", "torch.where.unsqueeze().long", "torch.where.unsqueeze().long", "tuple", "dcac.Agent.model.actor", "dcac.Agent.rsample", "dcac.Agent.traj_new_actions[].detach", "dcac.Agent.log_prob", "dcac.Agent.traj_new_actions_log_prob[].detach", "torch.stack", "c", "range", "torch.nn.functional.mse_loss", "functools.reduce", "loss_total.detach", "sum.detach", "torch.zeros.detach", "len", "c", "torch.zeros", "torch.zeros", "enumerate", "range", "enumerate", "enumerate", "functools.reduce", "torch.stack", "len", "torch.where.unsqueeze", "len", "torch.where.unsqueeze", "torch.stack", "enumerate"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.exponential_moving_average", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.rsample", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.log_prob", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach"], ["", "def", "train", "(", "self", ")", ":", "\n", "# sample a trajectory of length self.act_buf_size", "\n", "# NB: when terminals is True, the terminal augmented state is the last one of the trajectory (this is ensured by the sampling procedure)", "\n", "\n", "# TODO: act_traj is useless, it could be removed from the replay memory", "\n", "# FIXME: the profiler indicates that memory is inefficient, optimize", "\n", "\n", "        ", "augm_obs_traj", ",", "act_traj", ",", "rew_traj", ",", "terminals", "=", "self", ".", "memory", ".", "sample", "(", ")", "\n", "\n", "batch_size", "=", "terminals", ".", "shape", "[", "0", "]", "\n", "\n", "# value of the first augmented state:", "\n", "values", "=", "[", "c", "(", "augm_obs_traj", "[", "0", "]", ")", ".", "squeeze", "(", ")", "for", "c", "in", "self", ".", "model", ".", "critics", "]", "\n", "\n", "# nstep_len is the number of valid transitions of the sampled sub-trajectory, not counting the first one which is always valid since we consider the action delay to be always >= 1.", "\n", "# nstep_len will be e.g. 0 in the rtrl setting (an action delay of 0 here means an action delay of 1 in the paper).", "\n", "\n", "int_tens_type", "=", "obs_del", "=", "augm_obs_traj", "[", "0", "]", "[", "2", "]", ".", "dtype", "\n", "ones_tens", "=", "torch", ".", "ones", "(", "batch_size", ",", "device", "=", "self", ".", "device", ",", "dtype", "=", "int_tens_type", ",", "requires_grad", "=", "False", ")", "\n", "\n", "if", "not", "self", ".", "rtac", ":", "\n", "            ", "nstep_len", "=", "ones_tens", "*", "(", "self", ".", "act_buf_size", "-", "1", ")", "\n", "for", "i", "in", "reversed", "(", "range", "(", "self", ".", "act_buf_size", ")", ")", ":", "# we don't care about the delay of the first observation in the trajectory, but we care about the last one", "\n", "                ", "obs_del", "=", "augm_obs_traj", "[", "i", "+", "1", "]", "[", "2", "]", "# observation delay (alpha)", "\n", "act_del", "=", "augm_obs_traj", "[", "i", "+", "1", "]", "[", "4", "]", "# action_delay (beta)", "\n", "tot_del", "=", "obs_del", "+", "act_del", "\n", "# TODO: the last iteration is useless", "\n", "nstep_len", "=", "torch", ".", "where", "(", "(", "tot_del", "<=", "i", ")", ",", "ones_tens", "*", "(", "i", "-", "1", ")", ",", "nstep_len", ")", "\n", "", "nstep_max_len", "=", "torch", ".", "max", "(", "nstep_len", ")", "\n", "nstep_min_len", "=", "torch", ".", "min", "(", "nstep_len", ")", "\n", "assert", "nstep_min_len", ">=", "0", ",", "\"Each total delay must be at least 1 (instantaneous turn-based RL not supported)\"", "\n", "nstep_one_hot", "=", "torch", ".", "zeros", "(", "len", "(", "nstep_len", ")", ",", "nstep_max_len", "+", "1", ",", "device", "=", "self", ".", "device", ",", "requires_grad", "=", "False", ")", ".", "scatter_", "(", "1", ",", "nstep_len", ".", "unsqueeze", "(", "1", ")", ".", "long", "(", ")", ",", "1.", ")", "\n", "", "else", ":", "# RTAC is equivalent to doing only 1-step backups (i.e. nstep_len==0)", "\n", "            ", "nstep_len", "=", "torch", ".", "zeros", "(", "batch_size", ",", "device", "=", "self", ".", "device", ",", "dtype", "=", "int_tens_type", ",", "requires_grad", "=", "False", ")", "\n", "nstep_max_len", "=", "torch", ".", "max", "(", "nstep_len", ")", "\n", "nstep_one_hot", "=", "torch", ".", "zeros", "(", "len", "(", "nstep_len", ")", ",", "nstep_max_len", "+", "1", ",", "device", "=", "self", ".", "device", ",", "requires_grad", "=", "False", ")", ".", "scatter_", "(", "1", ",", "nstep_len", ".", "unsqueeze", "(", "1", ")", ".", "long", "(", ")", ",", "1.", ")", "\n", "terminals", "=", "terminals", "if", "self", ".", "act_buf_size", "==", "1", "else", "terminals", "*", "0.0", "# the way the replay memory works, RTAC will never encounter terminal states for buffers of more than 1 action", "\n", "\n", "# use the current policy to compute a new trajectory of actions of length self.act_buf_size", "\n", "", "for", "i", "in", "range", "(", "self", ".", "act_buf_size", "+", "1", ")", ":", "\n", "# compute a new action and update the corresponding *next* augmented observation:", "\n", "            ", "augm_obs", "=", "augm_obs_traj", "[", "i", "]", "\n", "if", "i", ">", "0", ":", "\n", "                ", "act_slice", "=", "tuple", "(", "self", ".", "traj_new_actions", "[", "self", ".", "act_buf_size", "-", "i", ":", "self", ".", "act_buf_size", "]", ")", "\n", "augm_obs", "=", "augm_obs", "[", ":", "1", "]", "+", "(", "(", "act_slice", "+", "augm_obs", "[", "1", "]", "[", "i", ":", "]", ")", ",", ")", "+", "augm_obs", "[", "2", ":", "]", "\n", "", "if", "i", "<", "self", ".", "act_buf_size", ":", "# we don't compute the action for the last observation of the trajectory", "\n", "                ", "new_action_distribution", "=", "self", ".", "model", ".", "actor", "(", "augm_obs", ")", "\n", "# this is stored in right -> left order for replacing correctly in augm_obs:", "\n", "self", ".", "traj_new_actions", "[", "self", ".", "act_buf_size", "-", "i", "-", "1", "]", "=", "new_action_distribution", ".", "rsample", "(", ")", "\n", "self", ".", "traj_new_actions_detach", "[", "self", ".", "act_buf_size", "-", "i", "-", "1", "]", "=", "self", ".", "traj_new_actions", "[", "self", ".", "act_buf_size", "-", "i", "-", "1", "]", ".", "detach", "(", ")", "\n", "# this is stored in left -> right order for to be consistent with the reward trajectory:", "\n", "self", ".", "traj_new_actions_log_prob", "[", "i", "]", "=", "new_action_distribution", ".", "log_prob", "(", "self", ".", "traj_new_actions", "[", "self", ".", "act_buf_size", "-", "i", "-", "1", "]", ")", "\n", "self", ".", "traj_new_actions_log_prob_detach", "[", "i", "]", "=", "self", ".", "traj_new_actions_log_prob", "[", "i", "]", ".", "detach", "(", ")", "\n", "# this is stored in left -> right order:", "\n", "", "self", ".", "traj_new_augm_obs", "[", "i", "]", "=", "augm_obs", "\n", "\n", "# We now compute the state-value estimate", "\n", "# (this can be a different position in the trajectory for each element of the batch).", "\n", "# We expect each augmented state to be of shape (obs:tensor, act_buf:(tensor, ..., tensor), obs_del:tensor, act_del:tensor). Each tensor is batched.", "\n", "# To execute only 1 forward pass in the state-value estimator we recreate an artificially batched augmented state for this specific purpose.", "\n", "\n", "# FIXME: the profiler indicates that the following 5 lines are very inefficient, optimize", "\n", "\n", "", "obs_s", "=", "torch", ".", "stack", "(", "[", "self", ".", "traj_new_augm_obs", "[", "i", "+", "1", "]", "[", "0", "]", "[", "ibatch", "]", "for", "ibatch", ",", "i", "in", "enumerate", "(", "nstep_len", ")", "]", ")", "\n", "act_s", "=", "tuple", "(", "torch", ".", "stack", "(", "[", "self", ".", "traj_new_augm_obs", "[", "i", "+", "1", "]", "[", "1", "]", "[", "iact", "]", "[", "ibatch", "]", "for", "ibatch", ",", "i", "in", "enumerate", "(", "nstep_len", ")", "]", ")", "for", "iact", "in", "range", "(", "self", ".", "old_act_buf_size", ")", ")", "\n", "od_s", "=", "torch", ".", "stack", "(", "[", "self", ".", "traj_new_augm_obs", "[", "i", "+", "1", "]", "[", "2", "]", "[", "ibatch", "]", "for", "ibatch", ",", "i", "in", "enumerate", "(", "nstep_len", ")", "]", ")", "\n", "ad_s", "=", "torch", ".", "stack", "(", "[", "self", ".", "traj_new_augm_obs", "[", "i", "+", "1", "]", "[", "3", "]", "[", "ibatch", "]", "for", "ibatch", ",", "i", "in", "enumerate", "(", "nstep_len", ")", "]", ")", "\n", "mod_augm_obs", "=", "tuple", "(", "(", "obs_s", ",", "act_s", ",", "od_s", ",", "ad_s", ")", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "# These are the delayed state-value estimates we are looking for:", "\n", "            ", "target_mod_val", "=", "[", "c", "(", "mod_augm_obs", ")", "for", "c", "in", "self", ".", "model_target", ".", "critics", "]", "\n", "target_mod_val", "=", "reduce", "(", "torch", ".", "min", ",", "torch", ".", "stack", "(", "target_mod_val", ")", ")", ".", "squeeze", "(", ")", "# minimum target estimate", "\n", "target_mod_val", "=", "target_mod_val", "*", "(", "1.", "-", "terminals", ")", "\n", "\n", "# Now let us use this to compute the state-value targets of the batch of initial augmented states:", "\n", "\n", "value_target", "=", "torch", ".", "zeros", "(", "batch_size", ",", "device", "=", "self", ".", "device", ")", "\n", "backup_started", "=", "torch", ".", "zeros", "(", "batch_size", ",", "device", "=", "self", ".", "device", ")", "\n", "for", "i", "in", "reversed", "(", "range", "(", "nstep_max_len", "+", "1", ")", ")", ":", "\n", "                ", "start_backup_mask", "=", "nstep_one_hot", "[", ":", ",", "i", "]", "\n", "backup_started", "+=", "start_backup_mask", "\n", "value_target", "=", "self", ".", "reward_scale", "*", "rew_traj", "[", "i", "]", "-", "self", ".", "entropy_scale", "*", "self", ".", "traj_new_actions_log_prob_detach", "[", "i", "]", "+", "backup_started", "*", "self", ".", "discount", "*", "(", "value_target", "+", "start_backup_mask", "*", "target_mod_val", ")", "\n", "\n", "", "", "assert", "values", "[", "0", "]", ".", "shape", "==", "value_target", ".", "shape", ",", "f\"values[0].shape : {values[0].shape} != value_target.shape : {value_target.shape}\"", "\n", "assert", "not", "value_target", ".", "requires_grad", "\n", "\n", "# Now the critic loss is:", "\n", "\n", "loss_critic", "=", "sum", "(", "mse_loss", "(", "v", ",", "value_target", ")", "for", "v", "in", "values", ")", "\n", "\n", "# actor loss:", "\n", "# TODO: there is probably a way of merging this with the previous for loop", "\n", "\n", "model_mod_val", "=", "[", "c", "(", "mod_augm_obs", ")", "for", "c", "in", "self", ".", "model_nograd", ".", "critics", "]", "\n", "model_mod_val", "=", "reduce", "(", "torch", ".", "min", ",", "torch", ".", "stack", "(", "model_mod_val", ")", ")", ".", "squeeze", "(", ")", "# minimum model estimate", "\n", "model_mod_val", "=", "model_mod_val", "*", "(", "1.", "-", "terminals", ")", "\n", "\n", "loss_actor", "=", "torch", ".", "zeros", "(", "batch_size", ",", "device", "=", "self", ".", "device", ")", "\n", "backup_started", "=", "torch", ".", "zeros", "(", "batch_size", ",", "device", "=", "self", ".", "device", ")", "\n", "for", "i", "in", "reversed", "(", "range", "(", "nstep_max_len", "+", "1", ")", ")", ":", "\n", "            ", "start_backup_mask", "=", "nstep_one_hot", "[", ":", ",", "i", "]", "\n", "backup_started", "+=", "start_backup_mask", "\n", "loss_actor", "=", "-", "self", ".", "entropy_scale", "*", "self", ".", "traj_new_actions_log_prob", "[", "i", "]", "+", "backup_started", "*", "self", ".", "discount", "*", "(", "loss_actor", "+", "start_backup_mask", "*", "model_mod_val", ")", "\n", "", "loss_actor", "=", "-", "loss_actor", ".", "mean", "(", "0", ")", "\n", "\n", "# update model", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss_total", "=", "self", ".", "loss_alpha", "*", "loss_actor", "+", "(", "1", "-", "self", ".", "loss_alpha", ")", "*", "loss_critic", "\n", "loss_total", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# update target model", "\n", "exponential_moving_average", "(", "self", ".", "model_target", ".", "parameters", "(", ")", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "target_update", ")", "\n", "\n", "# exponential_moving_average(self.outputnorm_target.parameters(), self.outputnorm.parameters(), self.target_update)  # this is for trying PopArt in the future", "\n", "\n", "return", "dict", "(", "\n", "loss_total", "=", "loss_total", ".", "detach", "(", ")", ",", "\n", "loss_critic", "=", "loss_critic", ".", "detach", "(", ")", ",", "\n", "loss_actor", "=", "loss_actor", ".", "detach", "(", ")", ",", "\n", "memory_size", "=", "len", "(", "self", ".", "memory", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to": [[18, 22], ["super().to"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to"], ["def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "\"\"\"keeps track which device this module has been moved to\"\"\"", "\n", "self", ".", "device", "=", "device", "\n", "return", "super", "(", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.reset": [[23, 26], ["numpy.array"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the hidden state. This will be collated before being fed to the actual model and thus should be a structure of numpy arrays rather than torch tensors.\"\"\"", "\n", "return", "np", ".", "array", "(", "(", ")", ")", "# just so we don't get any errors when collating and partitioning", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.act": [[27, 36], ["rlrd.util.collate", "rlrd.util.partition", "torch.no_grad", "sac_models.ActorModule.actor", "sac_models.ActorModule.sample", "sac_models.ActorModule.sample_deterministic"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.collate", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partition", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.Independent.sample_deterministic"], ["", "def", "act", "(", "self", ",", "state", ",", "obs", ",", "r", ",", "done", ",", "info", ",", "train", "=", "False", ")", ":", "\n", "        ", "\"\"\"allows this module to be used with gym.Env\n        converts inputs to torch tensors and converts outputs to numpy arrays\"\"\"", "\n", "obs", "=", "collate", "(", "[", "obs", "]", ",", "device", "=", "self", ".", "device", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "action_distribution", "=", "self", ".", "actor", "(", "obs", ")", "\n", "action", "=", "action_distribution", ".", "sample", "(", ")", "if", "train", "else", "action_distribution", ".", "sample_deterministic", "(", ")", "\n", "", "action", ",", "=", "partition", "(", "action", ")", "\n", "return", "action", ",", "state", ",", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.MlpActionValue.__init__": [[39, 44], ["torch.nn.Sequential.__init__", "rlrd.nn.SacLinear", "torch.nn.ReLU", "rlrd.nn.SacLinear", "torch.nn.ReLU", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim_obs", ",", "dim_action", ",", "hidden_units", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "SacLinear", "(", "dim_obs", "+", "dim_action", ",", "hidden_units", ")", ",", "ReLU", "(", ")", ",", "\n", "SacLinear", "(", "hidden_units", ",", "hidden_units", ")", ",", "ReLU", "(", ")", ",", "\n", "Linear", "(", "hidden_units", ",", "2", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.MlpActionValue.forward": [[47, 50], ["torch.cat", "super().forward"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward"], ["", "def", "forward", "(", "self", ",", "obs", ",", "action", ")", ":", "\n", "        ", "x", "=", "torch", ".", "cat", "(", "(", "*", "obs", ",", "action", ")", ",", "-", "1", ")", "\n", "return", "super", "(", ")", ".", "forward", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.MlpPolicy.__init__": [[53, 58], ["torch.nn.Sequential.__init__", "rlrd.nn.SacLinear", "torch.nn.ReLU", "rlrd.nn.SacLinear", "torch.nn.ReLU", "rlrd.nn.TanhNormalLayer"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim_obs", ",", "dim_action", ",", "hidden_units", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "SacLinear", "(", "dim_obs", ",", "hidden_units", ")", ",", "ReLU", "(", ")", ",", "\n", "SacLinear", "(", "hidden_units", ",", "hidden_units", ")", ",", "ReLU", "(", ")", ",", "\n", "TanhNormalLayer", "(", "hidden_units", ",", "dim_action", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.MlpPolicy.forward": [[61, 63], ["super().forward", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward"], ["", "def", "forward", "(", "self", ",", "obs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "forward", "(", "torch", ".", "cat", "(", "obs", ",", "-", "1", ")", ")", "# XXX", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.Mlp.__init__": [[66, 74], ["torch.nn.Module.__init__", "isinstance", "sum", "torch.nn.ModuleList", "sac_models.MlpPolicy", "sac_models.MlpActionValue", "range"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ":", "int", "=", "256", ",", "num_critics", ":", "int", "=", "2", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "observation_space", ",", "gym", ".", "spaces", ".", "Tuple", ")", "\n", "dim_obs", "=", "sum", "(", "space", ".", "shape", "[", "0", "]", "for", "space", "in", "observation_space", ")", "\n", "dim_action", "=", "action_space", ".", "shape", "[", "0", "]", "\n", "self", ".", "critics", "=", "ModuleList", "(", "MlpActionValue", "(", "dim_obs", ",", "dim_action", ",", "hidden_units", ")", "for", "_", "in", "range", "(", "num_critics", ")", ")", "\n", "self", ".", "actor", "=", "MlpPolicy", "(", "dim_obs", ",", "dim_action", ",", "hidden_units", ")", "\n", "self", ".", "critic_output_layers", "=", "[", "c", "[", "-", "1", "]", "for", "c", "in", "self", ".", "critics", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ConvActor.__init__": [[78, 95], ["torch.nn.Module.__init__", "isinstance", "Conv", "torch.nn.Linear", "torch.nn.Linear", "rlrd.nn.TanhNormalLayer", "torch.no_grad", "sac_models.ConvActor.conv().view().size", "print", "sum", "sum", "sac_models.ConvActor.conv().view", "sac_models.ConvActor.conv", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ":", "int", "=", "512", ",", "Conv", ":", "type", "=", "big_conv", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "observation_space", ",", "gym", ".", "spaces", ".", "Tuple", ")", "\n", "(", "img_sp", ",", "vec_sp", ")", ",", "*", "aux", "=", "observation_space", "\n", "\n", "self", ".", "conv", "=", "Conv", "(", "img_sp", ".", "shape", "[", "0", "]", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "conv_size", "=", "self", ".", "conv", "(", "torch", ".", "zeros", "(", "(", "1", ",", "*", "img_sp", ".", "shape", ")", ")", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "size", "(", "1", ")", "\n", "print", "(", "\"conv_size =\"", ",", "conv_size", ")", "\n", "", "self", ".", "lin1", "=", "torch", ".", "nn", ".", "Linear", "(", "\n", "conv_size", "+", "vec_sp", ".", "shape", "[", "0", "]", "+", "sum", "(", "sp", ".", "shape", "[", "0", "]", "for", "sp", "in", "aux", ")", ",", "\n", "hidden_units", ")", "\n", "self", ".", "lin2", "=", "torch", ".", "nn", ".", "Linear", "(", "\n", "hidden_units", "+", "vec_sp", ".", "shape", "[", "0", "]", "+", "sum", "(", "sp", ".", "shape", "[", "0", "]", "for", "sp", "in", "aux", ")", ",", "\n", "hidden_units", "\n", ")", "\n", "self", ".", "output_layer", "=", "TanhNormalLayer", "(", "hidden_units", ",", "action_space", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ConvActor.forward": [[96, 106], ["sac_models.ConvActor.type", "sac_models.ConvActor.conv", "sac_models.ConvActor.view", "torch.nn.functional.leaky_relu", "torch.nn.functional.leaky_relu", "sac_models.ConvActor.output_layer", "sac_models.ConvActor.size", "sac_models.ConvActor.lin1", "sac_models.ConvActor.lin2", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "observation", ")", ":", "\n", "        ", "(", "x", ",", "vec", ")", ",", "*", "aux", "=", "observation", "\n", "x", "=", "x", ".", "type", "(", "torch", ".", "float32", ")", "\n", "x", "=", "x", "/", "255", "-", "0.5", "\n", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "leaky_relu", "(", "self", ".", "lin1", "(", "torch", ".", "cat", "(", "(", "x", ",", "vec", ",", "*", "aux", ")", ",", "-", "1", ")", ")", ")", "\n", "x", "=", "leaky_relu", "(", "self", ".", "lin2", "(", "torch", ".", "cat", "(", "(", "x", ",", "vec", ",", "*", "aux", ")", ",", "-", "1", ")", ")", ")", "\n", "x", "=", "self", ".", "output_layer", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ConvCritic.__init__": [[109, 127], ["torch.nn.Module.__init__", "isinstance", "Conv", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.no_grad", "sac_models.ConvCritic.conv().view().size", "sac_models.ConvCritic.conv().view", "sum", "sum", "sac_models.ConvCritic.conv", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ":", "int", "=", "512", ",", "Conv", ":", "type", "=", "big_conv", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "observation_space", ",", "gym", ".", "spaces", ".", "Tuple", ")", "\n", "(", "img_sp", ",", "vec_sp", ")", ",", "*", "aux", "=", "observation_space", "\n", "\n", "self", ".", "conv", "=", "Conv", "(", "img_sp", ".", "shape", "[", "0", "]", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "conv_size", "=", "self", ".", "conv", "(", "torch", ".", "zeros", "(", "(", "1", ",", "*", "img_sp", ".", "shape", ")", ")", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "size", "(", "1", ")", "\n", "\n", "", "self", ".", "lin1", "=", "torch", ".", "nn", ".", "Linear", "(", "\n", "conv_size", "+", "vec_sp", ".", "shape", "[", "0", "]", "+", "sum", "(", "sp", ".", "shape", "[", "0", "]", "for", "sp", "in", "aux", ")", "+", "action_space", ".", "shape", "[", "0", "]", ",", "\n", "hidden_units", ")", "\n", "self", ".", "lin2", "=", "torch", ".", "nn", ".", "Linear", "(", "\n", "hidden_units", "+", "vec_sp", ".", "shape", "[", "0", "]", "+", "sum", "(", "sp", ".", "shape", "[", "0", "]", "for", "sp", "in", "aux", ")", "+", "action_space", ".", "shape", "[", "0", "]", ",", "\n", "hidden_units", "\n", ")", "\n", "self", ".", "output_layer", "=", "torch", ".", "nn", ".", "Linear", "(", "hidden_units", ",", "2", ")", "\n", "self", ".", "critic_output_layers", "=", "self", ".", "output_layer", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ConvCritic.forward": [[128, 139], ["sac_models.ConvCritic.type", "sac_models.ConvCritic.conv", "print", "torch.nn.functional.leaky_relu", "torch.nn.functional.leaky_relu", "sac_models.ConvCritic.output_layer", "sac_models.ConvCritic.lin1", "sac_models.ConvCritic.lin2", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "observation", ",", "a", ")", ":", "\n", "        ", "(", "x", ",", "vec", ")", ",", "*", "aux", "=", "observation", "\n", "x", "=", "x", ".", "type", "(", "torch", ".", "float32", ")", "\n", "x", "=", "x", "/", "255", "-", "0.5", "\n", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "print", "(", "x", ".", "shape", ")", "\n", "# x = x.view(x.size(0), -1)", "\n", "x", "=", "leaky_relu", "(", "self", ".", "lin1", "(", "torch", ".", "cat", "(", "(", "x", ",", "vec", ",", "*", "aux", ",", "a", ")", ",", "-", "1", ")", ")", ")", "\n", "x", "=", "leaky_relu", "(", "self", ".", "lin2", "(", "torch", ".", "cat", "(", "(", "x", ",", "vec", ",", "*", "aux", ",", "a", ")", ",", "-", "1", ")", ")", ")", "\n", "x", "=", "self", ".", "output_layer", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ConvModel.__init__": [[142, 147], ["torch.nn.Module.__init__", "sac_models.ConvActor", "torch.nn.ModuleList", "sum", "sac_models.ConvCritic", "range"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "num_critics", ":", "int", "=", "2", ",", "hidden_units", ":", "int", "=", "256", ",", "Conv", ":", "type", "=", "big_conv", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "actor", "=", "ConvActor", "(", "observation_space", ",", "action_space", ",", "hidden_units", ",", "Conv", ")", "\n", "self", ".", "critics", "=", "ModuleList", "(", "ConvCritic", "(", "observation_space", ",", "action_space", ",", "hidden_units", ",", "Conv", ")", "for", "_", "in", "range", "(", "num_critics", ")", ")", "\n", "self", ".", "critic_output_layers", "=", "sum", "(", "(", "c", ".", "critic_output_layers", "for", "c", "in", "self", ".", "critics", ")", ",", "(", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models_rd.DelayedMlpModule.__init__": [[13, 69], ["torch.nn.Module.__init__", "isinstance", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "is_Q_network", ",", "hidden_units", ":", "int", "=", "256", ",", "obs_delay", "=", "True", ",", "act_delay", "=", "True", ",", "tbmdp", "=", "False", ")", ":", "# FIXME: action_space param is useless", "\n", "        ", "\"\"\"\n        Args:\n            observation_space:\n                Tuple((\n                    obs_space,  # most recent observation\n                    Tuple([act_space] * (obs_delay_range.stop + act_delay_range.stop)),  # action buffer\n                    Discrete(obs_delay_range.stop),  # observation delay int64\n                    Discrete(act_delay_range.stop),  # action delay int64\n                ))\n            action_space\n            is_Q_network: bool: if True, the input of forward() expects the action to be appended at the end of the input\n            hidden_units: number of output units of this module\n            (optional) obs_delay: bool (default True): if False, the observation delay of observation_space will be ignored (e.g. unknown)\n            (optional) act_delay: bool (default True): if False, the action delay of observation_space will be ignored (e.g. unknown)\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "observation_space", ",", "gym", ".", "spaces", ".", "Tuple", ")", "\n", "# TODO: check that x is actually in:", "\n", "# Tuple((", "\n", "# \tobs_space,  # most recent observation", "\n", "# \tTuple([act_space] * (obs_delay_range.stop + act_delay_range.stop)),  # action buffer", "\n", "# \tDiscrete(obs_delay_range.stop),  # observation delay int64", "\n", "# \tDiscrete(act_delay_range.stop),  # kappa int64", "\n", "#   Discrete(act_delay_range.stop+1),  # beta int64 (not used by the model)", "\n", "# ))", "\n", "\n", "self", ".", "tbmdp", "=", "tbmdp", "\n", "self", ".", "is_Q_network", "=", "is_Q_network", "\n", "self", ".", "act_delay", "=", "act_delay", "\n", "self", ".", "obs_delay", "=", "obs_delay", "\n", "\n", "self", ".", "obs_dim", "=", "observation_space", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "self", ".", "buf_size", "=", "len", "(", "observation_space", "[", "1", "]", ")", "\n", "# print(f\"DEBUG: MLP self.buf_size: {self.buf_size}\")", "\n", "self", ".", "act_dim", "=", "observation_space", "[", "1", "]", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "assert", "self", ".", "act_dim", "==", "action_space", ".", "shape", "[", "0", "]", ",", "f\"action spaces mismatch: {self.act_dim} and {action_space.shape[0]}\"", "\n", "\n", "if", "self", ".", "is_Q_network", ":", "\n", "            ", "if", "self", ".", "tbmdp", ":", "\n", "                ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "self", ".", "act_dim", ",", "hidden_units", ")", "\n", "", "elif", "self", ".", "act_delay", "and", "self", ".", "obs_delay", ":", "\n", "                ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "(", "self", ".", "act_dim", "+", "2", ")", "*", "self", ".", "buf_size", "+", "self", ".", "act_dim", ",", "hidden_units", ")", "\n", "", "elif", "self", ".", "act_delay", "or", "self", ".", "obs_delay", ":", "\n", "                ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "(", "self", ".", "act_dim", "+", "1", ")", "*", "self", ".", "buf_size", "+", "self", ".", "act_dim", ",", "hidden_units", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "self", ".", "act_dim", "*", "self", ".", "buf_size", "+", "self", ".", "act_dim", ",", "hidden_units", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "tbmdp", ":", "\n", "                ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", ",", "hidden_units", ")", "\n", "", "elif", "self", ".", "act_delay", "and", "self", ".", "obs_delay", ":", "\n", "                ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "(", "self", ".", "act_dim", "+", "2", ")", "*", "self", ".", "buf_size", ",", "hidden_units", ")", "\n", "", "elif", "self", ".", "act_delay", "or", "self", ".", "obs_delay", ":", "\n", "                ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "(", "self", ".", "act_dim", "+", "1", ")", "*", "self", ".", "buf_size", ",", "hidden_units", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "lin", "=", "Linear", "(", "self", ".", "obs_dim", "+", "self", ".", "act_dim", "*", "self", ".", "buf_size", ",", "hidden_units", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models_rd.DelayedMlpModule.forward": [[70, 114], ["isinstance", "torch.cat", "torch.cat", "sac_models_rd.DelayedMlpModule.lin", "sac_models_rd.DelayedMlpModule.lin", "torch.zeros().scatter_", "torch.cat", "torch.zeros().scatter_", "torch.cat", "torch.cat", "torch.cat", "obs_del.unsqueeze().long", "act_del.unsqueeze().long", "torch.zeros", "torch.zeros", "obs_del.unsqueeze", "act_del.unsqueeze"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "isinstance", "(", "x", ",", "tuple", ")", ",", "f\"x is not a tuple: {x}\"", "\n", "# TODO: check that x is actually in:", "\n", "# Tuple((", "\n", "# \tobs_space,  # most recent observation", "\n", "# \tTuple([act_space] * (obs_delay_range.stop + act_delay_range.stop)),  # action buffer", "\n", "# \tDiscrete(obs_delay_range.stop),  # observation delay int64", "\n", "# \tDiscrete(act_delay_range.stop),  # kappa int64", "\n", "#   Discrete(act_delay_range.stop+1),  # beta int64 (not used by the model)", "\n", "# ))", "\n", "\n", "# TODO: double check that everything is correct (dims, devices, autograd)", "\n", "# TODO: triple check devices...", "\n", "\n", "obs", "=", "x", "[", "0", "]", "\n", "\n", "if", "self", ".", "tbmdp", ":", "\n", "            ", "input", "=", "obs", "\n", "if", "self", ".", "is_Q_network", ":", "\n", "                ", "act", "=", "x", "[", "5", "]", "\n", "input", "=", "torch", ".", "cat", "(", "(", "input", ",", "act", ")", ",", "dim", "=", "1", ")", "\n", "", "h", "=", "self", ".", "lin", "(", "input", ")", "\n", "return", "h", "\n", "\n", "", "act_buf", "=", "torch", ".", "cat", "(", "x", "[", "1", "]", ",", "dim", "=", "1", ")", "\n", "\n", "input", "=", "torch", ".", "cat", "(", "(", "obs", ",", "act_buf", ")", ",", "dim", "=", "1", ")", "\n", "\n", "batch_size", "=", "obs", ".", "shape", "[", "0", "]", "\n", "if", "self", ".", "obs_delay", ":", "\n", "            ", "obs_del", "=", "x", "[", "2", "]", "\n", "obs_one_hot", "=", "torch", ".", "zeros", "(", "batch_size", ",", "self", ".", "buf_size", ",", "device", "=", "input", ".", "device", ")", ".", "scatter_", "(", "1", ",", "obs_del", ".", "unsqueeze", "(", "1", ")", ".", "long", "(", ")", ",", "1.0", ")", "\n", "input", "=", "torch", ".", "cat", "(", "(", "input", ",", "obs_one_hot", ")", ",", "dim", "=", "1", ")", "\n", "", "if", "self", ".", "act_delay", ":", "\n", "            ", "act_del", "=", "x", "[", "3", "]", "\n", "act_one_hot", "=", "torch", ".", "zeros", "(", "batch_size", ",", "self", ".", "buf_size", ",", "device", "=", "input", ".", "device", ")", ".", "scatter_", "(", "1", ",", "act_del", ".", "unsqueeze", "(", "1", ")", ".", "long", "(", ")", ",", "1.0", ")", "\n", "input", "=", "torch", ".", "cat", "(", "(", "input", ",", "act_one_hot", ")", ",", "dim", "=", "1", ")", "\n", "", "if", "self", ".", "is_Q_network", ":", "\n", "            ", "act", "=", "x", "[", "5", "]", "\n", "input", "=", "torch", ".", "cat", "(", "(", "input", ",", "act", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "h", "=", "self", ".", "lin", "(", "input", ")", "\n", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models_rd.MlpActionValue.__init__": [[117, 122], ["torch.nn.Sequential.__init__", "sac_models_rd.DelayedMlpModule", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ",", "act_delay", "=", "True", ",", "obs_delay", "=", "True", ",", "tbmdp", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "DelayedMlpModule", "(", "observation_space", ",", "action_space", ",", "is_Q_network", "=", "True", ",", "act_delay", "=", "act_delay", ",", "obs_delay", "=", "obs_delay", ",", "tbmdp", "=", "tbmdp", ")", ",", "ReLU", "(", ")", ",", "\n", "Linear", "(", "hidden_units", ",", "hidden_units", ")", ",", "ReLU", "(", ")", ",", "\n", "Linear", "(", "hidden_units", ",", "2", ")", "# reward and entropy predicted separately", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models_rd.MlpActionValue.forward": [[125, 128], ["super().forward"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward"], ["", "def", "forward", "(", "self", ",", "obs", ",", "action", ")", ":", "\n", "        ", "x", "=", "(", "*", "obs", ",", "action", ")", "\n", "return", "super", "(", ")", ".", "forward", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models_rd.MlpPolicy.__init__": [[131, 136], ["torch.nn.Sequential.__init__", "sac_models_rd.DelayedMlpModule", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "rlrd.nn.TanhNormalLayer"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ",", "act_delay", "=", "True", ",", "obs_delay", "=", "True", ",", "tbmdp", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "DelayedMlpModule", "(", "observation_space", ",", "action_space", ",", "is_Q_network", "=", "False", ",", "act_delay", "=", "act_delay", ",", "obs_delay", "=", "obs_delay", ",", "tbmdp", "=", "tbmdp", ")", ",", "ReLU", "(", ")", ",", "\n", "Linear", "(", "hidden_units", ",", "hidden_units", ")", ",", "ReLU", "(", ")", ",", "\n", "TanhNormalLayer", "(", "hidden_units", ",", "action_space", ".", "shape", "[", "0", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models_rd.MlpPolicy.forward": [[139, 141], ["super().forward"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward"], ["", "def", "forward", "(", "self", ",", "obs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "forward", "(", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models_rd.Mlp.__init__": [[144, 150], ["rlrd.sac_models.ActorModule.__init__", "isinstance", "torch.nn.ModuleList", "sac_models_rd.MlpPolicy", "sac_models_rd.MlpActionValue", "range"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "observation_space", ",", "action_space", ",", "hidden_units", ":", "int", "=", "256", ",", "num_critics", ":", "int", "=", "2", ",", "act_delay", ":", "bool", "=", "True", ",", "obs_delay", ":", "bool", "=", "True", ",", "tbmdp", ":", "bool", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "observation_space", ",", "gym", ".", "spaces", ".", "Tuple", ")", "\n", "self", ".", "critics", "=", "ModuleList", "(", "MlpActionValue", "(", "observation_space", ",", "action_space", ",", "hidden_units", ",", "act_delay", "=", "act_delay", ",", "obs_delay", "=", "obs_delay", ",", "tbmdp", "=", "tbmdp", ")", "for", "_", "in", "range", "(", "num_critics", ")", ")", "\n", "self", ".", "actor", "=", "MlpPolicy", "(", "observation_space", ",", "action_space", ",", "hidden_units", ",", "act_delay", "=", "act_delay", ",", "obs_delay", "=", "obs_delay", ",", "tbmdp", "=", "tbmdp", ")", "\n", "self", ".", "critic_output_layers", "=", "[", "c", "[", "-", "1", "]", "for", "c", "in", "self", ".", "critics", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.__init__": [[30, 34], ["gym.Wrapper.__init__", "envs.Env.reset"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset"], ["def", "__init__", "(", "self", ",", "env", ",", "store_env", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "self", ".", "transition", "=", "(", "self", ".", "reset", "(", ")", ",", "0.", ",", "True", ",", "{", "}", ")", "\n", "self", ".", "store_env", "=", "store_env", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset": [[35, 37], ["envs.Env.observation", "envs.Env.env.reset"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "observation", "(", "self", ".", "env", ".", "reset", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.step": [[38, 47], ["envs.Env.env.step", "envs.Env.reset", "envs.Env.observation", "pickle.dumps", "rlrd.batch_env.get_env_state"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.observation", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.get_env_state"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "next_state", ",", "reward", ",", "done", ",", "info", "=", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "next_state", "=", "self", ".", "reset", "(", ")", "if", "done", "else", "self", ".", "observation", "(", "next_state", ")", "\n", "self", ".", "transition", "=", "next_state", ",", "reward", ",", "done", ",", "info", "\n", "\n", "if", "self", ".", "store_env", ":", "\n", "            ", "info", "[", "'env_state'", "]", "=", "pickle", ".", "dumps", "(", "get_env_state", "(", "self", ")", ")", "\n", "\n", "", "return", "self", ".", "transition", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.observation": [[48, 50], ["None"], "methods", ["None"], ["", "def", "observation", "(", "self", ",", "observation", ")", ":", "\n", "        ", "return", "observation", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.GymEnv.__init__": [[53, 83], ["gym.make", "rlrd.wrappers.Float64ToFloat32", "isinstance", "rlrd.wrappers.NormalizeActionWrapper", "envs.Env.__init__", "rlrd.wrappers.AffineObservationWrapper", "getattr", "rlrd.wrappers.get_wrapper_by_class", "int", "rlrd.wrappers.FrameSkip", "rlrd.wrappers.RealTimeWrapper", "rlrd.wrappers.TupleObservationWrapper"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.get_wrapper_by_class"], ["    ", "def", "__init__", "(", "self", ",", "seed_val", "=", "0", ",", "id", ":", "str", "=", "\"Pendulum-v0\"", ",", "real_time", ":", "bool", "=", "False", ",", "frame_skip", ":", "int", "=", "0", ",", "obs_scale", ":", "float", "=", "0.", ",", "store_env", ":", "bool", "=", "False", ")", ":", "\n", "        ", "env", "=", "gym", ".", "make", "(", "id", ")", "\n", "\n", "if", "obs_scale", ":", "\n", "            ", "env", "=", "AffineObservationWrapper", "(", "env", ",", "0", ",", "obs_scale", ")", "\n", "\n", "", "if", "frame_skip", ":", "\n", "            ", "original_frame_skip", "=", "getattr", "(", "env", ".", "unwrapped", ",", "'frame_skip'", ",", "1", ")", "# on many Mujoco environments this is 5", "\n", "# print(\"Original frame skip\", original_frame_skip)", "\n", "\n", "# I think the two lines below were actually a mistake after all (at least for HalfCheetah)", "\n", "# if hasattr(env, 'dt'):", "\n", "#   env.dt = env.dt  # in case this is an attribute we fix it to its orignal value to not distort rewards (see", "\n", "#   halfcheetah.py)", "\n", "env", ".", "unwrapped", ".", "frame_skip", "=", "1", "\n", "tl", "=", "get_wrapper_by_class", "(", "env", ",", "TimeLimit", ")", "\n", "tl", ".", "_max_episode_steps", "=", "int", "(", "tl", ".", "_max_episode_steps", "*", "original_frame_skip", ")", "\n", "# print(\"New max episode steps\", env._max_episode_steps)", "\n", "env", "=", "FrameSkip", "(", "env", ",", "frame_skip", ",", "1", "/", "original_frame_skip", ")", "\n", "\n", "", "env", "=", "Float64ToFloat32", "(", "env", ")", "\n", "# env = TimeLimitResetWrapper(env)  # obsolete", "\n", "assert", "isinstance", "(", "env", ".", "action_space", ",", "gym", ".", "spaces", ".", "Box", ")", "\n", "env", "=", "NormalizeActionWrapper", "(", "env", ")", "\n", "if", "real_time", ":", "\n", "            ", "env", "=", "RealTimeWrapper", "(", "env", ")", "\n", "", "else", ":", "\n", "            ", "env", "=", "TupleObservationWrapper", "(", "env", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "env", ",", "store_env", "=", "store_env", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.RandomDelayEnv.__init__": [[88, 125], ["gym.make", "rlrd.wrappers.Float64ToFloat32", "isinstance", "rlrd.wrappers.NormalizeActionWrapper", "envs.Env.__init__", "getattr", "rlrd.wrappers.get_wrapper_by_class", "int", "rlrd.wrappers.FrameSkip", "rlrd.wrappers_rd.RandomDelayWrapper", "range", "range", "rlrd.wrappers_rd.WifiDelayWrapper1", "rlrd.wrappers_rd.WifiDelayWrapper2"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.wrappers.get_wrapper_by_class"], ["    ", "def", "__init__", "(", "self", ",", "\n", "seed_val", "=", "0", ",", "id", ":", "str", "=", "\"Pendulum-v0\"", ",", "\n", "frame_skip", ":", "int", "=", "0", ",", "\n", "min_observation_delay", ":", "int", "=", "0", ",", "\n", "sup_observation_delay", ":", "int", "=", "8", ",", "\n", "min_action_delay", ":", "int", "=", "0", ",", "# this is equivalent to a MIN of 1 in the paper", "\n", "sup_action_delay", ":", "int", "=", "2", ",", "# this is equivalent to a MAX of 2 in the paper", "\n", "real_world_sampler", ":", "int", "=", "0", ")", ":", "# 0 for uniform, 1 or 2 for simple wifi sampler", "\n", "        ", "env", "=", "gym", ".", "make", "(", "id", ")", "\n", "\n", "if", "frame_skip", ":", "\n", "            ", "original_frame_skip", "=", "getattr", "(", "env", ".", "unwrapped", ",", "'frame_skip'", ",", "1", ")", "# on many Mujoco environments this is 5", "\n", "# print(\"Original frame skip\", original_frame_skip)", "\n", "\n", "# I think the two lines below were actually a mistake after all (at least for HalfCheetah)", "\n", "# if hasattr(env, 'dt'):", "\n", "#   env.dt = env.dt  # in case this is an attribute we fix it to its orignal value to not distort rewards (see", "\n", "#   halfcheetah.py)", "\n", "env", ".", "unwrapped", ".", "frame_skip", "=", "1", "\n", "tl", "=", "get_wrapper_by_class", "(", "env", ",", "TimeLimit", ")", "\n", "tl", ".", "_max_episode_steps", "=", "int", "(", "tl", ".", "_max_episode_steps", "*", "original_frame_skip", ")", "\n", "# print(\"New max episode steps\", env._max_episode_steps)", "\n", "env", "=", "FrameSkip", "(", "env", ",", "frame_skip", ",", "1", "/", "original_frame_skip", ")", "\n", "\n", "", "env", "=", "Float64ToFloat32", "(", "env", ")", "\n", "assert", "isinstance", "(", "env", ".", "action_space", ",", "gym", ".", "spaces", ".", "Box", ")", "\n", "env", "=", "NormalizeActionWrapper", "(", "env", ")", "\n", "\n", "if", "real_world_sampler", "==", "0", ":", "\n", "            ", "env", "=", "RandomDelayWrapper", "(", "env", ",", "range", "(", "min_observation_delay", ",", "sup_observation_delay", ")", ",", "range", "(", "min_action_delay", ",", "sup_action_delay", ")", ")", "\n", "", "elif", "real_world_sampler", "==", "1", ":", "\n", "            ", "env", "=", "WifiDelayWrapper1", "(", "env", ")", "\n", "", "elif", "real_world_sampler", "==", "2", ":", "\n", "            ", "env", "=", "WifiDelayWrapper2", "(", "env", ")", "\n", "", "else", ":", "\n", "            ", "assert", "False", ",", "f\"invalid value for real_world_sampler:{real_world_sampler}\"", "\n", "", "super", "(", ")", ".", "__init__", "(", "env", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.mujoco_py_issue_424_workaround": [[14, 25], ["join", "dirname", "os.remove", "join", "os.listdir", "name.endswith", "pkgutil.get_loader"], "function", ["None"], ["def", "mujoco_py_issue_424_workaround", "(", ")", ":", "\n", "    ", "\"\"\"Mujoco_py generates files in site-packages for some reason.\n    It causes trouble with docker and during runtime.\n    https://github.com/openai/mujoco-py/issues/424\n    \"\"\"", "\n", "import", "os", "\n", "from", "os", ".", "path", "import", "dirname", ",", "join", "\n", "from", "shutil", "import", "rmtree", "\n", "import", "pkgutil", "\n", "path", "=", "join", "(", "dirname", "(", "pkgutil", ".", "get_loader", "(", "\"mujoco_py\"", ")", ".", "path", ")", ",", "\"generated\"", ")", "\n", "[", "os", ".", "remove", "(", "join", "(", "path", ",", "name", ")", ")", "for", "name", "in", "os", ".", "listdir", "(", "path", ")", "if", "name", ".", "endswith", "(", "\"lock\"", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.test_random_delay_env": [[127, 133], ["envs.RandomDelayEnv", "envs.Env.reset", "envs.Env.step", "print", "envs.Env.step", "RandomDelayEnv.action_space.sample", "RandomDelayEnv.action_space.sample", "range"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample"], ["", "", "def", "test_random_delay_env", "(", ")", ":", "\n", "    ", "env", "=", "RandomDelayEnv", "(", ")", "\n", "obs", "=", "env", ".", "reset", "(", ")", "\n", "[", "env", ".", "step", "(", "env", ".", "action_space", ".", "sample", "(", ")", ")", "for", "_", "in", "range", "(", "1000", ")", "]", "\n", "obs", ",", "_", ",", "_", ",", "_", "=", "env", ".", "step", "(", "env", ".", "action_space", ".", "sample", "(", ")", ")", "\n", "print", "(", "'done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac.Agent.__post_init__": [[38, 52], ["sac.Agent.Model", "sac.Agent.to", "rlrd.nn.no_grad", "torch.optim.Adam", "torch.optim.Adam", "rlrd.memory.Memory", "sac.Agent.OutputNorm", "sac.Agent.OutputNorm", "Env", "copy.copy.deepcopy", "sac.Agent.model.actor.parameters", "sac.Agent.model.critics.parameters", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad"], ["def", "__post_init__", "(", "self", ",", "Env", ")", ":", "\n", "        ", "with", "Env", "(", ")", "as", "env", ":", "\n", "            ", "observation_space", ",", "action_space", "=", "env", ".", "observation_space", ",", "env", ".", "action_space", "\n", "", "device", "=", "self", ".", "device", "or", "(", "\"cuda\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "model", "=", "self", ".", "Model", "(", "observation_space", ",", "action_space", ")", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "self", ".", "model_target", "=", "no_grad", "(", "deepcopy", "(", "self", ".", "model", ")", ")", "\n", "\n", "self", ".", "actor_optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "actor", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "self", ".", "critic_optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "critics", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "self", ".", "memory", "=", "Memory", "(", "self", ".", "memory_size", ",", "self", ".", "batchsize", ",", "device", ")", "\n", "\n", "self", ".", "outputnorm", "=", "self", ".", "OutputNorm", "(", "self", ".", "model", ".", "critic_output_layers", ")", "\n", "self", ".", "outputnorm_target", "=", "self", ".", "OutputNorm", "(", "self", ".", "model_target", ".", "critic_output_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac.Agent.act": [[53, 69], ["sac.Agent.model.act", "sac.Agent.model.reset", "sac.Agent.memory.append", "numpy.float32", "numpy.float32", "int", "print", "sac.Agent.train"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac.Agent.act", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.envs.Env.reset", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac.Agent.train"], ["", "def", "act", "(", "self", ",", "state", ",", "obs", ",", "r", ",", "done", ",", "info", ",", "train", "=", "False", ")", ":", "\n", "        ", "stats", "=", "[", "]", "\n", "state", "=", "self", ".", "model", ".", "reset", "(", ")", "if", "state", "is", "None", "else", "state", "# initialize state if necessary", "\n", "action", ",", "next_state", ",", "_", "=", "self", ".", "model", ".", "act", "(", "state", ",", "obs", ",", "r", ",", "done", ",", "info", ",", "train", ")", "\n", "\n", "if", "train", ":", "\n", "            ", "self", ".", "memory", ".", "append", "(", "np", ".", "float32", "(", "r", ")", ",", "np", ".", "float32", "(", "done", ")", ",", "info", ",", "obs", ",", "action", ")", "\n", "self", ".", "environment_steps", "+=", "1", "\n", "\n", "total_updates_target", "=", "(", "self", ".", "environment_steps", "-", "self", ".", "start_training", ")", "*", "self", ".", "training_steps", "\n", "while", "self", ".", "total_updates", "<", "int", "(", "total_updates_target", ")", ":", "\n", "                ", "if", "self", ".", "total_updates", "==", "0", ":", "\n", "                    ", "print", "(", "\"starting training\"", ")", "\n", "", "stats", "+=", "self", ".", "train", "(", ")", ",", "\n", "self", ".", "total_updates", "+=", "1", "\n", "", "", "return", "action", ",", "next_state", ",", "stats", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac.Agent.train": [[70, 128], ["sac.Agent.memory.sample", "sac.Agent.model.actor", "sac.Agent.rsample", "sac.Agent.model_nograd.actor", "sac.Agent.sample", "functools.reduce", "sac.Agent.outputnorm_target.unnormalize", "torch.cat", "sac.Agent.outputnorm.update", "sum", "sac.Agent.critic_optimizer.zero_grad", "sum.backward", "sac.Agent.critic_optimizer.step", "functools.reduce", "sac.Agent.outputnorm.unnormalize", "sac.Agent.actor_optimizer.zero_grad", "loss_actor.backward", "sac.Agent.actor_optimizer.step", "rlrd.nn.exponential_moving_average", "rlrd.nn.exponential_moving_average", "dict", "c", "sac.Agent.log_prob", "c", "c", "sac.Agent.log_prob", "sac.Agent.outputnorm.normalize_sum().mean", "sac.Agent.model_target.critics.parameters", "sac.Agent.model.critics.parameters", "sac.Agent.outputnorm_target.parameters", "sac.Agent.outputnorm.parameters", "torch.nn.functional.mse_loss", "loss_actor.detach", "sum.detach", "len", "sac.Agent.outputnorm.normalize_sum", "sac.Agent.sum"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.rsample", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.unnormalize", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.update", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.unnormalize", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.exponential_moving_average", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.exponential_moving_average", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.log_prob", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.log_prob", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.normalize_sum"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "obs", ",", "actions", ",", "rewards", ",", "next_obs", ",", "terminals", "=", "self", ".", "memory", ".", "sample", "(", ")", "# sample a transition from the replay buffer", "\n", "new_action_distribution", "=", "self", ".", "model", ".", "actor", "(", "obs", ")", "# outputs distribution object", "\n", "new_actions", "=", "new_action_distribution", ".", "rsample", "(", ")", "# samples using the reparametrization trick", "\n", "\n", "# critic loss", "\n", "next_action_distribution", "=", "self", ".", "model_nograd", ".", "actor", "(", "next_obs", ")", "# outputs distribution object", "\n", "next_actions", "=", "next_action_distribution", ".", "sample", "(", ")", "# samples", "\n", "next_value", "=", "[", "c", "(", "next_obs", ",", "next_actions", ")", "for", "c", "in", "self", ".", "model_target", ".", "critics", "]", "\n", "next_value", "=", "reduce", "(", "torch", ".", "min", ",", "next_value", ")", "# minimum action-value", "\n", "next_value", "=", "self", ".", "outputnorm_target", ".", "unnormalize", "(", "next_value", ")", "# PopArt (not present in the original paper)", "\n", "# next_value = self.outputnorm.unnormalize(next_value)  # PopArt (not present in the original paper)", "\n", "\n", "# predict entropy rewards in a separate dimension from the normal rewards (not present in the original paper)", "\n", "next_action_entropy", "=", "-", "(", "1.", "-", "terminals", ")", "*", "self", ".", "discount", "*", "next_action_distribution", ".", "log_prob", "(", "next_actions", ")", "\n", "reward_components", "=", "torch", ".", "cat", "(", "(", "\n", "self", ".", "reward_scale", "*", "rewards", "[", ":", ",", "None", "]", ",", "\n", "self", ".", "entropy_scale", "*", "next_action_entropy", "[", ":", ",", "None", "]", ",", "\n", ")", ",", "dim", "=", "1", ")", "# shape = (batchsize, reward_components)", "\n", "\n", "value_target", "=", "reward_components", "+", "(", "1.", "-", "terminals", "[", ":", ",", "None", "]", ")", "*", "self", ".", "discount", "*", "next_value", "\n", "normalized_value_target", "=", "self", ".", "outputnorm", ".", "update", "(", "value_target", ")", "# PopArt update and normalize", "\n", "\n", "values", "=", "[", "c", "(", "obs", ",", "actions", ")", "for", "c", "in", "self", ".", "model", ".", "critics", "]", "\n", "assert", "values", "[", "0", "]", ".", "shape", "==", "normalized_value_target", ".", "shape", "and", "not", "normalized_value_target", ".", "requires_grad", "\n", "loss_critic", "=", "sum", "(", "mse_loss", "(", "v", ",", "normalized_value_target", ")", "for", "v", "in", "values", ")", "\n", "\n", "# update critic", "\n", "self", ".", "critic_optimizer", ".", "zero_grad", "(", ")", "\n", "loss_critic", ".", "backward", "(", ")", "\n", "self", ".", "critic_optimizer", ".", "step", "(", ")", "\n", "\n", "# actor loss", "\n", "new_value", "=", "[", "c", "(", "obs", ",", "new_actions", ")", "for", "c", "in", "self", ".", "model", ".", "critics", "]", "# new_actions with reparametrization trick", "\n", "new_value", "=", "reduce", "(", "torch", ".", "min", ",", "new_value", ")", "# minimum action_values", "\n", "assert", "new_value", ".", "shape", "==", "(", "self", ".", "batchsize", ",", "2", ")", "\n", "\n", "new_value", "=", "self", ".", "outputnorm", ".", "unnormalize", "(", "new_value", ")", "\n", "new_value", "[", ":", ",", "-", "1", "]", "-=", "self", ".", "entropy_scale", "*", "new_action_distribution", ".", "log_prob", "(", "new_actions", ")", "\n", "loss_actor", "=", "-", "self", ".", "outputnorm", ".", "normalize_sum", "(", "new_value", ".", "sum", "(", "1", ")", ")", ".", "mean", "(", ")", "# normalize_sum preserves relative scale", "\n", "\n", "# update actor", "\n", "self", ".", "actor_optimizer", ".", "zero_grad", "(", ")", "\n", "loss_actor", ".", "backward", "(", ")", "\n", "self", ".", "actor_optimizer", ".", "step", "(", ")", "\n", "\n", "# update target critics and normalizers", "\n", "exponential_moving_average", "(", "self", ".", "model_target", ".", "critics", ".", "parameters", "(", ")", ",", "self", ".", "model", ".", "critics", ".", "parameters", "(", ")", ",", "self", ".", "target_update", ")", "\n", "exponential_moving_average", "(", "self", ".", "outputnorm_target", ".", "parameters", "(", ")", ",", "self", ".", "outputnorm", ".", "parameters", "(", ")", ",", "self", ".", "target_update", ")", "\n", "\n", "return", "dict", "(", "\n", "loss_actor", "=", "loss_actor", ".", "detach", "(", ")", ",", "\n", "loss_critic", "=", "loss_critic", ".", "detach", "(", ")", ",", "\n", "outputnorm_reward_mean", "=", "self", ".", "outputnorm", ".", "mean", "[", "0", "]", ",", "\n", "outputnorm_entropy_mean", "=", "self", ".", "outputnorm", ".", "mean", "[", "-", "1", "]", ",", "\n", "outputnorm_reward_std", "=", "self", ".", "outputnorm", ".", "std", "[", "0", "]", ",", "\n", "outputnorm_entropy_std", "=", "self", ".", "outputnorm", ".", "std", "[", "-", "1", "]", ",", "\n", "memory_size", "=", "len", "(", "self", ".", "memory", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.__init__": [[44, 47], ["Env", "range", "range"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "Env", ",", "batch_size", "=", "128", ",", "num_avg", "=", "32", ")", ":", "\n", "        ", "self", ".", "num_avg", "=", "num_avg", "\n", "self", ".", "envs", "=", "[", "[", "Env", "(", ")", "for", "_", "in", "range", "(", "batch_size", ")", "]", "for", "_", "in", "range", "(", "num_avg", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.init_from_pickle": [[48, 51], ["batch_env.BatchEnv._init_from_state_dict", "map"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv._init_from_state_dict"], ["", "def", "init_from_pickle", "(", "self", ",", "states", ")", ":", "\n", "        ", "for", "envs", "in", "self", ".", "envs", ":", "\n", "            ", "self", ".", "_init_from_state_dict", "(", "envs", ",", "map", "(", "pickle", ".", "loads", ",", "states", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv._init_from_state_dict": [[52, 54], ["all", "map", "zip", "batch_env.set_env_state"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.set_env_state"], ["", "", "def", "_init_from_state_dict", "(", "self", ",", "envs", ",", "states", ")", ":", "\n", "        ", "all", "(", "map", "(", "lambda", "args", ":", "set_env_state", "(", "*", "args", ")", ",", "zip", "(", "envs", ",", "states", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step": [[55, 79], ["len", "len", "actions.repeat.repeat.repeat", "batch_env.BatchEnv.pool.map", "list", "obss.append", "rewards.append", "dones.append", "info_i.append", "hasattr", "multiprocessing.Pool", "zip", "map", "obss_i.append", "rewards_i.append", "dones_i.append", "info_i.append", "zip"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append"], ["", "def", "step", "(", "self", ",", "actions", ")", ":", "\n", "        ", "if", "len", "(", "actions", ")", "<", "len", "(", "self", ".", "envs", ")", ":", "\n", "# first action", "\n", "            ", "actions", "=", "actions", ".", "repeat", "(", "self", ".", "num_avg", ",", "0", ")", "\n", "", "if", "USE_MP", ":", "\n", "            ", "if", "not", "hasattr", "(", "self", ",", "'pool'", ")", ":", "\n", "                ", "self", ".", "pool", "=", "mp", ".", "Pool", "(", ")", "\n", "", "res", "=", "self", ".", "pool", ".", "map", "(", "_step_nd", ",", "zip", "(", "self", ".", "envs", ",", "actions", ")", ")", "\n", "", "else", ":", "\n", "            ", "res", "=", "list", "(", "map", "(", "_step_nd", ",", "zip", "(", "self", ".", "envs", ",", "actions", ")", ")", ")", "\n", "\n", "", "obss", ",", "rewards", ",", "dones", ",", "info", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "res_i", "in", "res", ":", "\n", "            ", "obss_i", ",", "rewards_i", ",", "dones_i", ",", "info_i", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "r", "in", "res_i", ":", "\n", "                ", "obss_i", ".", "append", "(", "r", "[", "0", "]", ")", "\n", "rewards_i", ".", "append", "(", "r", "[", "1", "]", ")", "\n", "dones_i", ".", "append", "(", "r", "[", "2", "]", ")", "\n", "info_i", ".", "append", "(", "r", "[", "3", "]", ")", "\n", "", "obss", ".", "append", "(", "obss_i", ")", "\n", "rewards", ".", "append", "(", "rewards_i", ")", "\n", "dones", ".", "append", "(", "dones_i", ")", "\n", "info_i", ".", "append", "(", "info_i", ")", "\n", "", "return", "obss", ",", "rewards", ",", "dones", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.get_env_state": [[10, 19], ["dict", "dict.update", "hasattr", "dict.update", "hasattr", "dict.update", "env.__dict__.items", "isinstance", "batch_env.get_env_state", "env.sim.get_state"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.update", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.update", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.update", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.get_env_state"], ["def", "get_env_state", "(", "env", ")", ":", "\n", "    ", "dtypes", "=", "(", "int", ",", "np", ".", "ndarray", ",", "np", ".", "random", ".", "RandomState", ")", "\n", "state", "=", "dict", "(", ")", "\n", "state", ".", "update", "(", "{", "k", ":", "v", "for", "k", ",", "v", "in", "env", ".", "__dict__", ".", "items", "(", ")", "if", "isinstance", "(", "v", ",", "dtypes", ")", "}", ")", "\n", "if", "hasattr", "(", "env", ",", "'env'", ")", ":", "\n", "        ", "state", ".", "update", "(", "env", "=", "get_env_state", "(", "env", ".", "env", ")", ")", "\n", "", "elif", "hasattr", "(", "env", ",", "'sim'", ")", ":", "\n", "        ", "state", ".", "update", "(", "sim_state", "=", "env", ".", "sim", ".", "get_state", "(", ")", ")", "\n", "", "return", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.set_env_state": [[21, 27], ["env.__dict__.update", "batch_env.set_env_state", "env.sim.set_state", "state.pop", "state.pop"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.update", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.set_env_state"], ["", "def", "set_env_state", "(", "env", ",", "state", ")", ":", "\n", "    ", "if", "'env'", "in", "state", ":", "\n", "        ", "set_env_state", "(", "env", ".", "env", ",", "state", ".", "pop", "(", "'env'", ")", ")", "\n", "", "if", "'sim_state'", "in", "state", ":", "\n", "        ", "env", ".", "sim", ".", "set_state", "(", "state", ".", "pop", "(", "'sim_state'", ")", ")", "\n", "", "env", ".", "__dict__", ".", "update", "(", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env._step": [[29, 32], ["env.step"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step"], ["", "def", "_step", "(", "args", ")", ":", "\n", "    ", "env", ",", "action", "=", "args", "\n", "return", "env", ".", "step", "(", "action", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env._step_nd": [[34, 37], ["list", "map", "zip"], "function", ["None"], ["", "def", "_step_nd", "(", "args", ")", ":", "\n", "    ", "envs", ",", "actions", "=", "args", "\n", "return", "list", "(", "map", "(", "_step", ",", "zip", "(", "envs", ",", "actions", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env._set_envs_from_pickle": [[39, 41], ["pickle.loads"], "function", ["None"], ["", "def", "_set_envs_from_pickle", "(", "envs", ")", ":", "\n", "    ", "_envs", "=", "[", "pickle", ".", "loads", "(", "e", ")", "for", "e", "in", "envs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.__init__": [[48, 62], ["torch.nn.Module.__init__", "all", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "isinstance", "torch.zeros", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["def", "__init__", "(", "self", ",", "output_layer", ",", "beta", ":", "float", "=", "0.0003", ",", "zero_debias", ":", "bool", "=", "True", ",", "start_pop", ":", "int", "=", "8", ")", ":", "\n", "# zero_debias=True and start_pop=8 seem to improve things a little but (False, 0) works as well", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "start_pop", "=", "start_pop", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "zero_debias", "=", "zero_debias", "\n", "self", ".", "output_layers", "=", "output_layer", "if", "isinstance", "(", "output_layer", ",", "(", "tuple", ",", "list", ",", "torch", ".", "nn", ".", "ModuleList", ")", ")", "else", "(", "output_layer", ",", ")", "\n", "shape", "=", "self", ".", "output_layers", "[", "0", "]", ".", "bias", ".", "shape", "\n", "device", "=", "self", ".", "output_layers", "[", "0", "]", ".", "bias", ".", "device", "\n", "assert", "all", "(", "shape", "==", "x", ".", "bias", ".", "shape", "for", "x", "in", "self", ".", "output_layers", ")", "\n", "self", ".", "mean", "=", "Parameter", "(", "torch", ".", "zeros", "(", "shape", ",", "device", "=", "device", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "mean_square", "=", "Parameter", "(", "torch", ".", "ones", "(", "shape", ",", "device", "=", "device", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "std", "=", "Parameter", "(", "torch", ".", "ones", "(", "shape", ",", "device", "=", "device", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "updates", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.update": [[63, 86], ["torch.no_grad", "nn.PopArt.mean.copy_", "nn.PopArt.mean_square.copy_", "nn.PopArt.std.copy_", "nn.PopArt.normalize", "max", "targets.mean"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.normalize"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "update", "(", "self", ",", "targets", ")", ":", "\n", "        ", "beta", "=", "max", "(", "1", "/", "(", "self", ".", "updates", "+", "1", ")", ",", "self", ".", "beta", ")", "if", "self", ".", "zero_debias", "else", "self", ".", "beta", "\n", "# note that for beta = 1/self.updates the resulting mean, std would be the true mean and std over all past data", "\n", "\n", "new_mean", "=", "(", "1", "-", "beta", ")", "*", "self", ".", "mean", "+", "beta", "*", "targets", ".", "mean", "(", "0", ")", "\n", "new_mean_square", "=", "(", "1", "-", "beta", ")", "*", "self", ".", "mean_square", "+", "beta", "*", "(", "targets", "*", "targets", ")", ".", "mean", "(", "0", ")", "\n", "new_std", "=", "(", "new_mean_square", "-", "new_mean", "*", "new_mean", ")", ".", "sqrt", "(", ")", ".", "clamp", "(", "0.0001", ",", "1e6", ")", "\n", "\n", "# assert self.std.shape == (1,), 'this has only been tested in 1D'", "\n", "\n", "if", "self", ".", "updates", ">=", "self", ".", "start_pop", ":", "\n", "            ", "for", "layer", "in", "self", ".", "output_layers", ":", "\n", "                ", "layer", ".", "weight", "*=", "(", "self", ".", "std", "/", "new_std", ")", "[", ":", ",", "None", "]", "\n", "layer", ".", "bias", "*=", "self", ".", "std", "\n", "layer", ".", "bias", "+=", "self", ".", "mean", "-", "new_mean", "\n", "layer", ".", "bias", "/=", "new_std", "\n", "\n", "", "", "self", ".", "mean", ".", "copy_", "(", "new_mean", ")", "\n", "self", ".", "mean_square", ".", "copy_", "(", "new_mean_square", ")", "\n", "self", ".", "std", ".", "copy_", "(", "new_std", ")", "\n", "self", ".", "updates", "+=", "1", "\n", "return", "self", ".", "normalize", "(", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.normalize": [[87, 89], ["None"], "methods", ["None"], ["", "def", "normalize", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "(", "x", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.unnormalize": [[90, 92], ["None"], "methods", ["None"], ["", "def", "unnormalize", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "std", "+", "self", ".", "mean", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.normalize_sum": [[93, 96], ["nn.PopArt.std.norm", "nn.PopArt.mean.sum"], "methods", ["None"], ["", "def", "normalize_sum", "(", "self", ",", "s", ")", ":", "\n", "        ", "\"\"\"normalize x.sum(1) preserving relative weightings between elements\"\"\"", "\n", "return", "(", "s", "-", "self", ".", "mean", ".", "sum", "(", ")", ")", "/", "self", ".", "std", ".", "norm", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.__init__": [[104, 110], ["torch.distributions.Normal", "torch.distributions.Distribution.__init__"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["def", "__init__", "(", "self", ",", "normal_mean", ",", "normal_std", ",", "epsilon", "=", "1e-6", ")", ":", "\n", "        ", "self", ".", "normal_mean", "=", "normal_mean", "\n", "self", ".", "normal_std", "=", "normal_std", "\n", "self", ".", "normal", "=", "Normal", "(", "normal_mean", ",", "normal_std", ")", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "normal", ".", "batch_shape", ",", "self", ".", "normal", ".", "event_shape", ",", "validate_args", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.log_prob": [[111, 118], ["hasattr", "nn.TanhNormal.normal.log_prob", "torch.log", "x.dim", "pre_tanh_value.dim", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.log_prob"], ["", "def", "log_prob", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "hasattr", "(", "x", ",", "\"pre_tanh_value\"", ")", ":", "\n", "            ", "pre_tanh_value", "=", "x", ".", "pre_tanh_value", "\n", "", "else", ":", "\n", "            ", "pre_tanh_value", "=", "(", "torch", ".", "log", "(", "1", "+", "x", "+", "self", ".", "epsilon", ")", "-", "torch", ".", "log", "(", "1", "-", "x", "+", "self", ".", "epsilon", ")", ")", "/", "2", "\n", "", "assert", "x", ".", "dim", "(", ")", "==", "2", "and", "pre_tanh_value", ".", "dim", "(", ")", "==", "2", "\n", "return", "self", ".", "normal", ".", "log_prob", "(", "pre_tanh_value", ")", "-", "torch", ".", "log", "(", "1", "-", "x", "*", "x", "+", "self", ".", "epsilon", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.sample": [[119, 124], ["torch.Size", "nn.TanhNormal.normal.sample", "torch.tanh"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample"], ["", "def", "sample", "(", "self", ",", "sample_shape", "=", "torch", ".", "Size", "(", ")", ")", ":", "\n", "        ", "z", "=", "self", ".", "normal", ".", "sample", "(", "sample_shape", ")", "\n", "out", "=", "torch", ".", "tanh", "(", "z", ")", "\n", "out", ".", "pre_tanh_value", "=", "z", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.rsample": [[125, 130], ["torch.Size", "nn.TanhNormal.normal.rsample", "torch.tanh"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormal.rsample"], ["", "def", "rsample", "(", "self", ",", "sample_shape", "=", "torch", ".", "Size", "(", ")", ")", ":", "\n", "        ", "z", "=", "self", ".", "normal", ".", "rsample", "(", "sample_shape", ")", "\n", "out", "=", "torch", ".", "tanh", "(", "z", ")", "\n", "out", ".", "pre_tanh_value", "=", "z", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.Independent.sample_deterministic": [[134, 136], ["torch.tanh"], "methods", ["None"], ["    ", "def", "sample_deterministic", "(", "self", ")", ":", "\n", "        ", "return", "torch", ".", "tanh", "(", "self", ".", "base_dist", ".", "normal_mean", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormalLayer.__init__": [[139, 149], ["super().__init__", "torch.nn.Linear", "torch.nn.Linear", "nn.TanhNormalLayer.lin_std.weight.data.uniform_", "nn.TanhNormalLayer.lin_std.bias.data.uniform_"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n", ",", "m", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "lin_mean", "=", "torch", ".", "nn", ".", "Linear", "(", "n", ",", "m", ")", "\n", "# self.lin_mean.weight.data", "\n", "# self.lin_mean.bias.data", "\n", "\n", "self", ".", "lin_std", "=", "torch", ".", "nn", ".", "Linear", "(", "n", ",", "m", ")", "\n", "self", ".", "lin_std", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "1e-3", ",", "1e-3", ")", "\n", "self", ".", "lin_std", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "1e-3", ",", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.TanhNormalLayer.forward": [[150, 158], ["nn.TanhNormalLayer.lin_mean", "nn.TanhNormalLayer.lin_std", "torch.clamp", "torch.exp", "nn.Independent", "nn.TanhNormal"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "mean", "=", "self", ".", "lin_mean", "(", "x", ")", "\n", "log_std", "=", "self", ".", "lin_std", "(", "x", ")", "\n", "log_std", "=", "torch", ".", "clamp", "(", "log_std", ",", "-", "20", ",", "2", ")", "\n", "std", "=", "torch", ".", "exp", "(", "log_std", ")", "\n", "# a = TanhTransformedDist(Independent(Normal(m, std), 1))", "\n", "a", "=", "Independent", "(", "TanhNormal", "(", "mean", ",", "std", ")", ",", "1", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.RlkitLinear.__init__": [[161, 170], ["super().__init__", "nn.RlkitLinear.weight.data.uniform_", "nn.RlkitLinear.bias.data.fill_", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ")", "\n", "# TODO: investigate the following", "\n", "# this mistake seems to be in rlkit too", "\n", "# https://github.com/vitchyr/rlkit/blob/master/rlkit/torch/pytorch_util.py", "\n", "fan_in", "=", "self", ".", "weight", ".", "shape", "[", "0", "]", "# this is actually fanout!!!", "\n", "bound", "=", "1.", "/", "np", ".", "sqrt", "(", "fan_in", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "bound", ",", "bound", ")", "\n", "self", ".", "bias", ".", "data", ".", "fill_", "(", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.SacLinear.__init__": [[173, 178], ["super().__init__", "torch.no_grad", "nn.SacLinear.weight.uniform_", "nn.SacLinear.bias.fill_"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_features", ",", "out_features", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "self", ".", "weight", ".", "uniform_", "(", "-", "0.06", ",", "0.06", ")", "# 0.06 == 1 / sqrt(256)", "\n", "self", ".", "bias", ".", "fill_", "(", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.BasicReLU.forward": [[181, 184], ["super().forward", "torch.relu"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "super", "(", ")", ".", "forward", "(", "x", ")", "\n", "return", "torch", ".", "relu", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.AffineReLU.__init__": [[187, 192], ["super().__init__", "nn.AffineReLU.weight.data.uniform_", "nn.AffineReLU.bias.data.fill_", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "init_weight_bound", ":", "float", "=", "1.", ",", "init_bias", ":", "float", "=", "0.", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_features", ",", "out_features", ")", "\n", "bound", "=", "init_weight_bound", "/", "np", ".", "sqrt", "(", "in_features", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "bound", ",", "bound", ")", "\n", "self", ".", "bias", ".", "data", ".", "fill_", "(", "init_bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.NormalizedReLU.__init__": [[195, 200], ["super().__init__", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "prenorm_bias", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "torch", ".", "nn", ".", "Linear", "(", "in_features", ",", "out_features", ",", "bias", "=", "prenorm_bias", ")", ",", "\n", "torch", ".", "nn", ".", "LayerNorm", "(", "out_features", ")", ",", "\n", "torch", ".", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.__init__": [[203, 208], ["super().__init__", "torch.no_grad", "torch.nn.init.kaiming_uniform_", "nn.KaimingReLU.bias.fill_"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_features", ",", "out_features", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "kaiming_uniform_", "(", "self", ".", "weight", ")", "\n", "self", ".", "bias", ".", "fill_", "(", "0.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward": [[209, 212], ["super().forward", "torch.relu"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.KaimingReLU.forward"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "super", "(", ")", ".", "forward", "(", "x", ")", "\n", "return", "torch", ".", "relu", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach": [[14, 19], ["isinstance", "x.detach", "nn.detach"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.detach"], ["def", "detach", "(", "x", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "x", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "[", "detach", "(", "elem", ")", "for", "elem", "in", "x", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad": [[21, 25], ["model.parameters"], "function", ["None"], ["", "", "def", "no_grad", "(", "model", ")", ":", "\n", "    ", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "p", ".", "requires_grad", "=", "False", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.exponential_moving_average": [[27, 31], ["torch.no_grad", "zip"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.no_grad"], ["", "def", "exponential_moving_average", "(", "averages", ",", "values", ",", "factor", ")", ":", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "a", ",", "v", "in", "zip", "(", "averages", ",", "values", ")", ":", "\n", "            ", "a", "+=", "factor", "*", "(", "v", "-", "a", ")", "# equivalent to a = (1-factor) * a + factor * v", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.copy_shared": [[33, 43], ["copy.deepcopy", "model_a.state_dict", "copy.deepcopy.state_dict", "b.storage().data_ptr", "a.storage().data_ptr", "b.storage", "a.storage"], "function", ["None"], ["", "", "", "def", "copy_shared", "(", "model_a", ")", ":", "\n", "    ", "\"\"\"Create a deepcopy of a model but with the underlying state_dict shared. E.g. useful in combination with `no_grad`.\"\"\"", "\n", "model_b", "=", "deepcopy", "(", "model_a", ")", "\n", "sda", "=", "model_a", ".", "state_dict", "(", "keep_vars", "=", "True", ")", "\n", "sdb", "=", "model_b", ".", "state_dict", "(", "keep_vars", "=", "True", ")", "\n", "for", "key", "in", "sda", ":", "\n", "        ", "a", ",", "b", "=", "sda", "[", "key", "]", ",", "sdb", "[", "key", "]", "\n", "b", ".", "data", "=", "a", ".", "data", "# strangely this will not make a.data and b.data the same object but their underlying data_ptr will be the same", "\n", "assert", "b", ".", "storage", "(", ")", ".", "data_ptr", "(", ")", "==", "a", ".", "storage", "(", ")", ".", "data_ptr", "(", ")", "\n", "", "return", "model_b", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.dqn_conv": [[221, 229], ["torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.ReLU"], "function", ["None"], ["def", "dqn_conv", "(", "n", ")", ":", "\n", "    ", "return", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "n", ",", "32", ",", "kernel_size", "=", "8", ",", "stride", "=", "4", ")", ",", "\n", "torch", ".", "nn", ".", "ReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "32", ",", "64", ",", "kernel_size", "=", "4", ",", "stride", "=", "2", ")", ",", "\n", "torch", ".", "nn", ".", "ReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ")", ",", "\n", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.big_conv": [[232, 239], ["torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.LeakyReLU"], "function", ["None"], ["", "def", "big_conv", "(", "n", ")", ":", "\n", "# if input shape = 64 x 256 then output shape = 2 x 26", "\n", "    ", "return", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "n", ",", "64", ",", "8", ",", "stride", "=", "2", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "4", ",", "stride", "=", "2", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "4", ",", "stride", "=", "2", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "4", ",", "stride", "=", "1", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.hd_conv": [[242, 249], ["torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.LeakyReLU"], "function", ["None"], ["", "def", "hd_conv", "(", "n", ")", ":", "\n", "    ", "return", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "n", ",", "32", ",", "8", ",", "stride", "=", "2", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "32", ",", "64", ",", "4", ",", "stride", "=", "2", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "4", ",", "stride", "=", "2", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "4", ",", "stride", "=", "2", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "torch", ".", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "4", ",", "stride", "=", "2", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__main__.parse_args": [[16, 19], ["dict", "rlrd.util.partial_from_args", "x.split"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_from_args"], ["def", "parse_args", "(", "func", ",", "*", "a", ")", ":", "\n", "    ", "kwargs", "=", "dict", "(", "x", ".", "split", "(", "\"=\"", ")", "for", "x", "in", "a", ")", "\n", "return", "partial_from_args", "(", "func", ",", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.testing.Test.__init__": [[17, 24], ["copy.deepcopy().to", "multiprocessing.get_context().Pool", "testing.Test.pool.map_async", "functools.partial", "range", "copy.deepcopy", "multiprocessing.get_context"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial"], ["    ", "def", "__init__", "(", "self", ",", "actor", ",", "workers", ":", "int", "=", "1", ",", "number", ":", "int", "=", "1", ",", "device", ":", "str", "=", "'cpu'", ",", "**", "kwargs", ")", ":", "\n", "# cuda requires ~2GB RAM per process just to start so we might want to test on cpu even if cuda is available.", "\n", "        ", "actor", "=", "deepcopy", "(", "actor", ")", ".", "to", "(", "device", ")", "\n", "\n", "# Note: It is important that we `spawn` here. Using the default `fork`, will cause Pytorch 1.2 to lock up because it uses a buggy OpenMPI implementation (libgomp). Olexa Bilaniuk at Mila helped us figure this out.", "\n", "self", ".", "pool", "=", "mp", ".", "get_context", "(", "'spawn'", ")", ".", "Pool", "(", "workers", ")", "\n", "self", ".", "result_handle", "=", "self", ".", "pool", ".", "map_async", "(", "partial", "(", "run_test", ",", "actor", "=", "actor", ",", "**", "kwargs", ")", ",", "range", "(", "number", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.testing.Test.stats": [[25, 31], ["testing.Test.result_handle.get", "pandas.DataFrame", "pandas.DataFrame.mean"], "methods", ["None"], ["", "def", "stats", "(", "self", ")", ":", "\n", "        ", "st", "=", "self", ".", "result_handle", ".", "get", "(", ")", "\n", "st", "=", "DataFrame", "(", "st", ")", "\n", "means", "=", "st", ".", "mean", "(", "skipna", "=", "True", ")", "\n", "# stds = st.std(skipna=True).add_suffix(\"std\")", "\n", "return", "means", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.testing.Test.__del__": [[32, 35], ["testing.Test.pool.close", "testing.Test.pool.join"], "methods", ["None"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "self", ".", "pool", ".", "close", "(", ")", "\n", "self", ".", "pool", ".", "join", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.testing.run_test": [[37, 48], ["pandas.Timestamp.utcnow", "Env", "rlrd.wrappers.StatsWrapper", "range", "rlrd.util.pandas_dict", "actor.act", "Env.step", "Env.stats", "pandas.Timestamp.utcnow"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.pandas_dict", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac.Agent.act", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.testing.Test.stats"], ["", "", "def", "run_test", "(", "number", ",", "*", ",", "Env", ",", "actor", ",", "base_seed", ",", "steps", ")", ":", "\n", "    ", "t0", "=", "pd", ".", "Timestamp", ".", "utcnow", "(", ")", "\n", "env", "=", "Env", "(", "seed_val", "=", "base_seed", "+", "number", ")", "\n", "state", "=", "None", "\n", "with", "StatsWrapper", "(", "env", ",", "window", "=", "steps", ")", "as", "env", ":", "\n", "        ", "for", "step", "in", "range", "(", "steps", ")", ":", "\n", "            ", "action", ",", "state", ",", "stats", "=", "actor", ".", "act", "(", "state", ",", "*", "env", ".", "transition", ")", "\n", "# action = env.action_space.sample()", "\n", "env", ".", "step", "(", "action", ")", "\n", "\n", "", "return", "pandas_dict", "(", "env", ".", "stats", "(", ")", ",", "round_time", "=", "pd", ".", "Timestamp", ".", "utcnow", "(", ")", "-", "t0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.training.Training.__post_init__": [[32, 35], ["training.Training.Agent"], "methods", ["None"], ["self", ".", "state", "=", "np", ".", "asarray", "(", "(", "self", ".", "state", "[", "0", "]", "+", "np", ".", "float32", "(", "1", ")", ",", ")", ")", "\n", "return", "self", ".", "state", ",", "reward", ",", "self", ".", "state", "[", "0", "]", ">", "self", ".", "high", ",", "{", "\"reset\"", ":", "False", "}", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.training.Training.run_epoch": [[36, 72], ["rlrd.wrappers.StatsWrapper", "range", "training.Training.Env", "print", "pandas.Timestamp.utcnow", "training.Training.Test", "range", "print", "training.Training.agent.act", "env.step", "rlrd.util.pandas_dict", "stats[].add_prefix().to_string", "env.stats", "training.Training.stats().add_suffix", "pandas.DataFrame().mean", "stats[].add_prefix", "pandas.Timestamp.utcnow", "pandas.Timestamp.utcnow", "training.Training.stats", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac.Agent.act", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.batch_env.BatchEnv.step", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.pandas_dict", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.testing.Test.stats", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.testing.Test.stats"], ["", "", "Test", "=", "partial", "(", "\n", "Training", ",", "\n", "epochs", "=", "3", ",", "\n", "rounds", "=", "5", ",", "\n", "steps", "=", "100", ",", "\n", "Agent", "=", "partial", "(", "memory_size", "=", "1000000", ",", "Model", "=", "TestMlp", ")", ",", "\n", "Env", "=", "partial", "(", "TestEnv", ")", ",", "\n", ")", "\n", "\n", "if", "__name__", "==", "\"__main__\"", ":", "\n", "\t", "spec_init_run", "(", "Test", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.iterate_episodes": [[23, 56], ["tempfile.mktemp", "rlrd.util.load", "os.path.exists", "print", "print", "run_cls", "rlrd.util.dump", "print", "print", "print", "rlrd.util.dump", "gc.collect", "rlrd.util.load", "checkpoint_path.endswith", "os.path.exists", "os.remove", "yaml.dump", "rlrd.util.load.run_epoch", "rlrd.util.partial_to_dict"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.load", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dump", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dump", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.load", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dump", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.training.Training.run_epoch", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_to_dict"], ["def", "iterate_episodes", "(", "run_cls", ":", "type", "=", "Training", ",", "checkpoint_path", ":", "str", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generator [1] yielding episode statistics (list of pd.Series) while running and checkpointing\n    - run_cls: can by any callable that outputs an appropriate run object (e.g. has a 'run_epoch' method)\n\n    [1] https://docs.python.org/3/howto/functional.html#generators\n    \"\"\"", "\n", "checkpoint_path", "=", "checkpoint_path", "or", "tempfile", ".", "mktemp", "(", "\"_remove_on_exit\"", ")", "\n", "\n", "try", ":", "\n", "        ", "if", "not", "exists", "(", "checkpoint_path", ")", ":", "\n", "            ", "print", "(", "\"=== specification \"", ".", "ljust", "(", "70", ",", "\"=\"", ")", ")", "\n", "print", "(", "yaml", ".", "dump", "(", "partial_to_dict", "(", "run_cls", ")", ",", "indent", "=", "3", ",", "default_flow_style", "=", "False", ",", "sort_keys", "=", "False", ")", ",", "end", "=", "\"\"", ")", "\n", "run_instance", "=", "run_cls", "(", ")", "\n", "dump", "(", "run_instance", ",", "checkpoint_path", ")", "\n", "print", "(", "\"\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"\\ncontinuing...\\n\"", ")", "\n", "\n", "", "run_instance", "=", "load", "(", "checkpoint_path", ")", "\n", "while", "run_instance", ".", "epoch", "<", "run_instance", ".", "epochs", ":", "\n", "# time.sleep(1)  # on network file systems writing files is asynchronous and we need to wait for sync", "\n", "            ", "yield", "run_instance", ".", "run_epoch", "(", ")", "# yield stats data frame (this makes this function a generator)", "\n", "print", "(", "\"\"", ")", "\n", "dump", "(", "run_instance", ",", "checkpoint_path", ")", "\n", "\n", "# we delete and reload the run_instance from disk to ensure the exact same code runs regardless of interruptions", "\n", "del", "run_instance", "\n", "gc", ".", "collect", "(", ")", "\n", "run_instance", "=", "load", "(", "checkpoint_path", ")", "\n", "\n", "", "", "finally", ":", "\n", "        ", "if", "checkpoint_path", ".", "endswith", "(", "\"_remove_on_exit\"", ")", "and", "exists", "(", "checkpoint_path", ")", ":", "\n", "            ", "os", ".", "remove", "(", "checkpoint_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.log_environment_variables": [[58, 63], ["os.environ.get", "os.environ.get().strip().split", "os.environ.get().strip", "os.environ.get"], "function", ["None"], ["", "", "", "def", "log_environment_variables", "(", ")", ":", "\n", "    ", "\"\"\"add certain relevant environment variables to our config\n    usage: `LOG_VARIABLES='HOME JOBID' python ...`\n    \"\"\"", "\n", "return", "{", "k", ":", "os", ".", "environ", ".", "get", "(", "k", ",", "''", ")", "for", "k", "in", "os", ".", "environ", ".", "get", "(", "'LOG_VARIABLES'", ",", "''", ")", ".", "strip", "(", ")", ".", "split", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.run": [[65, 67], ["list", "__init__.iterate_episodes"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.iterate_episodes"], ["", "def", "run", "(", "run_cls", ":", "type", "=", "Training", ",", "checkpoint_path", ":", "str", "=", "None", ")", ":", "\n", "    ", "list", "(", "iterate_episodes", "(", "run_cls", ",", "checkpoint_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.run_wandb": [[69, 82], ["tempfile.mkdtemp", "atexit.register", "rlrd.util.partial_to_dict", "__init__.log_environment_variables", "rlrd.util.git_info", "wandb.init", "__init__.iterate_episodes", "random.randrange", "os.path.exists", "wandb.log", "json.loads", "s.to_json"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_to_dict", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.log_environment_variables", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.git_info", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.iterate_episodes"], ["", "def", "run_wandb", "(", "entity", ",", "project", ",", "run_id", ",", "run_cls", ":", "type", "=", "Training", ",", "checkpoint_path", ":", "str", "=", "None", ")", ":", "\n", "    ", "\"\"\"run and save config and stats to https://wandb.com\"\"\"", "\n", "wandb_dir", "=", "mkdtemp", "(", ")", "# prevent wandb from polluting the home directory", "\n", "atexit", ".", "register", "(", "shutil", ".", "rmtree", ",", "wandb_dir", ",", "ignore_errors", "=", "True", ")", "# clean up after wandb atexit handler finishes", "\n", "import", "wandb", "\n", "config", "=", "partial_to_dict", "(", "run_cls", ")", "\n", "config", "[", "'seed'", "]", "=", "config", "[", "'seed'", "]", "or", "randrange", "(", "1", ",", "1000000", ")", "# if seed == 0 replace with random", "\n", "config", "[", "'environ'", "]", "=", "log_environment_variables", "(", ")", "\n", "config", "[", "'git'", "]", "=", "git_info", "(", ")", "\n", "resume", "=", "checkpoint_path", "and", "exists", "(", "checkpoint_path", ")", "\n", "wandb", ".", "init", "(", "dir", "=", "wandb_dir", ",", "entity", "=", "entity", ",", "project", "=", "project", ",", "id", "=", "run_id", ",", "resume", "=", "resume", ",", "config", "=", "config", ")", "\n", "for", "stats", "in", "iterate_episodes", "(", "run_cls", ",", "checkpoint_path", ")", ":", "\n", "        ", "[", "wandb", ".", "log", "(", "json", ".", "loads", "(", "s", ".", "to_json", "(", ")", ")", ")", "for", "s", "in", "stats", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.run_fs": [[84, 94], ["rlrd.util.save_json", "__init__.iterate_episodes", "os.path.exists", "os.mkdir", "rlrd.util.partial_to_dict", "os.path.exists", "rlrd.util.dump", "rlrd.util.dump", "pandas.DataFrame", "rlrd.util.load().append", "rlrd.util.load"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.save_json", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.__init__.iterate_episodes", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_to_dict", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dump", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dump", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.load"], ["", "", "def", "run_fs", "(", "path", ":", "str", ",", "run_cls", ":", "type", "=", "Training", ")", ":", "\n", "    ", "\"\"\"run and save config and stats to `path` (with pickle)\"\"\"", "\n", "if", "not", "exists", "(", "path", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "path", ")", "\n", "", "save_json", "(", "partial_to_dict", "(", "run_cls", ")", ",", "path", "+", "'/spec.json'", ")", "\n", "if", "not", "exists", "(", "path", "+", "'/stats'", ")", ":", "\n", "        ", "dump", "(", "pd", ".", "DataFrame", "(", ")", ",", "path", "+", "'/stats'", ")", "\n", "", "for", "stats", "in", "iterate_episodes", "(", "run_cls", ",", "path", "+", "'/state'", ")", ":", "\n", "        ", "dump", "(", "load", "(", "path", "+", "'/stats'", ")", ".", "append", "(", "stats", ",", "ignore_index", "=", "True", ")", ",", "\n", "path", "+", "'/stats'", ")", "# concat with stats from previous episodes", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.cached_property.__init__": [[81, 84], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "init", "=", "None", ")", ":", "\n", "        ", "self", ".", "cache", "=", "{", "}", "\n", "self", ".", "init", "=", "init", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.cached_property.__get__": [[85, 90], ["id", "util.cached_property.__set__", "AttributeError", "util.cached_property.init", "id"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.cached_property.__set__"], ["", "def", "__get__", "(", "self", ",", "instance", ",", "owner", ")", ":", "\n", "        ", "if", "id", "(", "instance", ")", "not", "in", "self", ".", "cache", ":", "\n", "            ", "if", "self", ".", "init", "is", "None", ":", "raise", "AttributeError", "(", ")", "\n", "self", ".", "__set__", "(", "instance", ",", "self", ".", "init", "(", "instance", ")", ")", "\n", "", "return", "self", ".", "cache", "[", "id", "(", "instance", ")", "]", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.cached_property.__set__": [[91, 94], ["weakref.ref", "id", "functools.partial", "id"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial"], ["", "def", "__set__", "(", "self", ",", "instance", ",", "value", ")", ":", "\n", "# Cache the attribute value based on the instance id. If instance is garbage collected its cached value is removed.", "\n", "        ", "self", ".", "cache", "[", "id", "(", "instance", ")", "]", "=", "(", "value", ",", "weakref", ".", "ref", "(", "instance", ",", "functools", ".", "partial", "(", "self", ".", "cache", ".", "pop", ",", "id", "(", "instance", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.DelayInterrupt.__enter__": [[239, 242], ["signal.getsignal", "signal.signal"], "methods", ["None"], ["def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "default_handlers", "=", "[", "signal", ".", "getsignal", "(", "s", ")", "for", "s", "in", "self", ".", "signals", "]", "\n", "[", "signal", ".", "signal", "(", "s", ",", "self", ".", "on_signal", ")", "for", "s", "in", "self", ".", "signals", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.DelayInterrupt.on_signal": [[243, 246], ["print"], "methods", ["None"], ["", "def", "on_signal", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "print", "(", "\"dcac_python.util:DelayInterrupt -- Signal received!\"", ",", "*", "args", ")", "\n", "self", ".", "signal_received", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.DelayInterrupt.__exit__": [[247, 251], ["signal.signal", "KeyboardInterrupt", "zip"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "[", "signal", ".", "signal", "(", "s", ",", "d", ")", "for", "s", ",", "d", "in", "zip", "(", "self", ".", "signals", ",", "self", ".", "default_handlers", ")", "]", "\n", "if", "self", ".", "signal_received", ":", "\n", "            ", "raise", "KeyboardInterrupt", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.pandas_dict": [[24, 26], ["pandas.Series", "dict"], "function", ["None"], ["def", "pandas_dict", "(", "*", "args", ",", "**", "kwargs", ")", "->", "pd", ".", "Series", ":", "\n", "    ", "return", "pd", ".", "Series", "(", "dict", "(", "*", "args", ",", "**", "kwargs", ")", ",", "dtype", "=", "object", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.shallow_copy": [[28, 32], ["type().__new__", "vars().update", "type", "vars", "type", "vars"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.update"], ["", "def", "shallow_copy", "(", "obj", ":", "T", ")", "->", "T", ":", "\n", "    ", "x", "=", "type", "(", "obj", ")", ".", "__new__", "(", "type", "(", "obj", ")", ")", "\n", "vars", "(", "x", ")", ".", "update", "(", "vars", "(", "obj", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.collate": [[36, 56], ["isinstance", "isinstance", "elem.numel", "torch.stack().to", "torch.stack", "util.collate", "hasattr", "tuple", "torch.stack", "isinstance", "torch.stack", "b.contiguous().to", "zip", "isinstance", "torch.from_numpy", "b.__torch_tensor__().to", "type", "torch.from_numpy().to", "b.contiguous", "util.collate", "type", "b.__torch_tensor__", "torch.from_numpy", "util.collate", "numpy.array", "tuple"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.collate", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.sac_models.ActorModule.to", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.collate", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.collate"], ["", "def", "collate", "(", "batch", ",", "device", "=", "None", ")", ":", "\n", "    ", "\"\"\"Turns a batch of nested structures with numpy arrays as leaves into into a single element of the same nested structure with batched torch tensors as leaves\"\"\"", "\n", "elem", "=", "batch", "[", "0", "]", "\n", "if", "isinstance", "(", "elem", ",", "torch", ".", "Tensor", ")", ":", "\n", "# return torch.stack(batch, 0).to(device, non_blocking=non_blocking)", "\n", "        ", "if", "elem", ".", "numel", "(", ")", "<", "20000", ":", "# TODO: link to the relavant profiling that lead to this threshold", "\n", "            ", "return", "torch", ".", "stack", "(", "batch", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "stack", "(", "[", "b", ".", "contiguous", "(", ")", ".", "to", "(", "device", ")", "for", "b", "in", "batch", "]", ",", "0", ")", "\n", "", "", "elif", "isinstance", "(", "elem", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "collate", "(", "tuple", "(", "torch", ".", "from_numpy", "(", "b", ")", "for", "b", "in", "batch", ")", ",", "device", ")", "\n", "", "elif", "hasattr", "(", "elem", ",", "'__torch_tensor__'", ")", ":", "\n", "        ", "return", "torch", ".", "stack", "(", "[", "b", ".", "__torch_tensor__", "(", ")", ".", "to", "(", "device", ")", "for", "b", "in", "batch", "]", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "Sequence", ")", ":", "\n", "        ", "transposed", "=", "zip", "(", "*", "batch", ")", "\n", "return", "type", "(", "elem", ")", "(", "collate", "(", "samples", ",", "device", ")", "for", "samples", "in", "transposed", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "Mapping", ")", ":", "\n", "        ", "return", "type", "(", "elem", ")", "(", "(", "key", ",", "collate", "(", "tuple", "(", "d", "[", "key", "]", "for", "d", "in", "batch", ")", ",", "device", ")", ")", "for", "key", "in", "elem", ")", "\n", "", "else", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "batch", ")", ")", ".", "to", "(", "device", ")", "# we create a numpy array first to work around https://github.com/pytorch/pytorch/issues/24200", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partition": [[58, 71], ["isinstance", "TypeError", "x.cpu().numpy", "isinstance", "len", "tuple", "isinstance", "x.cpu", "util.partition", "tuple", "tuple", "zip", "m.values", "type", "range", "m.items", "util.partition"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partition", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partition"], ["", "", "def", "partition", "(", "x", ")", ":", "\n", "    ", "\"\"\"Turns a nested structure with batched torch tensors as leaves into a batch of elements with the same nested structure and un-batched numpy arrays as leaves\"\"\"", "\n", "if", "isinstance", "(", "x", ",", "torch", ".", "Tensor", ")", ":", "\n", "# return x.cpu()", "\n", "        ", "return", "x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "# perhaps we should convert this to tuple for consistency?", "\n", "", "elif", "isinstance", "(", "x", ",", "Mapping", ")", ":", "\n", "        ", "m", "=", "{", "k", ":", "partition", "(", "x", "[", "k", "]", ")", "for", "k", "in", "x", "}", "\n", "numel", "=", "len", "(", "tuple", "(", "m", ".", "values", "(", ")", ")", "[", "0", "]", ")", "\n", "out", "=", "tuple", "(", "type", "(", "x", ")", "(", "(", "key", ",", "value", "[", "i", "]", ")", "for", "key", ",", "value", "in", "m", ".", "items", "(", ")", ")", "for", "i", "in", "range", "(", "numel", ")", ")", "\n", "return", "out", "\n", "", "elif", "isinstance", "(", "x", ",", "Tuple", ")", ":", "\n", "        ", "return", "tuple", "(", "zip", "(", "*", "[", "partition", "(", "elem", ")", "for", "elem", "in", "x", "]", ")", ")", "\n", "", "raise", "TypeError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.default": [[97, 99], ["ValueError"], "function", ["None"], ["", "", "def", "default", "(", ")", ":", "\n", "    ", "raise", "ValueError", "(", "\"This is a dummy function and not meant to be called.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial": [[101, 110], ["functools.partial", "kwargs.items", "isinstance", "util.partial", "inspect.signature", "inspect.signature().parameters[].default"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.default"], ["", "def", "partial", "(", "func", ":", "Type", "[", "T", "]", "=", "default", ",", "*", "args", ",", "**", "kwargs", ")", "->", "Union", "[", "T", ",", "Type", "[", "T", "]", "]", ":", "\n", "    ", "\"\"\"Like `functools.partial`, except if used as a keyword argument for another `partial` and no function is supplied.\n     Then, the outer `partial` will insert the appropriate default value as the function. \"\"\"", "\n", "\n", "if", "func", "is", "not", "default", ":", "\n", "        ", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "functools", ".", "partial", ")", "and", "v", ".", "func", "is", "default", ":", "\n", "                ", "kwargs", "[", "k", "]", "=", "partial", "(", "inspect", ".", "signature", "(", "func", ")", ".", "parameters", "[", "k", "]", ".", "default", ",", "*", "v", ".", "args", ",", "**", "v", ".", "keywords", ")", "\n", "", "", "", "return", "functools", ".", "partial", "(", "func", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_to_dict": [[115, 126], ["dataclasses.fields.update", "p.keywords.keys", "dataclasses.fields.keys", "util.partial_to_dict", "dict", "inspect.signature().parameters.items", "dataclasses.fields.items", "util.partial", "dataclasses.fields.items", "callable", "dataclasses.fields.items", "inspect.signature"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.nn.PopArt.update", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_to_dict", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial"], ["def", "partial_to_dict", "(", "p", ":", "functools", ".", "partial", ",", "version", "=", "\"3\"", ")", ":", "\n", "    ", "assert", "not", "p", ".", "args", ",", "\"So far only keyword arguments are supported, here\"", "\n", "fields", "=", "{", "k", ":", "v", ".", "default", "for", "k", ",", "v", "in", "inspect", ".", "signature", "(", "p", ".", "func", ")", ".", "parameters", ".", "items", "(", ")", "}", "\n", "fields", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "fields", ".", "items", "(", ")", "if", "v", "is", "not", "inspect", ".", "Parameter", ".", "empty", "}", "\n", "diff", "=", "p", ".", "keywords", ".", "keys", "(", ")", "-", "fields", ".", "keys", "(", ")", "\n", "assert", "not", "diff", ",", "f\"There are invalid keywords present: {diff}\"", "\n", "fields", ".", "update", "(", "p", ".", "keywords", ")", "\n", "nested", "=", "{", "k", ":", "partial_to_dict", "(", "partial", "(", "v", ")", ",", "version", "=", "\"\"", ")", "for", "k", ",", "v", "in", "fields", ".", "items", "(", ")", "if", "callable", "(", "v", ")", "}", "\n", "simple", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "fields", ".", "items", "(", ")", "if", "k", "not", "in", "nested", "}", "\n", "output", "=", "{", "FKEY", ":", "p", ".", "func", ".", "__module__", "+", "\":\"", "+", "p", ".", "func", ".", "__qualname__", ",", "**", "simple", ",", "**", "nested", "}", "\n", "return", "dict", "(", "output", ",", "__format_version__", "=", "version", ")", "if", "version", "else", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_from_dict": [[128, 134], ["d.copy.copy", "util.get_class_or_function", "util.partial", "d.copy.pop", "util.partial_from_dict", "d.copy.items", "d.copy.pop", "isinstance"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_class_or_function", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_from_dict"], ["", "def", "partial_from_dict", "(", "d", ":", "dict", ")", ":", "\n", "    ", "d", "=", "d", ".", "copy", "(", ")", "\n", "assert", "d", ".", "pop", "(", "\"__format_version__\"", ",", "\"3\"", ")", "==", "\"3\"", "\n", "d", "=", "{", "k", ":", "partial_from_dict", "(", "v", ")", "if", "isinstance", "(", "v", ",", "dict", ")", "and", "FKEY", "in", "v", "else", "v", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", "}", "\n", "func", "=", "get_class_or_function", "(", "d", ".", "pop", "(", "FKEY", ")", "or", "\"dcac_python.util:default\"", ")", "\n", "return", "partial", "(", "func", ",", "**", "d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_class_or_function": [[136, 139], ["func.split", "getattr", "importlib.import_module"], "function", ["None"], ["", "def", "get_class_or_function", "(", "func", ")", ":", "\n", "    ", "module", ",", "name", "=", "func", ".", "split", "(", "\":\"", ")", "\n", "return", "getattr", "(", "import_module", "(", "module", ")", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_from_args": [[141, 159], ["util.partial", "isinstance", "util.get_class_or_function", "kwargs.get", "k.split", "inspect.signature", "util.partial_from_args", "tuple", "bool", "param.annotation", "params.keys", "k.split", "kwargs.items", "k.startswith", "eval"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_class_or_function", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.partial_from_args"], ["", "def", "partial_from_args", "(", "func", ":", "Union", "[", "str", ",", "callable", "]", ",", "kwargs", ":", "Dict", "[", "str", ",", "str", "]", ")", ":", "\n", "# print(func, kwargs)  # useful to visualize the parsing process", "\n", "    ", "func", "=", "get_class_or_function", "(", "func", ")", "if", "isinstance", "(", "func", ",", "str", ")", "else", "func", "\n", "keys", "=", "{", "k", ".", "split", "(", "'.'", ")", "[", "0", "]", "for", "k", "in", "kwargs", "}", "\n", "keywords", "=", "{", "}", "\n", "for", "key", "in", "keys", ":", "\n", "        ", "params", "=", "inspect", ".", "signature", "(", "func", ")", ".", "parameters", "\n", "assert", "key", "in", "params", ",", "f\"'{key}' is not a valid parameter of {func}. Valid parameters are {tuple(params.keys())}.\"", "\n", "param", "=", "params", "[", "key", "]", "\n", "value", "=", "kwargs", ".", "get", "(", "key", ",", "param", ".", "default", ")", "\n", "if", "param", ".", "annotation", "is", "type", ":", "\n", "            ", "sub_keywords", "=", "{", "k", ".", "split", "(", "'.'", ",", "1", ")", "[", "1", "]", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "if", "k", ".", "startswith", "(", "key", "+", "'.'", ")", "}", "\n", "keywords", "[", "key", "]", "=", "partial_from_args", "(", "value", ",", "sub_keywords", ")", "\n", "", "elif", "param", ".", "annotation", "is", "bool", ":", "\n", "            ", "keywords", "[", "key", "]", "=", "bool", "(", "eval", "(", "value", ")", ")", "# because bool('False') will evaluate to True (it's a non-empty string).", "\n", "", "else", ":", "\n", "            ", "keywords", "[", "key", "]", "=", "param", ".", "annotation", "(", "value", ")", "\n", "", "", "return", "partial", "(", "func", ",", "**", "keywords", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_output": [[163, 169], ["subprocess.check_output", "subprocess.check_output.rstrip"], "function", ["None"], ["", "def", "get_output", "(", "*", "args", ",", "default", "=", "''", ",", "**", "kwargs", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "output", "=", "subprocess", ".", "check_output", "(", "*", "args", ",", "universal_newlines", "=", "True", ",", "**", "kwargs", ")", "\n", "return", "output", ".", "rstrip", "(", "\"\\n\"", ")", "# skip trailing newlines as done in bash", "\n", "", "except", "subprocess", ".", "CalledProcessError", ":", "\n", "        ", "return", "default", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.git_info": [[171, 192], ["util.get_output", "int", "util.get_output", "util.get_output", "get_output().strip", "get_output().strip.startswith", "dict", "os.path.dirname", "util.get_output", "get_output().strip.startswith", "get_output().splitlines", "util.get_output", "util.get_output", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_output", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_output", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_output", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_output", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_output", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.get_output"], ["", "", "def", "git_info", "(", "path", "=", "None", ")", ":", "\n", "    ", "\"\"\"returns a dict with information about the git repo at path (path can be a sub-directory of the git repo)\n    \"\"\"", "\n", "import", "__main__", "\n", "path", "=", "path", "or", "os", ".", "path", ".", "dirname", "(", "__main__", ".", "__file__", ")", "\n", "rev", "=", "get_output", "(", "'git rev-parse HEAD'", ".", "split", "(", ")", ",", "cwd", "=", "path", ")", "\n", "count", "=", "int", "(", "get_output", "(", "'git rev-list HEAD --count'", ".", "split", "(", ")", ",", "default", "=", "'-1'", ",", "cwd", "=", "path", ")", ")", "\n", "status", "=", "get_output", "(", "'git status --short'", ".", "split", "(", ")", ",", "cwd", "=", "path", ")", "# shows un-committed modified files", "\n", "# commit_date = get_output(\"git show --quiet --date=format-local:%Y-%m-%dT%H:%M:%SZ --format=%cd\".split(), cwd=path, env=dict(TZ='UTC'))", "\n", "commit_date", "=", "\"0\"", "# FIXME: hack because didn't work on computecanada for some reason", "\n", "desc", "=", "get_output", "(", "[", "'git'", ",", "'describe'", ",", "'--long'", ",", "'--tags'", ",", "'--dirty'", ",", "'--always'", ",", "'--match'", ",", "r'v[0-9]*\\.[0-9]*'", "]", ",", "cwd", "=", "path", ")", "\n", "message", "=", "desc", "+", "\" \"", "+", "' '", ".", "join", "(", "get_output", "(", "[", "'git'", ",", "'log'", ",", "'--oneline'", ",", "'--format=%B'", ",", "'-n'", ",", "'1'", ",", "\"HEAD\"", "]", ",", "cwd", "=", "path", ")", ".", "splitlines", "(", ")", ")", "\n", "\n", "url", "=", "get_output", "(", "'git config --get remote.origin.url'", ".", "split", "(", ")", ",", "cwd", "=", "path", ")", ".", "strip", "(", ")", "\n", "# if on github, change remote to a meaningful https url", "\n", "if", "url", ".", "startswith", "(", "'git@github.com:'", ")", ":", "\n", "        ", "url", "=", "'https://github.com/'", "+", "url", "[", "len", "(", "'git@github.com:'", ")", ":", "-", "len", "(", "'.git'", ")", "]", "+", "'/commit/'", "+", "rev", "\n", "", "elif", "url", ".", "startswith", "(", "'https://github.com'", ")", ":", "\n", "        ", "url", "=", "url", "[", ":", "len", "(", "'.git'", ")", "]", "+", "'/commit/'", "+", "rev", "\n", "\n", "", "return", "dict", "(", "url", "=", "url", ",", "rev", "=", "rev", ",", "count", "=", "count", ",", "status", "=", "status", ",", "desc", "=", "desc", ",", "date", "=", "commit_date", ",", "message", "=", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dump": [[196, 201], ["util.DelayInterrupt", "open", "pickle.dump"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dump"], ["", "def", "dump", "(", "obj", ",", "path", ")", ":", "\n", "# TODO: use atomic write: https://stackoverflow.com/questions/2333872/atomic-writing-to-file-with-python", "\n", "    ", "with", "DelayInterrupt", "(", ")", ":", "# Continue to save even if SIGINT or SIGTERM is sent and raise KeyboardInterrupt afterwards.", "\n", "        ", "with", "open", "(", "path", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "return", "pickle", ".", "dump", "(", "obj", ",", "f", ",", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.load": [[203, 206], ["open", "pickle.load"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.load"], ["", "", "", "def", "load", "(", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "return", "pickle", ".", "load", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dumps_torch": [[208, 212], ["io.BytesIO", "torch.save", "f.getvalue"], "function", ["None"], ["", "", "def", "dumps_torch", "(", "obj", ")", ":", "\n", "    ", "with", "io", ".", "BytesIO", "(", ")", "as", "f", ":", "\n", "        ", "torch", ".", "save", "(", "obj", ",", "f", ")", "\n", "return", "f", ".", "getvalue", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.loads_torch": [[214, 217], ["io.BytesIO", "torch.load"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.load"], ["", "", "def", "loads_torch", "(", "b", ":", "bytes", ")", ":", "\n", "    ", "with", "io", ".", "BytesIO", "(", "b", ")", "as", "f", ":", "\n", "        ", "return", "torch", ".", "load", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.save_json": [[219, 222], ["open", "json.dump"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.dump"], ["", "", "def", "save_json", "(", "d", ",", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "d", ",", "f", ",", "ensure_ascii", "=", "False", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.load_json": [[224, 227], ["open", "json.load"], "function", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.load"], ["", "", "def", "load_json", "(", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "return", "json", ".", "load", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.Memory.__init__": [[9, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "memory_size", ",", "batchsize", ",", "device", ",", "remove_size", "=", "100", ")", ":", "\n", "        ", "self", ".", "device", "=", "device", "\n", "self", ".", "batchsize", "=", "batchsize", "\n", "self", ".", "capacity", "=", "memory_size", "\n", "self", ".", "memory", "=", "[", "]", "# list is much faster to index than deque for big sizes", "\n", "self", ".", "remove_size", "=", "remove_size", "\n", "\n", "self", ".", "last_observation", "=", "None", "\n", "self", ".", "last_action", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.Memory.append": [[19, 38], ["len", "memory.Memory.memory.append", "info.get", "info.get"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append"], ["", "def", "append", "(", "self", ",", "r", ",", "done", ",", "info", ",", "obs", ",", "action", ")", ":", "\n", "        ", "if", "self", ".", "last_observation", "is", "not", "None", ":", "\n", "\n", "            ", "if", "self", ".", "keep_reset_transitions", ":", "\n", "                ", "store", "=", "True", "\n", "", "else", ":", "\n", "# info[\"reset\"] = True means the episode reset shouldn't be treated as a true terminal state", "\n", "                ", "store", "=", "not", "info", ".", "get", "(", "'TimeLimit.truncated'", ",", "False", ")", "and", "not", "info", ".", "get", "(", "'reset'", ",", "False", ")", "\n", "\n", "", "if", "store", ":", "\n", "                ", "self", ".", "memory", ".", "append", "(", "(", "self", ".", "last_observation", ",", "self", ".", "last_action", ",", "r", ",", "obs", ",", "done", ")", ")", "\n", "\n", "", "", "self", ".", "last_observation", "=", "obs", "\n", "self", ".", "last_action", "=", "action", "\n", "\n", "# remove old entries if necessary (delete generously so we don't have to do it often)", "\n", "if", "len", "(", "self", ".", "memory", ")", ">", "self", ".", "capacity", ":", "\n", "            ", "del", "self", ".", "memory", "[", ":", "self", ".", "capacity", "//", "self", ".", "remove_size", "+", "1", "]", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.Memory.__len__": [[39, 41], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "memory", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.Memory.__getitem__": [[42, 44], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "return", "self", ".", "memory", "[", "item", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.Memory.sample_indices": [[45, 47], ["random.randint", "range", "len"], "methods", ["None"], ["", "def", "sample_indices", "(", "self", ")", ":", "\n", "        ", "return", "(", "randint", "(", "0", ",", "len", "(", "self", ".", "memory", ")", "-", "1", ")", "for", "_", "in", "range", "(", "self", ".", "batchsize", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.Memory.sample": [[48, 53], ["rlrd.util.collate", "memory.Memory.sample_indices"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.collate", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample_indices"], ["", "def", "sample", "(", "self", ",", "indices", "=", "None", ")", ":", "\n", "        ", "indices", "=", "self", ".", "sample_indices", "(", ")", "if", "indices", "is", "None", "else", "indices", "\n", "batch", "=", "[", "self", ".", "memory", "[", "idx", "]", "for", "idx", "in", "indices", "]", "\n", "batch", "=", "collate", "(", "batch", ",", "self", ".", "device", ")", "\n", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemory.__init__": [[58, 65], ["collections.deque"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "memory_size", ",", "batchsize", ",", "device", ",", "history", "=", "1", ",", "remove_size", "=", "100", ")", ":", "\n", "        ", "self", ".", "device", "=", "device", "\n", "self", ".", "batchsize", "=", "batchsize", "\n", "self", ".", "capacity", "=", "memory_size", "\n", "self", ".", "memory", "=", "[", "]", "# list is much faster to index than deque for big sizes", "\n", "self", ".", "history", "=", "deque", "(", "maxlen", "=", "history", "+", "1", ")", "\n", "self", ".", "remove_size", "=", "remove_size", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemory.append": [[66, 83], ["memory.TrajMemory.history.append", "memory.TrajMemory.history.clear", "len", "zip", "memory.TrajMemory.memory.append", "memory.TrajMemory.history.clear", "len", "info.get", "info.get"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append"], ["", "def", "append", "(", "self", ",", "r", ",", "done", ",", "info", ",", "obs", ",", "h", ",", "action", ")", ":", "\n", "        ", "self", ".", "history", ".", "append", "(", "(", "r", ",", "obs", ",", "h", ",", "action", ")", ")", "\n", "if", "not", "self", ".", "keep_reset_transitions", "and", "(", "info", ".", "get", "(", "'TimeLimit.truncated'", ",", "False", ")", "or", "info", ".", "get", "(", "'reset'", ",", "False", ")", ")", ":", "\n", "            ", "self", ".", "history", ".", "clear", "(", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "history", ")", "==", "self", ".", "history", ".", "maxlen", ":", "\n", "            ", "(", "_", ",", "*", "r", ")", ",", "m", ",", "h", ",", "a", "=", "zip", "(", "*", "self", ".", "history", ")", "\n", "self", ".", "memory", ".", "append", "(", "(", "m", ",", "h", ",", "a", ",", "r", ",", "done", ")", ")", "\n", "\n", "", "if", "done", ":", "\n", "            ", "self", ".", "history", ".", "clear", "(", ")", "\n", "\n", "# remove old entries if necessary (delete generously so we don't have to do it often)", "\n", "", "if", "len", "(", "self", ".", "memory", ")", ">", "self", ".", "capacity", ":", "\n", "            ", "del", "self", ".", "memory", "[", ":", "self", ".", "capacity", "//", "self", ".", "remove_size", "+", "1", "]", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemory.__len__": [[84, 86], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "memory", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemory.__getitem__": [[87, 89], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "return", "self", ".", "memory", "[", "item", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemory.sample_indices": [[90, 92], ["random.randint", "range", "len"], "methods", ["None"], ["", "def", "sample_indices", "(", "self", ")", ":", "\n", "        ", "return", "(", "randint", "(", "0", ",", "len", "(", "self", ".", "memory", ")", "-", "1", ")", "for", "_", "in", "range", "(", "self", ".", "batchsize", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemory.sample": [[93, 98], ["rlrd.util.collate", "memory.TrajMemory.sample_indices"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.collate", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample_indices"], ["", "def", "sample", "(", "self", ",", "indices", "=", "None", ")", ":", "\n", "        ", "indices", "=", "self", ".", "sample_indices", "(", ")", "if", "indices", "is", "None", "else", "indices", "\n", "batch", "=", "[", "self", ".", "memory", "[", "idx", "]", "for", "idx", "in", "indices", "]", "\n", "batch", "=", "collate", "(", "batch", ",", "self", ".", "device", ")", "\n", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__init__": [[103, 110], ["collections.deque"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "memory_size", ",", "batchsize", ",", "device", ",", "history", "=", "1", ",", "remove_size", "=", "100", ")", ":", "\n", "        ", "self", ".", "device", "=", "device", "\n", "self", ".", "batchsize", "=", "batchsize", "\n", "self", ".", "capacity", "=", "memory_size", "\n", "self", ".", "memory", "=", "[", "]", "# list is much faster to index than deque for big sizes", "\n", "self", ".", "history", "=", "deque", "(", "maxlen", "=", "history", "+", "1", ")", "\n", "self", ".", "remove_size", "=", "remove_size", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append": [[111, 128], ["memory.TrajMemoryNoHidden.history.append", "memory.TrajMemoryNoHidden.history.clear", "len", "zip", "memory.TrajMemoryNoHidden.memory.append", "memory.TrajMemoryNoHidden.history.clear", "len", "info.get", "info.get"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.append"], ["", "def", "append", "(", "self", ",", "r", ",", "done", ",", "info", ",", "obs", ",", "action", ")", ":", "\n", "        ", "self", ".", "history", ".", "append", "(", "(", "r", ",", "obs", ",", "action", ")", ")", "\n", "if", "not", "self", ".", "keep_reset_transitions", "and", "(", "info", ".", "get", "(", "'TimeLimit.truncated'", ",", "False", ")", "or", "info", ".", "get", "(", "'reset'", ",", "False", ")", ")", ":", "\n", "            ", "self", ".", "history", ".", "clear", "(", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "history", ")", "==", "self", ".", "history", ".", "maxlen", ":", "\n", "            ", "(", "_", ",", "*", "r", ")", ",", "m", ",", "a", "=", "zip", "(", "*", "self", ".", "history", ")", "\n", "self", ".", "memory", ".", "append", "(", "(", "m", ",", "a", ",", "r", ",", "done", ")", ")", "\n", "\n", "", "if", "done", ":", "\n", "            ", "self", ".", "history", ".", "clear", "(", ")", "\n", "\n", "# remove old entries if necessary (delete generously so we don't have to do it often)", "\n", "", "if", "len", "(", "self", ".", "memory", ")", ">", "self", ".", "capacity", ":", "\n", "            ", "del", "self", ".", "memory", "[", ":", "self", ".", "capacity", "//", "self", ".", "remove_size", "+", "1", "]", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__len__": [[129, 131], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "memory", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.__getitem__": [[132, 134], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "return", "self", ".", "memory", "[", "item", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample_indices": [[135, 137], ["random.randint", "range", "len"], "methods", ["None"], ["", "def", "sample_indices", "(", "self", ")", ":", "\n", "        ", "return", "(", "randint", "(", "0", ",", "len", "(", "self", ".", "memory", ")", "-", "1", ")", "for", "_", "in", "range", "(", "self", ".", "batchsize", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample": [[138, 143], ["rlrd.util.collate", "memory.TrajMemoryNoHidden.sample_indices"], "methods", ["home.repos.pwc.inspect_result.rmst_rlrd.rlrd.util.collate", "home.repos.pwc.inspect_result.rmst_rlrd.rlrd.memory.TrajMemoryNoHidden.sample_indices"], ["", "def", "sample", "(", "self", ",", "indices", "=", "None", ")", ":", "\n", "        ", "indices", "=", "self", ".", "sample_indices", "(", ")", "if", "indices", "is", "None", "else", "indices", "\n", "batch", "=", "[", "self", ".", "memory", "[", "idx", "]", "for", "idx", "in", "indices", "]", "\n", "batch", "=", "collate", "(", "batch", ",", "self", ".", "device", ")", "\n", "return", "batch", "\n", "", "", ""]]}