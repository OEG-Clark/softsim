{"home.repos.pwc.inspect_result.huhailinguist_ccg2mono.None.xml2text.main": [[13, 24], ["xml.parse", "ET.parse.getroot", "tree.getroot.iter", "list", "print", "print", "sentence.iter"], "function", ["None"], ["def", "main", "(", "args", ")", ":", "\n", "\n", "    ", "tree", "=", "ET", ".", "parse", "(", "args", ".", "in_file", ")", "\n", "root", "=", "tree", ".", "getroot", "(", ")", "\n", "\n", "for", "sentence", "in", "root", ".", "iter", "(", "'sentence'", ")", ":", "\n", "        ", "tokens", "=", "list", "(", "sentence", ".", "iter", "(", "'token'", ")", ")", "\n", "string", "=", "' '", ".", "join", "(", "[", "token", ".", "attrib", "[", "'surf'", "]", "for", "token", "in", "tokens", "]", ")", "\n", "polarity", "=", "' '", ".", "join", "(", "[", "polarity_to_labels", "[", "token", ".", "attrib", "[", "'polarity'", "]", "]", "for", "token", "in", "tokens", "]", ")", "\n", "print", "(", "string", ")", "\n", "print", "(", "polarity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.main": [[37, 45], ["len", "getMono.eprint", "mytree2transccg.convert2transccg"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.convert2transccg"], ["def", "main", "(", ")", ":", "\n", "    ", "if", "len", "(", "sys", ".", "argv", ")", "<", "4", ":", "\n", "        ", "eprint", "(", "message", ")", "\n", "", "else", ":", "\n", "        ", "filename", "=", "sys", ".", "argv", "[", "1", "]", "\n", "parser", "=", "sys", ".", "argv", "[", "2", "]", "\n", "filename_log", "=", "sys", ".", "argv", "[", "3", "]", "\n", "convert2transccg", "(", "filename", ",", "parser", ",", "filename_log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.convert2transccg": [[46, 162], ["getMono.CCGtrees", "open", "range", "open.close", "getMono.eprint", "print", "getMono.CCGtrees.trees.items", "print", "getMono.CCGtrees.readEasyccgStr", "open().readlines", "len", "getMono.CCGtrees.build_one_tree", "getMono.eprint", "print", "print", "print", "print", "mytree2transccg.traverse2get_span_id", "mytree2transccg.traverse", "print", "print", "getMono.CCGtrees.readCandCxml", "open().readlines", "getMono.eprint", "getMono.eprint", "raw_sentences[].replace().replace", "open.write", "trees.build_one_tree.fixQuantifier", "open.write", "open.write", "token.cat.semCat.__str__", "mytree2transccg.getPolarityAsArrow", "print", "open", "getMono.CCGtrees.readEasyccgStr", "open().readlines", "getMono.eprint", "exit", "trees.build_one_tree.fixNot", "trees.build_one_tree.fixRC", "trees.build_one_tree.mark", "trees.build_one_tree.polarize", "trees.build_one_tree.getImpSign", "trees.build_one_tree.printSent_raw", "str", "str_token.format", "str", "str", "open", "raw_sentences[].replace", "getMono.eprint", "getMono.eprint", "filename.replace", "open", "str", "filename.replace", "filename.replace"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readEasyccgStr", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.build_one_tree", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse2get_span_id", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readCandCxml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixQuantifier", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.__str__", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.getPolarityAsArrow", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readEasyccgStr", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixNot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixRC", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarize", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getImpSign", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent_raw", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "", "def", "convert2transccg", "(", "filename", ",", "parser", ",", "filename_log", ")", ":", "\n", "    ", "\"\"\"\n    input: \n    - easyccg output (tmp.easyccg.parsed.txt) or \n    - candc output (tmp.candc.parsed.xml)\n\n    input is read into my CCGtree format. \n\n    then traverse the tree and print xml to stdout\n\n    return # of sents not polarized\n    \"\"\"", "\n", "trees", "=", "CCGtrees", "(", "filename_log", ")", "\n", "\n", "if", "parser", "==", "'easyccg'", ":", "\n", "        ", "trees", ".", "readEasyccgStr", "(", "filename", ")", "#('tmp.easyccg.parsed.txt')", "\n", "raw_sentences", "=", "open", "(", "filename", ".", "replace", "(", "\".easyccg.parsed.txt\"", ",", "\"\"", ")", "+", "\".tok.clean\"", ")", ".", "readlines", "(", ")", "\n", "", "elif", "parser", "==", "'candc'", ":", "\n", "        ", "trees", ".", "readCandCxml", "(", "filename", ")", "#('tmp.candc.parsed.xml')", "\n", "raw_sentences", "=", "open", "(", "filename", ".", "replace", "(", "\".candc.parsed.xml\"", ",", "\"\"", ")", "+", "\".tok.clean\"", ")", ".", "readlines", "(", ")", "\n", "", "elif", "parser", "==", "'depccg'", ":", "# same as easyccg", "\n", "        ", "trees", ".", "readEasyccgStr", "(", "filename", ")", "\n", "raw_sentences", "=", "open", "(", "filename", ".", "replace", "(", "\".depccg.parsed.txt\"", ",", "\"\"", ")", "+", "\".tok.clean\"", ")", ".", "readlines", "(", ")", "\n", "", "else", ":", "\n", "        ", "eprint", "(", "'parser can only be: easyccg, candc, depccg'", ")", "\n", "exit", "(", ")", "\n", "\n", "# ----------------------------------", "\n", "# mark and polarize", "\n", "", "N_polar", "=", "0", "\n", "N_unpolar", "=", "0", "\n", "N_unparsed", "=", "0", "\n", "fh_polarized_trees", "=", "open", "(", "filename", "+", "\".polarized\"", ",", "\"w\"", ")", "\n", "\n", "# sent_parsed = True", "\n", "\n", "# idx_cant_polarize = {}", "\n", "for", "idx", "in", "range", "(", "len", "(", "raw_sentences", ")", ")", ":", "\n", "# build the tree here", "\n", "        ", "t", "=", "trees", ".", "build_one_tree", "(", "idx", ",", "parser", ",", "use_lemma", "=", "False", ")", "\n", "# eprint(trees.easyccg_str.get(idx, None))", "\n", "# print(t)", "\n", "# return", "\n", "\n", "if", "t", "in", "[", "\"failed_to_parse\"", ",", "\"parse_exception\"", "]", ":", "# easyccg failed to parse the sent", "\n", "            ", "eprint", "(", "'easyccg failed to parse the sent'", ")", "\n", "eprint", "(", "raw_sentences", "[", "idx", "]", ")", "\n", "sent", "=", "raw_sentences", "[", "idx", "]", ".", "replace", "(", "\" \"", ",", "\"= \"", ")", ".", "replace", "(", "\"\\n\"", ",", "\"=\\n\"", ")", "# = for every token", "\n", "fh_polarized_trees", ".", "write", "(", "sent", ")", "\n", "N_unparsed", "+=", "1", "\n", "\n", "", "else", ":", "# t is a tree", "\n", "# fix tree", "\n", "            ", "t", ".", "fixQuantifier", "(", ")", "\n", "try", ":", "t", ".", "fixNot", "(", ")", "\n", "except", "AttributeError", ":", "pass", "\n", "if", "parser", "in", "[", "'candc'", "]", ":", "t", ".", "fixRC", "(", ")", "# only fix RC for candc", "\n", "\n", "try", ":", "\n", "                ", "t", ".", "mark", "(", ")", "\n", "t", ".", "polarize", "(", ")", "\n", "t", ".", "getImpSign", "(", ")", "\n", "N_polar", "+=", "1", "\n", "", "except", "(", "ErrorCompareSemCat", ",", "ErrorCCGtree", ",", "AssertionError", ",", "AttributeError", ",", "ErrorCat", ")", "as", "e", ":", "\n", "                ", "eprint", "(", "e", ")", "\n", "eprint", "(", "'-- cannot polarize sent: '", ",", "end", "=", "''", ")", "\n", "N_unpolar", "+=", "1", "\n", "# t.printSent(stream=sys.stderr)", "\n", "", "fh_polarized_trees", ".", "write", "(", "t", ".", "printSent_raw", "(", "stream", "=", "sys", ".", "stderr", ")", ")", "\n", "fh_polarized_trees", ".", "write", "(", "\"\\n\"", ")", "\n", "", "eprint", "(", ")", "\n", "", "fh_polarized_trees", ".", "close", "(", ")", "\n", "eprint", "(", "\"\\n\\n===========\\npolarized {} trees\\n\"", "\n", "\"unable to parse {} trees\\n\"", "\n", "\"unable to polarize {} trees\"", ".", "format", "(", "N_polar", ",", "N_unparsed", ",", "N_unpolar", ")", ")", "\n", "\n", "# ----------------------------------", "\n", "\n", "print", "(", "\"\"\"<?xml version='1.0' encoding='UTF-8'?>\\n<root>\\n<document>\\n<sentences>\"\"\"", ")", "\n", "for", "idx", ",", "t", "in", "trees", ".", "trees", ".", "items", "(", ")", ":", "\n", "        ", "if", "t", "in", "[", "\"failed_to_parse\"", ",", "\"parse_exception\"", "]", ":", "\n", "            ", "continue", "\n", "\n", "", "print", "(", "\"<sentence>\"", ")", "\n", "\n", "# ----------------------------", "\n", "# print tokens", "\n", "print", "(", "\"<tokens>\"", ")", "\n", "counter", "=", "0", "\n", "for", "token", "in", "t", ".", "leafNodes", ":", "\n", "# depth,cat,chunk,entity,lemma,pos,span,start,word", "\n", "            ", "token_id", "=", "\"t\"", "+", "str", "(", "idx", ")", "+", "'_'", "+", "str", "(", "counter", ")", "\n", "ETtype", "=", "token", ".", "cat", ".", "semCat", ".", "__str__", "(", ")", "\n", "polarity", "=", "getPolarityAsArrow", "(", "token", ")", "\n", "print", "(", "str_token", ".", "format", "(", "token", ".", "start", ",", "token", ".", "span", ",", "token", ".", "pos", ",", "token", ".", "chunk", ",", "\n", "token", ".", "entity", ",", "token", ".", "cat", ".", "originalType", ",", "token_id", ",", "\n", "token", ".", "word", ",", "token", ".", "lemma", ",", "ETtype", ",", "polarity", ")", ")", "\n", "counter", "+=", "1", "\n", "", "print", "(", "\"</tokens>\"", ")", "\n", "\n", "# ----------------------------", "\n", "# print nodes", "\n", "# <ccg root=\"s0_sp0\" id=\"s0_ccg0\">", "\n", "print", "(", "'<ccg root=\"s{}_sp0\" id=\"s{}_ccg0\">'", ".", "format", "(", "str", "(", "idx", ")", ",", "str", "(", "idx", ")", ")", ")", "\n", "\n", "# tree", "\n", "# in-order traversal of tree to get span_id of non term node", "\n", "traverse2get_span_id", "(", "t", ".", "root", ",", "-", "1", ",", "idx", ")", "\n", "\n", "# in order traversal of tree", "\n", "traverse", "(", "t", ".", "root", ",", "0", ",", "idx", ")", "\n", "\n", "print", "(", "\"</ccg>\"", ")", "\n", "print", "(", "\"</sentence>\"", ")", "\n", "\n", "", "print", "(", "\"\"\"</sentences>\\n</document>\\n</root>\"\"\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse2get_span_id": [[164, 182], ["len", "str", "len", "mytree2transccg.traverse2get_span_id", "mytree2transccg.traverse2get_span_id", "mytree2transccg.traverse2get_span_id", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse2get_span_id", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse2get_span_id", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse2get_span_id"], ["", "def", "traverse2get_span_id", "(", "node", ",", "counter", ",", "idx", ")", ":", "\n", "    ", "'''\n    traverse the tree to get span_id of all nodes (leaf + non term)\n    '''", "\n", "counter", "+=", "1", "\n", "if", "node", "is", "None", ":", "return", "# why would this happen?", "\n", "\n", "# idx is the sentence idx", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "# leaf", "\n", "        ", "node", ".", "span_id", "=", "'s'", "+", "str", "(", "idx", ")", "+", "'_sp'", "+", "str", "(", "counter", ")", "\n", "", "elif", "len", "(", "node", ".", "children", ")", "==", "1", ":", "# 1 child", "\n", "        ", "node", ".", "span_id", "=", "'s'", "+", "str", "(", "idx", ")", "+", "'_sp'", "+", "str", "(", "counter", ")", "\n", "counter", "=", "traverse2get_span_id", "(", "node", ".", "children", "[", "0", "]", ",", "counter", ",", "idx", ")", "\n", "", "else", ":", "# 2 children", "\n", "        ", "node", ".", "span_id", "=", "'s'", "+", "str", "(", "idx", ")", "+", "'_sp'", "+", "str", "(", "counter", ")", "\n", "counter", "=", "traverse2get_span_id", "(", "node", ".", "children", "[", "0", "]", ",", "counter", ",", "idx", ")", "\n", "counter", "=", "traverse2get_span_id", "(", "node", ".", "children", "[", "1", "]", ",", "counter", ",", "idx", ")", "\n", "", "return", "counter", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse": [[183, 224], ["node.cat.semCat.__str__", "mytree2transccg.getPolarityAsArrow", "len", "print", "str", "str_span_leaf.format", "len", "mytree2transccg.traverse", "mytree2transccg.traverse", "mytree2transccg.traverse", "print", "print", "print", "print", "str", "str_span_root.format", "str_span_nonTerm.format", "str_span_root.format", "str_span_nonTerm.format"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.__str__", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.getPolarityAsArrow", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.traverse"], ["", "def", "traverse", "(", "node", ",", "leafCounter", ",", "idx", ")", ":", "\n", "    ", "\"\"\" traverse the tree to print xml \"\"\"", "\n", "ETtype", "=", "node", ".", "cat", ".", "semCat", ".", "__str__", "(", ")", "\n", "polarity", "=", "getPolarityAsArrow", "(", "node", ")", "\n", "if", "node", ".", "impSign", ":", "# TODO need to fix this", "\n", "        ", "polarity", "=", "polarity", "+", "\" : \"", "+", "node", ".", "impSign", "# plus implicative sign", "\n", "\n", "", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "# leaf", "\n", "        ", "terminal", "=", "\"t\"", "+", "str", "(", "idx", ")", "+", "'_'", "+", "str", "(", "leafCounter", ")", "\n", "print", "(", "str_span_leaf", ".", "format", "(", "node", ".", "start", ",", "node", ".", "span", ",", "node", ".", "pos", ",", "\n", "node", ".", "chunk", ",", "node", ".", "entity", ",", "node", ".", "span_id", ",", "\n", "node", ".", "word", ",", "node", ".", "lemma", ",", "terminal", ",", "\n", "node", ".", "cat", ".", "originalType", ",", "ETtype", ",", "polarity", ")", ")", "\n", "leafCounter", "+=", "1", "\n", "\n", "", "else", ":", "\n", "        ", "child_str", "=", "' '", ".", "join", "(", "child", ".", "span_id", "for", "child", "in", "node", ".", "children", ")", "\n", "# 1 child", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "1", ":", "\n", "# root", "\n", "            ", "if", "node", ".", "span_id", "[", "3", ":", "]", "==", "'sp0'", ":", "\n", "                ", "child_str", "=", "' '", ".", "join", "(", "child", ".", "span_id", "for", "child", "in", "node", ".", "children", ")", "\n", "print", "(", "str_span_root", ".", "format", "(", "node", ".", "span_id", ",", "child_str", ",", "node", ".", "cat", ".", "originalType", ",", "node", ".", "ruleType", ",", "ETtype", ",", "polarity", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "str_span_nonTerm", ".", "format", "(", "node", ".", "span_id", ",", "child_str", ",", "node", ".", "cat", ".", "originalType", ",", "node", ".", "ruleType", ",", "ETtype", ",", "polarity", ")", ")", "\n", "\n", "", "leafCounter", "=", "traverse", "(", "node", ".", "children", "[", "0", "]", ",", "leafCounter", ",", "idx", ")", "\n", "\n", "# 2 children", "\n", "", "else", ":", "\n", "# root", "\n", "            ", "if", "node", ".", "span_id", "[", "3", ":", "]", "==", "'sp0'", ":", "\n", "                ", "child_str", "=", "' '", ".", "join", "(", "child", ".", "span_id", "for", "child", "in", "node", ".", "children", ")", "\n", "print", "(", "str_span_root", ".", "format", "(", "node", ".", "span_id", ",", "child_str", ",", "node", ".", "cat", ".", "originalType", ",", "node", ".", "ruleType", ",", "ETtype", ",", "polarity", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "str_span_nonTerm", ".", "format", "(", "node", ".", "span_id", ",", "child_str", ",", "node", ".", "cat", ".", "originalType", ",", "node", ".", "ruleType", ",", "ETtype", ",", "polarity", ")", ")", "\n", "\n", "", "leafCounter", "=", "traverse", "(", "node", ".", "children", "[", "0", "]", ",", "leafCounter", ",", "idx", ")", "\n", "leafCounter", "=", "traverse", "(", "node", ".", "children", "[", "1", "]", ",", "leafCounter", ",", "idx", ")", "\n", "\n", "", "", "return", "leafCounter", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.mytree2transccg.getPolarityAsArrow": [[225, 231], ["None"], "function", ["None"], ["", "def", "getPolarityAsArrow", "(", "node", ")", ":", "\n", "    ", "\"\"\" map (None, UP, DOWN) to (=, uparrow, downarrow) \"\"\"", "\n", "polarity", "=", "\"=\"", "\n", "if", "node", ".", "cat", ".", "monotonicity", "==", "\"UP\"", ":", "polarity", "=", "'\\u2191'", "\n", "elif", "node", ".", "cat", ".", "monotonicity", "==", "\"DOWN\"", ":", "polarity", "=", "'\\u2193'", "\n", "return", "polarity", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.preprocess.main": [[64, 68], ["preprocess.preprocess"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.preprocess.preprocess"], ["def", "main", "(", ")", ":", "\n", "# fn = \"test.tok\"", "\n", "    ", "fn", "=", "sys", ".", "argv", "[", "1", "]", "\n", "preprocess", "(", "fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.preprocess.preprocess": [[69, 107], ["open", "open.write", "open", "getMono.eprint", "open.close", "open.close", "getMono.eprint", "open", "preprocess_line.strip", "getMono.eprint", "preprocess.preprocess_line", "getMono.eprint", "open.write", "open.write"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.preprocess.preprocess_line", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "preprocess", "(", "fn", ")", ":", "\n", "    ", "\"\"\" produce a clean file named: test.tok.clean\n    and log file: test.tok.preprocess.log \"\"\"", "\n", "sent_id", "=", "-", "1", "\n", "fh_log", "=", "open", "(", "fn", "+", "'.preprocess.log'", ",", "'w'", ")", "\n", "fh_log", ".", "write", "(", "\"sentId,before,after,idx,len_sent\\n\"", ")", "\n", "fh_clean", "=", "open", "(", "fn", "+", "'.clean'", ",", "'w'", ")", "\n", "s_pattern", "=", "\"{},{},{},{},{}\\n\"", "\n", "# p2a = P2A_transformer(spacy.load('en'))", "\n", "# corenlp = StanfordCoreNLP('http://localhost', port=9000, lang='en')", "\n", "\n", "eprint", "(", "'\\npreprocessing...'", ")", "\n", "with", "open", "(", "fn", ")", "as", "f", ":", "\n", "        ", "for", "line", "in", "f", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "==", "\"\"", ":", "continue", "\n", "\n", "sent_id", "+=", "1", "\n", "# print('\\npreprocessing:', sent_id)", "\n", "\n", "# line = line.lower()", "\n", "\n", "eprint", "(", "'\\nbefore:'", ",", "line", ")", "\n", "\n", "# with passitve to active transformation", "\n", "# line = preprocess_line(line, fh_log, s_pattern, sent_id, p2a, corenlp)", "\n", "\n", "# no passive to active transformation", "\n", "line", "=", "preprocess_line", "(", "line", ",", "fh_log", ",", "s_pattern", ",", "sent_id", ")", "\n", "eprint", "(", "'after :'", ",", "line", ")", "\n", "\n", "# write to clean file", "\n", "fh_clean", ".", "write", "(", "line", ")", "\n", "fh_clean", ".", "write", "(", "'\\n'", ")", "\n", "\n", "", "", "fh_log", ".", "close", "(", ")", "\n", "fh_clean", ".", "close", "(", ")", "\n", "eprint", "(", "'...done!\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.preprocess.preprocess_line": [[108, 231], ["pat[].sub.lower", "pat[].sub.replace", "pat[].sub.replace().replace", "pat[].sub.replace", "pat[].sub.replace().replace", "PAT_someone.sub", "PAT_noone.sub", "PAT_everyone.sub", "PAT_something.sub", "PAT_nothing.sub", "PAT_everything.sub", "PAT_somewhere.sub", "PAT_nowhere.sub", "PAT_everywhere.sub", "pat[].sub.replace", "pat[].sub.replace().replace", "pat[].sub.replace().replace", "pat[].sub.replace().replace", "pat[].sub.replace().replace", "pat[].sub.replace().replace", "pat[].sub.replace().replace", "pat[].sub.replace().replace", "pat[].sub.replace().replace", "PAT_more_than_n.sub", "PAT_less_than_n.sub", "PAT_at_least_n.sub", "PAT_at_most_n.sub", "PAT_exactly_n.sub", "PAT_some_but_not_all.sub", "len", "enumerate", "preprocess.fix_a_lot_of", "pat[].sub", "pat[].sub.split", "pat[].sub.split", "line[].upper", "pat[].sub.replace", "pat[].sub.replace", "pat[].sub.replace", "pat[].sub.replace", "pat[].sub.replace", "pat[].sub.replace", "pat[].sub.replace", "pat[].sub.replace", "pat[].sub.replace", "pat[].sub.replace", "word.lower", "new_line.append", "word.lower().startswith", "word.lower().startswith", "new_line.append", "fh_log.write", "s_pattern.format", "word.lower().startswith", "word.lower().startswith", "new_line.append", "fh_log.write", "word.lower().startswith", "word.lower", "word.lower", "str", "str", "s_pattern.format", "new_line.append", "fh_log.write", "new_line.append", "word.lower", "word.lower", "str", "str", "word.lower", "s_pattern.format", "str", "str"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.preprocess.fix_a_lot_of"], ["", "def", "preprocess_line", "(", "line", ",", "fh_log", ",", "s_pattern", ",", "sent_id", ",", "p2a", "=", "None", ",", "corenlp", "=", "None", ")", ":", "\n", "    ", "\"\"\" preprocess one line \"\"\"", "\n", "line_lower", "=", "line", ".", "lower", "(", ")", "\n", "\n", "# ----------------------------------------------", "\n", "# change `#` to `number`", "\n", "# e.g.: # 6 tries her best to help her team to victory", "\n", "line", "=", "line", ".", "replace", "(", "\"#\"", ",", "\"number\"", ")", "\n", "\n", "# ----------------------------------------------", "\n", "# green/blue ... colored -> green/blue", "\n", "#line = line.replace(\"blue colored\", \"blue\").replace(\"green colored\", \"green\").\\", "\n", "#    replace(\"brown colored\", \"brown\").replace(\"dark colored\", \"dark\").\\", "\n", "#    replace(\"light colored\", \"light\").replace(\"orange colored\", \"orange\").\\", "\n", "#    replace(\"purple colored\", \"purple\")", "\n", "\n", "# ----------------------------------------------", "\n", "# a group of -> some", "\n", "line", "=", "line", ".", "replace", "(", "\"A group of four\"", ",", "\"Four\"", ")", ".", "replace", "(", "\"A group of five\"", ",", "\"Five\"", ")", "\n", "line", "=", "line", ".", "replace", "(", "\"A cluster of four\"", ",", "\"Four\"", ")", "\n", "line", "=", "line", ".", "replace", "(", "\"A group of\"", ",", "\"Some\"", ")", ".", "replace", "(", "\"a group of\"", ",", "\"some\"", ")", "\n", "\n", "# ----------------------------------------------", "\n", "# fix ``a lot of''", "\n", "if", "\"a lot of \"", "in", "line_lower", ":", "\n", "        ", "line", "=", "fix_a_lot_of", "(", "line", ",", "fh_log", ",", "s_pattern", ",", "sent_id", ")", "\n", "\n", "# ----------------------------------------------", "\n", "# someone/body -> some person; nobody/no one -> no person", "\n", "", "line", "=", "PAT_someone", ".", "sub", "(", "\"some person\"", ",", "line", ")", "\n", "line", "=", "PAT_noone", ".", "sub", "(", "\"no person\"", ",", "line", ")", "\n", "line", "=", "PAT_everyone", ".", "sub", "(", "\"every person\"", ",", "line", ")", "\n", "\n", "line", "=", "PAT_something", ".", "sub", "(", "\"some thing\"", ",", "line", ")", "\n", "line", "=", "PAT_nothing", ".", "sub", "(", "\"no thing\"", ",", "line", ")", "\n", "line", "=", "PAT_everything", ".", "sub", "(", "\"every thing\"", ",", "line", ")", "\n", "\n", "line", "=", "PAT_somewhere", ".", "sub", "(", "\"some place\"", ",", "line", ")", "\n", "line", "=", "PAT_nowhere", ".", "sub", "(", "\"no place\"", ",", "line", ")", "\n", "line", "=", "PAT_everywhere", ".", "sub", "(", "\"every place\"", ",", "line", ")", "\n", "\n", "# ----------------------------------------------", "\n", "# n't -> not", "\n", "line", "=", "line", ".", "replace", "(", "\" n't \"", ",", "\" not \"", ")", "\n", "\n", "# ----------------------------------------------", "\n", "# the -> a", "\n", "# line = line.replace(\"The \", \"A \").replace(\" the \", \" a \")", "\n", "\n", "# ----------------------------------------------", "\n", "# there is no ... -> no boy/woman/person ...", "\n", "#if PAT_there_be_no.match(line):", "\n", "#    new_sent, new_sent2, diff = utils.there_be_no_sent(line, corenlp)", "\n", "#    line = new_sent2", "\n", "# else:  pass # TODO only pass2act if not \"there be no\"", "\n", "\n", "# ----------------------------------------------", "\n", "# pass2actPAT_a_few", "\n", "#    line_old = line[:]", "\n", "#    line = p2a.pass2act(line).strip('. ')", "\n", "#    if line == line_old and line.endswith(\" by a thing\"):", "\n", "#        line = line[:-11]  # remove by a thing if still not activized", "\n", "\n", "# ----------------------------------------------", "\n", "# numbers", "\n", "line", "=", "line", ".", "replace", "(", "'Two '", ",", "'2 '", ")", ".", "replace", "(", "' two '", ",", "' 2 '", ")", "\n", "line", "=", "line", ".", "replace", "(", "'Three '", ",", "'3 '", ")", ".", "replace", "(", "' three '", ",", "' 3 '", ")", "\n", "line", "=", "line", ".", "replace", "(", "'Four '", ",", "'4 '", ")", ".", "replace", "(", "' four '", ",", "' 4 '", ")", "\n", "line", "=", "line", ".", "replace", "(", "'Five '", ",", "'5 '", ")", ".", "replace", "(", "' five '", ",", "' 5 '", ")", "\n", "line", "=", "line", ".", "replace", "(", "'Six '", ",", "'6 '", ")", ".", "replace", "(", "' six '", ",", "' 6 '", ")", "\n", "line", "=", "line", ".", "replace", "(", "'Seven '", ",", "'7 '", ")", ".", "replace", "(", "' seven '", ",", "' 7 '", ")", "\n", "line", "=", "line", ".", "replace", "(", "'Eight '", ",", "'8 '", ")", ".", "replace", "(", "' eight '", ",", "' 8 '", ")", "\n", "line", "=", "line", ".", "replace", "(", "'Nine '", ",", "'9 '", ")", ".", "replace", "(", "' nine '", ",", "' 9 '", ")", "\n", "\n", "# ----------------------------------------------", "\n", "if", "'a few'", "in", "line_lower", ":", "\n", "        ", "line", "=", "pat", "[", "'a_few'", "]", ".", "sub", "(", "'several'", ",", "line", ")", "\n", "# no need to write to log, just use 'several'", "\n", "\n", "# ----------------------------------------------", "\n", "# fix quantifiers", "\n", "\n", "", "line", "=", "PAT_more_than_n", ".", "sub", "(", "\"more-than-\\\\1\"", ",", "line", ")", "\n", "line", "=", "PAT_less_than_n", ".", "sub", "(", "\"less-than-\\\\1\"", ",", "line", ")", "\n", "line", "=", "PAT_at_least_n", ".", "sub", "(", "\"at-least-\\\\1\"", ",", "line", ")", "\n", "line", "=", "PAT_at_most_n", ".", "sub", "(", "\"at-most-\\\\1\"", ",", "line", ")", "\n", "line", "=", "PAT_exactly_n", ".", "sub", "(", "\"exactly-\\\\1\"", ",", "line", ")", "\n", "line", "=", "PAT_some_but_not_all", ".", "sub", "(", "\"some-but-not-all\"", ",", "line", ")", "\n", "\n", "quant_cnt", "=", "0", "\n", "new_line", "=", "[", "]", "\n", "len_sent", "=", "len", "(", "line", ".", "split", "(", ")", ")", "\n", "for", "idx", ",", "word", "in", "enumerate", "(", "line", ".", "split", "(", ")", ")", ":", "\n", "        ", "if", "word", ".", "lower", "(", ")", "in", "QUANTIFIERS", ":", "\n", "            ", "quant_cnt", "+=", "1", "\n", "new_line", ".", "append", "(", "word", ")", "\n", "# more than n, at least n -> some", "\n", "", "elif", "word", ".", "lower", "(", ")", ".", "startswith", "(", "\"more-than-\"", ")", "or", "word", ".", "lower", "(", ")", ".", "startswith", "(", "\"at-least-\"", ")", ":", "\n", "            ", "new_line", ".", "append", "(", "\"some\"", ")", "\n", "# write to log", "\n", "fh_log", ".", "write", "(", "s_pattern", ".", "format", "(", "str", "(", "sent_id", ")", ",", "word", ",", "\"some\"", ",", "str", "(", "idx", ")", ",", "len_sent", ")", ")", "\n", "# less than n, at most n -> no", "\n", "", "elif", "word", ".", "lower", "(", ")", ".", "startswith", "(", "\"less-than-\"", ")", "or", "word", ".", "lower", "(", ")", ".", "startswith", "(", "\"at-most-\"", ")", ":", "\n", "            ", "new_line", ".", "append", "(", "\"no\"", ")", "\n", "# write to log", "\n", "fh_log", ".", "write", "(", "s_pattern", ".", "format", "(", "str", "(", "sent_id", ")", ",", "word", ",", "\"no\"", ",", "str", "(", "idx", ")", ",", "len_sent", ")", ")", "\n", "# exactly n -> some", "\n", "", "elif", "word", ".", "lower", "(", ")", ".", "startswith", "(", "\"exactly-\"", ")", ":", "\n", "            ", "new_line", ".", "append", "(", "\"some\"", ")", "\n", "fh_log", ".", "write", "(", "s_pattern", ".", "format", "(", "str", "(", "sent_id", ")", ",", "word", ",", "\"some\"", ",", "str", "(", "idx", ")", ",", "len_sent", ")", ")", "\n", "# many -> most", "\n", "# elif word.lower().startswith(\"many\"):", "\n", "#     new_line.append(\"every\")", "\n", "#     fh_log.write(s_pattern.format(str(sent_id), word, \"every\", str(idx), len_sent))", "\n", "", "else", ":", "\n", "            ", "new_line", ".", "append", "(", "word", ")", "\n", "\n", "", "", "line", "=", "\" \"", ".", "join", "(", "new_line", ")", "\n", "\n", "# make sure first letter is capital", "\n", "line", "=", "line", "[", "0", "]", ".", "upper", "(", ")", "+", "line", "[", "1", ":", "]", "\n", "\n", "return", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.preprocess.subst": [[232, 258], ["pat[].sub.split", "len", "enumerate", "pat[].search", "getMono.eprint", "pat[].sub", "fh_log.write", "pat[].search.group", "s_pattern.format", "str", "str", "len", "word.lower", "line_list[].lower"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "subst", "(", "line", ",", "quantifier", ",", "fh_log", ",", "s_pattern", ",", "sent_id", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\" substitute: word = most/least \"\"\"", "\n", "# find the index of `at' in line.split()", "\n", "idx_at", "=", "-", "1", "\n", "line_list", "=", "line", ".", "split", "(", ")", "\n", "num_tokens", "=", "len", "(", "line_list", ")", "\n", "for", "idx", ",", "word", "in", "enumerate", "(", "line_list", ")", ":", "\n", "        ", "if", "idx", "==", "num_tokens", "-", "2", ":", "break", "\n", "if", "word", ".", "lower", "(", ")", "==", "'at'", "and", "line_list", "[", "idx", "+", "1", "]", ".", "lower", "(", ")", "==", "quantifier", ":", "# 'most':", "\n", "            ", "idx_at", "=", "idx", "\n", "break", "\n", "\n", "# replace `at most 10' with `no'", "\n", "", "", "m", "=", "pat", "[", "quantifier", "]", ".", "search", "(", "line", ")", "\n", "if", "m", ":", "original", "=", "m", ".", "group", "(", "0", ")", "\n", "else", ":", "return", "line", "\n", "eprint", "(", "'original:'", ",", "original", ")", "\n", "if", "quantifier", "==", "'most'", ":", "after", "=", "\"no\"", "\n", "elif", "quantifier", "==", "'least'", ":", "after", "=", "\"some\"", "\n", "line", "=", "pat", "[", "quantifier", "]", ".", "sub", "(", "after", ",", "line", ")", "\n", "\n", "# log", "\n", "fh_log", ".", "write", "(", "s_pattern", ".", "format", "(", "str", "(", "sent_id", ")", ",", "original", ",", "after", ",", "str", "(", "idx_at", ")", ",", "len", "(", "line_list", ")", ")", ")", "\n", "\n", "return", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.preprocess.fix_a_lot_of": [[259, 264], ["fh_log.write", "line.replace().replace", "s_pattern.format", "str", "len", "line.replace", "line.split"], "function", ["None"], ["", "def", "fix_a_lot_of", "(", "line", ",", "fh_log", ",", "s_pattern", ",", "sent_id", ")", ":", "\n", "    ", "\"\"\" change 'a lot of' to 'much' \"\"\"", "\n", "# log", "\n", "fh_log", ".", "write", "(", "s_pattern", ".", "format", "(", "str", "(", "sent_id", ")", ",", "\"a-lot-of\"", ",", "\"much\"", ",", "\"-1\"", ",", "len", "(", "line", ".", "split", "(", ")", ")", ")", ")", "\n", "return", "line", ".", "replace", "(", "'a lot of'", ",", "'much'", ")", ".", "replace", "(", "'A lot of'", ",", "'Much'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.__init__": [[271, 279], ["getMono.CCGtrees.readLog"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readLog"], ["    ", "def", "__init__", "(", "self", ",", "fn_log", ")", ":", "\n", "        ", "self", ".", "trees", "=", "{", "}", "\n", "self", ".", "numTrees", "=", "0", "\n", "self", ".", "CandC_xml", "=", "{", "}", "# { tree_idx : candc_xml   }", "\n", "self", ".", "easyccg_str", "=", "{", "}", "# { tree_idx : easyccg_str }", "\n", "self", ".", "changes", "=", "{", "}", "# { tree_idx : {'before':at most 5, 'after':no, 'idx':0}  }", "\n", "self", ".", "readLog", "(", "fn_log", ")", "# \"test.tok.preprocess.log\"", "\n", "self", ".", "tree_idxs", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readLog": [[280, 296], ["getMono.eprint", "getMono.eprint", "open", "line.startswith", "line.split", "int", "int", "int", "getMono.CCGtrees.changes[].append"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "readLog", "(", "self", ",", "log_fn", ")", ":", "\n", "        ", "\"\"\" read log for pre processing \"\"\"", "\n", "# log_fn: test.tok.preprocess.log", "\n", "eprint", "(", "\"\\nreading log file: {}\"", ".", "format", "(", "log_fn", ")", ")", "\n", "with", "open", "(", "log_fn", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "if", "line", ".", "startswith", "(", "'sentId'", ")", ":", "continue", "\n", "line_l", "=", "line", ".", "split", "(", "','", ")", "\n", "sentId", ",", "before", ",", "after", ",", "idx", ",", "len_sent", "=", "int", "(", "line_l", "[", "0", "]", ")", ",", "line_l", "[", "1", "]", ",", "line_l", "[", "2", "]", ",", "int", "(", "line_l", "[", "3", "]", ")", ",", "int", "(", "line_l", "[", "4", "]", ")", "\n", "# may have multiple changes per sentence", "\n", "if", "sentId", "in", "self", ".", "changes", ":", "\n", "                    ", "self", ".", "changes", "[", "sentId", "]", ".", "append", "(", "{", "'before'", ":", "before", ",", "'after'", ":", "after", ",", "'idx'", ":", "idx", ",", "'len_sent'", ":", "len_sent", "}", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "changes", "[", "sentId", "]", "=", "[", "{", "'before'", ":", "before", ",", "'after'", ":", "after", ",", "'idx'", ":", "idx", ",", "'len_sent'", ":", "len_sent", "}", "]", "\n", "", "", "", "eprint", "(", "\"reading log file done!\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.idx2change": [[297, 300], ["getMono.CCGtrees.changes.get"], "methods", ["None"], ["", "def", "idx2change", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\" return the changes made to one tree \"\"\"", "\n", "return", "self", ".", "changes", ".", "get", "(", "idx", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readCandCxml": [[301, 324], ["getMono.eprint", "bs4.BeautifulSoup", "bs4.BeautifulSoup.find_all", "getMono.eprint", "open().read", "getMono.CCGtrees.tree_idxs.append", "open", "len", "getMono.ErrorCCGtrees", "ccgXml.find_all"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "readCandCxml", "(", "self", ",", "xml_fn", ",", "treeIdxs", "=", "None", ")", ":", "# treeIdx starts at 0", "\n", "        ", "eprint", "(", "'reading trees from candc output'", ")", "\n", "soup", "=", "BeautifulSoup", "(", "open", "(", "xml_fn", ")", ".", "read", "(", ")", ",", "'lxml'", ")", "\n", "counterSent", "=", "-", "1", "\n", "for", "ccgXml", "in", "soup", ".", "find_all", "(", "'ccg'", ")", ":", "\n", "            ", "counterSent", "+=", "1", "\n", "if", "treeIdxs", ":", "\n", "                ", "if", "counterSent", "not", "in", "treeIdxs", ":", "continue", "\n", "# make sure there is only one root:", "\n", "", "try", ":", "assert", "len", "(", "ccgXml", ".", "find_all", "(", "'rule'", ",", "recursive", "=", "False", ")", ")", "==", "1", "\n", "except", "AssertionError", ":", "raise", "ErrorCCGtrees", "(", "'more than 1 root'", ")", "\n", "\n", "#### build the tree  ####", "\n", "# eprint('reading tree {}...'.format(counterSent))", "\n", "self", ".", "CandC_xml", "[", "counterSent", "]", "=", "ccgXml", "\n", "self", ".", "tree_idxs", ".", "append", "(", "counterSent", ")", "\n", "# if counterSent in self.changes:", "\n", "#     tree = CCGtree(ccgXml=ccgXml, changes=self.changes[counterSent])", "\n", "# else:", "\n", "#     tree = CCGtree(ccgXml=ccgXml, changes=None)", "\n", "# self.trees[counterSent] = tree", "\n", "\n", "", "eprint", "(", "'\\ntrees read in from candc output!\\n\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readEasyccgStr": [[325, 357], ["getMono.eprint", "open().readlines", "getMono.eprint", "tree_str.startswith", "getMono.CCGtrees.tree_idxs.append", "open", "getMono.eprint", "int", "tree_str.strip().split", "tree_str.strip"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "readEasyccgStr", "(", "self", ",", "easyccg_fn", ",", "treeIdxs", "=", "None", ")", ":", "# treeIdx starts at 0", "\n", "        ", "eprint", "(", "'reading trees from easyccg / depccg output ...'", ")", "\n", "easyccg_str", "=", "open", "(", "easyccg_fn", ")", ".", "readlines", "(", ")", "\n", "\n", "# for each tree", "\n", "counterSent", "=", "-", "1", "\n", "tree_id", "=", "1", "\n", "for", "tree_str", "in", "easyccg_str", ":", "\n", "            ", "if", "tree_str", ".", "startswith", "(", "'ID='", ")", ":", "\n", "# depccg: ID=3, log probability=-2.5454466342926025", "\n", "# easyccg: ID=3", "\n", "                ", "tree_id", "=", "int", "(", "tree_str", ".", "strip", "(", ")", ".", "split", "(", "','", ")", "[", "0", "]", "[", "3", ":", "]", ")", "-", "1", "# get ID", "\n", "continue", "\n", "# counterSent += 1", "\n", "", "if", "treeIdxs", ":", "\n", "# if counterSent not in treeIdxs: continue", "\n", "                ", "if", "tree_id", "not", "in", "treeIdxs", ":", "continue", "\n", "# if counterSent == 1: break", "\n", "#### build the tree  ####", "\n", "# eprint('reading tree {}...'.format(counterSent))", "\n", "", "if", "tree_str", "==", "\"\\n\"", ":", "# easyccg failed to parse this sentence", "\n", "                ", "eprint", "(", "\"- easyccg / depccg failed to parse sent {}\"", ".", "format", "(", "counterSent", ")", ")", "\n", "tree_str", "=", "\"failed_to_parse\"", "\n", "", "self", ".", "easyccg_str", "[", "tree_id", "]", "=", "tree_str", "\n", "self", ".", "tree_idxs", ".", "append", "(", "tree_id", ")", "\n", "# if counterSent in self.changes:", "\n", "#     tree = CCGtree(easyccg_tree_str=tree_str, changes=self.changes[counterSent])", "\n", "# else:", "\n", "#     tree = CCGtree(easyccg_tree_str=tree_str, changes=None)", "\n", "# self.trees[counterSent] = tree", "\n", "\n", "", "eprint", "(", "'\\ntrees read in from easyccg / depccg output!\\n\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.build_one_tree": [[358, 375], ["getMono.eprint", "getMono.CCGtree", "getMono.CCGtrees.easyccg_str.get", "getMono.CCGtree", "getMono.CCGtrees.idx2change", "getMono.CCGtrees.idx2change"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.idx2change", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.idx2change"], ["", "def", "build_one_tree", "(", "self", ",", "idx", ",", "parser", ",", "use_lemma", "=", "True", ")", ":", "\n", "# t = None", "\n", "        ", "eprint", "(", "'building tree {}...'", ".", "format", "(", "idx", ")", ")", "\n", "if", "parser", "in", "[", "'candc'", "]", ":", "\n", "            ", "t", "=", "CCGtree", "(", "ccgXml", "=", "self", ".", "CandC_xml", "[", "idx", "]", ",", "changes", "=", "self", ".", "idx2change", "(", "idx", ")", ")", "\n", "", "else", ":", "\n", "            ", "tree_str", "=", "self", ".", "easyccg_str", ".", "get", "(", "idx", ",", "None", ")", "\n", "if", "tree_str", "is", "None", ":", "\n", "                ", "self", ".", "trees", "[", "idx", "]", "=", "\"parse_exception\"", "\n", "return", "\"parse_exception\"", "\n", "", "elif", "tree_str", "==", "\"failed_to_parse\"", ":", "\n", "                ", "self", ".", "trees", "[", "idx", "]", "=", "\"failed_to_parse\"", "\n", "return", "tree_str", "\n", "", "t", "=", "CCGtree", "(", "easyccg_tree_str", "=", "tree_str", ",", "changes", "=", "self", ".", "idx2change", "(", "idx", ")", ")", "\n", "", "t", ".", "use_lemma", "=", "use_lemma", "\n", "self", ".", "trees", "[", "idx", "]", "=", "t", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.__init__": [[389, 433], ["kwargs.get", "kwargs.get", "getMono.CCGtree.build_CandC", "kwargs.get", "kwargs.get", "kwargs.get", "getMono.CCGtree.build_easyccg", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "getMono.CCGtree.buildFromRoot", "kwargs.get", "kwargs.get", "getMono.CCGtree.buildFromRoot"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.build_CandC", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.build_easyccg", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "leafNodes", "=", "[", "]", ";", "self", ".", "words", "=", "[", "]", ";", "self", ".", "nonTermNodes", "=", "[", "]", "\n", "self", ".", "root", "=", "None", "\n", "self", ".", "allNodes", "=", "[", "]", "# self.leafNodes + self.nonTermNodes", "\n", "\n", "# when making tree out of a NonTermNode/LeafNode", "\n", "# wholeStr = 'CHASED SOME CAT' / 'BIRD'", "\n", "self", ".", "wholeStr", "=", "''", "\n", "\n", "# all the inferences we can get by using one replacement in a list", "\n", "# self.inferences = []  # a list of *first_order* CCGtrees, should have no repetition", "\n", "\n", "self", ".", "numInfTotal", "=", "0", "# total num of inferences recursively", "\n", "\n", "self", ".", "inf_depth", "=", "0", "# depth of inference: how many replacements to get here", "\n", "\n", "self", ".", "neutral_depth", "=", "0", "# depth of neutral: how many replacements to get here", "\n", "\n", "# a list of tuples (y1, y2), storing the two types in a 'tr' rule that should", "\n", "# be the same, i.e. the two y's in:", "\n", "#        x", "\n", "#  ------------tr", "\n", "#   (x-->y1)-->y2", "\n", "self", ".", "trTypes", "=", "[", "]", "\n", "\n", "# build tree based on xml", "\n", "if", "kwargs", ".", "get", "(", "'ccgXml'", ")", "is", "not", "None", ":", "\n", "            ", "self", ".", "build_CandC", "(", "kwargs", ".", "get", "(", "'ccgXml'", ")", ",", "kwargs", ".", "get", "(", "'changes'", ")", ")", "\n", "", "elif", "kwargs", ".", "get", "(", "'easyccg_tree_str'", ")", "is", "not", "None", ":", "\n", "# build tree from easyccg output string", "\n", "            ", "self", ".", "build_easyccg", "(", "kwargs", ".", "get", "(", "'easyccg_tree_str'", ")", ",", "kwargs", ".", "get", "(", "'changes'", ")", ")", "\n", "", "elif", "kwargs", ".", "get", "(", "'NonTermNode'", ")", "is", "not", "None", ":", "\n", "# build tree from NonTermNode", "\n", "            ", "self", ".", "root", "=", "kwargs", ".", "get", "(", "'NonTermNode'", ")", "\n", "self", ".", "buildFromRoot", "(", ")", "\n", "", "elif", "kwargs", ".", "get", "(", "'TermNode'", ")", "is", "not", "None", ":", "\n", "# build tree from LeafNode", "\n", "            ", "self", ".", "root", "=", "kwargs", ".", "get", "(", "'TermNode'", ")", "\n", "self", ".", "buildFromRoot", "(", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "# raise ErrorCCGtree('wrong initialization of CCGtree!')", "\n", "\n", "", "self", ".", "use_lemma", "=", "kwargs", ".", "get", "(", "'use_lemma'", ")", "# whether use lemma in replacement_contra()", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot": [[434, 452], ["getMono.CCGtree.buildFromRootHelper", "getMono.NonTermNode", "getMono.CCGtree.getWholeStrAllNodes", "getMono.CCGtree.regetDepth", "getMono.CCGtree.words.append", "lfnode.word.upper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRootHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getWholeStrAllNodes", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.regetDepth"], ["", "def", "buildFromRoot", "(", "self", ")", ":", "\n", "        ", "self", ".", "leafNodes", "=", "[", "]", "\n", "self", ".", "nonTermNodes", "=", "[", "]", "\n", "self", ".", "words", "=", "[", "]", "\n", "self", ".", "buildFromRootHelper", "(", "self", ".", "root", ")", "# get the leafNodes", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "self", ".", "words", ".", "append", "(", "lfnode", ".", "word", ".", "upper", "(", ")", ")", "\n", "# fix dummy root", "\n", "", "dummyRoot", "=", "NonTermNode", "(", "depth", "=", "-", "1", ")", "\n", "self", ".", "root", ".", "sisters", "=", "[", "]", "\n", "self", ".", "root", ".", "parent", "=", "dummyRoot", "\n", "dummyRoot", ".", "children", "=", "[", "self", ".", "root", "]", "\n", "# fix wholeStr", "\n", "self", ".", "getWholeStrAllNodes", "(", ")", "\n", "self", ".", "wholeStr", "=", "self", ".", "root", ".", "wholeStr", "\n", "# allNodes", "\n", "self", ".", "allNodes", "=", "self", ".", "leafNodes", "+", "self", ".", "nonTermNodes", "\n", "self", ".", "regetDepth", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRootHelper": [[453, 468], ["len", "getMono.CCGtree.leafNodes.append", "getMono.CCGtree.nonTermNodes.append", "len", "getMono.CCGtree.buildFromRootHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRootHelper"], ["", "def", "buildFromRootHelper", "(", "self", ",", "node", ")", ":", "\n", "        ", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "\n", "            ", "self", ".", "leafNodes", ".", "append", "(", "node", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "nonTermNodes", ".", "append", "(", "node", ")", "\n", "# take care of sisters", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "1", ":", "\n", "                ", "node", ".", "children", "[", "0", "]", ".", "sisters", "=", "[", "]", "\n", "", "else", ":", "\n", "                ", "node", ".", "children", "[", "0", "]", ".", "sisters", "=", "[", "node", ".", "children", "[", "1", "]", "]", "\n", "node", ".", "children", "[", "1", "]", ".", "sisters", "=", "[", "node", ".", "children", "[", "0", "]", "]", "\n", "# recurse", "\n", "", "for", "child", "in", "node", ".", "children", ":", "\n", "                ", "child", ".", "parent", "=", "node", "\n", "self", ".", "buildFromRootHelper", "(", "child", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getWholeStrAllNodes": [[469, 471], ["getMono.CCGtree.getWholeStrAllNodesHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getWholeStrAllNodesHelper"], ["", "", "", "def", "getWholeStrAllNodes", "(", "self", ")", ":", "\n", "        ", "self", ".", "getWholeStrAllNodesHelper", "(", "self", ".", "root", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getWholeStrAllNodesHelper": [[472, 479], ["len", "node.word.upper", "getMono.CCGtree.getWholeStrAllNodesHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getWholeStrAllNodesHelper"], ["", "def", "getWholeStrAllNodesHelper", "(", "self", ",", "node", ")", ":", "\n", "        ", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "\n", "            ", "node", ".", "wholeStr", "=", "node", ".", "word", ".", "upper", "(", ")", "\n", "", "else", ":", "\n", "            ", "for", "child", "in", "node", ".", "children", ":", "\n", "                ", "self", ".", "getWholeStrAllNodesHelper", "(", "child", ")", "\n", "", "node", ".", "wholeStr", "=", "' '", ".", "join", "(", "[", "x", ".", "wholeStr", "for", "x", "in", "node", ".", "children", "]", ")", ".", "rstrip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.tree_str": [[480, 497], ["s.replace().replace().replace.replace().replace().replace.replace().replace().replace", "s.replace().replace().replace.replace().replace().replace.replace().replace", "s.replace().replace().replace.replace().replace().replace.replace"], "methods", ["None"], ["", "", "def", "tree_str", "(", "self", ",", "lemma", "=", "True", ",", "arrow", "=", "True", ")", ":", "\n", "        ", "\"\"\" return the sentence as string \"\"\"", "\n", "s", "=", "''", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "if", "not", "arrow", ":", "\n", "                ", "if", "lemma", ":", "s", "+=", "'{} '", ".", "format", "(", "lfnode", ".", "word", ")", "\n", "else", ":", "s", "+=", "'{} '", ".", "format", "(", "lfnode", ".", "word_raw", ")", "\n", "", "else", ":", "\n", "                ", "if", "lfnode", ".", "cat", ".", "monotonicity", "is", "not", "None", ":", "\n", "                    ", "if", "lemma", ":", "s", "+=", "'{}{} '", ".", "format", "(", "lfnode", ".", "word", ",", "lfnode", ".", "cat", ".", "monotonicity", ")", "\n", "else", ":", "s", "+=", "'{}{} '", ".", "format", "(", "lfnode", ".", "word_raw", ",", "lfnode", ".", "cat", ".", "monotonicity", ")", "\n", "", "else", ":", "\n", "                    ", "if", "lemma", ":", "s", "+=", "'{}{} '", ".", "format", "(", "lfnode", ".", "word", ",", "'='", ")", "\n", "else", ":", "s", "+=", "'{}{} '", ".", "format", "(", "lfnode", ".", "word_raw", ",", "'='", ")", "\n", "", "", "", "if", "arrow", ":", "\n", "            ", "s", "=", "s", ".", "replace", "(", "'DOWN'", ",", "'\\u2193'", ")", ".", "replace", "(", "'UP'", ",", "'\\u2191'", ")", ".", "replace", "(", "'UNK'", ",", "'='", ")", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent": [[498, 509], ["s.replace().replace().replace.replace().replace().replace.replace().replace().replace", "print", "s.replace().replace().replace.replace().replace().replace.replace().replace", "s.replace().replace().replace.replace().replace().replace.replace"], "methods", ["None"], ["", "def", "printSent", "(", "self", ",", "stream", "=", "sys", ".", "stdout", ")", ":", "\n", "        ", "\"\"\" print sent lemma by lemma \"\"\"", "\n", "s", "=", "''", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "# s+='{}{}{} '.format(lfnode.word, lfnode.cat.monotonicity, self.printImpSign(lfnode.impSign))", "\n", "            ", "if", "lfnode", ".", "cat", ".", "monotonicity", "is", "not", "None", ":", "\n", "                ", "s", "+=", "'{}{} '", ".", "format", "(", "lfnode", ".", "word", ",", "lfnode", ".", "cat", ".", "monotonicity", ")", "\n", "", "else", ":", "s", "+=", "'{}{} '", ".", "format", "(", "lfnode", ".", "word", ",", "'='", ")", "\n", "", "s", "=", "s", ".", "replace", "(", "'DOWN'", ",", "'\\u2193'", ")", ".", "replace", "(", "'UP'", ",", "'\\u2191'", ")", ".", "replace", "(", "'UNK'", ",", "'='", ")", "\n", "print", "(", "s", ",", "file", "=", "stream", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent_no_pol": [[510, 517], ["None"], "methods", ["None"], ["", "def", "printSent_no_pol", "(", "self", ",", "stream", "=", "sys", ".", "stdout", ")", ":", "\n", "        ", "\"\"\" print sent lemma by lemma, no polarization \"\"\"", "\n", "s", "=", "''", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "s", "+=", "'{} '", ".", "format", "(", "lfnode", ".", "word", ")", "\n", "# eprint(s, stream)", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent_raw": [[518, 529], ["s.replace().replace().replace.replace().replace().replace.replace().replace().replace", "print", "s.replace().replace().replace.replace().replace().replace.replace().replace", "s.replace().replace().replace.replace().replace().replace.replace"], "methods", ["None"], ["", "def", "printSent_raw", "(", "self", ",", "stream", "=", "sys", ".", "stdout", ")", ":", "\n", "        ", "\"\"\" print sent word by word, not lemma by lemma \"\"\"", "\n", "s", "=", "''", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "if", "lfnode", ".", "cat", ".", "monotonicity", "is", "None", ":", "mono", "=", "'\\u2193'", "\n", "else", ":", "mono", "=", "lfnode", ".", "cat", ".", "monotonicity", "\n", "s", "+=", "'{}{} '", ".", "format", "(", "lfnode", ".", "word_raw", ",", "mono", ")", "\n", "", "s", "=", "s", ".", "replace", "(", "'DOWN'", ",", "'\\u2193'", ")", ".", "replace", "(", "'UP'", ",", "'\\u2191'", ")", ".", "replace", "(", "'UNK'", ",", "'='", ")", "\n", "print", "(", "s", ",", "file", "=", "stream", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent_raw_no_pol": [[530, 537], ["print"], "methods", ["None"], ["", "def", "printSent_raw_no_pol", "(", "self", ",", "stream", "=", "sys", ".", "stdout", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\" print sent word by word, not lemma by lemma, w/o polarity \"\"\"", "\n", "s", "=", "''", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "s", "+=", "'{} '", ".", "format", "(", "lfnode", ".", "word_raw", ")", "\n", "", "if", "verbose", ":", "print", "(", "s", ",", "file", "=", "stream", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printImpSign": [[538, 541], ["None"], "methods", ["None"], ["", "def", "printImpSign", "(", "self", ",", "impSign", ")", ":", "\n", "        ", "if", "impSign", "is", "None", ":", "return", "\"\\u2022\"", "# bullet", "\n", "return", "impSign", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSentLatex": [[542, 549], ["print", "print"], "methods", ["None"], ["", "def", "printSentLatex", "(", "self", ")", ":", "\n", "# \\mbox{\\emph{No${}^{\\upred}$ man${}^{\\downred}$ walks${}^{\\downred}$}}\\\\", "\n", "        ", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "print", "(", "'{}${{}}^{{\\{}}}$'", ".", "format", "(", "lfnode", ".", "word", ",", "lfnode", ".", "cat", ".", "monotonicity", ")", ".", "replace", "(", "'DOWN'", ",", "'downred'", ")", ".", "replace", "(", "'UP'", ",", "'upred'", ")", ".", "replace", "(", "'UNK'", ",", "'nonered'", ")", ",", "end", "=", "' '", ")", "\n", "", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.__str__": [[550, 553], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "' '", ".", "join", "(", "[", "'{} *{}*'", ".", "format", "(", "lfnode", ".", "word", ",", "lfnode", ".", "cat", ".", "monotonicity", ")", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.__repr__": [[554, 556], ["getMono.CCGtree.__str__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTree": [[557, 560], ["print", "getMono.CCGtree.printTreeHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTreeHelper"], ["", "def", "printTree", "(", "self", ",", "stream", "=", "sys", ".", "stdout", ")", ":", "\n", "        ", "print", "(", "'\\n--- tree:\\n'", ",", "file", "=", "stream", ")", "\n", "self", ".", "printTreeHelper", "(", "self", ".", "root", ",", "stream", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTreeHelper": [[561, 568], ["len", "print", "print", "getMono.CCGtree.printTreeHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTreeHelper"], ["", "def", "printTreeHelper", "(", "self", ",", "node", ",", "stream", "=", "sys", ".", "stdout", ")", ":", "\n", "        ", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "# leaf", "\n", "            ", "print", "(", "\"{}{}\\n\"", ".", "format", "(", "node", ".", "depth", "*", "'   '", ",", "node", ")", ",", "file", "=", "stream", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"{}{}\\n\"", ".", "format", "(", "node", ".", "depth", "*", "'   '", ",", "node", ")", ",", "file", "=", "stream", ")", "\n", "for", "child", "in", "node", ".", "children", ":", "\n", "                ", "self", ".", "printTreeHelper", "(", "child", ",", "stream", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.replacement": [[588, 689], ["range", "len", "node.parent.children.index", "k.frags.keys", "inferences.extend", "contras.extend", "nodes2repwith.append", "len", "getMono.CCGtree.replacement_helper", "getMono.CCGtree.replacement_helper", "nodes2repwith.append", "nodes2repwith_con.append", "nodes2repwith.append", "nodes2repwith_con.append"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.replacement_helper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.replacement_helper"], ["", "", "", "def", "replacement", "(", "self", ",", "k", ",", "gen_inf", ")", ":", "\n", "        ", "'''  replacement for inference; k is knowledge\n        gen_inf is a bool\n        '''", "\n", "# nodes2repwith is a list. there might be multiple things to replace in each run.", "\n", "# e.g. beagle < [dog, animal]", "\n", "inferences", "=", "[", "]", "\n", "nodes2repwith", "=", "[", "]", "# nodes to replace with", "\n", "# neutrals = []", "\n", "# nodes2repwith_neu = []   # neutral", "\n", "contras", "=", "[", "]", "\n", "nodes2repwith_con", "=", "[", "]", "# contradiction", "\n", "\n", "for", "ind", "in", "range", "(", "len", "(", "self", ".", "allNodes", ")", ")", ":", "\n", "            ", "node", "=", "self", ".", "allNodes", "[", "ind", "]", "\n", "node_type", "=", "node", ".", "cat", ".", "typeWOfeats", "\n", "# print('***'+node.wholeStr+'***', end='   ')", "\n", "# print('***'+node.cat.monotonicity+'***')", "\n", "if", "node", ".", "wholeStr", "in", "k", ".", "frags", ".", "keys", "(", ")", "and", "node_type", "==", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", ":", "\n", "\n", "# replacement for once only!!", "\n", "# get index of node in node.parent.children", "\n", "                ", "i", "=", "node", ".", "parent", ".", "children", ".", "index", "(", "node", ")", "\n", "\n", "# --------------  inferences  ---------------- #", "\n", "# TODO check if POS/cat is the same??", "\n", "# check the monotonicity to see whether can replace", "\n", "# make sure cat is the same: e.g. NP = NP", "\n", "\n", "# EQUAL, e.g. all = each = every; men = man", "\n", "# !! only add those that have same cat !!", "\n", "for", "equal", "in", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "equal", ":", "# equal is Fragment", "\n", "                    ", "if", "equal", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", "==", "node_type", ":", "\n", "                        ", "nodes2repwith", ".", "append", "(", "equal", ")", "\n", "\n", "# UP", "\n", "", "", "if", "node", ".", "cat", ".", "monotonicity", "==", "'UP'", ":", "\n", "# replace node with the first thing bigger than it", "\n", "# print('\\nfound a node to replace:', node.wholeStr)", "\n", "# print('replace it with        :', k.frags[node.wholeStr].big[0].ccgtree.root.wholeStr)", "\n", "# print('cat must be the same:')", "\n", "# print(node.cat.typeWOfeats)", "\n", "# print(k.frags[node.wholeStr].ccgtree.root.cat.typeWOfeats)", "\n", "\n", "# !! only add those that have same cat !!", "\n", "                    ", "for", "big", "in", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "big", ":", "# big is Fragment", "\n", "                        ", "if", "big", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", "==", "node_type", ":", "\n", "                            ", "nodes2repwith", ".", "append", "(", "big", ")", "\n", "\n", "# DOWN", "\n", "", "", "", "elif", "node", ".", "cat", ".", "monotonicity", "==", "'DOWN'", ":", "\n", "# print('cat must be the same:')", "\n", "# print(node.cat.typeWOfeats)", "\n", "# print(k.frags[node.wholeStr].ccgtree.root.cat.typeWOfeats)", "\n", "\n", "# !! only add those that have same cat !!", "\n", "                    ", "for", "small", "in", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "small", ":", "# big is Fragment", "\n", "                        ", "if", "small", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", "==", "node_type", ":", "\n", "                            ", "nodes2repwith", ".", "append", "(", "small", ")", "\n", "\n", "# --------------  contras  ---------------- #", "\n", "", "", "", "if", "node", ".", "cat", ".", "monotonicity", "==", "\"UP\"", ":", "# only do this in UP!", "\n", "                    ", "for", "ant", "in", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "ant", ":", "# todo: replace w/ ant results in contra?", "\n", "                        ", "if", "ant", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", "==", "node_type", ":", "\n", "                            ", "nodes2repwith_con", ".", "append", "(", "ant", ")", "\n", "\n", "# --------------  contras  ---------------- #", "\n", "# alternations todo: not implemented??", "\n", "", "", "", "if", "node", ".", "cat", ".", "monotonicity", "==", "'UP'", ":", "\n", "# TODO", "\n", "                    ", "if", "len", "(", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "alter", ")", "!=", "0", ":", "\n", "# replace with alternations", "\n", "                        ", "for", "alter", "in", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "alter", ":", "# alter is Fragment", "\n", "                            ", "if", "alter", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", "==", "node_type", ":", "\n", "                                ", "nodes2repwith_con", ".", "append", "(", "alter", ")", "\n", "\n", "# if there are nodes to replace", "\n", "", "", "", "", "if", "nodes2repwith", ":", "\n", "                    ", "inferences", ".", "extend", "(", "self", ".", "replacement_helper", "(", "node", ",", "nodes2repwith", ",", "ind", ",", "i", ",", "at_least", "=", "False", ")", ")", "\n", "\n", "", "if", "nodes2repwith_con", ":", "\n", "                    ", "contras", ".", "extend", "(", "self", ".", "replacement_helper", "(", "node", ",", "nodes2repwith_con", ",", "ind", ",", "i", ",", "at_least", "=", "False", ")", ")", "\n", "\n", "", "nodes2repwith", "=", "[", "]", "\n", "# nodes2repwith_neu = []", "\n", "nodes2repwith_con", "=", "[", "]", "\n", "\n", "# at-least N < some = a = an, N = 3, 5, several", "\n", "# todo: ** when generating challenge dataset, we don't need this **", "\n", "# elif node.wholeStr.startswith(\"AT-LEAST\") and \\", "\n", "#         len(node.wholeStr.split(' ')) == 2:", "\n", "#     # [some, a, an]", "\n", "#     nodes2repwith = [n for n in k.frags[\"AT-LEAST-N\"].big]", "\n", "#     i = node.parent.children.index(node)  # index of 'at-least-N' in parent", "\n", "#     eprint(\"replacing at least N\")", "\n", "#     # do replacement, SAME AS ABOVE", "\n", "#     inferences.extend(self.replacement_helper(node, nodes2repwith, ind, i, at_least=True))", "\n", "#     nodes2repwith = []", "\n", "\n", "", "", "return", "inferences", ",", "contras", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.replacement_neutral": [[690, 736], ["range", "len", "node.parent.children.index", "k.frags.keys", "neutrals.extend", "len", "getMono.CCGtree.replacement_helper", "nodes2repwith_neu.append", "len", "nodes2repwith_neu.append"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.replacement_helper"], ["", "def", "replacement_neutral", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\"\n        generate neutral sentences\n        - Intuition: Just do the opposite of inference generation!\n        Always replace ``against the scale'' and\n        replace on the newly generated *neutrals*, not the inferences!\n        - Explanation:\n          original premise: every[up] dog[down] danced[up]\n          neutral 1: every animal danced\n          Based on neutral 1, we further generate neutrals:\n          every living thing danced\n          every animal waltzed\n        \"\"\"", "\n", "# todo!!", "\n", "neutrals", "=", "[", "]", "\n", "nodes2repwith_neu", "=", "[", "]", "# neutral", "\n", "\n", "for", "ind", "in", "range", "(", "len", "(", "self", ".", "allNodes", ")", ")", ":", "\n", "            ", "node", "=", "self", ".", "allNodes", "[", "ind", "]", "\n", "node_type", "=", "node", ".", "cat", ".", "typeWOfeats", "\n", "if", "node", ".", "wholeStr", "in", "k", ".", "frags", ".", "keys", "(", ")", "and", "node_type", "==", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", ":", "\n", "\n", "# replacement for once only!!", "\n", "# get index of node in node.parent.children", "\n", "                ", "i", "=", "node", ".", "parent", ".", "children", ".", "index", "(", "node", ")", "\n", "\n", "# --------------  neutrals  ---------------- #", "\n", "if", "(", "node", ".", "cat", ".", "monotonicity", "==", "'UP'", ")", "and", "(", "len", "(", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "small", ")", "!=", "0", ")", ":", "\n", "# replace with smaller sets", "\n", "                    ", "for", "small", "in", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "small", ":", "# small is Fragment", "\n", "                        ", "if", "small", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", "==", "node_type", ":", "\n", "                            ", "nodes2repwith_neu", ".", "append", "(", "small", ")", "\n", "\n", "", "", "", "elif", "(", "node", ".", "cat", ".", "monotonicity", "==", "'DOWN'", ")", "and", "(", "len", "(", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "big", ")", "!=", "0", ")", ":", "\n", "# replace with bigger sets", "\n", "                    ", "for", "big", "in", "k", ".", "frags", "[", "node", ".", "wholeStr", "]", ".", "big", ":", "# big is Fragment", "\n", "                        ", "if", "big", ".", "ccgtree", ".", "root", ".", "cat", ".", "typeWOfeats", "==", "node_type", ":", "\n", "                            ", "nodes2repwith_neu", ".", "append", "(", "big", ")", "\n", "\n", "", "", "", "if", "nodes2repwith_neu", ":", "\n", "                    ", "neutrals", ".", "extend", "(", "self", ".", "replacement_helper", "(", "node", ",", "nodes2repwith_neu", ",", "ind", ",", "i", ",", "at_least", "=", "False", ")", ")", "\n", "\n", "", "nodes2repwith_neu", "=", "[", "]", "\n", "\n", "", "", "return", "neutrals", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.replacement_helper": [[737, 785], ["copy.deepcopy", "copy.deepcopy", "copy.deepcopy.buildFromRoot", "copy.deepcopy.regetDepth", "copy.deepcopy.mark", "copy.deepcopy.polarize", "ans.append"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.regetDepth", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarize"], ["", "def", "replacement_helper", "(", "self", ",", "node", ",", "nodes2repwith", ",", "ind", ",", "i", ",", "at_least", ")", ":", "\n", "        ", "ans", "=", "[", "]", "# inferences or neutrals", "\n", "\n", "for", "newNode", "in", "nodes2repwith", ":", "# newNode is a Fragment", "\n", "            ", "newNode", "=", "newNode", ".", "ccgtree", ".", "root", "\n", "# if node.wholeStr == 'LARGE':", "\n", "#     print(newNode)", "\n", "# -----------------------------", "\n", "# SET POS and CAT for newNode", "\n", "# !! newNode.pos, newNode.cat came from building the knowledge", "\n", "# could be incomplete", "\n", "if", "not", "at_least", ":", "# only check the following criteria if not \"at least\"", "\n", "                ", "try", ":", "\n", "                    ", "if", "newNode", ".", "pos", "is", "None", ":", "# replace", "\n", "                        ", "newNode", ".", "pos", ",", "newNode", ".", "cat", "=", "node", ".", "pos", ",", "node", ".", "cat", "\n", "", "elif", "newNode", ".", "cat", ".", "typeWOfeats", "==", "node", ".", "cat", ".", "typeWOfeats", ":", "# replace", "\n", "                        ", "if", "newNode", ".", "pos", "==", "node", ".", "pos", ":", "pass", "\n", "else", ":", "newNode", ".", "pos", "=", "node", ".", "pos", "\n", "", "elif", "newNode", ".", "pos", "[", "0", "]", "==", "node", ".", "pos", "[", "0", "]", ":", "# replace", "\n", "                        ", "if", "newNode", ".", "cat", ".", "typeWOfeats", "==", "newNode", ".", "cat", ".", "typeWOfeats", ":", "\n", "                            ", "pass", "\n", "", "else", ":", "# e.g. both are N, but cat are different", "\n", "                            ", "newNode", ".", "pos", ",", "newNode", ".", "cat", "=", "node", ".", "pos", ",", "node", ".", "cat", "\n", "", "", "else", ":", "# in all other cases, don't replace, e.g.newNode = V, node = N", "\n", "                        ", "continue", "\n", "", "", "except", "AttributeError", ":", "# NonTermNode does not have pos", "\n", "# print(newNode.cat, node.cat)", "\n", "                    ", "pass", "\n", "\n", "# --------------------------", "\n", "# NOW build new tree and add to self.inferences", "\n", "# initialize new tree", "\n", "", "", "newTree", "=", "copy", ".", "deepcopy", "(", "self", ")", "\n", "oldNode", "=", "newTree", ".", "allNodes", "[", "ind", "]", "# important: locate the oldNode in newTree", "\n", "\n", "# replace oldNode w/ newNode", "\n", "newNode", "=", "copy", ".", "deepcopy", "(", "newNode", ")", "# newNode is from K, need to make a new instance", "\n", "oldNode", ".", "parent", ".", "children", "[", "i", "]", "=", "newNode", "\n", "newNode", ".", "parent", "=", "oldNode", ".", "parent", "\n", "\n", "# rebuild tree", "\n", "newTree", ".", "buildFromRoot", "(", ")", "\n", "newTree", ".", "regetDepth", "(", ")", "\n", "newTree", ".", "mark", "(", ")", "\n", "newTree", ".", "polarize", "(", ")", "\n", "\n", "ans", ".", "append", "(", "newTree", ")", "\n", "", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.replacement_contra": [[786, 917], ["getMono.CCGtree.wholeStr.startswith", "getMono.CCGtree.wholeStr.startswith", "contras.append", "getMono.CCGtree.wholeStr.startswith", "contras.append", "contras.append", "contras.append", "len", "get_str().replace().replace().replace", "get_str().replace().replace", "get_str().split", "contras.append", "len", "node.word_wholeStr", "len", "getMono.CCGtree.replacement_contra.get_str"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.word_wholeStr"], ["", "def", "replacement_contra", "(", "self", ")", ":", "\n", "        ", "\"\"\" return all contradictions based on rules, contras is a list \"\"\"", "\n", "# the reason not to replace every \"no\" with \"some\" is the relative clauses", "\n", "# Books that no one liked are all sold.", "\n", "# does not contradict: Books that some one liked are sold.", "\n", "contras", "=", "[", "]", "\n", "\n", "def", "get_str", "(", "node", ",", "use_lemma", ")", ":", "\n", "            ", "if", "use_lemma", ":", "\n", "                ", "return", "node", ".", "wholeStr", "\n", "", "else", ":", "# word", "\n", "                ", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "return", "node", ".", "word_raw", "# leaf", "\n", "else", ":", "return", "node", ".", "word_wholeStr", "(", ")", "# non term", "\n", "\n", "# if False, accuracy for contradiction will be 0!", "\n", "", "", "use_lemma", "=", "self", ".", "use_lemma", "# default is True; False when only generate infs and contras", "\n", "\n", "# TODO rule 1", "\n", "# first word: some --> no; no --> some", "\n", "if", "self", ".", "wholeStr", ".", "startswith", "(", "\"SOME\"", ")", ":", "\n", "            ", "contras", ".", "append", "(", "\"NO \"", "+", "' '", ".", "join", "(", "get_str", "(", "self", ".", "root", ",", "use_lemma", ")", ".", "split", "(", ")", "[", "1", ":", "]", ")", ")", "\n", "# contras.append(\"NO \" + ' '.join(self.wholeStr.split()[1:]))", "\n", "", "elif", "self", ".", "wholeStr", ".", "startswith", "(", "\"NO\"", ")", ":", "\n", "            ", "contras", ".", "append", "(", "\"SOME \"", "+", "' '", ".", "join", "(", "get_str", "(", "self", ".", "root", ",", "use_lemma", ")", ".", "split", "(", ")", "[", "1", ":", "]", ")", ")", "\n", "# contras.append(\"SOME \" + ' '.join(self.wholeStr.split()[1:]))", "\n", "\n", "# TODO rule 2", "\n", "# in object position: a/an/the/some --> no; no --> some", "\n", "# test sent: Each European has the right to live in Europe.", "\n", "# contra: Each European has no right to live in Europe.", "\n", "#                      the          right to live in Europe", "\n", "#                     NP/N                  N", "\n", "#         have      ---------------------------------------", "\n", "#       (S\\NP)/NP                    NP  =  myNP", "\n", "#      ----------------------------------", "\n", "# NP                S\\NP  =  VP", "\n", "# -----------------------", "\n", "#            S", "\n", "", "if", "len", "(", "self", ".", "root", ".", "children", ")", "==", "2", "and", "self", ".", "root", ".", "children", "[", "1", "]", ".", "cat", ".", "typeWOfeats", "==", "r\"S\\NP\"", ":", "\n", "            ", "VP", "=", "self", ".", "root", ".", "children", "[", "1", "]", "\n", "# make sure main verb is not \"BE\"", "\n", "if", "len", "(", "VP", ".", "children", ")", "==", "2", "and", "VP", ".", "children", "[", "0", "]", ".", "wholeStr", "!=", "\"BE\"", "and", "VP", ".", "children", "[", "1", "]", ".", "cat", ".", "typeWOfeats", "==", "\"NP\"", ":", "\n", "                ", "myNP", "=", "VP", ".", "children", "[", "1", "]", "\n", "# some --> no", "\n", "if", "len", "(", "myNP", ".", "children", ")", "==", "2", "and", "myNP", ".", "children", "[", "0", "]", ".", "wholeStr", "in", "{", "\"SOME\"", ",", "\"A\"", ",", "\"AN\"", ",", "\"THE\"", "}", ":", "\n", "# contra_str = VP.sisters[0].wholeStr", "\n", "# contra_str += \" \" + VP.children[0].wholeStr", "\n", "# contra_str += \" \" + \"NO \" + \" \".join(myNP.wholeStr.split()[1:])", "\n", "                    ", "contra_str", "=", "get_str", "(", "VP", ".", "sisters", "[", "0", "]", ",", "use_lemma", ")", "\n", "contra_str", "+=", "\" \"", "+", "get_str", "(", "VP", ".", "children", "[", "0", "]", ",", "use_lemma", ")", "\n", "contra_str", "+=", "\" \"", "+", "\"NO \"", "+", "\" \"", ".", "join", "(", "get_str", "(", "myNP", ",", "use_lemma", ")", ".", "split", "(", ")", "[", "1", ":", "]", ")", "\n", "contras", ".", "append", "(", "contra_str", ")", "\n", "# no --> some", "\n", "", "elif", "len", "(", "myNP", ".", "children", ")", "==", "2", "and", "myNP", ".", "children", "[", "0", "]", ".", "wholeStr", "==", "\"NO\"", ":", "# was: NEVER", "\n", "# contra_str = VP.sisters[0].wholeStr", "\n", "# contra_str += \" \" + VP.children[0].wholeStr", "\n", "# contra_str += \" \" + \"SOME \" + \" \".join(myNP.wholeStr.split()[1:])", "\n", "                    ", "contra_str", "=", "get_str", "(", "VP", ".", "sisters", "[", "0", "]", ",", "use_lemma", ")", "\n", "contra_str", "+=", "\" \"", "+", "get_str", "(", "VP", ".", "children", "[", "0", "]", ",", "use_lemma", ")", "\n", "contra_str", "+=", "\" \"", "+", "\"SOME \"", "+", "\" \"", ".", "join", "(", "get_str", "(", "myNP", ",", "use_lemma", ")", ".", "split", "(", ")", "[", "1", ":", "]", ")", "\n", "contras", ".", "append", "(", "contra_str", ")", "\n", "\n", "# TODO another way to implement rule 2", "\n", "# TODO use dependency parse, find the \"nmod\" of \"dobj\". then swap \"no\" with \"some\"", "\n", "\n", "# TODO rule 3", "\n", "# add \"do not\" before a verb", "\n", "# test sent: Each European has the right to live in Europe.", "\n", "# contra: Each European does not has right to live in Europe", "\n", "#                      the          right to live in Europe", "\n", "#                     NP/N                  N", "\n", "#         have      ---------------------------------------", "\n", "#       (S\\NP)/NP = myV           NP  =  myNP", "\n", "#      ----------------------------------", "\n", "# NP                S\\NP  =  VP", "\n", "# -----------------------", "\n", "#            S", "\n", "", "", "", "if", "\" NOT \"", "not", "in", "self", ".", "wholeStr", "and", "\" N'T \"", "not", "in", "self", ".", "wholeStr", ":", "\n", "            ", "if", "len", "(", "self", ".", "root", ".", "children", ")", "==", "2", "and", "self", ".", "root", ".", "children", "[", "1", "]", ".", "cat", ".", "typeWOfeats", "==", "r\"S\\NP\"", ":", "\n", "                ", "VP", "=", "self", ".", "root", ".", "children", "[", "1", "]", "\n", "# main verb is not \"BE\"", "\n", "if", "len", "(", "VP", ".", "children", ")", "==", "2", "and", "VP", ".", "children", "[", "0", "]", ".", "wholeStr", "!=", "\"BE\"", "and", "VP", ".", "children", "[", "0", "]", ".", "cat", ".", "typeWOfeats", "==", "r\"(S\\NP)/NP\"", ":", "\n", "# add \"do not\"", "\n", "# contra_str = VP.sisters[0].wholeStr + \" DO NOT \" + VP.wholeStr", "\n", "                    ", "contra_str", "=", "get_str", "(", "VP", ".", "sisters", "[", "0", "]", ",", "use_lemma", ")", "+", "\" DID NOT \"", "+", "get_str", "(", "VP", ",", "use_lemma", ")", "\n", "contras", ".", "append", "(", "contra_str", ")", "\n", "# main ver = BE", "\n", "", "elif", "len", "(", "VP", ".", "children", ")", "==", "2", "and", "VP", ".", "children", "[", "0", "]", ".", "wholeStr", "in", "{", "\"BE\"", ",", "\"ARE\"", ",", "\"IS\"", ",", "\"WAS\"", ",", "\"WERE\"", "}", ":", "\n", "# the person is slicing a garlic -> the person is not slicing ...", "\n", "# contra_str = VP.sisters[0].wholeStr + \" BE NOT \" + VP.children[1].wholeStr", "\n", "# contra_str = get_str(VP.sisters[0], use_lemma) + \" BE NOT \" + get_str(VP.children[1], use_lemma)", "\n", "                    ", "contra_str", "=", "\" \"", ".", "join", "(", "[", "get_str", "(", "VP", ".", "sisters", "[", "0", "]", ",", "use_lemma", ")", ",", "VP", ".", "children", "[", "0", "]", ".", "wholeStr", ",", "\"NOT\"", ",", "get_str", "(", "VP", ".", "children", "[", "1", "]", ",", "use_lemma", ")", "]", ")", "\n", "contras", ".", "append", "(", "contra_str", ")", "\n", "\n", "# sent: a man (is (recklessly climbing a rope))", "\n", "# contra: a man is climbing a rope", "\n", "# TODO: recklessly climb a rope < climb a rope", "\n", "\n", "\n", "# TODO rule 4: if not in sent, then remove not. what if two negations?", "\n", "", "", "", "if", "\" NOT \"", "in", "self", ".", "wholeStr", ":", "\n", "# contras.append(self.wholeStr.replace(\" NOT\", \"\"))", "\n", "            ", "contras", ".", "append", "(", "get_str", "(", "self", ".", "root", ",", "use_lemma", ")", ".", "replace", "(", "\" NOT\"", ",", "\"\"", ")", ".", "replace", "(", "\" not\"", ",", "\"\"", ")", ".", "replace", "(", "\"Not\"", ",", "\"\"", ")", ")", "\n", "", "if", "\" N'T \"", "in", "self", ".", "wholeStr", ":", "\n", "# contras.append(self.wholeStr.replace(\" N'T\", \"\"))", "\n", "            ", "contras", ".", "append", "(", "get_str", "(", "self", ".", "root", ",", "use_lemma", ")", ".", "replace", "(", "\" N'T\"", ",", "\"\"", ")", ".", "replace", "(", "\" n't\"", ",", "\"\"", ")", ")", "\n", "\n", "# TODO rule 5:", "\n", "# sent: There is no boy walking across a bridge", "\n", "# contra: A/the/an/some boy is walking across a bridge", "\n", "", "if", "self", ".", "wholeStr", ".", "startswith", "(", "\"THERE BE NO\"", ")", ":", "\n", "# find the subj: boy. Maybe use dep parse???", "\n", "# subj = self.wholeStr.split()[3]  # TODO this assumes subj has only one word!", "\n", "            ", "subj", "=", "get_str", "(", "self", ".", "root", ",", "use_lemma", ")", ".", "split", "(", ")", "[", "3", "]", "# TODO this assumes subj has only one word!", "\n", "for", "quant", "in", "[", "\"A\"", ",", "\"THE\"", ",", "\"AN\"", ",", "\"SOME\"", "]", ":", "\n", "                ", "contra_str", "=", "quant", "+", "\" \"", "+", "subj", "+", "\" BE \"", "+", "' '", ".", "join", "(", "get_str", "(", "self", ".", "root", ",", "use_lemma", ")", ".", "split", "(", ")", "[", "4", ":", "]", ")", "\n", "contras", ".", "append", "(", "contra_str", ")", "\n", "\n", "# TODO dependncy tree", "\n", "\n", "\n", "# TODO another way is to find contra from both directions: P->H, H->P", "\n", "# this should make implementation easier", "\n", "\n", "", "", "return", "contras", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.transform_RC2JJ": [[918, 994], ["enumerate", "lfnode.parent.wholeStr.lower", "len", "lfnode.parent.wholeStr.lower.split", "copy.deepcopy", "ADJ_node.wholeStr.lower", "getMono.LeafNode", "getMono.NonTermNode", "copy.deepcopy.buildFromRoot", "copy.deepcopy.regetDepth", "copy.deepcopy.mark", "copy.deepcopy.polarize", "new_trees.append", "hasattr", "getMono.eprint", "getMono.eprint", "getMono.eprint", "full_N_node.parent.children.index", "getMono.eprint", "lfnode.parent.wholeStr.lower.split", "getMono.Cat", "getMono.Cat"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.regetDepth", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarize", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "transform_RC2JJ", "(", "self", ")", ":", "\n", "        ", "\"\"\" relative clause to adjective\n        a dog which is black is running -> a black dog is running \"\"\"", "\n", "new_trees", "=", "[", "]", "\n", "\n", "# find RC", "\n", "for", "i", ",", "lfnode", "in", "enumerate", "(", "self", ".", "leafNodes", ")", ":", "\n", "            ", "if", "lfnode", ".", "wholeStr", "in", "RC_PRON", ":", "\n", "                ", "RC", "=", "lfnode", ".", "parent", ".", "wholeStr", ".", "lower", "(", ")", "\n", "len_RC", "=", "len", "(", "RC", ".", "split", "(", ")", ")", "\n", "if", "len_RC", "==", "3", "and", "RC", ".", "split", "(", ")", "[", "1", "]", "==", "\"be\"", ":", "# e.g. which is little", "\n", "                    ", "new_tree", "=", "copy", ".", "deepcopy", "(", "self", ")", "# need a new tree", "\n", "lfnode", "=", "new_tree", ".", "leafNodes", "[", "i", "]", "# lfnode has to be in the new_tree!", "\n", "\n", "# kangaroo that be little", "\n", "#                   that           be little", "\n", "#                                 ----------", "\n", "#               (N\\N)/(S\\NP)         (S\\NP)", "\n", "# kangaroo    ---------------------------------", "\n", "#    N = N_node            N\\N", "\n", "# ----------------------------", "\n", "#              N = full_N_node", "\n", "full_N_node", "=", "lfnode", ".", "parent", ".", "parent", "\n", "N_node", "=", "lfnode", ".", "parent", ".", "parent", ".", "children", "[", "0", "]", "\n", "ADJ_node", "=", "lfnode", ".", "sisters", "[", "0", "]", ".", "children", "[", "1", "]", "\n", "# print(\"ADJ:\", ADJ_node)", "\n", "if", "not", "hasattr", "(", "ADJ_node", ",", "'pos'", ")", ":", "\n", "                        ", "ADJ_node", "=", "ADJ_node", ".", "children", "[", "0", "]", "\n", "# print(ADJ_node)", "\n", "# ADJ_node can either be a JJ", "\n", "# or a nonTermNode: NP lex from another word", "\n", "\n", "# eprint(\"N  :\", N_node)", "\n", "# eprint(\"N f:\", full_N_node)", "\n", "# eprint()", "\n", "\n", "", "if", "full_N_node", ".", "cat", ".", "typeWOfeats", "!=", "\"N\"", ":", "\n", "                        ", "eprint", "(", "\"full_N_node not N\"", ")", "\n", "break", "# can't handle it", "\n", "", "if", "ADJ_node", ".", "cat", ".", "typeWOfeats", "not", "in", "{", "r\"S\\NP\"", ",", "r\"N\"", "}", ":", "\n", "                        ", "eprint", "(", "r\"ADJ_node not S\\NP or N\"", ")", "\n", "break", "# can't handle it", "\n", "", "if", "N_node", ".", "cat", ".", "typeWOfeats", "!=", "\"N\"", ":", "\n", "                        ", "eprint", "(", "\"N_node not N\"", ")", "\n", "break", "# can't handle it", "\n", "\n", "# --------------------------------", "\n", "# build a new full_N_node, and adjust pointers", "\n", "# ADJ can be of type: S\\NP, N", "\n", "# both needs to be converted to N/N", "\n", "", "ADJ_word", "=", "ADJ_node", ".", "wholeStr", ".", "lower", "(", ")", "\n", "ADJ_node_new", "=", "LeafNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "originalType", "=", "r\"N/N\"", ",", "word", "=", "ADJ_word", ")", ",", "\n", "chunk", "=", "None", ",", "entity", "=", "None", ",", "lemma", "=", "ADJ_word", ",", "pos", "=", "\"JJ\"", ",", "\n", "span", "=", "None", ",", "start", "=", "None", ",", "word", "=", "ADJ_word", ")", "\n", "full_N_node_new", "=", "NonTermNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "originalType", "=", "\"N\"", ")", ",", "ruleType", "=", "\"fa\"", ")", "\n", "N_node", ".", "parent", ",", "ADJ_node_new", ".", "parent", "=", "full_N_node_new", ",", "full_N_node_new", "\n", "full_N_node_new", ".", "children", "=", "[", "ADJ_node_new", ",", "N_node", "]", "\n", "\n", "if", "full_N_node", ".", "parent", ":", "# if full_N_node has a parent", "\n", "                        ", "idx_full_N_node_in_parent", "=", "full_N_node", ".", "parent", ".", "children", ".", "index", "(", "full_N_node", ")", "\n", "full_N_node", ".", "parent", ".", "children", "[", "idx_full_N_node_in_parent", "]", "=", "full_N_node_new", "\n", "full_N_node_new", ".", "parent", "=", "full_N_node", ".", "parent", "\n", "full_N_node", ".", "parent", "=", "None", "\n", "", "else", ":", "\n", "                        ", "eprint", "(", "\"full_N_node has no parent\"", ")", "\n", "break", "# can't handle it", "\n", "\n", "", "new_tree", ".", "buildFromRoot", "(", ")", "\n", "new_tree", ".", "regetDepth", "(", ")", "\n", "new_tree", ".", "mark", "(", ")", "\n", "new_tree", ".", "polarize", "(", ")", "\n", "\n", "# new_tree.printSent(stream=sys.stderr)", "\n", "new_trees", ".", "append", "(", "new_tree", ")", "\n", "\n", "", "", "", "return", "new_trees", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.transform_JJ2RC": [[995, 1002], ["None"], "methods", ["None"], ["", "def", "transform_JJ2RC", "(", "self", ")", ":", "\n", "        ", "\"\"\" 2622\n        A man is wearing a hard hat and dancing\n        A man is wearing a hat which is hard and is dancing \"\"\"", "\n", "new_trees", "=", "[", "]", "\n", "\n", "return", "new_trees", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getAllDescendants": [[1075, 1080], ["getMono.CCGtree.getAllDescendantsHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getAllDescendantsHelper"], ["", "def", "getAllDescendants", "(", "self", ",", "nonTermNode", ")", ":", "\n", "        ", "''' Returns a list of all descendants of a nonTermNode (including itself) '''", "\n", "des", "=", "[", "]", "\n", "self", ".", "getAllDescendantsHelper", "(", "nonTermNode", ",", "des", ")", "\n", "return", "des", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getAllDescendantsHelper": [[1081, 1086], ["des.append", "len", "getMono.CCGtree.getAllDescendantsHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getAllDescendantsHelper"], ["", "def", "getAllDescendantsHelper", "(", "self", ",", "node", ",", "des", ")", ":", "\n", "        ", "des", ".", "append", "(", "node", ")", "\n", "if", "len", "(", "node", ".", "children", ")", ">", "0", ":", "\n", "            ", "for", "child", "in", "node", ".", "children", ":", "\n", "                ", "self", ".", "getAllDescendantsHelper", "(", "child", ",", "des", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.assignEqualMarkingTR": [[1087, 1091], ["getMono.CCGtree.assignEqualMarkingTRHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.assignEqualMarkingTRHelper"], ["", "", "", "def", "assignEqualMarkingTR", "(", "self", ")", ":", "\n", "        ", "\"\"\" make sure 2y's in 'tr' have the same markings \"\"\"", "\n", "for", "y", "in", "self", ".", "trTypes", ":", "# for each pair of ys", "\n", "            ", "self", ".", "assignEqualMarkingTRHelper", "(", "y", "[", "0", "]", ",", "y", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.assignEqualMarkingTRHelper": [[1092, 1114], ["getMono.CCGtree.assignEqualMarkingTRHelper", "getMono.CCGtree.assignEqualMarkingTRHelper", "getMono.ErrorAssignEqualMarking", "getMono.ErrorAssignEqualMarking"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.assignEqualMarkingTRHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.assignEqualMarkingTRHelper"], ["", "", "def", "assignEqualMarkingTRHelper", "(", "self", ",", "semCat1", ",", "semCat2", ")", ":", "\n", "        ", "\"\"\" assign equal markings, used for post-processing 2 y's in 'tr' rule\n            x\n        ---------tr\n        (x-->y)-->y\n        e.g. semCat1: (((e,t),t),+t) semCat2: (((e,t),-t),t)\n        result: semCat1 = semCat2 = (((e,t),-t),+t)\n        \"\"\"", "\n", "try", ":", "assert", "semCat1", ".", "semCatStr", "==", "semCat2", ".", "semCatStr", "# semCatStr does not have +/-", "\n", "except", "AssertionError", ":", "raise", "ErrorAssignEqualMarking", "(", "\"semCatStr not the same {}; {}\"", ".", "format", "(", "semCat1", ",", "semCat2", ")", ")", "\n", "try", ":", "assert", "(", "semCat1", ".", "marking", "is", "None", ")", "or", "(", "semCat2", ".", "marking", "is", "None", ")", "or", "(", "semCat1", ".", "marking", "==", "semCat2", ".", "marking", ")", "\n", "except", "AssertionError", ":", "\n", "            ", "raise", "ErrorAssignEqualMarking", "(", "\"conflicting markings {}; {}\"", ".", "format", "(", "semCat1", ",", "semCat2", ")", ")", "\n", "# assign marking", "\n", "", "if", "semCat1", ".", "marking", "is", "None", ":", "semCat1", ".", "marking", "=", "semCat2", ".", "marking", "\n", "if", "semCat2", ".", "marking", "is", "None", ":", "semCat2", ".", "marking", "=", "semCat1", ".", "marking", "\n", "# recurse", "\n", "if", "semCat1", ".", "IN", ":", "self", ".", "assignEqualMarkingTRHelper", "(", "semCat1", ".", "IN", ",", "semCat2", ".", "IN", ")", "\n", "if", "semCat1", ".", "OUT", ":", "self", ".", "assignEqualMarkingTRHelper", "(", "semCat1", ".", "OUT", ",", "semCat2", ".", "OUT", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark": [[1115, 1131], ["getMono.CCGtree.mark_LeafNodes", "getMono.CCGtree.mark_NTN", "getMono.CCGtree.assignEqualMarkingTR", "getMono.CCGtree.equate_marking"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_LeafNodes", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.assignEqualMarkingTR", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.equate_marking"], ["", "def", "mark", "(", "self", ")", ":", "\n", "        ", "''' add plus minus to all nodes '''", "\n", "self", ".", "mark_LeafNodes", "(", ")", "\n", "self", ".", "mark_NTN", "(", ")", "\n", "\n", "# post-processing", "\n", "self", ".", "assignEqualMarkingTR", "(", ")", "\n", "\n", "# equate markings if needed", "\n", "# TODO more compliccated than I thought", "\n", "# TODO have to propogate much further up the tree", "\n", "for", "node", "in", "self", ".", "leafNodes", "+", "self", ".", "nonTermNodes", ":", "\n", "            ", "if", "node", ".", "cat", ":", "# if not None", "\n", "                ", "if", "node", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)/(S\\NP)'", ":", "\n", "# eprint('equate marking:', node)", "\n", "                    ", "self", ".", "equate_marking", "(", "node", ".", "cat", ".", "semCat", ".", "IN", ",", "node", ".", "cat", ".", "semCat", ".", "OUT", ")", "\n", "# eprint('after equate marking:', node)", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_LeafNodes": [[1133, 1444], ["token.word.upper", "token.word.upper", "token.cat.semCat.assignRecursive", "getMono.eprint", "token.word.upper", "token.word.upper", "token.word.upper", "token.word.upper", "token.word.upper", "token.pos.upper", "token.cat.semCat.assignRecursive", "token.word.upper", "token.word.upper", "token.word.upper", "token.pos.upper", "token.word.upper", "getMono.eprint", "token.pos.upper().startswith", "token.cat.semCat.assignRecursive", "token.pos.upper", "token.pos.upper", "token.word.upper", "token.word.upper", "token.word.upper", "token.word.upper", "token.word.upper", "token.word.upper", "token.pos.upper", "token.cat.semCat.assignRecursive", "token.pos.upper().startswith", "token.pos.upper", "token.lemma.upper", "token.pos.upper", "token.pos.upper", "token.cat.semCat.assignRecursive", "token.pos.upper().startswith", "token.pos.upper", "token.word.upper", "token.pos.upper", "token.word.upper", "token.cat.semCat.assignRecursive", "token.cat.semCat.assignRecursive", "token.pos.upper", "token.word.upper", "token.word.upper", "token.cat.semCat.assignRecursive", "token.word.upper", "token.pos.upper", "token.cat.semCat.assignRecursive", "token.pos.upper", "token.cat.semCat.assignRecursive", "token.cat.semCat.IN.assignRecursive", "token.cat.semCat.OUT.assignRecursive"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive"], ["", "", "", "", "def", "mark_LeafNodes", "(", "self", ")", ":", "\n", "        ", "''' mark leaf nodes '''", "\n", "for", "token", "in", "self", ".", "leafNodes", ":", "\n", "# -----------------------", "\n", "# quantifiers   TODO what if not of type NP/N", "\n", "# # TODO (SST): MANY actually here? HH: MANY with BOTH, MOST, THE ...", "\n", "            ", "if", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'SOME'", ",", "'A'", ",", "'AN'", ",", "'SEVERAL'", ",", "\n", "'ONE'", ",", "\n", "'SOME-BUT-NOT-ALL'", "}", ":", "# + +", "\n", "# if token.cat.semCat.semCatStr == '((e,t),((e,t),t))':", "\n", "                ", "try", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "if", "token", ".", "cat", ".", "typeWOfeats", "!=", "r\"NP/N\"", ":", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "", "", "except", "AttributeError", ":", "\n", "                    ", "eprint", "(", "'Attribute error'", ")", "\n", "", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'EVERY'", ",", "'ALL'", ",", "'EACH'", "}", ":", "# - +", "\n", "# if token.cat.semCat.semCatStr == '((e,t),((e,t),t))':", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'NO'", ",", "'FEW'", "}", ":", "# - -", "\n", "# if token.cat.semCat.semCatStr == '((e,t),((e,t),t))':", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'-'", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'BOTH'", ",", "'EITHER'", ",", "'MOST'", ",", "'THE'", ",", "'THOSE'", ",", "'THESE'", ",", "'MANY'", ",", "'THIS'", ",", "'THAT'", "}", ":", "\n", "# TODO: restore 'MANY' here??? HH: Yes!", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'NEITHER'", "}", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'-'", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'2'", ",", "'3'", ",", "'4'", ",", "'5'", ",", "'6'", ",", "'7'", ",", "'8'", ",", "'9'", ",", "'10'", "}", "and", "token", ".", "cat", ".", "typeWOfeats", "in", "{", "r'NP/N'", ",", "r'N/N'", "}", ":", "\n", "# = =                     NP/N = I have 3 apples, N/N = at most 3 apples", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "None", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "None", "\n", "\n", "# TODO other DTs: this, that?", "\n", "# TODO(SST): is this right?! It seems like it should be '-' and", "\n", "# '+', but when embedded under negative words, that gives the wrong", "\n", "# results", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'ANY'", "}", ":", "# this is the existential any", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "# universal any:", "\n", "# -, +", "\n", "\n", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", "==", "\"PRP$\"", ":", "# pos", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "pass", "\n", "\n", "# -----------------------", "\n", "# at-most, at-least", "\n", "", "elif", "token", ".", "note", "in", "{", "\"at-most\"", ",", "\"less-than\"", "}", ":", "\n", "# (NP/N)/(N/N)", "\n", "# ((et,et),+(et-,(et-,t)))", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'-'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "OUT", ".", "marking", "=", "'-'", "\n", "", "elif", "token", ".", "note", "in", "{", "\"at-least\"", ",", "\"more-than\"", "}", ":", "\n", "# (NP/N)/(N/N)", "\n", "# ((et,et),-(et+,(et+,t)))", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "OUT", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "note", "==", "\"exactly\"", ":", "\n", "# (NP/N)/(N/N)", "\n", "# ((et,et),(et,(et,t)))", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "None", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "None", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "OUT", ".", "marking", "=", "None", "\n", "\n", "# -----------------------", "\n", "# TODO negation", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'NOT'", ",", "\"N'T\"", "}", ":", "# N'T: (S\\NP)\\(S\\NP)", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "# check semCatStr??", "\n", "# TODO is this correct?", "\n", "if", "token", ".", "cat", ".", "typeWOfeats", "==", "r\"NP/NP\"", ":", "# not every person", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'-'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "!=", "r\"N/N\"", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "\n", "# token.cat.semCat.OUT.IN.marking = '+'  # (S+\\NP+)-\\(S+\\NP)", "\n", "# token.cat.semCat.IN.IN.marking = '+'  # (S+\\NP)-\\(S+\\NP+)", "\n", "\n", "# -----------------------", "\n", "# TODO nouns", "\n", "# nobody DT, NP", "\n", "", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "==", "\"NOBODY\"", ":", "\n", "                ", "if", "token", ".", "cat", ".", "typeWOfeats", "==", "\"NP\"", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "\"-\"", "\n", "# if the leafNode is NP, e.g. pronouns such as I, make it NP+", "\n", "", "", "elif", "token", ".", "cat", ".", "originalType", "==", "'NP'", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "# token.cat.semCat.OUT.marking = token.cat.semCat.IN.marking = '+'", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "==", "'IT'", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "\n", "# -----------------------", "\n", "# TODO noun can be: N/(S\\NP)", "\n", "# e.g. the `right` to live in Europe", "\n", "", "elif", "(", "token", ".", "pos", ".", "upper", "(", ")", "==", "'NN'", ")", "and", "(", "token", ".", "cat", ".", "typeWOfeats", "==", "r'N/(S\\NP)'", ")", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "IN", ".", "marking", "=", "'+'", "\n", "\n", "# TODO (SS-T): is this the right way of handling None?", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'NONE'", "}", ":", "\n", "                ", "eprint", "(", "'Labeling NONE'", ")", "\n", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "\"-\"", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'-'", "\n", "# TODO NNS, NN", "\n", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", ".", "startswith", "(", "\"NN\"", ")", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n", "# THERE BE", "\n", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", "==", "\"EX\"", ":", "\n", "                ", "if", "token", ".", "word", ".", "upper", "(", ")", "==", "\"THERE\"", ":", "\n", "                    ", "if", "token", ".", "cat", ".", "semCat", ".", "semCatStr", "==", "\"((e,t),t)\"", ":", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "\"+\"", "\n", "\n", "# -----------------------", "\n", "# if = (t,-(t,+t))", "\n", "", "", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "==", "'IF'", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "==", "'THEN'", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "\n", "# that, who", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "[", "'THAT'", ",", "'WHO'", ",", "'WHICH'", "]", "and", "(", "token", ".", "pos", "in", "[", "'WDT'", ",", "'IN'", ",", "'WP'", "]", ")", ":", "\n", "# !! already handled in Cat() !! modified #", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "# token.cat.semCat.OUT.assignRecursive(\"+\", EXCLUDE)", "\n", "\n", "# possessive 's", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "==", "\"'S\"", "and", "token", ".", "pos", "==", "\"POS\"", ":", "\n", "# (NP/+N)\\+NP", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "\n", "# except", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "==", "\"EXCEPT\"", ":", "\n", "# (N\\+N)/.NP, pos = IN: all students except engineers", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "None", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "\"+\"", "\n", "\n", "# cardinals", "\n", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", "==", "\"CD\"", ":", "# and token.cat.typeWOfeats == r'(S\\NP)\\(S\\NP)':", "\n", "# you can smoke *2* a day", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n", "# TODO verbs", "\n", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", ".", "startswith", "(", "'VB'", ")", ":", "\n", "# TODO add monotone DOWN verbs", "\n", "                ", "if", "token", ".", "lemma", ".", "upper", "(", ")", "in", "[", "'REFUSE'", ",", "'FAIL'", "]", "and", "token", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)/(S\\NP)'", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "# (S+\\NP)-/(S+\\NP)", "\n", "# token.cat.semCat.IN.IN.marking = '+'", "\n", "# token.cat.semCat.OUT.IN.marking = '+'  # (S+\\NP+)-/(S+\\NP+)", "\n", "\n", "", "else", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "if", "token", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)/NP'", ":", "# transitive verb", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "# make it (S+\\NP)+/NP", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'((S\\NP)/PP)/NP'", ":", "# 'put' with a PP argument", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "OUT", ".", "marking", "=", "'+'", "# make it ((S\\+NP)/+PP)+/NP", "\n", "# elif (token.word.upper() in ['DID', 'DO']) and \\", "\n", "#         (token.cat.typeWOfeats == r'(S\\NP)/(S\\NP)'):  # 'did' in 'did not'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)/(S\\NP)'", ":", "\n", "# 'did' in 'did not', 'want' in I want to go", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "# (S+\\NP)+/(S+\\NP)", "\n", "# token.cat.semCat.IN.IN.marking = '+'   # (S+\\NP)+/(S+\\NP+)", "\n", "# token.cat.semCat.OUT.IN.marking = '+'  # (S+\\NP+)+/(S+\\NP)", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)/PP'", ":", "# 'ask' as in 'ask about'", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)/N'", ":", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)/PR'", ":", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'((S\\NP)/NP)/PR'", ":", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "OUT", ".", "marking", "=", "'+'", "\n", "", "else", ":", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n", "\n", "# TODO modal verbs", "\n", "", "", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", "==", "'MD'", "and", "token", ".", "cat", ".", "typeWOfeats", "!=", "'N'", ":", "\n", "# can: (S\\NP)/(S\\NP)", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "# ??", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "# ??", "\n", "\n", "# TODO to", "\n", "# elif (token.pos.upper() == 'TO') and \\", "\n", "#         (token.cat.typeWOfeats == r'(S\\NP)/(S\\NP)'):", "\n", "#     # 'to' in 'I want to', 'refused to' # (S+\\NP)+/(S+\\NP)", "\n", "#     token.cat.semCat.marking = '+'", "\n", "#     token.cat.semCat.OUT.marking = '+'", "\n", "#     token.cat.semCat.IN.marking = '+'", "\n", "#     # token.cat.semCat.OUT.IN.marking = '+'", "\n", "#     # token.cat.semCat.IN.IN.marking = '+'  # (S+\\NP+)+/(S+\\NP+)", "\n", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", "==", "'TO'", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n", "# TODO adverbs 1", "\n", "", "elif", "(", "token", ".", "pos", ".", "upper", "(", ")", "==", "'RB'", ")", "and", "(", "token", ".", "word", ".", "upper", "(", ")", "not", "in", "[", "'NOT'", ",", "\"N'T\"", "]", ")", ":", "\n", "                ", "if", "token", ".", "cat", ".", "typeWOfeats", "in", "[", "r'(S\\NP)/(S\\NP)'", ",", "r'(S\\NP)\\(S\\NP)'", "]", ":", "\n", "# adverbs; make it (S+\\NP)+/(S+\\NP)", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "in", "[", "r'S\\NP'", "]", ":", "\n", "# adverbs; make it S+\\NP", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "in", "[", "r'(S\\NP)/PP'", "]", ":", "\n", "# as fast as him, fast = (S\\NP)/PP", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "# TODO all other adverbs", "\n", "", "else", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n", "# -----------------------", "\n", "# TODO adjectives, add +", "\n", "", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", ".", "startswith", "(", "'JJ'", ")", ":", "\n", "                ", "if", "token", ".", "word", ".", "upper", "(", ")", "not", "in", "[", "'FAKE'", ",", "'FORMER'", "]", ":", "\n", "# token.cat.semCat.marking = '+'", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n", "# noun as noun modifiers, add +", "\n", "", "", "elif", "(", "token", ".", "pos", ".", "upper", "(", ")", "in", "[", "'NN'", ",", "'NNP'", "]", ")", "and", "(", "token", ".", "cat", ".", "typeWOfeats", "==", "r'N/N'", ")", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "\n", "# TODO than", "\n", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "==", "\"THAN\"", ":", "\n", "                ", "if", "token", ".", "cat", ".", "typeWOfeats", "==", "r'((S\\NP)\\(S\\NP))/NP'", ":", "\n", "# ((S+\\NP)+\\(S+\\NP))+/NP", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "IN", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "OUT", ".", "marking", "=", "'+'", "\n", "\n", "\n", "# TODO prepositions", "\n", "", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "{", "'IN'", ",", "'ON'", ",", "'TO'", ",", "'FROM'", ",", "'FOR'", ",", "\n", "'WITHIN'", ",", "'OF'", ",", "'AT'", ",", "'BY'", ",", "'INTO'", "}", ":", "\n", "# prepositions like 'in' as an argument, as in 'He puts it in the box'", "\n", "                ", "if", "token", ".", "cat", ".", "typeWOfeats", "==", "'PP/NP'", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "# make it PP/+NP'", "\n", "\n", "# 'in' as an adjunct as in 'John sleeps in France'", "\n", "# 'to' as in 'go to bed'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'((S\\NP)\\(S\\NP))/NP'", ":", "\n", "# TODO important!! the first 2 NPs should be None", "\n", "# make it ((S+\\NP)+\\(S+\\NP))+/NP", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "IN", ".", "marking", "=", "'+'", "\n", "# token.cat.semCat.OUT.IN.IN.marking = '+'", "\n", "# token.cat.semCat.OUT.OUT.IN.marking = '+'", "\n", "\n", "# 'in' as a modifier for nouns as in 'the man in France sleeps'", "\n", "# candc: (NP\\NP)/NP; easyccg: (N\\N)/NP", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "in", "[", "r'(NP\\NP)/NP'", ",", "r'(N\\N)/NP'", "]", ":", "\n", "# make it (NP+\\NP)+/NP", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "\n", "# 'in' in a PP that serves as sentential adverb, as in 'In theory, ...'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "in", "[", "r'(S/S)/NP'", ",", "r'(S\\S)/NP'", "]", ":", "\n", "# make it (S+/S)+/NP", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "\n", "", "", "elif", "token", ".", "word", ".", "upper", "(", ")", "in", "DE_PREP", ":", "# out, without, outside", "\n", "                ", "if", "token", ".", "cat", ".", "typeWOfeats", "==", "r'((S\\NP)\\(S\\NP))/NP'", ":", "# without", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "IN", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "OUT", ".", "marking", "=", "'+'", "\n", "# token.cat.semCat.OUT.IN.IN.marking = '+'", "\n", "# token.cat.semCat.OUT.OUT.IN.marking = '+'  # ((S+\\NP+)+\\(S+\\NP+))-/NP", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)\\(S\\NP)'", ":", "\n", "# `they are playing outside`", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "\n", "", "elif", "token", ".", "cat", ".", "typeWOfeats", "==", "r'S\\NP'", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "# 'out' in '2 men are looking out'", "\n", "", "else", ":", "\n", "                    ", "token", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "if", "token", ".", "cat", ".", "semCat", ".", "IN", ":", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "IN", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "", "if", "token", ".", "cat", ".", "semCat", ".", "OUT", ":", "\n", "                        ", "token", ".", "cat", ".", "semCat", ".", "OUT", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n", "", "", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", "==", "\"IN\"", ":", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n", "", "elif", "token", ".", "pos", ".", "upper", "(", ")", "==", "\"RP\"", ":", "# preposition??", "\n", "                ", "token", ".", "cat", ".", "semCat", ".", "assignRecursive", "(", "\"+\"", ",", "EXCLUDE", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN": [[1445, 1448], ["getMono.CCGtree.mark_NTN_helper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper"], ["", "", "", "def", "mark_NTN", "(", "self", ")", ":", "\n", "        ", "''' mark non terminal node '''", "\n", "self", ".", "mark_NTN_helper", "(", "self", ".", "root", ")", "\n", "# get marking for conj", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper": [[1451, 1506], ["len", "len", "getMono.CCGtree.mark_NTN_myparent", "getMono.CCGtree.mark_NTN_myparent_conj", "getMono.CCGtree.mark_NTN_myparent_conj", "getMono.CCGtree.mark_NTN_myparent", "len", "getMono.ErrorCCGtree", "getMono.CCGtree.mark_NTN_helper", "getMono.CCGtree.mark_NTN_helper", "getMono.CCGtree.mark_NTN_helper", "getMono.ErrorCCGtree", "getMono.CCGtree.mark_NTN_helper", "getMono.CCGtree.mark_NTN_helper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent_conj", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent_conj", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper"], ["", "def", "mark_NTN_helper", "(", "self", ",", "node", ")", ":", "\n", "# we can only set our parent when all its DESCENDANTS", "\n", "# have been set", "\n", "\n", "# no sisters", "\n", "        ", "if", "len", "(", "node", ".", "sisters", ")", "==", "0", ":", "\n", "# print('\\n\\nnode:', node)", "\n", "# print('no sister')", "\n", "            ", "if", "node", ".", "visited", ":", "# either leafNode or a visited parent of a unary rule", "\n", "# print('\\n\\nnode visited:', node)", "\n", "                ", "pass", "\n", "", "else", ":", "# an unvisited parent of a unary rule", "\n", "# print('\\n\\nnode not visited:', node)", "\n", "                ", "for", "child", "in", "node", ".", "children", ":", "\n", "# print('child:', child)", "\n", "                    ", "self", ".", "mark_NTN_helper", "(", "child", ")", "\n", "\n", "# IMPORTANT: now all its descendants have been marked!", "\n", "# so we can set node.parent", "\n", "", "", "if", "node", ".", "parent", ".", "ruleType", "==", "'conj'", ":", "self", ".", "mark_NTN_myparent_conj", "(", "node", ")", "\n", "else", ":", "self", ".", "mark_NTN_myparent", "(", "node", ")", "\n", "\n", "# 1 sister", "\n", "", "elif", "len", "(", "node", ".", "sisters", ")", "==", "1", ":", "\n", "# only if BOTH me and my sister have been marked,", "\n", "# can we set marking for parent", "\n", "# I can either be 'left' or 'right', so is my sister", "\n", "            ", "parent", "=", "node", ".", "parent", "\n", "left", "=", "parent", ".", "children", "[", "0", "]", "\n", "right", "=", "parent", ".", "children", "[", "1", "]", "\n", "if", "left", ".", "visited", "and", "right", ".", "visited", ":", "pass", "\n", "# whoever is not visited, we should recurse down", "\n", "elif", "left", ".", "visited", "and", "(", "not", "right", ".", "visited", ")", ":", "\n", "                ", "for", "child", "in", "right", ".", "children", ":", "self", ".", "mark_NTN_helper", "(", "child", ")", "\n", "", "elif", "(", "not", "left", ".", "visited", ")", "and", "right", ".", "visited", ":", "\n", "                ", "for", "child", "in", "left", ".", "children", ":", "self", ".", "mark_NTN_helper", "(", "child", ")", "\n", "", "elif", "(", "not", "left", ".", "visited", ")", "and", "(", "not", "right", ".", "visited", ")", ":", "\n", "                ", "for", "child", "in", "left", ".", "children", ":", "self", ".", "mark_NTN_helper", "(", "child", ")", "\n", "for", "child", "in", "right", ".", "children", ":", "self", ".", "mark_NTN_helper", "(", "child", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ErrorCCGtree", "(", "'something wrong in mark_NTN_helper()'", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "ErrorCCGtree", "(", "'number of sisters more than 1: {}'", ".", "format", "(", "node", ")", ")", "\n", "\n", "# check all descendants are marked", "\n", "", "if", "len", "(", "node", ".", "children", ")", "!=", "0", ":", "\n", "            ", "for", "child", "in", "node", ".", "parent", ".", "children", ":", "assert", "child", ".", "visited", "\n", "# now all its descendants have been marked! Mark node.parent", "\n", "# but only do this when parent not already set by my sister", "\n", "", "if", "not", "node", ".", "parent", ".", "visited", ":", "\n", "            ", "self", ".", "mark_NTN_myparent", "(", "node", ")", "\n", "", "if", "node", ".", "parent", ".", "ruleType", "==", "'conj'", ":", "\n", "            ", "self", ".", "mark_NTN_myparent_conj", "(", "node", ")", "\n", "\n", "", "node", ".", "visited", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent": [[1507, 1704], ["getMono.CCGtree.assignEqualMarkingTR", "len", "getMono.CCGtree.trTypes.append", "len", "getMono.eprint", "getMono.ErrorCCGtree", "getMono.CCGtree.compareSemCat", "getMono.CCGtree.compareSemCat", "getMono.eprint", "getMono.eprint", "right.ruleType.upper", "getMono.CCGtree.compareSemCat", "getMono.CCGtree.compareSemCat", "getMono.CCGtree.compareSemCat", "getMono.CCGtree.compareSemCat", "getMono.eprint", "getMono.eprint", "getMono.eprint", "getMono.eprint", "getMono.ErrorCCGtree", "getMono.eprint", "getMono.eprint", "getMono.eprint", "getMono.CCGtree.printSent", "getMono.ErrorCCGtree"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.assignEqualMarkingTR", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCat", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCat", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCat", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCat", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCat", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCat", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent"], ["", "def", "mark_NTN_myparent", "(", "self", ",", "node", ")", ":", "\n", "        ", "''' assign the marking of node.parent '''", "\n", "\n", "# if I'm single child, then rule can be 'lex', 'tr', 'unlex'", "\n", "if", "len", "(", "node", ".", "sisters", ")", "==", "0", ":", "\n", "# eprint('\\n\\n-- Now getting parent')", "\n", "# eprint('I am node:', node)", "\n", "            ", "if", "node", ".", "depth", "!=", "0", ":", "\n", "# eprint('my parent before:', node.parent)", "\n", "                ", "pass", "\n", "\n", "", "if", "node", ".", "parent", ".", "ruleType", "==", "'tr'", ":", "\n", "                ", "node", ".", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "# * syntactically 2 possibilities:", "\n", "#   X                  X", "\n", "# -------     or     -------", "\n", "# Y\\(Y/X)            Y/(Y\\X)", "\n", "# * but semantically only 1:", "\n", "#     x", "\n", "# --------- tr", "\n", "# (x->y)->y", "\n", "# make sure the markings on x is populated down", "\n", "# eprint(node.parent.cat.semCat)", "\n", "# eprint(node.cat.semCat)", "\n", "node", ".", "parent", ".", "cat", ".", "semCat", ".", "IN", ".", "IN", ".", "marking", "=", "node", ".", "cat", ".", "semCat", ".", "marking", "# TODO", "\n", "# eprint(node.parent.cat.semCat)", "\n", "# eprint(node.cat.semCat)", "\n", "# store the 2 y's in self.trTypes", "\n", "self", ".", "trTypes", ".", "append", "(", "(", "node", ".", "parent", ".", "cat", ".", "semCat", ".", "IN", ".", "OUT", ",", "\n", "node", ".", "parent", ".", "cat", ".", "semCat", ".", "OUT", ")", ")", "\n", "# eprint('------')", "\n", "# eprint(node)", "\n", "# eprint(node.parent)", "\n", "", "elif", "node", ".", "parent", ".", "ruleType", "==", "'lex'", ":", "\n", "# probably we don't have to do anything", "\n", "# 'lex' happens for 'John' or 'reading' in 'this is the book that", "\n", "#   I burnt without reading'", "\n", "# we want 'John' to be NP+", "\n", "# eprint('node:', node)", "\n", "                ", "node", ".", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "# eprint('node.parent:', node.parent)", "\n", "", "elif", "node", ".", "parent", ".", "ruleType", "==", "'unlex'", ":", "\n", "# NP -> N: rule added by me, for RC, do nothing", "\n", "                ", "pass", "\n", "", "else", ":", "# terminal node", "\n", "                ", "pass", "\n", "\n", "# if I got one sister", "\n", "", "", "elif", "len", "(", "node", ".", "sisters", ")", "==", "1", ":", "\n", "            ", "parent", "=", "node", ".", "parent", "\n", "left", "=", "parent", ".", "children", "[", "0", "]", "\n", "right", "=", "parent", ".", "children", "[", "1", "]", "\n", "\n", "if", "node", ".", "depth", "!=", "0", ":", "\n", "                ", "pass", "\n", "", "if", "parent", ".", "ruleType", "==", "'fa'", ":", "\n", "# X/Y Y -> X", "\n", "# make sure input and output of FA is correct", "\n", "# may not be true after fixQuantifier: e.g. Several man in a competition are running in door", "\n", "                ", "try", ":", "\n", "                    ", "assert", "parent", ".", "cat", ".", "semCat", ".", "semCatStr", "==", "left", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "\n", "assert", "left", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "right", ".", "cat", ".", "semCat", ".", "semCatStr", "\n", "", "except", "AssertionError", ":", "\n", "                    ", "eprint", "(", "\"Error in fa, likely due to fixQuantifier:\"", ")", "\n", "eprint", "(", "\"parent: {}\\nleft  : {}\\nright : {}\"", ".", "format", "(", "parent", ",", "left", ",", "right", ")", ")", "\n", "", "parent", ".", "cat", ".", "semCat", "=", "left", ".", "cat", ".", "semCat", ".", "OUT", "# assign marking", "\n", "\n", "# TODO comparator", "\n", "self", ".", "compareSemCat", "(", "left", ".", "cat", ".", "semCat", ".", "IN", ",", "right", ".", "cat", ".", "semCat", ",", "parent", ")", "\n", "# left.cat.semCat.IN = right.cat.semCat", "\n", "\n", "", "elif", "parent", ".", "ruleType", "==", "'ba'", ":", "\n", "# Y X\\Y -> X", "\n", "# make sure input and output of BA is correct", "\n", "                ", "assert", "parent", ".", "cat", ".", "semCat", ".", "semCatStr", "==", "right", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "\n", "assert", "right", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "left", ".", "cat", ".", "semCat", ".", "semCatStr", "\n", "\n", "# --- FOR RELATIVE CLAUSES --- #", "\n", "# TODO: COULD BE DELETED NOW since fixTree() fixes the RC", "\n", "# if X\\Y is NP\\NP, the RC in English (English RC comes after the head NP)", "\n", "# TODO, ONLY do this for RC, but NOT conjunction!", "\n", "if", "(", "right", ".", "cat", ".", "typeWOfeats", "==", "r'NP\\NP'", ")", "and", "(", "right", ".", "ruleType", ".", "upper", "(", ")", "!=", "'CONJ'", ")", ":", "\n", "# then the OUT NP should have the same marking as the IN NP in right", "\n", "# assert right.cat.semCat.OUT.marking is None", "\n", "                    ", "right", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "left", ".", "cat", ".", "semCat", ".", "marking", "\n", "# --- END: FOR RELATIVE CLAUSES --- #", "\n", "\n", "", "parent", ".", "cat", ".", "semCat", "=", "right", ".", "cat", ".", "semCat", ".", "OUT", "# assign marking", "\n", "\n", "# TODO comparator", "\n", "self", ".", "compareSemCat", "(", "right", ".", "cat", ".", "semCat", ".", "IN", ",", "left", ".", "cat", ".", "semCat", ",", "parent", ")", "# IMPORTANT", "\n", "# right.cat.semCat.IN = left.cat.semCat", "\n", "\n", "", "elif", "parent", ".", "ruleType", "==", "'bx'", ":", "\n", "# two possibilities", "\n", "# X/Y Y\\Z -> X\\Z", "\n", "                ", "if", "parent", ".", "cat", ".", "direction", "==", "'l'", ":", "\n", "# if left.cat.right.typeWOfeats == right.cat.left.typeWOfeats:", "\n", "# make sure input and output of BX is correct", "\n", "                    ", "assert", "parent", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "right", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "\n", "assert", "parent", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "==", "left", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "\n", "parent", ".", "cat", ".", "semCat", ".", "IN", "=", "right", ".", "cat", ".", "semCat", ".", "IN", "# assign marking", "\n", "parent", ".", "cat", ".", "semCat", ".", "OUT", "=", "left", ".", "cat", ".", "semCat", ".", "OUT", "# assign marking", "\n", "# TODO comparator here", "\n", "self", ".", "compareSemCat", "(", "left", ".", "cat", ".", "semCat", ".", "IN", ",", "right", ".", "cat", ".", "semCat", ".", "OUT", ",", "parent", ")", "\n", "# left.cat.semCat.IN = right.cat.semCat.OUT", "\n", "\n", "# Y/Z X\\Y -> X/Z  \"DID NOT\" is this pattern", "\n", "# z-->y  y-->x  ->  z-->x", "\n", "", "else", ":", "\n", "# make sure input and output of BX is correct", "\n", "# TODO", "\n", "# if parent.cat.semCat.IN and parent.cat.semCat.OUT:", "\n", "                    ", "try", ":", "\n", "                        ", "assert", "parent", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "left", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "\n", "assert", "parent", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "==", "right", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "\n", "", "except", "AssertionError", ":", "\n", "                        ", "eprint", "(", "'AssertionError in mark, rule = bx'", ")", "\n", "eprint", "(", "'left:'", ",", "left", ".", "cat", ".", "semCat", ")", "\n", "eprint", "(", "'right:'", ",", "right", ".", "cat", ".", "semCat", ")", "\n", "eprint", "(", "'parent:'", ",", "parent", ".", "cat", ".", "semCat", ")", "\n", "raise", "ErrorCCGtree", "(", "'error in mark_NTN_myparent'", ")", "\n", "", "parent", ".", "cat", ".", "semCat", ".", "IN", "=", "left", ".", "cat", ".", "semCat", ".", "IN", "# assign marking", "\n", "parent", ".", "cat", ".", "semCat", ".", "OUT", "=", "right", ".", "cat", ".", "semCat", ".", "OUT", "# assign marking", "\n", "\n", "# TODO comparator here", "\n", "self", ".", "compareSemCat", "(", "right", ".", "cat", ".", "semCat", ".", "IN", ",", "left", ".", "cat", ".", "semCat", ".", "OUT", ",", "parent", ")", "\n", "# right.cat.semCat.IN = left.cat.semCat.OUT", "\n", "\n", "# assign marking", "\n", "# if at least one of them is None (i.e. dot), result = None:", "\n", "", "if", "(", "right", ".", "cat", ".", "semCat", ".", "marking", "is", "None", ")", "or", "(", "left", ".", "cat", ".", "semCat", ".", "marking", "is", "None", ")", ":", "\n", "                    ", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "None", "\n", "", "elif", "right", ".", "cat", ".", "semCat", ".", "marking", "==", "left", ".", "cat", ".", "semCat", ".", "marking", ":", "\n", "                    ", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "", "else", ":", "\n", "                    ", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "\n", "", "", "elif", "parent", ".", "ruleType", "==", "'fc'", ":", "\n", "# X/Y Y/Z -> X/Z", "\n", "                ", "if", "left", ".", "cat", ".", "right", ".", "typeWOfeats", "==", "right", ".", "cat", ".", "left", ".", "typeWOfeats", ":", "\n", "# make sure input and output of fc is correct", "\n", "                    ", "assert", "parent", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "right", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "\n", "assert", "parent", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "==", "left", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "\n", "parent", ".", "cat", ".", "semCat", ".", "IN", "=", "right", ".", "cat", ".", "semCat", ".", "IN", "# assign marking", "\n", "parent", ".", "cat", ".", "semCat", ".", "OUT", "=", "left", ".", "cat", ".", "semCat", ".", "OUT", "# assign marking", "\n", "# TODO comparator here", "\n", "self", ".", "compareSemCat", "(", "left", ".", "cat", ".", "semCat", ".", "IN", ",", "right", ".", "cat", ".", "semCat", ".", "OUT", ",", "parent", ")", "\n", "# left.cat.semCat.IN = right.cat.semCat.OUT", "\n", "\n", "# Y\\Z X\\Y -> X\\Z", "\n", "", "else", ":", "\n", "                    ", "assert", "parent", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "left", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "\n", "assert", "parent", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "==", "right", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "\n", "parent", ".", "cat", ".", "semCat", ".", "IN", "=", "left", ".", "cat", ".", "semCat", ".", "IN", "# assign marking", "\n", "parent", ".", "cat", ".", "semCat", ".", "OUT", "=", "right", ".", "cat", ".", "semCat", ".", "OUT", "# assign marking", "\n", "# TODO comparator here", "\n", "self", ".", "compareSemCat", "(", "right", ".", "cat", ".", "semCat", ".", "OUT", ",", "left", ".", "cat", ".", "semCat", ".", "IN", ",", "parent", ")", "\n", "# right.cat.semCat.OUT = left.cat.semCat.IN", "\n", "\n", "# assign marking", "\n", "# if at least one of them is None (i.e. dot), result = None:", "\n", "", "if", "(", "right", ".", "cat", ".", "semCat", ".", "marking", "is", "None", ")", "or", "(", "left", ".", "cat", ".", "semCat", ".", "marking", "is", "None", ")", ":", "\n", "                    ", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "None", "\n", "", "elif", "right", ".", "cat", ".", "semCat", ".", "marking", "==", "left", ".", "cat", ".", "semCat", ".", "marking", ":", "\n", "                    ", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "", "else", ":", "\n", "                    ", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "'-'", "\n", "\n", "", "", "elif", "parent", ".", "ruleType", "in", "[", "'rp'", ",", "'lp'", "]", ":", "\n", "# rp: right punctuation?", "\n", "# punctuation, make parent.marking = non-punctuation-child.marking", "\n", "                ", "if", "parent", ".", "cat", ".", "semCat", ".", "semCatStr", "==", "left", ".", "cat", ".", "semCat", ".", "semCatStr", ":", "\n", "                    ", "parent", ".", "cat", "=", "left", ".", "cat", "\n", "", "else", ":", "\n", "                    ", "parent", ".", "cat", "=", "right", ".", "cat", "\n", "\n", "", "", "elif", "parent", ".", "ruleType", "==", "'conj'", ":", "pass", "# already handled", "\n", "\n", "else", ":", "\n", "                ", "eprint", "(", "'\\nunable to process rule in mark_NTN_myparent(): {}'", ".", "format", "(", "\n", "node", ".", "parent", ".", "ruleType", ")", ")", "\n", "eprint", "(", "node", ")", "\n", "eprint", "(", "node", ".", "parent", ")", "\n", "self", ".", "printSent", "(", "stream", "=", "sys", ".", "stderr", ")", "\n", "raise", "ErrorCCGtree", "(", "'error in mark_NTN_myparent()'", ")", "\n", "\n", "# TODO", "\n", "", "", "else", ":", "\n", "            ", "eprint", "(", "'wrong number of sisters: {}'", ".", "format", "(", "node", ")", ")", "\n", "raise", "ErrorCCGtree", "(", "'error in mark_NTN_myparent()'", ")", "\n", "\n", "", "node", ".", "parent", ".", "visited", "=", "True", "\n", "\n", "# do this every time when we mark a parent", "\n", "self", ".", "assignEqualMarkingTR", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper_conj": [[1707, 1727], ["len", "getMono.CCGtree.mark_NTN_myparent_conj", "len", "getMono.CCGtree.mark_NTN_helper_conj", "getMono.CCGtree.mark_NTN_helper_conj", "getMono.CCGtree.mark_NTN_myparent_conj", "len", "getMono.CCGtree.mark_NTN_helper_conj", "getMono.eprint", "getMono.ErrorCCGtree", "getMono.CCGtree.mark_NTN_myparent_conj"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent_conj", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper_conj", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper_conj", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent_conj", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_helper_conj", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent_conj"], ["", "def", "mark_NTN_helper_conj", "(", "self", ",", "node", ")", ":", "\n", "        ", "''' get marking for CONJ rule '''", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "\n", "            ", "if", "node", ".", "parent", ".", "ruleType", "==", "'conj'", ":", "\n", "                ", "self", ".", "mark_NTN_myparent_conj", "(", "node", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "len", "(", "node", ".", "children", ")", "==", "2", ":", "# 2 children", "\n", "                ", "self", ".", "mark_NTN_helper_conj", "(", "node", ".", "children", "[", "0", "]", ")", "# left child", "\n", "self", ".", "mark_NTN_helper_conj", "(", "node", ".", "children", "[", "1", "]", ")", "# right child", "\n", "# now fix node.parent", "\n", "if", "node", ".", "parent", ".", "ruleType", "==", "'conj'", ":", "\n", "                    ", "self", ".", "mark_NTN_myparent_conj", "(", "node", ")", "\n", "", "", "elif", "len", "(", "node", ".", "children", ")", "==", "1", ":", "# only one child, rule is either 'lex' or 'tr'", "\n", "                ", "self", ".", "mark_NTN_helper_conj", "(", "node", ".", "children", "[", "0", "]", ")", "\n", "# now fix node itself", "\n", "if", "node", ".", "parent", ".", "ruleType", "==", "'conj'", ":", "\n", "                    ", "self", ".", "mark_NTN_myparent_conj", "(", "node", ")", "\n", "", "", "else", ":", "\n", "                ", "eprint", "(", "'number of children more than 2: {}'", ".", "format", "(", "node", ")", ")", "\n", "raise", "ErrorCCGtree", "(", "'error in mark_NTN_myparent()'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark_NTN_myparent_conj": [[1728, 1810], ["conj.cat.typeWOfeats.upper", "str", "getMono.Cat", "getMono.eprint", "getMono.eprint", "getMono.eprint", "getMono.eprint", "X2.cat.typeWOfeats.upper", "getMono.ErrorCCGtree", "getMono.eprint", "getMono.eprint", "getMono.ErrorCCGtree"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "", "", "def", "mark_NTN_myparent_conj", "(", "self", ",", "node", ")", ":", "\n", "#        conj(conj)=(X\\X1)/X2      NP(X2)", "\n", "#        -------------------------- conj", "\n", "# NP(X1)           NP\\NP(parent)=X\\X1", "\n", "# ----------------------------------- fa/ba", "\n", "#             NP(grandparent)=X", "\n", "\n", "# TODO", "\n", "# NOTE: X1 and X2 may have different types!", "\n", "# e.g. A man and a woman be in a room paint beige wear dark colored shirt and a monitor be in the background", "\n", "\n", "        ", "parent", "=", "node", ".", "parent", "\n", "conj", "=", "parent", ".", "children", "[", "0", "]", "\n", "X2", "=", "parent", ".", "children", "[", "1", "]", "\n", "X1", "=", "parent", ".", "sisters", "[", "0", "]", "\n", "grandparent", "=", "parent", ".", "parent", "\n", "\n", "# print(\"im here!\")", "\n", "# print(conj.cat.typeWOfeats.upper())", "\n", "\n", "# first get the cat for conj, and marking on the SLASHES,", "\n", "# not on the NP", "\n", "# i.e. if right = X, sister = X, then we want conj to be: (X\\X)/X", "\n", "if", "conj", ".", "cat", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'CONJ'", ":", "\n", "\n", "# check if X1 type = X2 type", "\n", "            ", "if", "X1", ".", "cat", ".", "typeWOpolarity", "!=", "X2", ".", "cat", ".", "typeWOpolarity", ":", "\n", "                ", "eprint", "(", "\"bad conjunction! setting conjuction type to 'conj'\"", ")", "\n", "eprint", "(", "\"\\tX1:\"", ",", "X1", ".", "cat", ".", "typeWOpolarity", ")", "\n", "eprint", "(", "\"\\tX2:\"", ",", "X2", ".", "cat", ".", "typeWOpolarity", ")", "\n", "eprint", "(", "\"\\tconj:\"", ",", "conj", ".", "cat", ")", "\n", "return", "\n", "\n", "", "X2Type", "=", "str", "(", "X2", ".", "cat", ".", "typeWOpolarity", ")", "\n", "\n", "# if X2Type X is basic: NP, then conj: (NP\\NP)/NP", "\n", "# but when X2Type is complex: (S\\NP)/NP", "\n", "# we need an extra pair of brackets for rightType X:", "\n", "# i.e. ((X)\\(X))/(X) = (((S\\NP)/NP)\\((S\\NP)/NP))/((S\\NP)/NP)", "\n", "if", "'('", "in", "X2Type", ":", "X2Type", "=", "'('", "+", "X2Type", "+", "')'", "\n", "elif", "(", "'\\\\'", "in", "X2Type", ")", "or", "(", "'/'", "in", "X2Type", ")", ":", "X2Type", "=", "'('", "+", "X2Type", "+", "')'", "\n", "\n", "conj", ".", "cat", "=", "Cat", "(", "'('", "+", "X2Type", "+", "'\\\\'", "+", "X2Type", "+", "')/'", "+", "\n", "X2Type", ",", "word", "=", "conj", ".", "word", ")", "\n", "\n", "# ---------------------------------", "\n", "# assign marking to conj, both slashes are '+' TODO", "\n", "conj", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "conj", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "# assign marking to parent '+'", "\n", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "\n", "\n", "# ---------------------------------", "\n", "conj", ".", "cat", ".", "semCat", ".", "IN", "=", "X2", ".", "cat", ".", "semCat", "\n", "conj", ".", "cat", ".", "semCat", ".", "OUT", ".", "IN", "=", "X1", ".", "cat", ".", "semCat", "\n", "parent", ".", "cat", ".", "semCat", ".", "IN", "=", "X1", ".", "cat", ".", "semCat", "\n", "\n", "# ---------------------------------", "\n", "# !! assign parent.OUT marking !! #", "\n", "if", "(", "X2", ".", "cat", ".", "typeWOfeats", "==", "'S'", ")", "and", "(", "X1", ".", "cat", ".", "typeWOfeats", "==", "'S'", ")", ":", "\n", "                ", "parent", ".", "cat", ".", "semCat", ".", "marking", "=", "'+'", "# conjoining two S   S+\\S", "\n", "", "elif", "(", "X2", ".", "cat", ".", "semCat", ".", "marking", "is", "None", ")", "or", "(", "X1", ".", "cat", ".", "semCat", ".", "marking", "is", "None", ")", ":", "\n", "                ", "parent", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "None", "# this will be grandparent NP", "\n", "# if right.marking == sister.marking != None, then grandparent = that marking", "\n", "", "elif", "X2", ".", "cat", ".", "semCat", ".", "marking", "==", "X1", ".", "cat", ".", "semCat", ".", "marking", ":", "\n", "                ", "parent", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "X2", ".", "cat", ".", "semCat", ".", "marking", "\n", "# assert X1 and X2 are exactly the same", "\n", "try", ":", "assert", "X1", ".", "cat", ".", "semCat", ".", "semCatStr", "==", "X2", ".", "cat", ".", "semCat", ".", "semCatStr", "\n", "except", "AssertionError", ":", "\n", "                    ", "eprint", "(", "'X1.cat.semCat:'", ",", "X1", ".", "cat", ".", "semCat", ")", "\n", "eprint", "(", "'X2.cat.semCat:'", ",", "X2", ".", "cat", ".", "semCat", ")", "\n", "raise", "ErrorCCGtree", "(", "'error in mark_NTN_myparent_conj'", ")", "\n", "", "parent", ".", "cat", ".", "semCat", ".", "OUT", "=", "X2", ".", "cat", ".", "semCat", "\n", "\n", "# right and sister have different marking; this handles 'No man but some woman walks'", "\n", "", "else", ":", "parent", ".", "cat", ".", "semCat", ".", "OUT", ".", "marking", "=", "None", "\n", "\n", "# now set semCat for grandparent", "\n", "grandparent", ".", "cat", ".", "semCat", "=", "parent", ".", "cat", ".", "semCat", ".", "OUT", "\n", "\n", "", "elif", "X2", ".", "cat", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'CONJ'", ":", "# impossible", "\n", "            ", "raise", "ErrorCCGtree", "(", "'right is a conj! this is impossible!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCat": [[1818, 1842], ["getMono.CCGtree.compareSemCatHelper", "getMono.eprint", "getMono.eprint", "getMono.ErrorCompareSemCat"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCatHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "", "def", "compareSemCat", "(", "self", ",", "semCat1", ",", "semCat2", ",", "parent", ")", ":", "\n", "        ", "\"\"\"\n        - traverse semCat1 and semCat2 at the same time,\n        - populate the more ``specific'' marking (+/-) to the ``unspecific''\n          in each step\n\n        semCat1 > semCat2\n        e.g. semCat1 = ((et,-t),((et,t),t))   semCat2 = ((et,t),+((et,t),+t))\n        result: ((et,-t),+((et,t),+t))\n        [pay attention to +/- signs]\n        \"\"\"", "\n", "\n", "try", ":", "\n", "            ", "assert", "semCat1", ".", "semCatStr", "==", "semCat2", ".", "semCatStr", "# semCatStr does not have +/-", "\n", "", "except", "AssertionError", ":", "\n", "            ", "eprint", "(", "'semCat1.semCatStr: {}'", ".", "format", "(", "semCat1", ".", "semCatStr", ")", ")", "\n", "eprint", "(", "'semCat2.semCatStr: {}'", ".", "format", "(", "semCat2", ".", "semCatStr", ")", ")", "\n", "raise", "ErrorCompareSemCat", "(", "'parent is: {}'", ".", "format", "(", "parent", ")", ")", "\n", "\n", "# eprint('---\\nbefore:\\nsemCat1:', semCat1, semCat1.semCatStr)", "\n", "# eprint('semCat2:', semCat2, semCat2.semCatStr)", "\n", "\n", "# recurse through semCat1 and semCat2 at the same time", "\n", "", "self", ".", "compareSemCatHelper", "(", "semCat1", ",", "semCat2", ",", "parent", ")", "\n", "# semCat1.marking = semCat2.marking", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCatHelper": [[1847, 1864], ["getMono.CCGtree.semCatGreater", "getMono.CCGtree.compareSemCatHelper", "getMono.CCGtree.compareSemCatHelper", "getMono.eprint", "getMono.eprint", "getMono.eprint", "getMono.ErrorCompareSemCat"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.semCatGreater", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCatHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.compareSemCatHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "compareSemCatHelper", "(", "self", ",", "semCat1", ",", "semCat2", ",", "parent", ")", ":", "\n", "        ", "\"\"\" recursive helper function\n        e.g. semCat1 = ((et,-t),((et,t),t))   semCat2 = ((et,t),+((et,t),+t))\n        result: ((et,-t),+((et,t),+t))\n        \"\"\"", "\n", "if", "semCat1", ".", "IN", ":", "# if semCat1.IN is not None", "\n", "            ", "self", ".", "compareSemCatHelper", "(", "semCat2", ".", "IN", ",", "semCat1", ".", "IN", ",", "parent", ")", "\n", "", "if", "semCat1", ".", "OUT", ":", "\n", "            ", "self", ".", "compareSemCatHelper", "(", "semCat1", ".", "OUT", ",", "semCat2", ".", "OUT", ",", "parent", ")", "\n", "\n", "", "if", "self", ".", "semCatGreater", "(", "semCat1", ",", "semCat2", ")", ":", "# semCat2 is more specific", "\n", "            ", "semCat1", ".", "marking", "=", "semCat2", ".", "marking", "\n", "", "else", ":", "\n", "            ", "eprint", "(", "semCat1", ",", "semCat2", ")", "\n", "eprint", "(", "semCat1", ".", "marking", ",", "semCat2", ".", "marking", ")", "\n", "eprint", "(", "\"parent: {}\"", ".", "format", "(", "parent", ")", ")", "\n", "raise", "ErrorCompareSemCat", "(", "\"{} not greater than {}\\n\\n\"", ".", "format", "(", "semCat1", ",", "semCat2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.semCatGreater": [[1865, 1869], ["None"], "methods", ["None"], ["", "", "def", "semCatGreater", "(", "self", ",", "semCat1", ",", "semCat2", ")", ":", "\n", "        ", "\"\"\" semCat1 >= semCat2 iff: \"\"\"", "\n", "# eprint('compareing: {} and {}'.format(semCat1, semCat2))", "\n", "return", "(", "semCat1", ".", "marking", "is", "None", ")", "or", "(", "semCat1", ".", "marking", "==", "semCat2", ".", "marking", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.equate_marking": [[1870, 1884], ["getMono.CCGtree.semCatGreater", "getMono.CCGtree.equate_marking", "getMono.CCGtree.equate_marking"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.semCatGreater", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.equate_marking", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.equate_marking"], ["", "def", "equate_marking", "(", "self", ",", "semCat1", ",", "semCat2", ")", ":", "\n", "        ", "\"\"\" to assign the same markings on x, y in type (x, y)\n        e.g. 1. in negation, didn't = (NP->S)->(NP->S) where both (NP->S) should have\n         the same markings\n        e.g. 2. verbs of type (NP->S)->(NP->S) as 'manage' in 'I managed to pass the exam'.\n        \"\"\"", "\n", "assert", "semCat1", ".", "semCatStr", "==", "semCat2", ".", "semCatStr", "\n", "if", "self", ".", "semCatGreater", "(", "semCat1", ",", "semCat2", ")", ":", "# OUT is more specific", "\n", "            ", "semCat1", ".", "marking", "=", "semCat2", ".", "marking", "\n", "", "else", ":", "semCat1", ".", "marking", "=", "semCat2", ".", "marking", "\n", "\n", "# recurse", "\n", "if", "semCat1", ".", "IN", ":", "self", ".", "equate_marking", "(", "semCat1", ".", "IN", ",", "semCat2", ".", "IN", ")", "\n", "if", "semCat1", ".", "OUT", ":", "self", ".", "equate_marking", "(", "semCat1", ".", "OUT", ",", "semCat2", ".", "OUT", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule": [[1885, 1905], ["getMono.CCGtree.polarizeHelper", "getMono.CCGtree.flip", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.flip", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper"], ["", "def", "Krule", "(", "self", ",", "functor", ",", "monoDirection", ")", ":", "\n", "        ", "r\"\"\"\n        if functor.cat.semCat.IN.semCatStr == '((e,t),t)':  # NP\n        we look at K-rule\n        rule: {'>': fa and ba, 'B': fc and bx}\n\n        # if (S\\NP)/NP, then look at markings on both NP\n        # if S\\NP, then only look at marking on one NP\n        \"\"\"", "\n", "NP", "=", "functor", ".", "cat", ".", "semCat", ".", "IN", "\n", "if", "NP", ".", "marking", "==", "'-'", ":", "# NP-, flip", "\n", "            ", "self", ".", "polarizeHelper", "(", "functor", ",", "self", ".", "flip", "(", "monoDirection", ")", ")", "\n", "", "elif", "NP", ".", "marking", "is", "None", ":", "\n", "            ", "if", "functor", ".", "cat", ".", "semCat", ".", "OUT", ".", "semCatStr", "==", "'(((e,t),t),t)'", ":", "\n", "# (S\\NP1)/NP2 TODO is this correct?", "\n", "                ", "self", ".", "polarizeHelper", "(", "functor", ",", "monoDirection", ")", "\n", "", "else", ":", "# NP=", "\n", "                ", "self", ".", "polarizeHelper", "(", "functor", ",", "'UNK'", ")", "\n", "", "", "else", ":", "# NP+", "\n", "            ", "self", ".", "polarizeHelper", "(", "functor", ",", "monoDirection", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule_composition": [[1927, 1956], ["getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.flip", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.flip", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper"], ["", "", "def", "Krule_composition", "(", "self", ",", "functor", ",", "monoDirection", ")", ":", "\n", "        ", "r\"\"\"  k-rule for composition\n        e.g. in object RC: Z/Y Y/X -> Z/X  i.e. x-->y  y-->z = x-->z\n        to expand it:\n        x-->y   x\n        ----------\n            y         y-->z\n        --------------------\n                z\n        If y.IN = NP, then we need to use Krule.\n        That is, if y is (NP- --> S), then flip y.\n        But it's hard to flip intermediate polarities, so instead,\n        we do: if x-->y is '+' on the \\rightarrow, and y is NP-, we flip x-->y\n\n        Here x-->y is the functor\n        y = functor.cat.semCat.OUT.IN\n        \"\"\"", "\n", "if", "functor", ".", "cat", ".", "semCat", ".", "OUT", "is", "not", "None", ":", "\n", "            ", "if", "functor", ".", "cat", ".", "semCat", ".", "OUT", ".", "IN", "is", "not", "None", ":", "\n", "                ", "if", "functor", ".", "cat", ".", "semCat", ".", "OUT", ".", "IN", ".", "marking", "==", "'-'", ":", "\n", "                    ", "self", ".", "polarizeHelper", "(", "functor", ",", "self", ".", "flip", "(", "monoDirection", ")", ")", "\n", "", "elif", "functor", ".", "cat", ".", "semCat", ".", "OUT", ".", "IN", ".", "marking", "is", "None", ":", "\n", "                    ", "self", ".", "polarizeHelper", "(", "functor", ",", "'UNK'", ")", "\n", "", "else", ":", "# +", "\n", "                    ", "self", ".", "polarizeHelper", "(", "functor", ",", "monoDirection", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "polarizeHelper", "(", "functor", ",", "monoDirection", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "polarizeHelper", "(", "functor", ",", "monoDirection", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarize": [[1957, 1959], ["getMono.CCGtree.polarizeHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper"], ["", "", "def", "polarize", "(", "self", ")", ":", "\n", "        ", "self", ".", "polarizeHelper", "(", "self", ".", "root", ",", "'UP'", ")", "\n", "# for leafNode in self.leafNodes:", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper": [[1962, 2119], ["len", "len", "len", "getMono.CCGtree.polarizeHelper", "right.ruleType.upper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "getMono.CCGtree.Krule", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "getMono.CCGtree.Krule", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "left.ruleType.upper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.eprint", "getMono.CCGtree.calcMono", "getMono.CCGtree.Krule", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "getMono.CCGtree.Krule", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "getMono.CCGtree.Krule", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "getMono.CCGtree.Krule", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "len", "len", "getMono.CCGtree.Krule", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "getMono.CCGtree.Krule", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.calcMono", "getMono.CCGtree.polarizeHelper", "getMono.CCGtree.polarizeHelper", "getMono.ErrorCCGtree", "len", "len", "getMono.eprint", "getMono.eprint", "getMono.eprint", "getMono.eprint", "getMono.ErrorCCGtree", "left.pos.upper", "getMono.CCGtree.polarizeHelper", "right.pos.upper", "getMono.CCGtree.polarizeHelper", "getMono.eprint"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.Krule", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarizeHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "polarizeHelper", "(", "self", ",", "node", ",", "monoDirection", ")", ":", "\n", "# assign UP/DOWN to node", "\n", "        ", "node", ".", "cat", ".", "monotonicity", "=", "monoDirection", "\n", "\n", "r\"\"\"\n        # -----------------------\n        # TODO new 20181008: no k-rule\n        # IN is NP\n        if (node.cat.semCat.IN is not None) and \\\n                (node.cat.semCat.IN.semCatStr == '((e,t),t)'):\n            NP = node.cat.semCat.IN\n            # if transitive verb: (S\\NP)/NP\n            if (node.cat.semCat.OUT.IN is not None) and \\\n                    (node.cat.semCat.OUT.IN.semCatStr == '((e,t),t)'):\n                NP2 = node.cat.semCat.OUT.IN\n                if (NP.marking is None) or (NP2.marking is None):\n                    node.cat.originalType += ' none'\n                elif [NP.marking, NP2.marking].count('-') == 1:  # 1 -\n                    node.cat.originalType += ' flip'\n                else:  # 0 or 2 -\n                    pass\n            # intransitive verb: S\\NP, or a VP: S/NP\n            else:\n                if NP.marking == '-':  # NP-, flip\n                    node.cat.originalType += ' flip'\n                elif NP.marking is None:  # NP=\n                    node.cat.originalType += ' none'\n                else:  # NP+\n                    pass\n        # -----------------------\n        \"\"\"", "\n", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "# leaf", "\n", "            ", "return", "\n", "", "if", "len", "(", "node", ".", "children", ")", "==", "2", ":", "# 2 children", "\n", "            ", "left", "=", "node", ".", "children", "[", "0", "]", "\n", "right", "=", "node", ".", "children", "[", "1", "]", "\n", "\n", "if", "node", ".", "ruleType", "==", "'ba'", ":", "# Y X\\Y --> X   functor = right", "\n", "                ", "try", ":", "\n", "                    ", "if", "right", ".", "ruleType", ".", "upper", "(", ")", "==", "'CONJ'", ":", "\n", "                        ", "self", ".", "polarizeHelper", "(", "left", ",", "self", ".", "calcMono", "(", "right", ",", "monoDirection", ")", ")", "\n", "self", ".", "polarizeHelper", "(", "right", ",", "monoDirection", ")", "\n", "", "else", ":", "\n", "                        ", "if", "right", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "'((e,t),t)'", ":", "# NP", "\n", "                            ", "self", ".", "Krule", "(", "right", ",", "monoDirection", ")", "# k rule", "\n", "", "else", ":", "\n", "                            ", "self", ".", "polarizeHelper", "(", "right", ",", "monoDirection", ")", "\n", "", "self", ".", "polarizeHelper", "(", "left", ",", "self", ".", "calcMono", "(", "right", ",", "monoDirection", ")", ")", "\n", "", "", "except", "AttributeError", ":", "# 'LeafNode' (right) object has no attribute 'ruleType'", "\n", "                    ", "if", "right", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "'((e,t),t)'", ":", "# NP", "\n", "                        ", "self", ".", "Krule", "(", "right", ",", "monoDirection", ")", "# k rule", "\n", "", "else", ":", "\n", "                        ", "self", ".", "polarizeHelper", "(", "right", ",", "monoDirection", ")", "\n", "", "self", ".", "polarizeHelper", "(", "left", ",", "self", ".", "calcMono", "(", "right", ",", "monoDirection", ")", ")", "\n", "\n", "", "", "elif", "node", ".", "ruleType", "==", "'fa'", ":", "# X/Y Y --> X   functor = left", "\n", "                ", "try", ":", "\n", "                    ", "if", "left", ".", "ruleType", ".", "upper", "(", ")", "==", "'CONJ'", ":", "\n", "                        ", "self", ".", "polarizeHelper", "(", "right", ",", "self", ".", "calcMono", "(", "left", ",", "monoDirection", ")", ")", "\n", "self", ".", "polarizeHelper", "(", "left", ",", "monoDirection", ")", "\n", "", "else", ":", "\n", "                        ", "if", "left", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "'((e,t),t)'", ":", "# NP", "\n", "                            ", "self", ".", "Krule", "(", "left", ",", "monoDirection", ")", "# k rule", "\n", "", "else", ":", "\n", "                            ", "self", ".", "polarizeHelper", "(", "left", ",", "monoDirection", ")", "\n", "", "self", ".", "polarizeHelper", "(", "right", ",", "self", ".", "calcMono", "(", "left", ",", "monoDirection", ")", ")", "\n", "", "", "except", "AttributeError", ":", "# 'LeafNode' (left) object has no attribute 'ruleType'", "\n", "                    ", "if", "left", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "'((e,t),t)'", ":", "# NP", "\n", "                        ", "self", ".", "Krule", "(", "left", ",", "monoDirection", ")", "# k rule", "\n", "", "else", ":", "\n", "                        ", "self", ".", "polarizeHelper", "(", "left", ",", "monoDirection", ")", "\n", "", "self", ".", "polarizeHelper", "(", "right", ",", "self", ".", "calcMono", "(", "left", ",", "monoDirection", ")", ")", "\n", "\n", "", "", "elif", "node", ".", "ruleType", "==", "'bx'", ":", "\n", "# X/Y Y\\Z -> X\\Z    functor = left", "\n", "                ", "if", "node", ".", "cat", ".", "direction", "==", "'l'", ":", "\n", "                    ", "if", "(", "len", "(", "left", ".", "children", ")", "!=", "0", ")", "and", "(", "left", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "'((e,t),t)'", ")", ":", "# NP", "\n", "                        ", "self", ".", "Krule", "(", "left", ",", "monoDirection", ")", "# TODO no k rule if leafNode", "\n", "", "else", ":", "\n", "                        ", "self", ".", "polarizeHelper", "(", "left", ",", "monoDirection", ")", "\n", "", "self", ".", "polarizeHelper", "(", "right", ",", "self", ".", "calcMono", "(", "left", ",", "monoDirection", ")", ")", "\n", "# Y/Z X\\Y -> X/Z    functor = right", "\n", "", "else", ":", "\n", "                    ", "if", "(", "len", "(", "right", ".", "children", ")", "!=", "0", ")", "and", "(", "right", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "'((e,t),t)'", ")", ":", "# NP", "\n", "                        ", "self", ".", "Krule", "(", "right", ",", "monoDirection", ")", "# TODO no k rule if leafNode", "\n", "", "else", ":", "\n", "                        ", "self", ".", "polarizeHelper", "(", "right", ",", "monoDirection", ")", "\n", "", "self", ".", "polarizeHelper", "(", "left", ",", "self", ".", "calcMono", "(", "right", ",", "monoDirection", ")", ")", "\n", "\n", "", "", "elif", "node", ".", "ruleType", "==", "'fc'", ":", "# Z/Y Y/X -> Z/X or Y\\X Z\\Y -> Z\\X", "\n", "# X/Y Y/Z -> X/Z    functor = left", "\n", "                ", "if", "node", ".", "cat", ".", "direction", "==", "'r'", ":", "\n", "                    ", "if", "(", "len", "(", "left", ".", "children", ")", "!=", "0", ")", "and", "(", "left", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "'((e,t),t)'", ")", ":", "# NP", "\n", "                        ", "self", ".", "Krule", "(", "left", ",", "monoDirection", ")", "# TODO no k rule if leafNode", "\n", "", "else", ":", "\n", "                        ", "self", ".", "polarizeHelper", "(", "left", ",", "monoDirection", ")", "\n", "", "self", ".", "polarizeHelper", "(", "right", ",", "self", ".", "calcMono", "(", "right", ",", "monoDirection", ")", ")", "\n", "# Y\\Z X\\Y -> X\\Z    functor = right", "\n", "", "else", ":", "\n", "                    ", "if", "(", "len", "(", "right", ".", "children", ")", "!=", "0", ")", "and", "(", "right", ".", "cat", ".", "semCat", ".", "IN", ".", "semCatStr", "==", "'((e,t),t)'", ")", ":", "# NP", "\n", "                        ", "self", ".", "Krule", "(", "right", ",", "monoDirection", ")", "# TODO no k rule if leafNode", "\n", "", "else", ":", "\n", "                        ", "self", ".", "polarizeHelper", "(", "right", ",", "monoDirection", ")", "\n", "", "self", ".", "polarizeHelper", "(", "left", ",", "self", ".", "calcMono", "(", "right", ",", "monoDirection", ")", ")", "\n", "\n", "", "", "elif", "node", ".", "ruleType", "==", "'conj'", ":", "# conjunction", "\n", "                ", "try", ":", "#", "\n", "                    ", "if", "left", ".", "cat", ".", "typeWOfeats", "==", "\"conj\"", ":", "\n", "                        ", "eprint", "(", "\"unable to polarize conj rule! X1, X2 not same type!\"", ")", "\n", "", "elif", "left", ".", "pos", ".", "upper", "(", ")", "==", "'CC'", ":", "\n", "#        conj(left)      NP(right)", "\n", "#        -------------------------- conj", "\n", "# NP(sister)           NP\\NP(parent)", "\n", "# ----------------------------------- fa/ba", "\n", "#             NP", "\n", "# right.mono = sister.mono", "\n", "                        ", "self", ".", "polarizeHelper", "(", "right", ",", "right", ".", "parent", ".", "sisters", "[", "0", "]", ".", "cat", ".", "monotonicity", ")", "\n", "left", ".", "cat", ".", "monotonicity", "=", "'UP'", "# set the conj to UP, no matter what", "\n", "", "", "except", "AttributeError", ":", "# 'NonTermNode' object has no attribute 'pos'", "\n", "                    ", "try", ":", "\n", "                        ", "if", "right", ".", "pos", ".", "upper", "(", ")", "==", "'CC'", ":", "\n", "                            ", "self", ".", "polarizeHelper", "(", "left", ",", "left", ".", "parent", ".", "sisters", "[", "0", "]", ".", "cat", ".", "monotonicity", ")", "\n", "right", ".", "cat", ".", "monotonicity", "=", "'UP'", "# set the conj to UP, no matter what", "\n", "", "", "except", "AttributeError", ":", "\n", "                        ", "eprint", "(", "'unable to polarize conj rule!\\nNo \"CC\" pos'", ")", "\n", "", "", "except", ":", "\n", "                    ", "eprint", "(", "'unable to polarize conj rule!\\n'", ")", "\n", "eprint", "(", "left", ")", "\n", "eprint", "(", "right", ")", "\n", "raise", "ErrorCCGtree", "(", "'unable to polarize conj rule!'", ")", "\n", "", "", "elif", "node", ".", "ruleType", "in", "[", "'rp'", ",", "'lp'", "]", ":", "# punctuation", "\n", "                ", "self", ".", "polarizeHelper", "(", "left", ",", "monoDirection", ")", "\n", "self", ".", "polarizeHelper", "(", "right", ",", "monoDirection", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ErrorCCGtree", "(", "'unknown ruleType in polarize (two children): '", "\n", "'{}'", ".", "format", "(", "node", ".", "ruleType", ")", ")", "\n", "\n", "", "", "elif", "len", "(", "node", ".", "children", ")", "==", "1", ":", "# 1 child", "\n", "            ", "child", "=", "node", ".", "children", "[", "0", "]", "\n", "if", "node", ".", "ruleType", "==", "'lex'", ":", "\n", "                ", "self", ".", "polarizeHelper", "(", "child", ",", "monoDirection", ")", "\n", "", "elif", "node", ".", "ruleType", "==", "'unlex'", ":", "# keep the same direction", "\n", "                ", "self", ".", "polarizeHelper", "(", "child", ",", "monoDirection", ")", "\n", "", "elif", "node", ".", "ruleType", "==", "'tr'", ":", "# type raising", "\n", "# for (x->y)->y, the +/- on the first (i.e. left) arrow", "\n", "# determines the monoDirection of child", "\n", "                ", "self", ".", "polarizeHelper", "(", "child", ",", "\n", "self", ".", "calcMono", "(", "node", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", ",", "\n", "monoDirection", ")", ")", "\n", "", "else", ":", "\n", "                ", "eprint", "(", "'unknown ruleType in polarize (one child): {}'", ".", "format", "(", "node", ".", "ruleType", ")", ")", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.calcMono": [[2120, 2140], ["getMono.CCGtree.printTree", "getMono.eprint", "getMono.ErrorCCGtree"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTree", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "", "", "def", "calcMono", "(", "self", ",", "functorORmarking", ",", "monoDirection", ")", ":", "\n", "        ", "''' functorORmarking can either be a functor or simply marking(+/-) '''", "\n", "marking", "=", "functorORmarking", "\n", "if", "functorORmarking", "not", "in", "[", "'-'", ",", "'+'", ",", "None", "]", ":", "\n", "            ", "marking", "=", "functorORmarking", ".", "cat", ".", "semCat", ".", "marking", "\n", "\n", "", "if", "monoDirection", "==", "'UP'", "and", "marking", "==", "'-'", ":", "\n", "            ", "return", "'DOWN'", "\n", "", "elif", "monoDirection", "==", "'DOWN'", "and", "marking", "==", "'-'", ":", "\n", "            ", "return", "'UP'", "\n", "", "elif", "monoDirection", "==", "'UP'", "and", "marking", "==", "'+'", ":", "\n", "            ", "return", "'UP'", "\n", "", "elif", "monoDirection", "==", "'DOWN'", "and", "marking", "==", "'+'", ":", "\n", "            ", "return", "'DOWN'", "\n", "", "elif", "monoDirection", "==", "'UNK'", "or", "marking", "is", "None", ":", "# None = 'dot':", "\n", "            ", "return", "'UNK'", "\n", "", "else", ":", "\n", "            ", "self", ".", "printTree", "(", ")", "\n", "eprint", "(", "marking", ",", "monoDirection", ")", "\n", "raise", "ErrorCCGtree", "(", "'Unknown Mono monoDirection/functor!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.flip": [[2141, 2146], ["None"], "methods", ["None"], ["", "", "def", "flip", "(", "self", ",", "monoDirection", ")", ":", "\n", "        ", "''' flip UP and DOWN'''", "\n", "if", "monoDirection", "==", "'UP'", ":", "return", "'DOWN'", "\n", "elif", "monoDirection", "==", "'DOWN'", ":", "return", "'UP'", "\n", "else", ":", "return", "'UNK'", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.finalFlip": [[2147, 2160], ["getMono.CCGtree.flip", "getMono.CCGtree.flip"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.flip", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.flip"], ["", "def", "finalFlip", "(", "self", ",", "leafNode", ")", ":", "\n", "        ", "r''' if the leafNode is a verb: S\\NP, or (S\\NP)/NP, then check the\n        number of NP-. If there are odd number of NP-, flip its polarity '''", "\n", "if", "leafNode", ".", "cat", ".", "typeWOfeats", "==", "r'S\\NP'", ":", "# intransitive verb", "\n", "            ", "if", "leafNode", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "==", "'-'", ":", "\n", "                ", "leafNode", ".", "cat", ".", "monotonicity", "=", "self", ".", "flip", "(", "leafNode", ".", "cat", ".", "monotonicity", ")", "\n", "", "", "elif", "leafNode", ".", "cat", ".", "typeWOfeats", "==", "r'(S\\NP)/NP'", ":", "# transitive verb", "\n", "            ", "marking_outer_NP", "=", "leafNode", ".", "cat", ".", "semCat", ".", "IN", ".", "marking", "\n", "marking_inner_NP", "=", "leafNode", ".", "cat", ".", "semCat", ".", "OUT", ".", "IN", ".", "marking", "\n", "# if one is - and the other is +, then flip", "\n", "if", "(", "(", "marking_outer_NP", "==", "'-'", ")", "and", "(", "marking_inner_NP", "==", "'+'", ")", ")", "or", "(", "(", "marking_outer_NP", "==", "'+'", ")", "and", "(", "marking_inner_NP", "==", "'-'", ")", ")", ":", "\n", "                ", "leafNode", ".", "cat", ".", "monotonicity", "=", "self", ".", "flip", "(", "leafNode", ".", "cat", ".", "monotonicity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getImpSign": [[2161, 2171], ["getMono.CCGtree.getImpSignHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getImpSignHelper"], ["", "", "", "def", "getImpSign", "(", "self", ")", ":", "\n", "        ", "\"\"\" propagate the implicative sign from root to leaf\n        my algorithm:\n        * root has default +.\n        * Whenever one of the two child nodes has\n        impType, need to compute the impSign of the other child,\n        based on the impType\n        \"\"\"", "\n", "self", ".", "root", ".", "impSign", "=", "\"+\"", "\n", "self", ".", "getImpSignHelper", "(", "self", ".", "root", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getImpSignHelper": [[2172, 2201], ["len", "len", "getMono.CCGtree.getImpSignHelper", "getMono.CCGtree.getImpSignHelper", "getMono.CCGtree.getImpSignHelper", "getMono.CCGtree.computeImpSign"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getImpSignHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getImpSignHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getImpSignHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.computeImpSign"], ["", "def", "getImpSignHelper", "(", "self", ",", "node", ")", ":", "\n", "        ", "\"\"\" node is the parent \"\"\"", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "return", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "1", ":", "\n", "            ", "node", ".", "children", "[", "0", "]", ".", "impSign", "=", "node", ".", "impSign", "\n", "self", ".", "getImpSignHelper", "(", "node", ".", "children", "[", "0", "]", ")", "\n", "", "else", ":", "# 2 children", "\n", "# find out if any child has impType", "\n", "            ", "functor", ",", "argument", "=", "None", ",", "None", "\n", "# if len(node.children[0].children) == 0:", "\n", "#     if node.children[0].word in {\"not\", \"n't\"}:", "\n", "#         eprint(node.children[0])", "\n", "#         eprint(node.children[0].impType.impType_str)", "\n", "if", "node", ".", "children", "[", "0", "]", ".", "impType", ".", "impType_str", ":", "# children[0] has impType", "\n", "                ", "functor", "=", "node", ".", "children", "[", "0", "]", "\n", "argument", "=", "node", ".", "children", "[", "1", "]", "\n", "", "if", "node", ".", "children", "[", "1", "]", ".", "impType", ".", "impType_str", ":", "# children[1] has impType", "\n", "                ", "functor", "=", "node", ".", "children", "[", "1", "]", "\n", "argument", "=", "node", ".", "children", "[", "0", "]", "\n", "\n", "", "if", "functor", ":", "# if one child has impType", "\n", "                ", "functor", ".", "impSign", "=", "node", ".", "impSign", "\n", "argument", ".", "impSign", "=", "self", ".", "computeImpSign", "(", "functor", ")", "\n", "# eprint(functor)  # should be a implivative verb", "\n", "", "else", ":", "# just propagate up", "\n", "                ", "node", ".", "children", "[", "0", "]", ".", "impSign", "=", "node", ".", "impSign", "\n", "node", ".", "children", "[", "1", "]", ".", "impSign", "=", "node", ".", "impSign", "\n", "", "self", ".", "getImpSignHelper", "(", "node", ".", "children", "[", "0", "]", ")", "\n", "self", ".", "getImpSignHelper", "(", "node", ".", "children", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.computeImpSign": [[2202, 2214], ["None"], "methods", ["None"], ["", "", "def", "computeImpSign", "(", "self", ",", "functor", ")", ":", "\n", "        ", "\"\"\" if functor = forget +-|-+, then return the flipped impSign \"\"\"", "\n", "if", "functor", ".", "impSign", "==", "\"-\"", ":", "\n", "            ", "if", "\"nn\"", "in", "functor", ".", "impType", ".", "impType_str", ":", "return", "\"-\"", "\n", "if", "\"np\"", "in", "functor", ".", "impType", ".", "impType_str", ":", "return", "\"+\"", "\n", "else", ":", "return", "\"\\u2022\"", "# bullet", "\n", "", "elif", "functor", ".", "impSign", "==", "\"+\"", ":", "\n", "            ", "if", "\"pp\"", "in", "functor", ".", "impType", ".", "impType_str", ":", "return", "\"+\"", "\n", "if", "\"pn\"", "in", "functor", ".", "impType", ".", "impType_str", ":", "return", "\"-\"", "\n", "else", ":", "return", "\"\\u2022\"", "# bullet", "\n", "", "elif", "functor", ".", "impSign", "==", "\"\\u2022\"", ":", "\n", "            ", "return", "\"\\u2022\"", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.build_easyccg": [[2215, 2379], ["getMono.CCGtree.build_easyccg.findIdxStr"], "methods", ["None"], ["", "", "def", "build_easyccg", "(", "self", ",", "easyccg_tree_str", ",", "changes_onetree", "=", "None", ")", ":", "\n", "        ", "''' build the tree recursively from easyccg extended output string '''", "\n", "\n", "# the boundaries of nodes are marked by { and }, not ( or ), nor [ or ]", "\n", "# make sure there are same number of { and }", "\n", "try", ":", "assert", "easyccg_tree_str", ".", "count", "(", "'{'", ")", "==", "easyccg_tree_str", ".", "count", "(", "'}'", ")", "\n", "except", "AssertionError", ":", "\n", "            ", "eprint", "(", "'unequal num of { and }\\n#{: %s, #}: %s'", "%", "\n", "(", "easyccg_tree_str", ".", "count", "(", "'{'", ")", ",", "easyccg_tree_str", ".", "count", "(", "'}'", ")", ")", ")", "\n", "eprint", "(", "easyccg_tree_str", ")", "\n", "raise", "ErrorCCGtree", "(", "\"Error in build_easyccg()\"", ")", "\n", "\n", "", "def", "findIdxStr", "(", "s", ",", "char_set", ")", ":", "\n", "            ", "''' find all index of char in string s\n            char_set is the set of characters we want to find\n            return a list '''", "\n", "return", "[", "i", "for", "i", ",", "ch", "in", "enumerate", "(", "s", ")", "if", "ch", "in", "char_set", "]", "\n", "\n", "", "def", "getBrk", "(", "idx", ",", "easyccg_tree_str", ",", "idxBrk", ")", ":", "\n", "            ", "''' return the Brk, (< or >), based on idx of curr Brk '''", "\n", "return", "easyccg_tree_str", "[", "idxBrk", "[", "idx", "]", "]", "\n", "\n", "# don't need dummy root if reading from easyccg!", "\n", "# self.root = NonTermNode(depth=-1)", "\n", "\n", "# print(easyccg_tree_str)", "\n", "\n", "# find idx of ( and )", "\n", "", "idxBrk", "=", "findIdxStr", "(", "easyccg_tree_str", ",", "{", "'{'", ",", "'}'", "}", ")", "\n", "# print(idxBrk)", "\n", "\n", "numBrk", "=", "len", "(", "idxBrk", ")", "\n", "numLeafNode", "=", "0", "\n", "numNTN", "=", "0", "\n", "i", "=", "0", "\n", "stack", "=", "[", "]", "\n", "\n", "while", "i", "<", "numBrk", "-", "1", ":", "\n", "            ", "currBrk", "=", "getBrk", "(", "i", ",", "easyccg_tree_str", ",", "idxBrk", ")", "\n", "nextBrk", "=", "getBrk", "(", "i", "+", "1", ",", "easyccg_tree_str", ",", "idxBrk", ")", "\n", "# print('\\ncurr Brk', currBrk)", "\n", "# print('next Brk', nextBrk)", "\n", "\n", "# leaf node:", "\n", "# <L N John John NNP I-PER O N>", "\n", "# <L ((S[dcl]\\NP)/PP)/NP puts put VBZ O O ((S[dcl]\\NP)/PP)/NP>", "\n", "# Leaf - category - token - lemma - pos - NER - chunk - category?", "\n", "\n", "# non term node:", "\n", "# <T S[dcl]\\NP fa 0 2>", "\n", "# NTN - category - rule - start - end/span??", "\n", "\n", "# start of leaf node", "\n", "if", "(", "currBrk", "==", "'{'", ")", "and", "(", "nextBrk", "==", "'}'", ")", ":", "\n", "                ", "numLeafNode", "+=", "1", "\n", "node_str", "=", "easyccg_tree_str", "[", "(", "idxBrk", "[", "i", "]", "+", "2", ")", ":", "(", "idxBrk", "[", "i", "+", "1", "]", "-", "1", ")", "]", "\n", "# print(node_str)", "\n", "node_lst", "=", "node_str", ".", "split", "(", "' '", ")", "\n", "try", ":", "\n", "                    ", "if", "len", "(", "node_lst", ")", "==", "6", ":", "# CCGbank ['L', 'N/N', 'NNP', 'NNP', 'Pierre', 'N_73/N_73']", "\n", "                        ", "category_str", ",", "token", "=", "node_lst", "[", "1", "]", ",", "node_lst", "[", "4", "]", "\n", "lemma", "=", "None", ";", "pos", "=", "None", ";", "NER", "=", "None", ";", "chunk", "=", "None", "\n", "", "else", ":", "\n", "                        ", "category_str", ",", "token", ",", "lemma", ",", "pos", ",", "NER", ",", "chunk", "=", "node_lst", "[", "1", "]", ",", "node_lst", "[", "2", "]", ",", "node_lst", "[", "3", "]", ",", "node_lst", "[", "4", "]", ",", "node_lst", "[", "5", "]", ",", "node_lst", "[", "6", "]", "\n", "", "", "except", "IndexError", ":", "\n", "                    ", "eprint", "(", "'node_str index error: {}'", ".", "format", "(", "node_str", ")", ")", "\n", "raise", "ErrorCCGtree", "(", "\"Error in build_easyccg()\"", ")", "\n", "\n", "", "cat", "=", "Cat", "(", "originalType", "=", "category_str", ",", "word", "=", "token", ")", "\n", "lf_node", "=", "LeafNode", "(", "depth", "=", "0", ",", "cat", "=", "cat", ",", "chunk", "=", "chunk", ",", "entity", "=", "NER", ",", "\n", "lemma", "=", "lemma", ",", "pos", "=", "pos", ",", "span", "=", "1", ",", "\n", "start", "=", "numLeafNode", "-", "1", ",", "word", "=", "token", ")", "\n", "# print(lf_node)", "\n", "self", ".", "words", ".", "append", "(", "lf_node", ".", "word", ".", "upper", "(", ")", ")", "\n", "\n", "# add lf_node to the last ntn_node in stack", "\n", "try", ":", "\n", "                    ", "ntn_node", "=", "stack", "[", "-", "1", "]", "\n", "", "except", "IndexError", ":", "# when the sent is empty ", "\n", "                    ", "return", "\n", "", "lf_node", ".", "parent", "=", "ntn_node", "# set parent pointer", "\n", "if", "len", "(", "ntn_node", ".", "children", ")", "==", "1", ":", "# ntn_node already has a child, set sister", "\n", "                    ", "sister", "=", "ntn_node", ".", "children", "[", "0", "]", "\n", "lf_node", ".", "sisters", "=", "[", "sister", "]", "\n", "sister", ".", "sisters", "=", "[", "lf_node", "]", "\n", "", "ntn_node", ".", "children", ".", "append", "(", "lf_node", ")", "\n", "\n", "self", ".", "leafNodes", ".", "append", "(", "lf_node", ")", "# append to self.leafNodes", "\n", "i", "+=", "2", "\n", "\n", "# start of NT node", "\n", "", "elif", "(", "currBrk", "==", "'{'", ")", "and", "(", "nextBrk", "==", "'{'", ")", ":", "\n", "                ", "node_str", "=", "easyccg_tree_str", "[", "(", "idxBrk", "[", "i", "]", "+", "2", ")", ":", "(", "idxBrk", "[", "i", "+", "1", "]", "-", "2", ")", "]", "\n", "# print(node_str)", "\n", "node_lst", "=", "node_str", ".", "split", "(", "' '", ")", "\n", "try", ":", "\n", "                    ", "if", "len", "(", "node_lst", ")", "==", "4", ":", "# output from CCGbank", "\n", "                        ", "category_str", ",", "start", ",", "end", "=", "node_lst", "[", "1", "]", ",", "node_lst", "[", "2", "]", ",", "node_lst", "[", "3", "]", "\n", "rule", "=", "None", "\n", "", "else", ":", "\n", "                        ", "category_str", ",", "rule", ",", "start", ",", "end", "=", "node_lst", "[", "1", "]", ",", "node_lst", "[", "2", "]", ",", "node_lst", "[", "3", "]", ",", "node_lst", "[", "4", "]", "\n", "", "", "except", "IndexError", ":", "\n", "                    ", "eprint", "(", "'node_str index error: {}'", ".", "format", "(", "node_str", ")", ")", "\n", "raise", "ErrorCCGtree", "(", "\"Error in build_easyccg()\"", ")", "\n", "\n", "", "cat", "=", "Cat", "(", "originalType", "=", "category_str", ")", "\n", "ntn_node", "=", "NonTermNode", "(", "depth", "=", "0", ",", "cat", "=", "cat", ",", "ruleType", "=", "rule", ")", "\n", "# if rule == \"bx\":", "\n", "# eprint(ntn_node)", "\n", "# eprint(ntn_node.cat.semCat)", "\n", "# eprint(ntn_node.cat.semCat.IN)", "\n", "# eprint(ntn_node.cat.semCat.OUT)", "\n", "# eprint()", "\n", "# exit()", "\n", "stack", ".", "append", "(", "ntn_node", ")", "\n", "numNTN", "+=", "1", "\n", "i", "+=", "1", "\n", "\n", "# end of NT node, pop a node", "\n", "", "else", ":", "# (currBrk == '}')", "\n", "                ", "node_popped", "=", "stack", ".", "pop", "(", "-", "1", ")", "\n", "# print('*** length of stack ***: {}'.format(len(stack)))", "\n", "\n", "# if the stack is not empty,", "\n", "# then ntn_node is one child of the current last node in stack", "\n", "if", "len", "(", "stack", ")", "!=", "0", ":", "\n", "                    ", "last_node", "=", "stack", "[", "-", "1", "]", "\n", "node_popped", ".", "parent", "=", "last_node", "# set parent pointer", "\n", "if", "len", "(", "last_node", ".", "children", ")", "==", "1", ":", "# last_node already has a child, set sister", "\n", "                        ", "sister", "=", "last_node", ".", "children", "[", "0", "]", "\n", "node_popped", ".", "sisters", "=", "[", "sister", "]", "\n", "sister", ".", "sisters", "=", "[", "node_popped", "]", "\n", "", "last_node", ".", "children", ".", "append", "(", "node_popped", ")", "\n", "", "else", ":", "pass", "# nothing in stack; this never happens", "\n", "\n", "self", ".", "nonTermNodes", ".", "append", "(", "node_popped", ")", "\n", "# TODO get wholeStr of ntn_node", "\n", "i", "+=", "1", "\n", "\n", "# print('\\n\\n')", "\n", "# print('leaf:', numLeafNode)", "\n", "# print('NTN:', numNTN)", "\n", "\n", "# there is one last node in stack, pop it and attach it to dummy root", "\n", "", "", "try", ":", "assert", "len", "(", "stack", ")", "==", "1", "\n", "except", "AssertionError", ":", "return", "\n", "last_node", "=", "stack", ".", "pop", "(", "-", "1", ")", "\n", "self", ".", "root", "=", "last_node", "\n", "self", ".", "regetDepth", "(", ")", "\n", "\n", "dummy_root", "=", "NonTermNode", "(", "depth", "=", "-", "1", ")", "# dummy root, as the parent of real self.root", "\n", "dummy_root", ".", "children", "=", "[", "self", ".", "root", "]", "\n", "self", ".", "root", ".", "parent", "=", "dummy_root", "\n", "\n", "# self.printTree()", "\n", "self", ".", "getWholeStrAllNodes", "(", ")", "\n", "self", ".", "wholeStr", "=", "self", ".", "root", ".", "wholeStr", "\n", "# allNodes", "\n", "self", ".", "allNodes", "=", "self", ".", "leafNodes", "+", "self", ".", "nonTermNodes", "\n", "\n", "if", "changes_onetree", ":", "self", ".", "recover_tree", "(", "changes_onetree", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.recover_tree": [[2380, 2401], ["getMono.eprint", "getMono.eprint", "getMono.CCGtree.recover_at_most_least", "getMono.CCGtree.recover_a_lot_of", "getMono.eprint", "getMono.CCGtree.printSent"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.recover_at_most_least", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.recover_a_lot_of", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent"], ["", "def", "recover_tree", "(", "self", ",", "changes_onetree", ")", ":", "\n", "        ", "''' recover tree from changes: e.g. no => at most 5 '''", "\n", "# changes_onetree is a list of changes", "\n", "# [ {'before':at most 5, 'after':no, 'idx':0}, {} ... ]", "\n", "eprint", "(", "'changes:'", ")", "\n", "eprint", "(", "changes_onetree", ")", "\n", "changes", "=", "changes_onetree", "\n", "\n", "change_cnt", "=", "0", "\n", "\n", "for", "change", "in", "changes", ":", "\n", "# check whether it's `at most' or `at least' or `a-lot-of'", "\n", "            ", "if", "change", "[", "'after'", "]", "in", "{", "\"no\"", ",", "\"some\"", ",", "\"some-exactly\"", "}", ":", "\n", "                ", "self", ".", "recover_at_most_least", "(", "change", ",", "change_cnt", ")", "\n", "change_cnt", "+=", "1", "\n", "", "elif", "change", "[", "'before'", "]", "==", "\"a-lot-of\"", ":", "\n", "                ", "self", ".", "recover_a_lot_of", "(", ")", "# TODO", "\n", "", "else", ":", "\n", "                ", "eprint", "(", "\"*** something wrong in changes for sentence:\"", ")", "\n", "self", ".", "printSent", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.recover_at_most_least": [[2402, 2465], ["change[].startswith", "getMono.LeafNode", "getMono.LeafNode", "getMono.NonTermNode", "getMono.CCGtree.buildFromRoot", "change[].split", "len", "getMono.eprint", "getMono.eprint", "getMono.CCGtree.printSent_raw", "getMono.eprint", "sys.exit", "node_old.word.lower", "change[].lower", "getMono.eprint", "sys.exit", "getMono.Cat", "getMono.Cat", "getMono.Cat", "len", "change[].split"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent_raw", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "", "", "def", "recover_at_most_least", "(", "self", ",", "change", ",", "change_cnt", ")", ":", "\n", "        ", "\"\"\" recover 'at most' and 'at leat', more than, less than \"\"\"", "\n", "# change is a dict", "\n", "# {'before':at most 5, 'after':no, 'idx':0}", "\n", "if", "change_cnt", ">", "0", ":", "\n", "# we have already recovered something,", "\n", "# so len_sent increased the number of changes we recovered", "\n", "# since one change results in one more leafNode", "\n", "            ", "change", "[", "'len_sent'", "]", "+=", "change_cnt", "\n", "change", "[", "'idx'", "]", "+=", "change_cnt", "\n", "\n", "# step 1. Make sure len_sent is correct", "\n", "", "try", ":", "assert", "len", "(", "self", ".", "leafNodes", ")", "==", "change", "[", "'len_sent'", "]", "\n", "except", "AssertionError", ":", "\n", "            ", "eprint", "(", "len", "(", "self", ".", "leafNodes", ")", ")", "\n", "eprint", "(", "change", "[", "'len_sent'", "]", ")", "\n", "self", ".", "printSent_raw", "(", "sys", ".", "stderr", ")", "\n", "eprint", "(", "\"something wrong in recovering at most/least\"", ")", "\n", "exit", "(", ")", "\n", "\n", "", "node_old", "=", "self", ".", "leafNodes", "[", "change", "[", "\"idx\"", "]", "]", "# !!! replace this with `at most 5'", "\n", "try", ":", "assert", "node_old", ".", "word", ".", "lower", "(", ")", "==", "change", "[", "\"after\"", "]", ".", "lower", "(", ")", "\n", "except", "AssertionError", ":", "\n", "            ", "eprint", "(", "\"words don't match in recovering at most/least\"", ")", "\n", "exit", "(", ")", "\n", "\n", "# quant = exaclty", "\n", "", "if", "change", "[", "\"before\"", "]", ".", "startswith", "(", "\"exactly-\"", ")", ":", "\n", "            ", "quant", "=", "\"exactly\"", "\n", "", "else", ":", "# quant = at-most or at-least", "\n", "            ", "quant", "=", "\"-\"", ".", "join", "(", "change", "[", "\"before\"", "]", ".", "split", "(", "\"-\"", ")", "[", ":", "2", "]", ")", "\n", "\n", "# step 2. build 'at-most 5'", "\n", "#   at-most          5               let's say numbers are of type N/N", "\n", "#   (NP/N)/(N/N)     N/N", "\n", "#   ---------------------- fa        people", "\n", "#            NP/N                      N", "\n", "# TODO lemma, word?", "\n", "", "node_at_most", "=", "LeafNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "originalType", "=", "\"(NP/N)/(N/N)\"", ",", "\n", "word", "=", "quant", ")", ",", "\n", "chunk", "=", "None", ",", "entity", "=", "None", ",", "\n", "lemma", "=", "quant", ",", "pos", "=", "\"DT\"", ",", "span", "=", "None", ",", "start", "=", "None", ",", "\n", "word", "=", "quant", ",", "impType", "=", "None", ",", "fixed", "=", "True", ",", "\n", "note", "=", "quant", ")", "\n", "\n", "num_str", "=", "change", "[", "'before'", "]", ".", "split", "(", "\"-\"", ")", "[", "-", "1", "]", "\n", "node_num", "=", "LeafNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "originalType", "=", "\"N/N\"", ",", "\n", "word", "=", "num_str", ")", ",", "\n", "chunk", "=", "None", ",", "entity", "=", "None", ",", "\n", "lemma", "=", "num_str", ",", "pos", "=", "\"CD\"", ",", "span", "=", "None", ",", "start", "=", "None", ",", "\n", "word", "=", "num_str", ",", "impType", "=", "None", ",", "fixed", "=", "True", ")", "\n", "\n", "node_at_most_num", "=", "NonTermNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "originalType", "=", "\"NP/N\"", ")", ",", "\n", "ruleType", "=", "\"fa\"", ",", "note", "=", "quant", "+", "'-N'", ")", "\n", "node_at_most_num", ".", "children", "=", "[", "node_at_most", ",", "node_num", "]", "\n", "node_at_most", ".", "parent", ",", "node_num", ".", "parent", "=", "node_at_most_num", ",", "node_at_most_num", "\n", "\n", "# step 3. replace `no' with `at most 5'    kEY STEP!!", "\n", "node_old", ".", "parent", ".", "children", "[", "0", "]", "=", "node_at_most_num", "\n", "node_at_most_num", ".", "parent", "=", "node_old", ".", "parent", "\n", "\n", "# step 4. rebuld tree", "\n", "self", ".", "buildFromRoot", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.recover_a_lot_of": [[2469, 2488], ["getMono.CCGtree.buildFromRoot", "getMono.LeafNode", "lnode.parent.children.index", "getMono.Cat"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot"], ["", "def", "recover_a_lot_of", "(", "self", ")", ":", "\n", "        ", "\"\"\" recover. Change 'much' to 'a lot of' \"\"\"", "\n", "# step 1: find the node 'much'", "\n", "for", "lnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "if", "lnode", ".", "word", "==", "'much'", ":", "\n", "# step 2: replace it with 'a lot of'", "\n", "                ", "node_a_lot_of", "=", "LeafNode", "(", "depth", "=", "0", ",", "\n", "cat", "=", "Cat", "(", "originalType", "=", "lnode", ".", "cat", ".", "typeWOfeats", ",", "word", "=", "'a-lot-of'", ")", ",", "\n", "chunk", "=", "None", ",", "entity", "=", "None", ",", "lemma", "=", "'a-lot-of'", ",", "\n", "pos", "=", "lnode", ".", "pos", ",", "span", "=", "0", ",", "start", "=", "0", ",", "\n", "word", "=", "'a-lot-of'", ",", "impType", "=", "None", ",", "fixed", "=", "False", ",", "\n", "note", "=", "\"a-lot-of\"", ")", "\n", "# get idx of 'much'", "\n", "idx", "=", "lnode", ".", "parent", ".", "children", ".", "index", "(", "lnode", ")", "\n", "lnode", ".", "parent", ".", "children", "[", "idx", "]", "=", "node_a_lot_of", "\n", "node_a_lot_of", ".", "parent", "=", "lnode", ".", "parent", "\n", "lnode", ".", "parent", "=", "None", "\n", "\n", "", "", "self", ".", "buildFromRoot", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.build_CandC": [[2489, 2498], ["getMono.NonTermNode", "getMono.CCGtree.build_CandC_helper", "getMono.CCGtree.getWholeStrAllNodes", "getMono.CCGtree.recover_tree"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.build_CandC_helper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getWholeStrAllNodes", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.recover_tree"], ["", "def", "build_CandC", "(", "self", ",", "ccgXml", ",", "changes_onetree", "=", "None", ")", ":", "\n", "        ", "''' build the tree recursively from xml output of CandC '''", "\n", "self", ".", "root", "=", "NonTermNode", "(", "depth", "=", "-", "1", ")", "# dummy root; important for building the tree from candc", "\n", "self", ".", "build_CandC_helper", "(", "ccgXml", ",", "self", ".", "root", ",", "-", "1", ")", "\n", "self", ".", "getWholeStrAllNodes", "(", ")", "\n", "# allNodes", "\n", "self", ".", "allNodes", "=", "self", ".", "leafNodes", "+", "self", ".", "nonTermNodes", "\n", "# self.printTree()", "\n", "if", "changes_onetree", ":", "self", ".", "recover_tree", "(", "changes_onetree", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.build_CandC_helper": [[2499, 2529], ["nodeXml.find_all", "re.compile", "Node.children.copy", "Node.children.copy.remove", "getMono.CCGtree.nonTermNodes.append", "childXml.find", "getMono.Cat", "getMono.LeafNode", "Node.children.append", "getMono.ImpType", "getMono.CCGtree.leafNodes.append", "getMono.CCGtree.words.append", "getMono.Cat", "getMono.NonTermNode", "Node.children.append", "getMono.CCGtree.build_CandC_helper", "len", "LeafNode.word.upper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.copy", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.build_CandC_helper"], ["", "def", "build_CandC_helper", "(", "self", ",", "nodeXml", ",", "Node", ",", "depth", ")", ":", "\n", "        ", "for", "childXml", "in", "nodeXml", ".", "find_all", "(", "re", ".", "compile", "(", "'(lf|rule)'", ")", ",", "recursive", "=", "False", ")", ":", "\n", "            ", "if", "childXml", ".", "find", "(", "'lf'", ")", "is", "None", ":", "# if the child is leaf", "\n", "                ", "cat", "=", "Cat", "(", "**", "{", "'originalType'", ":", "childXml", "[", "'cat'", "]", ",", "'word'", ":", "childXml", "[", "'word'", "]", "}", ")", "\n", "leafNode", "=", "LeafNode", "(", "depth", "=", "depth", "+", "1", ",", "cat", "=", "cat", ",", "chunk", "=", "childXml", "[", "'chunk'", "]", ",", "\n", "entity", "=", "childXml", "[", "'entity'", "]", ",", "lemma", "=", "childXml", "[", "'lemma'", "]", ",", "\n", "pos", "=", "childXml", "[", "'pos'", "]", ",", "span", "=", "childXml", "[", "'span'", "]", ",", "\n", "start", "=", "childXml", "[", "'start'", "]", ",", "word", "=", "childXml", "[", "'word'", "]", ")", "\n", "Node", ".", "children", ".", "append", "(", "leafNode", ")", "\n", "leafNode", ".", "parent", "=", "Node", "\n", "leafNode", ".", "impType", "=", "ImpType", "(", "childXml", "[", "'lemma'", "]", ",", "childXml", "[", "'pos'", "]", ")", "\n", "self", ".", "leafNodes", ".", "append", "(", "leafNode", ")", "\n", "self", ".", "words", ".", "append", "(", "leafNode", ".", "word", ".", "upper", "(", ")", ")", "\n", "", "else", ":", "# non terminal node", "\n", "                ", "cat", "=", "Cat", "(", "childXml", "[", "'cat'", "]", ")", "\n", "childNode", "=", "NonTermNode", "(", "depth", "+", "1", ",", "cat", ",", "childXml", "[", "'type'", "]", ")", "\n", "Node", ".", "children", ".", "append", "(", "childNode", ")", "\n", "childNode", ".", "parent", "=", "Node", "\n", "self", ".", "build_CandC_helper", "(", "childXml", ",", "childNode", ",", "depth", "+", "1", ")", "\n", "\n", "# add sisters", "\n", "", "", "for", "childNode", "in", "Node", ".", "children", ":", "\n", "            ", "sisters", "=", "Node", ".", "children", ".", "copy", "(", ")", "\n", "sisters", ".", "remove", "(", "childNode", ")", "\n", "childNode", ".", "sisters", "=", "sisters", "\n", "", "if", "Node", ".", "depth", "!=", "-", "1", ":", "# to exclude the dummy None root", "\n", "            ", "self", ".", "nonTermNodes", ".", "append", "(", "Node", ")", "\n", "", "else", ":", "# the dummy root. The real root should be its only child", "\n", "            ", "assert", "len", "(", "Node", ".", "children", ")", "==", "1", "\n", "self", ".", "root", "=", "Node", ".", "children", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixQuantifier": [[2530, 2535], ["getMono.CCGtree.fixQuantifierHelper", "any", "getMono.CCGtree.fixQuantifierHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixQuantifierHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixQuantifierHelper"], ["", "", "def", "fixQuantifier", "(", "self", ")", ":", "\n", "        ", "if", "not", "any", "(", "[", "quant", "in", "self", ".", "words", "for", "quant", "in", "QUANTIFIERS_TO_FIX", "]", ")", ":", "\n", "            ", "return", "\n", "", "flag", "=", "self", ".", "fixQuantifierHelper", "(", ")", "\n", "while", "flag", ":", "flag", "=", "self", ".", "fixQuantifierHelper", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixQuantifierHelper": [[2536, 2689], ["range", "len", "getMono.LeafNode", "getMono.CCGtree.buildFromRoot", "getMono.eprint", "getMono.LeafNode", "getMono.NonTermNode", "getMono.CCGtree.buildFromRoot", "getMono.CCGtree.leafNodes[].word.upper", "hasattr", "getMono.eprint", "getMono.CCGtree.leafNodes[].word.upper", "getMono.Cat", "getMono.Cat", "getMono.Cat", "nodeMost.parent.sisters[].children[].word.upper", "quant.lower", "quant.lower"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "fixQuantifierHelper", "(", "self", ")", ":", "\n", "        ", "\"\"\" fix the cat of some quantifiers and the tree structure\n        return False if there are no more quantifiers to fix\n        - QUANTIFIERS_TO_FIX:\n        'MOST', 'MANY', 'FEW', 'SEVERAL', 'ONE', 2, 3, 4, 5\n\n        return True: needs to check other quantifiers\n        return False: every quantifier fixed!\n        \"\"\"", "\n", "# first identify the quantifier to fix", "\n", "quant", "=", "None", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "if", "lfnode", ".", "fixed", ":", "continue", "# already fixed!", "\n", "if", "lfnode", ".", "wholeStr", "in", "QUANTIFIERS_TO_FIX", ":", "\n", "                ", "if", "lfnode", ".", "cat", ".", "typeWOfeats", "==", "r\"N/N\"", "and", "lfnode", ".", "parent", ".", "ruleType", "==", "\"fa\"", ":", "\n", "# only fix quant if N/N, when NP/N, don't fix it", "\n", "                    ", "quant", "=", "lfnode", ".", "wholeStr", "\n", "# eprint(quant)", "\n", "break", "\n", "", "", "", "if", "quant", "is", "None", ":", "return", "False", "# everything fixed!!", "\n", "\n", "# here we only want to fix \"most\" as in \"most people are ...\"", "\n", "# so we want to make sure that we are", "\n", "# NOT getting \"at most N\"", "\n", "nodeMost", "=", "None", "\n", "nodeMostID", "=", "None", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "leafNodes", ")", ")", ":", "\n", "            ", "if", "self", ".", "leafNodes", "[", "i", "]", ".", "word", ".", "upper", "(", ")", "==", "quant", "and", "self", ".", "leafNodes", "[", "i", "]", ".", "cat", ".", "typeWOfeats", "==", "r\"N/N\"", ":", "\n", "                ", "if", "i", "==", "0", ":", "# first word in sent", "\n", "                    ", "nodeMost", "=", "self", ".", "leafNodes", "[", "i", "]", "\n", "nodeMostID", "=", "0", "\n", "", "else", ":", "# not first word", "\n", "# make sure we are not fixing:", "\n", "# at most, a few, exaclty 2", "\n", "                    ", "if", "self", ".", "leafNodes", "[", "i", "-", "1", "]", ".", "word", ".", "upper", "(", ")", "in", "{", "'AT'", ",", "'A'", ",", "'LEAST'", ",", "'EXACTLY'", "}", ":", "\n", "                        ", "self", ".", "leafNodes", "[", "i", "]", ".", "fixed", "=", "True", "\n", "", "else", ":", "# it's not at most, a few; needs fixing", "\n", "                        ", "nodeMost", "=", "self", ".", "leafNodes", "[", "i", "]", "\n", "nodeMostID", "=", "i", "\n", "\n", "# the following works when there is no RC: most people are ...", "\n", "", "", "", "", "flag_RC", "=", "False", "\n", "if", "nodeMost", ":", "\n", "            ", "if", "nodeMost", ".", "parent", ".", "sisters", ":", "\n", "                ", "if", "nodeMost", ".", "parent", ".", "sisters", "[", "0", "]", ".", "children", ":", "\n", "                    ", "if", "hasattr", "(", "nodeMost", ".", "parent", ".", "sisters", "[", "0", "]", ".", "children", "[", "0", "]", ",", "'word'", ")", ":", "\n", "                        ", "if", "nodeMost", ".", "parent", ".", "sisters", "[", "0", "]", ".", "children", "[", "0", "]", ".", "word", ".", "upper", "(", ")", "in", "{", "\"WHO\"", ",", "\"WHICH\"", ",", "\"THAT\"", "}", ":", "\n", "                            ", "flag_RC", "=", "True", "\n", "\n", "", "", "", "", "", "if", "not", "flag_RC", ":", "# no RC", "\n", "            ", "if", "nodeMost", ":", "# fix trees involving 'most'", "\n", "# BEFORE:", "\n", "#   most    dogs", "\n", "#    N/N      N  <= nodeMostSister", "\n", "# fa--------------", "\n", "#          N  <= nodeN", "\n", "# lex-------------", "\n", "#          NP  <= nodeNP", "\n", "\n", "# AFTER:", "\n", "#   most NP/N     dogs N", "\n", "# fa----------------------", "\n", "#              NP", "\n", "                ", "nodeN", "=", "nodeMost", ".", "parent", "\n", "nodeNP", "=", "nodeN", ".", "parent", "\n", "try", ":", "\n", "                    ", "nodeMostSister", "=", "nodeMost", ".", "sisters", "[", "0", "]", "\n", "", "except", "IndexError", ":", "\n", "                    ", "return", "False", "# consider it as fixed", "\n", "\n", "# get new nodeMost", "\n", "", "nodeMostNew", "=", "LeafNode", "(", "depth", "=", "nodeMost", ".", "depth", "-", "1", ",", "cat", "=", "Cat", "(", "'NP/N'", ",", "quant", ".", "lower", "(", ")", ")", ",", "\n", "chunk", "=", "nodeMost", ".", "chunk", ",", "entity", "=", "nodeMost", ".", "entity", ",", "\n", "lemma", "=", "nodeMost", ".", "lemma", ",", "pos", "=", "'DT'", ",", "\n", "span", "=", "nodeMost", ".", "span", ",", "start", "=", "nodeMost", ".", "start", ",", "\n", "word", "=", "nodeMost", ".", "word", ",", "impType", "=", "None", ",", "fixed", "=", "True", ")", "\n", "# nodeMostNew.cat.semCat.OUT.marking = '+'", "\n", "# nodeMostNew.cat.semCat.marking = None", "\n", "# nodeMostNew.sisters = [nodeMostSister]", "\n", "nodeMostNew", ".", "parent", "=", "nodeNP", "\n", "\n", "# fix nodeMostSister, and its depth", "\n", "nodeMostSister", ".", "parent", "=", "nodeNP", "\n", "# self.decreaseDepth(nodeMostSister)", "\n", "\n", "# fix nodeNP", "\n", "nodeNP", ".", "ruleType", "=", "'fa'", "\n", "nodeNP", ".", "children", "=", "[", "nodeMostNew", ",", "nodeMostSister", "]", "\n", "\n", "# fix self.leafNodes", "\n", "# self.leafNodes[nodeMostID] = nodeMostNew", "\n", "\n", "# rebuild tree", "\n", "self", ".", "buildFromRoot", "(", ")", "\n", "\n", "return", "True", "\n", "\n", "", "else", ":", "# nodeMost = None, i.e. it's \"AT MOST\", or no 'most' in sent", "\n", "                ", "return", "True", "\n", "", "", "else", ":", "\n", "# ---------------------------------", "\n", "# there is RC", "\n", "\n", "# before:  (from easyccg)", "\n", "# most    Europeans         who          VP", "\n", "# N/N         N = node_N    (N\\N)/(S\\NP)    S\\NP", "\n", "# ---------------           ---------------------", "\n", "#        N                    N\\N  =  node_1", "\n", "#       --------------------------", "\n", "#                   N", "\n", "#         ------------------- lex", "\n", "#                  NP  =  node_NP", "\n", "\n", "# after:", "\n", "#                         who          VP", "\n", "#                      (N\\N)/(S\\NP)    S\\NP", "\n", "#          Europeans  ---------------------", "\n", "#              N            N\\N  =  node_1", "\n", "#   most     ------------------ba", "\n", "#   NP/N              N  =  node_2", "\n", "#  ----------------------fa", "\n", "#              NP   =  node_NP", "\n", "            ", "if", "nodeMost", ":", "\n", "                ", "eprint", "(", "'\\nfixing\\n\\tmost/many/several + N + RC'", ")", "\n", "node_most_new", "=", "LeafNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "'NP/N'", ",", "word", "=", "quant", ".", "lower", "(", ")", ")", ",", "\n", "chunk", "=", "None", ",", "entity", "=", "None", ",", "\n", "lemma", "=", "nodeMost", ".", "lemma", ",", "pos", "=", "'DT'", ",", "span", "=", "None", ",", "start", "=", "None", ",", "\n", "word", "=", "nodeMost", ".", "word", ",", "impType", "=", "None", ",", "fixed", "=", "True", ")", "\n", "node_N", "=", "nodeMost", ".", "sisters", "[", "0", "]", "\n", "node_1", "=", "nodeMost", ".", "parent", ".", "sisters", "[", "0", "]", "\n", "node_NP", "=", "nodeMost", ".", "parent", ".", "parent", ".", "parent", "\n", "\n", "# something wrong, cannot fix it", "\n", "if", "node_NP", ".", "cat", ".", "typeWOfeats", "!=", "'NP'", ":", "\n", "                    ", "eprint", "(", "'something wrong fixing most + N + RC; cannot fix it'", ")", "\n", "nodeMost", ".", "fixed", "=", "True", "\n", "return", "False", "\n", "\n", "# combine node_N and node_1", "\n", "", "node_2", "=", "NonTermNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "'N'", ")", ",", "ruleType", "=", "'ba'", ")", "\n", "node_2", ".", "children", "=", "[", "node_N", ",", "node_1", "]", "\n", "node_N", ".", "parent", ",", "node_1", ".", "parent", "=", "node_2", ",", "node_2", "\n", "\n", "node_NP", ".", "ruleType", "=", "'fa'", "\n", "node_NP", ".", "children", "=", "[", "node_most_new", ",", "node_2", "]", "\n", "node_most_new", ".", "parent", ",", "node_2", ".", "parent", "=", "node_NP", ",", "node_NP", "\n", "\n", "self", ".", "buildFromRoot", "(", ")", "\n", "return", "True", "\n", "\n", "", "else", ":", "# nodeMost = None, i.e. it's \"AT MOST\", or no 'most' in sent", "\n", "                ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixRC": [[2690, 2809], ["len", "any", "getMono.CCGtree.getLeftMostLeaf", "getMono.CCGtree.word.upper", "getMono.CCGtree.getLeftMostLeaf", "getMono.CCGtree.word.upper", "getMono.NonTermNode", "NonTermNode.children.append", "getMono.NonTermNode", "NonTermNode.children.append", "NonTermNode.children.append", "getMono.NonTermNode", "NonTermNode.children.append", "len", "getMono.CCGtree.regetDepth", "getMono.CCGtree.nonTermNodes.remove", "getMono.CCGtree.nonTermNodes.append", "getMono.CCGtree.nonTermNodes.append", "getMono.CCGtree.nonTermNodes.append", "getMono.Cat", "getMono.Cat", "getMono.Cat", "getMono.eprint"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getLeftMostLeaf", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getLeftMostLeaf", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.regetDepth", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "", "", "def", "fixRC", "(", "self", ")", ":", "\n", "        ", "RelPronouns", "=", "[", "'WHO'", ",", "'WHOM'", ",", "'THAT'", ",", "'WHICH'", "]", "\n", "if", "not", "any", "(", "x", "in", "self", ".", "words", "for", "x", "in", "RelPronouns", ")", ":", "\n", "            ", "return", "# does not have RC", "\n", "# -----------------------------", "\n", "# fix trees involving Relative Clauses", "\n", "# -----------------------------", "\n", "\n", "# -----------------------------", "\n", "# we can only handle:", "\n", "# **no/some/every/most young man** that every woman hits", "\n", "# -----------------------------", "\n", "\n", "# BEFORE:", "\n", "# (COULD BE Object RC, or Subject RC)", "\n", "# no             young man         that            every woman hits OR eats pizzas", "\n", "# NP/N <= nodeQ  N <= nodeN         (NP\\NP)/(S\\/NP)       S/NP or S\\NP", "\n", "# -----------------              ---------------------------------", "\n", "#       NP  <= nodeFakeNP        NP\\NP  <= nodeRC", "\n", "#       -----------------------------------------", "\n", "#                      NP  <= nodeTrueNP", "\n", "\n", "# AFTER:", "\n", "#                      that            every woman hits OR eats pizzas", "\n", "#       young man      (NP\\NP)/(S\\/NP)       S/NP or S\\NP", "\n", "#       ---------     ----------------------------------", "\n", "#          N <= nodeN            NP\\NP  <= nodeRC", "\n", "#         --------- lex", "\n", "#  no          NP <= nodeNewNP1 (lex rule is one rule in C&C)", "\n", "# ----         ---------------------------------- ba", "\n", "#  NP/N <= nodeQ                NP <= nodeNewNP2", "\n", "#                           ---------------------- unlex", "\n", "#                                  N <= nodeNtmp", "\n", "#          TODO: both should be functor:", "\n", "#          TODO: one is quantifier, the other is NP", "\n", "#          TODO: for now I will change NP to N", "\n", "#  --------------------------------------- fa", "\n", "#                NP  <= nodeTrueNP", "\n", "\n", "", "numNonTermNodes_before", "=", "len", "(", "self", ".", "nonTermNodes", ")", "\n", "\n", "# test if the first word in the preceeding NP is a quantifier", "\n", "for", "node", "in", "self", ".", "nonTermNodes", ":", "\n", "            ", "if", "node", ".", "cat", ".", "typeWOfeats", "==", "r'NP\\NP'", ":", "\n", "                ", "nodeRC", "=", "node", "\n", "leftMostWordRC", "=", "self", ".", "getLeftMostLeaf", "(", "nodeRC", ")", "\n", "# print(\"the leftmost word of potential RC is:\", leftMostWordRC.word)", "\n", "\n", "if", "leftMostWordRC", ".", "word", ".", "upper", "(", ")", "in", "RelPronouns", ":", "\n", "# this is RC", "\n", "                    ", "nodeTrueNP", "=", "nodeRC", ".", "parent", "\n", "# left most word of preceeding noun", "\n", "leftMostWordPreN", "=", "self", ".", "getLeftMostLeaf", "(", "nodeTrueNP", ")", "\n", "# print('leftMostWordPreN.word:',leftMostWordPreN.word)", "\n", "if", "leftMostWordPreN", ".", "word", ".", "upper", "(", ")", "in", "[", "\n", "'NO'", ",", "'SOME'", ",", "'EVERY'", ",", "'MOST'", ",", "'ANY'", ",", "'ALL'", ",", "\n", "'EACH'", ",", "'THE'", "]", ":", "\n", "# quantifier", "\n", "                        ", "nodeFakeNP", "=", "nodeTrueNP", ".", "children", "[", "0", "]", "\n", "assert", "nodeFakeNP", ".", "children", "[", "0", "]", "==", "leftMostWordPreN", "\n", "nodeN", "=", "nodeFakeNP", ".", "children", "[", "1", "]", "\n", "nodeQ", "=", "nodeFakeNP", ".", "children", "[", "0", "]", "\n", "\n", "# ----- real work starts here ----- #", "\n", "# add lex rule to make nodeN to NP (nodeNewNP1)", "\n", "nodeNewNP1", "=", "NonTermNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "'NP'", ")", ",", "\n", "ruleType", "=", "'lex'", ")", "\n", "nodeN", ".", "parent", "=", "nodeNewNP1", "\n", "nodeNewNP1", ".", "children", ".", "append", "(", "nodeN", ")", "\n", "nodeN", ".", "sisters", "=", "[", "]", "\n", "nodeNewNP1", ".", "sisters", "=", "[", "nodeRC", "]", "\n", "nodeRC", ".", "sisters", "=", "[", "nodeNewNP1", "]", "\n", "\n", "# nodeNewNP1 + nodeRC = nodeNewNP2 (ba rule)", "\n", "nodeNewNP2", "=", "NonTermNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "'NP'", ")", ",", "\n", "ruleType", "=", "'ba'", ")", "\n", "nodeNewNP2", ".", "children", ".", "append", "(", "nodeNewNP1", ")", "\n", "nodeNewNP2", ".", "children", ".", "append", "(", "nodeRC", ")", "\n", "nodeNewNP1", ".", "parent", "=", "nodeNewNP2", "\n", "nodeRC", ".", "parent", "=", "nodeNewNP2", "\n", "nodeNewNP2", ".", "sisters", "=", "[", "]", "\n", "\n", "# nodeNewNP2 -> nodeNtmp, unlex rule", "\n", "nodeNtmp", "=", "NonTermNode", "(", "depth", "=", "0", ",", "cat", "=", "Cat", "(", "'N'", ")", ",", "\n", "ruleType", "=", "'unlex'", ")", "\n", "nodeNtmp", ".", "children", ".", "append", "(", "nodeNewNP2", ")", "\n", "nodeNewNP2", ".", "parent", "=", "nodeNtmp", "\n", "nodeNtmp", ".", "sisters", "=", "[", "nodeQ", "]", "\n", "nodeQ", ".", "sisters", "=", "[", "nodeNtmp", "]", "\n", "\n", "# nodeQ + nodeNtmp = nodeTrueNP", "\n", "nodeTrueNP", ".", "children", "=", "[", "nodeQ", ",", "nodeNtmp", "]", "\n", "nodeQ", ".", "parent", "=", "nodeTrueNP", "\n", "nodeNtmp", ".", "parent", "=", "nodeTrueNP", "\n", "nodeTrueNP", ".", "ruleType", "=", "'fa'", "\n", "\n", "# fix self.nonTermNodes", "\n", "try", ":", "\n", "                            ", "self", ".", "nonTermNodes", ".", "remove", "(", "nodeFakeNP", ")", "\n", "self", ".", "nonTermNodes", ".", "append", "(", "nodeNewNP1", ")", "\n", "self", ".", "nonTermNodes", ".", "append", "(", "nodeNewNP2", ")", "\n", "self", ".", "nonTermNodes", ".", "append", "(", "nodeNtmp", ")", "\n", "", "except", "ValueError", ":", "\n", "                            ", "eprint", "(", "'error removing node from nonTermNodes'", ")", "\n", "pass", "\n", "\n", "# sanity check: after the fix, 2 more NonTermNodes for each RC", "\n", "# could have multiple RCs", "\n", "", "numNonTermNodes_after", "=", "len", "(", "self", ".", "nonTermNodes", ")", "\n", "assert", "(", "numNonTermNodes_before", "-", "numNonTermNodes_after", ")", "%", "2", "==", "0", "\n", "\n", "# recalculate depth", "\n", "self", ".", "regetDepth", "(", ")", "\n", "# ----- real work ends here ----- #", "\n", "", "", "else", ":", "\n", "                    ", "continue", "\n", "\n", "# print('fixing RC done!\\n')", "\n", "", "", "", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixNot": [[2810, 2871], ["getMono.Cat", "getMono.ImpType", "getMono.LeafNode", "getMono.Cat", "getMono.NonTermNode", "getMono.CCGtree.buildFromRoot", "lfnode.word.lower", "getMono.eprint", "lfnode.parent.children[].word.lower", "node_not_s.append"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.buildFromRoot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "def", "fixNot", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        fix: did not, do not, does not\n        BEFORE:\n             did               not\n        (S\\NP)/(S\\NP)      (S\\NP)\\(S\\NP)\n        bx--------------------------------            sleep\n                (S\\NP)/(S\\NP) <- node_did_not       S\\NP  <- node_VP\n                fa--------------------------------------\n                             S\\NP  <- node_whole_VP\n\n        AFTER:\n                             not **change cat**      sleep\n                         (S\\NP)/(S\\NP)               S\\NP\n            did         fa--------------------------------\n        (S\\NP)/(S\\NP)              S\\NP  <- node_new\n        fa---------------------------------\n                         S\\NP   <- node_whole_VP\n        \"\"\"", "\n", "if", "(", "\"NOT\"", "not", "in", "self", ".", "words", ")", "and", "(", "\"N'T\"", "not", "in", "self", ".", "words", ")", ":", "return", "\n", "# find node_not", "\n", "node_not_s", "=", "[", "]", "# may have multiple \"did not\"", "\n", "for", "lfnode", "in", "self", ".", "leafNodes", ":", "\n", "            ", "if", "lfnode", ".", "word", ".", "lower", "(", ")", "in", "{", "\"not\"", ",", "\"n't\"", "}", ":", "\n", "                ", "if", "lfnode", ".", "parent", ".", "children", "[", "0", "]", ".", "word", ".", "lower", "(", ")", "in", "{", "\"do\"", ",", "\"does\"", ",", "\"did\"", ",", "\"is\"", "}", ":", "# TODO \"is\" ok here?", "\n", "                    ", "if", "lfnode", ".", "cat", ".", "typeWOpolarity", "==", "r\"(S\\NP)\\(S\\NP)\"", ":", "\n", "                        ", "node_not_s", ".", "append", "(", "lfnode", ")", "\n", "", "", "", "", "for", "node_not", "in", "node_not_s", ":", "\n", "# name other nodes", "\n", "            ", "node_did", "=", "node_not", ".", "parent", ".", "children", "[", "0", "]", "\n", "node_did_not", "=", "node_not", ".", "parent", "\n", "node_VP", "=", "node_did_not", ".", "sisters", "[", "0", "]", "\n", "node_whole_VP", "=", "node_did_not", ".", "parent", "\n", "\n", "# check node_VP.cat = S\\NP", "\n", "if", "node_VP", ".", "cat", ".", "typeWOfeats", "!=", "r\"S\\NP\"", ":", "\n", "                ", "eprint", "(", "\"warning: something weird in fixNot()\"", ")", "\n", "continue", "# then don't fix this 'not'", "\n", "\n", "# make a new node_not, could be NOT or N'T", "\n", "", "cat", "=", "Cat", "(", "originalType", "=", "r\"(S\\NP)/(S\\NP)\"", ",", "word", "=", "node_not", ".", "word", ")", "\n", "impType", "=", "ImpType", "(", "lemma", "=", "node_not", ".", "lemma", ",", "pos", "=", "node_not", ".", "pos", ")", "\n", "node_not", "=", "LeafNode", "(", "depth", "=", "0", ",", "cat", "=", "cat", ",", "chunk", "=", "\"I-VP\"", ",", "entity", "=", "\"O\"", ",", "\n", "lemma", "=", "node_not", ".", "lemma", ",", "pos", "=", "\"RB\"", ",", "span", "=", "\"1\"", ",", "\n", "start", "=", "node_not", ".", "start", ",", "word", "=", "node_not", ".", "word", ",", "\n", "impType", "=", "impType", ")", "\n", "\n", "# fix it", "\n", "cat", "=", "Cat", "(", "originalType", "=", "r\"S\\NP\"", ",", "word", "=", "None", ")", "\n", "node_new", "=", "NonTermNode", "(", "depth", "=", "0", ",", "cat", "=", "cat", ",", "ruleType", "=", "\"fa\"", ",", "wholeStr", "=", "\"\"", ")", "\n", "# fix parent children pointer", "\n", "node_new", ".", "children", "=", "[", "node_not", ",", "node_VP", "]", "\n", "node_new", ".", "parent", "=", "node_whole_VP", "\n", "\n", "node_VP", ".", "parent", "=", "node_new", "\n", "node_not", ".", "parent", "=", "node_new", "\n", "node_did", ".", "parent", "=", "node_whole_VP", "\n", "\n", "node_whole_VP", ".", "children", "=", "[", "node_did", ",", "node_new", "]", "\n", "self", ".", "buildFromRoot", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.regetDepth": [[2872, 2875], ["getMono.CCGtree.regetDepthHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.regetDepthHelper"], ["", "", "def", "regetDepth", "(", "self", ")", ":", "\n", "        ", "''' calculate depth again, just need to traverse the tree '''", "\n", "self", ".", "regetDepthHelper", "(", "self", ".", "root", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.regetDepthHelper": [[2876, 2882], ["len", "getMono.CCGtree.regetDepthHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.regetDepthHelper"], ["", "def", "regetDepthHelper", "(", "self", ",", "node", ",", "depth", ")", ":", "\n", "        ", "node", ".", "depth", "=", "depth", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "\n", "            ", "return", "\n", "", "for", "child", "in", "node", ".", "children", ":", "\n", "            ", "self", ".", "regetDepthHelper", "(", "child", ",", "depth", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getLeftMostLeaf": [[2883, 2895], ["len"], "methods", ["None"], ["", "", "def", "getLeftMostLeaf", "(", "self", ",", "node", ")", ":", "\n", "        ", "''' return the left most leaf of all the nodes under node\n        X    Y        Z\n        ------\n           A\n           -------------\n                 B\n        getLeftMostLeaf(B) will return X\n        '''", "\n", "while", "len", "(", "node", ".", "children", ")", "!=", "0", ":", "\n", "            ", "node", "=", "node", ".", "children", "[", "0", "]", "\n", "", "return", "node", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.decreaseDepth": [[2896, 2901], ["len", "getMono.CCGtree.decreaseDepth"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.decreaseDepth"], ["", "def", "decreaseDepth", "(", "self", ",", "node", ")", ":", "\n", "        ", "node", ".", "depth", "-=", "1", "\n", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "return", "\n", "else", ":", "\n", "            ", "for", "n", "in", "node", ".", "children", ":", "self", ".", "decreaseDepth", "(", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getSubjPredISA": [[2902, 2921], ["n.wholeStr.upper"], "methods", ["None"], ["", "", "def", "getSubjPredISA", "(", "self", ")", ":", "\n", "        ", "'''\n        find the subject and predicate in ISA sentence\n        e.g. Tom Hanks is a cat.  # next step: Tom Hanks is a cute cat.\n        returns: [Tom Hanks, cat]\n        '''", "\n", "ISnode", "=", "None", "\n", "for", "n", "in", "self", ".", "leafNodes", ":", "\n", "            ", "if", "n", ".", "wholeStr", ".", "upper", "(", ")", "==", "\"IS\"", ":", "\n", "                ", "ISnode", "=", "n", "\n", "break", "\n", "# print(ISnode)", "\n", "", "", "if", "ISnode", "is", "not", "None", ":", "\n", "# subj is ISnode.parent.sisters[0]; pred is ISnode.sisters[0].children[1]", "\n", "            ", "subj", "=", "ISnode", ".", "parent", ".", "sisters", "[", "0", "]", "\n", "pred", "=", "ISnode", ".", "sisters", "[", "0", "]", ".", "children", "[", "1", "]", "\n", "return", "(", "subj", ",", "pred", ")", "\n", "", "else", ":", "\n", "            ", "return", "(", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.LeafNode.__init__": [[2923, 2945], ["lemma.upper", "getMono.ImpType"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "depth", ",", "cat", ",", "chunk", ",", "entity", ",", "lemma", ",", "pos", ",", "span", ",", "start", ",", "word", ",", "impType", "=", "None", ",", "fixed", "=", "False", ",", "note", "=", "None", ",", "number", "=", "None", ")", ":", "\n", "        ", "self", ".", "parent", "=", "None", ";", "self", ".", "children", "=", "[", "]", ";", "self", ".", "sisters", "=", "[", "]", "\n", "self", ".", "depth", "=", "depth", "\n", "\n", "self", ".", "cat", "=", "cat", ";", "self", ".", "chunk", "=", "chunk", ";", "self", ".", "entity", "=", "entity", "\n", "self", ".", "lemma", "=", "lemma", ";", "self", ".", "pos", "=", "pos", ";", "self", ".", "span", "=", "span", "\n", "self", ".", "start", "=", "start", "\n", "# --------------", "\n", "# self.word = word", "\n", "# self.wholeStr = word.upper()", "\n", "self", ".", "word", "=", "lemma", "\n", "self", ".", "wholeStr", "=", "lemma", ".", "upper", "(", ")", "\n", "self", ".", "word_raw", "=", "word", "\n", "# --------------", "\n", "self", ".", "visited", "=", "True", "# whether visited or not when assigning plus/minus sign", "\n", "self", ".", "span_id", "=", "None", "# an id, for mytree2transccg.py", "\n", "if", "impType", "is", "None", ":", "self", ".", "impType", "=", "ImpType", "(", ")", "\n", "else", ":", "self", ".", "impType", "=", "impType", "# type of implicative", "\n", "self", ".", "impSign", "=", "None", "# sign of implicative", "\n", "self", ".", "fixed", "=", "fixed", "# when it's quantifier (most, many), whether it has been fixed", "\n", "self", ".", "note", "=", "note", "# note: \"at-most\", \"at-least\", \"at-most-N\", \"at-least-N\"", "\n", "self", ".", "number", "=", "number", "# sg = singular, pl = plural", "\n", "", "def", "assign_new_word", "(", "self", ",", "word", ",", "number", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.LeafNode.assign_new_word": [[2945, 2949], ["getMono.LeafNode.lemma.upper"], "methods", ["None"], ["", "def", "assign_new_word", "(", "self", ",", "word", ",", "number", ")", ":", "\n", "        ", "self", ".", "word", "=", "self", ".", "lemma", "=", "self", ".", "word_raw", "=", "word", "\n", "self", ".", "wholeStr", "=", "self", ".", "lemma", ".", "upper", "(", ")", "\n", "self", ".", "number", "=", "number", "\n", "", "def", "copy", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.LeafNode.copy": [[2949, 2953], ["copy.deepcopy", "getMono.LeafNode"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "cat", "=", "copy", ".", "deepcopy", "(", "self", ".", "cat", ")", "# recursively create new copy", "\n", "return", "LeafNode", "(", "self", ".", "depth", ",", "cat", ",", "self", ".", "chunk", ",", "self", ".", "entity", ",", "self", ".", "lemma", ",", "\n", "self", ".", "pos", ",", "self", ".", "span", ",", "self", ".", "start", ",", "self", ".", "word", ")", "\n", "# def word_wholeStr(self):", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.LeafNode.__str__": [[2956, 2960], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"lf: {} {} {} {} {} mono:{} imp:{} {}\"", ".", "format", "(", "self", ".", "cat", ",", "self", ".", "cat", ".", "semCat", ",", "self", ".", "word", ",", "self", ".", "pos", ",", "\n", "self", ".", "depth", ",", "self", ".", "cat", ".", "monotonicity", ",", "\n", "self", ".", "impSign", ",", "self", ".", "visited", ")", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.LeafNode.__repr__": [[2960, 2962], ["getMono.LeafNode.__str__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.__init__": [[2964, 2976], ["wholeStr.upper", "getMono.ImpType"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "depth", "=", "None", ",", "cat", "=", "None", ",", "ruleType", "=", "None", ",", "wholeStr", "=", "''", ",", "impType", "=", "None", ",", "note", "=", "None", ",", "number", "=", "None", ")", ":", "\n", "        ", "self", ".", "parent", "=", "None", ";", "self", ".", "children", "=", "[", "]", ";", "self", ".", "sisters", "=", "[", "]", "\n", "self", ".", "depth", "=", "depth", "\n", "self", ".", "cat", "=", "cat", ";", "self", ".", "ruleType", "=", "ruleType", "\n", "self", ".", "wholeStr", "=", "wholeStr", ".", "upper", "(", ")", "\n", "self", ".", "visited", "=", "False", "# whether visited or not when assigning plus/minus sign", "\n", "self", ".", "span_id", "=", "None", "# an id, for mytree2transccg.py", "\n", "if", "impType", "is", "None", ":", "self", ".", "impType", "=", "ImpType", "(", ")", "\n", "else", ":", "self", ".", "impType", "=", "impType", "# type of implicative", "\n", "self", ".", "impSign", "=", "None", "# sign of implicative", "\n", "self", ".", "note", "=", "note", "# note: \"at-most\", \"at-least\", \"at-most-N\", \"at-least-N\"", "\n", "self", ".", "number", "=", "number", "# sg = singular, pl = plural", "\n", "", "def", "copy", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.copy": [[2976, 2982], ["copy.deepcopy", "getMono.NonTermNode", "getMono.NonTermNode.copyHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.copyHelper"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "cat", "=", "copy", ".", "deepcopy", "(", "self", ".", "cat", ")", "# recursively create new copy", "\n", "newNode", "=", "NonTermNode", "(", "self", ".", "depth", ",", "cat", ",", "self", ".", "ruleType", ",", "self", ".", "wholeStr", ")", "\n", "# recursively build all descendents", "\n", "self", ".", "copyHelper", "(", "newNode", ")", "\n", "return", "newNode", "\n", "", "def", "copyHelper", "(", "self", ",", "newNode", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.copyHelper": [[2982, 2989], ["len", "newNode.children.append", "newNode.children.append", "child.copy", "child.copy"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.copy", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.copy"], ["", "def", "copyHelper", "(", "self", ",", "newNode", ")", ":", "\n", "# build all descendents", "\n", "        ", "for", "child", "in", "self", ".", "children", ":", "\n", "            ", "if", "len", "(", "child", ".", "children", ")", "==", "0", ":", "# LeafNode", "\n", "                ", "newNode", ".", "children", ".", "append", "(", "child", ".", "copy", "(", ")", ")", "\n", "", "else", ":", "# NonTermNode", "\n", "                ", "newNode", ".", "children", ".", "append", "(", "child", ".", "copy", "(", ")", ")", "\n", "", "", "", "def", "assignWholeStr", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.assignWholeStr": [[2989, 2992], ["getMono.NonTermNode.assignWholeStrHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.assignWholeStrHelper"], ["", "", "", "def", "assignWholeStr", "(", "self", ")", ":", "\n", "        ", "\"\"\" get wholeStr \"\"\"", "\n", "self", ".", "wholeStr", "=", "self", ".", "assignWholeStrHelper", "(", "self", ")", "\n", "", "def", "assignWholeStrHelper", "(", "self", ",", "node", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.assignWholeStrHelper": [[2992, 2996], ["len"], "methods", ["None"], ["", "def", "assignWholeStrHelper", "(", "self", ",", "node", ")", ":", "\n", "        ", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "return", "node", ".", "wholeStr", "\n", "else", ":", "\n", "            ", "return", "' '", ".", "join", "(", "[", "child", ".", "wholeStr", "for", "child", "in", "node", ".", "children", "]", ")", "\n", "", "", "def", "set_children", "(", "self", ",", "children", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.set_children": [[2996, 3008], ["getMono.NonTermNode.assignWholeStr", "len", "len"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.assignWholeStr"], ["", "", "def", "set_children", "(", "self", ",", "children", ")", ":", "\n", "        ", "\"\"\"  set up my child/children  \"\"\"", "\n", "self", ".", "children", "=", "children", "\n", "self", ".", "assignWholeStr", "(", ")", "\n", "if", "len", "(", "children", ")", "==", "0", ":", "pass", "\n", "elif", "len", "(", "children", ")", "==", "1", ":", "\n", "            ", "children", "[", "0", "]", ".", "parent", "=", "self", "\n", "children", "[", "0", "]", ".", "sisters", "=", "[", "]", "\n", "", "else", ":", "# 2 children", "\n", "            ", "children", "[", "0", "]", ".", "parent", ",", "children", "[", "1", "]", ".", "parent", "=", "self", ",", "self", "\n", "children", "[", "0", "]", ".", "sisters", "=", "[", "children", "[", "1", "]", "]", "\n", "children", "[", "1", "]", ".", "sisters", "=", "[", "children", "[", "0", "]", "]", "\n", "", "", "def", "word_wholeStr", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.word_wholeStr": [[3008, 3011], ["getMono.NonTermNode.word_wholeStr_helper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.word_wholeStr_helper"], ["", "", "def", "word_wholeStr", "(", "self", ")", ":", "\n", "        ", "\"\"\" return wholeStr by concatenating word, not lemma \"\"\"", "\n", "return", "self", ".", "word_wholeStr_helper", "(", "self", ")", "\n", "", "def", "word_wholeStr_helper", "(", "self", ",", "node", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.word_wholeStr_helper": [[3011, 3015], ["len", "getMono.NonTermNode.word_wholeStr_helper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.word_wholeStr_helper"], ["", "def", "word_wholeStr_helper", "(", "self", ",", "node", ")", ":", "\n", "        ", "if", "len", "(", "node", ".", "children", ")", "==", "0", ":", "return", "node", ".", "word_raw", "\n", "else", ":", "\n", "            ", "return", "' '", ".", "join", "(", "[", "self", ".", "word_wholeStr_helper", "(", "child", ")", "for", "child", "in", "node", ".", "children", "]", ")", "\n", "", "", "def", "__str__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.__str__": [[3015, 3019], ["None"], "methods", ["None"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"nt: {} {} {} {} {} {}\"", ".", "format", "(", "self", ".", "cat", ",", "self", ".", "cat", ".", "semCat", ",", "\n", "self", ".", "ruleType", ",", "self", ".", "depth", ",", "\n", "self", ".", "cat", ".", "monotonicity", ",", "self", ".", "visited", ")", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.NonTermNode.__repr__": [[3019, 3021], ["getMono.NonTermNode.__str__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.__init__": [[3023, 3036], ["getMono.SemCat.semCatStr.replace().replace", "getMono.SemCat.semCatStr.replace"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "semCatStr", "=", "None", ",", "IN", "=", "None", ",", "OUT", "=", "None", ",", "marking", "=", "None", ")", ":", "# '+'):", "\n", "# TODO initialize marking as '+' or None?", "\n", "        ", "''' if it's just e or t, then it will be assigned to OUT, and IN=None;\n        that is, there are only two basic SemCat: e and t\n        all the others are built recursively based on these two '''", "\n", "self", ".", "IN", "=", "IN", "# (e,t): also a SemCat", "\n", "self", ".", "OUT", "=", "OUT", "# t: also a SemCat", "\n", "self", ".", "marking", "=", "marking", "# + or -, similar to lex_polarity", "\n", "if", "semCatStr", ":", "\n", "            ", "self", ".", "semCatStr", "=", "semCatStr", "# NP has sem cat: ((e,t),t), no - +", "\n", "", "else", ":", "\n", "            ", "self", ".", "semCatStr", "=", "'({},{})'", ".", "format", "(", "self", ".", "IN", ",", "self", ".", "OUT", ")", "\n", "self", ".", "semCatStr", "=", "self", ".", "semCatStr", ".", "replace", "(", "'-'", ",", "''", ")", ".", "replace", "(", "'+'", ",", "''", ")", "\n", "", "", "def", "assignRecursive", "(", "self", ",", "plusORminus", ",", "exclude", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursive": [[3036, 3040], ["getMono.SemCat.assignRecursiveHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursiveHelper"], ["", "", "def", "assignRecursive", "(", "self", ",", "plusORminus", ",", "exclude", "=", "None", ")", ":", "\n", "        ", "''' assign +/- recursively to every --> inside\n        excluding semCat of the type in exclude '''", "\n", "self", ".", "assignRecursiveHelper", "(", "self", ",", "plusORminus", ",", "exclude", ")", "\n", "", "def", "assignRecursiveHelper", "(", "self", ",", "semcat", ",", "plusORminus", ",", "exclude", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursiveHelper": [[3040, 3053], ["getMono.SemCat.assignRecursiveHelper", "getMono.SemCat.assignRecursiveHelper", "getMono.SemCat.assignRecursiveHelper", "getMono.SemCat.assignRecursiveHelper"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursiveHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursiveHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursiveHelper", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.assignRecursiveHelper"], ["", "def", "assignRecursiveHelper", "(", "self", ",", "semcat", ",", "plusORminus", ",", "exclude", "=", "None", ")", ":", "\n", "        ", "if", "semcat", "is", "None", ":", "return", "\n", "elif", "semcat", ".", "semCatStr", "in", "{", "\"(e,t)\"", ",", "\"e\"", ",", "\"et\"", "}", ":", "return", "\n", "else", ":", "\n", "            ", "if", "exclude", "is", "None", ":", "\n", "                ", "semcat", ".", "marking", "=", "plusORminus", "\n", "self", ".", "assignRecursiveHelper", "(", "semcat", ".", "IN", ",", "plusORminus", ",", "exclude", ")", "\n", "self", ".", "assignRecursiveHelper", "(", "semcat", ".", "OUT", ",", "plusORminus", ",", "exclude", ")", "\n", "", "elif", "semcat", ".", "semCatStr", "not", "in", "exclude", ":", "\n", "                ", "semcat", ".", "marking", "=", "plusORminus", "\n", "# print(semcat)", "\n", "self", ".", "assignRecursiveHelper", "(", "semcat", ".", "IN", ",", "plusORminus", ",", "exclude", ")", "\n", "self", ".", "assignRecursiveHelper", "(", "semcat", ".", "OUT", ",", "plusORminus", ",", "exclude", ")", "\n", "", "", "", "def", "getsemCatStrWithPM", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.getsemCatStrWithPM": [[3053, 3060], ["None"], "methods", ["None"], ["", "", "", "def", "getsemCatStrWithPM", "(", "self", ")", ":", "\n", "        ", "\"\"\" return semCatStr with + - \"\"\"", "\n", "if", "(", "self", ".", "IN", "is", "None", ")", "and", "(", "self", ".", "OUT", "is", "None", ")", ":", "\n", "            ", "return", "'{}'", ".", "format", "(", "self", ".", "semCatStr", ")", "\n", "", "if", "self", ".", "marking", ":", "\n", "            ", "return", "'({},{}{})'", ".", "format", "(", "self", ".", "IN", ",", "self", ".", "marking", ",", "self", ".", "OUT", ")", "\n", "", "return", "'({},{})'", ".", "format", "(", "self", ".", "IN", ",", "self", ".", "OUT", ")", "\n", "", "def", "__str__", "(", "self", ")", ":", "# has + -", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.__str__": [[3060, 3062], ["getMono.SemCat.getsemCatStrWithPM"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.getsemCatStrWithPM"], ["", "def", "__str__", "(", "self", ")", ":", "# has + -", "\n", "        ", "return", "self", ".", "getsemCatStrWithPM", "(", ")", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.__repr__": [[3062, 3064], ["getMono.SemCat.getsemCatStrWithPM"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.SemCat.getsemCatStrWithPM"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "getsemCatStrWithPM", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ImpType.__init__": [[3067, 3087], ["lemma.lower.lower.lower", "pos.startswith"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lemma", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "self", ".", "impType_str", "=", "None", "# for most verbs, it is none", "\n", "if", "lemma", "and", "pos", ":", "\n", "            ", "lemma", "=", "lemma", ".", "lower", "(", ")", "\n", "if", "pos", ".", "startswith", "(", "\"V\"", ")", ":", "# implicatives must be verbs", "\n", "# crucial: TODO", "\n", "# I add px to mean \"no entailment in positive env", "\n", "# should ALL other verbs get \"px|nx\"??? TODO", "\n", "                ", "if", "lemma", "in", "IMP_pp_nn", ":", "self", ".", "impType_str", "=", "\"pp|nn\"", "\n", "elif", "lemma", "in", "IMP_pp", ":", "self", ".", "impType_str", "=", "\"pp\"", "\n", "elif", "lemma", "in", "IMP_nn", ":", "self", ".", "impType_str", "=", "\"nn\"", "\n", "elif", "lemma", "in", "IMP_pn_np", ":", "self", ".", "impType_str", "=", "\"pn|np\"", "\n", "elif", "lemma", "in", "IMP_pn", ":", "self", ".", "impType_str", "=", "\"pn\"", "\n", "elif", "lemma", "in", "IMP_np", ":", "self", ".", "impType_str", "=", "\"np\"", "\n", "elif", "lemma", "in", "IMP_px_nx", ":", "self", ".", "impType_str", "=", "\"px|nx\"", "\n", "# else:  # all other verbs # test case: want to should entail nothing", "\n", "#     self.impType_str = \"px|nx\"", "\n", "# custom words", "\n", "", "elif", "lemma", "in", "{", "\"not\"", ",", "\"n't\"", "}", ":", "\n", "                ", "self", ".", "impType_str", "=", "\"pn|np\"", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.__init__": [[3098, 3123], ["getMono.SemCat", "getMono.Cat.originalType.replace().replace", "re.sub", "getMono.Cat.processBasicType", "getMono.Cat.processComplexType", "getMono.Cat.originalType.replace"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.processBasicType", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.processComplexType"], ["def", "__init__", "(", "self", ",", "originalType", "=", "None", ",", "word", "=", "None", ")", ":", "\n", "        ", "self", ".", "direction", "=", "None", "# str: \\=l, /=r and s(single)", "\n", "self", ".", "left", "=", "None", "# another Cat object", "\n", "self", ".", "right", "=", "None", "# another Cat object", "\n", "self", ".", "originalType", "=", "None", "# str: (S\\+NP)/+NP, or NP[nb]/N", "\n", "self", ".", "typeWOpolarity", "=", "None", "# str: (S\\NP)/NP, or NP[nb]/N, i.e. comes w/ feats", "\n", "self", ".", "typeWOfeats", "=", "None", "# str: get rid of extra features like [nb]: NP/N", "\n", "self", ".", "monotonicity", "=", "None", "# str: [UP, DOWN]", "\n", "self", ".", "lex_polarity", "=", "None", "# str: [i, r], c.f. van Eijck's algorithm", "\n", "self", ".", "word", "=", "word", "# str: if leafNode, then it has word", "\n", "# ------- SEMANTIC CAT ------- #", "\n", "self", ".", "semCat", "=", "SemCat", "(", ")", "# SemCat Object: e,t type", "\n", "# ------- END: SEMANTIC CAT ------- #", "\n", "self", ".", "regexBrk", "=", "'\\[[^\\[\\]]+?\\]'", "# deepcopy cannot handle compiled regex", "\n", "if", "originalType", ":", "\n", "            ", "self", ".", "originalType", "=", "originalType", "\n", "", "else", ":", "# a null Cat", "\n", "            ", "return", "\n", "", "if", "(", "'/'", "not", "in", "self", ".", "originalType", ")", "and", "(", "'\\\\'", "not", "in", "self", ".", "originalType", ")", ":", "\n", "            ", "self", ".", "processBasicType", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "processComplexType", "(", ")", "\n", "\n", "", "self", ".", "typeWOpolarity", "=", "self", ".", "originalType", ".", "replace", "(", "'_i'", ",", "''", ")", ".", "replace", "(", "'_r'", ",", "''", ")", "\n", "self", ".", "typeWOfeats", "=", "re", ".", "sub", "(", "self", ".", "regexBrk", ",", "''", ",", "self", ".", "typeWOpolarity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.processBasicType": [[3133, 3208], ["getMono.Cat.originalType.replace().replace", "re.sub", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.originalType.replace", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.SemCat", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.SemCat", "getMono.SemCat", "getMono.SemCat", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.word.upper", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.word.upper", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.word.upper", "getMono.SemCat", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.Cat.typeWOfeats.upper", "getMono.SemCat", "getMono.SemCat", "getMono.ErrorCat"], "methods", ["None"], ["", "def", "processBasicType", "(", "self", ")", ":", "\n", "        ", "''' basicType: NP, S, N. I.e. with out slashes '''", "\n", "self", ".", "direction", "=", "'s'", "\n", "self", ".", "left", "=", "self", ".", "right", "=", "None", "\n", "self", ".", "typeWOpolarity", "=", "self", ".", "originalType", ".", "replace", "(", "'_i'", ",", "''", ")", ".", "replace", "(", "'_r'", ",", "''", ")", "\n", "self", ".", "originalType", "=", "self", ".", "typeWOpolarity", "\n", "# ------- SEMANTIC CAT ------- #", "\n", "# can only be S, N, NP, pp", "\n", "self", ".", "typeWOfeats", "=", "re", ".", "sub", "(", "self", ".", "regexBrk", ",", "''", ",", "self", ".", "typeWOpolarity", ")", "\n", "if", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'S'", ":", "# t", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'t'", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'N'", ":", "# e,t", "\n", "# IN = SemCat(**{'OUT':'e','semCatStr':'e'})", "\n", "# OUT = SemCat(**{'OUT':'t','semCatStr':'t'})", "\n", "            ", "E", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'e'", "}", ")", "\n", "T", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'t'", "}", ")", "\n", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'IN'", ":", "E", ",", "'OUT'", ":", "T", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'NP'", ":", "# (e,t),t", "\n", "            ", "E", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'e'", "}", ")", "\n", "T", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'t'", "}", ")", "\n", "IN", "=", "SemCat", "(", "**", "{", "'IN'", ":", "E", ",", "'OUT'", ":", "T", "}", ")", "\n", "OUT", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'t'", "}", ")", "\n", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'IN'", ":", "IN", ",", "'OUT'", ":", "OUT", "}", ")", "\n", "# TODO relative pronoun 'that' should have NP+ in the last NP", "\n", "# (NP\\NP)/(S/NP+) or (N\\N)/NP", "\n", "# if (self.word is not None) \\", "\n", "#     and (self.word.upper() in {'WHO', 'THAT', 'WHICH'}):", "\n", "#     self.semCat = SemCat(**{'IN': IN, 'OUT': OUT, 'marking': '+'})", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "in", "[", "'.'", ",", "','", ",", "';'", "]", ":", "# punctuation", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'PP'", ":", "# TODO", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'pp'", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'CONJ'", ":", "# TODO", "\n", "            ", "if", "self", ".", "word", "is", "None", ":", "pass", "\n", "elif", "self", ".", "word", ".", "upper", "(", ")", "==", "'AND'", ":", "# TODO and is +?", "\n", "                ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'CONJ'", ",", "'marking'", ":", "'+'", "}", ")", "\n", "", "elif", "self", ".", "word", ".", "upper", "(", ")", "==", "'OR'", ":", "# TODO +?", "\n", "                ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'CONJ'", ",", "'marking'", ":", "'+'", "}", ")", "\n", "", "elif", "self", ".", "word", ".", "upper", "(", ")", "==", "'BUT'", ":", "\n", "                ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'CONJ'", ",", "'marking'", ":", "'+'", "}", ")", "\n", "", "else", ":", "# sometimes \"if\" is tagged as a conjunction", "\n", "                ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'CONJ'", ",", "'marking'", ":", "'+'", "}", ")", "\n", "#else:", "\n", "#    raise ErrorCat('unable to create semCat for conjunction {}'.format(self.word))", "\n", "\n", "", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'PR'", ":", "# preposition", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'pr'", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "':'", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "':'", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'LQU'", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'LQU'", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'RQU'", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'RQU'", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'RRB'", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'RRB'", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "'LRB'", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "'LRB'", "}", ")", "\n", "\n", "", "elif", "self", ".", "typeWOfeats", ".", "upper", "(", ")", "==", "';'", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'semCatStr'", ":", "';'", "}", ")", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", ")", "\n", "raise", "ErrorCat", "(", "'no semCat for basic type: {}\\noriginalType: {}'", ".", "format", "(", "self", ".", "typeWOfeats", ",", "\n", "self", ".", "originalType", ")", ")", "\n", "# ------- END: SEMANTIC CAT ------- #", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.processComplexType": [[3210, 3304], ["getMono.Cat", "getMono.Cat", "getMono.Cat.originalType.startswith", "getMono.Cat.originalType.find", "getMono.Cat.originalType.find", "getMono.Cat.stripOneChar", "getMono.Cat.stripOneChar", "getMono.SemCat", "getMono.SemCat", "getMono.Cat.stripOneChar", "getMono.Cat.stripOneChar", "getMono.Cat.stripOneChar", "getMono.Cat.stripOneChar", "getMono.Cat.word.upper", "getMono.eprint", "getMono.eprint", "getMono.ErrorCat"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.stripOneChar", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.stripOneChar", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.stripOneChar", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.stripOneChar", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.stripOneChar", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.stripOneChar", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["", "", "def", "processComplexType", "(", "self", ")", ":", "\n", "        ", "''' originalType has either / or \\, \n        process originalType into left, right and direction '''", "\n", "\n", "# need to remove _r, (, ) if originalType == (S_i/VP)_r,", "\n", "if", "self", ".", "originalType", "[", "-", "2", ":", "]", "in", "[", "'_r'", ",", "'_i'", "]", ":", "\n", "            ", "if", "self", ".", "originalType", "[", "-", "3", "]", "!=", "')'", ":", "\n", "                ", "self", ".", "originalType", "=", "self", ".", "originalType", "[", ":", "-", "2", "]", "# A_r --> A", "\n", "", "else", ":", "\n", "                ", "self", ".", "originalType", "=", "self", ".", "originalType", "[", "1", ":", "-", "3", "]", "# remove ( and )", "\n", "\n", "# if the left part has no brackets: e.g. XP\\((XP/YP)\\ZP)", "\n", "", "", "if", "not", "self", ".", "originalType", ".", "startswith", "(", "'('", ")", ":", "\n", "            ", "ind1", "=", "self", ".", "originalType", ".", "find", "(", "'\\\\'", ")", "# ind1 is the index of the left slash", "\n", "ind2", "=", "self", ".", "originalType", ".", "find", "(", "'/'", ")", "# ind2 is the index of the right slash", "\n", "ind", "=", "ind1", "# ind of the first slash, first set to ind1", "\n", "self", ".", "direction", "=", "'l'", "\n", "\n", "if", "ind1", "==", "-", "1", "and", "ind2", "!=", "-", "1", ":", "# only has /", "\n", "                ", "self", ".", "direction", "=", "'r'", "# right", "\n", "ind", "=", "ind2", "\n", "", "elif", "ind2", "==", "-", "1", "and", "ind1", "!=", "-", "1", ":", "# only has \\", "\n", "                ", "self", ".", "direction", "=", "'l'", "# left", "\n", "", "else", ":", "# has both / and \\", "\n", "                ", "if", "ind2", "<", "ind1", ":", "# first slash is /", "\n", "                    ", "ind", "=", "ind2", "\n", "self", ".", "direction", "=", "'r'", "\n", "\n", "# now ind is the critical slash that separates left and right", "\n", "", "", "try", ":", "\n", "                ", "if", "self", ".", "originalType", "[", "(", "ind", "-", "2", ")", ":", "ind", "]", "in", "[", "'_i'", ",", "'_r'", "]", ":", "\n", "                    ", "self", ".", "lex_polarity", "=", "self", ".", "originalType", "[", "(", "ind", "-", "1", ")", ":", "ind", "]", "\n", "", "", "except", "IndexError", ":", "pass", "\n", "self", ".", "left", "=", "self", ".", "originalType", "[", ":", "ind", "]", "\n", "right_tmp", "=", "self", ".", "originalType", "[", "(", "ind", "+", "1", ")", ":", "]", "\n", "\n", "right_tmp", "=", "self", ".", "stripOneChar", "(", "right_tmp", ",", "'('", ")", "\n", "self", ".", "right", "=", "self", ".", "stripOneChar", "(", "right_tmp", ",", "')'", ")", "\n", "\n", "# if the left part has brackets: e.g. ((XP\\X)/XP)\\(((X\\Y)/Z)\\A)", "\n", "", "else", ":", "\n", "            ", "numLB", "=", "1", "# number of left brackets '('", "\n", "ind", "=", "1", "# the index for / or \\", "\n", "\n", "while", "numLB", ">", "0", ":", "\n", "                ", "if", "self", ".", "originalType", "[", "ind", "]", "==", "'('", ":", "\n", "                    ", "numLB", "+=", "1", "\n", "", "elif", "self", ".", "originalType", "[", "ind", "]", "==", "')'", ":", "\n", "                    ", "numLB", "-=", "1", "\n", "", "ind", "+=", "1", "\n", "\n", "# assign i or r to lex_polarity and", "\n", "# handle cases like: every (TV\\VP_i)_r/CN", "\n", "# now ind is 9 = the ind after the last ')', which correspond to _", "\n", "# we want ind to be 11, which correspond to /", "\n", "", "try", ":", "\n", "                ", "if", "(", "self", ".", "originalType", "[", "ind", ":", "(", "ind", "+", "2", ")", "]", "==", "'_i'", ")", "or", "(", "self", ".", "originalType", "[", "ind", ":", "(", "ind", "+", "2", ")", "]", "==", "'_r'", ")", ":", "\n", "                    ", "self", ".", "lex_polarity", "=", "self", ".", "originalType", "[", "(", "ind", "+", "1", ")", ":", "(", "ind", "+", "2", ")", "]", "# i or r", "\n", "ind", "+=", "2", "\n", "", "", "except", ":", "pass", "\n", "\n", "if", "self", ".", "originalType", "[", "ind", "]", "==", "'\\\\'", ":", "\n", "                ", "self", ".", "direction", "=", "'l'", "\n", "", "elif", "self", ".", "originalType", "[", "ind", "]", "==", "'/'", ":", "\n", "                ", "self", ".", "direction", "=", "'r'", "\n", "", "else", ":", "\n", "                ", "eprint", "(", "'something went wrong when converting types!'", ")", "\n", "eprint", "(", "self", ".", "originalType", ",", "self", ".", "originalType", "[", "ind", "]", ")", "\n", "raise", "ErrorCat", "(", ")", "\n", "\n", "", "self", ".", "left", "=", "self", ".", "originalType", "[", ":", "ind", "]", "\n", "self", ".", "right", "=", "self", ".", "originalType", "[", "(", "ind", "+", "1", ")", ":", "]", "\n", "\n", "if", "(", "not", "self", ".", "left", "[", "-", "2", ":", "]", "==", "'_r'", ")", "and", "(", "not", "self", ".", "left", "[", "-", "2", ":", "]", "==", "'_i'", ")", ":", "\n", "                ", "self", ".", "left", "=", "self", ".", "stripOneChar", "(", "self", ".", "left", ",", "'('", ")", "\n", "self", ".", "left", "=", "self", ".", "stripOneChar", "(", "self", ".", "left", ",", "')'", ")", "\n", "", "if", "(", "not", "self", ".", "right", "[", "-", "2", ":", "]", "==", "'_r'", ")", "and", "(", "not", "self", ".", "right", "[", "-", "2", ":", "]", "==", "'_i'", ")", ":", "\n", "                ", "self", ".", "right", "=", "self", ".", "stripOneChar", "(", "self", ".", "right", ",", "'('", ")", "\n", "self", ".", "right", "=", "self", ".", "stripOneChar", "(", "self", ".", "right", ",", "')'", ")", "\n", "\n", "", "", "self", ".", "left", "=", "Cat", "(", "self", ".", "left", ",", "self", ".", "word", ")", "# recursively build Cat", "\n", "self", ".", "right", "=", "Cat", "(", "self", ".", "right", ",", "self", ".", "word", ")", "# recursively build Cat", "\n", "\n", "# if the word is 'who', then assign '+' to every slash TODO why??? not now", "\n", "if", "(", "self", ".", "word", "is", "not", "None", ")", "and", "(", "self", ".", "word", ".", "upper", "(", ")", "in", "{", "'WHO'", ",", "'THAT'", ",", "'WHICH'", "}", ")", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'IN'", ":", "self", ".", "right", ".", "semCat", ",", "\n", "'OUT'", ":", "self", ".", "left", ".", "semCat", "}", ")", "\n", "# self.semCat = SemCat(**{'IN': self.right.semCat,", "\n", "#                         'OUT': self.left.semCat, 'marking':'+'})", "\n", "", "else", ":", "\n", "            ", "self", ".", "semCat", "=", "SemCat", "(", "**", "{", "'IN'", ":", "self", ".", "right", ".", "semCat", ",", "\n", "'OUT'", ":", "self", ".", "left", ".", "semCat", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.__str__": [[3305, 3307], ["None"], "methods", ["None"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "(", "'{}'", ".", "format", "(", "self", ".", "typeWOpolarity", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.__repr__": [[3308, 3310], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "(", "'{}'", ".", "format", "(", "self", ".", "typeWOpolarity", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.Cat.stripOneChar": [[3311, 3322], ["len"], "methods", ["None"], ["", "def", "stripOneChar", "(", "self", ",", "stri", ",", "char", ")", ":", "\n", "        ", "''' strip the first or last char or both of a string, if it == char:\n        e.g. \\\\this\\\\ will become \\this\\ i.e. only strips off one '\\' '''", "\n", "if", "len", "(", "stri", ")", "<=", "2", ":", "\n", "            ", "return", "stri", "\n", "", "else", ":", "\n", "            ", "if", "stri", "[", "0", "]", "==", "char", ":", "\n", "                ", "stri", "=", "stri", "[", "1", ":", "]", "\n", "", "if", "stri", "[", "-", "1", "]", "==", "char", ":", "\n", "                ", "stri", "=", "stri", "[", ":", "-", "1", "]", "\n", "", "return", "stri", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorCCGtrees.__init__": [[3325, 3326], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__"], ["def", "__init__", "(", "self", ",", "message", "=", "\"\"", ")", ":", "Exception", ".", "__init__", "(", "self", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorCCGtree.__init__": [[3329, 3330], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__"], ["def", "__init__", "(", "self", ",", "message", "=", "\"\"", ")", ":", "Exception", ".", "__init__", "(", "self", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorLeafNode.__init__": [[3333, 3334], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__"], ["def", "__init__", "(", "self", ",", "message", "=", "\"\"", ")", ":", "Exception", ".", "__init__", "(", "self", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorNonTermNode.__init__": [[3337, 3338], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__"], ["def", "__init__", "(", "self", ",", "message", "=", "\"\"", ")", ":", "Exception", ".", "__init__", "(", "self", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorSemCat.__init__": [[3341, 3342], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__"], ["def", "__init__", "(", "self", ",", "message", "=", "\"\"", ")", ":", "Exception", ".", "__init__", "(", "self", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorCat.__init__": [[3345, 3346], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__"], ["def", "__init__", "(", "self", ",", "message", "=", "\"\"", ")", ":", "Exception", ".", "__init__", "(", "self", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorCompareSemCat.__init__": [[3349, 3350], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__"], ["def", "__init__", "(", "self", ",", "message", "=", "\"\"", ")", ":", "Exception", ".", "__init__", "(", "self", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__": [[3353, 3354], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.ErrorAssignEqualMarking.__init__"], ["def", "__init__", "(", "self", ",", "message", "=", "\"\"", ")", ":", "Exception", ".", "__init__", "(", "self", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.main": [[76, 195], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "getMono.eprint", "os.path.isfile", "print", "sorted", "print", "print", "getMono.test", "sys.exit", "getMono.CCGtrees", "getMono.CCGtrees.build_one_tree", "print", "trees.build_one_tree.fixQuantifier", "trees.build_one_tree.fixNot", "trees.build_one_tree.getImpSign", "trees.build_one_tree.printSent_raw", "idx_cant_polarize.items", "print", "int", "getMono.eprint", "sys.exit", "getMono.CCGtrees.readCandCxml", "trees.build_one_tree.printSent", "trees.build_one_tree.printTree", "trees.build_one_tree.fixRC", "trees.build_one_tree.mark", "trees.build_one_tree.polarize", "len", "getMono.CCGtrees.readEasyccgStr", "getMono.CCGtrees.readCandCxml", "getMono.CCGtrees.readEasyccgStr", "getMono.eprint", "sys.exit", "trees.build_one_tree.printTree", "trees.build_one_tree.printTree", "trees.build_one_tree.printTree", "print", "trees.build_one_tree.printSent_raw_no_pol", "getMono.CCGtrees.readEasyccgStr", "getMono.eprint", "sys.exit", "type", "type"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.test", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.build_one_tree", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixQuantifier", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixNot", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.getImpSign", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent_raw", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readCandCxml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTree", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.fixRC", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.mark", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.polarize", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readEasyccgStr", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readCandCxml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readEasyccgStr", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTree", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTree", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTree", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printSent_raw_no_pol", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtrees.readEasyccgStr", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint"], ["def", "main", "(", ")", ":", "\n", "# -------------------------------------", "\n", "# parse cmd arguments", "\n", "    ", "description", "=", "\"\"\"\n    Polarize CCG trees. Authors: Hai Hu, Larry Moss\n    \"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "description", ")", "\n", "parser", ".", "add_argument", "(", "'-s'", ",", "'--sentNo'", ",", "dest", "=", "'sentNo'", ",", "type", "=", "str", ",", "nargs", "=", "'+'", ",", "default", "=", "[", "'all'", "]", ",", "\n", "help", "=", "'index(s) of sentence to process. E.g. \"2\", \"3 5\", \"all\" '", "\n", "\"[default: %(default)s]\"", ")", "\n", "parser", ".", "add_argument", "(", "'-p'", ",", "dest", "=", "'parser'", ",", "default", "=", "'candc'", ",", "choices", "=", "[", "'candc'", ",", "'easyccg'", ",", "'depccg'", "]", ",", "\n", "help", "=", "'parser of your choice: candc, easyccg, depccg '", "\n", "\"[default: %(default)s]\"", ")", "\n", "parser", ".", "add_argument", "(", "'-v'", ",", "dest", "=", "'verbose'", ",", "choices", "=", "[", "-", "1", ",", "0", ",", "1", ",", "2", ",", "3", ",", "4", "]", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "'verbose: -1: None, 0: after reading in tree, '", "\n", "'1: after fixTree(), '", "\n", "'2: after mark(), 3: after polarize(), \\n4: all '", "\n", "\"[default: %(default)s]\"", ")", "\n", "parser", ".", "add_argument", "(", "'-f'", ",", "dest", "=", "'filename'", ",", "type", "=", "str", ",", "default", "=", "'tmp.candc.parsed.xml'", ",", "\n", "help", "=", "'parser output filename. E.g. fracas_1_80.raw.easyccg.parsed.txt, or '", "\n", "'tmp.candc.parsed.xml '", "\n", "\"[default: %(default)s]\"", ")", "\n", "parser", ".", "add_argument", "(", "'-flog'", ",", "dest", "=", "'filename_log'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'preprocess log filename. E.g. test.tok.preprocess.log'", "\n", "\"[default: %(default)s]\"", ")", "\n", "parser", ".", "add_argument", "(", "'-t'", ",", "dest", "=", "'test'", ",", "action", "=", "'store_const'", ",", "const", "=", "True", ",", "default", "=", "False", ",", "\n", "help", "=", "'if -t, run test()'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "# -------------------------------------", "\n", "\n", "if", "args", ".", "test", ":", "\n", "        ", "print", "(", "'in test'", ")", "\n", "test", "(", ")", "\n", "exit", "(", ")", "\n", "\n", "", "eprint", "(", "\"trees to build: \"", ",", "args", ".", "sentNo", ")", "\n", "if", "args", ".", "sentNo", "==", "[", "'all'", "]", ":", "\n", "        ", "args", ".", "sentNo", "=", "[", "]", "\n", "", "else", ":", "\n", "        ", "args", ".", "sentNo", "=", "[", "int", "(", "i", ")", "for", "i", "in", "args", ".", "sentNo", "]", "\n", "\n", "# intialize trees", "\n", "", "try", ":", "\n", "        ", "trees", "=", "CCGtrees", "(", "args", ".", "filename_log", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "        ", "eprint", "(", "'please specify filename of pre process log, using -flog'", ")", "\n", "exit", "(", ")", "\n", "\n", "# parser output filename", "\n", "", "if", "os", ".", "path", ".", "isfile", "(", "args", ".", "filename", ")", ":", "\n", "        ", "if", "'.candc.'", "in", "args", ".", "filename", ":", "\n", "            ", "args", ".", "parser", "=", "'candc'", "\n", "trees", ".", "readCandCxml", "(", "args", ".", "filename", ",", "args", ".", "sentNo", ")", "\n", "", "elif", "'.easyccg'", "in", "args", ".", "filename", ":", "\n", "            ", "args", ".", "parser", "=", "'easyccg'", "\n", "trees", ".", "readEasyccgStr", "(", "args", ".", "filename", ",", "args", ".", "sentNo", ")", "\n", "", "elif", "'.depccg'", "in", "args", ".", "filename", ":", "\n", "            ", "args", ".", "parser", "=", "'depccg'", "# same as easyccg", "\n", "trees", ".", "readEasyccgStr", "(", "args", ".", "filename", ",", "args", ".", "sentNo", ")", "\n", "", "else", ":", "\n", "            ", "eprint", "(", "'parser not supported'", ")", "\n", "exit", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "if", "args", ".", "parser", "==", "'candc'", ":", "\n", "                ", "trees", ".", "readCandCxml", "(", "'tmp.candc.parsed.xml'", ")", "\n", "", "else", ":", "trees", ".", "readEasyccgStr", "(", "'tmp.easyccg.parsed.txt'", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "            ", "eprint", "(", "'please specify filename of parser output, using -f'", ")", "\n", "exit", "(", ")", "\n", "\n", "", "", "idx_cant_polarize", "=", "{", "}", "\n", "for", "idx", "in", "trees", ".", "tree_idxs", ":", "\n", "# build the tree here", "\n", "        ", "t", "=", "trees", ".", "build_one_tree", "(", "idx", ",", "args", ".", "parser", ")", "\n", "\n", "# print()", "\n", "# print('-' * 20)", "\n", "# print('tree {}\\n'.format(idx))", "\n", "print", "(", "'{}\\t'", ".", "format", "(", "idx", ")", ",", "end", "=", "\"\"", ")", "\n", "\n", "if", "args", ".", "verbose", "in", "[", "0", ",", "4", "]", ":", "\n", "            ", "t", ".", "printSent", "(", ")", "\n", "t", ".", "printTree", "(", ")", "\n", "\n", "# fix tree", "\n", "", "t", ".", "fixQuantifier", "(", ")", "\n", "t", ".", "fixNot", "(", ")", "\n", "if", "args", ".", "parser", "==", "'candc'", ":", "t", ".", "fixRC", "(", ")", "# only fix RC for candc", "\n", "\n", "try", ":", "\n", "            ", "if", "args", ".", "verbose", "in", "[", "1", ",", "4", "]", ":", "t", ".", "printTree", "(", ")", "\n", "\n", "t", ".", "mark", "(", ")", "\n", "if", "args", ".", "verbose", "in", "[", "2", ",", "4", "]", ":", "t", ".", "printTree", "(", ")", "\n", "\n", "t", ".", "polarize", "(", ")", "\n", "if", "args", ".", "verbose", "in", "[", "3", ",", "4", "]", ":", "t", ".", "printTree", "(", ")", "\n", "", "except", "(", "ErrorCompareSemCat", ",", "ErrorCCGtree", ")", "as", "e", ":", "\n", "            ", "idx_cant_polarize", "[", "idx", "]", "=", "type", "(", "e", ")", ".", "__name__", "\n", "# print(e)", "\n", "print", "(", "\"Polarizing error:\"", ",", "type", "(", "e", ")", ".", "__name__", ",", "end", "=", "\"; \"", ")", "\n", "t", ".", "printSent_raw_no_pol", "(", ")", "\n", "continue", "\n", "\n", "", "t", ".", "getImpSign", "(", ")", "\n", "\n", "t", ".", "printSent_raw", "(", ")", "\n", "# t.printSent()", "\n", "# t.printSentLatex()", "\n", "\n", "# testTrees(trees)", "\n", "\n", "# return", "\n", "", "print", "(", "\"\\ncannot polarize the following trees:\"", ")", "\n", "for", "idx", ",", "e", "in", "sorted", "(", "idx_cant_polarize", ".", "items", "(", ")", ")", ":", "\n", "        ", "print", "(", "idx", ",", "e", ")", "\n", "\n", "", "print", "(", "\"\\n\\ncannot polarize {} trees\"", ".", "format", "(", "len", "(", "idx_cant_polarize", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.testTrees": [[196, 206], ["print", "getMono.CCGtree", "getMono.CCGtree.printTree", "print", "print"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.CCGtree.printTree"], ["", "def", "testTrees", "(", "trees", ")", ":", "\n", "    ", "'''  test other constructors of CCGtree: passed  '''", "\n", "t", "=", "trees", ".", "trees", "[", "3", "]", "\n", "node", "=", "t", ".", "root", ".", "children", "[", "0", "]", ".", "children", "[", "0", "]", "\n", "print", "(", "node", ")", "\n", "\n", "newtree", "=", "CCGtree", "(", "NonTermNode", "=", "node", ")", "\n", "newtree", ".", "printTree", "(", ")", "\n", "print", "(", "newtree", ".", "words", ")", "\n", "print", "(", "newtree", ".", "wholeStr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.test": [[207, 262], ["getMono.Cat", "print", "print", "print", "print", "print", "getMono.Cat", "getMono.Cat", "print", "copy.deepcopy", "print", "copy.deepcopy", "print", "getMono.Cat", "getMono.Cat", "print"], "function", ["None"], ["", "def", "test", "(", ")", ":", "\n", "# # test semcat assign recursive", "\n", "# # passed", "\n", "# mycat = Cat(originalType=r'((S[ng]\\NP)/NP)/PR')", "\n", "# print(mycat.semCat)", "\n", "# exclude = {\"((e,t),t)\", \"t\", \"pp\", \"pr\"}", "\n", "# mycat.semCat.assignRecursive(\"+\", exclude)", "\n", "# print(mycat.semCat)", "\n", "#", "\n", "# return", "\n", "#", "\n", "# \"\"\" test compareSemCat(): passed \"\"\"", "\n", "# left = Cat(originalType=r'(S[dcl]\\NP)/NP')", "\n", "# left.semCat.marking = '+'", "\n", "# left.semCat.OUT.marking = '+'", "\n", "#", "\n", "# right = Cat(originalType=r'(S[dcl]\\NP)/NP')", "\n", "# right.semCat.IN.marking = '-'", "\n", "#", "\n", "# t = CCGtree()", "\n", "# t.compareSemCat(right.semCat, left.semCat, 'parent')", "\n", "#", "\n", "# return", "\n", "\n", "    ", "''' test Cat constructor '''", "\n", "x", "=", "Cat", "(", "originalType", "=", "r'S[dcl]/(S[dcl]\\NP)'", ")", "\n", "print", "(", "x", ")", "\n", "print", "(", "x", ".", "semCat", ")", "\n", "print", "(", "x", ".", "semCat", ".", "IN", ")", "\n", "print", "(", "x", ".", "semCat", ".", "OUT", ")", "\n", "print", "(", ")", "\n", "\n", "right", "=", "Cat", "(", "originalType", "=", "r'(S\\NP)\\(S\\NP)'", ")", "\n", "right", ".", "semCat", ".", "marking", "=", "'+'", "\n", "right", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "\n", "right", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "\n", "left", "=", "Cat", "(", "originalType", "=", "r'(S\\NP)\\(S\\NP)'", ")", "\n", "left", ".", "semCat", ".", "marking", "=", "'+'", "\n", "left", ".", "semCat", ".", "IN", ".", "marking", "=", "'+'", "\n", "left", ".", "semCat", ".", "OUT", ".", "marking", "=", "'+'", "\n", "print", "(", "right", ".", "semCat", ")", "\n", "\n", "rightCopy", "=", "copy", ".", "deepcopy", "(", "right", ")", "\n", "print", "(", "rightCopy", ".", "semCat", ")", "\n", "\n", "leftCopy", "=", "copy", ".", "deepcopy", "(", "left", ")", "\n", "print", "(", "leftCopy", ".", "semCat", ")", "\n", "\n", "conj", "=", "Cat", "(", ")", "\n", "conj", ".", "right", "=", "rightCopy", "\n", "conj", ".", "left", "=", "Cat", "(", ")", "\n", "conj", ".", "left", ".", "right", "=", "leftCopy", "\n", "conj", ".", "left", ".", "left", "=", "leftCopy", "\n", "print", "(", "conj", ".", "right", ")", "\n", "# passed the test:", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.src.getMono.eprint": [[266, 269], ["print"], "function", ["None"], ["", "def", "eprint", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\" print to stderr \"\"\"", "\n", "print", "(", "*", "args", ",", "file", "=", "sys", ".", "stderr", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml": [[72, 83], ["cgi.escape", "str"], "function", ["None"], ["def", "get_fraction_mathml", "(", "numerator", ",", "denominator", ",", "line_thickness", "=", "3", ",", "\n", "rule", "=", "''", ",", "upwards", "=", "kUpwardsTree", ")", ":", "\n", "    ", "if", "upwards", ":", "\n", "        ", "numerator", ",", "denominator", "=", "denominator", ",", "numerator", "\n", "", "mathml_str", "=", "\"<mfrac linethickness='\"", "+", "str", "(", "line_thickness", ")", "+", "\"px'>\\n\"", "+", "\"  <mrow>\"", "+", "numerator", "+", "\"</mrow>\\n\"", "+", "\"  <mrow>\"", "+", "denominator", "+", "\"</mrow>\\n\"", "+", "\"</mfrac>\\n\"", "\n", "if", "rule", ":", "\n", "        ", "mathml_str", "=", "\"<mrow><mo>\"", "+", "cgi", ".", "escape", "(", "rule", ")", "+", "\"</mo>\"", "+", "mathml_str", "+", "\"</mrow>\"", "\n", "", "return", "mathml_str", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_category_mathml": [[84, 107], ["re.findall", "str", "str"], "function", ["None"], ["", "def", "get_category_mathml", "(", "category", ")", ":", "\n", "    ", "cats_feats", "=", "re", ".", "findall", "(", "r'([\\w\\\\/()]+)(\\[.+?\\])*'", ",", "category", ")", "\n", "mathml_str", "=", "''", "\n", "for", "cat", ",", "feat", "in", "cats_feats", ":", "\n", "        ", "cat_mathml", "=", "\"  <mi mathvariant='italic'\"", "+", "\" fontsize='\"", "+", "str", "(", "kOtherSize", ")", "+", "\"'\"", "+", "\" color='\"", "+", "kCategoryColor", "+", "\"'>\"", "+", "cat", "+", "\"  </mi>\\n\"", "\n", "if", "feat", "!=", "''", "and", "kDisplayFeatures", ":", "\n", "            ", "mathml_str", "+=", "\"<msub>\\n\"", "+", "cat_mathml", "+", "\"  <mrow>\\n\"", "+", "\"    <mi mathvariant='italic'\"", "+", "\" fontsize='\"", "+", "str", "(", "kFeatureSize", ")", "+", "\"'\"", "+", "\" color='\"", "+", "kFeatureColor", "+", "\"'>\"", "+", "feat", "+", "\"  </mi>\\n\"", "+", "\"  </mrow>\\n\"", "+", "\"</msub>\\n\"", "\n", "", "else", ":", "\n", "            ", "mathml_str", "+=", "cat_mathml", "\n", "", "", "return", "mathml_str", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_surface_mathml": [[108, 114], ["str"], "function", ["None"], ["", "def", "get_surface_mathml", "(", "surface", ")", ":", "\n", "    ", "return", "\"<mtext \"", "+", "\" fontsize='\"", "+", "str", "(", "kOtherSize", ")", "+", "\"'\"", "+", "\" color='\"", "+", "kLexicalColor", "+", "\"'>\"", "+", "surface", "+", "\"</mtext>\\n\"", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_entity_mathml": [[115, 121], ["str"], "function", ["None"], ["", "def", "get_entity_mathml", "(", "entity", ")", ":", "\n", "    ", "return", "\"<mtext \"", "+", "\" fontsize='\"", "+", "str", "(", "kOtherSize", ")", "+", "\"'\"", "+", "\" color='\"", "+", "kEntityColor", "+", "\"'>\"", "+", "entity", "+", "\"</mtext>\\n\"", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_pos_mathml": [[122, 128], ["str"], "function", ["None"], ["", "def", "get_pos_mathml", "(", "pos", ")", ":", "\n", "    ", "return", "\"<mtext \"", "+", "\" fontsize='\"", "+", "str", "(", "kOtherSize", ")", "+", "\"'\"", "+", "\" color='\"", "+", "kPosColor", "+", "\"'>\"", "+", "pos", "+", "\"</mtext>\\n\"", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_ETtype_mathml": [[129, 140], ["ETtype.strip.replace", "ETtype.strip.strip", "str"], "function", ["None"], ["", "def", "get_ETtype_mathml", "(", "ETtype", ")", ":", "\n", "    ", "ETtype", "=", "ETtype", ".", "replace", "(", "'(e,t)'", ",", "'et'", ")", "\n", "# ETtype = ETtype.replace(',+', arrowplus_mathml).\\", "\n", "# replace(',-', arrowminus_mathml).\\", "\n", "# replace(',', arrowdot_mathml)", "\n", "ETtype", "=", "ETtype", ".", "strip", "(", ")", "\n", "return", "\"<mtext \"", "+", "\" fontsize='\"", "+", "str", "(", "kOtherSize", ")", "+", "\"'\"", "+", "\" color='\"", "+", "kETtypeColor", "+", "\"'>\"", "+", "ETtype", "+", "\"</mtext>\\n\"", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_polarity_mathml": [[141, 147], ["str"], "function", ["None"], ["", "def", "get_polarity_mathml", "(", "polarity", ")", ":", "\n", "    ", "return", "\"<mtext \"", "+", "\" fontsize='\"", "+", "str", "(", "kOtherSize", ")", "+", "\"'\"", "+", "\" color='\"", "+", "kPolarityColor", "+", "\"'>\"", "+", "polarity", "+", "\"</mtext>\\n\"", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_semantics_mathml": [[148, 154], ["cgi.escape", "str"], "function", ["None"], ["", "def", "get_semantics_mathml", "(", "semantics", ")", ":", "\n", "    ", "return", "\"<mtext \"", "+", "\" fontsize='\"", "+", "str", "(", "kOtherSize", ")", "+", "\"'\"", "+", "\" color='\"", "+", "kSemanticsColor", "+", "\"'>\"", "+", "cgi", ".", "escape", "(", "semantics", ")", "+", "\"</mtext>\\n\"", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_node_to_mathml": [[155, 232], ["ccg_node.get().strip", "visualization_tools.get_category_mathml", "ccg_node.get", "ccg_node.get", "visualization_tools.get_ETtype_mathml", "visualization_tools.get_polarity_mathml", "len", "ccg_node.get", "semantic_index.find_node_by_id", "semantic_index.find_node_by_id.get", "visualization_tools.get_surface_mathml", "semantic_index.find_node_by_id.get", "visualization_tools.get_pos_mathml", "semantic_index.find_node_by_id.get", "semantic_index.find_node_by_id.get", "semantic_index.find_node_by_id.get", "semantic_index.find_node_by_id.get", "ccg_node.get", "semantic_index.find_node_by_id", "semantic_index.find_node_by_id.get", "visualization_tools.get_semantics_mathml", "visualization_tools.get_fraction_mathml", "ccg_node.get", "ccg_node.get", "ccg_node.get", "visualization_tools.get_entity_mathml", "visualization_tools.get_pos_mathml", "visualization_tools.get_pos_mathml", "visualization_tools.get_pos_mathml", "visualization_tools.get_fraction_mathml", "visualization_tools.get_fraction_mathml", "visualization_tools.get_fraction_mathml", "len", "visualization_tools.convert_node_to_mathml", "ccg_node.get", "visualization_tools.get_fraction_mathml", "visualization_tools.get_fraction_mathml", "visualization_tools.get_fraction_mathml", "visualization_tools.get_fraction_mathml", "visualization_tools.get_fraction_mathml", "len", "ccg_node.get", "visualization_tools.get_fraction_mathml", "visualization_tools.convert_node_to_mathml", "visualization_tools.get_fraction_mathml", "visualization_tools.get_fraction_mathml"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_category_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_ETtype_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_polarity_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_surface_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_pos_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_semantics_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_entity_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_pos_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_pos_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_pos_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_node_to_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_node_to_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_fraction_mathml"], ["", "def", "convert_node_to_mathml", "(", "ccg_node", ",", "sem_tree", ",", "tokens", ")", ":", "\n", "    ", "mathml_str", "=", "''", "\n", "category", "=", "ccg_node", ".", "get", "(", "'category'", ")", ".", "strip", "(", ")", "\n", "category_mathml", "=", "get_category_mathml", "(", "category", ")", "\n", "# add ETtype, polarity", "\n", "mathml_ETtype_str", "=", "''", "\n", "mathml_polarity_str", "=", "''", "\n", "if", "ccg_node", ".", "get", "(", "'ETtype'", ")", ":", "mathml_ETtype_str", "=", "get_ETtype_mathml", "(", "ccg_node", ".", "get", "(", "'ETtype'", ")", ")", "\n", "if", "ccg_node", ".", "get", "(", "'polarity'", ")", ":", "mathml_polarity_str", "=", "get_polarity_mathml", "(", "ccg_node", ".", "get", "(", "'polarity'", ")", ")", "\n", "if", "len", "(", "ccg_node", ")", "==", "0", ":", "# terminal node", "\n", "        ", "token_id", "=", "ccg_node", ".", "get", "(", "'terminal'", ")", "\n", "token", "=", "find_node_by_id", "(", "token_id", ",", "tokens", ")", "\n", "surf", "=", "token", ".", "get", "(", "'surf'", ")", "\n", "surf_mathml", "=", "get_surface_mathml", "(", "surf", ")", "\n", "pos", "=", "token", ".", "get", "(", "'pos'", ")", "\n", "pos_mathml", "=", "get_pos_mathml", "(", "pos", ")", "\n", "entity", "=", "token", ".", "get", "(", "'entity'", ")", "\n", "if", "not", "entity", "==", "None", ":", "\n", "            ", "entity_mathml", "=", "get_entity_mathml", "(", "entity", ")", "\n", "pos_mathml", "=", "pos_mathml", "+", "\"<mtext>,</mtext><mspace width='.1em'/>\"", "+", "entity_mathml", "\n", "", "pos1", "=", "token", ".", "get", "(", "'pos1'", ")", "\n", "if", "not", "(", "pos1", "==", "None", "or", "pos1", "==", "'*'", ")", ":", "\n", "            ", "pos1_mathml", "=", "get_pos_mathml", "(", "pos1", ")", "\n", "pos_mathml", "=", "pos_mathml", "+", "\"<mspace width='.1em'/>\"", "+", "pos1_mathml", "\n", "", "pos2", "=", "token", ".", "get", "(", "'pos2'", ")", "\n", "if", "not", "(", "pos2", "==", "None", "or", "pos2", "==", "'*'", ")", ":", "\n", "            ", "pos2_mathml", "=", "get_pos_mathml", "(", "pos2", ")", "\n", "pos_mathml", "=", "pos_mathml", "+", "\"<mspace width='.1em'/>\"", "+", "pos2_mathml", "\n", "", "pos3", "=", "token", ".", "get", "(", "'pos3'", ")", "\n", "if", "not", "(", "pos3", "==", "None", "or", "pos3", "==", "'*'", ")", ":", "\n", "            ", "pos3_mathml", "=", "get_pos_mathml", "(", "pos3", ")", "\n", "pos_mathml", "=", "pos_mathml", "+", "\"<mspace width='.1em'/>\"", "+", "pos3_mathml", "\n", "", "if", "pos", "==", "'.'", ":", "# punctuation", "\n", "            ", "mathml_str", "=", "get_fraction_mathml", "(", "category_mathml", ",", "surf_mathml", ",", "'0'", ")", "\n", "", "else", ":", "\n", "            ", "mathml_pos_str", "=", "get_fraction_mathml", "(", "category_mathml", ",", "pos_mathml", ",", "'0'", ")", "\n", "mathml_str", "=", "get_fraction_mathml", "(", "mathml_pos_str", ",", "surf_mathml", ",", "'0'", ")", "\n", "# add ETtype, polarity", "\n", "if", "mathml_ETtype_str", ":", "\n", "                ", "mathml_str", "=", "get_fraction_mathml", "(", "mathml_ETtype_str", ",", "mathml_str", ",", "'0'", ")", "\n", "", "if", "mathml_polarity_str", ":", "\n", "                ", "mathml_str", "=", "get_fraction_mathml", "(", "mathml_polarity_str", ",", "mathml_str", ",", "'0'", ")", "\n", "\n", "", "", "", "elif", "len", "(", "ccg_node", ")", "==", "1", ":", "# non term node w/ one child", "\n", "        ", "mathml_str_child", "=", "convert_node_to_mathml", "(", "ccg_node", "[", "0", "]", ",", "sem_tree", ",", "tokens", ")", "\n", "rule", "=", "ccg_node", ".", "get", "(", "'rule'", ")", "\n", "mathml_str", "=", "get_fraction_mathml", "(", "category_mathml", ",", "mathml_str_child", ",", "'3'", ",", "rule", ")", "\n", "# add ETtype, polarity", "\n", "if", "mathml_ETtype_str", ":", "\n", "            ", "mathml_str", "=", "get_fraction_mathml", "(", "mathml_ETtype_str", ",", "mathml_str", ",", "'0'", ")", "\n", "", "if", "mathml_polarity_str", ":", "\n", "            ", "mathml_str", "=", "get_fraction_mathml", "(", "mathml_polarity_str", ",", "mathml_str", ",", "'0'", ")", "\n", "\n", "", "", "elif", "len", "(", "ccg_node", ")", ">", "0", ":", "# non term node w/ 2 or more children", "\n", "        ", "mathml_str_children", "=", "''", "\n", "for", "child", "in", "ccg_node", ":", "\n", "            ", "mathml_str_child", "=", "convert_node_to_mathml", "(", "child", ",", "sem_tree", ",", "tokens", ")", "\n", "mathml_str_children", "+=", "mathml_str_child", "\n", "", "rule", "=", "ccg_node", ".", "get", "(", "'rule'", ")", "\n", "mathml_str", "=", "get_fraction_mathml", "(", "category_mathml", ",", "mathml_str_children", ",", "'3'", ",", "rule", ")", "\n", "# add ETtype, polarity", "\n", "if", "mathml_ETtype_str", ":", "\n", "            ", "mathml_str", "=", "get_fraction_mathml", "(", "mathml_ETtype_str", ",", "mathml_str", ",", "'0'", ")", "\n", "", "if", "mathml_polarity_str", ":", "\n", "            ", "mathml_str", "=", "get_fraction_mathml", "(", "mathml_polarity_str", ",", "mathml_str", ",", "'0'", ")", "\n", "\n", "", "", "if", "sem_tree", "is", "not", "None", "and", "kDisplaySemantics", ":", "\n", "        ", "span_id", "=", "ccg_node", ".", "get", "(", "'id'", ")", "\n", "sem_node", "=", "find_node_by_id", "(", "span_id", ",", "sem_tree", ")", "\n", "semantics", "=", "sem_node", ".", "get", "(", "'sem'", ")", "\n", "semantics_mathml", "=", "get_semantics_mathml", "(", "semantics", ")", "\n", "mathml_str", "=", "get_fraction_mathml", "(", "semantics_mathml", ",", "mathml_str", ",", "'0'", ")", "\n", "\n", "# print('\\n\\n-------------Im a node-------------', file=sys.stderr)", "\n", "# print(mathml_str, file=sys.stderr)", "\n", "\n", "", "return", "mathml_str", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_surf_from_xml_node": [[233, 237], ["node.xpath"], "function", ["None"], ["", "def", "get_surf_from_xml_node", "(", "node", ")", ":", "\n", "    ", "tokens", "=", "node", ".", "xpath", "(", "\n", "\"./tokens/token[not(@surf='*')]/@surf | ./tokens/token[@surf='*']/@base\"", ")", "\n", "return", "' '", ".", "join", "(", "tokens", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_doc_to_mathml": [[238, 286], ["int", "enumerate", "doc.xpath", "doc.xpath", "doc.xpath", "int", "visualization_tools.get_surf_from_xml_node", "sentence.xpath", "sentence.xpath", "sentence.xpath", "range", "sentence.get", "len", "len", "len", "ccg_trees[].get", "str", "ccg2lambda_tools.build_ccg_tree", "ccg2lambda_tools.build_ccg_tree", "len", "visualization_tools.convert_node_to_mathml"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.get_surf_from_xml_node", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_node_to_mathml"], ["", "def", "convert_doc_to_mathml", "(", "doc", ",", "use_gold_trees", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    This function expects an XML <document>, which is then converted\n    into a presentation MathML string.\n    \"\"\"", "\n", "num_sentences", "=", "int", "(", "doc", ".", "xpath", "(", "'count(./sentences/sentence)'", ")", ")", "\n", "mathml_str", "=", "\"\"", "\n", "for", "sent_ind", ",", "sentence", "in", "enumerate", "(", "doc", ".", "xpath", "(", "'./sentences/sentence'", ")", ")", ":", "\n", "        ", "gold_tree_index", "=", "int", "(", "sentence", ".", "get", "(", "'gold_tree'", ",", "-", "1", ")", ")", "\n", "if", "sent_ind", "<", "num_sentences", "-", "1", ":", "\n", "            ", "sentence_label", "=", "'Premise {0}'", ".", "format", "(", "sent_ind", ")", "\n", "", "else", ":", "\n", "            ", "sentence_label", "=", "'Conclusion'", "\n", "", "sentence_text", "=", "get_surf_from_xml_node", "(", "sentence", ")", "\n", "ccg_trees", "=", "sentence", ".", "xpath", "(", "'./ccg'", ")", "\n", "sem_trees", "=", "sentence", ".", "xpath", "(", "'./semantics'", ")", "\n", "tokens", "=", "sentence", ".", "xpath", "(", "'./tokens'", ")", "\n", "if", "not", "tokens", ":", "\n", "            ", "return", "mathml_str", "\n", "", "tokens", "=", "tokens", "[", "0", "]", "\n", "assert", "len", "(", "ccg_trees", ")", ">=", "len", "(", "sem_trees", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "ccg_trees", ")", ")", ":", "\n", "            ", "ccg_tree_id", "=", "ccg_trees", "[", "i", "]", ".", "get", "(", "'id'", ",", "str", "(", "i", ")", ")", "\n", "try", ":", "\n", "                ", "ccg_tree", "=", "build_ccg_tree", "(", "ccg_trees", "[", "i", "]", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "mathml_str", "+=", "\"<p>{0}, tree {1}: {2}</p>\\n\"", ".", "format", "(", "\n", "sentence_label", ",", "ccg_tree_id", ",", "sentence_text", ")", "+", "\"<p>Syntactic parse error. Visualization skipped.</p>\"", "\n", "continue", "\n", "", "if", "gold_tree_index", "==", "i", ":", "\n", "                ", "ccg_tree_id", "+=", "\" (gold)\"", "\n", "", "sem_tree", "=", "None", "if", "i", ">=", "len", "(", "sem_trees", ")", "else", "sem_trees", "[", "i", "]", "\n", "if", "sem_tree", "is", "not", "None", ":", "\n", "                ", "sem_tree", "=", "build_ccg_tree", "(", "sem_tree", ")", "\n", "", "mathml_str", "+=", "\"<p>{0}, tree {1}: {2}</p>\\n\"", ".", "format", "(", "\n", "sentence_label", ",", "ccg_tree_id", ",", "sentence_text", ")", "+", "\"<math xmlns='http://www.w3.org/1998/Math/MathML'>\\n\"", "+", "convert_node_to_mathml", "(", "ccg_tree", ",", "sem_tree", ",", "tokens", ")", "+", "\"</math>\\n\"", "\n", "", "", "verbatim_strings", "=", "doc", ".", "xpath", "(", "'./proof/master_theorem/theorems/theorem/coq_script/text()'", ")", "\n", "verbatim_text", "=", "\"\"", "\n", "if", "verbatim_strings", ":", "\n", "       ", "verbatim_text", "=", "\"<p>Script piped to coq</p>\"", "\n", "for", "vb_str", "in", "verbatim_strings", ":", "\n", "           ", "verbatim_text", "+=", "\"<pre>\\n\"", "+", "vb_str", "+", "\"\\n</pre>\\n\"", "\n", "", "", "doc_mathml_str", "=", "'{0}\\n{1}'", ".", "format", "(", "mathml_str", ",", "verbatim_text", ")", "\n", "return", "doc_mathml_str", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.wrap_mathml_in_html": [[287, 311], ["None"], "function", ["None"], ["", "def", "wrap_mathml_in_html", "(", "mathml_str", ")", ":", "\n", "    ", "html_str", "=", "\"\"\"\\\n    <!DOCTYPE html>\n    <html lang='en'>\n    <head>\n      <meta charset='UTF-8'/>\n      <title>CCG to Lambda conversion</title>\n      <style>\n        body {\n          font-size: 1em;\n        }\n      </style>\n      <script type=\"text/javascript\"\n              src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n      </script>\n    </head>\n    <body>\n    \"\"\"", "\n", "html_str", "+=", "mathml_str", "\n", "html_str", "+=", "\"\"\"\\\n    </body>\n    </html>\n    \"\"\"", "\n", "return", "html_str", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_root_to_mathml": [[312, 331], ["enumerate", "visualization_tools.wrap_mathml_in_html", "root.xpath", "doc.get", "visualization_tools.convert_doc_to_mathml", "doc_mathml_strs.append"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.wrap_mathml_in_html", "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_doc_to_mathml"], ["", "def", "convert_root_to_mathml", "(", "root", ",", "use_gold_trees", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    This function expects an XML root. Then, it converts each document doc\n    into a presentation MathML string, and wraps them with HTML code.\n    \"\"\"", "\n", "doc_mathml_strs", "=", "[", "]", "\n", "for", "doc_ind", ",", "doc", "in", "enumerate", "(", "root", ".", "xpath", "(", "'./document'", ")", ")", ":", "\n", "        ", "doc_id", "=", "doc", ".", "get", "(", "'id'", ",", "doc_ind", ")", "\n", "doc_mathml_str", "=", "convert_doc_to_mathml", "(", "doc", ",", "use_gold_trees", ")", "\n", "\n", "\n", "# print(doc_id)", "\n", "# print(doc_mathml_str)", "\n", "# exit()", "\n", "\n", "\n", "doc_mathml_strs", ".", "append", "(", "doc_mathml_str", ")", "\n", "", "html_str", "=", "wrap_mathml_in_html", "(", "'\\n'", ".", "join", "(", "[", "s", "for", "s", "in", "doc_mathml_strs", "]", ")", ")", "\n", "return", "html_str", "\n", "\n"]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_doc_to_mathml_": [[333, 395], ["doc.xpath", "sentence_ids.append", "range", "cgi.escape", "doc.xpath", "ccg2lambda_tools.build_ccg_tree", "len", "len", "len", "len", "int", "ccg_trees.append", "ccg2lambda_tools.build_ccg_tree", "ccg2lambda_tools.build_ccg_tree", "doc.xpath", "len", "range", "tokens[].xpath", "sentence.get", "doc.xpath", "visualization_tools.convert_node_to_mathml", "sentence.xpath"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_node_to_mathml"], ["", "def", "convert_doc_to_mathml_", "(", "doc", ",", "verbatim_strings", "=", "[", "]", ",", "use_gold_trees", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    This function expects a list of ccg_trees, and a list of tokens\n    (as produced by transccg). Then, it converts each pair (ccg_tree, ccg_tokens)\n    into a presentation MathML string, and wraps them with HTML code.\n    verbatim_strings contains a list of strings that should be printed\n    verbatim at the end of the HTML document, for debugging.\n    \"\"\"", "\n", "ccg_trees", "=", "[", "]", "\n", "if", "use_gold_trees", ":", "\n", "        ", "for", "sentence", "in", "doc", ".", "xpath", "(", "'./sentences/sentence'", ")", ":", "\n", "            ", "gold_tree_index", "=", "int", "(", "sentence", ".", "get", "(", "'gold_tree'", ",", "'0'", ")", ")", "\n", "ccg_trees", ".", "append", "(", "sentence", ".", "xpath", "(", "'./ccg'", ")", "[", "gold_tree_index", "]", ")", "\n", "", "ccg_trees", "=", "[", "build_ccg_tree", "(", "c", ")", "for", "c", "in", "ccg_trees", "]", "\n", "", "else", ":", "\n", "        ", "ccg_trees", "=", "[", "build_ccg_tree", "(", "c", ")", "for", "c", "in", "doc", ".", "xpath", "(", "'./sentences/sentence/ccg[1]'", ")", "]", "\n", "", "sem_trees", "=", "[", "build_ccg_tree", "(", "c", ")", "for", "c", "in", "doc", ".", "xpath", "(", "'./sentences/sentence/semantics'", ")", "]", "\n", "if", "not", "sem_trees", ":", "\n", "        ", "sem_trees", "=", "[", "None", "]", "*", "len", "(", "ccg_trees", ")", "\n", "", "tokens", "=", "doc", ".", "xpath", "(", "'./sentences/sentence/tokens'", ")", "\n", "assert", "len", "(", "ccg_trees", ")", "==", "len", "(", "tokens", ")", "\n", "num_hypotheses", "=", "len", "(", "ccg_trees", ")", "-", "1", "\n", "sentence_ids", "=", "[", "\"Premise {0}: \"", ".", "format", "(", "i", "+", "1", ")", "for", "i", "in", "range", "(", "num_hypotheses", ")", "]", "\n", "sentence_ids", ".", "append", "(", "\"Conclusion: \"", ")", "\n", "mathml_str", "=", "\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "ccg_trees", ")", ")", ":", "\n", "        ", "sentence_surface", "=", "' '", ".", "join", "(", "tokens", "[", "i", "]", ".", "xpath", "(", "'token/@surf'", ")", ")", "\n", "mathml_str", "+=", "\"<p>\"", "+", "sentence_ids", "[", "i", "]", "+", "sentence_surface", "+", "\"</p>\\n\"", "+", "\"<math xmlns='http://www.w3.org/1998/Math/MathML'>\"", "+", "convert_node_to_mathml", "(", "ccg_trees", "[", "i", "]", ",", "sem_trees", "[", "i", "]", ",", "tokens", "[", "i", "]", ")", "+", "\"</math>\"", "\n", "\n", "", "verbatim_text", "=", "\"\"", "\n", "if", "verbatim_strings", ":", "\n", "       ", "verbatim_text", "=", "\"<p>Script piped to coq</p>\"", "\n", "for", "vb_str", "in", "verbatim_strings", ":", "\n", "           ", "verbatim_text", "+=", "\"<pre>\\n\"", "+", "vb_str", "+", "\"\\n</pre>\\n\"", "\n", "\n", "", "", "html_str", "=", "\"\"\"\\\n  <!doctype html>\n  <html lang='en'>\n  <head>\n    <style>\n      body {\n        font-size: 1em;\n      }\n    </style>\n    <meta charset='UTF-8'>\n    <title>CCG to Lambda conversion</title>\n    <script type=\"text/javascript\"\n            src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n    </script>\n  </head>\n  <body>\n  \"\"\"", "\n", "html_str", "+=", "mathml_str", "\n", "html_str", "+=", "verbatim_text", "\n", "html_str", "+=", "\"\"\"\\\n  </body>\n  </html>\n  \"\"\"", "\n", "return", "cgi", ".", "escape", "(", "html_str", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualize.main": [[27, 56], ["textwrap.dedent", "argparse.ArgumentParser", "etree.XMLParser.add_argument", "etree.XMLParser.add_argument", "etree.XMLParser.parse_args", "logging.basicConfig", "lxml.etree.XMLParser", "lxml.etree.parse", "visualization_tools.convert_root_to_mathml", "print", "os.path.exists", "print", "sys.exit"], "function", ["home.repos.pwc.inspect_result.huhailinguist_ccg2mono.files_for_ccg2lambda.visualization_tools.convert_root_to_mathml"], ["def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "DESCRIPTION", "=", "textwrap", ".", "dedent", "(", "\"\"\"\\\n            Prints graphically in HTML the CCG tree. If <semantics> content\n            is also present in the XML file, then logical formulas appear\n            below the syntactic categories to show the semantic composition.\n            The input file with the CCG tree should follow Jigg's format:\n            https://github.com/mynlp/jigg\n      \"\"\"", ")", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "formatter_class", "=", "argparse", ".", "RawDescriptionHelpFormatter", ",", "\n", "description", "=", "DESCRIPTION", ")", "\n", "parser", ".", "add_argument", "(", "\"trees_xml\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--nbest\"", ",", "nargs", "=", "'?'", ",", "type", "=", "int", ",", "default", "=", "\"1\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "trees_xml", ")", ":", "\n", "        ", "print", "(", "'File does not exist: {0}'", ".", "format", "(", "args", ".", "trees_xml", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "logging", ".", "basicConfig", "(", "level", "=", "logging", ".", "WARNING", ")", "\n", "\n", "parser", "=", "etree", ".", "XMLParser", "(", "remove_blank_text", "=", "True", ")", "\n", "root", "=", "etree", ".", "parse", "(", "args", ".", "trees_xml", ",", "parser", ")", "\n", "\n", "# print(root)", "\n", "\n", "html_str", "=", "convert_root_to_mathml", "(", "root", ")", "\n", "print", "(", "html_str", ")", "\n", "\n"]]}