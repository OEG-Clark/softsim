{"home.repos.pwc.inspect_result.drscotthawley_signaltrain.None.gen_dataset.gen_one_io_pair": [[39, 152], ["len", "range", "effect.go_wc", "signaltrain.audio.write_audio_file", "signaltrain.audio.write_audio_file", "len", "signaltrain.audio.read_audio_file", "range", "effect.knobs_wc", "signaltrain.audio.int2knobs", "len", "knobs_sigfigs.append", "print", "x.astype", "y.astype", "len", "len", "len", "random.randint", "random.randint", "numpy.random.choice", "signaltrain.audio.synth_input_sample", "max", "numpy.random.rand", "float", "float", "str", "print", "numpy.max", "abs", "numpy.min", "os.path.exists", "os.makedirs", "str"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.FileEffect.go_wc", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.write_audio_file", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.write_audio_file", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.read_audio_file", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.knobs_wc", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.int2knobs", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.synth_input_sample"], ["def", "gen_one_io_pair", "(", "name", ",", "t", ",", "x", ",", "sr", ",", "effect", ",", "settings_per", ",", "log_interval", ",", "infile_list", ",", "num_outfiles", ",", "start_output_i", ",", "outfile_i", ")", ":", "\n", "    ", "\"\"\"\n    One instance to be called in trivially-parallel implentation\n\n    Produces input & output (target) audio clips, at one (random) knob setting for the whole thing\n    This routine is called many times, either in serial or parallel.\n\n\n    Inputs:\n        name: name of the dataset (output subdirectory )\n        t: range of time values used in function synthesis, for each clip\n        x: pre-allocated storage for full input signal\n        sr: sample rate in Hz\n        effect: a member of the audio.Effect class\n        settings_per:  May be None.  # of settings per knob. if None, use random value\n        log_interval: how often to print status messages\n        num_clips: number of clips\n        outfile_i: an index number denoting which (random) audio clip this will be\n    Outputs:\n        Two .wav files, one for the input and one for the target output from the effect\n        The filename of the target audio will include the knob settings, in the order they appear in effect.\n           Thus the filename will need to be parsed to obtain these values for network training & inference.\n    \"\"\"", "\n", "outpath", "=", "name", "+", "'/'", "\n", "\n", "# Decide where this data is coming from", "\n", "if", "infile_list", "is", "not", "None", ":", "# use pre-existing input files", "\n", "# read audio from file on the list", "\n", "        ", "infile_i", "=", "outfile_i", "%", "len", "(", "infile_list", ")", "# sequentially walk through and 'wrap-around' end of infile list", "\n", "#infile_i = np.random.randint(len(infile_list))  # just grab some random file", "\n", "infilename", "=", "infile_list", "[", "infile_i", "]", "\n", "\n", "clip_len", "=", "len", "(", "x", ")", "# signal length is stored in x from earlier", "\n", "\n", "x", ",", "sr", "=", "st", ".", "audio", ".", "read_audio_file", "(", "infilename", ",", "sr", "=", "sr", ",", "dtype", "=", "dtype", ",", "warn", "=", "False", ")", "# overwrite x by reading audio", "\n", "\n", "# but only use a random subset of x, given by len(t) (which was set by --dur)", "\n", "\n", "# grab a random part of the file", "\n", "if", "clip_len", ">=", "len", "(", "x", ")", ":", "# unless there's not enough audio in the file to justify this", "\n", "            ", "randi", "=", "0", "\n", "clip_len", "=", "len", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "randi", "=", "random", ".", "randint", "(", "0", ",", "x", ".", "shape", "[", "0", "]", "-", "clip_len", "-", "1", ")", "# random index at which to start the clip", "\n", "", "x", "=", "x", "[", "randi", ":", "randi", "+", "clip_len", "]", "\n", "\n", "# destination output dir: base it on what's the input path", "\n", "if", "'Train'", "in", "infilename", ":", "\n", "            ", "outpath", "+=", "'Train/'", "\n", "", "elif", "'Val'", "in", "infilename", ":", "\n", "            ", "outpath", "+=", "'Val/'", "\n", "", "elif", "'Test'", "in", "infilename", ":", "\n", "            ", "outpath", "+=", "'Test/'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "outpath", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "outpath", ")", "\n", "\n", "", "", "", "else", ":", "# synthesize new input", "\n", "# Input audio: synthesize or read from file", "\n", "        ", "clip_length", "=", "t", ".", "shape", "[", "0", "]", "\n", "num_clips", "=", "x", ".", "shape", "[", "0", "]", "//", "clip_length", "\n", "for", "clip_i", "in", "range", "(", "num_clips", ")", ":", "\n", "            ", "ibgn", ",", "iend", "=", "clip_i", "*", "clip_length", ",", "(", "clip_i", "+", "1", ")", "*", "clip_length", "\n", "chooser", "=", "np", ".", "random", ".", "choice", "(", "[", "0", ",", "1", ",", "2", ",", "4", ",", "6", ",", "7", ",", "8", ",", "9", "]", ")", "# skipping 5=\"bunch of spikes\"", "\n", "\n", "# added conditional normalization, to avoid any possible rescaling errors during training later", "\n", "tmp", "=", "st", ".", "audio", ".", "synth_input_sample", "(", "t", ",", "chooser", ")", "\n", "x", "[", "ibgn", ":", "iend", "]", "=", "tmp", "\n", "tmpmax", "=", "max", "(", "np", ".", "max", "(", "tmp", ")", ",", "abs", "(", "np", ".", "min", "(", "tmp", ")", ")", ")", "\n", "if", "tmpmax", ">", "1.0", ":", "\n", "                ", "x", "[", "ibgn", ":", "iend", "]", "/=", "tmpmax", "\n", "\n", "# and decide where to send it (for synthesized audio)", "\n", "", "", "if", "outfile_i", "/", "num_outfiles", ">", "0.8", ":", "\n", "            ", "outpath", "+=", "'Val/'", "\n", "", "else", ":", "\n", "            ", "outpath", "+=", "'Train/'", "\n", "\n", "# generate knob setting(s) -- one setting for the whole signal \"streamed target\"", "\n", "", "", "nk", "=", "len", "(", "effect", ".", "knob_ranges", ")", "# numknobs", "\n", "if", "(", "(", "'Train'", "not", "in", "outpath", ")", "and", "(", "'Val'", "not", "in", "outpath", ")", ")", "or", "(", "settings_per", "is", "None", ")", "or", "(", "outfile_i", ">=", "settings_per", "**", "nk", ")", ":", "\n", "# Then randomly choose knob settings", "\n", "        ", "knobs_nn", "=", "np", ".", "random", ".", "rand", "(", "nk", ")", "-", "0.5", "# uniform distribution of knob values", "\n", "knobs_wc", "=", "effect", ".", "knobs_wc", "(", "knobs_nn", ")", "# 'physical' knob values in \"world coordinates\" of the effect", "\n", "", "else", ":", "# sequentially choose knob settings", "\n", "        ", "knobs_wc", "=", "st", ".", "audio", ".", "int2knobs", "(", "outfile_i", ",", "effect", ".", "knob_ranges", ",", "settings_per", ")", "\n", "#print(f\"file #{outfile_i}, settings_per = {settings_per}, knobs_wc = {knobs_wc}\")", "\n", "\n", "# We need to enforce a certain number of significant digits to ensure reproducability (after we read the files back in)", "\n", "# The easiest way to do this is to print to string, and then convert back to values", "\n", "#  Plus we'll save the file notating the values in the effect's own unit 'coordinate system,' since that's likely how users will record data in the future", "\n", "", "knobs_sigfigs", ",", "knobs_str", "=", "[", "]", ",", "''", "\n", "for", "k", "in", "range", "(", "len", "(", "knobs_wc", ")", ")", ":", "\n", "        ", "k_str", "=", "'%s'", "%", "float", "(", "'%.4g'", "%", "knobs_wc", "[", "k", "]", ")", "\n", "knobs_sigfigs", ".", "append", "(", "float", "(", "k_str", ")", ")", "# save the values to pass to the effect", "\n", "knobs_str", "+=", "\"__\"", "+", "k_str", "# save the strings to use in the filename", "\n", "\n", "# Actually run the effect (on the entire audio stream at once, not chunk by chunk)", "\n", "", "y", ",", "x", "=", "effect", ".", "go_wc", "(", "x", ",", "knobs_sigfigs", ")", "\n", "\n", "# save files", "\n", "out_idx", "=", "start_output_i", "+", "outfile_i", "# hey, don't overwrite existing files", "\n", "outfilename_input", "=", "outpath", "+", "\"input_\"", "+", "str", "(", "out_idx", ")", "+", "\"_.wav\"", "# note the extra _ before the .wav. That ensures the input filenames sort in the same order as the targets", "\n", "outfilename_target", "=", "outpath", "+", "\"target_\"", "+", "str", "(", "out_idx", ")", "+", "\"_\"", "+", "effect", ".", "name", "+", "knobs_str", "+", "\".wav\"", "\n", "\n", "if", "(", "outfile_i", "%", "log_interval", "==", "0", ")", ":", "# status message every now & then. we do NOT output every file!", "\n", "        ", "if", "infile_list", "is", "not", "None", ":", "\n", "            ", "print", "(", "\"orig input file = \"", ",", "infilename", ")", "\n", "", "print", "(", "\"outfile_i = \"", ",", "outfile_i", ",", "\"/\"", ",", "num_outfiles", ",", "\", outpath = \"", ",", "outpath", ",", "\", outfilename_input = \"", ",", "outfilename_input", ",", "\", target = \"", ",", "outfilename_target", ",", "sep", "=", "\"\"", ")", "\n", "\n", "", "st", ".", "audio", ".", "write_audio_file", "(", "outfilename_input", ",", "x", ".", "astype", "(", "dtype", ",", "copy", "=", "False", ")", ",", "sr", ")", "\n", "st", ".", "audio", ".", "write_audio_file", "(", "outfilename_target", ",", "y", ".", "astype", "(", "dtype", ",", "copy", "=", "False", ")", ",", "sr", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.None.gen_dataset.gen_synth_data": [[154, 246], ["int", "range", "st.audio.Compressor_4c_OneSetting.info", "int", "numpy.zeros", "len", "functools.partial", "signaltrain.audio.Compressor_4c", "int", "print", "print", "open", "print", "print", "print", "print", "numpy.ceil", "numpy.arange", "glob.glob", "glob.glob", "print", "print", "glob.glob", "multiprocessing.cpu_count", "print", "multiprocessing.Pool", "range", "mp.Pool.map", "mp.Pool.close", "mp.Pool.join", "range", "signaltrain.audio.Compressor", "int", "len", "os.path.exists", "os.makedirs", "functools.partial.", "signaltrain.audio.Comp_Just_Thresh", "len", "signaltrain.audio.Compressor_4c_Large", "st.audio.Compressor_4c_OneSetting.knob_ranges.tolist", "signaltrain.audio.Compressor_4c_OneSetting", "print", "sys.exit"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.info"], ["", "def", "gen_synth_data", "(", "args", ")", ":", "\n", "\n", "# Parse command line arguments", "\n", "    ", "name", "=", "args", ".", "name", "\n", "num_outfiles", "=", "args", ".", "num", "\n", "sr", "=", "args", ".", "sr", "\n", "settings_per", "=", "args", ".", "sp", "\n", "signal_length", "=", "int", "(", "args", ".", "dur", "*", "sr", ")", "\n", "outfile_indices", "=", "range", "(", "num_outfiles", ")", "\n", "inpath", "=", "args", ".", "inpath", "\n", "\n", "if", "'comp_4c'", "==", "args", ".", "effect", ":", "\n", "        ", "effect", "=", "st", ".", "audio", ".", "Compressor_4c", "(", ")", "\n", "", "elif", "'comp'", "==", "args", ".", "effect", ":", "\n", "        ", "effect", "=", "st", ".", "audio", ".", "Compressor", "(", ")", "# 3-knob compressor", "\n", "", "elif", "'comp_t'", "==", "args", ".", "effect", ":", "\n", "        ", "effect", "=", "st", ".", "audio", ".", "Comp_Just_Thresh", "(", ")", "\n", "", "elif", "'comp_4c_large'", "==", "args", ".", "effect", ":", "\n", "        ", "effect", "=", "st", ".", "audio", ".", "Compressor_4c_Large", "(", ")", "\n", "", "elif", "'comp_one'", "==", "args", ".", "effect", ":", "\n", "        ", "effect", "=", "st", ".", "audio", ".", "Compressor_4c_OneSetting", "(", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Sorry, not set up to work for other effects\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "effect", ".", "info", "(", ")", "\n", "\n", "train_val_split", "=", "0.8", "# between 0 and 1, below number will be train, rest will be val 0.8 means 80-20 split", "\n", "if", "settings_per", "is", "not", "None", ":", "# evenly cover knob values in Train", "\n", "        ", "num_train_files", "=", "int", "(", "settings_per", "**", "len", "(", "effect", ".", "knob_ranges", ")", ")", "# Evenly spaces settings", "\n", "if", "(", "inpath", "is", "None", ")", "or", "(", "(", "'Train'", "not", "in", "inpath", ")", "and", "(", "'Val'", "not", "in", "inpath", ")", ")", ":", "\n", "            ", "num_outfiles", "=", "int", "(", "num_train_files", "/", "train_val_split", ")", "\n", "", "else", ":", "\n", "            ", "num_outfiles", "=", "num_train_files", "\n", "", "print", "(", "\"Evenly spacing\"", ",", "settings_per", ",", "\"settings across\"", ",", "len", "(", "effect", ".", "knob_ranges", ")", ",", "\" knob(s)\"", ",", "end", "=", "\"\"", ")", "\n", "print", "(", "\", for\"", ",", "num_train_files", ",", "\"files in Train and\"", ",", "num_outfiles", ",", "\"total files\"", ")", "\n", "\n", "# Make sure name, Test & Val directories exist", "\n", "", "for", "dir", "in", "[", "name", ",", "name", "+", "\"/Train\"", ",", "name", "+", "\"/Val\"", "]", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir", ")", "\n", "\n", "# create an effect_info.ini file in the new dataset directory", "\n", "", "", "with", "open", "(", "name", "+", "\"/effect_info.ini\"", ",", "\"w\"", ")", "as", "info_file", ":", "\n", "        ", "print", "(", "\"[effect]\"", ",", "file", "=", "info_file", ")", "\n", "print", "(", "f\"name = {effect.name}\"", ",", "file", "=", "info_file", ")", "\n", "print", "(", "f\"knob_names = {effect.knob_names}\"", ",", "file", "=", "info_file", ")", "\n", "print", "(", "f\"knob_ranges = {effect.knob_ranges.tolist()}\"", ",", "file", "=", "info_file", ")", "\n", "\n", "# for synthed inputs only:", "\n", "# Compute a few auxiliary variables", "\n", "# We will end up concatenating a number of \"clips\" which have some length", "\n", "# We'll adjust the length of total audio based on number of clips", "\n", "", "clip_length", "=", "4096", "\n", "num_clips", "=", "int", "(", "np", ".", "ceil", "(", "signal_length", "/", "clip_length", ")", ")", "\n", "signal_length", "=", "clip_length", "*", "num_clips", "\n", "\n", "# Set up some array storage we'll use multiple times", "\n", "t", "=", "np", ".", "arange", "(", "clip_length", ",", "dtype", "=", "dtype", ")", "/", "sr", "# time indeices", "\n", "x", "=", "np", ".", "zeros", "(", "signal_length", ",", "dtype", "=", "dtype", ")", "\n", "\n", "\n", "# If input files are specified via --inpath", "\n", "infile_list", "=", "None", "\n", "if", "inpath", "!=", "None", ":", "\n", "        ", "infile_list", "=", "glob", ".", "glob", "(", "inpath", "+", "\"/*.wav\"", ")", "\n", "infile_list", "+=", "glob", ".", "glob", "(", "inpath", "+", "\"/*/*.wav\"", ")", "\n", "infile_list", "=", "[", "x", "for", "x", "in", "infile_list", "if", "\"target\"", "not", "in", "x", "]", "# remove any 'target' audio", "\n", "print", "(", "\"\\ninfile_list =\"", ",", "infile_list", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Number of \"", ",", "clip_length", ",", "\"-length clips per synthesized input file: \"", ",", "num_clips", ",", "sep", "=", "\"\"", ")", "\n", "\n", "\n", "# was having problems with existing files getting overwritten", "\n", "", "num_already_there", "=", "len", "(", "glob", ".", "glob", "(", "name", "+", "\"/*/input*\"", ")", ")", "# count the number of pre-existing input files", "\n", "start_output_i", "=", "num_already_there", "# we're zero indexed", "\n", "\n", "# Loop over the number of audio files to generate", "\n", "log_every", "=", "100", "\n", "wrapper", "=", "partial", "(", "gen_one_io_pair", ",", "name", ",", "t", ",", "x", ",", "sr", ",", "effect", ",", "settings_per", ",", "log_every", ",", "infile_list", ",", "num_outfiles", ",", "start_output_i", ")", "\n", "if", "parallel", ":", "\n", "# spawn across many processes", "\n", "        ", "num_procs", "=", "mp", ".", "cpu_count", "(", ")", "\n", "print", "(", "\"Splitting\"", ",", "num_outfiles", ",", "\"jobs across\"", ",", "num_procs", ",", "\"processes\"", ")", "\n", "pool", "=", "mp", ".", "Pool", "(", "num_procs", ")", "\n", "indices", "=", "range", "(", "num_outfiles", ")", "\n", "results", "=", "pool", ".", "map", "(", "wrapper", ",", "indices", ")", "# Farm out list of files#'s to different procs", "\n", "pool", ".", "close", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "", "else", ":", "\n", "        ", "for", "outfile_i", "in", "range", "(", "num_outfiles", ")", ":", "\n", "            ", "wrapper", "(", "outfile_i", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.check_window_exists": [[68, 77], ["cv2.getWindowProperty", "print"], "function", ["None"], ["def", "check_window_exists", "(", "title", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "window_handle", "=", "cv2", ".", "getWindowProperty", "(", "title", ",", "0", ")", "\n", "#print(f\"window {title}: handle is {window_handle}\")", "\n", "return", "window_handle", "==", "0.0", "\n", "return", "True", "\n", "", "except", ":", "\n", "        ", "print", "(", "\"******  error checking for window \"", ",", "title", ")", "\n", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.show_2d": [[83, 99], ["numpy.clip().astype", "numpy.repeat", "cv2.applyColorMap", "cv2.namedWindow", "cv2.imshow", "len", "numpy.flip", "viz.check_window_exists", "cv2.resizeWindow", "numpy.clip", "numpy.transpose"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.flip", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.check_window_exists"], ["def", "show_2d", "(", "array_2d", ",", "title", "=", "\"weights_layer\"", ",", "colormap", "=", "rainbow", ",", "flip", "=", "True", ")", ":", "\n", "\n", "#print(\"weights_layer.shape = \",weights_layer.shape)", "\n", "    ", "if", "len", "(", "array_2d", ".", "shape", ")", "<", "2", ":", "\n", "        ", "return", "\n", "", "img", "=", "np", ".", "clip", "(", "array_2d", "*", "255", ",", "-", "255", ",", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "# scale", "\n", "if", "flip", ":", "\n", "        ", "img", "=", "np", ".", "flip", "(", "np", ".", "transpose", "(", "img", ")", ")", "\n", "", "img", "=", "np", ".", "repeat", "(", "img", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "3", ",", "axis", "=", "2", ")", "# add color channels", "\n", "img", "=", "cv2", ".", "applyColorMap", "(", "img", ",", "colormap", ")", "# rainbow: blue=low, red=high", "\n", "# see if it exists", "\n", "new_window", "=", "not", "check_window_exists", "(", "title", ")", "\n", "window", "=", "cv2", ".", "namedWindow", "(", "title", ",", "cv2", ".", "WINDOW_NORMAL", ")", "\n", "cv2", ".", "imshow", "(", "title", ",", "img", ")", "\n", "if", "new_window", ":", "\n", "        ", "cv2", ".", "resizeWindow", "(", "title", ",", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "0", "]", ")", "# show what we've got", "\n", "#aspect = img.shape[0] / img.shape[1]", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.draw_weights": [[108, 112], ["model.state_dict", "model.state_dict.items", "viz.show_2d", "value.data.squeeze().numpy", "value.data.squeeze", "str", "value.data.numpy"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.show_2d"], ["", "", "def", "draw_weights", "(", "model", ",", "colormap", "=", "rainbow", ")", ":", "\n", "    ", "sd", "=", "model", ".", "state_dict", "(", ")", "\n", "for", "key", ",", "value", "in", "sd", ".", "items", "(", ")", ":", "\n", "        ", "show_2d", "(", "value", ".", "data", ".", "squeeze", "(", ")", ".", "numpy", "(", ")", ",", "title", "=", "key", "+", "\" \"", "+", "str", "(", "value", ".", "data", ".", "numpy", "(", ")", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.random_color": [[114, 119], ["numpy.random.seed", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint"], "function", ["None"], ["", "", "def", "random_color", "(", "seed", "=", "None", ")", ":", "\n", "# seed is a cheap way of keeping the color from changing too frequently", "\n", "    ", "if", "seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "seed", "+", "1", ")", "# +1 because it gives you green for seed=0   :-)", "\n", "", "return", "(", "128", "+", "np", ".", "random", ".", "randint", "(", "127", ")", ",", "128", "+", "np", ".", "random", ".", "randint", "(", "127", ")", ",", "128", "+", "np", ".", "random", ".", "randint", "(", "127", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.draw_activations": [[127, 194], ["torch.as_tensor().unsqueeze().double().requires_grad_", "torch.as_tensor().unsqueeze().double().requires_grad_", "torch.as_tensor().unsqueeze().double().requires_grad_", "torch.as_tensor().unsqueeze().double().requires_grad_", "model.forward", "range", "numpy.array", "cv2.polylines", "len", "range", "cv2.putText", "cv2.namedWindow", "cv2.imshow", "len", "list", "int", "numpy.array", "cv2.polylines", "len", "layer_acts[].data.squeeze().detach().numpy", "screen.astype", "torch.as_tensor().unsqueeze().double", "torch.as_tensor().unsqueeze().double", "torch.as_tensor().unsqueeze().double", "torch.as_tensor().unsqueeze().double", "len", "zip", "list", "len", "numpy.array", "cv2.polylines", "len", "viz.show_2d", "zip", "layer_acts[].data.squeeze().detach", "list", "viz.random_color", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "layer_acts[].data.squeeze().detach().numpy", "numpy.clip", "zip", "layer_acts[].data.squeeze", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "layer_acts[].data.squeeze().detach", "numpy.clip", "layer_acts[].data.squeeze", "len", "len"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.show_2d", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.random_color"], ["def", "draw_activations", "(", "screen", ",", "model", ",", "mono_audio", ",", "xs", ",", "trig_level", "=", "None", ",", "title", "=", "\"activations (cyan=input, green=output)\"", ",", "gains", "=", "[", "1.0", ",", "1.0", "]", ")", ":", "\n", "\n", "# run the model", "\n", "    ", "x", "=", "torch", ".", "as_tensor", "(", "mono_audio", ")", ".", "unsqueeze", "(", "0", ")", ".", "double", "(", ")", ".", "requires_grad_", "(", "False", ")", "\n", "knobs", "=", "torch", ".", "as_tensor", "(", "knobs_nn", ")", ".", "unsqueeze", "(", "0", ")", ".", "double", "(", ")", ".", "requires_grad_", "(", "False", ")", "\n", "#torch.zeros(model.num_knobs, requires_grad=False).unsqueeze(0).double()  # TODO: allow user to change knobs", "\n", "\n", "y_hat", ",", "mag", ",", "mag_hat", ",", "layer_acts", "=", "model", ".", "forward", "(", "x", ",", "knobs", ",", "return_acts", "=", "True", ")", "\n", "\n", "\n", "\n", "screen", "*=", "0", "# clear the screen", "\n", "\n", "# parameters for the one window that will show all the audio activations together", "\n", "# count how many activations are 1d", "\n", "n_1d_acts", "=", "0", "# number of activations to show in oscilloscope besides the input", "\n", "for", "l", "in", "range", "(", "len", "(", "layer_acts", ")", ")", ":", "\n", "        ", "if", "len", "(", "layer_acts", "[", "l", "]", ".", "data", ".", "squeeze", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "shape", ")", "==", "1", ":", "\n", "            ", "n_1d_acts", "+=", "1", "\n", "", "", "max_amp_pixels", "=", "imHeight", "/", "(", "n_1d_acts", "+", "1", ")", "/", "2", "# maximum amplitude in pixels", "\n", "dy0", "=", "2", "*", "max_amp_pixels", "# spacing between zero lines", "\n", "\n", "# Draw Input audio", "\n", "act", "=", "mono_audio", "# first show the input", "\n", "y0", "=", "max_amp_pixels", "# zero line", "\n", "# minux sign after y0 in the following is because computer graphics are 'upside down'", "\n", "ys_in", "=", "(", "y0", "-", "max_amp_pixels", "*", "np", ".", "clip", "(", "act", "[", "-", "len", "(", "xs", ")", ":", "]", ",", "-", "1", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "pts_in", "=", "np", ".", "array", "(", "list", "(", "zip", "(", "xs", ",", "ys_in", ")", ")", ")", "# pair up xs & ys for input", "\n", "cv2", ".", "polylines", "(", "screen", ",", "[", "pts_in", "]", ",", "False", ",", "cyan", ")", "# draw lines connecting the points", "\n", "\n", "if", "trig_level", "is", "not", "None", ":", "# draw the trigger", "\n", "        ", "trig_pos", "=", "int", "(", "y0", "-", "trig_level", "*", "max_amp_pixels", ")", "\n", "pts_in", "=", "np", ".", "array", "(", "list", "(", "zip", "(", "[", "0", ",", "10", "]", ",", "[", "trig_pos", ",", "trig_pos", "]", ")", ")", ")", "\n", "cv2", ".", "polylines", "(", "screen", ",", "[", "pts_in", "]", ",", "False", ",", "yellow", ")", "\n", "\n", "\n", "# draw all other activations (besides input)", "\n", "", "n_acts", "=", "len", "(", "layer_acts", ")", "\n", "count_1d", "=", "0", "\n", "for", "l", "in", "range", "(", "len", "(", "layer_acts", ")", ")", ":", "\n", "        ", "act", "=", "layer_acts", "[", "l", "]", ".", "data", ".", "squeeze", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "#print(f\"layer {l} of {n_acts}: act.shape = {act.shape}, len = {len(act.shape)}\")", "\n", "if", "len", "(", "act", ".", "shape", ")", "==", "1", ":", "\n", "            ", "count_1d", "+=", "1", "\n", "y0", "=", "max_amp_pixels", "+", "(", "count_1d", ")", "*", "dy0", "# zero line", "\n", "act", "*=", "gains", "[", "1", "]", "\n", "ys_out", "=", "(", "y0", "-", "max_amp_pixels", "*", "np", ".", "clip", "(", "act", "[", "-", "len", "(", "xs", ")", ":", "]", ",", "-", "1", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "int", ")", "# gains[1] gets applied to weights directly", "\n", "#ys_out = ys_out[0:layer_out_dim]            # don't show more than is supposed to be there", "\n", "pts_out", "=", "np", ".", "array", "(", "list", "(", "zip", "(", "xs", ",", "ys_out", ")", ")", ")", "# pair up xs & ys for output", "\n", "if", "(", "count_1d", "<", "n_1d_acts", ")", ":", "\n", "                ", "color", "=", "random_color", "(", ")", "\n", "", "else", ":", "\n", "                ", "color", "=", "green", "\n", "", "cv2", ".", "polylines", "(", "screen", ",", "[", "pts_out", "]", ",", "False", ",", "color", ")", "\n", "", "if", "len", "(", "act", ".", "shape", ")", "==", "2", ":", "\n", "            ", "show_2d", "(", "act", ",", "title", "=", "f\"act_{l} {act.shape}\"", ")", "\n", "\n", "#cv2.text(screen, 'gains = '+str(gains))", "\n", "", "", "cv2", ".", "putText", "(", "screen", ",", "f\"gains = {gains[0]:.1f}, {gains[1]:.1f} \"", ",", "(", "10", ",", "30", ")", ",", "\n", "cv2", ".", "FONT_HERSHEY_SIMPLEX", ",", "0.9", ",", "(", "255", ",", "255", ",", "255", ")", ",", "lineType", "=", "cv2", ".", "LINE_AA", ")", "\n", "\n", "\n", "# draw the one window showing all the activations together", "\n", "window", "=", "cv2", ".", "namedWindow", "(", "title", ",", "cv2", ".", "WINDOW_NORMAL", ")", "# allow the window containing the image to be resized", "\n", "cv2", ".", "imshow", "(", "title", ",", "screen", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.find_trigger": [[199, 209], ["scipy.ndimage.interpolation.shift", "numpy.where", "numpy.where", "len", "numpy.logical_and", "numpy.logical_and"], "function", ["None"], ["def", "find_trigger", "(", "mono_audio", ",", "thresh", "=", "0.02", ",", "pos_slope", "=", "True", ")", ":", "# thresh = trigger level", "\n", "    ", "start_ind", "=", "None", "# this is where in the buffer the trigger should go; None", "\n", "shift_forward", "=", "shift", "(", "mono_audio", ",", "1", ",", "cval", "=", "0", ")", "\n", "if", "pos_slope", ":", "\n", "        ", "inds", "=", "np", ".", "where", "(", "np", ".", "logical_and", "(", "mono_audio", ">=", "thresh", ",", "shift_forward", "<=", "thresh", ")", ")", "\n", "", "else", ":", "\n", "        ", "inds", "=", "np", ".", "where", "(", "np", ".", "logical_and", "(", "mono_audio", "<=", "thresh", ",", "shift_forward", ">=", "thresh", ")", ")", "\n", "", "if", "(", "len", "(", "inds", "[", "0", "]", ")", ">", "0", ")", ":", "\n", "        ", "start_ind", "=", "inds", "[", "0", "]", "[", "0", "]", "\n", "", "return", "start_ind", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.instructions": [[214, 226], ["print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print"], "function", ["None"], ["def", "instructions", "(", ")", ":", "\n", "    ", "print", "(", "\"Keys: \"", ")", "\n", "print", "(", "\"  Q : quit \"", ")", "\n", "print", "(", "\"  = : increase input gain\"", ")", "\n", "print", "(", "\"  - : decrease input gain\"", ")", "\n", "print", "(", "\"  ] : increase output gain\"", ")", "\n", "print", "(", "\"  [ : decrease output gain\"", ")", "\n", "print", "(", "\"  ' : increase trigger level\"", ")", "\n", "print", "(", "\"  ; : decrease trigger level\"", ")", "\n", "print", "(", "\"      Two-finger scroll on trackpad will zoom in on 2D images\"", ")", "\n", "print", "(", "\"\"", ")", "\n", "print", "(", "\"Note: windows start out reduced in display size; can be resized at will.\"", ")", "\n", "#print(\"      (Don't beleive the 'Zoom:%' display; it doesn't reflect proper array size)\")", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.scope": [[234, 287], ["soundcard.default_microphone", "print", "viz.instructions", "numpy.zeros", "numpy.arange().astype", "numpy.arange", "viz.find_trigger", "sc.default_microphone.recorder", "mic.record", "min", "max", "numpy.pad", "viz.draw_activations", "viz.draw_activations", "cv2.waitKeyEx", "ord", "ord", "ord", "ord", "ord", "ord", "ord"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.instructions", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.find_trigger", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.draw_activations", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.draw_activations"], ["def", "scope", "(", "model", ",", "buf_size", "=", "2000", ",", "fs", "=", "44100", ")", ":", "\n", "\n", "    ", "default_mic", "=", "sc", ".", "default_microphone", "(", ")", "\n", "print", "(", "\"oscilloscope: listening on \"", ",", "default_mic", ")", "\n", "instructions", "(", ")", "\n", "\n", "trig_level", "=", "0.01", "# trigger value for input waveform", "\n", "gains", "=", "[", "1", ",", "1", "]", "# gains for input and output", "\n", "\n", "# allocate storage for 'screen'", "\n", "screen", "=", "np", ".", "zeros", "(", "(", "imHeight", ",", "imWidth", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "# 3=color channels", "\n", "xs", "=", "np", ".", "arange", "(", "imWidth", ")", ".", "astype", "(", "np", ".", "int", ")", "# x values of pixels (time samples)", "\n", "\n", "while", "(", "1", ")", ":", "# keep looping until someone stops this", "\n", "        ", "try", ":", "# sometimes the mic will give a RunTimeError while you're reizing windows", "\n", "            ", "with", "default_mic", ".", "recorder", "(", "samplerate", "=", "fs", ")", "as", "mic", ":", "\n", "                ", "audio_data", "=", "mic", ".", "record", "(", "numframes", "=", "buf_size", ")", "# get some audio from the mic", "\n", "", "audio_data", "*=", "gains", "[", "0", "]", "# apply gain before activation", "\n", "\n", "bgn", "=", "find_trigger", "(", "audio_data", "[", ":", ",", "0", "]", ",", "thresh", "=", "trig_level", ")", "# try to trigger", "\n", "layer_in_dim", "=", "model", ".", "in_chunk_size", "# length of input layer", "\n", "if", "bgn", "is", "not", "None", ":", "# we found a spot to trigger at", "\n", "                ", "end", "=", "min", "(", "bgn", "+", "layer_in_dim", ",", "buf_size", ")", "# don't go off the end of the buffer", "\n", "pad_len", "=", "max", "(", "0", ",", "layer_in_dim", "-", "(", "end", "-", "bgn", ")", ")", "# might have to pad with zeros", "\n", "padded_data", "=", "np", ".", "pad", "(", "audio_data", "[", "bgn", ":", "end", ",", "0", "]", ",", "(", "0", ",", "pad_len", ")", ",", "'constant'", ",", "constant_values", "=", "0", ")", "\n", "draw_activations", "(", "screen", ",", "model", ",", "padded_data", ",", "xs", ",", "trig_level", "=", "trig_level", ",", "gains", "=", "gains", ")", "# draw left channel", "\n", "", "else", ":", "\n", "                ", "draw_activations", "(", "screen", ",", "model", ",", "audio_data", "[", "0", ":", "layer_in_dim", ",", "0", "]", "*", "0", ",", "xs", ",", "trig_level", "=", "trig_level", ",", "gains", "=", "gains", ")", "# just draw zero line", "\n", "\n", "\n", "", "key", "=", "cv2", ".", "waitKeyEx", "(", "1", ")", "&", "0xFF", "# keyboard input", "\n", "\n", "# Controls:  (Couldn't get arrow keys to work.)", "\n", "if", "(", "key", "!=", "-", "1", ")", "and", "(", "key", "!=", "255", ")", ":", "\n", "#print('key = ',key)", "\n", "                ", "pass", "\n", "", "if", "ord", "(", "'q'", ")", "==", "key", ":", "# quit key", "\n", "                ", "break", "\n", "", "elif", "ord", "(", "'='", ")", "==", "key", ":", "\n", "                ", "gains", "[", "0", "]", "*=", "1.1", "\n", "", "elif", "ord", "(", "\"-\"", ")", "==", "key", ":", "\n", "                ", "gains", "[", "0", "]", "*=", "0.9", "\n", "", "elif", "ord", "(", "']'", ")", "==", "key", ":", "#  right bracket", "\n", "                ", "gains", "[", "1", "]", "*=", "1.1", "\n", "", "elif", "ord", "(", "'['", ")", "==", "key", ":", "# left bracket", "\n", "                ", "gains", "[", "1", "]", "*=", "0.9", "\n", "", "elif", "ord", "(", "\"'\"", ")", "==", "key", ":", "\n", "                ", "trig_level", "+=", "0.02", "\n", "", "elif", "ord", "(", "\";\"", ")", "==", "key", ":", "# letter p", "\n", "                ", "trig_level", "-=", "0.02", "\n", "", "", "except", ":", "\n", "            ", "pass", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.set_knobs": [[293, 311], ["len", "range", "exec", "cv2.rectangle", "cv2.putText", "cv2.imshow", "len", "numpy.array2string"], "function", ["None"], ["def", "set_knobs", "(", ")", ":", "\n", "    ", "global", "knob_names", ",", "knobs_nn", "\n", "setstr", "=", "'global knobs_nn;  knobs_nn = np.array(['", "\n", "num_knobs", "=", "len", "(", "knob_names", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "knob_names", ")", ")", ":", "\n", "        ", "knob_name", "=", "knob_names", "[", "i", "]", "\n", "setstr", "+=", "f\"{knob_name}\"", "\n", "if", "i", "<", "num_knobs", "-", "1", ":", "setstr", "+=", "','", "\n", "", "setstr", "+=", "'])'", "\n", "#print('setstr = ',setstr)", "\n", "exec", "(", "setstr", ")", "\n", "#knobs_wc = knobs_nn * ()", "\n", "knobs_wc", "=", "knob_ranges", "[", ":", ",", "0", "]", "+", "(", "knobs_nn", "+", "0.5", ")", "*", "(", "knob_ranges", "[", ":", ",", "1", "]", "-", "knob_ranges", "[", ":", ",", "0", "]", ")", "\n", "\n", "text", "=", "\"knobs_wc = \"", "+", "np", ".", "array2string", "(", "knobs_wc", ",", "precision", "=", "3", ",", "separator", "=", "','", ",", "suppress_small", "=", "True", ")", "\n", "cv2", ".", "rectangle", "(", "logo", ",", "(", "0", ",", "0", ")", ",", "(", "500", ",", "25", ")", ",", "(", "255", ",", "255", ",", "255", ")", ",", "-", "1", ")", "\n", "cv2", ".", "putText", "(", "logo", ",", "text", ",", "(", "10", ",", "20", ")", ",", "cv2", ".", "FONT_HERSHEY_SIMPLEX", ",", "0.4", ",", "(", "0", ",", "0", ",", "0", ")", ",", "lineType", "=", "cv2", ".", "LINE_AA", ")", "\n", "cv2", ".", "imshow", "(", "knob_controls_window", ",", "logo", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.make_controls": [[314, 338], ["print", "print", "numpy.zeros", "len", "range", "viz.set_knobs", "len", "exec", "exec", "exec", "numpy.array"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.viz.set_knobs"], ["", "def", "make_controls", "(", "cp_items", ")", ":", "\n", "    ", "global", "knob_ranges", ",", "knobs_nn", ",", "knob_names", "\n", "# cp_items are items in the checkpoint file", "\n", "for", "key", ",", "value", "in", "cp_items", ":", "\n", "        ", "if", "key", "==", "'knob_names'", ":", "\n", "            ", "knob_names", "=", "value", "\n", "", "elif", "key", "==", "'knob_ranges'", ":", "\n", "            ", "knob_ranges", "=", "np", ".", "array", "(", "value", ")", "\n", "", "", "print", "(", "\"knob_names = \"", ",", "knob_names", ")", "\n", "print", "(", "\"knob_ranges = \"", ",", "knob_ranges", ")", "\n", "\n", "knobs_nn", "=", "np", ".", "zeros", "(", "len", "(", "knob_names", ")", ")", "\n", "\n", "\n", "\n", "num_knobs", "=", "len", "(", "knob_names", ")", "\n", "for", "i", "in", "range", "(", "num_knobs", ")", ":", "\n", "        ", "knob_name", "=", "knob_names", "[", "i", "]", "\n", "exec", "(", "f\"global {knob_name}; {knob_name} = 0.0\"", ")", "\n", "fn_name", "=", "f\"on_{knob_name}_change\"", "\n", "exec", "(", "f'def {fn_name}(val): global {knob_name};  {knob_name} = val/100.0-0.5; set_knobs()'", ")", "\n", "exec", "(", "f\"cv2.createTrackbar(knob_name, knob_controls_window, 50, 100, {fn_name})\"", ")", "\n", "", "set_knobs", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.predict_long.predict_long": [[30, 80], ["print", "signaltrain.audio.sliding_window", "print", "numpy.tile", "torch.Tensor().to", "numpy.empty", "int", "print", "range", "print", "print", "signaltrain.audio.mu_compand", "print", "numpy.round", "print", "print", "numpy.tile", "torch.Tensor().to", "torch.Tensor().to", "model.forward", "numpy.append", "torch.Tensor", "y_hat.squeeze().cpu().detach().numpy().flatten().astype", "np.tile.astype", "torch.Tensor", "torch.Tensor", "np.tile.astype", "x[].astype", "y_hat.squeeze().cpu().detach().numpy().flatten", "y_hat.squeeze().cpu().detach().numpy", "y_hat.squeeze().cpu().detach", "y_hat.squeeze().cpu", "y_hat.squeeze"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.sliding_window", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.mu_compand", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward"], ["", "def", "predict_long", "(", "signal", ",", "knobs_nn", ",", "model", ",", "chunk_size", ",", "out_chunk_size", ",", "sr", "=", "44100", ",", "effect", "=", "None", ",", "device", "=", "\"cpu:0\"", ",", "compand", "=", "False", ")", ":", "\n", "\n", "# reshape input and knobs.  break signal up into overlapping windows", "\n", "    ", "overlap", "=", "chunk_size", "-", "out_chunk_size", "\n", "print", "(", "\"predict_long: chunk_size, out_chunk_size, overlap = \"", ",", "chunk_size", ",", "out_chunk_size", ",", "overlap", ")", "\n", "x", "=", "st", ".", "audio", ".", "sliding_window", "(", "signal", ",", "chunk_size", ",", "overlap", "=", "overlap", ")", "\n", "print", "(", "\"predict_long: x.shape, signal.shape = \"", ",", "x", ".", "shape", ",", "signal", ".", "shape", ")", "\n", "\n", "if", "compand", ":", "\n", "        ", "print", "(", "\"Companding input\"", ")", "\n", "x", "=", "st", ".", "audio", ".", "mu_compand", "(", "x", ")", "\n", "\n", "", "batch_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "if", "x", ".", "shape", "[", "0", "]", ">", "200", ":", "\n", "        ", "print", "(", "f\"**WARNING: effective batch size = {x.shape[0]}, may be too large and produce CUDA out of memory errors\"", ")", "\n", "batch_size", "=", "200", "\n", "\n", "", "knobs", "=", "np", ".", "tile", "(", "knobs_nn", ",", "(", "batch_size", ",", "1", ")", ")", "# repeat knob settings a bunch of times", "\n", "knobs_torch", "=", "torch", ".", "Tensor", "(", "knobs", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "y_pred", "=", "np", ".", "empty", "(", "shape", "=", "(", "0", ")", ")", "\n", "# move through the audio file, one batch at a time", "\n", "bmax", "=", "int", "(", "np", ".", "round", "(", "x", ".", "shape", "[", "0", "]", "/", "batch_size", ")", ")", "\n", "print", "(", "\"bmax = \"", ",", "bmax", ")", "\n", "for", "b", "in", "range", "(", "bmax", ")", ":", "\n", "        ", "print", "(", "'batch id b ='", ",", "b", ",", "end", "=", "\"\"", ")", "\n", "bstart", "=", "b", "*", "batch_size", "\n", "if", "b", "==", "bmax", "-", "1", ":", "# last batch", "\n", "            ", "batch_size", "=", "x", ".", "shape", "[", "0", "]", "-", "bstart", "\n", "", "print", "(", "', bstart = '", ",", "bstart", ",", "', batch_size = '", ",", "batch_size", ")", "\n", "# Move data to torch device", "\n", "knobs", "=", "np", ".", "tile", "(", "knobs_nn", ",", "(", "batch_size", ",", "1", ")", ")", "# repeat knob settings a bunch of times", "\n", "knobs_torch", "=", "torch", ".", "Tensor", "(", "knobs", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", ")", ".", "to", "(", "device", ")", "\n", "x_torch", "=", "torch", ".", "Tensor", "(", "x", "[", "bstart", ":", "bstart", "+", "batch_size", "]", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "# Do the model prediction", "\n", "y_hat", ",", "mag", ",", "mag_hat", "=", "model", ".", "forward", "(", "x_torch", ",", "knobs_torch", ")", "\n", "\n", "# Reassemble the output into one long signal", "\n", "# Note: we don't need (or want) to undo_sliding_window() because y_hat has no overlaps", "\n", "y_pred", "=", "np", ".", "append", "(", "y_pred", ",", "y_hat", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", ")", "\n", "\n", "# note that sliding_window() probably tacked zeros onto the end, so let's remember to take them off", "\n", "", "unique", "=", "x", ".", "shape", "[", "1", "]", "+", "(", "x", ".", "shape", "[", "0", "]", "-", "1", ")", "*", "(", "x", ".", "shape", "[", "1", "]", "-", "overlap", ")", "# number of unique values in windowed x (including extra zeros but not overlaps)", "\n", "num_extra", "=", "unique", "-", "signal", ".", "size", "# difference between that and original signal", "\n", "print", "(", "\"predict_long:  y_pred.shape, num_extra = \"", ",", "y_pred", ".", "shape", ",", "num_extra", ")", "\n", "if", "num_extra", ">", "0", ":", "\n", "        ", "return", "y_pred", "[", "0", ":", "-", "num_extra", "]", "\n", "", "else", ":", "\n", "        ", "return", "y_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.predict_long.calc_ct": [[82, 98], ["numpy.concatenate", "numpy.zeros", "numpy.arange", "len", "len", "min", "effect.go_wc", "numpy.zeros", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.FileEffect.go_wc"], ["", "", "def", "calc_ct", "(", "signal", ",", "effect", ",", "knobs_wc", ",", "out_chunk_size", ",", "chunk_size", ",", "sr", "=", "44100", ")", ":", "\n", "# calculate chunked target audio", "\n", "    ", "lookback_size", "=", "chunk_size", "-", "out_chunk_size", "\n", "if", "lookback_size", ">=", "0", ":", "\n", "        ", "padded_sig", "=", "np", ".", "concatenate", "(", "(", "np", ".", "zeros", "(", "lookback_size", ",", "dtype", "=", "np", ".", "float32", ")", ",", "signal", ")", ")", "\n", "y_ct", "=", "np", ".", "zeros", "(", "len", "(", "padded_sig", ")", ")", "# start with y_ct all zeros", "\n", "for", "i", "in", "np", ".", "arange", "(", "0", ",", "len", "(", "padded_sig", ")", ",", "out_chunk_size", ")", ":", "\n", "            ", "iend", "=", "min", "(", "i", "+", "chunk_size", ",", "len", "(", "padded_sig", ")", ")", "# where's the end of this", "\n", "in_chunk", "=", "padded_sig", "[", "i", ":", "iend", "]", "# grab input chunk from padded signal", "\n", "out_chunk", ",", "_", "=", "effect", ".", "go_wc", "(", "in_chunk", ",", "knobs_wc", ")", "# apply effect on this chunk", "\n", "if", "len", "(", "out_chunk", ")", ">", "out_chunk_size", ":", "# watch out for array sizes...", "\n", "                ", "out_chunk", "=", "out_chunk", "[", "-", "out_chunk_size", ":", "]", "\n", "", "itbgn", ",", "itend", "=", "iend", "-", "len", "(", "out_chunk", ")", ",", "iend", "\n", "y_ct", "[", "itbgn", ":", "itend", "]", "=", "out_chunk", "# paste the result into y_ct", "\n", "", "y_ct", "=", "y_ct", "[", "lookback_size", ":", "]", "# remove padding", "\n", "", "return", "y_ct", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.check_dataset.estimate_time_shift": [[86, 111], ["scipy.signal.correlate", "numpy.arange", "numpy.argmax", "print", "print", "len", "len", "print", "plt.subplots", "ax_x.get_shared_x_axes().join", "ax_x.plot", "ax_y.plot", "ax_corr.plot", "plt.show", "ax_x.get_shared_x_axes"], "function", ["None"], ["", "def", "estimate_time_shift", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\" Computes the cross-correlation between time series x and y, grabs the\n        index of where it's a maximum.  This yields the time difference in\n        samples between x and y.\n    \"\"\"", "\n", "if", "DEBUG", ":", "print", "(", "\"computing cross-correlation\"", ")", "\n", "corr", "=", "signal", ".", "correlate", "(", "y", ",", "x", ",", "mode", "=", "'same'", ",", "method", "=", "'fft'", ")", "\n", "if", "DEBUG", ":", "print", "(", "\"finished computing cross-correlation\"", ")", "\n", "\n", "nx", ",", "ny", "=", "len", "(", "x", ")", ",", "len", "(", "y", ")", "\n", "t_samples", "=", "np", ".", "arange", "(", "nx", ")", "\n", "ct_samples", "=", "t_samples", "-", "nx", "//", "2", "# try to center time shift (x axis) on zero", "\n", "cmax_ind", "=", "np", ".", "argmax", "(", "corr", ")", "# where is the max of the cross-correlation?", "\n", "dt", "=", "ct_samples", "[", "cmax_ind", "]", "# grab the time shift value corresponding to the max c-corr", "\n", "\n", "if", "DEBUG", ":", "\n", "        ", "print", "(", "\"cmax_ind, nx//2, ny//2, dt =\"", ",", "cmax_ind", ",", "nx", "//", "2", ",", "ny", "//", "2", ",", "dt", ")", "\n", "fig", ",", "(", "ax_x", ",", "ax_y", ",", "ax_corr", ")", "=", "plt", ".", "subplots", "(", "3", ",", "1", ")", "\n", "ax_x", ".", "get_shared_x_axes", "(", ")", ".", "join", "(", "ax_x", ",", "ax_y", ")", "\n", "ax_x", ".", "plot", "(", "t_samples", ",", "x", ")", "\n", "ax_y", ".", "plot", "(", "t_samples", ",", "y", ")", "\n", "ax_corr", ".", "plot", "(", "ct_samples", ",", "corr", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "return", "dt", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.check_dataset.is_acceptable": [[114, 117], ["filename.lower().endswith", "filename.lower"], "function", ["None"], ["", "def", "is_acceptable", "(", "filename", ")", ":", "\n", "    ", "return", "filename", ".", "lower", "(", ")", ".", "endswith", "(", "(", "'.wav'", ",", "'.mp3'", ",", "'.aif'", ",", "'.aiff'", ")", ")", "and", "(", "(", "'input_'", "in", "filename", ")", "or", "(", "'target_'", "in", "filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.ptsd2full.load_model": [[26, 61], ["torch.load", "print", "inspect.getargspec", "print", "torch.load.items", "len", "TheModelClass", "TheModelClass.load_state_dict", "os.path.isfile", "print", "sys.exit", "torch.load.keys", "print", "torch.load.items", "print", "print"], "function", ["None"], ["def", "load_model", "(", "infile", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "isfile", "(", "infile", ")", ":", "\n", "        ", "print", "(", "f\"Error: file {infile} not found.\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "\n", "# read the checkpoint file, first to cpu", "\n", "", "checkpoint", "=", "torch", ".", "load", "(", "infile", ",", "map_location", "=", "'cpu'", ")", "\n", "print", "(", "\"checkpoint.keys() = \"", ",", "checkpoint", ".", "keys", "(", ")", ")", "\n", "\n", "\n", "# grab any model-setup-info parameters needed from the checkpoint", "\n", "model_keys", "=", "inspect", ".", "getargspec", "(", "TheModelClass", ")", "\n", "print", "(", "\"TheModelClass expects kwargs:\"", ",", "model_keys", ")", "\n", "\n", "args", ",", "kwargs", "=", "[", "]", ",", "{", "}", "\n", "# populate kwargs with anything the model needs that is given in cp_keys", "\n", "for", "key", ",", "value", "in", "checkpoint", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "\" checking key = \"", ",", "key", ")", "\n", "if", "key", "in", "model_keys", ".", "args", ":", "\n", "            ", "print", "(", "f\"    **** Hey: key {key} is in both\"", ")", "\n", "kwargs", "[", "key", "]", "=", "value", "\n", "print", "(", "f\"          setting kwargs[{key}] = {value}\"", ")", "\n", "\n", "# set any more 'custom' kwargs you need", "\n", "", "", "kwargs", "[", "'num_knobs'", "]", "=", "len", "(", "checkpoint", "[", "'knob_names'", "]", ")", "# my special thing", "\n", "\n", "# setup the model  # <--- You have to do this yourself **", "\n", "model", "=", "TheModelClass", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "\n", "# populate the model weights from the state dict", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'state_dict'", "]", ")", "\n", "\n", "return", "model", ",", "checkpoint", ".", "items", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.lr_finder.lrfind": [[18, 56], ["print", "numpy.logspace", "matplotlib.figure", "matplotlib.semilogx", "numpy.log10", "numpy.log10", "model.forward", "lrs.append", "losses.append", "optimizer.zero_grad", "calc_loss.backward", "model.clip_grad_norm_", "optimizer.step", "matplotlib.show", "matplotlib.savefig", "matplotlib.close", "print", "len", "print", "x.to", "y.to", "knobs.to", "x_hat.float", "y_cuda.float", "mag.float", "calc_loss.item", "matplotlib.gcf", "signaltrain.st.loss_functions.calc_loss"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.calc_loss"], ["def", "lrfind", "(", "model", ",", "dataloader", ",", "optimizer", ",", "calc_loss", ",", "start", "=", "1e-6", ",", "stop", "=", "4e-3", ",", "num_lrs", "=", "150", ",", "to_screen", "=", "False", ")", ":", "\n", "    ", "\"\"\" Learning Rate finder.  See leslie howard, sylvian gugger & jeremy howard's work \"\"\"", "\n", "print", "(", "\"Running LR Find:\"", ",", "end", "=", "\"\"", ",", "flush", "=", "True", ")", "\n", "\n", "lrs", ",", "losses", "=", "[", "]", ",", "[", "]", "\n", "lr_tries", "=", "np", ".", "logspace", "(", "np", ".", "log10", "(", "start", ")", ",", "np", ".", "log10", "(", "stop", ")", ",", "num_lrs", ")", "\n", "ind", ",", "count", ",", "repeat", "=", "0", ",", "0", ",", "3", "\n", "for", "x", ",", "y", ",", "knobs", "in", "dataloader", ":", "\n", "        ", "count", "+=", "1", "\n", "if", "ind", ">=", "len", "(", "lr_tries", ")", ":", "\n", "            ", "break", "\n", "", "lr_try", "=", "lr_tries", "[", "ind", "]", "\n", "if", "count", "%", "repeat", "==", "0", ":", "# repeat over this many data points per lr value", "\n", "            ", "ind", "+=", "1", "\n", "print", "(", "\".\"", ",", "sep", "=", "\"\"", ",", "end", "=", "\"\"", ",", "flush", "=", "True", ")", "\n", "", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "=", "lr_try", "\n", "\n", "#x_cuda, y_cuda, knobs_cuda = datagen.new()", "\n", "x_cuda", ",", "y_cuda", ",", "knobs_cuda", "=", "x", ".", "to", "(", "device", ")", ",", "y", ".", "to", "(", "device", ")", ",", "knobs", ".", "to", "(", "device", ")", "\n", "x_hat", ",", "mag", ",", "mag_hat", "=", "model", ".", "forward", "(", "x_cuda", ",", "knobs_cuda", ")", "\n", "loss", "=", "calc_loss", "(", "x_hat", ".", "float", "(", ")", ",", "y_cuda", ".", "float", "(", ")", ",", "mag", ".", "float", "(", ")", ")", "\n", "lrs", ".", "append", "(", "lr_try", ")", "\n", "losses", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "model", ".", "clip_grad_norm_", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "plt", ".", "figure", "(", "1", ")", "\n", "plt", ".", "semilogx", "(", "lrs", ",", "losses", ")", "\n", "if", "to_screen", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "", "else", ":", "\n", "        ", "outfile", "=", "'lrfind.png'", "\n", "plt", ".", "savefig", "(", "outfile", ")", "\n", "plt", ".", "close", "(", "plt", ".", "gcf", "(", ")", ")", "\n", "print", "(", "\"\\nLR Find finished. See \"", "+", "outfile", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.soxeffect.is_number": [[39, 45], ["float"], "function", ["None"], ["def", "is_number", "(", "string", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "float", "(", "string", ")", "\n", "return", "True", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.soxeffect.ranges_to_vals": [[47, 65], ["str.split", "p.split", "soxeffect.is_number", "pranges.append", "pvals.append", "len", "float", "float", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.soxeffect.is_number"], ["", "", "def", "ranges_to_vals", "(", "str", ")", ":", "\n", "    ", "\"\"\"replace instances of comma-separated pairs of max,min numbers\n       with values randomly generated in between min & max (via uniform distribution)\n    \"\"\"", "\n", "out_str", "=", "''", "# this will be the final output", "\n", "pvals", ",", "pranges", "=", "[", "]", ",", "[", "]", "# list of parameter values used for naming files", "\n", "pars", "=", "str", ".", "split", "(", "' '", ")", "# first split on spaces", "\n", "for", "p", "in", "pars", ":", "\n", "        ", "mm", "=", "p", ".", "split", "(", "','", ")", "# split at comma for min & max", "\n", "valstr", "=", "mm", "[", "0", "]", "\n", "if", "is_number", "(", "valstr", ")", "and", "len", "(", "mm", ")", ">", "1", ":", "# if we have a range of numbers", "\n", "            ", "minval", ",", "maxval", "=", "float", "(", "valstr", ")", ",", "float", "(", "mm", "[", "1", "]", ")", "\n", "pranges", ".", "append", "(", "[", "minval", ",", "maxval", "]", ")", "\n", "val", "=", "minval", "+", "np", ".", "random", ".", "rand", "(", ")", "*", "(", "maxval", "-", "minval", ")", "\n", "valstr", "=", "f'{val:.3f}'", "# trunacte to 3 decimal points", "\n", "pvals", ".", "append", "(", "valstr", ")", "\n", "", "out_str", "+=", "f'{valstr} '", "\n", "", "return", "out_str", ",", "pvals", ",", "pranges", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.soxeffect.test_ranges_to_vals": [[67, 69], ["soxeffect.ranges_to_vals"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.soxeffect.ranges_to_vals"], ["", "def", "test_ranges_to_vals", "(", ")", ":", "# just a sample test", "\n", "    ", "ranges_to_vals", "(", "'0.7,.8 0.9 55.0 0.4 0.25,.3 2.0 -s'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.soxeffect.process_one_file": [[71, 87], ["soxeffect.ranges_to_vals", "out_file.replace.replace", "print", "os.system", "in_file.replace", "len"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.utils.soxeffect.ranges_to_vals"], ["", "def", "process_one_file", "(", "args_inputs", ",", "args_effect", ",", "args_params", ",", "i", ")", ":", "\n", "    ", "\"\"\" Given one input file (name), run sox on it\n    \"\"\"", "\n", "in_file", "=", "args_inputs", "[", "i", "]", "\n", "paramstr", ",", "pvals", ",", "pranges", "=", "ranges_to_vals", "(", "args_params", ")", "# replace ranges with random #s", "\n", "out_file", "=", "'target'", "+", "in_file", ".", "replace", "(", "'input'", ",", "''", ")", "# remove input & prepent target", "\n", "if", "len", "(", "pvals", ")", ">", "0", ":", "\n", "        ", "pvalstr", "=", "''", "\n", "for", "p", "in", "pvals", ":", "# note that pvals are strings, not numbers", "\n", "            ", "pvalstr", "+=", "f'__{p}'", "\n", "", "", "else", ":", "\n", "        ", "pvalstr", "=", "'_1'", "\n", "", "out_file", "=", "out_file", ".", "replace", "(", "'_.wav'", ",", "f'{pvalstr}.wav'", ")", "\n", "execstr", "=", "f'sox --multi-threaded {in_file} {out_file} {args_effect} {args_params}'", "\n", "print", "(", "\"  execstr = \"", ",", "execstr", ")", "\n", "os", ".", "system", "(", "execstr", ")", "# Execute sox for this setting", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.get_input_sample": [[39, 59], ["numpy.linspace", "signaltrain.audio.randsine", "signaltrain.audio.box", "signaltrain.audio.randsine", "signaltrain.audio.box", "signaltrain.audio.box", "signaltrain.audio.pluck", "numpy.random.rand", "numpy.random.rand", "next", "numpy.linspace", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.randsine", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.box", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.randsine", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.box", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.box", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pluck"], ["def", "get_input_sample", "(", "chooser", ",", "in_chunk_size", "=", "8192", ")", ":", "\n", "# input selection", "\n", "    ", "global", "t", ",", "sr", "\n", "t", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "in_chunk_size", ")", "\n", "if", "'sine'", "==", "chooser", ":", "\n", "        ", "return", "st", ".", "audio", ".", "randsine", "(", "t", ",", "freq_range", "=", "[", "5", ",", "20", "]", ")", "\n", "", "elif", "'box'", "==", "chooser", ":", "\n", "        ", "return", "st", ".", "audio", ".", "box", "(", "t", ",", "delta", "=", "0", ")", "\n", "", "elif", "'noisy sine'", "==", "chooser", ":", "\n", "        ", "return", "st", ".", "audio", ".", "randsine", "(", "t", ",", "freq_range", "=", "[", "5", ",", "20", "]", ")", "+", "0.1", "*", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "t", ".", "shape", "[", "0", "]", ")", "-", "1", ")", "\n", "", "elif", "'box * noise'", "==", "chooser", ":", "\n", "        ", "return", "st", ".", "audio", ".", "box", "(", "t", ")", "*", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "t", ".", "shape", "[", "0", "]", ")", "-", "1", ")", "\n", "", "elif", "'box + noise'", "==", "chooser", ":", "\n", "        ", "return", "st", ".", "audio", ".", "box", "(", "t", ")", "+", "0.5", "*", "np", ".", "random", ".", "rand", "(", ")", "*", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "t", ".", "shape", "[", "0", "]", ")", "-", "1", ")", "\n", "", "elif", "'pluck'", "==", "chooser", ":", "\n", "        ", "return", "st", ".", "audio", ".", "pluck", "(", "t", ")", "\n", "", "elif", "'real audio'", "==", "chooser", ":", "\n", "        ", "x", "=", "next", "(", "ra_gen", ")", "\n", "t", "=", "np", ".", "linspace", "(", "0", ",", "x", ".", "shape", "[", "0", "]", "/", "sr", ",", "x", ".", "shape", "[", "0", "]", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.torch_chunkify": [[61, 73], ["x.reshape", "torch.autograd.Variable().float", "torch.autograd.Variable", "torch.from_numpy().to", "torch.from_numpy"], "function", ["None"], ["", "", "def", "torch_chunkify", "(", "x", ",", "chunk_size", "=", "4096", ")", ":", "\n", "# For long signals.  pads x with zeros and returns a 2D array", "\n", "    ", "''' # for now, make it just one big long chunk.\n    rows = int(np.ceil(x.shape[0]/chunk_size))  # this will be the batch size\n    nearest_mult = rows*(chunk_size)\n    xnew = np.zeros(nearest_mult)\n    xnew[0:x.shape[0]] = x[0:x.shape[0]]\n    xnew  = xnew.reshape(rows, chunk_size)\n    '''", "\n", "xnew", "=", "x", ".", "reshape", "(", "1", ",", "chunk_size", ")", "\n", "x_torch", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "from_numpy", "(", "xnew", ")", ".", "to", "(", "device", ")", ",", "requires_grad", "=", "False", ")", ".", "float", "(", ")", "\n", "return", "x_torch", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.setup_model": [[75, 91], ["signaltrain.misc.load_checkpoint", "len", "signaltrain.nn_proc.st_model", "nn_proc.st_model.load_state_dict"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.misc.load_checkpoint"], ["", "def", "setup_model", "(", "checkpoint_file", ",", "fatal", "=", "True", ")", ":", "\n", "    ", "global", "knob_names", ",", "knob_ranges", ",", "num_knobs", ",", "sr", ",", "chunk_size", ",", "out_chunk_size", "\n", "state_dict", ",", "rv", "=", "st", ".", "misc", ".", "load_checkpoint", "(", "checkpoint_file", ",", "fatal", "=", "fatal", ",", "device", "=", "\"cpu\"", ")", "\n", "if", "{", "}", "==", "state_dict", ":", "\n", "        ", "return", "None", "\n", "", "scale_factor", "=", "rv", "[", "'scale_factor'", "]", "\n", "shrink_factor", "=", "rv", "[", "'shrink_factor'", "]", "\n", "knob_names", "=", "rv", "[", "'knob_names'", "]", "\n", "knob_ranges", "=", "rv", "[", "'knob_ranges'", "]", "\n", "num_knobs", "=", "len", "(", "knob_names", ")", "\n", "sr", "=", "rv", "[", "'sr'", "]", "\n", "# set up model", "\n", "model", "=", "nn_proc", ".", "st_model", "(", "scale_factor", "=", "scale_factor", ",", "shrink_factor", "=", "shrink_factor", ",", "num_knobs", "=", "num_knobs", ",", "sr", "=", "sr", ")", "\n", "model", ".", "load_state_dict", "(", "state_dict", ")", "# overwrite weights using checkpoint info", "\n", "chunk_size", ",", "out_chunk_size", "=", "model", ".", "in_chunk_size", ",", "model", ".", "out_chunk_size", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.update_data": [[167, 201], ["dict", "range", "effect.go_wc", "dict", "dict", "bokeh_sliders.torch_chunkify", "numpy.tile", "torch.autograd.Variable().float", "model.forward", "dict", "dict", "knobs_wc.append", "torch_chunkify.size", "y_pred_torch.data.cpu().numpy().flatten", "len", "torch.autograd.Variable", "torch.from_numpy().to", "y_pred_torch.data.cpu().numpy", "torch.from_numpy", "y_pred_torch.data.cpu", "len"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.FileEffect.go_wc", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.torch_chunkify", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward"], ["", "def", "update_data", "(", "attrname", ",", "old", ",", "new", ")", ":", "\n", "    ", "global", "t", ",", "x", ",", "y", "\n", "plot", ".", "title", ".", "text", "=", "\"sample data\"", "\n", "\n", "source", ".", "data", "=", "dict", "(", "x", "=", "t", "[", "-", "show_size", ":", "]", ",", "y", "=", "x", "[", "-", "show_size", ":", "]", ")", "\n", "\n", "# Get the current slider values", "\n", "knobs_wc", "=", "[", "]", "\n", "if", "num_knobs", ">", "0", ":", "\n", "        ", "for", "k", "in", "range", "(", "num_knobs", ")", ":", "\n", "            ", "knobs_wc", ".", "append", "(", "knob_sliders", "[", "k", "]", ".", "value", ")", "\n", "\n", "# generate the new target curve, if possible", "\n", "", "", "if", "(", "effect", "is", "not", "None", ")", "and", "(", "'De'", "not", "in", "effect", ".", "name", ")", ":", "# don't update x for de- effects. (even though we should; but doing so makes the demo behave funny)", "\n", "        ", "y", ",", "x_tmp", "=", "effect", ".", "go_wc", "(", "x", ",", "knobs_wc", ")", "\n", "source2", ".", "data", "=", "dict", "(", "x", "=", "t", "[", "-", "show_size", ":", "]", ",", "y", "=", "y", "[", "-", "show_size", ":", "]", ")", "\n", "", "else", ":", "\n", "        ", "source2", ".", "data", "=", "dict", "(", "x", "=", "t", "[", "0", ":", "1", "]", ",", "y", "=", "0", "*", "t", "[", "0", ":", "1", "]", ")", "# effectively remove the display of data for this one", "\n", "plot", ".", "title", ".", "text", "+=", "\", no target\"", "\n", "\n", "# call the model in inference mode", "\n", "", "if", "model", "is", "not", "None", ":", "\n", "        ", "x_torch", "=", "torch_chunkify", "(", "x", ",", "chunk_size", "=", "len", "(", "t", ")", ")", "\n", "knobs_nn", "=", "(", "knobs_wc", "-", "knob_ranges", "[", ":", ",", "0", "]", ")", "/", "(", "knob_ranges", "[", ":", ",", "1", "]", "-", "knob_ranges", "[", ":", ",", "0", "]", ")", "-", "0.5", "\n", "knobs", "=", "knobs_nn", "# np.array([thresh_nn, ratio_nn, attack_nn])", "\n", "rows", "=", "x_torch", ".", "size", "(", ")", "[", "0", "]", "\n", "knobs", "=", "np", ".", "tile", "(", "knobs", ",", "(", "rows", ",", "1", ")", ")", "\n", "knobs_torch", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "from_numpy", "(", "knobs", ")", ".", "to", "(", "device", ")", ",", "requires_grad", "=", "False", ")", ".", "float", "(", ")", "\n", "y_pred_torch", ",", "mag", ",", "mag_hat", "=", "model", ".", "forward", "(", "x_torch", ",", "knobs_torch", ")", "\n", "y_pred", "=", "y_pred_torch", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "[", "0", ":", "t", ".", "shape", "[", "0", "]", "]", "#flattened numpy version", "\n", "source3", ".", "data", "=", "dict", "(", "x", "=", "t", "[", "-", "len", "(", "y_pred", ")", ":", "]", ",", "y", "=", "y_pred", ")", "\n", "", "else", ":", "\n", "        ", "source3", ".", "data", "=", "dict", "(", "x", "=", "t", "[", "0", ":", "1", "]", ",", "y", "=", "0", "*", "t", "[", "0", ":", "1", "]", ")", "\n", "plot", ".", "title", ".", "text", "+=", "\", no predicted\"", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.update_effect": [[204, 250], ["effects_dict.items", "bokeh_sliders.setup_model", "bokeh.layouts.column", "bokeh.io.curdoc().clear", "bokeh.io.curdoc().add_root", "bokeh_sliders.update_data", "len", "print", "knob_ranges.mean", "range", "bokeh.layouts.row", "bokeh.io.curdoc", "numpy.array", "bokeh.models.widgets.Slider", "knob_sliders.append", "w.on_change", "bokeh.io.curdoc", "bokeh.io.curdoc"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.setup_model", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.update_data"], ["", "", "def", "update_effect", "(", "attrname", ",", "old", ",", "new", ")", ":", "\n", "    ", "global", "effect", ",", "model", ",", "knob_names", ",", "knob_ranges", ",", "num_knobs", ",", "knob_sliders", "\n", "# match the menu option with the right entry in effects_dict", "\n", "long_name", "=", "effect_select", ".", "value", "\n", "plot", ".", "title", ".", "text", "=", "f\"Trying to setup effect '{long_name}'...\"", "\n", "shortname", "=", "''", "\n", "for", "key", ",", "val", "in", "effects_dict", ".", "items", "(", ")", ":", "\n", "        ", "if", "val", "[", "'name'", "]", "==", "long_name", ":", "\n", "            ", "shortname", "=", "key", "\n", "break", "\n", "", "", "if", "''", "==", "shortname", ":", "\n", "        ", "plot", ".", "title", ".", "text", "=", "f\"**ERROR: Effect '{long_name}' not defined**\"", "\n", "return", "\n", "", "effect", "=", "effects_dict", "[", "shortname", "]", "[", "'effect'", "]", "\n", "num_knobs", "=", "0", "\n", "if", "effect", "is", "not", "None", ":", "\n", "        ", "knob_names", ",", "knob_ranges", "=", "effect", ".", "knob_names", ",", "np", ".", "array", "(", "effect", ".", "knob_ranges", ")", "\n", "num_knobs", "=", "len", "(", "knob_names", ")", "\n", "\n", "# try to read the checkpoint file", "\n", "", "checkpoint_file", "=", "effects_dict", "[", "shortname", "]", "[", "'checkpoint'", "]", "\n", "model", "=", "setup_model", "(", "checkpoint_file", ",", "fatal", "=", "False", ")", "\n", "if", "model", "is", "None", ":", "\n", "        ", "msg", "=", "f\"**ERROR: checkpoint file '{checkpoint_file}' not found**\"", "\n", "print", "(", "\"\\n\"", ",", "msg", ")", "\n", "plot", ".", "title", ".", "text", "=", "msg", "\n", "\n", "# rebuild the entire display  (because knobs have changed)", "\n", "", "knob_sliders", "=", "[", "]", "\n", "if", "num_knobs", ">", "0", ":", "\n", "        ", "knobs_wc", "=", "knob_ranges", ".", "mean", "(", "axis", "=", "1", ")", "\n", "for", "k", "in", "range", "(", "num_knobs", ")", ":", "\n", "            ", "start", ",", "end", "=", "knob_ranges", "[", "k", "]", "[", "0", "]", ",", "knob_ranges", "[", "k", "]", "[", "1", "]", "\n", "mid", "=", "knobs_wc", "[", "k", "]", "\n", "step", "=", "(", "end", "-", "start", ")", "/", "25", "\n", "tmp", "=", "Slider", "(", "title", "=", "knob_names", "[", "k", "]", ",", "value", "=", "mid", ",", "start", "=", "start", ",", "end", "=", "end", ",", "step", "=", "step", ")", "\n", "knob_sliders", ".", "append", "(", "tmp", ")", "\n", "", "for", "w", "in", "knob_sliders", ":", "# since we now defined new widgets, we need triggers for them", "\n", "            ", "w", ".", "on_change", "(", "'value'", ",", "update_data", ")", "\n", "\n", "", "", "inputs", "=", "column", "(", "[", "effect_select", ",", "input_select", "]", "+", "knob_sliders", ")", "\n", "curdoc", "(", ")", ".", "clear", "(", ")", "\n", "curdoc", "(", ")", ".", "add_root", "(", "row", "(", "inputs", ",", "plot", ",", "width", "=", "800", ")", ")", "\n", "curdoc", "(", ")", ".", "title", "=", "\"SignalTrain Demo\"", "\n", "\n", "update_data", "(", "attrname", ",", "old", ",", "new", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.update_input": [[252, 261], ["bokeh_sliders.get_input_sample", "bokeh_sliders.torch_chunkify", "dict", "bokeh_sliders.update_data"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.get_input_sample", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.torch_chunkify", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.demo.bokeh_sliders.update_data"], ["", "def", "update_input", "(", "attrname", ",", "old", ",", "new", ")", ":", "\n", "    ", "global", "t", ",", "x", ",", "x_torch", ",", "chunk_size", "\n", "chooser", "=", "input_select", ".", "value", "\n", "x", "=", "get_input_sample", "(", "chooser", ",", "in_chunk_size", "=", "chunk_size", ")", "\n", "#x = np.concatenate( (np.zeros(len(x)),x))  # double it and add zeros", "\n", "\n", "x_torch", "=", "torch_chunkify", "(", "x", ",", "chunk_size", "=", "chunk_size", ")", "\n", "source", ".", "data", "=", "dict", "(", "x", "=", "t", "[", "-", "show_size", ":", "]", ",", "y", "=", "x", "[", "-", "show_size", ":", "]", ")", "\n", "update_data", "(", "attrname", ",", "old", ",", "new", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.AsymAutoEncoder.__init__": [[29, 70], ["torch.Module.__init__", "print", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ELU", "torch.ELU", "nn_proc.AsymAutoEncoder.initialize", "torch.Dropout2d", "torch.Dropout2d"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["    ", "def", "__init__", "(", "self", ",", "T", "=", "25", ",", "R", "=", "64", ",", "K", "=", "3", ",", "OT", "=", "None", ",", "use_bias", "=", "True", ",", "use_dropout", "=", "False", ")", ":", "\n", "        ", "super", "(", "AsymAutoEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Parameters", "\n", "self", ".", "_T", "=", "T", "# expected number of time frames", "\n", "self", ".", "_R", "=", "R", "# decomposition rank - (output) size of first encoded layer of activations", "\n", "self", ".", "_K", "=", "K", "# number of knobs", "\n", "if", "OT", "is", "None", ":", "# expected number of output time frames", "\n", "            ", "self", ".", "_OT", "=", "T", "\n", "", "else", ":", "\n", "            ", "self", ".", "_OT", "=", "OT", "\n", "", "self", ".", "use_bias", "=", "use_bias", "\n", "self", ".", "use_dropout", "=", "use_dropout", "\n", "\n", "print", "(", "\"AsymAutoEncoder __init__: T, R, K, OT = \"", ",", "T", ",", "R", ",", "K", ",", "OT", ")", "\n", "\n", "# Analysis", "\n", "rf", "=", "2", "# \"reduction factor\": size ratio between successive layers in autoencoder", "\n", "self", ".", "fnn_enc", "=", "nn", ".", "Linear", "(", "self", ".", "_T", ",", "self", ".", "_R", ",", "bias", "=", "self", ".", "use_bias", ")", "\n", "self", ".", "fnn_enc2", "=", "nn", ".", "Linear", "(", "self", ".", "_R", ",", "self", ".", "_R", "//", "rf", ",", "bias", "=", "self", ".", "use_bias", ")", "\n", "self", ".", "fnn_enc3", "=", "nn", ".", "Linear", "(", "self", ".", "_R", "//", "rf", ",", "self", ".", "_R", "//", "rf", "**", "2", ",", "bias", "=", "self", ".", "use_bias", ")", "\n", "self", ".", "fnn_enc4", "=", "nn", ".", "Linear", "(", "self", ".", "_R", "//", "rf", "**", "2", ",", "self", ".", "_R", "//", "rf", "**", "2", ",", "bias", "=", "self", ".", "use_bias", ")", "\n", "\n", "self", ".", "fnn_addknobs", "=", "nn", ".", "Linear", "(", "self", ".", "_R", "//", "rf", "**", "2", "+", "self", ".", "_K", ",", "self", ".", "_R", "//", "rf", "**", "2", ",", "bias", "=", "self", ".", "use_bias", ")", "\n", "\n", "self", ".", "fnn_dec4", "=", "nn", ".", "Linear", "(", "self", ".", "_R", "//", "rf", "**", "2", ",", "self", ".", "_R", "//", "rf", "**", "2", ",", "bias", "=", "self", ".", "use_bias", ")", "# repeat size, now with knobs catted", "\n", "self", ".", "fnn_dec3", "=", "nn", ".", "Linear", "(", "self", ".", "_R", "//", "rf", "**", "2", ",", "self", ".", "_R", "//", "rf", ",", "bias", "=", "self", ".", "use_bias", ")", "\n", "self", ".", "fnn_dec2", "=", "nn", ".", "Linear", "(", "self", ".", "_R", "//", "rf", ",", "self", ".", "_R", ",", "bias", "=", "self", ".", "use_bias", ")", "\n", "self", ".", "fnn_dec", "=", "nn", ".", "Linear", "(", "self", ".", "_R", ",", "self", ".", "_OT", ",", "bias", "=", "self", ".", "use_bias", ")", "\n", "\n", "self", ".", "layer_list", "=", "[", "self", ".", "fnn_enc", ",", "self", ".", "fnn_enc2", ",", "self", ".", "fnn_enc3", ",", "self", ".", "fnn_enc4", ",", "\n", "self", ".", "fnn_addknobs", ",", "self", ".", "fnn_dec4", ",", "self", ".", "fnn_dec3", ",", "self", ".", "fnn_dec2", ",", "self", ".", "fnn_dec", "]", "\n", "\n", "# Activation function(s)", "\n", "self", ".", "relu", "=", "nn", ".", "ELU", "(", ")", "#  nn.LeakyReLU()", "\n", "#self.relu = nn.ReLU()", "\n", "\n", "# Dropout regularization", "\n", "if", "self", ".", "use_dropout", ":", "self", ".", "dropout", "=", "nn", ".", "Dropout2d", "(", "p", "=", "0.2", ")", "\n", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.AsymAutoEncoder.initialize": [[71, 76], ["torch.nn.init.xavier_normal_", "torch.nn.init.xavier_normal_", "torch.nn.init.xavier_normal_", "torch.nn.init.xavier_normal_", "x.bias.data.zero_"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "for", "x", "in", "self", ".", "layer_list", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "xavier_normal_", "(", "x", ".", "weight", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "                ", "x", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.AsymAutoEncoder.forward": [[77, 127], ["x_input.transpose.transpose.transpose", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.relu", "knobs.unsqueeze().repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.transpose", "nn_proc.AsymAutoEncoder.fnn_enc", "acts.append", "nn_proc.AsymAutoEncoder.dropout", "nn_proc.AsymAutoEncoder.fnn_enc2", "acts.append", "nn_proc.AsymAutoEncoder.dropout", "nn_proc.AsymAutoEncoder.fnn_enc3", "acts.append", "nn_proc.AsymAutoEncoder.fnn_enc4", "acts.append", "acts.append", "nn_proc.AsymAutoEncoder.fnn_addknobs", "acts.append", "nn_proc.AsymAutoEncoder.fnn_dec4", "acts.append", "nn_proc.AsymAutoEncoder.fnn_dec3", "acts.append", "nn_proc.AsymAutoEncoder.dropout", "nn_proc.AsymAutoEncoder.fnn_dec2", "acts.append", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "nn_proc.AsymAutoEncoder.dropout", "acts.append", "knobs.unsqueeze", "nn_proc.AsymAutoEncoder.size", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.fnn_dec", "nn_proc.AsymAutoEncoder.relu", "nn_proc.AsymAutoEncoder.fnn_dec", "nn_proc.AsymAutoEncoder.fnn_dec", "nn_proc.AsymAutoEncoder.fnn_dec"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x_input", ",", "knobs", ",", "skip_connections", "=", "'res'", ",", "return_acts", "=", "False", ")", ":", "\n", "        ", "acts", "=", "[", "]", "# list of activations", "\n", "x_input", "=", "x_input", ".", "transpose", "(", "2", ",", "1", ")", "\n", "z", "=", "self", ".", "relu", "(", "self", ".", "fnn_enc", "(", "x_input", ")", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "z", ")", "\n", "z", "=", "self", ".", "dropout", "(", "z", ")", "if", "self", ".", "use_dropout", "else", "z", "\n", "z", "=", "self", ".", "relu", "(", "self", ".", "fnn_enc2", "(", "z", ")", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "z", ")", "\n", "z", "=", "self", ".", "dropout", "(", "z", ")", "if", "self", ".", "use_dropout", "else", "z", "\n", "z", "=", "self", ".", "relu", "(", "self", ".", "fnn_enc3", "(", "z", ")", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "z", ")", "\n", "z", "=", "self", ".", "relu", "(", "self", ".", "fnn_enc4", "(", "z", ")", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "z", ")", "\n", "\n", "\n", "knobs_r", "=", "knobs", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "z", ".", "size", "(", ")", "[", "1", "]", ",", "1", ")", "# repeat the knobs to make dimensions match", "\n", "catted", "=", "torch", ".", "cat", "(", "(", "z", ",", "knobs_r", ")", ",", "2", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "catted", ")", "\n", "\n", "z", "=", "self", ".", "relu", "(", "self", ".", "fnn_addknobs", "(", "catted", ")", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "z", ")", "\n", "\n", "z", "=", "self", ".", "relu", "(", "self", ".", "fnn_dec4", "(", "z", ")", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "z", ")", "\n", "\n", "z", "=", "self", ".", "relu", "(", "self", ".", "fnn_dec3", "(", "z", ")", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "z", ")", "\n", "\n", "z", "=", "self", ".", "dropout", "(", "z", ")", "if", "self", ".", "use_dropout", "else", "z", "\n", "z", "=", "self", ".", "relu", "(", "self", ".", "fnn_dec2", "(", "z", ")", ")", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "z", ")", "\n", "\n", "if", "skip_connections", "==", "'exp'", ":", "# Refering to an old AES paper for exponentiation", "\n", "            ", "z_a", "=", "torch", ".", "log", "(", "self", ".", "relu", "(", "self", ".", "fnn_dec", "(", "z", ")", ")", "+", "1e-6", ")", "*", "torch", ".", "log", "(", "x_input", "[", ":", ",", "-", "self", ".", "_OT", ":", ",", ":", "]", "+", "1e-6", ")", "\n", "out", "=", "torch", ".", "exp", "(", "z_a", ")", "\n", "", "elif", "skip_connections", "==", "'res'", ":", "# Refering to residual connections", "\n", "            ", "out", "=", "self", ".", "relu", "(", "self", ".", "fnn_dec", "(", "z", ")", "+", "x_input", "[", ":", ",", ":", ",", "-", "self", ".", "_OT", ":", "]", ")", "\n", "", "elif", "skip_connections", "==", "'sf'", ":", "# Skip-filter", "\n", "            ", "out", "=", "self", ".", "relu", "(", "self", ".", "fnn_dec", "(", "z", ")", ")", "*", "x_input", "[", ":", ",", ":", ",", "-", "self", ".", "_OT", ":", "]", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "relu", "(", "self", ".", "fnn_dec", "(", "z", ")", ")", "\n", "", "out", "=", "self", ".", "dropout", "(", "out", ")", "if", "self", ".", "use_dropout", "else", "out", "\n", "if", "return_acts", ":", "acts", ".", "append", "(", "out", ")", "\n", "\n", "result", "=", "out", ".", "transpose", "(", "2", ",", "1", ")", "\n", "\n", "if", "return_acts", ":", "\n", "            ", "return", "result", ",", "acts", "\n", "", "else", ":", "\n", "            ", "return", "result", ",", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.AsymMPAEC.__init__": [[278, 292], ["torch.Module.__init__", "print", "Analysis", "Synthesis", "nn_proc.AsymAutoEncoder", "nn_proc.AsymAutoEncoder"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["def", "__init__", "(", "self", ",", "expected_time_frames", ",", "ft_size", "=", "1024", ",", "hop_size", "=", "384", ",", "\n", "decomposition_rank", "=", "64", ",", "n_knobs", "=", "4", ",", "output_tf", "=", "None", ")", ":", "\n", "        ", "super", "(", "AsymMPAEC", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "print", "(", "\"AsymMPAEC: expected_time_frames, ft_size, hop_size, decomposition_rank, n_knobs, output_tf = \"", ",", "expected_time_frames", ",", "ft_size", ",", "hop_size", ",", "decomposition_rank", ",", "n_knobs", ",", "output_tf", ")", "\n", "if", "output_tf", "is", "None", ":", "\n", "            ", "self", ".", "output_tf", "=", "expected_time_frames", "\n", "", "else", ":", "\n", "            ", "self", ".", "output_tf", "=", "output_tf", "\n", "\n", "", "self", ".", "dft_analysis", "=", "Analysis", "(", "ft_size", "=", "ft_size", ",", "hop_size", "=", "hop_size", ")", "\n", "self", ".", "dft_synthesis", "=", "Synthesis", "(", "ft_size", "=", "ft_size", ",", "hop_size", "=", "hop_size", ")", "\n", "self", ".", "aenc", "=", "AsymAutoEncoder", "(", "T", "=", "expected_time_frames", ",", "R", "=", "decomposition_rank", ",", "K", "=", "n_knobs", ",", "OT", "=", "self", ".", "output_tf", ")", "\n", "self", ".", "phs_aenc", "=", "AsymAutoEncoder", "(", "T", "=", "expected_time_frames", ",", "R", "=", "decomposition_rank", ",", "K", "=", "n_knobs", ",", "OT", "=", "self", ".", "output_tf", ")", "\n", "#self.valve = nn.Parameter(torch.tensor([0.2,1.0]), requires_grad=True)  # \"wet-dry mix\"", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.AsymMPAEC.reinitialize": [[295, 298], ["nn_proc.AsymMPAEC.aenc.initialize", "nn_proc.AsymMPAEC.phs_aenc.initialize"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["", "def", "reinitialize", "(", "self", ")", ":", "# randomly reassigns weights", "\n", "        ", "self", ".", "aenc", ".", "initialize", "(", ")", "\n", "self", ".", "phs_aenc", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.AsymMPAEC.clip_grad_norm_": [[299, 303], ["torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "list", "list", "nn_proc.AsymMPAEC.dft_analysis.parameters", "nn_proc.AsymMPAEC.dft_synthesis.parameters"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_"], ["", "def", "clip_grad_norm_", "(", "self", ")", ":", "\n", "        ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "list", "(", "self", ".", "dft_analysis", ".", "parameters", "(", ")", ")", "+", "\n", "list", "(", "self", ".", "dft_synthesis", ".", "parameters", "(", ")", ")", ",", "\n", "max_norm", "=", "1.", ",", "norm_type", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.AsymMPAEC.forward": [[305, 341], ["nn_proc.AsymMPAEC.dft_analysis.forward", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.atan2().to", "torch.atan2().to", "torch.atan2().to", "torch.atan2().to", "nn_proc.AsymMPAEC.aenc.forward", "nn_proc.AsymMPAEC.phs_aenc.forward", "nn_proc.AsymMPAEC.dft_synthesis.forward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "layer_acts.extend", "layer_acts.extend", "phs_hat.size", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "layer_acts.extend", "torch.atan2", "torch.atan2", "torch.atan2", "torch.atan2", "x_real.unsqueeze", "x_imag.unsqueeze", "x_imag.float", "x_real.float", "nn_proc.AsymMPAEC.size"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward"], ["", "def", "forward", "(", "self", ",", "x_cuda", ",", "knobs_cuda", ",", "return_acts", "=", "False", ")", ":", "\n", "# trainable STFT, outputs spectrograms for real & imag parts", "\n", "        ", "x_real", ",", "x_imag", "=", "self", ".", "dft_analysis", ".", "forward", "(", "x_cuda", "/", "2", ")", "# the /2 is cheap way to help us approach 'unit variaance' of -0.5 and .5", "\n", "# Magnitude-Phase computation", "\n", "mag", "=", "torch", ".", "norm", "(", "torch", ".", "cat", "(", "(", "x_real", ".", "unsqueeze", "(", "0", ")", ",", "x_imag", ".", "unsqueeze", "(", "0", ")", ")", ",", "0", ")", ",", "2", ",", "dim", "=", "0", ")", "\n", "phs", "=", "torch", ".", "atan2", "(", "x_imag", ".", "float", "(", ")", ",", "x_real", ".", "float", "(", ")", "+", "1e-7", ")", ".", "to", "(", "x_cuda", ".", "dtype", ")", "\n", "if", "return_acts", ":", "\n", "            ", "layer_acts", "=", "[", "x_real", ",", "x_imag", ",", "mag", ",", "phs", "]", "\n", "\n", "# Processes Magnitude and phase individually", "\n", "", "mag_hat", ",", "m_acts", "=", "self", ".", "aenc", ".", "forward", "(", "mag", ",", "knobs_cuda", ",", "skip_connections", "=", "'sf'", ",", "return_acts", "=", "return_acts", ")", "\n", "phs_hat", ",", "p_acts", "=", "self", ".", "phs_aenc", ".", "forward", "(", "phs", ",", "knobs_cuda", ",", "skip_connections", "=", "''", ",", "return_acts", "=", "return_acts", ")", "\n", "if", "return_acts", ":", "\n", "            ", "layer_acts", ".", "extend", "(", "m_acts", ")", "\n", "layer_acts", ".", "extend", "(", "p_acts", ")", "\n", "\n", "", "output_phs_dim", "=", "phs_hat", ".", "size", "(", ")", "[", "1", "]", "\n", "phs_hat", "=", "phs_hat", "+", "phs", "[", ":", ",", "-", "output_phs_dim", ":", ",", ":", "]", "# <-- residual skip connection. Slightly smoother convergence", "\n", "\n", "# Back to Real and Imaginary", "\n", "an_real", "=", "mag_hat", "*", "torch", ".", "cos", "(", "phs_hat", ")", "\n", "an_imag", "=", "mag_hat", "*", "torch", ".", "sin", "(", "phs_hat", ")", "\n", "\n", "# Forward synthesis pass", "\n", "x_fwdsyn", "=", "self", ".", "dft_synthesis", ".", "forward", "(", "an_real", ",", "an_imag", ")", "\n", "\n", "# final skip residual", "\n", "y_hat", "=", "x_fwdsyn", "+", "x_cuda", "[", ":", ",", "-", "x_fwdsyn", ".", "size", "(", ")", "[", "-", "1", "]", ":", "]", "/", "2", "\n", "\n", "if", "return_acts", ":", "\n", "            ", "layer_acts", ".", "extend", "(", "[", "mag_hat", ",", "phs_hat", ",", "an_real", ",", "an_imag", ",", "x_fwdsyn", ",", "y_hat", "]", ")", "\n", "\n", "", "if", "return_acts", ":", "\n", "            ", "return", "2", "*", "y_hat", ",", "mag", ",", "mag_hat", ",", "layer_acts", "# undo the /2 at the beginning", "\n", "", "else", ":", "\n", "            ", "return", "2", "*", "y_hat", ",", "mag", ",", "mag_hat", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.__init__": [[348, 386], ["torch.Module.__init__", "int", "int", "print", "print", "print", "int", "int", "nn_proc.AsymMPAEC", "int", "int", "print", "print", "numpy.ceil", "numpy.ceil", "numpy.ceil", "numpy.ceil", "float", "float", "float", "float"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["def", "__init__", "(", "self", ",", "scale_factor", "=", "1", ",", "shrink_factor", "=", "4", ",", "num_knobs", "=", "3", ",", "sr", "=", "44100", ",", "scale_scheme", "=", "'lean'", ")", ":", "\n", "        ", "\"\"\"\n            scale_factor: change dimensionality of run by this factor\n            shrink_factor:  output shrink factor, i.e. fraction of output actually trained on\n\n        \"\"\"", "\n", "super", "(", "st_model", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Data settings", "\n", "chunk_size", "=", "int", "(", "8192", "*", "scale_factor", ")", "# size of audio that NN model expects as input", "\n", "out_chunk_size", "=", "int", "(", "chunk_size", "/", "shrink_factor", ")", "# size of output audio that we actually care about", "\n", "\n", "# save these variables for use when loading models later", "\n", "self", ".", "scale_factor", ",", "self", ".", "shrink_factor", "=", "scale_factor", ",", "shrink_factor", "\n", "self", ".", "in_chunk_size", ",", "self", ".", "out_chunk_size", "=", "chunk_size", ",", "out_chunk_size", "\n", "self", ".", "num_knobs", "=", "num_knobs", "\n", "\n", "print", "(", "\"Input chunk size =\"", ",", "chunk_size", ")", "\n", "print", "(", "\"Intended Output chunk size =\"", ",", "out_chunk_size", ")", "\n", "print", "(", "\"Sample rate =\"", ",", "sr", ")", "\n", "\n", "# Analysis parameters", "\n", "ft_size", "=", "1024", "\n", "hop_size", "=", "384", "\n", "#hop_size = int(256 * scale_factor)", "\n", "\n", "if", "scale_scheme", "!=", "'lean'", ":", "# the following doesn't scale well (like O(N^2)), but this is the old scheme, for backwards compatibility", "\n", "            ", "ft_size", "=", "int", "(", "ft_size", "*", "scale_factor", ")", "\n", "hop_size", "=", "int", "(", "hop_size", "*", "scale_factor", ")", "\n", "\n", "", "expected_time_frames", "=", "int", "(", "np", ".", "ceil", "(", "chunk_size", "/", "float", "(", "hop_size", ")", ")", "+", "np", ".", "ceil", "(", "ft_size", "/", "float", "(", "hop_size", ")", ")", ")", "\n", "output_time_frames", "=", "int", "(", "np", ".", "ceil", "(", "out_chunk_size", "/", "float", "(", "hop_size", ")", ")", "+", "np", ".", "ceil", "(", "ft_size", "/", "float", "(", "hop_size", ")", ")", ")", "\n", "y_size", "=", "(", "output_time_frames", "-", "1", ")", "*", "hop_size", "-", "ft_size", "\n", "if", "y_size", "!=", "out_chunk_size", ":", "\n", "            ", "print", "(", "f\"Warning: y_size ({y_size}) should equal out_chunk_size ({out_chunk_size})\"", ")", "\n", "print", "(", "f\"    Setting out_chunk_size = y_size = {y_size}\"", ")", "\n", "", "self", ".", "out_chunk_size", "=", "y_size", "\n", "self", ".", "mpaec", "=", "AsymMPAEC", "(", "expected_time_frames", ",", "ft_size", "=", "ft_size", ",", "hop_size", "=", "hop_size", ",", "n_knobs", "=", "num_knobs", ",", "output_tf", "=", "output_time_frames", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_": [[389, 391], ["nn_proc.st_model.mpaec.clip_grad_norm_"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_"], ["", "def", "clip_grad_norm_", "(", "self", ")", ":", "\n", "        ", "self", ".", "mpaec", ".", "clip_grad_norm_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.forward": [[392, 394], ["nn_proc.st_model.mpaec.forward"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward"], ["", "def", "forward", "(", "self", ",", "x_cuda", ",", "knobs_cuda", ",", "return_acts", "=", "False", ")", ":", "\n", "        ", "return", "self", ".", "mpaec", ".", "forward", "(", "x_cuda", ",", "knobs_cuda", ",", "return_acts", "=", "return_acts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.freeze_layers": [[17, 21], ["layer.parameters"], "function", ["None"], ["def", "freeze_layers", "(", "layers", ")", ":", "\n", "    ", "for", "layer", "in", "layers", ":", "\n", "        ", "for", "param", "in", "layer", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.unfreeze_layers": [[22, 26], ["layer.parameters"], "function", ["None"], ["", "", "", "def", "unfreeze_layers", "(", "layers", ")", ":", "\n", "    ", "for", "layer", "in", "layers", ":", "\n", "        ", "for", "param", "in", "layer", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Analysis.__init__": [[17, 35], ["torch.Module.__init__", "int", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "cls_fe_dft.Analysis.initialize"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["def", "__init__", "(", "self", ",", "ft_size", "=", "1024", ",", "hop_size", "=", "384", ")", ":", "\n", "        ", "super", "(", "Analysis", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Parameters", "\n", "self", ".", "batch_size", "=", "None", "\n", "self", ".", "time_domain_samples", "=", "None", "\n", "self", ".", "sz", "=", "ft_size", "\n", "self", ".", "hop", "=", "hop_size", "\n", "self", ".", "half_N", "=", "int", "(", "self", ".", "sz", "/", "2.", "+", "1", ")", "\n", "\n", "# Analysis 1D CNN", "\n", "self", ".", "conv_analysis_real", "=", "nn", ".", "Conv1d", "(", "1", ",", "self", ".", "sz", ",", "self", ".", "sz", ",", "\n", "padding", "=", "self", ".", "sz", ",", "stride", "=", "self", ".", "hop", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv_analysis_imag", "=", "nn", ".", "Conv1d", "(", "1", ",", "self", ".", "sz", ",", "self", ".", "sz", ",", "\n", "padding", "=", "self", ".", "sz", ",", "stride", "=", "self", ".", "hop", ",", "bias", "=", "False", ")", "\n", "\n", "# Custom Initialization with Fourier matrix", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Analysis.initialize": [[36, 49], ["numpy.fft.fft", "scipy.signal.hamming", "numpy.eye", "cls_fe_dft.Analysis.conv_analysis_real.weight.data.copy_", "cls_fe_dft.Analysis.conv_analysis_imag.weight.data.copy_", "cls_fe_dft.Analysis.conv_analysis_real.weight.data.copy_", "cls_fe_dft.Analysis.conv_analysis_imag.weight.data.copy_", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.real", "numpy.imag", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "f_matrix", "=", "np", ".", "fft", ".", "fft", "(", "np", ".", "eye", "(", "self", ".", "sz", ")", ",", "norm", "=", "'ortho'", ")", "\n", "w", "=", "sig", ".", "hamming", "(", "self", ".", "sz", ")", "\n", "\n", "f_matrix_real", "=", "(", "np", ".", "real", "(", "f_matrix", ")", "*", "w", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "f_matrix_imag", "=", "(", "np", ".", "imag", "(", "f_matrix", ")", "*", "w", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "\n", "if", "torch", ".", "has_cudnn", ":", "\n", "            ", "self", ".", "conv_analysis_real", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_real", "[", ":", ",", "None", ",", ":", "]", ")", ".", "cuda", "(", ")", ")", "\n", "self", ".", "conv_analysis_imag", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_imag", "[", ":", ",", "None", ",", ":", "]", ")", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv_analysis_real", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_real", "[", ":", ",", "None", ",", ":", "]", ")", ")", "\n", "self", ".", "conv_analysis_imag", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_imag", "[", ":", ",", "None", ",", ":", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Analysis.forward": [[50, 59], ["wave_form.view.view.size", "wave_form.view.view.size", "wave_form.view.view.view", "cls_fe_dft.Analysis.conv_analysis_real().transpose", "cls_fe_dft.Analysis.conv_analysis_imag().transpose", "cls_fe_dft.Analysis.conv_analysis_real", "cls_fe_dft.Analysis.conv_analysis_imag"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "wave_form", ")", ":", "\n", "        ", "batch_size", "=", "wave_form", ".", "size", "(", "0", ")", "\n", "time_domain_samples", "=", "wave_form", ".", "size", "(", "1", ")", "\n", "\n", "wave_form", "=", "wave_form", ".", "view", "(", "batch_size", ",", "1", ",", "time_domain_samples", ")", "\n", "an_real", "=", "self", ".", "conv_analysis_real", "(", "wave_form", ")", ".", "transpose", "(", "1", ",", "2", ")", "[", ":", ",", ":", ",", ":", "self", ".", "half_N", "]", "\n", "an_imag", "=", "self", ".", "conv_analysis_imag", "(", "wave_form", ")", ".", "transpose", "(", "1", ",", "2", ")", "[", ":", ",", ":", ",", ":", "self", ".", "half_N", "]", "\n", "\n", "return", "an_real", ",", "an_imag", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Synthesis.__init__": [[67, 86], ["torch.Module.__init__", "int", "torch.ConvTranspose1d", "torch.ConvTranspose1d", "torch.ConvTranspose1d", "torch.ConvTranspose1d", "cls_fe_dft.Synthesis.initialize"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["def", "__init__", "(", "self", ",", "ft_size", "=", "1024", ",", "hop_size", "=", "384", ")", ":", "\n", "        ", "super", "(", "Synthesis", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Parameters", "\n", "self", ".", "batch_size", "=", "None", "\n", "self", ".", "time_domain_samples", "=", "None", "\n", "self", ".", "sz", "=", "ft_size", "\n", "self", ".", "hop", "=", "hop_size", "\n", "self", ".", "half_N", "=", "int", "(", "self", ".", "sz", "/", "2", "+", "1", ")", "\n", "\n", "# Synthesis 1D CNN", "\n", "self", ".", "conv_synthesis_real", "=", "nn", ".", "ConvTranspose1d", "(", "self", ".", "sz", ",", "1", ",", "self", ".", "sz", ",", "\n", "padding", "=", "0", ",", "stride", "=", "self", ".", "hop", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "conv_synthesis_imag", "=", "nn", ".", "ConvTranspose1d", "(", "self", ".", "sz", ",", "1", ",", "self", ".", "sz", ",", "\n", "padding", "=", "0", ",", "stride", "=", "self", ".", "hop", ",", "bias", "=", "False", ")", "\n", "\n", "# Custom Initialization with Fourier matrix", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Synthesis.initialize": [[87, 101], ["numpy.fft.fft", "cls_fe_dft.Synthesis.GLA", "numpy.eye", "cls_fe_dft.Synthesis.conv_synthesis_real.weight.data.copy_", "cls_fe_dft.Synthesis.conv_synthesis_imag.weight.data.copy_", "cls_fe_dft.Synthesis.conv_synthesis_real.weight.data.copy_", "cls_fe_dft.Synthesis.conv_synthesis_imag.weight.data.copy_", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.real", "numpy.imag", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Synthesis.GLA"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "f_matrix", "=", "np", ".", "fft", ".", "fft", "(", "np", ".", "eye", "(", "self", ".", "sz", ")", ",", "norm", "=", "'ortho'", ")", "\n", "w", "=", "Synthesis", ".", "GLA", "(", "self", ".", "sz", ",", "self", ".", "hop", ",", "self", ".", "sz", ")", "\n", "\n", "f_matrix_real", "=", "(", "np", ".", "real", "(", "f_matrix", ")", "*", "w", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "f_matrix_imag", "=", "(", "np", ".", "imag", "(", "f_matrix", ")", "*", "w", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "\n", "if", "torch", ".", "has_cudnn", ":", "\n", "            ", "self", ".", "conv_synthesis_real", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_real", "[", ":", ",", "None", ",", ":", "]", ")", ".", "cuda", "(", ")", ")", "\n", "self", ".", "conv_synthesis_imag", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_imag", "[", ":", ",", "None", ",", ":", "]", ")", ".", "cuda", "(", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv_synthesis_real", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_real", "[", ":", ",", "None", ",", ":", "]", ")", ")", "\n", "self", ".", "conv_synthesis_imag", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_imag", "[", ":", ",", "None", ",", ":", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Synthesis.forward": [[102, 116], ["torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "cls_fe_dft.Synthesis.conv_synthesis_real", "cls_fe_dft.Synthesis.conv_synthesis_imag", "cls_fe_dft.Synthesis.flip", "cls_fe_dft.Synthesis.flip"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.flip", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.flip"], ["", "", "def", "forward", "(", "self", ",", "real", ",", "imag", ")", ":", "\n", "        ", "real", "=", "torch", ".", "transpose", "(", "real", ",", "1", ",", "2", ")", "\n", "imag", "=", "torch", ".", "transpose", "(", "imag", ",", "1", ",", "2", ")", "\n", "\n", "# Hawley removed 'contiguous' with no apparent accuracy changes but a slight performance boost to flip() call", "\n", "#real = torch.cat((real, Synthesis.flip(real[:, 1:-1, :].contiguous(), 1)), 1)", "\n", "#imag = torch.cat((imag, Synthesis.flip(-imag[:, 1:-1, :].contiguous(), 1)), 1)", "\n", "real", "=", "torch", ".", "cat", "(", "(", "real", ",", "Synthesis", ".", "flip", "(", "real", "[", ":", ",", "1", ":", "-", "1", ",", ":", "]", ",", "1", ")", ")", ",", "1", ")", "\n", "imag", "=", "torch", ".", "cat", "(", "(", "imag", ",", "Synthesis", ".", "flip", "(", "-", "imag", "[", ":", ",", "1", ":", "-", "1", ",", ":", "]", ",", "1", ")", ")", ",", "1", ")", "\n", "\n", "wave_form", "=", "self", ".", "conv_synthesis_real", "(", "real", ")", "+", "self", ".", "conv_synthesis_imag", "(", "imag", ")", "\n", "wave_form", "=", "wave_form", "[", ":", ",", ":", ",", "self", ".", "sz", ":", "-", "self", ".", "sz", "]", "\n", "\n", "return", "wave_form", "[", ":", ",", "0", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Synthesis.flip": [[128, 131], ["x.flip"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.flip"], ["", "@", "staticmethod", "\n", "def", "flip", "(", "x", ",", "dim", ")", ":", "\n", "        ", "return", "x", ".", "flip", "(", "dim", ")", "# flip now in PyTorch, PR #7873 https://github.com/pytorch/pytorch/pull/7873", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.Synthesis.GLA": [[133, 164], ["scipy.signal.hamming", "numpy.zeros", "range", "numpy.arange", "numpy.where"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "GLA", "(", "wsz", ",", "hop", ",", "N", "=", "4096", ")", ":", "\n", "        ", "\"\"\" LSEE-MSTFT algorithm for computing the synthesis window used in\n        inverse STFT method.\n        Args:\n            wsz :   (int)    Synthesis window size\n            hop :   (int)    Hop size\n            N   :   (int)    DFT Size\n        Returns :\n            symw:   (array)  Synthesised windowing function\n        References :\n            [1] Daniel W. Griffin and Jae S. Lim, ``Signal estimation from modified short-time\n            Fourier transform,'' IEEE Transactions on Acoustics, Speech and Signal Processing,\n            vol. 32, no. 2, pp. 236-243, Apr 1984.\n        \"\"\"", "\n", "synw", "=", "sig", ".", "hamming", "(", "wsz", ")", "\n", "synwProd", "=", "synw", "**", "2.", "\n", "synwProd", ".", "shape", "=", "(", "wsz", ",", "1", ")", "\n", "redundancy", "=", "wsz", "//", "hop", "\n", "env", "=", "np", ".", "zeros", "(", "(", "wsz", ",", "1", ")", ")", "\n", "for", "k", "in", "range", "(", "-", "redundancy", ",", "redundancy", "+", "1", ")", ":", "\n", "            ", "envInd", "=", "(", "hop", "*", "k", ")", "\n", "winInd", "=", "np", ".", "arange", "(", "1", ",", "wsz", "+", "1", ")", "\n", "envInd", "+=", "winInd", "\n", "valid", "=", "np", ".", "where", "(", "(", "envInd", ">", "0", ")", "&", "(", "envInd", "<=", "wsz", ")", ")", "\n", "envInd", "=", "envInd", "[", "valid", "]", "-", "1", "\n", "winInd", "=", "winInd", "[", "valid", "]", "-", "1", "\n", "env", "[", "envInd", "]", "+=", "synwProd", "[", "winInd", "]", "\n", "\n", "", "synw", "=", "synw", "/", "env", "[", ":", ",", "0", "]", "\n", "return", "synw", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNAnalysis.__init__": [[172, 187], ["torch.Module.__init__", "int", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "cls_fe_dft.FNNAnalysis.initialize"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["def", "__init__", "(", "self", ",", "ft_size", "=", "1024", ")", ":", "\n", "        ", "super", "(", "FNNAnalysis", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Parameters", "\n", "self", ".", "batch_size", "=", "None", "\n", "self", ".", "time_domain_samples", "=", "None", "\n", "self", ".", "sz", "=", "ft_size", "\n", "self", ".", "half_N", "=", "int", "(", "self", ".", "sz", "/", "2", "+", "1", ")", "\n", "\n", "# Analysis", "\n", "self", ".", "fnn_analysis_real", "=", "nn", ".", "Linear", "(", "self", ".", "sz", ",", "self", ".", "sz", ",", "bias", "=", "False", ")", "\n", "self", ".", "fnn_analysis_imag", "=", "nn", ".", "Linear", "(", "self", ".", "sz", ",", "self", ".", "sz", ",", "bias", "=", "False", ")", "\n", "\n", "# Custom Initialization with Fourier matrix", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNAnalysis.initialize": [[188, 200], ["numpy.fft.fft", "numpy.real().astype", "numpy.imag().astype", "numpy.eye", "cls_fe_dft.FNNAnalysis.fnn_analysis_real.weight.data.copy_", "cls_fe_dft.FNNAnalysis.fnn_analysis_imag.weight.data.copy_", "cls_fe_dft.FNNAnalysis.fnn_analysis_real.weight.data.copy_", "cls_fe_dft.FNNAnalysis.fnn_analysis_imag.weight.data.copy_", "numpy.real", "numpy.imag", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "f_matrix", "=", "np", ".", "fft", ".", "fft", "(", "np", ".", "eye", "(", "self", ".", "sz", ")", ",", "norm", "=", "'ortho'", ")", "\n", "\n", "f_matrix_real", "=", "(", "np", ".", "real", "(", "f_matrix", ")", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "f_matrix_imag", "=", "(", "np", ".", "imag", "(", "f_matrix", ")", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "\n", "if", "torch", ".", "has_cudnn", ":", "\n", "            ", "self", ".", "fnn_analysis_real", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_real", ")", ".", "cuda", "(", ")", ")", "\n", "self", ".", "fnn_analysis_imag", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_imag", ")", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fnn_analysis_real", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_real", ")", ")", "\n", "self", ".", "fnn_analysis_imag", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_imag", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNAnalysis.forward": [[201, 206], ["cls_fe_dft.FNNAnalysis.fnn_analysis_real", "cls_fe_dft.FNNAnalysis.fnn_analysis_imag"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "wave_form", ")", ":", "\n", "        ", "an_real", "=", "self", ".", "fnn_analysis_real", "(", "wave_form", ")", "[", ":", ",", ":", ",", ":", "self", ".", "half_N", "]", "\n", "an_imag", "=", "self", ".", "fnn_analysis_imag", "(", "wave_form", ")", "[", ":", ",", ":", ",", ":", "self", ".", "half_N", "]", "\n", "\n", "return", "an_real", ",", "an_imag", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.__init__": [[214, 236], ["torch.Module.__init__", "int", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.nn.Tanh", "torch.nn.Tanh", "torch.nn.Tanh", "torch.nn.Tanh", "cls_fe_dft.FNNSynthesis.initialize_random", "cls_fe_dft.FNNSynthesis.initialize"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.initialize_random", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["def", "__init__", "(", "self", ",", "ft_size", "=", "1024", ",", "random_init", "=", "False", ")", ":", "\n", "        ", "super", "(", "FNNSynthesis", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Parameters", "\n", "self", ".", "batch_size", "=", "None", "\n", "self", ".", "time_domain_samples", "=", "None", "\n", "self", ".", "sz", "=", "ft_size", "\n", "self", ".", "half_N", "=", "int", "(", "self", ".", "sz", "/", "2", "+", "1", ")", "\n", "\n", "# Synthesis", "\n", "self", ".", "fnn_synthesis_real", "=", "nn", ".", "Linear", "(", "self", ".", "sz", ",", "self", ".", "sz", ",", "bias", "=", "False", ")", "\n", "self", ".", "fnn_synthesis_imag", "=", "nn", ".", "Linear", "(", "self", ".", "sz", ",", "self", ".", "sz", ",", "bias", "=", "False", ")", "\n", "\n", "# Tanh", "\n", "self", ".", "tanh", "=", "torch", ".", "nn", ".", "Tanh", "(", ")", "\n", "\n", "if", "random_init", ":", "\n", "# Random Initialization", "\n", "            ", "self", ".", "initialize_random", "(", ")", "\n", "", "else", ":", "\n", "# Custom Initialization with Fourier matrix", "\n", "            ", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.initialize": [[237, 251], ["print", "numpy.fft.fft", "numpy.real().astype", "numpy.imag().astype", "numpy.eye", "cls_fe_dft.FNNSynthesis.fnn_synthesis_real.weight.data.copy_", "cls_fe_dft.FNNSynthesis.fnn_synthesis_imag.weight.data.copy_", "cls_fe_dft.FNNSynthesis.fnn_synthesis_real.weight.data.copy_", "cls_fe_dft.FNNSynthesis.fnn_synthesis_imag.weight.data.copy_", "numpy.real", "numpy.imag", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Initializing with Fourier bases'", ")", "\n", "f_matrix", "=", "np", ".", "fft", ".", "fft", "(", "np", ".", "eye", "(", "self", ".", "sz", ")", ",", "norm", "=", "'ortho'", ")", "\n", "\n", "f_matrix_real", "=", "(", "np", ".", "real", "(", "f_matrix", ")", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "f_matrix_imag", "=", "(", "np", ".", "imag", "(", "f_matrix", ")", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "\n", "if", "torch", ".", "has_cudnn", ":", "\n", "            ", "self", ".", "fnn_synthesis_real", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_real", ".", "T", ")", ".", "cuda", "(", ")", ")", "\n", "self", ".", "fnn_synthesis_imag", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_imag", ".", "T", ")", ".", "cuda", "(", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "fnn_synthesis_real", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_real", ".", "T", ")", ")", "\n", "self", ".", "fnn_synthesis_imag", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "f_matrix_imag", ".", "T", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.initialize_random": [[252, 256], ["print", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform"], "methods", ["None"], ["", "", "def", "initialize_random", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Initializing randomly'", ")", "\n", "nn", ".", "init", ".", "xavier_uniform", "(", "self", ".", "fnn_synthesis_real", ".", "weight", ")", "\n", "nn", ".", "init", ".", "xavier_uniform", "(", "self", ".", "fnn_synthesis_imag", ".", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.forward": [[257, 263], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "cls_fe_dft.FNNSynthesis.fnn_synthesis_real", "cls_fe_dft.FNNSynthesis.fnn_synthesis_imag", "cls_fe_dft.Synthesis.flip", "cls_fe_dft.Synthesis.flip", "real[].contiguous", "imag[].contiguous"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.flip", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.flip"], ["", "def", "forward", "(", "self", ",", "real", ",", "imag", ")", ":", "\n", "        ", "real", "=", "torch", ".", "cat", "(", "(", "real", ",", "Synthesis", ".", "flip", "(", "real", "[", ":", ",", ":", ",", "1", ":", "-", "1", "]", ".", "contiguous", "(", ")", ",", "2", ")", ")", ",", "2", ")", "\n", "imag", "=", "torch", ".", "cat", "(", "(", "imag", ",", "Synthesis", ".", "flip", "(", "-", "imag", "[", ":", ",", ":", ",", "1", ":", "-", "1", "]", ".", "contiguous", "(", ")", ",", "2", ")", ")", ",", "2", ")", "\n", "\n", "wave_form", "=", "self", ".", "fnn_synthesis_real", "(", "real", ")", "+", "self", ".", "fnn_synthesis_imag", "(", "imag", ")", "\n", "return", "wave_form", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dft.FNNSynthesis.flip": [[275, 280], ["torch.arange", "torch.arange", "torch.arange", "torch.arange", "x.dim", "slice", "x.size", "tuple"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "flip", "(", "x", ",", "dim", ")", ":", "\n", "        ", "indices", "=", "[", "slice", "(", "None", ")", "]", "*", "x", ".", "dim", "(", ")", "\n", "indices", "[", "dim", "]", "=", "torch", ".", "arange", "(", "x", ".", "size", "(", "dim", ")", "-", "1", ",", "-", "1", ",", "-", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "x", ".", "device", ")", "\n", "return", "x", "[", "tuple", "(", "indices", ")", "]", "\n", "# EOF", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.__init__": [[455, 461], ["numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sr", "=", "44100.0", ",", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "        ", "self", ".", "name", "=", "'Generic Effect'", "\n", "self", ".", "knob_names", "=", "[", "'knob'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", "]", ",", "dtype", "=", "dtype", ")", "# min,max world coordinate values for \"all the way counterclockwise\" and \"all the way clockwise\"", "\n", "self", ".", "sr", "=", "sr", "\n", "self", ".", "is_inverse", "=", "False", "# Does this effect perform an 'inverse problem' by reversing x & y at the end?", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.knobs_wc": [[462, 464], ["None"], "methods", ["None"], ["", "def", "knobs_wc", "(", "self", ",", "knobs_nn", ")", ":", "# convert knob vals from [-.5,.5] to \"world coordinates\" used by effect functions", "\n", "        ", "return", "(", "self", ".", "knob_ranges", "[", ":", ",", "0", "]", "+", "(", "knobs_nn", "+", "0.5", ")", "*", "(", "self", ".", "knob_ranges", "[", ":", ",", "1", "]", "-", "self", ".", "knob_ranges", "[", ":", ",", "0", "]", ")", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.info": [[465, 472], ["print", "range", "len", "len", "len", "print", "print"], "methods", ["None"], ["", "def", "info", "(", "self", ")", ":", "# Print some information about the effect", "\n", "        ", "assert", "len", "(", "self", ".", "knob_names", ")", "==", "len", "(", "self", ".", "knob_ranges", ")", "\n", "print", "(", "f'Effect: {self.name}.  Knobs:'", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "knob_names", ")", ")", ":", "\n", "            ", "print", "(", "f'                            {self.knob_names[i]}: {self.knob_ranges[i][0]} to {self.knob_ranges[i][1]}'", ")", "\n", "", "if", "self", ".", "is_inverse", ":", "\n", "            ", "print", "(", "\"                            <<<< INVERSE EFFECT <<<<\"", ")", "\n", "# Effects should also define a 'go_wc' method which executes the effect, mapping input and knobs_nn to output y, x", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.go_wc": [[474, 476], ["Exception"], "methods", ["None"], ["", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_wc", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"This effect's go_wc() is undefined\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.go": [[478, 481], ["audio.Effect.knobs_wc", "audio.Effect.go_wc"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.knobs_wc", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.FileEffect.go_wc"], ["", "def", "go", "(", "self", ",", "x", ",", "knobs_nn", ",", "**", "kwargs", ")", ":", "\n", "        ", "knobs_w", "=", "self", ".", "knobs_wc", "(", "knobs_nn", ")", "\n", "return", "self", ".", "go_wc", "(", "x", ",", "knobs_w", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Compressor.__init__": [[485, 490], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Compressor", ",", "self", ",", "**", "kwargs", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'Compressor'", "\n", "self", ".", "knob_names", "=", "[", "'threshold'", ",", "'ratio'", ",", "'attackreleaseTime'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "-", "30", ",", "0", "]", ",", "[", "1", ",", "5", "]", ",", "[", "1e-3", ",", "4e-2", "]", "]", ")", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Compressor.go_wc": [[490, 492], ["audio.compressor"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.compressor"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "compressor", "(", "x", ",", "thresh", "=", "knobs_w", "[", "0", "]", ",", "ratio", "=", "knobs_w", "[", "1", "]", ",", "attackrel", "=", "knobs_w", "[", "2", "]", ",", "sr", "=", "self", ".", "sr", ")", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Compressor_4c.__init__": [[494, 499], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Compressor_4c", ",", "self", ",", "**", "kwargs", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'Compressor_4c'", "\n", "self", ".", "knob_names", "=", "[", "'threshold'", ",", "'ratio'", ",", "'attackTime'", ",", "'releaseTime'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "-", "30", ",", "0", "]", ",", "[", "1", ",", "5", "]", ",", "[", "1e-3", ",", "4e-2", "]", ",", "[", "1e-3", ",", "4e-2", "]", "]", ")", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Compressor_4c.go_wc": [[499, 501], ["audio.compressor_4controls"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.compressor_4controls"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "compressor_4controls", "(", "x", ",", "thresh", "=", "knobs_w", "[", "0", "]", ",", "ratio", "=", "knobs_w", "[", "1", "]", ",", "attackTime", "=", "knobs_w", "[", "2", "]", ",", "releaseTime", "=", "knobs_w", "[", "3", "]", ",", "sr", "=", "self", ".", "sr", ")", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Compressor_4c_Large.__init__": [[504, 509], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Compressor_4c_Large", ",", "self", ",", "**", "kwargs", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'Compressor_4c_Large'", "\n", "self", ".", "knob_names", "=", "[", "'threshold'", ",", "'ratio'", ",", "'attackTime'", ",", "'releaseTime'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "-", "50", ",", "0", "]", ",", "[", "1.5", ",", "10", "]", ",", "[", "1e-3", ",", "1", "]", ",", "[", "1e-3", ",", "1", "]", "]", ")", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Compressor_4c_Large.go_wc": [[509, 511], ["audio.compressor_4controls"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.compressor_4controls"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "compressor_4controls", "(", "x", ",", "thresh", "=", "knobs_w", "[", "0", "]", ",", "ratio", "=", "knobs_w", "[", "1", "]", ",", "attackTime", "=", "knobs_w", "[", "2", "]", ",", "releaseTime", "=", "knobs_w", "[", "3", "]", ",", "sr", "=", "self", ".", "sr", ")", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Comp_Just_Thresh.__init__": [[517, 525], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Comp_Just_Thresh", ",", "self", ",", "**", "kwargs", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'Comp_Just_Thresh'", "\n", "self", ".", "knob_names", "=", "[", "'threshold'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "-", "50", ",", "-", "10", "]", "]", ")", "\n", "self", ".", "ratio", "=", "3.0", "\n", "self", ".", "attack", "=", ".05", "# 50ms", "\n", "self", ".", "release", "=", "1.0", "# 1 second!", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Comp_Just_Thresh.go_wc": [[525, 527], ["audio.compressor_4controls"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.compressor_4controls"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "compressor_4controls", "(", "x", ",", "thresh", "=", "knobs_w", "[", "0", "]", ",", "ratio", "=", "self", ".", "ratio", ",", "attackTime", "=", "self", ".", "attack", ",", "releaseTime", "=", "self", ".", "release", ",", "sr", "=", "self", ".", "sr", ")", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Compressor_4c_OneSetting.__init__": [[530, 535], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Compressor_4c_OneSetting", ",", "self", ",", "**", "kwargs", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'Compressor_4c_OneSetting'", "\n", "self", ".", "knob_names", "=", "[", "'threshold'", ",", "'ratio'", ",", "'attackTime'", ",", "'releaseTime'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "-", "25.001", ",", "-", "25.", "]", ",", "[", "4", ",", "4.001", "]", ",", "[", "5e-3", ",", "5.001e-3", "]", ",", "[", "2e-2", ",", "2.001e-2", "]", "]", ")", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Compressor_4c_OneSetting.go_wc": [[535, 537], ["audio.compressor_4controls"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.compressor_4controls"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "compressor_4controls", "(", "x", ",", "thresh", "=", "knobs_w", "[", "0", "]", ",", "ratio", "=", "knobs_w", "[", "1", "]", ",", "attackTime", "=", "knobs_w", "[", "2", "]", ",", "releaseTime", "=", "knobs_w", "[", "3", "]", ",", "sr", "=", "self", ".", "sr", ")", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Echo.__init__": [[540, 546], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Echo", ",", "self", ",", "**", "kwargs", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'Echo'", "\n", "self", ".", "knob_names", "=", "[", "'delay_samples'", ",", "'ratio'", ",", "'echoes'", "]", "\n", "#self.knob_ranges = np.array([[100,1500], [0.1,0.9],[2,2]])", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "400", ",", "400", "]", ",", "[", "0.4", ",", "1.0", "]", ",", "[", "2", ",", "2", "]", "]", ")", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Echo.go_wc": [[546, 548], ["audio.echo", "int", "int", "numpy.round", "numpy.round"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.echo"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "echo", "(", "x", ",", "delay_samples", "=", "int", "(", "np", ".", "round", "(", "knobs_w", "[", "0", "]", ")", ")", ",", "ratio", "=", "knobs_w", "[", "1", "]", ",", "echoes", "=", "int", "(", "np", ".", "round", "(", "knobs_w", "[", "2", "]", ")", ")", ")", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.PitchShifter.__init__": [[550, 555], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "PitchShifter", ",", "self", ",", "**", "kwargs", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'PitchShifter'", "\n", "self", ".", "knob_names", "=", "[", "'n_steps'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "-", "12", ",", "12", "]", "]", ")", "# number of 12-tone pitch steps by which to shift the signal", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.PitchShifter.go_wc": [[555, 557], ["librosa.effects.pitch_shift"], "methods", ["None"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "librosa", ".", "effects", ".", "pitch_shift", "(", "x", ",", "sr", "=", "self", ".", "sr", ",", "n_steps", "=", "knobs_w", "[", "0", "]", ")", ",", "x", "# TODO: librosa's pitch_shift is SLOW!", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Denoise.__init__": [[564, 570], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Denoise", ",", "self", ",", "**", "kwargs", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'Denoise'", "\n", "self", ".", "knob_names", "=", "[", "'strength'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.5", "]", "]", ")", "\n", "self", ".", "is_inverse", "=", "True", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Denoise.go_wc": [[570, 572], ["numpy.random.random"], "methods", ["None"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "x", ",", "x", "+", "(", "knobs_w", "[", "0", "]", "*", "(", "2", "*", "np", ".", "random", ".", "random", "(", "x", ".", "shape", "[", "0", "]", ")", "-", "1", ")", ")", ".", "astype", "(", "x", ".", "dtype", ",", "copy", "=", "False", ")", "# swaps y & x: what was the input becomes the output", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.DeCompressor_4c.__init__": [[574, 581], ["audio.Effect.__init__", "audio.Compressor_4c"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DeCompressor_4c", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'DeCompressor_4c'", "\n", "sub_effect", "=", "Compressor_4c", "(", ")", "\n", "self", ".", "knob_names", "=", "sub_effect", ".", "knob_names", "\n", "self", ".", "knob_ranges", "=", "sub_effect", ".", "knob_ranges", "\n", "self", ".", "is_inverse", "=", "True", "# this effect swaps input & output at the end", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.DeCompressor_4c.go_wc": [[581, 584], ["audio.compressor_4controls"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.compressor_4controls"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "y", "=", "compressor_4controls", "(", "x", ",", "thresh", "=", "knobs_w", "[", "0", "]", ",", "ratio", "=", "knobs_w", "[", "1", "]", ",", "attackTime", "=", "knobs_w", "[", "2", "]", ",", "releaseTime", "=", "knobs_w", "[", "3", "]", ")", "\n", "return", "x", ",", "y", "# swap usual order of x and y", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.TimeAlign.__init__": [[590, 598], ["audio.Effect.__init__", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["def", "__init__", "(", "self", ",", "sr", "=", "44100", ")", ":", "\n", "        ", "super", "(", "TimeAlign", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'TimeAlign'", "\n", "self", ".", "knob_names", "=", "[", "'strength'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "0.001", ",", "0.5", "]", "]", ")", "\n", "self", ".", "is_inverse", "=", "True", "\n", "chunk_size", "=", "4096", "# TODO un-hardcode this", "\n", "self", ".", "t", "=", "np", ".", "arange", "(", "chunk_size", ",", "dtype", "=", "np", ".", "float32", ")", "/", "sr", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.TimeAlign.go_wc": [[598, 608], ["numpy.random.choice", "audio.synth_input_sample", "int", "numpy.roll", "numpy.zeros", "numpy.zeros", "numpy.abs", "numpy.random.rand", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.synth_input_sample"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "chooser", "=", "np", ".", "random", ".", "choice", "(", "[", "2", ",", "4", ",", "6", ",", "7", "]", ")", "\n", "y", "=", "synth_input_sample", "(", "self", ".", "t", ",", "chooser", ",", "t0_fac", "=", "0.5", ")", "# start onset in the middle of chunk", "\n", "rand_shift", "=", "int", "(", "x", ".", "shape", "[", "0", "]", "*", "knobs_w", "[", "0", "]", "*", "(", "2", "*", "np", ".", "random", ".", "rand", "(", ")", "-", "1", ")", ")", "# shift forward or back by 1/3 of width", "\n", "x", "=", "np", ".", "roll", "(", "y", ",", "rand_shift", ")", "\n", "if", "rand_shift", ">", "0", ":", "\n", "            ", "x", "[", "0", ":", "rand_shift", "]", "=", "np", ".", "zeros", "(", "rand_shift", ")", "\n", "", "elif", "rand_shift", "<", "0", ":", "\n", "            ", "x", "[", "-", "np", ".", "abs", "(", "rand_shift", ")", ":", "]", "=", "np", ".", "zeros", "(", "np", ".", "abs", "(", "rand_shift", ")", ")", "\n", "", "return", "y", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.LowPass.__init__": [[612, 618], ["audio.Effect.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "sr", "=", "44100", ")", ":", "\n", "        ", "super", "(", "LowPass", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'LowPass'", "\n", "self", ".", "knob_names", "=", "[", "'cutoff'", "]", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "[", "[", "10", ",", "2000", "]", "]", ")", "# number of 12-tone pitch steps by which to shift the signal", "\n", "self", ".", "sr", "=", "sr", "\n", "", "def", "butter_lowpass", "(", "self", ",", "cutoff", ",", "order", "=", "3", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.LowPass.butter_lowpass": [[618, 623], ["scipy.butter"], "methods", ["None"], ["", "def", "butter_lowpass", "(", "self", ",", "cutoff", ",", "order", "=", "3", ")", ":", "\n", "        ", "nyq", "=", "0.5", "*", "self", ".", "sr", "\n", "normal_cutoff", "=", "cutoff", "/", "nyq", "\n", "b", ",", "a", "=", "scipy_signal", ".", "butter", "(", "order", ",", "normal_cutoff", ",", "btype", "=", "'low'", ",", "analog", "=", "False", ")", "\n", "return", "b", ",", "a", "\n", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ",", "order", "=", "3", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.LowPass.go_wc": [[623, 626], ["audio.LowPass.butter_lowpass", "scipy.lfilter"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.LowPass.butter_lowpass"], ["", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ",", "order", "=", "3", ")", ":", "\n", "        ", "b", ",", "a", "=", "self", ".", "butter_lowpass", "(", "knobs_w", "[", "0", "]", ",", "order", "=", "order", ")", "\n", "return", "scipy_signal", ".", "lfilter", "(", "b", ",", "a", ",", "x", ")", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.FileEffect.__init__": [[648, 669], ["audio.Effect.__init__", "print", "configparser.ConfigParser", "configparser.ConfigParser.read", "eval", "numpy.array", "print", "sys.exit", "configparser.ConfigParser.get", "eval", "glob.glob", "glob.glob", "glob.glob", "configparser.ConfigParser.get", "bool"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__"], ["def", "__init__", "(", "self", ",", "path", ",", "sr", "=", "44100", ",", ")", ":", "\n", "        ", "super", "(", "FileEffect", ",", "self", ")", ".", "__init__", "(", ")", "\n", "print", "(", "\"  FileEffect: path = \"", ",", "path", ")", "\n", "if", "(", "path", "is", "None", ")", "or", "(", "not", "glob", ".", "glob", "(", "path", "+", "\"/Train/target*\"", ")", ")", "or", "(", "not", "glob", ".", "glob", "(", "path", "+", "\"/Val/target*\"", ")", ")", "or", "(", "(", "not", "glob", ".", "glob", "(", "path", "+", "\"/effect_info.ini\"", ")", ")", ")", ":", "\n", "            ", "print", "(", "f\"Error: can't file target output files or effect_info.ini in path = {path}\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "# Yea, this is fatal", "\n", "\n", "", "self", ".", "sr", "=", "sr", "\n", "# read the effect info config file  \"effect_info.ini\"", "\n", "config", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "config", ".", "read", "(", "path", "+", "'/effect_info.ini'", ")", "\n", "self", ".", "name", "=", "config", "[", "'effect'", "]", "[", "'name'", "]", "+", "\"(files)\"", "# tack on \"(files)\" to the effect name", "\n", "#TODO: note that use of 'eval' below could be a potential security issue", "\n", "self", ".", "knob_names", "=", "eval", "(", "config", ".", "get", "(", "\"effect\"", ",", "\"knob_names\"", ")", ")", "\n", "self", ".", "knob_ranges", "=", "np", ".", "array", "(", "eval", "(", "config", ".", "get", "(", "\"effect\"", ",", "\"knob_ranges\"", ")", ")", ")", "\n", "try", ":", "\n", "            ", "self", ".", "is_inverse", "=", "(", "True", "==", "bool", "(", "config", "[", "'effect'", "]", "[", "'inverse'", "]", ")", ")", "\n", "self", ".", "name", "=", "\"De-\"", "+", "self", ".", "name", "\n", "", "except", ":", "\n", "            ", "pass", "# Ignore errors we don't require that 'inverse' be defined anywhere in the file", "\n", "", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.FileEffect.go_wc": [[669, 671], ["None"], "methods", ["None"], ["", "", "def", "go_wc", "(", "self", ",", "x", ",", "knobs_w", ")", ":", "\n", "        ", "return", "# dummy op. there is no plugin to call; we're reading from files", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.random_ends": [[20, 22], ["numpy.random.beta"], "function", ["None"], ["def", "random_ends", "(", "size", "=", "1", ")", ":", "# probabilty dist. that emphasizes boundaries", "\n", "    ", "return", "np", ".", "random", ".", "beta", "(", "0.8", ",", "0.8", ",", "size", "=", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.sliding_window": [[23, 50], ["numpy.lib.stride_tricks.as_strided", "numpy.pad"], "function", ["None"], ["", "@", "jit", "\n", "def", "sliding_window", "(", "x", ",", "size", ",", "overlap", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Stacks 1D array into a series of sliding windows with a certain amount of overlaps.\n    This is fast because it generates a \"view\" rather than creating a new array.\n    -->Unless the windows don't divide evenly, in which case we pad with zeros to get an even coverage\n    Inputs:\n       x:  the 1D array to be windowed\n       size:  the width of each window\n       overlap = amount of \"lookback\" (in samples), when predicting the next set of values\n    Example:\n        x = np.arange(10)\n        print(sliding_window(x, 5, overlap=2))\n         [[0 1 2 3 4]\n         [3 4 5 6 7]\n         [6 7 8 9 0]]\n    Source: from last answer to https://stackoverflow.com/questions/4923617/efficient-numpy-2d-array-construction-from-1d-array\n    \"\"\"", "\n", "step", "=", "size", "-", "overlap", "# amount of non-overlapped values per window", "\n", "remainder", "=", "(", "x", ".", "shape", "[", "-", "1", "]", "-", "size", ")", "%", "step", "# see if array will divide up evenly", "\n", "if", "remainder", "!=", "0", ":", "\n", "        ", "x", "=", "np", ".", "pad", "(", "x", ",", "(", "0", ",", "step", "-", "remainder", ")", ",", "mode", "=", "'constant'", ")", "# pad end with zeros until it does. note this changes the size of x", "\n", "\n", "", "nwin", "=", "(", "x", ".", "shape", "[", "-", "1", "]", "-", "size", ")", "//", "step", "+", "1", "# this truncates any leftover rows, rather than padding with zeros", "\n", "shape", "=", "x", ".", "shape", "[", ":", "-", "1", "]", "+", "(", "nwin", ",", "size", ")", "\n", "strides", "=", "x", ".", "strides", "[", ":", "-", "1", "]", "+", "(", "step", "*", "x", ".", "strides", "[", "-", "1", "]", ",", "x", ".", "strides", "[", "-", "1", "]", ")", "\n", "return", "np", ".", "lib", ".", "stride_tricks", ".", "as_strided", "(", "x", ",", "shape", "=", "shape", ",", "strides", "=", "strides", ",", "writeable", "=", "False", ")", "# writeable=False is to avoid memory corruption. better safe than sorry!", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.undo_sliding_window": [[61, 74], ["numpy.concatenate", "x[].flatten"], "function", ["None"], ["def", "undo_sliding_window", "(", "x", ",", "overlap", ",", "flatsize", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    This works in general, i.e. for views and for copies of arrays.\n    NOTE: only undoes padding that might have occurred if flatsize != None.\n    \"\"\"", "\n", "if", "overlap", "!=", "0", ":", "\n", "        ", "xnew", "=", "np", ".", "concatenate", "(", "(", "x", "[", "0", ",", "0", ":", "overlap", "]", ",", "x", "[", ":", ",", "overlap", ":", "]", ".", "flatten", "(", ")", ")", ")", "\n", "if", "flatsize", "is", "not", "None", ":", "\n", "          ", "return", "xnew", "[", "0", ":", "flatsize", "]", "\n", "", "else", ":", "\n", "          ", "return", "xnew", "\n", "", "", "else", ":", "\n", "        ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.normish": [[75, 82], ["numpy.max", "numpy.abs", "randfunc"], "function", ["None"], ["", "", "def", "normish", "(", "y", ",", "amp_range", "=", "None", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ")", ":", "\n", "    ", "\"\"\"\n    Keep signal from exceeding -1,1...but still have random amplitude\n    \"\"\"", "\n", "amp_range", "=", "[", "0.6", ",", "0.9", "]", "if", "amp_range", "is", "None", "else", "amp_range", "\n", "y", "=", "y", "/", "np", ".", "max", "(", "np", ".", "abs", "(", "y", ")", ")", "*", "(", "(", "amp_range", "[", "1", "]", "-", "amp_range", "[", "0", "]", ")", "*", "randfunc", "(", ")", "+", "amp_range", "[", "0", "]", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pinknoise": [[85, 95], ["numpy.sqrt", "numpy.fft.irfft", "numpy.max", "numpy.random.random", "numpy.arange", "numpy.abs", "len"], "function", ["None"], ["", "def", "pinknoise", "(", "N", ")", ":", "\n", "    ", "\"\"\"\n    Generates 1/f noise\n      N = length of array to generate\n    \"\"\"", "\n", "N_f", "=", "N", "//", "2", "+", "1", "\n", "noise", "=", "2", "*", "np", ".", "random", ".", "random", "(", "N_f", ")", "-", "1", "\n", "s", "=", "np", ".", "sqrt", "(", "np", ".", "arange", "(", "len", "(", "noise", ")", ")", "+", "1.", ")", "# +1 avoids dividing by zero", "\n", "y", "=", "(", "np", ".", "fft", ".", "irfft", "(", "noise", "/", "s", ")", ")", ".", "real", "\n", "return", "y", "/", "np", ".", "max", "(", "np", ".", "abs", "(", "y", ")", ")", "# normalize", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.randsine": [[96, 105], ["numpy.zeros", "range", "audio.normish", "numpy.random.randint", "numpy.cos", "randfunc", "randfunc", "randfunc"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.normish"], ["", "def", "randsine", "(", "t", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ",", "amp_range", "=", "[", "0.2", ",", "0.9", "]", ",", "freq_range", "=", "[", "5", ",", "150", "]", ",", "n_tones", "=", "None", ",", "t0_fac", "=", "None", ")", ":", "\n", "    ", "y", "=", "np", ".", "zeros", "(", "t", ".", "shape", "[", "0", "]", ")", "\n", "if", "n_tones", "is", "None", ":", "n_tones", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "3", ")", "\n", "for", "i", "in", "range", "(", "n_tones", ")", ":", "\n", "        ", "amp", "=", "amp_range", "[", "0", "]", "+", "(", "amp_range", "[", "1", "]", "-", "amp_range", "[", "0", "]", ")", "*", "randfunc", "(", ")", "\n", "freq", "=", "freq_range", "[", "0", "]", "+", "(", "freq_range", "[", "1", "]", "-", "freq_range", "[", "0", "]", ")", "*", "randfunc", "(", ")", "\n", "t0", "=", "randfunc", "(", ")", "*", "t", "[", "-", "1", "]", "if", "t0_fac", "is", "None", "else", "t0_fac", "*", "t", "[", "-", "1", "]", "\n", "y", "+=", "amp", "*", "np", ".", "cos", "(", "freq", "*", "(", "t", "-", "t0", ")", ")", "\n", "", "return", "normish", "(", "y", ",", "randfunc", "=", "randfunc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.box": [[106, 123], ["len", "min", "int", "numpy.ones().astype", "randfunc", "int", "int", "randfunc", "randfunc", "numpy.ones", "randfunc", "numpy.arange", "numpy.arange", "randfunc"], "function", ["None"], ["", "def", "box", "(", "t", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ",", "t0_fac", "=", "None", ",", "delta", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    classic \"box\"-shaped step response\n    t0_fac: specifies faction of total length at which to start at (otherwise random)\n    \"\"\"", "\n", "height_bgn", ",", "height_mid", ",", "height_end", "=", "0.15", "*", "randfunc", "(", ")", ",", "0.35", "*", "randfunc", "(", ")", "+", "0.6", ",", "0.2", "*", "randfunc", "(", ")", "+", "0.1", "\n", "maxi", "=", "len", "(", "t", ")", "\n", "delta", "=", "0", "# np.random.choice([0, np.random.randint(100) ]) if delta is None else delta # maybe slope the sides ; delta=0 is an immediate step response", "\n", "i_up", "=", "delta", "+", "int", "(", "0.3", "*", "randfunc", "(", ")", "*", "maxi", ")", "if", "t0_fac", "is", "None", "else", "int", "(", "t0_fac", "*", "maxi", ")", "\n", "i_dn", "=", "min", "(", "i_up", "+", "int", "(", "(", "0.3", "+", "0.35", "*", "randfunc", "(", ")", ")", "*", "maxi", ")", ",", "maxi", "-", "delta", "-", "1", ")", "# time for jumping back down", "\n", "x", "=", "height_end", "*", "np", ".", "ones", "(", "t", ".", "shape", "[", "0", "]", ")", ".", "astype", "(", "t", ".", "dtype", ",", "copy", "=", "False", ")", "# unit amplitude", "\n", "x", "[", "0", ":", "i_up", "-", "1", "]", "=", "height_bgn", "\n", "x", "[", "i_up", ":", "i_dn", "]", "=", "height_mid", "# the \"flat top\" middle area of the box", "\n", "if", "delta", ">", "0", ":", "\n", "        ", "x", "[", "i_up", "-", "delta", ":", "i_up", "+", "delta", "]", "=", "height_bgn", "+", "(", "height_mid", "-", "height_bgn", ")", "*", "(", "np", ".", "arange", "(", "2", "*", "delta", ")", ")", "/", "2", "/", "delta", "\n", "x", "[", "i_dn", "-", "delta", ":", "i_dn", "+", "delta", "]", "=", "height_mid", "-", "(", "height_mid", "-", "height_end", ")", "*", "(", "np", ".", "arange", "(", "2", "*", "delta", ")", ")", "/", "2", "/", "delta", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.expdecay": [[124, 135], ["randfunc", "numpy.exp", "numpy.where", "randfunc", "randfunc", "randfunc"], "function", ["None"], ["", "def", "expdecay", "(", "t", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ",", "t0_fac", "=", "None", ",", "high_fac", "=", "None", ",", "low_fac", "=", "None", ")", ":", "\n", "    ", "\"\"\"generic exponential decay envelope; called by other routines (below)\n       t0_fac is fraction of final time at which to start\n    \"\"\"", "\n", "t0", "=", "0.35", "*", "randfunc", "(", ")", "*", "t", "[", "-", "1", "]", "if", "t0_fac", "is", "None", "else", "t0_fac", "*", "t", "[", "-", "1", "]", "\n", "height_high", "=", "0.35", "*", "randfunc", "(", ")", "+", "0.6", "if", "high_fac", "is", "None", "else", "high_fac", "\n", "height_low", "=", "0.1", "*", "randfunc", "(", ")", "+", "0.1", "if", "low_fac", "is", "None", "else", "low_fac", "\n", "decay", "=", "12", "*", "randfunc", "(", ")", "\n", "x", "=", "np", ".", "exp", "(", "-", "decay", "*", "(", "t", "-", "t0", ")", ")", "*", "height_high", "# decaying envelope", "\n", "x", "[", "np", ".", "where", "(", "t", "<", "t0", ")", "]", "=", "height_low", "# without this, it grow exponentially 'to the left'", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pluck": [[136, 147], ["numpy.zeros", "range", "audio.normish", "numpy.random.randint", "audio.expdecay", "numpy.sin", "numpy.random.choice", "randfunc", "randfunc", "randfunc"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.normish", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.expdecay"], ["", "def", "pluck", "(", "t", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ",", "freq_range", "=", "[", "50", ",", "6400", "]", ",", "n_tones", "=", "None", ",", "t0_fac", "=", "None", ",", "amp", "=", "None", ")", ":", "\n", "    ", "y", "=", "np", ".", "zeros", "(", "t", ".", "shape", "[", "0", "]", ")", "\n", "\"\"\" supposed to be like a plucked string; but with a few random tones as well\"\"\"", "\n", "if", "n_tones", "is", "None", ":", "n_tones", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "4", ")", "\n", "for", "i", "in", "range", "(", "n_tones", ")", ":", "\n", "        ", "amp0", "=", "(", "0.45", "*", "randfunc", "(", ")", "+", "0.5", ")", "*", "np", ".", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "if", "amp", "is", "None", "else", "amp", "\n", "t0", "=", "(", "2.", "*", "randfunc", "(", ")", "-", "1", ")", "*", "0.3", "*", "t", "[", "-", "1", "]", "if", "t0_fac", "is", "None", "else", "t0_fac", "*", "t", "[", "-", "1", "]", "# for phase", "\n", "freq", "=", "freq_range", "[", "0", "]", "+", "(", "freq_range", "[", "1", "]", "-", "freq_range", "[", "0", "]", ")", "*", "randfunc", "(", ")", "\n", "y", "+=", "amp0", "*", "np", ".", "sin", "(", "freq", "*", "(", "t", "-", "t0", ")", ")", "\n", "", "y", "=", "y", "*", "expdecay", "(", "t", ",", "t0_fac", "=", "t0_fac", ")", "\n", "return", "normish", "(", "y", ",", "randfunc", "=", "randfunc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.ampexpstepup": [[149, 162], ["numpy.floor", "numpy.power", "audio.normish", "numpy.linspace", "numpy.sin", "len", "randfunc"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.normish"], ["", "def", "ampexpstepup", "(", "t", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ",", "freq", "=", "None", ",", "freq_range", "=", "[", "400", ",", "5000", "]", ",", "start_dB", "=", "-", "40", ")", ":", "\n", "    ", "\"\"\" sine wave with exponentially increase amplitude\n    cf. Figure 3 of AES Conf Paper 6849: \"Parameter Estimation of Dynamic Range Compressors: Models, Procedures and Test Signals\"\n    http://www.aes.org/e-lib/browse.cfm?elib=13653\n    ...except we typically won't do a signal that long (theirs is ~120 seconds)\n    ...Looks lik they stey by 1dB for about 50 steps across the clip\n    \"\"\"", "\n", "env_dB", "=", "np", ".", "floor", "(", "np", ".", "linspace", "(", "start_dB", ",", "0", ",", "num", "=", "len", "(", "t", ")", ")", ")", "# envelope in integer steps from start_dB to 0dB", "\n", "env", "=", "np", ".", "power", "(", "10.0", ",", "env_dB", "/", "10", ")", "# envelope in float values", "\n", "if", "freq", "is", "None", ":", "#  Otherwise, the user has specified a frequency in Hz", "\n", "        ", "freq", "=", "freq_range", "[", "0", "]", "+", "(", "freq_range", "[", "1", "]", "-", "freq_range", "[", "0", "]", ")", "*", "randfunc", "(", ")", "# pick a freq", "\n", "", "y", "=", "env", "*", "np", ".", "sin", "(", "freq", "*", "t", ")", "\n", "return", "normish", "(", "y", ",", "randfunc", "=", "randfunc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.sweep": [[164, 174], ["numpy.log", "audio.normish", "numpy.sin", "numpy.exp", "randfunc", "numpy.exp"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.normish"], ["", "def", "sweep", "(", "t", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ",", "freq_range", "=", "[", "20", ",", "20000", "]", ",", "amp", "=", "None", ",", "amp_too", "=", "False", ")", ":", "\n", "    ", "\"\"\"exponential frequency sweep\n    \"\"\"", "\n", "tmax", "=", "t", "[", "-", "1", "]", "\n", "lnfr", "=", "np", ".", "log", "(", "freq_range", "[", "1", "]", "/", "freq_range", "[", "0", "]", ")", "# ln of frequency ratio", "\n", "amp", "=", "0.9", "*", "randfunc", "(", ")", "if", "amp", "is", "None", "else", "amp", "\n", "y", "=", "amp", "*", "np", ".", "sin", "(", "20", "*", "2", "*", "np", ".", "pi", "*", "tmax", "/", "lnfr", "*", "(", "np", ".", "exp", "(", "t", "/", "tmax", "*", "lnfr", ")", "-", "1", ")", ")", "\n", "if", "amp_too", ":", "# exponentially increase the amplitude as well", "\n", "        ", "y", "*=", "np", ".", "exp", "(", "lnfr", "*", "t", "/", "tmax", ")", "\n", "", "return", "normish", "(", "y", ",", "randfunc", "=", "randfunc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.spikes": [[175, 187], ["numpy.zeros", "range", "int", "randfunc", "numpy.random.normal", "int", "randfunc", "randfunc", "len"], "function", ["None"], ["", "def", "spikes", "(", "t", ",", "n_spikes", "=", "50", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ")", ":", "# \"bunch of random spikes\"", "\n", "    ", "x", "=", "np", ".", "zeros", "(", "t", ".", "shape", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "n_spikes", ")", ":", "# arbitrarily make a 'spike' somewhere, surrounded by silence", "\n", "      ", "loc", "=", "int", "(", "int", "(", "randfunc", "(", ")", "*", "len", "(", "t", ")", "-", "2", ")", "+", "1", "*", "t", "[", "-", "1", "]", ")", "\n", "height", "=", "(", "2", "*", "randfunc", "(", ")", "-", "1", ")", "*", "0.7", "# -0.7...0.7", "\n", "x", "[", "loc", "]", "=", "height", "\n", "x", "[", "loc", "+", "1", "]", "=", "height", "/", "2", "# widen the spike a bit", "\n", "x", "[", "loc", "-", "1", "]", "=", "height", "/", "2", "\n", "\n", "", "amp_n", "=", "0.1", "*", "randfunc", "(", ")", "\n", "x", "=", "x", "+", "amp_n", "*", "np", ".", "random", ".", "normal", "(", "size", "=", "t", ".", "shape", "[", "0", "]", ")", "# throw in noise", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.triangle": [[188, 197], ["numpy.random.choice", "randfunc", "numpy.where", "numpy.where", "randfunc", "audio.pinknoise", "randfunc", "numpy.abs", "randfunc"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pinknoise"], ["", "def", "triangle", "(", "t", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ",", "t0_fac", "=", "None", ")", ":", "# ramp up then down", "\n", "    ", "height", "=", "(", "0.4", "*", "randfunc", "(", ")", "+", "0.4", ")", "*", "np", ".", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "\n", "width", "=", "randfunc", "(", ")", "/", "4", "*", "t", "[", "-", "1", "]", "# half-width actually", "\n", "t0", "=", "2", "*", "width", "+", "0.4", "*", "randfunc", "(", ")", "*", "t", "[", "-", "1", "]", "if", "t0_fac", "is", "None", "else", "t0_fac", "*", "t", "[", "-", "1", "]", "\n", "x", "=", "height", "*", "(", "1", "-", "np", ".", "abs", "(", "t", "-", "t0", ")", "/", "width", ")", "\n", "x", "[", "np", ".", "where", "(", "t", "<", "(", "t0", "-", "width", ")", ")", "]", "=", "0", "\n", "x", "[", "np", ".", "where", "(", "t", ">", "(", "t0", "+", "width", ")", ")", "]", "=", "0", "\n", "amp_n", "=", "(", "0.1", "*", "randfunc", "(", ")", "+", "0.02", ")", "# add noise", "\n", "return", "x", "+", "amp_n", "*", "pinknoise", "(", "t", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.read_audio_file": [[207, 256], ["warnings.catch_warnings", "warnings.simplefilter", "isinstance", "librosa.core.load", "print", "audio.write_audio_file", "librosa.resample.astype", "numpy.max", "scipy.io.wavfile.read", "numpy.array", "int", "print", "librosa.resample", "print", "numpy.abs", "len", "print"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.write_audio_file"], ["", "def", "read_audio_file", "(", "filename", ",", "sr", "=", "44100", ",", "mono", "=", "True", ",", "norm", "=", "False", ",", "device", "=", "'cpu'", ",", "dtype", "=", "np", ".", "float32", ",", "warn", "=", "True", ",", "fix_and_overwrite", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Generic wrapper for reading an audio file.\n    Different libraries offer different speeds for this, so this routine is the\n    'catch-all' for whatever read routine happens to work best\n\n    Tries a fast method via scipy first, reverts to slower librosa when necessary.\n    \"\"\"", "\n", "# first try to read via scipy, because it's fast", "\n", "scipy_ok", "=", "False", "\n", "with", "warnings", ".", "catch_warnings", "(", "record", "=", "True", ")", "as", "w", ":", "\n", "        ", "warnings", ".", "simplefilter", "(", "\"error\"", ")", "# scipy throws warnings which should be errors", "\n", "try", ":", "\n", "            ", "read_sr", ",", "signal", "=", "wavfile", ".", "read", "(", "filename", ")", "\n", "scipy_ok", "=", "True", "\n", "", "except", "wavfile", ".", "WavFileWarning", ":", "\n", "            ", "if", "warn", ":", "\n", "                ", "print", "(", "\"read_audio_file: Warning raised by scipy. \"", ",", "end", "=", "\"\"", ")", "\n", "\n", "", "", "", "might_want_overwrite", "=", "False", "\n", "if", "scipy_ok", ":", "\n", "        ", "if", "mono", "and", "(", "len", "(", "signal", ".", "shape", ")", ">", "1", ")", ":", "# convert to mono", "\n", "            ", "signal", "=", "signal", "[", ":", ",", "0", "]", "\n", "\n", "", "if", "isinstance", "(", "signal", "[", "0", "]", ",", "np", ".", "int16", ")", ":", "# convert from ints to floats if necessary", "\n", "            ", "signal", "=", "np", ".", "array", "(", "signal", "/", "32767.0", ",", "dtype", "=", "dtype", ")", "# change from [-32767..32767] to [-1..1]", "\n", "\n", "", "if", "read_sr", "!=", "int", "(", "sr", ")", ":", "\n", "            ", "print", "(", "f\"read_audio_file: Got sample rate of {read_sr} Hz instead of {sr} Hz requested. Resampling.\"", ")", "\n", "signal", "=", "librosa", ".", "resample", "(", "signal", ",", "read_sr", "*", "1.0", ",", "sr", "*", "1.0", ",", "res_type", "=", "'kaiser_fast'", ")", "\n", "might_want_overwrite", "=", "True", "\n", "", "", "else", ":", "# try librosa; it's slower but general", "\n", "        ", "if", "warn", ":", "\n", "            ", "print", "(", "\"Trying librosa.\"", ")", "\n", "", "signal", ",", "read_sr", "=", "librosa", ".", "core", ".", "load", "(", "filename", ",", "mono", "=", "mono", ",", "sr", "=", "sr", ",", "res_type", "=", "'kaiser_fast'", ")", "\n", "might_want_overwrite", "=", "True", "\n", "\n", "", "if", "fix_and_overwrite", "and", "might_want_overwrite", ":", "\n", "        ", "print", "(", "f\"    Overwriting {filename} (so we don't have to use process as much again)\"", ")", "\n", "write_audio_file", "(", "filename", ",", "signal", ",", "sr", ")", "\n", "\n", "", "if", "signal", ".", "dtype", "!=", "dtype", ":", "\n", "        ", "signal", "=", "signal", ".", "astype", "(", "dtype", ",", "copy", "=", "False", ")", "\n", "\n", "", "if", "norm", ":", "\n", "        ", "absmax", "=", "np", ".", "max", "(", "np", ".", "abs", "(", "signal", ")", ")", "\n", "signal", "=", "signal", "/", "absmax", "if", "absmax", ">", "0", "else", "signal", "\n", "\n", "", "return", "signal", ",", "sr", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.write_audio_file": [[258, 263], ["scipy.io.wavfile.write"], "function", ["None"], ["", "def", "write_audio_file", "(", "filename", ",", "data", ",", "sr", "=", "44100", ")", ":", "\n", "    ", "wavfile", ".", "write", "(", "filename", ",", "sr", ",", "data", ")", "\n", "#librosa.output.write_wav(filename, data, sr)", "\n", "#torchaudio.save(filename, torch.Tensor(data).unsqueeze(1), sr)", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.readaudio_generator": [[264, 294], ["glob.glob", "os.path.expanduser", "isinstance", "numpy.random.choice", "audio.read_audio_file", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.read_audio_file"], ["", "def", "readaudio_generator", "(", "seq_size", ",", "path", "=", "os", ".", "path", ".", "expanduser", "(", "'~'", ")", "+", "'/datasets/signaltrain/Val'", ",", "sr", "=", "44100", ",", "\n", "random_every", "=", "True", ",", "mono", "=", "True", ",", "norm", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    reads audio from any number of audio files sitting in directory 'path'\n    supplies a window of length \"seconds\". If random_every=True, this window will be randomly chosen\n    \"\"\"", "\n", "# seq_size = amount of audio samples to supply from file", "\n", "# basepath = directory containing Train, Val, and Test directories", "\n", "# path = audio files for dataset  (can be Train, Val or test)", "\n", "# random_every = get a random window every time next is called, or step sequentially through file", "\n", "files", "=", "glob", ".", "glob", "(", "path", "+", "\"*.wav\"", ")", "\n", "read_new_file", "=", "True", "\n", "start", "=", "-", "seq_size", "\n", "while", "True", ":", "\n", "        ", "if", "read_new_file", ":", "\n", "            ", "filename", "=", "np", ".", "random", ".", "choice", "(", "files", ")", "# pick a random audio file in the directory", "\n", "#print(\"Reading new data from \"+filename+\" \")", "\n", "data", ",", "sr", "=", "read_audio_file", "(", "filename", ",", "sr", "=", "sr", ",", "mono", "=", "mono", ",", "norm", "=", "norm", ")", "\n", "read_new_file", "=", "False", "# don't keep switching files  everytime generator is called", "\n", "\n", "\n", "", "if", "(", "random_every", ")", ":", "# grab a random window of the signal", "\n", "            ", "start", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "data", ".", "shape", "[", "0", "]", "-", "seq_size", ")", "\n", "", "else", ":", "\n", "            ", "start", "+=", "seq_size", "\n", "", "xraw", "=", "data", "[", "start", ":", "start", "+", "seq_size", "]", "# the newaxis just gives us a [1,] on front", "\n", "# Note: any 'windowing' happens after the effects are applied, later", "\n", "rc", "=", "(", "yield", "xraw", ")", "# rc is set by generator's send() method.  YIELD here is the output", "\n", "if", "isinstance", "(", "rc", ",", "bool", ")", ":", "# can set read_new by calling send(True)", "\n", "            ", "read_new_file", "=", "rc", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.synth_input_sample": [[296, 335], ["numpy.random.randint", "audio.randsine", "numpy.random.choice", "numpy.random.rand", "audio.pluck", "len", "audio.randsine", "audio.triangle", "audio.pinknoise", "numpy.random.rand", "audio.box", "numpy.random.rand", "numpy.random.rand", "audio.spikes", "audio.box", "audio.pluck", "audio.ampexpstepup", "numpy.random.rand", "randfunc", "audio.pinknoise", "numpy.random.choice", "audio.sweep", "numpy.random.randint", "numpy.random.randint", "audio.box", "audio.pinknoise", "audio.pinknoise", "numpy.random.rand", "randfunc", "audio.synth_input_sample", "audio.synth_input_sample", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.randsine", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pluck", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.randsine", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.triangle", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pinknoise", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.box", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.spikes", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.box", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pluck", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.ampexpstepup", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pinknoise", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.sweep", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.box", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pinknoise", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.pinknoise", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.synth_input_sample", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.synth_input_sample"], ["", "", "", "def", "synth_input_sample", "(", "t", ",", "chooser", "=", "None", ",", "randfunc", "=", "np", ".", "random", ".", "rand", ",", "t0_fac", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Synthesizes one instance from various 'fake' audio wave forms -- synthetic data\n    \"\"\"", "\n", "if", "chooser", "is", "None", ":", "\n", "        ", "chooser", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "11", ")", "\n", "\n", "", "if", "0", "==", "chooser", ":", "# sine, with random phase, amp & freq", "\n", "        ", "y", "=", "randsine", "(", "t", ",", "t0_fac", "=", "t0_fac", ")", "\n", "", "elif", "1", "==", "chooser", ":", "# noisy sine", "\n", "        ", "y", "=", "randsine", "(", "t", ",", "t0_fac", "=", "t0_fac", ")", "+", "0.2", "*", "np", ".", "random", ".", "rand", "(", ")", "*", "pinknoise", "(", "t", ".", "shape", "[", "0", "]", ")", "+", "0.2", "*", "np", ".", "random", ".", "rand", "(", ")", "*", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "t", ".", "shape", "[", "0", "]", ")", "-", "1", ")", "\n", "", "elif", "2", "==", "chooser", ":", "#  \"pluck\", decaying sine wave", "\n", "        ", "y", "=", "pluck", "(", "t", ",", "t0_fac", "=", "t0_fac", ")", "\n", "", "elif", "3", "==", "chooser", ":", "# ramp up then down", "\n", "        ", "y", "=", "triangle", "(", "t", ",", "t0_fac", "=", "t0_fac", ")", "\n", "", "elif", "(", "4", "==", "chooser", ")", ":", "# 'box'", "\n", "        ", "y", "=", "box", "(", "t", ",", "t0_fac", "=", "t0_fac", ")", "\n", "", "elif", "5", "==", "chooser", ":", "# \"bunch of spikes\"", "\n", "        ", "y", "=", "spikes", "(", "t", ")", "\n", "", "elif", "6", "==", "chooser", ":", "# noisy box", "\n", "        ", "y", "=", "box", "(", "t", ",", "t0_fac", "=", "t0_fac", ")", "*", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "t", ".", "shape", "[", "0", "]", ")", "-", "1", ")", "# don't use pinknoise here", "\n", "", "elif", "7", "==", "chooser", ":", "# noisy 'pluck'", "\n", "        ", "amp_n", "=", "(", "0.3", "*", "randfunc", "(", ")", "+", "0.1", ")", "\n", "y", "=", "pluck", "(", "t", ",", "t0_fac", "=", "t0_fac", ")", "+", "amp_n", "*", "pinknoise", "(", "t", ".", "shape", "[", "0", "]", ")", "\n", "", "elif", "8", "==", "chooser", ":", "\n", "        ", "y", "=", "ampexpstepup", "(", "t", ",", "start_dB", "=", "-", "30", ")", "# increasing amplitude-steps of sine wave", "\n", "", "elif", "9", "==", "chooser", ":", "# freq sweep", "\n", "        ", "f_low", ",", "f_high", "=", "np", ".", "random", ".", "randint", "(", "20", ",", "1000", ")", ",", "np", ".", "random", ".", "randint", "(", "1000", ",", "20000", ")", "\n", "amp_too", "=", "np", ".", "random", ".", "choice", "(", "[", "False", ",", "False", ",", "True", "]", ")", "\n", "y", "=", "sweep", "(", "t", ",", "freq_range", "=", "[", "f_low", ",", "f_high", "]", ",", "amp_too", "=", "amp_too", ")", "\n", "", "elif", "10", "==", "chooser", ":", "# box plus noise", "\n", "        ", "y", "=", "box", "(", "t", ")", "+", "0.2", "*", "np", ".", "random", ".", "rand", "(", ")", "*", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "t", ".", "shape", "[", "0", "]", ")", "-", "1", ")", "+", "0.2", "*", "np", ".", "random", ".", "rand", "(", ")", "*", "pinknoise", "(", "t", ".", "shape", "[", "0", "]", ")", "\n", "", "elif", "11", "==", "chooser", ":", "# just noise", "\n", "        ", "amp_n", "=", "(", "0.6", "*", "randfunc", "(", ")", "+", "0.2", ")", "\n", "y", "=", "amp_n", "*", "pinknoise", "(", "t", ".", "shape", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "        ", "y", "=", "0.5", "*", "(", "synth_input_sample", "(", "t", ")", "+", "synth_input_sample", "(", "t", ")", ")", "# superposition of the above", "\n", "", "eps", "=", "1e-8", "\n", "return", "y", "*", "np", ".", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "+", "np", ".", "random", ".", "rand", "(", "len", "(", "y", ")", ")", "*", "eps", "# flip phase + tiny noise", "\n", "#---- End test signals", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.mu_compand": [[339, 341], ["numpy.log", "numpy.sign", "numpy.log", "numpy.abs"], "function", ["None"], ["", "def", "mu_compand", "(", "y", ",", "mu", "=", "32", ")", ":", "\n", "    ", "return", "np", ".", "sign", "(", "y", ")", "*", "np", ".", "log", "(", "1", "+", "mu", "*", "np", ".", "abs", "(", "y", ")", ")", "/", "np", ".", "log", "(", "1", "+", "mu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.mu_decompand": [[343, 345], ["numpy.sign", "numpy.abs"], "function", ["None"], ["", "def", "mu_decompand", "(", "y", ",", "mu", "=", "32", ")", ":", "\n", "    ", "return", "np", ".", "sign", "(", "y", ")", "/", "mu", "*", "(", "(", "1", "+", "mu", ")", "**", "np", ".", "abs", "(", "y", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.compressor": [[348, 372], ["scipy.butter", "scipy.lfilter_zi", "scipy.lfilter", "numpy.copy", "numpy.where", "numpy.power", "float", "numpy.log10", "numpy.abs"], "function", ["None"], ["", "@", "jit", "\n", "def", "compressor", "(", "x", ",", "thresh", "=", "-", "24", ",", "ratio", "=", "2", ",", "attackrel", "=", "0.045", ",", "sr", "=", "44100.0", ",", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "    ", "\"\"\"\n    simple compressor effect, code thanks to Eric Tarr @hackaudio\n    Inputs:\n       x:        the input waveform\n       thresh:   threshold in dB\n       ratio:    compression ratio\n       attackrel:   attack & release time in seconds\n       sr:       sample rate\n    \"\"\"", "\n", "attack", "=", "attackrel", "*", "sr", "# convert to samples", "\n", "fc", "=", "1.0", "/", "float", "(", "attack", ")", "# this is like 1/attack time", "\n", "b", ",", "a", "=", "scipy_signal", ".", "butter", "(", "1", ",", "fc", ",", "analog", "=", "False", ",", "output", "=", "'ba'", ")", "\n", "zi", "=", "scipy_signal", ".", "lfilter_zi", "(", "b", ",", "a", ")", "\n", "\n", "dB", "=", "20.", "*", "np", ".", "log10", "(", "np", ".", "abs", "(", "x", ")", "+", "1e-6", ")", "\n", "in_env", ",", "_", "=", "scipy_signal", ".", "lfilter", "(", "b", ",", "a", ",", "dB", ",", "zi", "=", "zi", "*", "dB", "[", "0", "]", ")", "# input envelope calculation", "\n", "out_env", "=", "np", ".", "copy", "(", "in_env", ")", "# output envelope", "\n", "i", "=", "np", ".", "where", "(", "in_env", ">", "thresh", ")", "# compress where input env exceeds thresh", "\n", "out_env", "[", "i", "]", "=", "thresh", "+", "(", "in_env", "[", "i", "]", "-", "thresh", ")", "/", "ratio", "\n", "gain", "=", "np", ".", "power", "(", "10.0", ",", "(", "out_env", "-", "in_env", ")", "/", "20", ")", "\n", "y", "=", "x", "*", "gain", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.my_clip_min": [[373, 379], ["numba.jit", "numpy.where"], "function", ["None"], ["", "@", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "my_clip_min", "(", "x", ",", "clip_min", ")", ":", "# does the work of np.clip(), which numba doesn't support yet", "\n", "# TODO: keep an eye on Numba PR https://github.com/numba/numba/pull/3468 that fixes this", "\n", "    ", "inds", "=", "np", ".", "where", "(", "x", "<", "clip_min", ")", "\n", "x", "[", "inds", "]", "=", "clip_min", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.compressor_4controls": [[380, 427], ["numba.jit", "len", "numpy.zeros", "numpy.zeros", "numpy.exp", "numpy.exp", "numpy.abs", "audio.my_clip_min", "numpy.zeros", "numpy.where", "range", "numpy.power", "numpy.log10", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.my_clip_min"], ["", "@", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "compressor_4controls", "(", "x", ",", "thresh", "=", "-", "24.0", ",", "ratio", "=", "2.0", ",", "attackTime", "=", "0.01", ",", "releaseTime", "=", "0.01", ",", "sr", "=", "44100.0", ")", ":", "\n", "    ", "\"\"\"\n    Thanks to Eric Tarr for MATLAB code for this, p. 428 of his Hack Audio book.  Used with permission.\n    Our mods for Python:\n        Minimized the for loop, removed dummy variables, and invoked numba @jit to make this \"fast\"\n    Inputs:\n      x: input signal\n      sr: sample rate in Hz\n      thresh: threhold in dB\n      ratio: ratio (should be >=1 , i.e. ratio:1)\n      attackTime, releaseTime: in seconds\n    \"\"\"", "\n", "N", "=", "len", "(", "x", ")", "\n", "dtype", "=", "x", ".", "dtype", "\n", "y", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "dtype", ")", "\n", "lin_A", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "dtype", ")", "# functions as gain", "\n", "\n", "# Initialize separate attack and release times", "\n", "alphaA", "=", "np", ".", "exp", "(", "-", "np", ".", "log", "(", "9", ")", "/", "(", "sr", "*", "attackTime", ")", ")", "#.astype(dtype,copy=False)  numba doesn't support astype", "\n", "alphaR", "=", "np", ".", "exp", "(", "-", "np", ".", "log", "(", "9", ")", "/", "(", "sr", "*", "releaseTime", ")", ")", "#.astype(dtype,copy=False)", "\n", "\n", "# Turn the input signal into a uni-polar signal on the dB scale", "\n", "x_uni", "=", "np", ".", "abs", "(", "x", ")", "\n", "x_dB", "=", "20", "*", "np", ".", "log10", "(", "x_uni", "+", "1e-8", ")", "# x_uni casts type", "\n", "\n", "# Ensure there are no values of negative infinity", "\n", "#x_dB = np.clip(x_dB, -96, None)   # Numba doesn't yet support np.clip but we can write our own", "\n", "x_dB", "=", "my_clip_min", "(", "x_dB", ",", "-", "96", ")", "\n", "\n", "# Static Characteristics", "\n", "gainChange_dB", "=", "np", ".", "zeros", "(", "x_dB", ".", "shape", "[", "0", "]", ",", "dtype", "=", "dtype", ")", "\n", "i", "=", "np", ".", "where", "(", "x_dB", ">", "thresh", ")", "\n", "gainChange_dB", "[", "i", "]", "=", "thresh", "+", "(", "x_dB", "[", "i", "]", "-", "thresh", ")", "/", "ratio", "-", "x_dB", "[", "i", "]", "# Perform Downwards Compression", "\n", "\n", "for", "n", "in", "range", "(", "1", ",", "N", ")", ":", "# this loop is slow but not vectorizable due to its cumulative, sequential nature. @autojit makes it fast(er).", "\n", "# smooth over the gainChange", "\n", "        ", "if", "gainChange_dB", "[", "n", "]", "<", "lin_A", "[", "n", "-", "1", "]", ":", "\n", "            ", "lin_A", "[", "n", "]", "=", "(", "(", "1", "-", "alphaA", ")", "*", "gainChange_dB", "[", "n", "]", ")", "+", "(", "alphaA", "*", "lin_A", "[", "n", "-", "1", "]", ")", "# attack mode", "\n", "", "else", ":", "\n", "            ", "lin_A", "[", "n", "]", "=", "(", "(", "1", "-", "alphaR", ")", "*", "gainChange_dB", "[", "n", "]", ")", "+", "(", "alphaR", "*", "lin_A", "[", "n", "-", "1", "]", ")", "# release", "\n", "\n", "", "", "lin_A", "=", "np", ".", "power", "(", "10.0", ",", "(", "lin_A", "/", "20", ")", ")", "# Convert to linear amplitude scalar; i.e. map from dB to amplitude", "\n", "\n", "y", "=", "lin_A", "*", "x", "# Apply linear amplitude to input sample", "\n", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.echo": [[430, 444], ["numpy.copy", "range", "int", "int", "numpy.round", "numpy.floor", "pow", "numpy.pad", "numpy.pad"], "function", ["None"], ["", "def", "echo", "(", "x", ",", "delay_samples", "=", "1487", ",", "ratio", "=", "0.6", ",", "echoes", "=", "1", ")", ":", "\n", "# ratio = redution ratio", "\n", "    ", "dtype", "=", "x", ".", "dtype", "\n", "y", "=", "np", ".", "copy", "(", "x", ")", "\n", "for", "i", "in", "range", "(", "int", "(", "np", ".", "round", "(", "echoes", ")", ")", ")", ":", "# note 'echoes' is a 'switch'; does not vary continuously", "\n", "        ", "ip1", "=", "i", "+", "1", "# literally \"i plus 1\"", "\n", "delay_length", "=", "ip1", "*", "delay_samples", "\n", "delay_length_int", "=", "int", "(", "np", ".", "floor", "(", "delay_length", ")", ")", "\n", "# the following is an attempt to make the delay continuously differentiable", "\n", "diff", "=", "delay_length", "-", "delay_length_int", "\n", "x_delayed", "=", "(", "(", "1", "-", "diff", ")", "*", "np", ".", "pad", "(", "x", ",", "(", "delay_length_int", ",", "0", ")", ",", "mode", "=", "'constant'", ")", "[", "0", ":", "-", "delay_length_int", "]", "#shift and pad with zeros", "\n", "+", "diff", "*", "np", ".", "pad", "(", "x", ",", "(", "delay_length_int", "+", "1", ",", "0", ")", ",", "mode", "=", "'constant'", ")", "[", "0", ":", "-", "(", "delay_length_int", "+", "1", ")", "]", ")", "\n", "y", "+=", "pow", "(", "ratio", ",", "ip1", ")", "*", "x_delayed", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.int2knobs": [[677, 713], ["range", "len", "knobs.append"], "function", ["None"], ["", "", "def", "int2knobs", "(", "idx", ":", "int", ",", "knob_ranges", ":", "list", ",", "settings_per", ":", "int", ")", "->", "list", ":", "\n", "  ", "\"\"\"\n  Maps a single (0-indexed) integer to a group of knob settings.\n  Useful for systematically covering a range of (linearly) equally-spaced knob\n  settings for dataset creation\n  NOTE: Operates in a \"little-endian\" format, i.e. last knob(/digit) varies most\n        rapidly as index changes\n  Inputs:\n     idx:  integer value to convert\n     knob_ranges: a list of 2-element lists consiting of [min,max] values for each knob\n          Ranges can be anything,\n     settings_per: Settings per knob, i.e. number of increments (assumes same inc for all knobs)\n\n  Examples:\n  print(int2knobs(12345, [[-0.5,0.5]]*4, 12))\n  [0.13636363636363635, -0.40909090909090906, 0.2272727272727273, 0.31818181818181823]\n\n  For rolling a set of 3 dice:\n  print( int2knobs(100, [[1,6]]*3, 6))\n  [3.0, 5.0, 5.0]\n\n  Simple base 10 aritmetic:\n  print(int2knobs(1234, [[0,9]]*4, 10))\n  [1.0, 2.0, 3.0, 4.0]\n  \"\"\"", "\n", "sp", ",", "nk", "=", "settings_per", ",", "len", "(", "knob_ranges", ")", "# mere abbreviations, nk=num_knobs", "\n", "assert", "idx", "<", "sp", "**", "nk", ",", "f\"idx ({idx}) must be less than max range of possible values ({sp**nk})\"", "\n", "knobs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "nk", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "# loop over knobs and multiples of sp", "\n", "    ", "sp_pow", "=", "sp", "**", "i", "\n", "setting", "=", "idx", "//", "sp_pow", "# which setting (of settings_per) for this knob", "\n", "ik", "=", "nk", "-", "1", "-", "i", "# because we're going in reverse order, we need to grab knob-ranges in reverse order", "\n", "dkval", "=", "(", "knob_ranges", "[", "ik", "]", "[", "1", "]", "-", "knob_ranges", "[", "ik", "]", "[", "0", "]", ")", "/", "(", "sp", "-", "1", ")", "# increment of knob value", "\n", "knobs", ".", "append", "(", "knob_ranges", "[", "ik", "]", "[", "0", "]", "+", "dkval", "*", "setting", ")", "# calc knob val and add to list", "\n", "idx", "-=", "setting", "*", "sp_pow", "# prepare to calc next \"digit\" in next loop", "\n", "", "return", "knobs", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.train.eval_status_save": [[28, 81], ["model.eval", "model.forward", "signaltrain.loss_functions.calc_loss", "open", "myfile.write", "open", "signaltrain.loss_functions.mae().item", "myfile.write", "print", "signaltrain.io_methods.plot_valdata", "signaltrain.io_methods.plot_spectrograms", "signaltrain.misc.save_checkpoint", "print", "x_val.to", "y_val.to", "knobs_val.to", "y_val_hat.float", "y_val_cuda.float", "mag_val_hat.float", "print", "time.time", "loss_functions.calc_loss.item", "time.time", "signaltrain.loss_functions.mae", "time.time", "y_val_hat.float", "y_val_cuda.float", "time.ctime"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.calc_loss", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.plot_valdata", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.plot_spectrograms", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.misc.save_checkpoint", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.mae"], ["", "def", "eval_status_save", "(", "model", ",", "effect", ",", "epoch", ",", "epochs", ",", "lr", ",", "mom", ",", "device", ",", "dataloader_val", ",", "logfilename", ",", "first_time", ",", "\n", "beta", ",", "vl_avg", ",", "out_checkpointname", ",", "parallel", ",", "optimizer", ",", "data_point", ",", "smoothed_loss", ",", "y_size", ",", "sr", ",", "status_every", ",", "\n", "plot_every", "=", "10", ",", "cp_every", "=", "25", ",", "scale_by_freq", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Status messages and run-time diagnostics.\n    Check Validation set, write files & give garious messages about how we're doing\n    Also does checkpointing\n\n    See train() below for variable meanings -- this all used to be in there.\n    \"\"\"", "\n", "# Validation phase", "\n", "model", ".", "eval", "(", ")", "\n", "val_batch_num", "=", "0", "\n", "for", "x_val", ",", "y_val", ",", "knobs_val", "in", "dataloader_val", ":", "\n", "        ", "val_batch_num", "+=", "1", "\n", "x_val_cuda", ",", "y_val_cuda", ",", "knobs_val_cuda", "=", "x_val", ".", "to", "(", "device", ")", ",", "y_val", ".", "to", "(", "device", ")", ",", "knobs_val", ".", "to", "(", "device", ")", "\n", "\n", "y_val_hat", ",", "mag_val", ",", "mag_val_hat", "=", "model", ".", "forward", "(", "x_val_cuda", ",", "knobs_val_cuda", ")", "\n", "loss_val", "=", "loss_functions", ".", "calc_loss", "(", "y_val_hat", ".", "float", "(", ")", ",", "y_val_cuda", ".", "float", "(", ")", ",", "mag_val_hat", ".", "float", "(", ")", ",", "\n", "scale_by_freq", "=", "scale_by_freq", ")", "#, l1_lambda=lr/1000 )", "\n", "vl_avg", "=", "beta", "*", "vl_avg", "+", "(", "1", "-", "beta", ")", "*", "loss_val", ".", "item", "(", ")", "# (running) average val loss", "\n", "if", "0", "==", "val_batch_num", "%", "status_every", ":", "\n", "            ", "timediff", "=", "time", ".", "time", "(", ")", "-", "first_time", "\n", "print", "(", "f\"\\repoch {epoch+1}/{epochs}, time: {timediff:.2f}: lr={lr:.2e},mom={mom:.3f} data_point {data_point}: loss: {smoothed_loss:.3e} val_loss: {vl_avg:.3e}   \"", ",", "end", "=", "\"\"", ")", "\n", "\n", "#  Write various forms of status output...", "\n", "", "", "with", "open", "(", "logfilename", ",", "\"a\"", ")", "as", "myfile", ":", "# save progress of val loss to text file", "\n", "        ", "myfile", ".", "write", "(", "f\"{epoch+1} {vl_avg:.3e}\\n\"", ")", "\n", "\n", "", "with", "open", "(", "\"val_err_mae.dat\"", ",", "\"a\"", ")", "as", "myfile", ":", "# different diagnostic: exclude L1 regularization and just give MAE", "\n", "        ", "val_mae", "=", "loss_functions", ".", "mae", "(", "y_val_hat", ".", "float", "(", ")", ",", "y_val_cuda", ".", "float", "(", ")", ")", ".", "item", "(", ")", "\n", "myfile", ".", "write", "(", "f\"{epoch+1} {val_mae:.3e}\\n\"", ")", "\n", "\n", "\n", "", "if", "(", "epoch", "+", "1", ")", "%", "plot_every", "==", "0", ":", "# plot sample val data", "\n", "        ", "print", "(", "\"\\nSaving sample data plots\"", ",", "end", "=", "\"\"", ")", "\n", "io_methods", ".", "plot_valdata", "(", "x_val_cuda", ",", "knobs_val_cuda", ",", "y_val_cuda", ",", "y_val_hat", ",", "effect", ",", "epoch", ",", "loss_val", ",", "target_size", "=", "y_size", ")", "\n", "\n", "", "if", "(", "(", "epoch", "+", "1", ")", "%", "20", "==", "0", ")", "or", "(", "epoch", "==", "epochs", "-", "1", ")", ":", "# write out spectrograms from time to time", "\n", "        ", "io_methods", ".", "plot_spectrograms", "(", "model", ",", "mag_val", ",", "mag_val_hat", ")", "\n", "\n", "# save checkpoint of model to file, which can be loaded later", "\n", "", "if", "(", "(", "epoch", "+", "1", ")", "%", "cp_every", "==", "0", ")", "or", "(", "epoch", "==", "epochs", "-", "1", ")", ":", "\n", "        ", "misc", ".", "save_checkpoint", "(", "out_checkpointname", ",", "model", ",", "epoch", ",", "parallel", ",", "optimizer", ",", "effect", ",", "sr", ")", "\n", "\n", "# time estimate (got tired of calcuting this by hand every time!)", "\n", "", "if", "(", "(", "epoch", "+", "1", ")", "==", "1", ")", ":", "\n", "        ", "secs_left", "=", "(", "time", ".", "time", "(", ")", "-", "first_time", ")", "*", "(", "epochs", "-", "1", ")", "\n", "future", "=", "time", ".", "time", "(", ")", "+", "secs_left", "\n", "hours", "=", "secs_left", "/", "3600.0", "\n", "print", "(", "f\"\\nExpect run to finish in roughly {hours:.1f} hours, on {time.ctime(future)}\"", ")", "\n", "\n", "", "return", "vl_avg", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.train.train_loop": [[84, 165], ["time.time", "range", "print", "print", "model.train", "train.eval_status_save", "model.forward", "signaltrain.loss_functions.calc_loss", "optimizer.zero_grad", "optimizer.step", "time.time", "x.to", "y.to", "knobs.to", "torch.exp().expand_as().float", "torch.exp().expand_as().float", "y_hat.float", "y_cuda.float", "mag_hat.float", "print", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "loss_functions.calc_loss.backward", "min", "min", "time.time", "amp.scale_loss", "scaled_loss.backward", "amp.master_params", "model.children", "hasattr", "mag_hat.size", "torch.exp().expand_as", "torch.exp().expand_as", "loss_functions.calc_loss.item", "hasattr", "model.clip_grad_norm_", "len", "len", "child.clip_grad_norm_", "torch.exp", "torch.exp", "torch.arange", "torch.arange", "mag_hat.size"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.train.train", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.train.eval_status_save", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.calc_loss", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.nn_proc.st_model.clip_grad_norm_"], ["", "def", "train_loop", "(", "model", ",", "effect", ",", "device", ",", "optimizer", ",", "epochs", ",", "batch_size", ",", "lr_sched", ",", "mom_sched", ",", "\n", "dataloader", ",", "dataloader_val", ",", "y_size", ",", "parallel", ",", "logfilename", ",", "out_checkpointname", ",", "\n", "plot_every", "=", "10", ",", "cp_every", "=", "25", ",", "sr", "=", "44100", ",", "lr_max", "=", "1e-4", ")", ":", "\n", "    ", "\"\"\"\n    The actual training loop called by train() below, after setup has occurred\n        See train() below for variable meanings -- this all used to be in there.\n    \"\"\"", "\n", "scale_by_freq", "=", "None", "# we change this below; but we need to know the size of mag_hat to set it, so wait", "\n", "\n", "# Loop over epochs", "\n", "iter_count", ",", "batch_num", ",", "status_every", "=", "0", ",", "0", ",", "10", "# some loop-related meta-variabled initializations", "\n", "avg_loss", ",", "vl_avg", ",", "beta", "=", "0.0", ",", "0.0", ",", "0.98", "# for reporting, average over last 50 iterations", "\n", "first_time", "=", "time", ".", "time", "(", ")", "# start the clock for logging purposes", "\n", "\n", "for", "epoch", "in", "range", "(", "epochs", ")", ":", "\n", "        ", "print", "(", "\"\"", ")", "\n", "data_point", "=", "0", "# within this epoch, count which 'data point' we're using (i.e. which audio sample is at the beginning of our batch)", "\n", "\n", "# Training phase", "\n", "model", ".", "train", "(", ")", "\n", "for", "x", ",", "y", ",", "knobs", "in", "dataloader", ":", "\n", "# move to GPU TODO: does DataLoader already do this?", "\n", "            ", "x_cuda", ",", "y_cuda", ",", "knobs_cuda", "=", "x", ".", "to", "(", "device", ")", ",", "y", ".", "to", "(", "device", ")", ",", "knobs", ".", "to", "(", "device", ")", "\n", "\n", "lr", "=", "lr_sched", "[", "min", "(", "iter_count", ",", "len", "(", "lr_sched", ")", "-", "1", ")", "]", "# get value for learning rate", "\n", "mom", "=", "mom_sched", "[", "min", "(", "iter_count", ",", "len", "(", "mom_sched", ")", "-", "1", ")", "]", "\n", "data_point", "+=", "batch_size", "\n", "\n", "y_hat", ",", "mag", ",", "mag_hat", "=", "model", ".", "forward", "(", "x_cuda", ",", "knobs_cuda", ")", "# feed-forward synthesis", "\n", "\n", "# set up loss weighting", "\n", "if", "scale_by_freq", "is", "None", ":", "\n", "                ", "expfac", "=", "7.", "/", "mag_hat", ".", "size", "(", ")", "[", "-", "1", "]", "# exponential L1 loss scaling by ~1000 times (30dB) over freq range", "\n", "scale_by_freq", "=", "torch", ".", "exp", "(", "expfac", "*", "torch", ".", "arange", "(", "0.", ",", "mag_hat", ".", "size", "(", ")", "[", "-", "1", "]", ")", ")", ".", "expand_as", "(", "mag_hat", ")", ".", "float", "(", ")", "\n", "\n", "# loss evaluation", "\n", "", "loss", "=", "loss_functions", ".", "calc_loss", "(", "y_hat", ".", "float", "(", ")", ",", "y_cuda", ".", "float", "(", ")", ",", "\n", "mag_hat", ".", "float", "(", ")", ",", "scale_by_freq", "=", "scale_by_freq", ")", "#, l1_lambda=lr/1000)", "\n", "\n", "# Status message", "\n", "batch_num", "+=", "1", "\n", "if", "0", "==", "batch_num", "%", "status_every", ":", "\n", "                ", "avg_loss", "=", "beta", "*", "avg_loss", "+", "(", "1", "-", "beta", ")", "*", "loss", ".", "item", "(", ")", "\n", "smoothed_loss", "=", "avg_loss", "/", "(", "1", "-", "beta", "**", "batch_num", ")", "\n", "timediff", "=", "time", ".", "time", "(", ")", "-", "first_time", "\n", "print", "(", "f\"\\repoch {epoch+1}/{epochs}, time: {timediff:.2f}: lr={lr:.2e},mom={mom:.3f}, data_point {data_point}: loss: {smoothed_loss:.3e}   \"", ",", "end", "=", "\"\"", ")", "\n", "\n", "# Optimization", "\n", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "if", "have_apex", ":", "\n", "                ", "with", "amp", ".", "scale_loss", "(", "loss", ",", "optimizer", ")", "as", "scaled_loss", ":", "\n", "                    ", "scaled_loss", ".", "backward", "(", ")", "\n", "", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "amp", ".", "master_params", "(", "optimizer", ")", ",", "max_norm", "=", "1.", ",", "norm_type", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "loss", ".", "backward", "(", ")", "# replace this with amp call", "\n", "# Clip model norm", "\n", "if", "parallel", ":", "\n", "                    ", "for", "child", "in", "model", ".", "children", "(", ")", ":", "# for DataParallel", "\n", "                        ", "if", "hasattr", "(", "child", ",", "'clip_grad_norm_'", ")", ":", "\n", "                            ", "child", ".", "clip_grad_norm_", "(", ")", "\n", "", "", "", "else", ":", "\n", "                    ", "if", "hasattr", "(", "model", ",", "'clip_grad_norm_'", ")", ":", "\n", "                        ", "model", ".", "clip_grad_norm_", "(", ")", "# for non-DataParallel", "\n", "", "", "", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Apply Learning rate scheduling", "\n", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "=", "lr", "# adjust according to schedule", "\n", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'momentum'", "]", "=", "mom", "\n", "iter_count", "+=", "1", "\n", "\n", "# Epoch finished", "\n", "\n", "", "vl_avg", "=", "eval_status_save", "(", "model", ",", "effect", ",", "epoch", ",", "epochs", ",", "lr", ",", "mom", ",", "device", ",", "dataloader_val", ",", "\n", "logfilename", ",", "first_time", ",", "beta", ",", "vl_avg", ",", "\n", "out_checkpointname", ",", "parallel", ",", "optimizer", ",", "data_point", ",", "smoothed_loss", ",", "y_size", ",", "sr", ",", "\n", "status_every", ",", "scale_by_freq", "=", "scale_by_freq", ")", "\n", "\n", "# end of loop over all epochs", "\n", "\n", "", "print", "(", "\"\\nTotal elapsed time for training loop =\"", ",", "time", ".", "time", "(", ")", "-", "first_time", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.train.train": [[167, 279], ["signaltrain.audio.Compressor_4c", "torch.device", "torch.device", "print", "print", "print", "len", "print", "effect.info", "signaltrain.misc.load_checkpoint", "signaltrain.nn_proc.st_model", "print", "print", "nn.DataParallel.to", "signaltrain.learningrate.get_1cycle_schedule", "len", "torch.optim.Adam", "torch.optim.Adam", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "train.train_loop", "len", "nn.DataParallel.load_state_dict", "sum", "list", "signaltrain.datasets.SynthAudioDataSet", "signaltrain.datasets.SynthAudioDataSet", "signaltrain.datasets.AudioFileDataSet", "signaltrain.datasets.AudioFileDataSet", "amp.initialize", "print", "print", "torch.DataParallel", "open", "myfile.close", "nn.DataParallel.parameters", "torch.cuda.device_count", "torch.cuda.device_count", "time.ctime", "p.numel", "nn.DataParallel.parameters"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.info", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.misc.load_checkpoint", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.learningrate.get_1cycle_schedule", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.train.train_loop", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["", "def", "train", "(", "effect", "=", "audio", ".", "Compressor_4c", "(", ")", ",", "epochs", "=", "100", ",", "n_data_points", "=", "200000", ",", "batch_size", "=", "20", ",", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", ")", ",", "plot_every", "=", "10", ",", "cp_every", "=", "25", ",", "sr", "=", "44100", ",", "datapath", "=", "None", ",", "\n", "scale_factor", "=", "1", ",", "shrink_factor", "=", "4", ",", "apex_opt", "=", "\"O0\"", ",", "target_type", "=", "\"stream\"", ",", "lr_max", "=", "1e-4", ",", "\n", "in_checkpointname", "=", "'modelcheckpoint.tar'", ",", "compand", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Main training routine for signaltrain\n\n    Parameters:\n        effect:           class for the audio effect to learn (see audio.py)\n        epochs:           how many epochs to run over\n        n_data_points:    data instances per epoch (or iterations per epoch)\n        batch_size:       batch size\n        device:           pytorch device to run on, either cpu or cuda (GPU)\n        plot_every:       how often to generate plots of sample outputs\n        cp_every:         save checkpoint every this many iterations\n        scale_factor:     change overal dimensionality of i/o chunks by this factor\n        shrink_factor:    output shrink factor, i.e. fraction of output actually trained on\n        apex_opt:         option for apex multi-precision training. default is \"O0\" which means none\n                          For Turing cards (e.g. RTX 2080 Ti), set this to \"O2\"\n        target_type:      \"chunk\" (re-run the effect for each chunk) or \"stream\" (apply effect to whole audio stream)\n        lr_max:           maximum learning rate\n        in_checkpointname:   filename of previous checkpoint to load from (if it exists)\n        compand:          whether to compand / decompand the audio\n    \"\"\"", "\n", "\n", "# print info about this training run", "\n", "print", "(", "f'SignalTrain training execution began at {time.ctime()}. Options:'", ")", "\n", "print", "(", "f'    epochs = {epochs}, n_data_points = {n_data_points}, batch_size = {batch_size}'", ")", "\n", "print", "(", "f'    scale_factor = {scale_factor}, shrink_factor = {shrink_factor}, apex_opt = {apex_opt}'", ")", "\n", "num_knobs", "=", "len", "(", "effect", ".", "knob_names", ")", "\n", "print", "(", "f'    num_knobs = {num_knobs}'", ")", "\n", "effect", ".", "info", "(", ")", "# Print effect settings", "\n", "\n", "# Setup the Model", "\n", "# check to see if there's a checkpoint", "\n", "state_dict", ",", "rv", "=", "misc", ".", "load_checkpoint", "(", "in_checkpointname", ",", "fatal", "=", "False", ")", "\n", "if", "state_dict", "!=", "{", "}", ":", "# load metadata from a checkpoint if it exists", "\n", "#model.load_state_dict(state_dict)", "\n", "        ", "scale_factor", ",", "shrink_factor", "=", "rv", "[", "'scale_factor'", "]", ",", "rv", "[", "'shrink_factor'", "]", "\n", "knob_names", ",", "knob_ranges", "=", "rv", "[", "'knob_names'", "]", ",", "rv", "[", "'knob_ranges'", "]", "\n", "model_num_knobs", "=", "len", "(", "knob_names", ")", "\n", "sr", "=", "rv", "[", "'sr'", "]", "\n", "chunk_size", ",", "out_chunk_size", "=", "rv", "[", "'in_chunk_size'", "]", ",", "rv", "[", "'out_chunk_size'", "]", "\n", "\n", "# initialize from scratch", "\n", "", "model", "=", "nn_proc", ".", "st_model", "(", "scale_factor", "=", "scale_factor", ",", "shrink_factor", "=", "shrink_factor", ",", "num_knobs", "=", "num_knobs", ",", "sr", "=", "sr", ")", "\n", "if", "state_dict", "!=", "{", "}", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "state_dict", ")", "# overwrite the weights using the input checkpoint if it exists", "\n", "", "chunk_size", ",", "out_chunk_size", "=", "model", ".", "in_chunk_size", ",", "model", ".", "out_chunk_size", "\n", "y_size", "=", "out_chunk_size", "\n", "\n", "print", "(", "\"Model defined.  Number of trainable parameters:\"", ",", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", ")", "\n", "print", "(", "\"      model.in_chunk_size, model.out_chunk_size = \"", ",", "model", ".", "in_chunk_size", ",", "model", ".", "out_chunk_size", ")", "\n", "model", ".", "to", "(", "device", ")", "\n", "\n", "# Specify learning rate schedule...although we don't bother stepping the momentum", "\n", "# Note: lr_max should be obtained by running lr_finder in learningrate.py", "\n", "lr_sched", ",", "mom_sched", "=", "learningrate", ".", "get_1cycle_schedule", "(", "lr_max", "=", "lr_max", ",", "n_data_points", "=", "n_data_points", ",", "epochs", "=", "epochs", ",", "batch_size", "=", "batch_size", ")", "\n", "maxiter", "=", "len", "(", "lr_sched", ")", "\n", "\n", "# Initialize optimizer. given our \"random\" training data, weight decay seem to doesn't help but rather slows training way down", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "list", "(", "model", ".", "parameters", "(", ")", ")", ",", "lr", "=", "lr_sched", "[", "0", "]", ",", "weight_decay", "=", "0", ")", "\n", "# TODO: should also set optimizer state from checkpoint", "\n", "\n", "\n", "# Setup/load data", "\n", "synth_data", "=", "datapath", "is", "None", "# Are we synthesizing data or do we expect it to come from files", "\n", "if", "synth_data", ":", "# synthesize input & target data", "\n", "        ", "dataset", "=", "datasets", ".", "SynthAudioDataSet", "(", "chunk_size", ",", "effect", ",", "sr", "=", "sr", ",", "datapoints", "=", "n_data_points", ",", "\n", "y_size", "=", "out_chunk_size", ",", "augment", "=", "True", ")", "\n", "dataset_val", "=", "datasets", ".", "SynthAudioDataSet", "(", "chunk_size", ",", "effect", ",", "sr", "=", "sr", ",", "datapoints", "=", "n_data_points", "//", "4", ",", "\n", "recycle", "=", "True", ",", "y_size", "=", "out_chunk_size", ",", "augment", "=", "False", ")", "\n", "", "else", ":", "# use prerecorded files for input & target data", "\n", "        ", "dataset", "=", "datasets", ".", "AudioFileDataSet", "(", "chunk_size", ",", "effect", ",", "sr", "=", "sr", ",", "datapoints", "=", "n_data_points", ",", "\n", "path", "=", "datapath", "+", "\"/Train/\"", ",", "y_size", "=", "out_chunk_size", ",", "rerun", "=", "(", "target_type", "!=", "\"stream\"", ")", ",", "augment", "=", "True", ",", "\n", "preload", "=", "True", ",", "compand", "=", "compand", ")", "\n", "dataset_val", "=", "datasets", ".", "AudioFileDataSet", "(", "chunk_size", ",", "effect", ",", "sr", "=", "sr", ",", "datapoints", "=", "n_data_points", "//", "4", ",", "\n", "path", "=", "datapath", "+", "\"/Val/\"", ",", "y_size", "=", "out_chunk_size", ",", "rerun", "=", "(", "target_type", "!=", "\"stream\"", ")", ",", "augment", "=", "False", ",", "\n", "compand", "=", "compand", ")", "\n", "\n", "", "dataloader", "=", "DataLoader", "(", "dataset", ",", "batch_size", "=", "batch_size", ",", "num_workers", "=", "10", ",", "shuffle", "=", "True", ",", "worker_init_fn", "=", "datasets", ".", "worker_init", ")", "# need worker_init for more variance", "\n", "dataloader_val", "=", "DataLoader", "(", "dataset_val", ",", "batch_size", "=", "batch_size", ",", "num_workers", "=", "10", ",", "shuffle", "=", "False", ")", "\n", "\n", "\n", "\n", "# Mixed precision:  Initialize NVIDIA Apex/Amp.  Amp accepts either values or strings for", "\n", "#     the optional override arguments, for convenient interoperation with argparse.", "\n", "if", "have_apex", ":", "\n", "        ", "model", ",", "optimizer", "=", "amp", ".", "initialize", "(", "model", ",", "optimizer", ",", "opt_level", "=", "apex_opt", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"*** WARNING: No APEX available.\"", ")", "\n", "\n", "# Copy model to (other) GPU if possbible", "\n", "", "parallel", "=", "False", "# SHH had trouble so am turning parallelism off.  #  torch.cuda.device_count() > 1", "\n", "if", "parallel", ":", "# For Hawley's 2 Titan X GPUs this typically cuts execution time down by ~30% (not 50%)", "\n", "        ", "print", "(", "\"Replicating NN model for data-parallel execution across\"", ",", "torch", ".", "cuda", ".", "device_count", "(", ")", ",", "\"GPUs\"", ")", "\n", "model", "=", "nn", ".", "DataParallel", "(", "model", ")", "\n", "\n", "# Set up for using additional L1 regularization - scale by frequency bin", "\n", "", "scale_by_freq", "=", "None", "# this gets changed later", "\n", "\n", "# Setup log file", "\n", "logfilename", "=", "\"vl_avg_out.dat\"", "# Val Loss, average, output", "\n", "with", "open", "(", "logfilename", ",", "\"a\"", ")", "as", "myfile", ":", "# save progress of val loss, append", "\n", "        ", "myfile", ".", "close", "(", ")", "\n", "\n", "# Now that everything's set up, call the training loop", "\n", "", "out_checkpointname", "=", "\"modelcheckpoint.tar\"", "\n", "train_loop", "(", "model", ",", "effect", ",", "device", ",", "optimizer", ",", "epochs", ",", "batch_size", ",", "lr_sched", ",", "mom_sched", ",", "dataloader", ",", "dataloader_val", ",", "\n", "y_size", ",", "parallel", ",", "logfilename", ",", "out_checkpointname", ",", "sr", "=", "sr", ",", "lr_max", "=", "lr_max", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Analysis.__init__": [[105, 121], ["torch.Module.__init__", "torch.Conv1d", "torch.Conv1d", "cls_fe_dct_bases.Analysis.initialize"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["def", "__init__", "(", "self", ",", "ft_size", "=", "1024", ",", "w_size", "=", "2048", ",", "hop_size", "=", "1024", ",", "shrink", "=", "False", ")", ":", "\n", "        ", "super", "(", "Analysis", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Parameters", "\n", "self", ".", "batch_size", "=", "None", "\n", "self", ".", "time_domain_samples", "=", "None", "\n", "self", ".", "sz", "=", "ft_size", "\n", "self", ".", "wsz", "=", "w_size", "\n", "self", ".", "hop", "=", "hop_size", "\n", "\n", "# Analysis 1D CNN", "\n", "self", ".", "conv_analysis", "=", "nn", ".", "Conv1d", "(", "1", ",", "self", ".", "sz", ",", "self", ".", "wsz", ",", "\n", "padding", "=", "self", ".", "sz", ",", "stride", "=", "self", ".", "hop", ",", "bias", "=", "True", ")", "\n", "\n", "# Custom Initialization with Fourier matrix", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Analysis.initialize": [[122, 128], ["cls_fe_dct_bases.core_modulation", "cls_fe_dct_bases.Analysis.conv_analysis.weight.data.copy_", "cls_fe_dct_bases.Analysis.conv_analysis.weight.data.copy_", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.core_modulation"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "fa_matrix", "=", "core_modulation", "(", "self", ".", "sz", ",", "self", ".", "wsz", ")", "\n", "if", "torch", ".", "has_cudnn", ":", "\n", "            ", "self", ".", "conv_analysis", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "fa_matrix", "[", ":", ",", "None", ",", ":", "]", ")", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv_analysis", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "fa_matrix", "[", ":", ",", "None", ",", ":", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Analysis.forward": [[129, 136], ["torch.autograd.Variable", "torch.autograd.Variable", "wave_form.view.view.size", "wave_form.view.view.size", "wave_form.view.view.view", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "cls_fe_dct_bases.Analysis.conv_analysis", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "wave_form", ")", ":", "\n", "        ", "wave_form", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "wave_form", ")", ".", "cuda", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "batch_size", "=", "wave_form", ".", "size", "(", "0", ")", "\n", "time_domain_samples", "=", "wave_form", ".", "size", "(", "1", ")", "\n", "wave_form", "=", "wave_form", ".", "view", "(", "batch_size", ",", "1", ",", "time_domain_samples", ")", "\n", "x_ft", "=", "torch", ".", "transpose", "(", "self", ".", "conv_analysis", "(", "wave_form", ")", ",", "2", ",", "1", ")", "\n", "return", "x_ft", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.__init__": [[144, 165], ["torch.Module.__init__", "int", "torch.ConvTranspose1d", "torch.ConvTranspose1d", "torch.nn.Hardtanh", "torch.nn.Hardtanh", "torch.nn.Hardtanh", "torch.nn.Hardtanh", "torch.nn.Tanh", "torch.nn.Tanh", "torch.nn.Tanh", "torch.nn.Tanh", "cls_fe_dct_bases.Synthesis.initialize"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize"], ["def", "__init__", "(", "self", ",", "ft_size", "=", "1024", ",", "w_size", "=", "2048", ",", "hop_size", "=", "1024", ")", ":", "\n", "        ", "super", "(", "Synthesis", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Parameters", "\n", "self", ".", "batch_size", "=", "None", "\n", "self", ".", "time_domain_samples", "=", "None", "\n", "self", ".", "sz", "=", "ft_size", "\n", "self", ".", "wsz", "=", "w_size", "\n", "self", ".", "hop", "=", "hop_size", "\n", "self", ".", "half_N", "=", "int", "(", "self", ".", "sz", "/", "2", "+", "1", ")", "\n", "\n", "# Synthesis 1D CNN", "\n", "self", ".", "conv_synthesis", "=", "nn", ".", "ConvTranspose1d", "(", "self", ".", "sz", ",", "1", ",", "self", ".", "wsz", ",", "\n", "padding", "=", "0", ",", "stride", "=", "self", ".", "hop", ",", "bias", "=", "False", ")", "\n", "\n", "# Activation functions", "\n", "self", ".", "h_tanh", "=", "torch", ".", "nn", ".", "Hardtanh", "(", ")", "\n", "self", ".", "tanh", "=", "torch", ".", "nn", ".", "Tanh", "(", ")", "\n", "\n", "# Custom Initialization with DCT-TypeIV matrix", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.initialize": [[166, 173], ["cls_fe_dct_bases.core_modulation", "cls_fe_dct_bases.Synthesis.conv_synthesis.weight.data.copy_", "cls_fe_dct_bases.Synthesis.conv_synthesis.weight.data.copy_", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.core_modulation"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "fs_matrix", "=", "core_modulation", "(", "self", ".", "sz", ",", "self", ".", "wsz", ")", "\n", "\n", "if", "torch", ".", "has_cudnn", ":", "\n", "            ", "self", ".", "conv_synthesis", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "fs_matrix", "[", ":", ",", "None", ",", ":", "]", ")", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv_synthesis", ".", "weight", ".", "data", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "fs_matrix", "[", ":", ",", "None", ",", ":", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward": [[174, 180], ["cls_fe_dct_bases.Synthesis.conv_synthesis", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x_ft", ")", ":", "\n", "        ", "wave_form", "=", "self", ".", "conv_synthesis", "(", "torch", ".", "transpose", "(", "x_ft", ",", "2", ",", "1", ")", ")", "\n", "wave_form", "=", "wave_form", "[", ":", ",", ":", ",", "self", ".", "sz", ":", "]", "\n", "wave_form", "=", "wave_form", "[", ":", ",", ":", ",", ":", "-", "self", ".", "sz", "]", "\n", "\n", "return", "wave_form", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.core_modulation": [[57, 98], ["scipy.signal.cosine", "orig_method.astype", "numpy.zeros", "xrange", "cls_fe_dct_bases.core_modulation.scott_method"], "function", ["None"], ["", "def", "core_modulation", "(", "freq_subbands", ",", "window_size", ")", ":", "\n", "    ", "\"\"\"\n        Method to produce Analysis and Synthesis matrices.\n        -https://github.com/Js-Mim/ASP/\n\n        Arguments              :\n            freq_subbands      :   (int) Number of subbands\n            window_size        :   (int) Window size\n        Returns                :\n            Cos                :   (2D Array) Cosine Modulated Polyphase Matrix\n    \"\"\"", "\n", "w", "=", "cosine", "(", "window_size", ")", "\n", "\n", "# just added the following profiling to compare the speed of the two methods", "\n", "#from profilehooks import profile", "\n", "#@profile", "\n", "def", "orig_method", "(", "freq_subbands", ",", "window_size", ",", "w", ")", ":", "\n", "# Initialize Storing Variables", "\n", "        ", "cos_an", "=", "np", ".", "zeros", "(", "(", "freq_subbands", ",", "window_size", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# Generate Matrices", "\n", "for", "k", "in", "xrange", "(", "0", ",", "freq_subbands", ")", ":", "\n", "            ", "for", "n", "in", "xrange", "(", "0", ",", "window_size", ")", ":", "\n", "                ", "cos_an", "[", "k", ",", "n", "]", "=", "w", "[", "n", "]", "*", "np", ".", "cos", "(", "np", ".", "pi", "/", "freq_subbands", "*", "(", "k", "+", "0.5", ")", "*", "\n", "(", "n", "+", "0.5", "+", "freq_subbands", "/", "2", ")", ")", "*", "np", ".", "sqrt", "(", "2.", "/", "freq_subbands", ")", "\n", "", "", "return", "cos_an", "\n", "\n", "#@profile", "\n", "", "def", "scott_method", "(", "freq_subbands", ",", "window_size", ",", "w", ")", ":", "\n", "# Generate Matrices", "\n", "        ", "kvec", "=", "np", ".", "arange", "(", "0", ",", "freq_subbands", ")", "+", "0.5", "\n", "nvec", "=", "np", ".", "arange", "(", "0", ",", "window_size", ")", "+", "0.5", "+", "freq_subbands", "/", "2", "\n", "cos_an", "=", "w", "*", "np", ".", "cos", "(", "np", ".", "pi", "/", "freq_subbands", "*", "kvec", "[", "np", ".", "newaxis", "]", ".", "T", "*", "nvec", ")", "*", "np", ".", "sqrt", "(", "2.", "/", "freq_subbands", ")", "\n", "return", "cos_an", "\n", "\n", "", "method", "=", "'scott'", "\n", "if", "(", "'scott'", "==", "method", ")", ":", "\n", "        ", "cos_an", "=", "scott_method", "(", "freq_subbands", ",", "window_size", ",", "w", ")", "\n", "", "else", ":", "\n", "        ", "cos_an", "=", "orig_method", "(", "freq_subbands", ",", "window_size", ",", "w", ")", "\n", "\n", "", "return", "cos_an", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.tied_transform": [[36, 55], ["torch.functional.conv_transpose2d", "nn.functional.conv_transpose2d.squeeze", "analysis.conv_analysis.weight.size", "torch.transpose().unsqueeze", "torch.transpose().unsqueeze", "analysis.conv_analysis.weight.unsqueeze", "torch.transpose", "torch.transpose"], "function", ["None"], ["", "def", "tied_transform", "(", "analysis", ",", "x_ft", ",", "hop", ")", ":", "\n", "    ", "\"\"\"\n        A method to compute an orthogonal transform for audio signals.\n        It will use the analysis weights to perform the reconstruction, via\n        transposed convolution.\n\n        Arguments              :\n            analysis           :   (object)         Pytorch module\n            x_ft               :   (Torch Tensor)   Tensor containing the transformed signal\n            hop                :   (int)            Hop-size\n        Returns                :\n            wave_from          :   (Torch Tensor)   Reconstructed waveform\n    \"\"\"", "\n", "\n", "sz", "=", "analysis", ".", "conv_analysis", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "wave_form", "=", "nn", ".", "functional", ".", "conv_transpose2d", "(", "torch", ".", "transpose", "(", "x_ft", ",", "2", ",", "1", ")", ".", "unsqueeze", "(", "3", ")", ",", "\n", "analysis", ".", "conv_analysis", ".", "weight", ".", "unsqueeze", "(", "3", ")", ",", "\n", "padding", "=", "(", "sz", ",", "0", ")", ",", "stride", "=", "(", "hop", ",", "1", ")", ")", "\n", "return", "wave_form", ".", "squeeze", "(", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.misc.print_choochoo": [[9, 19], ["print", "print", "print", "print", "print", "print", "print", "print"], "function", ["None"], ["def", "print_choochoo", "(", "__version__", ")", ":", "\n", "    ", "\"\"\"Just for fun. Makes a train picture.\"\"\"", "\n", "print", "(", "\" ~.~.~.~.      \"", ")", "\n", "print", "(", "\" ____    `.    \"", ")", "\n", "print", "(", "\" ]DD|_n_n_][   \"", ")", "\n", "print", "(", "\" |__|_______)  \"", ")", "\n", "print", "(", "\" 'oo OOOO oo\\_ \"", ")", "\n", "print", "(", "\"~+~+~+~+~+~+~+~\"", ")", "\n", "print", "(", "\"SignalTrain \"", "+", "__version__", ")", "\n", "print", "(", "\"\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.misc.save_checkpoint": [[21, 36], ["print", "model2save.state_dict", "torch.save", "optimizer.state_dict"], "function", ["None"], ["", "def", "save_checkpoint", "(", "checkpointname", ",", "model", ",", "epoch", ",", "parallel", ",", "optimizer", ",", "effect", ",", "sr", ")", ":", "\n", "    ", "\"\"\"\n    Saves a dictionary to a tar file. Package it with model state_dict and run parameters\n    \"\"\"", "\n", "print", "(", "f'\\nsaving model to {checkpointname}'", ",", "end", "=", "\"\"", ")", "\n", "model2save", "=", "model", ".", "module", "if", "parallel", "else", "model", "\n", "state_dict", "=", "model2save", ".", "state_dict", "(", ")", "\n", "state", "=", "{", "'epoch'", ":", "epoch", "+", "1", ",", "'state_dict'", ":", "state_dict", ",", "\n", "'optimizer'", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'effect_name'", ":", "effect", ".", "name", ",", "\n", "'knob_names'", ":", "effect", ".", "knob_names", ",", "'knob_ranges'", ":", "effect", ".", "knob_ranges", ",", "\n", "'scale_factor'", ":", "model2save", ".", "scale_factor", ",", "'shrink_factor'", ":", "model2save", ".", "shrink_factor", ",", "\n", "'in_chunk_size'", ":", "model2save", ".", "in_chunk_size", ",", "'out_chunk_size'", ":", "model2save", ".", "out_chunk_size", ",", "\n", "'sr'", ":", "sr", "}", "\n", "torch", ".", "save", "(", "state", ",", "checkpointname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.misc.load_checkpoint": [[38, 67], ["os.path.isfile", "print", "torch.load", "rv.setdefault", "rv.setdefault", "rv.setdefault", "rv.setdefault", "rv.setdefault", "rv.setdefault", "rv.setdefault", "torch.load.items", "numpy.array", "print", "sys.exit"], "function", ["None"], ["", "def", "load_checkpoint", "(", "checkpointname", ",", "fatal", "=", "False", ",", "device", "=", "\"cuda\"", ")", ":", "\n", "    ", "\"\"\"\n    load up the checkpoint if it exists\n    for backwards-compatibility: guess some common run parameters if they're not in the checkpoint\n    \"\"\"", "\n", "state_dict", ",", "rv", "=", "{", "}", ",", "{", "}", "# rv = run_values", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "checkpointname", ")", ":", "\n", "        ", "print", "(", "\"\\n***** Checkpoint file found. Loading weights.\"", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "checkpointname", ",", "map_location", "=", "device", ")", "\n", "state_dict", "=", "checkpoint", "[", "'state_dict'", "]", "\n", "\n", "# Guess some typical run values in case they're not in the checkpoint file", "\n", "rv", ".", "setdefault", "(", "'sr'", ",", "44100", ")", "\n", "rv", ".", "setdefault", "(", "'scale_factor'", ",", "1", ")", "\n", "rv", ".", "setdefault", "(", "'shrink_factor'", ",", "4", ")", "\n", "rv", ".", "setdefault", "(", "'in_chunk_size'", ",", "8192", ")", "\n", "rv", ".", "setdefault", "(", "'out_chunk_size'", ",", "2048", ")", "\n", "rv", ".", "setdefault", "(", "'knob_names'", ",", "[", "'thresh'", ",", "'ratio'", ",", "'attackTime'", ",", "'releaseTime'", "]", ")", "\n", "rv", ".", "setdefault", "(", "'knob_ranges'", ",", "np", ".", "array", "(", "[", "[", "-", "30", ",", "0", "]", ",", "[", "1", ",", "5", "]", ",", "[", "1e-3", ",", "4e-2", "]", ",", "[", "1e-3", ",", "4e-2", "]", "]", ")", ")", "\n", "\n", "for", "key", ",", "value", "in", "checkpoint", ".", "items", "(", ")", ":", "\n", "            ", "if", "'state_dict'", "not", "in", "key", ":", "# everything that's not state_dict becomes a run value", "\n", "                ", "rv", "[", "key", "]", "=", "value", "\n", "", "", "", "elif", "fatal", ":", "\n", "        ", "print", "(", "\"Error, no checkpoint found\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "return", "state_dict", ",", "rv", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.misc.print_model_params": [[69, 78], ["print", "model.children", "child.children", "childchild.children", "sum", "print", "p.numel", "ccc.parameters"], "function", ["None"], ["", "def", "print_model_params", "(", "model", ")", ":", "\n", "    ", "print", "(", "\"Printing model parameters\"", ")", "\n", "total_params", "=", "0", "\n", "for", "child", "in", "model", ".", "children", "(", ")", ":", "\n", "        ", "for", "childchild", "in", "child", ".", "children", "(", ")", ":", "\n", "            ", "for", "ccc", "in", "childchild", ".", "children", "(", ")", ":", "\n", "                ", "cpcount", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "ccc", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "total_params", "+=", "cpcount", "\n", "print", "(", "f\"    {child}: {cpcount} parameters.     Total params = {total_params}.\"", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.learningrate.get_1cycle_schedule": [[14, 53], ["int", "numpy.concatenate", "numpy.concatenate", "numpy.cos", "numpy.cos", "numpy.linspace", "numpy.linspace", "numpy.cos", "numpy.cos", "numpy.linspace", "numpy.linspace"], "function", ["None"], ["def", "get_1cycle_schedule", "(", "lr_max", "=", "1e-3", ",", "n_data_points", "=", "8000", ",", "epochs", "=", "200", ",", "\n", "batch_size", "=", "40", ")", ":", "\n", "  ", "\"\"\"\n  Creates a look-up table of learning rates for 1cycle schedule with cosine annealing\n\n  Keywork inputs:\n    lr_max            chosen by user after lr_finder\n    n_data_points     data points per epoch (e.g. size of training set)\n    epochs            number of epochs\n    batch_size        batch size\n\n  Output:\n    lrs               look-up table of LR's, with length equal to total # of iterations\n\n  Then you can use this in your PyTorch code by counting iteration number and setting\n          optimizer.param_groups[0]['lr'] = lrs[iter_count]\n  \"\"\"", "\n", "#pct_start, div_factor = 0.3, 25.        # @sgugger's parameters in fastai code", "\n", "pct_start", ",", "div_factor", "=", "0.3", ",", "15.", "# my attempt to train faster", "\n", "lr_start", "=", "lr_max", "/", "div_factor", "\n", "lr_end", "=", "lr_start", "/", "1e2", "\n", "n_iter", "=", "n_data_points", "*", "epochs", "//", "batch_size", "# number of iterations", "\n", "a1", "=", "int", "(", "n_iter", "*", "pct_start", ")", "# boundary between increasing and decreasing", "\n", "a2", "=", "n_iter", "-", "a1", "\n", "\n", "# make look-up table", "\n", "#lrs_first = np.linspace(lr_start, lr_max, a1)            # linear growth", "\n", "lrs_first", "=", "(", "lr_max", "-", "lr_start", ")", "*", "(", "1", "-", "np", ".", "cos", "(", "np", ".", "linspace", "(", "0", ",", "np", ".", "pi", ",", "a1", ")", ")", ")", "/", "2", "+", "lr_start", "# cosine growth", "\n", "lrs_second", "=", "(", "lr_max", "-", "lr_end", ")", "*", "(", "1", "+", "np", ".", "cos", "(", "np", ".", "linspace", "(", "0", ",", "np", ".", "pi", ",", "a2", ")", ")", ")", "/", "2", "+", "lr_end", "# cosine annealing", "\n", "lrs", "=", "np", ".", "concatenate", "(", "(", "lrs_first", ",", "lrs_second", ")", ")", "\n", "\n", "# also schedule the momentum", "\n", "mom_min", ",", "mom_max", "=", "0.85", ",", "0.95", "\n", "mom_avg", ",", "mom_amp", "=", "(", "mom_min", "+", "mom_max", ")", "/", "2", ",", "(", "mom_max", "-", "mom_min", ")", "/", "2", "\n", "mom_first", "=", "mom_avg", "+", "mom_amp", "*", "np", ".", "cos", "(", "np", ".", "linspace", "(", "0", ",", "np", ".", "pi", ",", "a1", ")", ")", "\n", "mom_second", "=", "mom_avg", "-", "mom_amp", "*", "np", ".", "cos", "(", "np", ".", "linspace", "(", "0", ",", "np", ".", "pi", ",", "a2", ")", ")", "\n", "moms", "=", "np", ".", "concatenate", "(", "(", "mom_first", ",", "mom_second", ")", ")", "\n", "\n", "return", "lrs", ",", "moms", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.logcosh": [[9, 11], ["torch.mean", "torch.log", "torch.cosh"], "function", ["None"], ["def", "logcosh", "(", "y_hat", ",", "y", ")", ":", "\n", "    ", "return", "torch", ".", "mean", "(", "torch", ".", "log", "(", "torch", ".", "cosh", "(", "y", "-", "y_hat", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.smoothl1": [[12, 16], ["torch.nn.SmoothL1Loss"], "function", ["None"], ["", "def", "smoothl1", "(", "x", ",", "x_hat", ",", "delta", "=", "0.5", ")", ":", "# Huber loss", "\n", "#return torch.sum ( torch.where(torch.abs(true-pred) < delta , 0.5*((true-pred)**2), \\", "\n", "#    delta*toch.abs(true - pred) - 0.5*(delta**2)) )", "\n", "    ", "return", "torch", ".", "nn", ".", "SmoothL1Loss", "(", "true", "-", "pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.mse": [[18, 20], ["torch.mean"], "function", ["None"], ["", "def", "mse", "(", "x", ",", "x_hat", ")", ":", "\n", "    ", "return", "torch", ".", "mean", "(", "(", "x", "-", "x_hat", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.mae": [[22, 24], ["torch.mean", "torch.abs"], "function", ["None"], ["", "def", "mae", "(", "x", ",", "x_hat", ")", ":", "\n", "    ", "return", "torch", ".", "mean", "(", "torch", ".", "abs", "(", "x", "-", "x_hat", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.calc_loss": [[26, 44], ["loss_functions.logcosh", "loss_functions.logcosh", "loss_functions.logcosh", "loss_functions.logcosh", "torch.abs().mean", "torch.abs().mean", "torch.mean", "torch.mean", "torch.log", "torch.abs", "torch.abs", "torch.cosh", "torch.log", "torch.cosh"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.logcosh", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.logcosh", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.logcosh", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.logcosh"], ["", "def", "calc_loss", "(", "y_hat", ",", "y_cuda", ",", "mag_hat", ",", "batch_size", "=", "20", ",", "scale_by_freq", "=", "None", ",", "l1_lambda", "=", "2e-5", ",", "reg_logcosh", "=", "False", ")", ":", "\n", "# Reconstruction term plus regularization -> Slightly less wiggly waveform", "\n", "\n", "#loss = logcosh(y_hat, y_cuda) + 1e-5*torch.abs(mag_hat).mean()", "\n", "# loss = logcosh(y_hat, y_cuda) + 2e-5*torch.abs(mag_hat).mean()", "\n", "#print(\"y_hat.dtype, y_cuda.dtype, mag_hat.dtype, scale_by_freq.dtype =\",y_hat.dtype, y_cuda.dtype, mag_hat.dtype, scale_by_freq.dtype)", "\n", "    ", "if", "not", "reg_logcosh", ":", "\n", "        ", "if", "scale_by_freq", "is", "None", ":", "\n", "            ", "loss", "=", "logcosh", "(", "y_hat", ",", "y_cuda", ")", "+", "l1_lambda", "*", "torch", ".", "abs", "(", "mag_hat", ")", ".", "mean", "(", ")", "# second term is an L1 regularization to help 'damp' high-freq noise", "\n", "", "else", ":", "\n", "            ", "loss", "=", "logcosh", "(", "y_hat", ",", "y_cuda", ")", "+", "l1_lambda", "/", "10", "*", "torch", ".", "abs", "(", "mag_hat", "*", "scale_by_freq", ")", ".", "mean", "(", ")", "# second term is an L1 regularization to help 'damp' high-freq noise", "\n", "", "", "else", ":", "\n", "        ", "if", "scale_by_freq", "is", "None", ":", "\n", "            ", "loss", "=", "logcosh", "(", "y_hat", ",", "y_cuda", ")", "+", "l1_lambda", "*", "torch", ".", "mean", "(", "torch", ".", "log", "(", "torch", ".", "cosh", "(", "mag_hat", ")", ")", ")", "# second term is an L1 regularization to help 'damp' high-freq noise", "\n", "", "else", ":", "\n", "            ", "loss", "=", "logcosh", "(", "y_hat", ",", "y_cuda", ")", "+", "l1_lambda", "/", "10", "*", "torch", ".", "mean", "(", "scale_by_freq", "*", "torch", ".", "log", "(", "torch", ".", "cosh", "(", "mag_hat", ")", ")", ")", "# second term is an L1 regularization to help 'damp' high-freq noise", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.__init__": [[56, 58], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "\t\t", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.audioRead": [[59, 167], ["os.path.abspath", "print", "os.path.join", "subprocess.call", "io_methods.AudioIO.wavRead", "os.remove", "Exception", "os.path.abspath", "print", "os.path.join", "subprocess.call", "io_methods.AudioIO.wavRead", "os.remove", "os.path.abspath", "print", "os.path.join", "subprocess.call", "io_methods.AudioIO.wavRead", "os.remove", "os.path.abspath", "print", "os.path.join", "subprocess.call", "io_methods.AudioIO.wavRead", "os.remove", "os.path.abspath", "print", "os.path.join", "subprocess.call", "io_methods.AudioIO.wavRead", "os.remove", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.abspath", "print", "os.path.join", "subprocess.call", "io_methods.AudioIO.wavRead", "os.remove", "Exception", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavRead", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavRead", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavRead", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavRead", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavRead", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavRead"], ["", "@", "staticmethod", "\n", "def", "audioRead", "(", "fileName", ",", "mono", "=", "False", ")", ":", "\n", "\t\t", "\"\"\" Function to load audio files such as *.mp3, *.au, *.wma, *.m4a, *.x-wav & *.aiff.\n\t\t\tIt first converts them to .wav and reads them with the methods below.\n\t\t\tCurrently, it uses a static build of ffmpeg.\n\n        Args:\n            fileName:       (str)       Absolute filename of WAV file\n            mono:           (bool)      Switch if samples should be converted to mono\n        Returns:\n            samples:        (np array)  Audio samples (between [-1,1]\n                                        (if stereo: numSamples x numChannels,\n                                        if mono: numSamples)\n            sampleRate:     (float):    Sampling frequency [Hz]\n        \"\"\"", "\n", "\n", "# Get the absolute path", "\n", "fileName", "=", "os", ".", "path", ".", "abspath", "(", "fileName", ")", "\n", "\n", "# Linux", "\n", "if", "(", "platform", "==", "\"linux\"", ")", "or", "(", "platform", "==", "\"linux2\"", ")", ":", "\n", "\t\t\t", "convDict", "=", "{", "\n", "'m4a'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "3", "]", ",", "\n", "'mp3'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "3", "]", ",", "\n", "'au'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "2", "]", ",", "\n", "'wma'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "3", "]", ",", "\n", "'aiff'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "4", "]", ",", "\n", "'wav'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "3", "]", "\n", "}", "\n", "\n", "# MacOSX", "\n", "", "elif", "(", "platform", "==", "\"darwin\"", ")", ":", "\n", "\t\t\t", "convDict", "=", "{", "\n", "'m4a'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "3", "]", ",", "\n", "'mp3'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "3", "]", ",", "\n", "'au'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "2", "]", ",", "\n", "'wma'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "3", "]", ",", "\n", "'aiff'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "4", "]", ",", "\n", "'wav'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "\n", "+", "' -i '", "+", "fileName", "+", "' '", ",", "-", "3", "]", "\n", "}", "\n", "# Add windows support!", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'This OS is not supported.'", ")", "\n", "\n", "# Construct", "\n", "", "if", "fileName", "[", "convDict", "[", "'mp3'", "]", "[", "1", "]", ":", "]", "==", "'mp3'", ":", "\n", "\t\t\t", "print", "(", "fileName", "[", "convDict", "[", "'mp3'", "]", "[", "1", "]", ":", "]", ")", "\n", "modfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "fileName", "[", ":", "convDict", "[", "'mp3'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'mp3'", "]", "[", "0", "]", "+", "modfileName", ",", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "samples", ",", "sampleRate", "=", "AudioIO", ".", "wavRead", "(", "modfileName", ",", "mono", ")", "\n", "os", ".", "remove", "(", "modfileName", ")", "\n", "\n", "", "elif", "fileName", "[", "convDict", "[", "'au'", "]", "[", "1", "]", ":", "]", "==", "'au'", ":", "\n", "\t\t\t", "print", "(", "fileName", "[", "convDict", "[", "'au'", "]", "[", "1", "]", ":", "]", ")", "\n", "modfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "fileName", "[", ":", "convDict", "[", "'au'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'au'", "]", "[", "0", "]", "+", "modfileName", ",", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "samples", ",", "sampleRate", "=", "AudioIO", ".", "wavRead", "(", "modfileName", ",", "mono", ")", "\n", "os", ".", "remove", "(", "modfileName", ")", "\n", "\n", "", "elif", "fileName", "[", "convDict", "[", "'wma'", "]", "[", "1", "]", ":", "]", "==", "'wma'", ":", "\n", "\t\t\t", "print", "(", "fileName", "[", "convDict", "[", "'wma'", "]", "[", "1", "]", ":", "]", ")", "\n", "modfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "fileName", "[", ":", "convDict", "[", "'wma'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'wma'", "]", "[", "0", "]", "+", "modfileName", ",", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "samples", ",", "sampleRate", "=", "AudioIO", ".", "wavRead", "(", "modfileName", ",", "mono", ")", "\n", "os", ".", "remove", "(", "modfileName", ")", "\n", "\n", "", "elif", "fileName", "[", "convDict", "[", "'aiff'", "]", "[", "1", "]", ":", "]", "==", "'aiff'", ":", "\n", "\t\t\t", "print", "(", "fileName", "[", "convDict", "[", "'aiff'", "]", "[", "1", "]", ":", "]", ")", "\n", "modfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "fileName", "[", ":", "convDict", "[", "'aiff'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'aiff'", "]", "[", "0", "]", "+", "modfileName", ",", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "samples", ",", "sampleRate", "=", "AudioIO", ".", "wavRead", "(", "modfileName", ",", "mono", ")", "\n", "os", ".", "remove", "(", "modfileName", ")", "\n", "\n", "", "elif", "fileName", "[", "convDict", "[", "'wav'", "]", "[", "1", "]", ":", "]", "==", "'wav'", ":", "\n", "\t\t\t", "\"\"\"\n\t\t\t\tGeneral purpose reading of wav files that do not contain the RIFF header.\n\t\t\t\"\"\"", "\n", "print", "(", "'x-wav'", ")", "\n", "modfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "fileName", "[", ":", "-", "4", "]", "+", "'_temp.wav'", ")", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'wav'", "]", "[", "0", "]", "+", "modfileName", ",", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "\n", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "samples", ",", "sampleRate", "=", "AudioIO", ".", "wavRead", "(", "modfileName", ",", "mono", ")", "\n", "os", ".", "remove", "(", "modfileName", ")", "\n", "\n", "", "elif", "fileName", "[", "convDict", "[", "'m4a'", "]", "[", "1", "]", ":", "]", "==", "'m4a'", ":", "\n", "\t\t\t", "print", "(", "fileName", "[", "convDict", "[", "'m4a'", "]", "[", "1", "]", ":", "]", ")", "\n", "modfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "fileName", "[", ":", "-", "4", "]", "+", "'_temp.wav'", ")", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'m4a'", "]", "[", "0", "]", "+", "modfileName", ",", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "\n", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "samples", ",", "sampleRate", "=", "AudioIO", ".", "wavRead", "(", "modfileName", ",", "mono", ")", "\n", "os", ".", "remove", "(", "modfileName", ")", "\n", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'This format is not supported.'", ")", "\n", "\n", "", "return", "samples", ",", "sampleRate", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.audioWrite": [[168, 251], ["os.path.join", "io_methods.AudioIO.wavWrite", "subprocess.call", "os.remove", "Exception", "os.path.abspath", "io_methods.AudioIO.wavWrite", "os.path.join", "io_methods.AudioIO.wavWrite", "subprocess.call", "os.remove", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.abspath", "os.path.join", "io_methods.AudioIO.wavWrite", "subprocess.call", "os.remove", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.abspath", "os.path.join", "io_methods.AudioIO.wavWrite", "subprocess.call", "os.remove", "os.path.abspath", "os.path.join", "io_methods.AudioIO.wavWrite", "subprocess.call", "os.remove", "Exception", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavWrite", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavWrite", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavWrite", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavWrite", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavWrite", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavWrite"], ["", "@", "staticmethod", "\n", "def", "audioWrite", "(", "y", ",", "fs", ",", "nbits", ",", "audioFile", ",", "format", ")", ":", "\n", "\t\t", "\"\"\" Write samples to WAV file and then converts to selected\n\t\tformat using ffmpeg.\n        Args:\n            samples: \t(ndarray / 2D ndarray) (floating point) sample vector\n                    \t\tmono:   DIM: nSamples\n                    \t\tstereo: DIM: nSamples x nChannels\n\n            fs: \t\t(int) Sample rate in Hz\n            nBits: \t\t(int) Number of bits\n            audioFile: \t(string) File name to write\n            format:\t\t(string) Selected format\n            \t\t\t\t'mp3' \t: Writes to .mp3\n            \t\t\t\t'wma' \t: Writes to .wma\n            \t\t\t\t'wav' \t: Writes to .wav\n            \t\t\t\t'aiff'\t: Writes to .aiff\n            \t\t\t\t'au'\t: Writes to .au\n            \t\t\t\t'm4a'   : Writes to .m4a\n\t\t\"\"\"", "\n", "\n", "# Linux", "\n", "if", "(", "platform", "==", "\"linux\"", ")", "or", "(", "platform", "==", "\"linux2\"", ")", ":", "\n", "\t\t\t", "convDict", "=", "{", "\n", "'m4a'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "+", "' -i '", ",", "-", "3", "]", ",", "\n", "'mp3'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "+", "' -i '", ",", "-", "3", "]", ",", "\n", "'au'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "+", "' -i '", ",", "-", "2", "]", ",", "\n", "'wma'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "+", "' -i '", ",", "-", "3", "]", ",", "\n", "'aiff'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_linux'", ")", "+", "' -i '", ",", "-", "4", "]", "\n", "}", "\n", "\n", "# MacOSX", "\n", "", "elif", "(", "platform", "==", "\"darwin\"", ")", ":", "\n", "\t\t\t", "convDict", "=", "{", "\n", "'m4a'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "+", "' -i '", ",", "-", "3", "]", ",", "\n", "'mp3'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "+", "' -i '", ",", "-", "3", "]", ",", "\n", "'au'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "+", "' -i '", ",", "-", "2", "]", ",", "\n", "'wma'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "+", "' -i '", ",", "-", "3", "]", ",", "\n", "'aiff'", ":", "[", "os", ".", "path", ".", "join", "(", "AudioIO", ".", "pathToffmpeg", ",", "'ffmpeg_osx'", ")", "+", "' -i '", ",", "-", "4", "]", "\n", "}", "\n", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'This OS is not supported.'", ")", "\n", "\n", "", "if", "(", "format", "==", "'mp3'", ")", ":", "\n", "\t\t\t", "prmfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "audioFile", "[", ":", "convDict", "[", "'mp3'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "AudioIO", ".", "wavWrite", "(", "y", ",", "fs", ",", "nbits", ",", "prmfileName", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'mp3'", "]", "[", "0", "]", "+", "prmfileName", "+", "' '", "+", "audioFile", ",", "\n", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "os", ".", "remove", "(", "prmfileName", ")", "\n", "\n", "", "elif", "(", "format", "==", "'wav'", ")", ":", "\n", "\t\t\t", "AudioIO", ".", "wavWrite", "(", "y", ",", "fs", ",", "nbits", ",", "audioFile", ")", "\n", "\n", "", "elif", "(", "format", "==", "'wma'", ")", ":", "\n", "\t\t\t", "prmfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "audioFile", "[", ":", "convDict", "[", "'wma'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "AudioIO", ".", "wavWrite", "(", "y", ",", "fs", ",", "nbits", ",", "prmfileName", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'wma'", "]", "[", "0", "]", "+", "prmfileName", "+", "' '", "+", "audioFile", ",", "\n", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "os", ".", "remove", "(", "prmfileName", ")", "\n", "\n", "", "elif", "(", "format", "==", "'aiff'", ")", ":", "\n", "\t\t\t", "prmfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "audioFile", "[", ":", "convDict", "[", "'aiff'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "AudioIO", ".", "wavWrite", "(", "y", ",", "fs", ",", "nbits", ",", "prmfileName", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'aiff'", "]", "[", "0", "]", "+", "prmfileName", "+", "' '", "+", "audioFile", ",", "\n", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "os", ".", "remove", "(", "prmfileName", ")", "\n", "\n", "", "elif", "(", "format", "==", "'au'", ")", ":", "\n", "\t\t\t", "prmfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "audioFile", "[", ":", "convDict", "[", "'au'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "AudioIO", ".", "wavWrite", "(", "y", ",", "fs", ",", "nbits", ",", "prmfileName", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'au'", "]", "[", "0", "]", "+", "prmfileName", "+", "' '", "+", "audioFile", ",", "\n", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "os", ".", "remove", "(", "prmfileName", ")", "\n", "\n", "", "elif", "(", "format", "==", "'m4a'", ")", ":", "\n", "\t\t\t", "prmfileName", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "audioFile", "[", ":", "convDict", "[", "'m4a'", "]", "[", "1", "]", "]", "+", "'wav'", ")", ")", "\n", "AudioIO", ".", "wavWrite", "(", "y", ",", "fs", ",", "nbits", ",", "prmfileName", ")", "\n", "subprocess", ".", "call", "(", "convDict", "[", "'m4a'", "]", "[", "0", "]", "+", "prmfileName", "+", "' -b:a 320k '", "+", "audioFile", ",", "\n", "shell", "=", "True", ",", "stdout", "=", "AudioIO", ".", "FNULL", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "\n", "os", ".", "remove", "(", "prmfileName", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'This format is not supported.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavRead": [[252, 287], ["io_methods.AudioIO._loadWAVWithWave", "wave.open().getsampwidth", "io_methods.AudioIO._loadWAVWithScipy", "wave.open", "samples.astype", "samples.astype", "samples.astype"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO._loadWAVWithWave", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO._loadWAVWithScipy"], ["", "", "@", "staticmethod", "\n", "def", "wavRead", "(", "fileName", ",", "mono", "=", "False", ")", ":", "\n", "\t\t", "\"\"\" Function to load WAV file.\n\n        Args:\n            fileName:       (str)       Absolute filename of WAV file\n            mono:           (bool)      Switch if samples should be converted to mono\n        Returns:\n            samples:        (np array)  Audio samples (between [-1,1]\n                                        (if stereo: numSamples x numChannels,\n                                        if mono: numSamples)\n            sampleRate:     (float):    Sampling frequency [Hz]\n        \"\"\"", "\n", "try", ":", "\n", "\t\t\t", "samples", ",", "sampleRate", "=", "AudioIO", ".", "_loadWAVWithWave", "(", "fileName", ")", "\n", "sWidth", "=", "_wave", ".", "open", "(", "fileName", ")", ".", "getsampwidth", "(", ")", "\n", "if", "sWidth", "==", "1", ":", "\n", "#print('8bit case')", "\n", "\t\t\t\t", "samples", "=", "samples", ".", "astype", "(", "float", ",", "copy", "=", "False", ")", "/", "AudioIO", ".", "normFact", "[", "'int8'", "]", "-", "1.0", "\n", "", "elif", "sWidth", "==", "2", ":", "\n", "#print('16bit case')", "\n", "\t\t\t\t", "samples", "=", "samples", ".", "astype", "(", "float", ",", "copy", "=", "False", ")", "/", "AudioIO", ".", "normFact", "[", "'int16'", "]", "\n", "", "elif", "sWidth", "==", "3", ":", "\n", "#print('24bit case')", "\n", "\t\t\t\t", "samples", "=", "samples", ".", "astype", "(", "float", ",", "copy", "=", "False", ")", "/", "AudioIO", ".", "normFact", "[", "'int24'", "]", "\n", "", "", "except", ":", "\n", "#print('32bit case')", "\n", "\t\t\t", "samples", ",", "sampleRate", "=", "AudioIO", ".", "_loadWAVWithScipy", "(", "fileName", ")", "\n", "\n", "# mono conversion", "\n", "", "if", "mono", ":", "\n", "\t\t\t", "if", "samples", ".", "ndim", "==", "2", "and", "samples", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "\t\t\t\t", "samples", "=", "(", "samples", "[", ":", ",", "0", "]", "+", "samples", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "\n", "", "", "return", "samples", ",", "sampleRate", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO._loadWAVWithWave": [[288, 301], ["wave.open", "wave.open.getframerate", "wave.open.getnchannels", "wave.open.getsampwidth", "wave.open.getnframes", "wave.open.readframes", "wave.open.close", "io_methods.AudioIO._wav2array"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO._wav2array"], ["", "@", "staticmethod", "\n", "def", "_loadWAVWithWave", "(", "fileName", ")", ":", "\n", "\t\t", "\"\"\" Load samples & sample rate from 24 bit WAV file \"\"\"", "\n", "wav", "=", "_wave", ".", "open", "(", "fileName", ")", "\n", "rate", "=", "wav", ".", "getframerate", "(", ")", "\n", "nchannels", "=", "wav", ".", "getnchannels", "(", ")", "\n", "sampwidth", "=", "wav", ".", "getsampwidth", "(", ")", "\n", "nframes", "=", "wav", ".", "getnframes", "(", ")", "\n", "data", "=", "wav", ".", "readframes", "(", "nframes", ")", "\n", "wav", ".", "close", "(", ")", "\n", "array", "=", "AudioIO", ".", "_wav2array", "(", "nchannels", ",", "sampwidth", ",", "data", ")", "\n", "\n", "return", "array", ",", "rate", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO._loadWAVWithScipy": [[302, 310], ["scipy.io.wavfile.read"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_loadWAVWithScipy", "(", "fileName", ")", ":", "\n", "\t\t", "\"\"\" Load samples & sample rate from WAV file \"\"\"", "\n", "inputData", "=", "read", "(", "fileName", ")", "\n", "samples", "=", "inputData", "[", "1", "]", "\n", "sampleRate", "=", "inputData", "[", "0", "]", "\n", "\n", "return", "samples", ",", "sampleRate", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO._wav2array": [[311, 333], ["divmod", "len", "ValueError", "ValueError", "numpy.empty", "numpy.fromstring", "numpy.fromstring.reshape", "numpy.fromstring.view().reshape", "numpy.fromstring", "numpy.fromstring.reshape", "numpy.fromstring.view"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_wav2array", "(", "nchannels", ",", "sampwidth", ",", "data", ")", ":", "\n", "\t\t", "\"\"\"data must be the string containing the bytes from the wav file.\"\"\"", "\n", "num_samples", ",", "remainder", "=", "divmod", "(", "len", "(", "data", ")", ",", "sampwidth", "*", "nchannels", ")", "\n", "if", "remainder", ">", "0", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'The length of data is not a multiple of '", "\n", "'sampwidth * num_channels.'", ")", "\n", "", "if", "sampwidth", ">", "4", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"sampwidth must not be greater than 4.\"", ")", "\n", "\n", "", "if", "sampwidth", "==", "3", ":", "\n", "\t\t\t", "a", "=", "np", ".", "empty", "(", "(", "num_samples", ",", "nchannels", ",", "4", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "raw_bytes", "=", "np", ".", "fromstring", "(", "data", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "a", "[", ":", ",", ":", ",", ":", "sampwidth", "]", "=", "raw_bytes", ".", "reshape", "(", "-", "1", ",", "nchannels", ",", "sampwidth", ")", "\n", "a", "[", ":", ",", ":", ",", "sampwidth", ":", "]", "=", "(", "a", "[", ":", ",", ":", ",", "sampwidth", "-", "1", ":", "sampwidth", "]", ">>", "7", ")", "*", "255", "\n", "result", "=", "a", ".", "view", "(", "'<i4'", ")", ".", "reshape", "(", "a", ".", "shape", "[", ":", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "# 8 bit samples are stored as unsigned ints; others as signed ints.", "\n", "\t\t\t", "dt_char", "=", "'u'", "if", "sampwidth", "==", "1", "else", "'i'", "\n", "a", "=", "np", ".", "fromstring", "(", "data", ",", "dtype", "=", "'<%s%d'", "%", "(", "dt_char", ",", "sampwidth", ")", ")", "\n", "result", "=", "a", ".", "reshape", "(", "-", "1", ",", "nchannels", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavWrite": [[334, 356], ["scipy.io.wavfile.write", "numpy.int8", "numpy.int16", "str", "str"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "wavWrite", "(", "y", ",", "fs", ",", "nbits", ",", "audioFile", ")", ":", "\n", "\t\t", "\"\"\" Write samples to WAV file\n        Args:\n            samples: (ndarray / 2D ndarray) (floating point) sample vector\n                    \tmono: DIM: nSamples\n                    \tstereo: DIM: nSamples x nChannels\n\n            fs: \t(int) Sample rate in Hz\n            nBits: \t(int) Number of bits\n            fnWAV: \t(string) WAV file name to write\n\t\t\"\"\"", "\n", "if", "nbits", "==", "8", ":", "\n", "\t\t\t", "intsamples", "=", "(", "y", "+", "1.0", ")", "*", "AudioIO", ".", "normFact", "[", "'int'", "+", "str", "(", "nbits", ")", "]", "\n", "fX", "=", "np", ".", "int8", "(", "intsamples", ")", "\n", "", "elif", "nbits", "==", "16", ":", "\n", "\t\t\t", "intsamples", "=", "y", "*", "AudioIO", ".", "normFact", "[", "'int'", "+", "str", "(", "nbits", ")", "]", "\n", "fX", "=", "np", ".", "int16", "(", "intsamples", ")", "\n", "", "elif", "nbits", ">", "16", ":", "\n", "\t\t\t", "fX", "=", "y", "\n", "\n", "", "write", "(", "audioFile", ",", "fs", ",", "fX", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.sound": [[357, 383], ["io_methods.AudioIO.wavWrite", "pg.media.Player", "pg.media.load", "pg.media.Player.queue", "pg.media.Player.play", "raw_input", "os.remove", "io_methods.AudioIO.stop"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.wavWrite", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.stop"], ["", "@", "staticmethod", "\n", "def", "sound", "(", "x", ",", "fs", ")", ":", "\n", "\t\t", "\"\"\" Plays a wave file using the pyglet library. But first, it has to be written.\n\t\t\tTermination of the playback is being performed by any keyboard input and Enter.\n\t\t\tArgs:\n\t\t\tx: \t\t   (array) Floating point samples\n\t\t\tfs:\t\t   (int) The sampling rate\n\t\t\"\"\"", "\n", "import", "pyglet", "as", "pg", "\n", "global", "player", "\n", "# Call the writing function", "\n", "AudioIO", ".", "wavWrite", "(", "x", ",", "fs", ",", "16", ",", "'testPlayback.wav'", ")", "\n", "# Initialize playback engine", "\n", "player", "=", "pg", ".", "media", ".", "Player", "(", ")", "\n", "# Initialize the object with the audio file", "\n", "playback", "=", "pg", ".", "media", ".", "load", "(", "'testPlayback.wav'", ")", "\n", "# Set it to player", "\n", "player", ".", "queue", "(", "playback", ")", "\n", "# Sound call", "\n", "player", ".", "play", "(", ")", "\n", "# Killed by \"keyboard\"", "\n", "kill", "=", "raw_input", "(", ")", "\n", "if", "kill", "or", "kill", "==", "''", ":", "\n", "\t\t\t", "AudioIO", ".", "stop", "(", ")", "\n", "# Remove the dummy wave write", "\n", "", "os", ".", "remove", "(", "'testPlayback.wav'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.AudioIO.stop": [[384, 395], ["player.pause"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "stop", "(", ")", ":", "\n", "\t\t", "\"\"\" Stops a playback object of the pyglet library.\n\t\t\tIt does not accept arguments, but a player has to be\n\t\t\talready initialized by the above \"sound\" method.\n\t\t\"\"\"", "\n", "global", "player", "\n", "# Just Pause & Destruct", "\n", "player", ".", "pause", "(", ")", "\n", "player", "=", "None", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.makemovie": [[399, 422], ["print", "print", "datagen_movie.new", "numpy.linspace", "call", "numpy.linspace", "numpy.linspace", "print", "numpy.array", "datagen_movie.new", "model.forward", "calc_loss", "print", "io_methods.plot_valdata"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.cls_fe_dct_bases.Synthesis.forward", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.loss_functions.calc_loss", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.plot_valdata"], ["", "", "def", "makemovie", "(", "datagen", ",", "model", ",", "batch_size", ")", ":", "\n", "    ", "print", "(", "\"\\n\\nMaking movies\"", ")", "\n", "for", "sig_type", "in", "[", "0", ",", "4", "]", ":", "\n", "        ", "print", "(", ")", "\n", "x_val_cuda2", ",", "y_val_cuda2", ",", "knobs_val_cuda2", "=", "datagen_movie", ".", "new", "(", "chooser", "=", "sig_type", ")", "\n", "frame", "=", "0", "\n", "intervals", "=", "7", "\n", "for", "t", "in", "np", ".", "linspace", "(", "-", "0.5", ",", "0.5", ",", "intervals", ")", ":", "# threshold", "\n", "            ", "for", "r", "in", "np", ".", "linspace", "(", "-", "0.5", ",", "0.5", ",", "intervals", ")", ":", "# ratio", "\n", "                ", "for", "a", "in", "np", ".", "linspace", "(", "-", "0.5", ",", "0.5", ",", "intervals", ")", ":", "# attack", "\n", "                    ", "frame", "+=", "1", "\n", "print", "(", "f'\\rframe = {frame}/{intervals**3-1}.   '", ",", "end", "=", "\"\"", ")", "\n", "knobs", "=", "np", ".", "array", "(", "[", "t", ",", "r", ",", "a", "]", ")", "\n", "x_val_cuda2", ",", "y_val_cuda2", ",", "knobs_val_cuda2", "=", "datagen_movie", ".", "new", "(", "knobs", "=", "knobs", ",", "recyc_x", "=", "True", ",", "chooser", "=", "sig_type", ")", "\n", "x_val_hat2", ",", "mag_val2", ",", "mag_val_hat2", "=", "model", ".", "forward", "(", "x_val_cuda2", ",", "knobs_val_cuda2", ")", "\n", "loss_val2", "=", "calc_loss", "(", "x_val_hat2", ",", "y_val_cuda2", ",", "mag_val2", ",", "objective", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "framename", "=", "f'movie{sig_type}_{frame:04}.png'", "\n", "print", "(", "f'Saving {framename}           '", ",", "end", "=", "\"\"", ")", "\n", "plot_valdata", "(", "x_val_cuda2", ",", "knobs_val_cuda2", ",", "y_val_cuda2", ",", "x_val_hat2", ",", "knob_ranges", ",", "epoch", ",", "loss_val", ",", "filename", "=", "framename", ")", "\n", "", "", "", "shellcmd", "=", "f'rm -f movie{sig_type}.mp4; ffmpeg -framerate 10 -i movie{sig_type}_%04d.png -c:v libx264 -vf format=yuv420p movie{sig_type}.mp4; rm -f movie{sig_type}_*.png'", "\n", "p", "=", "call", "(", "shellcmd", ",", "stdout", "=", "PIPE", ",", "shell", "=", "True", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig": [[424, 427], ["matplotlib.savefig", "matplotlib.close", "matplotlib.gcf"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig"], ["", "def", "savefig", "(", "*", "args", ",", "**", "kwargs", ")", ":", "# little helper to close figures", "\n", "    ", "plt", ".", "savefig", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "plt", ".", "close", "(", "plt", ".", "gcf", "(", ")", ")", "# without this you eventually get 'too many figures open' message", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.plot_valdata": [[429, 468], ["len", "range", "range", "len", "x_val_cuda.data.cpu().numpy", "effect.knobs_wc", "matplotlib.figure", "range", "matplotlib.suptitle", "matplotlib.subplot", "matplotlib.plot", "matplotlib.ylim", "matplotlib.xlim", "matplotlib.legend", "matplotlib.subplot", "y_val_cuda.data.cpu().numpy", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.legend", "matplotlib.subplot", "matplotlib.plot", "y_val_hat_cuda.data.cpu().numpy", "matplotlib.plot", "matplotlib.ylim", "matplotlib.xlim", "matplotlib.legend", "io_methods.savefig", "x_val_cuda.data.cpu().numpy", "len", "y_val_cuda.data.cpu().numpy", "x_val_cuda.data.cpu", "knobs_val_cuda.data.cpu().numpy", "loss_val.item", "y_val_cuda.data.cpu", "y_val_hat_cuda.data.cpu", "str", "x_val_cuda.data.cpu", "len", "y_val_cuda.data.cpu", "knobs_val_cuda.data.cpu"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.knobs_wc", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig"], ["", "def", "plot_valdata", "(", "x_val_cuda", ",", "knobs_val_cuda", ",", "y_val_cuda", ",", "y_val_hat_cuda", ",", "effect", ",", "epoch", ",", "loss_val", ",", "file_prefix", "=", "'val_data'", ",", "num_plots", "=", "50", ",", "target_size", "=", "None", ")", ":", "\n", "\n", "\t", "x_size", "=", "len", "(", "x_val_cuda", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", "\n", "if", "target_size", "is", "None", ":", "\n", "\t\t", "y_size", "=", "len", "(", "y_val_cuda", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "\t\t", "y_size", "=", "target_size", "\n", "", "t_small", "=", "range", "(", "x_size", "-", "y_size", ",", "x_size", ")", "\n", "for", "plot_i", "in", "range", "(", "0", ",", "num_plots", ")", ":", "\n", "\t\t", "x_val", "=", "x_val_cuda", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "knobs_w", "=", "effect", ".", "knobs_wc", "(", "knobs_val_cuda", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "plot_i", ",", ":", "]", ")", "\n", "plt", ".", "figure", "(", "plot_i", ",", "figsize", "=", "(", "6", ",", "8", ")", ")", "\n", "titlestr", "=", "f'{effect.name} Val data, epoch {epoch+1}, loss_val = {loss_val.item():.3e}\\n'", "\n", "for", "i", "in", "range", "(", "len", "(", "effect", ".", "knob_names", ")", ")", ":", "\n", "\t\t    ", "titlestr", "+=", "f'{effect.knob_names[i]} = {knobs_w[i]:.2f}'", "\n", "if", "i", "<", "len", "(", "effect", ".", "knob_names", ")", "-", "1", ":", "titlestr", "+=", "', '", "\n", "", "plt", ".", "suptitle", "(", "titlestr", ")", "\n", "plt", ".", "subplot", "(", "3", ",", "1", ",", "1", ")", "\n", "plt", ".", "plot", "(", "x_val", "[", "plot_i", ",", ":", "]", ",", "'b'", ",", "label", "=", "'Input'", ")", "\n", "plt", ".", "ylim", "(", "-", "1", ",", "1", ")", "\n", "plt", ".", "xlim", "(", "0", ",", "x_size", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "subplot", "(", "3", ",", "1", ",", "2", ")", "\n", "y_val", "=", "y_val_cuda", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "plt", ".", "plot", "(", "t_small", ",", "y_val", "[", "plot_i", ",", "-", "y_size", ":", "]", ",", "'r'", ",", "label", "=", "'Target'", ")", "\n", "plt", ".", "xlim", "(", "0", ",", "x_size", ")", "\n", "plt", ".", "ylim", "(", "-", "1", ",", "1", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "subplot", "(", "3", ",", "1", ",", "3", ")", "\n", "plt", ".", "plot", "(", "t_small", ",", "y_val", "[", "plot_i", ",", "-", "y_size", ":", "]", ",", "'r'", ",", "label", "=", "'Target'", ")", "\n", "y_val_hat", "=", "y_val_hat_cuda", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "plt", ".", "plot", "(", "t_small", ",", "y_val_hat", "[", "plot_i", ",", "-", "y_size", ":", "]", ",", "c", "=", "(", "0", ",", "0.5", ",", "0", ",", "0.85", ")", ",", "label", "=", "'Predicted'", ")", "\n", "plt", ".", "ylim", "(", "-", "1", ",", "1", ")", "\n", "plt", ".", "xlim", "(", "0", ",", "x_size", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "filename", "=", "file_prefix", "+", "'_'", "+", "str", "(", "plot_i", ")", "+", "'.png'", "\n", "savefig", "(", "filename", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.plot_spectrograms": [[470, 498], ["matplotlib.figure", "matplotlib.imshow", "matplotlib.title", "io_methods.savefig", "matplotlib.figure", "matplotlib.imshow", "matplotlib.title", "io_methods.savefig", "matplotlib.matshow", "matplotlib.title", "io_methods.savefig", "matplotlib.matshow", "matplotlib.title", "io_methods.savefig", "matplotlib.matshow", "matplotlib.title", "io_methods.savefig", "matplotlib.matshow", "matplotlib.title", "io_methods.savefig", "model.mpaec.dft_analysis.conv_analysis_imag.weight.data.cpu().numpy().astype", "model.mpaec.dft_synthesis.conv_synthesis_real.weight.data.cpu().numpy().astype", "model.mpaec.dft_synthesis.conv_synthesis_imag.weight.data.cpu().numpy().astype", "mag_val.data.cpu().numpy", "mag_val_hat.data.cpu().numpy", "model.mpaec.dft_analysis.conv_analysis_real.weight.data.cpu().numpy().astype", "model.mpaec.dft_analysis.conv_analysis_imag.weight.data.cpu().numpy", "model.mpaec.dft_synthesis.conv_synthesis_real.weight.data.cpu().numpy", "model.mpaec.dft_synthesis.conv_synthesis_imag.weight.data.cpu().numpy", "mag_val.data.cpu", "mag_val_hat.data.cpu", "model.mpaec.dft_analysis.conv_analysis_real.weight.data.cpu().numpy", "model.mpaec.dft_analysis.conv_analysis_imag.weight.data.cpu", "model.mpaec.dft_synthesis.conv_synthesis_real.weight.data.cpu", "model.mpaec.dft_synthesis.conv_synthesis_imag.weight.data.cpu", "model.mpaec.dft_analysis.conv_analysis_real.weight.data.cpu"], "function", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.io_methods.savefig"], ["", "def", "plot_spectrograms", "(", "model", ",", "mag_val", ",", "mag_val_hat", ")", ":", "\n", "\t", "'''\n\tRoutine for plotting magnitude and phase spectorgrams\n\t'''", "\n", "plt", ".", "figure", "(", "1", ")", "\n", "plt", ".", "imshow", "(", "mag_val", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", ",", ":", ",", ":", "]", ".", "T", ",", "aspect", "=", "'auto'", ",", "origin", "=", "'lower'", ")", "\n", "plt", ".", "title", "(", "'Initial magnitude'", ")", "\n", "savefig", "(", "'mag.png'", ")", "\n", "plt", ".", "figure", "(", "2", ")", "# <---- Check this out! Some \"sub-harmonic\" content is generated for the compressor if the analysis weights make only small perturbations", "\n", "plt", ".", "imshow", "(", "mag_val_hat", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", ",", ":", ",", ":", "]", ".", "T", ",", "aspect", "=", "'auto'", ",", "origin", "=", "'lower'", ")", "\n", "plt", ".", "title", "(", "'Processed magnitude'", ")", "\n", "savefig", "(", "'mag_hat.png'", ")", "\n", "\n", "#if isinstance(model, nn_proc.AsymMPAEC):     # Plot the spectrograms", "\n", "plt", ".", "matshow", "(", "model", ".", "mpaec", ".", "dft_analysis", ".", "conv_analysis_real", ".", "weight", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", "[", ":", ",", "0", ",", ":", "]", "+", "1", ")", "\n", "plt", ".", "title", "(", "'Conv-Analysis Real'", ")", "\n", "savefig", "(", "'conv_anal_real.png'", ")", "\n", "plt", ".", "matshow", "(", "model", ".", "mpaec", ".", "dft_analysis", ".", "conv_analysis_imag", ".", "weight", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "plt", ".", "title", "(", "'Conv-Analysis Imag'", ")", "\n", "savefig", "(", "'conv_anal_imag.png'", ")", "\n", "plt", ".", "matshow", "(", "model", ".", "mpaec", ".", "dft_synthesis", ".", "conv_synthesis_real", ".", "weight", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "plt", ".", "title", "(", "'Conv-Synthesis Real'", ")", "\n", "savefig", "(", "'conv_synth_real.png'", ")", "\n", "plt", ".", "matshow", "(", "model", ".", "mpaec", ".", "dft_synthesis", ".", "conv_synthesis_imag", ".", "weight", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "plt", ".", "title", "(", "'Conv-Synthesis Imag'", ")", "\n", "savefig", "(", "'conv_synth_imag.png'", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.__init__": [[69, 122], ["torch.utils.data.Dataset.__init__", "print", "sorted", "sorted", "print", "print", "range", "print", "glob.glob", "glob.glob", "len", "len", "len", "len", "min", "print", "datasets.AudioFileDataSet.preload_audio", "len", "os.path.basename", "os.path.basename"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.preload_audio"], ["def", "__init__", "(", "self", ",", "chunk_size", ",", "effect", ",", "sr", "=", "44100", ",", "path", "=", "\"./Train/\"", ",", "datapoints", "=", "8000", ",", "dtype", "=", "np", ".", "float32", ",", "preload", "=", "True", ",", "rerun", "=", "False", ",", "y_size", "=", "None", ",", "augment", "=", "True", ",", "\n", "align_end", "=", "True", ",", "view_of", "=", "None", ",", "compand", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        view_of: as a memory-saving experiment, pass another dataset.\n        \"\"\"", "\n", "super", "(", "AudioFileDataSet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "chunk_size", "=", "chunk_size", "\n", "self", ".", "effect", "=", "effect", "# The only reason we still need the effect defined (even though we're reading files) is to get the RANGES for the knobs", "\n", "self", ".", "sr", "=", "sr", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "dtype", "=", "dtype", "\n", "self", ".", "datapoints", "=", "datapoints", "\n", "self", ".", "preload", "=", "preload", "\n", "self", ".", "align_end", "=", "align_end", "# found that some of our audio files have starting points that are not aligned, but their einding points are.", "\n", "self", ".", "rerun_effect", "=", "rerun", "# a hack to avoid causality issues at chunk boundaries", "\n", "self", ".", "compand", "=", "compand", "\n", "if", "y_size", "is", "None", ":", "\n", "            ", "self", ".", "y_size", "=", "chunk_size", "\n", "", "else", ":", "\n", "            ", "self", ".", "y_size", "=", "y_size", "\n", "", "self", ".", "augment", "=", "augment", "# data augmentation: randomly invert phase", "\n", "self", ".", "processed_dir", "=", "''", "\n", "self", ".", "num_knobs", "=", "0", "\n", "'''\n        # Loading raw audio files (\".wav\") is incredibly slow. Much fast to preprocess and save in another format\n        check_preproc = False\n        if check_preproc:\n            self.processed_dir = 'processed_audio/'\n            self.process_audio()\n        '''", "\n", "\n", "if", "view_of", "is", "None", ":", "\n", "            ", "print", "(", "\"view_of = None. Original data\"", ")", "\n", "# get a list of available files.  Note that knob settings are included to the target filenames", "\n", "self", ".", "input_filenames", "=", "sorted", "(", "glob", ".", "glob", "(", "self", ".", "processed_dir", "+", "self", ".", "path", "+", "'/'", "+", "'input_*'", ")", ")", "\n", "self", ".", "target_filenames", "=", "sorted", "(", "glob", ".", "glob", "(", "self", ".", "processed_dir", "+", "self", ".", "path", "+", "'/'", "+", "'target_*'", ")", ")", "\n", "print", "(", "\"AudioFileDataSet: Found\"", ",", "len", "(", "self", ".", "input_filenames", ")", ",", "\"input files and\"", ",", "\n", "len", "(", "self", ".", "target_filenames", ")", ",", "\" target files in path\"", ",", "self", ".", "path", ")", "\n", "assert", "len", "(", "self", ".", "input_filenames", ")", "==", "len", "(", "self", ".", "target_filenames", ")", "# TODO: One can imagine a scheme with multiple targets per input", "\n", "\n", "print", "(", "\"  AudioFileDataSet: Check to make sure input & target filenames sorted together in the same order:\"", ")", "\n", "for", "i", "in", "range", "(", "min", "(", "10", ",", "len", "(", "self", ".", "input_filenames", ")", ")", ")", ":", "\n", "                ", "print", "(", "\"      i =\"", ",", "i", ",", "\", input_filename =\"", ",", "os", ".", "path", ".", "basename", "(", "self", ".", "input_filenames", "[", "i", "]", ")", ",", "\", target_filename =\"", ",", "os", ".", "path", ".", "basename", "(", "self", ".", "target_filenames", "[", "i", "]", ")", ")", "\n", "\n", "", "if", "self", ".", "preload", ":", "# load data files into memory first", "\n", "                ", "self", ".", "preload_audio", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "\" *** Warning, using only a view of earlier dataset\"", ")", "\n", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "knobs", "=", "view_of", ".", "x", ",", "view_of", ".", "y", ",", "view_of", ".", "knobs", "\n", "self", ".", "num_knobs", "=", "view_of", ".", "num_knobs", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.preload_audio": [[124, 161], ["print", "min", "datasets.AudioFileDataSet.read_one_new_file_pair", "len", "numpy.zeros", "range", "print", "len", "len", "datasets.AudioFileDataSet.read_one_new_file_pair", "datasets.AudioFileDataSet.x.append", "datasets.AudioFileDataSet.y.append", "print", "len", "len", "print", "len", "len", "min", "print", "print", "print", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.read_one_new_file_pair", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.read_one_new_file_pair"], ["", "", "def", "preload_audio", "(", "self", ")", ":", "\n", "# This is much faster than reading files anew each epoch, but comes at the cost of assuming a uniform dataset.", "\n", "# Alternative is to have workers load files at each epoch: that saves memory but is WAY slower that preloading", "\n", "        ", "print", "(", "\"    Preloading audio files for this dataset...\"", ")", "\n", "files_to_load", "=", "min", "(", "100000", ",", "len", "(", "self", ".", "input_filenames", ")", ")", "# min / trap to avoid memory errors", "\n", "audio_in", ",", "audio_targ", ",", "knobs_wc", "=", "self", ".", "read_one_new_file_pair", "(", ")", "# read one file for sizing", "\n", "dur", "=", "len", "(", "audio_in", ")", "/", "self", ".", "sr", "\n", "self", ".", "num_knobs", "=", "len", "(", "knobs_wc", ")", "\n", "self", ".", "x", ",", "self", ".", "y", "=", "[", "]", ",", "[", "]", "\n", "#self.x = np.zeros((files_to_load,len(audio_in) ),dtype=self.dtype)", "\n", "#self.y = np.zeros((files_to_load,len(audio_targ) ),dtype=self.dtype)", "\n", "self", ".", "knobs", "=", "np", ".", "zeros", "(", "(", "files_to_load", ",", "self", ".", "num_knobs", ")", ",", "dtype", "=", "self", ".", "dtype", ")", "\n", "print_every", "=", "files_to_load", "//", "10", "if", "0", "!=", "files_to_load", "//", "10", "else", "1", "\n", "for", "i", "in", "range", "(", "files_to_load", ")", ":", "\n", "            ", "tmp_x", ",", "tmp_y", ",", "self", ".", "knobs", "[", "i", "]", "=", "self", ".", "read_one_new_file_pair", "(", "idx", "=", "i", ")", "\n", "\n", "if", "(", "(", "i", "+", "1", ")", "%", "print_every", "==", "0", ")", "or", "(", "i", "+", "1", "==", "files_to_load", ")", ":", "\n", "                ", "print", "(", "\"\\r       i = \"", ",", "i", "+", "1", ",", "\"/\"", ",", "files_to_load", ",", "\" len x =\"", ",", "len", "(", "tmp_x", ")", ",", "\"dur=\"", ",", "len", "(", "tmp_x", ")", "/", "44100.0", "/", "60", ",", "\" min\"", ",", "\" len y =\"", ",", "len", "(", "tmp_y", ")", ")", "\n", "\n", "", "if", "(", "len", "(", "tmp_x", ")", "!=", "len", "(", "tmp_y", ")", ")", ":", "\n", "                ", "print", "(", "\"  ***Warning: Length mismatch. input & output filenames:\"", ",", "\n", "self", ".", "input_filenames", "[", "i", "]", ",", "self", ".", "target_filenames", "[", "i", "]", ")", "\n", "if", "self", ".", "align_end", ":", "\n", "                    ", "minlen", "=", "min", "(", "len", "(", "tmp_x", ")", ",", "len", "(", "tmp_y", ")", ")", "\n", "print", "(", "\"   Aligning to ends:\"", ")", "\n", "print", "(", "\"      Before alignment: tmp_x.shape, tmp_y.shape = \"", ",", "tmp_x", ".", "shape", ",", "tmp_y", ".", "shape", ")", "\n", "tmp_x", ",", "tmp_y", "=", "tmp_x", "[", "-", "minlen", ":", "]", ",", "tmp_y", "[", "-", "minlen", ":", "]", "\n", "print", "(", "\"      After alignment:  tmp_x.shape, tmp_y.shape = \"", ",", "tmp_x", ".", "shape", ",", "tmp_y", ".", "shape", ")", "\n", "\n", "", "", "if", "self", ".", "effect", ".", "is_inverse", ":", "\n", "                ", "tmp_x", ",", "tmp_y", "=", "tmp_y", ",", "tmp_x", "# for effects that reverse 'input' and 'output' (for de-____ effects)", "\n", "\n", "# add audio to the lists that make up the datasets", "\n", "", "self", ".", "x", ".", "append", "(", "tmp_x", ")", "\n", "self", ".", "y", ".", "append", "(", "tmp_y", ")", "\n", "\n", "", "print", "(", "\"    ...finished preloading\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.__len__": [[162, 164], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "datapoints", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.process_audio": [[165, 176], ["os.path.exists", "sorted", "sorted", "print", "glob.glob", "glob.glob", "len", "len", "datasets.AudioFileDataSet.__len__"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__len__"], ["", "def", "process_audio", "(", "self", ")", ":", "# TODO: not used yet following torchaudio", "\n", "        ", "\"\"\" Render raw audio as pytorch-friendly file. TODO: not done yet.\n        \"\"\"", "\n", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "processed_dir", ")", ":", "\n", "            ", "return", "\n", "\n", "# get a list of available audio files.  Note that knob settings are included to the target filenames", "\n", "", "input_filenames", "=", "sorted", "(", "glob", ".", "glob", "(", "self", ".", "path", "+", "'/'", "+", "'input_*'", ")", ")", "\n", "self", ".", "target_filenames", "=", "sorted", "(", "glob", ".", "glob", "(", "self", ".", "path", "+", "'/'", "+", "'target_*'", ")", ")", "\n", "assert", "len", "(", "input_filenames", ")", "==", "len", "(", "target_filenames", ")", "# TODO: One can image a scheme with multiple targets per input", "\n", "print", "(", "\"Dataset: Found\"", ",", "self", ".", "__len__", "(", ")", ",", "\"raw audio i-o pairs in path\"", ",", "self", ".", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.parse_knob_string": [[178, 187], ["numpy.array", "knob_str.replace().split", "float", "knob_str.replace"], "methods", ["None"], ["", "def", "parse_knob_string", "(", "self", ",", "knob_str", ",", "ext", "=", "\".wav\"", ")", ":", "# given target filename, get knob settings", "\n", "        ", "\"\"\" By convention, we will use double-underscores in the filename before each knob setting,\n            and these should be the last part of the filename before the extension\n            Nowhere else in the filename should double underscores appear.\n            Example: 'target_9400_Compressor_4c__-10.95__3.428__0.005043__0.01308.wav'\n        \"\"\"", "\n", "knob_list", "=", "knob_str", ".", "replace", "(", "ext", ",", "''", ")", ".", "split", "(", "'__'", ")", "[", "1", ":", "]", "# strip ext, and throw out everything before first __'s", "\n", "knobs", "=", "np", ".", "array", "(", "[", "float", "(", "x", ")", "for", "x", "in", "knob_list", "]", ",", "dtype", "=", "self", ".", "dtype", ")", "# turn list of number-strings into float numpy array", "\n", "return", "knobs", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.read_one_new_file_pair": [[189, 223], ["audio.read_audio_file", "audio.read_audio_file", "datasets.AudioFileDataSet.parse_knob_string", "numpy.random.randint", "audio.mu_compand", "audio.mu_compand", "len"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.read_audio_file", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.read_audio_file", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.parse_knob_string", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.mu_compand", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.mu_compand"], ["", "def", "read_one_new_file_pair", "(", "self", ",", "idx", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        read from input-target audio files, and parse target audio filename to get knob setting\n        Inputs:\n            idx (optional): index within the list of filenames to read from\n        \"\"\"", "\n", "if", "idx", "is", "None", ":", "\n", "            ", "idx", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "high", "=", "len", "(", "self", ".", "input_filenames", ")", ")", "# pick a file at random", "\n", "\n", "", "audio_in", ",", "sr", "=", "audio", ".", "read_audio_file", "(", "self", ".", "input_filenames", "[", "idx", "]", ",", "sr", "=", "self", ".", "sr", ",", "fix_and_overwrite", "=", "True", ")", "\n", "audio_targ", ",", "sr", "=", "audio", ".", "read_audio_file", "(", "self", ".", "target_filenames", "[", "idx", "]", ",", "sr", "=", "self", ".", "sr", ",", "fix_and_overwrite", "=", "True", ")", "\n", "\n", "# parse knobs from target filename", "\n", "knobs_wc", "=", "self", ".", "parse_knob_string", "(", "self", ".", "target_filenames", "[", "idx", "]", ")", "\n", "\n", "'''# Keeping this in code in case I want to switch it on for diagnostic reasons later\n         # only rerun effect on chunks. see get_single_chunk() below\n        if self.rerun_effect: # run effect on entire file; this for checking/diagnostic only; can ignore for typical uses\n            audio_orig = np.copy(audio_targ)\n            audio_targ, audio_in = self.effect.go_wc(audio_in, knobs_wc)\n\n            audio_diff = audio_targ - audio_orig\n            if np.max(np.abs(audio_diff)) > 1e-6:  # output log files for when this makes a difference\n                audio.write_audio_file('audio_in_'+str(idx)+'.wav', audio_in, sr=44100)\n                audio.write_audio_file('audio_orig_'+str(idx)+'.wav', audio_orig, sr=44100)\n                audio.write_audio_file('audio_targ_'+str(idx)+'.wav', audio_targ, sr=44100)\n                audio.write_audio_file('audio_diff_'+str(idx)+'.wav', audio_diff, sr=44100)\n            '''", "\n", "\n", "if", "self", ".", "compand", ":", "\n", "            ", "audio_in", "=", "audio", ".", "mu_compand", "(", "audio_in", ")", "\n", "audio_targ", "=", "audio", ".", "mu_compand", "(", "audio_targ", ")", "\n", "\n", "", "return", "audio_in", ",", "audio_targ", ",", "knobs_wc", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.get_single_chunk": [[225, 254], ["numpy.random.randint", "numpy.random.randint", "datasets.AudioFileDataSet.read_one_new_file_pair", "len", "datasets.AudioFileDataSet.effect.go_wc", "datasets.do_augment", "x_item.astype", "y_item.astype", "knobs_nn.astype", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.read_one_new_file_pair", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.FileEffect.go_wc", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.do_augment"], ["", "def", "get_single_chunk", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Grabs audio and knobs either from files or from preloaded buffer(s)\n        \"\"\"", "\n", "if", "self", ".", "preload", ":", "# This will typically be the case", "\n", "            ", "i", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "high", "=", "len", "(", "self", ".", "x", ")", ")", "# pick a random line from preloaded audio", "\n", "in_audio", ",", "targ_audio", ",", "knobs_wc", "=", "self", ".", "x", "[", "i", "]", ",", "self", ".", "y", "[", "i", "]", ",", "self", ".", "knobs", "[", "i", "]", "# note these might be, e.g. 10 seconds long", "\n", "", "else", ":", "\n", "            ", "in_audio", ",", "targ_audio", ",", "knobs_wc", "=", "self", ".", "read_one_new_file_pair", "(", ")", "# read x, y, knobs", "\n", "\n", "# Grab a random chunk from within total audio nfile", "\n", "", "assert", "len", "(", "in_audio", ")", ">", "self", ".", "chunk_size", ",", "f\"Error: len(in_audio)={len(in_audio)}, must be > self.chunk_size={self.chunk_size}\"", "\n", "ibgn", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "in_audio", ")", "-", "self", ".", "chunk_size", ")", "\n", "x_item", "=", "in_audio", "[", "ibgn", ":", "ibgn", "+", "self", ".", "chunk_size", "]", "\n", "y_item", "=", "targ_audio", "[", "ibgn", ":", "ibgn", "+", "self", ".", "chunk_size", "]", "\n", "\n", "if", "self", ".", "rerun_effect", ":", "# re-run the effect on this chunk , and replace target audio", "\n", "            ", "y_item", ",", "x_item", "=", "self", ".", "effect", ".", "go_wc", "(", "x_item", ",", "knobs_wc", ")", "# Apply the audio effect", "\n", "\n", "", "y_item", "=", "y_item", "[", "-", "self", ".", "y_size", ":", "]", "# Format for expected output size", "\n", "\n", "# normalize knobs for nn usage", "\n", "kr", "=", "self", ".", "effect", ".", "knob_ranges", "# kr is abbribation for 'knob ranges'", "\n", "knobs_nn", "=", "(", "knobs_wc", "-", "kr", "[", ":", ",", "0", "]", ")", "/", "(", "kr", "[", ":", ",", "1", "]", "-", "kr", "[", ":", ",", "0", "]", ")", "-", "0.5", "\n", "\n", "if", "self", ".", "augment", ":", "\n", "            ", "x_item", ",", "y_item", "=", "do_augment", "(", "x_item", ",", "y_item", ")", "\n", "\n", "", "return", "x_item", ".", "astype", "(", "self", ".", "dtype", ",", "copy", "=", "False", ")", ",", "y_item", ".", "astype", "(", "self", ".", "dtype", ",", "copy", "=", "False", ")", ",", "knobs_nn", ".", "astype", "(", "self", ".", "dtype", ",", "copy", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.__getitem__": [[256, 260], ["datasets.AudioFileDataSet.get_single_chunk"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.AudioFileDataSet.get_single_chunk"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "# we ignore idx and grab a random bit from a random file", "\n", "#if self.recycle:", "\n", "#    return self.x[idx], self.y[idx], self.knobs[idx]", "\n", "        ", "return", "self", ".", "get_single_chunk", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__": [[275, 301], ["torch.utils.data.Dataset.__init__", "len", "print", "numpy.arange", "print", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "print", "datasets.SynthAudioDataSet.gen_single_chunk"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__init__", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.gen_single_chunk"], ["def", "__init__", "(", "self", ",", "chunk_size", ",", "effect", ",", "sr", "=", "44100", ",", "datapoints", "=", "8000", ",", "dtype", "=", "np", ".", "float32", ",", "\n", "recycle", "=", "False", ",", "y_size", "=", "None", ",", "augment", "=", "True", ")", ":", "\n", "        ", "super", "(", "SynthAudioDataSet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "chunk_size", "=", "chunk_size", "\n", "self", ".", "effect", "=", "effect", "\n", "self", ".", "sr", "=", "sr", "\n", "self", ".", "datapoints", "=", "datapoints", "\n", "self", ".", "dtype", "=", "dtype", "\n", "self", ".", "recycle", "=", "recycle", "\n", "self", ".", "num_knobs", "=", "len", "(", "effect", ".", "knob_names", ")", "\n", "self", ".", "y_size", "=", "chunk_size", "if", "(", "y_size", "is", "None", ")", "else", "y_size", "\n", "self", ".", "augment", "=", "augment", "# data augmentation: randomly invert phase", "\n", "\n", "# preallocate an array of time values across one chunk for use with audio synth functions", "\n", "self", ".", "t", "=", "np", ".", "arange", "(", "chunk_size", ",", "dtype", "=", "np", ".", "float32", ")", "/", "sr", "\n", "\n", "print", "(", "\"SynthAudioDataSet: synthetic/generated data\"", ")", "\n", "\n", "if", "recycle", ":", "# keep the same data over & over (Useful for monitoring Validation set)", "\n", "            ", "print", "(", "\"Setting up recycling (static data) for this dataset. This may take a short while...\"", ")", "\n", "self", ".", "x", "=", "np", ".", "zeros", "(", "(", "datapoints", ",", "chunk_size", ")", ",", "dtype", "=", "self", ".", "dtype", ")", "\n", "self", ".", "y", "=", "np", ".", "zeros", "(", "(", "datapoints", ",", "self", ".", "y_size", ")", ",", "dtype", "=", "self", ".", "dtype", ")", "\n", "self", ".", "knobs", "=", "np", ".", "zeros", "(", "(", "datapoints", ",", "self", ".", "num_knobs", ")", ",", "dtype", "=", "self", ".", "dtype", ")", "\n", "for", "i", "in", "range", "(", "datapoints", ")", ":", "\n", "                ", "self", ".", "x", "[", "i", "]", ",", "self", ".", "y", "[", "i", "]", ",", "self", ".", "knobs", "[", "i", "]", "=", "self", ".", "gen_single_chunk", "(", ")", "\n", "", "print", "(", "\"...done\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__len__": [[302, 304], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "datapoints", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.__getitem__": [[305, 311], ["datasets.SynthAudioDataSet.gen_single_chunk", "knobs.astype", "x.astype"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.gen_single_chunk"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "# Basic PyTorch operation with DataLoader", "\n", "        ", "if", "self", ".", "recycle", ":", "\n", "            ", "return", "self", ".", "x", "[", "idx", "]", ",", "self", ".", "y", "[", "idx", "]", ",", "self", ".", "knobs", "[", "idx", "]", "\n", "\n", "", "x", ",", "y", ",", "knobs", "=", "self", ".", "gen_single_chunk", "(", ")", "\n", "return", "x", ".", "astype", "(", "self", ".", "dtype", ",", "copy", "=", "False", ")", "[", "-", "self", ".", "chunk_size", ":", "]", ",", "y", "[", "-", "self", ".", "y_size", ":", "]", ",", "knobs", ".", "astype", "(", "self", ".", "dtype", ",", "copy", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.SynthAudioDataSet.gen_single_chunk": [[312, 335], ["audio.synth_input_sample", "datasets.SynthAudioDataSet.effect.go", "numpy.random.choice", "datasets.do_augment", "audio.random_ends", "len"], "methods", ["home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.synth_input_sample", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.Effect.go", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.do_augment", "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.audio.random_ends"], ["", "def", "gen_single_chunk", "(", "self", ",", "chooser", "=", "None", ",", "knobs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        create a single time-series of input and target output, all with the same knobs setting\n        \"\"\"", "\n", "if", "chooser", "is", "None", ":", "\n", "            ", "chooser", "=", "np", ".", "random", ".", "choice", "(", "[", "0", ",", "1", ",", "2", ",", "4", ",", "6", ",", "7", "]", ")", "# for compressor", "\n", "#chooser = np.random.choice([0,1,3,4,6,10,2,7,9]) # for compressor & more", "\n", "#chooser = 4  # for just step response ('cheating')", "\n", "#chooser = np.random.choice([1,3,5,6,7])  # for echo", "\n", "\n", "", "x", "=", "audio", ".", "synth_input_sample", "(", "self", ".", "t", ",", "chooser", ")", "\n", "\n", "if", "knobs", "is", "None", ":", "\n", "            ", "knobs", "=", "audio", ".", "random_ends", "(", "len", "(", "self", ".", "effect", ".", "knob_ranges", ")", ")", "-", "0.5", "# inputs to NN, zero-mean...except we emphasize the ends slightly", "\n", "\n", "", "y", ",", "x", "=", "self", ".", "effect", ".", "go", "(", "x", ",", "knobs", ")", "# Apply the audio effect", "\n", "\n", "y", "=", "y", "[", "-", "self", ".", "y_size", ":", "]", "# shrink output size", "\n", "\n", "if", "self", ".", "augment", ":", "\n", "            ", "x", ",", "y", "=", "do_augment", "(", "x", ",", "y", ")", "\n", "\n", "", "return", "x", ",", "y", ",", "knobs", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.do_augment": [[21, 52], ["numpy.random.choice", "numpy.random.choice", "int", "numpy.random.randint", "numpy.random.choice", "int", "numpy.random.randint", "numpy.max", "numpy.random.rand", "numpy.random.rand"], "function", ["None"], ["def", "do_augment", "(", "x", ",", "y", ",", "rand_invert", "=", "True", ",", "mult_some", "=", "False", ",", "add_some", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    A few simple hacks for data augmentation, to make the dataset go further.\n    Nothing fancy: Don't want to mess up the target data if this is a file-based dataset.\n    Note that time translations are effectively already handled by the data generators (below).\n    \"\"\"", "\n", "if", "rand_invert", "and", "np", ".", "random", ".", "choice", "(", "[", "True", ",", "False", "]", ")", ":", "\n", "# randomly flip phases of both input & target", "\n", "        ", "x", ",", "y", "=", "-", "x", ",", "-", "y", "\n", "\n", "# Below are ugmentations that only affect the lookback part of the input x", "\n", "", "lookback", "=", "x", ".", "size", "-", "y", ".", "size", "\n", "\n", "if", "mult_some", "and", "np", ".", "random", ".", "choice", "(", "[", "True", ",", "False", "]", ")", ":", "\n", "# like \"cutout\" or \"salt & pepper\". here we randomly multiply isolated samples by random factors.", "\n", "# NOTE: this will end up adding lots of high-freq info in the STFT and may not be adviseable.", "\n", "        ", "fraction", "=", "0.2", "# mess with this fraction of number of samples in the lookback window", "\n", "n", "=", "int", "(", "lookback", "*", "fraction", ")", "# number of samples to modify", "\n", "indices", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "high", "=", "lookback", ",", "size", "=", "n", ")", "# indices where mod will occur", "\n", "mults", "=", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "n", ")", "-", "1", ")", ".", "astype", "(", "x", ".", "dtype", ",", "copy", "=", "False", ")", "# random multiplicative factor [-1..1]", "\n", "x", "[", "indices", "]", "=", "x", "[", "indices", "]", "*", "mults", "\n", "\n", "", "if", "add_some", "and", "np", ".", "random", ".", "choice", "(", "[", "True", ",", "False", "]", ")", ":", "\n", "# similar to mult_some, but we add verrry small noise to some points", "\n", "        ", "fraction", "=", "0.3", "\n", "n", "=", "int", "(", "lookback", "*", "fraction", ")", "# number of samples to modify", "\n", "indices", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "high", "=", "lookback", ",", "size", "=", "n", ")", "\n", "tiny_fac", "=", "np", ".", "max", "(", "x", ")", "/", "1e6", "\n", "adds", "=", "(", "tiny_fac", "*", "(", "2", "*", "np", ".", "random", ".", "rand", "(", "n", ")", "-", "1", ")", ")", ".", "astype", "(", "x", ".", "dtype", ",", "copy", "=", "False", ")", "\n", "x", "[", "indices", "]", "=", "x", "[", "indices", "]", "+", "adds", "\n", "", "return", "x", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.drscotthawley_signaltrain.signaltrain.datasets.worker_init": [[54, 62], ["numpy.random.seed"], "function", ["None"], ["", "def", "worker_init", "(", "worker_id", ")", ":", "\n", "    ", "\"\"\"\n    used with PyTorch DataLoader so that we can grab random bits of files or\n    synth random input data on the fly\n    Without this you get the same thing every epoch\n    \"\"\"", "\n", "# NOTE that this current implementation prevents strict reproducability", "\n", "np", ".", "random", ".", "seed", "(", ")", "\n", "\n"]]}