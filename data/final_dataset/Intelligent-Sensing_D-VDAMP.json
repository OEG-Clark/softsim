{"home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.simulation.denoise_sim": [[23, 45], ["print", "util.general.add_noise", "print", "denoiser"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.add_noise"], ["def", "denoise_sim", "(", "image", ",", "std", ",", "denoiser", ")", ":", "\n", "    ", "\"\"\"Simulate denoising problem\n\n    Args:\n        image (torch.Tensor): image tensor with shape (C, H, W).\n        std (float): standard deviation of additive Gaussian noise\n            on the scale [0., 1.].\n        denoiser: a denoiser instance (as in algorithms.denoiser).\n            The std argument for this denoiser is already specified\n            if applicable.\n\n    Returns:\n        denoised_image (torch.Tensor): tensor of denoised image\n        noisy_image (torch.Tensor): tensor of noisy image\n    \"\"\"", "\n", "print", "(", "'deploy.sim.denoise_sim: Simulating noisy image...'", ")", "\n", "noisy_image", "=", "gutil", ".", "add_noise", "(", "image", ",", "std", ")", "\n", "\n", "print", "(", "'deploy.sim.denoise_sim: Begin image denoising...'", ")", "\n", "denoised_image", "=", "denoiser", "(", "noisy_image", ",", "std", "=", "std", ")", "\n", "\n", "return", "denoised_image", ",", "noisy_image", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.simulation.cs_sim": [[46, 77], ["print", "cs_transform.Afun", "print", "time.time", "cs_algo", "print", "image.view", "torch.normal", "cs_transform.get_m", "cs_transform.get_n", "torch.zeros", "time.time"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.Afun", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.get_m", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.get_n"], ["", "def", "cs_sim", "(", "image", ",", "cs_transform", ",", "std", ",", "cs_algo", ")", ":", "\n", "    ", "\"\"\"Simulate compressive sensing problem\n\n    Args:\n        image (torch.Tensor): image tensor with shape (C, H, W).\n        cs_transform (CStransform): a CS transformation instance.\n        std (float): standard deviation of additive Gaussian noise\n            on the scale [0., 1.].\n        cs_algo (algorithms.csalgo.IterativeDenoisingCSRecon):\n            an instance of CS reconstruction algorithm.\n\n    Returns:\n        recon_image (torch.Tensor): tensor of reconstructed image.\n        r_t (torch.Tensor): tensor of the pseudo noisy image (r_t)\n            from last iteration of cs_algo.\n        std_est (float): estimated standard deviation of noise in r_t\n        psnr (np.ndarray): PSNR at each iteration of reconstruction with cs_algo.\n            psnr is None if cs_algo does not have the reference ground truth image.\n    \"\"\"", "\n", "print", "(", "'deploy.sim.cs_sim: Simulating compressive sensing...'", ")", "\n", "y", "=", "cs_transform", ".", "Afun", "(", "image", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "if", "std", ">", "0", ":", "\n", "        ", "y", "+=", "torch", ".", "normal", "(", "mean", "=", "torch", ".", "zeros", "(", "y", ".", "shape", ")", ",", "std", "=", "std", ")", "\n", "\n", "", "print", "(", "'deploy.sim.cs_sim: Begin compressive sensing reconstruction...'", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "recon_image", ",", "psnr", ",", "r_t", ",", "std_est", "=", "cs_algo", "(", "y", ",", "cs_transform", ".", "Afun", ",", "cs_transform", ".", "Atfun", ",", "\n", "cs_transform", ".", "get_m", "(", ")", ",", "cs_transform", ".", "get_n", "(", ")", ")", "\n", "print", "(", "'deploy.sim.cs_sim: Reconstruction took {:.3f} s'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", "\n", "\n", "return", "recon_image", ",", "r_t", ",", "std_est", ",", "psnr", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.simulation.vdamp_se_sim": [[78, 112], ["numpy.sqrt", "util.transform.forward().astype", "util.transform.add_noise_subbandwise", "denoiser", "denoiser.inverse().unsqueeze", "util.transform.forward", "denoiser.inverse"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.astype", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.add_noise_subbandwise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse"], ["", "def", "vdamp_se_sim", "(", "image", ",", "tau", ",", "denoiser", ",", "level", "=", "4", ",", "is_complex", "=", "True", ")", ":", "\n", "    ", "\"\"\"Simulate VDAMP State Evolution\n\n    Args:\n        image (torch.Tensor): image tensor with shape (C, H, W).\n        tau (array): array of variance of noise in each wavelet subband.\n        denoiser: a denoiser instance from algorithm.vdamp.\n        level (int): the level of wavelet decomposition.\n        is_complex (bool): whether to add complex noise.\n\n    Returns:\n        image_denoised (tutil.Wavelet): the denoised image i.e. inverse wavelet transform\n            of the denoised wavelet.\n        wavelet_noisy (tutil.Wavelet): the noisy wavelet.\n        wavelet_denoised (tutil.Wavelet): the denoised wavelet.\n\n    Notes:\n        The denoiser must be the kind that handles wavelet coefficients.\n        Some can be found in algorithm.vdamp.\n    \"\"\"", "\n", "\n", "if", "complex", ":", "\n", "        ", "dtype", "=", "np", ".", "complex64", "\n", "", "else", ":", "\n", "        ", "dtype", "=", "np", ".", "float32", "\n", "\n", "", "std", "=", "np", ".", "sqrt", "(", "tau", ")", "\n", "wavelet_image", "=", "tutil", ".", "forward", "(", "image", "[", "0", "]", ",", "level", "=", "level", ")", ".", "astype", "(", "dtype", ")", "# x", "\n", "wavelet_noisy", "=", "tutil", ".", "add_noise_subbandwise", "(", "wavelet_image", ",", "std", ",", "\n", "is_complex", "=", "is_complex", ")", "# r", "\n", "wavelet_denoised", "=", "denoiser", "(", "wavelet_noisy", ",", "tau", ",", "calc_divergence", "=", "False", ")", "# w_hat", "\n", "image_denoised", "=", "wavelet_denoised", ".", "inverse", "(", ")", ".", "unsqueeze", "(", "0", ")", "# x_hat", "\n", "\n", "return", "image_denoised", ",", "wavelet_noisy", ",", "wavelet_denoised", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.simulation.dvdamp_sim": [[113, 152], ["algorithm.dvdamp.gen_pdf", "numpy.random.binomial", "algorithm.dvdamp.dvdamp", "util.general.im_numpy_to_tensor", "util.transform.fftnc", "util.general.generate_noise", "numpy.sqrt", "image.abs"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.gen_pdf", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.dvdamp", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.im_numpy_to_tensor", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.fftnc", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_noise"], ["", "def", "dvdamp_sim", "(", "image", ",", "sampling_rate", ",", "snr", ",", "denoiser", ",", "iters", ",", "\n", "level", "=", "4", ",", "wavetype", "=", "'haar'", ",", "stop_on_increase", "=", "True", ")", ":", "\n", "    ", "\"\"\"Simulate MRI measurement with variable-density sampling and reconstruct\n        the image with D-VDAMP.\n\n    Args:\n        image (torch.Tensor): image tensor with shape (C, H, W).\n        sampling_rate (float): sampling rate of the measurement.\n        snr (float): signal-to-noise ratio of the measurement.\n        denoiser: a denoiser instance from algorithm.vdamp.\n        iters (int): maximum number of iterations for D-VDAMP.\n        level (int): the level of wavelet decomposition.\n        wavetype (str): type of the wavelet in wavelet transform.\n        stop_on_increase (bool): whether to stop D-VDAMP when the predicted MSE increases.\n\n    Returns:\n        recon_image (torch.Tensor): the reconstructed image.\n        log (dict): log of D-VDAMP containing the following information in each iteration.\n            - reconstruction, x_hat\n            - noisy wavelet, r\n            - denoised wavelet, w_hat\n            - predicted noise variance, tau\n            - mean squared error, err (if the ground truth image is given to D-VDAMP)\n        true_iters (int): the number of iterations before D-VDAMP terminates.\n\n    Notes:\n        We assume that the ground truth is a real image.\n        The denoiser must be the kind that handles wavelet coefficients.\n        Some can be found in algorithm.vdamp.\n    \"\"\"", "\n", "prob_map", "=", "dvdamp", ".", "gen_pdf", "(", "image", ".", "shape", ",", "sampling_rate", ")", "\n", "mask", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "prob_map", ")", "\n", "var0", "=", "(", "(", "image", ".", "abs", "(", ")", "**", "2", ")", ".", "mean", "(", ")", "/", "(", "10", "**", "(", "0.1", "*", "snr", ")", ")", ")", ".", "item", "(", ")", "\n", "y", "=", "mask", "*", "(", "tutil", ".", "fftnc", "(", "image", "[", "0", "]", ")", "+", "gutil", ".", "generate_noise", "(", "mask", ".", "shape", ",", "np", ".", "sqrt", "(", "var0", ")", ",", "ret_array", "=", "True", ")", ")", "\n", "x_hat", ",", "log", ",", "true_iters", "=", "dvdamp", ".", "dvdamp", "(", "y", ",", "prob_map", ",", "mask", ",", "var0", ",", "denoiser", ",", "\n", "image", "=", "image", "[", "0", "]", ",", "iters", "=", "iters", ",", "level", "=", "level", ",", "\n", "wavetype", "=", "wavetype", ",", "stop_on_increase", "=", "stop_on_increase", ")", "\n", "recon_image", "=", "gutil", ".", "im_numpy_to_tensor", "(", "x_hat", ")", "\n", "return", "recon_image", ",", "log", ",", "true_iters", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.BM3D_denoiser.__init__": [[37, 45], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "std", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize BM3D denoiser.\n\n        Args:\n            std (float): the default standard deviation (std) as input to BM3D denoiser.\n            This value is used when std is not given when the denoiser is called.\n        \"\"\"", "\n", "self", ".", "std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.BM3D_denoiser.__call__": [[46, 59], ["torch.Tensor().unsqueeze", "torch.Tensor", "bm3d.bm3d.bm3d"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "std", "=", "None", ")", ":", "\n", "        ", "\"\"\"Denoise image with BM3D.\n\n        Args:\n            image (array/tensor): image with shape (C, H, W)\n            std (float): std as input to BM3D denoiser. If None, use default std value instead.\n\n        Returns:\n            denoised_image (tensor): denoised image with shape (C, H, W)\n        \"\"\"", "\n", "if", "std", "is", "None", ":", "\n", "            ", "std", "=", "self", ".", "std", "\n", "", "return", "torch", ".", "Tensor", "(", "bm3d", "(", "image", "[", "0", "]", ",", "std", ")", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.DnCNN_denoiser.__init__": [[67, 77], ["torch.device"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "        ", "\"\"\"Initialize DnCNN denoiser\n\n        Args:\n            model: the DnCNN denoiser model. See setup_DnCNN function for loading the model.\n            batch_size (int): the batch size in case this denoiser is called on tensor of multiple images.\n            device: the device to run the model on e.g. torch.device('cpu'), torch.device('cuda'), etc.\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.DnCNN_denoiser.__call__": [[78, 93], ["image.to.to.to", "denoiser.DnCNN_denoiser.model", "denoiser.DnCNN_denoiser.cpu"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "std", "=", "None", ")", ":", "\n", "        ", "\"\"\"Denoise images with DnCNN.\n\n        Args:\n            image (tensor): the noisy image tensor. The shape can be (C, H, W) for single image and\n                (N, C, H, W) for multiple images.\n            std: dummy argument so that this denoiser is compatible with\n                algorithm.heatmap.calc_sure.\n\n        Returns:\n            output (tensor): denoised image(s).\n        \"\"\"", "\n", "image", "=", "image", ".", "to", "(", "device", "=", "self", ".", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "output", "=", "self", ".", "model", "(", "image", ")", "\n", "return", "output", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.DnCNN_ensemble_denoiser.__init__": [[99, 116], ["torch.device"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "models", ",", "std_ranges", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ",", "verbose", "=", "False", ",", "std", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize DnCNN ensemble denoiser.\n\n        Args:\n            models (list): list of DnCNN models.\n            std_ranges (np.ndarray): array of ranges of noise std corresponding to the model\n                in the increasing order. For example, array([0, 5, 10]) means the ranges are\n                [0, 5] and [5, 10].\n            device: the device to run the model on.\n            verbose (bool): whether to print which DnCNN is selected.\n            std (float): the default std of the noise image.\n        \"\"\"", "\n", "self", ".", "models", "=", "models", "\n", "self", ".", "std_ranges", "=", "std_ranges", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.DnCNN_ensemble_denoiser.__call__": [[117, 145], ["image.to.to.to", "output.cpu", "numpy.sum", "print", "print", "len", "print"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "std", "=", "None", ")", ":", "\n", "        ", "\"\"\"Denoise images with DnCNN ensemble.\n\n        Args:\n            image (tensor): single noise image with shape (C, H, W).\n            std (float): std of the noise for selecting DnCNN trained on\n                this noise level. If None, use the default value.\n\n        Returns:\n            output (tensor): denoised image.\n        \"\"\"", "\n", "if", "std", "is", "None", ":", "\n", "            ", "std", "=", "self", ".", "std", "\n", "\n", "", "select", "=", "np", ".", "sum", "(", "std", ">", "self", ".", "std_ranges", ")", "-", "1", "\n", "if", "select", "<", "0", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "'denoiser.DnCNN_ensemble_denoiser: The noise level is lower than models available'", ")", "\n", "", "select", "+=", "1", "\n", "", "elif", "select", ">", "len", "(", "self", ".", "models", ")", "-", "1", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "'denoiser.DnCNN_ensemble_denoiser: The noise level is higher than models available'", ")", "\n", "", "select", "-=", "1", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'denoiser.DnCNN_ensemble_denoiser: select = {:d}'", ".", "format", "(", "select", ")", ")", "\n", "", "image", "=", "image", ".", "to", "(", "device", "=", "self", ".", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "output", "=", "self", ".", "models", "[", "select", "]", "(", "image", ")", "\n", "return", "output", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.DnCNN.__init__": [[184, 205], ["torch.nn.Module.__init__", "layers.append", "layers.append", "range", "layers.append", "torch.nn.Sequential", "denoiser.DnCNN._initialize_weights", "torch.nn.Conv2d", "torch.nn.ReLU", "layers.append", "layers.append", "layers.append", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.__init__", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN._initialize_weights"], ["def", "__init__", "(", "self", ",", "channels", ",", "num_layers", "=", "17", ")", ":", "\n", "        ", "super", "(", "DnCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Fixed parameters", "\n", "kernel_size", "=", "3", "\n", "padding", "=", "1", "\n", "features", "=", "64", "\n", "\n", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "in_channels", "=", "channels", ",", "out_channels", "=", "features", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", ")", "\n", "layers", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "for", "_", "in", "range", "(", "num_layers", "-", "2", ")", ":", "\n", "            ", "layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "in_channels", "=", "features", ",", "out_channels", "=", "features", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", ")", "\n", "layers", ".", "append", "(", "nn", ".", "BatchNorm2d", "(", "features", ")", ")", "\n", "layers", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "", "layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "in_channels", "=", "features", ",", "out_channels", "=", "channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", ")", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "self", ".", "_initialize_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.DnCNN.forward": [[206, 219], ["denoiser.DnCNN.layers().squeeze", "denoiser.DnCNN.layers", "x.expand"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Model forward function.\n\n        Args:\n            x (tensor): image of shape (C, H, W)\n\n        Note:\n            The expected image shape is different from the model when training which\n            expects (N, C, H, W) where N is the batch size.\n        \"\"\"", "\n", "noise", "=", "self", ".", "layers", "(", "x", ".", "expand", "(", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ")", ")", ".", "squeeze", "(", "dim", "=", "0", ")", "\n", "out", "=", "x", "-", "noise", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.DnCNN._initialize_weights": [[220, 227], ["denoiser.DnCNN.modules", "isinstance", "torch.nn.init.kaiming_normal_", "isinstance", "torch.nn.init.ones_", "torch.nn.init.zeros_"], "methods", ["None"], ["", "def", "_initialize_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "ones_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "zeros_", "(", "m", ".", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.ColoredDnCNN.__init__": [[243, 268], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "range", "torch.nn.Conv2d", "torch.nn.ModuleList", "torch.nn.ModuleList", "denoiser.ColoredDnCNN._initialize_weights", "conv_layers.append", "bn_layers.append", "torch.nn.Conv2d", "torch.nn.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.__init__", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN._initialize_weights"], ["def", "__init__", "(", "self", ",", "channels", "=", "1", ",", "num_layers", "=", "20", ",", "std_channels", "=", "13", ")", ":", "\n", "        ", "super", "(", "ColoredDnCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "\n", "# Fixed parameters", "\n", "kernel_size", "=", "3", "\n", "padding", "=", "1", "\n", "features", "=", "64", "\n", "\n", "conv_layers", "=", "[", "]", "\n", "bn_layers", "=", "[", "]", "\n", "\n", "self", ".", "first_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "channels", "+", "std_channels", ",", "out_channels", "=", "features", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", "\n", "for", "_", "in", "range", "(", "num_layers", "-", "2", ")", ":", "\n", "            ", "conv_layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "in_channels", "=", "features", "+", "std_channels", ",", "out_channels", "=", "features", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", ")", "\n", "bn_layers", ".", "append", "(", "nn", ".", "BatchNorm2d", "(", "features", ")", ")", "\n", "", "self", ".", "last_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "features", "+", "std_channels", ",", "out_channels", "=", "channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "conv_layers", "=", "nn", ".", "ModuleList", "(", "conv_layers", ")", "\n", "self", ".", "bn_layers", "=", "nn", ".", "ModuleList", "(", "bn_layers", ")", "\n", "self", ".", "_initialize_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.ColoredDnCNN.forward": [[269, 293], ["x.unsqueeze.unsqueeze.unsqueeze", "std.unsqueeze.unsqueeze.unsqueeze", "denoiser.ColoredDnCNN._generate_std_channels", "torch.cat", "torch.nn.functional.relu", "range", "torch.cat", "denoiser.ColoredDnCNN.last_conv", "denoiser.ColoredDnCNN.first_conv", "torch.cat", "torch.nn.functional.relu"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN._generate_std_channels"], ["", "def", "forward", "(", "self", ",", "x", ",", "std", ")", ":", "\n", "        ", "\"\"\"Model forward function.\n\n        Args:\n            x (tensor): image of shape (C, H, W)\n            std (tensor): standard deviation of noise in each wavelet subband. Expect (num_subbands,) shape.\n\n        Note:\n            The expected input shapes are different from the model when training which\n            expects (N, C, H, W) and (N, num_subbands) where N is the batch size.\n        \"\"\"", "\n", "_", ",", "H", ",", "W", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "unsqueeze", "(", "0", ")", "\n", "std", "=", "std", ".", "unsqueeze", "(", "0", ")", "\n", "std_channels", "=", "self", ".", "_generate_std_channels", "(", "std", ",", "H", ",", "W", ")", "\n", "noise", "=", "torch", ".", "cat", "(", "(", "x", ",", "std_channels", ")", ",", "dim", "=", "1", ")", "\n", "noise", "=", "F", ".", "relu", "(", "self", ".", "first_conv", "(", "noise", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", "-", "2", ")", ":", "\n", "            ", "noise", "=", "torch", ".", "cat", "(", "(", "noise", ",", "std_channels", ")", ",", "dim", "=", "1", ")", "\n", "noise", "=", "F", ".", "relu", "(", "self", ".", "bn_layers", "[", "i", "]", "(", "self", ".", "conv_layers", "[", "i", "]", "(", "noise", ")", ")", ")", "\n", "", "noise", "=", "torch", ".", "cat", "(", "(", "noise", ",", "std_channels", ")", ",", "dim", "=", "1", ")", "\n", "noise", "=", "self", ".", "last_conv", "(", "noise", ")", "\n", "out", "=", "(", "x", "-", "noise", ")", ".", "squeeze", "(", "0", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.ColoredDnCNN._generate_std_channels": [[294, 298], ["std.reshape().repeat", "std.reshape"], "methods", ["None"], ["", "def", "_generate_std_channels", "(", "self", ",", "std", ",", "H", ",", "W", ")", ":", "\n", "        ", "concat_channels", "=", "std", ".", "shape", "[", "1", "]", "\n", "std_channels", "=", "std", ".", "reshape", "(", "1", ",", "concat_channels", ",", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "1", ",", "H", ",", "W", ")", "\n", "return", "std_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.ColoredDnCNN._initialize_weights": [[299, 306], ["denoiser.ColoredDnCNN.modules", "isinstance", "torch.nn.init.kaiming_normal_", "isinstance", "torch.nn.init.ones_", "torch.nn.init.zeros_"], "methods", ["None"], ["", "def", "_initialize_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "ones_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "zeros_", "(", "m", ".", "bias", ")", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.setup_DnCNN": [[146, 159], ["torch.device", "denoiser.DnCNN", "util.general.load_checkpoint", "DnCNN.to", "DnCNN.eval"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.load_checkpoint", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve.eval"], ["", "", "def", "setup_DnCNN", "(", "modedir", ",", "num_layers", "=", "17", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "    ", "\"\"\"Load a DnCNN model\n\n    Args:\n        modeldir (str): path to model.\n        num_layers (int): number of layers of the DnCNN model.\n        device: device to run DnCNN on.\n    \"\"\"", "\n", "model", "=", "DnCNN", "(", "1", ",", "num_layers", "=", "num_layers", ")", "\n", "gutil", ".", "load_checkpoint", "(", "modedir", ",", "model", ",", "None", ",", "device", "=", "device", ")", "\n", "model", ".", "to", "(", "device", "=", "device", ")", "\n", "model", ".", "eval", "(", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.setup_DnCNN_ensemble": [[160, 174], ["torch.device", "enumerate", "len", "denoiser.setup_DnCNN", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.denoiser.setup_DnCNN"], ["", "def", "setup_DnCNN_ensemble", "(", "path", ",", "modelnames", ",", "num_layers", "=", "20", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "    ", "\"\"\"Set up a DnCNN ensemble from saved DnCNN models.\n\n    Args:\n        path (str): path to directory containing DnCNN models.\n        modelnames (list): list of saved model file names.\n        num_layers (int): number of layers of the DnCNN models.\n        device: device to run DnCNN on.\n    \"\"\"", "\n", "models", "=", "[", "None", "]", "*", "len", "(", "modelnames", ")", "\n", "for", "i", ",", "name", "in", "enumerate", "(", "modelnames", ")", ":", "\n", "        ", "models", "[", "i", "]", "=", "setup_DnCNN", "(", "os", ".", "path", ".", "join", "(", "path", ",", "'{}.pth'", ".", "format", "(", "name", ")", ")", ",", "\n", "num_layers", "=", "num_layers", ",", "device", "=", "device", ")", "\n", "", "return", "models", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo.IterativeDenoisingCSRecon.__init__": [[19, 42], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "image_shape", ",", "\n", "denoiser", ",", "\n", "iters", ",", "\n", "image", ",", "\n", "verbose", ")", ":", "\n", "        ", "\"\"\"Initialize an iterative denoising CS solver.\n\n        Args:\n            image_shape (list/array): shape of the ground truth image in the format (C, H, W).\n            denoiser: the denoiser for thresholding.\n            iters: number of iterations.\n            image: the ground truth image. If image is given, calculate the PSNR of the \n                thresholding result at every iteration.\n            verbose (bool): whether to print standard deviation of the effective noise \n                and/or PSNR at every iteration.\n        \"\"\"", "\n", "self", ".", "H", "=", "image_shape", "[", "1", "]", "\n", "self", ".", "W", "=", "image_shape", "[", "2", "]", "\n", "self", ".", "denoiser", "=", "denoiser", "\n", "self", ".", "iters", "=", "iters", "\n", "self", ".", "image", "=", "image", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo.IterativeDenoisingCSRecon.__call__": [[43, 60], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y", ",", "Afun", ",", "Atfun", ",", "m", ",", "n", ")", ":", "\n", "        ", "\"\"\"Solve the CS reconstruction problem.\n\n        Args:\n            y (tensor): the measurement with dimension m.\n            Afun: the forward CS measurement operator.\n            Atfun: the transpose of Afun.\n            m (int): dimension of the measurement.\n            n (int): dimension of the ground truth.\n\n        Returns:\n            output: CS reconstruction result.\n            psnr: PSNR of the thresholding results at every iteration.\n            r_t: The noisy image before thresholding at the last iteration.\n            sigma_hat_t: the estimated standard deviation of the effective noise at the last iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo.DIT.__init__": [[68, 76], ["csalgo.IterativeDenoisingCSRecon.__init__"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.__init__"], ["def", "__init__", "(", "self", ",", "\n", "image_shape", ",", "\n", "denoiser", ",", "\n", "iters", ",", "\n", "image", "=", "None", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "image_shape", ",", "denoiser", ",", "iters", ",", "\n", "image", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo.DIT.__call__": [[77, 96], ["csalgo._setup", "torch.zeros", "y.clone", "range", "x_t.view.view.view().cpu", "csalgo.DIT.denoiser", "csalgo._calc_psnr", "x_t.view.view.view", "csalgo._print", "r_t.view().cpu", "sigma_hat_t.item", "y.clone.norm", "numpy.sqrt", "Afun", "x_t.view.view.view", "sigma_hat_t.item", "r_t.view", "Atfun"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._setup", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._calc_psnr", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._print", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.Afun", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.Atfun"], ["", "def", "__call__", "(", "self", ",", "y", ",", "Afun", ",", "Atfun", ",", "m", ",", "n", ")", ":", "\n", "        ", "psnr", "=", "_setup", "(", "self", ")", "\n", "x_t", "=", "torch", ".", "zeros", "(", "n", ",", "1", ")", "\n", "z_t", "=", "y", ".", "clone", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "iters", ")", ":", "\n", "# Update x_t", "\n", "            ", "r_t", "=", "(", "x_t", "+", "Atfun", "(", "z_t", ")", ")", ".", "view", "(", "1", ",", "self", ".", "H", ",", "self", ".", "W", ")", "\n", "sigma_hat_t", "=", "z_t", ".", "norm", "(", ")", "/", "np", ".", "sqrt", "(", "m", ")", "\n", "x_t", "=", "self", ".", "denoiser", "(", "r_t", ",", "std", "=", "sigma_hat_t", ".", "item", "(", ")", ")", "\n", "_calc_psnr", "(", "self", ",", "i", ",", "x_t", ",", "psnr", ")", "\n", "x_t", "=", "x_t", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "# Update z_t", "\n", "z_t", "=", "y", "-", "Afun", "(", "x_t", ")", "\n", "\n", "_print", "(", "self", ",", "i", ",", "x_t", ",", "sigma_hat_t", ",", "psnr", ")", "\n", "\n", "", "output", "=", "x_t", ".", "view", "(", "1", ",", "self", ".", "H", ",", "self", ".", "W", ")", ".", "cpu", "(", ")", "\n", "return", "output", ",", "psnr", ",", "r_t", ".", "view", "(", "1", ",", "self", ".", "H", ",", "self", ".", "W", ")", ".", "cpu", "(", ")", ",", "sigma_hat_t", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo.DAMP.__init__": [[99, 107], ["csalgo.IterativeDenoisingCSRecon.__init__"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.__init__"], ["def", "__init__", "(", "self", ",", "\n", "image_shape", ",", "\n", "denoiser", ",", "\n", "iters", ",", "\n", "image", "=", "None", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "image_shape", ",", "denoiser", ",", "iters", ",", "\n", "image", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo.DAMP.__call__": [[108, 133], ["csalgo._setup", "torch.zeros", "y.clone", "range", "x_t.view.view.view().cpu", "csalgo.DAMP.denoiser", "csalgo._calc_psnr", "x_t.view.view.view", "util.general.generate_noise", "csalgo._print", "r_t.view().cpu", "sigma_hat_t.item", "y.clone.norm", "numpy.sqrt", "x_t.view.view.view", "sigma_hat_t.item", "Afun", "r_t.view", "Atfun", "csalgo.DAMP.denoiser", "csalgo.DAMP.denoiser", "sigma_hat_t.item", "sigma_hat_t.item"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._setup", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._calc_psnr", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_noise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._print", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.Afun", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.Atfun"], ["", "def", "__call__", "(", "self", ",", "y", ",", "Afun", ",", "Atfun", ",", "m", ",", "n", ")", ":", "\n", "        ", "psnr", "=", "_setup", "(", "self", ")", "\n", "eps", "=", "0.001", "\n", "x_t", "=", "torch", ".", "zeros", "(", "n", ",", "1", ")", "\n", "z_t", "=", "y", ".", "clone", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "iters", ")", ":", "\n", "# Update x_t", "\n", "            ", "r_t", "=", "(", "x_t", "+", "Atfun", "(", "z_t", ")", ")", ".", "view", "(", "1", ",", "self", ".", "H", ",", "self", ".", "W", ")", "\n", "sigma_hat_t", "=", "z_t", ".", "norm", "(", ")", "/", "np", ".", "sqrt", "(", "m", ")", "\n", "x_t", "=", "self", ".", "denoiser", "(", "r_t", ",", "std", "=", "sigma_hat_t", ".", "item", "(", ")", ")", "# shape (1, H, W)", "\n", "_calc_psnr", "(", "self", ",", "i", ",", "x_t", ",", "psnr", ")", "\n", "x_t", "=", "x_t", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "# Calculate Divergence of r_t", "\n", "noise", "=", "generate_noise", "(", "r_t", ".", "shape", ",", "std", "=", "1.", ")", "\n", "div", "=", "(", "noise", "*", "(", "self", ".", "denoiser", "(", "r_t", "+", "eps", "*", "noise", ",", "std", "=", "sigma_hat_t", ".", "item", "(", ")", ")", "-", "\n", "self", ".", "denoiser", "(", "r_t", ",", "std", "=", "sigma_hat_t", ".", "item", "(", ")", ")", ")", "/", "eps", ")", ".", "sum", "(", ")", "\n", "\n", "# Update z_t", "\n", "z_t", "=", "y", "-", "Afun", "(", "x_t", ")", "+", "z_t", "*", "(", "div", "/", "m", ")", "\n", "\n", "_print", "(", "self", ",", "i", ",", "x_t", ",", "sigma_hat_t", ",", "psnr", ")", "\n", "\n", "", "output", "=", "x_t", ".", "view", "(", "1", ",", "self", ".", "H", ",", "self", ".", "W", ")", ".", "cpu", "(", ")", "\n", "return", "output", ",", "psnr", ",", "r_t", ".", "view", "(", "1", ",", "self", ".", "H", ",", "self", ".", "W", ")", ".", "cpu", "(", ")", ",", "sigma_hat_t", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._setup": [[134, 138], ["torch.zeros"], "function", ["None"], ["", "", "def", "_setup", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "image", "is", "not", "None", ":", "\n", "        ", "psnr", "=", "torch", ".", "zeros", "(", "self", ".", "iters", ")", "\n", "", "return", "psnr", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._calc_psnr": [[139, 142], ["util.general.calc_psnr"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.calc_psnr"], ["", "def", "_calc_psnr", "(", "self", ",", "i", ",", "x_t", ",", "psnr", ")", ":", "\n", "    ", "if", "self", ".", "image", "is", "not", "None", ":", "\n", "        ", "psnr", "[", "i", "]", "=", "calc_psnr", "(", "x_t", ",", "self", ".", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.csalgo._print": [[143, 149], ["print", "print"], "function", ["None"], ["", "", "def", "_print", "(", "self", ",", "i", ",", "x_t", ",", "sigma_hat_t", ",", "psnr", ")", ":", "\n", "    ", "if", "self", ".", "verbose", ":", "\n", "        ", "if", "self", ".", "image", "is", "None", ":", "\n", "            ", "print", "(", "'iter {}, approx. std of effective noise {:.3f}'", ".", "format", "(", "i", ",", "sigma_hat_t", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'iter {}, approx. std of effective noise {:.3f}, PSNR {:.3f}'", ".", "format", "(", "i", ",", "sigma_hat_t", ",", "psnr", "[", "i", "]", ")", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.ColoredDnCNN_VDAMP.__init__": [[372, 401], ["torch.device", "dvdamp.ColoredDnCNN_VDAMP._load_models"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.ColoredDnCNN_VDAMP._load_models"], ["def", "__init__", "(", "self", ",", "modeldir", ",", "std_ranges", ",", "channels", "=", "1", ",", "wavetype", "=", "'haar'", ",", "\n", "num_layers", "=", "20", ",", "std_channels", "=", "13", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ",", "\n", "std_pool_func", "=", "np", ".", "mean", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialize ColoredDnCNN_VDAMP\n\n        Args:\n            modeldirs (str): path to directory containing model weights.\n            std_ranges (array): range of noise std for each denoiser.\n                For example, [0, 20, 50, 120, 500] / 255 means that\n                denoiser 1 is for noise with std 0 to 20 / 255.\n                denoiser 2 is for noise with std 20 / 255 to 50 / 255.\n                denoiser 3 is for noise with std 50 / 255 to 120 / 255.\n                denoiser 4 is for noise with std 120 / 255 to 500 / 255.\n            channels (int): number of channels in the model.\n            wavetype (str): type of wavelet transform.\n            num_layers (int): number of layers in the model.\n            std_channels (int): number of std channels for the model i.e.\n                number of wavelet subbands.\n            device: the device to run the model on.\n            std_pool_func (callable): function for pooling the std values in all subbands\n                to determine which denoiser model to use.\n        \"\"\"", "\n", "self", ".", "channels", "=", "channels", "\n", "self", ".", "std_ranges", "=", "std_ranges", "\n", "self", ".", "wavetype", "=", "wavetype", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "models", "=", "self", ".", "_load_models", "(", "modeldir", ",", "num_layers", ",", "std_channels", ")", "\n", "self", ".", "std_pool_func", "=", "std_pool_func", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.ColoredDnCNN_VDAMP.__call__": [[402, 422], ["dvdamp.ColoredDnCNN_VDAMP._denoise", "dvdamp.calc_MC_divergence"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.SoftThresholding_VDAMP._denoise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.calc_MC_divergence"], ["", "def", "__call__", "(", "self", ",", "wavelet", ",", "variances", ",", "gamma", "=", "1.", ",", "calc_divergence", "=", "True", ")", ":", "\n", "        ", "\"\"\"Denoise the wavelet and calculate the divergence\n\n        Args:\n            wavelet (util.transform.Wavelet): the noisy wavelet.\n            variances (array): the variance of noise in each wavelet subband.\n            gamma (float): scaling on the variances.\n\n        Returns:\n            denoised (util.transform.Wavelet): the denoised wavelet.\n            alpha (list): the divergence in each subband.\n        \"\"\"", "\n", "# variances = tutil.reformat_subband2array(variances) * gamma", "\n", "variances", "*=", "gamma", "\n", "denoised", "=", "self", ".", "_denoise", "(", "wavelet", ",", "variances", ")", "\n", "if", "calc_divergence", ":", "\n", "            ", "alpha", "=", "calc_MC_divergence", "(", "self", ".", "_denoise", ",", "denoised", ",", "wavelet", ",", "variances", ")", "\n", "return", "denoised", ",", "alpha", "\n", "", "else", ":", "\n", "            ", "return", "denoised", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.ColoredDnCNN_VDAMP._denoise": [[423, 456], ["torch.no_grad", "wavelet.get_bands", "torch.from_numpy().sqrt().to", "dvdamp.ColoredDnCNN_VDAMP.std_pool_func", "wavelet.inverse().unsqueeze", "numpy.sqrt", "numpy.sum", "print", "noisy_image.to.to.real.to", "util.transform.forward", "torch.from_numpy().sqrt", "wavelet.inverse", "torch.vstack", "noisy_image.to.to.to", "util.transform.forward", "ValueError", "len", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_denoise", "(", "self", ",", "wavelet", ",", "variances", ")", ":", "\n", "        ", "level", "=", "wavelet", ".", "get_bands", "(", ")", "\n", "\n", "# Select the model to use", "\n", "stds", "=", "torch", ".", "from_numpy", "(", "variances", ")", ".", "sqrt", "(", ")", ".", "to", "(", "device", "=", "self", ".", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "std_pooled", "=", "self", ".", "std_pool_func", "(", "np", ".", "sqrt", "(", "variances", ")", ")", "\n", "select", "=", "np", ".", "sum", "(", "std_pooled", ">", "self", ".", "std_ranges", ")", "-", "1", "\n", "if", "select", "<", "0", ":", "\n", "            ", "select", "+=", "1", "\n", "", "elif", "select", ">", "len", "(", "self", ".", "models", ")", "-", "1", ":", "\n", "            ", "select", "-=", "1", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'ColoredDnCNN_VDAMP select: {}'", ".", "format", "(", "select", ")", ")", "\n", "\n", "# Denoise", "\n", "", "noisy_image", "=", "wavelet", ".", "inverse", "(", ")", ".", "unsqueeze", "(", "0", ")", "\n", "if", "self", ".", "channels", "==", "1", ":", "\n", "            ", "noisy_real", "=", "noisy_image", ".", "real", ".", "to", "(", "device", "=", "self", ".", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "noisy_imag", "=", "noisy_image", ".", "imag", "\n", "denoised_real", "=", "self", ".", "models", "[", "select", "]", "(", "noisy_real", ",", "stds", ")", ".", "cpu", "(", ")", "\n", "denoised_imag", "=", "noisy_imag", "*", "0.1", "\n", "denoised_image", "=", "denoised_real", "+", "1j", "*", "denoised_imag", "\n", "denoised_wavelet", "=", "tutil", ".", "forward", "(", "denoised_image", "[", "0", "]", ",", "wavelet", "=", "self", ".", "wavetype", ",", "level", "=", "level", ")", "\n", "", "elif", "self", ".", "channels", "==", "2", ":", "\n", "            ", "noisy_image", "=", "torch", ".", "vstack", "(", "[", "noisy_image", ".", "real", ",", "noisy_image", ".", "imag", "]", ")", "\n", "noisy_image", "=", "noisy_image", ".", "to", "(", "device", "=", "self", ".", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "denoised_image", "=", "self", ".", "models", "[", "select", "]", "(", "noisy_image", ",", "stds", ")", ".", "cpu", "(", ")", "\n", "denoised_image", "=", "denoised_image", "[", "0", "]", "+", "1j", "*", "denoised_image", "[", "1", "]", "\n", "denoised_wavelet", "=", "tutil", ".", "forward", "(", "denoised_image", ",", "wavelet", "=", "self", ".", "wavetype", ",", "level", "=", "level", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Only support channel == 1 or 2.'", ")", "\n", "", "return", "denoised_wavelet", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.ColoredDnCNN_VDAMP._load_models": [[457, 466], ["enumerate", "len", "algorithm.denoiser.ColoredDnCNN", "util.general.load_checkpoint", "algorithm.denoiser.ColoredDnCNN.to", "algorithm.denoiser.ColoredDnCNN.eval"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.load_checkpoint", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve.eval"], ["", "def", "_load_models", "(", "self", ",", "modeldirs", ",", "num_layers", ",", "std_channels", ")", ":", "\n", "        ", "models", "=", "[", "None", "]", "*", "len", "(", "modeldirs", ")", "\n", "for", "i", ",", "modeldir", "in", "enumerate", "(", "modeldirs", ")", ":", "\n", "            ", "model", "=", "ColoredDnCNN", "(", "channels", "=", "self", ".", "channels", ",", "num_layers", "=", "num_layers", ",", "std_channels", "=", "std_channels", ")", "\n", "load_checkpoint", "(", "modeldir", ",", "model", ",", "None", ",", "device", "=", "self", ".", "device", ")", "\n", "model", ".", "to", "(", "device", "=", "self", ".", "device", ")", "\n", "model", ".", "eval", "(", ")", "\n", "models", "[", "i", "]", "=", "model", "\n", "", "return", "models", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.BM3D_VDAMP.__init__": [[469, 483], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "channels", ",", "wavetype", "=", "'haar'", ",", "std_pool_func", "=", "np", ".", "max", ")", ":", "\n", "        ", "\"\"\"Initialize BM3D_VDAMP\n\n        Args:\n            channels (int): number of channels to apply BM3D.\n                If channels == 1, apply BM3D to the real part and scale the imaginary part by 0.1.\n                If channels == 2, apply BM3D to both real and imaginary parts seperately.\n            wavetype (str): type of wavelet transform.\n            std_pool_func (callable): function for pooling the std values in all subbands\n                to determine which denoiser model to use.\n        \"\"\"", "\n", "self", ".", "channels", "=", "channels", "\n", "self", ".", "std_pool_func", "=", "std_pool_func", "\n", "self", ".", "wavetype", "=", "wavetype", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.BM3D_VDAMP.__call__": [[484, 502], ["dvdamp.BM3D_VDAMP._denoise", "dvdamp.calc_MC_divergence"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.SoftThresholding_VDAMP._denoise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.calc_MC_divergence"], ["", "def", "__call__", "(", "self", ",", "wavelet", ",", "variances", ",", "calc_divergence", "=", "True", ")", ":", "\n", "        ", "\"\"\"Denoise the wavelet and calculate the divergence\n\n        Args:\n            wavelet (util.transform.Wavelet): the noisy wavelet.\n            variances (array): the variance of noise in each wavelet subband.\n\n        Returns:\n            denoised (util.transform.Wavelet): the denoised wavelet.\n            alpha (list): the divergence in each subband.\n        \"\"\"", "\n", "# variances = tutil.reformat_subband2array(variances)", "\n", "denoised", "=", "self", ".", "_denoise", "(", "wavelet", ",", "variances", ")", "\n", "if", "calc_divergence", ":", "\n", "            ", "alpha", "=", "calc_MC_divergence", "(", "self", ".", "_denoise", ",", "denoised", ",", "wavelet", ",", "variances", ")", "\n", "return", "denoised", ",", "alpha", "\n", "", "else", ":", "\n", "            ", "return", "denoised", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.BM3D_VDAMP._denoise": [[503, 524], ["wavelet.get_bands", "dvdamp.BM3D_VDAMP.std_pool_func", "wavelet.inverse", "numpy.sqrt", "torch.Tensor", "util.transform.forward", "bm3d.bm3d.bm3d", "torch.Tensor", "torch.Tensor", "util.transform.forward", "ValueError", "bm3d.bm3d.bm3d", "bm3d.bm3d.bm3d"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward"], ["", "", "def", "_denoise", "(", "self", ",", "wavelet", ",", "variances", ")", ":", "\n", "        ", "level", "=", "wavelet", ".", "get_bands", "(", ")", "\n", "std_pooled", "=", "self", ".", "std_pool_func", "(", "np", ".", "sqrt", "(", "variances", ")", ")", "\n", "noisy_image", "=", "wavelet", ".", "inverse", "(", ")", "\n", "if", "self", ".", "channels", "==", "1", ":", "\n", "            ", "noisy_real", "=", "noisy_image", ".", "real", "\n", "noisy_imag", "=", "noisy_image", ".", "imag", "\n", "denoised_real", "=", "torch", ".", "Tensor", "(", "bm3d", "(", "noisy_real", ",", "std_pooled", ")", ")", "\n", "denoised_imag", "=", "noisy_imag", "*", "0.1", "\n", "denoised_image", "=", "denoised_real", "+", "1j", "*", "denoised_imag", "\n", "denoised_wavelet", "=", "tutil", ".", "forward", "(", "denoised_image", ",", "wavelet", "=", "self", ".", "wavetype", ",", "level", "=", "level", ")", "\n", "", "elif", "self", ".", "channels", "==", "2", ":", "\n", "            ", "noisy_real", "=", "noisy_image", ".", "real", "\n", "noisy_imag", "=", "noisy_image", ".", "imag", "\n", "denoised_real", "=", "torch", ".", "Tensor", "(", "bm3d", "(", "noisy_real", ",", "std_pooled", ")", ")", "\n", "denoised_imag", "=", "torch", ".", "Tensor", "(", "bm3d", "(", "noisy_imag", ",", "std_pooled", ")", ")", "\n", "denoised_image", "=", "denoised_real", "+", "1j", "*", "denoised_imag", "\n", "denoised_wavelet", "=", "tutil", ".", "forward", "(", "denoised_image", ",", "wavelet", "=", "self", ".", "wavetype", ",", "level", "=", "level", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Only support channel == 1 or 2.'", ")", "\n", "", "return", "denoised_wavelet", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.SoftThresholding_VDAMP.__init__": [[536, 547], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "MC_divergence", ",", "debug", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialize SoftThresholding_VDAMP\n\n        Args:\n            MC_divergence (bool): whether to calculate the divergence with the \n                Monte Carlo approach (True) or analytically (False).\n            debug (bool): whether to calculate the analytical divergence as well\n                for comparison when MC_divergence is True.\n        \"\"\"", "\n", "self", ".", "MC_divergence", "=", "MC_divergence", "\n", "self", ".", "debug", "=", "debug", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.SoftThresholding_VDAMP.__call__": [[548, 565], ["util.transform.reformat_array2subband", "dvdamp.multiscaleSureSoft", "dvdamp.calc_MC_divergence", "dvdamp.SoftThresholding_VDAMP._calc_ana_div", "dvdamp.SoftThresholding_VDAMP._calc_ana_div", "util.transform.reformat_subband2array", "util.transform.reformat_subband2array", "print"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.reformat_array2subband", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.multiscaleSureSoft", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.calc_MC_divergence", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.SoftThresholding_VDAMP._calc_ana_div", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.SoftThresholding_VDAMP._calc_ana_div", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.reformat_subband2array", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.reformat_subband2array"], ["", "def", "__call__", "(", "self", ",", "wavelet", ",", "variances", ",", "calc_divergence", "=", "True", ")", ":", "\n", "        ", "variances", "=", "tutil", ".", "reformat_array2subband", "(", "variances", ")", "\n", "denoised", ",", "df", ",", "_", "=", "multiscaleSureSoft", "(", "wavelet", ",", "variances", ")", "\n", "if", "calc_divergence", ":", "\n", "            ", "if", "self", ".", "MC_divergence", ":", "\n", "                ", "alpha", "=", "calc_MC_divergence", "(", "self", ".", "_denoise", ",", "denoised", ",", "wavelet", ",", "variances", ")", "\n", "if", "self", ".", "debug", ":", "\n", "                    ", "alpha_ana", "=", "self", ".", "_calc_ana_div", "(", "df", ")", "\n", "alpha_array", "=", "tutil", ".", "reformat_subband2array", "(", "alpha", ")", "\n", "alpha_ana_array", "=", "tutil", ".", "reformat_subband2array", "(", "alpha_ana", ")", "\n", "error", "=", "(", "(", "alpha_array", "-", "alpha_ana_array", ")", "/", "alpha_ana_array", "*", "100", ")", ".", "mean", "(", ")", "\n", "print", "(", "'MC div error: {} %'", ".", "format", "(", "error", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "alpha", "=", "self", ".", "_calc_ana_div", "(", "df", ")", "\n", "", "return", "denoised", ",", "alpha", "\n", "", "else", ":", "\n", "            ", "return", "denoised", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.SoftThresholding_VDAMP._denoise": [[567, 570], ["dvdamp.multiscaleSureSoft"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.multiscaleSureSoft"], ["", "", "def", "_denoise", "(", "self", ",", "wavelet", ",", "variances", ")", ":", "\n", "        ", "denoised", ",", "_", ",", "_", "=", "multiscaleSureSoft", "(", "wavelet", ",", "variances", ")", "\n", "return", "denoised", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.SoftThresholding_VDAMP._calc_ana_div": [[571, 581], ["range", "len", "numpy.mean", "range", "numpy.mean"], "methods", ["None"], ["", "def", "_calc_ana_div", "(", "self", ",", "df", ")", ":", "\n", "        ", "level", "=", "len", "(", "df", ")", "-", "1", "\n", "alpha", "=", "[", "None", "]", "*", "(", "level", "+", "1", ")", "\n", "alpha", "[", "0", "]", "=", "np", ".", "mean", "(", "df", "[", "0", "]", ")", "/", "2", "\n", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "            ", "alpha_b", "=", "[", "None", "]", "*", "3", "\n", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "                ", "alpha_b", "[", "s", "]", "=", "np", ".", "mean", "(", "df", "[", "b", "+", "1", "]", "[", "s", "]", ")", "/", "2", "\n", "", "alpha", "[", "b", "+", "1", "]", "=", "alpha_b", "\n", "", "return", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.dvdamp": [[40, 177], ["dvdamp.calc_wavespec", "dvdamp.calc_wavespec", "util.transform.forward", "range", "tutil.add.pyramid_forward", "range", "util.transform.forward", "util.transform.ifftnc", "denoiser", "w_hat.inverse", "tutil.add.pyramid_forward", "w_hat.pyramid_forward", "range", "util.transform.Wavelet", "util.transform.add", "range", "numpy.zeros", "numpy.zeros", "numpy.zeros", "util.transform.reformat_subband2array", "util.transform.ifftnc", "dvdamp._calc_mse", "dvdamp._calc_pred_mse", "numpy.sum", "numpy.sum", "range", "util.transform.forward", "specY[].reshape", "util.transform.fftnc", "util.transform.ifftnc", "numpy.abs", "specX[].reshape", "specY[].reshape", "specY[].reshape", "specY[].reshape", "numpy.sum", "numpy.sum", "tutil.Wavelet.inverse", "specY[].reshape", "specX[].reshape", "specX[].reshape", "specX[].reshape", "util.transform.fftnc", "numpy.abs", "specX[].reshape", "specY[].reshape", "specY[].reshape", "specY[].reshape", "specX[].reshape", "specX[].reshape", "specX[].reshape"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.calc_wavespec", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.calc_wavespec", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.ifftnc", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.add", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.reformat_subband2array", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.ifftnc", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp._calc_mse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp._calc_pred_mse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.fftnc", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.ifftnc", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.fftnc"], ["def", "dvdamp", "(", "y", ",", "\n", "prob_map", ",", "\n", "mask", ",", "\n", "var0", ",", "\n", "denoiser", ",", "\n", "image", "=", "None", ",", "\n", "iters", "=", "30", ",", "\n", "level", "=", "4", ",", "\n", "wavetype", "=", "'haar'", ",", "\n", "stop_on_increase", "=", "True", ")", ":", "\n", "    ", "\"\"\"Perform VDAMP\n\n    Args:\n        y (np.ndarray, (H, W)): MRI measurement.\n        prob_map (np.ndarray, (H, W)): sampling probability map.\n        mask (np.ndarray, (H, W)): sampling mask generated from prob_map.\n        var0 (float): variance of measurement noise.\n        image (np.ndarray, (H, W)): Ground truth image.\n        iters (int): number of iterations.\n        level (int): number of levels for wavelet transform.\n        wavetype (str): wavelet type. Refer to pywt for options.\n        stop_on_increase (bool): whether to stop D-VDAMP when the predicted MSE increases.\n\n    Returns:\n        x_hat (np.ndarray, (H, W)): reconstructed image.\n        log (dict): reconstruction log, containing reconstructed image (x_hat),\n            wavelet pyramids before (r) and after thresholding (w_hat), and\n            true (err) and estimated (tau) RMSE of effective noise for each iteration.\n        true_iter (int): actual number of iterations before stopping. This is equal to\n            iters if stop_on_increase is False.\n\n    Notes:\n        The algorithm is Algorithm 1 described in\n\n            C. A. Metzler and G. Wetzstein, \"D-VDAMP: Denoising-Based Approximate Message Passing\n            for Compressive MRI,\" ICASSP 2021 - 2021 IEEE International Conference on Acoustics, \n            Speech and Signal Processing (ICASSP), 2021, pp. 1410-1414, doi: 10.1109/ICASSP39728.2021.9414708.\n\n        This function follows the MATLAB code of VDAMP closely with the soft-thresholding denoiser\n        changed to a generic denoiser.\n\n            Charles Millard, Aaron T Hess, Boris Mailhe, and Jared Tanner, \n            \u201cApproximate message passing with a colored aliasing model for variable density \n            fourier sampled images,\u201d arXiv preprint arXiv:2003.02701, 2020.\n    \"\"\"", "\n", "\n", "# Precompute", "\n", "H", ",", "W", "=", "y", ".", "shape", "\n", "specX", "=", "calc_wavespec", "(", "H", ",", "level", ")", "\n", "specY", "=", "calc_wavespec", "(", "W", ",", "level", ")", "\n", "Pinv", "=", "1", "/", "prob_map", "# Pinv is element-wise inverse", "\n", "Pinvm1", "=", "Pinv", "-", "1", "\n", "if", "image", "is", "not", "None", ":", "\n", "        ", "w0", "=", "tutil", ".", "forward", "(", "image", ",", "wavelet", "=", "wavetype", ",", "level", "=", "level", ")", "\n", "log", "=", "{", "\n", "'x_hat'", ":", "np", ".", "zeros", "(", "(", "iters", ",", "H", ",", "W", ")", ",", "dtype", "=", "complex", ")", ",", "\n", "'r'", ":", "np", ".", "zeros", "(", "(", "iters", ",", "H", ",", "W", ")", ",", "dtype", "=", "complex", ")", ",", "\n", "'w_hat'", ":", "np", ".", "zeros", "(", "(", "iters", ",", "H", ",", "W", ")", ",", "dtype", "=", "complex", ")", ",", "\n", "'err'", ":", "[", "None", "]", "*", "iters", ",", "\n", "'tau'", ":", "[", "None", "]", "*", "iters", "\n", "}", "\n", "\n", "# Initialize", "\n", "", "r", "=", "tutil", ".", "forward", "(", "tutil", ".", "ifftnc", "(", "Pinv", "*", "mask", "*", "y", ")", ",", "wavelet", "=", "wavetype", ",", "level", "=", "level", ")", "\n", "tau_y", "=", "mask", "*", "Pinv", "*", "(", "Pinvm1", "*", "np", ".", "abs", "(", "y", ")", "**", "2", "+", "var0", ")", "\n", "tau", "=", "[", "None", "]", "*", "(", "level", "+", "1", ")", "\n", "tau", "[", "0", "]", "=", "(", "specX", "[", ":", ",", "0", ",", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "@", "tau_y", "@", "specY", "[", ":", ",", "0", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "item", "(", ")", "\n", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "        ", "tau_b", "=", "[", "None", "]", "*", "3", "\n", "tau_b", "[", "0", "]", "=", "(", "specX", "[", ":", ",", "b", ",", "1", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "@", "tau_y", "@", "specY", "[", ":", ",", "b", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "item", "(", ")", "\n", "tau_b", "[", "1", "]", "=", "(", "specX", "[", ":", ",", "b", ",", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "@", "tau_y", "@", "specY", "[", ":", ",", "b", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "item", "(", ")", "\n", "tau_b", "[", "2", "]", "=", "(", "specX", "[", ":", ",", "b", ",", "1", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "@", "tau_y", "@", "specY", "[", ":", ",", "b", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "item", "(", ")", "\n", "tau", "[", "b", "+", "1", "]", "=", "tau_b", "\n", "", "pred_MSE_prev_iter", "=", "np", ".", "inf", "\n", "true_iters", "=", "0", "\n", "\n", "_", ",", "slices", "=", "r", ".", "pyramid_forward", "(", "get_slices", "=", "True", ")", "\n", "log", "[", "'slices'", "]", "=", "slices", "\n", "\n", "# Loop", "\n", "for", "it", "in", "range", "(", "iters", ")", ":", "\n", "\n", "# Thresholding", "\n", "        ", "w_hat", ",", "alpha", "=", "denoiser", "(", "r", ",", "tutil", ".", "reformat_subband2array", "(", "tau", ")", ")", "\n", "\n", "# Calculate x_hat", "\n", "# x_hat = w_hat.inverse(to_tensor=False)", "\n", "x_tilde", "=", "w_hat", ".", "inverse", "(", "to_tensor", "=", "False", ")", "\n", "x_hat", "=", "x_tilde", "+", "tutil", ".", "ifftnc", "(", "mask", "*", "(", "y", "-", "tutil", ".", "fftnc", "(", "x_tilde", ")", ")", ")", "\n", "\n", "log", "[", "'r'", "]", "[", "it", "]", "=", "r", ".", "pyramid_forward", "(", "to_tensor", "=", "False", ")", "\n", "log", "[", "'w_hat'", "]", "[", "it", "]", "=", "w_hat", ".", "pyramid_forward", "(", "to_tensor", "=", "False", ")", "\n", "log", "[", "'x_hat'", "]", "[", "it", "]", "=", "x_hat", "\n", "log", "[", "'tau'", "]", "[", "it", "]", "=", "tau", "\n", "if", "image", "is", "not", "None", ":", "\n", "            ", "log", "[", "'err'", "]", "[", "it", "]", "=", "_calc_mse", "(", "r", ",", "w0", ")", "\n", "\n", "", "if", "stop_on_increase", ":", "\n", "            ", "true_iters", "+=", "1", "\n", "pred_MSE_this_iter", "=", "_calc_pred_mse", "(", "tau", ",", "level", ")", "\n", "if", "pred_MSE_this_iter", ">", "pred_MSE_prev_iter", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "pred_MSE_prev_iter", "=", "pred_MSE_this_iter", "\n", "", "", "else", ":", "\n", "            ", "true_iters", "+=", "1", "\n", "\n", "# Onsager correction", "\n", "", "w_tilde_coeff", "=", "[", "None", "]", "*", "(", "level", "+", "1", ")", "\n", "w_tilde_coeff", "[", "0", "]", "=", "w_hat", ".", "coeff", "[", "0", "]", "-", "alpha", "[", "0", "]", "*", "r", ".", "coeff", "[", "0", "]", "\n", "w_div", "=", "np", ".", "sum", "(", "r", ".", "coeff", "[", "0", "]", "*", "w_tilde_coeff", "[", "0", "]", ")", "/", "(", "np", ".", "sum", "(", "w_tilde_coeff", "[", "0", "]", "**", "2", ")", ")", "\n", "w_tilde_coeff", "[", "0", "]", "*=", "w_div", "\n", "for", "b", "in", "range", "(", "1", ",", "level", "+", "1", ")", ":", "\n", "            ", "w_tilde_coeff_b", "=", "[", "None", "]", "*", "3", "\n", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "                ", "w_tilde_coeff_b", "[", "s", "]", "=", "w_hat", ".", "coeff", "[", "b", "]", "[", "s", "]", "-", "alpha", "[", "b", "]", "[", "s", "]", "*", "r", ".", "coeff", "[", "b", "]", "[", "s", "]", "\n", "w_div", "=", "np", ".", "sum", "(", "r", ".", "coeff", "[", "b", "]", "[", "s", "]", "*", "w_tilde_coeff_b", "[", "s", "]", ")", "/", "(", "np", ".", "sum", "(", "w_tilde_coeff_b", "[", "s", "]", "**", "2", ")", ")", "\n", "w_tilde_coeff_b", "[", "s", "]", "*=", "w_div", "\n", "", "w_tilde_coeff", "[", "b", "]", "=", "w_tilde_coeff_b", "\n", "", "w_tilde", "=", "tutil", ".", "Wavelet", "(", "w_tilde_coeff", ")", "\n", "\n", "# Reweighted gradient step", "\n", "z", "=", "mask", "*", "(", "y", "-", "tutil", ".", "fftnc", "(", "w_tilde", ".", "inverse", "(", "to_tensor", "=", "False", ")", ")", ")", "\n", "r", "=", "tutil", ".", "add", "(", "w_tilde", ",", "tutil", ".", "forward", "(", "tutil", ".", "ifftnc", "(", "Pinv", "*", "z", ")", ",", "wavelet", "=", "wavetype", ",", "level", "=", "level", ")", ")", "\n", "\n", "# Noise power re-estimation", "\n", "tau_y", "=", "mask", "*", "Pinv", "*", "(", "Pinvm1", "*", "np", ".", "abs", "(", "z", ")", "**", "2", "+", "var0", ")", "\n", "tau", "=", "[", "None", "]", "*", "(", "level", "+", "1", ")", "\n", "tau", "[", "0", "]", "=", "(", "specX", "[", ":", ",", "0", ",", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "@", "tau_y", "@", "specY", "[", ":", ",", "0", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "item", "(", ")", "\n", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "            ", "tau_b", "=", "[", "None", "]", "*", "3", "\n", "tau_b", "[", "0", "]", "=", "(", "specX", "[", ":", ",", "b", ",", "1", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "@", "tau_y", "@", "specY", "[", ":", ",", "b", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "item", "(", ")", "\n", "tau_b", "[", "1", "]", "=", "(", "specX", "[", ":", ",", "b", ",", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "@", "tau_y", "@", "specY", "[", ":", ",", "b", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "item", "(", ")", "\n", "tau_b", "[", "2", "]", "=", "(", "specX", "[", ":", ",", "b", ",", "1", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "@", "tau_y", "@", "specY", "[", ":", ",", "b", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "item", "(", ")", "\n", "tau", "[", "b", "+", "1", "]", "=", "tau_b", "\n", "\n", "", "", "return", "x_hat", ",", "log", ",", "true_iters", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp._calc_mse": [[178, 196], ["numpy.mean", "range", "range", "test.get_bands", "numpy.abs", "test.get_bands", "numpy.mean", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands"], ["", "def", "_calc_mse", "(", "test", ",", "ref", ")", ":", "\n", "    ", "\"\"\"Calculate band-wise mean squared error (MSE).\n\n    Args:\n        test (util.transform.Wavelet): noisy (test) wavelet.\n        ref (util.transform.Wavelet): ground truth (reference) wavelet.\n\n    Returns:\n        mse (list): list of MSE in the \"wavelet\" format.\n    \"\"\"", "\n", "mse", "=", "[", "None", "]", "*", "(", "test", ".", "get_bands", "(", ")", "+", "1", ")", "\n", "mse", "[", "0", "]", "=", "np", ".", "mean", "(", "np", ".", "abs", "(", "test", ".", "coeff", "[", "0", "]", "-", "ref", ".", "coeff", "[", "0", "]", ")", "**", "2", ")", "\n", "for", "b", "in", "range", "(", "1", ",", "test", ".", "get_bands", "(", ")", "+", "1", ")", ":", "\n", "        ", "mse_band", "=", "[", "None", "]", "*", "3", "\n", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "            ", "mse_band", "[", "s", "]", "=", "np", ".", "mean", "(", "np", ".", "abs", "(", "test", ".", "coeff", "[", "b", "]", "[", "s", "]", "-", "ref", ".", "coeff", "[", "b", "]", "[", "s", "]", ")", "**", "2", ")", "\n", "", "mse", "[", "b", "]", "=", "mse_band", "\n", "", "return", "mse", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp._calc_pred_mse": [[197, 217], ["range", "range"], "function", ["None"], ["", "def", "_calc_pred_mse", "(", "tau", ",", "level", ")", ":", "\n", "    ", "\"\"\"Calculate a scaled predicted MSE based on \n    the predicted noise variance and the level of wavelet decomposition.\n\n    Args:\n        tau (list): predicted noise variance in each subband in the \"wavelet\" format.\n\n    Returns:\n        pred_mse (float): scaled predicted MSE.\n\n    Note:\n        The predicted MSE is used to determine whether to stop D-VDAMP early.\n    \"\"\"", "\n", "pred_mse", "=", "0", "\n", "pred_mse", "+=", "tau", "[", "0", "]", "*", "(", "4", "**", "(", "-", "level", ")", ")", "\n", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "        ", "weight", "=", "4", "**", "(", "b", "-", "level", ")", "\n", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "            ", "pred_mse", "+=", "tau", "[", "b", "+", "1", "]", "[", "s", "]", "*", "weight", "\n", "", "", "return", "pred_mse", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.calc_wavespec": [[218, 253], ["util.transform.Wavelet_bank", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.abs", "numpy.abs", "numpy.fft.fftshift", "torch.from_numpy().flip().to", "numpy.flip", "len", "len", "numpy.fft.fft", "numpy.fft.fft", "numpy.transpose().reshape", "numpy.transpose().reshape", "torch.from_numpy().flip", "numpy.transpose", "numpy.transpose", "torch.from_numpy", "spec[].reshape", "numpy.ones", "spec[].reshape", "numpy.ones"], "function", ["None"], ["", "def", "calc_wavespec", "(", "numsamples", ",", "level", ",", "wavetype", "=", "'haar'", ",", "ret_tensor", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculate power spectrum of wavelet decomposition kernels.\n\n    Returns:\n        spec: (numsamples, level, [lowpass, highpass]) power spectrum.\n            In axis=1 (level), higher indices mean larger scales.\n    \"\"\"", "\n", "\n", "wavelet", "=", "tutil", ".", "Wavelet_bank", "(", "wavetype", ")", "\n", "spec", "=", "np", ".", "zeros", "(", "[", "numsamples", ",", "level", ",", "2", "]", ")", "\n", "\n", "# Zero-pad decomposition filters", "\n", "L", "=", "np", ".", "zeros", "(", "numsamples", ")", "\n", "L", "[", "0", ":", "len", "(", "wavelet", ".", "dec_lo", ")", "]", "=", "wavelet", ".", "dec_lo", "\n", "H", "=", "np", ".", "zeros", "(", "numsamples", ")", "\n", "H", "[", "0", ":", "len", "(", "wavelet", ".", "dec_hi", ")", "]", "=", "wavelet", ".", "dec_hi", "\n", "\n", "# Spectrum of the largest scale", "\n", "spec", "[", ":", ",", "0", ",", "0", "]", "=", "np", ".", "abs", "(", "fft", ".", "fft", "(", "L", ")", ")", "**", "2", "\n", "spec", "[", ":", ",", "0", ",", "1", "]", "=", "np", ".", "abs", "(", "fft", ".", "fft", "(", "H", ")", ")", "**", "2", "\n", "\n", "# Spectrum of other scales", "\n", "numblock", "=", "1", "\n", "for", "s", "in", "range", "(", "1", ",", "level", ")", ":", "\n", "        ", "numblock", "*=", "2", "\n", "spec", "[", ":", ",", "s", ",", "0", "]", "=", "spec", "[", ":", ",", "s", "-", "1", ",", "0", "]", "*", "np", ".", "transpose", "(", "spec", "[", ":", ":", "numblock", ",", "0", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "@", "np", ".", "ones", "(", "[", "1", ",", "numblock", "]", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "spec", "[", ":", ",", "s", ",", "1", "]", "=", "spec", "[", ":", ",", "s", "-", "1", ",", "0", "]", "*", "np", ".", "transpose", "(", "spec", "[", ":", ":", "numblock", ",", "0", ",", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "@", "np", ".", "ones", "(", "[", "1", ",", "numblock", "]", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "", "spec", "=", "fft", ".", "fftshift", "(", "spec", ",", "axes", "=", "0", ")", "/", "numsamples", "\n", "\n", "if", "ret_tensor", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "spec", ")", ".", "flip", "(", "1", ")", ".", "to", "(", "torch", ".", "float32", ")", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "flip", "(", "spec", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.gen_pdf": [[256, 322], ["numpy.floor", "numpy.meshgrid", "numpy.where", "range", "numpy.linspace", "numpy.linspace", "numpy.maximum", "numpy.floor", "RuntimeError", "numpy.floor", "torch.from_numpy().to", "numpy.abs", "numpy.abs", "numpy.sqrt", "numpy.max", "ValueError", "numpy.ones_like", "numpy.sum", "numpy.sum", "numpy.abs", "numpy.ones_like", "numpy.where", "torch.from_numpy", "numpy.ones_like", "RuntimeError"], "function", ["None"], ["def", "gen_pdf", "(", "shape", ",", "sampling_rate", ",", "p", "=", "8", ",", "dist_type", "=", "'l2'", ",", "radius", "=", "0.", ",", "ret_tensor", "=", "False", ")", ":", "\n", "    ", "\"\"\"Generate probability density function (PDF) for variable density undersampling masking in MRI simulation\n\n    Args:\n        shape: shape of image\n        sampling_rate (float): ratio of sampled pixels to ground truth pixels (n/N)\n        p (int): polynomial power\n        dist_type (str): distance type - l1 or l2\n        radius (float): radius of fully sampled center\n\n    Returns:\n        pdf (np.ndarray): the desired PDF (sampling probability map)\n\n    Notes:\n        This is the Python implementation of the genPDF function from the SparseMRI package.\n        (http://people.eecs.berkeley.edu/~mlustig/Software.html). The sampling scheme is described\n        in the paper M. Lustig, D.L Donoho and J.M Pauly \u201cSparse MRI: The Application of Compressed\n        Sensing for Rapid MR Imaging\u201d Magnetic Resonance in Medicine, 2007 Dec; 58(6):1182-1195.\n\n    \"\"\"", "\n", "C", ",", "H", ",", "W", "=", "shape", "\n", "\n", "num_samples", "=", "np", ".", "floor", "(", "sampling_rate", "*", "H", "*", "W", ")", "\n", "\n", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "np", ".", "linspace", "(", "-", "1", ",", "1", ",", "H", ")", ",", "np", ".", "linspace", "(", "-", "1", ",", "1", ",", "W", ")", ")", "\n", "if", "dist_type", "==", "'l1'", ":", "\n", "        ", "r", "=", "np", ".", "maximum", "(", "np", ".", "abs", "(", "x", ")", ",", "np", ".", "abs", "(", "y", ")", ")", "\n", "", "elif", "dist_type", "==", "'l2'", ":", "\n", "        ", "r", "=", "np", ".", "sqrt", "(", "x", "**", "2", "+", "y", "**", "2", ")", "\n", "r", "/=", "np", ".", "max", "(", "np", ".", "abs", "(", "r", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'genPDF: invalid dist_type'", ")", "\n", "\n", "", "idx", "=", "np", ".", "where", "(", "r", "<", "radius", ")", "\n", "\n", "pdf", "=", "(", "np", ".", "ones_like", "(", "r", ")", "-", "r", ")", "**", "p", "\n", "pdf", "[", "idx", "]", "=", "1", "\n", "\n", "if", "np", ".", "floor", "(", "np", ".", "sum", "(", "pdf", ")", ")", ">", "num_samples", ":", "\n", "        ", "raise", "RuntimeError", "(", "'genPDF: infeasible without undersampling dc, increase p'", ")", "\n", "\n", "# Bisection", "\n", "", "minval", "=", "0", "\n", "maxval", "=", "1", "\n", "val", "=", "0.5", "\n", "it", "=", "0", "\n", "for", "_", "in", "range", "(", "20", ")", ":", "\n", "        ", "it", "+=", "1", "\n", "val", "=", "(", "minval", "+", "maxval", ")", "/", "2", "\n", "pdf", "=", "(", "np", ".", "ones_like", "(", "r", ")", "-", "r", ")", "**", "p", "+", "val", "*", "np", ".", "ones_like", "(", "r", ")", "\n", "pdf", "[", "np", ".", "where", "(", "pdf", ">", "1", ")", "]", "=", "1", "\n", "pdf", "[", "idx", "]", "=", "1", "\n", "N", "=", "np", ".", "floor", "(", "np", ".", "sum", "(", "pdf", ")", ")", "\n", "if", "N", ">", "num_samples", ":", "# Infeasible", "\n", "            ", "maxval", "=", "val", "\n", "", "elif", "N", "<", "num_samples", ":", "# Feasible, but not optimal", "\n", "            ", "minval", "=", "val", "\n", "", "elif", "N", "==", "num_samples", ":", "# Optimal", "\n", "            ", "break", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "'genPDF: error with calculation of N'", ")", "\n", "\n", "", "", "if", "ret_tensor", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "pdf", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "else", ":", "\n", "        ", "return", "pdf", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.calc_MC_divergence": [[325, 358], ["wavelet.get_bands", "wavelet.copy", "denoiser", "range", "numpy.abs", "numpy.random.randn", "range", "wavelet.copy.coeff[].max", "numpy.random.randn", "wavelet.copy", "denoiser", "numpy.dot", "numpy.dot", "numpy.abs", "numpy.random.randn", "numpy.real().reshape", "numpy.imag().reshape", "[].max", "numpy.random.randn", "numpy.real().reshape", "numpy.imag().reshape", "numpy.dot", "numpy.dot", "numpy.real", "numpy.imag", "numpy.real().reshape", "numpy.imag().reshape", "numpy.real", "numpy.imag", "numpy.real().reshape", "numpy.imag().reshape", "numpy.real", "numpy.imag", "numpy.real", "numpy.imag"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.copy", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.copy", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.real", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.imag", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.real", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.imag", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.real", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.imag", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.real", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.imag"], ["def", "calc_MC_divergence", "(", "denoiser", ",", "denoised", ",", "wavelet", ",", "variances", ")", ":", "\n", "    ", "\"\"\"Calculate the divergence required by D-VDAMP using a Monte Carlo approach.\n\n    Note:\n        See section 2.1 of Metzler and Wetzstein 2020, \"D-VDAMP: Denoising-Based Approximate Message Passing\n        for Compressive MRI\" for the equation.\n    \"\"\"", "\n", "level", "=", "wavelet", ".", "get_bands", "(", ")", "\n", "alpha", "=", "[", "None", "]", "*", "(", "level", "+", "1", ")", "\n", "wavelet_jittered", "=", "wavelet", ".", "copy", "(", ")", "\n", "eta", "=", "np", ".", "abs", "(", "wavelet_jittered", ".", "coeff", "[", "0", "]", ".", "max", "(", ")", ")", "/", "1000.", "\n", "noise_vec", "=", "np", ".", "random", ".", "randn", "(", "*", "wavelet_jittered", ".", "coeff", "[", "0", "]", ".", "shape", ")", "+", "1j", "*", "np", ".", "random", ".", "randn", "(", "*", "wavelet_jittered", ".", "coeff", "[", "0", "]", ".", "shape", ")", "\n", "wavelet_jittered", ".", "coeff", "[", "0", "]", "+=", "eta", "*", "noise_vec", "\n", "denoised_jittered", "=", "denoiser", "(", "wavelet_jittered", ",", "variances", ")", "\n", "alpha", "[", "0", "]", "=", "0.5", "*", "(", "\n", "1.", "/", "wavelet_jittered", ".", "coeff", "[", "0", "]", ".", "size", "*", "np", ".", "dot", "(", "np", ".", "real", "(", "noise_vec", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "np", ".", "real", "(", "denoised_jittered", ".", "coeff", "[", "0", "]", "-", "denoised", ".", "coeff", "[", "0", "]", ")", ".", "reshape", "(", "-", "1", ")", "/", "eta", ")", "+", "# real part", "\n", "1.", "/", "wavelet_jittered", ".", "coeff", "[", "0", "]", ".", "size", "*", "np", ".", "dot", "(", "np", ".", "imag", "(", "noise_vec", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "np", ".", "imag", "(", "denoised_jittered", ".", "coeff", "[", "0", "]", "-", "denoised", ".", "coeff", "[", "0", "]", ")", ".", "reshape", "(", "-", "1", ")", "/", "eta", ")", ")", "# img part", "\n", "for", "s", "in", "range", "(", "level", ")", ":", "\n", "        ", "alpha", "[", "s", "+", "1", "]", "=", "3", "*", "[", "None", "]", "\n", "for", "b", "in", "range", "(", "3", ")", ":", "\n", "            ", "wavelet_jittered", "=", "wavelet", ".", "copy", "(", ")", "\n", "eta", "=", "np", ".", "abs", "(", "wavelet_jittered", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", ".", "max", "(", ")", ")", "/", "1000.", "\n", "noise_vec", "=", "np", ".", "random", ".", "randn", "(", "*", "wavelet_jittered", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", ".", "shape", ")", "+", "1j", "*", "np", ".", "random", ".", "randn", "(", "*", "wavelet_jittered", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", ".", "shape", ")", "\n", "wavelet_jittered", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", "+=", "eta", "*", "noise_vec", "\n", "denoised_jittered", "=", "denoiser", "(", "wavelet_jittered", ",", "variances", ")", "\n", "alpha", "[", "s", "+", "1", "]", "[", "b", "]", "=", "0.5", "*", "(", "\n", "1.", "/", "wavelet_jittered", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", ".", "size", "*", "np", ".", "dot", "(", "np", ".", "real", "(", "noise_vec", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "np", ".", "real", "(", "denoised_jittered", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", "-", "denoised", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", ")", ".", "reshape", "(", "-", "1", ")", "/", "eta", ")", "+", "# real part", "\n", "1.", "/", "wavelet_jittered", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", ".", "size", "*", "np", ".", "dot", "(", "np", ".", "imag", "(", "noise_vec", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "np", ".", "imag", "(", "denoised_jittered", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", "-", "denoised", ".", "coeff", "[", "s", "+", "1", "]", "[", "b", "]", ")", ".", "reshape", "(", "-", "1", ")", "/", "eta", ")", ")", "# img part", "\n", "", "", "return", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.complexSoft": [[584, 604], ["numpy.ones_like", "numpy.abs", "numpy.minimum"], "function", ["None"], ["def", "complexSoft", "(", "wavelet_coeff", ",", "threshold", ")", ":", "\n", "    ", "\"\"\"Perform soft-thresholding on a wavelet subband given a threshold.\n\n    Args:\n        wavelet_coeff (np.ndarray): array of wavelet coefficients.\n        threshold (float): the threshold.\n\n    Returns:\n        thresholded_coeff (np.ndarray): the thresholded wavelet coefficients.\n        df (np.ndarray): degree of freedom, shape like thresholded_coeff\n\n    Notes:\n        The original MATLAB implementation can be found at https://github.com/charlesmillard/VDAMP.\n    \"\"\"", "\n", "ones", "=", "np", ".", "ones_like", "(", "wavelet_coeff", ",", "dtype", "=", "float", ")", "\n", "mag", "=", "np", ".", "abs", "(", "wavelet_coeff", ")", "\n", "gdual", "=", "np", ".", "minimum", "(", "threshold", "/", "mag", ",", "ones", ")", "\n", "thresholded_coeff", "=", "wavelet_coeff", "*", "(", "ones", "-", "gdual", ")", "\n", "df", "=", "2", "*", "ones", "-", "(", "2", "*", "ones", "-", "(", "gdual", "<", "1", ")", ")", "*", "gdual", "\n", "return", "thresholded_coeff", ",", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.sureSoft": [[605, 640], ["numpy.abs", "numpy.flipud", "numpy.ones_like", "numpy.flipud", "numpy.argmin", "dvdamp.complexSoft", "wavelet_coeff.reshape", "numpy.argsort", "numpy.ones_like", "numpy.cumsum", "numpy.sum", "numpy.abs", "numpy.flipud", "numpy.cumsum", "numpy.cumsum", "numpy.cumsum"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.complexSoft"], ["", "def", "sureSoft", "(", "wavelet_coeff", ",", "var", ")", ":", "\n", "    ", "\"\"\"\n    Perform soft-thresholding on a wavelet subband using optimal threshold estimated with SURE.\n\n    Args:\n        wavelet_coeff (np.ndarray): array of wavelet coefficients.\n        var (float): variance of wavelet_coeff.\n\n    Returns:\n        thresholded_coeff (np.ndarray): the thresholded wavelet coefficients.\n        df (np.ndarray): degree of freedom, shape like thresholded_coeff\n        threshold (float): the threshold used.\n\n    Notes:\n        The original MATLAB implementation can be found at https://github.com/charlesmillard/VDAMP.\n    \"\"\"", "\n", "\n", "mag_flat", "=", "np", ".", "abs", "(", "wavelet_coeff", ".", "reshape", "(", "-", "1", ")", ")", "\n", "index", "=", "np", ".", "flipud", "(", "np", ".", "argsort", "(", "np", ".", "abs", "(", "mag_flat", ")", ")", ")", "\n", "lamb", "=", "mag_flat", "[", "index", "]", "\n", "\n", "V", "=", "var", "*", "np", ".", "ones_like", "(", "mag_flat", ")", "\n", "V", "=", "V", "[", "index", "]", "\n", "\n", "z0", "=", "np", ".", "ones_like", "(", "lamb", ")", "\n", "\n", "SURE_inf", "=", "np", ".", "flipud", "(", "np", ".", "cumsum", "(", "np", ".", "flipud", "(", "lamb", "**", "2", ")", ")", ")", "\n", "SURE_sup", "=", "np", ".", "cumsum", "(", "z0", ")", "*", "(", "lamb", "**", "2", ")", "-", "lamb", "*", "np", ".", "cumsum", "(", "V", "/", "lamb", ")", "+", "2", "*", "np", ".", "cumsum", "(", "V", ")", "\n", "SURE", "=", "SURE_inf", "+", "SURE_sup", "-", "np", ".", "sum", "(", "V", ")", "\n", "\n", "idx", "=", "np", ".", "argmin", "(", "SURE", ")", "\n", "thresholded_coeff", ",", "df", "=", "complexSoft", "(", "wavelet_coeff", ",", "lamb", "[", "idx", "]", ")", "\n", "threshold", "=", "lamb", "[", "idx", "]", "\n", "\n", "return", "thresholded_coeff", ",", "df", ",", "threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.multiscaleComplexSoft": [[641, 670], ["wavelet.get_bands", "wavelet.copy", "dvdamp.complexSoft", "range", "range", "dvdamp.complexSoft"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.copy", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.complexSoft", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.complexSoft"], ["", "def", "multiscaleComplexSoft", "(", "wavelet", ",", "variances", ",", "lambdas", ")", ":", "\n", "    ", "\"\"\"\n    Perform soft-thresholding on wavelet coefficients given sparse weighings.\n\n    Args:\n        wavelet (util.transform.Wavelet): the target wavelet.\n        variances (list): estimated variances of the bands.\n        lambdas (list): sparse weighings.\n\n    Returns:\n        thresholded_wavelet (util.transform.Wavelet): the thresholded wavelet.\n        df (list): degrees of freedom of bands.\n\n    Notes:\n        The original MATLAB implementation can be found at https://github.com/charlesmillard/VDAMP.\n    \"\"\"", "\n", "\n", "scales", "=", "wavelet", ".", "get_bands", "(", ")", "\n", "thresholded_wavelet", "=", "wavelet", ".", "copy", "(", ")", "\n", "df", "=", "[", "None", "]", "*", "(", "scales", "+", "1", ")", "\n", "\n", "thresholded_wavelet", ".", "coeff", "[", "0", "]", ",", "df", "[", "0", "]", "=", "complexSoft", "(", "wavelet", ".", "coeff", "[", "0", "]", ",", "variances", "[", "0", "]", "*", "lambdas", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "scales", "+", "1", ")", ":", "\n", "        ", "df_subband", "=", "[", "None", "]", "*", "3", "\n", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "            ", "thresholded_wavelet", ".", "coeff", "[", "i", "]", "[", "j", "]", ",", "df_subband", "[", "j", "]", "=", "complexSoft", "(", "wavelet", ".", "coeff", "[", "i", "]", "[", "j", "]", ",", "variances", "[", "i", "]", "[", "j", "]", "*", "lambdas", "[", "i", "]", "[", "j", "]", ")", "\n", "", "df", "[", "i", "]", "=", "df_subband", "\n", "\n", "", "return", "thresholded_wavelet", ",", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.multiscaleSureSoft": [[671, 703], ["wavelet.get_bands", "wavelet.copy", "dvdamp.sureSoft", "range", "range", "dvdamp.sureSoft"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.copy", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.sureSoft", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.dvdamp.sureSoft"], ["", "def", "multiscaleSureSoft", "(", "wavelet", ",", "variances", ")", ":", "\n", "    ", "\"\"\"\n    Perform soft-thresholding on wavelet coefficients using optimal thresholds estimated with SURE.\n\n    Args:\n        wavelet (util.transform.Wavelet): the target wavelet.\n        variances (list): estimated variances of the bands.\n\n    Returns:\n        thresholded_wavelet (util.transform.Wavelet): the thresholded wavelet.\n        df (list): degrees of freedom of bands.\n        thres (list): used thresholds for bands.\n\n    Notes:\n        The original MATLAB implementation can be found at https://github.com/charlesmillard/VDAMP.\n    \"\"\"", "\n", "\n", "scales", "=", "wavelet", ".", "get_bands", "(", ")", "\n", "thresholded_wavelet", "=", "wavelet", ".", "copy", "(", ")", "\n", "df", "=", "[", "None", "]", "*", "(", "scales", "+", "1", ")", "\n", "thres", "=", "[", "None", "]", "*", "(", "scales", "+", "1", ")", "\n", "\n", "thresholded_wavelet", ".", "coeff", "[", "0", "]", ",", "df", "[", "0", "]", ",", "thres", "[", "0", "]", "=", "sureSoft", "(", "wavelet", ".", "coeff", "[", "0", "]", ",", "variances", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "scales", "+", "1", ")", ":", "\n", "        ", "df_subband", "=", "[", "None", "]", "*", "3", "\n", "thres_subband", "=", "[", "None", "]", "*", "3", "\n", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "            ", "thresholded_wavelet", ".", "coeff", "[", "i", "]", "[", "j", "]", ",", "df_subband", "[", "j", "]", ",", "thres_subband", "[", "j", "]", "=", "sureSoft", "(", "wavelet", ".", "coeff", "[", "i", "]", "[", "j", "]", ",", "variances", "[", "i", "]", "[", "j", "]", ")", "\n", "", "df", "[", "i", "]", "=", "df_subband", "\n", "thres", "[", "i", "]", "=", "thres_subband", "\n", "\n", "", "return", "thresholded_wavelet", ",", "df", ",", "thres", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.heatmap.calc_sure": [[17, 89], ["util.patch.calc_num_patches", "util.patch.ImageToPatches", "patch.ImageToPatches.", "torch.zeros", "range", "patch_decom.view().sum", "util.general.generate_noise", "denoiser", "patch.ImageToPatches.", "patch_decom.view().sum", "util.patch.Compose", "patch.Compose.", "patch_decom.view", "patch_decom.view", "util.patch.VecToPatches", "util.patch.PatchesToImage", "patch.Compose.", "patch.Compose.", "patch.Compose."], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.calc_num_patches", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_noise"], ["def", "calc_sure", "(", "noisy_image", ",", "\n", "denoised_image", ",", "\n", "denoiser", ",", "\n", "std", ",", "\n", "window", ",", "\n", "stride", "=", "None", ",", "\n", "num_noise", "=", "1", ",", "\n", "heatmap", "=", "True", ",", "\n", "test", "=", "False", ")", ":", "\n", "    ", "\"\"\"Generate SURE heatmap\n    \n    Args:\n        noisy_image (tensor): tensor of noisy image.\n        denoised_image (tensor): tensor of denoised image.\n        denoiser: the denoiser used to generate denoised_image.\n        std (float): the standard deviation of the Gaussian noise in [0, 1] scale.\n        window (int): the width in pixels of the square patch to calculate each SURE value.\n        stride (int): the stride in pixels between each square patch to calculate SURE value.\n            If None, stride = window.\n        num_noise (int): number of noise samples for calculating the divergence term.\n        heatmap (bool): whether to return a heatmap. If false, return a 1D tensor of\n            SURE values. This tensor can be composed to the heatmap using functions in util.patch.\n        test (bool): whether to return the fidelity term and the divergence term along with SURE.\n\n    Returns:\n        sure (tensor): SURE\n        fidelity (tensor): the fidelity term 1/n ||f(y) - y||^2.\n        divergence (tensor): the divergence term (2 std^2)/n div f(y).\n\n    Note:\n        The image tensors have shape (CHW). The returns are heatmap or 1D tensor depending on\n        the heatmap flag.\n    \"\"\"", "\n", "# Prepare image, parameters, and function handles", "\n", "C", ",", "H", ",", "W", "=", "noisy_image", ".", "shape", "\n", "num_patches", "=", "patch", ".", "calc_num_patches", "(", "H", ",", "W", ",", "window", ",", "stride", "=", "stride", ")", "\n", "eps", "=", "0.001", "\n", "patch_decom", "=", "patch", ".", "ImageToPatches", "(", "window", ",", "stride", "=", "stride", ")", "\n", "\n", "# Fidelity term", "\n", "fidelity", "=", "patch_decom", "(", "(", "noisy_image", "-", "denoised_image", ")", "**", "2", ")", "\n", "fidelity", "=", "fidelity", ".", "view", "(", "num_patches", ",", "-", "1", ")", ".", "sum", "(", "1", ")", "/", "(", "window", "**", "2", ")", "\n", "\n", "# Divergence term", "\n", "divergence", "=", "torch", ".", "zeros", "(", "num_patches", ")", "\n", "for", "_", "in", "range", "(", "num_noise", ")", ":", "\n", "        ", "random_image", "=", "generate_noise", "(", "noisy_image", ".", "shape", ",", "std", "=", "1.", ")", "\n", "image_perturbed", "=", "noisy_image", "+", "eps", "*", "random_image", "\n", "denoised_perturbed", "=", "denoiser", "(", "image_perturbed", ",", "std", "=", "std", ")", "\n", "div_patches", "=", "patch_decom", "(", "\n", "random_image", "*", "(", "(", "denoised_perturbed", "-", "denoised_image", ")", "/", "eps", ")", ")", "\n", "divergence", "+=", "div_patches", ".", "view", "(", "num_patches", ",", "-", "1", ")", ".", "sum", "(", "1", ")", "\n", "", "divergence", "/=", "num_noise", "\n", "divergence", "*=", "(", "2", "*", "(", "std", "**", "2", ")", ")", "/", "(", "window", "**", "2", ")", "\n", "\n", "# Combine terms", "\n", "sure", "=", "fidelity", "+", "divergence", "-", "std", "**", "2", "\n", "\n", "if", "heatmap", ":", "\n", "        ", "patch_recon", "=", "patch", ".", "Compose", "(", "[", "\n", "patch", ".", "VecToPatches", "(", "window", ")", ",", "\n", "patch", ".", "PatchesToImage", "(", "H", ",", "W", ",", "stride", "=", "stride", ")", ",", "\n", "]", ")", "\n", "if", "test", ":", "\n", "            ", "return", "patch_recon", "(", "sure", ")", ",", "patch_recon", "(", "fidelity", ")", ",", "patch_recon", "(", "divergence", ")", "\n", "", "else", ":", "\n", "            ", "return", "patch_recon", "(", "sure", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "test", ":", "\n", "            ", "return", "sure", ",", "fidelity", ",", "divergence", "\n", "", "else", ":", "\n", "            ", "return", "sure", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.heatmap.calc_sure_vdamp": [[90, 184], ["noisy_wavelet.get_bands", "util.patch.calc_num_patches", "util.patch.ImageToPatches", "util.patch.Compose", "patch.ImageToPatches.view().mean", "noisy_wavelet.count_subbandwise", "torch.zeros", "range", "numpy.sum", "numpy.sum", "util.general.generate_noise", "util.transform.add", "denoiser", "util.transform.sub", "util.transform.add", "denoiser", "util.transform.sub", "patch.ImageToPatches.view().mean", "util.patch.Compose", "util.patch.VecToPatches", "util.patch.PatchesToImage", "patch.ImageToPatches.view", "util.transform.mul_subbandwise", "util.transform.mul_subbandwise", "patch.Compose.", "util.transform.forward", "tutil.sub.real().inverse", "util.transform.forward", "tutil.sub.imag().inverse", "patch.ImageToPatches.view", "util.patch.VecToPatches", "util.patch.PatchesToImage", "patch.Compose.", "patch.Compose.", "patch.Compose.", "noisy_wavelet.inverse().unsqueeze", "patch.ImageToPatches.", "tutil.sub.real", "tutil.sub.imag", "patch.ImageToPatches.", "noisy_wavelet.inverse", "div_real.unsqueeze", "div_imag.unsqueeze"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.calc_num_patches", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.count_subbandwise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_noise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.add", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.sub", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.add", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.sub", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.mul_subbandwise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.mul_subbandwise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.real", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.imag", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse"], ["", "", "", "def", "calc_sure_vdamp", "(", "noisy_wavelet", ",", "\n", "denoised_wavelet", ",", "\n", "denoised_image", ",", "\n", "denoiser", ",", "\n", "tau", ",", "\n", "window", ",", "\n", "stride", "=", "None", ",", "\n", "num_noise", "=", "1", ",", "\n", "heatmap", "=", "True", ",", "\n", "test", "=", "False", ")", ":", "\n", "    ", "\"\"\"Generate SURE heatmap for D-VDAMP\n    \n    Args:\n        noisy_wavelet (util.transform.Wavelet): noisy wavelet (r in D-VDAMP).\n        denoised_wavelet (util.transform.Wavelet): denoised wavelet (w_hat in D-VDAMP)\n        denoised_image (tensor): denoised image of shape (C, H, W) i.e. inverse of denoised_wavelet.\n        denoiser: the denoiser used to generate denoised_image.\n        tau (list/array of floats): the variance of noise in each wavelet subband.\n        window (int): the width in pixels of the square patch to calculate each SURE value.\n        stride (int): the stride in pixels between each square patch to calculate SURE value.\n            If None, stride = window.\n        num_noise (int): number of noise samples for calculating the divergence term.\n        heatmap (bool): whether to return a heatmap. If false, return a 1D tensor of\n            SURE values. This tensor can be composed to the heatmap using functions in util.patch.\n        test (bool): whether to return the fidelity term and the divergence term along with SURE.\n\n    Returns:\n        sure (tensor): SURE\n        fidelity (tensor): the fidelity term 1/n ||f(y) - y||^2.\n        divergence (tensor): the divergence term (2 std^2)/n div f(y).\n\n    Note:\n        When calculating SURE map, we take x_hat to be the inverse wavelet transform of w_hat\n        directly without further correction. In many cases, we found that the quality of x_hat\n        without the final correction is comparable to the case with final correction.\n        See line 11 of Algorithm 2 in\n\n        Charles Millard, Aaron T Hess, Boris Mailhe, and Jared Tanner, \n        \u201cApproximate message passing with a colored aliasing model for variable density \n        fourier sampled images,\u201d arXiv preprint arXiv:2003.02701, 2020.\n\n        for this final correction term.\n\n        The image tensors have shape (CHW). The returns are heatmap or 1D tensor depending on\n        the heatmap flag.\n    \"\"\"", "\n", "C", ",", "H", ",", "W", "=", "denoised_image", ".", "shape", "\n", "level", "=", "noisy_wavelet", ".", "get_bands", "(", ")", "\n", "num_patches", "=", "patch", ".", "calc_num_patches", "(", "H", ",", "W", ",", "window", ",", "stride", "=", "stride", ")", "\n", "patch_decom", "=", "patch", ".", "ImageToPatches", "(", "window", ",", "stride", "=", "stride", ")", "\n", "patch_recon", "=", "patch", ".", "Compose", "(", "[", "patch", ".", "VecToPatches", "(", "window", ")", ",", "\n", "patch", ".", "PatchesToImage", "(", "H", ",", "W", ",", "stride", "=", "stride", ")", ",", "\n", "]", ")", "\n", "\n", "# SURE fidelity term", "\n", "fid", "=", "(", "noisy_wavelet", ".", "inverse", "(", ")", ".", "unsqueeze", "(", "0", ")", "-", "denoised_image", ")", ".", "abs", "(", ")", "**", "2", "\n", "fid", "=", "patch_decom", "(", "fid", ")", ".", "view", "(", "num_patches", ",", "-", "1", ")", ".", "mean", "(", "1", ")", "\n", "\n", "# SURE bias term", "\n", "num_coeffs", "=", "noisy_wavelet", ".", "count_subbandwise", "(", ")", "\n", "bias", "=", "np", ".", "sum", "(", "num_coeffs", "*", "tau", ")", "/", "np", ".", "sum", "(", "num_coeffs", ")", "\n", "\n", "# SURE divergence term (Monte Carlo)", "\n", "eps", "=", "0.001", "\n", "div", "=", "torch", ".", "zeros", "(", "num_patches", ")", "\n", "for", "_", "in", "range", "(", "num_noise", ")", ":", "\n", "        ", "b", "=", "generate_noise", "(", "(", "H", ",", "W", ")", ",", "std", "=", "1.0", ")", "\n", "jittered_real", "=", "tutil", ".", "add", "(", "noisy_wavelet", ",", "tutil", ".", "mul_subbandwise", "(", "tutil", ".", "forward", "(", "b", ",", "level", "=", "level", ")", ",", "eps", "*", "tau", "/", "2", ")", ")", "\n", "den_jit_real", "=", "denoiser", "(", "jittered_real", ",", "tau", ",", "calc_divergence", "=", "False", ")", "\n", "diff_real", "=", "tutil", ".", "sub", "(", "den_jit_real", ",", "denoised_wavelet", ")", "\n", "div_real", "=", "(", "2", "/", "eps", ")", "*", "(", "b", "*", "diff_real", ".", "real", "(", ")", ".", "inverse", "(", ")", ")", "\n", "jittered_imag", "=", "tutil", ".", "add", "(", "noisy_wavelet", ",", "tutil", ".", "mul_subbandwise", "(", "tutil", ".", "forward", "(", "1j", "*", "b", ",", "level", "=", "level", ")", ",", "eps", "*", "tau", "/", "2", ")", ")", "\n", "den_jit_imag", "=", "denoiser", "(", "jittered_imag", ",", "tau", ",", "calc_divergence", "=", "False", ")", "\n", "diff_imag", "=", "tutil", ".", "sub", "(", "den_jit_imag", ",", "denoised_wavelet", ")", "\n", "div_imag", "=", "(", "2", "/", "eps", ")", "*", "(", "b", "*", "diff_imag", ".", "imag", "(", ")", ".", "inverse", "(", ")", ")", "\n", "div", "+=", "patch_decom", "(", "div_real", ".", "unsqueeze", "(", "0", ")", "+", "div_imag", ".", "unsqueeze", "(", "0", ")", ")", ".", "view", "(", "num_patches", ",", "-", "1", ")", ".", "mean", "(", "1", ")", "\n", "", "div", "/=", "num_noise", "\n", "\n", "sure", "=", "fid", "+", "div", "-", "bias", "\n", "\n", "if", "heatmap", ":", "\n", "        ", "patch_recon", "=", "patch", ".", "Compose", "(", "[", "\n", "patch", ".", "VecToPatches", "(", "window", ")", ",", "\n", "patch", ".", "PatchesToImage", "(", "H", ",", "W", ",", "stride", "=", "stride", ")", ",", "\n", "]", ")", "\n", "if", "test", ":", "\n", "            ", "return", "patch_recon", "(", "sure", ")", ",", "patch_recon", "(", "fid", ")", ",", "patch_recon", "(", "div", ")", "\n", "", "else", ":", "\n", "            ", "return", "patch_recon", "(", "sure", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "test", ":", "\n", "            ", "return", "sure", ",", "fid", ",", "div", "\n", "", "else", ":", "\n", "            ", "return", "sure", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.heatmap.calc_mse": [[185, 225], ["util.patch.calc_num_patches", "util.patch.ImageToPatches", "patch.ImageToPatches.", "mse.view().sum.view().sum", "util.patch.Compose", "patch.Compose.", "mse.view().sum.view", "util.patch.VecToPatches", "util.patch.PatchesToImage"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.calc_num_patches"], ["", "", "", "def", "calc_mse", "(", "image", ",", "\n", "denoised_image", ",", "\n", "window", ",", "\n", "stride", "=", "None", ",", "\n", "heatmap", "=", "True", ")", ":", "\n", "    ", "\"\"\"Generate MSE heatmap\n    \n    Args:\n        image (tensor): tensor of ground truth image.\n        denoised_image (tensor): tensor of denoised image.\n        window (int): the width in pixels of the square patch to calculate each SURE value.\n        stride (int): the stride in pixels between each square patch to calculate SURE value.\n        heatmap (bool): whether to return a heatmap. If false, return a 1D tensor of\n            SURE values. This tensor can be composed to the heatmap using functions in util.patch.\n\n    Returns:\n        mse (tensor): patch-average mean squared error.\n\n    Note:\n        The image tensors have shape (C, H, W). The returns are heatmap or 1D tensor depending on\n        the heatmap flag.\n    \"\"\"", "\n", "# Prepare image, parameters, and function handles", "\n", "C", ",", "H", ",", "W", "=", "image", ".", "shape", "\n", "num_patches", "=", "patch", ".", "calc_num_patches", "(", "H", ",", "W", ",", "window", ",", "stride", "=", "stride", ")", "\n", "image_to_patches", "=", "patch", ".", "ImageToPatches", "(", "window", ",", "stride", "=", "stride", ")", "\n", "\n", "# Calculate MSE", "\n", "mse", "=", "image_to_patches", "(", "(", "image", "-", "denoised_image", ")", ".", "abs", "(", ")", "**", "2", ")", "\n", "mse", "=", "mse", ".", "view", "(", "num_patches", ",", "-", "1", ")", ".", "sum", "(", "1", ")", "\n", "mse", "=", "mse", "/", "(", "window", "**", "2", ")", "\n", "\n", "if", "heatmap", ":", "\n", "        ", "recon", "=", "patch", ".", "Compose", "(", "[", "\n", "patch", ".", "VecToPatches", "(", "window", ")", ",", "\n", "patch", ".", "PatchesToImage", "(", "H", ",", "W", ",", "stride", "=", "stride", ")", ",", "\n", "]", ")", "\n", "return", "recon", "(", "mse", ")", "\n", "", "else", ":", "\n", "        ", "return", "mse", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.heatmap.calc_perpixel_mse": [[226, 237], ["None"], "function", ["None"], ["", "", "def", "calc_perpixel_mse", "(", "image", ",", "denoised_image", ")", ":", "\n", "    ", "\"\"\"Generate per-pixel squared error heatmap\n\n    Args:\n        image (tensor): ground truth image.\n        denoised_image (tensor): denoiesd image.\n\n    Returns:\n        result (tensor): per-pixel squared difference between image and denoised image.\n    \"\"\"", "\n", "return", "(", "denoised_image", "-", "image", ")", "**", "2", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.vdamp_se_exp.main": [[79, 154], ["print", "util.general.mkdir_if_not_exists", "util.general.print_arguments", "util.general.log_arguments", "util.general.prepare_image_path", "torch.zeros", "enumerate", "print", "torch.save", "os.path.join", "algorithm.dvdamp.SoftThresholding_VDAMP", "torch.zeros", "zip", "print", "util.general.read_image", "os.path.join", "algorithm.simulation.vdamp_se_sim", "util.general.calc_psnr", "print", "util.general.save_image", "util.plot.save_heatmap", "os.path.join", "open", "f.write", "torch.save", "util.plot.save_sqerror_plot", "algorithm.dvdamp.BM3D_VDAMP", "len", "len", "print", "enumerate", "os.path.join", "os.path.join", "os.path.join", "enumerate", "algorithm.dvdamp.ColoredDnCNN_VDAMP", "algorithm.heatmap.calc_mse", "enumerate", "torch.zeros.mean().item", "len", "os.path.join", "print", "algorithm.heatmap.calc_sure_vdamp", "util.plot.get_heatmap_limits", "util.plot.save_heatmap", "util.plot.save_heatmap", "os.path.join", "os.path.join", "torch.zeros.mean"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.mkdir_if_not_exists", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.print_arguments", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.log_arguments", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.prepare_image_path", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.read_image", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.simulation.vdamp_se_sim", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.calc_psnr", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_heatmap", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_sqerror_plot", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.heatmap.calc_mse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.heatmap.calc_sure_vdamp", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.get_heatmap_limits", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_heatmap", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_heatmap"], ["def", "main", "(", ")", ":", "\n", "\n", "    ", "print", "(", "'---VDAMP Simulation---'", ")", "\n", "gutil", ".", "mkdir_if_not_exists", "(", "savedir", ")", "\n", "gutil", ".", "print_arguments", "(", "args", ")", "\n", "gutil", ".", "log_arguments", "(", "args", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'args.txt'", ")", ")", "\n", "loadlist", ",", "namelist", ",", "num_images", "=", "gutil", ".", "prepare_image_path", "(", "datadir", ",", "oneim", "=", "oneim", ")", "\n", "\n", "# Setup denoiser", "\n", "if", "dentype", "==", "'soft'", ":", "\n", "        ", "denoiser", "=", "dvdamp", ".", "SoftThresholding_VDAMP", "(", "MC_divergence", "=", "True", ",", "debug", "=", "True", ")", "\n", "", "elif", "dentype", "==", "'bm3d'", ":", "\n", "        ", "denoiser", "=", "dvdamp", ".", "BM3D_VDAMP", "(", "channels", "=", "1", ")", "\n", "", "elif", "dentype", "==", "'cdncnn'", ":", "\n", "        ", "modeldirs", "=", "[", "None", "]", "*", "len", "(", "modelnames", ")", "\n", "std_channels", "=", "3", "*", "level", "+", "1", "\n", "for", "i", ",", "modelname", "in", "enumerate", "(", "modelnames", ")", ":", "\n", "            ", "modeldirs", "[", "i", "]", "=", "os", ".", "path", ".", "join", "(", "modeldir", ",", "'{}.pth'", ".", "format", "(", "modelname", ")", ")", "\n", "", "denoiser", "=", "dvdamp", ".", "ColoredDnCNN_VDAMP", "(", "modeldirs", ",", "std_ranges", ",", "std_channels", "=", "std_channels", ",", "verbose", "=", "verbose", ")", "\n", "\n", "# Setup log variable", "\n", "", "psnr_log", "=", "torch", ".", "zeros", "(", "num_images", ")", "\n", "if", "args", ".", "errorlog", "and", "savemode", "!=", "'recon-only'", ":", "\n", "        ", "error_log", "=", "torch", ".", "zeros", "(", "num_images", ",", "len", "(", "args", ".", "windows", ")", ",", "len", "(", "args", ".", "numnoises", ")", ")", "\n", "\n", "", "for", "i", ",", "(", "loadname", ",", "name", ")", "in", "enumerate", "(", "zip", "(", "loadlist", ",", "namelist", ")", ")", ":", "\n", "\n", "        ", "print", "(", "'{}. image: {}'", ".", "format", "(", "i", "+", "1", ",", "name", ")", ")", "\n", "image", "=", "gutil", ".", "read_image", "(", "loadname", ")", "\n", "this_savedir", "=", "os", ".", "path", ".", "join", "(", "savedir", ",", "name", ")", "\n", "\n", "denoised_image", ",", "noisy_wavelet", ",", "denoised_wavelet", "=", "sim", ".", "vdamp_se_sim", "(", "image", ",", "tau", ",", "denoiser", ")", "\n", "psnr_log", "[", "i", "]", "=", "gutil", ".", "calc_psnr", "(", "denoised_image", ".", "real", ",", "image", ")", "\n", "print", "(", "'PSNR = {:.3f}'", ".", "format", "(", "psnr_log", "[", "i", "]", ")", ")", "\n", "\n", "# Saving results and statistics", "\n", "error_map", "=", "(", "denoised_image", "-", "image", ")", ".", "abs", "(", ")", "\n", "gutil", ".", "save_image", "(", "denoised_image", ".", "real", ",", "'{}-recon.png'", ".", "format", "(", "this_savedir", ")", ")", "\n", "putil", ".", "save_heatmap", "(", "error_map", ",", "'{}-recon_err'", ".", "format", "(", "this_savedir", ")", ",", "savemode", "=", "'plot'", ")", "\n", "\n", "if", "savemode", "!=", "'recon-only'", ":", "\n", "            ", "print", "(", "'Begin generating MSE and SURE heatmaps...'", ")", "\n", "\n", "for", "iwin", ",", "window", "in", "enumerate", "(", "args", ".", "windows", ")", ":", "\n", "\n", "                ", "mse", "=", "heatmap", ".", "calc_mse", "(", "image", ",", "denoised_image", ",", "window", ",", "stride", "=", "args", ".", "stride", ")", "\n", "\n", "for", "inoi", ",", "num_noise", "in", "enumerate", "(", "args", ".", "numnoises", ")", ":", "\n", "\n", "                    ", "print", "(", "'patch size = {:d}, k = {:d}'", ".", "format", "(", "window", ",", "num_noise", ")", ")", "\n", "\n", "sure", "=", "heatmap", ".", "calc_sure_vdamp", "(", "noisy_wavelet", ",", "denoised_wavelet", ",", "denoised_image", ",", "denoiser", ",", "tau", ",", "\n", "window", ",", "stride", "=", "args", ".", "stride", ",", "num_noise", "=", "num_noise", ")", "\n", "\n", "vmin", ",", "vmax", "=", "putil", ".", "get_heatmap_limits", "(", "[", "mse", ",", "sure", "]", ")", "\n", "\n", "# Note: even though k does not affect mse calculation, we save mse for each k anyway so that", "\n", "# the scaling (color bar) of the MSE heatmap matches the corresponding SURE heatmap.", "\n", "putil", ".", "save_heatmap", "(", "mse", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'{}-w{:d}-k{:d}-mse'", ".", "format", "(", "name", ",", "window", ",", "num_noise", ")", ")", ",", "\n", "savemode", "=", "savemode", ",", "title", "=", "'MSE, patch size = {:d}, k = {:d}'", ".", "format", "(", "window", ",", "num_noise", ")", ",", "\n", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ")", "\n", "putil", ".", "save_heatmap", "(", "sure", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'{}-w{:d}-k{:d}-sure'", ".", "format", "(", "name", ",", "window", ",", "num_noise", ")", ")", ",", "\n", "savemode", "=", "savemode", ",", "title", "=", "'SURE, patch size = {:d}, k = {:d}'", ".", "format", "(", "window", ",", "num_noise", ")", ",", "\n", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ")", "\n", "\n", "if", "args", ".", "errorlog", ":", "\n", "                        ", "error_log", "[", "i", ",", "iwin", ",", "inoi", "]", "=", "(", "(", "mse", "-", "sure", ")", "**", "2", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "", "", "", "print", "(", "'Saving log file(s)...'", ")", "\n", "torch", ".", "save", "(", "psnr_log", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'psnr_log.pt'", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "savedir", ",", "'psnr_mean.txt'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "'{}'", ".", "format", "(", "psnr_log", ".", "mean", "(", ")", ".", "item", "(", ")", ")", ")", "\n", "", "if", "args", ".", "errorlog", "and", "savemode", "!=", "'recon-only'", ":", "\n", "            ", "torch", ".", "save", "(", "error_log", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'error.pt'", ")", ")", "\n", "putil", ".", "save_sqerror_plot", "(", "error_log", ",", "args", ".", "windows", ",", "args", ".", "numnoises", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'error.png'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.main": [[95, 187], ["print", "util.general.mkdir_if_not_exists", "util.general.print_arguments", "util.general.log_arguments", "util.general.prepare_image_path", "torch.zeros", "enumerate", "print", "torch.save", "os.path.join", "algorithm.dvdamp.SoftThresholding_VDAMP", "torch.zeros", "zip", "print", "util.general.read_image", "os.path.join", "algorithm.simulation.dvdamp_sim", "torch.save", "util.general.calc_psnr", "print", "util.general.save_image", "util.plot.save_heatmap", "util.transform.forward", "dvdamp_exp.plot_psnr", "dvdamp_exp.plot_effective_noise", "dvdamp_exp.plot_qq", "dvdamp_exp.plot_err", "os.path.join", "open", "f.write", "torch.save", "util.plot.save_sqerror_plot", "algorithm.dvdamp.BM3D_VDAMP", "len", "len", "os.path.join", "print", "print", "util.transform.pyramid_backward", "util.transform.pyramid_backward", "tutil.pyramid_backward.inverse().unsqueeze", "util.transform.reformat_subband2array", "util.general.save_image", "enumerate", "os.path.join", "os.path.join", "os.path.join", "enumerate", "algorithm.dvdamp.ColoredDnCNN_VDAMP", "algorithm.heatmap.calc_mse", "enumerate", "torch.zeros.mean().item", "len", "os.path.join", "tutil.pyramid_backward.inverse", "print", "algorithm.heatmap.calc_sure_vdamp", "util.plot.get_heatmap_limits", "util.plot.save_heatmap", "util.plot.save_heatmap", "os.path.join", "os.path.join", "torch.zeros.mean"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.mkdir_if_not_exists", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.print_arguments", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.log_arguments", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.prepare_image_path", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.read_image", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.simulation.dvdamp_sim", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.calc_psnr", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_heatmap", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.plot_psnr", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.plot_effective_noise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.plot_qq", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.plot_err", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_sqerror_plot", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.reformat_subband2array", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.heatmap.calc_mse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.algorithm.heatmap.calc_sure_vdamp", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.get_heatmap_limits", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_heatmap", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_heatmap"], ["def", "main", "(", ")", ":", "\n", "\n", "    ", "print", "(", "'---VDAMP Simulation---'", ")", "\n", "gutil", ".", "mkdir_if_not_exists", "(", "savedir", ")", "\n", "gutil", ".", "print_arguments", "(", "args", ")", "\n", "gutil", ".", "log_arguments", "(", "args", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'args.txt'", ")", ")", "\n", "loadlist", ",", "namelist", ",", "num_images", "=", "gutil", ".", "prepare_image_path", "(", "datadir", ",", "oneim", "=", "oneim", ")", "\n", "\n", "# Setup denoiser", "\n", "if", "dentype", "==", "'soft'", ":", "\n", "        ", "denoiser", "=", "dvdamp", ".", "SoftThresholding_VDAMP", "(", "MC_divergence", "=", "True", ",", "debug", "=", "True", ")", "\n", "", "elif", "dentype", "==", "'bm3d'", ":", "\n", "        ", "denoiser", "=", "dvdamp", ".", "BM3D_VDAMP", "(", "channels", "=", "1", ")", "\n", "", "elif", "dentype", "==", "'cdncnn'", ":", "\n", "        ", "modeldirs", "=", "[", "None", "]", "*", "len", "(", "modelnames", ")", "\n", "std_channels", "=", "3", "*", "level", "+", "1", "\n", "for", "i", ",", "modelname", "in", "enumerate", "(", "modelnames", ")", ":", "\n", "            ", "modeldirs", "[", "i", "]", "=", "os", ".", "path", ".", "join", "(", "modeldir", ",", "'{}.pth'", ".", "format", "(", "modelname", ")", ")", "\n", "", "denoiser", "=", "dvdamp", ".", "ColoredDnCNN_VDAMP", "(", "modeldirs", ",", "std_ranges", ",", "std_channels", "=", "std_channels", ",", "verbose", "=", "verbose", ")", "\n", "\n", "# Setup log variable", "\n", "", "psnr_log", "=", "torch", ".", "zeros", "(", "num_images", ")", "\n", "if", "args", ".", "errorlog", "and", "savemode", "!=", "'recon-only'", ":", "\n", "        ", "error_log", "=", "torch", ".", "zeros", "(", "num_images", ",", "len", "(", "args", ".", "windows", ")", ",", "len", "(", "args", ".", "numnoises", ")", ")", "\n", "\n", "", "for", "i", ",", "(", "loadname", ",", "name", ")", "in", "enumerate", "(", "zip", "(", "loadlist", ",", "namelist", ")", ")", ":", "\n", "\n", "        ", "print", "(", "'{}. image: {}'", ".", "format", "(", "i", "+", "1", ",", "name", ")", ")", "\n", "image", "=", "gutil", ".", "read_image", "(", "loadname", ")", "\n", "this_savedir", "=", "os", ".", "path", ".", "join", "(", "savedir", ",", "name", ")", "\n", "\n", "# MRI sampling simulation and VDAMP", "\n", "recon_image", ",", "log", ",", "true_iters", "=", "sim", ".", "dvdamp_sim", "(", "image", ",", "sampling_rate", ",", "snr", ",", "denoiser", ",", "iters", ",", "\n", "level", "=", "level", ",", "wavetype", "=", "wavetype", ",", "stop_on_increase", "=", "stop_on_increase", ")", "\n", "torch", ".", "save", "(", "log", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'log.pt'", ")", ")", "\n", "psnr_log", "[", "i", "]", "=", "gutil", ".", "calc_psnr", "(", "recon_image", ".", "real", ",", "image", ")", "\n", "print", "(", "'PSNR = {:.3f}'", ".", "format", "(", "psnr_log", "[", "i", "]", ")", ")", "\n", "\n", "# Saving results and statistics", "\n", "error_map", "=", "(", "recon_image", "-", "image", ")", ".", "abs", "(", ")", "\n", "gutil", ".", "save_image", "(", "recon_image", ".", "real", ",", "'{}-recon.png'", ".", "format", "(", "this_savedir", ")", ")", "\n", "putil", ".", "save_heatmap", "(", "error_map", ",", "'{}-recon_err'", ".", "format", "(", "this_savedir", ")", ",", "savemode", "=", "'plot'", ")", "\n", "w0", "=", "tutil", ".", "forward", "(", "image", "[", "0", "]", ",", "wavelet", "=", "wavetype", ",", "level", "=", "level", ")", "\n", "plot_psnr", "(", "log", ",", "image", ",", "this_savedir", ",", "true_iters", ")", "\n", "plot_effective_noise", "(", "log", ",", "w0", ",", "this_savedir", ",", "true_iters", ")", "\n", "plot_qq", "(", "log", ",", "w0", ",", "this_savedir", ",", "true_iters", ")", "\n", "plot_err", "(", "log", ",", "w0", ",", "this_savedir", ",", "true_iters", ")", "\n", "\n", "if", "savemode", "!=", "'recon-only'", ":", "\n", "            ", "print", "(", "'Begin generating MSE and SURE heatmaps...'", ")", "\n", "\n", "print", "(", "'true_iters'", ",", "true_iters", ")", "\n", "\n", "# Get ingredients for SURE map", "\n", "noisy_wavelet", "=", "tutil", ".", "pyramid_backward", "(", "log", "[", "'r'", "]", "[", "true_iters", "-", "1", "]", ",", "log", "[", "'slices'", "]", ")", "\n", "denoised_wavelet", "=", "tutil", ".", "pyramid_backward", "(", "log", "[", "'w_hat'", "]", "[", "true_iters", "-", "1", "]", ",", "log", "[", "'slices'", "]", ")", "\n", "denoised_image", "=", "denoised_wavelet", ".", "inverse", "(", "to_tensor", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", "\n", "tau", "=", "tutil", ".", "reformat_subband2array", "(", "log", "[", "'tau'", "]", "[", "true_iters", "-", "1", "]", ")", "\n", "gutil", ".", "save_image", "(", "denoised_image", ".", "real", ",", "'{}-recon-no-final-correction.png'", ".", "format", "(", "this_savedir", ")", ")", "\n", "\n", "for", "iwin", ",", "window", "in", "enumerate", "(", "args", ".", "windows", ")", ":", "\n", "\n", "                ", "mse", "=", "heatmap", ".", "calc_mse", "(", "image", ",", "recon_image", ",", "window", ",", "stride", "=", "args", ".", "stride", ")", "\n", "\n", "for", "inoi", ",", "num_noise", "in", "enumerate", "(", "args", ".", "numnoises", ")", ":", "\n", "\n", "                    ", "print", "(", "'patch size = {:d}, k = {:d}'", ".", "format", "(", "window", ",", "num_noise", ")", ")", "\n", "\n", "sure", "=", "heatmap", ".", "calc_sure_vdamp", "(", "noisy_wavelet", ",", "denoised_wavelet", ",", "denoised_image", ",", "denoiser", ",", "tau", ",", "\n", "window", ",", "stride", "=", "args", ".", "stride", ",", "num_noise", "=", "num_noise", ")", "\n", "\n", "vmin", ",", "vmax", "=", "putil", ".", "get_heatmap_limits", "(", "[", "mse", ",", "sure", "]", ")", "\n", "\n", "# Note: even though k does not affect mse calculation, we save mse for each k anyway so that", "\n", "# the scaling (color bar) of the MSE heatmap matches the corresponding SURE heatmap.", "\n", "putil", ".", "save_heatmap", "(", "mse", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'{}-w{:d}-k{:d}-mse'", ".", "format", "(", "name", ",", "window", ",", "num_noise", ")", ")", ",", "\n", "savemode", "=", "savemode", ",", "title", "=", "'MSE, patch size = {:d}, k = {:d}'", ".", "format", "(", "window", ",", "num_noise", ")", ",", "\n", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ")", "\n", "putil", ".", "save_heatmap", "(", "sure", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'{}-w{:d}-k{:d}-sure'", ".", "format", "(", "name", ",", "window", ",", "num_noise", ")", ")", ",", "\n", "savemode", "=", "savemode", ",", "title", "=", "'SURE, patch size = {:d}, k = {:d}'", ".", "format", "(", "window", ",", "num_noise", ")", ",", "\n", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ")", "\n", "\n", "if", "args", ".", "errorlog", ":", "\n", "                        ", "error_log", "[", "i", ",", "iwin", ",", "inoi", "]", "=", "(", "(", "mse", "-", "sure", ")", "**", "2", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "", "", "", "print", "(", "'Saving log file(s)...'", ")", "\n", "torch", ".", "save", "(", "psnr_log", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'psnr_log.pt'", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "savedir", ",", "'psnr_mean.txt'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "'{}'", ".", "format", "(", "psnr_log", ".", "mean", "(", ")", ".", "item", "(", ")", ")", ")", "\n", "", "if", "args", ".", "errorlog", "and", "savemode", "!=", "'recon-only'", ":", "\n", "            ", "torch", ".", "save", "(", "error_log", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'error.pt'", ")", ")", "\n", "putil", ".", "save_sqerror_plot", "(", "error_log", ",", "args", ".", "windows", ",", "args", ".", "numnoises", ",", "os", ".", "path", ".", "join", "(", "savedir", ",", "'error.png'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.plot_psnr": [[188, 200], ["numpy.zeros", "range", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.savefig", "matplotlib.clf", "util.general.im_numpy_to_tensor", "util.general.calc_psnr"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.im_numpy_to_tensor", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.calc_psnr"], ["", "", "def", "plot_psnr", "(", "log", ",", "image", ",", "savedir", ",", "true_iters", ")", ":", "\n", "    ", "\"\"\"Plot PSNR history\"\"\"", "\n", "psnr", "=", "np", ".", "zeros", "(", "true_iters", ")", "\n", "for", "i", "in", "range", "(", "true_iters", ")", ":", "\n", "        ", "x_hat", "=", "gutil", ".", "im_numpy_to_tensor", "(", "log", "[", "'x_hat'", "]", "[", "i", "]", ".", "real", ")", "\n", "psnr", "[", "i", "]", "=", "gutil", ".", "calc_psnr", "(", "x_hat", ",", "image", ")", "\n", "", "plt", ".", "plot", "(", "psnr", ")", "\n", "plt", ".", "xlabel", "(", "'Iteration'", ")", "\n", "plt", ".", "ylabel", "(", "'PSNR'", ")", "\n", "plt", ".", "title", "(", "'PSNR of Reconstructed Image (x_hat)'", ")", "\n", "plt", ".", "savefig", "(", "'{}-psnr.png'", ".", "format", "(", "savedir", ")", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.plot_effective_noise": [[201, 219], ["w0.pyramid_forward", "numpy.zeros", "enumerate", "numpy.min", "numpy.max", "enumerate", "numpy.abs", "util.plot.save_heatmap", "len"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_heatmap"], ["", "def", "plot_effective_noise", "(", "log", ",", "w0", ",", "savedir", ",", "true_iters", ")", ":", "\n", "    ", "\"\"\"Plot pyramid of effective noise in wavelet coefficients\"\"\"", "\n", "w0_pyramid", "=", "w0", ".", "pyramid_forward", "(", "to_tensor", "=", "False", ")", "\n", "H", ",", "W", "=", "w0_pyramid", ".", "shape", "\n", "eff_noise", "=", "np", ".", "zeros", "(", "(", "len", "(", "selected_it", ")", ",", "H", ",", "W", ")", ")", "\n", "for", "i", ",", "it", "in", "enumerate", "(", "selected_it", ")", ":", "\n", "        ", "if", "it", ">=", "true_iters", ":", "\n", "            ", "break", "\n", "", "eff_noise", "[", "i", "]", "=", "np", ".", "abs", "(", "log", "[", "'r'", "]", "[", "it", "]", "-", "w0_pyramid", ")", "\n", "", "vmin", "=", "np", ".", "min", "(", "eff_noise", ")", "\n", "vmax", "=", "np", ".", "max", "(", "eff_noise", ")", "\n", "\n", "for", "i", ",", "it", "in", "enumerate", "(", "selected_it", ")", ":", "\n", "        ", "if", "it", ">=", "true_iters", ":", "\n", "            ", "break", "\n", "", "putil", ".", "save_heatmap", "(", "eff_noise", "[", "i", "]", ",", "'{}-eff_noise-{}'", ".", "format", "(", "savedir", ",", "it", ")", ",", "\n", "title", "=", "'|w_hat - r|, iteration {}'", ".", "format", "(", "it", ")", ",", "\n", "savemode", "=", "'plot'", ",", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ",", "tensor", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.plot_qq": [[220, 238], ["enumerate", "matplotlib.subplots", "w0.pyramid_forward", "util.transform.pyramid_backward", "enumerate", "fig.suptitle", "fig.savefig", "fig.clear", "matplotlib.close", "len", "enumerate", "statsmodels.qqplot", "ax[].set_title", "numpy.std", "len", "numpy.mean", "eff_noise.reshape"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward"], ["", "", "def", "plot_qq", "(", "log", ",", "w0", ",", "savedir", ",", "true_iters", ")", ":", "\n", "    ", "\"\"\"QQ plot of effective noise in wavelet coefficients\"\"\"", "\n", "for", "i", ",", "it", "in", "enumerate", "(", "selected_it", ")", ":", "\n", "        ", "if", "it", ">=", "true_iters", ":", "\n", "            ", "break", "\n", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "len", "(", "selected_scale", ")", ",", "3", ",", "figsize", "=", "(", "8", "*", "len", "(", "selected_scale", ")", ",", "5", "*", "3", ")", ")", "\n", "_", ",", "slices", "=", "w0", ".", "pyramid_forward", "(", "get_slices", "=", "True", ",", "to_tensor", "=", "False", ")", "\n", "r", "=", "tutil", ".", "pyramid_backward", "(", "log", "[", "'r'", "]", "[", "it", "]", ",", "slices", ")", "\n", "for", "i_b", ",", "b", "in", "enumerate", "(", "selected_scale", ")", ":", "\n", "            ", "for", "i_s", ",", "s", "in", "enumerate", "(", "tutil", ".", "SUBBAND", "[", "1", ":", "]", ")", ":", "\n", "                ", "eff_noise", "=", "r", ".", "coeff", "[", "b", "+", "1", "]", "[", "i_s", "]", "-", "w0", ".", "coeff", "[", "b", "+", "1", "]", "[", "i_s", "]", "\n", "eff_noise", "=", "(", "eff_noise", "-", "np", ".", "mean", "(", "eff_noise", ")", ")", "/", "np", ".", "std", "(", "eff_noise", ")", "\n", "sm", ".", "qqplot", "(", "eff_noise", ".", "reshape", "(", "-", "1", ")", ".", "real", ",", "line", "=", "'45'", ",", "ax", "=", "ax", "[", "i_b", ",", "i_s", "]", ")", "\n", "ax", "[", "i_b", ",", "i_s", "]", ".", "set_title", "(", "'{}, level {}'", ".", "format", "(", "s", ",", "b", ")", ")", "\n", "", "", "fig", ".", "suptitle", "(", "'QQ plot of effective noise at iteration {}'", ".", "format", "(", "it", ")", ")", "\n", "fig", ".", "savefig", "(", "'{}-qq-{}.png'", ".", "format", "(", "savedir", ",", "it", ")", ")", "\n", "fig", ".", "clear", "(", ")", "\n", "plt", ".", "close", "(", "fig", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp.plot_err": [[239, 268], ["dvdamp_exp._calc_wavelet_coeff_norm_and_count", "matplotlib.subplots", "dvdamp_exp._band_iter_reformat", "dvdamp_exp._band_iter_reformat", "ax[].plot", "ax[].plot", "range", "fig.suptitle", "ax[].get_legend_handles_labels", "fig.legend", "fig.savefig", "fig.clear", "matplotlib.close", "range", "ax[].set_xlabel", "ax[].set_ylabel", "ax[].set_title", "numpy.log10", "numpy.log10", "ax[].plot", "ax[].plot", "numpy.log10", "numpy.log10"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp._calc_wavelet_coeff_norm_and_count", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp._band_iter_reformat", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp._band_iter_reformat"], ["", "", "def", "plot_err", "(", "log", ",", "w0", ",", "savedir", ",", "true_iters", ")", ":", "\n", "    ", "\"\"\"Plot predicted and true normalized mean squared erro\"\"\"", "\n", "norms", ",", "sizes", "=", "_calc_wavelet_coeff_norm_and_count", "(", "w0", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "level", ",", "figsize", "=", "(", "20", ",", "10", ")", ")", "\n", "err", "=", "_band_iter_reformat", "(", "log", "[", "'err'", "]", ",", "true_iters", ")", "\n", "tau", "=", "_band_iter_reformat", "(", "log", "[", "'tau'", "]", ",", "true_iters", ")", "\n", "ax", "[", "0", "]", ".", "plot", "(", "10", "*", "np", ".", "log10", "(", "sizes", "[", "0", "]", "*", "err", "[", "0", "]", "/", "(", "norms", "[", "0", "]", "**", "2", ")", ")", ",", "\n", "ls", "=", "'-'", ",", "c", "=", "tutil", ".", "SUBBAND_COLOR", "[", "0", "]", ",", "\n", "label", "=", "'{} True'", ".", "format", "(", "tutil", ".", "SUBBAND", "[", "0", "]", ")", ")", "\n", "ax", "[", "0", "]", ".", "plot", "(", "10", "*", "np", ".", "log10", "(", "sizes", "[", "0", "]", "*", "tau", "[", "0", "]", "/", "(", "norms", "[", "0", "]", "**", "2", ")", ")", ",", "\n", "ls", "=", "':'", ",", "c", "=", "tutil", ".", "SUBBAND_COLOR", "[", "0", "]", ",", "\n", "label", "=", "'{} Model'", ".", "format", "(", "tutil", ".", "SUBBAND", "[", "0", "]", ")", ")", "\n", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "        ", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "            ", "ax", "[", "b", "]", ".", "plot", "(", "10", "*", "np", ".", "log10", "(", "sizes", "[", "b", "+", "1", "]", "[", "s", "]", "*", "err", "[", "b", "+", "1", "]", "[", "s", "]", "/", "(", "norms", "[", "b", "+", "1", "]", "[", "s", "]", "**", "2", ")", ")", ",", "\n", "ls", "=", "'-'", ",", "c", "=", "tutil", ".", "SUBBAND_COLOR", "[", "s", "+", "1", "]", ",", "\n", "label", "=", "'{} True'", ".", "format", "(", "tutil", ".", "SUBBAND", "[", "s", "+", "1", "]", ")", ")", "\n", "ax", "[", "b", "]", ".", "plot", "(", "10", "*", "np", ".", "log10", "(", "sizes", "[", "b", "+", "1", "]", "[", "s", "]", "*", "tau", "[", "b", "+", "1", "]", "[", "s", "]", "/", "(", "norms", "[", "b", "+", "1", "]", "[", "s", "]", "**", "2", ")", ")", ",", "\n", "ls", "=", "':'", ",", "c", "=", "tutil", ".", "SUBBAND_COLOR", "[", "s", "+", "1", "]", ",", "\n", "label", "=", "'{} Model'", ".", "format", "(", "tutil", ".", "SUBBAND", "[", "s", "+", "1", "]", ")", ")", "\n", "", "ax", "[", "b", "]", ".", "set_xlabel", "(", "'Iteration'", ")", "\n", "ax", "[", "b", "]", ".", "set_ylabel", "(", "'NMSE (dB)'", ")", "\n", "ax", "[", "b", "]", ".", "set_title", "(", "'Level {}'", ".", "format", "(", "b", "+", "1", ")", ")", "\n", "", "fig", ".", "suptitle", "(", "'True and Estimated NMSE of r'", ")", "\n", "handles", ",", "labels", "=", "ax", "[", "0", "]", ".", "get_legend_handles_labels", "(", ")", "\n", "fig", ".", "legend", "(", "handles", ",", "labels", ")", "\n", "fig", ".", "savefig", "(", "'{}-err_est.png'", ".", "format", "(", "savedir", ")", ")", "\n", "fig", ".", "clear", "(", ")", "\n", "plt", ".", "close", "(", "fig", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp._calc_wavelet_coeff_norm_and_count": [[269, 284], ["wavelet.get_bands", "numpy.linalg.norm", "numpy.prod", "range", "range", "numpy.linalg.norm", "numpy.prod"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands"], ["", "def", "_calc_wavelet_coeff_norm_and_count", "(", "wavelet", ")", ":", "\n", "    ", "level", "=", "wavelet", ".", "get_bands", "(", ")", "\n", "norms", "=", "[", "None", "]", "*", "(", "level", "+", "1", ")", "\n", "sizes", "=", "[", "None", "]", "*", "(", "level", "+", "1", ")", "\n", "norms", "[", "0", "]", "=", "np", ".", "linalg", ".", "norm", "(", "wavelet", ".", "coeff", "[", "0", "]", ")", "\n", "sizes", "[", "0", "]", "=", "np", ".", "prod", "(", "wavelet", ".", "coeff", "[", "0", "]", ".", "shape", ")", "\n", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "        ", "norms_band", "=", "[", "None", "]", "*", "3", "\n", "sizes_band", "=", "[", "None", "]", "*", "3", "\n", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "            ", "norms_band", "[", "s", "]", "=", "np", ".", "linalg", ".", "norm", "(", "wavelet", ".", "coeff", "[", "b", "+", "1", "]", "[", "s", "]", ")", "\n", "sizes_band", "[", "s", "]", "=", "np", ".", "prod", "(", "wavelet", ".", "coeff", "[", "b", "+", "1", "]", "[", "s", "]", ".", "shape", ")", "\n", "", "norms", "[", "b", "+", "1", "]", "=", "norms_band", "\n", "sizes", "[", "b", "+", "1", "]", "=", "sizes_band", "\n", "", "return", "norms", ",", "sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.experiment.dvdamp_exp._band_iter_reformat": [[285, 299], ["numpy.zeros", "range", "range", "len", "range", "numpy.zeros", "range"], "function", ["None"], ["", "def", "_band_iter_reformat", "(", "target", ",", "true_iters", ")", ":", "\n", "    ", "result", "=", "[", "None", "]", "*", "len", "(", "target", "[", "0", "]", ")", "\n", "result", "[", "0", "]", "=", "np", ".", "zeros", "(", "true_iters", ")", "\n", "for", "i", "in", "range", "(", "true_iters", ")", ":", "\n", "        ", "result", "[", "0", "]", "[", "i", "]", "=", "target", "[", "i", "]", "[", "0", "]", "\n", "", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "        ", "result_band", "=", "[", "None", "]", "*", "3", "\n", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "            ", "result_subband", "=", "np", ".", "zeros", "(", "true_iters", ")", "\n", "for", "i", "in", "range", "(", "true_iters", ")", ":", "\n", "                ", "result_subband", "[", "i", "]", "=", "target", "[", "i", "]", "[", "b", "+", "1", "]", "[", "s", "]", "\n", "", "result_band", "[", "s", "]", "=", "result_subband", "\n", "", "result", "[", "b", "+", "1", "]", "=", "result_band", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.__init__": [[16, 40], ["torch.normal", "numpy.zeros", "ValueError", "torch.zeros", "numpy.random.choice", "torch.rand().round", "torch.rand"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "m", ",", "n", ",", "mode", "=", "'matmul'", ")", ":", "\n", "        ", "\"\"\"Initialize the CS measurement operator.\n\n        Args:\n            m (int): dimension of the measurement.\n            n (int): dimension of the image.\n            mode (str): how to apply the CS measurement operator A.\n                - matmul: matrix multiplication by a Gaussian matrix normalized by column.\n                - jl: Fast Johonson-Lindenstrauss Transform.\n        \"\"\"", "\n", "self", ".", "mode", "=", "mode", "\n", "if", "mode", "==", "'matmul'", ":", "\n", "            ", "A", "=", "torch", ".", "normal", "(", "mean", "=", "torch", ".", "zeros", "(", "m", ",", "n", ")", ",", "std", "=", "1", ")", "\n", "A", "/=", "(", "A", "**", "2", ")", ".", "sum", "(", "dim", "=", "0", ")", ".", "sqrt", "(", ")", "\n", "self", ".", "A", "=", "A", "\n", "", "elif", "mode", "==", "'jl'", ":", "\n", "            ", "idx", "=", "np", ".", "zeros", "(", "m", ")", "\n", "idx", "[", "1", ":", "]", "=", "np", ".", "random", ".", "choice", "(", "n", "-", "1", ",", "m", "-", "1", ",", "replace", "=", "False", ")", "+", "1", "\n", "self", ".", "idx", "=", "idx", "\n", "self", ".", "sign_vector", "=", "(", "2", "*", "torch", ".", "rand", "(", "n", ")", ".", "round", "(", ")", "-", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'deploy.cs.CStransform: Invalid mode'", ")", "\n", "", "self", ".", "m", "=", "m", "\n", "self", ".", "n", "=", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.Afun": [[41, 51], ["cs.CStransform.A.matmul", "torch_dct.dct().view", "ValueError", "numpy.sqrt", "torch_dct.dct"], "methods", ["None"], ["", "def", "Afun", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Operator for A @ x matrix-vector multiplication.\"\"\"", "\n", "if", "self", ".", "mode", "==", "'matmul'", ":", "\n", "            ", "return", "self", ".", "A", ".", "matmul", "(", "x", ")", "\n", "", "elif", "self", ".", "mode", "==", "'jl'", ":", "\n", "            ", "dct_result", "=", "dct", ".", "dct", "(", "(", "self", ".", "sign_vector", "*", "x", ")", ".", "view", "(", "-", "1", ")", ",", "norm", "=", "'ortho'", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "sampling_result", "=", "dct_result", "[", "self", ".", "idx", "]", "\n", "return", "np", ".", "sqrt", "(", "self", ".", "n", "/", "self", ".", "m", ")", "*", "sampling_result", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'deploy.cs.CStransform: Invalid mode'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.Atfun": [[52, 62], ["cs.CStransform.A.transpose().matmul", "torch.zeros", "ValueError", "cs.CStransform.A.transpose", "torch_dct.idct().view", "numpy.sqrt", "torch_dct.idct", "torch.zeros.view"], "methods", ["None"], ["", "", "def", "Atfun", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Operator for A.T @ x matrix-vector multiplication.\"\"\"", "\n", "if", "self", ".", "mode", "==", "'matmul'", ":", "\n", "            ", "return", "self", ".", "A", ".", "transpose", "(", "0", ",", "1", ")", ".", "matmul", "(", "x", ")", "\n", "", "elif", "self", ".", "mode", "==", "'jl'", ":", "\n", "            ", "sampling_result", "=", "torch", ".", "zeros", "(", "self", ".", "n", ",", "1", ")", "\n", "sampling_result", "[", "self", ".", "idx", "]", "=", "x", "\n", "return", "np", ".", "sqrt", "(", "self", ".", "n", "/", "self", ".", "m", ")", "*", "self", ".", "sign_vector", "*", "dct", ".", "idct", "(", "sampling_result", ".", "view", "(", "-", "1", ")", ",", "norm", "=", "'ortho'", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'deploy.cs.CStransform: Invalid mode'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.get_m": [[63, 65], ["None"], "methods", ["None"], ["", "", "def", "get_m", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.get_n": [[66, 68], ["None"], "methods", ["None"], ["", "def", "get_n", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.get_A": [[69, 74], ["ValueError"], "methods", ["None"], ["", "def", "get_A", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "mode", "==", "'matmul'", ":", "\n", "            ", "return", "self", ".", "A", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'deploy.cs.CStransform: Incompatible mode'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.CStransform.set_A_device": [[75, 80], ["cs.CStransform.A.to", "RuntimeError"], "methods", ["None"], ["", "", "def", "set_A_device", "(", "self", ",", "device", ")", ":", "\n", "        ", "if", "self", ".", "mode", "==", "'matmul'", ":", "\n", "            ", "self", ".", "A", "=", "self", ".", "A", ".", "to", "(", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "'util.cs.CStransform.set_A_device: Incompatible mode'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.cs.get_cs_param": [[81, 86], ["int", "int", "numpy.round"], "function", ["None"], ["", "", "", "def", "get_cs_param", "(", "shape", ",", "sampling_rate", ")", ":", "\n", "    ", "_", ",", "H", ",", "W", "=", "shape", "\n", "n", "=", "int", "(", "H", "*", "W", ")", "\n", "m", "=", "int", "(", "np", ".", "round", "(", "n", "*", "sampling_rate", ")", ")", "\n", "return", "m", ",", "n", "\n", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot._fmt": [[18, 24], ["format().replace", "format"], "function", ["None"], ["def", "_fmt", "(", "x", ",", "pos", ")", ":", "\n", "    ", "\"\"\"Formatting for plot_heatmap function\"\"\"", "\n", "if", "x", "==", "0", ":", "\n", "        ", "return", "'0'", "\n", "", "else", ":", "\n", "        ", "return", "format", "(", "x", ",", "'1.0e'", ")", ".", "replace", "(", "\"e-0\"", ",", "\"e-\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.plot_heatmap": [[25, 34], ["matplotlib.imshow", "matplotlib.axis", "matplotlib.colorbar", "plt.colorbar.ax.tick_params", "input.numpy", "matplotlib.FuncFormatter"], "function", ["None"], ["", "", "def", "plot_heatmap", "(", "input", ",", "vmin", "=", "None", ",", "vmax", "=", "None", ",", "tensor", "=", "True", ",", "cmap", "=", "'inferno'", ",", "add_cbar", "=", "True", ",", "cbarfsize", "=", "12", ")", ":", "\n", "    ", "\"\"\"Plot heatmap of tensor with colorbar\"\"\"", "\n", "if", "tensor", ":", "\n", "        ", "input", "=", "input", ".", "numpy", "(", ")", "[", "0", "]", "\n", "", "plt", ".", "imshow", "(", "input", ",", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ",", "cmap", "=", "cmap", ")", "\n", "if", "add_cbar", ":", "\n", "        ", "cbar", "=", "plt", ".", "colorbar", "(", "shrink", "=", "0.8", ",", "format", "=", "ticker", ".", "FuncFormatter", "(", "_fmt", ")", ")", "\n", "cbar", ".", "ax", ".", "tick_params", "(", "labelsize", "=", "cbarfsize", ")", "\n", "", "plt", ".", "axis", "(", "'off'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_heatmap": [[35, 51], ["plot.plot_heatmap", "matplotlib.savefig", "matplotlib.clf", "torch.save", "matplotlib.title", "matplotlib.tight_layout", "matplotlib.subplots_adjust"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.plot_heatmap"], ["", "def", "save_heatmap", "(", "input", ",", "path", ",", "savemode", "=", "'full'", ",", "title", "=", "None", ",", "\n", "vmin", "=", "None", ",", "vmax", "=", "None", ",", "tensor", "=", "True", ",", "cmap", "=", "'inferno'", ",", "add_cbar", "=", "True", ",", "\n", "font", "=", "FONT", ",", "adjust", "=", "None", ")", ":", "\n", "    ", "assert", "savemode", "in", "[", "'full'", ",", "'raw'", ",", "'plot'", "]", "\n", "if", "savemode", "in", "[", "'full'", ",", "'plot'", "]", ":", "\n", "        ", "plot_heatmap", "(", "input", ",", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ",", "tensor", "=", "tensor", ",", "cmap", "=", "cmap", ",", "add_cbar", "=", "add_cbar", ")", "\n", "if", "title", "is", "not", "None", ":", "\n", "            ", "plt", ".", "title", "(", "title", ",", "**", "font", ")", "\n", "", "if", "adjust", "is", "None", ":", "\n", "            ", "plt", ".", "tight_layout", "(", ")", "\n", "", "else", ":", "\n", "            ", "plt", ".", "subplots_adjust", "(", "bottom", "=", "adjust", "[", "0", "]", ",", "top", "=", "adjust", "[", "1", "]", ",", "left", "=", "adjust", "[", "2", "]", ",", "right", "=", "adjust", "[", "3", "]", ")", "\n", "", "plt", ".", "savefig", "(", "'{}.png'", ".", "format", "(", "path", ")", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "", "if", "savemode", "in", "[", "'full'", ",", "'raw'", "]", ":", "\n", "        ", "torch", ".", "save", "(", "input", ",", "'{}.pt'", ".", "format", "(", "path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.get_heatmap_limits": [[52, 61], ["input.min().item", "input.min().item", "input.max().item", "input.max().item", "input.min", "input.min", "input.max", "input.max"], "function", ["None"], ["", "", "def", "get_heatmap_limits", "(", "input_list", ")", ":", "\n", "    ", "vmin", "=", "np", ".", "infty", "\n", "vmax", "=", "-", "np", ".", "infty", "\n", "for", "input", "in", "input_list", ":", "\n", "        ", "if", "vmin", ">", "input", ".", "min", "(", ")", ".", "item", "(", ")", ":", "\n", "            ", "vmin", "=", "input", ".", "min", "(", ")", ".", "item", "(", ")", "\n", "", "if", "vmax", "<", "input", ".", "max", "(", ")", ".", "item", "(", ")", ":", "\n", "            ", "vmax", "=", "input", ".", "max", "(", ")", ".", "item", "(", ")", "\n", "", "", "return", "vmin", ",", "vmax", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.plot.save_sqerror_plot": [[62, 71], ["enumerate", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "matplotlib.savefig", "matplotlib.clf", "matplotlib.plot", "error.mean"], "function", ["None"], ["", "def", "save_sqerror_plot", "(", "error", ",", "windows", ",", "num_noises", ",", "path", ",", "font", "=", "{", "}", ")", ":", "\n", "    ", "for", "i", ",", "num_noise", "in", "enumerate", "(", "num_noises", ")", ":", "\n", "        ", "plt", ".", "plot", "(", "windows", ",", "error", ".", "mean", "(", "dim", "=", "0", ")", "[", ":", ",", "i", "]", ",", "label", "=", "'k = {:d}'", ".", "format", "(", "num_noise", ")", ")", "\n", "", "plt", ".", "xlabel", "(", "'patch size'", ",", "**", "font", ")", "\n", "plt", ".", "ylabel", "(", "'$|MSE - SURE|^2$'", ",", "**", "font", ")", "\n", "plt", ".", "title", "(", "'Mean squared error of SURE heatmap'", ",", "**", "font", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "savefig", "(", "path", ",", "bbox_inches", "=", "'tight'", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.__init__": [[214, 218], ["range", "len", "list"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "coeff", ")", ":", "\n", "        ", "self", ".", "coeff", "=", "coeff", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "self", ".", "coeff", ")", ")", ":", "\n", "            ", "self", ".", "coeff", "[", "i", "]", "=", "list", "(", "coeff", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands": [[219, 222], ["len"], "methods", ["None"], ["", "", "def", "get_bands", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return level of decomposition\"\"\"", "\n", "return", "len", "(", "self", ".", "coeff", ")", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_subbands": [[223, 229], ["range", "len", "len"], "methods", ["None"], ["", "def", "get_subbands", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return total number of wavelet subbands, generally 3 * level + 1\"\"\"", "\n", "subbands", "=", "1", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "self", ".", "coeff", ")", ")", ":", "\n", "            ", "subbands", "+=", "len", "(", "self", ".", "coeff", "[", "i", "]", ")", "\n", "", "return", "subbands", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.count_subbandwise": [[230, 240], ["numpy.zeros", "numpy.zeros", "numpy.prod", "numpy.prod", "range", "transform.Wavelet.get_subbands", "transform.Wavelet.get_bands", "range", "len", "numpy.prod", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_subbands", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.get_bands"], ["", "def", "count_subbandwise", "(", "self", ")", ":", "\n", "        ", "\"\"\"Count number of coefficients in each subband\"\"\"", "\n", "result", "=", "np", ".", "zeros", "(", "self", ".", "get_subbands", "(", ")", ",", "dtype", "=", "int", ")", "\n", "result", "[", "0", "]", "=", "np", ".", "prod", "(", "self", ".", "coeff", "[", "0", "]", ".", "shape", ")", "\n", "idx", "=", "1", "\n", "for", "i", "in", "range", "(", "self", ".", "get_bands", "(", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "len", "(", "self", ".", "coeff", "[", "i", "+", "1", "]", ")", ")", ":", "\n", "                ", "result", "[", "idx", "]", "+=", "np", ".", "prod", "(", "self", ".", "coeff", "[", "i", "+", "1", "]", "[", "j", "]", ".", "shape", ")", "\n", "idx", "+=", "1", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse": [[241, 248], ["transform.Wavelet._subband_to_tuple", "torch.from_numpy", "pywt.waverec2", "pywt.waverec2"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet._subband_to_tuple"], ["", "def", "inverse", "(", "self", ",", "wavelet", "=", "'haar'", ",", "to_tensor", "=", "True", ")", ":", "\n", "        ", "\"\"\"Inverse wavelet transform\"\"\"", "\n", "self", ".", "_subband_to_tuple", "(", ")", "\n", "if", "to_tensor", ":", "\n", "            ", "return", "torch", ".", "from_numpy", "(", "pywt", ".", "waverec2", "(", "self", ".", "coeff", ",", "wavelet", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "pywt", ".", "waverec2", "(", "self", ".", "coeff", ",", "wavelet", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward": [[249, 265], ["transform.Wavelet._subband_to_tuple", "pywt.coeffs_to_array", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet._subband_to_tuple"], ["", "", "def", "pyramid_forward", "(", "self", ",", "get_slices", "=", "False", ",", "to_tensor", "=", "True", ")", ":", "\n", "        ", "\"\"\"Build wavelet pyramid i.e. place wavelet coefficients into an array\n\n        Note:\n            If you want to be able to recover the wavelet from a pyramid, choose to\n            return the slices as well since it is needed for pyramid_backward.\n            Note that the slices depend only on the image shape.\n        \"\"\"", "\n", "self", ".", "_subband_to_tuple", "(", ")", "\n", "pyramid", ",", "slices", "=", "pywt", ".", "coeffs_to_array", "(", "self", ".", "coeff", ",", "axes", "=", "(", "-", "2", ",", "-", "1", ")", ")", "\n", "if", "to_tensor", ":", "\n", "            ", "pyramid", "=", "torch", ".", "from_numpy", "(", "pyramid", ")", "\n", "", "if", "get_slices", ":", "\n", "            ", "return", "pyramid", ",", "slices", "\n", "", "else", ":", "\n", "            ", "return", "pyramid", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.real": [[266, 271], ["transform.Wavelet.pyramid_forward", "numpy.real", "numpy.real", "transform.pyramid_backward"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.real", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.real", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward"], ["", "", "def", "real", "(", "self", ")", ":", "\n", "        ", "\"\"\"Take real part of the wavelet coefficients\"\"\"", "\n", "pyramid", ",", "slices", "=", "self", ".", "pyramid_forward", "(", "get_slices", "=", "True", ",", "to_tensor", "=", "False", ")", "\n", "pyramid", "=", "np", ".", "real", "(", "pyramid", ")", "\n", "return", "pyramid_backward", "(", "pyramid", ",", "slices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.imag": [[272, 277], ["transform.Wavelet.pyramid_forward", "numpy.imag", "numpy.imag", "transform.pyramid_backward"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.imag", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.imag", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward"], ["", "def", "imag", "(", "self", ")", ":", "\n", "        ", "\"\"\"Take imaginary part of the wavelet coefficients\"\"\"", "\n", "pyramid", ",", "slices", "=", "self", ".", "pyramid_forward", "(", "get_slices", "=", "True", ",", "to_tensor", "=", "False", ")", "\n", "pyramid", "=", "np", ".", "imag", "(", "pyramid", ")", "\n", "return", "pyramid_backward", "(", "pyramid", ",", "slices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.copy": [[278, 281], ["transform.Wavelet", "copy.deepcopy"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Deep copy self\"\"\"", "\n", "return", "Wavelet", "(", "deepcopy", "(", "self", ".", "coeff", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.astype": [[282, 287], ["transform.Wavelet.pyramid_forward", "pyramid.astype.astype.astype", "transform.pyramid_backward"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.astype", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward"], ["", "def", "astype", "(", "self", ",", "type", ")", ":", "\n", "        ", "\"\"\"Cast the wavelet coefficients\"\"\"", "\n", "pyramid", ",", "slices", "=", "self", ".", "pyramid_forward", "(", "get_slices", "=", "True", ",", "to_tensor", "=", "False", ")", "\n", "pyramid", "=", "pyramid", ".", "astype", "(", "type", ")", "\n", "return", "pyramid_backward", "(", "pyramid", ",", "slices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet._subband_to_tuple": [[288, 291], ["range", "len", "tuple"], "methods", ["None"], ["", "def", "_subband_to_tuple", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "1", ",", "len", "(", "self", ".", "coeff", ")", ")", ":", "\n", "            ", "self", ".", "coeff", "[", "i", "]", "=", "tuple", "(", "self", ".", "coeff", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.fftnc": [[44, 52], ["numpy.fftshift", "numpy.sqrt", "numpy.fft2", "numpy.prod", "torch.from_numpy().to", "fft.fftshift.astype", "numpy.ifftshift", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.astype"], ["def", "fftnc", "(", "x", ",", "ret_tensor", "=", "False", ")", ":", "\n", "    ", "\"\"\"Normalized FFT of x with low frequency at center\"\"\"", "\n", "X", "=", "fft", ".", "fftshift", "(", "fft", ".", "fft2", "(", "fft", ".", "ifftshift", "(", "x", ")", ")", ")", "\n", "X", "/=", "np", ".", "sqrt", "(", "np", ".", "prod", "(", "x", ".", "shape", ")", ")", "\n", "if", "ret_tensor", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "X", ")", ".", "to", "(", "dtype", "=", "torch", ".", "complex64", ")", "\n", "", "else", ":", "\n", "        ", "return", "X", ".", "astype", "(", "np", ".", "complex64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.ifftnc": [[53, 61], ["numpy.fftshift", "numpy.sqrt", "numpy.ifft2", "numpy.prod", "torch.from_numpy().to", "fft.fftshift.astype", "numpy.ifftshift", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.astype"], ["", "", "def", "ifftnc", "(", "X", ",", "ret_tensor", "=", "False", ")", ":", "\n", "    ", "\"\"\"Inverse FFT for normalized X with low frequency at center\"\"\"", "\n", "x", "=", "fft", ".", "fftshift", "(", "fft", ".", "ifft2", "(", "fft", ".", "ifftshift", "(", "X", ")", ")", ")", "\n", "x", "*=", "np", ".", "sqrt", "(", "np", ".", "prod", "(", "X", ".", "shape", ")", ")", "\n", "if", "ret_tensor", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "x", ")", ".", "to", "(", "dtype", "=", "torch", ".", "complex64", ")", "\n", "", "else", ":", "\n", "        ", "return", "x", ".", "astype", "(", "np", ".", "complex64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.reformat_subband2array": [[64, 80], ["numpy.zeros", "range", "len", "range"], "function", ["None"], ["def", "reformat_subband2array", "(", "subband_val", ")", ":", "\n", "    ", "\"\"\"Reformat variable formatted by subband, e.g. per-subband variance, into an array.\n\n    Args:\n        subband_val (list): subband-wise values, organized as (A, (H1, W1, D1), (H2, W2, D2), ...)\n\n    Returns:\n        result (np.ndarray): subband-wise values sorted in order ([A, H1, W1, D1, H2, W2, D2, ...])\n    \"\"\"", "\n", "level", "=", "len", "(", "subband_val", ")", "-", "1", "\n", "result", "=", "np", ".", "zeros", "(", "1", "+", "3", "*", "level", ")", "\n", "result", "[", "0", "]", "=", "subband_val", "[", "0", "]", "\n", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "        ", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "            ", "result", "[", "3", "*", "b", "+", "s", "+", "1", "]", "=", "subband_val", "[", "b", "+", "1", "]", "[", "s", "]", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.reformat_array2subband": [[81, 103], ["len", "range", "range"], "function", ["None"], ["", "def", "reformat_array2subband", "(", "array", ")", ":", "\n", "    ", "\"\"\"Reformat array values to the wavelet subband format.\n\n    Args:\n        array (np.ndarray): subband-wise values sorted in order ([A, H1, W1, D1, H2, W2, D2, ...])\n\n    Returns:\n        subband_val (list): subband-wise values, organized as (A, (H1, W1, D1), (H2, W2, D2), ...)\n        \n    \"\"\"", "\n", "num_values", "=", "len", "(", "array", ")", "\n", "level", "=", "(", "num_values", "-", "1", ")", "//", "3", "\n", "subband_val", "=", "[", "None", "]", "*", "(", "level", "+", "1", ")", "\n", "subband_val", "[", "0", "]", "=", "array", "[", "0", "]", "\n", "idx", "=", "1", "\n", "for", "b", "in", "range", "(", "level", ")", ":", "\n", "        ", "this_band", "=", "[", "None", "]", "*", "3", "\n", "for", "s", "in", "range", "(", "3", ")", ":", "\n", "            ", "this_band", "[", "s", "]", "=", "array", "[", "idx", "]", "\n", "idx", "+=", "1", "\n", "", "subband_val", "[", "b", "+", "1", "]", "=", "this_band", "\n", "", "return", "subband_val", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.forward": [[104, 116], ["transform.Wavelet", "pywt.wavedec2"], "function", ["None"], ["", "def", "forward", "(", "image", ",", "wavelet", "=", "'haar'", ",", "level", "=", "4", ")", ":", "\n", "    ", "\"\"\"Wavelet transform.\n\n    Args:\n        image (np.ndarray): image to apply wavelet transform.\n        wavelet (str): type of wavelet. Refer to PyWavelets for the options.\n        level (int): level of wavelet decomposition.\n\n    Returns:\n        result (Wavelet): resulting wavelet.\n    \"\"\"", "\n", "return", "Wavelet", "(", "pywt", ".", "wavedec2", "(", "image", ",", "wavelet", ",", "level", "=", "level", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward": [[117, 128], ["transform.Wavelet", "pywt.array_to_coeffs"], "function", ["None"], ["", "def", "pyramid_backward", "(", "pyramid", ",", "slices", ")", ":", "\n", "    ", "\"\"\"Recover Wavelet object from the wavelet pyramid.\n\n    Args:\n        pyramid (np.ndarray): the wavelet pyramid.\n        slices (list of tuples): list of slices obtained from pyramid_forward required by pywt.array_to_coeffs.\n\n    Returns:\n        result (Wavelet): resulting wavelet.\n    \"\"\"", "\n", "return", "Wavelet", "(", "pywt", ".", "array_to_coeffs", "(", "pyramid", ",", "slices", ",", "output_format", "=", "'wavedec2'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.add": [[129, 146], ["w1.pyramid_forward", "w2.pyramid_forward", "transform.pyramid_backward", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward"], ["", "def", "add", "(", "w1", ",", "w2", ",", "safe", "=", "False", ")", ":", "\n", "    ", "\"\"\"Add two wavelets element-wise (band-by-band).\n\n    Args:\n        w1 (Wavelet): a wavelet to add.\n        w2 (Wavelet): another wavelet to add.\n        safe (bool): whether to check if the computation is legal.\n\n    Returns:\n        result (Wavelet): the sum of w1 and w2 element-wise.\n    \"\"\"", "\n", "pyramid_1", ",", "slices_1", "=", "w1", ".", "pyramid_forward", "(", "get_slices", "=", "True", ",", "to_tensor", "=", "False", ")", "\n", "pyramid_2", ",", "slices_2", "=", "w2", ".", "pyramid_forward", "(", "get_slices", "=", "True", ",", "to_tensor", "=", "False", ")", "\n", "if", "safe", "and", "slices_1", "!=", "slices_2", ":", "\n", "        ", "raise", "RuntimeError", "(", "'utils.wavelet.add: levels of the wavelets are different.'", ")", "\n", "", "pyramid_sum", "=", "pyramid_1", "+", "pyramid_2", "\n", "return", "pyramid_backward", "(", "pyramid_sum", ",", "slices_1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.sub": [[147, 164], ["w1.pyramid_forward", "w2.pyramid_forward", "transform.pyramid_backward", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.pyramid_forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.pyramid_backward"], ["", "def", "sub", "(", "w1", ",", "w2", ",", "safe", "=", "False", ")", ":", "\n", "    ", "\"\"\"Subtract two wavelets element-wise (band-by-band).\n\n    Args:\n        w1 (Wavelet): a wavelet to be subtracted.\n        w2 (Wavelet): a wavelet to subtract.\n        safe (bool): whether to check if the computation is legal.\n\n    Returns:\n        result (Wavelet): the result of w1 - w2 element-wise.\n    \"\"\"", "\n", "pyramid_1", ",", "slices_1", "=", "w1", ".", "pyramid_forward", "(", "get_slices", "=", "True", ",", "to_tensor", "=", "False", ")", "\n", "pyramid_2", ",", "slices_2", "=", "w2", ".", "pyramid_forward", "(", "get_slices", "=", "True", ",", "to_tensor", "=", "False", ")", "\n", "if", "safe", "and", "slices_1", "!=", "slices_2", ":", "\n", "        ", "raise", "RuntimeError", "(", "'utils.wavelet.add: levels of the wavelets are different.'", ")", "\n", "", "pyramid_sum", "=", "pyramid_1", "-", "pyramid_2", "\n", "return", "pyramid_backward", "(", "pyramid_sum", ",", "slices_1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.mul_subbandwise": [[165, 184], ["wavelet.copy", "range", "len", "range", "len"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.copy"], ["", "def", "mul_subbandwise", "(", "wavelet", ",", "scalars", ")", ":", "\n", "    ", "\"\"\"Multiply each subband of a wavelet by a scalar.\n\n    Args:\n        wavelet (Wavelet): a wavelet.\n        scalars (list of float): list of scalars to multiply the wavelet. The length of scalars\n            must match the number of wavelet subbands.\n\n    Returns:\n        result (Wavelet): scalars * wavelet subband-wise.\n    \"\"\"", "\n", "result", "=", "wavelet", ".", "copy", "(", ")", "\n", "result", ".", "coeff", "[", "0", "]", "*=", "scalars", "[", "0", "]", "\n", "idx", "=", "1", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "result", ".", "coeff", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "result", ".", "coeff", "[", "i", "]", ")", ")", ":", "\n", "            ", "result", ".", "coeff", "[", "i", "]", "[", "j", "]", "*=", "scalars", "[", "idx", "]", "\n", "idx", "+=", "1", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.add_noise_subbandwise": [[185, 208], ["wavelet.copy", "util.general.generate_noise", "range", "len", "range", "len", "util.general.generate_noise"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.copy", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_noise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_noise"], ["", "def", "add_noise_subbandwise", "(", "wavelet", ",", "stds", ",", "is_complex", "=", "False", ")", ":", "\n", "    ", "\"\"\"Add Gaussian noise to each wavelet subband.\n\n    Args:\n        wavelet (Wavelet): a wavelet.\n        stds (list of float): list of Gaussian noise standard deviation in each subband.\n        is_complex (bool): whether the noise to add is complex\n\n    Returns:\n        result (Wavelet): noisy wavelet.\n\n    Note:\n        When is_complex is True, for a standard deviation sigma of a subband, the noise is added independently\n        to the real and imaginary part in that subband, each part with standard deviation sigma / sqrt(2).\n    \"\"\"", "\n", "result", "=", "wavelet", ".", "copy", "(", ")", "\n", "result", ".", "coeff", "[", "0", "]", "+=", "gutil", ".", "generate_noise", "(", "result", ".", "coeff", "[", "0", "]", ".", "shape", ",", "stds", "[", "0", "]", ",", "ret_array", "=", "True", ",", "is_complex", "=", "is_complex", ")", "\n", "idx", "=", "1", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "result", ".", "coeff", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "result", ".", "coeff", "[", "i", "]", ")", ")", ":", "\n", "            ", "result", ".", "coeff", "[", "i", "]", "[", "j", "]", "+=", "gutil", ".", "generate_noise", "(", "result", ".", "coeff", "[", "i", "]", "[", "j", "]", ".", "shape", ",", "stds", "[", "idx", "]", ",", "ret_array", "=", "True", ",", "is_complex", "=", "is_complex", ")", "\n", "idx", "+=", "1", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.normalize": [[50, 53], ["None"], "function", ["None"], ["def", "normalize", "(", "input", ")", ":", "\n", "    ", "\"\"\"Normalize pixel values from [0, 255] to [0., 1.]\"\"\"", "\n", "return", "input", "/", "255.", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.clamp": [[54, 57], ["torch.clamp"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.clamp"], ["", "def", "clamp", "(", "image", ",", "min", "=", "0.", ",", "max", "=", "1.", ")", ":", "\n", "    ", "\"\"\"Clamp values in input tensor exceeding (min, max) to (min, max)\"\"\"", "\n", "return", "torch", ".", "clamp", "(", "image", ",", "min", ",", "max", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.im_numpy_to_tensor": [[58, 61], ["torch.from_numpy().unsqueeze", "torch.from_numpy"], "function", ["None"], ["", "def", "im_numpy_to_tensor", "(", "image", ")", ":", "\n", "    ", "\"\"\"Reformat (H, W) np.ndarray to (1, H, W) tensor\"\"\"", "\n", "return", "torch", ".", "from_numpy", "(", "image", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.calc_psnr": [[62, 66], ["torch.nn.functional.mse_loss", "torch.log10().item", "torch.log10", "torch.sqrt"], "function", ["None"], ["", "def", "calc_psnr", "(", "test_image", ",", "target_image", ",", "max", "=", "1.", ")", ":", "\n", "    ", "\"\"\"Calculate PSNR of images.\"\"\"", "\n", "mse", "=", "mse_loss", "(", "test_image", ",", "target_image", ")", "\n", "return", "20", "*", "torch", ".", "log10", "(", "max", "/", "torch", ".", "sqrt", "(", "mse", ")", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_noise": [[67, 78], ["torch.normal", "torch.normal", "torch.normal.numpy", "torch.zeros", "torch.zeros"], "function", ["None"], ["", "def", "generate_noise", "(", "size", ",", "std", ",", "ret_array", "=", "False", ",", "is_complex", "=", "False", ")", ":", "\n", "    ", "\"\"\"Generate zero-mean white Gaussian noise.\"\"\"", "\n", "if", "is_complex", ":", "\n", "# Real part and imaginary part are independent. Each has variance = (std ** 2) / 2.", "\n", "        ", "noise", "=", "torch", ".", "normal", "(", "mean", "=", "torch", ".", "zeros", "(", "*", "size", ",", "dtype", "=", "torch", ".", "complex64", ")", ",", "std", "=", "std", ")", "\n", "", "else", ":", "\n", "        ", "noise", "=", "torch", ".", "normal", "(", "mean", "=", "torch", ".", "zeros", "(", "*", "size", ")", ",", "std", "=", "std", ")", "\n", "", "if", "ret_array", ":", "\n", "        ", "return", "noise", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.add_noise": [[79, 83], ["general.generate_noise"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_noise"], ["", "", "def", "add_noise", "(", "image", ",", "std", ")", ":", "\n", "    ", "\"\"\"Add zero-mean white Gaussian noise to image\"\"\"", "\n", "noise", "=", "generate_noise", "(", "image", ".", "shape", ",", "std", ")", "\n", "return", "image", "+", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.save_cpx_image": [[84, 88], ["torchvision.utils.save_image", "torchvision.utils.save_image"], "function", ["None"], ["", "def", "save_cpx_image", "(", "image", ",", "name", ")", ":", "\n", "    ", "\"\"\"Save a complex image (represented by real and imaginary channels) as two images.\"\"\"", "\n", "save_image", "(", "image", "[", "0", "]", ",", "'{}_real.png'", ".", "format", "(", "name", ")", ")", "\n", "save_image", "(", "image", "[", "1", "]", ",", "'{}_imag.png'", ".", "format", "(", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.read_image": [[89, 109], ["PIL.Image.open", "to_tensor", "image.resize.convert", "image.resize.convert", "image.resize.resize", "int", "int"], "function", ["None"], ["", "def", "read_image", "(", "path", ",", "rgb", "=", "False", ",", "scale", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"Read image from path using PIL.Image\n\n    Args:\n        path (str): path to the image file.\n        rgb (bool): whether to read image as rgb. Otherwise, read image as grayscale.\n        scale (float): resize the image by the scale.\n\n    Returns:\n        image (torch.Tensor): image Tensor in (C, H, W) shape.\n    \"\"\"", "\n", "image", "=", "Image", ".", "open", "(", "path", ")", "\n", "if", "rgb", ":", "\n", "        ", "image", "=", "image", ".", "convert", "(", "'rgb'", ")", "\n", "", "else", ":", "\n", "        ", "image", "=", "image", ".", "convert", "(", "'L'", ")", "\n", "", "if", "scale", "!=", "1.0", ":", "\n", "        ", "new_size", "=", "(", "int", "(", "image", ".", "size", "[", "0", "]", "*", "scale", ")", ",", "int", "(", "image", ".", "size", "[", "1", "]", "*", "scale", ")", ")", "\n", "image", "=", "image", ".", "resize", "(", "new_size", ",", "Image", ".", "ANTIALIAS", ")", "\n", "", "return", "to_tensor", "(", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.prepare_image_path": [[110, 119], ["general.generate_loadlist", "general.generate_namelist", "len"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_loadlist", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_namelist"], ["", "def", "prepare_image_path", "(", "datadir", ",", "oneim", "=", "False", ")", ":", "\n", "    ", "\"\"\"Generate loadlist and namelist\"\"\"", "\n", "loadlist", "=", "generate_loadlist", "(", "datadir", ")", "\n", "namelist", "=", "generate_namelist", "(", "datadir", ",", "no_exten", "=", "True", ")", "\n", "if", "oneim", ":", "\n", "        ", "loadlist", "=", "[", "loadlist", "[", "0", "]", "]", "\n", "namelist", "=", "[", "namelist", "[", "0", "]", "]", "\n", "", "num_images", "=", "len", "(", "loadlist", ")", "\n", "return", "loadlist", ",", "namelist", ",", "num_images", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_loadlist": [[120, 129], ["general.generate_namelist", "enumerate", "len", "os.path.join", "len"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_namelist"], ["", "def", "generate_loadlist", "(", "datadir", ",", "prefix", "=", "None", ",", "suffix", "=", "None", ",", "num_files", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generate list of paths to images\"\"\"", "\n", "namelist", "=", "generate_namelist", "(", "datadir", ",", "prefix", "=", "prefix", ",", "suffix", "=", "suffix", ",", "num_files", "=", "num_files", ")", "\n", "if", "num_files", "is", "None", "or", "len", "(", "namelist", ")", "<", "num_files", ":", "\n", "        ", "num_files", "=", "len", "(", "namelist", ")", "\n", "", "loadlist", "=", "[", "None", "]", "*", "num_files", "\n", "for", "i", ",", "name", "in", "enumerate", "(", "namelist", ")", ":", "\n", "        ", "loadlist", "[", "i", "]", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "name", ")", "\n", "", "return", "loadlist", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_namelist": [[130, 176], ["sorted", "os.listdir", "len", "enumerate", "name.startswith", "name.endswith", "len", "prefix_filtered_list.append", "filtered_list.append", "os.path.splitext", "name.startswith"], "function", ["None"], ["", "def", "generate_namelist", "(", "datadir", ",", "num_files", "=", "None", ",", "prefix", "=", "None", ",", "suffix", "=", "None", ",", "no_exten", "=", "False", ",", "no_hidden", "=", "True", ")", ":", "\n", "    ", "\"\"\"Generate list of file names in a directory\n    \n    Args:\n        datadir (std): path to directory containing files.\n        num_files (int): number of files to read. If a number is given, return first num_files names by \n            lexicographical order. If None, read all files satisfying other criteria (prefix, etc.).\n        prefix (str): return only file names beginning with this prefix.\n        suffix (str): return only file names (including the extension) ending with this suffix.\n        no_exten (bool): whether to include the extension in the returning file names.\n        no_hidden (bool): whether to include hidden files.\n\n    Returns:\n        namelist (list): list of file names.\n    \"\"\"", "\n", "raw_list", "=", "sorted", "(", "os", ".", "listdir", "(", "datadir", ")", ")", "\n", "if", "prefix", "is", "not", "None", ":", "\n", "        ", "prefix_filtered_list", "=", "[", "]", "\n", "for", "name", "in", "raw_list", ":", "\n", "            ", "if", "name", ".", "startswith", "(", "prefix", ")", ":", "\n", "                ", "prefix_filtered_list", ".", "append", "(", "name", ")", "\n", "", "", "", "else", ":", "\n", "        ", "prefix_filtered_list", "=", "raw_list", "\n", "", "if", "suffix", "is", "not", "None", ":", "\n", "        ", "filtered_list", "=", "[", "]", "\n", "for", "name", "in", "prefix_filtered_list", ":", "\n", "            ", "if", "name", ".", "endswith", "(", "suffix", ")", ":", "\n", "                ", "filtered_list", ".", "append", "(", "name", ")", "\n", "", "", "", "else", ":", "\n", "        ", "filtered_list", "=", "prefix_filtered_list", "\n", "\n", "", "if", "num_files", "is", "None", "or", "len", "(", "filtered_list", ")", "<", "num_files", ":", "\n", "        ", "num_files", "=", "len", "(", "filtered_list", ")", "\n", "\n", "", "if", "no_exten", ":", "\n", "        ", "namelist", "=", "[", "None", "]", "*", "num_files", "\n", "namelist_with_exten", "=", "filtered_list", "[", ":", "num_files", "]", "\n", "for", "i", ",", "name", "in", "enumerate", "(", "namelist_with_exten", ")", ":", "\n", "            ", "namelist", "[", "i", "]", "=", "os", ".", "path", ".", "splitext", "(", "name", ")", "[", "0", "]", "\n", "", "", "else", ":", "\n", "        ", "namelist", "=", "filtered_list", "[", ":", "num_files", "]", "\n", "\n", "", "if", "no_hidden", ":", "\n", "        ", "namelist", "=", "[", "name", "for", "name", "in", "namelist", "if", "not", "name", ".", "startswith", "(", "'.'", ")", "]", "\n", "\n", "", "return", "namelist", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.remove_if_exists": [[177, 183], ["os.remove"], "function", ["None"], ["", "def", "remove_if_exists", "(", "path", ")", ":", "\n", "    ", "\"\"\"Remove file if exists\"\"\"", "\n", "try", ":", "\n", "        ", "os", ".", "remove", "(", "path", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.mkdir_if_not_exists": [[184, 188], ["os.path.exists", "os.mkdir"], "function", ["None"], ["", "", "def", "mkdir_if_not_exists", "(", "path", ")", ":", "\n", "    ", "\"\"\"Make a directory if not already exists\"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.print_arguments": [[189, 193], ["vars", "print", "getattr"], "function", ["None"], ["", "", "def", "print_arguments", "(", "args", ")", ":", "\n", "    ", "\"\"\"Print arguments in a given argparse.Namespace object\"\"\"", "\n", "for", "arg", "in", "vars", "(", "args", ")", ":", "\n", "        ", "print", "(", "'{}: {}'", ".", "format", "(", "arg", ",", "getattr", "(", "args", ",", "arg", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.log_arguments": [[194, 199], ["open", "vars", "f.write", "getattr"], "function", ["None"], ["", "", "def", "log_arguments", "(", "args", ",", "path", ")", ":", "\n", "    ", "\"\"\"Write arguments in a given argparse.Namespace object to a text file.\"\"\"", "\n", "with", "open", "(", "path", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "for", "arg", "in", "vars", "(", "args", ")", ":", "\n", "            ", "f", ".", "write", "(", "'{}: {}\\n'", ".", "format", "(", "arg", ",", "getattr", "(", "args", ",", "arg", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.load_checkpoint": [[200, 228], ["torch.device", "torch.load", "model.load_state_dict", "optimizer.load_state_dict"], "function", ["None"], ["", "", "", "def", "load_checkpoint", "(", "cpdir", ",", "model", ",", "optimizer", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "    ", "\"\"\"Load model and optimizer parameters from checkpoint\n\n    Note:\n        If optimizer is None, do not load optimizer.\n        The checkpoint is expected to be a dict containing theh following keys,\n            'model_state_dict': state dict of the model,\n            'optimizer_state_dict': state dict of the optimizer,\n            'epoch': the epoch count.\n            'global_step': the global step count.\n\n    Args:\n        cpdir (str): path to the checkpoint.\n        model: the model to load the parameters to.\n        optimizer: the optimizer to load parameters to.\n            If None (e.g. test, deploy, etc.), do not load optimizer.\n\n    Returns:\n        start_global_step (int): the global step from the checkpoint.\n        start_epoch (int): the epoch from the checkpoint.\n    \"\"\"", "\n", "checkpoint", "=", "torch", ".", "load", "(", "cpdir", ",", "map_location", "=", "device", ")", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model_state_dict'", "]", ")", "\n", "if", "optimizer", "is", "not", "None", ":", "\n", "        ", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer_state_dict'", "]", ")", "\n", "", "start_epoch", "=", "checkpoint", "[", "'epoch'", "]", "\n", "start_global_step", "=", "checkpoint", "[", "'global_step'", "]", "\n", "return", "start_global_step", ",", "start_epoch", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.ImageToPatches.__init__": [[31, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "window", ",", "stride", "=", "None", ")", ":", "\n", "        ", "self", ".", "window", "=", "window", "\n", "if", "stride", "is", "None", ":", "\n", "            ", "self", ".", "stride", "=", "window", "\n", "", "else", ":", "\n", "            ", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.ImageToPatches.__call__": [[38, 52], ["torch.zeros", "range", "range"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "image", ")", ":", "\n", "        ", "C", ",", "H", ",", "W", "=", "image", ".", "shape", "\n", "numPatchesH", "=", "(", "H", "-", "self", ".", "window", ")", "//", "self", ".", "stride", "+", "1", "\n", "numPatchesW", "=", "(", "W", "-", "self", ".", "window", ")", "//", "self", ".", "stride", "+", "1", "\n", "numPatches", "=", "numPatchesH", "*", "numPatchesW", "\n", "patches", "=", "torch", ".", "zeros", "(", "numPatches", ",", "C", ",", "self", ".", "window", ",", "self", ".", "window", ")", "\n", "idx", "=", "0", "\n", "for", "kh", "in", "range", "(", "numPatchesH", ")", ":", "\n", "            ", "for", "kw", "in", "range", "(", "numPatchesW", ")", ":", "\n", "                ", "patches", "[", "idx", "]", "=", "image", "[", ":", ",", "\n", "kh", "*", "self", ".", "stride", ":", "kh", "*", "self", ".", "stride", "+", "self", ".", "window", ",", "\n", "kw", "*", "self", ".", "stride", ":", "kw", "*", "self", ".", "stride", "+", "self", ".", "window", "]", "\n", "idx", "+=", "1", "\n", "", "", "return", "patches", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.PatchesToImage.__init__": [[63, 67], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "height", ",", "width", ",", "stride", "=", "None", ")", ":", "\n", "        ", "self", ".", "height", "=", "height", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.PatchesToImage.__call__": [[68, 96], ["torch.zeros", "range", "torch.ones", "torch.zeros", "torch.zeros", "range", "range", "range"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "patches", ")", ":", "\n", "        ", "_", ",", "c", ",", "h", ",", "w", "=", "patches", ".", "shape", "\n", "if", "self", ".", "stride", "is", "None", ":", "\n", "            ", "numPatchesH", "=", "self", ".", "height", "//", "h", "\n", "numPatchesW", "=", "self", ".", "width", "//", "w", "\n", "image", "=", "torch", ".", "zeros", "(", "c", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "idx", "=", "0", "\n", "for", "kh", "in", "range", "(", "numPatchesH", ")", ":", "\n", "                ", "for", "kw", "in", "range", "(", "numPatchesW", ")", ":", "\n", "                    ", "image", "[", ":", ",", "kh", "*", "h", ":", "(", "kh", "+", "1", ")", "*", "h", ",", "\n", "kw", "*", "w", ":", "(", "kw", "+", "1", ")", "*", "w", "]", "=", "patches", "[", "idx", "]", "\n", "idx", "+=", "1", "\n", "", "", "", "else", ":", "\n", "            ", "numPatchesH", "=", "(", "self", ".", "height", "-", "h", ")", "//", "self", ".", "stride", "+", "1", "\n", "numPatchesW", "=", "(", "self", ".", "width", "-", "w", ")", "//", "self", ".", "stride", "+", "1", "\n", "one_patches", "=", "torch", ".", "ones", "(", "*", "patches", ".", "shape", ")", "\n", "overlap_factor", "=", "torch", ".", "zeros", "(", "c", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "image", "=", "torch", ".", "zeros", "(", "c", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "idx", "=", "0", "\n", "for", "kh", "in", "range", "(", "numPatchesH", ")", ":", "\n", "                ", "for", "kw", "in", "range", "(", "numPatchesW", ")", ":", "\n", "                    ", "image", "[", ":", ",", "kh", "*", "self", ".", "stride", ":", "kh", "*", "self", ".", "stride", "+", "h", ",", "\n", "kw", "*", "self", ".", "stride", ":", "kw", "*", "self", ".", "stride", "+", "w", "]", "+=", "patches", "[", "idx", "]", "\n", "overlap_factor", "[", ":", ",", "kh", "*", "self", ".", "stride", ":", "kh", "*", "self", ".", "stride", "+", "h", ",", "\n", "kw", "*", "self", ".", "stride", ":", "kw", "*", "self", ".", "stride", "+", "w", "]", "+=", "one_patches", "[", "idx", "]", "\n", "idx", "+=", "1", "\n", "", "", "image", "/=", "overlap_factor", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.VecToPatches.__init__": [[105, 108], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "window", ",", "channels", "=", "1", ")", ":", "\n", "        ", "self", ".", "window", "=", "window", "\n", "self", ".", "channels", "=", "channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.VecToPatches.__call__": [[109, 114], ["vec.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "vec.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "vec.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "vec.unsqueeze().expand.unsqueeze().expand.unsqueeze", "vec.unsqueeze().expand.unsqueeze().expand.unsqueeze", "vec.unsqueeze().expand.unsqueeze().expand.unsqueeze"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "vec", ")", ":", "\n", "        ", "vec", "=", "vec", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "self", ".", "channels", ")", "\n", "vec", "=", "vec", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "self", ".", "window", ")", "\n", "vec", "=", "vec", ".", "unsqueeze", "(", "3", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "-", "1", ",", "self", ".", "window", ")", "\n", "return", "vec", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.patch.calc_num_patches": [[13, 23], ["None"], "function", ["None"], ["def", "calc_num_patches", "(", "height", ",", "width", ",", "window", ",", "stride", "=", "None", ",", "ret_hw", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculate number of patches given image dimension and window size\"\"\"", "\n", "if", "stride", "is", "None", ":", "\n", "        ", "stride", "=", "window", "\n", "", "numPatchesH", "=", "(", "height", "-", "window", ")", "//", "stride", "+", "1", "\n", "numPatchesW", "=", "(", "width", "-", "window", ")", "//", "stride", "+", "1", "\n", "if", "ret_hw", ":", "\n", "        ", "return", "numPatchesH", ",", "numPatchesW", "\n", "", "else", ":", "\n", "        ", "return", "numPatchesH", "*", "numPatchesW", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.train_util.FixedAngleRotation.__init__": [[56, 58], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "angles", ")", ":", "\n", "        ", "self", ".", "angles", "=", "angles", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.train_util.FixedAngleRotation.__call__": [[59, 62], ["float", "torchvision.transforms.functional.rotate", "numpy.random.choice"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "        ", "angle", "=", "float", "(", "np", ".", "random", ".", "choice", "(", "self", ".", "angles", ")", ")", "\n", "return", "rotate", "(", "x", ",", "angle", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.train_util.batch_psnr": [[10, 28], ["torch.no_grad", "range", "util.general.calc_psnr"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.calc_psnr"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "batch_psnr", "(", "test_image", ",", "target_image", ",", "max", "=", "1.", ")", ":", "\n", "    ", "\"\"\"Calculate average PSNR of a batch of denoised image\n    Note:\n        The first dimension of the batches must be N (batch size).\n    Args:\n        test_image (torch.Tensor): batch to calculate PSNR.\n        target_image (torch.Tensor): groud truth batch.\n        max (float): maximum pixel value on the scale e.g. 1. from [0., 1.].\n    Returns:\n        psnr (float): average PSNR value.\n    \"\"\"", "\n", "psnr", "=", "0", "\n", "num_images", "=", "test_image", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "        ", "psnr", "+=", "calc_psnr", "(", "test_image", "[", "i", "]", ",", "target_image", "[", "i", "]", ",", "max", "=", "max", ")", "\n", "", "psnr", "/=", "num_images", "\n", "return", "psnr", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.train_util.load_checkpoint_train": [[29, 52], ["util.general.load_checkpoint"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.load_checkpoint"], ["", "def", "load_checkpoint_train", "(", "cpdir", ",", "model", ",", "optimizer", ")", ":", "\n", "    ", "\"\"\"Load model and optimizer parameters for training\n    Note:\n        This is simply a wrapper to load_checkpoint so that\n        global_step and epoch are updated correctly.\n        If cpdir is None, do not load checkpoint and returns\n        0 for global_step and epoch.\n    Args:\n        cpdir (str): path to the checkpoint.\n        model: the model to load the parameters to.\n        optimizer: the optimizer to load parameters to.\n    Returns:\n        start_global_step (int): the global step from the checkpoint.\n        start_epoch (int): the epoch from the checkpoint.\n    \"\"\"", "\n", "start_epoch", "=", "0", "\n", "start_global_step", "=", "0", "\n", "if", "cpdir", "is", "not", "None", ":", "\n", "        ", "start_global_step", ",", "start_epoch", "=", "load_checkpoint", "(", "\n", "cpdir", ",", "model", ",", "optimizer", ")", "\n", "start_global_step", "+=", "1", "\n", "start_epoch", "+=", "1", "\n", "", "return", "start_global_step", ",", "start_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.dataset.DenoiseDataset.__init__": [[26, 46], ["torch.utils.data.Dataset.__init__", "h5py.File", "list", "h5py.File.close", "h5py.File.keys"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "datadir", ",", "std_range", ",", "wavetype", "=", "'haar'", ",", "level", "=", "4", ",", "transforms", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            datadir (str): path to .h5 file.\n            transform: image transformation, for data augmentation.\n            \n        Note:\n            If sigma or alpha are lists of two entries, the value used will be\n            uniformly sampled from the two values.\n        \"\"\"", "\n", "super", "(", "DenoiseDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "datadir", "=", "datadir", "\n", "self", ".", "std_range", "=", "std_range", "\n", "self", ".", "wavetype", "=", "wavetype", "\n", "self", ".", "level", "=", "level", "\n", "self", ".", "num_stds", "=", "3", "*", "level", "+", "1", "\n", "self", ".", "transforms", "=", "transforms", "\n", "h5f", "=", "h5py", ".", "File", "(", "datadir", ",", "'r'", ")", "\n", "self", ".", "keys", "=", "list", "(", "h5f", ".", "keys", "(", ")", ")", "\n", "h5f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.dataset.DenoiseDataset.__len__": [[47, 49], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.dataset.DenoiseDataset.__getitem__": [[50, 63], ["h5py.File", "torch.Tensor", "h5py.File.close", "dataset.DenoiseDataset._generate_noisy_image", "dataset.DenoiseDataset.transforms"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.dataset.DenoiseDataset._generate_noisy_image"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Return image, noise pair of the same size (C, H, W).\"\"\"", "\n", "# Load image", "\n", "h5f", "=", "h5py", ".", "File", "(", "self", ".", "datadir", ",", "'r'", ")", "\n", "key", "=", "self", ".", "keys", "[", "idx", "]", "\n", "image", "=", "torch", ".", "Tensor", "(", "h5f", "[", "key", "]", ")", "\n", "h5f", ".", "close", "(", ")", "\n", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "image", "=", "self", ".", "transforms", "(", "image", ")", "\n", "\n", "", "noisy_image", ",", "stds", "=", "self", ".", "_generate_noisy_image", "(", "image", ")", "\n", "\n", "return", "image", ",", "noisy_image", ",", "stds", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.dataset.DenoiseDataset._generate_noisy_image": [[64, 70], ["util.transform.forward", "torch.FloatTensor().uniform_", "util.transform.add_noise_subbandwise", "util.transform.add_noise_subbandwise.inverse", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.add_noise_subbandwise", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.transform.Wavelet.inverse"], ["", "def", "_generate_noisy_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "wavelet", "=", "transform", ".", "forward", "(", "image", ",", "wavelet", "=", "self", ".", "wavetype", ",", "level", "=", "self", ".", "level", ")", "\n", "stds", "=", "torch", ".", "FloatTensor", "(", "self", ".", "num_stds", ")", ".", "uniform_", "(", "self", ".", "std_range", "[", "0", "]", ",", "self", ".", "std_range", "[", "1", "]", ")", "\n", "noisy_wavelet", "=", "transform", ".", "add_noise_subbandwise", "(", "wavelet", ",", "stds", ",", "is_complex", "=", "False", ")", "\n", "noisy_image", "=", "noisy_wavelet", ".", "inverse", "(", "wavelet", "=", "self", ".", "wavetype", ")", "\n", "return", "noisy_image", ",", "stds", "", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.preprocess.generate_datasets": [[23, 48], ["util.general.generate_loadlist", "os.path.join", "util.general.remove_if_exists", "preprocess.generate_h5", "util.general.generate_loadlist", "os.path.join", "util.general.remove_if_exists", "preprocess.generate_h5", "util.general.generate_loadlist", "os.path.join", "util.general.remove_if_exists", "preprocess.generate_h5", "os.path.join", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_loadlist", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.remove_if_exists", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.preprocess.generate_h5", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_loadlist", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.remove_if_exists", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.preprocess.generate_h5", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.generate_loadlist", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.remove_if_exists", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.preprocess.generate_h5"], ["def", "generate_datasets", "(", "rootdir", ",", "num_train", "=", "None", ",", "num_val", "=", "None", ",", "num_test", "=", "None", ",", "train_window", "=", "40", ")", ":", "\n", "    ", "\"\"\"Generate train and test datasets.\n    Args:\n        rootdir (str): path to the data directory\n        num_train (int): number of images to be read for train set.\n        num_val (int): number of images to be read for validation set.\n        num_test (int): number of images to be read for test set.\n    \"\"\"", "\n", "# Generate train dataset", "\n", "loadlist", "=", "generate_loadlist", "(", "os", ".", "path", ".", "join", "(", "rootdir", ",", "'train'", ")", ",", "num_files", "=", "num_train", ",", "suffix", "=", "'.jpg'", ")", "\n", "savename", "=", "os", ".", "path", ".", "join", "(", "rootdir", ",", "'train.h5'", ")", "\n", "remove_if_exists", "(", "savename", ")", "\n", "generate_h5", "(", "loadlist", ",", "savename", ",", "train_window", ",", "10", ")", "\n", "\n", "# Generate validation dataset (Set12)", "\n", "loadlist", "=", "generate_loadlist", "(", "os", ".", "path", ".", "join", "(", "rootdir", ",", "'val'", ")", ",", "num_files", "=", "num_val", ",", "suffix", "=", "'.jpg'", ")", "\n", "savename", "=", "os", ".", "path", ".", "join", "(", "rootdir", ",", "'val.h5'", ")", "\n", "remove_if_exists", "(", "savename", ")", "\n", "generate_h5", "(", "loadlist", ",", "savename", ",", "None", ",", "None", ")", "\n", "\n", "# Generate test dataset (Set68)", "\n", "loadlist", "=", "generate_loadlist", "(", "os", ".", "path", ".", "join", "(", "rootdir", ",", "'test'", ")", ",", "num_files", "=", "num_test", ",", "suffix", "=", "'.jpg'", ")", "\n", "savename", "=", "os", ".", "path", ".", "join", "(", "rootdir", ",", "'test.h5'", ")", "\n", "remove_if_exists", "(", "savename", ")", "\n", "generate_h5", "(", "loadlist", ",", "savename", ",", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.preprocess.generate_h5": [[49, 72], ["h5py.File", "h5py.File.close", "util.general.read_image", "range", "numpy.expand_dims", "preprocess.image_to_patches", "h5py.File.create_dataset", "str"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.util.general.read_image", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.preprocess.image_to_patches"], ["", "def", "generate_h5", "(", "loadlist", ",", "savename", ",", "window", ",", "stride", ")", ":", "\n", "    ", "\"\"\"Generate a .h5 file from patches of specified images.\n    Note:\n        If window or stride are None, store images to the .h5 file without\n        extracting patches.\n    Args:\n        loadlist (list of str): list paths to images.\n        savename (str): name of the dataset file to save (must ends with .h5).\n        window (int): window size to extract patches.\n        stride (int): stride to extract patches.\n    \"\"\"", "\n", "h5f", "=", "h5py", ".", "File", "(", "savename", ",", "'w'", ")", "\n", "idx", "=", "0", "\n", "for", "loadname", "in", "loadlist", ":", "\n", "        ", "image", "=", "read_image", "(", "loadname", ")", "\n", "if", "window", "is", "None", "or", "stride", "is", "None", ":", "\n", "            ", "patches", "=", "np", ".", "expand_dims", "(", "image", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "patches", "=", "image_to_patches", "(", "image", ",", "window", ",", "stride", "=", "stride", ")", "\n", "", "for", "i", "in", "range", "(", "patches", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "h5f", ".", "create_dataset", "(", "str", "(", "idx", ")", ",", "data", "=", "patches", "[", "i", "]", ")", "\n", "idx", "+=", "1", "\n", "", "", "h5f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.preprocess.image_to_patches": [[73, 94], ["numpy.zeros", "range", "range"], "function", ["None"], ["", "def", "image_to_patches", "(", "image", ",", "window", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"Generate patches of images.\n    Args:\n        image (np.ndarray): the image with dimensions (C, H, W).\n        window (int): height and width of a patch.\n        stride (int): stride across pixels to extract patches.\n    Returns:\n        patches (np.ndarray): the resulting patches of dimensions (N, C, H, W).\n    \"\"\"", "\n", "C", ",", "H", ",", "W", "=", "image", ".", "shape", "\n", "numPatchesH", "=", "(", "H", "-", "window", ")", "//", "stride", "+", "1", "\n", "numPatchesW", "=", "(", "W", "-", "window", ")", "//", "stride", "+", "1", "\n", "numPatches", "=", "numPatchesH", "*", "numPatchesW", "\n", "patches", "=", "np", ".", "zeros", "(", "[", "numPatches", ",", "C", ",", "window", ",", "window", "]", ")", "\n", "idx", "=", "0", "\n", "for", "kh", "in", "range", "(", "numPatchesH", ")", ":", "\n", "        ", "for", "kw", "in", "range", "(", "numPatchesW", ")", ":", "\n", "            ", "patches", "[", "idx", ",", ":", ",", ":", ",", ":", "]", "=", "image", "[", ":", ",", "kh", "*", "stride", ":", "kh", "*", "stride", "+", "window", ",", "\n", "kw", "*", "stride", ":", "kw", "*", "stride", "+", "window", "]", "\n", "idx", "+=", "1", "\n", "", "", "return", "patches", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.__init__": [[15, 40], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "range", "torch.nn.Conv2d", "torch.nn.ModuleList", "torch.nn.ModuleList", "model.Colored_DnCNN._initialize_weights", "conv_layers.append", "bn_layers.append", "torch.nn.Conv2d", "torch.nn.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.__init__", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN._initialize_weights"], ["    ", "def", "__init__", "(", "self", ",", "channels", "=", "1", ",", "num_layers", "=", "20", ",", "std_channels", "=", "13", ")", ":", "\n", "        ", "super", "(", "Colored_DnCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "\n", "# Fixed parameters", "\n", "kernel_size", "=", "3", "\n", "padding", "=", "1", "\n", "features", "=", "64", "\n", "\n", "conv_layers", "=", "[", "]", "\n", "bn_layers", "=", "[", "]", "\n", "\n", "self", ".", "first_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "channels", "+", "std_channels", ",", "out_channels", "=", "features", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", "\n", "for", "_", "in", "range", "(", "num_layers", "-", "2", ")", ":", "\n", "            ", "conv_layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "in_channels", "=", "features", "+", "std_channels", ",", "out_channels", "=", "features", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", ")", "\n", "bn_layers", ".", "append", "(", "nn", ".", "BatchNorm2d", "(", "features", ")", ")", "\n", "", "self", ".", "last_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "features", "+", "std_channels", ",", "out_channels", "=", "channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "conv_layers", "=", "nn", ".", "ModuleList", "(", "conv_layers", ")", "\n", "self", ".", "bn_layers", "=", "nn", ".", "ModuleList", "(", "bn_layers", ")", "\n", "self", ".", "_initialize_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN.forward": [[41, 53], ["model.Colored_DnCNN._generate_std_channels", "torch.cat", "torch.nn.functional.relu", "range", "torch.cat", "model.Colored_DnCNN.last_conv", "model.Colored_DnCNN.first_conv", "torch.cat", "torch.nn.functional.relu"], "methods", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN._generate_std_channels"], ["", "def", "forward", "(", "self", ",", "x", ",", "std", ")", ":", "\n", "        ", "_", ",", "_", ",", "H", ",", "W", "=", "x", ".", "shape", "\n", "std_channels", "=", "self", ".", "_generate_std_channels", "(", "std", ",", "H", ",", "W", ")", "\n", "noise", "=", "torch", ".", "cat", "(", "(", "x", ",", "std_channels", ")", ",", "dim", "=", "1", ")", "\n", "noise", "=", "F", ".", "relu", "(", "self", ".", "first_conv", "(", "noise", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", "-", "2", ")", ":", "\n", "            ", "noise", "=", "torch", ".", "cat", "(", "(", "noise", ",", "std_channels", ")", ",", "dim", "=", "1", ")", "\n", "noise", "=", "F", ".", "relu", "(", "self", ".", "bn_layers", "[", "i", "]", "(", "self", ".", "conv_layers", "[", "i", "]", "(", "noise", ")", ")", ")", "\n", "", "noise", "=", "torch", ".", "cat", "(", "(", "noise", ",", "std_channels", ")", ",", "dim", "=", "1", ")", "\n", "noise", "=", "self", ".", "last_conv", "(", "noise", ")", "\n", "out", "=", "x", "-", "noise", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN._generate_std_channels": [[54, 58], ["std.reshape().repeat", "std.reshape"], "methods", ["None"], ["", "def", "_generate_std_channels", "(", "self", ",", "std", ",", "H", ",", "W", ")", ":", "\n", "        ", "N", ",", "concat_channels", "=", "std", ".", "shape", "\n", "std_channels", "=", "std", ".", "reshape", "(", "N", ",", "concat_channels", ",", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "1", ",", "H", ",", "W", ")", "\n", "return", "std_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.model.Colored_DnCNN._initialize_weights": [[59, 66], ["model.Colored_DnCNN.modules", "isinstance", "torch.nn.init.kaiming_normal_", "isinstance", "torch.nn.init.ones_", "torch.nn.init.zeros_"], "methods", ["None"], ["", "def", "_initialize_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "ones_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "zeros_", "(", "m", ".", "bias", ")", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve.train": [[8, 74], ["torch.device", "time.time", "solve._check_log_image", "range", "print", "len", "model.train", "enumerate", "solve._log_epoch", "solve._save_checkpoint", "print", "print", "solve.eval", "image.to.to", "noisy_image.to.to", "std.to.to", "model", "torch.nn.functional.mse_loss", "optimizer.zero_grad", "torch.nn.functional.mse_loss.backward", "optimizer.step", "print", "solve.eval", "scheduler.step", "solve._log_train"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._check_log_image", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve.train", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._log_epoch", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._save_checkpoint", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve.eval", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve.eval", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._log_train"], ["def", "train", "(", "model", ",", "\n", "loader_train", ",", "\n", "optimizer", ",", "\n", "scheduler", "=", "None", ",", "\n", "epochs", "=", "1", ",", "\n", "loader_val", "=", "None", ",", "\n", "loader_test", "=", "None", ",", "\n", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ",", "\n", "savedir", "=", "None", ",", "\n", "writer", "=", "None", ",", "\n", "log_every", "=", "20", ",", "\n", "log_image", "=", "[", "-", "1", "]", ",", "\n", "start_epoch", "=", "0", ",", "\n", "start_global_step", "=", "0", ")", ":", "\n", "    ", "\"\"\"Train the DnCNN model.\n    Note:\n        If specified, the model is validated and saved every epoch.\n        The loss, PSNR, and validation images are logged every epoch.\n    Args:\n        model: the DnCNN instance to be trained.\n        loader_train (torch.utils.data.DataLoader): train dataset loader.\n        optimizer (torch.optim.Optimizer): the optimizer.\n        scheduler: (torch.optim.lr_scheduler) a learning rate scheduler\n            Assumed to be ReduceLROnPlateau type for now.\n        epoches (int): the number of epochs.\n        loader_val (torch.utils.data.DataLoader): validation dataset loader.\n            If None, do not perform validation.\n        device (torch.device): the device to perform computations on.\n        savedir (string): path to save model every epoch. Do not save if None.\n        writer (tensorboardX.SummaryWriter): log writer for a train/test session.\n            If None, do not log\n        log_every (int): print and log the loss and PSNR every this number of\n            iterations within an epoch.\n        log_image (list): Log validation images of indices in this list.\n        start_epoch (int): epoch to begin (for resuming from checkpoint)\n        start_global_step (int): global step to begin (for resuming from checkpoint)\n        objective_params: parameters for calculating loss/objective function\n    \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "_check_log_image", "(", "log_image", ",", "len", "(", "loader_val", ")", ")", "\n", "global_step", "=", "start_global_step", "\n", "for", "e", "in", "range", "(", "start_epoch", ",", "start_epoch", "+", "epochs", ")", ":", "\n", "        ", "model", ".", "train", "(", ")", "\n", "for", "i", ",", "(", "image", ",", "noisy_image", ",", "std", ")", "in", "enumerate", "(", "loader_train", ")", ":", "\n", "            ", "image", "=", "image", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "dtype", ")", "\n", "noisy_image", "=", "noisy_image", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "dtype", ")", "\n", "std", "=", "std", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "dtype", ")", "\n", "denoised_image", "=", "model", "(", "noisy_image", ",", "std", ")", "\n", "loss", "=", "mse_loss", "(", "denoised_image", ",", "image", ",", "reduction", "=", "'mean'", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "i", "%", "log_every", "==", "0", ":", "\n", "                ", "_log_train", "(", "image", ",", "denoised_image", ",", "e", ",", "i", ",", "loss", ",", "global_step", ",", "writer", ")", "\n", "", "global_step", "+=", "1", "\n", "", "if", "loader_val", "is", "not", "None", ":", "\n", "            ", "print", "(", "'Validation after epoch {:d}'", ".", "format", "(", "e", ")", ")", "\n", "psnr", "=", "eval", "(", "model", ",", "loader_val", ",", "is_train", "=", "True", ",", "device", "=", "device", ",", "writer", "=", "writer", ",", "epoch", "=", "e", ",", "log_image", "=", "log_image", ")", "\n", "scheduler", ".", "step", "(", "psnr", ")", "\n", "", "_log_epoch", "(", "writer", ",", "optimizer", ",", "e", ",", "start_time", ")", "\n", "_save_checkpoint", "(", "savedir", ",", "e", ",", "global_step", ",", "model", ",", "optimizer", ")", "\n", "print", "(", ")", "\n", "", "print", "(", "'Training: Done!'", ")", "\n", "if", "loader_test", "is", "not", "None", ":", "\n", "        ", "print", "(", "'Begin testing...'", ")", "\n", "eval", "(", "model", ",", "loader_test", ",", "is_train", "=", "False", ",", "device", "=", "device", ",", "writer", "=", "writer", ",", "log_image", "=", "log_image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve.eval": [[75, 115], ["torch.device", "model.eval", "solve._select_imlogdir", "solve._log_eval", "torch.no_grad", "enumerate", "len", "image.to.to", "noisy_image.to.to", "std.to.to", "model", "train_util.batch_psnr", "writer.add_image", "torch.squeeze"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve.eval", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._select_imlogdir", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._log_eval", "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.train_util.batch_psnr"], ["", "", "def", "eval", "(", "model", ",", "\n", "loader", ",", "\n", "is_train", ",", "\n", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ",", "\n", "writer", "=", "None", ",", "\n", "epoch", "=", "0", ",", "\n", "log_image", "=", "[", "-", "1", "]", ")", ":", "\n", "    ", "\"\"\"Validate or test a DnCNN model.\n    Note:\n        Report average PSNR of the whole validation or test set.\n        Log validation PSNR. Note that passing summary writer\n        at test time does not do anything.\n    Args:\n        model: the DnCNN instance to be tested/validated.\n        loader (torch.utils.data.DataLoader): test/val dataset loader.\n        is_train: whether this function is called during training.\n        device (torch.device): the device to perform computations on.\n        writer (tensorboardX.SummaryWriter): log writer for a train/test session.\n            If None, do not log\n        epoch (int): training epoch when using this function for validation.\n        log_image (list): Log validation or test images of indices in this list.\n            If None, do not log images.\n    Returns:\n        psnr (float): validation PSNR\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "image_log_dir", "=", "_select_imlogdir", "(", "is_train", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "psnr", "=", "0", "\n", "for", "i", ",", "(", "image", ",", "noisy_image", ",", "std", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "image", "=", "image", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "dtype", ")", "\n", "noisy_image", "=", "noisy_image", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "dtype", ")", "\n", "std", "=", "std", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "dtype", ")", "\n", "denoised_image", "=", "model", "(", "noisy_image", ",", "std", ")", "\n", "psnr", "+=", "batch_psnr", "(", "denoised_image", ",", "image", ",", "max", "=", "1.", ")", "\n", "if", "i", "in", "log_image", "and", "writer", "is", "not", "None", ":", "\n", "                ", "writer", ".", "add_image", "(", "'{}{}'", ".", "format", "(", "image_log_dir", ",", "i", ")", ",", "torch", ".", "squeeze", "(", "denoised_image", ",", "dim", "=", "0", ")", ",", "epoch", ")", "\n", "", "", "psnr", "/=", "len", "(", "loader", ".", "dataset", ")", "\n", "", "_log_eval", "(", "is_train", ",", "psnr", ",", "epoch", ",", "writer", ")", "\n", "return", "psnr", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._check_log_image": [[116, 121], ["RuntimeError"], "function", ["None"], ["", "def", "_check_log_image", "(", "log_image", ",", "loader_len", ")", ":", "\n", "    ", "\"\"\"Verify that indices in log_image list do not exceed size of the loader.\"\"\"", "\n", "for", "i", "in", "log_image", ":", "\n", "        ", "if", "i", ">", "loader_len", "-", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "'solve.train._check_log_image: index in log_image exceeds size of val loader'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._save_checkpoint": [[122, 132], ["print", "torch.save", "model.state_dict", "optimizer.state_dict"], "function", ["None"], ["", "", "", "def", "_save_checkpoint", "(", "savedir", ",", "epoch", ",", "global_step", ",", "model", ",", "optimizer", ")", ":", "\n", "    ", "\"\"\"Save current checkpoint when training if the path is provided\"\"\"", "\n", "if", "savedir", "is", "not", "None", ":", "\n", "        ", "print", "(", "'Saving the model at epoch {:d}...'", ".", "format", "(", "epoch", ")", ")", "\n", "torch", ".", "save", "(", "{", "\n", "'epoch'", ":", "epoch", ",", "\n", "'global_step'", ":", "global_step", ",", "\n", "'model_state_dict'", ":", "model", ".", "state_dict", "(", ")", ",", "\n", "'optimizer_state_dict'", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "}", ",", "savedir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._log_train": [[133, 151], ["torch.no_grad", "train_util.batch_psnr", "print", "torch.nn.functional.mse_loss", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "loss.item", "loss.item", "mse.item", "diff.item"], "function", ["home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.train_util.batch_psnr"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_log_train", "(", "image", ",", "\n", "denoised_image", ",", "\n", "epoch", ",", "\n", "iteration", ",", "\n", "loss", ",", "\n", "global_step", ",", "\n", "writer", ")", ":", "\n", "    ", "\"\"\"Log the training loss and PSNR.\"\"\"", "\n", "psnr", "=", "batch_psnr", "(", "denoised_image", ",", "image", ",", "max", "=", "1.", ")", "\n", "mse", "=", "mse_loss", "(", "denoised_image", ",", "image", ",", "reduction", "=", "'sum'", ")", "/", "(", "2", "*", "image", ".", "shape", "[", "0", "]", ")", "\n", "diff", "=", "(", "mse", "-", "loss", ")", ".", "abs", "(", ")", "\n", "print", "(", "'Epoch {:d} Iteration {:d}, Loss = {:.4f}, PSNR = {:.4f}'", ".", "format", "(", "epoch", ",", "iteration", ",", "loss", ".", "item", "(", ")", ",", "psnr", ")", ")", "\n", "if", "writer", "is", "not", "None", ":", "\n", "        ", "writer", ".", "add_scalar", "(", "'loss/train'", ",", "loss", ".", "item", "(", ")", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "'mse/train'", ",", "mse", ".", "item", "(", ")", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "'mse_diff_loss/train'", ",", "diff", ".", "item", "(", ")", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "'PSNR/train'", ",", "psnr", ",", "global_step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._select_imlogdir": [[152, 158], ["None"], "function", ["None"], ["", "", "def", "_select_imlogdir", "(", "is_train", ")", ":", "\n", "    ", "\"\"\"Choose log name for image logging.\"\"\"", "\n", "if", "is_train", ":", "\n", "        ", "return", "'denoised/val/'", "\n", "", "else", ":", "\n", "        ", "return", "'denoised/test/'", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._log_eval": [[159, 171], ["print", "writer.add_scalar"], "function", ["None"], ["", "", "def", "_log_eval", "(", "is_train", ",", "psnr", ",", "epoch", ",", "writer", ")", ":", "\n", "    ", "\"\"\"Log the validation/testing PSNR and learning rate.\"\"\"", "\n", "if", "is_train", ":", "\n", "        ", "print_message", "=", "'Validation PSNR = '", "\n", "log_message", "=", "'PSNR/val'", "\n", "", "else", ":", "\n", "        ", "print_message", "=", "'Test PSNR = '", "\n", "log_message", "=", "'PSNR/test'", "\n", "", "print", "(", "print_message", "+", "'{:.4f}'", ".", "format", "(", "psnr", ")", ")", "\n", "\n", "if", "writer", "is", "not", "None", ":", "\n", "        ", "writer", ".", "add_scalar", "(", "log_message", ",", "psnr", ",", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Intelligent-Sensing_D-VDAMP.train.solve._log_epoch": [[172, 180], ["enumerate", "print", "writer.add_scalar", "writer.add_scalar", "time.time"], "function", ["None"], ["", "", "def", "_log_epoch", "(", "writer", ",", "optimizer", ",", "epoch", ",", "start_time", ")", ":", "\n", "    ", "\"\"\"Log optimizer learning rate and time\"\"\"", "\n", "lr_log", "=", "'lr/'", "\n", "for", "i", ",", "param_group", "in", "enumerate", "(", "optimizer", ".", "param_groups", ")", ":", "\n", "        ", "writer", ".", "add_scalar", "(", "lr_log", "+", "'{:d}'", ".", "format", "(", "i", ")", ",", "param_group", "[", "'lr'", "]", ",", "epoch", ")", "\n", "", "time_spent", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "'Time from begin training: {}'", ".", "format", "(", "time_spent", ")", ")", "\n", "writer", ".", "add_scalar", "(", "'time'", ",", "time_spent", ",", "epoch", ")", "", "", ""]]}