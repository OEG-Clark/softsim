{"home.repos.pwc.inspect_result.lanyavik_BAIL.spinup.run.friendly_err": [[29, 32], ["None"], "function", ["None"], ["def", "friendly_err", "(", "err_msg", ")", ":", "\n", "# add whitespace to error message to make it more readable", "\n", "    ", "return", "'\\n\\n'", "+", "err_msg", "+", "'\\n\\n'", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.spinup.run.parse_and_execute_grid_search": [[34, 163], ["eval", "any", "dict", "enumerate", "dict.items", "dict", "list", "SUBSTITUTIONS.items", "dict", "run.friendly_err", "spinup.utils.run_utils.ExperimentGrid", "dict.items", "spinup.utils.run_utils.ExperimentGrid.run", "print", "print", "sys.exit", "run.friendly_err", "dict.keys", "run.friendly_err", "run.friendly_err", "textwrap.dedent", "spinup.utils.run_utils.ExperimentGrid.add", "eval", "arg.lstrip", "arg_dict[].append", "len", "v.append", "k.find", "k.find", "run.friendly_err", "len", "list", "run.parse_and_execute_grid_search.process"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.spinup.run.friendly_err", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.run", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.spinup.run.friendly_err", "home.repos.pwc.inspect_result.lanyavik_BAIL.spinup.run.friendly_err", "home.repos.pwc.inspect_result.lanyavik_BAIL.spinup.run.friendly_err", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.spinup.run.friendly_err"], ["", "def", "parse_and_execute_grid_search", "(", "cmd", ",", "args", ")", ":", "\n", "    ", "\"\"\"Interprets algorithm name and cmd line args into an ExperimentGrid.\"\"\"", "\n", "\n", "# Parse which algorithm to execute", "\n", "algo", "=", "eval", "(", "'spinup.'", "+", "cmd", ")", "\n", "\n", "# Before all else, check to see if any of the flags is 'help'.", "\n", "valid_help", "=", "[", "'--help'", ",", "'-h'", ",", "'help'", "]", "\n", "if", "any", "(", "[", "arg", "in", "valid_help", "for", "arg", "in", "args", "]", ")", ":", "\n", "        ", "print", "(", "'\\n\\nShowing docstring for spinup.'", "+", "cmd", "+", "':\\n'", ")", "\n", "print", "(", "algo", ".", "__doc__", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "def", "process", "(", "arg", ")", ":", "\n", "# Process an arg by eval-ing it, so users can specify more", "\n", "# than just strings at the command line (eg allows for", "\n", "# users to give functions as args).", "\n", "        ", "try", ":", "\n", "            ", "return", "eval", "(", "arg", ")", "\n", "", "except", ":", "\n", "            ", "return", "arg", "\n", "\n", "# Make first pass through args to build base arg_dict. Anything", "\n", "# with a '--' in front of it is an argument flag and everything after,", "\n", "# until the next flag, is a possible value.", "\n", "", "", "arg_dict", "=", "dict", "(", ")", "\n", "for", "i", ",", "arg", "in", "enumerate", "(", "args", ")", ":", "\n", "        ", "assert", "i", ">", "0", "or", "'--'", "in", "arg", ",", "friendly_err", "(", "\"You didn't specify a first flag.\"", ")", "\n", "if", "'--'", "in", "arg", ":", "\n", "            ", "arg_key", "=", "arg", ".", "lstrip", "(", "'-'", ")", "\n", "arg_dict", "[", "arg_key", "]", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "arg_dict", "[", "arg_key", "]", ".", "append", "(", "process", "(", "arg", ")", ")", "\n", "\n", "# Make second pass through, to catch flags that have no vals.", "\n", "# Assume such flags indicate that a boolean parameter should have", "\n", "# value True.", "\n", "", "", "for", "k", ",", "v", "in", "arg_dict", ".", "items", "(", ")", ":", "\n", "        ", "if", "len", "(", "v", ")", "==", "0", ":", "\n", "            ", "v", ".", "append", "(", "True", ")", "\n", "\n", "# Third pass: check for user-supplied shorthands, where a key has", "\n", "# the form --keyname[kn]. The thing in brackets, 'kn', is the", "\n", "# shorthand. NOTE: modifying a dict while looping through its", "\n", "# contents is dangerous, and breaks in 3.6+. We loop over a fixed list", "\n", "# of keys to avoid this issue.", "\n", "", "", "given_shorthands", "=", "dict", "(", ")", "\n", "fixed_keys", "=", "list", "(", "arg_dict", ".", "keys", "(", ")", ")", "\n", "for", "k", "in", "fixed_keys", ":", "\n", "        ", "p1", ",", "p2", "=", "k", ".", "find", "(", "'['", ")", ",", "k", ".", "find", "(", "']'", ")", "\n", "if", "p1", ">=", "0", "and", "p2", ">=", "0", ":", "\n", "# Both '[' and ']' found, so shorthand has been given", "\n", "            ", "k_new", "=", "k", "[", ":", "p1", "]", "\n", "shorthand", "=", "k", "[", "p1", "+", "1", ":", "p2", "]", "\n", "given_shorthands", "[", "k_new", "]", "=", "shorthand", "\n", "arg_dict", "[", "k_new", "]", "=", "arg_dict", "[", "k", "]", "\n", "del", "arg_dict", "[", "k", "]", "\n", "\n", "# Penultimate pass: sugar. Allow some special shortcuts in arg naming,", "\n", "# eg treat \"env\" the same as \"env_name\". This is super specific", "\n", "# to Spinning Up implementations, and may be hard to maintain.", "\n", "# These special shortcuts are described by SUBSTITUTIONS.", "\n", "", "", "for", "special_name", ",", "true_name", "in", "SUBSTITUTIONS", ".", "items", "(", ")", ":", "\n", "        ", "if", "special_name", "in", "arg_dict", ":", "\n", "# swap it in arg dict", "\n", "            ", "arg_dict", "[", "true_name", "]", "=", "arg_dict", "[", "special_name", "]", "\n", "del", "arg_dict", "[", "special_name", "]", "\n", "\n", "", "if", "special_name", "in", "given_shorthands", ":", "\n", "# point the shortcut to the right name", "\n", "            ", "given_shorthands", "[", "true_name", "]", "=", "given_shorthands", "[", "special_name", "]", "\n", "del", "given_shorthands", "[", "special_name", "]", "\n", "\n", "# Final pass: check for the special args that go to the 'run' command", "\n", "# for an experiment grid, separate them from the arg dict, and make sure", "\n", "# that they have unique values. The special args are given by RUN_KEYS.", "\n", "", "", "run_kwargs", "=", "dict", "(", ")", "\n", "for", "k", "in", "RUN_KEYS", ":", "\n", "        ", "if", "k", "in", "arg_dict", ":", "\n", "            ", "val", "=", "arg_dict", "[", "k", "]", "\n", "assert", "len", "(", "val", ")", "==", "1", ",", "friendly_err", "(", "\"You can only provide one value for %s.\"", "%", "k", ")", "\n", "run_kwargs", "[", "k", "]", "=", "val", "[", "0", "]", "\n", "del", "arg_dict", "[", "k", "]", "\n", "\n", "# Determine experiment name. If not given by user, will be determined", "\n", "# by the algorithm name.", "\n", "", "", "if", "'exp_name'", "in", "arg_dict", ":", "\n", "        ", "assert", "len", "(", "arg_dict", "[", "'exp_name'", "]", ")", "==", "1", ",", "friendly_err", "(", "\"You can only provide one value for exp_name.\"", ")", "\n", "exp_name", "=", "arg_dict", "[", "'exp_name'", "]", "[", "0", "]", "\n", "del", "arg_dict", "[", "'exp_name'", "]", "\n", "", "else", ":", "\n", "        ", "exp_name", "=", "'cmd_'", "+", "cmd", "\n", "\n", "# Make sure that if num_cpu > 1, the algorithm being used is compatible", "\n", "# with MPI.", "\n", "", "if", "'num_cpu'", "in", "run_kwargs", "and", "not", "(", "run_kwargs", "[", "'num_cpu'", "]", "==", "1", ")", ":", "\n", "        ", "assert", "cmd", "in", "MPI_COMPATIBLE_ALGOS", ",", "friendly_err", "(", "\"This algorithm can't be run with num_cpu > 1.\"", ")", "\n", "\n", "# Special handling for environment: make sure that env_name is a real,", "\n", "# registered gym environment.", "\n", "", "valid_envs", "=", "[", "e", ".", "id", "for", "e", "in", "list", "(", "gym", ".", "envs", ".", "registry", ".", "all", "(", ")", ")", "]", "\n", "assert", "'env_name'", "in", "arg_dict", ",", "friendly_err", "(", "\"You did not give a value for --env_name! Add one and try again.\"", ")", "\n", "for", "env_name", "in", "arg_dict", "[", "'env_name'", "]", ":", "\n", "        ", "err_msg", "=", "dedent", "(", "\"\"\"\n\n            %s is not registered with Gym.\n\n            Recommendations:\n\n                * Check for a typo (did you include the version tag?)\n\n                * View the complete list of valid Gym environments at\n\n                    https://gym.openai.com/envs/\n\n            \"\"\"", "%", "env_name", ")", "\n", "assert", "env_name", "in", "valid_envs", ",", "err_msg", "\n", "\n", "\n", "# Construct and execute the experiment grid.", "\n", "", "eg", "=", "ExperimentGrid", "(", "name", "=", "exp_name", ")", "\n", "for", "k", ",", "v", "in", "arg_dict", ".", "items", "(", ")", ":", "\n", "        ", "eg", ".", "add", "(", "k", ",", "v", ",", "shorthand", "=", "given_shorthands", ".", "get", "(", "k", ")", ")", "\n", "", "eg", ".", "run", "(", "algo", ",", "**", "run_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.spinup.version.get_version": [[5, 8], ["None"], "function", ["None"], ["def", "get_version", "(", ")", ":", "\n", "    ", "\"Returns the version as a human-format string.\"", "\n", "return", "'%d.%d.%d'", "%", "version_info", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.Value.__init__": [[13, 36], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "torch.Linear", "bail_training.Value.value_head.weight.data.mul_", "bail_training.Value.value_head.bias.data.mul_", "bail_training.Value.affine_layers.append", "torch.Linear", "torch.Linear", "torch.Linear", "affine.weight.data.uniform_", "affine.bias.data.uniform_"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["    ", "def", "__init__", "(", "self", ",", "state_dim", ",", "hidden_size", "=", "(", "128", ",", "128", ")", ",", "activation", "=", "'relu'", ",", "init_small_weights", "=", "False", ",", "init_w", "=", "1e-3", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "activation", "==", "'tanh'", ":", "\n", "            ", "self", ".", "activation", "=", "torch", ".", "tanh", "\n", "", "elif", "activation", "==", "'relu'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "relu", "\n", "", "elif", "activation", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "sigmoid", "\n", "\n", "", "self", ".", "affine_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "last_dim", "=", "state_dim", "\n", "for", "nh", "in", "hidden_size", ":", "\n", "            ", "self", ".", "affine_layers", ".", "append", "(", "nn", ".", "Linear", "(", "last_dim", ",", "nh", ")", ")", "\n", "last_dim", "=", "nh", "\n", "\n", "", "self", ".", "value_head", "=", "nn", ".", "Linear", "(", "last_dim", ",", "1", ")", "\n", "self", ".", "value_head", ".", "weight", ".", "data", ".", "mul_", "(", "0.1", ")", "\n", "self", ".", "value_head", ".", "bias", ".", "data", ".", "mul_", "(", "0.0", ")", "\n", "\n", "if", "init_small_weights", ":", "\n", "            ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "                ", "affine", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "affine", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.Value.forward": [[38, 44], ["bail_training.Value.value_head", "bail_training.Value.activation", "affine"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "affine", "(", "x", ")", ")", "\n", "\n", "", "value", "=", "self", ".", "value_head", "(", "x", ")", "\n", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.Actor.__init__": [[47, 55], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["\t", "def", "__init__", "(", "self", ",", "state_dim", ",", "action_dim", ",", "max_action", ")", ":", "\n", "\t\t", "super", "(", "Actor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "l1", "=", "nn", ".", "Linear", "(", "state_dim", ",", "400", ")", "\n", "self", ".", "l2", "=", "nn", ".", "Linear", "(", "400", ",", "300", ")", "\n", "self", ".", "l3", "=", "nn", ".", "Linear", "(", "300", ",", "action_dim", ")", "\n", "\n", "self", ".", "max_action", "=", "max_action", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.Actor.forward": [[57, 62], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "bail_training.Actor.l1", "bail_training.Actor.l2", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "bail_training.Actor.l3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "state", ")", ":", "\n", "\t\t", "a", "=", "F", ".", "relu", "(", "self", ".", "l1", "(", "state", ")", ")", "\n", "a", "=", "F", ".", "relu", "(", "self", ".", "l2", "(", "a", ")", ")", "\n", "a", "=", "self", ".", "max_action", "*", "torch", ".", "tanh", "(", "self", ".", "l3", "(", "a", ")", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BAIL_selebah.__init__": [[65, 96], ["Actor().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "Value().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "Value().to", "bail_training.BAIL_selebah.v_ue.state_dict", "int", "numpy.random.randint", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "print", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "bail_training.BAIL_selebah.actor.parameters", "bail_training.BAIL_selebah.v_ue.parameters", "bail_training.BAIL_selebah.test_states.size", "bail_training.BAIL_selebah.test_mcrets.size", "bail_training.Actor", "bail_training.Value", "bail_training.Value", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "float"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print"], ["\t", "def", "__init__", "(", "self", ",", "state_dim", ",", "action_dim", ",", "max_action", ",", "max_iters", ",", "States", ",", "MCrets", ",", "\n", "ue_lr", "=", "3e-3", ",", "ue_wd", "=", "2e-2", ",", "lr", "=", "1e-3", ",", "wd", "=", "0", ",", "\n", "pct_anneal_type", "=", "None", ",", "last_pct", "=", "0.25", ",", "\n", "select_type", "=", "'border'", ",", "C", "=", "None", ")", ":", "\n", "\n", "\t\t", "self", ".", "actor", "=", "Actor", "(", "state_dim", ",", "action_dim", ",", "max_action", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "actor_optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "actor", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "weight_decay", "=", "wd", ")", "\n", "\n", "self", ".", "v_ue", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "v_ue_optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "v_ue", ".", "parameters", "(", ")", ",", "lr", "=", "ue_lr", ",", "weight_decay", "=", "ue_wd", ")", "\n", "self", ".", "best_v_ue", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "ue_best_parameters", "=", "self", ".", "v_ue", ".", "state_dict", "(", ")", "\n", "\n", "self", ".", "MCrets", "=", "MCrets", "\n", "test_size", "=", "int", "(", "MCrets", ".", "shape", "[", "0", "]", "*", "0.2", ")", "\n", "self", ".", "MC_valiset_indices", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "MCrets", ".", "shape", "[", "0", "]", ",", "size", "=", "test_size", ")", "\n", "\n", "self", ".", "test_states", "=", "torch", ".", "from_numpy", "(", "States", "[", "self", ".", "MC_valiset_indices", "]", ")", "\n", "self", ".", "test_mcrets", "=", "torch", ".", "from_numpy", "(", "self", ".", "MCrets", "[", "self", ".", "MC_valiset_indices", "]", ")", "\n", "print", "(", "'ue test set size:'", ",", "self", ".", "test_states", ".", "size", "(", ")", ",", "self", ".", "test_mcrets", ".", "size", "(", ")", ")", "\n", "\n", "self", ".", "state_dim", "=", "state_dim", "\n", "self", ".", "action_dim", "=", "action_dim", "\n", "self", ".", "ue_valiloss_min", "=", "torch", ".", "Tensor", "(", "[", "float", "(", "'inf'", ")", "]", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "num_increase", "=", "0", "\n", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "pct_anneal_type", "=", "pct_anneal_type", "\n", "self", ".", "last_pct", "=", "last_pct", "\n", "#self.pct_info_dic = pct_info_dic", "\n", "self", ".", "select_type", "=", "select_type", "\n", "self", ".", "C", "=", "C", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BAIL_selebah.select_action": [[98, 101], ["torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "bail_training.BAIL_selebah.actor().cpu().data.numpy().flatten", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "bail_training.BAIL_selebah.actor().cpu().data.numpy", "torch.FloatTensor().to.reshape", "torch.FloatTensor().to.reshape", "torch.FloatTensor().to.reshape", "bail_training.BAIL_selebah.actor().cpu", "bail_training.BAIL_selebah.actor"], "methods", ["None"], ["", "def", "select_action", "(", "self", ",", "state", ")", ":", "\n", "\t\t", "state", "=", "torch", ".", "FloatTensor", "(", "state", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ".", "to", "(", "device", ")", "\n", "return", "self", ".", "actor", "(", "state", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BAIL_selebah.train": [[102, 211], ["dict", "range", "logger.store", "replay_buffer.sample", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "bail_training.BAIL_selebah.v_ue", "bail_training.L2PenaltyLoss", "bail_training.BAIL_selebah.v_ue_optimizer.zero_grad", "L2PenaltyLoss.backward", "bail_training.BAIL_selebah.v_ue_optimizer.step", "bail_training.BAIL_selebah.best_v_ue().squeeze().detach", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "logger.store", "torch.where.sum().cpu().item", "torch.where.sum().cpu().item", "torch.where.sum().cpu().item", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "bail_training.BAIL_selebah.actor_optimizer.zero_grad", "torch.mul().pow().mean.backward", "torch.mul().pow().mean.backward", "torch.mul().pow().mean.backward", "bail_training.BAIL_selebah.actor_optimizer.step", "logger.store", "bail_training.calc_ue_valiloss", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "bail_training.BAIL_selebah.C.to", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "logger.store", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "enumerate", "bail_training.BAIL_selebah.best_v_ue.load_state_dict", "bail_training.BAIL_selebah.v_ue.state_dict", "bail_training.BAIL_selebah.v_ue.load_state_dict", "bail_training.BAIL_selebah.best_v_ue().squeeze", "Exception", "ratios.view", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "logger.store", "Exception", "torch.where.sum().cpu", "torch.where.sum().cpu", "torch.where.sum().cpu", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow().mean.detach().cpu().item", "torch.mul().pow().mean.detach().cpu().item", "torch.mul().pow().mean.detach().cpu().item", "L2PenaltyLoss.detach().cpu().item", "len", "torch.where.detach().mean", "torch.where.detach().mean", "torch.where.detach().mean", "int", "border.cpu().item", "diffs.view", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "bail_training.BAIL_selebah.best_v_ue", "int", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "margin.cpu().item", "torch.where.sum", "torch.where.sum", "torch.where.sum", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul().pow().mean.detach().cpu", "torch.mul().pow().mean.detach().cpu", "torch.mul().pow().mean.detach().cpu", "L2PenaltyLoss.detach().cpu", "torch.where.detach", "torch.where.detach", "torch.where.detach", "border.cpu", "int", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "margin.cpu", "bail_training.BAIL_selebah.actor", "torch.mul().pow().mean.detach", "torch.mul().pow().mean.detach", "torch.mul().pow().mean.detach", "L2PenaltyLoss.detach"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.L2PenaltyLoss", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.calc_ue_valiloss", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum"], ["", "def", "train", "(", "self", ",", "replay_buffer", ",", "done_training_iters", ",", "iterations", "=", "5000", ",", "batch_size", "=", "1000", ",", "\n", "ue_loss_k", "=", "10000", ",", "ue_vali_freq", "=", "1250", ",", "\n", "logger", "=", "dict", "(", ")", ")", ":", "\n", "\n", "\t\t", "for", "it", "in", "range", "(", "done_training_iters", ",", "done_training_iters", "+", "iterations", ")", ":", "\n", "\n", "# get batch data", "\n", "\t\t\t", "state", ",", "next_state", ",", "action", ",", "reward", ",", "done", ",", "idxs", "=", "replay_buffer", ".", "sample", "(", "batch_size", ",", "require_idxs", "=", "True", ")", "\n", "\n", "state", "=", "torch", ".", "FloatTensor", "(", "state", ")", ".", "to", "(", "device", ")", "\n", "action", "=", "torch", ".", "FloatTensor", "(", "action", ")", ".", "to", "(", "device", ")", "\n", "# next_state = torch.FloatTensor(next_state).to(device)", "\n", "# reward = torch.FloatTensor(reward).to(device)", "\n", "# done = torch.FloatTensor(1 - done).to(device)", "\n", "mc_ret", "=", "torch", ".", "FloatTensor", "(", "self", ".", "MCrets", "[", "idxs", "]", ")", ".", "to", "(", "device", ")", "\n", "\n", "uetrain_batch_pos", "=", "[", "p", "for", "p", ",", "i", "in", "enumerate", "(", "idxs", ")", "if", "i", "not", "in", "self", ".", "MC_valiset_indices", "]", "\n", "uetrain_s", "=", "state", "[", "uetrain_batch_pos", "]", "\n", "uetrain_mc", "=", "mc_ret", "[", "uetrain_batch_pos", "]", "\n", "\n", "# train upper envelope by the k-penalty loss", "\n", "Vsi", "=", "self", ".", "v_ue", "(", "uetrain_s", ")", "\n", "ue_loss", "=", "L2PenaltyLoss", "(", "Vsi", ",", "uetrain_mc", ",", "k_val", "=", "ue_loss_k", ")", "\n", "\n", "self", ".", "v_ue_optimizer", ".", "zero_grad", "(", ")", "\n", "ue_loss", ".", "backward", "(", ")", "\n", "self", ".", "v_ue_optimizer", ".", "step", "(", ")", "\n", "\n", "\"\"\" if it is time to recalculate border/margin \"\"\"", "\n", "\"\"\" do validation for the UE network, update the best ue \"\"\"", "\n", "if", "it", "%", "ue_vali_freq", "==", "0", ":", "\n", "\t\t\t\t", "validation_loss", "=", "calc_ue_valiloss", "(", "self", ".", "v_ue", ",", "self", ".", "test_states", ",", "self", ".", "test_mcrets", ",", "\n", "ue_bsize", "=", "int", "(", "batch_size", "*", "0.8", ")", ",", "ue_loss_k", "=", "ue_loss_k", ")", "\n", "\n", "# choose best parameters with least validation loss for the eval ue", "\n", "self", ".", "ue_valiloss_min", "=", "torch", ".", "min", "(", "self", ".", "ue_valiloss_min", ",", "validation_loss", ")", "\n", "\n", "if", "validation_loss", ">", "self", ".", "ue_valiloss_min", ":", "\n", "\t\t\t\t\t", "self", ".", "best_v_ue", ".", "load_state_dict", "(", "self", ".", "ue_best_parameters", ")", "\n", "self", ".", "num_increase", "+=", "1", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "ue_best_parameters", "=", "self", ".", "v_ue", ".", "state_dict", "(", ")", "\n", "self", ".", "num_increase", "=", "0", "\n", "# if validation loss of ue is increasing for some consecutive steps, also return the training ue to least", "\n", "# validation loss parameters", "\n", "", "if", "self", ".", "num_increase", "==", "4", ":", "\n", "\t\t\t\t\t", "self", ".", "v_ue", ".", "load_state_dict", "(", "self", ".", "ue_best_parameters", ")", "\n", "\n", "# estimate state values by the upper envelope", "\n", "", "", "state_value", "=", "self", ".", "best_v_ue", "(", "state", ")", ".", "squeeze", "(", ")", ".", "detach", "(", ")", "\n", "# project negative or small positive state values to (0, 1)", "\n", "state_value", "=", "torch", ".", "where", "(", "state_value", "<", "1", ",", "(", "state_value", "-", "1", ")", ".", "exp", "(", ")", ",", "state_value", ")", "\n", "if", "self", ".", "C", "is", "not", "None", ":", "\n", "\t\t\t\t", "C", "=", "self", ".", "C", ".", "to", "(", "device", ")", "\n", "state_value", "=", "torch", ".", "where", "(", "state_value", ">", "C", ",", "C", ",", "state_value", ")", "\n", "# print(type(state_value))", "\n", "\n", "# get current percentage", "\n", "", "if", "self", ".", "pct_anneal_type", "==", "'constant'", ":", "\n", "\t\t\t\t", "cur_pct", "=", "self", ".", "last_pct", "\n", "", "elif", "self", ".", "pct_anneal_type", "==", "'linear'", ":", "\n", "\t\t\t\t", "cur_pct", "=", "1", "-", "it", "/", "self", ".", "max_iters", "*", "(", "1", "-", "self", ".", "last_pct", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'! undefined percentage anneal type'", ")", "\n", "\n", "", "logger", ".", "store", "(", "SelePct", "=", "cur_pct", ")", "\n", "\n", "# determine the border / margin by current percentage", "\n", "if", "self", ".", "select_type", "==", "'border'", ":", "\n", "\t\t\t\t", "ratios", "=", "mc_ret", "/", "state_value", "\n", "increasing_ratios", ",", "increasing_ratio_indices", "=", "torch", ".", "sort", "(", "ratios", ".", "view", "(", "-", "1", ")", ")", "\n", "bor_ind", "=", "increasing_ratio_indices", "[", "-", "int", "(", "cur_pct", "*", "batch_size", ")", "]", "\n", "border", "=", "ratios", "[", "bor_ind", "]", "\n", "\n", "weights", "=", "torch", ".", "where", "(", "mc_ret", ">=", "border", "*", "state_value", ",", "torch", ".", "FloatTensor", "(", "[", "1", "]", ")", ".", "to", "(", "device", ")", ",", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "to", "(", "device", ")", ")", "\n", "logger", ".", "store", "(", "Border", "=", "border", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "elif", "self", ".", "select_type", "==", "'margin'", ":", "\n", "\t\t\t\t", "diffs", "=", "mc_ret", "-", "state_value", "\n", "increasing_diffs", ",", "increasing_diff_indices", "=", "torch", ".", "sort", "(", "diffs", ".", "view", "(", "-", "1", ")", ")", "\n", "mrg_ind", "=", "increasing_diff_indices", "[", "-", "int", "(", "cur_pct", "*", "batch_size", ")", "]", "\n", "margin", "=", "diffs", "[", "mrg_ind", "]", "\n", "\n", "weights", "=", "torch", ".", "where", "(", "mc_ret", ">=", "margin", "+", "state_value", ",", "torch", ".", "FloatTensor", "(", "[", "1", "]", ")", ".", "to", "(", "device", ")", ",", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "to", "(", "device", ")", ")", "\n", "logger", ".", "store", "(", "Margin", "=", "margin", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'! undefined selection type'", ")", "\n", "\n", "# Compute MSE loss for actor", "\n", "", "update_size", "=", "weights", ".", "sum", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "weights", "=", "torch", ".", "stack", "(", "[", "weights", ",", "]", "*", "self", ".", "action_dim", ",", "dim", "=", "1", ")", "\n", "# print(weights.size(), action.size())", "\n", "actor_loss", "=", "torch", ".", "mul", "(", "weights", ",", "self", ".", "actor", "(", "state", ")", "-", "action", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "# Optimize the actor", "\n", "self", ".", "actor_optimizer", ".", "zero_grad", "(", ")", "\n", "actor_loss", ".", "backward", "(", ")", "\n", "self", ".", "actor_optimizer", ".", "step", "(", ")", "\n", "\n", "logger", ".", "store", "(", "CloneLoss", "=", "actor_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "UELoss", "=", "ue_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "BatchUEtrnSize", "=", "len", "(", "uetrain_batch_pos", ")", ",", "BatchUpSize", "=", "update_size", ",", "\n", "SVal", "=", "state_value", ".", "detach", "(", ")", ".", "mean", "(", ")", ")", "\n", "\n", "", "logger", ".", "store", "(", "UEValiLossMin", "=", "self", ".", "ue_valiloss_min", ")", "\n", "\n", "return", "self", ".", "best_v_ue", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BAIL_selebuf.__init__": [[214, 243], ["Actor().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "Value().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "Value().to", "bail_training.BAIL_selebuf.v_ue.state_dict", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "int", "numpy.random.randint", "print", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "bail_training.BAIL_selebuf.actor.parameters", "bail_training.BAIL_selebuf.v_ue.parameters", "bail_training.Actor", "bail_training.Value", "bail_training.Value", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "float"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print"], ["\t", "def", "__init__", "(", "self", ",", "state_dim", ",", "action_dim", ",", "max_action", ",", "max_iters", ",", "States", ",", "MCrets", ",", "\n", "ue_lr", "=", "3e-3", ",", "ue_wd", "=", "2e-2", ",", "lr", "=", "1e-3", ",", "wd", "=", "0", ",", "\n", "pct_anneal_type", "=", "None", ",", "last_pct", "=", "0.25", ",", "\n", "select_type", "=", "'border'", ",", "C", "=", "None", ")", ":", "\n", "\n", "\t\t", "self", ".", "actor", "=", "Actor", "(", "state_dim", ",", "action_dim", ",", "max_action", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "actor_optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "actor", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "weight_decay", "=", "wd", ")", "\n", "\n", "self", ".", "v_ue", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "v_ue_optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "v_ue", ".", "parameters", "(", ")", ",", "lr", "=", "ue_lr", ",", "weight_decay", "=", "ue_wd", ")", "\n", "self", ".", "best_v_ue", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "ue_best_parameters", "=", "self", ".", "v_ue", ".", "state_dict", "(", ")", "\n", "\n", "self", ".", "States", "=", "torch", ".", "from_numpy", "(", "States", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "MCrets", "=", "torch", ".", "from_numpy", "(", "MCrets", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "test_size", "=", "int", "(", "self", ".", "MCrets", ".", "shape", "[", "0", "]", "*", "0.2", ")", "\n", "self", ".", "MC_valiset_indices", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "MCrets", ".", "shape", "[", "0", "]", ",", "size", "=", "test_size", ")", "\n", "print", "(", "'ue test set size:'", ",", "self", ".", "MC_valiset_indices", ".", "shape", ")", "\n", "\n", "self", ".", "state_dim", "=", "state_dim", "\n", "self", ".", "action_dim", "=", "action_dim", "\n", "self", ".", "ue_valiloss_min", "=", "torch", ".", "Tensor", "(", "[", "float", "(", "'inf'", ")", "]", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "num_increase", "=", "0", "\n", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "pct_anneal_type", "=", "pct_anneal_type", "\n", "self", ".", "last_pct", "=", "last_pct", "\n", "self", ".", "pct_info_dic", "=", "pct_info_dic", "\n", "self", ".", "select_type", "=", "select_type", "\n", "self", ".", "C", "=", "C", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BAIL_selebuf.select_action": [[244, 247], ["torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "bail_training.BAIL_selebuf.actor().cpu().data.numpy().flatten", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "bail_training.BAIL_selebuf.actor().cpu().data.numpy", "torch.FloatTensor().to.reshape", "torch.FloatTensor().to.reshape", "torch.FloatTensor().to.reshape", "bail_training.BAIL_selebuf.actor().cpu", "bail_training.BAIL_selebuf.actor"], "methods", ["None"], ["", "def", "select_action", "(", "self", ",", "state", ")", ":", "\n", "\t\t", "state", "=", "torch", ".", "FloatTensor", "(", "state", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ".", "to", "(", "device", ")", "\n", "return", "self", ".", "actor", "(", "state", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BAIL_selebuf.train": [[248, 376], ["dict", "range", "replay_buffer.sample", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "bail_training.BAIL_selebuf.v_ue", "bail_training.L2PenaltyLoss", "bail_training.BAIL_selebuf.v_ue_optimizer.zero_grad", "L2PenaltyLoss.backward", "bail_training.BAIL_selebuf.v_ue_optimizer.step", "States_values[].squeeze", "torch.where.sum().cpu().item", "torch.where.sum().cpu().item", "torch.where.sum().cpu().item", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "torch.mul().pow().mean", "bail_training.BAIL_selebuf.actor_optimizer.zero_grad", "torch.mul().pow().mean.backward", "torch.mul().pow().mean.backward", "torch.mul().pow().mean.backward", "bail_training.BAIL_selebuf.actor_optimizer.step", "logger.store", "bail_training.calc_ue_valiloss", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "logger.store", "int", "range", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "logger.store", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "enumerate", "bail_training.BAIL_selebuf.best_v_ue.load_state_dict", "bail_training.BAIL_selebuf.v_ue.state_dict", "bail_training.BAIL_selebuf.v_ue.load_state_dict", "numpy.ceil", "slice", "torch.where.append", "torch.where.append", "torch.where.append", "bail_training.BAIL_selebuf.C.to", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "logger.store", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where.sum().cpu", "torch.where.sum().cpu", "torch.where.sum().cpu", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow", "torch.mul().pow().mean.detach().cpu().item", "torch.mul().pow().mean.detach().cpu().item", "torch.mul().pow().mean.detach().cpu().item", "L2PenaltyLoss.detach().cpu().item", "len", "States_values[].squeeze.detach().mean", "int", "min", "bail_training.BAIL_selebuf.best_v_ue().detach", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "bail_training.BAIL_selebuf.MCrets.view", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "logger.store", "Exception", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "border.cpu().item", "bail_training.BAIL_selebuf.MCrets.view", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.where.sum", "torch.where.sum", "torch.where.sum", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul().pow().mean.detach().cpu", "torch.mul().pow().mean.detach().cpu", "torch.mul().pow().mean.detach().cpu", "L2PenaltyLoss.detach().cpu", "States_values[].squeeze.detach", "bail_training.BAIL_selebuf.best_v_ue", "Exception", "int", "margin.cpu().item", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "min", "border.cpu", "int", "bail_training.BAIL_selebuf.actor", "torch.mul().pow().mean.detach", "torch.mul().pow().mean.detach", "torch.mul().pow().mean.detach", "L2PenaltyLoss.detach", "margin.cpu", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.L2PenaltyLoss", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.calc_ue_valiloss", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min"], ["", "def", "train", "(", "self", ",", "replay_buffer", ",", "done_training_iters", ",", "iterations", "=", "5000", ",", "batch_size", "=", "1000", ",", "ue_loss_k", "=", "10000", ",", "\n", "ue_vali_freq", "=", "1000", ",", "\n", "logger", "=", "dict", "(", ")", ")", ":", "\n", "\n", "\t\t", "for", "it", "in", "range", "(", "done_training_iters", ",", "done_training_iters", "+", "iterations", ")", ":", "\n", "\n", "# get batch data", "\n", "\t\t\t", "state", ",", "next_state", ",", "action", ",", "reward", ",", "done", ",", "idxs", "=", "replay_buffer", ".", "sample", "(", "batch_size", ",", "require_idxs", "=", "True", ")", "\n", "\n", "state", "=", "torch", ".", "FloatTensor", "(", "state", ")", ".", "to", "(", "device", ")", "\n", "action", "=", "torch", ".", "FloatTensor", "(", "action", ")", ".", "to", "(", "device", ")", "\n", "# next_state = torch.FloatTensor(next_state).to(device)", "\n", "# reward = torch.FloatTensor(reward).to(device)", "\n", "# done = torch.FloatTensor(1 - done).to(device)", "\n", "mc_ret", "=", "self", ".", "MCrets", "[", "idxs", "]", "\n", "uetrain_batch_pos", "=", "[", "p", "for", "p", ",", "i", "in", "enumerate", "(", "idxs", ")", "if", "i", "not", "in", "self", ".", "MC_valiset_indices", "]", "\n", "uetrain_s", "=", "state", "[", "uetrain_batch_pos", "]", "\n", "uetrain_mc", "=", "mc_ret", "[", "uetrain_batch_pos", "]", "\n", "\n", "# train upper envelope by the k-penalty loss", "\n", "Vsi", "=", "self", ".", "v_ue", "(", "uetrain_s", ")", "\n", "ue_loss", "=", "L2PenaltyLoss", "(", "Vsi", ",", "uetrain_mc", ",", "k_val", "=", "ue_loss_k", ")", "\n", "\n", "self", ".", "v_ue_optimizer", ".", "zero_grad", "(", ")", "\n", "ue_loss", ".", "backward", "(", ")", "\n", "self", ".", "v_ue_optimizer", ".", "step", "(", ")", "\n", "\n", "\"\"\" if it is time to recalculate border/margin \"\"\"", "\n", "\"\"\" 1. calculate validation loss from the validation set, update the best ue \"\"\"", "\n", "if", "it", "%", "ue_vali_freq", "==", "0", ":", "\n", "\n", "\t\t\t\t", "test_states", ",", "test_mcrets", "=", "self", ".", "States", "[", "self", ".", "MC_valiset_indices", "]", ",", "self", ".", "MCrets", "[", "self", ".", "MC_valiset_indices", "]", "\n", "validation_loss", "=", "calc_ue_valiloss", "(", "self", ".", "v_ue", ",", "test_states", ",", "test_mcrets", ",", "\n", "ue_bsize", "=", "int", "(", "batch_size", "*", "0.8", ")", ",", "ue_loss_k", "=", "ue_loss_k", ")", "\n", "\n", "# choose the best parameters with least validation loss for the eval ue", "\n", "self", ".", "ue_valiloss_min", "=", "torch", ".", "min", "(", "self", ".", "ue_valiloss_min", ",", "validation_loss", ")", "\n", "logger", ".", "store", "(", "UEValiLossMin", "=", "self", ".", "ue_valiloss_min", ")", "\n", "if", "validation_loss", ">", "self", ".", "ue_valiloss_min", ":", "\n", "\t\t\t\t\t", "self", ".", "best_v_ue", ".", "load_state_dict", "(", "self", ".", "ue_best_parameters", ")", "\n", "self", ".", "num_increase", "+=", "1", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "self", ".", "ue_best_parameters", "=", "self", ".", "v_ue", ".", "state_dict", "(", ")", "\n", "self", ".", "num_increase", "=", "0", "\n", "# if validation loss of ue is increasing for some consecutive steps, also return the training ue to least", "\n", "# validation loss parameters", "\n", "", "if", "self", ".", "num_increase", "==", "4", ":", "\n", "\t\t\t\t\t", "self", ".", "v_ue", ".", "load_state_dict", "(", "self", ".", "ue_best_parameters", ")", "\n", "\n", "", "\"\"\" 2. estimate state values by the beat ue \"\"\"", "\n", "States_values", "=", "[", "]", "\n", "num_slice", "=", "int", "(", "np", ".", "ceil", "(", "self", ".", "States", ".", "shape", "[", "0", "]", "/", "batch_size", ")", ")", "\n", "for", "i", "in", "range", "(", "num_slice", ")", ":", "\n", "\t\t\t\t\t", "ind", "=", "slice", "(", "i", "*", "batch_size", ",", "min", "(", "(", "i", "+", "1", ")", "*", "batch_size", ",", "self", ".", "States", ".", "shape", "[", "0", "]", ")", ")", "\n", "s", "=", "self", ".", "States", "[", "ind", "]", "\n", "States_values", ".", "append", "(", "self", ".", "best_v_ue", "(", "s", ")", ".", "detach", "(", ")", ")", "\n", "", "States_values", "=", "torch", ".", "stack", "(", "States_values", ")", ".", "view", "(", "-", "1", ")", "\n", "# States_values = self.best_v_ue(self.States).squeeze().detach()", "\n", "\n", "# project negative or small positive state values to (0, 1)", "\n", "States_values", "=", "torch", ".", "where", "(", "States_values", "<", "1", ",", "(", "States_values", "-", "1", ")", ".", "exp", "(", ")", ",", "States_values", ")", "\n", "\n", "if", "self", ".", "C", "is", "not", "None", ":", "\n", "\t\t\t\t\t", "C", "=", "self", ".", "C", ".", "to", "(", "device", ")", "\n", "States_values", "=", "torch", ".", "where", "(", "States_values", ">", "C", ",", "C", ",", "States_values", ")", "\n", "\n", "", "\"\"\" 3. get current percentage from the anneal plan \"\"\"", "\n", "if", "self", ".", "pct_anneal_type", "==", "'constant'", ":", "\n", "\t\t\t\t\t", "cur_pct", "=", "self", ".", "last_pct", "\n", "", "elif", "self", ".", "pct_anneal_type", "==", "'linear'", ":", "\n", "\t\t\t\t\t", "cur_pct", "=", "1", "-", "it", "/", "self", ".", "max_iters", "*", "(", "1", "-", "self", ".", "last_pct", ")", "\n", "", "elif", "self", ".", "pct_anneal_type", "==", "'line2const'", ":", "\n", "\t\t\t\t\t", "const_timesteps", "=", "self", ".", "pct_info_dic", "[", "'const_timesteps'", "]", "\n", "cur_pct", "=", "1", "-", "min", "(", "it", "/", "(", "self", ".", "max_iters", "-", "const_timesteps", ")", ",", "1.0", ")", "*", "(", "1", "-", "self", ".", "last_pct", ")", "\n", "", "elif", "self", ".", "pct_anneal_type", "==", "'convex1'", ":", "# sigmoid-shape function", "\n", "\t\t\t\t\t", "convex1_coef", "=", "self", ".", "pct_info_dic", "[", "'convex1_coef'", "]", "\n", "cur_pct", "=", "self", ".", "last_pct", "+", "2", "*", "(", "1", "-", "self", ".", "last_pct", ")", "/", "(", "1", "+", "np", ".", "exp", "(", "convex1_coef", "*", "it", "/", "self", ".", "max_iters", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "raise", "Exception", "(", "'! undefined percentage anneal type'", ")", "\n", "\n", "", "logger", ".", "store", "(", "SelePct", "=", "cur_pct", ")", "\n", "\n", "\"\"\" 4.  determine the border / margin by current percentage \"\"\"", "\n", "if", "self", ".", "select_type", "==", "'border'", ":", "\n", "\t\t\t\t\t", "ratios", "=", "self", ".", "MCrets", ".", "view", "(", "-", "1", ")", "/", "States_values", "\n", "increasing_ratios", ",", "increasing_ratio_indices", "=", "torch", ".", "sort", "(", "ratios", ")", "\n", "bor_ind", "=", "increasing_ratio_indices", "[", "-", "int", "(", "cur_pct", "*", "self", ".", "States", ".", "shape", "[", "0", "]", ")", "]", "\n", "border", "=", "ratios", "[", "bor_ind", "]", "\n", "logger", ".", "store", "(", "Border", "=", "border", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", "\n", "# print(self.MCrets[increasing_ratio_indices[:100]], States_values[increasing_ratio_indices[:100]],", "\n", "#\t   ratios[increasing_ratio_indices[:100]])", "\n", "\n", "", "elif", "self", ".", "select_type", "==", "'margin'", ":", "\n", "\t\t\t\t\t", "diffs", "=", "self", ".", "MCrets", ".", "view", "(", "-", "1", ")", "-", "States_values", "\n", "increasing_diffs", ",", "increasing_diff_indices", "=", "torch", ".", "sort", "(", "diffs", ")", "\n", "mrg_ind", "=", "increasing_diff_indices", "[", "-", "int", "(", "cur_pct", "*", "self", ".", "States", ".", "shape", "[", "0", "]", ")", "]", "\n", "margin", "=", "diffs", "[", "mrg_ind", "]", "\n", "logger", ".", "store", "(", "Margin", "=", "margin", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "raise", "Exception", "(", "'! undefined selection type'", ")", "\n", "\n", "# Compute MSE loss for actor", "\n", "", "", "state_value", "=", "States_values", "[", "idxs", "]", ".", "squeeze", "(", ")", "\n", "# state_value_check = self.best_v_ue(state).squeeze().detach()", "\n", "# state_value_check = torch.where(state_value_check < 1, (state_value_check - 1).exp(), state_value_check)", "\n", "if", "self", ".", "select_type", "==", "'border'", ":", "\n", "\t\t\t\t", "weights", "=", "torch", ".", "where", "(", "mc_ret", ">=", "border", "*", "state_value", ",", "torch", ".", "FloatTensor", "(", "[", "1", "]", ")", ".", "to", "(", "device", ")", ",", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "to", "(", "device", ")", ")", "\n", "", "elif", "self", ".", "select_type", "==", "'margin'", ":", "\n", "\t\t\t\t", "weights", "=", "torch", ".", "where", "(", "mc_ret", ">=", "margin", "+", "state_value", ",", "torch", ".", "FloatTensor", "(", "[", "1", "]", ")", ".", "to", "(", "device", ")", ",", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "to", "(", "device", ")", ")", "\n", "\n", "", "update_size", "=", "weights", ".", "sum", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "weights", "=", "torch", ".", "stack", "(", "[", "weights", ",", "]", "*", "self", ".", "action_dim", ",", "dim", "=", "1", ")", "\n", "# print(weights.size(), action.size())", "\n", "actor_loss", "=", "torch", ".", "mul", "(", "weights", ",", "self", ".", "actor", "(", "state", ")", "-", "action", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "# Optimize the actor", "\n", "self", ".", "actor_optimizer", ".", "zero_grad", "(", ")", "\n", "actor_loss", ".", "backward", "(", ")", "\n", "self", ".", "actor_optimizer", ".", "step", "(", ")", "\n", "\n", "logger", ".", "store", "(", "CloneLoss", "=", "actor_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "UELoss", "=", "ue_loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "BatchUEtrnSize", "=", "len", "(", "uetrain_batch_pos", ")", ",", "BatchUpSize", "=", "update_size", ",", "\n", "SVal", "=", "state_value", ".", "detach", "(", ")", ".", "mean", "(", ")", ")", "\n", "\n", "", "return", "self", ".", "best_v_ue", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BC.__init__": [[379, 384], ["Actor().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "bail_training.BC.actor.parameters", "bail_training.Actor"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "state_dim", ",", "action_dim", ",", "max_action", ",", "lr", ",", "wd", ")", ":", "\n", "\t\t", "self", ".", "actor", "=", "Actor", "(", "state_dim", ",", "action_dim", ",", "max_action", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "actor_optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "actor", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "weight_decay", "=", "wd", ")", "\n", "\n", "self", ".", "state_dim", "=", "state_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BC.select_action": [[385, 388], ["torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "bail_training.BC.actor().cpu().data.numpy().flatten", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "bail_training.BC.actor().cpu().data.numpy", "torch.FloatTensor().to.reshape", "torch.FloatTensor().to.reshape", "torch.FloatTensor().to.reshape", "bail_training.BC.actor().cpu", "bail_training.BC.actor"], "methods", ["None"], ["", "def", "select_action", "(", "self", ",", "state", ")", ":", "\n", "\t\t", "state", "=", "torch", ".", "FloatTensor", "(", "state", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ".", "to", "(", "device", ")", "\n", "return", "self", ".", "actor", "(", "state", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BC.train": [[389, 405], ["dict", "range", "replay_buffer.sample", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "bail_training.BC.actor_optimizer.zero_grad", "actor_loss.backward", "bail_training.BC.actor_optimizer.step", "logger.store", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "actor_loss.cpu().item", "actor_loss.cpu", "bail_training.BC.actor"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store"], ["", "def", "train", "(", "self", ",", "replay_buffer", ",", "iterations", "=", "500", ",", "batch_size", "=", "1000", ",", "logger", "=", "dict", "(", ")", ")", ":", "\n", "\t\t", "for", "it", "in", "range", "(", "iterations", ")", ":", "\n", "\t\t\t", "state", ",", "_", ",", "action", ",", "_", ",", "_", "=", "replay_buffer", ".", "sample", "(", "batch_size", ")", "\n", "\n", "state", "=", "torch", ".", "FloatTensor", "(", "state", ")", ".", "to", "(", "device", ")", "\n", "action", "=", "torch", ".", "FloatTensor", "(", "action", ")", ".", "to", "(", "device", ")", "\n", "\n", "# Compute MSE loss", "\n", "actor_loss", "=", "(", "self", ".", "actor", "(", "state", ")", "-", "action", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "# Optimize the actor", "\n", "self", ".", "actor_optimizer", ".", "zero_grad", "(", ")", "\n", "actor_loss", ".", "backward", "(", ")", "\n", "self", ".", "actor_optimizer", ".", "step", "(", ")", "\n", "\n", "logger", ".", "store", "(", "Loss", "=", "actor_loss", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.L2PenaltyLoss": [[407, 423], ["numpy.arange", "torch.autograd.Variable().to", "torch.add", "torch.add", "torch.add", "torch.autograd.Variable", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add"], ["", "", "", "def", "L2PenaltyLoss", "(", "predicted", ",", "target", ",", "k_val", ")", ":", "\n", "    ", "perm", "=", "np", ".", "arange", "(", "predicted", ".", "shape", "[", "0", "]", ")", "\n", "loss", "=", "Variable", "(", "torch", ".", "Tensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "True", ")", ".", "to", "(", "device", ")", "\n", "num", "=", "0", "\n", "for", "i", "in", "perm", ":", "\n", "        ", "Vsi", "=", "predicted", "[", "i", "]", "\n", "yi", "=", "target", "[", "i", "]", "\n", "if", "Vsi", ">=", "yi", ":", "\n", "            ", "mseloss", "=", "(", "Vsi", "-", "yi", ")", "**", "2", "\n", "#loss = torch.add(loss,mseloss)", "\n", "", "else", ":", "\n", "            ", "mseloss", "=", "k_val", "*", "(", "yi", "-", "Vsi", ")", "**", "2", "\n", "num", "+=", "1", "\n", "", "loss", "=", "torch", ".", "add", "(", "loss", ",", "mseloss", ")", "# a very big number", "\n", "#print ('below:',num)", "\n", "", "return", "loss", "/", "predicted", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.calc_ue_valiloss": [[424, 438], ["int", "torch.FloatTensor().detach().to", "torch.FloatTensor().detach().to", "torch.FloatTensor().detach().to", "range", "numpy.ceil", "slice", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "upper_envelope", "L2PenaltyLoss().detach", "torch.FloatTensor().detach", "torch.FloatTensor().detach", "torch.FloatTensor().detach", "min", "torch.autograd.Variable", "torch.autograd.Variable", "bail_training.L2PenaltyLoss", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "Variable().to.float", "Variable().to.float"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.L2PenaltyLoss"], ["", "def", "calc_ue_valiloss", "(", "upper_envelope", ",", "test_states", ",", "test_returns", ",", "ue_bsize", ",", "ue_loss_k", ")", ":", "\n", "\n", "\t", "test_iter", "=", "int", "(", "np", ".", "ceil", "(", "test_returns", ".", "shape", "[", "0", "]", "/", "ue_bsize", ")", ")", "\n", "validation_loss", "=", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "detach", "(", ")", ".", "to", "(", "device", ")", "\n", "for", "n", "in", "range", "(", "test_iter", ")", ":", "\n", "\t\t", "ind", "=", "slice", "(", "n", "*", "ue_bsize", ",", "min", "(", "(", "n", "+", "1", ")", "*", "ue_bsize", ",", "test_returns", ".", "shape", "[", "0", "]", ")", ")", "\n", "states_t", ",", "returns_t", "=", "test_states", "[", "ind", "]", ",", "test_returns", "[", "ind", "]", "\n", "states_t", "=", "Variable", "(", "states_t", ".", "float", "(", ")", ")", ".", "to", "(", "device", ")", "\n", "returns_t", "=", "Variable", "(", "returns_t", ".", "float", "(", ")", ")", ".", "to", "(", "device", ")", "\n", "Vsi", "=", "upper_envelope", "(", "states_t", ")", "\n", "loss", "=", "L2PenaltyLoss", "(", "Vsi", ",", "returns_t", ",", "k_val", "=", "ue_loss_k", ")", ".", "detach", "(", ")", "\n", "validation_loss", "+=", "loss", "\n", "\n", "", "return", "validation_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.train_upper_envelope": [[442, 547], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "Value().to", "Value().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.max", "torch.max", "torch.max", "highestR.view.view", "print", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().to", "int", "print", "print", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "int", "float", "Value().to.state_dict", "Value().to.load_state_dict", "Value().to.train", "range", "print", "Value().to.parameters", "torch.cat.size", "highestS.size", "torch.cat.size", "highestR.view.size", "numpy.ceil", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().to", "range", "bail_training.calc_ue_valiloss", "print", "print", "print", "print", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "bail_training.Value", "bail_training.Value", "torch.LongTensor", "torch.cat.squeeze", "highestS.unsqueeze", "torch.cat.squeeze", "highestR.view.squeeze().unsqueeze", "slice", "torch.autograd.Variable", "torch.autograd.Variable", "Value().to.", "bail_training.L2PenaltyLoss", "L2PenaltyLoss.detach", "Value().to.zero_grad", "L2PenaltyLoss.backward", "torch.optim.Adam.step", "Value().to.state_dict", "Value().to.load_state_dict", "Value().to.load_state_dict", "L2PenaltyLoss.cpu().item", "calc_ue_valiloss.cpu().item", "numpy.array", "numpy.array", "torch.LongTensor", "min", "torch.autograd.Variable.float", "torch.autograd.Variable.float", "highestR.view.squeeze", "L2PenaltyLoss.cpu", "calc_ue_valiloss.cpu"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BC.train", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.calc_ue_valiloss", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.L2PenaltyLoss", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min"], ["def", "train_upper_envelope", "(", "states", ",", "returns", ",", "state_dim", ",", "seed", ",", "\n", "upper_learning_rate", "=", "3e-3", ",", "\n", "weight_decay", "=", "0.02", ",", "\n", "num_epoches", "=", "50", ",", "\n", "consecutive_steps", "=", "4", ",", "k", "=", "10000", ")", ":", "\n", "\n", "\t", "states", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "states", ")", ")", ".", "to", "(", "device", ")", "\n", "returns", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "returns", ")", ")", ".", "to", "(", "device", ")", "# reward is actually returns", "\n", "\n", "# Init upper_envelope net (*use relu as activation function", "\n", "upper_envelope", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", ".", "to", "(", "device", ")", "\n", "upper_envelope_retrain", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", ".", "to", "(", "device", ")", "\n", "optimizer_upper", "=", "torch", ".", "optim", ".", "Adam", "(", "upper_envelope", ".", "parameters", "(", ")", ",", "lr", "=", "upper_learning_rate", ",", "\n", "weight_decay", "=", "weight_decay", ")", "\n", "\n", "\n", "# Split data into training and testing #", "\n", "# But make sure the highest Ri is in the training set", "\n", "# pick out the highest data point", "\n", "highestR", ",", "indice", "=", "torch", ".", "max", "(", "returns", ",", "0", ")", "\n", "highestR", "=", "highestR", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "highestS", "=", "states", "[", "indice", "]", "\n", "print", "(", "\"HighestR:\"", ",", "highestR", ")", "\n", "\n", "statesW", "=", "torch", ".", "cat", "(", "(", "states", "[", ":", "indice", "]", ",", "states", "[", "indice", "+", "1", ":", "]", ")", ")", "\n", "returnsW", "=", "torch", ".", "cat", "(", "(", "returns", "[", ":", "indice", "]", ",", "returns", "[", "indice", "+", "1", ":", "]", ")", ")", "\n", "\n", "# shuffle the data", "\n", "perm", "=", "np", ".", "arange", "(", "statesW", ".", "shape", "[", "0", "]", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "perm", ")", "\n", "perm", "=", "LongTensor", "(", "perm", ")", ".", "to", "(", "device", ")", "\n", "statesW", ",", "returnsW", "=", "statesW", "[", "perm", "]", ",", "returnsW", "[", "perm", "]", "\n", "\n", "# divide data into train/test", "\n", "divide", "=", "int", "(", "states", ".", "shape", "[", "0", "]", "*", "0.8", ")", "\n", "train_states", ",", "train_returns", "=", "statesW", "[", ":", "divide", "]", ",", "returnsW", "[", ":", "divide", "]", "\n", "test_states", ",", "test_returns", "=", "statesW", "[", "divide", ":", "]", ",", "returnsW", "[", "divide", ":", "]", "\n", "\n", "# add the highest data into training", "\n", "print", "(", "train_states", ".", "size", "(", ")", ",", "highestS", ".", "size", "(", ")", ")", "\n", "print", "(", "train_returns", ".", "size", "(", ")", ",", "highestR", ".", "size", "(", ")", ")", "\n", "train_states", "=", "torch", ".", "cat", "(", "(", "train_states", ".", "squeeze", "(", ")", ",", "highestS", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "train_returns", "=", "torch", ".", "cat", "(", "(", "train_returns", ".", "squeeze", "(", ")", ",", "highestR", ".", "squeeze", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "\n", "# train upper envelope", "\n", "# env_dummy = env_factory(0)", "\n", "# state_dim = env_dummy.observation_space.shape[0]", "\n", "# upper_envelope = Value(state_dim)", "\n", "# optimizer = torch.optim.Adam(upper_envelope.parameters(), lr=0.003, weight_decay=20)", "\n", "\n", "batch_size", "=", "800", "\n", "optim_iter_num", "=", "int", "(", "np", ".", "ceil", "(", "train_states", ".", "shape", "[", "0", "]", "/", "batch_size", ")", ")", "\n", "\n", "num_increase", "=", "0", "\n", "previous_loss", "=", "float", "(", "'inf'", ")", "\n", "best_parameters", "=", "upper_envelope", ".", "state_dict", "(", ")", "\n", "upper_envelope_retrain", ".", "load_state_dict", "(", "best_parameters", ")", "\n", "\n", "# Upper Envelope Training starts", "\n", "upper_envelope", ".", "train", "(", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "num_epoches", ")", ":", "\n", "# update theta for n steps, n =", "\n", "\t\t", "train_loss", "=", "0", "\n", "perm", "=", "np", ".", "arange", "(", "train_states", ".", "shape", "[", "0", "]", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "perm", ")", "\n", "perm", "=", "LongTensor", "(", "perm", ")", ".", "to", "(", "device", ")", "\n", "\n", "train_states", ",", "train_returns", "=", "train_states", "[", "perm", "]", ",", "train_returns", "[", "perm", "]", "\n", "\n", "for", "i", "in", "range", "(", "optim_iter_num", ")", ":", "\n", "\t\t\t", "ind", "=", "slice", "(", "i", "*", "batch_size", ",", "min", "(", "(", "i", "+", "1", ")", "*", "batch_size", ",", "states", ".", "shape", "[", "0", "]", ")", ")", "\n", "states_b", ",", "returns_b", "=", "train_states", "[", "ind", "]", ",", "train_returns", "[", "ind", "]", "\n", "states_b", "=", "Variable", "(", "states_b", ".", "float", "(", ")", ")", "\n", "returns_b", "=", "Variable", "(", "returns_b", ".", "float", "(", ")", ")", "\n", "Vsi", "=", "upper_envelope", "(", "states_b", ")", "\n", "# loss = loss_fn(Vsi, returns_b)", "\n", "loss", "=", "L2PenaltyLoss", "(", "Vsi", ",", "returns_b", ",", "k_val", "=", "k", ")", "\n", "train_loss", "+=", "loss", ".", "detach", "(", ")", "\n", "upper_envelope", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer_upper", ".", "step", "(", ")", "\n", "\n", "# early stopping", "\n", "\n", "# calculate validation error", "\n", "", "validation_loss", "=", "calc_ue_valiloss", "(", "upper_envelope", ",", "test_states", ",", "test_returns", ",", "ue_bsize", "=", "batch_size", ",", "ue_loss_k", "=", "k", ")", "\n", "if", "validation_loss", "<", "previous_loss", ":", "\n", "\t\t\t", "previous_loss", "=", "validation_loss", "\n", "best_parameters", "=", "upper_envelope", ".", "state_dict", "(", ")", "\n", "upper_envelope_retrain", ".", "load_state_dict", "(", "best_parameters", ")", "\n", "num_increase", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t", "num_increase", "+=", "1", "\n", "", "if", "num_increase", "==", "consecutive_steps", ":", "\n", "\t\t\t", "upper_envelope", ".", "load_state_dict", "(", "best_parameters", ")", "\n", "\n", "", "print", "(", ")", "\n", "print", "(", "'Epoch:'", ",", "epoch", "+", "1", ")", "\n", "print", "(", "'UETrainLoss:'", ",", "loss", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", "\n", "print", "(", "'UEValiLoss:'", ",", "validation_loss", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "print", "(", "\"Policy training is complete.\"", ")", "\n", "\n", "return", "upper_envelope", ",", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.plot_envelope": [[551, 597], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "upper_envelope.to.to", "range", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.stack", "torch.stack", "torch.stack", "torch.sort", "torch.sort", "torch.sort", "matplotlib.rc", "matplotlib.subplots", "axs.set_xlabel", "axs.set_ylabel", "list", "matplotlib.scatter", "matplotlib.plot", "matplotlib.legend", "matplotlib.xticks", "matplotlib.yticks", "matplotlib.tight_layout", "matplotlib.savefig", "matplotlib.close", "print", "torch.stack.append", "torch.stack.view", "torch.nn.functional.relu().sum", "torch.nn.functional.relu().sum", "torch.nn.functional.relu().sum", "numpy.arange", "list", "list", "matplotlib.title", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "upper_envelope.to.detach", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.nn.functional.relu().sum", "torch.nn.functional.relu().sum", "torch.nn.functional.relu().sum", "all_ue_loss.item", "setting.replace", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.from_numpy().float().to.view().cpu().numpy", "increasing_ue_vals.view().cpu().numpy", "upper_envelope.to.", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "s.float", "torch.from_numpy().float().to.view().cpu", "increasing_ue_vals.view().cpu", "torch.from_numpy().float().to.view", "increasing_ue_vals.view"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum"], ["def", "plot_envelope", "(", "upper_envelope", ",", "states", ",", "returns", ",", "setting", ",", "seed", ",", "hyper_lst", ",", "make_title", "=", "False", ")", ":", "\n", "\n", "\t", "upper_learning_rate", ",", "weight_decay", ",", "k_val", ",", "num_epoches", ",", "consecutive_steps", "=", "hyper_lst", "\n", "\n", "states", "=", "torch", ".", "from_numpy", "(", "states", ")", ".", "to", "(", "device", ")", "\n", "upper_envelope", "=", "upper_envelope", ".", "to", "(", "device", ")", "\n", "# highestR, _ = torch.max(returns, 0)", "\n", "\n", "upper_envelope_r", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "\t\t", "s", "=", "states", "[", "i", "]", "\n", "upper_envelope_r", ".", "append", "(", "upper_envelope", "(", "s", ".", "float", "(", ")", ")", ".", "detach", "(", ")", ")", "\n", "\n", "", "MC_r", "=", "torch", ".", "from_numpy", "(", "returns", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "upper_envelope_r", "=", "torch", ".", "stack", "(", "upper_envelope_r", ")", "\n", "increasing_ue_vals", ",", "increasing_ue_indices", "=", "torch", ".", "sort", "(", "upper_envelope_r", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "MC_r", "=", "MC_r", "[", "increasing_ue_indices", "[", "0", "]", "]", "\n", "\n", "all_ue_loss", "=", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "increasing_ue_vals", "-", "MC_r", ")", ".", "sum", "(", ")", "+", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "MC_r", "-", "increasing_ue_vals", ")", ".", "sum", "(", ")", "*", "k_val", "\n", "\n", "plt", ".", "rc", "(", "'legend'", ",", "fontsize", "=", "14", ")", "# legend fontsize", "\n", "fig", ",", "axs", "=", "plt", ".", "subplots", "(", ")", "\n", "\n", "axs", ".", "set_xlabel", "(", "'state'", ",", "fontsize", "=", "28", ")", "\n", "axs", ".", "set_ylabel", "(", "'Returns and \\n Upper Envelope'", ",", "fontsize", "=", "28", ",", "multialignment", "=", "\"center\"", ")", "\n", "\n", "plot_s", "=", "list", "(", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", ")", "\n", "plt", ".", "scatter", "(", "plot_s", ",", "list", "(", "MC_r", ".", "view", "(", "1", ",", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", ",", "s", "=", "0.5", ",", "color", "=", "'orange'", ",", "label", "=", "'MC Returns'", ")", "\n", "plt", ".", "plot", "(", "plot_s", ",", "list", "(", "increasing_ue_vals", ".", "view", "(", "1", ",", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", ",", "color", "=", "'blue'", ",", "label", "=", "\"Upper Envelope\"", ")", "\n", "\n", "ue_info", "=", "'_loss_%.2fe6'", "%", "(", "all_ue_loss", ".", "item", "(", ")", "/", "1e6", ")", "\n", "if", "make_title", ":", "\n", "\t\t", "title", "=", "setting", ".", "replace", "(", "'_r'", ",", "'\\nr'", ")", "+", "ue_info", "\n", "plt", ".", "title", "(", "title", ")", "\n", "", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "xticks", "(", "fontsize", "=", "18", ",", "rotation", "=", "15", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "18", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "'./plots/'", "+", "\"ue_visual_%s.png\"", "%", "setting", ")", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "print", "(", "'Plotted current UE in'", ",", "\"ue_visual_%s.png\"", "%", "setting", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.plot_envelope_with_clipping": [[599, 662], ["torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "upper_envelope.to.to", "matplotlib.rc", "matplotlib.subplots", "axs.set_xlabel", "axs.set_ylabel", "range", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.stack", "torch.stack", "torch.stack", "torch.sort", "torch.sort", "torch.sort", "numpy.arange", "range", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.where", "torch.where", "torch.where", "list", "matplotlib.scatter", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.tight_layout", "matplotlib.savefig", "matplotlib.close", "print", "torch.stack.append", "torch.stack.view", "Diff.append", "min", "torch.FloatTensor().to.append", "torch.relu().sum", "numpy.arange", "list", "list", "torch.FloatTensor().to.cpu().numpy", "matplotlib.title", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "upper_envelope.to.detach", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.relu().sum", "Clipping_value.item", "setting.replace", "torch.relu", "torch.from_numpy().float().to.view().cpu().numpy", "increasing_ue_returns.view().cpu().numpy", "torch.FloatTensor().to.cpu", "Clipping_loss.item", "upper_envelope.to.", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().float().to.view().cpu().numpy", "torch.relu", "s.float", "torch.from_numpy().float().to.view().cpu", "increasing_ue_returns.view().cpu", "torch.from_numpy().float().to.view().cpu", "torch.from_numpy().float().to.view", "increasing_ue_returns.view", "torch.from_numpy().float().to.view"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum"], ["", "def", "plot_envelope_with_clipping", "(", "upper_envelope", ",", "states", ",", "returns", ",", "setting", ",", "seed", ",", "hyper_lst", ",", "make_title", "=", "False", ",", "S", "=", "10000", ")", ":", "\n", "\n", "\t", "upper_learning_rate", ",", "weight_decay", ",", "k_val", ",", "num_epoches", ",", "consecutive_steps", "=", "hyper_lst", "\n", "\n", "states", "=", "torch", ".", "from_numpy", "(", "states", ")", ".", "to", "(", "device", ")", "\n", "upper_envelope", "=", "upper_envelope", ".", "to", "(", "device", ")", "\n", "\n", "plt", ".", "rc", "(", "'legend'", ",", "fontsize", "=", "14", ")", "# legend fontsize", "\n", "fig", ",", "axs", "=", "plt", ".", "subplots", "(", ")", "\n", "\n", "axs", ".", "set_xlabel", "(", "'state'", ",", "fontsize", "=", "28", ")", "\n", "axs", ".", "set_ylabel", "(", "'Returns and \\n Upper Envelope'", ",", "fontsize", "=", "28", ",", "multialignment", "=", "\"center\"", ")", "\n", "\n", "upper_envelope_r", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "\t\t", "s", "=", "states", "[", "i", "]", "\n", "upper_envelope_r", ".", "append", "(", "upper_envelope", "(", "s", ".", "float", "(", ")", ")", ".", "detach", "(", ")", ")", "\n", "\n", "", "MC_r", "=", "torch", ".", "from_numpy", "(", "returns", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "upper_envelope_r", "=", "torch", ".", "stack", "(", "upper_envelope_r", ")", "\n", "increasing_ue_returns", ",", "increasing_ue_indices", "=", "torch", ".", "sort", "(", "upper_envelope_r", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "MC_r", "=", "MC_r", "[", "increasing_ue_indices", "[", "0", "]", "]", "\n", "\n", "# Do auto clipping", "\n", "perm", "=", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", "\n", "Diff", "=", "[", "]", "\n", "for", "idx", "in", "perm", ":", "\n", "\t\t", "Diff", ".", "append", "(", "increasing_ue_returns", "[", "0", ",", "idx", "]", "-", "MC_r", ".", "view", "(", "1", ",", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", ",", "idx", "]", ")", "\n", "\n", "", "eval_point", "=", "states", ".", "shape", "[", "0", "]", "-", "1", "\n", "Clipping_value", "=", "increasing_ue_returns", "[", "0", ",", "eval_point", "]", "\n", "while", "eval_point", ">=", "S", ":", "\n", "\t\t", "min_Diff", "=", "min", "(", "Diff", "[", "eval_point", "-", "S", ":", "eval_point", "]", ")", "\n", "if", "min_Diff", "<", "0", ":", "\n", "\t\t\t", "Clipping_value", "=", "increasing_ue_returns", "[", "0", ",", "eval_point", "]", "\n", "break", "\n", "", "eval_point", "-=", "S", "\n", "\n", "", "Adapt_Clip", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "\t\t", "Adapt_Clip", ".", "append", "(", "Clipping_value", ")", "\n", "", "Adapt_Clip", "=", "torch", ".", "FloatTensor", "(", "Adapt_Clip", ")", ".", "to", "(", "device", ")", "\n", "\n", "clipped_ue_r", "=", "torch", ".", "where", "(", "increasing_ue_returns", ">", "Adapt_Clip", ",", "Adapt_Clip", ",", "increasing_ue_returns", ")", "\n", "#num_above = torch.where(clipped_ue_r > MC_r, torch.FloatTensor([1]), torch.FloatTensor([0])).sum().item()", "\n", "Clipping_loss", "=", "F", ".", "relu", "(", "clipped_ue_r", "-", "MC_r", ")", ".", "sum", "(", ")", "+", "F", ".", "relu", "(", "MC_r", "-", "clipped_ue_r", ")", ".", "sum", "(", ")", "*", "k_val", "\n", "\n", "plot_s", "=", "list", "(", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", ")", "\n", "plt", ".", "scatter", "(", "plot_s", ",", "list", "(", "MC_r", ".", "view", "(", "1", ",", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", ",", "s", "=", "0.5", ",", "color", "=", "'orange'", ",", "label", "=", "'MC Returns'", ")", "\n", "plt", ".", "plot", "(", "plot_s", ",", "list", "(", "increasing_ue_returns", ".", "view", "(", "1", ",", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", ",", "color", "=", "'blue'", ",", "label", "=", "\"Upper Envelope\"", ")", "\n", "plt", ".", "plot", "(", "plot_s", ",", "Adapt_Clip", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "color", "=", "'black'", ",", "label", "=", "\"Adaptive_Clipping_%s\"", "%", "eval_point", ")", "\n", "clip_info", "=", "'_clip_%.2f_loss_%.2fe6_ues_%s'", "%", "(", "Clipping_value", ".", "item", "(", ")", ",", "Clipping_loss", ".", "item", "(", ")", "/", "1e6", ",", "seed", ")", "\n", "if", "make_title", ":", "\n", "\t\t", "plt", ".", "title", "(", "setting", ".", "replace", "(", "'K'", ",", "'K\\n'", ")", ")", "\n", "", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "'./plots/'", "+", "\"ue_visual_%s_Clipped.png\"", "%", "(", "setting", "+", "clip_info", ")", ")", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "print", "(", "'Plotting finished'", ")", "\n", "\n", "return", "Clipping_value", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_static_bail.bail_learn": [[18, 121], ["int", "int", "dict", "spinup.utils.logx.EpochLogger", "spinup.utils.logx.EpochLogger.save_config", "print", "print", "print", "print", "print", "gym.make", "gym.make", "gym.make.seed", "gym.make.seed", "gym.make.action_space.np_random.seed", "gym.make.action_space.np_random.seed", "torch.manual_seed", "numpy.random.seed", "float", "spinup.algos.BAIL.utils.ReplayBuffer", "buffer_type.replace", "utils.ReplayBuffer.load", "numpy.load().squeeze", "numpy.load().squeeze", "print", "print", "print", "main_static_bail.select_batch_ue", "print", "spinup.algos.BAIL.bail_training.BC", "locals", "os.path.exists", "print", "print", "spinup.algos.BAIL.bail_training.train_upper_envelope", "torch.save", "print", "spinup.algos.BAIL.bail_training.plot_envelope", "spinup.algos.BAIL.bail_training.Value", "spinup.algos.BAIL.bail_training.Value.load_state_dict", "print", "spinup.algos.BAIL.bail_training.plot_envelope_with_clipping", "bail_training.BC.train", "main_static_bail.evaluate_policy", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.dump_tabular", "buffer_type.replace", "numpy.load", "numpy.load", "spinup.algos.BAIL.bail_training.Value.state_dict", "torch.load", "border.item", "int"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.save_config", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_static_bail.select_batch_ue", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.train_upper_envelope", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.save", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.plot_envelope", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.plot_envelope_with_clipping", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BC.train", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_prog_bail.evaluate_policy", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.dump_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load"], ["def", "bail_learn", "(", "env_set", "=", "\"Hopper-v2\"", ",", "seed", "=", "0", ",", "buffer_type", "=", "\"FinalSAC_env_0_1000K\"", ",", "\n", "gamma", "=", "0.99", ",", "ue_rollout", "=", "1000", ",", "augment_mc", "=", "'gain'", ",", "\n", "ue_lr", "=", "3e-3", ",", "ue_wd", "=", "2e-2", ",", "ue_loss_k", "=", "1000", ",", "ue_train_epoch", "=", "50", ",", "\n", "clip_ue", "=", "False", ",", "detect_interval", "=", "10000", ",", "\n", "eval_freq", "=", "500", ",", "max_timesteps", "=", "int", "(", "2e5", ")", ",", "batch_size", "=", "int", "(", "1e3", ")", ",", "lr", "=", "1e-3", ",", "wd", "=", "0", ",", "pct", "=", "0.25", ",", "\n", "logger_kwargs", "=", "dict", "(", ")", ")", ":", "\n", "\n", "\n", "\t", "\"\"\"set up logger\"\"\"", "\n", "global", "logger", "\n", "logger", "=", "EpochLogger", "(", "**", "logger_kwargs", ")", "\n", "logger", ".", "save_config", "(", "locals", "(", ")", ")", "\n", "\n", "\n", "file_name", "=", "\"bail_stat_%s_%s\"", "%", "(", "env_set", ",", "seed", ")", "\n", "setting_name", "=", "\"%s_r%s_g%s\"", "%", "(", "buffer_type", ".", "replace", "(", "'env'", ",", "env_set", ")", ",", "ue_rollout", ",", "gamma", ")", "\n", "setting_name", "+=", "'_noaug'", "if", "not", "(", "augment_mc", ")", "else", "''", "\n", "setting_name", "+=", "'_augNew'", "if", "augment_mc", "==", "'new'", "else", "''", "\n", "#in oracle study, use gain calculated via Oracle data, but use NonOracle data to train UE and policy", "\n", "if", "'Oracle'", "==", "buffer_type", "[", ":", "6", "]", ":", "\n", "\t\t", "buffer_type", "=", "'Non'", "+", "buffer_type", "\n", "\n", "", "print", "(", "\"---------------------------------------\"", ")", "\n", "print", "(", "\"Algo: \"", "+", "file_name", "+", "\"\\tData: \"", "+", "buffer_type", ")", "\n", "print", "(", "\"Settings: \"", "+", "setting_name", ")", "\n", "print", "(", "\"Evaluate Policy every\"", ",", "eval_freq", "*", "batch_size", "/", "1e6", ",", "\n", "'epoches; Total'", ",", "max_timesteps", "*", "batch_size", "/", "1e6", ",", "'epoches'", ")", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "\n", "env", "=", "gym", ".", "make", "(", "env_set", ")", "\n", "test_env", "=", "gym", ".", "make", "(", "env_set", ")", "\n", "\n", "# Set seeds", "\n", "env", ".", "seed", "(", "seed", ")", "\n", "test_env", ".", "seed", "(", "seed", ")", "\n", "env", ".", "action_space", ".", "np_random", ".", "seed", "(", "seed", ")", "\n", "test_env", ".", "action_space", ".", "np_random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "state_dim", "=", "env", ".", "observation_space", ".", "shape", "[", "0", "]", "\n", "action_dim", "=", "env", ".", "action_space", ".", "shape", "[", "0", "]", "\n", "max_action", "=", "float", "(", "env", ".", "action_space", ".", "high", "[", "0", "]", ")", "\n", "\n", "# Load buffer", "\n", "replay_buffer", "=", "utils", ".", "ReplayBuffer", "(", ")", "\n", "buffer_name", "=", "buffer_type", ".", "replace", "(", "'env'", ",", "env_set", ")", "\n", "replay_buffer", ".", "load", "(", "buffer_name", ")", "\n", "\n", "states", "=", "np", ".", "load", "(", "'./results/ueMC_%s_S.npy'", "%", "buffer_name", ",", "allow_pickle", "=", "True", ")", ".", "squeeze", "(", ")", "\n", "setting_name", "+=", "'_Gain'", "if", "augment_mc", "==", "'gain'", "else", "'_Gt'", "\n", "returns", "=", "np", ".", "load", "(", "'./results/ueMC_%s.npy'", "%", "setting_name", ",", "allow_pickle", "=", "True", ")", ".", "squeeze", "(", ")", "\n", "print", "(", "'Load mc returns type'", ",", "augment_mc", ",", "'with gamma:'", ",", "gamma", ",", "'rollout length:'", ",", "ue_rollout", ")", "\n", "\n", "cur_ue_setting", "=", "'Stat_'", "+", "setting_name", "+", "'_lossk%s_s%s'", "%", "(", "ue_loss_k", ",", "seed", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'%s/Stat_UE_%s.pth'", "%", "(", "\"./pytorch_models\"", ",", "setting_name", "+", "'_s%s_lok%s'", "%", "(", "seed", ",", "ue_loss_k", ")", ")", ")", ":", "\n", "# train ue", "\n", "\t\t", "print", "(", "'ue train starts --'", ")", "\n", "print", "(", "'with testing MClength:'", ",", "ue_rollout", ",", "'training loss ratio k:'", ",", "ue_loss_k", ")", "\n", "upper_envelope", ",", "_", "=", "train_upper_envelope", "(", "states", ",", "returns", ",", "state_dim", ",", "seed", ",", "upper_learning_rate", "=", "ue_lr", ",", "\n", "weight_decay", "=", "ue_wd", ",", "num_epoches", "=", "ue_train_epoch", ",", "k", "=", "ue_loss_k", ")", "\n", "torch", ".", "save", "(", "upper_envelope", ".", "state_dict", "(", ")", ",", "'%s/Stat_UE_%s.pth'", "%", "(", "\"./pytorch_models\"", ",", "setting_name", "+", "'_s%s_lok%s'", "%", "(", "seed", ",", "ue_loss_k", ")", ")", ")", "\n", "print", "(", "'plotting ue --'", ")", "\n", "plot_envelope", "(", "upper_envelope", ",", "states", ",", "returns", ",", "cur_ue_setting", ",", "seed", ",", "[", "ue_lr", ",", "ue_wd", ",", "ue_loss_k", ",", "ue_train_epoch", ",", "4", "]", ")", "\n", "\n", "", "else", ":", "\n", "\t\t", "upper_envelope", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", "\n", "upper_envelope", ".", "load_state_dict", "(", "torch", ".", "load", "(", "'%s/Stat_UE_%s.pth'", "%", "(", "\"./pytorch_models\"", ",", "setting_name", "+", "'_s%s_lok%s'", "%", "(", "seed", ",", "ue_loss_k", ")", ")", ")", ")", "\n", "print", "(", "'Load seed %s envelope from'", "%", "seed", ",", "'with training loss ratio k:'", ",", "ue_loss_k", ")", "\n", "\n", "# do clipping if needed", "\n", "", "C", "=", "plot_envelope_with_clipping", "(", "upper_envelope", ",", "states", ",", "returns", ",", "cur_ue_setting", ",", "seed", ",", "\n", "[", "ue_lr", ",", "ue_wd", ",", "ue_loss_k", ",", "max_timesteps", ",", "4", "]", ",", "S", "=", "detect_interval", ")", "if", "clip_ue", "else", "None", "\n", "print", "(", "'clipping at:'", ",", "C", ")", "\n", "\n", "\n", "print", "(", "'Doing selection in Buffer via ue --'", ")", "\n", "selected_buffer", ",", "selected_len", ",", "border", "=", "select_batch_ue", "(", "replay_buffer", ",", "states", ",", "returns", ",", "upper_envelope", ",", "seed", ",", "ue_loss_k", ",", "C", ",", "select_percentage", "=", "pct", ")", "\n", "\n", "print", "(", "'-- Policy train starts --'", ")", "\n", "# Initialize policy", "\n", "policy", "=", "bail_training", ".", "BC", "(", "state_dim", ",", "action_dim", ",", "max_action", ",", "lr", "=", "lr", ",", "wd", "=", "wd", ")", "\n", "\n", "training_iters", ",", "epoch", "=", "0", ",", "ue_train_epoch", "\n", "while", "training_iters", "<", "max_timesteps", ":", "\n", "\t\t", "epoch", "+=", "eval_freq", "*", "batch_size", "/", "1e6", "\n", "pol_vals", "=", "policy", ".", "train", "(", "selected_buffer", ",", "iterations", "=", "int", "(", "eval_freq", ")", ",", "batch_size", "=", "batch_size", ",", "logger", "=", "logger", ")", "\n", "\n", "avgtest_reward", "=", "evaluate_policy", "(", "policy", ",", "test_env", ")", "\n", "training_iters", "+=", "eval_freq", "\n", "\n", "\n", "logger", ".", "log_tabular", "(", "'Epoch'", ",", "epoch", ")", "\n", "logger", ".", "log_tabular", "(", "'AverageTestEpRet'", ",", "avgtest_reward", ")", "\n", "logger", ".", "log_tabular", "(", "'TotalSteps'", ",", "training_iters", ")", "\n", "logger", ".", "log_tabular", "(", "'Loss'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'SelectSize'", ",", "selected_len", ")", "\n", "logger", ".", "log_tabular", "(", "'Border'", ",", "border", ".", "item", "(", ")", ")", "\n", "\n", "logger", ".", "dump_tabular", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_static_bail.select_batch_ue": [[124, 154], ["torch.from_numpy().to", "torch.from_numpy().to", "upper_envelope.to.to", "range", "torch.stack().view", "torch.sort", "spinup.algos.BAIL.utils.ReplayBuffer", "print", "range", "print", "upper_envelope.to.detach().squeeze", "torch.stack().view.append", "border.item", "replay_buffer.get_length", "utils.ReplayBuffer.get_length", "torch.from_numpy", "torch.from_numpy", "torch.stack", "replay_buffer.index", "utils.ReplayBuffer.add", "upper_envelope.to.detach", "int", "torch.min", "upper_envelope.to.", "s.unsqueeze().float", "s.unsqueeze"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.get_length", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.get_length", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.index", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min"], ["", "", "def", "select_batch_ue", "(", "replay_buffer", ",", "states", ",", "returns", ",", "upper_envelope", ",", "seed", ",", "ue_loss_k", ",", "C", ",", "select_percentage", ")", ":", "\n", "\n", "\t", "states", "=", "torch", ".", "from_numpy", "(", "states", ")", ".", "to", "(", "device", ")", "\n", "returns", "=", "torch", ".", "from_numpy", "(", "returns", ")", ".", "to", "(", "device", ")", "\n", "upper_envelope", "=", "upper_envelope", ".", "to", "(", "device", ")", "\n", "\n", "ratios", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "\t\t", "s", ",", "ret", "=", "states", "[", "i", "]", ",", "returns", "[", "i", "]", "\n", "s_val", "=", "upper_envelope", "(", "s", ".", "unsqueeze", "(", "dim", "=", "0", ")", ".", "float", "(", ")", ")", ".", "detach", "(", ")", ".", "squeeze", "(", ")", "\n", "ratios", ".", "append", "(", "ret", "/", "torch", ".", "min", "(", "s_val", ",", "C", ")", "if", "C", "is", "not", "None", "else", "ret", "/", "s_val", ")", "\n", "\n", "", "ratios", "=", "torch", ".", "stack", "(", "ratios", ")", ".", "view", "(", "-", "1", ")", "\n", "increasing_ratios", ",", "increasing_ratio_indices", "=", "torch", ".", "sort", "(", "ratios", ")", "\n", "bor_ind", "=", "increasing_ratio_indices", "[", "-", "int", "(", "select_percentage", "*", "states", ".", "shape", "[", "0", "]", ")", "]", "\n", "border", "=", "ratios", "[", "bor_ind", "]", "\n", "\n", "'''begin selection'''", "\n", "selected_buffer", "=", "utils", ".", "ReplayBuffer", "(", ")", "\n", "print", "(", "'Selecting with ue border'", ",", "border", ".", "item", "(", ")", ")", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "\t\t", "rat", "=", "ratios", "[", "i", "]", "\n", "if", "rat", ">=", "border", ":", "\n", "\t\t\t", "obs", ",", "_", ",", "act", ",", "_", ",", "_", "=", "replay_buffer", ".", "index", "(", "i", ")", "\n", "selected_buffer", ".", "add", "(", "(", "obs", ",", "None", ",", "act", ",", "None", ",", "None", ")", ")", "\n", "\n", "", "", "initial_len", ",", "selected_len", "=", "replay_buffer", ".", "get_length", "(", ")", ",", "selected_buffer", ".", "get_length", "(", ")", "\n", "print", "(", "'border:'", ",", "border", ",", "'selecting ratio:'", ",", "selected_len", ",", "'/'", ",", "initial_len", ")", "\n", "\n", "return", "(", "selected_buffer", ",", "selected_len", ",", "border", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_static_bail.evaluate_policy": [[157, 173], ["range", "print", "print", "print", "env.reset", "policy.select_action", "env.step", "numpy.array"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy.Policy.select_action", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step"], ["", "def", "evaluate_policy", "(", "policy", ",", "env", ",", "eval_episodes", "=", "10", ")", ":", "\n", "\t", "tol_reward", "=", "0", "\n", "for", "_", "in", "range", "(", "eval_episodes", ")", ":", "\n", "\t\t", "obs", "=", "env", ".", "reset", "(", ")", "\n", "done", "=", "False", "\n", "while", "not", "done", ":", "\n", "\t\t\t", "action", "=", "policy", ".", "select_action", "(", "np", ".", "array", "(", "obs", ")", ")", "\n", "obs", ",", "reward", ",", "done", ",", "_", "=", "env", ".", "step", "(", "action", ")", "\n", "tol_reward", "+=", "reward", "\n", "\n", "", "", "avg_reward", "=", "tol_reward", "/", "eval_episodes", "\n", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "print", "(", "\"Evaluation over %d episodes: %f\"", "%", "(", "eval_episodes", ",", "avg_reward", ")", ")", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "return", "avg_reward", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_get_mcret.get_mc": [[12, 54], ["dict", "print", "print", "torch.device", "print", "spinup.utils.logx.EpochLogger", "spinup.utils.logx.EpochLogger.save_config", "print", "print", "print", "spinup.algos.BAIL.utils.ReplayBuffer", "buffer_type.replace", "utils.ReplayBuffer.load", "print", "print", "locals", "os.path.exists", "os.makedirs", "main_get_mcret.calculate_mc_gain", "print", "numpy.save", "Exception", "torch.cuda.is_available", "buffer_type.replace", "os.path.exists", "numpy.save", "len"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.save_config", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_get_mcret.calculate_mc_gain", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.save", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.save"], ["def", "get_mc", "(", "env_set", "=", "\"Hopper-v2\"", ",", "seed", "=", "0", ",", "buffer_type", "=", "'FinalSAC_env_0_1000K'", ",", "\n", "gamma", "=", "0.99", ",", "rollout", "=", "1000", ",", "augment_mc", "=", "'gain'", ",", "\n", "logger_kwargs", "=", "dict", "(", ")", ")", ":", "\n", "\n", "    ", "print", "(", "'MClength:'", ",", "rollout", ")", "\n", "print", "(", "'Discount value'", ",", "gamma", ")", "\n", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "print", "(", "\"running on device:\"", ",", "device", ")", "\n", "\n", "global", "logger", "\n", "logger", "=", "EpochLogger", "(", "**", "logger_kwargs", ")", "\n", "logger", ".", "save_config", "(", "locals", "(", ")", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "\"./results\"", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "\"./results\"", ")", "\n", "\n", "", "setting_name", "=", "\"%s_r%s_g%s\"", "%", "(", "buffer_type", ".", "replace", "(", "'env'", ",", "env_set", ")", ",", "rollout", ",", "gamma", ")", "\n", "setting_name", "+=", "'noaug'", "if", "not", "(", "augment_mc", ")", "else", "''", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "print", "(", "\"Settings: \"", "+", "setting_name", ")", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "\n", "# Load buffer", "\n", "replay_buffer", "=", "utils", ".", "ReplayBuffer", "(", ")", "\n", "buffer_name", "=", "buffer_type", ".", "replace", "(", "'env'", ",", "env_set", ")", "\n", "replay_buffer", ".", "load", "(", "buffer_name", ")", "\n", "\n", "\n", "print", "(", "'Starting MC calculation, type:'", ",", "augment_mc", ")", "\n", "\n", "if", "augment_mc", "==", "'gain'", ":", "\n", "        ", "states", ",", "gains", "=", "calculate_mc_gain", "(", "replay_buffer", ",", "rollout", "=", "rollout", ",", "gamma", "=", "gamma", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'./results/ueMC_%s_S.npy'", "%", "buffer_name", ")", ":", "\n", "            ", "np", ".", "save", "(", "'./results/ueMC_%s_S'", "%", "buffer_name", ",", "states", ")", "\n", "", "print", "(", "len", "(", "gains", ")", ")", "\n", "np", ".", "save", "(", "'./results/ueMC_%s_Gain'", "%", "setting_name", ",", "gains", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'! undefined mc calculation type'", ")", "\n", "\n", "", "print", "(", "'Calculation finished =='", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_get_mcret.calculate_mc_gain": [[56, 85], ["main_get_mcret.calculate_mc_return_no_aug", "range", "len", "range", "interval.index", "min"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_get_mcret.calculate_mc_return_no_aug", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.index", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min"], ["", "def", "calculate_mc_gain", "(", "replay_buffer", ",", "rollout", "=", "1000", ",", "gamma", "=", "0.99", ")", ":", "\n", "    ", "states", ",", "actions", ",", "gts", ",", "endpoint", ",", "dist", "=", "calculate_mc_return_no_aug", "(", "replay_buffer", ",", "gamma", ")", "\n", "\n", "aug_gts", "=", "gts", "[", ":", "]", "\n", "\n", "#Add augmentation terms", "\n", "start", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "endpoint", ")", ")", ":", "\n", "        ", "end", "=", "endpoint", "[", "i", "]", "\n", "if", "end", "-", "start", "<", "rollout", "-", "1", ":", "\n", "#Early terminated episodes", "\n", "            ", "start", "=", "end", "+", "1", "\n", "continue", "\n", "\n", "#episodes not early terminated", "\n", "", "for", "j", "in", "range", "(", "end", ",", "start", ",", "-", "1", ")", ":", "\n", "            ", "interval", "=", "dist", "[", "start", ":", "start", "+", "end", "-", "j", "+", "2", "]", "\n", "index", "=", "interval", ".", "index", "(", "min", "(", "interval", ")", ")", "\n", "# term = end - j + 1", "\n", "# term += rollout - index", "\n", "aug_gts", "[", "j", "]", "+=", "gamma", "**", "(", "end", "-", "j", "+", "1", ")", "*", "gts", "[", "start", "+", "index", "]", "\n", "if", "index", "!=", "end", "-", "j", "+", "1", ":", "\n", "                ", "aug_gts", "[", "j", "]", "-=", "gamma", "**", "(", "1000", ")", "*", "gts", "[", "index", "+", "j", "]", "\n", "# term -= end - index - j + 1", "\n", "\n", "# print(\"number of terms used to calculate mc ret: \", term)", "\n", "", "", "start", "=", "end", "+", "1", "\n", "\n", "", "return", "states", ",", "aug_gts", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_get_mcret.calculate_mc_return_no_aug": [[86, 137], ["replaybuffer.get_length", "range", "replaybuffer.index", "states.append", "actions.append", "numpy.array_equal", "gts.append", "gts.append", "endpoint.append", "dist.append", "dist.append", "endpoint.append", "dist.append", "numpy.linalg.norm"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.get_length", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.index", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "calculate_mc_return_no_aug", "(", "replaybuffer", ",", "gamma", "=", "0.99", ")", ":", "\n", "    ", "\"\"\"\n    Calculate the MC return without augmentation\n    Input: replaybuffer: BCQ replay buffer\n    Output: states, actions, returns (no aug)\n    \"\"\"", "\n", "\n", "gts", "=", "[", "]", "\n", "states", "=", "[", "]", "\n", "actions", "=", "[", "]", "\n", "\n", "g", "=", "0", "\n", "\n", "g", "=", "0", "\n", "prev_s", "=", "0", "\n", "termination_point", "=", "0", "\n", "\n", "endpoint", "=", "[", "]", "\n", "dist", "=", "[", "]", "# L2 distance between the current state and the termination point", "\n", "\n", "length", "=", "replaybuffer", ".", "get_length", "(", ")", "\n", "\n", "for", "ind", "in", "range", "(", "length", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "        ", "state", ",", "o2", ",", "action", ",", "r", ",", "done", "=", "replaybuffer", ".", "index", "(", "ind", ")", "\n", "\n", "states", ".", "append", "(", "state", ")", "\n", "actions", ".", "append", "(", "action", ")", "\n", "\n", "if", "done", ":", "\n", "            ", "g", "=", "r", "\n", "gts", ".", "append", "(", "g", ")", "\n", "endpoint", ".", "append", "(", "ind", ")", "\n", "termination_point", "=", "state", "\n", "prev_s", "=", "state", "\n", "dist", ".", "append", "(", "0", ")", "\n", "continue", "\n", "\n", "", "if", "np", ".", "array_equal", "(", "prev_s", ",", "o2", ")", ":", "\n", "            ", "g", "=", "gamma", "*", "g", "+", "r", "\n", "prev_s", "=", "state", "\n", "dist", ".", "append", "(", "np", ".", "linalg", ".", "norm", "(", "state", "-", "termination_point", ")", ")", "\n", "", "else", ":", "\n", "            ", "g", "=", "r", "\n", "endpoint", ".", "append", "(", "ind", ")", "\n", "termination_point", "=", "state", "\n", "prev_s", "=", "state", "\n", "dist", ".", "append", "(", "0", ")", "\n", "\n", "", "gts", ".", "append", "(", "g", ")", "\n", "\n", "", "return", "states", "[", ":", ":", "-", "1", "]", ",", "actions", "[", ":", ":", "-", "1", "]", ",", "gts", "[", ":", ":", "-", "1", "]", ",", "endpoint", "[", ":", ":", "-", "1", "]", ",", "dist", "[", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_prog_bail.bail_learn": [[17, 128], ["int", "dict", "spinup.utils.logx.EpochLogger", "spinup.utils.logx.EpochLogger.save_config", "print", "print", "print", "print", "print", "gym.make", "gym.make", "gym.make.seed", "gym.make.seed", "gym.make.action_space.np_random.seed", "gym.make.action_space.np_random.seed", "torch.manual_seed", "numpy.random.seed", "float", "spinup.algos.BAIL.utils.ReplayBuffer", "buffer_type.replace", "utils.ReplayBuffer.load", "numpy.load().squeeze", "numpy.load().squeeze", "print", "print", "locals", "os.path.exists", "os.makedirs", "os.path.exists", "os.makedirs", "spinup.algos.BAIL.bail_training.BAIL_selebah", "bail_training.BAIL_selebuf.train", "main_prog_bail.evaluate_policy", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.log_tabular", "spinup.utils.logx.EpochLogger.dump_tabular", "buffer_type.replace", "numpy.load", "numpy.load", "spinup.algos.BAIL.bail_training.BAIL_selebuf", "Exception", "spinup.algos.BAIL.bail_training.plot_envelope", "torch.save", "spinup.utils.logx.EpochLogger.log_tabular", "policy.train.state_dict", "spinup.utils.logx.EpochLogger.log_tabular", "Exception"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.save_config", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BC.train", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_prog_bail.evaluate_policy", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.dump_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.plot_envelope", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.save", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular"], ["def", "bail_learn", "(", "algo", "=", "'bail_2_bah'", ",", "\n", "env_set", "=", "\"Hopper-v2\"", ",", "seed", "=", "0", ",", "buffer_type", "=", "'FinalSigma0.5_env_0_1000K'", ",", "\n", "gamma", "=", "0.99", ",", "ue_rollout", "=", "1000", ",", "augment_mc", "=", "'gain'", ",", "C", "=", "None", ",", "\n", "eval_freq", "=", "625", ",", "max_timesteps", "=", "int", "(", "25e4", ")", ",", "batch_size", "=", "1000", ",", "\n", "lr", "=", "1e-3", ",", "wd", "=", "0", ",", "ue_lr", "=", "3e-3", ",", "ue_wd", "=", "2e-2", ",", "ue_loss_k", "=", "1000", ",", "ue_vali_freq", "=", "1250", ",", "\n", "pct_anneal_type", "=", "'constant'", ",", "last_pct", "=", "0.25", ",", "\n", "select_type", "=", "'border'", ",", "\n", "logger_kwargs", "=", "dict", "(", ")", ")", ":", "\n", "\n", "\t", "\"\"\"set up logger\"\"\"", "\n", "global", "logger", "\n", "logger", "=", "EpochLogger", "(", "**", "logger_kwargs", ")", "\n", "logger", ".", "save_config", "(", "locals", "(", ")", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "\"./plots\"", ")", ":", "\n", "\t\t", "os", ".", "makedirs", "(", "\"./plots\"", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "\"./pytorch_models\"", ")", ":", "\n", "\t\t", "os", ".", "makedirs", "(", "\"./pytorch_models\"", ")", "\n", "\n", "", "file_name", "=", "\"%s_%s_%s\"", "%", "(", "algo", ",", "env_set", ",", "seed", ")", "\n", "setting_name", "=", "\"%s_r%s_g%s\"", "%", "(", "buffer_type", ".", "replace", "(", "'env'", ",", "env_set", ")", ",", "ue_rollout", ",", "gamma", ")", "\n", "setting_name", "+=", "'_noaug'", "if", "not", "(", "augment_mc", ")", "else", "''", "\n", "setting_name", "+=", "'_augNew'", "if", "augment_mc", "==", "'new'", "else", "''", "\n", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "print", "(", "\"Algo: \"", "+", "file_name", "+", "\"\\tData: \"", "+", "buffer_type", ")", "\n", "print", "(", "\"Settings: \"", "+", "setting_name", ")", "\n", "print", "(", "\"Evaluate Policy every\"", ",", "eval_freq", "*", "batch_size", "*", "0.8", "/", "1e6", ",", "\n", "'epoches; Total'", ",", "max_timesteps", "*", "batch_size", "*", "0.8", "/", "1e6", ",", "'epoches'", ")", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "\n", "env", "=", "gym", ".", "make", "(", "env_set", ")", "\n", "test_env", "=", "gym", ".", "make", "(", "env_set", ")", "\n", "\n", "# Set seeds", "\n", "env", ".", "seed", "(", "seed", ")", "\n", "test_env", ".", "seed", "(", "seed", ")", "\n", "env", ".", "action_space", ".", "np_random", ".", "seed", "(", "seed", ")", "\n", "test_env", ".", "action_space", ".", "np_random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "state_dim", "=", "env", ".", "observation_space", ".", "shape", "[", "0", "]", "\n", "action_dim", "=", "env", ".", "action_space", ".", "shape", "[", "0", "]", "\n", "max_action", "=", "float", "(", "env", ".", "action_space", ".", "high", "[", "0", "]", ")", "\n", "\n", "# Load buffer", "\n", "replay_buffer", "=", "utils", ".", "ReplayBuffer", "(", ")", "\n", "buffer_name", "=", "buffer_type", ".", "replace", "(", "'env'", ",", "env_set", ")", "\n", "replay_buffer", ".", "load", "(", "buffer_name", ")", "\n", "\n", "# Load data for training UE", "\n", "states", "=", "np", ".", "load", "(", "'./results/ueMC_%s_S.npy'", "%", "buffer_name", ",", "allow_pickle", "=", "True", ")", ".", "squeeze", "(", ")", "\n", "\n", "setting_name", "+=", "'_Gain'", "if", "augment_mc", "==", "'gain'", "else", "'_Gt'", "\n", "gts", "=", "np", ".", "load", "(", "'./results/ueMC_%s.npy'", "%", "setting_name", ",", "allow_pickle", "=", "True", ")", ".", "squeeze", "(", ")", "\n", "print", "(", "'Load mc returns type'", ",", "augment_mc", ",", "'with gamma:'", ",", "gamma", ",", "'rollout length:'", ",", "ue_rollout", ")", "\n", "\n", "# Start training", "\n", "print", "(", "'-- Policy train starts --'", ")", "\n", "# Initialize policy", "\n", "if", "algo", "==", "'bail_2_bah'", ":", "\n", "\t\t", "policy", "=", "bail_training", ".", "BAIL_selebah", "(", "state_dim", ",", "action_dim", ",", "max_action", ",", "max_iters", "=", "max_timesteps", ",", "States", "=", "states", ",", "MCrets", "=", "gts", ",", "\n", "ue_lr", "=", "ue_lr", ",", "ue_wd", "=", "ue_wd", ",", "\n", "pct_anneal_type", "=", "pct_anneal_type", ",", "last_pct", "=", "last_pct", ",", "pct_info_dic", "=", "pct_info_dic", ",", "\n", "select_type", "=", "select_type", ",", "C", "=", "C", ")", "\n", "", "elif", "algo", "==", "'bail_1_buf'", ":", "\n", "\t\t", "policy", "=", "bail_training", ".", "BAIL_selebuf", "(", "state_dim", ",", "action_dim", ",", "max_action", ",", "max_iters", "=", "max_timesteps", ",", "\n", "States", "=", "states", ",", "MCrets", "=", "gts", ",", "\n", "ue_lr", "=", "ue_lr", ",", "ue_wd", "=", "ue_wd", ",", "\n", "pct_anneal_type", "=", "pct_anneal_type", ",", "last_pct", "=", "last_pct", ",", "pct_info_dic", "=", "pct_info_dic", ",", "\n", "select_type", "=", "select_type", ",", "C", "=", "C", ")", "\n", "", "else", ":", "\n", "\t\t", "raise", "Exception", "(", "\"! undefined BAIL implementation '%s'\"", "%", "algo", ")", "\n", "\n", "", "training_iters", ",", "epoch", "=", "0", ",", "0", "\n", "\n", "while", "training_iters", "<", "max_timesteps", ":", "\n", "\t\t", "epoch", "+=", "eval_freq", "*", "batch_size", "*", "0.8", "/", "1e6", "\n", "ue", "=", "policy", ".", "train", "(", "replay_buffer", ",", "training_iters", ",", "iterations", "=", "eval_freq", ",", "batch_size", "=", "batch_size", ",", "\n", "ue_loss_k", "=", "ue_loss_k", ",", "ue_vali_freq", "=", "ue_vali_freq", ",", "\n", "logger", "=", "logger", ")", "\n", "\n", "if", "training_iters", ">=", "max_timesteps", "-", "eval_freq", ":", "\n", "\t\t\t", "cur_ue_setting", "=", "'Prog_'", "+", "setting_name", "+", "'_lossk%s_s%s'", "%", "(", "ue_loss_k", ",", "seed", ")", "\n", "bail_training", ".", "plot_envelope", "(", "ue", ",", "states", ",", "gts", ",", "cur_ue_setting", ",", "seed", ",", "[", "ue_lr", ",", "ue_wd", ",", "ue_loss_k", ",", "max_timesteps", "/", "batch_size", ",", "4", "]", ")", "\n", "torch", ".", "save", "(", "ue", ".", "state_dict", "(", ")", ",", "'%s/Prog_UE_%s.pth'", "%", "(", "\"./pytorch_models\"", ",", "setting_name", "+", "'_s%s_lok%s'", "%", "(", "seed", ",", "ue_loss_k", ")", ")", ")", "\n", "\n", "", "avgtest_reward", "=", "evaluate_policy", "(", "policy", ",", "test_env", ")", "\n", "training_iters", "+=", "eval_freq", "\n", "\n", "# log training info", "\n", "logger", ".", "log_tabular", "(", "'Epoch'", ",", "epoch", ")", "\n", "logger", ".", "log_tabular", "(", "'AverageTestEpRet'", ",", "avgtest_reward", ")", "\n", "logger", ".", "log_tabular", "(", "'TotalSteps'", ",", "training_iters", ")", "\n", "logger", ".", "log_tabular", "(", "'CloneLoss'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'UELoss'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'BatchUEtrnSize'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'SVal'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'SelePct'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'BatchUpSize'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'UEValiLossMin'", ",", "average_only", "=", "True", ")", "\n", "if", "select_type", "==", "'border'", ":", "\n", "\t\t\t", "logger", ".", "log_tabular", "(", "'Border'", ",", "with_min_and_max", "=", "True", ")", "\n", "", "elif", "select_type", "==", "'margin'", ":", "\n", "\t\t\t", "logger", ".", "log_tabular", "(", "'Margin'", ",", "with_min_and_max", "=", "True", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'! undefined selection type'", ")", "\n", "\n", "", "logger", ".", "dump_tabular", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.main_prog_bail.evaluate_policy": [[132, 148], ["range", "print", "print", "print", "env.reset", "policy.select_action", "env.step", "numpy.array"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy.Policy.select_action", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step"], ["", "", "def", "evaluate_policy", "(", "policy", ",", "env", ",", "eval_episodes", "=", "10", ")", ":", "\n", "\t", "tol_reward", "=", "0", "\n", "for", "_", "in", "range", "(", "eval_episodes", ")", ":", "\n", "\t\t", "obs", "=", "env", ".", "reset", "(", ")", "\n", "done", "=", "False", "\n", "while", "not", "done", ":", "\n", "\t\t\t", "action", "=", "policy", ".", "select_action", "(", "np", ".", "array", "(", "obs", ")", ")", "\n", "obs", ",", "reward", ",", "done", ",", "_", "=", "env", ".", "step", "(", "action", ")", "\n", "tol_reward", "+=", "reward", "\n", "\n", "", "", "avg_reward", "=", "tol_reward", "/", "eval_episodes", "\n", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "print", "(", "\"Evaluation over %d episodes: %f\"", "%", "(", "eval_episodes", ",", "avg_reward", ")", ")", "\n", "print", "(", "\"---------------------------------------\"", ")", "\n", "return", "avg_reward", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.__init__": [[10, 14], ["None"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "storage", "=", "[", "]", "\n", "\n", "self", ".", "with_mask", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.add": [[16, 18], ["utils.ReplayBuffer.storage.append"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "add", "(", "self", ",", "data", ")", ":", "\n", "\t\t", "self", ".", "storage", ".", "append", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.sample": [[19, 52], ["numpy.random.randint", "state.append", "next_state.append", "action.append", "reward.append", "done.append", "len", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array().reshape", "numpy.array().reshape", "numpy.array", "numpy.array", "numpy.array", "numpy.array().reshape", "numpy.array().reshape", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array().reshape", "numpy.array().reshape", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "sample", "(", "self", ",", "batch_size", ",", "require_idxs", "=", "False", ",", "space_rollout", "=", "0", ")", ":", "\n", "\t\t", "ind", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "storage", ")", "-", "space_rollout", ",", "\n", "size", "=", "batch_size", ")", "\n", "state", ",", "next_state", ",", "action", ",", "reward", ",", "done", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "for", "i", "in", "ind", ":", "\n", "\t\t\t", "s", ",", "s2", ",", "a", ",", "r", ",", "d", "=", "self", ".", "storage", "[", "i", "]", "\n", "state", ".", "append", "(", "np", ".", "array", "(", "s", ",", "copy", "=", "False", ")", ")", "\n", "next_state", ".", "append", "(", "np", ".", "array", "(", "s2", ",", "copy", "=", "False", ")", ")", "\n", "action", ".", "append", "(", "np", ".", "array", "(", "a", ",", "copy", "=", "False", ")", ")", "\n", "reward", ".", "append", "(", "np", ".", "array", "(", "r", ",", "copy", "=", "False", ")", ")", "\n", "done", ".", "append", "(", "np", ".", "array", "(", "d", ",", "copy", "=", "False", ")", ")", "\n", "\n", "", "if", "require_idxs", ":", "\n", "\t\t\t", "return", "(", "np", ".", "array", "(", "state", ")", ",", "\n", "np", ".", "array", "(", "next_state", ")", ",", "\n", "np", ".", "array", "(", "action", ")", ",", "\n", "np", ".", "array", "(", "reward", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "done", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "ind", ")", "\n", "", "elif", "self", ".", "with_mask", ":", "\n", "\t\t\t", "mask", "=", "self", ".", "bootstrap_mask", "[", "ind", "]", "\n", "return", "(", "np", ".", "array", "(", "state", ")", ",", "\n", "np", ".", "array", "(", "next_state", ")", ",", "\n", "np", ".", "array", "(", "action", ")", ",", "\n", "np", ".", "array", "(", "reward", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "done", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "mask", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "return", "(", "np", ".", "array", "(", "state", ")", ",", "\n", "np", ".", "array", "(", "next_state", ")", ",", "\n", "np", ".", "array", "(", "action", ")", ",", "\n", "np", ".", "array", "(", "reward", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "done", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.index": [[53, 55], ["None"], "methods", ["None"], ["", "", "def", "index", "(", "self", ",", "i", ")", ":", "\n", "\t\t", "return", "self", ".", "storage", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.save": [[56, 58], ["numpy.save"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.save"], ["", "def", "save", "(", "self", ",", "filename", ")", ":", "\n", "\t\t", "np", ".", "save", "(", "\"./buffers/\"", "+", "filename", "+", "\"sars.npy\"", ",", "self", ".", "storage", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load": [[59, 71], ["numpy.load", "len", "print", "print", "numpy.random.binomial", "numpy.squeeze"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print"], ["", "def", "load", "(", "self", ",", "filename", ",", "bootstrap_dim", "=", "None", ")", ":", "\n", "\t\t", "self", ".", "storage", "=", "np", ".", "load", "(", "\"./buffers/\"", "+", "filename", "+", "\"sars.npy\"", ",", "\n", "allow_pickle", "=", "True", ")", "\n", "num_samples", "=", "len", "(", "self", ".", "storage", ")", "\n", "print", "(", "'Load buffer size:'", ",", "num_samples", ")", "\n", "if", "bootstrap_dim", "is", "not", "None", ":", "\n", "\t\t\t", "print", "(", "'Bootstrap with dim'", ",", "bootstrap_dim", ")", "\n", "self", ".", "with_mask", "=", "True", "\n", "self", ".", "bootstrap_dim", "=", "bootstrap_dim", "\n", "bootstrap_mask", "=", "np", ".", "random", ".", "binomial", "(", "n", "=", "1", ",", "size", "=", "(", "1", ",", "num_samples", ",", "bootstrap_dim", ",", ")", ",", "p", "=", "0.8", ")", "\n", "bootstrap_mask", "=", "np", ".", "squeeze", "(", "bootstrap_mask", ",", "axis", "=", "0", ")", "\n", "self", ".", "bootstrap_mask", "=", "bootstrap_mask", "[", ":", "num_samples", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.cut_final": [[72, 74], ["int"], "methods", ["None"], ["", "", "def", "cut_final", "(", "self", ",", "buffer_size", ")", ":", "\n", "\t\t", "self", ".", "storage", "=", "self", ".", "storage", "[", "-", "int", "(", "buffer_size", ")", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.get_length": [[75, 77], ["utils.ReplayBuffer.storage.__len__"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.ReplayBuffer.__len__"], ["", "def", "get_length", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "storage", ".", "__len__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.L2PenaltyLoss": [[21, 36], ["np.arange", "torch.autograd.Variable", "torch.Tensor", "torch.Tensor", "torch.add", "torch.add"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add"], ["def", "L2PenaltyLoss", "(", "predicted", ",", "target", ",", "k_val", ")", ":", "\n", "    ", "perm", "=", "np", ".", "arange", "(", "predicted", ".", "shape", "[", "0", "]", ")", "\n", "loss", "=", "Variable", "(", "torch", ".", "Tensor", "(", "[", "0", "]", ")", ",", "requires_grad", "=", "True", ")", "\n", "num", "=", "0", "\n", "for", "i", "in", "perm", ":", "\n", "        ", "Vsi", "=", "predicted", "[", "i", "]", "\n", "yi", "=", "target", "[", "i", "]", "\n", "if", "Vsi", ">=", "yi", ":", "\n", "            ", "mseloss", "=", "(", "Vsi", "-", "yi", ")", "**", "2", "\n", "#loss = torch.add(loss,mseloss)", "\n", "", "else", ":", "\n", "            ", "mseloss", "=", "k_val", "*", "(", "yi", "-", "Vsi", ")", "**", "2", "\n", "num", "+=", "1", "\n", "", "loss", "=", "torch", ".", "add", "(", "loss", ",", "mseloss", ")", "# a very big number", "\n", "", "return", "loss", "/", "predicted", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.train_upper_envelope": [[39, 201], ["int", "dict", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "models.mlp_critic.Value", "models.mlp_critic.Value", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.max", "torch.max", "highestR.view.view", "print", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "np.arange", "np.random.shuffle", "int", "print", "print", "print", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "int", "upper_envelope.cuda.state_dict", "upper_envelope.cuda.train", "print", "upper_envelope.cuda.load_state_dict", "upper_envelope_retrain.cuda.train", "int", "range", "upper_envelope.cuda.load_state_dict", "print", "np.array", "np.array", "np.array", "upper_envelope.cuda.parameters", "upper_envelope_retrain.cuda.parameters", "upper_envelope.cuda.cuda", "upper_envelope_retrain.cuda.cuda", "torch.LongTensor().cuda", "torch.LongTensor", "torch.cat.size", "highestS.size", "torch.cat.size", "highestA.size", "torch.cat.size", "highestR.view.size", "math.ceil", "range", "int", "range", "math.ceil", "np.arange", "np.random.shuffle", "range", "logger.log_tabular", "logger.dump_tabular", "upper_envelope_retrain.cuda.state_dict", "torch.cat.squeeze", "highestS.unsqueeze", "torch.cat.squeeze", "highestA.unsqueeze", "torch.cat.squeeze", "highestR.view.squeeze().unsqueeze", "np.arange", "np.random.shuffle", "range", "math.ceil", "slice", "torch.autograd.Variable", "torch.autograd.Variable", "upper_envelope.cuda.", "MC_UE.L2PenaltyLoss", "upper_envelope.cuda.state_dict", "torch.LongTensor().cuda", "torch.LongTensor", "slice", "torch.autograd.Variable", "torch.autograd.Variable", "upper_envelope_retrain.cuda.", "MC_UE.L2PenaltyLoss", "L2PenaltyLoss.detach", "upper_envelope_retrain.cuda.zero_grad", "L2PenaltyLoss.backward", "torch.optim.Adam.step", "retrain_loss.cpu().item", "torch.LongTensor", "torch.LongTensor().cuda", "torch.LongTensor", "slice", "torch.autograd.Variable", "torch.autograd.Variable", "upper_envelope.cuda.", "MC_UE.L2PenaltyLoss", "L2PenaltyLoss.detach", "upper_envelope.cuda.zero_grad", "L2PenaltyLoss.backward", "torch.optim.Adam.step", "min", "torch.autograd.Variable.float", "torch.autograd.Variable.float", "min", "torch.autograd.Variable.float", "torch.autograd.Variable.float", "highestR.view.squeeze", "min", "torch.autograd.Variable.float", "torch.autograd.Variable.float", "torch.LongTensor", "retrain_loss.cpu", "torch.LongTensor"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BC.train", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.bail_training.BC.train", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.dump_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.L2PenaltyLoss", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.L2PenaltyLoss", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.L2PenaltyLoss", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min"], ["def", "train_upper_envelope", "(", "states", ",", "actions", ",", "returns", ",", "state_dim", ",", "device", ",", "seed", ",", "\n", "upper_learning_rate", "=", "3e-3", ",", "\n", "weight_decay", "=", "0.02", ",", "\n", "max_step_num", "=", "int", "(", "1e6", ")", ",", "\n", "consecutive_steps", "=", "4", ",", "k", "=", "10000", ",", "\n", "logger", "=", "dict", "(", ")", ")", ":", "\n", "\n", "    ", "states", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "states", ")", ")", "\n", "actions", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "actions", ")", ")", "\n", "returns", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "returns", ")", ")", "# reward is actually returns", "\n", "\n", "use_gpu", "=", "True", "if", "device", "==", "\"cuda:0\"", "else", "False", "\n", "\n", "# Init upper_envelope net (*use relu as activation function", "\n", "upper_envelope", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", "\n", "upper_envelope_retrain", "=", "Value", "(", "state_dim", ",", "activation", "=", "'relu'", ")", "\n", "optimizer_upper", "=", "torch", ".", "optim", ".", "Adam", "(", "upper_envelope", ".", "parameters", "(", ")", ",", "lr", "=", "upper_learning_rate", ",", "\n", "weight_decay", "=", "weight_decay", ")", "\n", "optimizer_upper_retrain", "=", "torch", ".", "optim", ".", "Adam", "(", "upper_envelope_retrain", ".", "parameters", "(", ")", ",", "lr", "=", "upper_learning_rate", ",", "\n", "weight_decay", "=", "weight_decay", ")", "\n", "\n", "if", "use_gpu", ":", "\n", "        ", "upper_envelope", "=", "upper_envelope", ".", "cuda", "(", ")", "\n", "upper_envelope_retrain", "=", "upper_envelope_retrain", ".", "cuda", "(", ")", "\n", "\n", "\n", "# =========================== #", "\n", "# Split data into training and testing #", "\n", "# But make sure the highest Ri is in the training set", "\n", "\n", "# pick out the highest data point", "\n", "", "highestR", ",", "indice", "=", "torch", ".", "max", "(", "returns", ",", "0", ")", "\n", "highestR", "=", "highestR", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "highestS", "=", "states", "[", "indice", "]", "\n", "highestA", "=", "actions", "[", "indice", "]", "\n", "print", "(", "\"HighestR:\"", ",", "highestR", ")", "\n", "\n", "statesW", "=", "torch", ".", "cat", "(", "(", "states", "[", ":", "indice", "]", ",", "states", "[", "indice", "+", "1", ":", "]", ")", ")", "\n", "actionsW", "=", "torch", ".", "cat", "(", "(", "actions", "[", ":", "indice", "]", ",", "actions", "[", "indice", "+", "1", ":", "]", ")", ")", "\n", "returnsW", "=", "torch", ".", "cat", "(", "(", "returns", "[", ":", "indice", "]", ",", "returns", "[", "indice", "+", "1", ":", "]", ")", ")", "\n", "\n", "# shuffle the data", "\n", "perm", "=", "np", ".", "arange", "(", "statesW", ".", "shape", "[", "0", "]", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "perm", ")", "\n", "perm", "=", "LongTensor", "(", "perm", ")", ".", "cuda", "(", ")", "if", "use_gpu", "else", "LongTensor", "(", "perm", ")", "\n", "statesW", ",", "actionsW", ",", "returnsW", "=", "statesW", "[", "perm", "]", ",", "actionsW", "[", "perm", "]", ",", "returnsW", "[", "perm", "]", "\n", "\n", "# divide data into train/test", "\n", "divide", "=", "int", "(", "states", ".", "shape", "[", "0", "]", "*", "0.8", ")", "\n", "train_states", ",", "train_actions", ",", "train_returns", "=", "statesW", "[", ":", "divide", "]", ",", "actionsW", "[", ":", "divide", "]", ",", "returnsW", "[", ":", "divide", "]", "\n", "test_states", ",", "test_actions", ",", "test_returns", "=", "statesW", "[", "divide", ":", "]", ",", "actionsW", "[", "divide", ":", "]", ",", "returnsW", "[", "divide", ":", "]", "\n", "\n", "# add the highest data into training", "\n", "print", "(", "train_states", ".", "size", "(", ")", ",", "highestS", ".", "size", "(", ")", ")", "\n", "print", "(", "train_actions", ".", "size", "(", ")", ",", "highestA", ".", "size", "(", ")", ")", "\n", "print", "(", "train_returns", ".", "size", "(", ")", ",", "highestR", ".", "size", "(", ")", ")", "\n", "train_states", "=", "torch", ".", "cat", "(", "(", "train_states", ".", "squeeze", "(", ")", ",", "highestS", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "train_actions", "=", "torch", ".", "cat", "(", "(", "train_actions", ".", "squeeze", "(", ")", ",", "highestA", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "train_returns", "=", "torch", ".", "cat", "(", "(", "train_returns", ".", "squeeze", "(", ")", ",", "highestR", ".", "squeeze", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "\n", "\n", "epoch_n", "=", "100", "\n", "batch_size", "=", "64", "\n", "optim_iter_num", "=", "int", "(", "math", ".", "ceil", "(", "train_states", ".", "shape", "[", "0", "]", "/", "batch_size", ")", ")", "\n", "\n", "\n", "num_increase", "=", "0", "\n", "previous_loss", "=", "math", ".", "inf", "\n", "\n", "calculate_vali", "=", "2", "\n", "best_parameters", "=", "upper_envelope", ".", "state_dict", "(", ")", "\n", "running_traning_steps", "=", "0", "\n", "best_training_steps", "=", "running_traning_steps", "\n", "\n", "\n", "# Upper Envelope Training starts", "\n", "upper_envelope", ".", "train", "(", ")", "\n", "\n", "while", "num_increase", "<", "consecutive_steps", ":", "\n", "# update theta for n steps, n = calculate_vali", "\n", "# train calculate_vali steps", "\n", "        ", "for", "i", "in", "range", "(", "calculate_vali", ")", ":", "\n", "            ", "train_loss", "=", "0", "\n", "perm", "=", "np", ".", "arange", "(", "train_states", ".", "shape", "[", "0", "]", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "perm", ")", "\n", "perm", "=", "LongTensor", "(", "perm", ")", ".", "cuda", "(", ")", "if", "use_gpu", "else", "LongTensor", "(", "perm", ")", "\n", "\n", "train_states", ",", "train_actions", ",", "train_returns", "=", "train_states", "[", "perm", "]", ",", "train_actions", "[", "perm", "]", ",", "train_returns", "[", "perm", "]", "\n", "\n", "for", "i", "in", "range", "(", "optim_iter_num", ")", ":", "\n", "                ", "ind", "=", "slice", "(", "i", "*", "batch_size", ",", "min", "(", "(", "i", "+", "1", ")", "*", "batch_size", ",", "states", ".", "shape", "[", "0", "]", ")", ")", "\n", "states_b", ",", "returns_b", "=", "train_states", "[", "ind", "]", ",", "train_returns", "[", "ind", "]", "\n", "states_b", "=", "Variable", "(", "states_b", ".", "float", "(", ")", ")", "\n", "returns_b", "=", "Variable", "(", "returns_b", ".", "float", "(", ")", ")", "\n", "Vsi", "=", "upper_envelope", "(", "states_b", ")", "\n", "# loss = loss_fn(Vsi, returns_b)", "\n", "loss", "=", "L2PenaltyLoss", "(", "Vsi", ",", "returns_b", ",", "k_val", "=", "k", ")", "\n", "train_loss", "+=", "loss", ".", "detach", "(", ")", "\n", "upper_envelope", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer_upper", ".", "step", "(", ")", "\n", "\n", "# early stopping", "\n", "\n", "", "", "running_traning_steps", "+=", "calculate_vali", "\n", "\n", "# calculate validation error", "\n", "test_iter", "=", "int", "(", "math", ".", "ceil", "(", "test_states", ".", "shape", "[", "0", "]", "/", "batch_size", ")", ")", "\n", "validation_loss", "=", "0", "\n", "for", "n", "in", "range", "(", "test_iter", ")", ":", "\n", "            ", "ind", "=", "slice", "(", "n", "*", "batch_size", ",", "min", "(", "(", "n", "+", "1", ")", "*", "batch_size", ",", "states", ".", "shape", "[", "0", "]", ")", ")", "\n", "states_t", ",", "returns_t", "=", "test_states", "[", "ind", "]", ",", "test_returns", "[", "ind", "]", "\n", "states_t", "=", "Variable", "(", "states_t", ".", "float", "(", ")", ")", "\n", "returns_t", "=", "Variable", "(", "returns_t", ".", "float", "(", ")", ")", "\n", "Vsi", "=", "upper_envelope", "(", "states_t", ")", "\n", "loss", "=", "L2PenaltyLoss", "(", "Vsi", ",", "returns_t", ",", "k_val", "=", "k", ")", "\n", "validation_loss", "+=", "loss", "\n", "\n", "", "if", "validation_loss", "<", "previous_loss", ":", "\n", "            ", "best_training_steps", "=", "running_traning_steps", "\n", "previous_loss", "=", "validation_loss", "\n", "best_parameters", "=", "upper_envelope", ".", "state_dict", "(", ")", "\n", "num_increase", "=", "0", "\n", "", "else", ":", "\n", "            ", "num_increase", "+=", "1", "\n", "\n", "", "", "print", "(", "\"best_training_steps:\"", ",", "best_training_steps", ")", "\n", "upper_envelope", ".", "load_state_dict", "(", "best_parameters", ")", "\n", "\n", "\n", "# retrain on the whole set", "\n", "upper_envelope_retrain", ".", "train", "(", ")", "\n", "\n", "optim_iter_num", "=", "int", "(", "math", ".", "ceil", "(", "states", ".", "shape", "[", "0", "]", "/", "batch_size", ")", ")", "\n", "for", "i", "in", "range", "(", "best_training_steps", ")", ":", "\n", "        ", "retrain_loss", "=", "0", "\n", "perm", "=", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "perm", ")", "\n", "perm", "=", "LongTensor", "(", "perm", ")", ".", "cuda", "(", ")", "if", "use_gpu", "else", "LongTensor", "(", "perm", ")", "\n", "\n", "states", ",", "actions", ",", "returns", "=", "states", "[", "perm", "]", ",", "actions", "[", "perm", "]", ",", "returns", "[", "perm", "]", "\n", "\n", "for", "i", "in", "range", "(", "optim_iter_num", ")", ":", "\n", "            ", "ind", "=", "slice", "(", "i", "*", "batch_size", ",", "min", "(", "(", "i", "+", "1", ")", "*", "batch_size", ",", "states", ".", "shape", "[", "0", "]", ")", ")", "\n", "states_b", ",", "returns_b", "=", "states", "[", "ind", "]", ",", "returns", "[", "ind", "]", "\n", "states_b", "=", "Variable", "(", "states_b", ".", "float", "(", ")", ")", "\n", "returns_b", "=", "Variable", "(", "returns_b", ".", "float", "(", ")", ")", "\n", "Vsi", "=", "upper_envelope_retrain", "(", "states_b", ")", "\n", "#loss = loss_fn(Vsi, returns_b)", "\n", "loss", "=", "L2PenaltyLoss", "(", "Vsi", ",", "returns_b", ",", "k_val", "=", "k", ")", "\n", "retrain_loss", "+=", "loss", ".", "detach", "(", ")", "\n", "upper_envelope_retrain", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer_upper_retrain", ".", "step", "(", ")", "\n", "\n", "", "logger", ".", "log_tabular", "(", "'UELoss'", ",", "retrain_loss", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", "\n", "logger", ".", "dump_tabular", "(", ")", "\n", "\n", "", "upper_envelope", ".", "load_state_dict", "(", "upper_envelope_retrain", ".", "state_dict", "(", ")", ")", "\n", "print", "(", "\"Policy training is complete.\"", ")", "\n", "\n", "return", "upper_envelope", ",", "retrain_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.plot_envelope": [[204, 300], ["torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.max", "torch.max", "highestR.view.view", "print", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.sort", "torch.sort", "list", "matplotlib.scatter", "matplotlib.plot", "matplotlib.title", "matplotlib.legend", "matplotlib.savefig", "matplotlib.close", "print", "np.array", "np.array", "np.array", "np.arange", "print", "upper_envelope().detach", "print", "print", "range", "torch.stack.view", "np.arange", "list", "list", "str", "matplotlib.xlabel", "matplotlib.ylabel", "int", "upper_envelope().detach", "torch.stack.append", "torch.stack.append", "np.arange", "print", "upper_envelope().detach", "print", "print", "range", "matplotlib.xlabel", "matplotlib.ylabel", "str", "re.float", "upper_envelope", "upper_envelope().detach", "upper_envelope().detach", "torch.stack.append", "torch.stack.append", "torch.stack.view().numpy", "increasing_ue_returns.view().numpy", "upper_envelope", "highestS.float", "re.float", "upper_envelope", "upper_envelope().detach", "str", "state.float", "upper_envelope", "upper_envelope", "torch.cat", "torch.cat", "torch.stack.view", "increasing_ue_returns.view", "s.float", "torch.cat", "torch.cat", "upper_envelope", "str", "highestS.float", "highestA.float", "torch.cat", "torch.cat", "state.float", "action.float", "str", "s.float", "a.float", "buffer_setting.replace", "torch.stack.mean().item", "highestR.view.item", "list", "torch.stack.mean", "increasing_ue_returns.view().numpy", "increasing_ue_returns.view"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean"], ["def", "plot_envelope", "(", "upper_envelope", ",", "states", ",", "actions", ",", "returns", ",", "buffer_setting", ",", "seed", ",", "plot_func", "=", "'v'", ",", "hyper_default", "=", "True", ")", ":", "\n", "\n", "    ", "if", "hyper_default", ":", "\n", "        ", "upper_learning_rate", ",", "weight_decay", ",", "max_step_num", ",", "consecutive_steps", "=", "3e-3", ",", "0.02", ",", "int", "(", "1e6", ")", ",", "4", "\n", "\n", "", "states", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "states", ")", ")", "\n", "actions", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "actions", ")", ")", "\n", "returns", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "returns", ")", ")", "# MC rets", "\n", "highestR", ",", "indice", "=", "torch", ".", "max", "(", "returns", ",", "0", ")", "\n", "highestR", "=", "highestR", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "highestS", "=", "states", "[", "indice", "]", "\n", "highestA", "=", "actions", "[", "indice", "]", "\n", "\n", "print", "(", "\"Plotting results...\"", ")", "\n", "\n", "\n", "# ======================= #", "\n", "# Sanity Check ", "\n", "# ======================= #", "\n", "\n", "# a) If all or almost all of the data points (test and validation) are below your envelope V(s)", "\n", "if", "plot_func", "==", "'v'", ":", "\n", "        ", "perm", "=", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", "\n", "num_above", "=", "0", "\n", "for", "s", "in", "perm", ":", "\n", "            ", "state", "=", "states", "[", "s", "]", "\n", "action", "=", "actions", "[", "s", "]", "\n", "re", "=", "returns", "[", "s", "]", "\n", "Vs", "=", "upper_envelope", "(", "state", ".", "float", "(", ")", ")", ".", "detach", "(", ")", "\n", "if", "Vs", "<", "re", ".", "float", "(", ")", ":", "\n", "                ", "num_above", "+=", "1", "\n", "", "", "print", "(", "\"number_above:\"", ",", "num_above", ")", "\n", "\n", "# b) V(si) approx equals Ri, where Ri is highest overall return", "\n", "Vs_highest", "=", "upper_envelope", "(", "highestS", ".", "float", "(", ")", ")", ".", "detach", "(", ")", "\n", "print", "(", "\"upper envelope Ri:\"", ",", "Vs_highest", ")", "\n", "print", "(", "\"highest Ri:\"", ",", "highestR", ")", "\n", "\n", "upper_envelope_r", "=", "[", "]", "\n", "MC_r", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "s", "=", "states", "[", "i", "]", "\n", "upper_envelope_r", ".", "append", "(", "upper_envelope", "(", "s", ".", "float", "(", ")", ")", ".", "detach", "(", ")", ")", "\n", "MC_r", ".", "append", "(", "returns", "[", "i", "]", ")", "\n", "\n", "", "", "elif", "plot_func", "==", "'q'", ":", "\n", "        ", "perm", "=", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", "\n", "num_above", "=", "0", "\n", "for", "s", "in", "perm", ":", "\n", "            ", "state", "=", "states", "[", "s", "]", "\n", "action", "=", "actions", "[", "s", "]", "\n", "re", "=", "returns", "[", "s", "]", "\n", "Vs", "=", "upper_envelope", "(", "torch", ".", "cat", "(", "[", "state", ".", "float", "(", ")", ",", "action", ".", "float", "(", ")", "]", ",", "1", ")", ")", ".", "detach", "(", ")", "\n", "if", "Vs", "<", "re", ".", "float", "(", ")", ":", "\n", "                ", "num_above", "+=", "1", "\n", "", "", "print", "(", "\"number_above:\"", ",", "num_above", ")", "\n", "\n", "# b) V(si) approx equals Ri, where Ri is highest overall return", "\n", "Vs_highest", "=", "upper_envelope", "(", "torch", ".", "cat", "(", "[", "highestS", ".", "float", "(", ")", ",", "highestA", ".", "float", "(", ")", "]", ",", "1", ")", ")", ".", "detach", "(", ")", "\n", "print", "(", "\"upper envelope Ri:\"", ",", "Vs_highest", ")", "\n", "print", "(", "\"highest Ri:\"", ",", "highestR", ")", "\n", "\n", "upper_envelope_r", "=", "[", "]", "\n", "MC_r", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "s", "=", "states", "[", "i", "]", "\n", "a", "=", "actions", "[", "i", "]", "\n", "upper_envelope_r", ".", "append", "(", "upper_envelope", "(", "torch", ".", "cat", "(", "[", "s", ".", "float", "(", ")", ",", "a", ".", "float", "(", ")", "]", ",", "1", ")", ")", ".", "detach", "(", ")", ")", "\n", "MC_r", ".", "append", "(", "returns", "[", "i", "]", ")", "\n", "\n", "", "", "upper_envelope_r", "=", "torch", ".", "stack", "(", "upper_envelope_r", ")", "\n", "MC_r", "=", "torch", ".", "stack", "(", "MC_r", ")", "\n", "\n", "increasing_ue_returns", ",", "increasing_ue_indices", "=", "torch", ".", "sort", "(", "upper_envelope_r", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "MC_r", "=", "MC_r", "[", "increasing_ue_indices", "[", "0", "]", "]", "\n", "\n", "plot_s", "=", "list", "(", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", ")", "\n", "plt", ".", "scatter", "(", "plot_s", ",", "list", "(", "MC_r", ".", "view", "(", "1", ",", "-", "1", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", ",", "s", "=", "0.5", ",", "color", "=", "'orange'", ",", "label", "=", "'MC_Returns'", ")", "\n", "plt", ".", "plot", "(", "plot_s", ",", "list", "(", "increasing_ue_returns", ".", "view", "(", "1", ",", "-", "1", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", ",", "label", "=", "\"UpperEnvelope\"", ")", "\n", "title", "=", "buffer_setting", "+", "'_ues_'", "+", "str", "(", "seed", ")", "\n", "if", "plot_func", "==", "'v'", ":", "\n", "        ", "plt", ".", "xlabel", "(", "'state'", ")", "\n", "plt", ".", "ylabel", "(", "'V(s) comparison'", ")", "\n", "", "elif", "plot_func", "==", "'q'", ":", "\n", "        ", "plt", ".", "xlabel", "(", "'state, action pair'", ")", "\n", "plt", ".", "ylabel", "(", "'Q(s,a) comparison'", ")", "\n", "", "plt", ".", "title", "(", "buffer_setting", ".", "replace", "(", "'['", ",", "'\\n'", ")", "+", "'\\n__mc_avg=%.2f'", "%", "MC_r", ".", "mean", "(", ")", ".", "item", "(", ")", "+", "'_above=%s_highUE=%.2f_highMC=%.2f'", "%", "(", "num_above", ",", "list", "(", "increasing_ue_returns", ".", "view", "(", "1", ",", "-", "1", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", "[", "-", "1", "]", ",", "highestR", ".", "item", "(", ")", ")", "+", "'\\ntrainhypers:'", "+", "'_maxsteps_'", "+", "str", "(", "max_step_num", ")", "+", "'_ulr_'", "+", "str", "(", "upper_learning_rate", ")", "+", "'_wd_'", "+", "str", "(", "weight_decay", ")", "+", "'_consteps_'", "+", "str", "(", "consecutive_steps", ")", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "savefig", "(", "'./plots/'", "+", "\"%s_ue_visual_%s.png\"", "%", "(", "plot_func", ",", "title", ")", ")", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "print", "(", "'Plotting finished'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.ue.MC_UE.plot_envelope_with_clipping": [[303, 370], ["torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.max", "torch.max", "range", "torch.stack", "torch.stack", "torch.stack().float", "torch.stack().float", "torch.sort", "torch.sort", "np.arange", "range", "torch.FloatTensor", "torch.FloatTensor", "torch.where", "torch.where", "torch.where().sum().item", "torch.where().sum().item", "list", "matplotlib.scatter", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "matplotlib.savefig", "matplotlib.close", "print", "np.array", "np.array", "torch.stack.append", "torch.stack().float.append", "torch.stack.view", "Diff.append", "min", "torch.FloatTensor.append", "torch.relu().sum", "np.arange", "list", "list", "torch.FloatTensor.numpy", "int", "upper_envelope().detach", "torch.stack", "torch.stack", "torch.where().sum", "torch.where().sum", "torch.relu().sum", "Clipping_value.item", "torch.relu", "torch.stack().float.view().numpy", "increasing_ue_returns.view().numpy", "Clipping_loss.item", "upper_envelope", "torch.stack().float.view().numpy", "torch.where", "torch.where", "torch.relu", "s.float", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.stack().float.view", "increasing_ue_returns.view", "buffer_setting.replace", "torch.stack().float.view", "torch.stack().float.mean().item", "highestR.item", "list", "torch.stack().float.mean", "increasing_ue_returns.view().numpy", "increasing_ue_returns.view"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean"], ["def", "plot_envelope_with_clipping", "(", "upper_envelope", ",", "states", ",", "returns", ",", "buffer_setting", ",", "seed", ",", "hyper_default", "=", "True", ",", "\n", "k_prime", "=", "10000", ",", "S", "=", "10000", ")", ":", "\n", "\n", "    ", "if", "hyper_default", ":", "\n", "        ", "upper_learning_rate", ",", "weight_decay", ",", "max_step_num", ",", "consecutive_steps", "=", "3e-3", ",", "0.02", ",", "int", "(", "1e6", ")", ",", "4", "\n", "\n", "", "states", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "states", ")", ")", "\n", "returns", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "returns", ")", ")", "\n", "highestR", ",", "_", "=", "torch", ".", "max", "(", "returns", ",", "0", ")", "\n", "\n", "upper_envelope_r", "=", "[", "]", "\n", "MC_r", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "s", "=", "states", "[", "i", "]", "\n", "upper_envelope_r", ".", "append", "(", "upper_envelope", "(", "s", ".", "float", "(", ")", ")", ".", "detach", "(", ")", ")", "\n", "MC_r", ".", "append", "(", "returns", "[", "i", "]", ")", "\n", "\n", "", "upper_envelope_r", "=", "torch", ".", "stack", "(", "upper_envelope_r", ")", "\n", "MC_r", "=", "torch", ".", "stack", "(", "MC_r", ")", ".", "float", "(", ")", "\n", "increasing_ue_returns", ",", "increasing_ue_indices", "=", "torch", ".", "sort", "(", "upper_envelope_r", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "MC_r", "=", "MC_r", "[", "increasing_ue_indices", "[", "0", "]", "]", "\n", "\n", "# Do auto clipping", "\n", "perm", "=", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", "\n", "Diff", "=", "[", "]", "\n", "for", "idx", "in", "perm", ":", "\n", "        ", "Diff", ".", "append", "(", "increasing_ue_returns", "[", "0", ",", "idx", "]", "-", "MC_r", ".", "view", "(", "1", ",", "-", "1", ")", ".", "numpy", "(", ")", "[", "0", ",", "idx", "]", ")", "\n", "\n", "", "eval_point", "=", "states", ".", "shape", "[", "0", "]", "-", "1", "\n", "Clipping_value", "=", "increasing_ue_returns", "[", "0", ",", "eval_point", "]", "\n", "while", "eval_point", ">=", "S", ":", "\n", "        ", "min_Diff", "=", "min", "(", "Diff", "[", "eval_point", "-", "S", ":", "eval_point", "]", ")", "\n", "if", "min_Diff", "<", "0", ":", "\n", "            ", "Clipping_value", "=", "increasing_ue_returns", "[", "0", ",", "eval_point", "]", "\n", "break", "\n", "", "eval_point", "-=", "S", "\n", "\n", "", "Adapt_Clip", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "states", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "Adapt_Clip", ".", "append", "(", "Clipping_value", ")", "\n", "", "Adapt_Clip", "=", "torch", ".", "FloatTensor", "(", "Adapt_Clip", ")", "\n", "\n", "clipped_ue_r", "=", "torch", ".", "where", "(", "increasing_ue_returns", ">", "Adapt_Clip", ",", "Adapt_Clip", ",", "increasing_ue_returns", ")", "\n", "#print(increasing_ue_returns.size(), clipped_ue_r.size())", "\n", "num_above", "=", "torch", ".", "where", "(", "clipped_ue_r", "<", "MC_r", ",", "torch", ".", "FloatTensor", "(", "[", "1", "]", ")", ",", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "Clipping_loss", "=", "F", ".", "relu", "(", "clipped_ue_r", "-", "MC_r", ")", ".", "sum", "(", ")", "+", "F", ".", "relu", "(", "MC_r", "-", "clipped_ue_r", ")", ".", "sum", "(", ")", "*", "k_prime", "\n", "\n", "plot_s", "=", "list", "(", "np", ".", "arange", "(", "states", ".", "shape", "[", "0", "]", ")", ")", "\n", "plt", ".", "scatter", "(", "plot_s", ",", "list", "(", "MC_r", ".", "view", "(", "1", ",", "-", "1", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", ",", "s", "=", "0.5", ",", "color", "=", "'orange'", ",", "label", "=", "'MC_Returns'", ")", "\n", "plt", ".", "plot", "(", "plot_s", ",", "list", "(", "increasing_ue_returns", ".", "view", "(", "1", ",", "-", "1", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", ",", "color", "=", "'blue'", ",", "label", "=", "\"UpperEnvelope\"", ")", "\n", "plt", ".", "plot", "(", "plot_s", ",", "Adapt_Clip", ".", "numpy", "(", ")", ",", "color", "=", "'black'", ",", "label", "=", "\"Adaptive_Clipping_%s\"", "%", "eval_point", ")", "\n", "clip_info", "=", "'_clip_%.2f_loss_%.2fe6_ues_%s'", "%", "(", "Clipping_value", ".", "item", "(", ")", ",", "Clipping_loss", ".", "item", "(", ")", "/", "1e6", ",", "seed", ")", "\n", "title", "=", "buffer_setting", "+", "clip_info", "\n", "plt", ".", "xlabel", "(", "'state'", ")", "\n", "plt", ".", "ylabel", "(", "'V(s) comparison'", ")", "\n", "plt", ".", "title", "(", "buffer_setting", ".", "replace", "(", "'['", ",", "'\\n'", ")", "+", "'\\n__mc_avg=%.2f'", "%", "MC_r", ".", "mean", "(", ")", ".", "item", "(", ")", "+", "'_above=%s_highUE=%.2f_highMC=%.2f'", "%", "(", "num_above", ",", "list", "(", "increasing_ue_returns", ".", "view", "(", "1", ",", "-", "1", ")", ".", "numpy", "(", ")", "[", "0", "]", ")", "[", "-", "1", "]", ",", "highestR", ".", "item", "(", ")", ")", "+", "'\\nclip_info:'", "+", "clip_info", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "savefig", "(", "'./plots/'", "+", "\"v_ue_visual_%s_Clipped.png\"", "%", "title", ")", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "print", "(", "'Plotting finished'", ")", "\n", "\n", "return", "Clipping_value", ",", "Clipping_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.tools.assets_dir": [[4, 6], ["os.path.abspath", "os.path.join", "os.path.dirname", "os.path.abspath"], "function", ["None"], ["def", "assets_dir", "(", ")", ":", "\n", "    ", "return", "path", ".", "abspath", "(", "path", ".", "join", "(", "path", ".", "dirname", "(", "path", ".", "abspath", "(", "__file__", ")", ")", ",", "'../assets'", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.math.normal_entropy": [[5, 9], ["std.pow", "entropy.sum", "torch.log"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log"], ["def", "normal_entropy", "(", "std", ")", ":", "\n", "    ", "var", "=", "std", ".", "pow", "(", "2", ")", "\n", "entropy", "=", "0.5", "+", "0.5", "*", "torch", ".", "log", "(", "2", "*", "var", "*", "math", ".", "pi", ")", "\n", "return", "entropy", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.math.normal_log_density": [[11, 15], ["std.pow", "log_density.sum", "math.log"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log"], ["", "def", "normal_log_density", "(", "x", ",", "mean", ",", "log_std", ",", "std", ")", ":", "\n", "    ", "var", "=", "std", ".", "pow", "(", "2", ")", "\n", "log_density", "=", "-", "(", "x", "-", "mean", ")", ".", "pow", "(", "2", ")", "/", "(", "2", "*", "var", ")", "-", "0.5", "*", "math", ".", "log", "(", "2", "*", "math", ".", "pi", ")", "-", "log_std", "\n", "return", "log_density", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.__init__": [[13, 15], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "memory", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.push": [[16, 19], ["replay_memory.Memory.memory.append", "Transition"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "push", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "\"\"\"Saves a transition.\"\"\"", "\n", "self", ".", "memory", ".", "append", "(", "Transition", "(", "*", "args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.sample": [[20, 26], ["Transition", "random.sample", "Transition", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample"], ["", "def", "sample", "(", "self", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "if", "batch_size", "is", "None", ":", "\n", "            ", "return", "Transition", "(", "*", "zip", "(", "*", "self", ".", "memory", ")", ")", "\n", "", "else", ":", "\n", "            ", "random_batch", "=", "random", ".", "sample", "(", "self", ".", "memory", ",", "batch_size", ")", "\n", "return", "Transition", "(", "*", "zip", "(", "*", "random_batch", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append": [[27, 29], ["None"], "methods", ["None"], ["", "", "def", "append", "(", "self", ",", "new_memory", ")", ":", "\n", "        ", "self", ".", "memory", "+=", "new_memory", ".", "memory", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.__len__": [[30, 32], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "memory", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones": [[12, 14], ["torch.ones().cuda", "torch.ones", "torch.ones"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones"], ["def", "ones", "(", "*", "shape", ")", ":", "\n", "    ", "return", "torch", ".", "ones", "(", "*", "shape", ")", ".", "cuda", "(", ")", "if", "use_gpu", "else", "torch", ".", "ones", "(", "*", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros": [[16, 18], ["torch.zeros().cuda", "torch.zeros", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros"], ["", "def", "zeros", "(", "*", "shape", ")", ":", "\n", "    ", "return", "torch", ".", "zeros", "(", "*", "shape", ")", ".", "cuda", "(", ")", "if", "use_gpu", "else", "torch", ".", "zeros", "(", "*", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.get_flat_params_from": [[20, 27], ["model.parameters", "torch.cat", "params.append", "param.data.view"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "get_flat_params_from", "(", "model", ")", ":", "\n", "    ", "params", "=", "[", "]", "\n", "for", "param", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "params", ".", "append", "(", "param", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "", "flat_params", "=", "torch", ".", "cat", "(", "params", ")", "\n", "return", "flat_params", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.set_flat_params_to": [[29, 36], ["model.parameters", "int", "param.data.copy_", "numpy.prod", "flat_params[].view", "list", "param.size", "param.size"], "function", ["None"], ["", "def", "set_flat_params_to", "(", "model", ",", "flat_params", ")", ":", "\n", "    ", "prev_ind", "=", "0", "\n", "for", "param", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "flat_size", "=", "int", "(", "np", ".", "prod", "(", "list", "(", "param", ".", "size", "(", ")", ")", ")", ")", "\n", "param", ".", "data", ".", "copy_", "(", "\n", "flat_params", "[", "prev_ind", ":", "prev_ind", "+", "flat_size", "]", ".", "view", "(", "param", ".", "size", "(", ")", ")", ")", "\n", "prev_ind", "+=", "flat_size", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.get_flat_grad_from": [[38, 51], ["torch.cat", "grads.append", "param.grad.grad.view", "grads.append", "grads.append", "torch.autograd.Variable", "param.grad.view", "torch.zeros", "param.data.view"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros"], ["", "", "def", "get_flat_grad_from", "(", "inputs", ",", "grad_grad", "=", "False", ")", ":", "\n", "    ", "grads", "=", "[", "]", "\n", "for", "param", "in", "inputs", ":", "\n", "        ", "if", "grad_grad", ":", "\n", "            ", "grads", ".", "append", "(", "param", ".", "grad", ".", "grad", ".", "view", "(", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "if", "param", ".", "grad", "is", "None", ":", "\n", "                ", "grads", ".", "append", "(", "Variable", "(", "zeros", "(", "param", ".", "data", ".", "view", "(", "-", "1", ")", ".", "shape", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "grads", ".", "append", "(", "param", ".", "grad", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "", "", "", "flat_grad", "=", "torch", ".", "cat", "(", "grads", ")", "\n", "return", "flat_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.compute_flat_grad": [[53, 78], ["set", "list", "enumerate", "torch.autograd.grad", "enumerate", "torch.cat", "params.append", "out_grads.append", "out_grads.append", "torch.autograd.Variable", "grads[].view", "torch.zeros", "param.data.view"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros"], ["", "def", "compute_flat_grad", "(", "output", ",", "inputs", ",", "filter_input_ids", "=", "set", "(", ")", ",", "retain_graph", "=", "False", ",", "create_graph", "=", "False", ")", ":", "\n", "    ", "if", "create_graph", ":", "\n", "        ", "retain_graph", "=", "True", "\n", "\n", "", "inputs", "=", "list", "(", "inputs", ")", "\n", "params", "=", "[", "]", "\n", "for", "i", ",", "param", "in", "enumerate", "(", "inputs", ")", ":", "\n", "        ", "if", "i", "not", "in", "filter_input_ids", ":", "\n", "            ", "params", ".", "append", "(", "param", ")", "\n", "\n", "", "", "grads", "=", "torch", ".", "autograd", ".", "grad", "(", "output", ",", "params", ",", "retain_graph", "=", "retain_graph", ",", "create_graph", "=", "create_graph", ")", "\n", "\n", "j", "=", "0", "\n", "out_grads", "=", "[", "]", "\n", "for", "i", ",", "param", "in", "enumerate", "(", "inputs", ")", ":", "\n", "        ", "if", "i", "in", "filter_input_ids", ":", "\n", "            ", "out_grads", ".", "append", "(", "Variable", "(", "zeros", "(", "param", ".", "data", ".", "view", "(", "-", "1", ")", ".", "shape", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "out_grads", ".", "append", "(", "grads", "[", "j", "]", ".", "view", "(", "-", "1", ")", ")", "\n", "j", "+=", "1", "\n", "", "", "grads", "=", "torch", ".", "cat", "(", "out_grads", ")", "\n", "\n", "for", "param", "in", "params", ":", "\n", "        ", "param", ".", "grad", "=", "None", "\n", "", "return", "grads", "\n", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.__init__": [[8, 12], ["numpy.zeros", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros"], ["    ", "def", "__init__", "(", "self", ",", "shape", ")", ":", "\n", "        ", "self", ".", "_n", "=", "0", "\n", "self", ".", "_M", "=", "np", ".", "zeros", "(", "shape", ")", "\n", "self", ".", "_S", "=", "np", ".", "zeros", "(", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.push": [[13, 23], ["numpy.asarray", "zfilter.RunningStat._M.copy"], "methods", ["None"], ["", "def", "push", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "np", ".", "asarray", "(", "x", ")", "\n", "assert", "x", ".", "shape", "==", "self", ".", "_M", ".", "shape", "\n", "self", ".", "_n", "+=", "1", "\n", "if", "self", ".", "_n", "==", "1", ":", "\n", "            ", "self", ".", "_M", "[", "...", "]", "=", "x", "\n", "", "else", ":", "\n", "            ", "oldM", "=", "self", ".", "_M", ".", "copy", "(", ")", "\n", "self", ".", "_M", "[", "...", "]", "=", "oldM", "+", "(", "x", "-", "oldM", ")", "/", "self", ".", "_n", "\n", "self", ".", "_S", "[", "...", "]", "=", "self", ".", "_S", "+", "(", "x", "-", "oldM", ")", "*", "(", "x", "-", "self", ".", "_M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.n": [[24, 27], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "n", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.mean": [[28, 31], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_M", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.var": [[32, 35], ["numpy.square"], "methods", ["None"], ["", "@", "property", "\n", "def", "var", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_S", "/", "(", "self", ".", "_n", "-", "1", ")", "if", "self", ".", "_n", ">", "1", "else", "np", ".", "square", "(", "self", ".", "_M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.std": [[36, 39], ["numpy.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "sqrt", "(", "self", ".", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.RunningStat.shape": [[40, 43], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_M", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.ZFilter.__init__": [[51, 57], ["zfilter.RunningStat"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "shape", ",", "demean", "=", "True", ",", "destd", "=", "True", ",", "clip", "=", "10.0", ")", ":", "\n", "        ", "self", ".", "demean", "=", "demean", "\n", "self", ".", "destd", "=", "destd", "\n", "self", ".", "clip", "=", "clip", "\n", "\n", "self", ".", "rs", "=", "RunningStat", "(", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.zfilter.ZFilter.__call__": [[58, 68], ["zfilter.ZFilter.rs.push", "numpy.clip"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.push"], ["", "def", "__call__", "(", "self", ",", "x", ",", "update", "=", "True", ")", ":", "\n", "        ", "if", "update", ":", "\n", "            ", "self", ".", "rs", ".", "push", "(", "x", ")", "\n", "", "if", "self", ".", "demean", ":", "\n", "            ", "x", "=", "x", "-", "self", ".", "rs", ".", "mean", "\n", "", "if", "self", ".", "destd", ":", "\n", "            ", "x", "=", "x", "/", "(", "self", ".", "rs", ".", "std", "+", "1e-8", ")", "\n", "", "if", "self", ".", "clip", ":", "\n", "            ", "x", "=", "np", ".", "clip", "(", "x", ",", "-", "self", ".", "clip", ",", "self", ".", "clip", ")", "\n", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.MpiAdamOptimizer.__init__": [[41, 44], ["tensorflow.train.AdamOptimizer.__init__"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "comm", "=", "MPI", ".", "COMM_WORLD", "\n", "tf", ".", "train", ".", "AdamOptimizer", ".", "__init__", "(", "self", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.MpiAdamOptimizer.compute_gradients": [[45, 70], ["super().compute_gradients", "mpi_tf.flat_concat", "mpi_tf.MpiAdamOptimizer.comm.Get_size", "numpy.zeros", "tensorflow.py_func", "tensorflow.py_func.set_shape", "tensorflow.split", "v.shape.as_list", "int", "mpi_tf.MpiAdamOptimizer.comm.Allreduce", "numpy.divide", "numpy.prod", "float", "tensorflow.reshape", "zip"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.MpiAdamOptimizer.compute_gradients", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.flat_concat", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros"], ["", "def", "compute_gradients", "(", "self", ",", "loss", ",", "var_list", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Same as normal compute_gradients, except average grads over processes.\n        \"\"\"", "\n", "grads_and_vars", "=", "super", "(", ")", ".", "compute_gradients", "(", "loss", ",", "var_list", ",", "**", "kwargs", ")", "\n", "grads_and_vars", "=", "[", "(", "g", ",", "v", ")", "for", "g", ",", "v", "in", "grads_and_vars", "if", "g", "is", "not", "None", "]", "\n", "flat_grad", "=", "flat_concat", "(", "[", "g", "for", "g", ",", "v", "in", "grads_and_vars", "]", ")", "\n", "shapes", "=", "[", "v", ".", "shape", ".", "as_list", "(", ")", "for", "g", ",", "v", "in", "grads_and_vars", "]", "\n", "sizes", "=", "[", "int", "(", "np", ".", "prod", "(", "s", ")", ")", "for", "s", "in", "shapes", "]", "\n", "\n", "num_tasks", "=", "self", ".", "comm", ".", "Get_size", "(", ")", "\n", "buf", "=", "np", ".", "zeros", "(", "flat_grad", ".", "shape", ",", "np", ".", "float32", ")", "\n", "\n", "def", "_collect_grads", "(", "flat_grad", ")", ":", "\n", "            ", "self", ".", "comm", ".", "Allreduce", "(", "flat_grad", ",", "buf", ",", "op", "=", "MPI", ".", "SUM", ")", "\n", "np", ".", "divide", "(", "buf", ",", "float", "(", "num_tasks", ")", ",", "out", "=", "buf", ")", "\n", "return", "buf", "\n", "\n", "", "avg_flat_grad", "=", "tf", ".", "py_func", "(", "_collect_grads", ",", "[", "flat_grad", "]", ",", "tf", ".", "float32", ")", "\n", "avg_flat_grad", ".", "set_shape", "(", "flat_grad", ".", "shape", ")", "\n", "avg_grads", "=", "tf", ".", "split", "(", "avg_flat_grad", ",", "sizes", ",", "axis", "=", "0", ")", "\n", "avg_grads_and_vars", "=", "[", "(", "tf", ".", "reshape", "(", "g", ",", "v", ".", "shape", ")", ",", "v", ")", "\n", "for", "g", ",", "(", "_", ",", "v", ")", "in", "zip", "(", "avg_grads", ",", "grads_and_vars", ")", "]", "\n", "\n", "return", "avg_grads_and_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.MpiAdamOptimizer.apply_gradients": [[71, 79], ["super().apply_gradients", "tensorflow.group", "tensorflow.control_dependencies", "mpi_tf.sync_params"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.MpiAdamOptimizer.apply_gradients", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.sync_params"], ["", "def", "apply_gradients", "(", "self", ",", "grads_and_vars", ",", "global_step", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Same as normal apply_gradients, except sync params after update.\n        \"\"\"", "\n", "opt", "=", "super", "(", ")", ".", "apply_gradients", "(", "grads_and_vars", ",", "global_step", ",", "name", ")", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "opt", "]", ")", ":", "\n", "            ", "sync", "=", "sync_params", "(", "[", "v", "for", "g", ",", "v", "in", "grads_and_vars", "]", ")", "\n", "", "return", "tf", ".", "group", "(", "[", "opt", ",", "sync", "]", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.flat_concat": [[7, 9], ["tensorflow.concat", "tensorflow.reshape"], "function", ["None"], ["def", "flat_concat", "(", "xs", ")", ":", "\n", "    ", "return", "tf", ".", "concat", "(", "[", "tf", ".", "reshape", "(", "x", ",", "(", "-", "1", ",", ")", ")", "for", "x", "in", "xs", "]", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.assign_params_from_flat": [[10, 15], ["tensorflow.split", "tensorflow.group", "int", "tensorflow.reshape", "numpy.prod", "flat_size", "zip", "tensorflow.assign", "p.shape.as_list", "zip"], "function", ["None"], ["", "def", "assign_params_from_flat", "(", "x", ",", "params", ")", ":", "\n", "    ", "flat_size", "=", "lambda", "p", ":", "int", "(", "np", ".", "prod", "(", "p", ".", "shape", ".", "as_list", "(", ")", ")", ")", "# the 'int' is important for scalars", "\n", "splits", "=", "tf", ".", "split", "(", "x", ",", "[", "flat_size", "(", "p", ")", "for", "p", "in", "params", "]", ")", "\n", "new_params", "=", "[", "tf", ".", "reshape", "(", "p_new", ",", "p", ".", "shape", ")", "for", "p", ",", "p_new", "in", "zip", "(", "params", ",", "splits", ")", "]", "\n", "return", "tf", ".", "group", "(", "[", "tf", ".", "assign", "(", "p", ",", "p_new", ")", "for", "p", ",", "p_new", "in", "zip", "(", "params", ",", "new_params", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.sync_params": [[16, 23], ["mpi_tf.flat_concat", "tensorflow.py_func", "mpi_tf.assign_params_from_flat", "spinup.utils.mpi_tools.broadcast"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.flat_concat", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.assign_params_from_flat", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.broadcast"], ["", "def", "sync_params", "(", "params", ")", ":", "\n", "    ", "get_params", "=", "flat_concat", "(", "params", ")", "\n", "def", "_broadcast", "(", "x", ")", ":", "\n", "        ", "broadcast", "(", "x", ")", "\n", "return", "x", "\n", "", "synced_params", "=", "tf", ".", "py_func", "(", "_broadcast", ",", "[", "get_params", "]", ",", "tf", ".", "float32", ")", "\n", "return", "assign_params_from_flat", "(", "synced_params", ",", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.sync_all_params": [[24, 27], ["mpi_tf.sync_params", "tensorflow.global_variables"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tf.sync_params"], ["", "def", "sync_all_params", "(", ")", ":", "\n", "    ", "\"\"\"Sync all tf variables across MPI processes.\"\"\"", "\n", "return", "sync_params", "(", "tf", ".", "global_variables", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.__init__": [[245, 251], ["run_utils.ExperimentGrid.name"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.name"], ["def", "__init__", "(", "self", ",", "name", "=", "''", ")", ":", "\n", "        ", "self", ".", "keys", "=", "[", "]", "\n", "self", ".", "vals", "=", "[", "]", "\n", "self", ".", "shs", "=", "[", "]", "\n", "self", ".", "in_names", "=", "[", "]", "\n", "self", ".", "name", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.name": [[252, 255], ["isinstance"], "methods", ["None"], ["", "def", "name", "(", "self", ",", "_name", ")", ":", "\n", "        ", "assert", "isinstance", "(", "_name", ",", "str", ")", ",", "\"Name has to be a string.\"", "\n", "self", ".", "_name", "=", "_name", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print": [[256, 293], ["run_utils.ExperimentGrid.print"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print"], ["", "def", "print", "(", "self", ")", ":", "\n", "        ", "\"\"\"Print a helpful report about the experiment grid.\"\"\"", "\n", "print", "(", "'='", "*", "DIV_LINE_WIDTH", ")", "\n", "\n", "# Prepare announcement at top of printing. If the ExperimentGrid has a", "\n", "# short name, write this as one line. If the name is long, break the", "\n", "# announcement over two lines.", "\n", "base_msg", "=", "'ExperimentGrid %s runs over parameters:\\n'", "\n", "name_insert", "=", "'['", "+", "self", ".", "_name", "+", "']'", "\n", "if", "len", "(", "base_msg", "%", "name_insert", ")", "<=", "80", ":", "\n", "            ", "msg", "=", "base_msg", "%", "name_insert", "\n", "", "else", ":", "\n", "            ", "msg", "=", "base_msg", "%", "(", "name_insert", "+", "'\\n'", ")", "\n", "", "print", "(", "colorize", "(", "msg", ",", "color", "=", "'green'", ",", "bold", "=", "True", ")", ")", "\n", "\n", "# List off parameters, shorthands, and possible values.", "\n", "for", "k", ",", "v", ",", "sh", "in", "zip", "(", "self", ".", "keys", ",", "self", ".", "vals", ",", "self", ".", "shs", ")", ":", "\n", "            ", "color_k", "=", "colorize", "(", "k", ".", "ljust", "(", "40", ")", ",", "color", "=", "'cyan'", ",", "bold", "=", "True", ")", "\n", "print", "(", "''", ",", "color_k", ",", "'['", "+", "sh", "+", "']'", "if", "sh", "is", "not", "None", "else", "''", ",", "'\\n'", ")", "\n", "for", "i", ",", "val", "in", "enumerate", "(", "v", ")", ":", "\n", "                ", "print", "(", "'\\t'", "+", "str", "(", "convert_json", "(", "val", ")", ")", ")", "\n", "", "print", "(", ")", "\n", "\n", "# Count up the number of variants. The number counting seeds", "\n", "# is the total number of experiments that will run; the number not", "\n", "# counting seeds is the total number of otherwise-unique configs", "\n", "# being investigated.", "\n", "", "nvars_total", "=", "int", "(", "np", ".", "prod", "(", "[", "len", "(", "v", ")", "for", "v", "in", "self", ".", "vals", "]", ")", ")", "\n", "if", "'seed'", "in", "self", ".", "keys", ":", "\n", "            ", "num_seeds", "=", "len", "(", "self", ".", "vals", "[", "self", ".", "keys", ".", "index", "(", "'seed'", ")", "]", ")", "\n", "nvars_seedless", "=", "int", "(", "nvars_total", "/", "num_seeds", ")", "\n", "", "else", ":", "\n", "            ", "nvars_seedless", "=", "nvars_total", "\n", "", "print", "(", "' Variants, counting seeds: '", ".", "ljust", "(", "40", ")", ",", "nvars_total", ")", "\n", "print", "(", "' Variants, not counting seeds: '", ".", "ljust", "(", "40", ")", ",", "nvars_seedless", ")", "\n", "print", "(", ")", "\n", "print", "(", "'='", "*", "DIV_LINE_WIDTH", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid._default_shorthand": [[295, 305], ["run_utils.ExperimentGrid._default_shorthand.shear"], "methods", ["None"], ["", "def", "_default_shorthand", "(", "self", ",", "key", ")", ":", "\n", "# Create a default shorthand for the key, built from the first ", "\n", "# three letters of each colon-separated part.", "\n", "# But if the first three letters contains something which isn't", "\n", "# alphanumeric, shear that off.", "\n", "        ", "valid_chars", "=", "\"%s%s\"", "%", "(", "string", ".", "ascii_letters", ",", "string", ".", "digits", ")", "\n", "def", "shear", "(", "x", ")", ":", "\n", "            ", "return", "''", ".", "join", "(", "z", "for", "z", "in", "x", "[", ":", "3", "]", "if", "z", "in", "valid_chars", ")", "\n", "", "sh", "=", "'-'", ".", "join", "(", "[", "shear", "(", "x", ")", "for", "x", "in", "key", ".", "split", "(", "':'", ")", "]", ")", "\n", "return", "sh", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add": [[306, 338], ["isinstance", "run_utils.ExperimentGrid.keys.append", "run_utils.ExperimentGrid.vals.append", "run_utils.ExperimentGrid.shs.append", "run_utils.ExperimentGrid.in_names.append", "isinstance", "isinstance", "run_utils.ExperimentGrid._default_shorthand"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid._default_shorthand"], ["", "def", "add", "(", "self", ",", "key", ",", "vals", ",", "shorthand", "=", "None", ",", "in_name", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Add a parameter (key) to the grid config, with potential values (vals).\n\n        By default, if a shorthand isn't given, one is automatically generated\n        from the key using the first three letters of each colon-separated\n        term. To disable this behavior, change ``DEFAULT_SHORTHAND`` in the\n        ``spinup/user_config.py`` file to ``False``. \n\n        Args:\n            key (string): Name of parameter.\n\n            vals (value or list of values): Allowed values of parameter.\n\n            shorthand (string): Optional, shortened name of parameter. For \n                example, maybe the parameter ``steps_per_epoch`` is shortened\n                to ``steps``. \n\n            in_name (bool): When constructing variant names, force the\n                inclusion of this parameter into the name.\n        \"\"\"", "\n", "assert", "isinstance", "(", "key", ",", "str", ")", ",", "\"Key must be a string.\"", "\n", "assert", "shorthand", "is", "None", "or", "isinstance", "(", "shorthand", ",", "str", ")", ",", "\"Shorthand must be a string.\"", "\n", "if", "not", "isinstance", "(", "vals", ",", "list", ")", ":", "\n", "            ", "vals", "=", "[", "vals", "]", "\n", "", "if", "DEFAULT_SHORTHAND", "and", "shorthand", "is", "None", ":", "\n", "            ", "shorthand", "=", "self", ".", "_default_shorthand", "(", "key", ")", "\n", "", "self", ".", "keys", ".", "append", "(", "key", ")", "\n", "self", ".", "vals", ".", "append", "(", "vals", ")", "\n", "self", ".", "shs", ".", "append", "(", "shorthand", ")", "\n", "self", ".", "in_names", ".", "append", "(", "in_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.variant_name": [[339, 393], ["zip", "var_name.lstrip", "k.split", "run_utils.ExperimentGrid.variant_name.get_val"], "methods", ["None"], ["", "def", "variant_name", "(", "self", ",", "variant", ")", ":", "\n", "        ", "\"\"\"\n        Given a variant (dict of valid param/value pairs), make an exp_name.\n\n        A variant's name is constructed as the grid name (if you've given it \n        one), plus param names (or shorthands if available) and values \n        separated by underscores.\n\n        Note: if ``seed`` is a parameter, it is not included in the name.\n        \"\"\"", "\n", "\n", "def", "get_val", "(", "v", ",", "k", ")", ":", "\n", "# Utility method for getting the correct value out of a variant", "\n", "# given as a nested dict. Assumes that a parameter name, k, ", "\n", "# describes a path into the nested dict, such that k='a:b:c'", "\n", "# corresponds to value=variant['a']['b']['c']. Uses recursion", "\n", "# to get this.", "\n", "            ", "if", "k", "in", "v", ":", "\n", "                ", "return", "v", "[", "k", "]", "\n", "", "else", ":", "\n", "                ", "splits", "=", "k", ".", "split", "(", "':'", ")", "\n", "k0", ",", "k1", "=", "splits", "[", "0", "]", ",", "':'", ".", "join", "(", "splits", "[", "1", ":", "]", ")", "\n", "return", "get_val", "(", "v", "[", "k0", "]", ",", "k1", ")", "\n", "\n", "# Start the name off with the name of the variant generator.", "\n", "", "", "var_name", "=", "self", ".", "_name", "\n", "\n", "# Build the rest of the name by looping through all parameters,", "\n", "# and deciding which ones need to go in there.", "\n", "for", "k", ",", "v", ",", "sh", ",", "inn", "in", "zip", "(", "self", ".", "keys", ",", "self", ".", "vals", ",", "self", ".", "shs", ",", "self", ".", "in_names", ")", ":", "\n", "\n", "# Include a parameter in a name if either 1) it can take multiple", "\n", "# values, or 2) the user specified that it must appear in the name.", "\n", "# Except, however, when the parameter is 'seed'. Seed is handled", "\n", "# differently so that runs of the same experiment, with different ", "\n", "# seeds, will be grouped by experiment name.", "\n", "            ", "if", "(", "len", "(", "v", ")", ">", "1", "or", "inn", ")", "and", "not", "(", "k", "==", "'seed'", ")", ":", "\n", "\n", "# Use the shorthand if available, otherwise the full name.", "\n", "                ", "param_name", "=", "sh", "if", "sh", "is", "not", "None", "else", "k", "\n", "param_name", "=", "valid_str", "(", "param_name", ")", "\n", "\n", "# Get variant value for parameter k", "\n", "variant_val", "=", "get_val", "(", "variant", ",", "k", ")", "\n", "\n", "# Append to name", "\n", "if", "all_bools", "(", "v", ")", ":", "\n", "# If this is a param which only takes boolean values,", "\n", "# only include in the name if it's True for this variant.", "\n", "                    ", "var_name", "+=", "(", "'_'", "+", "param_name", ")", "if", "variant_val", "else", "''", "\n", "", "else", ":", "\n", "                    ", "var_name", "+=", "'_'", "+", "param_name", "+", "valid_str", "(", "variant_val", ")", "\n", "\n", "", "", "", "return", "var_name", ".", "lstrip", "(", "'_'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid._variants": [[394, 411], ["len", "run_utils.ExperimentGrid._variants", "dict", "v.update", "variants.append"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid._variants", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "_variants", "(", "self", ",", "keys", ",", "vals", ")", ":", "\n", "        ", "\"\"\"\n        Recursively builds list of valid variants.\n        \"\"\"", "\n", "if", "len", "(", "keys", ")", "==", "1", ":", "\n", "            ", "pre_variants", "=", "[", "dict", "(", ")", "]", "\n", "", "else", ":", "\n", "            ", "pre_variants", "=", "self", ".", "_variants", "(", "keys", "[", "1", ":", "]", ",", "vals", "[", "1", ":", "]", ")", "\n", "\n", "", "variants", "=", "[", "]", "\n", "for", "val", "in", "vals", "[", "0", "]", ":", "\n", "            ", "for", "pre_v", "in", "pre_variants", ":", "\n", "                ", "v", "=", "{", "}", "\n", "v", "[", "keys", "[", "0", "]", "]", "=", "val", "\n", "v", ".", "update", "(", "pre_v", ")", "\n", "variants", ".", "append", "(", "v", ")", "\n", "", "", "return", "variants", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.variants": [[412, 479], ["run_utils.ExperimentGrid._variants", "dict", "set", "var.items", "run_utils.ExperimentGrid.variants.unflatten_var"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid._variants"], ["", "def", "variants", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Makes a list of dicts, where each dict is a valid config in the grid.\n\n        There is special handling for variant parameters whose names take\n        the form\n\n            ``'full:param:name'``.\n\n        The colons are taken to indicate that these parameters should\n        have a nested dict structure. eg, if there are two params,\n\n            ====================  ===\n            Key                   Val\n            ====================  ===\n            ``'base:param:one'``  1\n            ``'base:param:two'``  2\n            ====================  ===\n\n        the variant dict will have the structure\n\n        .. parsed-literal::\n\n            variant = {\n                base: {\n                    param : {\n                        a : 1,\n                        b : 2\n                        }\n                    }    \n                }\n        \"\"\"", "\n", "flat_variants", "=", "self", ".", "_variants", "(", "self", ".", "keys", ",", "self", ".", "vals", ")", "\n", "\n", "def", "unflatten_var", "(", "var", ")", ":", "\n", "            ", "\"\"\" \n            Build the full nested dict version of var, based on key names.\n            \"\"\"", "\n", "new_var", "=", "dict", "(", ")", "\n", "unflatten_set", "=", "set", "(", ")", "\n", "\n", "for", "k", ",", "v", "in", "var", ".", "items", "(", ")", ":", "\n", "                ", "if", "':'", "in", "k", ":", "\n", "                    ", "splits", "=", "k", ".", "split", "(", "':'", ")", "\n", "k0", "=", "splits", "[", "0", "]", "\n", "assert", "k0", "not", "in", "new_var", "or", "isinstance", "(", "new_var", "[", "k0", "]", ",", "dict", ")", ",", "\"You can't assign multiple values to the same key.\"", "\n", "\n", "if", "not", "(", "k0", "in", "new_var", ")", ":", "\n", "                        ", "new_var", "[", "k0", "]", "=", "dict", "(", ")", "\n", "\n", "", "sub_k", "=", "':'", ".", "join", "(", "splits", "[", "1", ":", "]", ")", "\n", "new_var", "[", "k0", "]", "[", "sub_k", "]", "=", "v", "\n", "unflatten_set", ".", "add", "(", "k0", ")", "\n", "", "else", ":", "\n", "                    ", "assert", "not", "(", "k", "in", "new_var", ")", ",", "\"You can't assign multiple values to the same key.\"", "\n", "new_var", "[", "k", "]", "=", "v", "\n", "\n", "# Make sure to fill out the nested dicts.", "\n", "", "", "for", "k", "in", "unflatten_set", ":", "\n", "                ", "new_var", "[", "k", "]", "=", "unflatten_var", "(", "new_var", "[", "k", "]", ")", "\n", "\n", "", "return", "new_var", "\n", "\n", "", "new_variants", "=", "[", "unflatten_var", "(", "var", ")", "for", "var", "in", "flat_variants", "]", "\n", "return", "new_variants", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.run": [[480, 547], ["run_utils.ExperimentGrid.print", "run_utils.ExperimentGrid.variants", "set", "sorted", "spinup.utils.logx.colorize", "run_utils.ExperimentGrid.print"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.variants", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print"], ["", "def", "run", "(", "self", ",", "thunk", ",", "num_cpu", "=", "1", ",", "data_dir", "=", "None", ",", "datestamp", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Run each variant in the grid with function 'thunk'.\n\n        Note: 'thunk' must be either a callable function, or a string. If it is\n        a string, it must be the name of a parameter whose values are all \n        callable functions.\n\n        Uses ``call_experiment`` to actually launch each experiment, and gives\n        each variant a name using ``self.variant_name()``. \n\n        Maintenance note: the args for ExperimentGrid.run should track closely\n        to the args for call_experiment. However, ``seed`` is omitted because\n        we presume the user may add it as a parameter in the grid.\n        \"\"\"", "\n", "\n", "# Print info about self.", "\n", "self", ".", "print", "(", ")", "\n", "\n", "# Make the list of all variants.", "\n", "variants", "=", "self", ".", "variants", "(", ")", "\n", "\n", "# Print variant names for the user.", "\n", "var_names", "=", "set", "(", "[", "self", ".", "variant_name", "(", "var", ")", "for", "var", "in", "variants", "]", ")", "\n", "var_names", "=", "sorted", "(", "list", "(", "var_names", ")", ")", "\n", "line", "=", "'='", "*", "DIV_LINE_WIDTH", "\n", "preparing", "=", "colorize", "(", "'Preparing to run the following experiments...'", ",", "\n", "color", "=", "'green'", ",", "bold", "=", "True", ")", "\n", "joined_var_names", "=", "'\\n'", ".", "join", "(", "var_names", ")", "\n", "announcement", "=", "f\"\\n{preparing}\\n\\n{joined_var_names}\\n\\n{line}\"", "\n", "print", "(", "announcement", ")", "\n", "\n", "\n", "if", "WAIT_BEFORE_LAUNCH", ">", "0", ":", "\n", "            ", "delay_msg", "=", "colorize", "(", "dedent", "(", "\"\"\"\n            Launch delayed to give you a few seconds to review your experiments.\n\n            To customize or disable this behavior, change WAIT_BEFORE_LAUNCH in\n            spinup/user_config.py.\n\n            \"\"\"", ")", ",", "color", "=", "'cyan'", ",", "bold", "=", "True", ")", "+", "line", "\n", "print", "(", "delay_msg", ")", "\n", "wait", ",", "steps", "=", "WAIT_BEFORE_LAUNCH", ",", "100", "\n", "prog_bar", "=", "trange", "(", "steps", ",", "desc", "=", "'Launching in...'", ",", "\n", "leave", "=", "False", ",", "ncols", "=", "DIV_LINE_WIDTH", ",", "\n", "mininterval", "=", "0.25", ",", "\n", "bar_format", "=", "'{desc}: {bar}| {remaining} {elapsed}'", ")", "\n", "for", "_", "in", "prog_bar", ":", "\n", "                ", "time", ".", "sleep", "(", "wait", "/", "steps", ")", "\n", "\n", "# Run the variants.", "\n", "", "", "for", "var", "in", "variants", ":", "\n", "            ", "exp_name", "=", "self", ".", "variant_name", "(", "var", ")", "\n", "\n", "# Figure out what the thunk is.", "\n", "if", "isinstance", "(", "thunk", ",", "str", ")", ":", "\n", "# Assume one of the variant parameters has the same", "\n", "# name as the string you passed for thunk, and that ", "\n", "# variant[thunk] is a valid callable function.", "\n", "                ", "thunk_", "=", "var", "[", "thunk", "]", "\n", "del", "var", "[", "thunk", "]", "\n", "", "else", ":", "\n", "# Assume thunk is given as a function.", "\n", "                ", "thunk_", "=", "thunk", "\n", "\n", "", "call_experiment", "(", "exp_name", ",", "thunk_", ",", "num_cpu", "=", "num_cpu", ",", "\n", "data_dir", "=", "data_dir", ",", "datestamp", "=", "datestamp", ",", "**", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.setup_logger_kwargs": [[25, 87], ["dict", "time.strftime", "os.join", "time.strftime", "os.join", "str", "str"], "function", ["None"], ["def", "setup_logger_kwargs", "(", "exp_name", ",", "seed", "=", "None", ",", "data_dir", "=", "None", ",", "datestamp", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Sets up the output_dir for a logger and returns a dict for logger kwargs.\n\n    If no seed is given and datestamp is false, \n\n    ::\n\n        output_dir = data_dir/exp_name\n\n    If a seed is given and datestamp is false,\n\n    ::\n\n        output_dir = data_dir/exp_name/exp_name_s[seed]\n\n    If datestamp is true, amend to\n\n    ::\n\n        output_dir = data_dir/YY-MM-DD_exp_name/YY-MM-DD_HH-MM-SS_exp_name_s[seed]\n\n    You can force datestamp=True by setting ``FORCE_DATESTAMP=True`` in \n    ``spinup/user_config.py``. \n\n    Args:\n\n        exp_name (string): Name for experiment.\n\n        seed (int): Seed for random number generators used by experiment.\n\n        data_dir (string): Path to folder where results should be saved.\n            Default is the ``DEFAULT_DATA_DIR`` in ``spinup/user_config.py``.\n\n        datestamp (bool): Whether to include a date and timestamp in the\n            name of the save directory.\n\n    Returns:\n\n        logger_kwargs, a dict containing output_dir and exp_name.\n    \"\"\"", "\n", "\n", "# Datestamp forcing", "\n", "datestamp", "=", "datestamp", "or", "FORCE_DATESTAMP", "\n", "\n", "# Make base path", "\n", "ymd_time", "=", "time", ".", "strftime", "(", "\"%Y-%m-%d_\"", ")", "if", "datestamp", "else", "''", "\n", "relpath", "=", "''", ".", "join", "(", "[", "ymd_time", ",", "exp_name", "]", ")", "\n", "\n", "if", "seed", "is", "not", "None", ":", "\n", "# Make a seed-specific subfolder in the experiment directory.", "\n", "        ", "if", "datestamp", ":", "\n", "            ", "hms_time", "=", "time", ".", "strftime", "(", "\"%Y-%m-%d_%H-%M-%S\"", ")", "\n", "subfolder", "=", "''", ".", "join", "(", "[", "hms_time", ",", "'-'", ",", "exp_name", ",", "'_s'", ",", "str", "(", "seed", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "subfolder", "=", "''", ".", "join", "(", "[", "exp_name", ",", "'_s'", ",", "str", "(", "seed", ")", "]", ")", "\n", "", "relpath", "=", "osp", ".", "join", "(", "relpath", ",", "subfolder", ")", "\n", "\n", "", "data_dir", "=", "data_dir", "or", "DEFAULT_DATA_DIR", "\n", "logger_kwargs", "=", "dict", "(", "output_dir", "=", "osp", ".", "join", "(", "data_dir", ",", "relpath", ")", ",", "\n", "exp_name", "=", "exp_name", ")", "\n", "return", "logger_kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.call_experiment": [[89, 212], ["print", "print", "print", "spinup.utils.serialization_utils.convert_json", "print", "print", "cloudpickle.dumps", "base64.b64encode().decode", "os.join", "spinup.utils.logx.colorize", "spinup.utils.logx.colorize", "print", "psutil.cpu_count", "spinup.utils.logx.colorize", "spinup.utils.logx.colorize", "json.dumps", "run_utils.setup_logger_kwargs", "print", "spinup.utils.mpi_tools.mpi_fork", "thunk", "os.abspath", "subprocess.check_call", "base64.b64encode", "os.dirname", "print", "gym.make", "zlib.compress", "textwrap.dedent", "textwrap.dedent"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.setup_logger_kwargs", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_fork", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print"], ["", "def", "call_experiment", "(", "exp_name", ",", "thunk", ",", "seed", "=", "0", ",", "num_cpu", "=", "1", ",", "data_dir", "=", "None", ",", "\n", "datestamp", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Run a function (thunk) with hyperparameters (kwargs), plus configuration.\n\n    This wraps a few pieces of functionality which are useful when you want\n    to run many experiments in sequence, including logger configuration and\n    splitting into multiple processes for MPI. \n\n    There's also a SpinningUp-specific convenience added into executing the\n    thunk: if ``env_name`` is one of the kwargs passed to call_experiment, it's\n    assumed that the thunk accepts an argument called ``env_fn``, and that\n    the ``env_fn`` should make a gym environment with the given ``env_name``. \n\n    The way the experiment is actually executed is slightly complicated: the\n    function is serialized to a string, and then ``run_entrypoint.py`` is\n    executed in a subprocess call with the serialized string as an argument.\n    ``run_entrypoint.py`` unserializes the function call and executes it.\n    We choose to do it this way---instead of just calling the function \n    directly here---to avoid leaking state between successive experiments.\n\n    Args:\n\n        exp_name (string): Name for experiment.\n\n        thunk (callable): A python function.\n\n        seed (int): Seed for random number generators.\n\n        num_cpu (int): Number of MPI processes to split into. Also accepts\n            'auto', which will set up as many procs as there are cpus on\n            the machine.\n\n        data_dir (string): Used in configuring the logger, to decide where\n            to store experiment results. Note: if left as None, data_dir will\n            default to ``DEFAULT_DATA_DIR`` from ``spinup/user_config.py``. \n\n        **kwargs: All kwargs to pass to thunk.\n\n    \"\"\"", "\n", "\n", "# Determine number of CPU cores to run on", "\n", "num_cpu", "=", "psutil", ".", "cpu_count", "(", "logical", "=", "False", ")", "if", "num_cpu", "==", "'auto'", "else", "num_cpu", "\n", "\n", "# Send random seed to thunk", "\n", "kwargs", "[", "'seed'", "]", "=", "seed", "\n", "\n", "# Be friendly and print out your kwargs, so we all know what's up", "\n", "print", "(", "colorize", "(", "'Running experiment:\\n'", ",", "color", "=", "'cyan'", ",", "bold", "=", "True", ")", ")", "\n", "print", "(", "exp_name", "+", "'\\n'", ")", "\n", "print", "(", "colorize", "(", "'with kwargs:\\n'", ",", "color", "=", "'cyan'", ",", "bold", "=", "True", ")", ")", "\n", "kwargs_json", "=", "convert_json", "(", "kwargs", ")", "\n", "print", "(", "json", ".", "dumps", "(", "kwargs_json", ",", "separators", "=", "(", "','", ",", "':\\t'", ")", ",", "indent", "=", "4", ",", "sort_keys", "=", "True", ")", ")", "\n", "print", "(", "'\\n'", ")", "\n", "\n", "# Set up logger output directory", "\n", "if", "'logger_kwargs'", "not", "in", "kwargs", ":", "\n", "        ", "kwargs", "[", "'logger_kwargs'", "]", "=", "setup_logger_kwargs", "(", "exp_name", ",", "seed", ",", "data_dir", ",", "datestamp", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "'Note: Call experiment is not handling logger_kwargs.\\n'", ")", "\n", "\n", "", "def", "thunk_plus", "(", ")", ":", "\n", "# Make 'env_fn' from 'env_name'", "\n", "        ", "if", "'env_name'", "in", "kwargs", ":", "\n", "            ", "import", "gym", "\n", "env_name", "=", "kwargs", "[", "'env_name'", "]", "\n", "kwargs", "[", "'env_fn'", "]", "=", "lambda", ":", "gym", ".", "make", "(", "env_name", ")", "\n", "del", "kwargs", "[", "'env_name'", "]", "\n", "\n", "# Fork into multiple processes", "\n", "", "mpi_fork", "(", "num_cpu", ")", "\n", "\n", "# Run thunk", "\n", "thunk", "(", "**", "kwargs", ")", "\n", "\n", "# Prepare to launch a script to run the experiment", "\n", "", "pickled_thunk", "=", "cloudpickle", ".", "dumps", "(", "thunk_plus", ")", "\n", "encoded_thunk", "=", "base64", ".", "b64encode", "(", "zlib", ".", "compress", "(", "pickled_thunk", ")", ")", ".", "decode", "(", "'utf-8'", ")", "\n", "\n", "entrypoint", "=", "osp", ".", "join", "(", "osp", ".", "abspath", "(", "osp", ".", "dirname", "(", "__file__", ")", ")", ",", "'run_entrypoint.py'", ")", "\n", "cmd", "=", "[", "sys", ".", "executable", "if", "sys", ".", "executable", "else", "'python'", ",", "entrypoint", ",", "encoded_thunk", "]", "\n", "try", ":", "\n", "        ", "subprocess", ".", "check_call", "(", "cmd", ",", "env", "=", "os", ".", "environ", ")", "\n", "", "except", "CalledProcessError", ":", "\n", "        ", "err_msg", "=", "'\\n'", "*", "3", "+", "'='", "*", "DIV_LINE_WIDTH", "+", "'\\n'", "+", "dedent", "(", "\"\"\"\n\n            There appears to have been an error in your experiment.\n\n            Check the traceback above to see what actually went wrong. The \n            traceback below, included for completeness (but probably not useful\n            for diagnosing the error), shows the stack leading up to the \n            experiment launch.\n\n            \"\"\"", ")", "+", "'='", "*", "DIV_LINE_WIDTH", "+", "'\\n'", "*", "3", "\n", "print", "(", "err_msg", ")", "\n", "raise", "\n", "\n", "# Tell the user about where results are, and how to check them", "\n", "", "logger_kwargs", "=", "kwargs", "[", "'logger_kwargs'", "]", "\n", "\n", "plot_cmd", "=", "'python -m spinup.run plot '", "+", "logger_kwargs", "[", "'output_dir'", "]", "\n", "plot_cmd", "=", "colorize", "(", "plot_cmd", ",", "'green'", ")", "\n", "\n", "test_cmd", "=", "'python -m spinup.run test_policy '", "+", "logger_kwargs", "[", "'output_dir'", "]", "\n", "test_cmd", "=", "colorize", "(", "test_cmd", ",", "'green'", ")", "\n", "\n", "output_msg", "=", "'\\n'", "*", "5", "+", "'='", "*", "DIV_LINE_WIDTH", "+", "'\\n'", "+", "dedent", "(", "\"\"\"\\\n    End of experiment.\n\n\n    Plot results from this run with:\n\n    %s\n\n\n    Watch the trained agent with:\n\n    %s\n\n\n    \"\"\"", "%", "(", "plot_cmd", ",", "test_cmd", ")", ")", "+", "'='", "*", "DIV_LINE_WIDTH", "+", "'\\n'", "*", "5", "\n", "\n", "print", "(", "output_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.all_bools": [[214, 216], ["all", "isinstance"], "function", ["None"], ["", "def", "all_bools", "(", "vals", ")", ":", "\n", "    ", "return", "all", "(", "[", "isinstance", "(", "v", ",", "bool", ")", "for", "v", "in", "vals", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.valid_str": [[217, 238], ["hasattr", "str().lower", "run_utils.valid_str", "isinstance", "isinstance", "str", "run_utils.valid_str"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.valid_str", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.valid_str"], ["", "def", "valid_str", "(", "v", ")", ":", "\n", "    ", "\"\"\" \n    Convert a value or values to a string which could go in a filepath.\n\n    Partly based on `this gist`_.\n\n    .. _`this gist`: https://gist.github.com/seanh/93666\n\n    \"\"\"", "\n", "if", "hasattr", "(", "v", ",", "'__name__'", ")", ":", "\n", "        ", "return", "valid_str", "(", "v", ".", "__name__", ")", "\n", "\n", "", "if", "isinstance", "(", "v", ",", "tuple", ")", "or", "isinstance", "(", "v", ",", "list", ")", ":", "\n", "        ", "return", "'-'", ".", "join", "(", "[", "valid_str", "(", "x", ")", "for", "x", "in", "v", "]", ")", "\n", "\n", "# Valid characters are '-', '_', and alphanumeric. Replace invalid chars", "\n", "# with '-'. ", "\n", "", "str_v", "=", "str", "(", "v", ")", ".", "lower", "(", ")", "\n", "valid_chars", "=", "\"-_%s%s\"", "%", "(", "string", ".", "ascii_letters", ",", "string", ".", "digits", ")", "\n", "str_v", "=", "''", ".", "join", "(", "c", "if", "c", "in", "valid_chars", "else", "'-'", "for", "c", "in", "str_v", ")", "\n", "return", "str_v", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.test_eg": [[549, 558], ["run_utils.ExperimentGrid", "run_utils.ExperimentGrid.add", "run_utils.ExperimentGrid.add", "run_utils.ExperimentGrid.add", "run_utils.ExperimentGrid.add", "run_utils.ExperimentGrid.add", "run_utils.ExperimentGrid.add", "run_utils.ExperimentGrid.variants"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.add", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.variants"], ["", "", "", "def", "test_eg", "(", ")", ":", "\n", "    ", "eg", "=", "ExperimentGrid", "(", ")", "\n", "eg", ".", "add", "(", "'test:a'", ",", "[", "1", ",", "2", ",", "3", "]", ",", "'ta'", ",", "True", ")", "\n", "eg", ".", "add", "(", "'test:b'", ",", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "eg", ".", "add", "(", "'some'", ",", "[", "4", ",", "5", "]", ")", "\n", "eg", ".", "add", "(", "'why'", ",", "[", "True", ",", "False", "]", ")", "\n", "eg", ".", "add", "(", "'huh'", ",", "5", ")", "\n", "eg", ".", "add", "(", "'no'", ",", "6", ",", "in_name", "=", "True", ")", "\n", "return", "eg", ".", "variants", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_fork": [[6, 37], ["os.getenv", "os.environ.copy", "os.environ.copy.update", "subprocess.check_call", "sys.exit", "str"], "function", ["None"], ["def", "mpi_fork", "(", "n", ",", "bind_to_core", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Re-launches the current script with workers linked by MPI.\n\n    Also, terminates the original process that launched it.\n\n    Taken almost without modification from the Baselines function of the\n    `same name`_.\n\n    .. _`same name`: https://github.com/openai/baselines/blob/master/baselines/common/mpi_fork.py\n\n    Args:\n        n (int): Number of process to split into.\n\n        bind_to_core (bool): Bind each MPI process to a core.\n    \"\"\"", "\n", "if", "n", "<=", "1", ":", "\n", "        ", "return", "\n", "", "if", "os", ".", "getenv", "(", "\"IN_MPI\"", ")", "is", "None", ":", "\n", "        ", "env", "=", "os", ".", "environ", ".", "copy", "(", ")", "\n", "env", ".", "update", "(", "\n", "MKL_NUM_THREADS", "=", "\"1\"", ",", "\n", "OMP_NUM_THREADS", "=", "\"1\"", ",", "\n", "IN_MPI", "=", "\"1\"", "\n", ")", "\n", "args", "=", "[", "\"mpirun\"", ",", "\"-np\"", ",", "str", "(", "n", ")", "]", "\n", "if", "bind_to_core", ":", "\n", "            ", "args", "+=", "[", "\"-bind-to\"", ",", "\"core\"", "]", "\n", "", "args", "+=", "[", "sys", ".", "executable", "]", "+", "sys", ".", "argv", "\n", "subprocess", ".", "check_call", "(", "args", ",", "env", "=", "env", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.msg": [[39, 41], ["print", "str", "mpi4py.MPI.COMM_WORLD.Get_rank"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print"], ["", "", "def", "msg", "(", "m", ",", "string", "=", "''", ")", ":", "\n", "    ", "print", "(", "(", "'Message from %d: %s \\t '", "%", "(", "MPI", ".", "COMM_WORLD", ".", "Get_rank", "(", ")", ",", "string", ")", ")", "+", "str", "(", "m", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.proc_id": [[42, 45], ["mpi4py.MPI.COMM_WORLD.Get_rank"], "function", ["None"], ["", "def", "proc_id", "(", ")", ":", "\n", "    ", "\"\"\"Get rank of calling process.\"\"\"", "\n", "return", "MPI", ".", "COMM_WORLD", ".", "Get_rank", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.allreduce": [[46, 48], ["mpi4py.MPI.COMM_WORLD.Allreduce"], "function", ["None"], ["", "def", "allreduce", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "MPI", ".", "COMM_WORLD", ".", "Allreduce", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.num_procs": [[49, 52], ["mpi4py.MPI.COMM_WORLD.Get_size"], "function", ["None"], ["", "def", "num_procs", "(", ")", ":", "\n", "    ", "\"\"\"Count active MPI processes.\"\"\"", "\n", "return", "MPI", ".", "COMM_WORLD", ".", "Get_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.broadcast": [[53, 55], ["mpi4py.MPI.COMM_WORLD.Bcast"], "function", ["None"], ["", "def", "broadcast", "(", "x", ",", "root", "=", "0", ")", ":", "\n", "    ", "MPI", ".", "COMM_WORLD", ".", "Bcast", "(", "x", ",", "root", "=", "root", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_op": [[56, 62], ["numpy.asarray", "numpy.zeros_like", "mpi_tools.allreduce", "numpy.isscalar", "mpi4py.MPI.SUM"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.allreduce"], ["", "def", "mpi_op", "(", "x", ",", "op", ")", ":", "\n", "    ", "x", ",", "scalar", "=", "(", "[", "x", "]", ",", "True", ")", "if", "np", ".", "isscalar", "(", "x", ")", "else", "(", "x", ",", "False", ")", "\n", "x", "=", "np", ".", "asarray", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "buff", "=", "np", ".", "zeros_like", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "allreduce", "(", "x", ",", "buff", ",", "op", "=", "op", ")", "\n", "return", "buff", "[", "0", "]", "if", "scalar", "else", "buff", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_sum": [[63, 65], ["mpi_tools.mpi_op"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_op"], ["", "def", "mpi_sum", "(", "x", ")", ":", "\n", "    ", "return", "mpi_op", "(", "x", ",", "MPI", ".", "SUM", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_avg": [[66, 69], ["mpi_tools.mpi_sum", "mpi_tools.num_procs"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.num_procs"], ["", "def", "mpi_avg", "(", "x", ")", ":", "\n", "    ", "\"\"\"Average a scalar or vector over MPI processes.\"\"\"", "\n", "return", "mpi_sum", "(", "x", ")", "/", "num_procs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_statistics_scalar": [[70, 93], ["numpy.array", "mpi_tools.mpi_sum", "mpi_tools.mpi_sum", "numpy.sqrt", "numpy.sum", "mpi_tools.mpi_op", "mpi_tools.mpi_op", "numpy.sum", "len", "numpy.min", "numpy.max", "len", "len"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_op", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_op", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min"], ["", "def", "mpi_statistics_scalar", "(", "x", ",", "with_min_and_max", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Get mean/std and optional min/max of scalar x across MPI processes.\n\n    Args:\n        x: An array containing samples of the scalar to produce statistics\n            for.\n\n        with_min_and_max (bool): If true, return min and max of x in \n            addition to mean and std.\n    \"\"\"", "\n", "x", "=", "np", ".", "array", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "global_sum", ",", "global_n", "=", "mpi_sum", "(", "[", "np", ".", "sum", "(", "x", ")", ",", "len", "(", "x", ")", "]", ")", "\n", "mean", "=", "global_sum", "/", "global_n", "\n", "\n", "global_sum_sq", "=", "mpi_sum", "(", "np", ".", "sum", "(", "(", "x", "-", "mean", ")", "**", "2", ")", ")", "\n", "std", "=", "np", ".", "sqrt", "(", "global_sum_sq", "/", "global_n", ")", "# compute global std", "\n", "\n", "if", "with_min_and_max", ":", "\n", "        ", "global_min", "=", "mpi_op", "(", "np", ".", "min", "(", "x", ")", "if", "len", "(", "x", ")", ">", "0", "else", "np", ".", "inf", ",", "op", "=", "MPI", ".", "MIN", ")", "\n", "global_max", "=", "mpi_op", "(", "np", ".", "max", "(", "x", ")", "if", "len", "(", "x", ")", ">", "0", "else", "-", "np", ".", "inf", ",", "op", "=", "MPI", ".", "MAX", ")", "\n", "return", "mean", ",", "std", ",", "global_min", ",", "global_max", "\n", "", "return", "mean", ",", "std", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.plot_data": [[15, 67], ["isinstance", "seaborn.set", "print", "seaborn.tsplot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.tight_layout", "numpy.ones", "pandas.concat", "matplotlib.legend().draggable", "numpy.max", "matplotlib.ticklabel_format", "numpy.asarray", "numpy.ones", "numpy.asarray", "len", "numpy.convolve", "numpy.convolve", "matplotlib.legend"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones"], ["def", "plot_data", "(", "data", ",", "xaxis", "=", "'Epoch'", ",", "value", "=", "\"AverageEpRet\"", ",", "condition", "=", "\"Condition1\"", ",", "smooth", "=", "1", ",", "no_legend", "=", "False", ",", "legend_loc", "=", "'best'", ",", "color", "=", "None", ",", "font_scale", "=", "1.5", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "smooth", ">", "1", ":", "\n", "        ", "\"\"\"\n        smooth data with moving window average.\n        that is,\n            smoothed_y[t] = average(y[t-k], y[t-k+1], ..., y[t+k-1], y[t+k])\n        where the \"smooth\" param is width of that window (2k+1)\n        \"\"\"", "\n", "y", "=", "np", ".", "ones", "(", "smooth", ")", "\n", "for", "datum", "in", "data", ":", "\n", "            ", "x", "=", "np", ".", "asarray", "(", "datum", "[", "value", "]", ")", "\n", "z", "=", "np", ".", "ones", "(", "len", "(", "x", ")", ")", "\n", "smoothed_x", "=", "np", ".", "convolve", "(", "x", ",", "y", ",", "'same'", ")", "/", "np", ".", "convolve", "(", "z", ",", "y", ",", "'same'", ")", "\n", "datum", "[", "value", "]", "=", "smoothed_x", "\n", "\n", "", "", "if", "isinstance", "(", "data", ",", "list", ")", ":", "\n", "        ", "data", "=", "pd", ".", "concat", "(", "data", ",", "ignore_index", "=", "True", ")", "\n", "", "sns", ".", "set", "(", "style", "=", "\"darkgrid\"", ",", "font_scale", "=", "font_scale", ")", "\n", "# sns.set_palette('bright')", "\n", "\n", "print", "(", "\"##############\"", ")", "\n", "\n", "## TODO CHANGE BACK", "\n", "sns", ".", "tsplot", "(", "data", "=", "data", ",", "time", "=", "xaxis", ",", "value", "=", "value", ",", "unit", "=", "\"Unit\"", ",", "condition", "=", "condition", ",", "legend", "=", "(", "not", "no_legend", ")", ",", "ci", "=", "'sd'", ",", "n_boot", "=", "0", ",", "color", "=", "color", ",", "**", "kwargs", ")", "\n", "plt", ".", "xlabel", "(", "'environment interactions'", ")", "\n", "plt", ".", "ylabel", "(", "'average test return'", ")", "\n", "\n", "\"\"\"\n    If you upgrade to any version of Seaborn greater than 0.8.1, switch from \n    tsplot to lineplot replacing L29 with:\n\n        sns.lineplot(data=data, x=xaxis, y=value, hue=condition, ci='sd', **kwargs)\n\n    Changes the colorscheme and the default legend style, though.\n    \"\"\"", "\n", "if", "not", "no_legend", ":", "\n", "        ", "plt", ".", "legend", "(", "loc", "=", "legend_loc", ")", ".", "draggable", "(", ")", "\n", "\n", "", "\"\"\"\n    For the version of the legend used in the Spinning Up benchmarking page, \n    swap L38 with:\n\n    plt.legend(loc='upper center', ncol=6, handlelength=1,\n               mode=\"expand\", borderaxespad=0., prop={'size': 13})\n    \"\"\"", "\n", "\n", "xscale", "=", "np", ".", "max", "(", "np", ".", "asarray", "(", "data", "[", "xaxis", "]", ")", ")", ">", "5e3", "\n", "if", "xscale", ":", "\n", "# Just some formatting niceness: x-axis scale in scientific notation if max x is large", "\n", "        ", "plt", ".", "ticklabel_format", "(", "style", "=", "'sci'", ",", "axis", "=", "'x'", ",", "scilimits", "=", "(", "0", ",", "0", ")", ")", "\n", "\n", "", "plt", ".", "tight_layout", "(", "pad", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.get_datasets": [[68, 104], ["os.walk", "os.walk", "pandas.read_table", "pd.read_table.insert", "pd.read_table.insert", "pd.read_table.insert", "pd.read_table.insert", "datasets.append", "open", "json.load", "str", "os.path.join", "os.path.join", "len", "len", "len", "len", "os.path.join", "os.path.join", "print"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print"], ["", "def", "get_datasets", "(", "logdir", ",", "condition", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Recursively look through logdir for output files produced by\n    spinup.logx.Logger. \n\n    Assumes that any file \"progress.txt\" is a valid hit. \n    \"\"\"", "\n", "global", "exp_idx", "\n", "global", "units", "\n", "datasets", "=", "[", "]", "\n", "for", "root", ",", "_", ",", "files", "in", "os", ".", "walk", "(", "logdir", ")", ":", "\n", "        ", "if", "'progress.txt'", "in", "files", ":", "\n", "            ", "exp_name", "=", "None", "\n", "try", ":", "\n", "                ", "config_path", "=", "open", "(", "os", ".", "path", ".", "join", "(", "root", ",", "'config.json'", ")", ")", "\n", "config", "=", "json", ".", "load", "(", "config_path", ")", "\n", "if", "'exp_name'", "in", "config", ":", "\n", "                    ", "exp_name", "=", "config", "[", "'exp_name'", "]", "\n", "", "", "except", ":", "\n", "                ", "print", "(", "'No file named config.json'", ")", "\n", "", "condition1", "=", "condition", "or", "exp_name", "or", "'exp'", "\n", "condition2", "=", "condition1", "+", "'-'", "+", "str", "(", "exp_idx", ")", "\n", "exp_idx", "+=", "1", "\n", "if", "condition1", "not", "in", "units", ":", "\n", "                ", "units", "[", "condition1", "]", "=", "0", "\n", "", "unit", "=", "units", "[", "condition1", "]", "\n", "units", "[", "condition1", "]", "+=", "1", "\n", "\n", "exp_data", "=", "pd", ".", "read_table", "(", "os", ".", "path", ".", "join", "(", "root", ",", "'progress.txt'", ")", ")", "\n", "performance", "=", "'AverageTestEpRet'", "if", "'AverageTestEpRet'", "in", "exp_data", "else", "'AverageEpRet'", "\n", "exp_data", ".", "insert", "(", "len", "(", "exp_data", ".", "columns", ")", ",", "'Unit'", ",", "unit", ")", "\n", "exp_data", ".", "insert", "(", "len", "(", "exp_data", ".", "columns", ")", ",", "'Condition1'", ",", "condition1", ")", "\n", "exp_data", ".", "insert", "(", "len", "(", "exp_data", ".", "columns", ")", ",", "'Condition2'", ",", "condition2", ")", "\n", "exp_data", ".", "insert", "(", "len", "(", "exp_data", ".", "columns", ")", ",", "'Performance'", ",", "exp_data", "[", "performance", "]", ")", "\n", "datasets", ".", "append", "(", "exp_data", ")", "\n", "", "", "return", "datasets", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.get_all_datasets": [[106, 155], ["print", "print", "print", "zip", "os.isdir", "os.dirname", "os.listdir", "os.listdir", "sorted", "len", "len", "plot.get_datasets", "plot.get_datasets", "os.join", "logdir.split", "all", "all", "fulldir"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.get_datasets", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.get_datasets"], ["", "def", "get_all_datasets", "(", "all_logdirs", ",", "legend", "=", "None", ",", "select", "=", "None", ",", "exclude", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    For every entry in all_logdirs,\n        1) check if the entry is a real directory and if it is, \n           pull data from it; \n\n        2) if not, check to see if the entry is a prefix for a \n           real directory, and pull data from that.\n    \"\"\"", "\n", "logdirs", "=", "[", "]", "\n", "for", "logdir", "in", "all_logdirs", ":", "\n", "        ", "if", "osp", ".", "isdir", "(", "logdir", ")", "and", "logdir", "[", "-", "1", "]", "==", "'/'", ":", "\n", "            ", "logdirs", "+=", "[", "logdir", "]", "\n", "", "else", ":", "\n", "            ", "basedir", "=", "osp", ".", "dirname", "(", "logdir", ")", "\n", "fulldir", "=", "lambda", "x", ":", "osp", ".", "join", "(", "basedir", ",", "x", ")", "\n", "prefix", "=", "logdir", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "listdir", "=", "os", ".", "listdir", "(", "basedir", ")", "\n", "logdirs", "+=", "sorted", "(", "[", "fulldir", "(", "x", ")", "for", "x", "in", "listdir", "if", "prefix", "in", "x", "]", ")", "\n", "\n", "", "", "\"\"\"\n    Enforce selection rules, which check logdirs for certain substrings.\n    Makes it easier to look at graphs from particular ablations, if you\n    launch many jobs at once with similar names.\n    \"\"\"", "\n", "if", "select", "is", "not", "None", ":", "\n", "        ", "logdirs", "=", "[", "log", "for", "log", "in", "logdirs", "if", "all", "(", "x", "in", "log", "for", "x", "in", "select", ")", "]", "\n", "", "if", "exclude", "is", "not", "None", ":", "\n", "        ", "logdirs", "=", "[", "log", "for", "log", "in", "logdirs", "if", "all", "(", "not", "(", "x", "in", "log", ")", "for", "x", "in", "exclude", ")", "]", "\n", "\n", "# Verify logdirs", "\n", "", "print", "(", "'Plotting from...\\n'", "+", "'='", "*", "DIV_LINE_WIDTH", "+", "'\\n'", ")", "\n", "for", "logdir", "in", "logdirs", ":", "\n", "        ", "print", "(", "logdir", ")", "\n", "", "print", "(", "'\\n'", "+", "'='", "*", "DIV_LINE_WIDTH", ")", "\n", "\n", "# Make sure the legend is compatible with the logdirs", "\n", "assert", "not", "(", "legend", ")", "or", "(", "len", "(", "legend", ")", "==", "len", "(", "logdirs", ")", ")", ",", "\"Must give a legend title for each set of experiments.\"", "\n", "\n", "# Load data from logdirs", "\n", "data", "=", "[", "]", "\n", "if", "legend", ":", "\n", "        ", "for", "log", ",", "leg", "in", "zip", "(", "logdirs", ",", "legend", ")", ":", "\n", "            ", "data", "+=", "get_datasets", "(", "log", ",", "leg", ")", "\n", "", "", "else", ":", "\n", "        ", "for", "log", "in", "logdirs", ":", "\n", "            ", "data", "+=", "get_datasets", "(", "log", ")", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.make_plots": [[157, 177], ["plot.get_all_datasets", "getattr", "isinstance", "matplotlib.figure", "plot.plot_data", "matplotlib.gcf", "plt.gcf.savefig", "matplotlib.show", "matplotlib.xlim"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.get_all_datasets", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.plot_data"], ["", "def", "make_plots", "(", "all_logdirs", ",", "legend", "=", "None", ",", "xaxis", "=", "None", ",", "values", "=", "None", ",", "count", "=", "False", ",", "\n", "font_scale", "=", "1.5", ",", "smooth", "=", "1", ",", "select", "=", "None", ",", "exclude", "=", "None", ",", "estimator", "=", "'mean'", ",", "no_legend", "=", "False", ",", "legend_loc", "=", "'best'", ",", "\n", "save_name", "=", "None", ",", "xlimit", "=", "-", "1", ",", "color", "=", "None", ")", ":", "\n", "    ", "data", "=", "get_all_datasets", "(", "all_logdirs", ",", "legend", ",", "select", ",", "exclude", ")", "\n", "values", "=", "values", "if", "isinstance", "(", "values", ",", "list", ")", "else", "[", "values", "]", "\n", "condition", "=", "'Condition2'", "if", "count", "else", "'Condition1'", "\n", "estimator", "=", "getattr", "(", "np", ",", "estimator", ")", "# choose what to show on main curve: mean? max? min?", "\n", "for", "value", "in", "values", ":", "\n", "        ", "plt", ".", "figure", "(", ")", "\n", "# plt.figure(figsize=(10, 7))", "\n", "plot_data", "(", "data", ",", "xaxis", "=", "xaxis", ",", "value", "=", "value", ",", "condition", "=", "condition", ",", "smooth", "=", "smooth", ",", "no_legend", "=", "no_legend", ",", "legend_loc", "=", "legend_loc", ",", "\n", "estimator", "=", "estimator", ",", "color", "=", "color", ",", "font_scale", "=", "font_scale", ")", "\n", "if", "xlimit", ">", "0", ":", "\n", "            ", "plt", ".", "xlim", "(", "0", ",", "xlimit", ")", "\n", "\n", "", "", "if", "save_name", "is", "not", "None", ":", "\n", "        ", "fig", "=", "plt", ".", "gcf", "(", ")", "\n", "fig", ".", "savefig", "(", "save_name", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.main": [[178, 253], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "plot.make_plots"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.plot.make_plots"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "import", "argparse", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'logdir'", ",", "nargs", "=", "'*'", ")", "\n", "parser", ".", "add_argument", "(", "'--legend'", ",", "'-l'", ",", "nargs", "=", "'*'", ")", "\n", "parser", ".", "add_argument", "(", "'--xaxis'", ",", "'-x'", ",", "default", "=", "'TotalEnvInteracts'", ")", "\n", "parser", ".", "add_argument", "(", "'--value'", ",", "'-y'", ",", "default", "=", "'Performance'", ",", "nargs", "=", "'*'", ")", "\n", "parser", ".", "add_argument", "(", "'--count'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--smooth'", ",", "'-s'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "'--select'", ",", "nargs", "=", "'*'", ")", "\n", "parser", ".", "add_argument", "(", "'--exclude'", ",", "nargs", "=", "'*'", ")", "\n", "parser", ".", "add_argument", "(", "'--est'", ",", "default", "=", "'mean'", ")", "\n", "parser", ".", "add_argument", "(", "'--no-legend'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--legend-loc'", ",", "type", "=", "str", ",", "default", "=", "'best'", ")", "\n", "parser", ".", "add_argument", "(", "'--save-name'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--xlimit'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ")", "\n", "parser", ".", "add_argument", "(", "'--color'", ",", "'-color'", ",", "nargs", "=", "'*'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\"\"\"\n\n    Args: \n        logdir (strings): As many log directories (or prefixes to log \n            directories, which the plotter will autocomplete internally) as \n            you'd like to plot from.\n\n        legend (strings): Optional way to specify legend for the plot. The \n            plotter legend will automatically use the ``exp_name`` from the\n            config.json file, unless you tell it otherwise through this flag.\n            This only works if you provide a name for each directory that\n            will get plotted. (Note: this may not be the same as the number\n            of logdir args you provide! Recall that the plotter looks for\n            autocompletes of the logdir args: there may be more than one \n            match for a given logdir prefix, and you will need to provide a \n            legend string for each one of those matches---unless you have \n            removed some of them as candidates via selection or exclusion \n            rules (below).)\n\n        xaxis (string): Pick what column from data is used for the x-axis.\n             Defaults to ``TotalEnvInteracts``.\n\n        value (strings): Pick what columns from data to graph on the y-axis. \n            Submitting multiple values will produce multiple graphs. Defaults\n            to ``Performance``, which is not an actual output of any algorithm.\n            Instead, ``Performance`` refers to either ``AverageEpRet``, the \n            correct performance measure for the on-policy algorithms, or\n            ``AverageTestEpRet``, the correct performance measure for the \n            off-policy algorithms. The plotter will automatically figure out \n            which of ``AverageEpRet`` or ``AverageTestEpRet`` to report for \n            each separate logdir.\n\n        count: Optional flag. By default, the plotter shows y-values which\n            are averaged across all results that share an ``exp_name``, \n            which is typically a set of identical experiments that only vary\n            in random seed. But if you'd like to see all of those curves \n            separately, use the ``--count`` flag.\n\n        smooth (int): Smooth data by averaging it over a fixed window. This \n            parameter says how wide the averaging window will be.\n\n        select (strings): Optional selection rule: the plotter will only show\n            curves from logdirs that contain all of these substrings.\n\n        exclude (strings): Optional exclusion rule: plotter will only show \n            curves from logdirs that do not contain these substrings.\n            \n        no-legend: if specified then no legend will be shown\n        \n\n    \"\"\"", "\n", "\n", "make_plots", "(", "args", ".", "logdir", ",", "args", ".", "legend", ",", "args", ".", "xaxis", ",", "args", ".", "value", ",", "args", ".", "count", ",", "\n", "smooth", "=", "args", ".", "smooth", ",", "select", "=", "args", ".", "select", ",", "exclude", "=", "args", ".", "exclude", ",", "\n", "estimator", "=", "args", ".", "est", ",", "no_legend", "=", "args", ".", "no_legend", ",", "legend_loc", "=", "args", ".", "legend_loc", ",", "save_name", "=", "args", ".", "save_name", ",", "\n", "xlimit", "=", "args", ".", "xlimit", ",", "color", "=", "args", ".", "color", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.__init__": [[77, 112], ["spinup.utils.mpi_tools.proc_id", "os.exists", "os.exists", "open", "atexit.register", "print", "print", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.join", "os.join", "logx.colorize", "int", "time.time"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.proc_id", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize"], ["def", "__init__", "(", "self", ",", "output_dir", "=", "None", ",", "output_fname", "=", "'progress.txt'", ",", "exp_name", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a Logger.\n\n        Args:\n            output_dir (string): A directory for saving results to. If \n                ``None``, defaults to a temp directory of the form\n                ``/tmp/experiments/somerandomnumber``.\n\n            output_fname (string): Name for the tab-separated-value file \n                containing metrics logged throughout a training run. \n                Defaults to ``progress.txt``. \n\n            exp_name (string): Experiment name. If you run multiple training\n                runs and give them all the same ``exp_name``, the plotter\n                will know to group them. (Use case: if you run the same\n                hyperparameter configuration with multiple random seeds, you\n                should give them all the same ``exp_name``.)\n        \"\"\"", "\n", "if", "proc_id", "(", ")", "==", "0", ":", "\n", "            ", "self", ".", "output_dir", "=", "output_dir", "or", "\"/tmp/experiments/%i\"", "%", "int", "(", "time", ".", "time", "(", ")", ")", "\n", "if", "osp", ".", "exists", "(", "self", ".", "output_dir", ")", ":", "\n", "                ", "print", "(", "\"Warning: Log dir %s already exists! Storing info there anyway.\"", "%", "self", ".", "output_dir", ")", "\n", "", "else", ":", "\n", "                ", "os", ".", "makedirs", "(", "self", ".", "output_dir", ")", "\n", "", "self", ".", "output_file", "=", "open", "(", "osp", ".", "join", "(", "self", ".", "output_dir", ",", "output_fname", ")", ",", "'w'", ")", "\n", "atexit", ".", "register", "(", "self", ".", "output_file", ".", "close", ")", "\n", "print", "(", "colorize", "(", "\"Logging data to %s\"", "%", "self", ".", "output_file", ".", "name", ",", "'green'", ",", "bold", "=", "True", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "output_dir", "=", "None", "\n", "self", ".", "output_file", "=", "None", "\n", "", "self", ".", "first_row", "=", "True", "\n", "self", ".", "log_headers", "=", "[", "]", "\n", "self", ".", "log_current_row", "=", "{", "}", "\n", "self", ".", "exp_name", "=", "exp_name", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log": [[113, 117], ["spinup.utils.mpi_tools.proc_id", "print", "logx.colorize"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.proc_id", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize"], ["", "def", "log", "(", "self", ",", "msg", ",", "color", "=", "'green'", ")", ":", "\n", "        ", "\"\"\"Print a colorized message to stdout.\"\"\"", "\n", "if", "proc_id", "(", ")", "==", "0", ":", "\n", "            ", "print", "(", "colorize", "(", "msg", ",", "color", ",", "bold", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log_tabular": [[118, 133], ["logx.Logger.log_headers.append"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "", "def", "log_tabular", "(", "self", ",", "key", ",", "val", ")", ":", "\n", "        ", "\"\"\"\n        Log a value of some diagnostic.\n\n        Call this only once for each diagnostic quantity, each iteration.\n        After using ``log_tabular`` to store values for each diagnostic,\n        make sure to call ``dump_tabular`` to write them out to file and\n        stdout (otherwise they will not get saved anywhere).\n        \"\"\"", "\n", "if", "self", ".", "first_row", ":", "\n", "            ", "self", ".", "log_headers", ".", "append", "(", "key", ")", "\n", "", "else", ":", "\n", "            ", "assert", "key", "in", "self", ".", "log_headers", ",", "\"Trying to introduce a new key %s that you didn't include in the first iteration\"", "%", "key", "\n", "", "assert", "key", "not", "in", "self", ".", "log_current_row", ",", "\"You already set %s this iteration. Maybe you forgot to call dump_tabular()\"", "%", "key", "\n", "self", ".", "log_current_row", "[", "key", "]", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.save_config": [[134, 159], ["spinup.utils.serialization_utils.convert_json", "spinup.utils.mpi_tools.proc_id", "json.dumps", "print", "print", "logx.colorize", "open", "out.write", "os.join", "os.join"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.proc_id", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize"], ["", "def", "save_config", "(", "self", ",", "config", ")", ":", "\n", "        ", "\"\"\"\n        Log an experiment configuration.\n\n        Call this once at the top of your experiment, passing in all important\n        config vars as a dict. This will serialize the config to JSON, while\n        handling anything which can't be serialized in a graceful way (writing\n        as informative a string as possible). \n\n        Example use:\n\n        .. code-block:: python\n\n            logger = EpochLogger(**logger_kwargs)\n            logger.save_config(locals())\n        \"\"\"", "\n", "config_json", "=", "convert_json", "(", "config", ")", "\n", "if", "self", ".", "exp_name", "is", "not", "None", ":", "\n", "            ", "config_json", "[", "'exp_name'", "]", "=", "self", ".", "exp_name", "\n", "", "if", "proc_id", "(", ")", "==", "0", ":", "\n", "            ", "output", "=", "json", ".", "dumps", "(", "config_json", ",", "separators", "=", "(", "','", ",", "':\\t'", ")", ",", "indent", "=", "4", ",", "sort_keys", "=", "True", ")", "\n", "print", "(", "colorize", "(", "'Saving config:\\n'", ",", "color", "=", "'cyan'", ",", "bold", "=", "True", ")", ")", "\n", "print", "(", "output", ")", "\n", "with", "open", "(", "osp", ".", "join", "(", "self", ".", "output_dir", ",", "\"config.json\"", ")", ",", "'w'", ")", "as", "out", ":", "\n", "                ", "out", ".", "write", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.save_state": [[160, 189], ["spinup.utils.mpi_tools.proc_id", "hasattr", "joblib.dump", "logx.Logger._tf_simple_save", "os.join", "os.join", "logx.Logger.log"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.proc_id", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger._tf_simple_save", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log"], ["", "", "", "def", "save_state", "(", "self", ",", "state_dict", ",", "itr", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Saves the state of an experiment.\n\n        To be clear: this is about saving *state*, not logging diagnostics.\n        All diagnostic logging is separate from this function. This function\n        will save whatever is in ``state_dict``---usually just a copy of the\n        environment---and the most recent parameters for the model you \n        previously set up saving for with ``setup_tf_saver``. \n\n        Call with any frequency you prefer. If you only want to maintain a\n        single state and overwrite it at each call with the most recent \n        version, leave ``itr=None``. If you want to keep all of the states you\n        save, provide unique (increasing) values for 'itr'.\n\n        Args:\n            state_dict (dict): Dictionary containing essential elements to\n                describe the current state of training.\n\n            itr: An int, or None. Current iteration of training.\n        \"\"\"", "\n", "if", "proc_id", "(", ")", "==", "0", ":", "\n", "            ", "fname", "=", "'vars.pkl'", "if", "itr", "is", "None", "else", "'vars%d.pkl'", "%", "itr", "\n", "try", ":", "\n", "                ", "joblib", ".", "dump", "(", "state_dict", ",", "osp", ".", "join", "(", "self", ".", "output_dir", ",", "fname", ")", ")", "\n", "", "except", ":", "\n", "                ", "self", ".", "log", "(", "'Warning: could not pickle state_dict.'", ",", "color", "=", "'red'", ")", "\n", "", "if", "hasattr", "(", "self", ",", "'tf_saver_elements'", ")", ":", "\n", "                ", "self", ".", "_tf_simple_save", "(", "itr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.setup_tf_saver": [[190, 211], ["dict", "inputs.items", "outputs.items"], "methods", ["None"], ["", "", "", "def", "setup_tf_saver", "(", "self", ",", "sess", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Set up easy model saving for tensorflow.\n\n        Call once, after defining your computation graph but before training.\n\n        Args:\n            sess: The Tensorflow session in which you train your computation\n                graph.\n\n            inputs (dict): A dictionary that maps from keys of your choice\n                to the tensorflow placeholders that serve as inputs to the \n                computation graph. Make sure that *all* of the placeholders\n                needed for your outputs are included!\n\n            outputs (dict): A dictionary that maps from keys of your choice\n                to the outputs from your computation graph.\n        \"\"\"", "\n", "self", ".", "tf_saver_elements", "=", "dict", "(", "session", "=", "sess", ",", "inputs", "=", "inputs", ",", "outputs", "=", "outputs", ")", "\n", "self", ".", "tf_saver_info", "=", "{", "'inputs'", ":", "{", "k", ":", "v", ".", "name", "for", "k", ",", "v", "in", "inputs", ".", "items", "(", ")", "}", ",", "\n", "'outputs'", ":", "{", "k", ":", "v", ".", "name", "for", "k", ",", "v", "in", "outputs", ".", "items", "(", ")", "}", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger._tf_simple_save": [[212, 228], ["spinup.utils.mpi_tools.proc_id", "hasattr", "os.join", "os.join", "os.exists", "os.exists", "tensorflow.saved_model.simple_save", "joblib.dump", "shutil.rmtree", "os.join", "os.join"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.proc_id"], ["", "def", "_tf_simple_save", "(", "self", ",", "itr", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Uses simple_save to save a trained model, plus info to make it easy\n        to associated tensors to variables after restore. \n        \"\"\"", "\n", "if", "proc_id", "(", ")", "==", "0", ":", "\n", "            ", "assert", "hasattr", "(", "self", ",", "'tf_saver_elements'", ")", ",", "\"First have to setup saving with self.setup_tf_saver\"", "\n", "fpath", "=", "'simple_save'", "+", "(", "'%d'", "%", "itr", "if", "itr", "is", "not", "None", "else", "''", ")", "\n", "fpath", "=", "osp", ".", "join", "(", "self", ".", "output_dir", ",", "fpath", ")", "\n", "if", "osp", ".", "exists", "(", "fpath", ")", ":", "\n", "# simple_save refuses to be useful if fpath already exists,", "\n", "# so just delete fpath if it's there.", "\n", "                ", "shutil", ".", "rmtree", "(", "fpath", ")", "\n", "", "tf", ".", "saved_model", ".", "simple_save", "(", "export_dir", "=", "fpath", ",", "**", "self", ".", "tf_saver_elements", ")", "\n", "joblib", ".", "dump", "(", "self", ".", "tf_saver_info", ",", "osp", ".", "join", "(", "fpath", ",", "'model_info.pkl'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.dump_tabular": [[229, 256], ["logx.Logger.log_current_row.clear", "spinup.utils.mpi_tools.proc_id", "max", "print", "print", "len", "max", "logx.Logger.log_current_row.get", "print", "vals.append", "logx.Logger.output_file.write", "logx.Logger.output_file.flush", "hasattr", "logx.Logger.output_file.write", "map"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.proc_id", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "", "def", "dump_tabular", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Write all of the diagnostics from the current iteration.\n\n        Writes both to stdout, and to the output file.\n        \"\"\"", "\n", "if", "proc_id", "(", ")", "==", "0", ":", "\n", "            ", "vals", "=", "[", "]", "\n", "key_lens", "=", "[", "len", "(", "key", ")", "for", "key", "in", "self", ".", "log_headers", "]", "\n", "max_key_len", "=", "max", "(", "15", ",", "max", "(", "key_lens", ")", ")", "\n", "keystr", "=", "'%'", "+", "'%d'", "%", "max_key_len", "\n", "fmt", "=", "\"| \"", "+", "keystr", "+", "\"s | %15s |\"", "\n", "n_slashes", "=", "22", "+", "max_key_len", "\n", "print", "(", "\"-\"", "*", "n_slashes", ")", "\n", "for", "key", "in", "self", ".", "log_headers", ":", "\n", "                ", "val", "=", "self", ".", "log_current_row", ".", "get", "(", "key", ",", "\"\"", ")", "\n", "valstr", "=", "\"%8.3g\"", "%", "val", "if", "hasattr", "(", "val", ",", "\"__float__\"", ")", "else", "val", "\n", "print", "(", "fmt", "%", "(", "key", ",", "valstr", ")", ")", "\n", "vals", ".", "append", "(", "val", ")", "\n", "", "print", "(", "\"-\"", "*", "n_slashes", ")", "\n", "if", "self", ".", "output_file", "is", "not", "None", ":", "\n", "                ", "if", "self", ".", "first_row", ":", "\n", "                    ", "self", ".", "output_file", ".", "write", "(", "\"\\t\"", ".", "join", "(", "self", ".", "log_headers", ")", "+", "\"\\n\"", ")", "\n", "", "self", ".", "output_file", ".", "write", "(", "\"\\t\"", ".", "join", "(", "map", "(", "str", ",", "vals", ")", ")", "+", "\"\\n\"", ")", "\n", "self", ".", "output_file", ".", "flush", "(", ")", "\n", "", "", "self", ".", "log_current_row", ".", "clear", "(", ")", "\n", "self", ".", "first_row", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.__init__": [[282, 285], ["logx.Logger.__init__", "dict"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "epoch_dict", "=", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.store": [[286, 297], ["kwargs.items", "logx.EpochLogger.epoch_dict[].append", "logx.EpochLogger.epoch_dict.keys"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "store", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Save something into the epoch_logger's current state.\n\n        Provide an arbitrary number of keyword arguments with numerical \n        values.\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "(", "k", "in", "self", ".", "epoch_dict", ".", "keys", "(", ")", ")", ":", "\n", "                ", "self", ".", "epoch_dict", "[", "k", "]", "=", "[", "]", "\n", "", "self", ".", "epoch_dict", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular": [[298, 330], ["logx.Logger.log_tabular", "spinup.utils.mpi_tools.mpi_statistics_scalar", "logx.Logger.log_tabular", "numpy.concatenate", "logx.Logger.log_tabular", "logx.Logger.log_tabular", "logx.Logger.log_tabular", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_statistics_scalar", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular"], ["", "", "def", "log_tabular", "(", "self", ",", "key", ",", "val", "=", "None", ",", "with_min_and_max", "=", "False", ",", "average_only", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Log a value or possibly the mean/std/min/max values of a diagnostic.\n\n        Args:\n            key (string): The name of the diagnostic. If you are logging a\n                diagnostic whose state has previously been saved with \n                ``store``, the key here has to match the key you used there.\n\n            val: A value for the diagnostic. If you have previously saved\n                values for this key via ``store``, do *not* provide a ``val``\n                here.\n\n            with_min_and_max (bool): If true, log min and max values of the \n                diagnostic over the epoch.\n\n            average_only (bool): If true, do not log the standard deviation\n                of the diagnostic over the epoch.\n        \"\"\"", "\n", "if", "val", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "log_tabular", "(", "key", ",", "val", ")", "\n", "", "else", ":", "\n", "            ", "v", "=", "self", ".", "epoch_dict", "[", "key", "]", "\n", "vals", "=", "np", ".", "concatenate", "(", "v", ")", "if", "isinstance", "(", "v", "[", "0", "]", ",", "np", ".", "ndarray", ")", "and", "len", "(", "v", "[", "0", "]", ".", "shape", ")", ">", "0", "else", "v", "\n", "stats", "=", "mpi_statistics_scalar", "(", "vals", ",", "with_min_and_max", "=", "with_min_and_max", ")", "\n", "super", "(", ")", ".", "log_tabular", "(", "key", "if", "average_only", "else", "'Average'", "+", "key", ",", "stats", "[", "0", "]", ")", "\n", "if", "not", "(", "average_only", ")", ":", "\n", "                ", "super", "(", ")", ".", "log_tabular", "(", "'Std'", "+", "key", ",", "stats", "[", "1", "]", ")", "\n", "", "if", "with_min_and_max", ":", "\n", "                ", "super", "(", ")", ".", "log_tabular", "(", "'Max'", "+", "key", ",", "stats", "[", "3", "]", ")", "\n", "super", "(", ")", ".", "log_tabular", "(", "'Min'", "+", "key", ",", "stats", "[", "2", "]", ")", "\n", "", "", "self", ".", "epoch_dict", "[", "key", "]", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.get_stats": [[331, 338], ["spinup.utils.mpi_tools.mpi_statistics_scalar", "numpy.concatenate", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.mpi_tools.mpi_statistics_scalar"], ["", "def", "get_stats", "(", "self", ",", "key", ")", ":", "\n", "        ", "\"\"\"\n        Lets an algorithm ask the logger for mean/std/min/max of a diagnostic.\n        \"\"\"", "\n", "v", "=", "self", ".", "epoch_dict", "[", "key", "]", "\n", "vals", "=", "np", ".", "concatenate", "(", "v", ")", "if", "isinstance", "(", "v", "[", "0", "]", ",", "np", ".", "ndarray", ")", "and", "len", "(", "v", "[", "0", "]", ".", "shape", ")", ">", "0", "else", "v", "\n", "return", "mpi_statistics_scalar", "(", "vals", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.colorize": [[29, 41], ["attr.append", "str", "attr.append"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["def", "colorize", "(", "string", ",", "color", ",", "bold", "=", "False", ",", "highlight", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Colorize a string.\n\n    This function was originally written by John Schulman.\n    \"\"\"", "\n", "attr", "=", "[", "]", "\n", "num", "=", "color2num", "[", "color", "]", "\n", "if", "highlight", ":", "num", "+=", "10", "\n", "attr", ".", "append", "(", "str", "(", "num", ")", ")", "\n", "if", "bold", ":", "attr", ".", "append", "(", "'1'", ")", "\n", "return", "'\\x1b[%sm%s\\x1b[0m'", "%", "(", "';'", ".", "join", "(", "attr", ")", ",", "string", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.restore_tf_graph": [[42, 68], ["tensorflow.saved_model.loader.load", "joblib.load", "tensorflow.get_default_graph", "dict", "dict.update", "dict.update", "os.join", "tf.get_default_graph.get_tensor_by_name", "tf.get_default_graph.get_tensor_by_name", "model_info[].items", "model_info[].items"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load"], ["", "def", "restore_tf_graph", "(", "sess", ",", "fpath", ")", ":", "\n", "    ", "\"\"\"\n    Loads graphs saved by Logger.\n\n    Will output a dictionary whose keys and values are from the 'inputs' \n    and 'outputs' dict you specified with logger.setup_tf_saver().\n\n    Args:\n        sess: A Tensorflow session.\n        fpath: Filepath to save directory.\n\n    Returns:\n        A dictionary mapping from keys to tensors in the computation graph\n        loaded from ``fpath``. \n    \"\"\"", "\n", "tf", ".", "saved_model", ".", "loader", ".", "load", "(", "\n", "sess", ",", "\n", "[", "tf", ".", "saved_model", ".", "tag_constants", ".", "SERVING", "]", ",", "\n", "fpath", "\n", ")", "\n", "model_info", "=", "joblib", ".", "load", "(", "osp", ".", "join", "(", "fpath", ",", "'model_info.pkl'", ")", ")", "\n", "graph", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "model", "=", "dict", "(", ")", "\n", "model", ".", "update", "(", "{", "k", ":", "graph", ".", "get_tensor_by_name", "(", "v", ")", "for", "k", ",", "v", "in", "model_info", "[", "'inputs'", "]", ".", "items", "(", ")", "}", ")", "\n", "model", ".", "update", "(", "{", "k", ":", "graph", ".", "get_tensor_by_name", "(", "v", ")", "for", "k", ",", "v", "in", "model_info", "[", "'outputs'", "]", ".", "items", "(", ")", "}", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.test_policy.load_policy": [[9, 43], ["tensorflow.Session", "spinup.utils.logx.restore_tf_graph", "os.join", "print", "print", "joblib.load", "int", "spinup.utils.logx.restore_tf_graph.keys", "tf.Session.run", "os.join", "os.listdir", "os.listdir", "len", "max", "len"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.restore_tf_graph", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.BAIL.utils.ReplayBuffer.load", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.run"], ["def", "load_policy", "(", "fpath", ",", "itr", "=", "'last'", ",", "deterministic", "=", "False", ")", ":", "\n", "\n", "# handle which epoch to load from", "\n", "    ", "if", "itr", "==", "'last'", ":", "\n", "        ", "saves", "=", "[", "int", "(", "x", "[", "11", ":", "]", ")", "for", "x", "in", "os", ".", "listdir", "(", "fpath", ")", "if", "'simple_save'", "in", "x", "and", "len", "(", "x", ")", ">", "11", "]", "\n", "itr", "=", "'%d'", "%", "max", "(", "saves", ")", "if", "len", "(", "saves", ")", ">", "0", "else", "''", "\n", "", "else", ":", "\n", "        ", "itr", "=", "'%d'", "%", "itr", "\n", "\n", "# load the things!", "\n", "", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "model", "=", "restore_tf_graph", "(", "sess", ",", "osp", ".", "join", "(", "fpath", ",", "'simple_save'", "+", "itr", ")", ")", "\n", "\n", "# get the correct op for executing actions", "\n", "if", "deterministic", "and", "'mu'", "in", "model", ".", "keys", "(", ")", ":", "\n", "# 'deterministic' is only a valid option for SAC policies", "\n", "        ", "print", "(", "'Using deterministic action op.'", ")", "\n", "action_op", "=", "model", "[", "'mu'", "]", "\n", "", "else", ":", "\n", "        ", "print", "(", "'Using default action op.'", ")", "\n", "action_op", "=", "model", "[", "'pi'", "]", "\n", "\n", "# make function for producing an action given a single state", "\n", "", "get_action", "=", "lambda", "x", ":", "sess", ".", "run", "(", "action_op", ",", "feed_dict", "=", "{", "model", "[", "'x'", "]", ":", "x", "[", "None", ",", ":", "]", "}", ")", "[", "0", "]", "\n", "\n", "# try to load environment from save", "\n", "# (sometimes this will fail because the environment could not be pickled)", "\n", "try", ":", "\n", "        ", "state", "=", "joblib", ".", "load", "(", "osp", ".", "join", "(", "fpath", ",", "'vars'", "+", "itr", "+", "'.pkl'", ")", ")", "\n", "env", "=", "state", "[", "'env'", "]", "\n", "", "except", ":", "\n", "        ", "env", "=", "None", "\n", "\n", "", "return", "env", ",", "get_action", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.test_policy.run_policy": [[45, 73], ["spinup.EpochLogger", "spinup.EpochLogger.log_tabular", "spinup.EpochLogger.log_tabular", "spinup.EpochLogger.dump_tabular", "env.reset", "get_action", "env.step", "env.render", "time.sleep", "spinup.EpochLogger.store", "print", "env.reset"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.EpochLogger.log_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.dump_tabular", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.run_utils.ExperimentGrid.print", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset"], ["", "def", "run_policy", "(", "env", ",", "get_action", ",", "max_ep_len", "=", "None", ",", "num_episodes", "=", "100", ",", "render", "=", "True", ")", ":", "\n", "\n", "    ", "assert", "env", "is", "not", "None", ",", "\"Environment not found!\\n\\n It looks like the environment wasn't saved, \"", "+", "\"and we can't run the agent in it. :( \\n\\n Check out the readthedocs \"", "+", "\"page on Experiment Outputs for how to handle this situation.\"", "\n", "\n", "logger", "=", "EpochLogger", "(", ")", "\n", "o", ",", "r", ",", "d", ",", "ep_ret", ",", "ep_len", ",", "n", "=", "env", ".", "reset", "(", ")", ",", "0", ",", "False", ",", "0", ",", "0", ",", "0", "\n", "while", "n", "<", "num_episodes", ":", "\n", "        ", "if", "render", ":", "\n", "            ", "env", ".", "render", "(", ")", "\n", "time", ".", "sleep", "(", "1e-3", ")", "\n", "\n", "", "a", "=", "get_action", "(", "o", ")", "\n", "o", ",", "r", ",", "d", ",", "_", "=", "env", ".", "step", "(", "a", ")", "\n", "ep_ret", "+=", "r", "\n", "ep_len", "+=", "1", "\n", "\n", "if", "d", "or", "(", "ep_len", "==", "max_ep_len", ")", ":", "\n", "            ", "logger", ".", "store", "(", "EpRet", "=", "ep_ret", ",", "EpLen", "=", "ep_len", ")", "\n", "print", "(", "'Episode %d \\t EpRet %.3f \\t EpLen %d'", "%", "(", "n", ",", "ep_ret", ",", "ep_len", ")", ")", "\n", "o", ",", "r", ",", "d", ",", "ep_ret", ",", "ep_len", "=", "env", ".", "reset", "(", ")", ",", "0", ",", "False", ",", "0", ",", "0", "\n", "n", "+=", "1", "\n", "\n", "", "", "logger", ".", "log_tabular", "(", "'EpRet'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'EpLen'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "dump_tabular", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json": [[3, 27], ["serialization_utils.is_json_serializable", "isinstance", "str", "isinstance", "serialization_utils.convert_json", "serialization_utils.convert_json", "isinstance", "obj.items", "serialization_utils.convert_json", "serialization_utils.convert_json", "hasattr", "serialization_utils.convert_json", "hasattr", "serialization_utils.convert_json", "serialization_utils.convert_json", "str", "obj.__dict__.items"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.is_json_serializable", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.convert_json"], ["def", "convert_json", "(", "obj", ")", ":", "\n", "    ", "\"\"\" Convert obj to a version which can be serialized with JSON. \"\"\"", "\n", "if", "is_json_serializable", "(", "obj", ")", ":", "\n", "        ", "return", "obj", "\n", "", "else", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "dict", ")", ":", "\n", "            ", "return", "{", "convert_json", "(", "k", ")", ":", "convert_json", "(", "v", ")", "\n", "for", "k", ",", "v", "in", "obj", ".", "items", "(", ")", "}", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "tuple", ")", ":", "\n", "            ", "return", "(", "convert_json", "(", "x", ")", "for", "x", "in", "obj", ")", "\n", "\n", "", "elif", "isinstance", "(", "obj", ",", "list", ")", ":", "\n", "            ", "return", "[", "convert_json", "(", "x", ")", "for", "x", "in", "obj", "]", "\n", "\n", "", "elif", "hasattr", "(", "obj", ",", "'__name__'", ")", "and", "not", "(", "'lambda'", "in", "obj", ".", "__name__", ")", ":", "\n", "            ", "return", "convert_json", "(", "obj", ".", "__name__", ")", "\n", "\n", "", "elif", "hasattr", "(", "obj", ",", "'__dict__'", ")", "and", "obj", ".", "__dict__", ":", "\n", "            ", "obj_dict", "=", "{", "convert_json", "(", "k", ")", ":", "convert_json", "(", "v", ")", "\n", "for", "k", ",", "v", "in", "obj", ".", "__dict__", ".", "items", "(", ")", "}", "\n", "return", "{", "str", "(", "obj", ")", ":", "obj_dict", "}", "\n", "\n", "", "return", "str", "(", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.serialization_utils.is_json_serializable": [[28, 34], ["json.dumps"], "function", ["None"], ["", "", "def", "is_json_serializable", "(", "v", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "json", ".", "dumps", "(", "v", ")", "\n", "return", "True", "\n", "", "except", ":", "\n", "        ", "return", "False", "", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy_disc.DiscretePolicy.__init__": [[8, 27], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "mlp_policy_disc.DiscretePolicy.action_head.weight.data.mul_", "mlp_policy_disc.DiscretePolicy.action_head.bias.data.mul_", "mlp_policy_disc.DiscretePolicy.affine_layers.append", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["    ", "def", "__init__", "(", "self", ",", "state_dim", ",", "action_num", ",", "hidden_size", "=", "(", "128", ",", "128", ")", ",", "activation", "=", "'tanh'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "is_disc_action", "=", "True", "\n", "if", "activation", "==", "'tanh'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "tanh", "\n", "", "elif", "activation", "==", "'relu'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "relu", "\n", "", "elif", "activation", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "sigmoid", "\n", "\n", "", "self", ".", "affine_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "last_dim", "=", "state_dim", "\n", "for", "nh", "in", "hidden_size", ":", "\n", "            ", "self", ".", "affine_layers", ".", "append", "(", "nn", ".", "Linear", "(", "last_dim", ",", "nh", ")", ")", "\n", "last_dim", "=", "nh", "\n", "\n", "", "self", ".", "action_head", "=", "nn", ".", "Linear", "(", "last_dim", ",", "action_num", ")", "\n", "self", ".", "action_head", ".", "weight", ".", "data", ".", "mul_", "(", "0.1", ")", "\n", "self", ".", "action_head", ".", "bias", ".", "data", ".", "mul_", "(", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy_disc.DiscretePolicy.forward": [[28, 34], ["torch.softmax", "torch.softmax", "mlp_policy_disc.DiscretePolicy.activation", "mlp_policy_disc.DiscretePolicy.action_head", "affine"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "affine", "(", "x", ")", ")", "\n", "\n", "", "action_prob", "=", "F", ".", "softmax", "(", "self", ".", "action_head", "(", "x", ")", ")", "\n", "return", "action_prob", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy_disc.DiscretePolicy.select_action": [[35, 39], ["mlp_policy_disc.DiscretePolicy.forward", "mlp_policy_disc.DiscretePolicy.multinomial"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward"], ["", "def", "select_action", "(", "self", ",", "x", ")", ":", "\n", "        ", "action_prob", "=", "self", ".", "forward", "(", "x", ")", "\n", "action", "=", "action_prob", ".", "multinomial", "(", ")", "\n", "return", "action", ".", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy_disc.DiscretePolicy.get_kl": [[40, 45], ["mlp_policy_disc.DiscretePolicy.forward", "torch.autograd.Variable", "torch.autograd.Variable", "kl.sum", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log"], ["", "def", "get_kl", "(", "self", ",", "x", ")", ":", "\n", "        ", "action_prob1", "=", "self", ".", "forward", "(", "x", ")", "\n", "action_prob0", "=", "Variable", "(", "action_prob1", ".", "data", ")", "\n", "kl", "=", "action_prob0", "*", "(", "torch", ".", "log", "(", "action_prob0", ")", "-", "torch", ".", "log", "(", "action_prob1", ")", ")", "\n", "return", "kl", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy_disc.DiscretePolicy.get_log_prob": [[46, 49], ["mlp_policy_disc.DiscretePolicy.forward", "torch.log", "torch.log", "torch.log", "torch.log", "mlp_policy_disc.DiscretePolicy.gather", "actions.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log"], ["", "def", "get_log_prob", "(", "self", ",", "x", ",", "actions", ")", ":", "\n", "        ", "action_prob", "=", "self", ".", "forward", "(", "x", ")", "\n", "return", "torch", ".", "log", "(", "action_prob", ".", "gather", "(", "1", ",", "actions", ".", "unsqueeze", "(", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy_disc.DiscretePolicy.get_fim": [[50, 54], ["mlp_policy_disc.DiscretePolicy.forward", "mlp_policy_disc.DiscretePolicy.pow().view", "mlp_policy_disc.DiscretePolicy.pow"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward"], ["", "def", "get_fim", "(", "self", ",", "x", ")", ":", "\n", "        ", "action_prob", "=", "self", ".", "forward", "(", "x", ")", "\n", "M", "=", "action_prob", ".", "pow", "(", "-", "1", ")", ".", "view", "(", "-", "1", ")", ".", "data", "\n", "return", "M", ",", "action_prob", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy.Policy.__init__": [[9, 30], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "mlp_policy.Policy.action_mean.weight.data.mul_", "mlp_policy.Policy.action_mean.bias.data.mul_", "torch.Parameter", "torch.Parameter", "mlp_policy.Policy.affine_layers.append", "torch.Linear", "torch.Linear", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones"], ["    ", "def", "__init__", "(", "self", ",", "state_dim", ",", "action_dim", ",", "hidden_size", "=", "(", "128", ",", "128", ")", ",", "activation", "=", "'tanh'", ",", "log_std", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "is_disc_action", "=", "False", "\n", "if", "activation", "==", "'tanh'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "tanh", "\n", "", "elif", "activation", "==", "'relu'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "relu", "\n", "", "elif", "activation", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "sigmoid", "\n", "\n", "", "self", ".", "affine_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "last_dim", "=", "state_dim", "\n", "for", "nh", "in", "hidden_size", ":", "\n", "            ", "self", ".", "affine_layers", ".", "append", "(", "nn", ".", "Linear", "(", "last_dim", ",", "nh", ")", ")", "\n", "last_dim", "=", "nh", "\n", "\n", "", "self", ".", "action_mean", "=", "nn", ".", "Linear", "(", "last_dim", ",", "action_dim", ")", "\n", "self", ".", "action_mean", ".", "weight", ".", "data", ".", "mul_", "(", "0.1", ")", "\n", "self", ".", "action_mean", ".", "bias", ".", "data", ".", "mul_", "(", "0.0", ")", "\n", "\n", "self", ".", "action_log_std", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "1", ",", "action_dim", ")", "*", "log_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy.Policy.forward": [[31, 40], ["mlp_policy.Policy.action_mean", "mlp_policy.Policy.action_log_std.expand_as", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "mlp_policy.Policy.activation", "affine"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "affine", "(", "x", ")", ")", "\n", "\n", "", "action_mean", "=", "self", ".", "action_mean", "(", "x", ")", "\n", "action_log_std", "=", "self", ".", "action_log_std", ".", "expand_as", "(", "action_mean", ")", "\n", "action_std", "=", "torch", ".", "exp", "(", "action_log_std", ")", "\n", "\n", "return", "action_mean", ",", "action_log_std", ",", "action_std", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy.Policy.select_action": [[41, 50], ["mlp_policy.Policy.forward", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal.rsample", "torch.distributions.Normal.rsample"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.rsample", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.rsample"], ["", "def", "select_action", "(", "self", ",", "x", ")", ":", "\n", "        ", "action_mean", ",", "_", ",", "action_std", "=", "self", ".", "forward", "(", "x", ")", "\n", "normal", "=", "Normal", "(", "action_mean", ",", "action_std", ")", "\n", "action", "=", "normal", ".", "rsample", "(", ")", "\n", "#size = action_std.shape", "\n", "#action = torch.randn(size) * action_std + action_mean", "\n", "#action = torch.normal(action_mean, action_std)", "\n", "#print ('Std:', action_std)", "\n", "return", "action", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy.Policy.get_kl": [[51, 59], ["mlp_policy.Policy.forward", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "kl.sum", "torch.autograd.Variable.pow", "torch.autograd.Variable.pow", "std1.pow"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum"], ["", "def", "get_kl", "(", "self", ",", "x", ")", ":", "\n", "        ", "mean1", ",", "log_std1", ",", "std1", "=", "self", ".", "forward", "(", "x", ")", "\n", "\n", "mean0", "=", "Variable", "(", "mean1", ".", "data", ")", "\n", "log_std0", "=", "Variable", "(", "log_std1", ".", "data", ")", "\n", "std0", "=", "Variable", "(", "std1", ".", "data", ")", "\n", "kl", "=", "log_std1", "-", "log_std0", "+", "(", "std0", ".", "pow", "(", "2", ")", "+", "(", "mean0", "-", "mean1", ")", ".", "pow", "(", "2", ")", ")", "/", "(", "2.0", "*", "std1", ".", "pow", "(", "2", ")", ")", "-", "0.5", "\n", "return", "kl", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy.Policy.get_log_prob": [[60, 63], ["mlp_policy.Policy.forward", "normal_log_density"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.math.normal_log_density"], ["", "def", "get_log_prob", "(", "self", ",", "x", ",", "actions", ")", ":", "\n", "        ", "action_mean", ",", "action_log_std", ",", "action_std", "=", "self", ".", "forward", "(", "x", ")", "\n", "return", "normal_log_density", "(", "actions", ",", "action_mean", ",", "action_log_std", ",", "action_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_policy.Policy.get_fim": [[64, 77], ["mlp_policy.Policy.forward", "mlp_policy.Policy.action_log_std.data.exp().pow().squeeze().repeat", "mlp_policy.Policy.named_parameters", "x.size", "mlp_policy.Policy.action_log_std.data.exp().pow().squeeze", "param.data.view", "mlp_policy.Policy.action_log_std.data.exp().pow", "mlp_policy.Policy.action_log_std.data.exp"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward"], ["", "def", "get_fim", "(", "self", ",", "x", ")", ":", "\n", "        ", "mean", ",", "_", ",", "_", "=", "self", ".", "forward", "(", "x", ")", "\n", "cov_inv", "=", "self", ".", "action_log_std", ".", "data", ".", "exp", "(", ")", ".", "pow", "(", "-", "2", ")", ".", "squeeze", "(", "0", ")", ".", "repeat", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "param_count", "=", "0", "\n", "std_index", "=", "0", "\n", "id", "=", "0", "\n", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "name", "==", "\"action_log_std\"", ":", "\n", "                ", "std_id", "=", "id", "\n", "std_index", "=", "param_count", "\n", "", "param_count", "+=", "param", ".", "data", ".", "view", "(", "-", "1", ")", ".", "shape", "[", "0", "]", "\n", "id", "+=", "1", "\n", "", "return", "cov_inv", ",", "mean", ",", "{", "'std_id'", ":", "std_id", ",", "'std_index'", ":", "std_index", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_discriminator.Discriminator.__init__": [[6, 24], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "mlp_discriminator.Discriminator.logic.weight.data.mul_", "mlp_discriminator.Discriminator.logic.bias.data.mul_", "mlp_discriminator.Discriminator.affine_layers.append", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["    ", "def", "__init__", "(", "self", ",", "num_inputs", ",", "hidden_size", "=", "(", "128", ",", "128", ")", ",", "activation", "=", "'tanh'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "activation", "==", "'tanh'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "tanh", "\n", "", "elif", "activation", "==", "'relu'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "relu", "\n", "", "elif", "activation", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "sigmoid", "\n", "\n", "", "self", ".", "affine_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "last_dim", "=", "num_inputs", "\n", "for", "nh", "in", "hidden_size", ":", "\n", "            ", "self", ".", "affine_layers", ".", "append", "(", "nn", ".", "Linear", "(", "last_dim", ",", "nh", ")", ")", "\n", "last_dim", "=", "nh", "\n", "\n", "", "self", ".", "logic", "=", "nn", ".", "Linear", "(", "last_dim", ",", "1", ")", "\n", "self", ".", "logic", ".", "weight", ".", "data", ".", "mul_", "(", "0.1", ")", "\n", "self", ".", "logic", ".", "bias", ".", "data", ".", "mul_", "(", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_discriminator.Discriminator.forward": [[25, 31], ["torch.sigmoid", "torch.sigmoid", "mlp_discriminator.Discriminator.activation", "mlp_discriminator.Discriminator.logic", "affine"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "affine", "(", "x", ")", ")", "\n", "\n", "", "prob", "=", "F", ".", "sigmoid", "(", "self", ".", "logic", "(", "x", ")", ")", "\n", "return", "prob", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_critic.Value.__init__": [[7, 30], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "torch.Linear", "mlp_critic.Value.value_head.weight.data.mul_", "mlp_critic.Value.value_head.bias.data.mul_", "mlp_critic.Value.affine_layers.append", "torch.Linear", "torch.Linear", "torch.Linear", "affine.weight.data.uniform_", "affine.bias.data.uniform_"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["    ", "def", "__init__", "(", "self", ",", "state_dim", ",", "hidden_size", "=", "(", "128", ",", "128", ")", ",", "activation", "=", "'tanh'", ",", "init_small_weights", "=", "False", ",", "init_w", "=", "1e-3", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "activation", "==", "'tanh'", ":", "\n", "            ", "self", ".", "activation", "=", "torch", ".", "tanh", "\n", "", "elif", "activation", "==", "'relu'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "relu", "\n", "", "elif", "activation", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "sigmoid", "\n", "\n", "", "self", ".", "affine_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "last_dim", "=", "state_dim", "\n", "for", "nh", "in", "hidden_size", ":", "\n", "            ", "self", ".", "affine_layers", ".", "append", "(", "nn", ".", "Linear", "(", "last_dim", ",", "nh", ")", ")", "\n", "last_dim", "=", "nh", "\n", "\n", "", "self", ".", "value_head", "=", "nn", ".", "Linear", "(", "last_dim", ",", "1", ")", "\n", "self", ".", "value_head", ".", "weight", ".", "data", ".", "mul_", "(", "0.1", ")", "\n", "self", ".", "value_head", ".", "bias", ".", "data", ".", "mul_", "(", "0.0", ")", "\n", "\n", "if", "init_small_weights", ":", "\n", "            ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "                ", "affine", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "affine", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_critic.Value.forward": [[32, 38], ["mlp_critic.Value.value_head", "mlp_critic.Value.activation", "affine"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "affine", "(", "x", ")", ")", "\n", "\n", "", "value", "=", "self", ".", "value_head", "(", "x", ")", "\n", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_critic.QNet.__init__": [[41, 64], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "torch.Linear", "mlp_critic.QNet.value_head.weight.data.mul_", "mlp_critic.QNet.value_head.bias.data.mul_", "mlp_critic.QNet.affine_layers.append", "torch.Linear", "torch.Linear", "torch.Linear", "affine.weight.data.uniform_", "affine.bias.data.uniform_"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["    ", "def", "__init__", "(", "self", ",", "state_dim", ",", "action_dim", ",", "hidden_size", "=", "(", "128", ",", "128", ")", ",", "activation", "=", "'tanh'", ",", "init_small_weights", "=", "False", ",", "init_w", "=", "1e-3", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "activation", "==", "'tanh'", ":", "\n", "            ", "self", ".", "activation", "=", "torch", ".", "tanh", "\n", "", "elif", "activation", "==", "'relu'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "relu", "\n", "", "elif", "activation", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "activation", "=", "F", ".", "sigmoid", "\n", "\n", "", "self", ".", "affine_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "last_dim", "=", "state_dim", "+", "action_dim", "\n", "for", "nh", "in", "hidden_size", ":", "\n", "            ", "self", ".", "affine_layers", ".", "append", "(", "nn", ".", "Linear", "(", "last_dim", ",", "nh", ")", ")", "\n", "last_dim", "=", "nh", "\n", "\n", "", "self", ".", "value_head", "=", "nn", ".", "Linear", "(", "last_dim", ",", "1", ")", "\n", "self", ".", "value_head", ".", "weight", ".", "data", ".", "mul_", "(", "0.1", ")", "\n", "self", ".", "value_head", ".", "bias", ".", "data", ".", "mul_", "(", "0.0", ")", "\n", "\n", "if", "init_small_weights", ":", "\n", "            ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "                ", "affine", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "affine", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.models.mlp_critic.QNet.forward": [[66, 72], ["mlp_critic.QNet.value_head", "mlp_critic.QNet.activation", "affine"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "affine", "in", "self", ".", "affine_layers", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "affine", "(", "x", ")", ")", "\n", "\n", "", "value", "=", "self", ".", "value_head", "(", "x", ")", "\n", "return", "value", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.__init__": [[14, 27], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros"], ["def", "__init__", "(", "self", ",", "obs_dim", ",", "act_dim", ",", "size", ")", ":", "\n", "        ", "\"\"\"\n        :param obs_dim: size of observation\n        :param act_dim: size of the action\n        :param size: size of the buffer\n        \"\"\"", "\n", "## init buffers as numpy arrays", "\n", "self", ".", "obs1_buf", "=", "np", ".", "zeros", "(", "[", "size", ",", "obs_dim", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "obs2_buf", "=", "np", ".", "zeros", "(", "[", "size", ",", "obs_dim", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "acts_buf", "=", "np", ".", "zeros", "(", "[", "size", ",", "act_dim", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "rews_buf", "=", "np", ".", "zeros", "(", "size", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "done_buf", "=", "np", ".", "zeros", "(", "size", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "ptr", ",", "self", ".", "size", ",", "self", ".", "max_size", "=", "0", ",", "0", ",", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store": [[28, 44], ["min"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min"], ["", "def", "store", "(", "self", ",", "obs", ",", "act", ",", "rew", ",", "next_obs", ",", "done", ")", ":", "\n", "        ", "\"\"\"\n        data will get stored in the pointer's location\n        data should NOT be in tensor format.\n        it's easier if you get data from environment\n        then just store them with the geiven format\n        \"\"\"", "\n", "self", ".", "obs1_buf", "[", "self", ".", "ptr", "]", "=", "obs", "\n", "self", ".", "obs2_buf", "[", "self", ".", "ptr", "]", "=", "next_obs", "\n", "self", ".", "acts_buf", "[", "self", ".", "ptr", "]", "=", "act", "\n", "self", ".", "rews_buf", "[", "self", ".", "ptr", "]", "=", "rew", "\n", "self", ".", "done_buf", "[", "self", ".", "ptr", "]", "=", "done", "\n", "## move the pointer to store in next location in buffer", "\n", "self", ".", "ptr", "=", "(", "self", ".", "ptr", "+", "1", ")", "%", "self", ".", "max_size", "\n", "## keep track of the current buffer size", "\n", "self", ".", "size", "=", "min", "(", "self", ".", "size", "+", "1", ",", "self", ".", "max_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.sample_batch": [[45, 53], ["numpy.random.randint", "dict"], "methods", ["None"], ["", "def", "sample_batch", "(", "self", ",", "batch_size", "=", "32", ")", ":", "\n", "## sample with replacement from buffer", "\n", "        ", "idxs", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "self", ".", "size", ",", "size", "=", "batch_size", ")", "\n", "return", "dict", "(", "obs1", "=", "self", ".", "obs1_buf", "[", "idxs", "]", ",", "\n", "obs2", "=", "self", ".", "obs2_buf", "[", "idxs", "]", ",", "\n", "acts", "=", "self", ".", "acts_buf", "[", "idxs", "]", ",", "\n", "rews", "=", "self", ".", "rews_buf", "[", "idxs", "]", ",", "\n", "done", "=", "self", ".", "done_buf", "[", "idxs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.__init__": [[61, 71], ["torch.distributions.Normal", "torch.distributions.Normal"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "normal_mean", ",", "normal_std", ",", "epsilon", "=", "1e-6", ")", ":", "\n", "        ", "\"\"\"\n        :param normal_mean: Mean of the normal distribution\n        :param normal_std: Std of the normal distribution\n        :param epsilon: Numerical stability epsilon when computing log-prob.\n        \"\"\"", "\n", "self", ".", "normal_mean", "=", "normal_mean", "\n", "self", ".", "normal_std", "=", "normal_std", "\n", "self", ".", "normal", "=", "Normal", "(", "normal_mean", ",", "normal_std", ")", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.log_prob": [[72, 86], ["core.TanhNormal.normal.log_prob", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.log_prob", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log"], ["", "def", "log_prob", "(", "self", ",", "value", ",", "pre_tanh_value", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        return the log probability of a value\n        :param value: some value, x\n        :param pre_tanh_value: arctanh(x)\n        :return:\n        \"\"\"", "\n", "# use arctanh formula to compute arctanh(value)", "\n", "if", "pre_tanh_value", "is", "None", ":", "\n", "            ", "pre_tanh_value", "=", "torch", ".", "log", "(", "\n", "(", "1", "+", "value", ")", "/", "(", "1", "-", "value", ")", "\n", ")", "/", "2", "\n", "", "return", "self", ".", "normal", ".", "log_prob", "(", "pre_tanh_value", ")", "-", "torch", ".", "log", "(", "1", "-", "value", "*", "value", "+", "self", ".", "epsilon", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.sample": [[87, 99], ["core.TanhNormal.normal.sample().detach", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "core.TanhNormal.normal.sample", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample"], ["", "def", "sample", "(", "self", ",", "return_pretanh_value", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Gradients will and should *not* pass through this operation.\n\n        See https://github.com/pytorch/pytorch/issues/4620 for discussion.\n        \"\"\"", "\n", "z", "=", "self", ".", "normal", ".", "sample", "(", ")", ".", "detach", "(", ")", "\n", "\n", "if", "return_pretanh_value", ":", "\n", "            ", "return", "torch", ".", "tanh", "(", "z", ")", ",", "z", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "tanh", "(", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.rsample": [[100, 135], ["torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.distributions.Normal().sample().cuda", "torch.distributions.Normal().sample().cuda", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.distributions.Normal().sample", "torch.distributions.Normal().sample", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.distributions.Normal().sample", "torch.distributions.Normal().sample", "torch.distributions.Normal", "torch.distributions.Normal", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.distributions.Normal", "torch.distributions.Normal", "core.TanhNormal.normal_mean.size", "core.TanhNormal.normal_std.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "core.TanhNormal.normal_mean.size", "core.TanhNormal.normal_std.size"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.ones"], ["", "", "def", "rsample", "(", "self", ",", "return_pretanh_value", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Sampling in the reparameterization case.\n        Implement: tanh(mu + sigma * eksee)\n        with eksee~N(0,1)\n        z here is mu+sigma+eksee\n        \"\"\"", "\n", "if", "self", ".", "normal_mean", ".", "is_cuda", ":", "\n", "            ", "z", "=", "(", "\n", "self", ".", "normal_mean", "+", "\n", "self", ".", "normal_std", "*", "\n", "Normal", "(", "## this part is eksee~N(0,1)", "\n", "torch", ".", "zeros", "(", "self", ".", "normal_mean", ".", "size", "(", ")", ")", ",", "\n", "torch", ".", "ones", "(", "self", ".", "normal_std", ".", "size", "(", ")", ")", "\n", ")", ".", "sample", "(", ")", ".", "cuda", "(", ")", "\n", ")", "\n", "\n", "if", "return_pretanh_value", ":", "\n", "                ", "return", "torch", ".", "tanh", "(", "z", ")", ",", "z", "\n", "", "else", ":", "\n", "                ", "return", "torch", ".", "tanh", "(", "z", ")", "\n", "", "", "else", ":", "\n", "            ", "z", "=", "(", "\n", "self", ".", "normal_mean", "+", "\n", "self", ".", "normal_std", "*", "\n", "Normal", "(", "## this part is eksee~N(0,1)", "\n", "torch", ".", "zeros", "(", "self", ".", "normal_mean", ".", "size", "(", ")", ")", ",", "\n", "torch", ".", "ones", "(", "self", ".", "normal_std", ".", "size", "(", ")", ")", "\n", ")", ".", "sample", "(", ")", "\n", ")", "\n", "\n", "if", "return_pretanh_value", ":", "\n", "                ", "return", "torch", ".", "tanh", "(", "z", ")", ",", "z", "\n", "", "else", ":", "\n", "                ", "return", "torch", ".", "tanh", "(", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.Mlp.__init__": [[149, 181], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "enumerate", "torch.Linear", "torch.Linear", "core.Mlp.last_fc_layer.weight.data.uniform_", "core.Mlp.last_fc_layer.bias.data.uniform_", "torch.Linear", "torch.Linear", "hidden_init", "torch.Linear.bias.data.fill_", "core.Mlp.hidden_layers.append"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_size", ",", "\n", "output_size", ",", "\n", "hidden_sizes", ",", "\n", "init_w", "=", "3e-3", ",", "\n", "hidden_activation", "=", "F", ".", "relu", ",", "\n", "hidden_init", "=", "fanin_init", ",", "\n", "b_init_value", "=", "0.1", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "hidden_activation", "=", "hidden_activation", "\n", "## here we use ModuleList so that the layers in it can be", "\n", "## detected by .parameters() call", "\n", "self", ".", "hidden_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "in_size", "=", "input_size", "\n", "\n", "## initialize each hidden layer", "\n", "for", "i", ",", "next_size", "in", "enumerate", "(", "hidden_sizes", ")", ":", "\n", "            ", "fc_layer", "=", "nn", ".", "Linear", "(", "in_size", ",", "next_size", ")", "\n", "in_size", "=", "next_size", "\n", "hidden_init", "(", "fc_layer", ".", "weight", ")", "\n", "fc_layer", ".", "bias", ".", "data", ".", "fill_", "(", "b_init_value", ")", "\n", "self", ".", "hidden_layers", ".", "append", "(", "fc_layer", ")", "\n", "\n", "## init last fully connected layer with small weight and bias", "\n", "", "self", ".", "last_fc_layer", "=", "nn", ".", "Linear", "(", "in_size", ",", "output_size", ")", "\n", "self", ".", "last_fc_layer", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "self", ".", "last_fc_layer", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.Mlp.forward": [[182, 189], ["enumerate", "core.Mlp.last_fc_layer", "fc_layer", "core.Mlp.hidden_activation"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "h", "=", "input", "\n", "for", "i", ",", "fc_layer", "in", "enumerate", "(", "self", ".", "hidden_layers", ")", ":", "\n", "            ", "h", "=", "fc_layer", "(", "h", ")", "\n", "h", "=", "self", ".", "hidden_activation", "(", "h", ")", "\n", "", "output", "=", "self", ".", "last_fc_layer", "(", "h", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhGaussianPolicy.__init__": [[191, 219], ["core.Mlp.__init__", "torch.Linear", "torch.Linear", "core.TanhGaussianPolicy.last_fc_log_std.weight.data.uniform_", "core.TanhGaussianPolicy.last_fc_log_std.bias.data.uniform_", "len"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "obs_dim", ",", "\n", "action_dim", ",", "\n", "hidden_sizes", ",", "\n", "init_w", "=", "1e-3", ",", "\n", "hidden_activation", "=", "F", ".", "relu", ",", "\n", "hidden_init", "=", "fanin_init", ",", "\n", "action_limit", "=", "1.0", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "input_size", "=", "obs_dim", ",", "\n", "output_size", "=", "action_dim", ",", "\n", "hidden_sizes", "=", "hidden_sizes", ",", "\n", "init_w", "=", "init_w", ",", "\n", "hidden_activation", "=", "hidden_activation", ",", "\n", "hidden_init", "=", "hidden_init", "\n", ")", "\n", "\n", "last_hidden_size", "=", "obs_dim", "\n", "if", "len", "(", "hidden_sizes", ")", ">", "0", ":", "\n", "            ", "last_hidden_size", "=", "hidden_sizes", "[", "-", "1", "]", "\n", "## this is the layer that gives log_std, init this layer with small weight and bias", "\n", "", "self", ".", "last_fc_log_std", "=", "nn", ".", "Linear", "(", "last_hidden_size", ",", "action_dim", ")", "\n", "self", ".", "last_fc_log_std", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "self", ".", "last_fc_log_std", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "## action limit: for example, humanoid has an action limit of -0.4 to 0.4", "\n", "self", ".", "action_limit", "=", "action_limit", "\n", "# def get_env_action(self, obs_np, action_limit, deterministic=False):", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhGaussianPolicy.get_env_action": [[235, 250], ["torch.Tensor().unsqueeze().to", "torch.Tensor().unsqueeze().to", "torch.Tensor().unsqueeze().to", "torch.Tensor().unsqueeze().to", "[].detach", "[].detach.cpu().numpy().reshape", "torch.Tensor().unsqueeze", "torch.Tensor().unsqueeze", "torch.Tensor().unsqueeze", "torch.Tensor().unsqueeze", "[].detach.cpu().numpy", "core.TanhGaussianPolicy.forward", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "[].detach.cpu"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward"], ["", "def", "get_env_action", "(", "self", ",", "obs_np", ",", "deterministic", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Get an action that can be used to forward one step in the environment\n        :param obs_np: observation got from environment, in numpy form\n        :param action_limit: for scaling the action from range (-1,1) to, for example, range (-3,3)\n        :param deterministic: if true then policy make a deterministic action, instead of sample an action\n        :return: action in numpy format, can be directly put into env.step()\n        \"\"\"", "\n", "## convert observations to pytorch tensors first", "\n", "## and then use the forward method", "\n", "obs_tensor", "=", "torch", ".", "Tensor", "(", "obs_np", ")", ".", "unsqueeze", "(", "0", ")", ".", "to", "(", "self", ".", "last_fc_layer", ".", "weight", ".", "device", ")", "\n", "action_tensor", "=", "self", ".", "forward", "(", "obs_tensor", ",", "deterministic", "=", "deterministic", ",", "return_log_prob", "=", "False", ")", "[", "0", "]", ".", "detach", "(", ")", "\n", "## convert action into the form that can put into the env and scale it", "\n", "action_np", "=", "action_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "return", "action_np", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhGaussianPolicy.forward": [[251, 301], ["core.TanhGaussianPolicy.last_fc_layer", "core.TanhGaussianPolicy.last_fc_log_std", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "core.TanhGaussianPolicy.hidden_activation", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "core.TanhNormal", "fc_layer", "core.TanhNormal.log_prob", "log_prob.sum.sum.sum", "core.TanhNormal.rsample", "core.TanhNormal.sample", "core.TanhNormal.rsample", "core.TanhNormal.sample"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.log_prob", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.rsample", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.rsample", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "obs", ",", "\n", "reparameterize", "=", "True", ",", "\n", "deterministic", "=", "False", ",", "\n", "return_log_prob", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param obs: Observation\n        :param reparameterize: if True, use the reparameterization trick\n        :param deterministic: If True, do not sample\n        :param return_log_prob: If True, return a sample and its log probability\n        \"\"\"", "\n", "h", "=", "obs", "\n", "for", "fc_layer", "in", "self", ".", "hidden_layers", ":", "\n", "            ", "h", "=", "self", ".", "hidden_activation", "(", "fc_layer", "(", "h", ")", ")", "\n", "", "mean", "=", "self", ".", "last_fc_layer", "(", "h", ")", "\n", "\n", "log_std", "=", "self", ".", "last_fc_log_std", "(", "h", ")", "\n", "log_std", "=", "torch", ".", "clamp", "(", "log_std", ",", "LOG_SIG_MIN", ",", "LOG_SIG_MAX", ")", "\n", "std", "=", "torch", ".", "exp", "(", "log_std", ")", "\n", "\n", "log_prob", "=", "None", "\n", "pre_tanh_value", "=", "None", "\n", "if", "deterministic", ":", "\n", "            ", "action", "=", "torch", ".", "tanh", "(", "mean", ")", "\n", "", "else", ":", "\n", "            ", "tanh_normal", "=", "TanhNormal", "(", "mean", ",", "std", ")", "\n", "if", "return_log_prob", ":", "\n", "                ", "if", "reparameterize", "is", "True", ":", "\n", "                    ", "action", ",", "pre_tanh_value", "=", "tanh_normal", ".", "rsample", "(", "## rsample means there is gradient", "\n", "return_pretanh_value", "=", "True", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "action", ",", "pre_tanh_value", "=", "tanh_normal", ".", "sample", "(", "## sample means there is no gradient", "\n", "return_pretanh_value", "=", "True", "\n", ")", "\n", "", "log_prob", "=", "tanh_normal", ".", "log_prob", "(", "\n", "action", ",", "\n", "pre_tanh_value", "=", "pre_tanh_value", "\n", ")", "\n", "log_prob", "=", "log_prob", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "if", "reparameterize", "is", "True", ":", "\n", "                    ", "action", "=", "tanh_normal", ".", "rsample", "(", ")", "\n", "", "else", ":", "\n", "                    ", "action", "=", "tanh_normal", ".", "sample", "(", ")", "\n", "\n", "", "", "", "return", "(", "\n", "action", "*", "self", ".", "action_limit", ",", "mean", ",", "log_std", ",", "log_prob", ",", "std", ",", "pre_tanh_value", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhGaussianPolicySACAdapt.__init__": [[316, 344], ["core.Mlp.__init__", "torch.Linear", "torch.Linear", "core.TanhGaussianPolicySACAdapt.last_fc_log_std.weight.data.uniform_", "core.TanhGaussianPolicySACAdapt.last_fc_log_std.bias.data.uniform_", "len"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "obs_dim", ",", "\n", "action_dim", ",", "\n", "hidden_sizes", ",", "\n", "init_w", "=", "1e-3", ",", "\n", "hidden_activation", "=", "F", ".", "relu", ",", "\n", "hidden_init", "=", "fanin_init", ",", "\n", "action_limit", "=", "1.0", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "input_size", "=", "obs_dim", ",", "\n", "output_size", "=", "action_dim", ",", "\n", "hidden_sizes", "=", "hidden_sizes", ",", "\n", "init_w", "=", "init_w", ",", "\n", "hidden_activation", "=", "hidden_activation", ",", "\n", "hidden_init", "=", "hidden_init", "\n", ")", "\n", "\n", "last_hidden_size", "=", "obs_dim", "\n", "if", "len", "(", "hidden_sizes", ")", ">", "0", ":", "\n", "            ", "last_hidden_size", "=", "hidden_sizes", "[", "-", "1", "]", "\n", "## this is the layer that gives log_std, init this layer with small weight and bias", "\n", "", "self", ".", "last_fc_log_std", "=", "nn", ".", "Linear", "(", "last_hidden_size", ",", "action_dim", ")", "\n", "self", ".", "last_fc_log_std", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "self", ".", "last_fc_log_std", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "init_w", ",", "init_w", ")", "\n", "## action limit: for example, humanoid has an action limit of -0.4 to 0.4", "\n", "self", ".", "action_limit", "=", "action_limit", "\n", "#", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhGaussianPolicySACAdapt.get_env_action": [[361, 377], ["torch.Tensor().unsqueeze", "torch.Tensor().unsqueeze", "torch.Tensor().unsqueeze", "torch.Tensor().unsqueeze", "[].detach", "[].detach.numpy().reshape", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "[].detach.numpy", "core.TanhGaussianPolicySACAdapt.forward"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward"], ["", "def", "get_env_action", "(", "self", ",", "obs_np", ",", "deterministic", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Get an action that can be used to forward one step in the environment\n        :param obs_np: observation got from environment, in numpy form\n        :param action_limit: for scaling the action from range (-1,1) to, for example, range (-3,3)\n        :param deterministic: if true then policy make a deterministic action, instead of sample an action\n        :return: action in numpy format, can be directly put into env.step()\n        \"\"\"", "\n", "## convert observations to pytorch tensors first", "\n", "## and then use the forward method", "\n", "obs_tensor", "=", "torch", ".", "Tensor", "(", "obs_np", ")", ".", "unsqueeze", "(", "0", ")", "\n", "action_tensor", "=", "self", ".", "forward", "(", "obs_tensor", ",", "deterministic", "=", "deterministic", ",", "\n", "return_log_prob", "=", "False", ")", "[", "0", "]", ".", "detach", "(", ")", "\n", "## convert action into the form that can put into the env and scale it", "\n", "action_np", "=", "action_tensor", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "return", "action_np", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhGaussianPolicySACAdapt.forward": [[378, 417], ["core.TanhGaussianPolicySACAdapt.last_fc_layer", "core.TanhGaussianPolicySACAdapt.last_fc_log_std", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.distributions.Normal", "torch.distributions.Normal", "core.TanhGaussianPolicySACAdapt.hidden_activation", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.distributions.Normal.rsample", "torch.distributions.Normal.rsample", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.distributions.Normal.log_prob", "torch.distributions.Normal.log_prob", "torch.log", "torch.log", "torch.log", "torch.log", "log_prob.sum.sum.sum", "fc_layer", "torch.tanh.pow", "torch.tanh.pow"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.rsample", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.rsample", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.log_prob", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhNormal.log_prob", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.log", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "obs", ",", "\n", "deterministic", "=", "False", ",", "\n", "return_log_prob", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param obs: Observation\n        :param reparameterize: if True, use the reparameterization trick\n        :param deterministic: If True, do not sample\n        :param return_log_prob: If True, return a sample and its log probability\n        \"\"\"", "\n", "h", "=", "obs", "\n", "for", "fc_layer", "in", "self", ".", "hidden_layers", ":", "\n", "            ", "h", "=", "self", ".", "hidden_activation", "(", "fc_layer", "(", "h", ")", ")", "\n", "", "mean", "=", "self", ".", "last_fc_layer", "(", "h", ")", "\n", "\n", "log_std", "=", "self", ".", "last_fc_log_std", "(", "h", ")", "\n", "log_std", "=", "torch", ".", "clamp", "(", "log_std", ",", "LOG_SIG_MIN", ",", "LOG_SIG_MAX", ")", "\n", "std", "=", "torch", ".", "exp", "(", "log_std", ")", "\n", "\n", "normal", "=", "Normal", "(", "mean", ",", "std", ")", "\n", "\n", "if", "deterministic", ":", "\n", "            ", "pre_tanh_value", "=", "mean", "\n", "action", "=", "torch", ".", "tanh", "(", "mean", ")", "\n", "", "else", ":", "\n", "            ", "pre_tanh_value", "=", "normal", ".", "rsample", "(", ")", "\n", "action", "=", "torch", ".", "tanh", "(", "pre_tanh_value", ")", "\n", "\n", "", "if", "return_log_prob", ":", "\n", "            ", "log_prob", "=", "normal", ".", "log_prob", "(", "pre_tanh_value", ")", "\n", "log_prob", "-=", "torch", ".", "log", "(", "1", "-", "action", ".", "pow", "(", "2", ")", "+", "ACTION_BOUND_EPSILON", ")", "\n", "log_prob", "=", "log_prob", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "log_prob", "=", "None", "\n", "\n", "", "return", "(", "\n", "action", "*", "self", ".", "action_limit", ",", "mean", ",", "log_std", ",", "log_prob", ",", "std", ",", "pre_tanh_value", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.fanin_init": [[136, 147], ["tensor.size", "tensor.data.uniform_", "len", "numpy.sqrt", "len", "numpy.prod", "Exception"], "function", ["None"], ["", "", "", "", "def", "fanin_init", "(", "tensor", ")", ":", "\n", "## used to initialize hidden layers in MLP", "\n", "    ", "size", "=", "tensor", ".", "size", "(", ")", "\n", "if", "len", "(", "size", ")", "==", "2", ":", "\n", "        ", "fan_in", "=", "size", "[", "0", "]", "\n", "", "elif", "len", "(", "size", ")", ">", "2", ":", "\n", "        ", "fan_in", "=", "np", ".", "prod", "(", "size", "[", "1", ":", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Shape must be have dimension at least 2.\"", ")", "\n", "", "bound", "=", "1.", "/", "np", ".", "sqrt", "(", "fan_in", ")", "\n", "return", "tensor", ".", "data", ".", "uniform_", "(", "-", "bound", ",", "bound", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.soft_update_model1_with_model2": [[419, 429], ["zip", "model1.parameters", "model2.parameters", "model1_param.data.copy_"], "function", ["None"], ["", "", "def", "soft_update_model1_with_model2", "(", "model1", ",", "model2", ",", "rou", ")", ":", "\n", "    ", "\"\"\"\n    see openai spinup sac psudocode line 16, used to update target_value_net\n    :param model1: a pytorch model\n    :param model2: a pytorch model of the same class\n    :param rou: the update is model1 <- rou*model1 + (1-rou)model2\n    \"\"\"", "\n", "for", "model1_param", ",", "model2_param", "in", "zip", "(", "model1", ".", "parameters", "(", ")", ",", "model2", ".", "parameters", "(", ")", ")", ":", "\n", "        ", "model1_param", ".", "data", ".", "copy_", "(", "\n", "rou", "*", "model1_param", ".", "data", "+", "(", "1", "-", "rou", ")", "*", "model2_param", ".", "data", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.sac_adapt.sac_adapt": [[20, 469], ["int", "dict", "spinup.utils.logx.EpochLogger", "spinup.utils.logx.EpochLogger.save_config", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "numpy.random.seed", "env.seed", "env.action_space.np_random.seed", "test_env.seed", "test_env.action_space.np_random.seed", "env.action_space.high[].item", "spinup.algos.sac_pytorch.core_auto.ReplayBuffer", "time.time", "spinup.algos.sac_pytorch.core_auto.TanhGaussianPolicySACAdapt", "spinup.algos.sac_pytorch.core_auto.Mlp", "spinup.algos.sac_pytorch.core_auto.Mlp", "spinup.algos.sac_pytorch.core_auto.Mlp", "spinup.algos.sac_pytorch.core_auto.Mlp", "spinup.algos.sac_pytorch.core_auto.Mlp.load_state_dict", "spinup.algos.sac_pytorch.core_auto.Mlp.load_state_dict", "torch.Adam", "torch.Adam", "torch.Adam", "torch.MSELoss", "range", "locals", "env_fn", "env_fn", "torch.zeros", "torch.zeros", "torch.zeros", "torch.Adam", "numpy.zeros", "range", "env.reset", "spinup.algos.sac_pytorch.core_auto.Mlp.state_dict", "spinup.algos.sac_pytorch.core_auto.Mlp.state_dict", "spinup.algos.sac_pytorch.core_auto.TanhGaussianPolicySACAdapt.parameters", "spinup.algos.sac_pytorch.core_auto.Mlp.parameters", "spinup.algos.sac_pytorch.core_auto.Mlp.parameters", "env.step", "spinup.algos.sac_pytorch.core_auto.ReplayBuffer.store", "numpy.prod().item", "spinup.utils.logx.EpochLogger.store", "spinup.algos.sac_pytorch.core_auto.TanhGaussianPolicySACAdapt.get_env_action", "env.action_space.sample", "spinup.algos.sac_pytorch.core_auto.ReplayBuffer.sample_batch", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor().unsqueeze", "torch.Tensor().unsqueeze", "spinup.algos.sac_pytorch.core_auto.Mlp.", "nn.MSELoss.", "spinup.algos.sac_pytorch.core_auto.Mlp.", "nn.MSELoss.", "spinup.algos.sac_pytorch.core_auto.TanhGaussianPolicySACAdapt.forward", "spinup.algos.sac_pytorch.core_auto.Mlp.", "spinup.algos.sac_pytorch.core_auto.Mlp.", "torch.min", "torch.min", "torch.min", "optim.Adam.zero_grad", "mse_criterion.backward", "optim.Adam.step", "optim.Adam.zero_grad", "mse_criterion.backward", "optim.Adam.step", "optim.Adam.zero_grad", "policy_loss.backward", "optim.Adam.step", "spinup.algos.sac_pytorch.core_auto.soft_update_model1_with_model2", "spinup.algos.sac_pytorch.core_auto.soft_update_model1_with_model2", "spinup.utils.logx.EpochLogger.store", "range", "spinup.utils.logx.EpochLogger.store", "sac_adapt.sac_adapt.test_agent"], "function", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.logx.Logger.save_config", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.TanhGaussianPolicySACAdapt.get_env_action", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.sample_batch", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.soft_update_model1_with_model2", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.soft_update_model1_with_model2", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store", "home.repos.pwc.inspect_result.lanyavik_BAIL.sac_pytorch.core.ReplayBuffer.store"], ["def", "sac_adapt", "(", "env_fn", ",", "Env_Name", ",", "hidden_sizes", "=", "[", "256", ",", "256", "]", ",", "seed", "=", "0", ",", "#buffer_size = int(1e6),", "\n", "steps_per_epoch", "=", "5000", ",", "epochs", "=", "100", ",", "replay_size", "=", "int", "(", "1e6", ")", ",", "gamma", "=", "0.99", ",", "\n", "polyak", "=", "0.995", ",", "lr", "=", "3e-4", ",", "alpha", "=", "0.2", ",", "batch_size", "=", "256", ",", "start_steps", "=", "10000", ",", "\n", "max_ep_len", "=", "1000", ",", "save_freq", "=", "1", ",", "dont_save", "=", "True", ",", "regularization_weight", "=", "1e-3", ",", "\n", "auto_alpha", "=", "True", ",", "grad_clip", "=", "-", "1", ",", "use_one_step_version", "=", "False", ",", "\n", "logger_kwargs", "=", "dict", "(", ")", ",", ")", ":", "\n", "    ", "\"\"\"\n    Largely following OpenAI documentation\n    But slightly different from tensorflow implementation\n    Args:\n        env_fn : A function which creates a copy of the environment.\n            The environment must satisfy the OpenAI Gym API.\n\n        hidden_sizes: number of entries is number of hidden layers\n            each entry in this list indicate the size of that hidden layer.\n            applies to all networks\n\n        seed (int): Seed for random number generators.\n\n        steps_per_epoch (int): Number of steps of interaction (state-action pairs)\n            for the agent and the environment in each epoch. Note the epoch here is just logging epoch\n            so every this many steps a logging to stdouot and also output file will happen\n            note: not to be confused with training epoch which is a term used often in literature for all kinds of\n            different things\n\n        epochs (int): Number of epochs to run and train agent. Usage of this term can be different in different\n            algorithms, use caution. Here every epoch you get new logs\n\n        replay_size (int): Maximum length of replay buffer.\n\n        gamma (float): Discount factor. (Always between 0 and 1.)\n\n        polyak (float): Interpolation factor in polyak averaging for target\n            networks. Target networks are updated towards main networks\n            according to:\n\n            .. math:: \\\\theta_{\\\\text{targ}} \\\\leftarrow\n                \\\\rho \\\\theta_{\\\\text{targ}} + (1-\\\\rho) \\\\theta\n\n            where :math:`\\\\rho` is polyak. (Always between 0 and 1, usually\n            close to 1.)\n\n        lr (float): Learning rate (used for both policy and value learning).\n\n        alpha (float): Entropy regularization coefficient. (Equivalent to\n            inverse of reward scale in the original SAC paper.)\n\n        batch_size (int): Minibatch size for SGD.\n\n        start_steps (int): Number of steps for uniform-random action selection,\n            before running real policy. Helps exploration. However during testing the action always come from policy\n\n        max_ep_len (int): Maximum length of trajectory / episode / rollout. Environment will get reseted if\n        timestep in an episode excedding this number\n\n        save_freq (int): How often (in terms of gap between epochs) to save\n            the current policy and value function.\n\n        logger_kwargs (dict): Keyword args for EpochLogger.\n\n    \"\"\"", "\n", "\n", "\"\"\"set up logger\"\"\"", "\n", "logger", "=", "EpochLogger", "(", "**", "logger_kwargs", ")", "\n", "logger", ".", "save_config", "(", "locals", "(", ")", ")", "\n", "\n", "env", ",", "test_env", "=", "env_fn", "(", ")", ",", "env_fn", "(", ")", "\n", "\n", "## seed torch and numpy", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "## seed environment along with env action space so that everything about env is seeded", "\n", "env", ".", "seed", "(", "seed", ")", "\n", "env", ".", "action_space", ".", "np_random", ".", "seed", "(", "seed", ")", "\n", "test_env", ".", "seed", "(", "seed", ")", "\n", "test_env", ".", "action_space", ".", "np_random", ".", "seed", "(", "seed", ")", "\n", "\n", "obs_dim", "=", "env", ".", "observation_space", ".", "shape", "[", "0", "]", "\n", "act_dim", "=", "env", ".", "action_space", ".", "shape", "[", "0", "]", "\n", "\n", "# if environment has a smaller max episode length, then use the environment's max episode length", "\n", "max_ep_len", "=", "env", ".", "_max_episode_steps", "if", "max_ep_len", ">", "env", ".", "_max_episode_steps", "else", "max_ep_len", "\n", "\n", "# Action limit for clamping: critically, assumes all dimensions share the same bound!", "\n", "# we need .item() to convert it from numpy float to python float", "\n", "act_limit", "=", "env", ".", "action_space", ".", "high", "[", "0", "]", ".", "item", "(", ")", "\n", "\n", "# Experience buffer", "\n", "replay_buffer", "=", "ReplayBuffer", "(", "obs_dim", "=", "obs_dim", ",", "act_dim", "=", "act_dim", ",", "size", "=", "replay_size", ")", "\n", "\n", "\"\"\"\n    Auto tuning alpha\n    \"\"\"", "\n", "if", "auto_alpha", ":", "\n", "        ", "target_entropy", "=", "-", "np", ".", "prod", "(", "env", ".", "action_space", ".", "shape", ")", ".", "item", "(", ")", "# H", "\n", "log_alpha", "=", "torch", ".", "zeros", "(", "1", ",", "requires_grad", "=", "True", ")", "\n", "alpha_optim", "=", "optim", ".", "Adam", "(", "[", "log_alpha", "]", ",", "lr", "=", "lr", ")", "\n", "", "else", ":", "\n", "        ", "target_entropy", ",", "log_alpha", ",", "alpha_optim", "=", "None", ",", "None", ",", "None", "\n", "\n", "", "def", "test_agent", "(", "n", "=", "10", ")", ":", "\n", "        ", "\"\"\"\n        This will test the agent's performance by running n episodes\n        During the runs, the agent only take deterministic action, so the\n        actions are not drawn from a distribution, but just use the mean\n        :param n: number of episodes to run the agent\n        \"\"\"", "\n", "ep_return_list", "=", "np", ".", "zeros", "(", "n", ")", "\n", "for", "j", "in", "range", "(", "n", ")", ":", "\n", "            ", "o", ",", "r", ",", "d", ",", "ep_ret", ",", "ep_len", "=", "test_env", ".", "reset", "(", ")", ",", "0", ",", "False", ",", "0", ",", "0", "\n", "while", "not", "d", ":", "\n", "# Take deterministic actions at test time", "\n", "                ", "a", "=", "policy_net", ".", "get_env_action", "(", "o", ",", "deterministic", "=", "True", ")", "\n", "o", ",", "r", ",", "d", ",", "_", "=", "test_env", ".", "step", "(", "a", ")", "\n", "ep_ret", "+=", "r", "\n", "#               ep_len += 1", "\n", "", "ep_return_list", "[", "j", "]", "=", "ep_ret", "\n", "logger", ".", "store", "(", "TestEpRet", "=", "ep_ret", ",", "TestEpLen", "=", "ep_len", ")", "\n", "\n", "", "", "start_time", "=", "time", ".", "time", "(", ")", "\n", "o", ",", "r", ",", "d", ",", "ep_ret", ",", "ep_len", "=", "env", ".", "reset", "(", ")", ",", "0", ",", "False", ",", "0", ",", "0", "\n", "total_steps", "=", "steps_per_epoch", "*", "epochs", "\n", "\n", "\"\"\"init all networks\"\"\"", "\n", "# see line 1", "\n", "policy_net", "=", "TanhGaussianPolicySACAdapt", "(", "obs_dim", ",", "act_dim", ",", "hidden_sizes", ",", "action_limit", "=", "act_limit", ")", "\n", "q1_net", "=", "Mlp", "(", "obs_dim", "+", "act_dim", ",", "1", ",", "hidden_sizes", ")", "\n", "q2_net", "=", "Mlp", "(", "obs_dim", "+", "act_dim", ",", "1", ",", "hidden_sizes", ")", "\n", "\n", "q1_target_net", "=", "Mlp", "(", "obs_dim", "+", "act_dim", ",", "1", ",", "hidden_sizes", ")", "\n", "q2_target_net", "=", "Mlp", "(", "obs_dim", "+", "act_dim", ",", "1", ",", "hidden_sizes", ")", "\n", "\n", "# see line 2: copy parameters from value_net to target_value_net", "\n", "q1_target_net", ".", "load_state_dict", "(", "q1_net", ".", "state_dict", "(", ")", ")", "\n", "q2_target_net", ".", "load_state_dict", "(", "q2_net", ".", "state_dict", "(", ")", ")", "\n", "\n", "# set up optimizers", "\n", "policy_optimizer", "=", "optim", ".", "Adam", "(", "policy_net", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "q1_optimizer", "=", "optim", ".", "Adam", "(", "q1_net", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "q2_optimizer", "=", "optim", ".", "Adam", "(", "q2_net", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n", "# mean squared error loss for v and q networks", "\n", "mse_criterion", "=", "nn", ".", "MSELoss", "(", ")", "\n", "\n", "# Main loop: collect experience in env and update/log each epoch", "\n", "# NOTE: t here is the current number of total timesteps used", "\n", "# it is not the number of timesteps passed in the current episode", "\n", "for", "t", "in", "range", "(", "total_steps", ")", ":", "\n", "        ", "\"\"\"\n        Until start_steps have elapsed, randomly sample actions\n        from a uniform distribution for better exploration. Afterwards, \n        use the learned policy. \n        \"\"\"", "\n", "if", "t", ">", "start_steps", ":", "\n", "            ", "a", "=", "policy_net", ".", "get_env_action", "(", "o", ",", "deterministic", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "a", "=", "env", ".", "action_space", ".", "sample", "(", ")", "\n", "# Step the env, get next observation, reward and done signal", "\n", "", "o2", ",", "r", ",", "d", ",", "_", "=", "env", ".", "step", "(", "a", ")", "\n", "ep_ret", "+=", "r", "\n", "ep_len", "+=", "1", "\n", "\n", "# Ignore the \"done\" signal if it comes from hitting the time", "\n", "# horizon (that is, when it's an artificial terminal signal", "\n", "# that isn't based on the agent's state)", "\n", "d", "=", "False", "if", "ep_len", "==", "max_ep_len", "else", "d", "\n", "\n", "# Store experience (observation, action, reward, next observation, done) to replay buffer", "\n", "replay_buffer", ".", "store", "(", "o", ",", "a", ",", "r", ",", "o2", ",", "d", ")", "\n", "\n", "#         if t >= buffer_size:", "\n", "#             save_buffer(replay_buffer, Env_Name, seed)", "\n", "#             break", "\n", "\n", "\"\"\"\n        one data one update part\n        \"\"\"", "\n", "if", "use_one_step_version", "and", "replay_buffer", ".", "size", ">=", "batch_size", ":", "\n", "# get data from replay buffer", "\n", "            ", "batch", "=", "replay_buffer", ".", "sample_batch", "(", "batch_size", ")", "\n", "obs_tensor", "=", "Tensor", "(", "batch", "[", "'obs1'", "]", ")", "\n", "obs_next_tensor", "=", "Tensor", "(", "batch", "[", "'obs2'", "]", ")", "\n", "acts_tensor", "=", "Tensor", "(", "batch", "[", "'acts'", "]", ")", "\n", "# unsqueeze is to make sure rewards and done tensors are of the shape nx1, instead of n", "\n", "# to prevent problems later", "\n", "rews_tensor", "=", "Tensor", "(", "batch", "[", "'rews'", "]", ")", ".", "unsqueeze", "(", "1", ")", "\n", "done_tensor", "=", "Tensor", "(", "batch", "[", "'done'", "]", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "\"\"\"\n            now we do a SAC update, following the OpenAI spinup doc\n            check the openai sac document psudocode part for reference\n            line nubmers indicate lines in psudocode part\n            we will first compute each of the losses\n            and then update all the networks in the end\n            \"\"\"", "\n", "# see line 12: get a_tilda, which is newly sampled action (not action from replay buffer)", "\n", "\n", "\"\"\"get q loss\"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "a_tilda_next", ",", "_", ",", "_", ",", "log_prob_a_tilda_next", ",", "_", ",", "_", "=", "policy_net", ".", "forward", "(", "obs_next_tensor", ")", "\n", "q1_next", "=", "q1_target_net", "(", "torch", ".", "cat", "(", "[", "obs_next_tensor", ",", "a_tilda_next", "]", ",", "1", ")", ")", "\n", "q2_next", "=", "q2_target_net", "(", "torch", ".", "cat", "(", "[", "obs_next_tensor", ",", "a_tilda_next", "]", ",", "1", ")", ")", "\n", "\n", "min_next_q", "=", "torch", ".", "min", "(", "q1_next", ",", "q2_next", ")", "-", "alpha", "*", "log_prob_a_tilda_next", "\n", "y_q", "=", "rews_tensor", "+", "gamma", "*", "(", "1", "-", "done_tensor", ")", "*", "min_next_q", "\n", "\n", "# JQ = \ud835\udd3c(st,at)~D[0.5(Q1(st,at) - r(st,at) - \u03b3(\ud835\udd3cst+1~p[V(st+1)]))^2]", "\n", "", "q1_prediction", "=", "q1_net", "(", "torch", ".", "cat", "(", "[", "obs_tensor", ",", "acts_tensor", "]", ",", "1", ")", ")", "\n", "q1_loss", "=", "mse_criterion", "(", "q1_prediction", ",", "y_q", ")", "\n", "q2_prediction", "=", "q2_net", "(", "torch", ".", "cat", "(", "[", "obs_tensor", ",", "acts_tensor", "]", ",", "1", ")", ")", "\n", "q2_loss", "=", "mse_criterion", "(", "q2_prediction", ",", "y_q", ")", "\n", "\n", "\"\"\"\n            get policy loss\n            \"\"\"", "\n", "a_tilda", ",", "mean_a_tilda", ",", "log_std_a_tilda", ",", "log_prob_a_tilda", ",", "_", ",", "_", "=", "policy_net", ".", "forward", "(", "obs_tensor", ")", "\n", "\n", "# see line 12: second equation", "\n", "q1_a_tilda", "=", "q1_net", "(", "torch", ".", "cat", "(", "[", "obs_tensor", ",", "a_tilda", "]", ",", "1", ")", ")", "\n", "q2_a_tilda", "=", "q2_net", "(", "torch", ".", "cat", "(", "[", "obs_tensor", ",", "a_tilda", "]", ",", "1", ")", ")", "\n", "min_q1_q2_a_tilda", "=", "torch", ".", "min", "(", "q1_a_tilda", ",", "q2_a_tilda", ")", "\n", "\n", "# J\u03c0 = \ud835\udd3cst\u223cD,\u03b5t\u223cN[\u03b1 * log\u03c0(f(\u03b5t;st)|st) \u2212 Q(st,f(\u03b5t;st))]", "\n", "policy_loss", "=", "(", "alpha", "*", "log_prob_a_tilda", "-", "min_q1_q2_a_tilda", ")", ".", "mean", "(", ")", "\n", "\n", "\"\"\"\n            add policy regularization loss, this is not in openai's minimal version, but\n            they are in the original sac code, see https://github.com/vitchyr/rlkit for reference\n            this part is not necessary but might improve performance\n            NO LONGER USE REGULARIZATION IN SAC ADAPT, rlkit also removed this now\n            \"\"\"", "\n", "# policy_mean_reg_weight = regularization_weight", "\n", "# policy_std_reg_weight = regularization_weight", "\n", "# mean_reg_loss = policy_mean_reg_weight * (mean_a_tilda ** 2).mean()", "\n", "# std_reg_loss = policy_std_reg_weight * (log_std_a_tilda ** 2).mean()", "\n", "# policy_loss = policy_loss + mean_reg_loss + std_reg_loss", "\n", "\n", "\"\"\"\n            alpha loss, update alpha\n            \"\"\"", "\n", "if", "auto_alpha", ":", "\n", "                ", "alpha_loss", "=", "-", "(", "log_alpha", "*", "(", "log_prob_a_tilda", "+", "target_entropy", ")", ".", "detach", "(", ")", ")", ".", "mean", "(", ")", "\n", "\n", "alpha_optim", ".", "zero_grad", "(", ")", "\n", "alpha_loss", ".", "backward", "(", ")", "\n", "if", "grad_clip", ">", "0", ":", "\n", "                    ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "log_alpha", ",", "grad_clip", ")", "\n", "", "alpha_optim", ".", "step", "(", ")", "\n", "\n", "alpha", "=", "log_alpha", ".", "exp", "(", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "                ", "alpha_loss", "=", "0", "\n", "\n", "", "\"\"\"update networks\"\"\"", "\n", "q1_optimizer", ".", "zero_grad", "(", ")", "\n", "q1_loss", ".", "backward", "(", ")", "\n", "if", "grad_clip", ">", "0", ":", "\n", "                ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "q1_net", ".", "parameters", "(", ")", ",", "grad_clip", ")", "\n", "", "q1_optimizer", ".", "step", "(", ")", "\n", "\n", "q2_optimizer", ".", "zero_grad", "(", ")", "\n", "q2_loss", ".", "backward", "(", ")", "\n", "if", "grad_clip", ">", "0", ":", "\n", "                ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "q2_net", ".", "parameters", "(", ")", ",", "grad_clip", ")", "\n", "", "q2_optimizer", ".", "step", "(", ")", "\n", "\n", "policy_optimizer", ".", "zero_grad", "(", ")", "\n", "policy_loss", ".", "backward", "(", ")", "\n", "if", "grad_clip", ">", "0", ":", "\n", "                ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "policy_net", ".", "parameters", "(", ")", ",", "grad_clip", ")", "\n", "", "policy_optimizer", ".", "step", "(", ")", "\n", "\n", "# see line 16: update target value network with value network", "\n", "soft_update_model1_with_model2", "(", "q1_target_net", ",", "q1_net", ",", "polyak", ")", "\n", "soft_update_model1_with_model2", "(", "q2_target_net", ",", "q2_net", ",", "polyak", ")", "\n", "\n", "# store diagnostic info to logger", "\n", "logger", ".", "store", "(", "LossPi", "=", "policy_loss", ".", "item", "(", ")", ",", "LossQ1", "=", "q1_loss", ".", "item", "(", ")", ",", "LossQ2", "=", "q2_loss", ".", "item", "(", ")", ",", "\n", "LossAlpha", "=", "alpha_loss", ".", "item", "(", ")", ",", "\n", "Q1Vals", "=", "q1_prediction", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "Q2Vals", "=", "q2_prediction", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "Alpha", "=", "alpha", ",", "\n", "LogPi", "=", "log_prob_a_tilda", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "# Super critical, easy to overlook step: make sure to update", "\n", "# most recent observation!", "\n", "", "o", "=", "o2", "\n", "if", "d", "or", "(", "ep_len", "==", "max_ep_len", ")", ":", "\n", "            ", "\"\"\"\n            Perform all SAC updates at the end of the trajectory.\n            This is a slight difference from the SAC specified in the\n            original paper.\n            Quoted from the original SAC paper: 'In practice, we take a single environment step\n            followed by one or several gradient step' after a single environment step,\n            the number of gradient steps is 1 for SAC. (see paper for reference)\n            \"\"\"", "\n", "for", "j", "in", "range", "(", "ep_len", ")", ":", "\n", "                ", "if", "use_one_step_version", ":", "\n", "                    ", "break", "\n", "# get data from replay buffer", "\n", "", "batch", "=", "replay_buffer", ".", "sample_batch", "(", "batch_size", ")", "\n", "obs_tensor", "=", "Tensor", "(", "batch", "[", "'obs1'", "]", ")", "\n", "obs_next_tensor", "=", "Tensor", "(", "batch", "[", "'obs2'", "]", ")", "\n", "acts_tensor", "=", "Tensor", "(", "batch", "[", "'acts'", "]", ")", "\n", "# unsqueeze is to make sure rewards and done tensors are of the shape nx1, instead of n", "\n", "# to prevent problems later", "\n", "rews_tensor", "=", "Tensor", "(", "batch", "[", "'rews'", "]", ")", ".", "unsqueeze", "(", "1", ")", "\n", "done_tensor", "=", "Tensor", "(", "batch", "[", "'done'", "]", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "\"\"\"\n                now we do a SAC update, following the OpenAI spinup doc\n                check the openai sac document psudocode part for reference\n                line nubmers indicate lines in psudocode part\n                we will first compute each of the losses\n                and then update all the networks in the end\n                \"\"\"", "\n", "# see line 12: get a_tilda, which is newly sampled action (not action from replay buffer)", "\n", "\n", "\"\"\"get q loss\"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "a_tilda_next", ",", "_", ",", "_", ",", "log_prob_a_tilda_next", ",", "_", ",", "_", "=", "policy_net", ".", "forward", "(", "obs_next_tensor", ")", "\n", "q1_next", "=", "q1_target_net", "(", "torch", ".", "cat", "(", "[", "obs_next_tensor", ",", "a_tilda_next", "]", ",", "1", ")", ")", "\n", "q2_next", "=", "q2_target_net", "(", "torch", ".", "cat", "(", "[", "obs_next_tensor", ",", "a_tilda_next", "]", ",", "1", ")", ")", "\n", "\n", "min_next_q", "=", "torch", ".", "min", "(", "q1_next", ",", "q2_next", ")", "-", "alpha", "*", "log_prob_a_tilda_next", "\n", "y_q", "=", "rews_tensor", "+", "gamma", "*", "(", "1", "-", "done_tensor", ")", "*", "min_next_q", "\n", "\n", "# JQ = \ud835\udd3c(st,at)~D[0.5(Q1(st,at) - r(st,at) - \u03b3(\ud835\udd3cst+1~p[V(st+1)]))^2]", "\n", "", "q1_prediction", "=", "q1_net", "(", "torch", ".", "cat", "(", "[", "obs_tensor", ",", "acts_tensor", "]", ",", "1", ")", ")", "\n", "q1_loss", "=", "mse_criterion", "(", "q1_prediction", ",", "y_q", ")", "\n", "q2_prediction", "=", "q2_net", "(", "torch", ".", "cat", "(", "[", "obs_tensor", ",", "acts_tensor", "]", ",", "1", ")", ")", "\n", "q2_loss", "=", "mse_criterion", "(", "q2_prediction", ",", "y_q", ")", "\n", "\n", "\"\"\"\n                get policy loss\n                \"\"\"", "\n", "a_tilda", ",", "mean_a_tilda", ",", "log_std_a_tilda", ",", "log_prob_a_tilda", ",", "_", ",", "_", "=", "policy_net", ".", "forward", "(", "obs_tensor", ")", "\n", "\n", "# see line 12: second equation", "\n", "q1_a_tilda", "=", "q1_net", "(", "torch", ".", "cat", "(", "[", "obs_tensor", ",", "a_tilda", "]", ",", "1", ")", ")", "\n", "q2_a_tilda", "=", "q2_net", "(", "torch", ".", "cat", "(", "[", "obs_tensor", ",", "a_tilda", "]", ",", "1", ")", ")", "\n", "min_q1_q2_a_tilda", "=", "torch", ".", "min", "(", "q1_a_tilda", ",", "q2_a_tilda", ")", "\n", "\n", "# J\u03c0 = \ud835\udd3cst\u223cD,\u03b5t\u223cN[\u03b1 * log\u03c0(f(\u03b5t;st)|st) \u2212 Q(st,f(\u03b5t;st))]", "\n", "policy_loss", "=", "(", "alpha", "*", "log_prob_a_tilda", "-", "min_q1_q2_a_tilda", ")", ".", "mean", "(", ")", "\n", "\n", "\"\"\"\n                add policy regularization loss, this is not in openai's minimal version, but\n                they are in the original sac code, see https://github.com/vitchyr/rlkit for reference\n                this part is not necessary but might improve performance\n                NO LONGER USE REGULARIZATION IN SAC ADAPT, rlkit also removed this now\n                \"\"\"", "\n", "# policy_mean_reg_weight = regularization_weight", "\n", "# policy_std_reg_weight = regularization_weight", "\n", "# mean_reg_loss = policy_mean_reg_weight * (mean_a_tilda ** 2).mean()", "\n", "# std_reg_loss = policy_std_reg_weight * (log_std_a_tilda ** 2).mean()", "\n", "# policy_loss = policy_loss + mean_reg_loss + std_reg_loss", "\n", "\n", "\"\"\"\n                alpha loss, update alpha\n                \"\"\"", "\n", "if", "auto_alpha", ":", "\n", "                    ", "alpha_loss", "=", "-", "(", "log_alpha", "*", "(", "log_prob_a_tilda", "+", "target_entropy", ")", ".", "detach", "(", ")", ")", ".", "mean", "(", ")", "\n", "\n", "alpha_optim", ".", "zero_grad", "(", ")", "\n", "alpha_loss", ".", "backward", "(", ")", "\n", "if", "grad_clip", ">", "0", ":", "\n", "                        ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "log_alpha", ",", "grad_clip", ")", "\n", "", "alpha_optim", ".", "step", "(", ")", "\n", "\n", "alpha", "=", "log_alpha", ".", "exp", "(", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "                    ", "alpha_loss", "=", "0", "\n", "\n", "", "\"\"\"update networks\"\"\"", "\n", "q1_optimizer", ".", "zero_grad", "(", ")", "\n", "q1_loss", ".", "backward", "(", ")", "\n", "if", "grad_clip", ">", "0", ":", "\n", "                    ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "q1_net", ".", "parameters", "(", ")", ",", "grad_clip", ")", "\n", "", "q1_optimizer", ".", "step", "(", ")", "\n", "\n", "q2_optimizer", ".", "zero_grad", "(", ")", "\n", "q2_loss", ".", "backward", "(", ")", "\n", "if", "grad_clip", ">", "0", ":", "\n", "                    ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "q2_net", ".", "parameters", "(", ")", ",", "grad_clip", ")", "\n", "", "q2_optimizer", ".", "step", "(", ")", "\n", "\n", "policy_optimizer", ".", "zero_grad", "(", ")", "\n", "policy_loss", ".", "backward", "(", ")", "\n", "if", "grad_clip", ">", "0", ":", "\n", "                    ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "policy_net", ".", "parameters", "(", ")", ",", "grad_clip", ")", "\n", "", "policy_optimizer", ".", "step", "(", ")", "\n", "\n", "# see line 16: update target value network with value network", "\n", "soft_update_model1_with_model2", "(", "q1_target_net", ",", "q1_net", ",", "polyak", ")", "\n", "soft_update_model1_with_model2", "(", "q2_target_net", ",", "q2_net", ",", "polyak", ")", "\n", "\n", "# store diagnostic info to logger", "\n", "logger", ".", "store", "(", "LossPi", "=", "policy_loss", ".", "item", "(", ")", ",", "LossQ1", "=", "q1_loss", ".", "item", "(", ")", ",", "LossQ2", "=", "q2_loss", ".", "item", "(", ")", ",", "\n", "LossAlpha", "=", "alpha_loss", ".", "item", "(", ")", ",", "\n", "Q1Vals", "=", "q1_prediction", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "Q2Vals", "=", "q2_prediction", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "Alpha", "=", "alpha", ",", "\n", "LogPi", "=", "log_prob_a_tilda", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "## store episode return and length to logger", "\n", "", "logger", ".", "store", "(", "EpRet", "=", "ep_ret", ",", "EpLen", "=", "ep_len", ")", "\n", "## reset environment", "\n", "o", ",", "r", ",", "d", ",", "ep_ret", ",", "ep_len", "=", "env", ".", "reset", "(", ")", ",", "0", ",", "False", ",", "0", ",", "0", "\n", "\n", "# End of epoch wrap-up", "\n", "", "if", "(", "t", "+", "1", ")", "%", "steps_per_epoch", "==", "0", ":", "\n", "            ", "epoch", "=", "t", "//", "steps_per_epoch", "\n", "\n", "\"\"\"\n            Save pytorch model, very different from tensorflow version\n            We need to save the environment, the state_dict of each network\n            and also the state_dict of each optimizer\n            \"\"\"", "\n", "# if not dont_save: TODO save is disabled for now", "\n", "#     sac_state_dict = {'env':env,'policy_net':policy_net.state_dict(),", "\n", "#                     'target_value_net':target_value_net.state_dict(),", "\n", "#                       'q1_net':q1_net.state_dict(), 'q2_net':q2_net.state_dict(),", "\n", "#                       'policy_opt':policy_optimizer, 'value_opt':value_optimizer,", "\n", "#                       'q1_opt':q1_optimizer, 'q2_opt':q2_optimizer}", "\n", "#     if (epoch % save_freq == 0) or (epoch == epochs-1):", "\n", "#         logger.save_state(sac_state_dict, None)", "\n", "\n", "# Test the performance of the deterministic version of the agent.", "\n", "test_agent", "(", ")", "\n", "\n", "# Log info about epoch", "\n", "logger", ".", "log_tabular", "(", "'Epoch'", ",", "epoch", ")", "\n", "logger", ".", "log_tabular", "(", "'EpRet'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'TestEpRet'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'EpLen'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'TestEpLen'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'TotalEnvInteracts'", ",", "t", ")", "\n", "logger", ".", "log_tabular", "(", "'Q1Vals'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'Q2Vals'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'Alpha'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'LossAlpha'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'LogPi'", ",", "with_min_and_max", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'LossPi'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'LossQ1'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'LossQ2'", ",", "average_only", "=", "True", ")", "\n", "logger", ".", "log_tabular", "(", "'Time'", ",", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "logger", ".", "dump_tabular", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.NoopResetEnv.__init__": [[9, 18], ["gym.Wrapper.__init__", "env.unwrapped.get_action_meanings"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "noop_max", "=", "30", ")", ":", "\n", "        ", "\"\"\"Sample initial states by taking random number of no-ops on reset.\n        No-op is assumed to be action 0.\n        \"\"\"", "\n", "gym", ".", "Wrapper", ".", "__init__", "(", "self", ",", "env", ")", "\n", "self", ".", "noop_max", "=", "noop_max", "\n", "self", ".", "override_num_noops", "=", "None", "\n", "self", ".", "noop_action", "=", "0", "\n", "assert", "env", ".", "unwrapped", ".", "get_action_meanings", "(", ")", "[", "0", "]", "==", "'NOOP'", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.NoopResetEnv.reset": [[19, 33], ["wrappers.NoopResetEnv.env.reset", "range", "wrappers.NoopResetEnv.unwrapped.np_random.randint", "wrappers.NoopResetEnv.env.step", "wrappers.NoopResetEnv.env.reset"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Do no-op action for a number of steps in [1, noop_max].\"\"\"", "\n", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "if", "self", ".", "override_num_noops", "is", "not", "None", ":", "\n", "            ", "noops", "=", "self", ".", "override_num_noops", "\n", "", "else", ":", "\n", "            ", "noops", "=", "self", ".", "unwrapped", ".", "np_random", ".", "randint", "(", "1", ",", "self", ".", "noop_max", "+", "1", ")", "#pylint: disable=E1101", "\n", "", "assert", "noops", ">", "0", "\n", "obs", "=", "None", "\n", "for", "_", "in", "range", "(", "noops", ")", ":", "\n", "            ", "obs", ",", "_", ",", "done", ",", "_", "=", "self", ".", "env", ".", "step", "(", "self", ".", "noop_action", ")", "\n", "if", "done", ":", "\n", "                ", "obs", "=", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "", "", "return", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.NoopResetEnv.step": [[34, 36], ["wrappers.NoopResetEnv.env.step"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step"], ["", "def", "step", "(", "self", ",", "ac", ")", ":", "\n", "        ", "return", "self", ".", "env", ".", "step", "(", "ac", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FireResetEnv.__init__": [[38, 43], ["gym.Wrapper.__init__", "len", "env.unwrapped.get_action_meanings", "env.unwrapped.get_action_meanings"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "\"\"\"Take action on reset for environments that are fixed until firing.\"\"\"", "\n", "gym", ".", "Wrapper", ".", "__init__", "(", "self", ",", "env", ")", "\n", "assert", "env", ".", "unwrapped", ".", "get_action_meanings", "(", ")", "[", "1", "]", "==", "'FIRE'", "\n", "assert", "len", "(", "env", ".", "unwrapped", ".", "get_action_meanings", "(", ")", ")", ">=", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FireResetEnv.reset": [[44, 53], ["wrappers.FireResetEnv.env.reset", "wrappers.FireResetEnv.env.step", "wrappers.FireResetEnv.env.step", "wrappers.FireResetEnv.env.reset", "wrappers.FireResetEnv.env.reset"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "obs", ",", "_", ",", "done", ",", "_", "=", "self", ".", "env", ".", "step", "(", "1", ")", "\n", "if", "done", ":", "\n", "            ", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "", "obs", ",", "_", ",", "done", ",", "_", "=", "self", ".", "env", ".", "step", "(", "2", ")", "\n", "if", "done", ":", "\n", "            ", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "", "return", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FireResetEnv.step": [[54, 56], ["wrappers.FireResetEnv.env.step"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step"], ["", "def", "step", "(", "self", ",", "ac", ")", ":", "\n", "        ", "return", "self", ".", "env", ".", "step", "(", "ac", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.EpisodicLifeEnv.__init__": [[58, 65], ["gym.Wrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "\"\"\"Make end-of-life == end-of-episode, but only reset on true game over.\n        Done by DeepMind for the DQN and co. since it helps value estimation.\n        \"\"\"", "\n", "gym", ".", "Wrapper", ".", "__init__", "(", "self", ",", "env", ")", "\n", "self", ".", "lives", "=", "0", "\n", "self", ".", "was_real_done", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.EpisodicLifeEnv.step": [[66, 79], ["wrappers.EpisodicLifeEnv.env.step", "wrappers.EpisodicLifeEnv.env.unwrapped.ale.lives"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "obs", ",", "reward", ",", "done", ",", "info", "=", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "self", ".", "was_real_done", "=", "done", "\n", "# check current lives, make loss of life terminal,", "\n", "# then update lives to handle bonus lives", "\n", "lives", "=", "self", ".", "env", ".", "unwrapped", ".", "ale", ".", "lives", "(", ")", "\n", "if", "lives", "<", "self", ".", "lives", "and", "lives", ">", "0", ":", "\n", "# for Qbert sometimes we stay in lives == 0 condtion for a few frames", "\n", "# so its important to keep lives > 0, so that we only reset once", "\n", "# the environment advertises done.", "\n", "            ", "done", "=", "True", "\n", "", "self", ".", "lives", "=", "lives", "\n", "return", "obs", ",", "reward", ",", "done", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.EpisodicLifeEnv.reset": [[80, 92], ["wrappers.EpisodicLifeEnv.env.unwrapped.ale.lives", "wrappers.EpisodicLifeEnv.env.reset", "wrappers.EpisodicLifeEnv.env.step"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Reset only when lives are exhausted.\n        This way all states are still reachable even though lives are episodic,\n        and the learner need not know about any of this behind-the-scenes.\n        \"\"\"", "\n", "if", "self", ".", "was_real_done", ":", "\n", "            ", "obs", "=", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# no-op step to advance from terminal/lost life state", "\n", "            ", "obs", ",", "_", ",", "_", ",", "_", "=", "self", ".", "env", ".", "step", "(", "0", ")", "\n", "", "self", ".", "lives", "=", "self", ".", "env", ".", "unwrapped", ".", "ale", ".", "lives", "(", ")", "\n", "return", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.MaxAndSkipEnv.__init__": [[94, 100], ["gym.Wrapper.__init__", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.torch.zeros"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "skip", "=", "4", ")", ":", "\n", "        ", "\"\"\"Return only every `skip`-th frame\"\"\"", "\n", "gym", ".", "Wrapper", ".", "__init__", "(", "self", ",", "env", ")", "\n", "# most recent raw observations (for max pooling across time steps)", "\n", "self", ".", "_obs_buffer", "=", "np", ".", "zeros", "(", "(", "2", ",", ")", "+", "env", ".", "observation_space", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "self", ".", "_skip", "=", "skip", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.MaxAndSkipEnv.reset": [[121, 123], ["wrappers.MaxAndSkipEnv.env.reset"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.MaxAndSkipEnv.step": [[104, 120], ["range", "wrappers.MaxAndSkipEnv._obs_buffer.max", "wrappers.MaxAndSkipEnv.env.step"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "\"\"\"Repeat action, sum reward, and max over last observations.\"\"\"", "\n", "total_reward", "=", "0.0", "\n", "done", "=", "None", "\n", "for", "i", "in", "range", "(", "self", ".", "_skip", ")", ":", "\n", "            ", "obs", ",", "reward", ",", "done", ",", "info", "=", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "if", "i", "==", "self", ".", "_skip", "-", "2", ":", "self", ".", "_obs_buffer", "[", "0", "]", "=", "obs", "\n", "if", "i", "==", "self", ".", "_skip", "-", "1", ":", "self", ".", "_obs_buffer", "[", "1", "]", "=", "obs", "\n", "total_reward", "+=", "reward", "\n", "if", "done", ":", "\n", "                ", "break", "\n", "# Note that the observation on the done=True frame", "\n", "# doesn't matter", "\n", "", "", "max_frame", "=", "self", ".", "_obs_buffer", ".", "max", "(", "axis", "=", "0", ")", "\n", "\n", "return", "max_frame", ",", "total_reward", ",", "done", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.ClipRewardEnv.__init__": [[125, 127], ["gym.RewardWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "gym", ".", "RewardWrapper", ".", "__init__", "(", "self", ",", "env", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.ClipRewardEnv.reward": [[128, 131], ["numpy.sign"], "methods", ["None"], ["", "def", "reward", "(", "self", ",", "reward", ")", ":", "\n", "        ", "\"\"\"Bin reward to {+1, 0, -1} by its sign.\"\"\"", "\n", "return", "np", ".", "sign", "(", "reward", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.WarpFrame.__init__": [[133, 140], ["gym.ObservationWrapper.__init__", "gym.spaces.Box"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "\"\"\"Warp frames to 84x84 as done in the Nature paper and later work.\"\"\"", "\n", "gym", ".", "ObservationWrapper", ".", "__init__", "(", "self", ",", "env", ")", "\n", "self", ".", "width", "=", "84", "\n", "self", ".", "height", "=", "84", "\n", "self", ".", "observation_space", "=", "spaces", ".", "Box", "(", "low", "=", "0", ",", "high", "=", "255", ",", "\n", "shape", "=", "(", "self", ".", "height", ",", "self", ".", "width", ",", "1", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.WarpFrame.observation": [[141, 145], ["cv2.cvtColor", "cv2.resize"], "methods", ["None"], ["", "def", "observation", "(", "self", ",", "frame", ")", ":", "\n", "        ", "frame", "=", "cv2", ".", "cvtColor", "(", "frame", ",", "cv2", ".", "COLOR_RGB2GRAY", ")", "\n", "frame", "=", "cv2", ".", "resize", "(", "frame", ",", "(", "self", ".", "width", ",", "self", ".", "height", ")", ",", "interpolation", "=", "cv2", ".", "INTER_AREA", ")", "\n", "return", "frame", "[", ":", ",", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.__init__": [[147, 159], ["gym.Wrapper.__init__", "collections.deque", "gym.spaces.Box"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "k", ")", ":", "\n", "        ", "\"\"\"Stack k last frames.\n        Returns lazy array, which is much more memory efficient.\n        See Also\n        --------\n        baselines.common.atari_wrappers.LazyFrames\n        \"\"\"", "\n", "gym", ".", "Wrapper", ".", "__init__", "(", "self", ",", "env", ")", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "frames", "=", "deque", "(", "[", "]", ",", "maxlen", "=", "k", ")", "\n", "shp", "=", "env", ".", "observation_space", ".", "shape", "\n", "self", ".", "observation_space", "=", "spaces", ".", "Box", "(", "low", "=", "0", ",", "high", "=", "255", ",", "shape", "=", "(", "shp", "[", "0", "]", ",", "shp", "[", "1", "]", ",", "shp", "[", "2", "]", "*", "k", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset": [[160, 165], ["wrappers.FrameStack.env.reset", "range", "wrappers.FrameStack._get_ob", "wrappers.FrameStack.frames.append"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.reset", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack._get_ob", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "ob", "=", "self", ".", "env", ".", "reset", "(", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "k", ")", ":", "\n", "            ", "self", ".", "frames", ".", "append", "(", "ob", ")", "\n", "", "return", "self", ".", "_get_ob", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step": [[166, 170], ["wrappers.FrameStack.env.step", "wrappers.FrameStack.frames.append", "wrappers.FrameStack._get_ob"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack.step", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack._get_ob"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "ob", ",", "reward", ",", "done", ",", "info", "=", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "self", ".", "frames", ".", "append", "(", "ob", ")", "\n", "return", "self", ".", "_get_ob", "(", ")", ",", "reward", ",", "done", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.FrameStack._get_ob": [[171, 174], ["wrappers.LazyFrames", "len", "list"], "methods", ["None"], ["", "def", "_get_ob", "(", "self", ")", ":", "\n", "        ", "assert", "len", "(", "self", ".", "frames", ")", "==", "self", ".", "k", "\n", "return", "LazyFrames", "(", "list", "(", "self", ".", "frames", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.ScaledFloatFrame.__init__": [[176, 178], ["gym.ObservationWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "gym", ".", "ObservationWrapper", ".", "__init__", "(", "self", ",", "env", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.ScaledFloatFrame.observation": [[179, 183], ["numpy.array().astype", "numpy.array"], "methods", ["None"], ["", "def", "observation", "(", "self", ",", "observation", ")", ":", "\n", "# careful! This undoes the memory optimization, use", "\n", "# with smaller replay buffers only.", "\n", "        ", "return", "np", ".", "array", "(", "observation", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.0", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.LazyFrames.__init__": [[185, 193], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "frames", ")", ":", "\n", "        ", "\"\"\"This object ensures that common frames between the observations are only stored once.\n        It exists purely to optimize memory usage which can be huge for DQN's 1M frames replay\n        buffers.\n        This object should only be converted to numpy array before being passed to the model.\n        You'd not believe how complex the previous solution was.\"\"\"", "\n", "self", ".", "_frames", "=", "frames", "\n", "self", ".", "_out", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.LazyFrames._force": [[194, 199], ["numpy.concatenate"], "methods", ["None"], ["", "def", "_force", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_out", "is", "None", ":", "\n", "            ", "self", ".", "_out", "=", "np", ".", "concatenate", "(", "self", ".", "_frames", ",", "axis", "=", "2", ")", "\n", "self", ".", "_frames", "=", "None", "\n", "", "return", "self", ".", "_out", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.LazyFrames.__array__": [[200, 205], ["wrappers.LazyFrames._force", "out.astype.astype.astype"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.LazyFrames._force"], ["", "def", "__array__", "(", "self", ",", "dtype", "=", "None", ")", ":", "\n", "        ", "out", "=", "self", ".", "_force", "(", ")", "\n", "if", "dtype", "is", "not", "None", ":", "\n", "            ", "out", "=", "out", ".", "astype", "(", "dtype", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.LazyFrames.__len__": [[206, 208], ["len", "wrappers.LazyFrames._force"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.LazyFrames._force"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_force", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.LazyFrames.__getitem__": [[209, 211], ["wrappers.LazyFrames._force"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.LazyFrames._force"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "self", ".", "_force", "(", ")", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.ImageToPyTorch.__init__": [[241, 245], ["gym.ObservationWrapper.__init__", "gym.spaces.Box"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["def", "__init__", "(", "self", ",", "env", ")", ":", "\n", "        ", "super", "(", "ImageToPyTorch", ",", "self", ")", ".", "__init__", "(", "env", ")", "\n", "old_shape", "=", "self", ".", "observation_space", ".", "shape", "\n", "self", ".", "observation_space", "=", "gym", ".", "spaces", ".", "Box", "(", "low", "=", "0.0", ",", "high", "=", "1.0", ",", "shape", "=", "(", "old_shape", "[", "-", "1", "]", ",", "old_shape", "[", "0", "]", ",", "old_shape", "[", "1", "]", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.ImageToPyTorch.observation": [[246, 248], ["numpy.swapaxes"], "methods", ["None"], ["", "def", "observation", "(", "self", ",", "observation", ")", ":", "\n", "        ", "return", "np", ".", "swapaxes", "(", "observation", ",", "2", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.make_atari": [[212, 218], ["gym.make", "wrappers.NoopResetEnv", "wrappers.MaxAndSkipEnv"], "function", ["None"], ["", "", "def", "make_atari", "(", "env_id", ")", ":", "\n", "    ", "env", "=", "gym", ".", "make", "(", "env_id", ")", "\n", "assert", "'NoFrameskip'", "in", "env", ".", "spec", ".", "id", "\n", "env", "=", "NoopResetEnv", "(", "env", ",", "noop_max", "=", "30", ")", "\n", "env", "=", "MaxAndSkipEnv", "(", "env", ",", "skip", "=", "4", ")", "\n", "return", "env", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.wrap_deepmind": [[219, 234], ["wrappers.WarpFrame", "wrappers.EpisodicLifeEnv", "FrameStack.unwrapped.get_action_meanings", "wrappers.FireResetEnv", "wrappers.ScaledFloatFrame", "wrappers.ClipRewardEnv", "wrappers.FrameStack"], "function", ["None"], ["", "def", "wrap_deepmind", "(", "env", ",", "episode_life", "=", "True", ",", "clip_rewards", "=", "True", ",", "frame_stack", "=", "False", ",", "scale", "=", "False", ")", ":", "\n", "    ", "\"\"\"Configure environment for DeepMind-style Atari.\n    \"\"\"", "\n", "if", "episode_life", ":", "\n", "        ", "env", "=", "EpisodicLifeEnv", "(", "env", ")", "\n", "", "if", "'FIRE'", "in", "env", ".", "unwrapped", ".", "get_action_meanings", "(", ")", ":", "\n", "        ", "env", "=", "FireResetEnv", "(", "env", ")", "\n", "", "env", "=", "WarpFrame", "(", "env", ")", "\n", "if", "scale", ":", "\n", "        ", "env", "=", "ScaledFloatFrame", "(", "env", ")", "\n", "", "if", "clip_rewards", ":", "\n", "        ", "env", "=", "ClipRewardEnv", "(", "env", ")", "\n", "", "if", "frame_stack", ":", "\n", "        ", "env", "=", "FrameStack", "(", "env", ",", "4", ")", "\n", "", "return", "env", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.wrappers.wrap_pytorch": [[250, 252], ["wrappers.ImageToPyTorch"], "function", ["None"], ["", "", "def", "wrap_pytorch", "(", "env", ")", ":", "\n", "    ", "return", "ImageToPyTorch", "(", "env", ")", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree.__init__": [[11, 38], ["range"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "capacity", ",", "operation", ",", "neutral_element", ")", ":", "\n", "        ", "\"\"\"Build a Segment Tree data structure.\n        https://en.wikipedia.org/wiki/Segment_tree\n        Can be used as regular array, but with two\n        important differences:\n            a) setting item's value is slightly slower.\n               It is O(lg capacity) instead of O(1).\n            b) user has access to an efficient `reduce`\n               operation which reduces `operation` over\n               a contiguous subsequence of items in the\n               array.\n        Paramters\n        ---------\n        capacity: int\n            Total size of the array - must be a power of two.\n        operation: lambda obj, obj -> obj\n            and operation for combining elements (eg. sum, max)\n            must for a mathematical group together with the set of\n            possible values for array elements.\n        neutral_element: obj\n            neutral element for the operation above. eg. float('-inf')\n            for max and 0 for sum.\n        \"\"\"", "\n", "assert", "capacity", ">", "0", "and", "capacity", "&", "(", "capacity", "-", "1", ")", "==", "0", ",", "\"capacity must be positive and a power of 2.\"", "\n", "self", ".", "_capacity", "=", "capacity", "\n", "self", ".", "_value", "=", "[", "neutral_element", "for", "_", "in", "range", "(", "2", "*", "capacity", ")", "]", "\n", "self", ".", "_operation", "=", "operation", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree._reduce_helper": [[39, 52], ["replay_buffer.SegmentTree._reduce_helper", "replay_buffer.SegmentTree._reduce_helper", "replay_buffer.SegmentTree._operation", "replay_buffer.SegmentTree._reduce_helper", "replay_buffer.SegmentTree._reduce_helper"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree._reduce_helper", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree._reduce_helper", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree._reduce_helper", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree._reduce_helper"], ["", "def", "_reduce_helper", "(", "self", ",", "start", ",", "end", ",", "node", ",", "node_start", ",", "node_end", ")", ":", "\n", "        ", "if", "start", "==", "node_start", "and", "end", "==", "node_end", ":", "\n", "            ", "return", "self", ".", "_value", "[", "node", "]", "\n", "", "mid", "=", "(", "node_start", "+", "node_end", ")", "//", "2", "\n", "if", "end", "<=", "mid", ":", "\n", "            ", "return", "self", ".", "_reduce_helper", "(", "start", ",", "end", ",", "2", "*", "node", ",", "node_start", ",", "mid", ")", "\n", "", "else", ":", "\n", "            ", "if", "mid", "+", "1", "<=", "start", ":", "\n", "                ", "return", "self", ".", "_reduce_helper", "(", "start", ",", "end", ",", "2", "*", "node", "+", "1", ",", "mid", "+", "1", ",", "node_end", ")", "\n", "", "else", ":", "\n", "                ", "return", "self", ".", "_operation", "(", "\n", "self", ".", "_reduce_helper", "(", "start", ",", "mid", ",", "2", "*", "node", ",", "node_start", ",", "mid", ")", ",", "\n", "self", ".", "_reduce_helper", "(", "mid", "+", "1", ",", "end", ",", "2", "*", "node", "+", "1", ",", "mid", "+", "1", ",", "node_end", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree.reduce": [[54, 75], ["replay_buffer.SegmentTree._reduce_helper"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree._reduce_helper"], ["", "", "", "def", "reduce", "(", "self", ",", "start", "=", "0", ",", "end", "=", "None", ")", ":", "\n", "        ", "\"\"\"Returns result of applying `self.operation`\n        to a contiguous subsequence of the array.\n            self.operation(arr[start], operation(arr[start+1], operation(... arr[end])))\n        Parameters\n        ----------\n        start: int\n            beginning of the subsequence\n        end: int\n            end of the subsequences\n        Returns\n        -------\n        reduced: obj\n            result of reducing self.operation over the specified range of array elements.\n        \"\"\"", "\n", "if", "end", "is", "None", ":", "\n", "            ", "end", "=", "self", ".", "_capacity", "\n", "", "if", "end", "<", "0", ":", "\n", "            ", "end", "+=", "self", ".", "_capacity", "\n", "", "end", "-=", "1", "\n", "return", "self", ".", "_reduce_helper", "(", "start", ",", "end", ",", "1", ",", "0", ",", "self", ".", "_capacity", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree.__setitem__": [[76, 87], ["replay_buffer.SegmentTree._operation"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "idx", ",", "val", ")", ":", "\n", "# index of the leaf", "\n", "        ", "idx", "+=", "self", ".", "_capacity", "\n", "self", ".", "_value", "[", "idx", "]", "=", "val", "\n", "idx", "//=", "2", "\n", "while", "idx", ">=", "1", ":", "\n", "            ", "self", ".", "_value", "[", "idx", "]", "=", "self", ".", "_operation", "(", "\n", "self", ".", "_value", "[", "2", "*", "idx", "]", ",", "\n", "self", ".", "_value", "[", "2", "*", "idx", "+", "1", "]", "\n", ")", "\n", "idx", "//=", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree.__getitem__": [[88, 91], ["None"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "assert", "0", "<=", "idx", "<", "self", ".", "_capacity", "\n", "return", "self", ".", "_value", "[", "self", ".", "_capacity", "+", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.__init__": [[94, 99], ["replay_buffer.SegmentTree.__init__"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "capacity", ")", ":", "\n", "        ", "super", "(", "SumSegmentTree", ",", "self", ")", ".", "__init__", "(", "\n", "capacity", "=", "capacity", ",", "\n", "operation", "=", "operator", ".", "add", ",", "\n", "neutral_element", "=", "0.0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum": [[101, 104], ["replay_buffer.SegmentTree.reduce"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree.reduce"], ["", "def", "sum", "(", "self", ",", "start", "=", "0", ",", "end", "=", "None", ")", ":", "\n", "        ", "\"\"\"Returns arr[start] + ... + arr[end]\"\"\"", "\n", "return", "super", "(", "SumSegmentTree", ",", "self", ")", ".", "reduce", "(", "start", ",", "end", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.find_prefixsum_idx": [[105, 129], ["replay_buffer.SumSegmentTree.sum"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum"], ["", "def", "find_prefixsum_idx", "(", "self", ",", "prefixsum", ")", ":", "\n", "        ", "\"\"\"Find the highest index `i` in the array such that\n            sum(arr[0] + arr[1] + ... + arr[i - i]) <= prefixsum\n        if array values are probabilities, this function\n        allows to sample indexes according to the discrete\n        probability efficiently.\n        Parameters\n        ----------\n        perfixsum: float\n            upperbound on the sum of array prefix\n        Returns\n        -------\n        idx: int\n            highest index satisfying the prefixsum constraint\n        \"\"\"", "\n", "assert", "0", "<=", "prefixsum", "<=", "self", ".", "sum", "(", ")", "+", "1e-5", "\n", "idx", "=", "1", "\n", "while", "idx", "<", "self", ".", "_capacity", ":", "# while non-leaf", "\n", "            ", "if", "self", ".", "_value", "[", "2", "*", "idx", "]", ">", "prefixsum", ":", "\n", "                ", "idx", "=", "2", "*", "idx", "\n", "", "else", ":", "\n", "                ", "prefixsum", "-=", "self", ".", "_value", "[", "2", "*", "idx", "]", "\n", "idx", "=", "2", "*", "idx", "+", "1", "\n", "", "", "return", "idx", "-", "self", ".", "_capacity", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.__init__": [[132, 137], ["replay_buffer.SegmentTree.__init__", "float"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "capacity", ")", ":", "\n", "        ", "super", "(", "MinSegmentTree", ",", "self", ")", ".", "__init__", "(", "\n", "capacity", "=", "capacity", ",", "\n", "operation", "=", "min", ",", "\n", "neutral_element", "=", "float", "(", "'inf'", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min": [[139, 143], ["replay_buffer.SegmentTree.reduce"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SegmentTree.reduce"], ["", "def", "min", "(", "self", ",", "start", "=", "0", ",", "end", "=", "None", ")", ":", "\n", "        ", "\"\"\"Returns min(arr[start], ...,  arr[end])\"\"\"", "\n", "\n", "return", "super", "(", "MinSegmentTree", ",", "self", ")", ".", "reduce", "(", "start", ",", "end", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.ReplayBuffer.__init__": [[146, 157], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "size", ")", ":", "\n", "        ", "\"\"\"Create Replay buffer.\n        Parameters\n        ----------\n        size: int\n            Max number of transitions to store in the buffer. When the buffer\n            overflows the old memories are dropped.\n        \"\"\"", "\n", "self", ".", "_storage", "=", "[", "]", "\n", "self", ".", "_maxsize", "=", "size", "\n", "self", ".", "_next_idx", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.ReplayBuffer.__len__": [[158, 160], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_storage", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.ReplayBuffer.push": [[161, 169], ["len", "replay_buffer.ReplayBuffer._storage.append"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "push", "(", "self", ",", "state", ",", "action", ",", "reward", ",", "next_state", ",", "done", ")", ":", "\n", "        ", "data", "=", "(", "state", ",", "action", ",", "reward", ",", "next_state", ",", "done", ")", "\n", "\n", "if", "self", ".", "_next_idx", ">=", "len", "(", "self", ".", "_storage", ")", ":", "\n", "            ", "self", ".", "_storage", ".", "append", "(", "data", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_storage", "[", "self", ".", "_next_idx", "]", "=", "data", "\n", "", "self", ".", "_next_idx", "=", "(", "self", ".", "_next_idx", "+", "1", ")", "%", "self", ".", "_maxsize", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.ReplayBuffer._encode_sample": [[170, 181], ["obses_t.append", "actions.append", "rewards.append", "obses_tp1.append", "dones.append", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append"], ["", "def", "_encode_sample", "(", "self", ",", "idxes", ")", ":", "\n", "        ", "obses_t", ",", "actions", ",", "rewards", ",", "obses_tp1", ",", "dones", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "idxes", ":", "\n", "            ", "data", "=", "self", ".", "_storage", "[", "i", "]", "\n", "obs_t", ",", "action", ",", "reward", ",", "obs_tp1", ",", "done", "=", "data", "\n", "obses_t", ".", "append", "(", "np", ".", "array", "(", "obs_t", ",", "copy", "=", "False", ")", ")", "\n", "actions", ".", "append", "(", "np", ".", "array", "(", "action", ",", "copy", "=", "False", ")", ")", "\n", "rewards", ".", "append", "(", "reward", ")", "\n", "obses_tp1", ".", "append", "(", "np", ".", "array", "(", "obs_tp1", ",", "copy", "=", "False", ")", ")", "\n", "dones", ".", "append", "(", "done", ")", "\n", "", "return", "np", ".", "array", "(", "obses_t", ")", ",", "np", ".", "array", "(", "actions", ")", ",", "np", ".", "array", "(", "rewards", ")", ",", "np", ".", "array", "(", "obses_tp1", ")", ",", "np", ".", "array", "(", "dones", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.ReplayBuffer.sample": [[182, 204], ["replay_buffer.ReplayBuffer._encode_sample", "random.randint", "range", "len"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.ReplayBuffer._encode_sample"], ["", "def", "sample", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "\"\"\"Sample a batch of experiences.\n        Parameters\n        ----------\n        batch_size: int\n            How many transitions to sample.\n        Returns\n        -------\n        obs_batch: np.array\n            batch of observations\n        act_batch: np.array\n            batch of actions executed given obs_batch\n        rew_batch: np.array\n            rewards received as results of executing act_batch\n        next_obs_batch: np.array\n            next set of observations seen after executing act_batch\n        done_mask: np.array\n            done_mask[i] = 1 if executing act_batch[i] resulted in\n            the end of an episode and 0 otherwise.\n        \"\"\"", "\n", "idxes", "=", "[", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "_storage", ")", "-", "1", ")", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "return", "self", ".", "_encode_sample", "(", "idxes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.__init__": [[207, 232], ["replay_buffer.ReplayBuffer.__init__", "replay_buffer.SumSegmentTree", "replay_buffer.MinSegmentTree"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__"], ["    ", "def", "__init__", "(", "self", ",", "size", ",", "alpha", ")", ":", "\n", "        ", "\"\"\"Create Prioritized Replay buffer.\n        Parameters\n        ----------\n        size: int\n            Max number of transitions to store in the buffer. When the buffer\n            overflows the old memories are dropped.\n        alpha: float\n            how much prioritization is used\n            (0 - no prioritization, 1 - full prioritization)\n        See Also\n        --------\n        ReplayBuffer.__init__\n        \"\"\"", "\n", "super", "(", "PrioritizedReplayBuffer", ",", "self", ")", ".", "__init__", "(", "size", ")", "\n", "assert", "alpha", ">", "0", "\n", "self", ".", "_alpha", "=", "alpha", "\n", "\n", "it_capacity", "=", "1", "\n", "while", "it_capacity", "<", "size", ":", "\n", "            ", "it_capacity", "*=", "2", "\n", "\n", "", "self", ".", "_it_sum", "=", "SumSegmentTree", "(", "it_capacity", ")", "\n", "self", ".", "_it_min", "=", "MinSegmentTree", "(", "it_capacity", ")", "\n", "self", ".", "_max_priority", "=", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.push": [[233, 239], ["replay_buffer.ReplayBuffer.push"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.push"], ["", "def", "push", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"See ReplayBuffer.store_effect\"\"\"", "\n", "idx", "=", "self", ".", "_next_idx", "\n", "super", "(", "PrioritizedReplayBuffer", ",", "self", ")", ".", "push", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_it_sum", "[", "idx", "]", "=", "self", ".", "_max_priority", "**", "self", ".", "_alpha", "\n", "self", ".", "_it_min", "[", "idx", "]", "=", "self", ".", "_max_priority", "**", "self", ".", "_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer._sample_proportional": [[240, 248], ["range", "replay_buffer.PrioritizedReplayBuffer._it_sum.find_prefixsum_idx", "res.append", "random.random", "replay_buffer.PrioritizedReplayBuffer._it_sum.sum", "len"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.find_prefixsum_idx", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum"], ["", "def", "_sample_proportional", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "res", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "# TODO(szymon): should we ensure no repeats?", "\n", "            ", "mass", "=", "random", ".", "random", "(", ")", "*", "self", ".", "_it_sum", ".", "sum", "(", "0", ",", "len", "(", "self", ".", "_storage", ")", "-", "1", ")", "\n", "idx", "=", "self", ".", "_it_sum", ".", "find_prefixsum_idx", "(", "mass", ")", "\n", "res", ".", "append", "(", "idx", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.sample": [[249, 296], ["replay_buffer.PrioritizedReplayBuffer._sample_proportional", "numpy.array", "replay_buffer.PrioritizedReplayBuffer._encode_sample", "tuple", "replay_buffer.PrioritizedReplayBuffer._it_min.min", "replay_buffer.PrioritizedReplayBuffer._it_sum.sum", "numpy.array.append", "len", "replay_buffer.PrioritizedReplayBuffer._it_sum.sum", "list", "len"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer._sample_proportional", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.ReplayBuffer._encode_sample", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.MinSegmentTree.min", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum", "home.repos.pwc.inspect_result.lanyavik_BAIL.utils.replay_memory.Memory.append", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.SumSegmentTree.sum"], ["", "def", "sample", "(", "self", ",", "batch_size", ",", "beta", ")", ":", "\n", "        ", "\"\"\"Sample a batch of experiences.\n        compared to ReplayBuffer.sample\n        it also returns importance weights and idxes\n        of sampled experiences.\n        Parameters\n        ----------\n        batch_size: int\n            How many transitions to sample.\n        beta: float\n            To what degree to use importance weights\n            (0 - no corrections, 1 - full correction)\n        Returns\n        -------\n        obs_batch: np.array\n            batch of observations\n        act_batch: np.array\n            batch of actions executed given obs_batch\n        rew_batch: np.array\n            rewards received as results of executing act_batch\n        next_obs_batch: np.array\n            next set of observations seen after executing act_batch\n        done_mask: np.array\n            done_mask[i] = 1 if executing act_batch[i] resulted in\n            the end of an episode and 0 otherwise.\n        weights: np.array\n            Array of shape (batch_size,) and dtype np.float32\n            denoting importance weight of each sampled transition\n        idxes: np.array\n            Array of shape (batch_size,) and dtype np.int32\n            idexes in buffer of sampled experiences\n        \"\"\"", "\n", "assert", "beta", ">", "0", "\n", "\n", "idxes", "=", "self", ".", "_sample_proportional", "(", "batch_size", ")", "\n", "\n", "weights", "=", "[", "]", "\n", "p_min", "=", "self", ".", "_it_min", ".", "min", "(", ")", "/", "self", ".", "_it_sum", ".", "sum", "(", ")", "\n", "max_weight", "=", "(", "p_min", "*", "len", "(", "self", ".", "_storage", ")", ")", "**", "(", "-", "beta", ")", "\n", "\n", "for", "idx", "in", "idxes", ":", "\n", "            ", "p_sample", "=", "self", ".", "_it_sum", "[", "idx", "]", "/", "self", ".", "_it_sum", ".", "sum", "(", ")", "\n", "weight", "=", "(", "p_sample", "*", "len", "(", "self", ".", "_storage", ")", ")", "**", "(", "-", "beta", ")", "\n", "weights", ".", "append", "(", "weight", "/", "max_weight", ")", "\n", "", "weights", "=", "np", ".", "array", "(", "weights", ")", "\n", "encoded_sample", "=", "self", ".", "_encode_sample", "(", "idxes", ")", "\n", "return", "tuple", "(", "list", "(", "encoded_sample", ")", "+", "[", "weights", ",", "idxes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.replay_buffer.PrioritizedReplayBuffer.update_priorities": [[297, 318], ["zip", "len", "len", "max", "len"], "methods", ["None"], ["", "def", "update_priorities", "(", "self", ",", "idxes", ",", "priorities", ")", ":", "\n", "        ", "\"\"\"Update priorities of sampled transitions.\n        sets priority of transition at index idxes[i] in buffer\n        to priorities[i].\n        Parameters\n        ----------\n        idxes: [int]\n            List of idxes of sampled transitions\n        priorities: [float]\n            List of updated priorities corresponding to\n            transitions at the sampled idxes denoted by\n            variable `idxes`.\n        \"\"\"", "\n", "assert", "len", "(", "idxes", ")", "==", "len", "(", "priorities", ")", "\n", "for", "idx", ",", "priority", "in", "zip", "(", "idxes", ",", "priorities", ")", ":", "\n", "            ", "assert", "priority", ">", "0", "\n", "assert", "0", "<=", "idx", "<", "len", "(", "self", ".", "_storage", ")", "\n", "self", ".", "_it_sum", "[", "idx", "]", "=", "priority", "**", "self", ".", "_alpha", "\n", "self", ".", "_it_min", "[", "idx", "]", "=", "priority", "**", "self", ".", "_alpha", "\n", "\n", "self", ".", "_max_priority", "=", "max", "(", "self", ".", "_max_priority", ",", "priority", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__": [[8, 26], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "layers.NoisyLinear.register_buffer", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "layers.NoisyLinear.register_buffer", "layers.NoisyLinear.reset_parameters", "layers.NoisyLinear.reset_noise", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.__init__", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.reset_parameters", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.reset_noise"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "use_cuda", ",", "std_init", "=", "0.4", ")", ":", "\n", "        ", "super", "(", "NoisyLinear", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "use_cuda", "=", "use_cuda", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "std_init", "=", "std_init", "\n", "\n", "self", ".", "weight_mu", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "out_features", ",", "in_features", ")", ")", "\n", "self", ".", "weight_sigma", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "out_features", ",", "in_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "'weight_epsilon'", ",", "torch", ".", "FloatTensor", "(", "out_features", ",", "in_features", ")", ")", "\n", "\n", "self", ".", "bias_mu", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "out_features", ")", ")", "\n", "self", ".", "bias_sigma", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "out_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "'bias_epsilon'", ",", "torch", ".", "FloatTensor", "(", "out_features", ")", ")", "\n", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "self", ".", "reset_noise", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.forward": [[27, 43], ["torch.linear", "torch.linear", "torch.linear", "layers.NoisyLinear.weight_epsilon.cuda", "layers.NoisyLinear.bias_epsilon.cuda", "layers.NoisyLinear.weight_sigma.mul", "layers.NoisyLinear.bias_sigma.mul", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "use_cuda", ":", "\n", "            ", "weight_epsilon", "=", "self", ".", "weight_epsilon", ".", "cuda", "(", ")", "\n", "bias_epsilon", "=", "self", ".", "bias_epsilon", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "            ", "weight_epsilon", "=", "self", ".", "weight_epsilon", "\n", "bias_epsilon", "=", "self", ".", "bias_epsilon", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "            ", "weight", "=", "self", ".", "weight_mu", "+", "self", ".", "weight_sigma", ".", "mul", "(", "Variable", "(", "weight_epsilon", ")", ")", "\n", "bias", "=", "self", ".", "bias_mu", "+", "self", ".", "bias_sigma", ".", "mul", "(", "Variable", "(", "bias_epsilon", ")", ")", "\n", "", "else", ":", "\n", "            ", "weight", "=", "self", ".", "weight_mu", "\n", "bias", "=", "self", ".", "bias_mu", "\n", "\n", "", "return", "F", ".", "linear", "(", "x", ",", "weight", ",", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.reset_parameters": [[44, 52], ["layers.NoisyLinear.weight_mu.data.uniform_", "layers.NoisyLinear.weight_sigma.data.fill_", "layers.NoisyLinear.bias_mu.data.uniform_", "layers.NoisyLinear.bias_sigma.data.fill_", "math.sqrt", "layers.NoisyLinear.weight_mu.size", "math.sqrt", "math.sqrt", "layers.NoisyLinear.weight_sigma.size", "layers.NoisyLinear.bias_sigma.size"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "mu_range", "=", "1", "/", "math", ".", "sqrt", "(", "self", ".", "weight_mu", ".", "size", "(", "1", ")", ")", "\n", "\n", "self", ".", "weight_mu", ".", "data", ".", "uniform_", "(", "-", "mu_range", ",", "mu_range", ")", "\n", "self", ".", "weight_sigma", ".", "data", ".", "fill_", "(", "self", ".", "std_init", "/", "math", ".", "sqrt", "(", "self", ".", "weight_sigma", ".", "size", "(", "1", ")", ")", ")", "\n", "\n", "self", ".", "bias_mu", ".", "data", ".", "uniform_", "(", "-", "mu_range", ",", "mu_range", ")", "\n", "self", ".", "bias_sigma", ".", "data", ".", "fill_", "(", "self", ".", "std_init", "/", "math", ".", "sqrt", "(", "self", ".", "bias_sigma", ".", "size", "(", "0", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear.reset_noise": [[53, 59], ["layers.NoisyLinear._scale_noise", "layers.NoisyLinear._scale_noise", "layers.NoisyLinear.weight_epsilon.copy_", "layers.NoisyLinear.bias_epsilon.copy_", "layers.NoisyLinear.ger", "layers.NoisyLinear._scale_noise"], "methods", ["home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear._scale_noise", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear._scale_noise", "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear._scale_noise"], ["", "def", "reset_noise", "(", "self", ")", ":", "\n", "        ", "epsilon_in", "=", "self", ".", "_scale_noise", "(", "self", ".", "in_features", ")", "\n", "epsilon_out", "=", "self", ".", "_scale_noise", "(", "self", ".", "out_features", ")", "\n", "\n", "self", ".", "weight_epsilon", ".", "copy_", "(", "epsilon_out", ".", "ger", "(", "epsilon_in", ")", ")", "\n", "self", ".", "bias_epsilon", ".", "copy_", "(", "self", ".", "_scale_noise", "(", "self", ".", "out_features", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lanyavik_BAIL.common.layers.NoisyLinear._scale_noise": [[60, 64], ["torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "x.sign().mul.sign().mul.sign().mul", "x.sign().mul.sign().mul.abs().sqrt", "x.sign().mul.sign().mul.sign", "x.sign().mul.sign().mul.abs"], "methods", ["None"], ["", "def", "_scale_noise", "(", "self", ",", "size", ")", ":", "\n", "        ", "x", "=", "torch", ".", "randn", "(", "size", ")", "\n", "x", "=", "x", ".", "sign", "(", ")", ".", "mul", "(", "x", ".", "abs", "(", ")", ".", "sqrt", "(", ")", ")", "\n", "return", "x", "", "", "", ""]]}