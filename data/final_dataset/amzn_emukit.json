{"home.repos.pwc.inspect_result.amzn_emukit.doc.conf.Mock.__getattr__": [[27, 30], ["unittest.mock.MagicMock"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "__getattr__", "(", "cls", ",", "name", ")", ":", "\n", "        ", "return", "MagicMock", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.vanilla_bq_model": [[56, 61], ["continuous_space.get_bounds", "emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model", "emukit.quadrature.methods.VanillaBayesianQuadrature"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_bounds", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model"], ["@", "pytest", ".", "fixture", "\n", "def", "vanilla_bq_model", "(", "gpy_model", ",", "continuous_space", ",", "n_dims", ")", ":", "\n", "    ", "integral_bounds", "=", "continuous_space", ".", "get_bounds", "(", ")", "\n", "model", "=", "create_emukit_model_from_gpy_model", "(", "gpy_model", ".", "model", ",", "integral_bounds", ",", "None", ")", "\n", "return", "VanillaBayesianQuadrature", "(", "model", ",", "model", ".", "X", ",", "model", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.negative_lower_confidence_bound_acquisition": [[64, 67], ["emukit.bayesian_optimization.acquisitions.NegativeLowerConfidenceBound"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "negative_lower_confidence_bound_acquisition", "(", "gpy_model", ")", ":", "\n", "    ", "return", "NegativeLowerConfidenceBound", "(", "gpy_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.expected_improvement_acquisition": [[69, 72], ["emukit.bayesian_optimization.acquisitions.ExpectedImprovement"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "expected_improvement_acquisition", "(", "gpy_model", ")", ":", "\n", "    ", "return", "ExpectedImprovement", "(", "gpy_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.integrated_expected_improvement_acquisition": [[74, 77], ["emukit.core.acquisition.IntegratedHyperParameterAcquisition"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "integrated_expected_improvement_acquisition", "(", "gpy_model_mcmc", ")", ":", "\n", "    ", "return", "IntegratedHyperParameterAcquisition", "(", "gpy_model_mcmc", ",", "ExpectedImprovement", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.integrated_probability_of_improvement_acquisition": [[79, 82], ["emukit.core.acquisition.IntegratedHyperParameterAcquisition"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "integrated_probability_of_improvement_acquisition", "(", "gpy_model_mcmc", ")", ":", "\n", "    ", "return", "IntegratedHyperParameterAcquisition", "(", "gpy_model_mcmc", ",", "ProbabilityOfImprovement", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.probability_of_feasibility_acquisition": [[84, 87], ["emukit.bayesian_optimization.acquisitions.ProbabilityOfFeasibility"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "probability_of_feasibility_acquisition", "(", "gpy_model", ")", ":", "\n", "    ", "return", "ProbabilityOfFeasibility", "(", "gpy_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.cost_acquisition": [[89, 92], ["emukit.core.acquisition.acquisition_per_cost.CostAcquisition"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "cost_acquisition", "(", "gpy_model", ")", ":", "\n", "    ", "return", "CostAcquisition", "(", "gpy_model", ",", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.log_acquisition": [[94, 97], ["emukit.bayesian_optimization.acquisitions.log_acquisition.LogAcquisition"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "log_acquisition", "(", "expected_improvement_acquisition", ")", ":", "\n", "    ", "return", "LogAcquisition", "(", "expected_improvement_acquisition", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.probability_of_improvement_acquisition": [[99, 102], ["emukit.bayesian_optimization.acquisitions.ProbabilityOfImprovement"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "probability_of_improvement_acquisition", "(", "gpy_model", ")", ":", "\n", "    ", "return", "ProbabilityOfImprovement", "(", "gpy_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.entropy_search_acquisition": [[104, 108], ["emukit.samplers.AffineInvariantEnsembleSampler", "emukit.bayesian_optimization.acquisitions.EntropySearch"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "entropy_search_acquisition", "(", "gpy_model", ",", "continuous_space", ")", ":", "\n", "    ", "sampler", "=", "AffineInvariantEnsembleSampler", "(", "continuous_space", ")", "\n", "return", "EntropySearch", "(", "gpy_model", ",", "continuous_space", ",", "sampler", ",", "num_representer_points", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.max_value_entropy_search_acquisition": [[110, 113], ["emukit.bayesian_optimization.acquisitions.MaxValueEntropySearch"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "max_value_entropy_search_acquisition", "(", "gpy_model", ",", "continuous_space", ")", ":", "\n", "    ", "return", "MaxValueEntropySearch", "(", "gpy_model", ",", "continuous_space", ",", "num_samples", "=", "2", ",", "grid_size", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.model_variance_acquisition": [[115, 118], ["emukit.experimental_design.acquisitions.ModelVariance"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "model_variance_acquisition", "(", "gpy_model", ")", ":", "\n", "    ", "return", "ModelVariance", "(", "gpy_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.integrated_variance_acquisition": [[120, 123], ["emukit.experimental_design.acquisitions.IntegratedVarianceReduction"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "integrated_variance_acquisition", "(", "gpy_model", ",", "continuous_space", ")", ":", "\n", "    ", "return", "IntegratedVarianceReduction", "(", "gpy_model", ",", "continuous_space", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.squared_correlation_acquisition": [[125, 128], ["emukit.quadrature.acquisitions.SquaredCorrelation"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "squared_correlation_acquisition", "(", "vanilla_bq_model", ")", ":", "\n", "    ", "return", "SquaredCorrelation", "(", "vanilla_bq_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.mutual_information_acquisition": [[130, 133], ["emukit.quadrature.acquisitions.MutualInformation"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "mutual_information_acquisition", "(", "vanilla_bq_model", ")", ":", "\n", "    ", "return", "MutualInformation", "(", "vanilla_bq_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.uncertainty_sampling_acquisition": [[135, 138], ["emukit.quadrature.acquisitions.UncertaintySampling"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "uncertainty_sampling_acquisition", "(", "vanilla_bq_model", ")", ":", "\n", "    ", "return", "UncertaintySampling", "(", "vanilla_bq_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.multi_source_entropy_search_acquisition": [[140, 145], ["pytest.mark.parametrize", "emukit.core.ParameterSpace", "emukit.bayesian_optimization.acquisitions.entropy_search.MultiInformationSourceEntropySearch", "emukit.core.ContinuousParameter", "emukit.core.InformationSourceParameter"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"n_dims\"", ",", "[", "2", "]", ")", "\n", "def", "multi_source_entropy_search_acquisition", "(", "gpy_model", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x1\"", ",", "0", ",", "1", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", ")", "\n", "return", "MultiInformationSourceEntropySearch", "(", "gpy_model", ",", "space", ",", "num_representer_points", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.MUMBO_acquisition": [[147, 152], ["pytest.mark.parametrize", "emukit.core.ParameterSpace", "emukit.bayesian_optimization.acquisitions.MUMBO", "emukit.core.ContinuousParameter", "emukit.core.InformationSourceParameter"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"n_dims\"", ",", "[", "2", "]", ")", "\n", "def", "MUMBO_acquisition", "(", "gpy_model", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x1\"", ",", "0", ",", "1", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", ")", "\n", "return", "MUMBO", "(", "gpy_model", ",", "space", ",", "num_samples", "=", "10", ",", "grid_size", "=", "5000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.create_acquisition_fixture_parameters": [[155, 157], ["pytest.param", "pytest_lazyfixture.lazy_fixture"], "function", ["None"], ["", "def", "create_acquisition_fixture_parameters", "(", ")", ":", "\n", "    ", "return", "[", "pytest", ".", "param", "(", "pytest_lazyfixture", ".", "lazy_fixture", "(", "acq", ".", "name", ")", ",", "id", "=", "acq", ".", "name", ")", "for", "acq", "in", "acquisition_tests", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.create_gradient_acquisition_fixtures": [[159, 168], ["pytest_lazyfixture.lazy_fixture", "parameters.append", "pytest.param"], "function", ["None"], ["", "def", "create_gradient_acquisition_fixtures", "(", ")", ":", "\n", "# Create list of tuples of parameters with (fixture, tolerance) for acquisitions that gave gradients only", "\n", "    ", "parameters", "=", "[", "]", "\n", "for", "acquisition", "in", "acquisition_tests", ":", "\n", "        ", "if", "acquisition", ".", "has_gradients", ":", "\n", "            ", "acquisition_name", "=", "acquisition", ".", "name", "\n", "lazy_fixture", "=", "pytest_lazyfixture", ".", "lazy_fixture", "(", "acquisition", ".", "name", ")", "\n", "parameters", ".", "append", "(", "pytest", ".", "param", "(", "lazy_fixture", ",", "acquisition", ".", "rmse_gradient_tolerance", ",", "id", "=", "acquisition_name", ")", ")", "\n", "", "", "return", "parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.test_acquisition_evaluate_shape": [[171, 180], ["pytest.mark.parametrize", "numpy.random.rand", "acquisition.evaluate", "numpy.random.rand", "acquisition.evaluate", "test_acquisitions.create_acquisition_fixture_parameters"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.create_acquisition_fixture_parameters"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"acquisition\"", ",", "create_acquisition_fixture_parameters", "(", ")", ")", "\n", "def", "test_acquisition_evaluate_shape", "(", "acquisition", ",", "n_dims", ")", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "rand", "(", "1", ",", "n_dims", ")", "\n", "acquisition_value", "=", "acquisition", ".", "evaluate", "(", "x", ")", "\n", "assert", "acquisition_value", ".", "shape", "==", "(", "1", ",", "1", ")", "\n", "\n", "x", "=", "np", ".", "random", ".", "rand", "(", "10", ",", "n_dims", ")", "\n", "acquisition_value", "=", "acquisition", ".", "evaluate", "(", "x", ")", "\n", "assert", "acquisition_value", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.test_acquisition_gradient_computation": [[182, 193], ["pytest.mark.parametrize", "numpy.random.RandomState", "np.random.RandomState.rand", "test_acquisitions.create_gradient_acquisition_fixtures", "scipy.optimize.check_grad", "acquisition.evaluate", "acquisition.evaluate_with_gradients", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.create_gradient_acquisition_fixtures", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "(", "\"acquisition\"", ",", "\"tol\"", ")", ",", "create_gradient_acquisition_fixtures", "(", ")", ")", "\n", "def", "test_acquisition_gradient_computation", "(", "acquisition", ",", "n_dims", ",", "tol", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "x_test", "=", "rng", ".", "rand", "(", "10", ",", "n_dims", ")", "\n", "\n", "acq", "=", "lambda", "x", ":", "acquisition", ".", "evaluate", "(", "np", ".", "array", "(", "[", "x", "]", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "grad", "=", "lambda", "x", ":", "acquisition", ".", "evaluate_with_gradients", "(", "np", ".", "array", "(", "[", "x", "]", ")", ")", "[", "1", "]", "[", "0", "]", "\n", "\n", "for", "xi", "in", "x_test", ":", "\n", "        ", "err", "=", "check_grad", "(", "acq", ",", "grad", ",", "xi", ",", "epsilon", "=", "gradient_check_step_size", ")", "\n", "assert", "err", "<", "tol", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.test_acquisition_gradient_shapes": [[195, 206], ["pytest.mark.parametrize", "numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "test_acquisitions.create_gradient_acquisition_fixtures", "acquisition.evaluate_with_gradients", "acquisition.evaluate_with_gradients"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.emukit.test_acquisitions.create_gradient_acquisition_fixtures", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "(", "\"acquisition\"", ",", "\"tol\"", ")", ",", "create_gradient_acquisition_fixtures", "(", ")", ")", "\n", "def", "test_acquisition_gradient_shapes", "(", "acquisition", ",", "n_dims", ",", "tol", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "\n", "x_test", "=", "rng", ".", "rand", "(", "1", ",", "n_dims", ")", "\n", "gradients", "=", "acquisition", ".", "evaluate_with_gradients", "(", "x_test", ")", "[", "1", "]", "\n", "assert", "gradients", ".", "shape", "==", "(", "1", ",", "n_dims", ")", "\n", "\n", "x_test", "=", "rng", ".", "rand", "(", "10", ",", "n_dims", ")", "\n", "gradients", "=", "acquisition", ".", "evaluate_with_gradients", "(", "x_test", ")", "[", "1", "]", "\n", "assert", "gradients", ".", "shape", "==", "(", "10", ",", "n_dims", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.conftest.n_dims": [[13, 18], ["None"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "n_dims", "(", ")", ":", "\n", "# default to 2 dimensional inputs for tests, but can be overridden by individual tests if desired by using the", "\n", "# following decorator: @pytest.mark.parametrize('n_dims', [xxx]) where xxx is the number of desired dimensions", "\n", "    ", "return", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.conftest.gpy_model": [[20, 29], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "GPy.models.GPRegression", "numpy.random.seed", "GPy.models.GPRegression.randomize", "emukit.model_wrappers.GPyModelWrapper", "GPy.kern.RBF"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_model", "(", "n_dims", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "x_init", "=", "rng", ".", "rand", "(", "5", ",", "n_dims", ")", "\n", "y_init", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ",", "GPy", ".", "kern", ".", "RBF", "(", "n_dims", ")", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "gpy_model", ".", "randomize", "(", ")", "\n", "return", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.conftest.gpy_model_mcmc": [[31, 41], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "GPy.models.GPRegression", "GPy.models.GPRegression.kern.set_prior", "numpy.random.seed", "GPy.models.GPRegression.randomize", "emukit.model_wrappers.GPyModelWrapper", "GPy.kern.RBF", "GPy.priors.Uniform"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_model_mcmc", "(", "n_dims", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "x_init", "=", "rng", ".", "rand", "(", "5", ",", "n_dims", ")", "\n", "y_init", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ",", "GPy", ".", "kern", ".", "RBF", "(", "n_dims", ")", ")", "\n", "gpy_model", ".", "kern", ".", "set_prior", "(", "GPy", ".", "priors", ".", "Uniform", "(", "0", ",", "5", ")", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "gpy_model", ".", "randomize", "(", ")", "\n", "return", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.conftest.continuous_space": [[43, 47], ["emukit.core.ParameterSpace", "emukit.core.ContinuousParameter", "range", "str"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "continuous_space", "(", "n_dims", ")", ":", "\n", "    ", "params", "=", "[", "ContinuousParameter", "(", "\"x\"", "+", "str", "(", "i", ")", ",", "0", ",", "1", ")", "for", "i", "in", "range", "(", "n_dims", ")", "]", "\n", "return", "ParameterSpace", "(", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emukit.conftest.encoding": [[49, 53], ["emukit.core.OneHotEncoding"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "encoding", "(", ")", ":", "\n", "# different types of volcanoes", "\n", "    ", "return", "OneHotEncoding", "(", "[", "\"strato\"", ",", "\"shield\"", ",", "\"dome\"", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.__init__": [[22, 51], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "a", ":", "float", ",", "b", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        :param a: Constant in Ishigami equation. See method docstrings for details\n        :param b: Constant in Ishigami equation. See method docstrings for details\n        \"\"\"", "\n", "self", ".", "a", "=", "a", "\n", "self", ".", "b", "=", "b", "\n", "\n", "self", ".", "variance_total", "=", "0.5", "+", "self", ".", "a", "**", "2", "/", "8", "+", "np", ".", "pi", "**", "4", "*", "self", ".", "b", "/", "5", "+", "np", ".", "pi", "**", "8", "*", "self", ".", "b", "**", "2", "/", "18", "\n", "self", ".", "variance_x1", "=", "0.5", "*", "(", "1", "+", "self", ".", "b", "*", "np", ".", "pi", "**", "4", "/", "5", ")", "**", "2", "\n", "self", ".", "variance_x2", "=", "self", ".", "a", "**", "2", "/", "8", "\n", "self", ".", "variance_x3", "=", "0", "\n", "self", ".", "variance_x12", "=", "0", "\n", "self", ".", "variance_x13", "=", "np", ".", "pi", "**", "8", "*", "self", ".", "b", "**", "2", "*", "(", "1", "/", "18", "-", "1", "/", "50", ")", "\n", "self", ".", "variance_x23", "=", "0", "\n", "self", ".", "variance_x123", "=", "0", "\n", "\n", "# Main effects", "\n", "self", ".", "main_effects", "=", "{", "\n", "\"x1\"", ":", "self", ".", "variance_x1", "/", "self", ".", "variance_total", ",", "\n", "\"x2\"", ":", "self", ".", "variance_x2", "/", "self", ".", "variance_total", ",", "\n", "\"x3\"", ":", "self", ".", "variance_x3", "/", "self", ".", "variance_total", ",", "\n", "}", "\n", "\n", "# Total effects", "\n", "self", ".", "total_effects", "=", "{", "\n", "\"x1\"", ":", "(", "self", ".", "variance_x1", "+", "self", ".", "variance_x13", ")", "/", "self", ".", "variance_total", ",", "\n", "\"x2\"", ":", "self", ".", "variance_x2", "/", "self", ".", "variance_total", ",", "\n", "\"x3\"", ":", "(", "self", ".", "variance_x3", "+", "self", ".", "variance_x13", ")", "/", "self", ".", "variance_total", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.fidelity1": [[53, 63], ["numpy.sin", "numpy.sin", "numpy.sin"], "methods", ["None"], ["", "def", "fidelity1", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Highest fidelity\n\n        .. math::\n            \\sin(x_1) + a \\sin(x_2)^2 + b x_3 ^ 4 \\sin(x_1)\n\n        :param x: (n_points x 3) numpy array containing inputs to function\n        \"\"\"", "\n", "return", "np", ".", "sin", "(", "x", "[", ":", ",", "0", "]", ")", "+", "self", ".", "a", "*", "np", ".", "sin", "(", "x", "[", ":", ",", "1", "]", ")", "**", "2", "+", "self", ".", "b", "*", "x", "[", ":", ",", "2", "]", "**", "4", "*", "(", "np", ".", "sin", "(", "x", "[", ":", ",", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.fidelity2": [[64, 74], ["numpy.sin", "numpy.sin", "numpy.sin"], "methods", ["None"], ["", "def", "fidelity2", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Low fidelity approximation\n\n        .. math::\n            \\sin(x_1) + a \\sin(x_2) + b x_3 ^ 4 \\sin(x_1)\n\n        :param x: (n_points x 3) numpy array containing inputs to function\n        \"\"\"", "\n", "return", "np", ".", "sin", "(", "x", "[", ":", ",", "0", "]", ")", "+", "self", ".", "a", "*", "np", ".", "sin", "(", "x", "[", ":", ",", "1", "]", ")", "+", "self", ".", "b", "*", "x", "[", ":", ",", "2", "]", "**", "4", "*", "(", "np", ".", "sin", "(", "x", "[", ":", ",", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.fidelity3": [[75, 85], ["numpy.sin", "numpy.sin", "numpy.sin"], "methods", ["None"], ["", "def", "fidelity3", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Low fidelity approximation\n\n        .. math::\n            \\sin(x_1) + 0.95 a \\sin(x_2)^2 + b x_3 ^ 4 \\sin(x_1)\n\n        :param x: (n_points x 3) numpy array containing inputs to function\n        \"\"\"", "\n", "return", "np", ".", "sin", "(", "x", "[", ":", ",", "0", "]", ")", "+", "0.95", "*", "self", ".", "a", "*", "np", ".", "sin", "(", "x", "[", ":", ",", "1", "]", ")", "**", "2", "+", "self", ".", "b", "*", "x", "[", ":", ",", "2", "]", "**", "4", "*", "(", "np", ".", "sin", "(", "x", "[", ":", ",", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.fidelity4": [[86, 96], ["numpy.sin", "numpy.sin", "numpy.sin"], "methods", ["None"], ["", "def", "fidelity4", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Low fidelity approximation\n\n        .. math::\n            \\sin(x_1) + 0.6 a \\sin(x_2)^2 + 9 b x_3 ^ 4 \\sin(x_1)\n\n        :param x: (n_points x 3) numpy array containing inputs to function\n        \"\"\"", "\n", "return", "np", ".", "sin", "(", "x", "[", ":", ",", "0", "]", ")", "+", "0.6", "*", "self", ".", "a", "*", "np", ".", "sin", "(", "x", "[", ":", ",", "1", "]", ")", "**", "2", "+", "9", "*", "self", ".", "b", "*", "x", "[", ":", ",", "2", "]", "**", "4", "*", "(", "np", ".", "sin", "(", "x", "[", ":", ",", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f0": [[97, 102], ["None"], "methods", ["None"], ["", "def", "f0", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Constant effect of high fidelity function\n        \"\"\"", "\n", "return", "self", ".", "a", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f1": [[103, 108], ["numpy.sin"], "methods", ["None"], ["", "def", "f1", "(", "self", ",", "x1", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        First order effect of x_1 on high fidelity function\n        \"\"\"", "\n", "return", "(", "1", "+", "(", "self", ".", "b", "/", "5", ")", "*", "np", ".", "pi", "**", "4", ")", "*", "np", ".", "sin", "(", "x1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f2": [[109, 114], ["numpy.sin"], "methods", ["None"], ["", "def", "f2", "(", "self", ",", "x2", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        First order effect of x_2 on high fidelity function\n        \"\"\"", "\n", "return", "self", ".", "a", "*", "np", ".", "sin", "(", "x2", ")", "**", "2", "-", "0.5", "*", "self", ".", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f3": [[115, 120], ["None"], "methods", ["None"], ["", "def", "f3", "(", "self", ",", "x3", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        First order effect of x_3 on high fidelity function\n        \"\"\"", "\n", "return", "x3", "[", ":", ",", "0", "]", "*", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f12": [[121, 126], ["None"], "methods", ["None"], ["", "def", "f12", "(", "self", ",", "x12", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Second order effect of x_1 and x_2 on high fidelity function\n        \"\"\"", "\n", "return", "x12", "[", ":", ",", "0", "]", "*", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f13": [[127, 132], ["numpy.sin"], "methods", ["None"], ["", "def", "f13", "(", "self", ",", "x13", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Second order effect of x_1 and x_3 on high fidelity function\n        \"\"\"", "\n", "return", "self", ".", "b", "*", "np", ".", "sin", "(", "x13", "[", ":", ",", "0", "]", ")", "*", "(", "x13", "[", ":", ",", "1", "]", "**", "4", "-", "np", ".", "pi", "**", "4", "/", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f23": [[133, 138], ["None"], "methods", ["None"], ["", "def", "f23", "(", "self", ",", "x23", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Second order effect of x_2 and x_3 on high fidelity function\n        \"\"\"", "\n", "return", "x23", "[", ":", ",", "0", "]", "*", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f123": [[139, 144], ["None"], "methods", ["None"], ["", "def", "f123", "(", "self", ",", "x123", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Third order effect of all inputs on high fidelity function\n        \"\"\"", "\n", "return", "x123", "[", ":", ",", "0", "]", "*", "0", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.test_emukit_sensitivity.space": [[10, 16], ["emukit.core.ParameterSpace", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "space", "(", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "\n", "[", "ContinuousParameter", "(", "\"x1\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"x2\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"x3\"", ",", "0", ",", "1", ")", "]", "\n", ")", "\n", "return", "space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.test_emukit_sensitivity.test_model_based_montecarlo_sensitivity": [[18, 43], ["mock.create_autospec", "emukit.sensitivity.monte_carlo.MonteCarloSensitivity", "numpy.zeros", "numpy.zeros", "emukit.sensitivity.monte_carlo.MonteCarloSensitivity.compute_effects", "all", "all", "all", "all", "numpy.zeros", "abs", "numpy.ones", "list", "list", "main_effects.values", "total_effects.values"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.compute_effects"], ["", "def", "test_model_based_montecarlo_sensitivity", "(", "space", ")", ":", "\n", "\n", "    ", "model", "=", "mock", ".", "create_autospec", "(", "IModel", ")", "\n", "model", ".", "predict", ".", "return_value", "=", "(", "0.1", "*", "np", ".", "ones", "(", "(", "3", ",", "2", ")", ")", ",", "np", ".", "zeros", "(", "(", "3", ",", "2", ")", ")", ")", "\n", "\n", "sensitivity", "=", "MonteCarloSensitivity", "(", "model", ",", "space", ")", "\n", "\n", "num_mc", "=", "1", "\n", "main_sample", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ")", ")", "\n", "fixing_sample", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ")", ")", "\n", "\n", "main_effects", ",", "total_effects", ",", "total_variance", "=", "sensitivity", ".", "compute_effects", "(", "\n", "main_sample", "=", "main_sample", ",", "fixing_sample", "=", "fixing_sample", ",", "num_monte_carlo_points", "=", "num_mc", "\n", ")", "\n", "\n", "keys", "=", "space", ".", "parameter_names", "\n", "assert", "all", "(", "k", "in", "main_effects", "for", "k", "in", "keys", ")", "\n", "assert", "all", "(", "k", "in", "total_effects", "for", "k", "in", "keys", ")", "\n", "\n", "expected_shape", "=", "(", "2", ",", ")", "\n", "assert", "all", "(", "v", ".", "shape", "==", "expected_shape", "for", "v", "in", "list", "(", "main_effects", ".", "values", "(", ")", ")", ")", "\n", "assert", "all", "(", "v", ".", "shape", "==", "expected_shape", "for", "v", "in", "list", "(", "total_effects", ".", "values", "(", ")", ")", ")", "\n", "\n", "eps", "=", "1e-6", "\n", "assert", "abs", "(", "total_variance", ")", "<", "eps", ",", "\"constant return value should yield 0 variance\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.test_emukit_sensitivity.test_model_free_montecarlo_sensitivity": [[45, 69], ["emukit.sensitivity.monte_carlo.ModelFreeMonteCarloSensitivity", "numpy.zeros", "emukit.sensitivity.monte_carlo.ModelFreeMonteCarloSensitivity.compute_effects", "all", "all", "all", "all", "numpy.ones", "abs", "numpy.ones", "list", "list", "main_effects.values", "total_effects.values"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.compute_effects"], ["", "def", "test_model_free_montecarlo_sensitivity", "(", "space", ")", ":", "\n", "\n", "    ", "mock_function", "=", "lambda", "x", ":", "0.1", "*", "np", ".", "ones", "(", "(", "3", ",", "1", ")", ")", "\n", "\n", "sensitivity", "=", "ModelFreeMonteCarloSensitivity", "(", "mock_function", ",", "space", ")", "\n", "\n", "num_mc", "=", "1", "\n", "main_sample", "=", "0.1", "*", "np", ".", "ones", "(", "(", "3", ",", "3", ")", ")", "\n", "fixing_sample", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ")", ")", "\n", "\n", "main_effects", ",", "total_effects", ",", "total_variance", "=", "sensitivity", ".", "compute_effects", "(", "\n", "main_sample", "=", "main_sample", ",", "fixing_sample", "=", "fixing_sample", ",", "num_monte_carlo_points", "=", "num_mc", "\n", ")", "\n", "\n", "keys", "=", "space", ".", "parameter_names", "\n", "assert", "all", "(", "k", "in", "main_effects", "for", "k", "in", "keys", ")", "\n", "assert", "all", "(", "k", "in", "total_effects", "for", "k", "in", "keys", ")", "\n", "\n", "expected_shape", "=", "(", "1", ",", ")", "\n", "assert", "all", "(", "v", ".", "shape", "==", "expected_shape", "for", "v", "in", "list", "(", "main_effects", ".", "values", "(", ")", ")", ")", "\n", "assert", "all", "(", "v", ".", "shape", "==", "expected_shape", "for", "v", "in", "list", "(", "total_effects", ".", "values", "(", ")", ")", ")", "\n", "\n", "eps", "=", "1e-6", "\n", "assert", "abs", "(", "total_variance", ")", "<", "eps", ",", "\"constant return value should yield 0 variance\"", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.__init__": [[21, 28], ["core.loop.UserFunctionWrapper"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "objective", ":", "Callable", ",", "input_domain", ":", "ParameterSpace", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param objective: python function in which the sensitivity analysis will be performed.\n        :param input_domain: parameter space.\n        \"\"\"", "\n", "self", ".", "objective", "=", "UserFunctionWrapper", "(", "objective", ")", "\n", "self", ".", "input_domain", "=", "input_domain", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity._generate_samples": [[29, 37], ["int", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.input_domain.sample_uniform", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.input_domain.sample_uniform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform"], ["", "def", "_generate_samples", "(", "self", ",", "num_monte_carlo_points", ":", "int", "=", "int", "(", "1e5", ")", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Generates the two samples that are used to compute the main and total indices\n\n        :param num_monte_carlo_points: number of samples to generate\n        \"\"\"", "\n", "self", ".", "main_sample", "=", "self", ".", "input_domain", ".", "sample_uniform", "(", "num_monte_carlo_points", ")", "\n", "self", ".", "fixing_sample", "=", "self", ".", "input_domain", ".", "sample_uniform", "(", "num_monte_carlo_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.saltelli_estimators": [[38, 58], ["sum", "sum"], "methods", ["None"], ["", "def", "saltelli_estimators", "(", "\n", "self", ",", "\n", "f_main_sample", ":", "np", ".", "ndarray", ",", "\n", "f_fixing_sample", ":", "np", ".", "ndarray", ",", "\n", "f_new_fixing_sample", ":", "np", ".", "ndarray", ",", "\n", "num_monte_carlo_points", ":", "int", ",", "\n", "total_mean", ":", "np", ".", "float64", ",", "\n", "total_variance", ":", "np", ".", "float64", ",", "\n", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Saltelli estimators of the total mean and variance\n        \"\"\"", "\n", "\n", "variable_main_variance", "=", "(", "\n", "sum", "(", "f_main_sample", "*", "f_new_fixing_sample", ")", "/", "(", "num_monte_carlo_points", "-", "1", ")", "-", "total_mean", "**", "2", "\n", ")", "\n", "variable_total_variance", "=", "(", "\n", "total_variance", "-", "sum", "(", "f_fixing_sample", "*", "f_new_fixing_sample", ")", "/", "(", "num_monte_carlo_points", "-", "1", ")", "+", "total_mean", "**", "2", "\n", ")", "\n", "return", "variable_main_variance", ",", "variable_total_variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.compute_statistics": [[59, 67], ["sample.mean", "sample.var"], "methods", ["None"], ["", "def", "compute_statistics", "(", "self", ",", "sample", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Computes mean and variance of a sample\n\n        :param sample: A sample to compute statistics for.\n        :return: A tuple (mean, variance).\n        \"\"\"", "\n", "return", "sample", ".", "mean", "(", ")", ",", "sample", ".", "var", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.compute_effects": [[68, 129], ["int", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.objective.f", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.objective.f", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.compute_statistics", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity._generate_samples", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.fixing_sample.copy", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.objective.f", "monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.saltelli_estimators"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.compute_statistics", "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity._generate_samples", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.saltelli_estimators"], ["", "def", "compute_effects", "(", "\n", "self", ",", "main_sample", ":", "np", ".", "ndarray", "=", "None", ",", "fixing_sample", ":", "np", ".", "ndarray", "=", "None", ",", "num_monte_carlo_points", ":", "int", "=", "int", "(", "1e5", ")", "\n", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Computes the main and total effects using Monte Carlo and a give number of samples.\n        - Main effects: contribution of x_j alone to the variance of f.\n        - Total effects: contribution to all Sobol terms in which x_j is involved to the variance of f.\n\n        The (unbiased) Monte Carlo estimates are computed using:\n\n        \"A. Saltelli, Making best use of model evaluations to compute sensitivity indices, Computer Physics Com.\n        608 munications, 145 (2002), pp. 280-297\"\n\n        :param main_sample: original sample that is used in the Monte Carlo computations.\n        :param fixing_sample: supplementary sample that is used in the Monte Carlo computations.\n        :param num_monte_carlo_points: number of points used to compute the effects.\n\n        :return: A tuple (main effects, total effects, total variance).\n        \"\"\"", "\n", "if", "main_sample", "is", "None", "or", "fixing_sample", "is", "None", ":", "\n", "            ", "self", ".", "num_monte_carlo_points", "=", "num_monte_carlo_points", "\n", "self", ".", "_generate_samples", "(", "self", ".", "num_monte_carlo_points", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "main_sample", "=", "main_sample", "\n", "self", ".", "fixing_sample", "=", "fixing_sample", "\n", "self", ".", "num_monte_carlo_points", "=", "self", ".", "main_sample", ".", "shape", "[", "0", "]", "\n", "\n", "", "f_main_sample", "=", "self", ".", "objective", ".", "f", "(", "self", ".", "main_sample", ")", "\n", "f_fixing_sample", "=", "self", ".", "objective", ".", "f", "(", "self", ".", "fixing_sample", ")", "\n", "\n", "total_mean", ",", "total_variance", "=", "self", ".", "compute_statistics", "(", "f_main_sample", ")", "\n", "variable_names", "=", "self", ".", "input_domain", ".", "parameter_names", "\n", "\n", "main_effects", "=", "{", "}", "\n", "total_effects", "=", "{", "}", "\n", "var_index", "=", "0", "\n", "\n", "for", "variable", "in", "variable_names", ":", "\n", "# --- All columns are the same but the one of interest that is replaced by the original sample", "\n", "            ", "self", ".", "new_fixing_sample", "=", "self", ".", "fixing_sample", ".", "copy", "(", ")", "\n", "self", ".", "new_fixing_sample", "[", ":", ",", "var_index", "]", "=", "self", ".", "main_sample", "[", ":", ",", "var_index", "]", "\n", "\n", "# --- Evaluate the objective at the new fixing sample", "\n", "f_new_fixing_sample", "=", "self", ".", "objective", ".", "f", "(", "self", ".", "new_fixing_sample", ")", "\n", "\n", "# --- Compute the main and total variances", "\n", "variable_main_variance", ",", "variable_total_variance", "=", "self", ".", "saltelli_estimators", "(", "\n", "f_main_sample", ",", "\n", "f_fixing_sample", ",", "\n", "f_new_fixing_sample", ",", "\n", "self", ".", "num_monte_carlo_points", ",", "\n", "total_mean", ",", "\n", "total_variance", ",", "\n", ")", "\n", "\n", "# --- Compute the effects", "\n", "main_effects", "[", "variable", "]", "=", "variable_main_variance", "/", "total_variance", "\n", "total_effects", "[", "variable", "]", "=", "variable_total_variance", "/", "total_variance", "\n", "\n", "var_index", "+=", "1", "\n", "", "return", "main_effects", ",", "total_effects", ",", "total_variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.monte_carlo.monte_carlo_sensitivity.MonteCarloSensitivity.__init__": [[137, 147], ["monte_carlo_sensitivity.ModelFreeMonteCarloSensitivity.__init__", "monte_carlo_sensitivity.MonteCarloSensitivity.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["def", "__init__", "(", "self", ",", "model", ":", "IModel", ",", "input_domain", ":", "ParameterSpace", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param model: model wrapper with the interface IModel.\n        :param input_domain: space class.\n        \"\"\"", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "model_objective", "=", "lambda", "x", ":", "self", ".", "model", ".", "predict", "(", "x", ")", "[", "0", "]", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "model_objective", ",", "input_domain", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.non_linear_sin.multi_fidelity_non_linear_sin": [[7, 33], ["emukit.core.ParameterSpace", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "emukit.core.ContinuousParameter", "emukit.core.InformationSourceParameter", "non_linear_sin.nonlinear_sin_low", "non_linear_sin.nonlinear_sin_high"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.non_linear_sin.nonlinear_sin_low", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.non_linear_sin.nonlinear_sin_high"], ["def", "multi_fidelity_non_linear_sin", "(", "high_fidelity_noise_std_deviation", "=", "0", ",", "low_fidelity_noise_std_deviation", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Two level non-linear sin function where high fidelity is given by:\n\n    .. math::\n        f_{high}(x) = (x - \\sqrt{2}) f_{low}(x)^2\n\n    and the low fidelity is:\n\n    .. math::\n        f_{low}(x) = \\sin(8 \\pi x)\n\n    Reference:\n    Nonlinear information fusion algorithms for data-efficient multi-fidelity modelling.\n    P. Perdikaris, M. Raissi, A. Damianou, N. D. Lawrence and G. E. Karniadakis (2017)\n    http://web.mit.edu/parisp/www/assets/20160751.full.pdf\n    \"\"\"", "\n", "\n", "parameter_space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x1\"", ",", "-", "5", ",", "10", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", ")", "\n", "user_function", "=", "MultiSourceFunctionWrapper", "(", "\n", "[", "\n", "lambda", "x", ":", "nonlinear_sin_low", "(", "x", ",", "low_fidelity_noise_std_deviation", ")", ",", "\n", "lambda", "x", ":", "nonlinear_sin_high", "(", "x", ",", "high_fidelity_noise_std_deviation", ")", ",", "\n", "]", "\n", ")", "\n", "return", "user_function", ",", "parameter_space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.non_linear_sin.nonlinear_sin_low": [[35, 41], ["numpy.sin", "numpy.random.randn"], "function", ["None"], ["", "def", "nonlinear_sin_low", "(", "x", ",", "sd", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Low fidelity version of nonlinear sin function\n    \"\"\"", "\n", "\n", "return", "np", ".", "sin", "(", "8", "*", "np", ".", "pi", "*", "x", ")", "+", "np", ".", "random", ".", "randn", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", "*", "sd", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.non_linear_sin.nonlinear_sin_high": [[43, 49], ["numpy.random.randn", "numpy.sqrt", "non_linear_sin.nonlinear_sin_low"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.non_linear_sin.nonlinear_sin_low"], ["", "def", "nonlinear_sin_high", "(", "x", ",", "sd", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    High fidelity version of nonlinear sin function\n    \"\"\"", "\n", "\n", "return", "(", "x", "-", "np", ".", "sqrt", "(", "2", ")", ")", "*", "nonlinear_sin_low", "(", "x", ",", "0", ")", "**", "2", "+", "np", ".", "random", ".", "randn", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", "*", "sd", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.sixhumpcamel.sixhumpcamel_function": [[8, 21], ["emukit.core.ParameterSpace", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["None"], ["def", "sixhumpcamel_function", "(", ")", ":", "\n", "    ", "\"\"\"\n    Two-dimensional SixHumpCamel function, often used as an optimization benchmark.\n\n    Based on: https://www.sfu.ca/~ssurjano/camel6.html\n\n    .. math::\n        f(\\mathbf{x}) = \\left(4-2.1x_1^2 = \\frac{x_1^4}{3} \\right)x_1^2 + x_1x_2 + (-4 +4x_2^2)x_2^2\n\n    \"\"\"", "\n", "\n", "parameter_space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x1\"", ",", "-", "2", ",", "2", ")", ",", "ContinuousParameter", "(", "\"x2\"", ",", "-", "1", ",", "1", ")", "]", ")", "\n", "return", "_sixhumpcamel", ",", "parameter_space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.sixhumpcamel._sixhumpcamel": [[23, 31], ["None"], "function", ["None"], ["", "def", "_sixhumpcamel", "(", "x", ")", ":", "\n", "    ", "x1", "=", "x", "[", ":", ",", "0", "]", "\n", "x2", "=", "x", "[", ":", ",", "1", "]", "\n", "term1", "=", "(", "4", "-", "2.1", "*", "x1", "**", "2", "+", "(", "x1", "**", "4", ")", "/", "3", ")", "*", "x1", "**", "2", "\n", "term2", "=", "x1", "*", "x2", "\n", "term3", "=", "(", "-", "4", "+", "4", "*", "x2", "**", "2", ")", "*", "x2", "**", "2", "\n", "y", "=", "term1", "+", "term2", "+", "term3", "\n", "return", "y", "[", ":", ",", "None", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin.branin_function": [[10, 35], ["emukit.core.ParameterSpace", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["None"], ["def", "branin_function", "(", ")", ":", "\n", "    ", "\"\"\"\n    Two-dimensional Branin, often used as an optimization benchmark.\n\n    Based on: https://www.sfu.ca/~ssurjano/branin.html\n\n    .. math::\n        f(\\mathbf{x}) = (x_2 - b x_1 ^ 2 + c x_1 - r) ^ 2 + s(1 - t) \\cos(x_1) + s\n\n    where:\n\n    .. math::\n        b = 5.1 / (4 \\pi ^ 2)\n\n        c = 5 /\\pi\n\n        r = 6\n\n        s = 10\n\n        t = 1 / (8\\pi)\n    \"\"\"", "\n", "\n", "parameter_space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x1\"", ",", "-", "5", ",", "10", ")", ",", "ContinuousParameter", "(", "\"x2\"", ",", "0", ",", "15", ")", "]", ")", "\n", "return", "_branin", ",", "parameter_space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin._branin": [[37, 52], ["numpy.cos"], "function", ["None"], ["", "def", "_branin", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    :param x: n_points x 2 array of input locations to evaluate\n    :return: n_points x 1 array of function evaluations\n    \"\"\"", "\n", "a", "=", "1", "\n", "b", "=", "5.1", "/", "(", "4", "*", "np", ".", "pi", "**", "2", ")", "\n", "c", "=", "5", "/", "np", ".", "pi", "\n", "r", "=", "6", "\n", "s", "=", "10", "\n", "t", "=", "1", "/", "(", "8", "*", "np", ".", "pi", ")", "\n", "x1", "=", "x", "[", ":", ",", "0", "]", "\n", "x2", "=", "x", "[", ":", ",", "1", "]", "\n", "y", "=", "a", "*", "(", "x2", "-", "b", "*", "x1", "**", "2", "+", "c", "*", "x1", "-", "r", ")", "**", "2", "+", "s", "*", "(", "1", "-", "t", ")", "*", "np", ".", "cos", "(", "x1", ")", "+", "s", "\n", "return", "y", "[", ":", ",", "None", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.multi_fidelity_forrester_function": [[11, 37], ["emukit.core.ParameterSpace", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "emukit.core.ContinuousParameter", "emukit.core.InformationSourceParameter", "forrester.forrester_low", "forrester.forrester"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_low", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester"], ["def", "multi_fidelity_forrester_function", "(", "high_fidelity_noise_std_deviation", "=", "0", ",", "low_fidelity_noise_std_deviation", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Two-level multi-fidelity forrester function where the high fidelity is given by:\n\n    .. math::\n        f(x) = (6x - 2)^2 \\sin(12x - 4)\n\n    and the low fidelity approximation given by:\n\n    .. math::\n        f_{low}(x) = 0.5 f_{high}(x) + 10 (x - 0.5) + 5\n\n    :param high_fidelity_noise_std_deviation: Standard deviation of observation noise on high fidelity observations.\n                                              Defaults to zero.\n    :param low_fidelity_noise_std_deviation: Standard deviation of observation noise on low fidelity observations.\n                                             Defaults to zero.\n    :return: Tuple of user function object and parameter space object\n    \"\"\"", "\n", "parameter_space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", ")", "\n", "user_function", "=", "MultiSourceFunctionWrapper", "(", "\n", "[", "\n", "lambda", "x", ":", "forrester_low", "(", "x", ",", "low_fidelity_noise_std_deviation", ")", ",", "\n", "lambda", "x", ":", "forrester", "(", "x", ",", "high_fidelity_noise_std_deviation", ")", ",", "\n", "]", "\n", ")", "\n", "return", "user_function", ",", "parameter_space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_function": [[39, 54], ["forrester.forrester", "emukit.core.ParameterSpace", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester"], ["", "def", "forrester_function", "(", "noise_standard_deviation", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Forrester function\n\n    .. math::\n        f(x) = (6x - 2)^2 \\sin(12x - 4)\n\n    :param noise_standard_deviation: Standard deviation of normally distributed observation noise\n    :return: Tuple of function and parameter space object\n    \"\"\"", "\n", "\n", "def", "forrester_fcn", "(", "x", ")", ":", "\n", "        ", "return", "forrester", "(", "x", ",", "sd", "=", "noise_standard_deviation", ")", "\n", "\n", "", "return", "forrester_fcn", ",", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester": [[56, 72], ["x.reshape.reshape", "numpy.sin", "numpy.zeros().reshape", "numpy.random.normal().reshape", "fval.reshape", "len", "numpy.zeros", "numpy.random.normal"], "function", ["None"], ["", "def", "forrester", "(", "x", ",", "sd", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Forrester function\n\n    :param x: input vector to be evaluated\n    :param sd: standard deviation of noise parameter\n    :return: outputs of the function\n    \"\"\"", "\n", "x", "=", "x", ".", "reshape", "(", "(", "len", "(", "x", ")", ",", "1", ")", ")", "\n", "n", "=", "x", ".", "shape", "[", "0", "]", "\n", "fval", "=", "(", "(", "6", "*", "x", "-", "2", ")", "**", "2", ")", "*", "np", ".", "sin", "(", "12", "*", "x", "-", "4", ")", "\n", "if", "sd", "==", "0", ":", "\n", "        ", "noise", "=", "np", ".", "zeros", "(", "n", ")", ".", "reshape", "(", "n", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "noise", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "sd", ",", "n", ")", ".", "reshape", "(", "n", ",", "1", ")", "\n", "", "return", "fval", ".", "reshape", "(", "n", ",", "1", ")", "+", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_low": [[74, 84], ["forrester.forrester", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester"], ["", "def", "forrester_low", "(", "x", ",", "sd", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Low fidelity forrester function approximation:\n\n    :param x: input vector to be evaluated\n    :param sd: standard deviation of observation noise at low fidelity\n    :return: outputs of the function\n    \"\"\"", "\n", "high_fidelity", "=", "forrester", "(", "x", ",", "0", ")", "\n", "return", "0.5", "*", "high_fidelity", "+", "10", "*", "(", "x", "[", ":", ",", "[", "0", "]", "]", "-", "0.5", ")", "+", "5", "+", "np", ".", "random", ".", "randn", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", "*", "sd", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_sixhumpcamel.test_sixhumpcamel_minima": [[6, 14], ["emukit.test_functions.sixhumpcamel_function", "numpy.isclose", "numpy.isclose", "sixhumpcamel", "sixhumpcamel", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.sixhumpcamel.sixhumpcamel_function"], ["def", "test_sixhumpcamel_minima", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test some known values at minima\n    \"\"\"", "\n", "sixhumpcamel", ",", "_", "=", "sixhumpcamel_function", "(", ")", "\n", "minimum", "=", "-", "1.0316", "# value of function at minima", "\n", "assert", "np", ".", "isclose", "(", "sixhumpcamel", "(", "np", ".", "array", "(", "[", "[", "0.0898", ",", "-", "0.7126", "]", "]", ")", ")", ",", "minimum", ",", "atol", "=", "1e-3", ")", "\n", "assert", "np", ".", "isclose", "(", "sixhumpcamel", "(", "np", ".", "array", "(", "[", "[", "-", "0.0898", ",", "0.7126", "]", "]", ")", ")", ",", "minimum", ",", "atol", "=", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_sixhumpcamel.test_sixhumpcamel_return_shape": [[16, 24], ["emukit.test_functions.sixhumpcamel_function", "numpy.array", "sixhumpcamel", "sixhumpcamel"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.sixhumpcamel.sixhumpcamel_function"], ["", "def", "test_sixhumpcamel_return_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "sixhumpcamel", ",", "_", "=", "sixhumpcamel_function", "(", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "7.5", ",", "7.5", "]", ",", "[", "10.0", ",", "10.0", "]", "]", ")", "\n", "assert", "sixhumpcamel", "(", "x", ")", ".", "ndim", "==", "2", "\n", "assert", "sixhumpcamel", "(", "x", ")", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_sombrero2d.test_sombrero2D_return_shape": [[10, 19], ["emukit.test_functions.quadrature.sombrero2D", "numpy.ones", "sombrero2D_func.f"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.sombrero2D.sombrero2D", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["def", "test_sombrero2D_return_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "sombrero2D_func", ",", "_", "=", "sombrero2D", "(", ")", "\n", "x", "=", "np", ".", "ones", "(", "(", "3", ",", "2", ")", ")", "\n", "result", "=", "sombrero2D_func", ".", "f", "(", "x", ")", "\n", "assert", "result", ".", "ndim", "==", "2", "\n", "assert", "result", ".", "shape", "==", "(", "3", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_nonlinear_sin.test_non_linear_high_return_shape": [[6, 12], ["numpy.array", "emukit.test_functions.non_linear_sin.nonlinear_sin_high"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.non_linear_sin.nonlinear_sin_high"], ["def", "test_non_linear_high_return_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "0.2", "]", ",", "[", "0.4", "]", "]", ")", "\n", "assert", "nonlinear_sin_high", "(", "x", ",", "0", ")", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_nonlinear_sin.test_non_linear_low_return_shape": [[14, 20], ["numpy.array", "emukit.test_functions.non_linear_sin.nonlinear_sin_low"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.non_linear_sin.nonlinear_sin_low"], ["", "def", "test_non_linear_low_return_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "0.2", "]", ",", "[", "0.4", "]", "]", ")", "\n", "assert", "nonlinear_sin_low", "(", "x", ",", "0", ")", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_forrester.test_forrester_return_shape": [[7, 15], ["emukit.test_functions.forrester_function", "numpy.array", "branin", "branin"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_function"], ["def", "test_forrester_return_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "branin", ",", "_", "=", "forrester_function", "(", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "0.75", "]", ",", "[", "0.10", "]", "]", ")", "\n", "assert", "branin", "(", "x", ")", ".", "ndim", "==", "2", "\n", "assert", "branin", "(", "x", ")", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_forrester.test_forrester_low_return_shape": [[17, 20], ["numpy.array", "emukit.test_functions.forrester.forrester_low"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_low"], ["", "def", "test_forrester_low_return_shape", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "array", "(", "[", "[", "0.2", "]", ",", "[", "0.4", "]", "]", ")", "\n", "assert", "forrester_low", "(", "x", ",", "0", ")", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_baselines.test_univariate_approximate_ground_truth_integral_shape": [[11, 17], ["emukit.test_functions.quadrature.baselines.univariate_approximate_ground_truth_integral", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.baselines.univariate_approximate_ground_truth_integral"], ["def", "test_univariate_approximate_ground_truth_integral_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "res", "=", "univariate_approximate_ground_truth_integral", "(", "lambda", "x", ":", "1.0", ",", "(", "0.0", ",", "1.0", ")", ")", "\n", "assert", "len", "(", "res", ")", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_baselines.test_bivariate_approximate_ground_truth_integral_shape": [[19, 25], ["emukit.test_functions.quadrature.baselines.bivariate_approximate_ground_truth_integral", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.baselines.bivariate_approximate_ground_truth_integral"], ["", "def", "test_bivariate_approximate_ground_truth_integral_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "res", "=", "bivariate_approximate_ground_truth_integral", "(", "lambda", "x", ":", "1.0", ",", "2", "*", "[", "(", "0.0", ",", "1.0", ")", "]", ")", "\n", "assert", "len", "(", "res", ")", "==", "2", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_hennig1d.test_hennig1D_return_shape": [[10, 19], ["emukit.test_functions.quadrature.hennig1D", "numpy.zeros", "hennig1d_func.f"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.hennig1D.hennig1D", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["def", "test_hennig1D_return_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "hennig1d_func", ",", "_", "=", "hennig1D", "(", ")", "\n", "x", "=", "np", ".", "zeros", "(", "(", "2", ",", "1", ")", ")", "\n", "result", "=", "hennig1d_func", ".", "f", "(", "x", ")", "\n", "assert", "result", ".", "ndim", "==", "2", "\n", "assert", "result", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_circular_gaussian.test_circular_gaussian_return_shape": [[10, 19], ["emukit.test_functions.quadrature.circular_gaussian", "numpy.ones", "circular_gaussian_func.f"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.circular_gaussian.circular_gaussian", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["def", "test_circular_gaussian_return_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "circular_gaussian_func", ",", "_", "=", "circular_gaussian", "(", ")", "\n", "x", "=", "np", ".", "ones", "(", "(", "3", ",", "2", ")", ")", "\n", "result", "=", "circular_gaussian_func", ".", "f", "(", "x", ")", "\n", "assert", "result", ".", "ndim", "==", "2", "\n", "assert", "result", ".", "shape", "==", "(", "3", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_branin.test_branin_minima": [[6, 15], ["emukit.test_functions.branin_function", "numpy.isclose", "numpy.isclose", "numpy.isclose", "branin", "branin", "branin", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin.branin_function"], ["def", "test_branin_minima", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test some known values at minima\n    \"\"\"", "\n", "branin", ",", "_", "=", "branin_function", "(", ")", "\n", "minimum", "=", "0.39788", "# value of function at minima", "\n", "assert", "np", ".", "isclose", "(", "branin", "(", "np", ".", "array", "(", "[", "[", "-", "np", ".", "pi", ",", "12.275", "]", "]", ")", ")", ",", "minimum", ",", "atol", "=", "1e-3", ")", "\n", "assert", "np", ".", "isclose", "(", "branin", "(", "np", ".", "array", "(", "[", "[", "np", ".", "pi", ",", "2.275", "]", "]", ")", ")", ",", "minimum", ",", "atol", "=", "1e-3", ")", "\n", "assert", "np", ".", "isclose", "(", "branin", "(", "np", ".", "array", "(", "[", "[", "9.42478", ",", "2.475", "]", "]", ")", ")", ",", "minimum", ",", "atol", "=", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_branin.test_branin_return_shape": [[17, 25], ["emukit.test_functions.branin_function", "numpy.array", "branin", "branin"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin.branin_function"], ["", "def", "test_branin_return_shape", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test output dimension is 2d\n    \"\"\"", "\n", "branin", ",", "_", "=", "branin_function", "(", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "7.5", ",", "7.5", "]", ",", "[", "10.0", ",", "10.0", "]", "]", ")", "\n", "assert", "branin", "(", "x", ")", ".", "ndim", "==", "2", "\n", "assert", "branin", "(", "x", ")", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_multi_fidelity_functions.test_multi_fidelity_function_shapes": [[13, 50], ["pytest.mark.parametrize", "fcn", "emukit.core.initial_designs.RandomDesign", "emukit.core.initial_designs.RandomDesign.get_samples", "len", "fcn.evaluate", "len", "ValueError", "f"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"fcn\"", ",", "\n", "[", "\n", "multi_fidelity_borehole_function", ",", "\n", "multi_fidelity_branin_function", ",", "\n", "multi_fidelity_currin_function", ",", "\n", "multi_fidelity_hartmann_3d", ",", "\n", "multi_fidelity_park_function", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_multi_fidelity_function_shapes", "(", "fcn", ")", ":", "\n", "    ", "n_points", "=", "10", "\n", "fcn", ",", "space", "=", "fcn", "(", ")", "\n", "random", "=", "RandomDesign", "(", "space", ")", "\n", "samples", "=", "random", ".", "get_samples", "(", "n_points", ")", "\n", "\n", "# There are only 2 or 3 fidelity functions in set of functions we are testing", "\n", "n_fidelities", "=", "len", "(", "space", ".", "parameters", "[", "-", "1", "]", ".", "domain", ")", "\n", "if", "n_fidelities", "==", "2", ":", "\n", "        ", "samples", "[", ":", "5", ",", "-", "1", "]", "=", "0", "\n", "samples", "[", "5", ":", ",", "-", "1", "]", "=", "1", "\n", "", "elif", "n_fidelities", "==", "3", ":", "\n", "        ", "samples", "[", ":", "5", ",", "-", "1", "]", "=", "0", "\n", "samples", "[", "5", ":", "8", ",", "-", "1", "]", "=", "1", "\n", "samples", "[", "8", ":", ",", "-", "1", "]", "=", "2", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Please add a case for functions with {:.0f} fidelity levels\"", ".", "format", "(", "n_fidelities", ")", ")", "\n", "\n", "# Check shapes when calling through function wrapper", "\n", "", "results", "=", "fcn", ".", "evaluate", "(", "samples", ")", "\n", "assert", "len", "(", "results", ")", "==", "n_points", "\n", "for", "result", "in", "results", ":", "\n", "        ", "assert", "result", ".", "Y", ".", "shape", "==", "(", "1", ",", ")", "\n", "\n", "# Also check shape when calling each fidelity function individually", "\n", "", "for", "f", "in", "fcn", ".", "f", ":", "\n", "        ", "assert", "f", "(", "samples", "[", ":", ",", ":", "-", "1", "]", ")", ".", "shape", "==", "(", "n_points", ",", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_hennig2d.test_hennig2D_return_shape": [[10, 16], ["emukit.test_functions.quadrature.hennig2D", "numpy.ones", "func.f"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.hennig2D.hennig2D", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["def", "test_hennig2D_return_shape", "(", ")", ":", "\n", "    ", "func", ",", "_", "=", "hennig2D", "(", ")", "\n", "x", "=", "np", ".", "ones", "(", "(", "3", ",", "2", ")", ")", "\n", "result", "=", "func", ".", "f", "(", "x", ")", "\n", "assert", "result", ".", "ndim", "==", "2", "\n", "assert", "result", ".", "shape", "==", "(", "3", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.test_functions.test_ishigami_function.test_ishigami_function": [[6, 22], ["emukit.test_functions.sensitivity.Ishigami", "emukit.test_functions.sensitivity.Ishigami.fidelity1", "emukit.test_functions.sensitivity.Ishigami.fidelity2", "emukit.test_functions.sensitivity.Ishigami.fidelity3", "emukit.test_functions.sensitivity.Ishigami.fidelity4", "emukit.test_functions.sensitivity.Ishigami.f1", "emukit.test_functions.sensitivity.Ishigami.f2", "emukit.test_functions.sensitivity.Ishigami.f3", "emukit.test_functions.sensitivity.Ishigami.f12", "emukit.test_functions.sensitivity.Ishigami.f13", "emukit.test_functions.sensitivity.Ishigami.f23", "emukit.test_functions.sensitivity.Ishigami.f123", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.fidelity1", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.fidelity2", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.fidelity3", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.fidelity4", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f1", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f2", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f3", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f12", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f13", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f23", "home.repos.pwc.inspect_result.amzn_emukit.sensitivity.ishigami.Ishigami.f123"], ["def", "test_ishigami_function", "(", ")", ":", "\n", "\n", "    ", "ishigami", "=", "Ishigami", "(", "a", "=", "5", ",", "b", "=", "0.1", ")", "\n", "\n", "assert", "ishigami", ".", "fidelity1", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "assert", "ishigami", ".", "fidelity2", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "assert", "ishigami", ".", "fidelity3", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "assert", "ishigami", ".", "fidelity4", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "\n", "assert", "ishigami", ".", "f1", "(", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", "1", ")", "\n", "assert", "ishigami", ".", "f2", "(", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", "1", ")", "\n", "assert", "ishigami", ".", "f3", "(", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "assert", "ishigami", ".", "f12", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "assert", "ishigami", ".", "f13", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "assert", "ishigami", ".", "f23", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "assert", "ishigami", ".", "f123", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", "]", ")", ")", ".", "shape", "==", "(", "1", ",", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.circular_gaussian.circular_gaussian": [[12, 31], ["circular_gaussian._circular_gaussian", "emukit.core.loop.user_function.UserFunctionWrapper"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.circular_gaussian._circular_gaussian"], ["def", "circular_gaussian", "(", "\n", "mean", ":", "float", "=", "0.0", ",", "variance", ":", "float", "=", "1.0", "\n", ")", "->", "Tuple", "[", "UserFunctionWrapper", ",", "List", "[", "Tuple", "[", "float", ",", "float", "]", "]", "]", ":", "\n", "    ", "r\"\"\"2D toy integrand that is a Gaussian on a circle.\n\n    .. math::\n        f(x) = (2\\pi \\sigma^2)^{-\\frac{1}{2}} r^2 e^{-\\frac{(r - \\mu)^2}{2 \\sigma^2}}\n\n    where :math:`\\sigma^2` is the :attr:`variance` attribute,\n    :math:`\\mu` is the :attr:`mean` attribute\n    and :math:`r = \\|x\\|` is the length of the input :math:`x`.\n\n    :param mean: The mean of the circular Gaussian in units of radius (must be >= 0, defaults to 0).\n    :param variance: The variance of the Gaussian (must be > 0, defaults to 1.).\n    :return: The wrapped test function, and the integrals bounds (the latter defaults to [-3, 3]^2).\n    \"\"\"", "\n", "func", "=", "lambda", "x", ":", "_circular_gaussian", "(", "x", ",", "mean", ",", "variance", ")", "\n", "integral_bounds", "=", "2", "*", "[", "(", "-", "3.0", ",", "3.0", ")", "]", "\n", "return", "UserFunctionWrapper", "(", "func", ")", ",", "integral_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.circular_gaussian._circular_gaussian": [[33, 42], ["numpy.sqrt", "numpy.sqrt", "numpy.exp"], "function", ["None"], ["", "def", "_circular_gaussian", "(", "x", ":", "np", ".", "ndarray", ",", "mean", ":", "float", ",", "variance", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    :param x: Locations for evaluation (num_points, 2).\n    :param mean: The mean of Gaussian in units of radius (must be >= 0).\n    :param variance: The variance of the Gaussian (must be > 0).\n    :return: The function values at x, shape (num_points, 1).\n    \"\"\"", "\n", "norm_x", "=", "np", ".", "sqrt", "(", "(", "x", "**", "2", ")", ".", "sum", "(", "axis", "=", "1", ",", "keepdims", "=", "True", ")", ")", "\n", "return", "norm_x", "**", "2", "*", "np", ".", "exp", "(", "-", "(", "(", "norm_x", "-", "mean", ")", "**", "2", ")", "/", "(", "2.0", "*", "variance", ")", ")", "/", "np", ".", "sqrt", "(", "2.0", "*", "np", ".", "pi", "*", "variance", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.hennig1D.hennig1D": [[12, 26], ["emukit.core.loop.user_function.UserFunctionWrapper"], "function", ["None"], ["def", "hennig1D", "(", ")", "->", "Tuple", "[", "UserFunctionWrapper", ",", "List", "[", "Tuple", "[", "float", ",", "float", "]", "]", "]", ":", "\n", "    ", "r\"\"\"1D toy integrand coined by Philipp Hennig.\n\n    One of the earlier mentions e.g., in `this talk <https://youtu.be/tZ9CP-kQAVI?t=704>`_\n    (external link).\n\n    .. math::\n        f(x) = e^{-x^2 -\\sin^2(3x)}\n\n    :return: The wrapped test function, and the integrals bounds\n             (the latter default to [-3, 3]).\n    \"\"\"", "\n", "integral_bounds", "=", "[", "(", "-", "3.0", ",", "3.0", ")", "]", "\n", "return", "UserFunctionWrapper", "(", "_hennig1D", ")", ",", "integral_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.hennig1D._hennig1D": [[28, 34], ["numpy.exp", "numpy.sin"], "function", ["None"], ["", "def", "_hennig1D", "(", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    :param x: Locations for evaluation (num_points, 1).\n    :return: The function values at x, shape (num_points, 1).\n    \"\"\"", "\n", "return", "np", ".", "exp", "(", "-", "(", "x", "**", "2", ")", "-", "np", ".", "sin", "(", "3.0", "*", "x", ")", "**", "2", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.hennig2D.hennig2D": [[12, 23], ["emukit.core.loop.user_function.UserFunctionWrapper"], "function", ["None"], ["def", "hennig2D", "(", ")", "->", "Tuple", "[", "UserFunctionWrapper", ",", "List", "[", "Tuple", "[", "float", ",", "float", "]", "]", "]", ":", "\n", "    ", "r\"\"\"2D toy integrand coined by Philipp Hennig.\n\n    .. math::\n        f(x) = e^{-x'Sx -\\sin(3\\|x\\|^2)}\n\n    :return: The wrapped test function, and the integrals bounds\n             (the latter default to [-3, 3]^2).\n    \"\"\"", "\n", "integral_bounds", "=", "2", "*", "[", "(", "-", "3.0", ",", "3.0", ")", "]", "\n", "return", "UserFunctionWrapper", "(", "_hennig2D", ")", ",", "integral_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.hennig2D._hennig2D": [[25, 34], ["numpy.exp", "numpy.reshape", "numpy.array", "numpy.sum", "numpy.sin", "numpy.sum"], "function", ["None"], ["", "def", "_hennig2D", "(", "x", ":", "np", ".", "ndarray", ",", "S", ":", "np", ".", "ndarray", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    :param x: Locations for evaluation (num_points, 2).\n    :return: The function values at x, shape (num_points, 2).\n    \"\"\"", "\n", "if", "S", "is", "None", ":", "\n", "        ", "S", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0.5", "]", ",", "[", "0.5", ",", "1", "]", "]", ")", "\n", "", "f", "=", "np", ".", "exp", "(", "-", "np", ".", "sin", "(", "3", "*", "np", ".", "sum", "(", "x", "**", "2", ",", "axis", "=", "1", ")", ")", "-", "np", ".", "sum", "(", "(", "x", "@", "S", ")", "*", "x", ",", "axis", "=", "1", ")", ")", "\n", "return", "np", ".", "reshape", "(", "f", ",", "[", "x", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.baselines.univariate_approximate_ground_truth_integral": [[11, 21], ["scipy.integrate.quad"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.quad"], ["def", "univariate_approximate_ground_truth_integral", "(", "func", ",", "integral_bounds", ":", "Tuple", "[", "float", ",", "float", "]", ")", ":", "\n", "    ", "\"\"\"Estimate the 1D ground truth integral.\n\n    :param func: A univariate function.\n    :param integral_bounds: Bounds of the integral.\n    :returns: The integral estimate (output of scipy.integrate.quad).\n    \"\"\"", "\n", "lower_bound", "=", "integral_bounds", "[", "0", "]", "\n", "upper_bound", "=", "integral_bounds", "[", "1", "]", "\n", "return", "quad", "(", "func", ",", "lower_bound", ",", "upper_bound", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.baselines.bivariate_approximate_ground_truth_integral": [[23, 44], ["scipy.integrate.dblquad", "numpy.array", "numpy.reshape", "func"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.func"], ["", "def", "bivariate_approximate_ground_truth_integral", "(", "func", ",", "integral_bounds", ":", "List", "[", "Tuple", "[", "float", ",", "float", "]", "]", ")", ":", "\n", "    ", "\"\"\"Estimate the 2D ground truth integral.\n\n    :param func: A bivariate function.\n    :param integral_bounds: Bounds of the integral.\n    :returns: The integral estimate (output of scipy.integrate.dblquad).\n    \"\"\"", "\n", "\n", "def", "func_dblquad", "(", "x", ",", "y", ")", ":", "\n", "        ", "z", "=", "np", ".", "array", "(", "[", "x", ",", "y", "]", ")", "\n", "z", "=", "np", ".", "reshape", "(", "z", ",", "[", "1", ",", "2", "]", ")", "\n", "return", "func", "(", "z", ")", "\n", "\n", "", "lower_bound_x", "=", "integral_bounds", "[", "0", "]", "[", "0", "]", "\n", "upper_bound_x", "=", "integral_bounds", "[", "0", "]", "[", "1", "]", "\n", "\n", "lower_bound_y", "=", "integral_bounds", "[", "1", "]", "[", "0", "]", "\n", "upper_bound_y", "=", "integral_bounds", "[", "1", "]", "[", "1", "]", "\n", "\n", "return", "dblquad", "(", "\n", "func", "=", "func_dblquad", ",", "a", "=", "lower_bound_x", ",", "b", "=", "upper_bound_x", ",", "gfun", "=", "lambda", "x", ":", "lower_bound_y", ",", "hfun", "=", "lambda", "x", ":", "upper_bound_y", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.sombrero2D.sombrero2D": [[12, 27], ["sombrero2D._sombrero2D", "emukit.core.loop.user_function.UserFunctionWrapper"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.sombrero2D._sombrero2D"], ["def", "sombrero2D", "(", "freq", ":", "float", "=", "1.0", ")", "->", "Tuple", "[", "UserFunctionWrapper", ",", "List", "[", "Tuple", "[", "float", ",", "float", "]", "]", "]", ":", "\n", "    ", "r\"\"\"2D Sombrero function.\n\n    .. math::\n        f(x) = \\frac{\\operatorname{sin}(\\pi r \\omega)}{\\pi r \\omega}\n\n    where :math:`\\omega` is the :attr:`freq` parameter and :math:`r=\\|x\\|` is the length\n    of the input vector :math:`x`.\n\n    :param freq: The frequency of the sombrero (must be > 0, defaults to 1).\n    :return: The wrapped test function, and the integrals bounds (the latter defaults to [-3, 3]^2).\n    \"\"\"", "\n", "func", "=", "lambda", "x", ":", "_sombrero2D", "(", "x", ",", "freq", ")", "\n", "integral_bounds", "=", "2", "*", "[", "(", "-", "3.0", ",", "3.0", ")", "]", "\n", "return", "UserFunctionWrapper", "(", "func", ")", ",", "integral_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.sombrero2D._sombrero2D": [[29, 40], ["numpy.sqrt", "numpy.sin", "numpy.isnan"], "function", ["None"], ["", "def", "_sombrero2D", "(", "x", ":", "np", ".", "ndarray", ",", "freq", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    :param x: Locations for evaluation (num_points, 2).\n    :param freq: The frequency of the sombrero (must be > 0).\n    :return: The function values at x, shape (num_points, 1).\n    \"\"\"", "\n", "r", "=", "np", ".", "sqrt", "(", "(", "x", "*", "x", ")", ".", "sum", "(", "axis", "=", "1", ")", ")", "\n", "r_scaled", "=", "(", "np", ".", "pi", "*", "freq", ")", "*", "r", "\n", "result", "=", "np", ".", "sin", "(", "r_scaled", ")", "/", "r_scaled", "\n", "result", "[", "np", ".", "isnan", "(", "result", ")", "]", "=", "1.0", "\n", "return", "result", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_gpy_model": [[32, 36], ["test_quadrature_models.DataGaussianSpread", "GPy.kern.RBF", "GPy.models.GPRegression"], "function", ["None"], ["", "def", "get_gpy_model", "(", ")", ":", "\n", "    ", "dat", "=", "DataGaussianSpread", "(", ")", "\n", "gpy_kern", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "dat", ".", "D", ")", "\n", "return", "GPy", ".", "models", ".", "GPRegression", "(", "X", "=", "dat", ".", "X", ",", "Y", "=", "dat", ".", "Y", ",", "kernel", "=", "gpy_kern", ")", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_base_gp": [[38, 43], ["test_quadrature_models.get_gpy_model", "emukit.quadrature.measures.GaussianMeasure", "emukit.quadrature.kernels.QuadratureRBFGaussianMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_gpy_model"], ["", "def", "get_base_gp", "(", ")", ":", "\n", "    ", "gpy_model", ",", "dat", "=", "get_gpy_model", "(", ")", "\n", "measure", "=", "GaussianMeasure", "(", "mean", "=", "dat", ".", "measure_mean", ",", "variance", "=", "dat", ".", "measure_var", ")", "\n", "qrbf", "=", "QuadratureRBFGaussianMeasure", "(", "RBFGPy", "(", "gpy_model", ".", "kern", ")", ",", "measure", "=", "measure", ")", "\n", "return", "BaseGaussianProcessGPy", "(", "kern", "=", "qrbf", ",", "gpy_model", "=", "gpy_model", ")", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_vanilla_bq_model": [[45, 48], ["test_quadrature_models.get_base_gp", "emukit.quadrature.methods.vanilla_bq.VanillaBayesianQuadrature"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_base_gp"], ["", "def", "get_vanilla_bq_model", "(", ")", ":", "\n", "    ", "base_gp", ",", "dat", "=", "get_base_gp", "(", ")", "\n", "return", "VanillaBayesianQuadrature", "(", "base_gp", "=", "base_gp", ",", "X", "=", "dat", ".", "X", ",", "Y", "=", "dat", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_bounded_bq_lower": [[50, 53], ["test_quadrature_models.get_base_gp", "emukit.quadrature.methods.BoundedBayesianQuadrature"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_base_gp"], ["", "def", "get_bounded_bq_lower", "(", ")", ":", "\n", "    ", "base_gp", ",", "dat", "=", "get_base_gp", "(", ")", "\n", "return", "BoundedBayesianQuadrature", "(", "base_gp", "=", "base_gp", ",", "X", "=", "dat", ".", "X", ",", "Y", "=", "dat", ".", "Y", ",", "lower_bound", "=", "dat", ".", "bound_lower", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_bounded_bq_upper": [[55, 58], ["test_quadrature_models.get_base_gp", "emukit.quadrature.methods.BoundedBayesianQuadrature"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_base_gp"], ["", "def", "get_bounded_bq_upper", "(", ")", ":", "\n", "    ", "base_gp", ",", "dat", "=", "get_base_gp", "(", ")", "\n", "return", "BoundedBayesianQuadrature", "(", "base_gp", "=", "base_gp", ",", "X", "=", "dat", ".", "X", ",", "Y", "=", "dat", ".", "Y", ",", "upper_bound", "=", "dat", ".", "bound_upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_wsabil_adapt": [[60, 63], ["test_quadrature_models.get_base_gp", "emukit.quadrature.methods.WSABIL"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_base_gp"], ["", "def", "get_wsabil_adapt", "(", ")", ":", "\n", "    ", "base_gp", ",", "dat", "=", "get_base_gp", "(", ")", "\n", "return", "WSABIL", "(", "base_gp", "=", "base_gp", ",", "X", "=", "dat", ".", "X", ",", "Y", "=", "dat", ".", "Y", ",", "adapt_alpha", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_wsabil_fixed": [[65, 69], ["test_quadrature_models.get_base_gp", "emukit.quadrature.methods.WSABIL"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_base_gp"], ["", "def", "get_wsabil_fixed", "(", ")", ":", "\n", "    ", "base_gp", ",", "dat", "=", "get_base_gp", "(", ")", "\n", "wsabil", "=", "WSABIL", "(", "base_gp", "=", "base_gp", ",", "X", "=", "dat", ".", "X", ",", "Y", "=", "dat", ".", "Y", ",", "adapt_alpha", "=", "False", ")", "\n", "return", "wsabil", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.data": [[72, 75], ["test_quadrature_models.DataGaussianSpread"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "data", "(", ")", ":", "\n", "    ", "return", "DataGaussianSpread", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.gpy_model": [[77, 80], ["test_quadrature_models.get_gpy_model"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_gpy_model"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_model", "(", ")", ":", "\n", "    ", "return", "get_gpy_model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.base_gp": [[82, 85], ["test_quadrature_models.get_base_gp"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_base_gp"], ["", "@", "pytest", ".", "fixture", "\n", "def", "base_gp", "(", ")", ":", "\n", "    ", "return", "get_base_gp", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.vanilla_bq": [[87, 90], ["test_quadrature_models.get_vanilla_bq_model"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_vanilla_bq_model"], ["", "@", "pytest", ".", "fixture", "\n", "def", "vanilla_bq", "(", ")", ":", "\n", "    ", "return", "get_vanilla_bq_model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.bounded_bq_lower": [[92, 95], ["test_quadrature_models.get_bounded_bq_lower"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_bounded_bq_lower"], ["", "@", "pytest", ".", "fixture", "\n", "def", "bounded_bq_lower", "(", ")", ":", "\n", "    ", "return", "get_bounded_bq_lower", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.bounded_bq_upper": [[97, 100], ["test_quadrature_models.get_bounded_bq_upper"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_bounded_bq_upper"], ["", "@", "pytest", ".", "fixture", "\n", "def", "bounded_bq_upper", "(", ")", ":", "\n", "    ", "return", "get_bounded_bq_upper", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.wsabil_adapt": [[102, 105], ["test_quadrature_models.get_wsabil_adapt"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_wsabil_adapt"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wsabil_adapt", "(", ")", ":", "\n", "    ", "return", "get_wsabil_adapt", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.wsabil_fixed": [[107, 110], ["test_quadrature_models.get_wsabil_fixed"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.get_wsabil_fixed"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wsabil_fixed", "(", ")", ":", "\n", "    ", "return", "get_wsabil_fixed", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_warped_model_data": [[132, 138], ["pytest.mark.parametrize", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose"], "function", ["None"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"model\"", ",", "all_models_test_list", ")", "\n", "def", "test_warped_model_data", "(", "model", ",", "data", ")", ":", "\n", "    ", "ABS_TOL", "=", "1e-5", "\n", "REL_TOL", "=", "1e-6", "\n", "assert_allclose", "(", "model", ".", "X", ",", "data", ".", "X", ",", "rtol", "=", "REL_TOL", ",", "atol", "=", "ABS_TOL", ")", "\n", "assert_allclose", "(", "model", ".", "Y", ",", "data", ".", "Y", ",", "rtol", "=", "REL_TOL", ",", "atol", "=", "ABS_TOL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_warped_model_shapes": [[140, 192], ["pytest.mark.parametrize", "numpy.array", "numpy.array", "model.integrate", "isinstance", "isinstance", "model.predict_base", "range", "model.predict_base_with_full_covariance", "model.predict", "model.predict_with_full_covariance", "model.get_prediction_gradients", "len", "isinstance", "len", "len", "len", "len", "len", "model.transform", "model.inverse_transform"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.integrate", "home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.predict_base", "home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.predict_base_with_full_covariance", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.predict_with_full_covariance", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"model\"", ",", "all_models_test_list", ")", "\n", "def", "test_warped_model_shapes", "(", "model", ")", ":", "\n", "    ", "x", "=", "np", ".", "array", "(", "[", "[", "-", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "-", "2", ",", "0.1", "]", ",", "[", "-", "3", ",", "4", "]", "]", ")", "\n", "Y", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "\n", "N", ",", "M", "=", "x", ".", "shape", "\n", "\n", "# integrate", "\n", "res", "=", "model", ".", "integrate", "(", ")", "\n", "assert", "len", "(", "res", ")", "==", "2", "\n", "assert", "isinstance", "(", "res", "[", "0", "]", ",", "float", ")", "\n", "\n", "if", "isinstance", "(", "model", ",", "VanillaBayesianQuadrature", ")", ":", "\n", "        ", "assert", "isinstance", "(", "res", "[", "1", "]", ",", "float", ")", "\n", "", "else", ":", "\n", "        ", "assert", "res", "[", "1", "]", "is", "None", "# None is returned temporarily until the variance is implemented.", "\n", "\n", "# transformations", "\n", "", "assert", "model", ".", "transform", "(", "Y", ")", ".", "shape", "==", "Y", ".", "shape", "\n", "assert", "model", ".", "inverse_transform", "(", "Y", ")", ".", "shape", "==", "Y", ".", "shape", "\n", "\n", "# predictions base", "\n", "res", "=", "model", ".", "predict_base", "(", "x", ")", "\n", "assert", "len", "(", "res", ")", "==", "4", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "assert", "res", "[", "i", "]", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "\n", "# predictions base full covariance", "\n", "", "res", "=", "model", ".", "predict_base_with_full_covariance", "(", "x", ")", "\n", "assert", "len", "(", "res", ")", "==", "4", "\n", "assert", "res", "[", "0", "]", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "res", "[", "1", "]", ".", "shape", "==", "(", "N", ",", "N", ")", "\n", "assert", "res", "[", "2", "]", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "res", "[", "3", "]", ".", "shape", "==", "(", "N", ",", "N", ")", "\n", "\n", "# predictions", "\n", "res", "=", "model", ".", "predict", "(", "x", ")", "\n", "assert", "len", "(", "res", ")", "==", "2", "\n", "assert", "res", "[", "0", "]", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "res", "[", "1", "]", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "\n", "# predictions full covariance", "\n", "res", "=", "model", ".", "predict_with_full_covariance", "(", "x", ")", "\n", "assert", "len", "(", "res", ")", "==", "2", "\n", "assert", "res", "[", "0", "]", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "res", "[", "1", "]", ".", "shape", "==", "(", "N", ",", "N", ")", "\n", "\n", "# predict gradients", "\n", "res", "=", "model", ".", "get_prediction_gradients", "(", "x", ")", "\n", "assert", "len", "(", "res", ")", "==", "2", "\n", "assert", "res", "[", "0", "]", ".", "shape", "==", "(", "N", ",", "M", ")", "\n", "assert", "res", "[", "1", "]", ".", "shape", "==", "(", "N", ",", "M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_warped_model_transforms": [[194, 209], ["pytest.mark.parametrize", "numpy.array", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "model.inverse_transform", "model.transform", "model.transform", "model.inverse_transform", "model.transform", "model.inverse_transform"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"model\"", ",", "all_models_test_list", ")", "\n", "def", "test_warped_model_transforms", "(", "model", ")", ":", "\n", "    ", "Y", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "ABS_TOL", "=", "1e-5", "\n", "REL_TOL", "=", "1e-6", "\n", "\n", "# check if warping and inverse warping correctly yield identity.", "\n", "assert_allclose", "(", "model", ".", "inverse_transform", "(", "model", ".", "transform", "(", "Y", ")", ")", ",", "Y", ",", "rtol", "=", "REL_TOL", ",", "atol", "=", "ABS_TOL", ")", "\n", "assert_allclose", "(", "model", ".", "transform", "(", "model", ".", "inverse_transform", "(", "Y", ")", ")", ",", "Y", ",", "rtol", "=", "REL_TOL", ",", "atol", "=", "ABS_TOL", ")", "\n", "\n", "# check if warping between base GP and model is consistent.", "\n", "Y2", "=", "model", ".", "Y", "\n", "Y1", "=", "model", ".", "base_gp", ".", "Y", "\n", "assert_allclose", "(", "model", ".", "transform", "(", "Y1", ")", ",", "Y2", ",", "rtol", "=", "REL_TOL", ",", "atol", "=", "ABS_TOL", ")", "\n", "assert_allclose", "(", "model", ".", "inverse_transform", "(", "Y2", ")", ",", "Y1", ",", "rtol", "=", "REL_TOL", ",", "atol", "=", "ABS_TOL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_warped_model_gradient_values": [[211, 223], ["pytest.mark.parametrize", "utils.check_grad", "utils.check_grad", "model.predict", "model.get_prediction_gradients", "model.predict", "model.get_prediction_gradients"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"model\"", ",", "all_models_test_list", ")", "\n", "def", "test_warped_model_gradient_values", "(", "model", ",", "data", ")", ":", "\n", "\n", "# gradient of mean", "\n", "    ", "func", "=", "lambda", "z", ":", "model", ".", "predict", "(", "z", ")", "[", "0", "]", "[", ":", ",", "0", "]", "\n", "dfunc", "=", "lambda", "z", ":", "model", ".", "get_prediction_gradients", "(", "z", ")", "[", "0", "]", ".", "T", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", "=", "(", "5", ",", "data", ".", "D", ")", ",", "bounds", "=", "data", ".", "dat_bounds", ")", "\n", "\n", "# gradient of var", "\n", "func", "=", "lambda", "z", ":", "model", ".", "predict", "(", "z", ")", "[", "1", "]", "[", ":", ",", "0", "]", "\n", "dfunc", "=", "lambda", "z", ":", "model", ".", "get_prediction_gradients", "(", "z", ")", "[", "1", "]", ".", "T", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", "=", "(", "5", ",", "data", ".", "D", ")", ",", "bounds", "=", "data", ".", "dat_bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_warped_model_integrate_mean": [[225, 245], ["pytest.mark.parametrize", "model.integrate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.integrate"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"model,interval\"", ",", "\n", "[", "\n", "(", "vanilla_test_list", "[", "0", "]", ",", "[", "0.5956279650321574", ",", "0.6000811779371775", "]", ")", ",", "\n", "(", "bounded_test_list", "[", "0", "]", ",", "[", "0.8383067891004425", ",", "0.8417905366769567", "]", ")", ",", "\n", "(", "bounded_test_list", "[", "1", "]", ",", "[", "2.977651803340788", ",", "2.981939540780773", "]", ")", ",", "\n", "(", "wsabi_test_list", "[", "0", "]", ",", "[", "1.0571955335349208", ",", "1.0601420159245922", "]", ")", ",", "\n", "(", "wsabi_test_list", "[", "1", "]", ",", "[", "0.47610638476406725", ",", "0.48068140048609603", "]", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_warped_model_integrate_mean", "(", "model", ",", "interval", ")", ":", "\n", "# Both outputs of the model.intgerate() method are analytic integrals.", "\n", "# To test their values we check if they lie in the confidence interva of an MC estimator.", "\n", "# These intervals were computed as follows: the mean model.predict (first argument) was integrated by", "\n", "# simple random sampling with 1e6 samples, and the variance (second argument) with 5*1e3 samples. This was done 100", "\n", "# times. The intervals show mean\\pm 3 std of the 100 integrals obtained by sampling. There might be a very small", "\n", "# chance that the true integrals lies outside the specified intervals.", "\n", "# See file \"ground_truth_integrals_methods.py\" for details.", "\n", "    ", "res", "=", "model", ".", "integrate", "(", ")", "[", "0", "]", "\n", "assert", "interval", "[", "0", "]", "<", "res", "<", "interval", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_warped_model_integrate_variance": [[247, 265], ["pytest.mark.parametrize", "model.integrate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.integrate"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"model,interval\"", ",", "\n", "[", "\n", "(", "vanilla_test_list", "[", "0", "]", ",", "[", "0.09859906877945852", ",", "0.11181285735935843", "]", ")", ",", "\n", "(", "bounded_test_list", "[", "0", "]", ",", "None", ")", ",", "\n", "(", "bounded_test_list", "[", "1", "]", ",", "None", ")", ",", "\n", "(", "wsabi_test_list", "[", "0", "]", ",", "None", ")", ",", "\n", "(", "wsabi_test_list", "[", "1", "]", ",", "None", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_warped_model_integrate_variance", "(", "model", ",", "interval", ")", ":", "\n", "# See test_warped_model_integrate_mean on how the intervals were computed", "\n", "    ", "res", "=", "model", ".", "integrate", "(", ")", "[", "1", "]", "\n", "\n", "if", "interval", "is", "None", ":", "\n", "        ", "assert", "res", "is", "None", "# None is returned temporarily until the variance is implemented.", "\n", "", "else", ":", "\n", "        ", "assert", "interval", "[", "0", "]", "<", "res", "<", "interval", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_bounded_bq_correct_bounded_flag": [[270, 276], ["None"], "function", ["None"], ["", "", "def", "test_bounded_bq_correct_bounded_flag", "(", "bounded_bq_upper", ",", "bounded_bq_lower", ")", ":", "\n", "    ", "assert", "bounded_bq_lower", ".", "is_lower_bounded", "\n", "assert", "not", "bounded_bq_lower", ".", "_warping", ".", "is_inverted", "\n", "\n", "assert", "not", "bounded_bq_upper", ".", "is_lower_bounded", "\n", "assert", "bounded_bq_upper", ".", "_warping", ".", "is_inverted", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_bounded_bq_correct_bound": [[278, 281], ["None"], "function", ["None"], ["", "def", "test_bounded_bq_correct_bound", "(", "data", ",", "bounded_bq_lower", ",", "bounded_bq_upper", ")", ":", "\n", "    ", "assert", "bounded_bq_lower", ".", "bound", "==", "data", ".", "bound_lower", "\n", "assert", "bounded_bq_upper", ".", "bound", "==", "data", ".", "bound_upper", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_bounded_bq_raises": [[283, 311], ["emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureRBFLebesgueMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy", "pytest.raises", "emukit.quadrature.methods.BoundedBayesianQuadrature", "pytest.raises", "emukit.quadrature.methods.BoundedBayesianQuadrature", "pytest.raises", "emukit.quadrature.methods.BoundedBayesianQuadrature", "numpy.min", "numpy.min", "numpy.min"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "test_bounded_bq_raises", "(", "gpy_model", ")", ":", "\n", "    ", "gpy_model", ",", "_", "=", "gpy_model", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "gpy_model", ".", "X", ".", "shape", "[", "1", "]", "*", "[", "(", "0", ",", "1", ")", "]", ",", "normalized", "=", "False", ")", "\n", "qrbf", "=", "QuadratureRBFLebesgueMeasure", "(", "RBFGPy", "(", "gpy_model", ".", "kern", ")", ",", "measure", "=", "measure", ")", "\n", "base_gp_wrong_kernel", "=", "BaseGaussianProcessGPy", "(", "kern", "=", "qrbf", ",", "gpy_model", "=", "gpy_model", ")", "\n", "\n", "# wrong kernel embedding", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "BoundedBayesianQuadrature", "(", "\n", "base_gp", "=", "base_gp_wrong_kernel", ",", "\n", "X", "=", "base_gp_wrong_kernel", ".", "X", ",", "\n", "Y", "=", "base_gp_wrong_kernel", ".", "Y", ",", "\n", "lower_bound", "=", "np", ".", "min", "(", "base_gp_wrong_kernel", ".", "Y", ")", "-", "0.5", ",", "\n", ")", "\n", "\n", "# both upper and lower bound are given", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "BoundedBayesianQuadrature", "(", "\n", "base_gp", "=", "base_gp_wrong_kernel", ",", "\n", "X", "=", "base_gp_wrong_kernel", ".", "X", ",", "\n", "Y", "=", "base_gp_wrong_kernel", ".", "Y", ",", "\n", "lower_bound", "=", "np", ".", "min", "(", "base_gp_wrong_kernel", ".", "Y", ")", "-", "0.5", ",", "\n", "upper_bound", "=", "np", ".", "min", "(", "base_gp_wrong_kernel", ".", "Y", ")", "-", "0.5", ",", "\n", ")", "\n", "\n", "# no bound is given", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "BoundedBayesianQuadrature", "(", "base_gp", "=", "base_gp_wrong_kernel", ",", "X", "=", "base_gp_wrong_kernel", ".", "X", ",", "Y", "=", "base_gp_wrong_kernel", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_models.test_wsabi_alpha_adaptation": [[316, 331], ["numpy.array", "numpy.array", "model.set_data", "math.isclose"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["", "", "def", "test_wsabi_alpha_adaptation", "(", "wsabil_adapt", ",", "wsabil_fixed", ")", ":", "\n", "    ", "X_new", "=", "np", ".", "array", "(", "[", "[", "1.1", ",", "1.2", "]", ",", "[", "-", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "-", "2", ",", "0.1", "]", "]", ")", "\n", "Y_new", "=", "np", ".", "array", "(", "[", "[", "0.8", "]", ",", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "# lowest value is 0.8", "\n", "\n", "# check if alpha is adapted correctly", "\n", "model", "=", "wsabil_adapt", "\n", "model", ".", "set_data", "(", "X_new", ",", "Y_new", ")", "\n", "assert", "model", ".", "adapt_alpha", "\n", "assert", "isclose", "(", "model", ".", "bound", ",", "0.64", ")", "# 0.8 * min(Y_new)", "\n", "\n", "# check if alpha stays fixed", "\n", "model", "=", "wsabil_fixed", "\n", "old_alpha", "=", "model", ".", "bound", "\n", "assert", "not", "model", ".", "adapt_alpha", "\n", "assert", "model", ".", "bound", "==", "old_alpha", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel._sample_lebesgue": [[27, 34], ["len", "numpy.reshape", "numpy.zeros", "range", "numpy.random.rand"], "function", ["None"], ["def", "_sample_lebesgue", "(", "num_samples", ":", "int", ",", "bounds", ":", "List", "[", "Tuple", "[", "float", ",", "float", "]", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "D", "=", "len", "(", "bounds", ")", "\n", "samples", "=", "np", ".", "reshape", "(", "np", ".", "random", ".", "rand", "(", "num_samples", "*", "D", ")", ",", "[", "num_samples", ",", "D", "]", ")", "\n", "samples_shifted", "=", "np", ".", "zeros", "(", "samples", ".", "shape", ")", "\n", "for", "d", "in", "range", "(", "D", ")", ":", "\n", "        ", "samples_shifted", "[", ":", ",", "d", "]", "=", "samples", "[", ":", ",", "d", "]", "*", "(", "bounds", "[", "d", "]", "[", "1", "]", "-", "bounds", "[", "d", "]", "[", "0", "]", ")", "+", "bounds", "[", "d", "]", "[", "0", "]", "\n", "", "return", "samples_shifted", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel._sample_gaussian": [[36, 40], ["numpy.reshape", "numpy.random.randn", "numpy.sqrt"], "function", ["None"], ["", "def", "_sample_gaussian", "(", "num_samples", ":", "int", ",", "mean", ":", "np", ".", "ndarray", ",", "variance", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "D", "=", "mean", ".", "shape", "[", "0", "]", "\n", "samples", "=", "np", ".", "reshape", "(", "np", ".", "random", ".", "randn", "(", "num_samples", "*", "D", ")", ",", "[", "num_samples", ",", "D", "]", ")", "\n", "return", "mean", "+", "np", ".", "sqrt", "(", "variance", ")", "*", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel.qK_lebesgue_normalized": [[43, 49], ["ground_truth_integrals_qkernel._sample_lebesgue", "qkern.K", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel._sample_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "qK_lebesgue_normalized", "(", "num_samples", ":", "int", ",", "qkern", ":", "QuadratureKernel", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"MC estimator for kernel mean qK on Lebesgue measure.\"\"\"", "\n", "bounds", "=", "qkern", ".", "measure", ".", "domain", ".", "bounds", "\n", "samples", "=", "_sample_lebesgue", "(", "num_samples", ",", "bounds", "=", "bounds", ")", "\n", "Kx", "=", "qkern", ".", "K", "(", "samples", ",", "x2", ")", "\n", "return", "np", ".", "mean", "(", "Kx", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel.qK_lebesgue": [[51, 56], ["numpy.array", "numpy.prod", "ground_truth_integrals_qkernel.qK_lebesgue_normalized"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel.qK_lebesgue_normalized"], ["", "def", "qK_lebesgue", "(", "num_samples", ":", "int", ",", "qkern", ":", "QuadratureKernel", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"MC estimator for kernel mean qK on Lebesgue measure.\"\"\"", "\n", "differences", "=", "np", ".", "array", "(", "[", "x", "[", "1", "]", "-", "x", "[", "0", "]", "for", "x", "in", "qkern", ".", "measure", ".", "domain", ".", "bounds", "]", ")", "\n", "volume", "=", "np", ".", "prod", "(", "differences", ")", "\n", "return", "qK_lebesgue_normalized", "(", "num_samples", "=", "num_samples", ",", "qkern", "=", "qkern", ",", "x2", "=", "x2", ")", "*", "volume", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel.qK_gaussian": [[58, 64], ["ground_truth_integrals_qkernel._sample_gaussian", "qkern.K", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel._sample_gaussian", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "qK_gaussian", "(", "num_samples", ":", "int", ",", "qkern", ":", "QuadratureKernel", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"MC estimator for kernel mean qK on Gaussian measure.\"\"\"", "\n", "measure", "=", "qkern", ".", "measure", "\n", "samples", "=", "_sample_gaussian", "(", "num_samples", ",", "mean", "=", "measure", ".", "mean", ",", "variance", "=", "measure", ".", "variance", ")", "\n", "Kx", "=", "qkern", ".", "K", "(", "samples", ",", "x2", ")", "\n", "return", "np", ".", "mean", "(", "Kx", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel.qKq_lebesgue_normalized": [[67, 73], ["ground_truth_integrals_qkernel._sample_lebesgue", "qkern.qK", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel._sample_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK"], ["", "def", "qKq_lebesgue_normalized", "(", "num_samples", ":", "int", ",", "qkern", ":", "QuadratureKernel", ")", "->", "float", ":", "\n", "    ", "\"\"\"MC estimator for initial error qKq on Lebesgue measure.\"\"\"", "\n", "bounds", "=", "qkern", ".", "measure", ".", "domain", ".", "bounds", "\n", "samples", "=", "_sample_lebesgue", "(", "num_samples", ",", "bounds", "=", "bounds", ")", "\n", "qKx", "=", "qkern", ".", "qK", "(", "samples", ")", "\n", "return", "np", ".", "mean", "(", "qKx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel.qKq_lebesgue": [[75, 80], ["numpy.array", "numpy.prod", "ground_truth_integrals_qkernel.qKq_lebesgue_normalized"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel.qKq_lebesgue_normalized"], ["", "def", "qKq_lebesgue", "(", "num_samples", ":", "int", ",", "qkern", ":", "QuadratureKernel", ")", "->", "float", ":", "\n", "    ", "\"\"\"MC estimator for initial error qKq on Lebesgue measure.\"\"\"", "\n", "differences", "=", "np", ".", "array", "(", "[", "x", "[", "1", "]", "-", "x", "[", "0", "]", "for", "x", "in", "qkern", ".", "measure", ".", "domain", ".", "bounds", "]", ")", "\n", "volume", "=", "np", ".", "prod", "(", "differences", ")", "\n", "return", "qKq_lebesgue_normalized", "(", "num_samples", "=", "num_samples", ",", "qkern", "=", "qkern", ")", "*", "volume", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel.qKq_gaussian": [[82, 88], ["ground_truth_integrals_qkernel._sample_gaussian", "qkern.qK", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_qkernel._sample_gaussian", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK"], ["", "def", "qKq_gaussian", "(", "num_samples", ":", "int", ",", "qkern", ":", "QuadratureKernel", ")", "->", "float", ":", "\n", "    ", "\"\"\"MC estimator for initial error qKq on Gaussian measure.\"\"\"", "\n", "measure", "=", "qkern", ".", "measure", "\n", "samples", "=", "_sample_gaussian", "(", "num_samples", ",", "mean", "=", "measure", ".", "mean", ",", "variance", "=", "measure", ".", "variance", ")", "\n", "qKx", "=", "qkern", ".", "qK", "(", "samples", ")", "\n", "return", "np", ".", "mean", "(", "qKx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_methods.mc_integral_mean_from_measure": [[19, 24], ["model.measure.sample", "model.predict", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["def", "mc_integral_mean_from_measure", "(", "num_samples", ":", "int", ",", "model", ":", "WarpedBayesianQuadratureModel", ")", "->", "float", ":", "\n", "    ", "\"\"\"Computes the MC estimator for the integral mean of the model.\"\"\"", "\n", "samples", "=", "model", ".", "measure", ".", "sample", "(", "num_samples", "=", "num_samples", ")", "\n", "gp_mean_at_samples", ",", "_", "=", "model", ".", "predict", "(", "samples", ")", "\n", "return", "np", ".", "mean", "(", "gp_mean_at_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.ground_truth_integrals_methods.mc_integral_var_from_measure": [[26, 31], ["model.measure.sample", "model.predict_with_full_covariance", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.predict_with_full_covariance"], ["", "def", "mc_integral_var_from_measure", "(", "num_samples", ":", "int", ",", "model", ":", "WarpedBayesianQuadratureModel", ")", "->", "float", ":", "\n", "    ", "\"\"\"Computes the MC estimator for the integral variance of the model.\"\"\"", "\n", "samples", "=", "model", ".", "measure", ".", "sample", "(", "num_samples", "=", "num_samples", ")", "\n", "_", ",", "gp_cov_at_samples", "=", "model", ".", "predict_with_full_covariance", "(", "samples", ")", "\n", "return", "np", ".", "sum", "(", "gp_cov_at_samples", ")", "/", "num_samples", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.gpy_model": [[23, 30], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "GPy.kern.RBF", "GPy.models.GPRegression"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "gpy_model", "(", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "X", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "Y", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "gpy_kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "X", ".", "shape", "[", "1", "]", ")", "\n", "return", "GPy", ".", "models", ".", "GPRegression", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "kernel", "=", "gpy_kernel", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.model_lebesgue": [[32, 38], ["emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.quadrature_rbf.QuadratureRBFLebesgueMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy", "emukit.quadrature.methods.VanillaBayesianQuadrature", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "@", "pytest", ".", "fixture", "\n", "def", "model_lebesgue", "(", "gpy_model", ")", ":", "\n", "    ", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "gpy_model", ".", "X", ".", "shape", "[", "1", "]", "*", "[", "(", "-", "1", ",", "2", ")", "]", ",", "normalized", "=", "False", ")", "\n", "qrbf", "=", "QuadratureRBFLebesgueMeasure", "(", "RBFGPy", "(", "gpy_model", ".", "kern", ")", ",", "measure", ")", "\n", "basegp", "=", "BaseGaussianProcessGPy", "(", "kern", "=", "qrbf", ",", "gpy_model", "=", "gpy_model", ")", "\n", "return", "VanillaBayesianQuadrature", "(", "base_gp", "=", "basegp", ",", "X", "=", "gpy_model", ".", "X", ",", "Y", "=", "gpy_model", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.model_lebesgue_normalized": [[40, 46], ["emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.quadrature_rbf.QuadratureRBFLebesgueMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy", "emukit.quadrature.methods.VanillaBayesianQuadrature", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "@", "pytest", ".", "fixture", "\n", "def", "model_lebesgue_normalized", "(", "gpy_model", ")", ":", "\n", "    ", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "gpy_model", ".", "X", ".", "shape", "[", "1", "]", "*", "[", "(", "-", "1", ",", "2", ")", "]", ",", "normalized", "=", "True", ")", "\n", "qrbf", "=", "QuadratureRBFLebesgueMeasure", "(", "RBFGPy", "(", "gpy_model", ".", "kern", ")", ",", "measure", ")", "\n", "basegp", "=", "BaseGaussianProcessGPy", "(", "kern", "=", "qrbf", ",", "gpy_model", "=", "gpy_model", ")", "\n", "return", "VanillaBayesianQuadrature", "(", "base_gp", "=", "basegp", ",", "X", "=", "gpy_model", ".", "X", ",", "Y", "=", "gpy_model", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.model_gaussian": [[48, 55], ["emukit.quadrature.measures.GaussianMeasure", "emukit.quadrature.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy", "emukit.quadrature.methods.VanillaBayesianQuadrature", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy", "numpy.arange", "numpy.linspace"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "model_gaussian", "(", "gpy_model", ")", ":", "\n", "    ", "X", ",", "Y", "=", "gpy_model", ".", "X", ",", "gpy_model", ".", "Y", "\n", "measure", "=", "GaussianMeasure", "(", "mean", "=", "np", ".", "arange", "(", "gpy_model", ".", "X", ".", "shape", "[", "1", "]", ")", ",", "variance", "=", "np", ".", "linspace", "(", "0.2", ",", "1.5", ",", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "qrbf", "=", "QuadratureRBFGaussianMeasure", "(", "RBFGPy", "(", "gpy_model", ".", "kern", ")", ",", "measure", "=", "measure", ")", "\n", "basegp", "=", "BaseGaussianProcessGPy", "(", "kern", "=", "qrbf", ",", "gpy_model", "=", "gpy_model", ")", "\n", "return", "VanillaBayesianQuadrature", "(", "base_gp", "=", "basegp", ",", "X", "=", "gpy_model", ".", "X", ",", "Y", "=", "gpy_model", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.model_test_list_fixture": [[64, 67], ["pytest.fixture"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", "params", "=", "model_test_list", ")", "\n", "def", "model_test_list_fixture", "(", "request", ")", ":", "\n", "    ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.mutual_information": [[72, 75], ["emukit.quadrature.acquisitions.MutualInformation"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "mutual_information", "(", "model_test_list_fixture", ")", ":", "\n", "    ", "return", "MutualInformation", "(", "model_test_list_fixture", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.squared_correlation": [[77, 80], ["emukit.quadrature.acquisitions.SquaredCorrelation"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "squared_correlation", "(", "model_test_list_fixture", ")", ":", "\n", "    ", "return", "SquaredCorrelation", "(", "model_test_list_fixture", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.integral_variance_reduction": [[82, 85], ["emukit.quadrature.acquisitions.IntegralVarianceReduction"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "integral_variance_reduction", "(", "model_test_list_fixture", ")", ":", "\n", "    ", "return", "IntegralVarianceReduction", "(", "model_test_list_fixture", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.uncertainty_sampling": [[87, 90], ["emukit.quadrature.acquisitions.UncertaintySampling"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "uncertainty_sampling", "(", "model_test_list_fixture", ")", ":", "\n", "    ", "return", "UncertaintySampling", "(", "model_test_list_fixture", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.test_quadrature_acquisition_shapes": [[100, 112], ["pytest.mark.parametrize", "numpy.array", "aq.evaluate", "aq.evaluate_with_gradients"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"aq\"", ",", "acquisitions_test_list", ")", "\n", "def", "test_quadrature_acquisition_shapes", "(", "aq", ")", ":", "\n", "    ", "x", "=", "np", ".", "array", "(", "[", "[", "-", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "-", "2", ",", "0.1", "]", "]", ")", "\n", "\n", "# value", "\n", "res", "=", "aq", ".", "evaluate", "(", "x", ")", "\n", "assert", "res", ".", "shape", "==", "(", "3", ",", "1", ")", "\n", "\n", "# gradient", "\n", "res", "=", "aq", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "assert", "res", "[", "0", "]", ".", "shape", "==", "(", "3", ",", "1", ")", "\n", "assert", "res", "[", "1", "]", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_acquisitions.test_quadrature_acquisition_gradient_values": [[114, 119], ["pytest.mark.parametrize", "utils.check_grad", "aq.evaluate", "aq.evaluate_with_gradients"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"aq\"", ",", "acquisitions_test_list", ")", "\n", "def", "test_quadrature_acquisition_gradient_values", "(", "aq", ")", ":", "\n", "    ", "func", "=", "lambda", "x", ":", "aq", ".", "evaluate", "(", "x", ")", "[", ":", ",", "0", "]", "\n", "dfunc", "=", "lambda", "x", ":", "aq", ".", "evaluate_with_gradients", "(", "x", ")", "[", "1", "]", ".", "T", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", "=", "(", "3", ",", "2", ")", ",", "bounds", "=", "aq", ".", "model", ".", "X", ".", "shape", "[", "1", "]", "*", "[", "(", "-", "3", ",", "3", ")", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.create_fixture_parameters": [[11, 13], ["pytest.param", "pytest_lazyfixture.lazy_fixture"], "function", ["None"], ["def", "create_fixture_parameters", "(", ")", ":", "\n", "    ", "return", "[", "pytest", ".", "param", "(", "lazy_fixture", "(", "warping", ".", "name", ")", ",", "id", "=", "warping", ".", "name", ")", "for", "warping", "in", "warpings", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.identity_warping": [[15, 18], ["emukit.quadrature.methods.warpings.IdentityWarping"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "identity_warping", "(", ")", ":", "\n", "    ", "return", "IdentityWarping", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.squarerroot_warping": [[20, 24], ["emukit.quadrature.methods.warpings.SquareRootWarping"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "squarerroot_warping", "(", ")", ":", "\n", "    ", "offset", "=", "1.0", "\n", "return", "SquareRootWarping", "(", "offset", "=", "offset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.inverted_squarerroot_warping": [[26, 30], ["emukit.quadrature.methods.warpings.SquareRootWarping"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "inverted_squarerroot_warping", "(", ")", ":", "\n", "    ", "offset", "=", "1.0", "\n", "return", "SquareRootWarping", "(", "offset", "=", "offset", ",", "is_inverted", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.test_warping_shapes": [[44, 49], ["pytest.mark.parametrize", "numpy.ones", "test_warpings.create_fixture_parameters", "warping.transform", "warping.inverse_transform"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.create_fixture_parameters", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"warping\"", ",", "create_fixture_parameters", "(", ")", ")", "\n", "def", "test_warping_shapes", "(", "warping", ")", ":", "\n", "    ", "Y", "=", "np", ".", "ones", "(", "[", "5", ",", "1", "]", ")", "\n", "assert", "warping", ".", "transform", "(", "Y", ")", ".", "shape", "==", "Y", ".", "shape", "\n", "assert", "warping", ".", "inverse_transform", "(", "Y", ")", ".", "shape", "==", "Y", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.test_warping_values": [[51, 57], ["pytest.mark.parametrize", "numpy.random.seed", "numpy.random.rand", "numpy.testing.assert_allclose", "test_warpings.create_fixture_parameters", "warping.inverse_transform", "warping.transform"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.create_fixture_parameters", "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"warping\"", ",", "create_fixture_parameters", "(", ")", ")", "\n", "def", "test_warping_values", "(", "warping", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "Y", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "assert_allclose", "(", "warping", ".", "inverse_transform", "(", "warping", ".", "transform", "(", "Y", ")", ")", ",", "Y", ",", "rtol", "=", "RTOL", ",", "atol", "=", "ATOL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.test_squarerroot_warping_update_parameters": [[59, 67], ["squarerroot_warping.update_parameters", "inverted_squarerroot_warping.update_parameters"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters"], ["", "def", "test_squarerroot_warping_update_parameters", "(", "squarerroot_warping", ",", "inverted_squarerroot_warping", ")", ":", "\n", "    ", "new_offset", "=", "10.0", "\n", "\n", "squarerroot_warping", ".", "update_parameters", "(", "offset", "=", "new_offset", ")", "\n", "assert", "squarerroot_warping", ".", "offset", "==", "new_offset", "\n", "\n", "inverted_squarerroot_warping", ".", "update_parameters", "(", "offset", "=", "new_offset", ")", "\n", "assert", "inverted_squarerroot_warping", ".", "offset", "==", "new_offset", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_warpings.test_squarerroot_warping_inverted_flag": [[69, 72], ["None"], "function", ["None"], ["", "def", "test_squarerroot_warping_inverted_flag", "(", "squarerroot_warping", ",", "inverted_squarerroot_warping", ")", ":", "\n", "    ", "assert", "not", "squarerroot_warping", ".", "is_inverted", "\n", "assert", "inverted_squarerroot_warping", ".", "is_inverted", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_gaussian_qrbf": [[115, 120], ["test_quadrature_kernels.DataGaussianSpread", "emukit.quadrature.measures.GaussianMeasure", "emukit.quadrature.kernels.QuadratureRBFGaussianMeasure", "test_quadrature_kernels.EmukitRBF"], "function", ["None"], ["", "def", "get_gaussian_qrbf", "(", ")", ":", "\n", "    ", "dat", "=", "DataGaussianSpread", "(", ")", "\n", "measure", "=", "GaussianMeasure", "(", "mean", "=", "dat", ".", "measure_mean", ",", "variance", "=", "dat", ".", "measure_var", ")", "\n", "qkern", "=", "QuadratureRBFGaussianMeasure", "(", "EmukitRBF", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qrbf": [[123, 128], ["test_quadrature_kernels.DataBox", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureRBFLebesgueMeasure", "test_quadrature_kernels.EmukitRBF"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_qrbf", "(", ")", ":", "\n", "    ", "dat", "=", "DataBox", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "False", ")", "\n", "qkern", "=", "QuadratureRBFLebesgueMeasure", "(", "EmukitRBF", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qmatern32": [[130, 135], ["test_quadrature_kernels.DataBox", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureProductMatern32LebesgueMeasure", "test_quadrature_kernels.EmukitProductMatern32"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_qmatern32", "(", ")", ":", "\n", "    ", "dat", "=", "DataBox", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "False", ")", "\n", "qkern", "=", "QuadratureProductMatern32LebesgueMeasure", "(", "EmukitProductMatern32", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qmatern52": [[137, 142], ["test_quadrature_kernels.DataBox", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureProductMatern52LebesgueMeasure", "test_quadrature_kernels.EmukitProductMatern52"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_qmatern52", "(", ")", ":", "\n", "    ", "dat", "=", "DataBox", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "False", ")", "\n", "qkern", "=", "QuadratureProductMatern52LebesgueMeasure", "(", "EmukitProductMatern52", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qbrownian": [[144, 149], ["test_quadrature_kernels.DataIntervalPositiveDomain", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureBrownianLebesgueMeasure", "test_quadrature_kernels.EmukitBrownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_qbrownian", "(", ")", ":", "\n", "    ", "dat", "=", "DataIntervalPositiveDomain", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "False", ")", "\n", "qkern", "=", "QuadratureBrownianLebesgueMeasure", "(", "EmukitBrownian", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qprodbrownian": [[151, 156], ["test_quadrature_kernels.DataBoxPositiveDomain", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureProductBrownianLebesgueMeasure", "test_quadrature_kernels.EmukitProductBrownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_qprodbrownian", "(", ")", ":", "\n", "    ", "dat", "=", "DataBoxPositiveDomain", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "False", ")", "\n", "qkern", "=", "QuadratureProductBrownianLebesgueMeasure", "(", "EmukitProductBrownian", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qrbf": [[159, 164], ["test_quadrature_kernels.DataBox", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureRBFLebesgueMeasure", "test_quadrature_kernels.EmukitRBF"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_normalized_qrbf", "(", ")", ":", "\n", "    ", "dat", "=", "DataBox", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "True", ")", "\n", "qkern", "=", "QuadratureRBFLebesgueMeasure", "(", "EmukitRBF", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qmatern32": [[166, 171], ["test_quadrature_kernels.DataBox", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureProductMatern32LebesgueMeasure", "test_quadrature_kernels.EmukitProductMatern32"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_normalized_qmatern32", "(", ")", ":", "\n", "    ", "dat", "=", "DataBox", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "True", ")", "\n", "qkern", "=", "QuadratureProductMatern32LebesgueMeasure", "(", "EmukitProductMatern32", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qmatern52": [[173, 178], ["test_quadrature_kernels.DataBox", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureProductMatern52LebesgueMeasure", "test_quadrature_kernels.EmukitProductMatern52"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_normalized_qmatern52", "(", ")", ":", "\n", "    ", "dat", "=", "DataBox", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "True", ")", "\n", "qkern", "=", "QuadratureProductMatern52LebesgueMeasure", "(", "EmukitProductMatern52", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qbrownian": [[180, 185], ["test_quadrature_kernels.DataIntervalPositiveDomain", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureBrownianLebesgueMeasure", "test_quadrature_kernels.EmukitBrownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_normalized_qbrownian", "(", ")", ":", "\n", "    ", "dat", "=", "DataIntervalPositiveDomain", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "True", ")", "\n", "qkern", "=", "QuadratureBrownianLebesgueMeasure", "(", "EmukitBrownian", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qprodbrownian": [[187, 192], ["test_quadrature_kernels.DataBoxPositiveDomain", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureProductBrownianLebesgueMeasure", "test_quadrature_kernels.EmukitProductBrownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "get_lebesgue_normalized_qprodbrownian", "(", ")", ":", "\n", "    ", "dat", "=", "DataBoxPositiveDomain", "(", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "dat", ".", "bounds", ",", "normalized", "=", "True", ")", "\n", "qkern", "=", "QuadratureProductBrownianLebesgueMeasure", "(", "EmukitProductBrownian", "(", ")", ".", "kern", ",", "measure", "=", "measure", ")", "\n", "return", "qkern", ",", "dat", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.gaussian_qrbf": [[195, 199], ["test_quadrature_kernels.get_gaussian_qrbf"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_gaussian_qrbf"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gaussian_qrbf", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_gaussian_qrbf", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesgue_qrbf": [[202, 206], ["test_quadrature_kernels.get_lebesgue_qrbf"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qrbf"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesgue_qrbf", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_qrbf", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesgue_qmatern32": [[208, 212], ["test_quadrature_kernels.get_lebesgue_qmatern32"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qmatern32"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesgue_qmatern32", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_qmatern32", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesgue_qmatern52": [[214, 218], ["test_quadrature_kernels.get_lebesgue_qmatern52"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qmatern52"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesgue_qmatern52", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_qmatern52", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesgue_qbrownian": [[220, 224], ["test_quadrature_kernels.get_lebesgue_qbrownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qbrownian"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesgue_qbrownian", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_qbrownian", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesque_qprodbrownian": [[226, 230], ["test_quadrature_kernels.get_lebesgue_qprodbrownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_qprodbrownian"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesque_qprodbrownian", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_qprodbrownian", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesgue_normalized_qrbf": [[233, 237], ["test_quadrature_kernels.get_lebesgue_normalized_qrbf"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qrbf"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesgue_normalized_qrbf", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_normalized_qrbf", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesgue_normalized_qmatern32": [[239, 243], ["test_quadrature_kernels.get_lebesgue_normalized_qmatern32"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qmatern32"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesgue_normalized_qmatern32", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_normalized_qmatern32", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesgue_normalized_qmatern52": [[245, 249], ["test_quadrature_kernels.get_lebesgue_normalized_qmatern52"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qmatern52"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesgue_normalized_qmatern52", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_normalized_qmatern52", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesgue_normalized_qbrownian": [[251, 255], ["test_quadrature_kernels.get_lebesgue_normalized_qbrownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qbrownian"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesgue_normalized_qbrownian", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_normalized_qbrownian", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.lebesque_normalized_qprodbrownian": [[257, 261], ["test_quadrature_kernels.get_lebesgue_normalized_qprodbrownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.get_lebesgue_normalized_qprodbrownian"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lebesque_normalized_qprodbrownian", "(", ")", ":", "\n", "    ", "qkern", ",", "dat", "=", "get_lebesgue_normalized_qprodbrownian", "(", ")", "\n", "return", "qkern", ",", "dat", ".", "x1", ",", "dat", ".", "x2", ",", "dat", ".", "N", ",", "dat", ".", "M", ",", "dat", ".", "D", ",", "dat", ".", "dat_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.test_qkernel_shapes": [[288, 300], ["pytest.mark.parametrize", "isinstance", "numpy.shape", "emukit_qkernel.qKq", "emukit_qkernel.K", "emukit_qkernel.qK", "emukit_qkernel.Kq", "emukit_qkernel.qKq"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qKq", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.Kq", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qKq"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"kernel_embedding\"", ",", "embeddings_test_list", ")", "\n", "def", "test_qkernel_shapes", "(", "kernel_embedding", ")", ":", "\n", "    ", "emukit_qkernel", ",", "x1", ",", "x2", ",", "N", ",", "M", ",", "D", ",", "_", "=", "kernel_embedding", "\n", "\n", "# kernel shapes", "\n", "assert", "emukit_qkernel", ".", "K", "(", "x1", ",", "x2", ")", ".", "shape", "==", "(", "N", ",", "M", ")", "\n", "\n", "# embedding shapes", "\n", "assert", "emukit_qkernel", ".", "qK", "(", "x2", ")", ".", "shape", "==", "(", "1", ",", "M", ")", "\n", "assert", "emukit_qkernel", ".", "Kq", "(", "x1", ")", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "np", ".", "shape", "(", "emukit_qkernel", ".", "qKq", "(", ")", ")", "==", "(", ")", "\n", "assert", "isinstance", "(", "emukit_qkernel", ".", "qKq", "(", ")", ",", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.test_qkernel_qKq": [[305, 330], ["pytest.mark.parametrize", "emukit_qkernel.qKq"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qKq"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"kernel_embedding,interval\"", ",", "\n", "[", "\n", "(", "gaussian_embeddings_test_list", "[", "0", "]", ",", "[", "0.22019471616760106", ",", "0.22056701590213823", "]", ")", ",", "\n", "(", "lebesgue_embeddings_test_list", "[", "0", "]", ",", "[", "38.267217898004176", ",", "38.32112525041843", "]", ")", ",", "\n", "(", "lebesgue_embeddings_test_list", "[", "1", "]", ",", "[", "33.68147561344138", ",", "33.72674814040212", "]", ")", ",", "\n", "(", "lebesgue_embeddings_test_list", "[", "2", "]", ",", "[", "36.31179230918318", ",", "36.36244064795965", "]", ")", ",", "\n", "(", "lebesgue_embeddings_test_list", "[", "3", "]", ",", "[", "0.6527648875308305", ",", "0.6539297075650101", "]", ")", ",", "\n", "(", "lebesgue_embeddings_test_list", "[", "4", "]", ",", "[", "147.14888857464945", ",", "147.3118404349691", "]", ")", ",", "\n", "(", "lebesgue_normalized_embeddings_test_list", "[", "0", "]", ",", "[", "0.11810869721606222", ",", "0.11827507793339022", "]", ")", ",", "\n", "(", "lebesgue_normalized_embeddings_test_list", "[", "1", "]", ",", "[", "0.10395517164642398", ",", "0.10409490166790775", "]", ")", ",", "\n", "(", "lebesgue_normalized_embeddings_test_list", "[", "2", "]", ",", "[", "0.11207343305303447", ",", "0.11222975508629518", "]", ")", ",", "\n", "(", "lebesgue_normalized_embeddings_test_list", "[", "3", "]", ",", "[", "0.3330433099647094", ",", "0.3336376059005152", "]", ")", ",", "\n", "(", "lebesgue_normalized_embeddings_test_list", "[", "4", "]", ",", "[", "5.199166451419295", ",", "5.204923979414083", "]", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_qkernel_qKq", "(", "kernel_embedding", ",", "interval", ")", ":", "\n", "# To test the integral value of the kernel embedding, we check if it lies in some confidence interval.", "\n", "# These intervals were computed as follows: The kernel emukit_qkernel.qK was integrated by", "\n", "# simple random sampling with 1e6 samples. This was done 100 times. The intervals show mean\\pm 3 std of the 100", "\n", "# integrals obtained by sampling. There might be a small chance that the true integrals lies outside the", "\n", "# specified intervals.", "\n", "    ", "emukit_qkernel", "=", "kernel_embedding", "[", "0", "]", "\n", "qKq", "=", "emukit_qkernel", ".", "qKq", "(", ")", "\n", "assert", "interval", "[", "0", "]", "<", "qKq", "<", "interval", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.test_qkernel_qK": [[332, 464], ["pytest.mark.parametrize", "range", "emukit_qkernel.qK", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"kernel_embedding,intervals\"", ",", "\n", "[", "\n", "(", "\n", "gaussian_embeddings_test_list", "[", "0", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "0.13947611219369957", ",", "0.14011691061322437", "]", ",", "\n", "[", "0.2451677448342577", ",", "0.24601121206543616", "]", ",", "\n", "[", "0.18304341553566297", ",", "0.1838963624576538", "]", ",", "\n", "[", "0.11108022737109795", ",", "0.11170403633365646", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_embeddings_test_list", "[", "0", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "1.5229873955135163", ",", "1.537991178335842", "]", ",", "\n", "[", "2.828702323003249", ",", "2.843692090253037", "]", ",", "\n", "[", "2.937171398518155", ",", "2.9515842742084026", "]", ",", "\n", "[", "1.4729457662097771", ",", "1.4865846411248254", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_embeddings_test_list", "[", "1", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "1.1766117360187398", ",", "1.1935736584098973", "]", ",", "\n", "[", "2.3869071010842884", ",", "2.409142999694124", "]", ",", "\n", "[", "2.4148816892041203", ",", "2.437462244987469", "]", ",", "\n", "[", "1.3630166608625143", ",", "1.380811565518279", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_embeddings_test_list", "[", "2", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "1.26728433492353", ",", "1.2866546055251578", "]", ",", "\n", "[", "2.5895905423583936", ",", "2.610587138492034", "]", ",", "\n", "[", "2.6142699903775943", ",", "2.636482161926817", "]", ",", "\n", "[", "1.4609721776184352", ",", "1.47994291152272", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_embeddings_test_list", "[", "3", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "0.1743636401938356", ",", "0.17438715306808195", "]", ",", "\n", "[", "0.3273539016153389", ",", "0.3276550528251683", "]", ",", "\n", "[", "0.5394612581143717", ",", "0.5405487424242873", "]", ",", "\n", "[", "0.5893093858085915", ",", "0.5906872718055994", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_embeddings_test_list", "[", "4", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "20.967420743471486", ",", "20.980449036984133", "]", ",", "\n", "[", "17.640458953546258", ",", "17.644744818957854", "]", ",", "\n", "[", "27.766348676441904", ",", "27.796613394625194", "]", ",", "\n", "[", "28.15902659895897", ",", "28.19052362974676", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_normalized_embeddings_test_list", "[", "0", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "0.08461041086186201", ",", "0.08544395435199122", "]", ",", "\n", "[", "0.157150129055736", ",", "0.15798289390294645", "]", ",", "\n", "[", "0.1631761888065642", ",", "0.16397690412268906", "]", ",", "\n", "[", "0.08183032034498759", ",", "0.08258803561804583", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_normalized_embeddings_test_list", "[", "1", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "0.06536731866770777", ",", "0.06630964768943874", "]", ",", "\n", "[", "0.13260595006023823", ",", "0.13384127776078464", "]", ",", "\n", "[", "0.13416009384467334", ",", "0.13541456916597047", "]", ",", "\n", "[", "0.07572314782569524", ",", "0.07671175363990439", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_normalized_embeddings_test_list", "[", "2", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "0.07040468527352946", ",", "0.07148081141806432", "]", ",", "\n", "[", "0.143866141242133", ",", "0.145032618805113", "]", ",", "\n", "[", "0.14523722168764414", ",", "0.14647123121815653", "]", ",", "\n", "[", "0.08116512097880196", ",", "0.08221905064015111", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_normalized_embeddings_test_list", "[", "3", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "0.12454545728131114", ",", "0.12456225219148712", "]", ",", "\n", "[", "0.23382421543952772", ",", "0.2340393234465488", "]", ",", "\n", "[", "0.385329470081694", ",", "0.38610624458877657", "]", ",", "\n", "[", "0.42093527557756527", ",", "0.4219194798611424", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "lebesgue_normalized_embeddings_test_list", "[", "4", "]", ",", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "3.9412445006525356", ",", "3.9436934280045364", "]", ",", "\n", "[", "3.315875743147793", ",", "3.316681356946966", "]", ",", "\n", "[", "5.219238473015395", ",", "5.224927329816765", "]", ",", "\n", "[", "5.293050112586275", ",", "5.298970607095257", "]", ",", "\n", "]", "\n", ")", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_qkernel_qK", "(", "kernel_embedding", ",", "intervals", ")", ":", "\n", "# See test_qkernel_qKq on how the intervals were computed.", "\n", "    ", "emukit_qkernel", ",", "_", ",", "x2", ",", "_", ",", "_", ",", "_", ",", "_", "=", "kernel_embedding", "\n", "qK", "=", "emukit_qkernel", ".", "qK", "(", "x2", ")", "[", "0", ",", ":", "]", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "assert", "intervals", "[", "i", ",", "0", "]", "<", "qK", "[", "i", "]", "<", "intervals", "[", "i", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.test_qkernel_gradient_shapes": [[469, 481], ["pytest.mark.parametrize", "emukit_qkernel.dK_dx1", "emukit_qkernel.dK_dx2", "emukit_qkernel.dKdiag_dx", "emukit_qkernel.dKq_dx", "emukit_qkernel.dqK_dx"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dK_dx1", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dK_dx2", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dKdiag_dx", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dKq_dx", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.dqK_dx"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"kernel_embedding\"", ",", "embeddings_test_list", ")", "\n", "def", "test_qkernel_gradient_shapes", "(", "kernel_embedding", ")", ":", "\n", "    ", "emukit_qkernel", ",", "x1", ",", "x2", ",", "N", ",", "M", ",", "D", ",", "_", "=", "kernel_embedding", "\n", "\n", "# gradient of kernel", "\n", "assert", "emukit_qkernel", ".", "dK_dx1", "(", "x1", ",", "x2", ")", ".", "shape", "==", "(", "D", ",", "N", ",", "M", ")", "\n", "assert", "emukit_qkernel", ".", "dK_dx2", "(", "x1", ",", "x2", ")", ".", "shape", "==", "(", "D", ",", "N", ",", "M", ")", "\n", "assert", "emukit_qkernel", ".", "dKdiag_dx", "(", "x1", ")", ".", "shape", "==", "(", "D", ",", "N", ")", "\n", "\n", "# gradient of embeddings", "\n", "assert", "emukit_qkernel", ".", "dKq_dx", "(", "x1", ")", ".", "shape", "==", "(", "N", ",", "D", ")", "\n", "assert", "emukit_qkernel", ".", "dqK_dx", "(", "x2", ")", ".", "shape", "==", "(", "D", ",", "M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.test_qkernel_gradient_values": [[483, 520], ["pytest.mark.parametrize", "numpy.random.seed", "utils.sample_uniform", "utils.sample_uniform", "utils.check_grad", "utils.check_grad", "utils.check_grad", "utils.check_grad", "utils.check_grad", "numpy.diag", "emukit_qkernel.dKdiag_dx", "emukit_qkernel.K", "emukit_qkernel.dK_dx1", "emukit_qkernel.K", "emukit_qkernel.dK_dx2", "emukit_qkernel.qK", "emukit_qkernel.dqK_dx", "emukit_qkernel.K", "emukit_qkernel.Kq", "emukit_qkernel.dKq_dx"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dKdiag_dx", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dK_dx1", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dK_dx2", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.dqK_dx", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.Kq", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dKq_dx"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"kernel_embedding\"", ",", "embeddings_test_list", ")", "\n", "def", "test_qkernel_gradient_values", "(", "kernel_embedding", ")", ":", "\n", "    ", "emukit_qkernel", ",", "x1", ",", "x2", ",", "N", ",", "M", ",", "D", ",", "dat_bounds", "=", "kernel_embedding", "\n", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "x1", "=", "sample_uniform", "(", "in_shape", "=", "(", "N", ",", "D", ")", ",", "bounds", "=", "dat_bounds", ")", "\n", "x2", "=", "sample_uniform", "(", "in_shape", "=", "(", "M", ",", "D", ")", ",", "bounds", "=", "dat_bounds", ")", "\n", "\n", "# dKdiag_dx", "\n", "in_shape", "=", "x1", ".", "shape", "\n", "func", "=", "lambda", "x", ":", "np", ".", "diag", "(", "emukit_qkernel", ".", "K", "(", "x", ",", "x", ")", ")", "\n", "dfunc", "=", "lambda", "x", ":", "emukit_qkernel", ".", "dKdiag_dx", "(", "x", ")", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", ",", "dat_bounds", ")", "\n", "\n", "# dK_dx1", "\n", "in_shape", "=", "x1", ".", "shape", "\n", "func", "=", "lambda", "x", ":", "emukit_qkernel", ".", "K", "(", "x", ",", "x2", ")", "\n", "dfunc", "=", "lambda", "x", ":", "emukit_qkernel", ".", "dK_dx1", "(", "x", ",", "x2", ")", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", ",", "dat_bounds", ")", "\n", "\n", "# dK_dx2", "\n", "in_shape", "=", "x2", ".", "shape", "\n", "func", "=", "lambda", "x", ":", "emukit_qkernel", ".", "K", "(", "x1", ",", "x", ")", "\n", "dfunc", "=", "lambda", "x", ":", "emukit_qkernel", ".", "dK_dx2", "(", "x1", ",", "x", ")", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", ",", "dat_bounds", ")", "\n", "\n", "# dqK_dx", "\n", "in_shape", "=", "x2", ".", "shape", "\n", "func", "=", "lambda", "x", ":", "emukit_qkernel", ".", "qK", "(", "x", ")", "\n", "dfunc", "=", "lambda", "x", ":", "emukit_qkernel", ".", "dqK_dx", "(", "x", ")", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", ",", "dat_bounds", ")", "\n", "\n", "# dKq_dx", "\n", "in_shape", "=", "x1", ".", "shape", "\n", "func", "=", "lambda", "x", ":", "emukit_qkernel", ".", "Kq", "(", "x", ")", ".", "T", "\n", "dfunc", "=", "lambda", "x", ":", "emukit_qkernel", ".", "dKq_dx", "(", "x", ")", ".", "T", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", ",", "dat_bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.test_brownian_qkernel_raises": [[525, 545], ["emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "pytest.raises", "emukit.quadrature.kernels.QuadratureBrownianLebesgueMeasure", "pytest.raises", "emukit.quadrature.kernels.QuadratureBrownianLebesgueMeasure", "pytest.raises", "emukit.quadrature.kernels.QuadratureProductBrownianLebesgueMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.BrownianGPy", "emukit.model_wrappers.gpy_quadrature_wrappers.BrownianGPy", "emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy", "GPy.kern.Brownian", "GPy.kern.Brownian"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds", "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds", "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "test_brownian_qkernel_raises", "(", ")", ":", "\n", "\n", "# measure has wrong dimensionality", "\n", "    ", "wrong_bounds", "=", "[", "(", "1", ",", "2", ")", ",", "(", "1", ",", "2", ")", "]", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "wrong_bounds", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "QuadratureBrownianLebesgueMeasure", "(", "BrownianGPy", "(", "GPy", ".", "kern", ".", "Brownian", "(", ")", ")", ",", "measure", ")", "\n", "\n", "# bounds are negative", "\n", "", "wrong_bounds", "=", "[", "(", "-", "1", ",", "2", ")", "]", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "wrong_bounds", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "QuadratureBrownianLebesgueMeasure", "(", "BrownianGPy", "(", "GPy", ".", "kern", ".", "Brownian", "(", ")", ")", ",", "measure", ")", "\n", "\n", "# bounds are smaller thn offset (product kernel)", "\n", "", "offset", "=", "-", "2", "\n", "wrong_bounds", "=", "[", "(", "offset", "-", "1", ",", "offset", "+", "1", ")", ",", "(", "offset", "+", "1", ",", "offset", "+", "2", ")", "]", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "wrong_bounds", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "QuadratureProductBrownianLebesgueMeasure", "(", "ProductBrownianGPy", "(", "input_dim", "=", "2", ",", "offset", "=", "offset", ")", ",", "measure", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.test_quadrature_kernel_lebesgue_mixin": [[550, 579], ["pytest.mark.parametrize", "emukit.quadrature.interfaces.IStandardKernel", "qkernel_type.from_integral_bounds", "isinstance", "qkernel_type.from_integral_bounds", "isinstance"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.LebesgueEmbedding.from_integral_bounds", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.LebesgueEmbedding.from_integral_bounds"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"qkernel_type\"", ",", "\n", "[", "\n", "QuadratureRBFLebesgueMeasure", ",", "\n", "QuadratureProductMatern32LebesgueMeasure", ",", "\n", "QuadratureProductMatern52LebesgueMeasure", ",", "\n", "QuadratureBrownianLebesgueMeasure", ",", "\n", "QuadratureBrownianLebesgueMeasure", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_quadrature_kernel_lebesgue_mixin", "(", "qkernel_type", ")", ":", "\n", "    ", "bounds", "=", "[", "(", "1", ",", "3", ")", "]", "\n", "kern", "=", "IStandardKernel", "(", ")", "\n", "\n", "# un-normalized measure", "\n", "normalized", "=", "False", "\n", "qkern", "=", "qkernel_type", ".", "from_integral_bounds", "(", "kern", ",", "bounds", ",", "normalized", ")", "\n", "\n", "assert", "isinstance", "(", "qkern", ".", "measure", ",", "LebesgueMeasure", ")", "\n", "assert", "qkern", ".", "measure", ".", "domain", ".", "bounds", "==", "bounds", "\n", "assert", "qkern", ".", "measure", ".", "density", "==", "1.0", "\n", "\n", "# normalized measure", "\n", "normalized", "=", "True", "\n", "qkern", "=", "qkernel_type", ".", "from_integral_bounds", "(", "kern", ",", "bounds", ",", "normalized", ")", "\n", "\n", "assert", "isinstance", "(", "qkern", ".", "measure", ",", "LebesgueMeasure", ")", "\n", "assert", "qkern", ".", "measure", ".", "domain", ".", "bounds", "==", "bounds", "\n", "assert", "qkern", ".", "measure", ".", "density", "==", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_quadrature_kernels.test_quadrature_kernel_gaussian_mixin": [[581, 608], ["pytest.mark.parametrize", "numpy.array", "emukit.quadrature.interfaces.IStandardKernel", "numpy.array", "qkernel_type.from_measure_params", "isinstance", "numpy.all", "numpy.all", "qkernel_type.from_measure_params", "isinstance", "numpy.all", "numpy.all", "numpy.full"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.GaussianEmbedding.from_measure_params", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.GaussianEmbedding.from_measure_params"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"qkernel_type\"", ",", "\n", "[", "\n", "QuadratureRBFGaussianMeasure", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_quadrature_kernel_gaussian_mixin", "(", "qkernel_type", ")", ":", "\n", "    ", "mean", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "kern", "=", "IStandardKernel", "(", ")", "\n", "\n", "# diagonal covariance", "\n", "variance", "=", "np", ".", "array", "(", "[", "1.0", ",", "2.0", "]", ")", "\n", "qkern", "=", "qkernel_type", ".", "from_measure_params", "(", "kern", ",", "mean", ",", "variance", ")", "\n", "\n", "assert", "isinstance", "(", "qkern", ".", "measure", ",", "GaussianMeasure", ")", "\n", "assert", "not", "qkern", ".", "measure", ".", "is_isotropic", "\n", "assert", "np", ".", "all", "(", "qkern", ".", "measure", ".", "mean", "==", "mean", ")", "\n", "assert", "np", ".", "all", "(", "qkern", ".", "measure", ".", "variance", "==", "variance", ")", "\n", "\n", "# isotropic covariance", "\n", "variance", "=", "2.0", "\n", "qkern", "=", "qkernel_type", ".", "from_measure_params", "(", "kern", ",", "mean", ",", "variance", ")", "\n", "\n", "assert", "isinstance", "(", "qkern", ".", "measure", ",", "GaussianMeasure", ")", "\n", "assert", "qkern", ".", "measure", ".", "is_isotropic", "\n", "assert", "np", ".", "all", "(", "qkern", ".", "measure", ".", "mean", "==", "mean", ")", "\n", "assert", "np", ".", "all", "(", "qkern", ".", "measure", ".", "variance", "==", "np", ".", "full", "(", "mean", ".", "shape", ",", "variance", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_domain.box_domain": [[12, 17], ["emukit.quadrature.measures.BoxDomain"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "box_domain", "(", ")", ":", "\n", "    ", "bounds", "=", "3", "*", "[", "(", "-", "4", ",", "4", ")", "]", "\n", "integral_bounds", "=", "BoxDomain", "(", "name", "=", "\"test_name\"", ",", "bounds", "=", "bounds", ")", "\n", "return", "integral_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_domain.test_box_domain_values": [[19, 33], ["emukit.quadrature.measures.BoxDomain", "numpy.array", "numpy.array", "numpy.all", "numpy.all", "len", "emukit.quadrature.measures.BoxDomain.convert_to_list_of_continuous_parameters"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain.convert_to_list_of_continuous_parameters"], ["", "def", "test_box_domain_values", "(", ")", ":", "\n", "    ", "bounds", "=", "[", "(", "-", "1", ",", "1", ")", ",", "(", "-", "2", ",", "0", ")", "]", "\n", "test_name", "=", "\"test_name\"", "\n", "domain", "=", "BoxDomain", "(", "name", "=", "test_name", ",", "bounds", "=", "bounds", ")", "\n", "\n", "# must match to the ones above", "\n", "lower_bounds", "=", "np", ".", "array", "(", "[", "-", "1", ",", "-", "2", "]", ")", "\n", "upper_bounds", "=", "np", ".", "array", "(", "[", "1", ",", "0", "]", ")", "\n", "\n", "assert", "np", ".", "all", "(", "domain", ".", "lower_bounds", "==", "lower_bounds", ")", "\n", "assert", "np", ".", "all", "(", "domain", ".", "upper_bounds", "==", "upper_bounds", ")", "\n", "\n", "assert", "len", "(", "domain", ".", "convert_to_list_of_continuous_parameters", "(", ")", ")", "==", "2", "\n", "assert", "domain", ".", "name", "==", "test_name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_domain.test_box_domain_wrong_bounds": [[35, 44], ["pytest.raises", "emukit.quadrature.measures.BoxDomain", "pytest.raises", "emukit.quadrature.measures.BoxDomain"], "function", ["None"], ["", "def", "test_box_domain_wrong_bounds", "(", ")", ":", "\n", "    ", "bounds_wrong", "=", "[", "(", "-", "1", ",", "1", ")", ",", "(", "0", ",", "-", "2", ")", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "BoxDomain", "(", "name", "=", "\"test_name\"", ",", "bounds", "=", "bounds_wrong", ")", "\n", "\n", "", "bounds_empty", "=", "[", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "BoxDomain", "(", "name", "=", "\"test_name\"", ",", "bounds", "=", "bounds_empty", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_domain.test_box_domain_set_bounds": [[46, 59], ["numpy.array", "numpy.array", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal"], "function", ["None"], ["", "", "def", "test_box_domain_set_bounds", "(", "box_domain", ")", ":", "\n", "    ", "new_bounds", "=", "3", "*", "[", "(", "-", "2", ",", "2", ")", "]", "\n", "\n", "# these must match the above bounds", "\n", "new_lower", "=", "np", ".", "array", "(", "[", "-", "2", ",", "-", "2", ",", "-", "2", "]", ")", "\n", "new_upper", "=", "np", ".", "array", "(", "[", "2", ",", "2", ",", "2", "]", ")", "\n", "\n", "# set new", "\n", "box_domain", ".", "bounds", "=", "new_bounds", "\n", "\n", "assert_array_equal", "(", "box_domain", ".", "bounds", ",", "new_bounds", ")", "\n", "assert_array_equal", "(", "box_domain", ".", "lower_bounds", ",", "new_lower", ")", "\n", "assert_array_equal", "(", "box_domain", ".", "upper_bounds", ",", "new_upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_domain.test_box_domain_set_bounds_raises": [[61, 76], ["pytest.raises", "pytest.raises", "pytest.raises"], "function", ["None"], ["", "def", "test_box_domain_set_bounds_raises", "(", "box_domain", ")", ":", "\n", "# wrong dimensionality", "\n", "    ", "wrong_bounds", "=", "4", "*", "[", "(", "-", "2", ",", "2", ")", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "box_domain", ".", "bounds", "=", "wrong_bounds", "\n", "\n", "# empty bounds", "\n", "", "wrong_bounds", "=", "[", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "box_domain", ".", "bounds", "=", "wrong_bounds", "\n", "\n", "# wrong bound values", "\n", "", "wrong_bounds", "=", "3", "*", "[", "(", "-", "2", ",", "-", "3", ")", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "box_domain", ".", "bounds", "=", "wrong_bounds", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils._compute_numerical_gradient": [[11, 34], ["utils.sample_uniform", "func", "dfunc", "numpy.zeros", "range", "sample_uniform.copy", "func"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.func", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.func"], ["def", "_compute_numerical_gradient", "(", "\n", "func", ":", "Callable", ",", "dfunc", ":", "Callable", ",", "in_shape", ":", "Tuple", "[", "int", ",", "...", "]", ",", "bounds", ":", "BoundsType", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"Computes the numerical gradient of ``func``.\n\n    :param func: Function must take inputs of shape ``in_shape = s + (input_dim, )`` and return np.ndarray of shape ``s``.\n    :param dfunc: Gradient of function to be tested. Must return np.ndarray of shape ``(input_dim) + s``.\n    :param in_shape: The input shape to ``func``. Must be of form ``in_shape = s + (input_dim, )``.\n    :param bounds: The bounds for the x values.\n    :return: The gradient ``dfunc`` evaluated at a random location and its numerical gradient.\n    \"\"\"", "\n", "eps", "=", "1e-8", "\n", "x", "=", "sample_uniform", "(", "in_shape", ",", "bounds", ")", "\n", "f", "=", "func", "(", "x", ")", "\n", "df", "=", "dfunc", "(", "x", ")", "\n", "dft", "=", "np", ".", "zeros", "(", "df", ".", "shape", ")", "\n", "for", "d", "in", "range", "(", "x", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "x_tmp", "=", "x", ".", "copy", "(", ")", "\n", "x_tmp", "[", "...", ",", "d", "]", "=", "x_tmp", "[", "...", ",", "d", "]", "+", "eps", "\n", "f_tmp", "=", "func", "(", "x_tmp", ")", "\n", "dft_d", "=", "(", "f_tmp", "-", "f", ")", "/", "eps", "\n", "dft", "[", "d", ",", "...", "]", "=", "dft_d", "\n", "", "return", "df", ",", "dft", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad": [[36, 58], ["utils._compute_numerical_gradient", "numpy.array", "math.isclose", "zip", "df.flatten", "dft.flatten"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils._compute_numerical_gradient"], ["", "def", "check_grad", "(", "\n", "func", ":", "Callable", ",", "\n", "dfunc", ":", "Callable", ",", "\n", "in_shape", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "bounds", ":", "BoundsType", ",", "\n", "atol", ":", "float", "=", "1e-4", ",", "\n", "rtol", ":", "float", "=", "1e-5", ",", "\n", ")", "->", "None", ":", "\n", "    ", "\"\"\"Asserts if the gradient of a function is close to its numerical gradient.\n\n    :param func: Function must take inputs of shape ``in_shape = s + (input_dim, )`` and return np.ndarray of shape ``s``.\n    :param dfunc: Gradient of function to be tested. Must return np.ndarray of shape ``(input_dim) + s``.\n    :param in_shape: The input shape to ``func``. Must be of form ``in_shape = s + (input_dim, )``.\n    :param bounds: The bounds for the x values.\n    :param atol: Absolute tolerance of the closeness check. Defaults to 1e-4.\n    :param atol: Relative tolerance of the closeness check. Defaults to 1e-5.\n    \"\"\"", "\n", "df", ",", "dft", "=", "_compute_numerical_gradient", "(", "func", ",", "dfunc", ",", "in_shape", ",", "bounds", ")", "\n", "isclose_all", "=", "np", ".", "array", "(", "\n", "[", "isclose", "(", "grad1", ",", "grad2", ",", "rel_tol", "=", "rtol", ",", "abs_tol", "=", "atol", ")", "for", "grad1", ",", "grad2", "in", "zip", "(", "df", ".", "flatten", "(", ")", ",", "dft", ".", "flatten", "(", ")", ")", "]", "\n", ")", "\n", "assert", "(", "1", "-", "isclose_all", ")", ".", "sum", "(", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.sample_uniform": [[60, 66], ["numpy.prod", "numpy.zeros", "enumerate", "numpy.random.uniform"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform"], ["", "def", "sample_uniform", "(", "in_shape", ",", "bounds", ")", ":", "\n", "    ", "n_samples", "=", "np", ".", "prod", "(", "in_shape", "[", ":", "-", "1", "]", ")", "\n", "samples", "=", "np", ".", "zeros", "(", "in_shape", ")", "\n", "for", "i", ",", "b", "in", "enumerate", "(", "bounds", ")", ":", "\n", "        ", "samples", "[", "...", ",", "i", "]", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "b", "[", "0", "]", ",", "high", "=", "b", "[", "1", "]", ",", "size", "=", "n_samples", ")", "\n", "", "return", "samples", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.lebesgue_measure": [[55, 58], ["pytest.fixture", "test_measures.DataLebesgueMeasure"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "lebesgue_measure", "(", ")", ":", "\n", "    ", "return", "DataLebesgueMeasure", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.lebesgue_measure_normalized": [[60, 63], ["pytest.fixture", "test_measures.DataLebesgueNormalizedMeasure"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "lebesgue_measure_normalized", "(", ")", ":", "\n", "    ", "return", "DataLebesgueNormalizedMeasure", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.gauss_iso_measure": [[65, 68], ["pytest.fixture", "test_measures.DataGaussIsoMeasure"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "gauss_iso_measure", "(", ")", ":", "\n", "    ", "return", "DataGaussIsoMeasure", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.gauss_measure": [[70, 73], ["pytest.fixture", "test_measures.DataGaussMeasure"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "gauss_measure", "(", ")", ":", "\n", "    ", "return", "DataGaussMeasure", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.test_measure_gradient_values": [[86, 92], ["pytest.mark.parametrize", "utils.check_grad", "measure.compute_density", "measure.compute_density_gradient"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density_gradient"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"measure\"", ",", "measure_test_list", ")", "\n", "def", "test_measure_gradient_values", "(", "measure", ")", ":", "\n", "    ", "D", ",", "measure", ",", "dat_bounds", "=", "measure", ".", "D", ",", "measure", ".", "measure", ",", "measure", ".", "dat_bounds", "\n", "func", "=", "lambda", "x", ":", "measure", ".", "compute_density", "(", "x", ")", "\n", "dfunc", "=", "lambda", "x", ":", "measure", ".", "compute_density_gradient", "(", "x", ")", ".", "T", "\n", "check_grad", "(", "func", ",", "dfunc", ",", "in_shape", "=", "(", "3", ",", "D", ")", ",", "bounds", "=", "dat_bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.test_measure_shapes": [[94, 116], ["pytest.mark.parametrize", "measure.reasonable_box", "numpy.random.seed", "numpy.random.randn", "measure.compute_density", "measure.sample", "len", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.reasonable_box", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"measure\"", ",", "measure_test_list", ")", "\n", "def", "test_measure_shapes", "(", "measure", ")", ":", "\n", "    ", "D", ",", "measure", "=", "measure", ".", "D", ",", "measure", ".", "measure", "\n", "\n", "# box bounds", "\n", "bounds", "=", "measure", ".", "reasonable_box", "(", ")", "\n", "assert", "len", "(", "bounds", ")", "==", "D", "\n", "for", "b", "in", "bounds", ":", "\n", "        ", "assert", "len", "(", "b", ")", "==", "2", "\n", "\n", "# density", "\n", "", "N", "=", "5", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "x", "=", "np", ".", "random", ".", "randn", "(", "N", ",", "D", ")", "\n", "\n", "res", "=", "measure", ".", "compute_density", "(", "x", ")", "\n", "assert", "res", ".", "shape", "==", "(", "N", ",", ")", "\n", "\n", "# sampling capabilities", "\n", "assert", "measure", ".", "can_sample", "\n", "res", "=", "measure", ".", "sample", "(", "N", ")", "\n", "assert", "res", ".", "shape", "==", "(", "N", ",", "D", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.test_lebesgue_measure_values": [[121, 144], ["isclose", "m.reasonable_box", "m_norm.reasonable_box"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.reasonable_box", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.reasonable_box"], ["", "def", "test_lebesgue_measure_values", "(", "lebesgue_measure", ",", "lebesgue_measure_normalized", ")", ":", "\n", "    ", "from", "math", "import", "isclose", "\n", "\n", "m", "=", "lebesgue_measure", ".", "measure", "\n", "dat", "=", "lebesgue_measure", "\n", "\n", "m_norm", "=", "lebesgue_measure_normalized", ".", "measure", "\n", "dat_norm", "=", "lebesgue_measure_normalized", "\n", "\n", "assert", "not", "m", ".", "is_normalized", "\n", "assert", "m_norm", ".", "is_normalized", "\n", "\n", "assert", "m", ".", "can_sample", "\n", "assert", "m_norm", ".", "can_sample", "\n", "\n", "assert", "m", ".", "input_dim", "==", "dat", ".", "D", "\n", "assert", "m_norm", ".", "input_dim", "==", "dat_norm", ".", "D", "\n", "\n", "assert", "m", ".", "density", "==", "1.0", "\n", "assert", "isclose", "(", "m_norm", ".", "density", ",", "1", "/", "dat_norm", ".", "volume", ")", "\n", "\n", "assert", "m", ".", "reasonable_box", "(", ")", "==", "dat", ".", "bounds", "\n", "assert", "m_norm", ".", "reasonable_box", "(", ")", "==", "dat_norm", ".", "bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.test_lebesgue_measure_raises": [[146, 156], ["pytest.raises", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "pytest.raises", "emukit.quadrature.measures.LebesgueMeasure.from_bounds"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds", "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "test_lebesgue_measure_raises", "(", ")", ":", "\n", "# upper bound smaller than lower bound", "\n", "    ", "wrong_bounds", "=", "[", "(", "-", "1", ",", "1", ")", ",", "(", "0", ",", "-", "2", ")", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "wrong_bounds", ")", "\n", "\n", "# empty domain", "\n", "", "wrong_bounds", "=", "[", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "wrong_bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.test_gauss_measure_values": [[161, 182], ["all", "all", "all", "all", "numpy.allclose", "numpy.allclose", "m.reasonable_box", "m_iso.reasonable_box"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.reasonable_box", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.reasonable_box"], ["", "", "def", "test_gauss_measure_values", "(", "gauss_measure", ",", "gauss_iso_measure", ")", ":", "\n", "    ", "m", "=", "gauss_measure", ".", "measure", "\n", "dat", "=", "gauss_measure", "\n", "\n", "m_iso", "=", "gauss_iso_measure", ".", "measure", "\n", "dat_iso", "=", "gauss_iso_measure", "\n", "\n", "assert", "m_iso", ".", "is_isotropic", "\n", "assert", "not", "m", ".", "is_isotropic", "\n", "\n", "assert", "m_iso", ".", "input_dim", "==", "dat_iso", ".", "D", "\n", "assert", "not", "m", ".", "is_isotropic", "==", "dat", ".", "D", "\n", "\n", "assert", "all", "(", "m_iso", ".", "mean", "==", "dat_iso", ".", "mean", ")", "\n", "assert", "all", "(", "gauss_measure", ".", "measure", ".", "mean", "==", "dat", ".", "mean", ")", "\n", "\n", "assert", "all", "(", "m_iso", ".", "variance", "==", "dat_iso", ".", "variance", ")", "\n", "assert", "all", "(", "gauss_measure", ".", "measure", ".", "variance", "==", "dat", ".", "variance", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "m", ".", "reasonable_box", "(", ")", ",", "dat", ".", "reasonable_box_bounds", ")", "\n", "assert", "np", ".", "allclose", "(", "m_iso", ".", "reasonable_box", "(", ")", ",", "dat_iso", ".", "reasonable_box_bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.test_gauss_measure_shapes": [[184, 190], ["None"], "function", ["None"], ["", "def", "test_gauss_measure_shapes", "(", "gauss_measure", ",", "gauss_iso_measure", ")", ":", "\n", "    ", "input_dim", "=", "gauss_measure", ".", "D", "\n", "measure", "=", "gauss_measure", ".", "measure", "\n", "assert", "measure", ".", "mean", ".", "shape", "==", "(", "input_dim", ",", ")", "\n", "assert", "measure", ".", "variance", ".", "shape", "==", "(", "input_dim", ",", ")", "\n", "assert", "measure", ".", "full_covariance_matrix", ".", "shape", "==", "(", "input_dim", ",", "input_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.test_gauss_measure_invalid_variance_raises": [[192, 206], ["pytest.mark.parametrize", "pytest.raises", "emukit.quadrature.measures.GaussianMeasure", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"wrong_input\"", ",", "\n", "[", "\n", "(", "np", ".", "ones", "(", "3", ")", ",", "-", "2.0", ")", ",", "\n", "(", "np", ".", "ones", "(", "3", ")", ",", "-", "np", ".", "array", "(", "[", "0.0", ",", "1.0", ",", "2.0", "]", ")", ")", ",", "\n", "(", "np", ".", "ones", "(", "3", ")", ",", "-", "np", ".", "array", "(", "[", "1.0", ",", "-", "1.0", ",", "2.0", "]", ")", ")", ",", "\n", "(", "np", ".", "ones", "(", "3", ")", ",", "-", "np", ".", "array", "(", "[", "1.0", ",", "2.0", "]", ")", ")", ",", "\n", "(", "np", ".", "ones", "(", "3", ")", ",", "-", "np", ".", "array", "(", "[", "1.0", ",", "-", "1.0", ",", "2.0", "]", ")", "[", ":", ",", "None", "]", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_gauss_measure_invalid_variance_raises", "(", "wrong_input", ")", ":", "\n", "    ", "mean", ",", "var_wrong_value", "=", "wrong_input", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "GaussianMeasure", "(", "mean", "=", "mean", ",", "variance", "=", "var_wrong_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_measures.test_gauss_measure_invalid_mean_raises": [[208, 216], ["numpy.ones", "pytest.raises", "emukit.quadrature.measures.GaussianMeasure", "pytest.raises", "emukit.quadrature.measures.GaussianMeasure"], "function", ["None"], ["", "", "def", "test_gauss_measure_invalid_mean_raises", "(", ")", ":", "\n", "    ", "mean_wrong_shape", "=", "np", ".", "ones", "(", "[", "3", ",", "1", "]", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "GaussianMeasure", "(", "mean", "=", "mean_wrong_shape", ",", "variance", "=", "1.0", ")", "\n", "\n", "", "mean_wrong_type", "=", "0.0", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "        ", "GaussianMeasure", "(", "mean", "=", "mean_wrong_type", ",", "variance", "=", "1.0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_vanilla_bq_loop.func": [[17, 19], ["numpy.ones"], "function", ["None"], ["def", "func", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_vanilla_bq_loop.loop": [[21, 37], ["numpy.random.rand", "numpy.random.rand", "GPy.models.GPRegression", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.model_wrappers.gpy_quadrature_wrappers.QuadratureRBFLebesgueMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy", "emukit.quadrature.methods.VanillaBayesianQuadrature", "emukit.quadrature.loop.VanillaBayesianQuadratureLoop", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy", "GPy.kern.RBF"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "@", "pytest", ".", "fixture", "\n", "def", "loop", "(", ")", ":", "\n", "    ", "init_size", "=", "5", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "init_size", ",", "2", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "init_size", ",", "1", ")", "\n", "bounds", "=", "[", "(", "-", "1", ",", "1", ")", ",", "(", "0", ",", "1", ")", "]", "\n", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "\n", "X", "=", "x_init", ",", "Y", "=", "y_init", ",", "kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "x_init", ".", "shape", "[", "1", "]", ",", "lengthscale", "=", "1.0", ",", "variance", "=", "1.0", ")", "\n", ")", "\n", "emukit_measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", ",", "normalized", "=", "False", ")", "\n", "emukit_qrbf", "=", "QuadratureRBFLebesgueMeasure", "(", "RBFGPy", "(", "gpy_model", ".", "kern", ")", ",", "measure", "=", "emukit_measure", ")", "\n", "emukit_model", "=", "BaseGaussianProcessGPy", "(", "kern", "=", "emukit_qrbf", ",", "gpy_model", "=", "gpy_model", ")", "\n", "emukit_method", "=", "VanillaBayesianQuadrature", "(", "base_gp", "=", "emukit_model", ",", "X", "=", "x_init", ",", "Y", "=", "y_init", ")", "\n", "emukit_loop", "=", "VanillaBayesianQuadratureLoop", "(", "model", "=", "emukit_method", ")", "\n", "return", "emukit_loop", ",", "init_size", ",", "x_init", ",", "y_init", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_vanilla_bq_loop.test_vanilla_bq_loop": [[39, 47], ["emukit_loop.run_loop", "emukit.core.loop.user_function.UserFunctionWrapper"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_vanilla_bq_loop", "(", "loop", ")", ":", "\n", "    ", "emukit_loop", ",", "init_size", ",", "_", ",", "_", "=", "loop", "\n", "num_iter", "=", "5", "\n", "\n", "emukit_loop", ".", "run_loop", "(", "user_function", "=", "UserFunctionWrapper", "(", "func", ")", ",", "stopping_condition", "=", "num_iter", ")", "\n", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "num_iter", "+", "init_size", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "Y", ".", "shape", "[", "0", "]", "==", "num_iter", "+", "init_size", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_vanilla_bq_loop.test_vanilla_bq_loop_initial_state": [[49, 55], ["numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal"], "function", ["None"], ["", "def", "test_vanilla_bq_loop_initial_state", "(", "loop", ")", ":", "\n", "    ", "emukit_loop", ",", "_", ",", "x_init", ",", "y_init", "=", "loop", "\n", "\n", "assert_array_equal", "(", "emukit_loop", ".", "loop_state", ".", "X", ",", "x_init", ")", "\n", "assert_array_equal", "(", "emukit_loop", ".", "loop_state", ".", "Y", ",", "y_init", ")", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "iteration", "==", "0", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_bayesian_monte_carlo_loop.func": [[17, 19], ["numpy.ones"], "function", ["None"], ["def", "func", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_bayesian_monte_carlo_loop.loop": [[21, 37], ["numpy.random.rand", "numpy.random.rand", "GPy.models.GPRegression", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.model_wrappers.gpy_quadrature_wrappers.QuadratureRBFLebesgueMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy", "emukit.quadrature.methods.VanillaBayesianQuadrature", "emukit.quadrature.loop.BayesianMonteCarlo", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy", "GPy.kern.RBF"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "@", "pytest", ".", "fixture", "\n", "def", "loop", "(", ")", ":", "\n", "    ", "init_size", "=", "5", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "init_size", ",", "2", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "init_size", ",", "1", ")", "\n", "bounds", "=", "[", "(", "-", "1", ",", "1", ")", ",", "(", "0", ",", "1", ")", "]", "\n", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "\n", "X", "=", "x_init", ",", "Y", "=", "y_init", ",", "kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "x_init", ".", "shape", "[", "1", "]", ",", "lengthscale", "=", "1.0", ",", "variance", "=", "1.0", ")", "\n", ")", "\n", "emukit_measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", ",", "normalized", "=", "False", ")", "\n", "emukit_qrbf", "=", "QuadratureRBFLebesgueMeasure", "(", "RBFGPy", "(", "gpy_model", ".", "kern", ")", ",", "measure", "=", "emukit_measure", ")", "\n", "emukit_model", "=", "BaseGaussianProcessGPy", "(", "kern", "=", "emukit_qrbf", ",", "gpy_model", "=", "gpy_model", ")", "\n", "emukit_method", "=", "VanillaBayesianQuadrature", "(", "base_gp", "=", "emukit_model", ",", "X", "=", "x_init", ",", "Y", "=", "y_init", ")", "\n", "emukit_loop", "=", "BayesianMonteCarlo", "(", "model", "=", "emukit_method", ")", "\n", "return", "emukit_loop", ",", "init_size", ",", "x_init", ",", "y_init", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_bayesian_monte_carlo_loop.test_bayesian_monte_carlo_loop": [[39, 47], ["emukit_loop.run_loop", "emukit.core.loop.user_function.UserFunctionWrapper"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_bayesian_monte_carlo_loop", "(", "loop", ")", ":", "\n", "    ", "emukit_loop", ",", "init_size", ",", "_", ",", "_", "=", "loop", "\n", "\n", "num_iter", "=", "5", "\n", "emukit_loop", ".", "run_loop", "(", "user_function", "=", "UserFunctionWrapper", "(", "func", ")", ",", "stopping_condition", "=", "num_iter", ")", "\n", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "num_iter", "+", "init_size", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "Y", ".", "shape", "[", "0", "]", "==", "num_iter", "+", "init_size", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_bayesian_monte_carlo_loop.test_bayesian_monte_carlo_loop_initial_state": [[49, 55], ["numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal"], "function", ["None"], ["", "def", "test_bayesian_monte_carlo_loop_initial_state", "(", "loop", ")", ":", "\n", "    ", "emukit_loop", ",", "_", ",", "x_init", ",", "y_init", "=", "loop", "\n", "\n", "assert_array_equal", "(", "emukit_loop", ".", "loop_state", ".", "X", ",", "x_init", ")", "\n", "assert_array_equal", "(", "emukit_loop", ".", "loop_state", ".", "Y", ",", "y_init", ")", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "iteration", "==", "0", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.func": [[14, 16], ["numpy.ones"], "function", ["None"], ["def", "func", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.base_gp_data": [[18, 27], ["numpy.array", "numpy.array", "GPy.models.GPRegression", "emukit.quadrature.measures.GaussianMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.QuadratureRBFGaussianMeasure", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy", "GPy.kern.RBF", "numpy.array"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "base_gp_data", "(", ")", ":", "\n", "    ", "X", "=", "np", ".", "array", "(", "[", "[", "-", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "-", "2", ",", "0.1", "]", "]", ")", "\n", "Y", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "X", "=", "X", ",", "Y", "=", "Y", ",", "kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "measure", "=", "GaussianMeasure", "(", "mean", "=", "np", ".", "array", "(", "[", "0.1", ",", "1.8", "]", ")", ",", "variance", "=", "0.8", ")", "\n", "qrbf", "=", "QuadratureRBFGaussianMeasure", "(", "RBFGPy", "(", "gpy_model", ".", "kern", ")", ",", "measure", "=", "measure", ")", "\n", "base_gp", "=", "BaseGaussianProcessGPy", "(", "kern", "=", "qrbf", ",", "gpy_model", "=", "gpy_model", ")", "\n", "return", "base_gp", ",", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.wsabil_adapt": [[29, 34], ["emukit.quadrature.methods.WSABIL"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wsabil_adapt", "(", "base_gp_data", ")", ":", "\n", "    ", "base_gp", ",", "X", ",", "Y", "=", "base_gp_data", "\n", "wsabil", "=", "WSABIL", "(", "base_gp", "=", "base_gp", ",", "X", "=", "X", ",", "Y", "=", "Y", ",", "adapt_alpha", "=", "True", ")", "\n", "return", "wsabil", ",", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.wsabil_fixed": [[36, 41], ["emukit.quadrature.methods.WSABIL"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wsabil_fixed", "(", "base_gp_data", ")", ":", "\n", "    ", "base_gp", ",", "X", ",", "Y", "=", "base_gp_data", "\n", "wsabil", "=", "WSABIL", "(", "base_gp", "=", "base_gp", ",", "X", "=", "base_gp", ".", "X", ",", "Y", "=", "base_gp", ".", "Y", ",", "adapt_alpha", "=", "True", ")", "\n", "return", "wsabil", ",", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.loop_adapt": [[43, 48], ["emukit.quadrature.loop.WSABILLoop"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "loop_adapt", "(", "wsabil_adapt", ")", ":", "\n", "    ", "emukit_model", ",", "X", ",", "Y", "=", "wsabil_adapt", "\n", "emukit_loop", "=", "WSABILLoop", "(", "model", "=", "emukit_model", ")", "\n", "return", "emukit_loop", ",", "Y", ".", "shape", "[", "0", "]", ",", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.loop_fixed": [[50, 55], ["emukit.quadrature.loop.WSABILLoop"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "loop_fixed", "(", "wsabil_fixed", ")", ":", "\n", "    ", "emukit_model", ",", "X", ",", "Y", "=", "wsabil_fixed", "\n", "emukit_loop", "=", "WSABILLoop", "(", "model", "=", "emukit_model", ")", "\n", "return", "emukit_loop", ",", "Y", ".", "shape", "[", "0", "]", ",", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.test_wsabil_loop": [[60, 69], ["pytest.mark.parametrize", "emukit_loop.run_loop", "emukit.core.loop.user_function.UserFunctionWrapper"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"loop\"", ",", "wsabi_test_list", ")", "\n", "def", "test_wsabil_loop", "(", "loop", ")", ":", "\n", "    ", "emukit_loop", ",", "init_size", ",", "_", ",", "_", "=", "loop", "\n", "num_iter", "=", "5", "\n", "\n", "emukit_loop", ".", "run_loop", "(", "user_function", "=", "UserFunctionWrapper", "(", "func", ")", ",", "stopping_condition", "=", "num_iter", ")", "\n", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "num_iter", "+", "init_size", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "Y", ".", "shape", "[", "0", "]", "==", "num_iter", "+", "init_size", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.test_wsabil_loop_initial_state": [[71, 78], ["pytest.mark.parametrize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"loop\"", ",", "wsabi_test_list", ")", "\n", "def", "test_wsabil_loop_initial_state", "(", "loop", ")", ":", "\n", "    ", "emukit_loop", ",", "_", ",", "x_init", ",", "y_init", "=", "loop", "\n", "\n", "assert_array_equal", "(", "emukit_loop", ".", "loop_state", ".", "X", ",", "x_init", ")", "\n", "assert_array_equal", "(", "emukit_loop", ".", "loop_state", ".", "Y", ",", "y_init", ")", "\n", "assert", "emukit_loop", ".", "loop_state", ".", "iteration", "==", "0", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.borehole.multi_fidelity_borehole_function": [[11, 48], ["core.ParameterSpace", "core.loop.user_function.MultiSourceFunctionWrapper", "core.ContinuousParameter", "core.ContinuousParameter", "core.ContinuousParameter", "core.ContinuousParameter", "core.ContinuousParameter", "core.ContinuousParameter", "core.ContinuousParameter", "core.ContinuousParameter", "core.InformationSourceParameter", "borehole._borehole_low", "borehole._borehole_high"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.borehole._borehole_low", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.borehole._borehole_high"], ["def", "multi_fidelity_borehole_function", "(", "\n", "high_noise_std_deviation", ":", "float", "=", "0", ",", "low_noise_std_deviation", ":", "float", "=", "0", "\n", ")", "->", "Tuple", "[", "MultiSourceFunctionWrapper", ",", "ParameterSpace", "]", ":", "\n", "    ", "\"\"\"\n    Two level borehole function.\n\n    The Borehole function models water flow through a borehole. Its simplicity and quick evaluation makes it a commonly\n    used function for testing a wide variety of methods in computer experiments.\n\n    See reference for equations:\n    https://www.sfu.ca/~ssurjano/borehole.html\n\n    :param high_noise_std_deviation: Standard deviation of Gaussian observation noise on high fidelity observations.\n                                     Defaults to zero.\n    :param low_noise_std_deviation: Standard deviation of Gaussian observation noise on low fidelity observations.\n                                     Defaults to zero.\n    :return: Tuple of user function object and parameter space\n    \"\"\"", "\n", "parameter_space", "=", "ParameterSpace", "(", "\n", "[", "\n", "ContinuousParameter", "(", "\"borehole_radius\"", ",", "0.05", ",", "0.15", ")", ",", "\n", "ContinuousParameter", "(", "\"radius_of_influence\"", ",", "100", ",", "50000", ")", ",", "\n", "ContinuousParameter", "(", "\"upper_aquifer_transmissivity\"", ",", "63070", ",", "115600", ")", ",", "\n", "ContinuousParameter", "(", "\"upper_aquifer_head\"", ",", "990", ",", "1110", ")", ",", "\n", "ContinuousParameter", "(", "\"lower_aquifer_transmissivity\"", ",", "63.1", ",", "116", ")", ",", "\n", "ContinuousParameter", "(", "\"lower_aquifer_head\"", ",", "700", ",", "820", ")", ",", "\n", "ContinuousParameter", "(", "\"borehole_length\"", ",", "1120", ",", "1680", ")", ",", "\n", "ContinuousParameter", "(", "\"hydraulic_conductivity\"", ",", "9855", ",", "12045", ")", ",", "\n", "InformationSourceParameter", "(", "2", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "user_function", "=", "MultiSourceFunctionWrapper", "(", "\n", "[", "lambda", "x", ":", "_borehole_low", "(", "x", ",", "low_noise_std_deviation", ")", ",", "lambda", "x", ":", "_borehole_high", "(", "x", ",", "high_noise_std_deviation", ")", "]", "\n", ")", "\n", "\n", "return", "user_function", ",", "parameter_space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.borehole._borehole_high": [[50, 62], ["numpy.log", "numpy.random.randn"], "function", ["None"], ["", "def", "_borehole_high", "(", "x", ",", "sd", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    High fidelity version of borehole function\n\n    Reference:\n    https://www.sfu.ca/~ssurjano/borehole.html\n    \"\"\"", "\n", "\n", "numerator", "=", "2", "*", "np", ".", "pi", "*", "x", "[", ":", ",", "2", "]", "*", "(", "x", "[", ":", ",", "3", "]", "-", "x", "[", ":", ",", "5", "]", ")", "\n", "ln_r_rw", "=", "np", ".", "log", "(", "x", "[", ":", ",", "1", "]", "/", "x", "[", ":", ",", "0", "]", ")", "\n", "denominator", "=", "ln_r_rw", "*", "(", "x", "[", ":", ",", "2", "]", "/", "x", "[", ":", ",", "4", "]", "+", "1", "+", "(", "2", "*", "x", "[", ":", ",", "6", "]", "*", "x", "[", ":", ",", "2", "]", ")", "/", "(", "x", "[", ":", ",", "0", "]", "**", "2", "*", "x", "[", ":", ",", "7", "]", "*", "ln_r_rw", ")", ")", "\n", "return", "(", "numerator", "/", "denominator", ")", "[", ":", ",", "None", "]", "+", "np", ".", "random", ".", "randn", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", "*", "sd", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.borehole._borehole_low": [[64, 76], ["numpy.log", "numpy.random.randn"], "function", ["None"], ["", "def", "_borehole_low", "(", "x", ",", "sd", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Low fidelity version of borehole function\n\n    Reference:\n    https://www.sfu.ca/~ssurjano/borehole.html\n    \"\"\"", "\n", "\n", "numerator", "=", "5", "*", "x", "[", ":", ",", "2", "]", "*", "(", "x", "[", ":", ",", "3", "]", "-", "x", "[", ":", ",", "5", "]", ")", "\n", "ln_r_rw", "=", "np", ".", "log", "(", "x", "[", ":", ",", "1", "]", "/", "x", "[", ":", ",", "0", "]", ")", "\n", "denominator", "=", "ln_r_rw", "*", "(", "x", "[", ":", ",", "2", "]", "/", "x", "[", ":", ",", "4", "]", "+", "1.5", "+", "(", "2", "*", "x", "[", ":", ",", "6", "]", "*", "x", "[", ":", ",", "2", "]", ")", "/", "(", "x", "[", ":", ",", "0", "]", "**", "2", "*", "x", "[", ":", ",", "7", "]", "*", "ln_r_rw", ")", ")", "\n", "return", "(", "numerator", "/", "denominator", ")", "[", ":", ",", "None", "]", "+", "np", ".", "random", ".", "randn", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", "*", "sd", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.branin.multi_fidelity_branin_function": [[10, 64], ["core.ParameterSpace", "core.loop.user_function.MultiSourceFunctionWrapper", "core.ContinuousParameter", "core.ContinuousParameter", "core.InformationSourceParameter", "branin._branin", "numpy.sqrt", "branin.multi_fidelity_branin_function.branin_medium_fidelity"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin._branin"], ["def", "branin_function", "(", ")", ":", "\n", "    ", "\"\"\"\n    Two-dimensional Branin, often used as an optimization benchmark.\n\n    Based on: https://www.sfu.ca/~ssurjano/branin.html\n\n    .. math::\n        f(\\mathbf{x}) = (x_2 - b x_1 ^ 2 + c x_1 - r) ^ 2 + s(1 - t) \\cos(x_1) + s\n\n    where:\n\n    .. math::\n        b = 5.1 / (4 \\pi ^ 2)\n\n        c = 5 /\\pi\n\n        r = 6\n\n        s = 10\n\n        t = 1 / (8\\pi)\n    \"\"\"", "\n", "\n", "parameter_space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x1\"", ",", "-", "5", ",", "10", ")", ",", "ContinuousParameter", "(", "\"x2\"", ",", "0", ",", "15", ")", "]", ")", "\n", "return", "_branin", ",", "parameter_space", "\n", "\n", "\n", "", "def", "_branin", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    :param x: n_points x 2 array of input locations to evaluate\n    :return: n_points x 1 array of function evaluations\n    \"\"\"", "\n", "a", "=", "1", "\n", "b", "=", "5.1", "/", "(", "4", "*", "np", ".", "pi", "**", "2", ")", "\n", "c", "=", "5", "/", "np", ".", "pi", "\n", "r", "=", "6", "\n", "s", "=", "10", "\n", "t", "=", "1", "/", "(", "8", "*", "np", ".", "pi", ")", "\n", "x1", "=", "x", "[", ":", ",", "0", "]", "\n", "x2", "=", "x", "[", ":", ",", "1", "]", "\n", "y", "=", "a", "*", "(", "x2", "-", "b", "*", "x1", "**", "2", "+", "c", "*", "x1", "-", "r", ")", "**", "2", "+", "s", "*", "(", "1", "-", "t", ")", "*", "np", ".", "cos", "(", "x1", ")", "+", "s", "\n", "return", "y", "[", ":", ",", "None", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.park.multi_fidelity_park_function": [[9, 61], ["core.ParameterSpace", "park.multi_fidelity_park_function.park_high"], "function", ["None"], ["def", "multi_fidelity_park_function", "(", ")", "->", "Tuple", "[", "MultiSourceFunctionWrapper", ",", "ParameterSpace", "]", ":", "\n", "    ", "r\"\"\"\n\n    High fidelity is given by:\n\n    .. math::\n        f_{high}(\\mathbf{x}) = \\frac{x_1}{2}\\left[ \\sqrt{1 + \\left( x_2 + x_3^2 \\right) \\frac{x_4}{x_1^2}} - 1\\right] +\n        \\left( x_1 + 3 x_4 \\right) \\exp \\left[ 1 + \\sin x_3 \\right]\n\n    Low fidelity is given by:\n\n    .. math::\n        f_{low}(\\mathbf{x}) = \\left[ 1 + \\frac{\\sin x_1}{10} \\right] f_{high}(\\mathbf{x}) -\n        2x_1 + x_2 ^ 2 + x_3 ^2 + 0.5\n\n    The input domain is given by:\n\n    .. math::\n        \\mathbf{x}_i \\in (0, 1)\n\n    Reference: https://www.sfu.ca/~ssurjano/park91a.html\n    \"\"\"", "\n", "\n", "def", "park_high", "(", "x", ")", ":", "\n", "        ", "x1", "=", "x", "[", ":", ",", "0", "]", "\n", "x2", "=", "x", "[", ":", ",", "1", "]", "\n", "x3", "=", "x", "[", ":", ",", "2", "]", "\n", "x4", "=", "x", "[", ":", ",", "3", "]", "\n", "\n", "tmp", "=", "1", "+", "(", "x2", "+", "x3", ")", "*", "(", "x4", "/", "x1", "**", "2", ")", "\n", "return", "(", "(", "x1", "/", "2", ")", "*", "(", "np", ".", "sqrt", "(", "tmp", ")", "-", "1", ")", "+", "(", "x1", "+", "3", "*", "x4", ")", "*", "np", ".", "exp", "(", "1", "+", "np", ".", "sin", "(", "x3", ")", ")", ")", "[", ":", ",", "None", "]", "\n", "\n", "", "def", "park_low", "(", "x", ")", ":", "\n", "        ", "f_high", "=", "park_high", "(", "x", ")", "\n", "\n", "x1", "=", "x", "[", ":", ",", "0", "]", "\n", "x2", "=", "x", "[", ":", ",", "1", "]", "\n", "x3", "=", "x", "[", ":", ",", "2", "]", "\n", "\n", "return", "(", "(", "1", "+", "np", ".", "sin", "(", "x1", ")", "/", "10", ")", "*", "f_high", ".", "flatten", "(", ")", "-", "2", "*", "x1", "+", "x2", "**", "2", "+", "x3", "**", "2", "+", "0.5", ")", "[", ":", ",", "None", "]", "\n", "\n", "", "space", "=", "ParameterSpace", "(", "\n", "[", "\n", "ContinuousParameter", "(", "\"x1\"", ",", "0.0", ",", "1.0", ")", ",", "\n", "ContinuousParameter", "(", "\"x2\"", ",", "0.0", ",", "1.0", ")", ",", "\n", "ContinuousParameter", "(", "\"x3\"", ",", "0.0", ",", "1.0", ")", ",", "\n", "ContinuousParameter", "(", "\"x4\"", ",", "0.0", ",", "1.0", ")", ",", "\n", "InformationSourceParameter", "(", "2", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "return", "MultiSourceFunctionWrapper", "(", "[", "park_low", ",", "park_high", "]", ")", ",", "space", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.hartmann.multi_fidelity_hartmann_3d": [[9, 113], ["numpy.array", "numpy.array", "numpy.array", "core.ParameterSpace", "core.loop.user_function.MultiSourceFunctionWrapper", "numpy.array", "range", "range", "range", "range", "range", "range", "core.ContinuousParameter", "core.ContinuousParameter", "core.ContinuousParameter", "core.InformationSourceParameter", "numpy.exp", "numpy.exp", "numpy.exp", "numpy.power", "numpy.power", "numpy.power"], "function", ["None"], ["def", "multi_fidelity_hartmann_3d", "(", ")", "->", "Tuple", "[", "MultiSourceFunctionWrapper", ",", "ParameterSpace", "]", ":", "\n", "    ", "r\"\"\"\n    The function is given by:\n\n    .. math::\n        f(x, \\alpha) = -\\sum_{i=1}^{4} \\alpha_i \\exp \\left( -\\sum_{j=1}^{3} A_{i,j}\\left( x_j - P_{i, j} \\right)^2 \\right)\n\n    where\n\n    .. math::\n        \\mathbf{A} = \\begin{bmatrix}\n        3.0 & 10 & 30 \\\\\n        0.1 & 10 & 35 \\\\\n        3.0 & 10 & 30 \\\\\n        0.1 & 10 & 35\n        \\end{bmatrix}\n\n    .. math::\n        \\mathbf{P} = 10^{-4} \\begin{bmatrix}\n        3689 & 1170 & 2673 \\\\\n        4699 & 4387 & 7470 \\\\\n        1091 & 8732 & 5547 \\\\\n        381 & 5743 & 8828\n        \\end{bmatrix}\n\n    The high fidelity function is given by setting:\n\n    .. math::\n        \\alpha = (1.0, 1.2, 3.0, 3.2)^T\n\n    The middle fidelity is given by setting:\n\n    .. math::\n        \\alpha = (1.01, 1.19, 2.9, 3.3)^T\n\n    The low fidelity is given by setting:\n\n    .. math::\n        \\alpha = (1.02, 1.18, 2.8, 3.4)^T\n\n    The domain is given by:\n\n    .. math::\n        \\mathbf{x}_i \\in (0, 1)\n\n    Reference: https://www.sfu.ca/~ssurjano/hart3.html\n\n    :return: Tuple of MultiSourceFunctionWrapper and ParameterSpace\n    \"\"\"", "\n", "A", "=", "np", ".", "array", "(", "[", "[", "3", ",", "10", ",", "30", "]", ",", "[", "0.1", ",", "10", ",", "35", "]", ",", "[", "3", ",", "10", ",", "30", "]", ",", "[", "0.1", ",", "10", ",", "35", "]", "]", ")", "\n", "P", "=", "1e-4", "*", "np", ".", "array", "(", "[", "[", "3689", ",", "1170", ",", "2673", "]", ",", "[", "4699", ",", "4387", ",", "7470", "]", ",", "[", "1091", ",", "8732", ",", "5547", "]", ",", "[", "381", ",", "5743", ",", "8828", "]", "]", ")", "\n", "\n", "alpha", "=", "np", ".", "array", "(", "[", "1.0", ",", "1.2", ",", "3.0", ",", "3.2", "]", ")", "\n", "delta", "=", "np", ".", "array", "(", "[", "0.01", ",", "-", "0.01", ",", "-", "0.1", ",", "0.1", "]", ")", "\n", "\n", "def", "high", "(", "x", ")", ":", "\n", "\n", "        ", "res", "=", "0", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "temp", "=", "0", "\n", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "                ", "temp", "-=", "A", "[", "i", "]", "[", "j", "]", "*", "np", ".", "power", "(", "x", "[", ":", ",", "j", "]", "-", "P", "[", "i", "]", "[", "j", "]", ",", "2", ")", "\n", "", "res", "+=", "alpha", "[", "i", "]", "*", "np", ".", "exp", "(", "temp", ")", "\n", "\n", "", "return", "res", "[", ":", ",", "None", "]", "\n", "\n", "", "def", "medium", "(", "x", ")", ":", "\n", "\n", "        ", "alpha_m", "=", "alpha", "+", "delta", "\n", "\n", "res", "=", "0", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "temp", "=", "0", "\n", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "                ", "temp", "-=", "A", "[", "i", "]", "[", "j", "]", "*", "np", ".", "power", "(", "x", "[", ":", ",", "j", "]", "-", "P", "[", "i", "]", "[", "j", "]", ",", "2", ")", "\n", "", "res", "+=", "alpha_m", "[", "i", "]", "*", "np", ".", "exp", "(", "temp", ")", "\n", "\n", "", "return", "res", "[", ":", ",", "None", "]", "\n", "\n", "", "def", "low", "(", "x", ")", ":", "\n", "\n", "        ", "alpha_l", "=", "alpha", "+", "2", "*", "delta", "\n", "\n", "res", "=", "0", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "temp", "=", "0", "\n", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "                ", "temp", "-=", "A", "[", "i", "]", "[", "j", "]", "*", "np", ".", "power", "(", "x", "[", ":", ",", "j", "]", "-", "P", "[", "i", "]", "[", "j", "]", ",", "2", ")", "\n", "", "res", "+=", "alpha_l", "[", "i", "]", "*", "np", ".", "exp", "(", "temp", ")", "\n", "\n", "", "return", "res", "[", ":", ",", "None", "]", "\n", "\n", "", "space", "=", "ParameterSpace", "(", "\n", "[", "\n", "ContinuousParameter", "(", "\"x1\"", ",", "0.0", ",", "1.0", ")", ",", "\n", "ContinuousParameter", "(", "\"x2\"", ",", "0.0", ",", "1.0", ")", ",", "\n", "ContinuousParameter", "(", "\"x3\"", ",", "0.0", ",", "1.0", ")", ",", "\n", "InformationSourceParameter", "(", "3", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "fcn_wrapper", "=", "MultiSourceFunctionWrapper", "(", "[", "low", ",", "medium", ",", "high", "]", ")", "\n", "\n", "return", "fcn_wrapper", ",", "space", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.currin.multi_fidelity_currin_function": [[9, 53], ["core.ParameterSpace", "core.loop.user_function.MultiSourceFunctionWrapper", "core.ContinuousParameter", "core.ContinuousParameter", "core.InformationSourceParameter", "currin.multi_fidelity_currin_function.high"], "function", ["None"], ["def", "multi_fidelity_currin_function", "(", ")", "->", "Tuple", "[", "MultiSourceFunctionWrapper", ",", "ParameterSpace", "]", ":", "\n", "    ", "r\"\"\"\n\n    High fidelity function is given by:\n\n    .. math::\n        f_{high}(\\mathbf{x}) = \\left[ 1 - \\exp \\left(-\\frac{1}{2x_2}\\right) \\right]\n        \\frac{2300x_1^3 + 1900x_1^2 + 2092x_1 + 60}{100x_1^3+500x_1^2 + 4x_1 + 20}\n\n    Low fidelity function given by:\n\n    .. math::\n        f_{low}(\\mathbf{x}) = \\frac{1}{4} \\left[ f_{high}(x_1 + 0.05, x_2 + 0.05) + f_{high}(x_1 + 0.05, \\max (0, x_2 - 0.05)) \\\\\n        +  f_{high}(x_1 - 0.05, x_2 + 0.05) + f_{high}\\left(x_1 - 0.05, \\max \\left(0, x_2 - 0.05\\right)\\right) \\right]\n\n    Input domain:\n\n    .. math::\n        \\mathbf{x}_i \\in [0, 1]\n\n    Reference: https://www.sfu.ca/~ssurjano/curretal88exp.html\n    \"\"\"", "\n", "\n", "def", "high", "(", "x", ")", ":", "\n", "        ", "x1", "=", "x", "[", ":", ",", "0", "]", "\n", "x2", "=", "x", "[", ":", ",", "1", "]", "\n", "return", "(", "\n", "1", "\n", "-", "np", ".", "exp", "(", "-", "0.5", "/", "x2", ")", "\n", "*", "(", "(", "2300", "*", "x1", "**", "3", "+", "1900", "*", "x1", "**", "2", "+", "2092", "*", "x1", "+", "60", ")", "/", "(", "100", "*", "x1", "**", "3", "+", "500", "*", "x1", "**", "2", "+", "4", "*", "x1", "+", "20", ")", ")", "\n", ")", "[", ":", ",", "None", "]", "\n", "\n", "", "def", "low", "(", "x", ")", ":", "\n", "        ", "return", "(", "\n", "0.25", "*", "high", "(", "np", ".", "stack", "(", "[", "x", "[", ":", ",", "0", "]", "+", "0.05", ",", "x", "[", ":", ",", "1", "]", "+", "0.05", "]", ",", "axis", "=", "1", ")", ")", "\n", "+", "0.25", "*", "high", "(", "np", ".", "stack", "(", "[", "x", "[", ":", ",", "0", "]", "+", "0.05", ",", "np", ".", "maximum", "(", "0", ",", "x", "[", ":", ",", "1", "]", "-", "0.05", ")", "]", ",", "axis", "=", "1", ")", ")", "\n", "+", "0.25", "*", "high", "(", "np", ".", "stack", "(", "[", "x", "[", ":", ",", "0", "]", "-", "0.05", ",", "x", "[", ":", ",", "1", "]", "+", "0.05", "]", ",", "axis", "=", "1", ")", ")", "\n", "+", "0.25", "*", "high", "(", "np", ".", "stack", "(", "[", "x", "[", ":", ",", "0", "]", "-", "0.05", ",", "np", ".", "maximum", "(", "0", ",", "x", "[", ":", ",", "1", "]", "-", "0.05", ")", "]", ",", "axis", "=", "1", ")", ")", "\n", ")", "\n", "\n", "", "space", "=", "ParameterSpace", "(", "\n", "[", "ContinuousParameter", "(", "\"x1\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"x2\"", ",", "0", ",", "1", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", "\n", ")", "\n", "return", "MultiSourceFunctionWrapper", "(", "[", "low", ",", "high", "]", ")", ",", "space", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_x_list_to_array": [[19, 36], ["numpy.concatenate", "enumerate", "numpy.concatenate", "numpy.all", "ValueError", "indices.append", "numpy.concatenate", "numpy.ones", "len"], "function", ["None"], ["def", "convert_x_list_to_array", "(", "x_list", ":", "List", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Converts list representation of features to array representation\n    :param x_list: A list of (n_points x n_dims) numpy arrays ordered from lowest to highest fidelity\n    :return: An array of all features with the zero-based fidelity index appended as the last column\n    \"\"\"", "\n", "# First check everything is a 2d array", "\n", "if", "not", "np", ".", "all", "(", "[", "x", ".", "ndim", "==", "2", "for", "x", "in", "x_list", "]", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"All x arrays must have 2 dimensions\"", ")", "\n", "\n", "", "x_array", "=", "np", ".", "concatenate", "(", "x_list", ",", "axis", "=", "0", ")", "\n", "indices", "=", "[", "]", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "x_list", ")", ":", "\n", "        ", "indices", ".", "append", "(", "i", "*", "np", ".", "ones", "(", "(", "len", "(", "x", ")", ",", "1", ")", ")", ")", "\n", "\n", "", "x_with_index", "=", "np", ".", "concatenate", "(", "(", "x_array", ",", "np", ".", "concatenate", "(", "indices", ")", ")", ",", "axis", "=", "1", ")", "\n", "return", "x_with_index", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_y_list_to_array": [[38, 48], ["numpy.concatenate", "numpy.all", "ValueError"], "function", ["None"], ["", "def", "convert_y_list_to_array", "(", "y_list", ":", "List", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Converts list representation of outputs to array representation\n    :param y_list: A list of (n_points x n_outputs) numpy arrays representing the outputs\n                   ordered from lowest to highest fidelity\n    :return: An array of all outputs\n    \"\"\"", "\n", "if", "not", "np", ".", "all", "(", "[", "y", ".", "ndim", "==", "2", "for", "y", "in", "y_list", "]", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"All y arrays must have 2 dimensions\"", ")", "\n", "", "return", "np", ".", "concatenate", "(", "y_list", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays": [[50, 71], ["numpy.array", "numpy.array", "len", "len", "ValueError", "numpy.all", "ValueError", "convert_lists_to_array.convert_x_list_to_array", "convert_lists_to_array.convert_y_list_to_array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_x_list_to_array", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_y_list_to_array"], ["", "def", "convert_xy_lists_to_arrays", "(", "x_list", ":", "List", ",", "y_list", ":", "List", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Converts list representation of targets to array representation\n    :param x_list: A list of (n_points x n_dims) numpy arrays ordered from lowest to highest fidelity\n    :param y_list: A list of (n_points x n_outputs) numpy arrays representing the outputs\n                   ordered from lowest to highest fidelity\n    :return: Tuple of (x_array, y_array) where\n             x_array contains all inputs across all fidelities with the fidelity index appended as the last column\n             and y_array contains all outputs across all fidelities.\n    \"\"\"", "\n", "\n", "if", "len", "(", "x_list", ")", "!=", "len", "(", "y_list", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Different number of fidelities between x and y\"", ")", "\n", "\n", "# Check same number of points in each fidelity", "\n", "", "n_points_x", "=", "np", ".", "array", "(", "[", "x", ".", "shape", "[", "0", "]", "for", "x", "in", "x_list", "]", ")", "\n", "n_points_y", "=", "np", ".", "array", "(", "[", "y", ".", "shape", "[", "0", "]", "for", "y", "in", "y_list", "]", ")", "\n", "if", "not", "np", ".", "all", "(", "n_points_x", "==", "n_points_y", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Different number of points in x and y at the same fidelity\"", ")", "\n", "\n", "", "return", "convert_x_list_to_array", "(", "x_list", ")", ",", "convert_y_list_to_array", "(", "y_list", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_convert_list_to_array.test_convert_x_list_to_array": [[11, 16], ["emukit.multi_fidelity.convert_lists_to_array.convert_x_list_to_array", "numpy.array", "numpy.array_equal", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_x_list_to_array"], ["def", "test_convert_x_list_to_array", "(", ")", ":", "\n", "    ", "x_list", "=", "[", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "3", ",", "2", "]", ",", "[", "4", ",", "5", "]", "]", ")", "]", "\n", "x_array", "=", "convert_x_list_to_array", "(", "x_list", ")", "\n", "expected_output", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", ",", "[", "2", ",", "1", ",", "0", "]", ",", "[", "3", ",", "2", ",", "1", "]", ",", "[", "4", ",", "5", ",", "1", "]", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "x_array", ",", "expected_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_convert_list_to_array.test_convert_y_list_to_array": [[18, 23], ["emukit.multi_fidelity.convert_lists_to_array.convert_y_list_to_array", "numpy.array", "numpy.array_equal", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_y_list_to_array"], ["", "def", "test_convert_y_list_to_array", "(", ")", ":", "\n", "    ", "y_list", "=", "[", "np", ".", "array", "(", "[", "[", "0.0", "]", ",", "[", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "2.0", "]", ",", "[", "5.0", "]", "]", ")", "]", "\n", "y_array", "=", "convert_y_list_to_array", "(", "y_list", ")", "\n", "expected_output", "=", "np", ".", "array", "(", "[", "[", "0.0", "]", ",", "[", "1.0", "]", ",", "[", "2.0", "]", ",", "[", "5.0", "]", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "y_array", ",", "expected_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_convert_list_to_array.test_convert_xy_lists_to_arrays": [[25, 34], ["emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays", "numpy.array", "numpy.array", "numpy.array_equal", "numpy.array_equal", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays"], ["", "def", "test_convert_xy_lists_to_arrays", "(", ")", ":", "\n", "    ", "x_list", "=", "[", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "3", ",", "2", "]", ",", "[", "4", ",", "5", "]", "]", ")", "]", "\n", "y_list", "=", "[", "np", ".", "array", "(", "[", "[", "0.0", "]", ",", "[", "1.0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "2.0", "]", ",", "[", "5.0", "]", "]", ")", "]", "\n", "x_array", ",", "y_array", "=", "convert_xy_lists_to_arrays", "(", "x_list", ",", "y_list", ")", "\n", "\n", "expected_y", "=", "np", ".", "array", "(", "[", "[", "0.0", "]", ",", "[", "1.0", "]", ",", "[", "2.0", "]", ",", "[", "5.0", "]", "]", ")", "\n", "expected_x", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", ",", "[", "2", ",", "1", ",", "0", "]", ",", "[", "3", ",", "2", ",", "1", "]", ",", "[", "4", ",", "5", ",", "1", "]", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "y_array", ",", "expected_y", ")", "\n", "assert", "np", ".", "array_equal", "(", "x_array", ",", "expected_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_convert_list_to_array.test_convert_y_list_to_array_fails_with_1d_input": [[36, 40], ["numpy.array", "numpy.array", "pytest.raises", "emukit.multi_fidelity.convert_lists_to_array.convert_y_list_to_array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_y_list_to_array"], ["", "def", "test_convert_y_list_to_array_fails_with_1d_input", "(", ")", ":", "\n", "    ", "y_list", "=", "[", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", ",", "np", ".", "array", "(", "[", "2.0", ",", "5.0", "]", ")", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "convert_y_list_to_array", "(", "y_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_convert_list_to_array.test_convert_x_list_to_array_fails_with_1d_input": [[42, 46], ["numpy.array", "numpy.array", "pytest.raises", "emukit.multi_fidelity.convert_lists_to_array.convert_x_list_to_array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_x_list_to_array"], ["", "", "def", "test_convert_x_list_to_array_fails_with_1d_input", "(", ")", ":", "\n", "    ", "x_list", "=", "[", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", ",", "np", ".", "array", "(", "[", "2.0", ",", "5.0", "]", ")", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "convert_x_list_to_array", "(", "x_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_convert_list_to_array.test_convert_xy_lists_to_arrays_fails_with_different_number_of_fidelities": [[48, 53], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "pytest.raises", "emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays"], ["", "", "def", "test_convert_xy_lists_to_arrays_fails_with_different_number_of_fidelities", "(", ")", ":", "\n", "    ", "x_list", "=", "[", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "3", ",", "2", "]", ",", "[", "4", ",", "5", "]", "]", ")", "]", "\n", "y_list", "=", "[", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", ",", "np", ".", "array", "(", "[", "2.0", ",", "5.0", "]", ")", ",", "np", ".", "array", "(", "[", "3", ",", "6", "]", ")", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "convert_xy_lists_to_arrays", "(", "x_list", ",", "y_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_convert_list_to_array.test_convert_xy_lists_to_arrays_fails_with_different_number_of_points_at_fidelity": [[55, 60], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "pytest.raises", "emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays"], ["", "", "def", "test_convert_xy_lists_to_arrays_fails_with_different_number_of_points_at_fidelity", "(", ")", ":", "\n", "    ", "x_list", "=", "[", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", ",", "[", "3", ",", "4", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "3", ",", "2", "]", ",", "[", "4", ",", "5", "]", "]", ")", "]", "\n", "y_list", "=", "[", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", ",", "np", ".", "array", "(", "[", "2.0", ",", "5.0", "]", ")", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "convert_xy_lists_to_arrays", "(", "x_list", ",", "y_list", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestModels.functions": [[12, 17], ["pytest.fixture", "emukit.test_functions.forrester.forrester_low", "emukit.test_functions.forrester.forrester_low", "emukit.test_functions.forrester.forrester_low", "emukit.test_functions.forrester.forrester_low", "emukit.test_functions.forrester.forrester", "emukit.test_functions.forrester.forrester", "emukit.test_functions.forrester.forrester", "emukit.test_functions.forrester.forrester"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_low", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_low", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_low", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_low", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester", "home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester"], ["    ", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "functions", "(", "self", ")", ":", "\n", "        ", "return", "[", "\n", "lambda", "x", ":", "emukit", ".", "test_functions", ".", "forrester", ".", "forrester_low", "(", "x", ",", "0", ")", ",", "\n", "lambda", "x", ":", "emukit", ".", "test_functions", ".", "forrester", ".", "forrester", "(", "x", ",", "0", ")", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestModels.x_init": [[19, 28], ["pytest.fixture", "numpy.random.seed", "len", "numpy.zeros", "range", "numpy.random.rand"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "x_init", "(", "self", ",", "functions", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "n_fidelities", "=", "len", "(", "functions", ")", "\n", "x_init", "=", "np", ".", "zeros", "(", "(", "5", "*", "n_fidelities", ",", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "n_fidelities", ")", ":", "\n", "            ", "x_init", "[", "i", "*", "5", ":", "(", "i", "+", "1", ")", "*", "5", ",", "0", "]", "=", "np", ".", "random", ".", "rand", "(", "5", ")", "\n", "x_init", "[", "i", "*", "5", ":", "(", "i", "+", "1", ")", "*", "5", ",", "1", "]", "=", "i", "\n", "", "return", "x_init", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestModels.y_init": [[29, 37], ["pytest.fixture", "len", "numpy.zeros", "range"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "y_init", "(", "self", ",", "x_init", ",", "functions", ")", ":", "\n", "        ", "n_fidelities", "=", "len", "(", "functions", ")", "\n", "y_init", "=", "np", ".", "zeros", "(", "(", "5", "*", "n_fidelities", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "n_fidelities", ")", ":", "\n", "            ", "is_this_fidelity", "=", "x_init", "[", ":", ",", "-", "1", "]", "==", "i", "\n", "y_init", "[", "is_this_fidelity", ",", ":", "]", "=", "functions", "[", "i", "]", "(", "x_init", "[", "is_this_fidelity", ",", ":", "-", "1", "]", ")", "\n", "", "return", "y_init", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestModels.model": [[38, 50], ["len", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "numpy.random.seed", "emukit.multi_fidelity.models.GPyLinearMultiFidelityModel", "emukit.multi_fidelity.models.GPyLinearMultiFidelityModel", "emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper", "emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper", "emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.optimize", "emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.optimize", "GPy.kern.RBF", "range", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "@", "pytest", ".", "fixture", "\n", "def", "model", "(", "self", ",", "x_init", ",", "y_init", ",", "functions", ")", ":", "\n", "        ", "n_fidelities", "=", "len", "(", "functions", ")", "\n", "base_kernels", "=", "[", "GPy", ".", "kern", ".", "RBF", "(", "1", ")", "for", "_", "in", "range", "(", "len", "(", "functions", ")", ")", "]", "\n", "k", "=", "emukit", ".", "multi_fidelity", ".", "kernels", ".", "LinearMultiFidelityKernel", "(", "base_kernels", ")", "\n", "\n", "# Train model", "\n", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "gpy_model", "=", "GPyLinearMultiFidelityModel", "(", "x_init", ",", "y_init", ",", "k", ",", "n_fidelities", ")", "\n", "model", "=", "GPyMultiOutputWrapper", "(", "gpy_model", ",", "n_fidelities", ",", "n_optimization_restarts", "=", "5", ")", "\n", "model", ".", "optimize", "(", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestModels.test_linear_model": [[51, 60], ["numpy.mean", "numpy.square", "model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_linear_model", "(", "self", ",", "model", ",", "x_init", ",", "y_init", ")", ":", "\n", "        ", "\"\"\"\n        Make the linear model and optimize it\n        \"\"\"", "\n", "\n", "# Check predictions are close to true value", "\n", "mean_square_error", "=", "np", ".", "mean", "(", "np", ".", "square", "(", "model", ".", "predict", "(", "x_init", ")", "[", "0", "]", "-", "y_init", ")", ")", "\n", "\n", "assert", "mean_square_error", "<", "1e-2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestModels.test_gradients": [[61, 87], ["model.gpy_model.mixed_noise.Gaussian_noise.fix", "model.gpy_model.mixed_noise.Gaussian_noise_1.fix", "model.optimize", "numpy.random.rand", "model.get_prediction_gradients", "model.predict", "numpy.random.rand.copy", "model.predict", "numpy.abs", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_gradients", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"\n        Ensure model gradients are correct\n        \"\"\"", "\n", "model", ".", "gpy_model", ".", "mixed_noise", ".", "Gaussian_noise", ".", "fix", "(", "1e-2", ")", "\n", "model", ".", "gpy_model", ".", "mixed_noise", ".", "Gaussian_noise_1", ".", "fix", "(", "1e-2", ")", "\n", "model", ".", "optimize", "(", ")", "\n", "\n", "# Calculate analytical gradients", "\n", "x_test", "=", "np", ".", "random", ".", "rand", "(", "1", ",", "2", ")", "\n", "x_test", "[", ":", ",", "1", "]", "=", "1", "\n", "dmean_dx", ",", "dvar_dx", "=", "model", ".", "get_prediction_gradients", "(", "x_test", ")", "\n", "\n", "# Calculate numerical gradients", "\n", "eps", "=", "1e-6", "\n", "mean", ",", "var", "=", "model", ".", "predict", "(", "x_test", ")", "\n", "\n", "x_test_dx", "=", "x_test", ".", "copy", "(", ")", "\n", "x_test_dx", "[", ":", ",", "0", "]", "+=", "eps", "\n", "d_mean", ",", "d_var", "=", "model", ".", "predict", "(", "x_test_dx", ")", "\n", "numerical_mean_gradient", "=", "(", "d_mean", "-", "mean", ")", "/", "eps", "\n", "numerical_var_gradient", "=", "(", "d_var", "-", "var", ")", "/", "eps", "\n", "\n", "# Check gradients are correct", "\n", "assert", "np", ".", "abs", "(", "numerical_mean_gradient", "-", "dmean_dx", ")", "<", "1e-2", "\n", "assert", "np", ".", "abs", "(", "numerical_var_gradient", "-", "dvar_dx", ")", "<", "1e-2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestModels.test_update_data": [[88, 100], ["numpy.array", "numpy.array", "model.set_data"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["", "def", "test_update_data", "(", "self", ",", "model", ",", "functions", ")", ":", "\n", "        ", "\"\"\"\n        Check updating model correctly sets new X/Y values\n        \"\"\"", "\n", "\n", "new_x", "=", "np", ".", "array", "(", "[", "[", "0.5", ",", "0", "]", ",", "[", "0.5", ",", "1", "]", "]", ")", "\n", "new_y", "=", "np", ".", "array", "(", "[", "[", "0.5", "]", ",", "[", "0.5", "]", "]", ")", "\n", "\n", "model", ".", "set_data", "(", "new_x", ",", "new_y", ")", "\n", "\n", "assert", "model", ".", "gpy_model", ".", "X", ".", "shape", "[", "0", "]", "==", "2", "\n", "assert", "model", ".", "gpy_model", ".", "Y", ".", "shape", "[", "0", "]", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestModels.test_calculate_variance_reduction": [[101, 122], ["numpy.array", "numpy.array", "model.gpy_model.mixed_noise.Gaussian_noise.variance.fix", "model.gpy_model.mixed_noise.Gaussian_noise_1.variance.fix", "model.calculate_variance_reduction", "numpy.concatenate", "numpy.concatenate", "model.set_data", "numpy.isclose", "model.predict", "model.predict", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.calculate_variance_reduction", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_calculate_variance_reduction", "(", "self", ",", "model", ",", "functions", ")", ":", "\n", "        ", "\"\"\"\n        Compare the analytical comparison of variance reduction to the reduction we get by explicitly adding another\n        training point into the model\n        \"\"\"", "\n", "x_test_high", "=", "np", ".", "array", "(", "[", "[", "0.24", ",", "1.0", "]", "]", ")", "\n", "x_test_low", "=", "np", ".", "array", "(", "[", "[", "0.24", ",", "0.0", "]", "]", ")", "\n", "\n", "model", ".", "gpy_model", ".", "mixed_noise", ".", "Gaussian_noise", ".", "variance", ".", "fix", "(", "1e-3", ")", "\n", "model", ".", "gpy_model", ".", "mixed_noise", ".", "Gaussian_noise_1", ".", "variance", ".", "fix", "(", "1e-3", ")", "\n", "var_reduction", "=", "model", ".", "calculate_variance_reduction", "(", "x_test_low", ",", "x_test_high", ")", "\n", "\n", "X_new", "=", "np", ".", "concatenate", "(", "[", "model", ".", "gpy_model", ".", "X", ",", "x_test_low", "]", ",", "axis", "=", "0", ")", "\n", "y_new", "=", "np", ".", "concatenate", "(", "[", "model", ".", "gpy_model", ".", "Y", ",", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", "]", ",", "axis", "=", "0", ")", "\n", "\n", "old_var", "=", "model", ".", "predict", "(", "x_test_high", ")", "[", "1", "]", "\n", "model", ".", "set_data", "(", "X_new", ",", "y_new", ")", "\n", "new_var", "=", "model", ".", "predict", "(", "x_test_high", ")", "[", "1", "]", "\n", "\n", "var_diff", "=", "old_var", "-", "new_var", "\n", "assert", "np", ".", "isclose", "(", "var_reduction", ",", "var_diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestInvalidInputs.kernel": [[129, 137], ["pytest.fixture", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "GPy.kern.RBF", "range"], "methods", ["None"], ["@", "pytest", ".", "fixture", "(", ")", "\n", "def", "kernel", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Make kernel\n        \"\"\"", "\n", "n_fidelities", "=", "2", "\n", "base_kernels", "=", "[", "GPy", ".", "kern", ".", "RBF", "(", "1", ")", "for", "_", "in", "range", "(", "n_fidelities", ")", "]", "\n", "return", "emukit", ".", "multi_fidelity", ".", "kernels", ".", "LinearMultiFidelityKernel", "(", "base_kernels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestInvalidInputs.test_array_training_input": [[138, 145], ["pytest.raises", "emukit.multi_fidelity.models.GPyLinearMultiFidelityModel", "emukit.multi_fidelity.models.GPyLinearMultiFidelityModel", "numpy.random.rand", "numpy.random.rand"], "methods", ["None"], ["", "def", "test_array_training_input", "(", "self", ",", "kernel", ")", ":", "\n", "        ", "\"\"\"\n        Test failure if lists rather than arrays are passed to model\n        \"\"\"", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "GPyLinearMultiFidelityModel", "(", "[", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "]", ",", "[", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "]", ",", "kernel", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestInvalidInputs.test_inconsistent_fidelity_indices": [[146, 157], ["numpy.random.rand", "numpy.random.rand", "pytest.raises", "emukit.multi_fidelity.models.GPyLinearMultiFidelityModel", "emukit.multi_fidelity.models.GPyLinearMultiFidelityModel"], "methods", ["None"], ["", "", "def", "test_inconsistent_fidelity_indices", "(", "self", ",", "kernel", ")", ":", "\n", "        ", "\"\"\"\n        Test failure if more fidelity indices than fidelities\n        \"\"\"", "\n", "\n", "x", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "2", ")", "\n", "x", "[", ":", ",", "-", "1", "]", "=", "3", "\n", "y", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "GPyLinearMultiFidelityModel", "(", "x", ",", "y", ",", "kernel", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_models.TestInvalidInputs.test_1d_training_inputs": [[158, 168], ["numpy.random.rand", "numpy.random.rand", "pytest.raises", "emukit.multi_fidelity.models.GPyLinearMultiFidelityModel", "emukit.multi_fidelity.models.GPyLinearMultiFidelityModel"], "methods", ["None"], ["", "", "def", "test_1d_training_inputs", "(", "self", ",", "kernel", ")", ":", "\n", "        ", "\"\"\"\n        Test failure if 1d training data is given\n        \"\"\"", "\n", "\n", "x", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "2", ")", "\n", "y", "=", "np", ".", "random", ".", "rand", "(", "5", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "GPyLinearMultiFidelityModel", "(", "x", ",", "y", ",", "kernel", ",", "2", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_kernels.test_gradidents": [[11, 39], ["range", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "numpy.array", "numpy.random.rand", "numpy.random.rand", "GPy.testing.kernel_tests.check_kernel_gradient_functions", "kernels.append", "GPy.kern.RBF", "numpy.random.rand"], "function", ["None"], ["def", "test_gradidents", "(", ")", ":", "\n", "    ", "\"\"\"\n    Use GPy gradient checker to check kernel gradients are implemented\n    correctly with many fidelities\n    \"\"\"", "\n", "\n", "kernels", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "4", ")", ":", "\n", "        ", "kernels", ".", "append", "(", "GPy", ".", "kern", ".", "RBF", "(", "1", ")", ")", "\n", "", "k", "=", "emukit", ".", "multi_fidelity", ".", "kernels", ".", "LinearMultiFidelityKernel", "(", "kernels", ")", "\n", "\n", "# Ensure values of scaling parameters and kernel variances aren't 1", "\n", "k", ".", "scaling_param", ".", "value", "=", "np", ".", "array", "(", "[", "0.1", ",", "0.5", ",", "1.5", "]", ")", "\n", "for", "kern", "in", "k", ".", "kernels", ":", "\n", "        ", "kern", ".", "variance", ".", "value", "=", "np", ".", "random", ".", "rand", "(", "1", ")", "+", "0.1", "\n", "\n", "", "inputs", "=", "np", ".", "random", ".", "rand", "(", "20", ",", "2", ")", "\n", "inputs", "[", ":", "5", ",", "1", "]", "=", "0", "\n", "inputs", "[", "5", ":", "9", ",", "1", "]", "=", "1", "\n", "inputs", "[", "9", ":", "15", ",", "1", "]", "=", "2", "\n", "inputs", "[", "15", ":", "]", "=", "3", "\n", "\n", "inputs_2", "=", "np", ".", "random", ".", "rand", "(", "20", ",", "2", ")", "\n", "inputs_2", "[", ":", "6", ",", "1", "]", "=", "0", "\n", "inputs_2", "[", "6", ":", "10", ",", "1", "]", "=", "1", "\n", "inputs_2", "[", "10", ":", "17", ",", "1", "]", "=", "2", "\n", "inputs_2", "[", "17", ":", "]", "=", "3", "\n", "assert", "check_kernel_gradient_functions", "(", "k", ",", "X", "=", "inputs", ",", "X2", "=", "inputs_2", ",", "verbose", "=", "True", ",", "fixed_X_dims", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_kernels.test_k_full_and_k_diag_are_equivalent": [[41, 53], ["range", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "numpy.random.rand", "numpy.array_equiv", "kernels.append", "numpy.diag", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel.Kdiag", "GPy.kern.RBF", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel.K"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasKernel.Kdiag", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "test_k_full_and_k_diag_are_equivalent", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test that kern.K and kern.Kdiag return equivalent results\n    \"\"\"", "\n", "kernels", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "2", ")", ":", "\n", "        ", "kernels", ".", "append", "(", "GPy", ".", "kern", ".", "RBF", "(", "1", ")", ")", "\n", "", "k", "=", "emukit", ".", "multi_fidelity", ".", "kernels", ".", "LinearMultiFidelityKernel", "(", "kernels", ")", "\n", "inputs", "=", "np", ".", "random", ".", "rand", "(", "20", ",", "2", ")", "\n", "inputs", "[", ":", "10", ",", "1", "]", "=", "1", "\n", "inputs", "[", "10", ":", ",", "1", "]", "=", "0", "\n", "assert", "np", ".", "array_equiv", "(", "np", ".", "diag", "(", "k", ".", "K", "(", "inputs", ")", ")", ",", "k", ".", "Kdiag", "(", "inputs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_kernels.test_k_x2": [[55, 67], ["range", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "numpy.array", "numpy.array", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel.K", "numpy.all", "kernels.append", "numpy.isclose", "GPy.kern.RBF", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "test_k_x2", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test kernel gives expected results when X != X2\n    \"\"\"", "\n", "kernels", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "2", ")", ":", "\n", "        ", "kernels", ".", "append", "(", "GPy", ".", "kern", ".", "RBF", "(", "1", ")", ")", "\n", "", "k", "=", "emukit", ".", "multi_fidelity", ".", "kernels", ".", "LinearMultiFidelityKernel", "(", "kernels", ")", "\n", "X", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "X2", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", "]", ")", "\n", "cov", "=", "k", ".", "K", "(", "X", ",", "X2", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "cov", ",", "np", ".", "array", "(", "[", "[", "2", "]", ",", "[", "1", "]", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_kernels.test_k": [[69, 83], ["range", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel", "numpy.array", "numpy.array", "emukit.multi_fidelity.kernels.LinearMultiFidelityKernel.K", "numpy.array", "numpy.all", "kernels.append", "numpy.isclose", "GPy.kern.RBF"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "test_k", "(", ")", ":", "\n", "    ", "\"\"\"\n    Tests we get expected answer with 3 fidelities\n    \"\"\"", "\n", "kernels", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "3", ")", ":", "\n", "        ", "kernels", ".", "append", "(", "GPy", ".", "kern", ".", "RBF", "(", "1", ")", ")", "\n", "", "k", "=", "emukit", ".", "multi_fidelity", ".", "kernels", ".", "LinearMultiFidelityKernel", "(", "kernels", ")", "\n", "\n", "k", ".", "scaling_param", "=", "np", ".", "array", "(", "[", "0.5", ",", "0.4", "]", ")", "\n", "X", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "2", "]", "]", ")", "\n", "cov", "=", "k", ".", "K", "(", "X", ")", "\n", "expected_result", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0.5", ",", "0.2", "]", ",", "[", "0.5", ",", "1.25", ",", "0.5", "]", ",", "[", "0.2", ",", "0.5", ",", "1.2", "]", "]", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "cov", ",", "expected_result", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.x_init": [[11, 18], ["pytest.fixture", "numpy.zeros", "range", "numpy.random.randn"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "x_init", "(", "self", ")", ":", "\n", "        ", "x_init", "=", "np", ".", "zeros", "(", "(", "15", ",", "3", ")", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "x_init", "[", "i", "*", "5", ":", "(", "i", "+", "1", ")", "*", "5", ",", ":", "2", "]", "=", "np", ".", "random", ".", "randn", "(", "5", ",", "2", ")", "\n", "x_init", "[", "i", "*", "5", ":", "(", "i", "+", "1", ")", "*", "5", ",", "2", "]", "=", "i", "\n", "", "return", "x_init", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.y_init": [[19, 25], ["pytest.fixture", "numpy.zeros", "range", "numpy.random.randn"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "y_init", "(", "self", ")", ":", "\n", "        ", "y_init", "=", "np", ".", "zeros", "(", "(", "15", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "y_init", "[", "i", "*", "5", ":", "(", "i", "+", "1", ")", "*", "5", ",", ":", "]", "=", "np", ".", "random", ".", "randn", "(", "5", ",", "1", ")", "\n", "", "return", "y_init", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.non_linear_model": [[26, 36], ["pytest.fixture", "numpy.random.seed", "emukit.multi_fidelity.models.non_linear_multi_fidelity_model.make_non_linear_kernels", "emukit.multi_fidelity.models.NonLinearMultiFidelityModel", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.make_non_linear_kernels"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "non_linear_model", "(", "self", ",", "x_init", ",", "y_init", ")", ":", "\n", "        ", "\"\"\"\n        Creates a NonLinearModel instance to use in tests\n        \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "base_kernel", "=", "GPy", ".", "kern", ".", "RBF", "\n", "kernel", "=", "make_non_linear_kernels", "(", "base_kernel", ",", "len", "(", "x_init", ")", ",", "x_init", ".", "shape", "[", "1", "]", "-", "1", ")", "\n", "model", "=", "emukit", ".", "multi_fidelity", ".", "models", ".", "NonLinearMultiFidelityModel", "(", "x_init", ",", "y_init", ",", "3", ",", "kernel", ",", "n_samples", "=", "3", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_invalid_kernel": [[37, 44], ["GPy.kern.RBF", "pytest.raises", "emukit.multi_fidelity.models.NonLinearMultiFidelityModel"], "methods", ["None"], ["", "def", "test_invalid_kernel", "(", "self", ",", "x_init", ",", "y_init", ")", ":", "\n", "        ", "\"\"\"\n        Check sensible error is thrown if we pass in a kernel instance rather than class definition\n        \"\"\"", "\n", "base_kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "1", ")", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "            ", "emukit", ".", "multi_fidelity", ".", "models", ".", "NonLinearMultiFidelityModel", "(", "x_init", ",", "y_init", ",", "base_kernel", ",", "n_samples", "=", "70", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_invalid_input": [[45, 56], ["numpy.random.rand", "numpy.random.rand", "pytest.raises", "emukit.multi_fidelity.models.NonLinearMultiFidelityModel", "pytest.raises", "emukit.multi_fidelity.models.NonLinearMultiFidelityModel"], "methods", ["None"], ["", "", "def", "test_invalid_input", "(", "self", ",", "x_init", ",", "y_init", ")", ":", "\n", "        ", "\"\"\"\n        Test for sensible error message if we pass arrays rather than lists to constructor\n        \"\"\"", "\n", "base_kernel", "=", "GPy", ".", "kern", ".", "RBF", "\n", "X_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "3", ")", "\n", "Y_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "3", ")", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "            ", "emukit", ".", "multi_fidelity", ".", "models", ".", "NonLinearMultiFidelityModel", "(", "[", "X_init", "]", ",", "[", "Y_init", "]", ",", "base_kernel", ",", "n_samples", "=", "70", ")", "\n", "", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "            ", "emukit", ".", "multi_fidelity", ".", "models", ".", "NonLinearMultiFidelityModel", "(", "[", "X_init", "]", ",", "Y_init", ",", "base_kernel", ",", "n_samples", "=", "70", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_get_fmin": [[57, 63], ["non_linear_model.get_f_minimum", "non_linear_model.models[].Y.min"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.get_f_minimum"], ["", "", "def", "test_get_fmin", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "\"\"\"\n        Tests get_fmin returns the correct value\n        \"\"\"", "\n", "min_value", "=", "non_linear_model", ".", "get_f_minimum", "(", ")", "\n", "assert", "min_value", "==", "non_linear_model", ".", "models", "[", "-", "1", "]", ".", "Y", ".", "min", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_optimize": [[64, 69], ["non_linear_model.optimize"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "test_optimize", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "\"\"\"\n        Tests the optimization doesn't fail\n        \"\"\"", "\n", "non_linear_model", ".", "optimize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_update": [[70, 93], ["numpy.zeros", "range", "numpy.zeros", "range", "non_linear_model.set_data", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["", "def", "test_update", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "\"\"\"\n        Tests updating the model works\n        \"\"\"", "\n", "\n", "x", "=", "np", ".", "zeros", "(", "(", "15", ",", "3", ")", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "x", "[", "i", "*", "5", ":", "(", "i", "+", "1", ")", "*", "5", ",", ":", "2", "]", "=", "np", ".", "random", ".", "randn", "(", "5", ",", "2", ")", "\n", "x", "[", "i", "*", "5", ":", "(", "i", "+", "1", ")", "*", "5", ",", "2", "]", "=", "i", "\n", "\n", "", "y", "=", "np", ".", "zeros", "(", "(", "15", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "y", "[", "i", "*", "5", ":", "(", "i", "+", "1", ")", "*", "5", ",", ":", "]", "=", "np", ".", "random", ".", "randn", "(", "5", ",", "1", ")", "\n", "\n", "", "non_linear_model", ".", "set_data", "(", "x", ",", "y", ")", "\n", "\n", "assert", "non_linear_model", ".", "models", "[", "0", "]", ".", "X", ".", "shape", "==", "(", "5", ",", "2", ")", "\n", "assert", "non_linear_model", ".", "models", "[", "1", "]", ".", "X", ".", "shape", "==", "(", "5", ",", "3", ")", "\n", "assert", "non_linear_model", ".", "models", "[", "2", "]", ".", "X", ".", "shape", "==", "(", "5", ",", "3", ")", "\n", "\n", "assert", "non_linear_model", ".", "models", "[", "0", "]", ".", "Y", ".", "shape", "==", "(", "5", ",", "1", ")", "\n", "assert", "non_linear_model", ".", "models", "[", "1", "]", ".", "Y", ".", "shape", "==", "(", "5", ",", "1", ")", "\n", "assert", "non_linear_model", ".", "models", "[", "2", "]", ".", "Y", ".", "shape", "==", "(", "5", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_X": [[94, 98], ["isinstance"], "methods", ["None"], ["", "def", "test_X", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "assert", "isinstance", "(", "non_linear_model", ".", "X", ",", "np", ".", "ndarray", ")", "\n", "assert", "non_linear_model", ".", "X", ".", "ndim", "==", "2", "\n", "assert", "non_linear_model", ".", "X", ".", "shape", "==", "(", "15", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_Y": [[99, 103], ["isinstance"], "methods", ["None"], ["", "def", "test_Y", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "assert", "isinstance", "(", "non_linear_model", ".", "Y", ",", "np", ".", "ndarray", ")", "\n", "assert", "non_linear_model", ".", "Y", ".", "ndim", "==", "2", "\n", "assert", "non_linear_model", ".", "Y", ".", "shape", "==", "(", "15", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_non_linear_model_with_3_fidelities": [[104, 114], ["numpy.random.rand", "non_linear_model.get_prediction_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "test_non_linear_model_with_3_fidelities", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "\"\"\"\n        Test the model prediction doesn't fail and shapes are correct\n        \"\"\"", "\n", "\n", "x_test", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ")", "\n", "x_test", "[", ":", ",", "-", "1", "]", "=", "2", "\n", "dmean_dx", ",", "dvar_dx", "=", "non_linear_model", ".", "get_prediction_gradients", "(", "x_test", ")", "\n", "assert", "dmean_dx", ".", "shape", "==", "(", "2", ",", "2", ")", "\n", "assert", "dvar_dx", ".", "shape", "==", "(", "2", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_non_linear_model_prediction": [[115, 124], ["numpy.random.rand", "non_linear_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_non_linear_model_prediction", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "\"\"\"\n        Test the model prediction doesn't fail and shapes are correct\n        \"\"\"", "\n", "X", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ")", "\n", "X", "[", ":", ",", "-", "1", "]", "=", "2", "\n", "mean", ",", "var", "=", "non_linear_model", ".", "predict", "(", "X", ")", "\n", "assert", "mean", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "assert", "var", ".", "shape", "==", "(", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_non_linear_model_prediction_with_grads": [[125, 135], ["numpy.random.rand", "non_linear_model.get_prediction_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "test_non_linear_model_prediction_with_grads", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "\"\"\"\n        Test the model prediction doesn't fail and shapes are correct\n        \"\"\"", "\n", "\n", "x_test", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ")", "\n", "x_test", "[", ":", ",", "-", "1", "]", "=", "2", "\n", "dmean_dx", ",", "dvar_dx", "=", "non_linear_model", ".", "get_prediction_gradients", "(", "x_test", ")", "\n", "assert", "dmean_dx", ".", "shape", "==", "(", "2", ",", "2", ")", "\n", "assert", "dvar_dx", ".", "shape", "==", "(", "2", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_non_linear_sample_fidelities_gradient": [[136, 158], ["pytest.mark.parametrize", "numpy.random.seed", "numpy.random.rand", "numpy.sum", "numpy.sum", "scipy.optimize.check_grad", "pytest.param", "pytest.param", "pytest.param", "pytest.param", "pytest.param", "pytest.param", "non_linear_model._predict_samples_with_gradients", "non_linear_model._predict_samples_with_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_samples_with_gradients", "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_samples_with_gradients"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"fidelity_idx,func_idx,grad_idx\"", ",", "\n", "[", "\n", "pytest", ".", "param", "(", "2", ",", "0", ",", "1", ",", "id", "=", "\"mean_gradient_highest_fidelity\"", ")", ",", "\n", "pytest", ".", "param", "(", "2", ",", "2", ",", "3", ",", "id", "=", "\"var_gradient_highest_fidelity\"", ")", ",", "\n", "pytest", ".", "param", "(", "1", ",", "0", ",", "1", ",", "id", "=", "\"mean_gradient_middle_fidelity\"", ")", ",", "\n", "pytest", ".", "param", "(", "1", ",", "2", ",", "3", ",", "id", "=", "\"var_gradient_middle_fidelity\"", ")", ",", "\n", "pytest", ".", "param", "(", "0", ",", "0", ",", "1", ",", "id", "=", "\"mean_gradient_lowest_fidelity\"", ")", ",", "\n", "pytest", ".", "param", "(", "0", ",", "2", ",", "3", ",", "id", "=", "\"var_gradient_lowest_fidelity\"", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_non_linear_sample_fidelities_gradient", "(", "self", ",", "non_linear_model", ",", "fidelity_idx", ",", "func_idx", ",", "grad_idx", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "1234", ")", "\n", "x0", "=", "np", ".", "random", ".", "rand", "(", "2", ")", "\n", "\n", "func", "=", "lambda", "x", ":", "np", ".", "sum", "(", "\n", "non_linear_model", ".", "_predict_samples_with_gradients", "(", "x", "[", "None", ",", ":", "]", ",", "fidelity_idx", ")", "[", "func_idx", "]", ",", "axis", "=", "0", "\n", ")", "\n", "grad", "=", "lambda", "x", ":", "np", ".", "sum", "(", "\n", "non_linear_model", ".", "_predict_samples_with_gradients", "(", "x", "[", "None", ",", ":", "]", ",", "fidelity_idx", ")", "[", "grad_idx", "]", ",", "axis", "=", "0", "\n", ")", "\n", "assert", "check_grad", "(", "func", ",", "grad", ",", "x0", ")", "<", "1e-6", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_non_linear_model_mean_gradient": [[159, 178], ["numpy.random.seed", "numpy.random.rand", "numpy.all", "numpy.concatenate", "non_linear_model.predict", "numpy.concatenate", "non_linear_model.get_prediction_gradients", "scipy.optimize.check_grad"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad"], ["", "def", "test_non_linear_model_mean_gradient", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "\"\"\"\n        Check the gradient of the mean prediction is correct\n        \"\"\"", "\n", "\n", "np", ".", "random", ".", "seed", "(", "1234", ")", "\n", "x0", "=", "np", ".", "random", ".", "rand", "(", "2", ")", "\n", "\n", "# wrap function so fidelity index doesn't change", "\n", "def", "wrap_func", "(", "x", ")", ":", "\n", "            ", "x_full", "=", "np", ".", "concatenate", "(", "[", "x", "[", "None", ",", ":", "]", ",", "[", "[", "2", "]", "]", "]", ",", "axis", "=", "1", ")", "\n", "mean", ",", "variance", "=", "non_linear_model", ".", "predict", "(", "x_full", ")", "\n", "return", "mean", "[", "0", "]", "\n", "\n", "", "def", "wrap_gradients", "(", "x", ")", ":", "\n", "            ", "x_full", "=", "np", ".", "concatenate", "(", "[", "x", "[", "None", ",", ":", "]", ",", "[", "[", "2", "]", "]", "]", ",", "axis", "=", "1", ")", "\n", "return", "non_linear_model", ".", "get_prediction_gradients", "(", "x_full", ")", "[", "0", "]", "\n", "\n", "", "assert", "np", ".", "all", "(", "check_grad", "(", "wrap_func", ",", "wrap_gradients", ",", "x0", ")", "<", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.TestNonLinearModel.test_non_linear_model_variance_gradient": [[179, 198], ["numpy.random.seed", "numpy.random.rand", "numpy.all", "numpy.concatenate", "non_linear_model.predict", "numpy.concatenate", "non_linear_model.get_prediction_gradients", "scipy.optimize.check_grad"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad"], ["", "def", "test_non_linear_model_variance_gradient", "(", "self", ",", "non_linear_model", ")", ":", "\n", "        ", "\"\"\"\n        Check the gradient of the predictive variance is correct\n        \"\"\"", "\n", "\n", "np", ".", "random", ".", "seed", "(", "1234", ")", "\n", "x0", "=", "np", ".", "random", ".", "rand", "(", "2", ")", "\n", "\n", "# wrap function so fidelity index doesn't change", "\n", "def", "wrap_func", "(", "x", ")", ":", "\n", "            ", "x_full", "=", "np", ".", "concatenate", "(", "[", "x", "[", "None", ",", ":", "]", ",", "[", "[", "2", "]", "]", "]", ",", "axis", "=", "1", ")", "\n", "mean", ",", "variance", "=", "non_linear_model", ".", "predict", "(", "x_full", ")", "\n", "return", "variance", "[", "0", "]", "\n", "\n", "", "def", "wrap_gradients", "(", "x", ")", ":", "\n", "            ", "x_full", "=", "np", ".", "concatenate", "(", "[", "x", "[", "None", ",", ":", "]", ",", "[", "[", "2", "]", "]", "]", ",", "axis", "=", "1", ")", "\n", "return", "non_linear_model", ".", "get_prediction_gradients", "(", "x_full", ")", "[", "1", "]", "\n", "\n", "", "assert", "np", ".", "all", "(", "check_grad", "(", "wrap_func", ",", "wrap_gradients", ",", "x0", ")", "<", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.test_non_linear_models.test_non_linear_kernel_ard": [[200, 208], ["emukit.multi_fidelity.models.non_linear_multi_fidelity_model.make_non_linear_kernels", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.make_non_linear_kernels"], ["", "", "def", "test_non_linear_kernel_ard", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test that the kernels that act on the input space have the correct number of lengthscales when ARD is true\n    \"\"\"", "\n", "kernels", "=", "make_non_linear_kernels", "(", "GPy", ".", "kern", ".", "RBF", ",", "2", ",", "2", ",", "ARD", "=", "True", ")", "\n", "assert", "len", "(", "kernels", "[", "0", "]", ".", "lengthscale", ")", "==", "2", "\n", "assert", "len", "(", "kernels", "[", "1", "]", ".", "bias_kernel_fidelity2", ".", "lengthscale", ")", "==", "2", "\n", "assert", "len", "(", "kernels", "[", "1", "]", ".", "mul", ".", "scale_kernel_fidelity2", ".", "lengthscale", ")", "==", "2", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.local_penalization_calculator.LocalPenalizationPointCalculator.__init__": [[26, 58], ["isinstance", "ValueError", "str"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "acquisition", ":", "Acquisition", ",", "\n", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", ",", "\n", "model", ":", "IDifferentiable", ",", "\n", "parameter_space", ":", "ParameterSpace", ",", "\n", "batch_size", ":", "int", ",", "\n", "fixed_lipschitz_constant", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "fixed_minimum", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param acquisition: Base acquisition function to use without any penalization applied, this acquisition should\n                            output positive values only.\n        :param acquisition_optimizer: AcquisitionOptimizer object to optimize the penalized acquisition\n        :param model: Model object, used to compute the parameters of the local penalization\n        :param parameter_space: Parameter space describing input domain\n        :param batch_size: Number of points to collect in each batch\n        :param fixed_lipschitz_constant: User-specified Lipschitz constant, which controls influence of local penalization\n        :param fixed_minimum: User-specified minimum output, which specifies origin of penalization cones\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "model", ",", "IDifferentiable", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Model must implement \"", "+", "str", "(", "IDifferentiable", ")", "+", "\" for use with Local Penalization batch method.\"", "\n", ")", "\n", "\n", "", "self", ".", "acquisition", "=", "acquisition", "\n", "self", ".", "acquisition_optimizer", "=", "acquisition_optimizer", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "parameter_space", "=", "parameter_space", "\n", "self", ".", "fixed_lipschitz_constant", "=", "fixed_lipschitz_constant", "\n", "self", ".", "fixed_minimum", "=", "fixed_minimum", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.local_penalization_calculator.LocalPenalizationPointCalculator.compute_next_points": [[59, 99], ["local_penalization_calculator.LocalPenalizationPointCalculator.acquisition.update_parameters", "isinstance", "range", "numpy.concatenate", "core.acquisition.IntegratedHyperParameterAcquisition", "bayesian_optimization.acquisitions.local_penalization.LocalPenalization", "local_penalization_calculator.LocalPenalizationPointCalculator.acquisition_optimizer.optimize", "x_batch.append", "y_batch.append", "bayesian_optimization.acquisitions.local_penalization.LocalPenalization.update_batches", "numpy.min", "local_penalization_calculator._estimate_lipschitz_constant", "numpy.concatenate", "numpy.append", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.local_penalization_calculator._estimate_lipschitz_constant"], ["", "def", "compute_next_points", "(", "self", ",", "loop_state", ":", "LoopState", ",", "context", ":", "dict", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes a batch of points using local penalization.\n\n        :param loop_state: Object containing the current state of the loop\n        :param context: Contains variables to fix through optimization of acquisition function. The dictionary key is\n                        the parameter name and the value is the value to fix the parameter to.\n        \"\"\"", "\n", "self", ".", "acquisition", ".", "update_parameters", "(", ")", "\n", "\n", "# Initialize local penalization acquisition", "\n", "if", "isinstance", "(", "self", ".", "model", ",", "IPriorHyperparameters", ")", ":", "\n", "            ", "local_penalization_acquisition", "=", "IntegratedHyperParameterAcquisition", "(", "self", ".", "model", ",", "LocalPenalization", ")", "\n", "", "else", ":", "\n", "            ", "local_penalization_acquisition", "=", "LocalPenalization", "(", "self", ".", "model", ")", "\n", "\n", "# Everything done in log space so addition here is same as multiplying acquisition with local penalization", "\n", "# function.", "\n", "", "acquisition", "=", "self", ".", "acquisition", "+", "local_penalization_acquisition", "\n", "\n", "x_batch", "=", "[", "]", "\n", "y_batch", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "# Collect point", "\n", "            ", "x_next", ",", "y_next", "=", "self", ".", "acquisition_optimizer", ".", "optimize", "(", "acquisition", ",", "context", ")", "\n", "x_batch", ".", "append", "(", "x_next", ")", "\n", "y_batch", ".", "append", "(", "y_next", ")", "\n", "\n", "# Update local penalization acquisition with x_next", "\n", "if", "self", ".", "fixed_minimum", "is", "None", ":", "\n", "                ", "f_min", "=", "np", ".", "min", "(", "np", ".", "append", "(", "self", ".", "model", ".", "Y", ",", "np", ".", "array", "(", "y_batch", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "f_min", "=", "self", ".", "fixed_minimum", "\n", "\n", "", "if", "self", ".", "fixed_lipschitz_constant", "is", "None", ":", "\n", "                ", "lipschitz_constant", "=", "_estimate_lipschitz_constant", "(", "self", ".", "parameter_space", ",", "self", ".", "model", ")", "\n", "", "else", ":", "\n", "                ", "lipschitz_constant", "=", "self", ".", "fixed_lipschitz_constant", "\n", "", "local_penalization_acquisition", ".", "update_batches", "(", "np", ".", "concatenate", "(", "x_batch", ",", "axis", "=", "0", ")", ",", "lipschitz_constant", ",", "f_min", ")", "\n", "", "return", "np", ".", "concatenate", "(", "x_batch", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.local_penalization_calculator._estimate_lipschitz_constant": [[101, 135], ["space.sample_uniform", "numpy.vstack", "local_penalization_calculator._estimate_lipschitz_constant.negative_gradient_norm"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform"], ["", "", "def", "_estimate_lipschitz_constant", "(", "space", ":", "ParameterSpace", ",", "model", ":", "IDifferentiable", ")", ":", "\n", "    ", "\"\"\"\n    Estimate the lipschitz constant of the function by max norm of gradient currently in the model. Find this max\n    gradient norm using an optimizer.\n    \"\"\"", "\n", "\n", "def", "negative_gradient_norm", "(", "x", ")", ":", "\n", "        ", "d_mean_d_x", ",", "_", "=", "model", ".", "get_prediction_gradients", "(", "x", ")", "\n", "result", "=", "np", ".", "sqrt", "(", "(", "np", ".", "square", "(", "d_mean_d_x", ")", ")", ".", "sum", "(", "1", ")", ")", "# simply take the norm of the expectation of the gradient", "\n", "return", "-", "result", "\n", "\n", "# Evaluate at some random samples first and start optimizer from point with highest gradient", "\n", "", "samples", "=", "space", ".", "sample_uniform", "(", "N_SAMPLES", ")", "\n", "samples", "=", "np", ".", "vstack", "(", "[", "samples", ",", "model", ".", "X", "]", ")", "\n", "gradient_norm_at_samples", "=", "negative_gradient_norm", "(", "samples", ")", "\n", "x0", "=", "samples", "[", "np", ".", "argmin", "(", "gradient_norm_at_samples", ")", "]", "[", "None", ",", ":", "]", "\n", "\n", "# Run optimizer to find point of highest gradient", "\n", "res", "=", "scipy", ".", "optimize", ".", "minimize", "(", "\n", "lambda", "x", ":", "negative_gradient_norm", "(", "x", "[", "None", ",", ":", "]", ")", ",", "x0", ",", "bounds", "=", "space", ".", "get_bounds", "(", ")", ",", "options", "=", "{", "\"maxiter\"", ":", "MAX_ITER", "}", "\n", ")", "\n", "# in Scipy 1.7.3 and below `run.fun` is a single-valued numpy array", "\n", "# in Scipy 1.8.0 this changed to a float number", "\n", "# Very annoying! See https://github.com/EmuKit/emukit/issues/402", "\n", "# so here we use `np.atleast_1d` to make them the same", "\n", "function_value", "=", "np", ".", "atleast_1d", "(", "res", ".", "fun", ")", "\n", "lipschitz_constant", "=", "-", "function_value", "[", "0", "]", "\n", "\n", "min_lipschitz_constant", "=", "1e-7", "\n", "fallback_lipschitz_constant", "=", "10", "# Value to use if calculated value is below minimum allowed", "\n", "if", "lipschitz_constant", "<", "min_lipschitz_constant", ":", "\n", "# To avoid problems in cases in which the model is flat.", "\n", "        ", "lipschitz_constant", "=", "fallback_lipschitz_constant", "\n", "", "return", "lipschitz_constant", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.joint_min": [[14, 73], ["numpy.zeros", "range", "numpy.sum", "numpy.max", "numpy.einsum", "numpy.reshape", "numpy.zeros", "numpy.zeros", "numpy.zeros", "epmgp.min_factor", "next", "numpy.exp", "numpy.log", "numpy.isinf", "sum", "sum", "numpy.einsum", "next", "numpy.isinf", "numpy.sum", "numpy.rot90", "numpy.rot90", "numpy.exp", "int", "next", "next", "numpy.exp", "numpy.exp", "numpy.rot90", "numpy.exp", "numpy.rot90"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.min_factor"], ["def", "joint_min", "(", "mu", ":", "np", ".", "ndarray", ",", "var", ":", "np", ".", "ndarray", ",", "with_derivatives", ":", "bool", "=", "False", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Computes the probability of every given point to be the minimum\n    based on the EPMGP[1] algorithm.\n    [1] J. Cunningham, P. Hennig, and S. Lacoste-Julien.\n    Gaussian probabilities and expectation propagation.\n    under review. Preprint at arXiv, November 2011.\n\n    :param mu: Mean value of each of the N points, dims (N,).\n    :param var: Covariance matrix for all points, dims (N, N).\n    :param with_derivatives: If True than also the gradients are computed.\n    :returns: pmin distribution, dims (N,1).\n    \"\"\"", "\n", "\n", "logP", "=", "np", ".", "zeros", "(", "mu", ".", "shape", ")", "\n", "D", "=", "mu", ".", "shape", "[", "0", "]", "\n", "if", "with_derivatives", ":", "\n", "        ", "dlogPdMu", "=", "np", ".", "zeros", "(", "(", "D", ",", "D", ")", ")", "\n", "dlogPdSigma", "=", "np", ".", "zeros", "(", "(", "D", ",", "int", "(", "0.5", "*", "D", "*", "(", "D", "+", "1", ")", ")", ")", ")", "\n", "dlogPdMudMu", "=", "np", ".", "zeros", "(", "(", "D", ",", "D", ",", "D", ")", ")", "\n", "", "for", "i", "in", "range", "(", "mu", ".", "shape", "[", "0", "]", ")", ":", "\n", "\n", "# logP[k] ) self._min_factor(mu, var, 0)", "\n", "        ", "a", "=", "min_factor", "(", "mu", ",", "var", ",", "i", ")", "\n", "\n", "logP", "[", "i", "]", "=", "next", "(", "a", ")", "\n", "if", "with_derivatives", ":", "\n", "            ", "dlogPdMu", "[", "i", ",", ":", "]", "=", "next", "(", "a", ")", ".", "T", "\n", "dlogPdMudMu", "[", "i", ",", ":", ",", ":", "]", "=", "next", "(", "a", ")", "\n", "dlogPdSigma", "[", "i", ",", ":", "]", "=", "next", "(", "a", ")", ".", "T", "\n", "\n", "", "", "logP", "[", "np", ".", "isinf", "(", "logP", ")", "]", "=", "-", "500", "\n", "# re-normalize at the end, to smooth out numerical imbalances:", "\n", "logPold", "=", "logP", "\n", "Z", "=", "np", ".", "sum", "(", "np", ".", "exp", "(", "logPold", ")", ")", "\n", "maxLogP", "=", "np", ".", "max", "(", "logP", ")", "\n", "s", "=", "maxLogP", "+", "np", ".", "log", "(", "np", ".", "sum", "(", "np", ".", "exp", "(", "logP", "-", "maxLogP", ")", ")", ")", "\n", "s", "=", "maxLogP", "if", "np", ".", "isinf", "(", "s", ")", "else", "s", "\n", "\n", "logP", "=", "logP", "-", "s", "\n", "if", "not", "with_derivatives", ":", "\n", "        ", "return", "logP", "\n", "\n", "", "dlogPdMuold", "=", "dlogPdMu", "\n", "dlogPdSigmaold", "=", "dlogPdSigma", "\n", "dlogPdMudMuold", "=", "dlogPdMudMu", "\n", "# adjust derivatives, too. This is a bit tedious.", "\n", "Zm", "=", "sum", "(", "np", ".", "rot90", "(", "(", "np", ".", "exp", "(", "logPold", ")", "*", "np", ".", "rot90", "(", "dlogPdMuold", ",", "1", ")", ")", ",", "3", ")", ")", "/", "Z", "\n", "Zs", "=", "sum", "(", "np", ".", "rot90", "(", "(", "np", ".", "exp", "(", "logPold", ")", "*", "np", ".", "rot90", "(", "dlogPdSigmaold", ",", "1", ")", ")", ",", "3", ")", ")", "/", "Z", "\n", "\n", "dlogPdMu", "=", "dlogPdMuold", "-", "Zm", "\n", "dlogPdSigma", "=", "dlogPdSigmaold", "-", "Zs", "\n", "\n", "ff", "=", "np", ".", "einsum", "(", "\"ki,kj->kij\"", ",", "dlogPdMuold", ",", "dlogPdMuold", ")", "\n", "gg", "=", "np", ".", "einsum", "(", "\"kij,k->ij\"", ",", "dlogPdMudMuold", "+", "ff", ",", "np", ".", "exp", "(", "logPold", ")", ")", "/", "Z", "\n", "Zij", "=", "Zm", ".", "T", "*", "Zm", "\n", "adds", "=", "np", ".", "reshape", "(", "-", "gg", "+", "Zij", ",", "(", "1", ",", "D", ",", "D", ")", ")", "\n", "dlogPdMudMu", "=", "dlogPdMudMuold", "+", "adds", "\n", "return", "logP", ",", "dlogPdMu", ",", "dlogPdSigma", ",", "dlogPdMudMu", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.min_factor": [[75, 159], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.copy", "numpy.copy", "range", "numpy.isnan", "range", "numpy.isnan", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.delete", "numpy.sum", "numpy.where", "sum", "sum", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.zeros_like", "numpy.fill_diagonal", "numpy.isnan", "numpy.abs", "numpy.abs", "numpy.eye", "numpy.sqrt", "numpy.eye", "numpy.dot", "numpy.dot", "numpy.linalg.solve", "numpy.dot", "numpy.linalg.cholesky", "numpy.sum", "numpy.outer", "numpy.diagonal", "epmgp.lt_factor", "int", "numpy.dot", "numpy.log", "numpy.outer", "numpy.rot90", "numpy.linalg.cholesky", "numpy.diagonal", "numpy.dot", "numpy.triu_indices", "numpy.linalg.cholesky", "numpy.outer", "numpy.eye", "numpy.dot", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.lt_factor"], ["", "def", "min_factor", "(", "Mu", ",", "Sigma", ",", "k", ",", "gamma", "=", "1", ")", ":", "\n", "    ", "D", "=", "Mu", ".", "shape", "[", "0", "]", "\n", "logS", "=", "np", ".", "zeros", "(", "(", "D", "-", "1", ",", ")", ")", "\n", "# mean time first moment", "\n", "MP", "=", "np", ".", "zeros", "(", "(", "D", "-", "1", ",", ")", ")", "\n", "\n", "# precision, second moment", "\n", "P", "=", "np", ".", "zeros", "(", "(", "D", "-", "1", ",", ")", ")", "\n", "\n", "M", "=", "np", ".", "copy", "(", "Mu", ")", "\n", "V", "=", "np", ".", "copy", "(", "Sigma", ")", "\n", "b", "=", "False", "\n", "d", "=", "np", ".", "NaN", "\n", "for", "count", "in", "range", "(", "50", ")", ":", "\n", "        ", "diff", "=", "0", "\n", "for", "i", "in", "range", "(", "D", "-", "1", ")", ":", "\n", "            ", "l", "=", "i", "if", "i", "<", "k", "else", "i", "+", "1", "# noqa: E741 to be consistent with paper notation", "\n", "try", ":", "\n", "                ", "M", ",", "V", ",", "P", "[", "i", "]", ",", "MP", "[", "i", "]", ",", "logS", "[", "i", "]", ",", "d", "=", "lt_factor", "(", "k", ",", "l", ",", "M", ",", "V", ",", "MP", "[", "i", "]", ",", "P", "[", "i", "]", ",", "gamma", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "raise", "\n", "\n", "", "if", "np", ".", "isnan", "(", "d", ")", ":", "\n", "                ", "break", "\n", "", "diff", "+=", "np", ".", "abs", "(", "d", ")", "\n", "", "if", "np", ".", "isnan", "(", "d", ")", ":", "\n", "            ", "break", "\n", "", "if", "np", ".", "abs", "(", "diff", ")", "<", "0.001", ":", "\n", "            ", "b", "=", "True", "\n", "break", "\n", "", "", "if", "np", ".", "isnan", "(", "d", ")", ":", "\n", "        ", "logZ", "=", "-", "np", ".", "Infinity", "\n", "yield", "logZ", "\n", "dlogZdMu", "=", "np", ".", "zeros", "(", "(", "D", ",", "1", ")", ")", "\n", "yield", "dlogZdMu", "\n", "\n", "dlogZdMudMu", "=", "np", ".", "zeros", "(", "(", "D", ",", "D", ")", ")", "\n", "yield", "dlogZdMudMu", "\n", "dlogZdSigma", "=", "np", ".", "zeros", "(", "(", "int", "(", "0.5", "*", "(", "D", "*", "(", "D", "+", "1", ")", ")", ")", ",", "1", ")", ")", "\n", "yield", "dlogZdSigma", "\n", "mvmin", "=", "[", "Mu", "[", "k", "]", ",", "Sigma", "[", "k", ",", "k", "]", "]", "\n", "yield", "mvmin", "\n", "", "else", ":", "\n", "# evaluate log Z:", "\n", "        ", "C", "=", "np", ".", "eye", "(", "D", ")", "/", "sq2", "\n", "C", "[", "k", ",", ":", "]", "=", "-", "1", "/", "sq2", "\n", "C", "=", "np", ".", "delete", "(", "C", ",", "k", ",", "1", ")", "\n", "\n", "R", "=", "np", ".", "sqrt", "(", "P", ".", "T", ")", "*", "C", "\n", "r", "=", "np", ".", "sum", "(", "MP", ".", "T", "*", "C", ",", "1", ")", "\n", "mp_not_zero", "=", "np", ".", "where", "(", "MP", "!=", "0", ")", "\n", "mpm", "=", "MP", "[", "mp_not_zero", "]", "*", "MP", "[", "mp_not_zero", "]", "/", "P", "[", "mp_not_zero", "]", "\n", "mpm", "=", "sum", "(", "mpm", ")", "\n", "\n", "s", "=", "sum", "(", "logS", ")", "\n", "IRSR", "=", "np", ".", "eye", "(", "D", "-", "1", ")", "+", "np", ".", "dot", "(", "np", ".", "dot", "(", "R", ".", "T", ",", "Sigma", ")", ",", "R", ")", "\n", "rSr", "=", "np", ".", "dot", "(", "np", ".", "dot", "(", "r", ".", "T", ",", "Sigma", ")", ",", "r", ")", "\n", "A", "=", "np", ".", "dot", "(", "R", ",", "np", ".", "linalg", ".", "solve", "(", "IRSR", ",", "R", ".", "T", ")", ")", "\n", "\n", "A", "=", "0.5", "*", "(", "A", ".", "T", "+", "A", ")", "# ensure symmetry.", "\n", "b", "=", "Mu", "+", "np", ".", "dot", "(", "Sigma", ",", "r", ")", "\n", "Ab", "=", "np", ".", "dot", "(", "A", ",", "b", ")", "\n", "try", ":", "\n", "            ", "cIRSR", "=", "np", ".", "linalg", ".", "cholesky", "(", "IRSR", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "try", ":", "\n", "                ", "cIRSR", "=", "np", ".", "linalg", ".", "cholesky", "(", "IRSR", "+", "1e-10", "*", "np", ".", "eye", "(", "IRSR", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "                ", "cIRSR", "=", "np", ".", "linalg", ".", "cholesky", "(", "IRSR", "+", "1e-6", "*", "np", ".", "eye", "(", "IRSR", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "", "dts", "=", "2", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "cIRSR", ")", ")", ")", "\n", "logZ", "=", "0.5", "*", "(", "rSr", "-", "np", ".", "dot", "(", "b", ".", "T", ",", "Ab", ")", "-", "dts", ")", "+", "np", ".", "dot", "(", "Mu", ".", "T", ",", "r", ")", "+", "s", "-", "0.5", "*", "mpm", "\n", "yield", "logZ", "\n", "btA", "=", "np", ".", "dot", "(", "b", ".", "T", ",", "A", ")", "\n", "\n", "dlogZdMu", "=", "r", "-", "Ab", "\n", "yield", "dlogZdMu", "\n", "dlogZdMudMu", "=", "-", "A", "\n", "yield", "dlogZdMudMu", "\n", "dlogZdSigma", "=", "-", "A", "-", "2", "*", "np", ".", "outer", "(", "r", ",", "Ab", ".", "T", ")", "+", "np", ".", "outer", "(", "r", ",", "r", ".", "T", ")", "+", "np", ".", "outer", "(", "btA", ".", "T", ",", "Ab", ".", "T", ")", "\n", "dlogZdSigma2", "=", "np", ".", "zeros_like", "(", "dlogZdSigma", ")", "\n", "np", ".", "fill_diagonal", "(", "dlogZdSigma2", ",", "np", ".", "diagonal", "(", "dlogZdSigma", ")", ")", "\n", "dlogZdSigma", "=", "0.5", "*", "(", "dlogZdSigma", "+", "dlogZdSigma", ".", "T", "-", "dlogZdSigma2", ")", "\n", "dlogZdSigma", "=", "np", ".", "rot90", "(", "dlogZdSigma", ",", "k", "=", "2", ")", "[", "np", ".", "triu_indices", "(", "D", ")", "]", "[", ":", ":", "-", "1", "]", "\n", "yield", "dlogZdSigma", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.lt_factor": [[161, 223], ["numpy.max", "numpy.isnan", "epmgp.log_relative_gauss", "numpy.sqrt", "numpy.max", "numpy.max", "numpy.max", "numpy.any", "numpy.sqrt", "numpy.isnan", "Exception", "numpy.outer", "max", "numpy.log", "numpy.outer", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.log_relative_gauss"], ["", "", "def", "lt_factor", "(", "s", ",", "l", ",", "M", ",", "V", ",", "mp", ",", "p", ",", "gamma", ")", ":", "\n", "    ", "cVc", "=", "(", "V", "[", "l", ",", "l", "]", "-", "2", "*", "V", "[", "s", ",", "l", "]", "+", "V", "[", "s", ",", "s", "]", ")", "/", "2.0", "\n", "Vc", "=", "(", "V", "[", ":", ",", "l", "]", "-", "V", "[", ":", ",", "s", "]", ")", "/", "sq2", "\n", "cM", "=", "(", "M", "[", "l", "]", "-", "M", "[", "s", "]", ")", "/", "sq2", "\n", "cVnic", "=", "np", ".", "max", "(", "[", "cVc", "/", "(", "1", "-", "p", "*", "cVc", ")", ",", "0", "]", ")", "\n", "cmni", "=", "cM", "+", "cVnic", "*", "(", "p", "*", "cM", "-", "mp", ")", "\n", "z", "=", "cmni", "/", "np", ".", "sqrt", "(", "cVnic", "+", "1e-25", ")", "\n", "if", "np", ".", "isnan", "(", "z", ")", ":", "\n", "        ", "z", "=", "-", "np", ".", "inf", "\n", "", "e", ",", "lP", ",", "exit_flag", "=", "log_relative_gauss", "(", "z", ")", "\n", "if", "exit_flag", "==", "0", ":", "\n", "        ", "alpha", "=", "e", "/", "np", ".", "sqrt", "(", "cVnic", ")", "\n", "# beta  = alpha * (alpha + cmni / cVnic);", "\n", "# r     = beta * cVnic / (1 - cVnic * beta);", "\n", "beta", "=", "alpha", "*", "(", "alpha", "*", "cVnic", "+", "cmni", ")", "\n", "r", "=", "beta", "/", "(", "1", "-", "beta", ")", "\n", "# new message", "\n", "pnew", "=", "r", "/", "cVnic", "\n", "mpnew", "=", "r", "*", "(", "alpha", "+", "cmni", "/", "cVnic", ")", "+", "alpha", "\n", "\n", "# update terms", "\n", "dp", "=", "np", ".", "max", "(", "[", "-", "p", "+", "eps", ",", "gamma", "*", "(", "pnew", "-", "p", ")", "]", ")", "# at worst, remove message", "\n", "dmp", "=", "np", ".", "max", "(", "[", "-", "mp", "+", "eps", ",", "gamma", "*", "(", "mpnew", "-", "mp", ")", "]", ")", "\n", "d", "=", "np", ".", "max", "(", "[", "dmp", ",", "dp", "]", ")", "# for convergence measures", "\n", "\n", "pnew", "=", "p", "+", "dp", "\n", "mpnew", "=", "mp", "+", "dmp", "\n", "# project out to marginal", "\n", "Vnew", "=", "V", "-", "dp", "/", "(", "1", "+", "dp", "*", "cVc", ")", "*", "np", ".", "outer", "(", "Vc", ",", "Vc", ")", "\n", "\n", "Mnew", "=", "M", "+", "(", "dmp", "-", "cM", "*", "dp", ")", "/", "(", "1", "+", "dp", "*", "cVc", ")", "*", "Vc", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "Vnew", ")", ")", ":", "\n", "            ", "raise", "Exception", "(", "\n", "\"an error occurs while running expectation \"", "\n", "\"propagation in entropy search. \"", "\n", "\"Resulting variance contains NaN\"", "\n", ")", "\n", "# % there is a problem here, when z is very large", "\n", "", "logS", "=", "lP", "-", "0.5", "*", "(", "np", ".", "log", "(", "beta", ")", "-", "np", ".", "log", "(", "pnew", ")", "-", "np", ".", "log", "(", "cVnic", ")", ")", "+", "(", "alpha", "*", "alpha", ")", "/", "(", "2", "*", "beta", ")", "*", "cVnic", "\n", "\n", "", "elif", "exit_flag", "==", "-", "1", ":", "\n", "        ", "d", "=", "np", ".", "NAN", "\n", "Mnew", "=", "0", "\n", "Vnew", "=", "0", "\n", "pnew", "=", "0", "\n", "mpnew", "=", "0", "\n", "logS", "=", "-", "np", ".", "Infinity", "\n", "", "elif", "exit_flag", "==", "1", ":", "\n", "        ", "d", "=", "0", "\n", "# remove message from marginal:", "\n", "# new message", "\n", "pnew", "=", "0", "\n", "mpnew", "=", "0", "\n", "# update terms", "\n", "dp", "=", "-", "p", "# at worst, remove message", "\n", "dmp", "=", "-", "mp", "\n", "d", "=", "max", "(", "[", "dmp", ",", "dp", "]", ")", "# for convergence measures", "\n", "# project out to marginal", "\n", "Vnew", "=", "V", "-", "dp", "/", "(", "1", "+", "dp", "*", "cVc", ")", "*", "(", "np", ".", "outer", "(", "Vc", ",", "Vc", ")", ")", "\n", "Mnew", "=", "M", "+", "(", "dmp", "-", "cM", "*", "dp", ")", "/", "(", "1", "+", "dp", "*", "cVc", ")", "*", "Vc", "\n", "logS", "=", "0", "\n", "", "return", "Mnew", ",", "Vnew", ",", "pnew", ",", "mpnew", ",", "logS", ",", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.log_relative_gauss": [[225, 238], ["numpy.log", "numpy.exp", "scipy.special.erfc"], "function", ["None"], ["", "def", "log_relative_gauss", "(", "z", ")", ":", "\n", "    ", "\"\"\"\n    log_relative_gauss\n    \"\"\"", "\n", "if", "z", "<", "-", "6", ":", "\n", "        ", "return", "1", ",", "-", "1.0e12", ",", "-", "1", "\n", "", "if", "z", ">", "6", ":", "\n", "        ", "return", "0", ",", "0", ",", "1", "\n", "", "else", ":", "\n", "        ", "logphi", "=", "-", "0.5", "*", "(", "z", "*", "z", "+", "l2p", ")", "\n", "logPhi", "=", "np", ".", "log", "(", "0.5", "*", "special", ".", "erfc", "(", "-", "z", "/", "sq2", ")", ")", "\n", "e", "=", "np", ".", "exp", "(", "logphi", "-", "logPhi", ")", "\n", "", "return", "e", ",", "logPhi", ",", "0", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_constrained_loop.f": [[11, 13], ["None"], "function", ["None"], ["def", "f", "(", "x", ")", ":", "\n", "    ", "return", "x", "**", "2", ",", "x", "-", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_constrained_loop.test_loop": [[15, 42], ["numpy.random.rand", "test_constrained_loop.f", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "emukit.core.ParameterSpace", "emukit.bayesian_optimization.acquisitions.ExpectedImprovement", "emukit.bayesian_optimization.loops.UnknownConstraintBayesianOptimizationLoop", "emukit.bayesian_optimization.loops.UnknownConstraintBayesianOptimizationLoop.run_loop", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.FixedIterationsStoppingCondition", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_loop", "(", ")", ":", "\n", "    ", "n_iterations", "=", "5", "\n", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "y_init", ",", "y_constraint_init", "=", "f", "(", "x_init", ")", "\n", "\n", "# Make GPy objective model", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "# Make GPy constraint model", "\n", "gpy_constraint_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "constraint_model", "=", "GPyModelWrapper", "(", "gpy_constraint_model", ")", "\n", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "acquisition", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "# Make loop and collect points", "\n", "bo", "=", "UnknownConstraintBayesianOptimizationLoop", "(", "\n", "model_objective", "=", "model", ",", "space", "=", "space", ",", "acquisition", "=", "acquisition", ",", "model_constraint", "=", "constraint_model", "\n", ")", "\n", "bo", ".", "run_loop", "(", "\n", "UserFunctionWrapper", "(", "f", ",", "extra_output_names", "=", "[", "\"Y_constraint\"", "]", ")", ",", "FixedIterationsStoppingCondition", "(", "n_iterations", ")", "\n", ")", "\n", "\n", "# Check we got the correct number of points", "\n", "assert", "bo", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "n_iterations", "+", "5", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_multipoint_expected_improvement.test_acquisition_multipoint_expected_improvement": [[16, 46], ["numpy.ones", "numpy.tril", "numpy.random.uniform", "emukit.bayesian_optimization.acquisitions.MultipointExpectedImprovement()._get_acquisition", "emukit.bayesian_optimization.acquisitions.MultipointExpectedImprovement", "emukit.bayesian_optimization.acquisitions.MultipointExpectedImprovement._get_acquisition", "numpy.random.multivariate_normal", "numpy.random.sample", "numpy.min", "sum", "float", "numpy.abs", "numpy.abs", "emukit.bayesian_optimization.acquisitions.MultipointExpectedImprovement"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_acquisition", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_acquisition", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample"], ["def", "test_acquisition_multipoint_expected_improvement", "(", ")", ":", "\n", "    ", "\"\"\"\n    Check if the q-EI acquisition function produces similar results as sampling\n    \"\"\"", "\n", "# Batch size", "\n", "k", "=", "2", "\n", "\n", "# Set mean to one", "\n", "mu", "=", "np", ".", "ones", "(", "(", "k", ")", ")", "\n", "\n", "# Sample random 3 dimensional covarinace matrix:", "\n", "L", "=", "np", ".", "tril", "(", "np", ".", "random", ".", "sample", "(", "(", "k", ",", "k", ")", ")", ")", "\n", "Sigma", "=", "L", "@", "L", ".", "T", "\n", "\n", "# Set current minimum to a random number smaller than the mean:", "\n", "current_minimum", "=", "np", ".", "random", ".", "uniform", "(", ")", "\n", "\n", "# Compute acquisition:", "\n", "qei_analytic", ",", "_", ",", "_", "=", "MultipointExpectedImprovement", "(", "None", ")", ".", "_get_acquisition", "(", "mu", ",", "Sigma", ",", "current_minimum", ")", "\n", "acq_fast", "=", "MultipointExpectedImprovement", "(", "None", ",", "fast_compute", "=", "True", ",", "eps", "=", "1e-3", ")", "\n", "qei_analytic_fast", ",", "_", ",", "_", "=", "acq_fast", ".", "_get_acquisition", "(", "mu", ",", "Sigma", ",", "current_minimum", ")", "\n", "\n", "# Reference with sampling", "\n", "N", "=", "1000000", "\n", "samples", "=", "np", ".", "random", ".", "multivariate_normal", "(", "mu", ",", "Sigma", ",", "size", "=", "N", ")", "\n", "qei_sampled", "=", "current_minimum", "-", "np", ".", "min", "(", "samples", ",", "axis", "=", "1", ")", "\n", "qei_sampled", "=", "sum", "(", "qei_sampled", "[", "qei_sampled", ">", "0", "]", ")", "/", "float", "(", "N", ")", "\n", "\n", "assert", "np", ".", "abs", "(", "qei_sampled", "-", "qei_analytic", ")", "<", "TOL", "\n", "assert", "np", ".", "abs", "(", "qei_analytic_fast", "-", "qei_analytic", ")", "<", "TOL", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_multipoint_expected_improvement.test_acquisition_gradient_multipoint_expected_improvement": [[48, 61], ["numpy.random.rand", "numpy.random.rand", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "numpy.array", "test_multipoint_expected_improvement._check_grad", "test_multipoint_expected_improvement._check_grad", "emukit.bayesian_optimization.acquisitions.MultipointExpectedImprovement", "emukit.bayesian_optimization.acquisitions.MultipointExpectedImprovement"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization._check_grad", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization._check_grad"], ["", "def", "test_acquisition_gradient_multipoint_expected_improvement", "(", ")", ":", "\n", "    ", "\"\"\"\n    Check the q-EI acquisition function gradients with numeric differentiation\n    \"\"\"", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "3", ",", "1", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "3", ",", "1", ")", "\n", "# Make GPy model", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "x0", "=", "np", ".", "array", "(", "[", "0.45", ",", "0.55", "]", ")", "\n", "_check_grad", "(", "MultipointExpectedImprovement", "(", "model", ")", ",", "TOL_GRAD", ",", "x0", ")", "\n", "_check_grad", "(", "MultipointExpectedImprovement", "(", "model", ",", "fast_compute", "=", "True", ",", "eps", "=", "1e-3", ")", ",", "TOL_GRAD_FAST", ",", "x0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_multipoint_expected_improvement._check_grad": [[63, 69], ["scipy.optimize.check_grad", "numpy.all", "lp.evaluate().flatten", "[].flatten", "lp.evaluate", "lp.evaluate_with_gradients"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "_check_grad", "(", "lp", ",", "tol", ",", "x0", ")", ":", "\n", "    ", "grad_error", "=", "check_grad", "(", "\n", "lambda", "x", ":", "lp", ".", "evaluate", "(", "x", "[", ":", ",", "None", "]", ")", ".", "flatten", "(", ")", ",", "lambda", "x", ":", "lp", ".", "evaluate_with_gradients", "(", "x", "[", ":", ",", "None", "]", ")", "[", "1", "]", ".", "flatten", "(", ")", ",", "x0", "\n", ")", "\n", "\n", "assert", "np", ".", "all", "(", "grad_error", "<", "tol", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_entropy_search.entropy_search_acquisition": [[8, 12], ["emukit.samplers.AffineInvariantEnsembleSampler", "emukit.bayesian_optimization.acquisitions.EntropySearch"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "entropy_search_acquisition", "(", "gpy_model", ",", "continuous_space", ")", ":", "\n", "    ", "sampler", "=", "AffineInvariantEnsembleSampler", "(", "continuous_space", ")", "\n", "return", "EntropySearch", "(", "gpy_model", ",", "continuous_space", ",", "sampler", ",", "num_representer_points", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_entropy_search.test_entropy_search_update_pmin": [[14, 22], ["entropy_search_acquisition.update_pmin", "numpy.all", "numpy.all", "numpy.all"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.update_pmin"], ["", "def", "test_entropy_search_update_pmin", "(", "entropy_search_acquisition", ")", ":", "\n", "    ", "logP", "=", "entropy_search_acquisition", ".", "update_pmin", "(", ")", "\n", "\n", "assert", "logP", ".", "shape", "[", "0", "]", "==", "entropy_search_acquisition", ".", "num_representer_points", "\n", "# Check if representer points are inside the bounds", "\n", "assert", "np", ".", "all", "(", "\n", "np", ".", "all", "(", "entropy_search_acquisition", ".", "representer_points", ">", "0", ")", "\n", "&", "np", ".", "all", "(", "entropy_search_acquisition", ".", "representer_points", "<", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_entropy_search.test_innovations": [[25, 40], ["numpy.array", "numpy.array", "entropy_search_acquisition._innovations", "numpy.any", "numpy.any", "numpy.array", "numpy.array", "entropy_search_acquisition._innovations", "numpy.any", "numpy.any", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._innovations", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._innovations"], ["", "def", "test_innovations", "(", "entropy_search_acquisition", ")", ":", "\n", "# Case 1: Assume no influence of test point on representer points", "\n", "    ", "entropy_search_acquisition", ".", "representer_points", "=", "np", ".", "array", "(", "[", "[", "100.0", ",", "100.0", "]", "]", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.0", "]", "]", ")", "\n", "dm", ",", "dv", "=", "entropy_search_acquisition", ".", "_innovations", "(", "x", ")", "\n", "\n", "assert", "np", ".", "any", "(", "np", ".", "abs", "(", "dm", ")", "<", "1e-3", ")", "\n", "assert", "np", ".", "any", "(", "np", ".", "abs", "(", "dv", ")", "<", "1e-3", ")", "\n", "\n", "# Case 2: Test point is close to representer points", "\n", "entropy_search_acquisition", ".", "representer_points", "=", "np", ".", "array", "(", "[", "[", "1.0", ",", "1.0", "]", "]", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "0.99", ",", "0.99", "]", "]", ")", "\n", "dm", ",", "dv", "=", "entropy_search_acquisition", ".", "_innovations", "(", "x", ")", "\n", "assert", "np", ".", "any", "(", "np", ".", "abs", "(", "dm", ")", ">", "1e-3", ")", "\n", "assert", "np", ".", "any", "(", "np", ".", "abs", "(", "dv", ")", ">", "1e-3", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization_calculator.test_local_penalization": [[15, 30], ["emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "numpy.random.rand", "numpy.random.rand", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "emukit.bayesian_optimization.acquisitions.ExpectedImprovement", "emukit.bayesian_optimization.local_penalization_calculator.LocalPenalizationPointCalculator", "emukit.core.loop.loop_state.create_loop_state", "emukit.bayesian_optimization.local_penalization_calculator.LocalPenalizationPointCalculator.compute_next_points", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["def", "test_local_penalization", "(", ")", ":", "\n", "    ", "parameter_space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "parameter_space", ")", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "acquisition", "=", "ExpectedImprovement", "(", "model", ")", "\n", "batch_size", "=", "5", "\n", "lp_calc", "=", "LocalPenalizationPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ",", "model", ",", "parameter_space", ",", "batch_size", ")", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "x_init", ",", "y_init", ")", "\n", "new_points", "=", "lp_calc", ".", "compute_next_points", "(", "loop_state", ")", "\n", "assert", "new_points", ".", "shape", "==", "(", "batch_size", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization_calculator.test_local_penalization_requires_gradients": [[32, 43], ["emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "mock.create_autospec", "emukit.bayesian_optimization.acquisitions.ExpectedImprovement", "pytest.raises", "emukit.bayesian_optimization.local_penalization_calculator.LocalPenalizationPointCalculator", "emukit.core.ContinuousParameter"], "function", ["None"], ["", "def", "test_local_penalization_requires_gradients", "(", ")", ":", "\n", "    ", "parameter_space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "parameter_space", ")", "\n", "\n", "model", "=", "mock", ".", "create_autospec", "(", "IModel", ")", "\n", "\n", "acquisition", "=", "ExpectedImprovement", "(", "model", ")", "\n", "batch_size", "=", "5", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "LocalPenalizationPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ",", "model", ",", "parameter_space", ",", "batch_size", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_max_value_entropy_search.max_value_entropy_search_acquisition": [[7, 10], ["emukit.bayesian_optimization.acquisitions.MaxValueEntropySearch"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "max_value_entropy_search_acquisition", "(", "gpy_model", ",", "continuous_space", ")", ":", "\n", "    ", "return", "MaxValueEntropySearch", "(", "gpy_model", ",", "continuous_space", ",", "num_samples", "=", "10", ",", "grid_size", "=", "5000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_max_value_entropy_search.test_entropy_search_update_pmin": [[12, 16], ["max_value_entropy_search_acquisition.update_parameters"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters"], ["", "def", "test_entropy_search_update_pmin", "(", "max_value_entropy_search_acquisition", ")", ":", "\n", "    ", "max_value_entropy_search_acquisition", ".", "update_parameters", "(", ")", "\n", "# check we sample required number of gumbel samplers", "\n", "assert", "max_value_entropy_search_acquisition", ".", "mins", ".", "shape", "[", "0", "]", "==", "max_value_entropy_search_acquisition", ".", "num_samples", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization.MockModel.predict": [[76, 78], ["numpy.random.rand", "numpy.random.rand"], "methods", ["None"], ["    ", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "rand", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "np", ".", "random", ".", "rand", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization.test_penalization_function_shape": [[10, 18], ["test_local_penalization.MockModel", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.update_batches", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.evaluate", "numpy.zeros", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["def", "test_penalization_function_shape", "(", ")", ":", "\n", "\n", "    ", "model", "=", "MockModel", "(", ")", "\n", "lp", "=", "LocalPenalization", "(", "model", ")", "\n", "lp", ".", "update_batches", "(", "np", ".", "zeros", "(", "(", "5", ",", "1", ")", ")", ",", "1", ",", "-", "0.1", ")", "\n", "\n", "value", "=", "lp", ".", "evaluate", "(", "np", ".", "random", ".", "rand", "(", "10", ",", "1", ")", ")", "\n", "assert", "value", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization.test_penalization_function_gradients_shape": [[20, 29], ["test_local_penalization.MockModel", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.update_batches", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.evaluate_with_gradients", "numpy.zeros", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "test_penalization_function_gradients_shape", "(", ")", ":", "\n", "\n", "    ", "model", "=", "MockModel", "(", ")", "\n", "lp", "=", "LocalPenalization", "(", "model", ")", "\n", "lp", ".", "update_batches", "(", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", ",", "1", ",", "-", "0.1", ")", "\n", "\n", "val", ",", "grad", "=", "lp", ".", "evaluate_with_gradients", "(", "np", ".", "random", ".", "rand", "(", "10", ",", "2", ")", ")", "\n", "assert", "grad", ".", "shape", "==", "(", "10", ",", "2", ")", "\n", "assert", "val", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization.test_local_penalization_gradients_with_single_point_in_batch": [[31, 39], ["numpy.random.seed", "test_local_penalization.MockModel", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.update_batches", "numpy.array", "test_local_penalization._check_grad", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization._check_grad"], ["", "def", "test_local_penalization_gradients_with_single_point_in_batch", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "model", "=", "MockModel", "(", ")", "\n", "lp", "=", "LocalPenalization", "(", "model", ")", "\n", "lp", ".", "update_batches", "(", "np", ".", "zeros", "(", "(", "1", ",", "1", ")", ")", ",", "1", ",", "-", "0.1", ")", "\n", "\n", "x0", "=", "np", ".", "array", "(", "[", "0.5", "]", ")", "\n", "_check_grad", "(", "lp", ",", "TOL", ",", "x0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization.test_local_penalization_gradients_with_no_points_in_batch": [[41, 49], ["numpy.random.seed", "test_local_penalization.MockModel", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.update_batches", "numpy.array", "test_local_penalization._check_grad", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization._check_grad"], ["", "def", "test_local_penalization_gradients_with_no_points_in_batch", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "model", "=", "MockModel", "(", ")", "\n", "lp", "=", "LocalPenalization", "(", "model", ")", "\n", "lp", ".", "update_batches", "(", "np", ".", "zeros", "(", "(", "1", ",", "1", ")", ")", ",", "1", ",", "-", "0.1", ")", "\n", "\n", "x0", "=", "np", ".", "array", "(", "[", "0.5", "]", ")", "\n", "_check_grad", "(", "lp", ",", "TOL", ",", "x0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization.test_local_penalization_gradients_with_multiple_points_in_batch": [[51, 59], ["numpy.random.seed", "test_local_penalization.MockModel", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.update_batches", "numpy.array", "test_local_penalization._check_grad", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization._check_grad"], ["", "def", "test_local_penalization_gradients_with_multiple_points_in_batch", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "model", "=", "MockModel", "(", ")", "\n", "lp", "=", "LocalPenalization", "(", "model", ")", "\n", "lp", ".", "update_batches", "(", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", ",", "1", ",", "-", "0.1", ")", "\n", "\n", "x0", "=", "np", ".", "array", "(", "[", "0.5", "]", ")", "\n", "_check_grad", "(", "lp", ",", "TOL", ",", "x0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization.test_local_penalization_at_batch_point": [[61, 73], ["numpy.random.seed", "test_local_penalization.MockModel", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization", "numpy.random.rand", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.update_batches", "emukit.bayesian_optimization.acquisitions.local_penalization.LocalPenalization.evaluate_with_gradients", "numpy.any", "numpy.isnan"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "test_local_penalization_at_batch_point", "(", ")", ":", "\n", "# Test edge case where evaluating local penalization at a point already in the batch.", "\n", "# This can lead to divide by zero errors if not done correctly.", "\n", "\n", "    ", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "model", "=", "MockModel", "(", ")", "\n", "lp", "=", "LocalPenalization", "(", "model", ")", "\n", "x_batch", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "lp", ".", "update_batches", "(", "x_batch", ",", "1", ",", "-", "0.1", ")", "\n", "\n", "val", ",", "grad", "=", "lp", ".", "evaluate_with_gradients", "(", "x_batch", ")", "\n", "assert", "not", "np", ".", "any", "(", "np", ".", "isnan", "(", "grad", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization._check_grad": [[80, 85], ["scipy.optimize.check_grad", "numpy.all", "lp.evaluate_with_gradients", "lp.evaluate_with_gradients"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.utils.check_grad", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "", "def", "_check_grad", "(", "lp", ",", "tol", ",", "x0", ")", ":", "\n", "    ", "grad_error", "=", "check_grad", "(", "\n", "lambda", "x", ":", "lp", ".", "evaluate_with_gradients", "(", "x", "[", "None", ",", ":", "]", ")", "[", "0", "]", "[", "0", "]", ",", "lambda", "x", ":", "lp", ".", "evaluate_with_gradients", "(", "x", "[", "None", ",", ":", "]", ")", "[", "1", "]", ",", "x0", "\n", ")", "\n", "assert", "np", ".", "all", "(", "grad_error", "<", "tol", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_epmgp.test_joint_min": [[6, 30], ["numpy.ones", "numpy.eye", "emukit.bayesian_optimization.epmgp.joint_min", "numpy.exp", "numpy.eye", "emukit.bayesian_optimization.epmgp.joint_min", "numpy.exp", "numpy.any", "numpy.any", "numpy.any", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.joint_min", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.joint_min"], ["def", "test_joint_min", "(", ")", ":", "\n", "\n", "# Uniform distribution", "\n", "    ", "n_points", "=", "5", "\n", "m", "=", "np", ".", "ones", "(", "[", "n_points", "]", ")", "\n", "v", "=", "np", ".", "eye", "(", "n_points", ")", "\n", "\n", "pmin", "=", "epmgp", ".", "joint_min", "(", "m", ",", "v", ")", "\n", "pmin", "=", "np", ".", "exp", "(", "pmin", ")", "\n", "\n", "uprob", "=", "1.0", "/", "n_points", "\n", "\n", "assert", "pmin", ".", "shape", "[", "0", "]", "==", "n_points", "\n", "assert", "np", ".", "any", "(", "pmin", "<", "(", "uprob", "+", "0.03", ")", ")", "and", "np", ".", "any", "(", "pmin", ">", "uprob", "-", "0.01", ")", "\n", "\n", "# Dirac delta", "\n", "m", "=", "np", ".", "ones", "(", "[", "n_points", "]", ")", "*", "1000", "\n", "m", "[", "0", "]", "=", "1", "\n", "v", "=", "np", ".", "eye", "(", "n_points", ")", "\n", "\n", "pmin", "=", "epmgp", ".", "joint_min", "(", "m", ",", "v", ")", "\n", "pmin", "=", "np", ".", "exp", "(", "pmin", ")", "\n", "assert", "pmin", "[", "0", "]", "==", "1.0", "\n", "assert", "np", ".", "any", "(", "pmin", "[", ":", "1", "]", ">", "1e-10", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_bayesian_optimization_loop.f": [[15, 17], ["None"], "function", ["None"], ["def", "f", "(", "x", ")", ":", "\n", "    ", "return", "x", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_bayesian_optimization_loop.test_loop": [[19, 46], ["pytest.mark.parametrize", "numpy.random.rand", "numpy.random.rand", "GPy.models.GPRegression", "emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper", "emukit.core.parameter_space.ParameterSpace", "emukit.bayesian_optimization.acquisitions.ExpectedImprovement", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop.run_loop", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop.get_results", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.FixedIterationsStoppingCondition", "emukit.core.continuous_parameter.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop", "home.repos.pwc.inspect_result.amzn_emukit.loops.bayesian_optimization_loop.BayesianOptimizationLoop.get_results"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"batch_size\"", ",", "[", "1", ",", "3", "]", ")", "\n", "def", "test_loop", "(", "batch_size", ")", ":", "\n", "    ", "n_init", "=", "5", "\n", "n_iterations", "=", "5", "\n", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "n_init", ",", "1", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "n_init", ",", "1", ")", "\n", "\n", "# Make GPy model", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "acquisition", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "# Make loop and collect points", "\n", "bo", "=", "BayesianOptimizationLoop", "(", "model", "=", "model", ",", "space", "=", "space", ",", "acquisition", "=", "acquisition", ",", "batch_size", "=", "batch_size", ")", "\n", "bo", ".", "run_loop", "(", "UserFunctionWrapper", "(", "f", ")", ",", "FixedIterationsStoppingCondition", "(", "n_iterations", ")", ")", "\n", "\n", "# Check we got the correct number of points", "\n", "assert", "bo", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "n_iterations", "*", "batch_size", "+", "n_init", "\n", "\n", "# Check the obtained results", "\n", "results", "=", "bo", ".", "get_results", "(", ")", "\n", "\n", "assert", "results", ".", "minimum_location", ".", "shape", "[", "0", "]", "==", "1", "\n", "assert", "results", ".", "best_found_value_per_iteration", ".", "shape", "[", "0", "]", "==", "n_iterations", "*", "batch_size", "+", "n_init", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_cost_sensitive_bayesian_optimization.test_cost_sensitive_bayesian_optimization_loop": [[12, 35], ["emukit.core.ParameterSpace", "numpy.random.rand", "emukit.core.loop.user_function.UserFunctionWrapper", "test_cost_sensitive_bayesian_optimization.test_cost_sensitive_bayesian_optimization_loop.function_with_cost"], "function", ["None"], ["def", "test_cost_sensitive_bayesian_optimization_loop", "(", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "10", ",", "1", ")", "\n", "\n", "def", "function_with_cost", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "sin", "(", "x", ")", ",", "x", "\n", "\n", "", "user_fcn", "=", "UserFunctionWrapper", "(", "function_with_cost", ",", "extra_output_names", "=", "[", "\"cost\"", "]", ")", "\n", "\n", "y_init", ",", "cost_init", "=", "function_with_cost", "(", "x_init", ")", "\n", "\n", "gpy_model_objective", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "gpy_model_cost", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "cost_init", ")", "\n", "\n", "model_objective", "=", "GPyModelWrapper", "(", "gpy_model_objective", ")", "\n", "model_cost", "=", "GPyModelWrapper", "(", "gpy_model_cost", ")", "\n", "\n", "loop", "=", "CostSensitiveBayesianOptimizationLoop", "(", "space", ",", "model_objective", ",", "model_cost", ")", "\n", "loop", ".", "run_loop", "(", "user_fcn", ",", "10", ")", "\n", "\n", "assert", "loop", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "20", "\n", "assert", "loop", ".", "loop_state", ".", "cost", ".", "shape", "[", "0", "]", "==", "20", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockIModel.__init__": [[15, 18], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "self", ".", "_X", "=", "X", "\n", "self", ".", "_Y", "=", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockIModel.X": [[19, 22], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockIModel.Y": [[23, 26], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockNoiselessModel._mean_func": [[41, 44], ["test_mean_plugin_expected_improvement.deterministic_test_func"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.deterministic_test_func"], ["@", "staticmethod", "\n", "def", "_mean_func", "(", "X", ")", ":", "\n", "        ", "return", "deterministic_test_func", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockNoiselessModel._var_func": [[45, 48], ["numpy.cos"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_var_func", "(", "X", ")", ":", "\n", "        ", "return", "(", "np", ".", "cos", "(", "X", "*", "10", ")", "+", "1.2", ")", ".", "sum", "(", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockNoiselessModel.predict": [[49, 51], ["test_mean_plugin_expected_improvement.MockNoiselessModel._mean_func", "test_mean_plugin_expected_improvement.MockNoiselessModel._var_func"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockNoiselessModel._mean_func", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockNoiselessModel._var_func"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "self", ".", "_mean_func", "(", "X", ")", ",", "self", ".", "_var_func", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockNoiselessModel.predict_noiseless": [[52, 54], ["test_mean_plugin_expected_improvement.MockNoiselessModel.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_noiseless", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "self", ".", "predict", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockConstantModel.predict": [[59, 62], ["numpy.ones", "numpy.ones"], "methods", ["None"], ["def", "predict", "(", "self", ",", "X", ")", ":", "\n", "# Return mean 1 and variance 8", "\n", "        ", "return", "np", ".", "ones", "(", "[", "X", ".", "shape", "[", "0", "]", ",", "1", "]", ")", ",", "8", "*", "np", ".", "ones", "(", "[", "X", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.MockConstantModel.predict_noiseless": [[63, 66], ["numpy.ones", "numpy.ones"], "methods", ["None"], ["", "def", "predict_noiseless", "(", "self", ",", "X", ")", ":", "\n", "# Return mean 1 and variance 1", "\n", "        ", "return", "np", ".", "ones", "(", "[", "X", ".", "shape", "[", "0", "]", ",", "1", "]", ")", ",", "np", ".", "ones", "(", "[", "X", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.deterministic_test_func": [[28, 30], ["numpy.sin().sum", "numpy.sin"], "function", ["None"], ["", "", "def", "deterministic_test_func", "(", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "return", "np", ".", "sin", "(", "x", "*", "30", "+", "x", "**", "2", ")", ".", "sum", "(", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.test_mean_plugin_ei_same_as_standard_on_noiseless": [[68, 81], ["numpy.random.seed", "numpy.random.randn", "test_mean_plugin_expected_improvement.deterministic_test_func", "test_mean_plugin_expected_improvement.MockNoiselessModel", "emukit.bayesian_optimization.acquisitions.expected_improvement.MeanPluginExpectedImprovement", "emukit.bayesian_optimization.acquisitions.expected_improvement.ExpectedImprovement", "numpy.random.randn", "pytest.approx", "emukit.bayesian_optimization.acquisitions.expected_improvement.MeanPluginExpectedImprovement.evaluate", "emukit.bayesian_optimization.acquisitions.expected_improvement.ExpectedImprovement.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.deterministic_test_func", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_mean_plugin_ei_same_as_standard_on_noiseless", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "10", ",", "3", ")", "\n", "Y", "=", "deterministic_test_func", "(", "X", ")", "\n", "\n", "model", "=", "MockNoiselessModel", "(", "X", ",", "Y", ")", "\n", "\n", "mean_plugin_ei", "=", "MeanPluginExpectedImprovement", "(", "model", ")", "\n", "standard_ei", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "x_new", "=", "np", ".", "random", ".", "randn", "(", "100", ",", "3", ")", "\n", "##\u00a0Assert the two expected improvement are equal", "\n", "assert", "pytest", ".", "approx", "(", "standard_ei", ".", "evaluate", "(", "x_new", ")", ")", "==", "mean_plugin_ei", ".", "evaluate", "(", "x_new", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_mean_plugin_expected_improvement.test_mean_plugin_expected_improvement_returns_expected": [[83, 99], ["numpy.random.seed", "numpy.random.randn", "numpy.random.randn", "test_mean_plugin_expected_improvement.MockConstantModel", "emukit.bayesian_optimization.acquisitions.expected_improvement.MeanPluginExpectedImprovement", "numpy.random.randn", "emukit.bayesian_optimization.acquisitions.expected_improvement.MeanPluginExpectedImprovement.evaluate", "pytest.approx"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_mean_plugin_expected_improvement_returns_expected", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "43", ")", "\n", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "10", ",", "3", ")", "\n", "Y", "=", "np", ".", "random", ".", "randn", "(", "10", ",", "1", ")", "\n", "\n", "model", "=", "MockConstantModel", "(", "X", ",", "Y", ")", "\n", "\n", "mean_plugin_ei", "=", "MeanPluginExpectedImprovement", "(", "model", ")", "\n", "\n", "x_new", "=", "np", ".", "random", ".", "randn", "(", "100", ",", "3", ")", "\n", "acquisition_values", "=", "mean_plugin_ei", ".", "evaluate", "(", "x_new", ")", "\n", "# The mean at every previously observed point will be 1, hence y_minimum will be 1.0.", "\n", "# The predicted values in the batch should all have mean 1 and variance 1", "\n", "# The correct expected improvement for Gaussian Y ~ Normal(1, 1), and y_minimum = 1.0 is 0.3989422804014327", "\n", "assert", "pytest", ".", "approx", "(", "0.3989422804014327", ",", "abs", "=", "0", ",", "rel", "=", "1e-7", ")", "==", "acquisition_values", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_constrained_loop.test_optimization_with_linear_constraint": [[10, 27], ["emukit.test_functions.branin_function", "parameter_space.sample_uniform", "branin_fcn", "numpy.array", "numpy.array", "numpy.array", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop.run_loop", "emukit.core.constraints.LinearInequalityConstraint", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin.branin_function", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["\n", "def", "f", "(", "x", ")", ":", "\n", "    ", "return", "x", "**", "2", ",", "x", "-", "0.5", "\n", "\n", "\n", "", "def", "test_loop", "(", ")", ":", "\n", "    ", "n_iterations", "=", "5", "\n", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "y_init", ",", "y_constraint_init", "=", "f", "(", "x_init", ")", "\n", "\n", "# Make GPy objective model", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "# Make GPy constraint model", "\n", "gpy_constraint_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "constraint_model", "=", "GPyModelWrapper", "(", "gpy_constraint_model", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_unknown_constraints_bayesian_optimization.f": [[10, 12], ["None"], "function", ["None"], ["def", "f", "(", "x", ")", ":", "\n", "    ", "return", "x", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_unknown_constraints_bayesian_optimization.fc": [[14, 16], ["None"], "function", ["None"], ["", "def", "fc", "(", "x", ")", ":", "\n", "    ", "return", "2", "*", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_unknown_constraints_bayesian_optimization.test_loop": [[18, 33], ["numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "emukit.core.continuous_parameter.ContinuousParameter", "emukit.examples.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization", "range", "emukit.examples.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization.get_next_points", "test_unknown_constraints_bayesian_optimization.f", "test_unknown_constraints_bayesian_optimization.fc", "emukit.core.loop.UserFunctionResult"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.get_next_points", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_unknown_constraints_bayesian_optimization.fc"], ["", "def", "test_loop", "(", ")", ":", "\n", "    ", "n_iterations", "=", "5", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "yc_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "x", "=", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "\n", "bo", "=", "UnknownConstraintGPBayesianOptimization", "(", "variables_list", "=", "[", "x", "]", ",", "X", "=", "x_init", ",", "Y", "=", "y_init", ",", "Yc", "=", "yc_init", ",", "batch_size", "=", "1", ")", "\n", "results", "=", "None", "\n", "for", "_", "in", "range", "(", "n_iterations", "+", "1", ")", ":", "\n", "        ", "X_new", "=", "bo", ".", "get_next_points", "(", "results", ")", "\n", "Y_new", "=", "f", "(", "X_new", ")", "\n", "Yc_new", "=", "fc", "(", "X_new", ")", "\n", "results", "=", "[", "UserFunctionResult", "(", "X_new", "[", "0", "]", ",", "Y_new", "[", "0", "]", ",", "Y_constraint", "=", "Yc_new", "[", "0", "]", ")", "]", "\n", "# Check we got the correct number of points", "\n", "", "assert", "bo", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "n_iterations", "+", "5", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_single_objective_bayesian_optimization.f": [[7, 9], ["None"], "function", ["None"], ["def", "f", "(", "x", ")", ":", "\n", "    ", "return", "x", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_single_objective_bayesian_optimization.test_loop": [[11, 23], ["numpy.random.rand", "numpy.random.rand", "emukit.core.continuous_parameter.ContinuousParameter", "emukit.examples.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization", "emukit.examples.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization.run_optimization", "emukit.examples.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization.suggest_new_locations"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization.run_optimization", "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization.suggest_new_locations"], ["", "def", "test_loop", "(", ")", ":", "\n", "    ", "n_iterations", "=", "5", "\n", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "x", "=", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "\n", "bo", "=", "GPBayesianOptimization", "(", "variables_list", "=", "[", "x", "]", ",", "X", "=", "x_init", ",", "Y", "=", "y_init", ")", "\n", "bo", ".", "run_optimization", "(", "f", ",", "n_iterations", ")", "\n", "\n", "# Check we got the correct number of points", "\n", "assert", "bo", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "n_iterations", "+", "5", "\n", "assert", "bo", ".", "suggest_new_locations", "(", ")", ".", "shape", "==", "(", "1", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_local_penalization_loop.test_local_penalization": [[10, 30], ["numpy.random.seed", "emukit.test_functions.branin_function", "parameter_space.sample_uniform", "branin_fcn", "GPy.models.GPRegression", "GPy.models.GPRegression.Gaussian_noise.fix", "emukit.model_wrappers.GPyModelWrapper", "emukit.bayesian_optimization.acquisitions.ExpectedImprovement", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop.run_loop", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin.branin_function", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["def", "test_local_penalization", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "branin_fcn", ",", "parameter_space", "=", "branin_function", "(", ")", "\n", "x_init", "=", "parameter_space", ".", "sample_uniform", "(", "10", ")", "\n", "\n", "y_init", "=", "branin_fcn", "(", "x_init", ")", "\n", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "gpy_model", ".", "Gaussian_noise", ".", "fix", "(", "1", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "base_acquisition", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "batch_size", "=", "10", "\n", "update_interval", "=", "1", "\n", "\n", "lp", "=", "BayesianOptimizationLoop", "(", "parameter_space", ",", "model", ",", "base_acquisition", ",", "update_interval", ",", "batch_size", ")", "\n", "lp", ".", "run_loop", "(", "branin_fcn", ",", "5", ")", "\n", "\n", "assert", "len", "(", "lp", ".", "loop_state", ".", "Y", ")", "==", "60", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_create_bayesian_optimization_loop.test_loop_state": [[8, 28], ["emukit.test_functions.forrester.forrester_function", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "emukit.examples.gp_bayesian_optimization.optimization_loops.create_bayesian_optimization_loop"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_function", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.create_bayesian_optimization_loop"], ["def", "test_loop_state", "(", ")", ":", "\n", "\n", "    ", "fcn", ",", "cs", "=", "forrester_function", "(", ")", "\n", "n_init", "=", "5", "\n", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "n_init", ",", "1", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "n_init", ",", "1", ")", "\n", "c_init", "=", "np", ".", "random", ".", "rand", "(", "n_init", ",", "1", ")", "\n", "bo", "=", "create_bayesian_optimization_loop", "(", "\n", "x_init", "=", "x_init", ",", "\n", "y_init", "=", "y_init", ",", "\n", "parameter_space", "=", "cs", ",", "\n", "acquisition_type", "=", "AcquisitionType", ".", "EI", ",", "\n", "model_type", "=", "ModelType", ".", "RandomForest", ",", "\n", "cost_init", "=", "c_init", ",", "\n", ")", "\n", "\n", "assert", "bo", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "n_init", "\n", "assert", "bo", ".", "loop_state", ".", "Y", ".", "shape", "[", "0", "]", "==", "n_init", "\n", "assert", "bo", ".", "loop_state", ".", "cost", ".", "shape", "[", "0", "]", "==", "n_init", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.test_optimization_with_categorical_variables.test_categorical_variables": [[10, 40], ["numpy.random.seed", "emukit.core.OneHotEncoding", "emukit.core.ParameterSpace", "emukit.core.ParameterSpace.sample_uniform", "numpy.all", "test_optimization_with_categorical_variables.test_categorical_variables.objective"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.objective"], ["def", "test_categorical_variables", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "\n", "def", "objective", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "np", ".", "sum", "(", "x", ",", "axis", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "", "carol_spirits", "=", "[", "\"past\"", ",", "\"present\"", ",", "\"yet to come\"", "]", "\n", "encoding", "=", "OneHotEncoding", "(", "carol_spirits", ")", "\n", "parameter_space", "=", "ParameterSpace", "(", "\n", "[", "ContinuousParameter", "(", "\"real_param\"", ",", "0.0", ",", "1.0", ")", ",", "CategoricalParameter", "(", "\"categorical_param\"", ",", "encoding", ")", "]", "\n", ")", "\n", "\n", "x_init", "=", "parameter_space", ".", "sample_uniform", "(", "10", ")", "\n", "\n", "assert", "x_init", ".", "shape", "==", "(", "10", ",", "4", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "logical_or", "(", "x_init", "[", ":", ",", "1", ":", "3", "]", "==", "0.0", ",", "x_init", "[", ":", ",", "1", ":", "3", "]", "==", "1.0", ")", ")", "\n", "\n", "y_init", "=", "objective", "(", "x_init", ")", "\n", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "gpy_model", ".", "Gaussian_noise", ".", "fix", "(", "1", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "acquisition", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "loop", "=", "BayesianOptimizationLoop", "(", "parameter_space", ",", "model", ",", "acquisition", ")", "\n", "loop", ".", "run_loop", "(", "objective", ",", "5", ")", "\n", "\n", "assert", "len", "(", "loop", ".", "loop_state", ".", "Y", ")", "==", "15", "\n", "assert", "np", ".", "all", "(", "np", ".", "logical_or", "(", "loop", ".", "loop_state", ".", "X", "[", ":", ",", "1", ":", "3", "]", "==", "0.0", ",", "loop", ".", "loop_state", ".", "X", "[", ":", ",", "1", ":", "3", "]", "==", "1.0", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IEntropySearchModel.predict_covariance": [[14, 22], ["None"], "methods", ["None"], ["def", "predict_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "with_noise", ":", "bool", "=", "True", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n\n        :param X: Numpy array of shape (n_points, n_features) of test input locations\n        :param with_noise: Whether to include likelihood noise term in covariance\n        :return: Posterior covariance matrix which has shape (n_points x n_points)\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IEntropySearchModel.get_covariance_between_points": [[23, 34], ["None"], "methods", ["None"], ["", "def", "get_covariance_between_points", "(", "self", ",", "X1", ":", "np", ".", "ndarray", ",", "X2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculate posterior covariance between one point in X1 and all points in X2\n\n        :param X1: An array of shape 1 x n_dimensions that contains a data single point. It is the first argument of the\n                   posterior covariance function\n        :param X2: An array of shape n_points x n_dimensions that may contain multiple data points. This is the second\n                   argument to the posterior covariance function.\n        :return: An array of shape n_points x 1 of posterior covariances between X1 and X2\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IStandardKernel.K": [[19, 27], ["None"], "methods", ["None"], ["def", "K", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The kernel k(x1, x2) evaluated at x1 and x2.\n\n        :param x1: First argument of the kernel, shape (n_points N, input_dim)\n        :param x2: Second argument of the kernel, shape (n_points M, input_dim)\n        :returns: Kernel evaluated at x1, x2, shape (N, M).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IStandardKernel.dK_dx1": [[29, 37], ["None"], "methods", ["None"], ["", "def", "dK_dx1", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Gradient of the kernel wrt x1 evaluated at pair x1, x2.\n\n        :param x1: First argument of the kernel, shape (n_points N, input_dim)\n        :param x2: Second argument of the kernel, shape (n_points M, input_dim)\n        :return: The gradient of the kernel wrt x1 evaluated at (x1, x2), shape (input_dim, N, M)\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IStandardKernel.dKdiag_dx": [[38, 45], ["None"], "methods", ["None"], ["", "def", "dKdiag_dx", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The gradient of the diagonal of the kernel (the variance) v(x):=k(x, x) evaluated at x.\n\n        :param x: The locations where the gradient is evaluated, shape (n_points, input_dim).\n        :return: The gradient of the diagonal of the kernel evaluated at x, shape (input_dim, n_points).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IRBF.lengthscales": [[69, 73], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"The lengthscales :math:`\\lambda` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IRBF.variance": [[74, 78], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IRBF.dK_dx1": [[79, 82], ["numpy.swapaxes", "standard_kernels.IRBF.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "dK_dx1", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "scaled_vector_diff", "=", "np", ".", "swapaxes", "(", "(", "x1", "[", "None", ",", ":", ",", ":", "]", "-", "x2", "[", ":", ",", "None", ",", ":", "]", ")", "/", "self", ".", "lengthscales", "**", "2", ",", "0", ",", "-", "1", ")", "\n", "return", "-", "self", ".", "K", "(", "x1", ",", "x2", ")", "[", "None", ",", "...", "]", "*", "scaled_vector_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IRBF.dKdiag_dx": [[83, 85], ["numpy.zeros"], "methods", ["None"], ["", "def", "dKdiag_dx", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern32.nu": [[113, 117], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "nu", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"The smoothness parameter of the kernel.\"\"\"", "\n", "return", "1.5", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern32.lengthscales": [[118, 122], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"The lengthscales :math:`\\lambda` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern32.variance": [[123, 127], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern32._dK_dx1_1d": [[128, 143], ["numpy.exp", "abs", "abs", "abs", "numpy.sqrt"], "methods", ["None"], ["", "def", "_dK_dx1_1d", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ",", "ell", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Unscaled gradient of 1D Matern32 where ``ell`` is the lengthscale parameter.\n\n        This method can be used in case the product Matern32 is implemented via a List of\n        univariate Matern32 kernels.\n\n        :param x1: First argument of the kernel, shape = (n_points N,).\n        :param x2: Second argument of the kernel, shape = (n_points M,).\n        :param ell: The lengthscale of the 1D Matern32.\n        :return: The gradient of the kernel wrt x1 evaluated at (x1, x2), shape (N, M).\n        \"\"\"", "\n", "r", "=", "(", "x1", ".", "T", "[", ":", ",", "None", "]", "-", "x2", ".", "T", "[", "None", ",", ":", "]", ")", "/", "ell", "# N x M", "\n", "dr_dx1", "=", "r", "/", "(", "ell", "*", "abs", "(", "r", ")", ")", "\n", "dK_dr", "=", "-", "3", "*", "abs", "(", "r", ")", "*", "np", ".", "exp", "(", "-", "np", ".", "sqrt", "(", "3", ")", "*", "abs", "(", "r", ")", ")", "\n", "return", "dK_dr", "*", "dr_dx1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern32.dKdiag_dx": [[144, 146], ["numpy.zeros"], "methods", ["None"], ["", "def", "dKdiag_dx", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern52.nu": [[174, 178], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "nu", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"The smoothness parameter of the kernel.\"\"\"", "\n", "return", "2.5", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern52.lengthscales": [[179, 183], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"The lengthscales :math:`\\lambda` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern52.variance": [[184, 188], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern52._dK_dx1_1d": [[189, 204], ["abs", "numpy.exp", "abs", "numpy.sqrt", "abs", "numpy.sqrt"], "methods", ["None"], ["", "def", "_dK_dx1_1d", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ",", "ell", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Unscaled gradient of 1D Matern52 where ``ell`` is the lengthscale parameter.\n\n        This method can be used in case the product Matern52 is implemented via a List of\n        univariate Matern52 kernels.\n\n        :param x1: First argument of the kernel, shape = (n_points N,).\n        :param x2: Second argument of the kernel, shape = (n_points M,).\n        :param ell: The lengthscale of the 1D Matern52.\n        :return: The gradient of the kernel wrt x1 evaluated at (x1, x2), shape (N, M).\n        \"\"\"", "\n", "r", "=", "(", "x1", ".", "T", "[", ":", ",", "None", "]", "-", "x2", ".", "T", "[", "None", ",", ":", "]", ")", "/", "ell", "# N x M", "\n", "dr_dx1", "=", "r", "/", "(", "ell", "*", "abs", "(", "r", ")", ")", "\n", "dK_dr", "=", "(", "-", "5", "/", "3", ")", "*", "np", ".", "exp", "(", "-", "np", ".", "sqrt", "(", "5", ")", "*", "abs", "(", "r", ")", ")", "*", "(", "abs", "(", "r", ")", "+", "np", ".", "sqrt", "(", "5", ")", "*", "r", "**", "2", ")", "\n", "return", "dK_dr", "*", "dr_dx1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductMatern52.dKdiag_dx": [[205, 207], ["numpy.zeros"], "methods", ["None"], ["", "def", "dKdiag_dx", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IBrownian.variance": [[228, 232], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IBrownian.dK_dx1": [[233, 237], ["numpy.repeat", "numpy.repeat"], "methods", ["None"], ["", "def", "dK_dx1", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "x1_rep", "=", "np", ".", "repeat", "(", "x1", "[", ":", ",", "0", "]", "[", "np", ".", "newaxis", ",", "...", "]", ",", "x2", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", ".", "T", "\n", "x2_rep", "=", "np", ".", "repeat", "(", "x2", "[", ":", ",", "0", "]", "[", "np", ".", "newaxis", ",", "...", "]", ",", "x1", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "return", "self", ".", "variance", "*", "(", "x1_rep", "<", "x2_rep", ")", "[", "np", ".", "newaxis", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IBrownian.dKdiag_dx": [[238, 240], ["numpy.ones"], "methods", ["None"], ["", "def", "dKdiag_dx", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "variance", "*", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian.variance": [[267, 271], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian.offset": [[272, 276], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "offset", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The offset :math:`c` of the kernel.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian._dK_dx1_1d": [[277, 290], ["numpy.repeat", "numpy.repeat"], "methods", ["None"], ["", "def", "_dK_dx1_1d", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Unscaled gradient of 1D Brownian kernel.\n\n        This method can be used in case the product Brownian is implemented via a List of\n        Brownian kernels.\n\n        :param x1: First argument of the kernel, shape = (n_points N,).\n        :param x2: Second argument of the kernel, shape = (n_points M,).\n        :return: The gradient of the kernel wrt x1 evaluated at (x1, x2), shape (N, M).\n        \"\"\"", "\n", "x1_rep", "=", "np", ".", "repeat", "(", "x1", "[", "np", ".", "newaxis", ",", "...", "]", ",", "x2", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", ".", "T", "\n", "x2_rep", "=", "np", ".", "repeat", "(", "x2", "[", "np", ".", "newaxis", ",", "...", "]", ",", "x1", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "return", "x1_rep", "<", "x2_rep", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.base_gp.IBaseGaussianProcess.__init__": [[32, 34], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "kern", ":", "QuadratureKernel", ")", "->", "None", ":", "\n", "        ", "self", ".", "kern", "=", "kern", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.base_gp.IBaseGaussianProcess.observation_noise_variance": [[35, 39], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "observation_noise_variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"The variance of the Gaussian observation noise.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.base_gp.IBaseGaussianProcess.predict_with_full_covariance": [[40, 47], ["None"], "methods", ["None"], ["", "def", "predict_with_full_covariance", "(", "self", ",", "X_pred", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Predictive mean and full co-variance at the locations X_pred.\n\n        :param X_pred: Points at which to predict, shape (n_points, input_dim)\n        :return: Predictive mean, predictive full co-variance, shapes (num_points, 1) and (num_points, num_points).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.base_gp.IBaseGaussianProcess.solve_linear": [[48, 58], ["None"], "methods", ["None"], ["", "def", "solve_linear", "(", "self", ",", "z", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Solve the linear system :math:`Gx=z` for :math:`x`.\n\n        :math:`G` is the Gram matrix :math:`G := K(X, X) + \\sigma^2 I`,\n        of shape (num_dat, num_dat) and :math:`z` is a matrix of shape (num_dat, num_obs).\n\n        :param z: A matrix of shape (num_dat, num_obs).\n        :return: The solution :math:`x` of the linear, shape (num_dat, num_obs).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.base_gp.IBaseGaussianProcess.graminv_residual": [[59, 72], ["None"], "methods", ["None"], ["", "def", "graminv_residual", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"The solution :math:`z` of the linear system\n\n        .. math::\n\n            (K_{XX} + \\zeta^2 I) z = (Y - m(X))\n\n        where :math:`X` and :math:`Y` are the available nodes and function evaluation, :math:`m(X)`\n        is the predictive mean at :math:`X`, and :math:`\\zeta^2` the observation noise variance.\n\n        :return: The solution :math:`z` of the linear system, shape (num_dat, 1).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.base_gp.IBaseGaussianProcess.get_prediction_gradients": [[73, 89], ["base_gp.IBaseGaussianProcess.kern.dKdiag_dx", "base_gp.IBaseGaussianProcess.kern.dK_dx1", "base_gp.IBaseGaussianProcess.solve_linear", "base_gp.IBaseGaussianProcess.kern.K", "base_gp.IBaseGaussianProcess.kern.dK_dx1", "base_gp.IBaseGaussianProcess.graminv_residual", "numpy.transpose"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dKdiag_dx", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dK_dx1", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.solve_linear", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dK_dx1", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.graminv_residual"], ["", "def", "get_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"Evaluates the predictive gradients of mean and variance at X.\n\n        :param X: Points at which the gradients are evaluated, shape (n_points, input_dim).\n        :returns: The gradients of mean and variance, each of shape (n_points, input_dim).\n        \"\"\"", "\n", "# gradient of mean", "\n", "d_mean_dx", "=", "(", "self", ".", "kern", ".", "dK_dx1", "(", "X", ",", "self", ".", "X", ")", "@", "self", ".", "graminv_residual", "(", ")", ")", "[", ":", ",", ":", ",", "0", "]", ".", "T", "\n", "\n", "# gradient of variance", "\n", "dKdiag_dx", "=", "self", ".", "kern", ".", "dKdiag_dx", "(", "X", ")", "\n", "dKxX_dx1", "=", "self", ".", "kern", ".", "dK_dx1", "(", "X", ",", "self", ".", "X", ")", "\n", "graminv_KXx", "=", "self", ".", "solve_linear", "(", "self", ".", "kern", ".", "K", "(", "self", ".", "X", ",", "X", ")", ")", "\n", "d_var_dx", "=", "dKdiag_dx", "-", "2.0", "*", "(", "dKxX_dx1", "*", "np", ".", "transpose", "(", "graminv_KXx", ")", ")", ".", "sum", "(", "axis", "=", "2", ",", "keepdims", "=", "False", ")", "\n", "\n", "return", "d_mean_dx", ",", "d_var_dx", ".", "T", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IModel.predict": [[11, 19], ["None"], "methods", ["None"], ["\n", "\n", "def", "predict_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "with_noise", ":", "bool", "=", "True", ")", "->", "np", ".", "ndarray", ":", "\n", "        "]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IModel.set_data": [[20, 28], ["None"], "methods", ["None"], ["\n", "raise", "NotImplementedError", "\n", "\n", "", "def", "get_covariance_between_points", "(", "self", ",", "X1", ":", "np", ".", "ndarray", ",", "X2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        "]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IModel.optimize": [[29, 34], ["None"], "methods", ["None"], ["\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IModel.X": [[35, 38], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IModel.Y": [[39, 42], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IDifferentiable.get_prediction_gradients": [[45, 53], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IJointlyDifferentiable.predict_with_full_covariance": [[56, 63], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IJointlyDifferentiable.get_joint_prediction_gradients": [[64, 74], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IPriorHyperparameters.generate_hyperparameters_samples": [[77, 90], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IPriorHyperparameters.fix_model_hyperparameters": [[91, 98], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.IModelWithNoise.predict_noiseless": [[101, 109], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.amzn_emukit.interfaces.models.ICalculateVarianceReduction.calculate_variance_reduction": [[9, 14], ["None"], "methods", ["None"], ["    ", "\"\"\"\n    Interface containing abstract methods that need to be implemented if using entropy search Bayesian optimization\n    acquisition function.\n    \"\"\"", "\n", "\n", "def", "predict_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "with_noise", ":", "bool", "=", "True", ")", "->", "np", ".", "ndarray", ":", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search.MaxValueEntropySearch.__init__": [[22, 55], ["core.acquisition.Acquisition.__init__", "isinstance", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Union", "[", "IModel", ",", "IEntropySearchModel", "]", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "num_samples", ":", "int", "=", "10", ",", "\n", "grid_size", ":", "int", "=", "5000", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "\"\"\"\n        MES acquisition function approximates the distribution of the value at the global\n        minimum and tries to decrease its entropy. See this paper for more details:\n        Z. Wang, S. Jegelka\n        Max-value Entropy Search for Efficient Bayesian Optimization\n        ICML 2017\n\n        :param model: GP model to compute the distribution of the minimum dubbed pmin.\n        :param space: Domain space which we need for the sampling of the representer points\n        :param num_samples: integer determining how many samples to draw of the minimum (does not need to be large)\n        :param grid_size: number of random locations in grid used to fit the gumbel distribution and approximately generate\n        the samples of the minimum (recommend scaling with problem dimension, i.e. 10000*d)\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "IEntropySearchModel", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Model is not supported for MES\"", ")", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "space", "=", "space", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "self", ".", "grid_size", "=", "grid_size", "\n", "\n", "# Initialize parameters to lazily compute them once needed", "\n", "self", ".", "mins", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search.MaxValueEntropySearch.update_parameters": [[56, 83], ["core.initial_designs.RandomDesign", "core.initial_designs.RandomDesign.get_samples", "numpy.vstack", "max_value_entropy_search.MaxValueEntropySearch.model.predict", "numpy.sqrt", "max_value_entropy_search._fit_gumbel", "numpy.random.rand", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search._fit_gumbel"], ["", "def", "update_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        MES requires acces to a sample of possible minimum values y* of the objective function.\n        To build this sample we approximate the empirical c.d.f of Pr(y*<y) with a Gumbel(a,b) distribution.\n        This Gumbel distribution can then be easily sampled to yield approximate samples of y*\n\n        This needs to be called once at the start of each BO step.\n        \"\"\"", "\n", "\n", "# First we generate a random grid of locations at which to fit the Gumbel distribution", "\n", "random_design", "=", "RandomDesign", "(", "self", ".", "space", ")", "\n", "grid", "=", "random_design", ".", "get_samples", "(", "self", ".", "grid_size", ")", "\n", "# also add the locations already queried in the previous BO steps", "\n", "grid", "=", "np", ".", "vstack", "(", "[", "self", ".", "model", ".", "X", ",", "grid", "]", ")", "\n", "# Get GP posterior at these points", "\n", "fmean", ",", "fvar", "=", "self", ".", "model", ".", "predict", "(", "grid", ")", "\n", "fsd", "=", "np", ".", "sqrt", "(", "fvar", ")", "\n", "\n", "# fit Gumbel distriubtion", "\n", "a", ",", "b", "=", "_fit_gumbel", "(", "fmean", ",", "fsd", ")", "\n", "\n", "# sample K times from this Gumbel distribution using the inverse probability integral transform,", "\n", "# i.e. given a sample r ~ Unif[0,1] then g = a + b * log( -1 * log(1 - r)) follows g ~ Gumbel(a,b).", "\n", "\n", "uniform_samples", "=", "np", ".", "random", ".", "rand", "(", "self", ".", "num_samples", ")", "\n", "gumbel_samples", "=", "np", ".", "log", "(", "-", "1", "*", "np", ".", "log", "(", "1", "-", "uniform_samples", ")", ")", "*", "b", "+", "a", "\n", "self", ".", "mins", "=", "gumbel_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search.MaxValueEntropySearch._required_parameters_initialized": [[84, 89], ["None"], "methods", ["None"], ["", "def", "_required_parameters_initialized", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Checks if all required parameters are initialized.\n        \"\"\"", "\n", "return", "self", ".", "mins", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search.MaxValueEntropySearch.evaluate": [[90, 115], ["max_value_entropy_search.MaxValueEntropySearch.model.predict", "numpy.sqrt", "numpy.maximum", "numpy.clip", "numpy.mean", "numpy.mean.reshape", "max_value_entropy_search.MaxValueEntropySearch._required_parameters_initialized", "max_value_entropy_search.MaxValueEntropySearch.update_parameters", "scipy.stats.norm.cdf", "numpy.log", "scipy.stats.norm.pdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._required_parameters_initialized", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the information gain, i.e the predicted change in entropy of p_min (the distribution\n        of the minimal value of the objective function) if we evaluate x.\n        :param x: points where the acquisition is evaluated.\n        \"\"\"", "\n", "if", "not", "self", ".", "_required_parameters_initialized", "(", ")", ":", "\n", "            ", "self", ".", "update_parameters", "(", ")", "\n", "\n", "# Calculate GP posterior at candidate points", "\n", "", "fmean", ",", "fvar", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "fsd", "=", "np", ".", "sqrt", "(", "fvar", ")", "\n", "# Clip below to improve numerical stability", "\n", "fsd", "=", "np", ".", "maximum", "(", "fsd", ",", "1e-10", ")", "\n", "\n", "# standardise", "\n", "gamma", "=", "(", "self", ".", "mins", "-", "fmean", ")", "/", "fsd", "\n", "\n", "minus_cdf", "=", "1", "-", "norm", ".", "cdf", "(", "gamma", ")", "\n", "# Clip  to improve numerical stability", "\n", "minus_cdf", "=", "np", ".", "clip", "(", "minus_cdf", ",", "a_min", "=", "1e-10", ",", "a_max", "=", "1", ")", "\n", "\n", "# calculate monte-carlo estimate of information gain", "\n", "f_acqu_x", "=", "np", ".", "mean", "(", "-", "gamma", "*", "norm", ".", "pdf", "(", "gamma", ")", "/", "(", "2", "*", "minus_cdf", ")", "-", "np", ".", "log", "(", "minus_cdf", ")", ",", "axis", "=", "1", ")", "\n", "return", "f_acqu_x", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search.MaxValueEntropySearch.has_gradients": [[116, 120], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Returns that this acquisition has gradients\"\"\"", "\n", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search.MUMBO.__init__": [[154, 205], ["max_value_entropy_search._find_source_parameter", "max_value_entropy_search.MaxValueEntropySearch.__init__", "isinstance", "RuntimeError", "max"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search._find_source_parameter", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Union", "[", "IModel", ",", "IEntropySearchModel", "]", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "target_information_source_index", ":", "int", "=", "None", ",", "\n", "num_samples", ":", "int", "=", "10", ",", "\n", "grid_size", ":", "int", "=", "5000", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "\"\"\"\n        MUMBO acquisition function approximates the distribution of the value at the global\n        minimum and tries to decrease its entropy.\n        This is a multi-fidelity/multi-task extension of max-value entropy search (MES) suitiable\n        for multi-information source problems where the objective function is the output of one\n        of the information sources. The other information sources provide auxiliary\n        information about the objective function\n        See this paper for more details:\n        Moss et al.\n        MUMBO: MUlti-task Max-value Bayesian Optimisation\n        ECML 2020\n\n        :param model: GP model to compute the distribution of the minimum dubbed pmin.\n        :param space: Domain space which we need for the sampling of the representer points\n        :param target_information_source_index: The index of the information source we want to minimise\n        :param num_samples: integer determining how many samples to draw of the minimum (does not need to be large)\n        :param grid_size: number of random locations in grid used to fit the gumbel distribution and approximately generate\n                          the samples of the minimum (recommend scaling with problem dimension, i.e. 10000*d)\n        \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "IEntropySearchModel", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Model is not supported for MES\"", ")", "\n", "\n", "# Find information source parameter in parameter space", "\n", "", "info_source_parameter", ",", "source_idx", "=", "_find_source_parameter", "(", "space", ")", "\n", "self", ".", "source_idx", "=", "source_idx", "\n", "\n", "# If not told otherwise assume we are in a multi-fidelity setting", "\n", "# and the highest index is the highest fidelity", "\n", "if", "target_information_source_index", "is", "None", ":", "\n", "            ", "target_information_source_index", "=", "max", "(", "info_source_parameter", ".", "domain", ")", "\n", "", "self", ".", "target_information_source_index", "=", "target_information_source_index", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "space", "=", "space", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "self", ".", "grid_size", "=", "grid_size", "\n", "\n", "# Initialize parameters to lazily compute them once needed", "\n", "self", ".", "mins", "=", "None", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "model", ",", "space", ",", "num_samples", ",", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search.MUMBO.update_parameters": [[206, 236], ["core.initial_designs.RandomDesign", "core.initial_designs.RandomDesign.get_samples", "numpy.vstack", "numpy.delete", "numpy.insert", "max_value_entropy_search.MUMBO.model.predict", "numpy.sqrt", "max_value_entropy_search._fit_gumbel", "numpy.random.rand", "numpy.ones", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search._fit_gumbel"], ["", "def", "update_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        MUMBO requires acces to a sample of possible minimum values y* of the objective function.\n        To build this sample we approximate the empirical c.d.f of Pr(y*<y) with a Gumbel(a,b) distribution.\n        This Gumbel distribution can then be easily sampled to yield approximate samples of y*\n\n        This needs to be called once at the start of each BO step.\n        \"\"\"", "\n", "\n", "# First we generate a random grid of locations at which to fit the Gumbel distribution", "\n", "random_design", "=", "RandomDesign", "(", "self", ".", "space", ")", "\n", "grid", "=", "random_design", ".", "get_samples", "(", "self", ".", "grid_size", ")", "\n", "# also add the locations already queried in the previous BO steps", "\n", "grid", "=", "np", ".", "vstack", "(", "[", "self", ".", "model", ".", "X", ",", "grid", "]", ")", "\n", "# remove current fidelity index from sample", "\n", "grid", "=", "np", ".", "delete", "(", "grid", ",", "self", ".", "source_idx", ",", "axis", "=", "1", ")", "\n", "# Add objective function fidelity index to sample", "\n", "idx", "=", "np", ".", "ones", "(", "(", "grid", ".", "shape", "[", "0", "]", ")", ")", "*", "self", ".", "target_information_source_index", "\n", "grid", "=", "np", ".", "insert", "(", "grid", ",", "self", ".", "source_idx", ",", "idx", ",", "axis", "=", "1", ")", "\n", "# Get GP posterior at these points", "\n", "fmean", ",", "fvar", "=", "self", ".", "model", ".", "predict", "(", "grid", ")", "\n", "fsd", "=", "np", ".", "sqrt", "(", "fvar", ")", "\n", "\n", "# fit Gumbel distriubtion", "\n", "a", ",", "b", "=", "_fit_gumbel", "(", "fmean", ",", "fsd", ")", "\n", "\n", "# sample K times from this Gumbel distribution", "\n", "uniform_samples", "=", "np", ".", "random", ".", "rand", "(", "self", ".", "num_samples", ")", "\n", "gumbel_samples", "=", "-", "np", ".", "log", "(", "-", "np", ".", "log", "(", "uniform_samples", ")", ")", "*", "b", "+", "a", "\n", "self", ".", "mins", "=", "gumbel_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search.MUMBO.evaluate": [[237, 310], ["max_value_entropy_search.MUMBO.model.predict", "numpy.sqrt", "numpy.maximum", "numpy.delete", "numpy.insert", "max_value_entropy_search.MUMBO.model.predict", "numpy.sqrt", "numpy.maximum", "numpy.array().reshape", "numpy.clip", "numpy.clip", "numpy.maximum", "numpy.linspace", "numpy.sqrt", "numpy.maximum", "scipy.integrate.simps", "numpy.mean", "f_acqu_x.reshape", "max_value_entropy_search.MUMBO._required_parameters_initialized", "max_value_entropy_search.MUMBO.update_parameters", "numpy.ones", "max_value_entropy_search.MUMBO.model.get_covariance_between_points", "scipy.stats.norm.cdf", "numpy.log", "x[].reshape", "x_target_fidelity[].reshape", "range", "numpy.array", "scipy.stats.norm.pdf", "numpy.sqrt", "numpy.sqrt", "scipy.stats.norm.pdf", "numpy.log", "scipy.stats.norm.cdf", "numpy.zeros_like", "scipy.stats.norm.pdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._required_parameters_initialized", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_covariance_between_points"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the information gain, i.e the change in entropy of p_min (the distribution\n        of the minimal value of the objective function) if we would evaluate x.\n        :param x: points where the acquisition is evaluated.\n        \"\"\"", "\n", "if", "not", "self", ".", "_required_parameters_initialized", "(", ")", ":", "\n", "            ", "self", ".", "update_parameters", "(", ")", "\n", "\n", "# Calculate GP posterior at candidate points", "\n", "", "fmean", ",", "fvar", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "fsd", "=", "np", ".", "sqrt", "(", "fvar", ")", "\n", "# clip below for numerical stability", "\n", "fsd", "=", "np", ".", "maximum", "(", "fsd", ",", "1e-10", ")", "\n", "\n", "# Also need posterior at locations with same search-space positions as x but on the objective function g", "\n", "# remove current fidelity index from sample", "\n", "x_target_fidelity", "=", "np", ".", "delete", "(", "x", ",", "self", ".", "source_idx", ",", "axis", "=", "1", ")", "\n", "# Add target fidelity index to sample", "\n", "idx", "=", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "0", "]", ")", ")", "*", "self", ".", "target_information_source_index", "\n", "x_target_fidelity", "=", "np", ".", "insert", "(", "x_target_fidelity", ",", "self", ".", "source_idx", ",", "idx", ",", "axis", "=", "1", ")", "\n", "gmean", ",", "gvar", "=", "self", ".", "model", ".", "predict", "(", "x_target_fidelity", ")", "\n", "gsd", "=", "np", ".", "sqrt", "(", "gvar", ")", "\n", "# clip below for numerical stability", "\n", "gsd", "=", "np", ".", "maximum", "(", "gsd", ",", "1e-10", ")", "\n", "\n", "# also get pair-wise correlations between GP at x and x_target_fidelity", "\n", "# faster to do for loop rather than vectorize to avoid unecessary between term covariance calculations", "\n", "covariances", "=", "[", "\n", "self", ".", "model", ".", "get_covariance_between_points", "(", "x", "[", "i", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "x_target_fidelity", "[", "i", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "x", ".", "shape", "[", "0", "]", ")", "\n", "]", "\n", "covariances", "=", "np", ".", "array", "(", "covariances", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "correlations", "=", "covariances", "/", "(", "fsd", "*", "gsd", ")", "\n", "# clip for numerical stability", "\n", "correlations", "=", "np", ".", "clip", "(", "correlations", ",", "-", "1", ",", "1", ")", "\n", "\n", "# Calculate variance of extended skew Gaussian distributions (ESG)", "\n", "# These will be used to define reasonable ranges for the numerical", "\n", "# intergration of the ESG's differential entropy.", "\n", "gammas", "=", "(", "self", ".", "mins", "-", "fmean", ")", "/", "fsd", "\n", "minus_cdf", "=", "1", "-", "norm", ".", "cdf", "(", "gammas", ")", "\n", "# Clip  to improve numerical stability", "\n", "minus_cdf", "=", "np", ".", "clip", "(", "minus_cdf", ",", "a_min", "=", "1e-10", ",", "a_max", "=", "1", ")", "\n", "ESGmean", "=", "correlations", "*", "(", "norm", ".", "pdf", "(", "gammas", ")", ")", "/", "minus_cdf", "\n", "ESGvar", "=", "1", "+", "correlations", "*", "ESGmean", "*", "(", "gammas", "-", "norm", ".", "pdf", "(", "gammas", ")", "/", "minus_cdf", ")", "\n", "# Clip  to improve numerical stability", "\n", "ESGvar", "=", "np", ".", "maximum", "(", "ESGvar", ",", "0", ")", "\n", "\n", "# get upper limits for numerical integration", "\n", "# we need this range to contain almost all of the ESG's probability density", "\n", "# we found +-8 standard deviations provides a tight enough approximation", "\n", "upper_limit", "=", "ESGmean", "+", "8", "*", "np", ".", "sqrt", "(", "ESGvar", ")", "\n", "lower_limit", "=", "ESGmean", "-", "8", "*", "np", ".", "sqrt", "(", "ESGvar", ")", "\n", "\n", "# perform numerical integrations", "\n", "# build discretisation", "\n", "z", "=", "np", ".", "linspace", "(", "lower_limit", ",", "upper_limit", ",", "num", "=", "5000", ")", "\n", "# calculate ESG density at these points", "\n", "minus_correlations", "=", "np", ".", "sqrt", "(", "1", "-", "correlations", "**", "2", ")", "\n", "# clip below for numerical stability", "\n", "minus_correlations", "=", "np", ".", "maximum", "(", "minus_correlations", ",", "1e-10", ")", "\n", "density", "=", "norm", ".", "pdf", "(", "z", ")", "*", "(", "1", "-", "norm", ".", "cdf", "(", "(", "gammas", "-", "correlations", "*", "z", ")", "/", "minus_correlations", ")", ")", "/", "minus_cdf", "\n", "# calculate point-wise entropy function contributions (carefuly where density is 0)", "\n", "entropy_function", "=", "-", "density", "*", "np", ".", "log", "(", "density", ",", "out", "=", "np", ".", "zeros_like", "(", "density", ")", ",", "where", "=", "(", "density", "!=", "0", ")", ")", "\n", "# perform integration over ranges", "\n", "approximate_entropy", "=", "simps", "(", "entropy_function", ".", "T", ",", "z", ".", "T", ")", "\n", "# build monte-carlo estimate over the gumbel samples", "\n", "approximate_entropy", "=", "np", ".", "mean", "(", "approximate_entropy", ",", "axis", "=", "0", ")", "\n", "\n", "# build MUMBO acquisition function", "\n", "f_acqu_x", "=", "0.5", "*", "np", ".", "log", "(", "2", "*", "np", ".", "pi", "*", "np", ".", "e", ")", "-", "approximate_entropy", "\n", "return", "f_acqu_x", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search._fit_gumbel": [[122, 151], ["numpy.min", "numpy.max", "map", "scipy.optimize.bisect", "numpy.exp", "numpy.log", "numpy.log", "numpy.log", "numpy.sum", "numpy.log", "numpy.log", "numpy.log", "scipy.stats.norm.logcdf", "max_value_entropy_search._fit_gumbel.probf"], "function", ["None"], ["", "", "def", "_fit_gumbel", "(", "fmean", ",", "fsd", ")", ":", "\n", "    ", "\"\"\"\n    Helper function to fit gumbel distribution when initialising the MES and MUMBO acquisition functions.\n\n    The Gumbel distribution for minimas has a cumulative density function of f(y)= 1 - exp(-1 * exp((y - a) / b)), i.e. the q^th quantile is given by\n    Q(q) = a + b * log( -1 * log(1 - q)). We choose values for a and b that match the Gumbel's\n    interquartile range with that of the observed empirical cumulative density function of Pr(y*<y)\n    i.e.  Pr(y* < lower_quantile)=0.25 and Pr(y* < upper_quantile)=0.75.\n    \"\"\"", "\n", "\n", "def", "probf", "(", "x", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "# Build empirical CDF function", "\n", "        ", "return", "1", "-", "np", ".", "exp", "(", "np", ".", "sum", "(", "norm", ".", "logcdf", "(", "-", "(", "x", "-", "fmean", ")", "/", "fsd", ")", ",", "axis", "=", "0", ")", ")", "\n", "\n", "# initialise end-points for binary search (the choice of 5 standard deviations ensures that these are outside the IQ range)", "\n", "", "left", "=", "np", ".", "min", "(", "fmean", "-", "5", "*", "fsd", ")", "\n", "right", "=", "np", ".", "max", "(", "fmean", "+", "5", "*", "fsd", ")", "\n", "\n", "def", "binary_search", "(", "val", ":", "float", ")", "->", "float", ":", "\n", "        ", "return", "bisect", "(", "lambda", "x", ":", "probf", "(", "x", ")", "-", "val", ",", "left", ",", "right", ",", "maxiter", "=", "10000", ")", "\n", "\n", "# Binary search for 3 percentiles", "\n", "", "lower_quantile", ",", "medium", ",", "upper_quantile", "=", "map", "(", "binary_search", ",", "[", "0.25", ",", "0.5", ",", "0.75", "]", ")", "\n", "\n", "# solve for Gumbel scaling parameters", "\n", "b", "=", "(", "lower_quantile", "-", "upper_quantile", ")", "/", "(", "np", ".", "log", "(", "np", ".", "log", "(", "4.0", "/", "3.0", ")", ")", "-", "np", ".", "log", "(", "np", ".", "log", "(", "4.0", ")", ")", ")", "\n", "a", "=", "medium", "-", "b", "*", "np", ".", "log", "(", "np", ".", "log", "(", "2.0", ")", ")", "\n", "\n", "return", "a", ",", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.max_value_entropy_search._find_source_parameter": [[312, 325], ["enumerate", "isinstance", "ValueError"], "function", ["None"], ["", "", "def", "_find_source_parameter", "(", "space", ")", ":", "\n", "# Find information source parameter in parameter space", "\n", "    ", "info_source_parameter", "=", "None", "\n", "source_idx", "=", "None", "\n", "for", "i", ",", "param", "in", "enumerate", "(", "space", ".", "parameters", ")", ":", "\n", "        ", "if", "isinstance", "(", "param", ",", "InformationSourceParameter", ")", ":", "\n", "            ", "info_source_parameter", "=", "param", "\n", "source_idx", "=", "i", "\n", "\n", "", "", "if", "info_source_parameter", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"No information source parameter found in the parameter space\"", ")", "\n", "\n", "", "return", "info_source_parameter", ",", "source_idx", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.probability_of_improvement.ProbabilityOfImprovement.__init__": [[15, 27], ["float"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "Union", "[", "IModel", ",", "IDifferentiable", "]", ",", "jitter", ":", "float", "=", "float", "(", "0", ")", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        This acquisition computes for a given input point the probability of improving over the\n        currently best observed function value. For more information see:\n        Efficient Global Optimization of Expensive Black-Box Functions\n        Jones, Donald R. and Schonlau, Matthias and Welch, William J.\n        Journal of Global Optimization\n        :param model: The underlying model that provides the predictive mean and variance for the given test points\n        :param jitter: Jitter to balance exploration / exploitation\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "jitter", "=", "jitter", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.probability_of_improvement.ProbabilityOfImprovement.evaluate": [[28, 40], ["probability_of_improvement.ProbabilityOfImprovement.model.predict", "numpy.sqrt", "numpy.min", "scipy.stats.norm.cdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the probability of improving over the current best\n        :param x: points where the acquisition is evaluated, shape (number of points, number of dimensions).\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "mean", "+=", "self", ".", "jitter", "\n", "\n", "standard_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "y_minimum", "=", "np", ".", "min", "(", "self", ".", "model", ".", "Y", ",", "axis", "=", "0", ")", "\n", "cdf", "=", "scipy", ".", "stats", ".", "norm", ".", "cdf", "(", "y_minimum", ",", "mean", ",", "standard_deviation", ")", "\n", "return", "cdf", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.probability_of_improvement.ProbabilityOfImprovement.evaluate_with_gradients": [[41, 61], ["probability_of_improvement.ProbabilityOfImprovement.model.predict", "numpy.sqrt", "probability_of_improvement.ProbabilityOfImprovement.model.get_prediction_gradients", "numpy.min", "scipy.stats.norm.pdf", "scipy.stats.norm.cdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Computes the  probability of improving over the current best and its derivative\n        :param x: points where the acquisition is evaluated, shape (number of points, number of dimensions).\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "standard_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "\n", "dmean_dx", ",", "dvariance_dx", "=", "self", ".", "model", ".", "get_prediction_gradients", "(", "x", ")", "\n", "dstandard_devidation_dx", "=", "dvariance_dx", "/", "(", "2", "*", "standard_deviation", ")", "\n", "\n", "y_minimum", "=", "np", ".", "min", "(", "self", ".", "model", ".", "Y", ",", "axis", "=", "0", ")", "\n", "\n", "mean", "+=", "self", ".", "jitter", "\n", "u", "=", "(", "y_minimum", "-", "mean", ")", "/", "standard_deviation", "\n", "pdf", "=", "scipy", ".", "stats", ".", "norm", ".", "pdf", "(", "y_minimum", ",", "mean", ",", "standard_deviation", ")", "\n", "cdf", "=", "scipy", ".", "stats", ".", "norm", ".", "cdf", "(", "y_minimum", ",", "mean", ",", "standard_deviation", ")", "\n", "dcdf_dx", "=", "-", "pdf", "*", "(", "dmean_dx", "+", "dstandard_devidation_dx", "*", "u", ")", "\n", "\n", "return", "cdf", ",", "dcdf_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.probability_of_improvement.ProbabilityOfImprovement.has_gradients": [[62, 65], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "return", "isinstance", "(", "self", ".", "model", ",", "IDifferentiable", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.__init__": [[21, 94], ["core.acquisition.Acquisition.__init__", "isinstance", "RuntimeError", "samplers.AffineInvariantEnsembleSampler", "acquisitions.ExpectedImprovement", "scipy.stats.norm.ppf", "space.check_points_in_domain", "numpy.linspace", "len", "numpy.log", "numpy.array", "numpy.clip", "acquisitions.ExpectedImprovement.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Union", "[", "IModel", ",", "IEntropySearchModel", "]", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "sampler", ":", "McmcSampler", "=", "None", ",", "\n", "num_samples", ":", "int", "=", "100", ",", "\n", "num_representer_points", ":", "int", "=", "50", ",", "\n", "proposal_function", ":", "Callable", "=", "None", ",", "\n", "burn_in_steps", ":", "int", "=", "50", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "\"\"\"\n        Entropy Search acquisition function approximates the distribution of the global\n        minimum and tries to decrease its entropy. See this paper for more details:\n\n        P. Hennig and C. J. Schuler\n        Entropy search for information-efficient global optimization\n        Journal of Machine Learning Research, 13, 2012\n\n        :param model: GP model to compute the distribution of the minimum dubbed pmin.\n        :param space: Domain space which we need for the sampling of the representer points\n        :param sampler: mcmc sampler for representer points\n        :param num_samples: integer determining how many samples to draw for each candidate input\n        :param num_representer_points: integer determining how many representer points to sample\n        :param proposal_function: Function that defines an unnormalized log proposal measure from which to sample the\n        representer points. The default is expected improvement.\n        :param burn_in_steps: integer that defines the number of burn-in steps when sampling the representer points\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "IEntropySearchModel", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Model is not supported for Entropy Search\"", ")", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "num_representer_points", "=", "num_representer_points", "\n", "self", ".", "burn_in_steps", "=", "burn_in_steps", "\n", "\n", "if", "sampler", "is", "None", ":", "\n", "            ", "self", ".", "sampler", "=", "AffineInvariantEnsembleSampler", "(", "space", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "sampler", "=", "sampler", "\n", "\n", "# (unnormalized) density from which to sample the representer points to approximate pmin", "\n", "", "if", "proposal_function", "is", "None", ":", "\n", "\n", "            ", "ei", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "def", "prop_func", "(", "x", ")", ":", "\n", "                ", "if", "len", "(", "x", ".", "shape", ")", "==", "1", ":", "\n", "                    ", "x_", "=", "x", "[", "None", ",", ":", "]", "\n", "", "else", ":", "\n", "                    ", "x_", "=", "x", "\n", "\n", "", "if", "space", ".", "check_points_in_domain", "(", "x_", ")", ":", "\n", "                    ", "return", "np", ".", "log", "(", "np", ".", "clip", "(", "ei", ".", "evaluate", "(", "x_", ")", "[", "0", "]", ",", "0.0", ",", "np", ".", "PINF", ")", ")", "\n", "", "else", ":", "\n", "                    ", "return", "np", ".", "array", "(", "[", "np", ".", "NINF", "]", ")", "\n", "\n", "", "", "self", ".", "proposal_function", "=", "prop_func", "\n", "", "else", ":", "\n", "            ", "self", ".", "proposal_function", "=", "proposal_function", "\n", "\n", "# This is used later to calculate derivative of the stochastic part for the loss function", "\n", "# Derived following Ito's Lemma, see for example https://en.wikipedia.org/wiki/It%C3%B4%27s_lemma", "\n", "", "self", ".", "W", "=", "scipy", ".", "stats", ".", "norm", ".", "ppf", "(", "np", ".", "linspace", "(", "1.0", "/", "(", "num_samples", "+", "1", ")", ",", "1", "-", "1.0", "/", "(", "num_samples", "+", "1", ")", ",", "num_samples", ")", ")", "[", "\n", "np", ".", "newaxis", ",", ":", "\n", "]", "\n", "\n", "# Initialize parameters to lazily compute them once needed", "\n", "self", ".", "representer_points", "=", "None", "\n", "self", ".", "representer_points_log", "=", "None", "\n", "self", ".", "logP", "=", "None", "\n", "self", ".", "p_min_entropy", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._sample_representer_points": [[95, 115], ["entropy_search.EntropySearch.sampler.get_samples", "numpy.any", "numpy.any", "RuntimeError", "numpy.where", "len", "list", "numpy.isnan", "numpy.isposinf", "numpy.isneginf", "set", "set", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples"], ["", "def", "_sample_representer_points", "(", "self", ")", "->", "tuple", ":", "\n", "        ", "\"\"\"Samples a new set of representer points from the proposal measurement\"\"\"", "\n", "\n", "repr_points", ",", "repr_points_log", "=", "self", ".", "sampler", ".", "get_samples", "(", "\n", "self", ".", "num_representer_points", ",", "self", ".", "proposal_function", ",", "self", ".", "burn_in_steps", "\n", ")", "\n", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "repr_points_log", ")", ")", "or", "np", ".", "any", "(", "np", ".", "isposinf", "(", "repr_points_log", ")", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"Sampler generated representer points with invalid log values: {}\"", ".", "format", "(", "repr_points_log", ")", "\n", ")", "\n", "\n", "# Removing representer points that have 0 probability of being the minimum", "\n", "", "idx_to_remove", "=", "np", ".", "where", "(", "np", ".", "isneginf", "(", "repr_points_log", ")", ")", "[", "0", "]", "\n", "if", "len", "(", "idx_to_remove", ")", ">", "0", ":", "\n", "            ", "idx", "=", "list", "(", "set", "(", "range", "(", "self", ".", "num_representer_points", ")", ")", "-", "set", "(", "idx_to_remove", ")", ")", "\n", "repr_points", "=", "repr_points", "[", "idx", ",", ":", "]", "\n", "repr_points_log", "=", "repr_points_log", "[", "idx", "]", "\n", "\n", "", "return", "repr_points", ",", "repr_points_log", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.update_parameters": [[116, 121], ["entropy_search.EntropySearch.update_pmin"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.update_pmin"], ["", "def", "update_parameters", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Updates p_min parameter\n        \"\"\"", "\n", "self", ".", "update_pmin", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.update_pmin": [[122, 145], ["entropy_search.EntropySearch._sample_representer_points", "entropy_search.EntropySearch.model.predict", "numpy.ndarray.flatten", "entropy_search.EntropySearch.model.predict_covariance", "epmgp.joint_min", "numpy.sum", "numpy.multiply", "numpy.exp", "numpy.add"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch._sample_representer_points", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.predict_covariance", "home.repos.pwc.inspect_result.amzn_emukit.bayesian_optimization.epmgp.joint_min"], ["", "def", "update_pmin", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Approximates the distribution of the global optimum  p(x=x_star|D) by doing the following steps:\n            - discretizing the input space by representer points sampled from a proposal measure (default EI)\n            - predicting mean and the covariance matrix of these representer points\n            - uses EPMGP algorithm to compute the probability of each representer point being the minimum\n        \"\"\"", "\n", "\n", "self", ".", "representer_points", ",", "self", ".", "representer_points_log", "=", "self", ".", "_sample_representer_points", "(", ")", "\n", "\n", "mu", ",", "_", "=", "self", ".", "model", ".", "predict", "(", "self", ".", "representer_points", ")", "\n", "mu", "=", "np", ".", "ndarray", ".", "flatten", "(", "mu", ")", "\n", "var", "=", "self", ".", "model", ".", "predict_covariance", "(", "self", ".", "representer_points", ")", "\n", "\n", "self", ".", "logP", ",", "self", ".", "dlogPdMu", ",", "self", ".", "dlogPdSigma", ",", "self", ".", "dlogPdMudMu", "=", "epmgp", ".", "joint_min", "(", "mu", ",", "var", ",", "with_derivatives", "=", "True", ")", "\n", "self", ".", "logP", "=", "self", ".", "logP", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "# Calculate the entropy of the distribution over the minimum given the current model", "\n", "self", ".", "p_min_entropy", "=", "np", ".", "sum", "(", "\n", "np", ".", "multiply", "(", "np", ".", "exp", "(", "self", ".", "logP", ")", ",", "np", ".", "add", "(", "self", ".", "logP", ",", "self", ".", "representer_points_log", ")", ")", ",", "axis", "=", "0", "\n", ")", "\n", "\n", "return", "self", ".", "logP", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._required_parameters_initialized": [[146, 151], ["None"], "methods", ["None"], ["", "def", "_required_parameters_initialized", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Checks if all required parameters are initialized.\n        \"\"\"", "\n", "return", "not", "(", "self", ".", "representer_points", "is", "None", "or", "self", ".", "representer_points_log", "is", "None", "or", "self", ".", "logP", "is", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.evaluate": [[152, 208], ["entropy_search.EntropySearch._innovations", "dMdx.dot", "entropy_search.EntropySearch.dlogPdMu.dot().dot", "numpy.add", "numpy.amax", "numpy.subtract", "numpy.sum", "numpy.mean", "entropy_change.reshape", "entropy_search.EntropySearch._required_parameters_initialized", "entropy_search.EntropySearch.update_pmin", "numpy.zeros", "range", "numpy.sum", "entropy_search.EntropySearch.dlogPdSigma.dot", "numpy.log", "numpy.any", "numpy.multiply", "entropy_search.EntropySearch.evaluate", "numpy.sum", "entropy_search.EntropySearch.dlogPdMu.dot", "numpy.sum", "numpy.isinf", "numpy.exp", "numpy.add", "numpy.triu().T.astype", "numpy.multiply", "numpy.exp", "numpy.reshape", "numpy.triu", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._innovations", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._required_parameters_initialized", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.update_pmin", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the information gain, i.e the change in entropy of p_min if we would evaluate x.\n\n        :param x: points where the acquisition is evaluated.\n        \"\"\"", "\n", "if", "not", "self", ".", "_required_parameters_initialized", "(", ")", ":", "\n", "            ", "self", ".", "update_pmin", "(", ")", "\n", "\n", "# Check if we want to compute the acquisition function for multiple inputs", "\n", "", "if", "x", ".", "shape", "[", "0", "]", ">", "1", ":", "\n", "            ", "results", "=", "np", ".", "zeros", "(", "[", "x", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "\n", "for", "j", "in", "range", "(", "x", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "results", "[", "j", "]", "=", "self", ".", "evaluate", "(", "x", "[", "j", ",", "None", ",", ":", "]", ")", "\n", "", "return", "results", "\n", "\n", "# Number of representer points locations", "\n", "", "N", "=", "self", ".", "logP", ".", "size", "\n", "\n", "# Evaluate innovations, i.e how much does mean and variance at the", "\n", "# representer points change if we would evaluate x", "\n", "dMdx", ",", "dVdx", "=", "self", ".", "_innovations", "(", "x", ")", "\n", "\n", "dVdx", "=", "dVdx", "[", "np", ".", "triu", "(", "np", ".", "ones", "(", "(", "N", ",", "N", ")", ")", ")", ".", "T", ".", "astype", "(", "bool", ")", ",", "np", ".", "newaxis", "]", "\n", "\n", "dMdx_squared", "=", "dMdx", ".", "dot", "(", "dMdx", ".", "T", ")", "\n", "trace_term", "=", "np", ".", "sum", "(", "\n", "np", ".", "sum", "(", "\n", "np", ".", "multiply", "(", "\n", "self", ".", "dlogPdMudMu", ",", "np", ".", "reshape", "(", "dMdx_squared", ",", "(", "1", ",", "dMdx_squared", ".", "shape", "[", "0", "]", ",", "dMdx_squared", ".", "shape", "[", "1", "]", ")", ")", "\n", ")", ",", "\n", "2", ",", "\n", ")", ",", "\n", "1", ",", "\n", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "# Deterministic part of change:", "\n", "deterministic_change", "=", "self", ".", "dlogPdSigma", ".", "dot", "(", "dVdx", ")", "+", "0.5", "*", "trace_term", "\n", "# Stochastic part of change:", "\n", "stochastic_change", "=", "(", "self", ".", "dlogPdMu", ".", "dot", "(", "dMdx", ")", ")", ".", "dot", "(", "self", ".", "W", ")", "\n", "\n", "# Update our pmin distribution", "\n", "predicted_logP", "=", "np", ".", "add", "(", "self", ".", "logP", "+", "deterministic_change", ",", "stochastic_change", ")", "\n", "max_predicted_logP", "=", "np", ".", "amax", "(", "predicted_logP", ",", "axis", "=", "0", ")", "\n", "\n", "# normalize predictions", "\n", "max_diff", "=", "max_predicted_logP", "+", "np", ".", "log", "(", "np", ".", "sum", "(", "np", ".", "exp", "(", "predicted_logP", "-", "max_predicted_logP", ")", ",", "axis", "=", "0", ")", ")", "\n", "lselP", "=", "max_predicted_logP", "if", "np", ".", "any", "(", "np", ".", "isinf", "(", "max_diff", ")", ")", "else", "max_diff", "\n", "predicted_logP", "=", "np", ".", "subtract", "(", "predicted_logP", ",", "lselP", ")", "\n", "\n", "# We maximize the information gain", "\n", "H_p", "=", "np", ".", "sum", "(", "np", ".", "multiply", "(", "np", ".", "exp", "(", "predicted_logP", ")", ",", "np", ".", "add", "(", "predicted_logP", ",", "self", ".", "representer_points_log", ")", ")", ",", "axis", "=", "0", ")", "\n", "\n", "new_entropy", "=", "np", ".", "mean", "(", "H_p", ")", "\n", "entropy_change", "=", "new_entropy", "-", "self", ".", "p_min_entropy", "\n", "return", "entropy_change", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch._innovations": [[209, 227], ["numpy.sqrt", "entropy_search.EntropySearch.model.get_covariance_between_points", "entropy_search.EntropySearch.model.predict_covariance", "dm_rep.dot"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_covariance_between_points", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.predict_covariance"], ["", "def", "_innovations", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "tuple", ":", "\n", "        ", "\"\"\"\n        Computes the expected change in mean and variance at the representer\n        points (cf. Section 2.4 in the paper).\n\n        :param x: candidate for which to compute the expected change in the GP\n        \"\"\"", "\n", "\n", "# Get the standard deviation at x without noise", "\n", "stdev_x", "=", "np", ".", "sqrt", "(", "self", ".", "model", ".", "predict_covariance", "(", "x", ",", "with_noise", "=", "False", ")", ")", "\n", "\n", "# Compute the variance between the test point x and the representer points", "\n", "sigma_x_rep", "=", "self", ".", "model", ".", "get_covariance_between_points", "(", "self", ".", "representer_points", ",", "x", ")", "\n", "dm_rep", "=", "sigma_x_rep", "/", "stdev_x", "\n", "\n", "# Compute the deterministic innovation for the variance", "\n", "dv_rep", "=", "-", "dm_rep", ".", "dot", "(", "dm_rep", ".", "T", ")", "\n", "return", "dm_rep", ",", "dv_rep", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.has_gradients": [[228, 232], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Returns that this acquisition has gradients\"\"\"", "\n", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.MultiInformationSourceEntropySearch.__init__": [[240, 279], ["entropy_search._find_source_parameter", "space.parameters.copy", "space.parameters.copy.remove", "core.parameter_space.ParameterSpace", "samplers.AffineInvariantEnsembleSampler", "entropy_search.MultiInformationSourceEntropySearch._get_proposal_function", "entropy_search.EntropySearch.__init__", "max"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search._find_source_parameter", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch._get_proposal_function", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Union", "[", "IModel", ",", "IEntropySearchModel", "]", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "target_information_source_index", ":", "int", "=", "None", ",", "\n", "num_samples", ":", "int", "=", "100", ",", "\n", "num_representer_points", ":", "int", "=", "50", ",", "\n", "burn_in_steps", ":", "int", "=", "50", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param model: Gaussian process model of the objective function that implements IEntropySearchModel\n        :param space: Parameter space of the input domain\n        :param target_information_source_index: The index of the information source we want to minimise\n        :param num_samples: Integer determining how many samples to draw for each candidate input\n        :param num_representer_points: Integer determining how many representer points to sample\n        :param burn_in_steps: Integer that defines the number of burn-in steps when sampling the representer points\n        \"\"\"", "\n", "\n", "# Find information source parameter in parameter space", "\n", "info_source_parameter", ",", "source_idx", "=", "_find_source_parameter", "(", "space", ")", "\n", "self", ".", "source_idx", "=", "source_idx", "\n", "\n", "# Assume we are in a multi-fidelity setting and the highest index is the highest fidelity", "\n", "if", "target_information_source_index", "is", "None", ":", "\n", "            ", "target_information_source_index", "=", "max", "(", "info_source_parameter", ".", "domain", ")", "\n", "", "self", ".", "target_information_source_index", "=", "target_information_source_index", "\n", "\n", "# Sampler of representer points should sample x location at the target information source only so make a", "\n", "# parameter space without the information source parameter", "\n", "parameters_without_info_source", "=", "space", ".", "parameters", ".", "copy", "(", ")", "\n", "parameters_without_info_source", ".", "remove", "(", "info_source_parameter", ")", "\n", "space_without_info_source", "=", "ParameterSpace", "(", "parameters_without_info_source", ")", "\n", "\n", "# Create sampler of representer points", "\n", "sampler", "=", "AffineInvariantEnsembleSampler", "(", "space_without_info_source", ")", "\n", "\n", "proposal_func", "=", "self", ".", "_get_proposal_function", "(", "model", ",", "space", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "model", ",", "space", ",", "sampler", ",", "num_samples", ",", "num_representer_points", ",", "proposal_func", ",", "burn_in_steps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.MultiInformationSourceEntropySearch._sample_representer_points": [[280, 287], ["entropy_search.EntropySearch._sample_representer_points", "numpy.insert", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch._sample_representer_points"], ["", "def", "_sample_representer_points", "(", "self", ")", ":", "\n", "        ", "repr_points", ",", "repr_points_log", "=", "super", "(", ")", ".", "_sample_representer_points", "(", ")", "\n", "\n", "# Add fidelity index to representer points", "\n", "idx", "=", "np", ".", "ones", "(", "(", "repr_points", ".", "shape", "[", "0", "]", ")", ")", "*", "self", ".", "target_information_source_index", "\n", "repr_points", "=", "np", ".", "insert", "(", "repr_points", ",", "self", ".", "source_idx", ",", "idx", ",", "axis", "=", "1", ")", "\n", "return", "repr_points", ",", "repr_points_log", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.MultiInformationSourceEntropySearch._get_proposal_function": [[288, 310], ["acquisitions.ExpectedImprovement", "numpy.insert", "space.check_points_in_domain", "numpy.ones", "numpy.log", "numpy.any", "numpy.array", "numpy.clip", "numpy.isnan", "numpy.array", "acquisitions.ExpectedImprovement.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "_get_proposal_function", "(", "self", ",", "model", ",", "space", ")", ":", "\n", "\n", "# Define proposal function for multi-fidelity", "\n", "        ", "ei", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "def", "proposal_func", "(", "x", ")", ":", "\n", "            ", "x_", "=", "x", "[", "None", ",", ":", "]", "\n", "\n", "# Add information source parameter into array", "\n", "idx", "=", "np", ".", "ones", "(", "(", "x_", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "*", "self", ".", "target_information_source_index", "\n", "x_", "=", "np", ".", "insert", "(", "x_", ",", "self", ".", "source_idx", ",", "idx", ",", "axis", "=", "1", ")", "\n", "\n", "if", "space", ".", "check_points_in_domain", "(", "x_", ")", ":", "\n", "                ", "val", "=", "np", ".", "log", "(", "np", ".", "clip", "(", "ei", ".", "evaluate", "(", "x_", ")", "[", "0", "]", ",", "0.0", ",", "np", ".", "PINF", ")", ")", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "val", ")", ")", ":", "\n", "                    ", "return", "np", ".", "array", "(", "[", "np", ".", "NINF", "]", ")", "\n", "", "else", ":", "\n", "                    ", "return", "val", "\n", "", "", "else", ":", "\n", "                ", "return", "np", ".", "array", "(", "[", "np", ".", "NINF", "]", ")", "\n", "\n", "", "", "return", "proposal_func", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search._find_source_parameter": [[312, 325], ["enumerate", "isinstance", "ValueError"], "function", ["None"], ["", "", "def", "_find_source_parameter", "(", "space", ")", ":", "\n", "# Find information source parameter in parameter space", "\n", "    ", "info_source_parameter", "=", "None", "\n", "source_idx", "=", "None", "\n", "for", "i", ",", "param", "in", "enumerate", "(", "space", ".", "parameters", ")", ":", "\n", "        ", "if", "isinstance", "(", "param", ",", "InformationSourceParameter", ")", ":", "\n", "            ", "info_source_parameter", "=", "param", "\n", "source_idx", "=", "i", "\n", "\n", "", "", "if", "info_source_parameter", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"No information source parameter found in the parameter space\"", ")", "\n", "\n", "", "return", "info_source_parameter", ",", "source_idx", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.ExpectedImprovement.__init__": [[16, 31], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "Union", "[", "IModel", ",", "IDifferentiable", "]", ",", "jitter", ":", "float", "=", "0.0", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        For a given input, this acquisition computes the improvement over the current best observed value in\n        expectation. For more information see:\n\n        Efficient Global Optimization of Expensive Black-Box Functions\n        Jones, Donald R. and Schonlau, Matthias and Welch, William J.\n        Journal of Global Optimization\n\n        :param model: model that is used to compute the improvement.\n        :param jitter: parameter to encourage extra exploration.\n        \"\"\"", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "jitter", "=", "jitter", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.ExpectedImprovement.evaluate": [[32, 48], ["expected_improvement.ExpectedImprovement._get_model_predictions", "numpy.sqrt", "expected_improvement.ExpectedImprovement._get_y_minimum", "expected_improvement.get_standard_normal_pdf_cdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MeanPluginExpectedImprovement._get_model_predictions", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MeanPluginExpectedImprovement._get_y_minimum", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_standard_normal_pdf_cdf"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the Expected Improvement.\n\n        :param x: points where the acquisition is evaluated.\n        \"\"\"", "\n", "\n", "mean", ",", "variance", "=", "self", ".", "_get_model_predictions", "(", "x", ")", "\n", "standard_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "mean", "+=", "self", ".", "jitter", "\n", "\n", "y_minimum", "=", "self", ".", "_get_y_minimum", "(", ")", "\n", "u", ",", "pdf", ",", "cdf", "=", "get_standard_normal_pdf_cdf", "(", "y_minimum", ",", "mean", ",", "standard_deviation", ")", "\n", "improvement", "=", "standard_deviation", "*", "(", "u", "*", "cdf", "+", "pdf", ")", "\n", "\n", "return", "improvement", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.ExpectedImprovement.evaluate_with_gradients": [[49, 71], ["expected_improvement.ExpectedImprovement._get_model_predictions", "numpy.sqrt", "expected_improvement.ExpectedImprovement._get_y_minimum", "expected_improvement.ExpectedImprovement.model.get_prediction_gradients", "expected_improvement.get_standard_normal_pdf_cdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MeanPluginExpectedImprovement._get_model_predictions", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MeanPluginExpectedImprovement._get_y_minimum", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_standard_normal_pdf_cdf"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Computes the Expected Improvement and its derivative.\n\n        :param x: locations where the evaluation with gradients is done.\n        \"\"\"", "\n", "\n", "mean", ",", "variance", "=", "self", ".", "_get_model_predictions", "(", "x", ")", "\n", "standard_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "\n", "y_minimum", "=", "self", ".", "_get_y_minimum", "(", ")", "\n", "\n", "dmean_dx", ",", "dvariance_dx", "=", "self", ".", "model", ".", "get_prediction_gradients", "(", "x", ")", "\n", "dstandard_deviation_dx", "=", "dvariance_dx", "/", "(", "2", "*", "standard_deviation", ")", "\n", "\n", "mean", "+=", "self", ".", "jitter", "\n", "u", ",", "pdf", ",", "cdf", "=", "get_standard_normal_pdf_cdf", "(", "y_minimum", ",", "mean", ",", "standard_deviation", ")", "\n", "\n", "improvement", "=", "standard_deviation", "*", "(", "u", "*", "cdf", "+", "pdf", ")", "\n", "dimprovement_dx", "=", "dstandard_deviation_dx", "*", "pdf", "-", "cdf", "*", "dmean_dx", "\n", "\n", "return", "improvement", ",", "dimprovement_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.ExpectedImprovement.has_gradients": [[72, 76], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Returns that this acquisition has gradients\"\"\"", "\n", "return", "isinstance", "(", "self", ".", "model", ",", "IDifferentiable", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.ExpectedImprovement._get_model_predictions": [[77, 80], ["expected_improvement.ExpectedImprovement.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "_get_model_predictions", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Get model predictions for the function values at given input locations.\"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.ExpectedImprovement._get_y_minimum": [[81, 84], ["numpy.min"], "methods", ["None"], ["", "def", "_get_y_minimum", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Return the minimum value in the samples observed so far.\"\"\"", "\n", "return", "np", ".", "min", "(", "self", ".", "model", ".", "Y", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MeanPluginExpectedImprovement.__init__": [[87, 106], ["expected_improvement.ExpectedImprovement.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "IModelWithNoise", ",", "jitter", ":", "float", "=", "0.0", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        A variant of expected improvement that accounts for observation noise.\n\n        For a given input, this acquisition computes the expected improvement over the *mean* at the\n        best point observed so far.\n\n        This is a heuristic that allows Expected Improvement to deal with problems with noisy observations, where\n        the standard Expected Improvement might behave undesirably if the noise is too large.\n\n        For more information see:\n            \"A benchmark of kriging-based infill criteria for noisy optimization\" by Picheny et al.\n        Note: the model type should be Union[IPredictsWithNoise, Intersection[IpredictsWithNoise, IDifferentiable]].\n            Support for Intersection types might be added to Python in the future (see PEP 483)\n\n        :param model: model that is used to compute the improvement.\n        :param jitter: parameter to encourage extra exploration.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "model", "=", "model", ",", "jitter", "=", "jitter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MeanPluginExpectedImprovement._get_y_minimum": [[107, 111], ["expected_improvement.MeanPluginExpectedImprovement.model.predict_noiseless", "numpy.min"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.predict_noiseless"], ["", "def", "_get_y_minimum", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Return the smallest model mean prediction at the previously observed points.\"\"\"", "\n", "means_at_prev", ",", "_", "=", "self", ".", "model", ".", "predict_noiseless", "(", "self", ".", "model", ".", "X", ")", "\n", "return", "np", ".", "min", "(", "means_at_prev", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MeanPluginExpectedImprovement._get_model_predictions": [[112, 115], ["expected_improvement.MeanPluginExpectedImprovement.model.predict_noiseless"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.predict_noiseless"], ["", "def", "_get_model_predictions", "(", "self", ",", "x", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Return the likelihood-free (i.e. without observation noise) prediction from the model.\"\"\"", "\n", "return", "self", ".", "model", ".", "predict_noiseless", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement.__init__": [[135, 175], ["expected_improvement.ExpectedImprovement.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Union", "[", "IModel", ",", "IDifferentiable", ",", "IJointlyDifferentiable", "]", ",", "\n", "jitter", ":", "float", "=", "0.0", ",", "\n", "fast_compute", ":", "bool", "=", "False", ",", "\n", "eps", ":", "float", "=", "1e-3", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        This acquisition computes for a given input the improvement over the current best observed value in\n        expectation for multiple points. For more information see:\n\n        Efficient Global Optimization of Expensive Black-Box Functions\n        Jones, Donald R. and Schonlau, Matthias and Welch, William J.\n        Journal of Global Optimization\n\n        Implementation based on papers and their implementations:\n\n        Fast computation of the multipoint Expected Improvement with\n        applications in batch selection\n        Chevalier, C. and Ginsbourger, D.\n        International Conference on Learning and Intelligent Optimization.\n        Springer, Berlin, Heidelberg, 2013.\n\n        Gradient of the acquisition is derived in:\n\n        Differentiating the multipoint Expected Improvement for optimal batch design\n        Marmin, S., Chevalier, C. and Ginsbourger, D.\n        International Workshop on Machine Learning, Optimization and Big Data.\n        Springer, Cham, 2015.\n\n        Source code for both: https://github.com/cran/DiceOptim\n\n        :param model: model that is used to compute the improvement.\n        :param jitter: parameter to encourage extra exploration.\n        :param fast_compute: Whether to use faster approximative method.\n        :param eps: Grid length for numerical derivative in approximative method.\n        \"\"\"", "\n", "super", "(", "MultipointExpectedImprovement", ",", "self", ")", ".", "__init__", "(", "model", ",", "jitter", ")", "\n", "self", ".", "fast_compute", "=", "fast_compute", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement.evaluate": [[176, 186], ["expected_improvement.MultipointExpectedImprovement.model.predict_with_full_covariance", "numpy.min", "expected_improvement.MultipointExpectedImprovement._get_acquisition", "mean.flatten"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.predict_with_full_covariance", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_acquisition"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the multipoint Expected Improvement.\n\n        :param x: points where the acquisition is evaluated.\n        :return: multipoint Expected Improvement at the input.\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict_with_full_covariance", "(", "x", ")", "\n", "y_minimum", "=", "np", ".", "min", "(", "self", ".", "model", ".", "Y", ",", "axis", "=", "0", ")", "\n", "return", "-", "self", ".", "_get_acquisition", "(", "mean", ".", "flatten", "(", ")", ",", "variance", ",", "y_minimum", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement.evaluate_with_gradients": [[187, 202], ["expected_improvement.MultipointExpectedImprovement.model.predict_with_full_covariance", "mean.flatten.flatten.flatten", "numpy.min", "expected_improvement.MultipointExpectedImprovement._get_acquisition", "expected_improvement.MultipointExpectedImprovement.model.get_joint_prediction_gradients", "expected_improvement.MultipointExpectedImprovement._get_acquisition_gradient"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.predict_with_full_covariance", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_acquisition", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.get_joint_prediction_gradients", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_acquisition_gradient"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Computes the multipoint Expected Improvement and its derivative.\n\n        :param x: locations where the evaluation with gradients is done.\n        :return: multipoint Expected Improvement and its gradient at the input.\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict_with_full_covariance", "(", "x", ")", "\n", "mean", "=", "mean", ".", "flatten", "(", ")", "\n", "y_minimum", "=", "np", ".", "min", "(", "self", ".", "model", ".", "Y", ",", "axis", "=", "0", ")", "\n", "qei", ",", "pk", ",", "symmetric_term", "=", "self", ".", "_get_acquisition", "(", "mean", ",", "variance", ",", "y_minimum", ")", "\n", "\n", "mean_dx", ",", "variance_dx", "=", "self", ".", "model", ".", "get_joint_prediction_gradients", "(", "x", ")", "\n", "qei_grad", "=", "self", ".", "_get_acquisition_gradient", "(", "mean", ",", "variance", ",", "mean_dx", ",", "variance_dx", ",", "y_minimum", ",", "pk", ",", "symmetric_term", ")", "\n", "return", "-", "qei", ",", "-", "qei_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_acquisition": [[203, 240], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.sum", "expected_improvement.get_covariance_given_smallest", "numpy.zeros", "scipy.stats.multivariate_normal.cdf", "expected_improvement.MultipointExpectedImprovement._get_non_symmetric_and_symmetric_term_k", "numpy.diag", "numpy.sum", "numpy.sum", "numpy.zeros", "range", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_covariance_given_smallest", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_non_symmetric_and_symmetric_term_k"], ["", "def", "_get_acquisition", "(", "self", ",", "mu", ":", "np", ".", "ndarray", ",", "Sigma", ":", "np", ".", "ndarray", ",", "y_minimum", ":", "float", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Computes the multi point Expected Improvement. A helper function for the class.\n\n        :param mu: Prediction mean at locations where the evaluation is done.\n        :param Sigma: Prediction covariance at locations where the evaluation is done.\n        :param y_minimum: The best value evaluated so far by the black box function.\n        :return: Multipoint Expected Improvement where the mean and the covariance are evaluated.\n        \"\"\"", "\n", "q", "=", "mu", ".", "shape", "[", "0", "]", "\n", "pk", "=", "np", ".", "zeros", "(", "(", "q", ",", ")", ")", "\n", "first_term", "=", "np", ".", "zeros", "(", "(", "q", ",", ")", ")", "\n", "non_symmetric_term", "=", "np", ".", "zeros", "(", "(", "q", ",", "q", ")", ")", "\n", "symmetric_term", "=", "np", ".", "zeros", "(", "(", "q", ",", "q", ")", ")", "\n", "for", "k", "in", "range", "(", "q", ")", ":", "\n", "            ", "Sigma_k", "=", "get_covariance_given_smallest", "(", "Sigma", ",", "k", ")", "\n", "mu_k", "=", "mu", "[", "k", "]", "-", "mu", "\n", "mu_k", "[", "k", "]", "=", "mu", "[", "k", "]", "\n", "b_k", "=", "np", ".", "zeros", "(", "(", "q", ",", ")", ")", "\n", "b_k", "[", "k", "]", "=", "y_minimum", "\n", "\n", "pk", "[", "k", "]", "=", "scipy", ".", "stats", ".", "multivariate_normal", ".", "cdf", "(", "b_k", "-", "mu_k", ",", "np", ".", "zeros", "(", "(", "q", ",", ")", ")", ",", "Sigma_k", ")", "\n", "\n", "first_term", "[", "k", "]", "=", "(", "y_minimum", "-", "mu", "[", "k", "]", ")", "*", "pk", "[", "k", "]", "\n", "symmetric_term", "[", "k", ",", ":", "]", ",", "non_symmetric_term", "[", "k", ",", ":", "]", "=", "self", ".", "_get_non_symmetric_and_symmetric_term_k", "(", "\n", "b_k", ",", "mu_k", ",", "Sigma_k", ",", "pk", ",", "k", "\n", ")", "\n", "\n", "# Symmetrify the symmetric term", "\n", "", "symmetric_term", "=", "symmetric_term", "+", "symmetric_term", ".", "T", "\n", "symmetric_term", "[", "range", "(", "q", ")", ",", "range", "(", "q", ")", "]", "=", "0.5", "*", "np", ".", "diag", "(", "symmetric_term", ")", "\n", "second_term", "=", "np", ".", "sum", "(", "symmetric_term", "*", "non_symmetric_term", ")", "\n", "\n", "# See equation (3) in the paper for details:", "\n", "opt_val", "=", "np", ".", "sum", "(", "first_term", ")", "+", "np", ".", "sum", "(", "second_term", ")", "\n", "\n", "return", "opt_val", ",", "pk", ",", "symmetric_term", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_acquisition_gradient": [[241, 290], ["range", "numpy.zeros", "numpy.zeros", "L.copy", "expected_improvement.MultipointExpectedImprovement._gradient_of_the_acquisition_first_term", "numpy.diag", "expected_improvement.MultipointExpectedImprovement._gradient_of_the_acquisition_second_term", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._gradient_of_the_acquisition_first_term", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._gradient_of_the_acquisition_second_term"], ["", "def", "_get_acquisition_gradient", "(", "\n", "self", ",", "\n", "mu", ":", "np", ".", "ndarray", ",", "\n", "Sigma", ":", "np", ".", "ndarray", ",", "\n", "dmu_dx", ":", "np", ".", "ndarray", ",", "\n", "dSigma_dx", ":", "np", ".", "ndarray", ",", "\n", "y_minimum", ":", "float", ",", "\n", "pk", ":", "np", ".", "ndarray", ",", "\n", "symmetric_term", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the gradient of multi point Expected Improvement. A helper function for the class.\n\n        :param mu: Prediction mean at locations where the evaluation is done.\n        :param Sigma: Prediction covariance at locations where the evaluation is done.\n        :param dmu_dx: Prediction mean gradient at locations where the evaluation is done.\n        :param dSigma_dx: Prediction covariance gradient at locations where the evaluation is done.\n        :param y_minimum: The best value evaluated so far by the black box function.\n        :param pk: Probabilities of each random variable being smaller than the rest.\n        :param symmetric_term: A helper matrix generated by the acquistion function.\n        :return: Gradient of the multipoint Expected Improvement where the mean and the covariance are evaluated.\n        \"\"\"", "\n", "q", ",", "d", "=", "Sigma", ".", "shape", "[", "0", "]", ",", "dmu_dx", ".", "shape", "[", "2", "]", "\n", "\n", "# Initialize empty vectors", "\n", "grad", ",", "L", "=", "np", ".", "zeros", "(", "(", "q", ",", "d", ")", ")", ",", "-", "np", ".", "diag", "(", "np", ".", "ones", "(", "q", ")", ")", "\n", "\n", "# First sum of the formula", "\n", "for", "k", "in", "range", "(", "q", ")", ":", "\n", "            ", "bk", "=", "np", ".", "zeros", "(", "(", "q", ",", "1", ")", ")", "\n", "bk", "[", "k", ",", "0", "]", "=", "y_minimum", "# creation of vector b^(k)", "\n", "Lk", "=", "L", ".", "copy", "(", ")", "\n", "Lk", "[", ":", ",", "k", "]", "=", "1.0", "# linear application to transform Y to Zk", "\n", "mk", "=", "Lk", "@", "mu", "[", ":", ",", "None", "]", "# mean of Zk (written m^(k) in the formula)", "\n", "Sigk", "=", "Lk", "@", "Sigma", "@", "Lk", ".", "T", "# covariance of Zk", "\n", "Sigk", "=", "0.5", "*", "(", "Sigk", "+", "Sigk", ".", "T", ")", "# numerical symmetrization", "\n", "\n", "# Compute the first two terms of the gradient (First row of Equation (6))", "\n", "grad_a", ",", "mk_dx", ",", "Sigk_dx", ",", "gradpk", ",", "hesspk", "=", "self", ".", "_gradient_of_the_acquisition_first_term", "(", "\n", "mu", ",", "dmu_dx", ",", "dSigma_dx", ",", "y_minimum", ",", "pk", ",", "k", ",", "bk", ",", "mk", ",", "Sigk", ",", "Lk", "\n", ")", "\n", "grad", "=", "grad", "+", "grad_a", "\n", "\n", "# Compute the last three terms of the gradiens (Rows 2-4 of Equation (6))", "\n", "grad", "=", "grad", "+", "self", ".", "_gradient_of_the_acquisition_second_term", "(", "\n", "mu", ",", "dmu_dx", ",", "dSigma_dx", ",", "y_minimum", ",", "pk", ",", "k", ",", "bk", ",", "mk", ",", "Sigk", ",", "mk_dx", ",", "Sigk_dx", ",", "symmetric_term", ",", "gradpk", ",", "hesspk", "\n", ")", "\n", "\n", "", "return", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._get_non_symmetric_and_symmetric_term_k": [[291, 337], ["numpy.zeros", "numpy.zeros", "range", "scipy.stats.multivariate_normal.cdf", "scipy.stats.norm.pdf", "get_correlations_given_value_of_i().flatten", "expected_improvement.get_covariance_given_value_of_i", "scipy.stats.multivariate_normal.cdf", "numpy.zeros", "numpy.zeros", "numpy.sqrt", "expected_improvement.get_correlations_given_value_of_i", "Sigma_k[].flatten"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_covariance_given_value_of_i", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_correlations_given_value_of_i"], ["", "def", "_get_non_symmetric_and_symmetric_term_k", "(", "\n", "self", ",", "b_k", ":", "np", ".", "ndarray", ",", "mu_k", ":", "np", ".", "ndarray", ",", "Sigma_k", ":", "np", ".", "ndarray", ",", "pk", ":", "np", ".", "ndarray", ",", "k", ":", "int", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Helper function for computing Second term in Equation (3) of the paper\n        for computing the multipoint Expected Improvement\n\n        :param b_k: Vector b^{k} in Equation (3) in the paper for computing the acquisition function.\n        :param mu_k: Mean of Y - Y_min given that Y_k is smaller than any other Y_i, i not k.\n        :param Sigma_k: Covariance of Y - Y_min given that Y_k is smaller than any other Y_i, i not k.\n        :param pk: Vector of probabilities of Y_k being smaller than the rest for all k.\n        :return: Non symmetric and symmetric matrices needed for computing the multipoint Expected Improvement.\n        \"\"\"", "\n", "q", "=", "mu_k", ".", "shape", "[", "0", "]", "\n", "non_symmetric_term", "=", "np", ".", "zeros", "(", "(", "q", ",", ")", ")", "\n", "symmetric_term", "=", "np", ".", "zeros", "(", "(", "q", ",", ")", ")", "\n", "if", "self", ".", "fast_compute", ":", "\n", "            ", "non_symmetric_term", "[", "k", "]", "=", "(", "\n", "1.0", "\n", "/", "self", ".", "eps", "\n", "*", "(", "\n", "scipy", ".", "stats", ".", "multivariate_normal", ".", "cdf", "(", "\n", "b_k", "-", "mu_k", "+", "self", ".", "eps", "*", "Sigma_k", "[", ":", ",", "k", "]", ".", "flatten", "(", ")", ",", "np", ".", "zeros", "(", "(", "q", ",", ")", ")", ",", "Sigma_k", "\n", ")", "\n", "-", "pk", "[", "k", "]", "\n", ")", "\n", ")", "\n", "symmetric_term", "[", "k", "]", "=", "1.0", "\n", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "q", ")", ":", "\n", "# First item inside the second sum of Equation (3) in the paper", "\n", "                ", "non_symmetric_term", "[", "i", "]", "=", "Sigma_k", "[", "i", ",", "k", "]", "\n", "\n", "if", "i", ">=", "k", ":", "\n", "                    ", "mik", "=", "mu_k", "[", "i", "]", "\n", "sigma_ii_k", "=", "Sigma_k", "[", "i", ",", "i", "]", "\n", "bik", "=", "b_k", "[", "i", "]", "\n", "phi_ik", "=", "scipy", ".", "stats", ".", "norm", ".", "pdf", "(", "bik", ",", "loc", "=", "mik", ",", "scale", "=", "np", ".", "sqrt", "(", "sigma_ii_k", ")", ")", "\n", "cik", "=", "get_correlations_given_value_of_i", "(", "b_k", ",", "mu_k", ",", "Sigma_k", ",", "i", ")", ".", "flatten", "(", ")", "\n", "sigmaik", "=", "get_covariance_given_value_of_i", "(", "Sigma_k", ",", "i", ")", "\n", "Phi_ik", "=", "scipy", ".", "stats", ".", "multivariate_normal", ".", "cdf", "(", "cik", ",", "np", ".", "zeros", "(", "(", "q", "-", "1", ",", ")", ")", ",", "sigmaik", ")", "\n", "\n", "# pdf times cdf in the paper, Equation (3) in the paper, two last items:", "\n", "symmetric_term", "[", "i", "]", "=", "phi_ik", "*", "Phi_ik", "\n", "", "", "", "return", "symmetric_term", ",", "non_symmetric_term", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._gradient_of_the_acquisition_first_term": [[338, 386], ["numpy.zeros", "expected_improvement.Phi_gradient", "expected_improvement.Phi_hessian", "itertools.product", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "range", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_gradient", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_hessian"], ["", "def", "_gradient_of_the_acquisition_first_term", "(", "\n", "self", ",", "\n", "mu", ":", "np", ".", "ndarray", ",", "\n", "dmu_dx", ":", "np", ".", "ndarray", ",", "\n", "dSigma_dx", ":", "np", ".", "ndarray", ",", "\n", "y_minimum", ":", "float", ",", "\n", "pk", ":", "np", ".", "ndarray", ",", "\n", "k", ":", "int", ",", "\n", "bk", ":", "np", ".", "ndarray", ",", "\n", "mk", ":", "np", ".", "ndarray", ",", "\n", "Sigk", ":", "np", ".", "ndarray", ",", "\n", "Lk", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Helper function for computing the first term of the gradient of the Acquisition (First row of Equation (6))\n\n        :param mu: Prediction mean at locations where the evaluation is done.\n        :param dmu_dx: Prediction mean gradient at locations where the evaluation is done.\n        :param dSigma_dx: Prediction covariance gradient at locations where the evaluation is done.\n        :param y_minimum: The best value evaluated so far by the black box function.\n        :param pk: Probabilities of each random variable being smaller than the rest.\n        :param k: Index of the assumed winner, as in Y_k < Y_i for all i not k\n        :param bk: Vector b^{k} in the Equation (6) in the paper.\n        :param mk: Mean of Y - Y_min given that Y_k is smaller than any other Y_i, i not k.\n        :param Sigk: Covariance of Y - Y_min given that Y_k is smaller than any other Y_i, i not k.\n        :param Lk: Linear application to transform Y to Zk\n        :return: Gradient of the first term of the multipoint Expected Improvement,\n                 gradient of the mean and covariance of the multivariate normal,\n                 and gradient and hessian of the probabilities of variable at k being less than the rest.\n        \"\"\"", "\n", "q", ",", "d", "=", "dSigma_dx", ".", "shape", "[", "0", "]", ",", "dmu_dx", ".", "shape", "[", "2", "]", "\n", "grad_a", "=", "np", ".", "zeros", "(", "(", "q", ",", "d", ")", ")", "\n", "tLk", "=", "Lk", ".", "T", "\n", "Dpk", ",", "Sigk_dx", ",", "mk_dx", "=", "np", ".", "zeros", "(", "(", "q", ",", "d", ")", ")", ",", "np", ".", "zeros", "(", "(", "q", ",", "d", ",", "q", ",", "q", ")", ")", ",", "np", ".", "zeros", "(", "(", "q", ",", "d", ",", "q", ")", ")", "\n", "\n", "# term A1: First term in Equation (6) in the paper", "\n", "grad_a", "[", "k", ",", ":", "]", "=", "-", "dmu_dx", "[", "k", ",", "k", ",", ":", "]", "*", "pk", "[", "k", "]", "# q x q x d", "\n", "\n", "# compute gradient and hessian matrix of the CDF term pk.", "\n", "gradpk", "=", "Phi_gradient", "(", "bk", "-", "mk", ",", "np", ".", "zeros", "(", "(", "q", ",", "1", ")", ")", ",", "Sigk", ")", "\n", "hesspk", "=", "Phi_hessian", "(", "bk", ",", "mk", ",", "Sigk", ",", "gradient", "=", "gradpk", ")", "\n", "for", "l", ",", "j", "in", "itertools", ".", "product", "(", "range", "(", "q", ")", ",", "range", "(", "d", ")", ")", ":", "\n", "            ", "Sigk_dx", "[", "l", ",", "j", ",", ":", ",", ":", "]", "=", "Lk", "@", "dSigma_dx", "[", ":", ",", ":", ",", "l", ",", "j", "]", "@", "tLk", "\n", "mk_dx", "[", "l", ",", "j", ",", ":", "]", "=", "Lk", "@", "dmu_dx", "[", ":", ",", "l", ",", "j", "]", "\n", "Dpk", "[", "l", ",", "j", "]", "=", "0.5", "*", "np", ".", "sum", "(", "hesspk", "*", "Sigk_dx", "[", "l", ",", "j", ",", ":", ",", ":", "]", ")", "-", "gradpk", "[", "None", ",", ":", "]", "@", "mk_dx", "[", "l", ",", "j", ",", ":", ",", "None", "]", "\n", "\n", "# term A2: Second term in Equation (6) in the paper", "\n", "", "return", "grad_a", "+", "(", "y_minimum", "-", "mu", "[", "k", "]", ")", "*", "Dpk", ",", "mk_dx", ",", "Sigk_dx", ",", "gradpk", ",", "hesspk", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.MultipointExpectedImprovement._gradient_of_the_acquisition_second_term": [[387, 494], ["numpy.zeros", "expected_improvement.Phi_gradient", "expected_improvement.Phi_hessian", "itertools.product", "range", "numpy.zeros", "range", "range", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.max", "expected_improvement.Phi_gradient", "expected_improvement.Phi_hessian", "itertools.product", "numpy.zeros", "numpy.zeros", "range", "range", "numpy.sum", "numpy.sum", "range", "scipy.stats.multivariate_normal.pdf", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_gradient", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_hessian", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_gradient", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_hessian"], ["", "def", "_gradient_of_the_acquisition_second_term", "(", "\n", "self", ",", "\n", "mu", ":", "np", ".", "ndarray", ",", "\n", "dmu_dx", ":", "np", ".", "ndarray", ",", "\n", "dSigma_dx", ":", "np", ".", "ndarray", ",", "\n", "y_minimum", ":", "float", ",", "\n", "pk", ":", "np", ".", "ndarray", ",", "\n", "k", ":", "int", ",", "\n", "bk", ":", "np", ".", "ndarray", ",", "\n", "mk", ":", "np", ".", "ndarray", ",", "\n", "Sigk", ":", "np", ".", "ndarray", ",", "\n", "mk_dx", ":", "np", ".", "ndarray", ",", "\n", "Sigk_dx", ":", "np", ".", "ndarray", ",", "\n", "symmetric_term", ":", "np", ".", "ndarray", ",", "\n", "gradpk", ":", "np", ".", "ndarray", ",", "\n", "hesspk", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Helper function for computing the second term of the gradient of the Acquisition (2-4 rows of Equation (6))\n\n        :param mu: Prediction mean at locations where the evaluation is done.\n        :param dmu_dx: Prediction mean gradient at locations where the evaluation is done.\n        :param dSigma_dx: Prediction covariance gradient at locations where the evaluation is done.\n        :param y_minimum: The best value evaluated so far by the black box function.\n        :param pk: Probabilities of each random variable being smaller than the rest.\n        :param k: Index of the assumed winner, as in Y_k < Y_i for all i not k\n        :param bk: Vector b^{k} in the Equation (6) in the paper.\n        :param mk: Mean of Y - Y_min given that Y_k is smaller than any other Y_i, i not k.\n        :param Sigk: Covariance of Y - Y_min given that Y_k is smaller than any other Y_i, i not k.\n        :param mk_dx: Gradient of mk.\n        :param Sigk_dx: Gradient of Sigk.\n        :param symmetric_term: A helper matrix generated by the acquistion function.\n        :param gradpk: Gradient of vector pk.\n        :param hesspk: Hessian of vecotr pk.\n        :return: Gradient of the first term of the multipoint Expected Improvement.\n        \"\"\"", "\n", "q", ",", "d", "=", "dSigma_dx", ".", "shape", "[", "0", "]", ",", "dmu_dx", ".", "shape", "[", "2", "]", "\n", "B", "=", "np", ".", "zeros", "(", "(", "q", ",", "d", ")", ")", "\n", "\n", "# term B (Rows 2-4 in Equation (6) in the paper)", "\n", "if", "self", ".", "fast_compute", ":", "\n", "# Numerical approximation through", "\n", "\n", "            ", "gradpk1", "=", "Phi_gradient", "(", "bk", "-", "mk", "+", "Sigk", "[", ":", ",", "k", ",", "None", "]", "*", "self", ".", "eps", ",", "np", ".", "zeros", "(", "(", "q", ",", "1", ")", ")", ",", "Sigk", ")", "\n", "hesspk1", "=", "Phi_hessian", "(", "bk", "+", "Sigk", "[", ":", ",", "k", ",", "None", "]", "*", "self", ".", "eps", ",", "mk", ",", "Sigk", ",", "gradient", "=", "gradpk1", ")", "\n", "for", "l", ",", "j", "in", "itertools", ".", "product", "(", "range", "(", "q", ")", ",", "range", "(", "d", ")", ")", ":", "\n", "                ", "f1", "=", "(", "\n", "-", "(", "mk_dx", "[", "None", ",", "l", ",", "j", ",", ":", "]", "@", "gradpk1", "[", ":", ",", "None", "]", ")", "\n", "+", "self", ".", "eps", "*", "(", "Sigk_dx", "[", "None", ",", "l", ",", "j", ",", ":", ",", "k", "]", "@", "gradpk1", ")", "\n", "+", "0.5", "*", "np", ".", "sum", "(", "Sigk_dx", "[", "l", ",", "j", ",", ":", ",", ":", "]", "*", "hesspk1", ")", "\n", ")", "\n", "f", "=", "-", "(", "mk_dx", "[", "None", ",", "l", ",", "j", ",", ":", "]", "@", "gradpk", "[", ":", ",", "None", "]", ")", "+", "0.5", "*", "np", ".", "sum", "(", "Sigk_dx", "[", "l", ",", "j", ",", ":", ",", ":", "]", "*", "hesspk", ")", "\n", "B", "[", "l", ",", "j", "]", "=", "1.0", "/", "self", ".", "eps", "*", "(", "f1", "-", "f", ")", "\n", "", "", "else", ":", "\n", "            ", "B1", ",", "B2", ",", "B3", "=", "np", ".", "zeros", "(", "(", "q", ",", "d", ")", ")", ",", "np", ".", "zeros", "(", "(", "q", ",", "d", ")", ")", ",", "np", ".", "zeros", "(", "(", "q", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "q", ")", ":", "\n", "\n", "# Assign helper variables needed by the gradients (See equation (6) for details)", "\n", "                ", "ineq", "=", "[", "n", "for", "n", "in", "range", "(", "q", ")", "if", "n", "is", "not", "i", "]", "\n", "Sigk_ik", "=", "Sigk", "[", "i", ",", "k", "]", "\n", "Sigk_ii", "=", "Sigk", "[", "i", ",", "i", "]", "\n", "mk_i", "=", "mk", "[", "i", "]", "\n", "mk_dx_i", "=", "mk_dx", "[", ":", ",", ":", ",", "i", "]", "\n", "bk_i", "=", "bk", "[", "i", ",", "0", "]", "\n", "ck_pi", "=", "(", "bk", "[", "ineq", ",", "0", "]", "-", "mk", "[", "ineq", ",", "0", "]", "-", "(", "bk", "[", "i", ",", "0", "]", "-", "mk", "[", "i", ",", "0", "]", ")", "/", "Sigk_ii", "*", "Sigk", "[", "ineq", ",", ":", "]", "[", ":", ",", "i", "]", ")", "[", ":", ",", "None", "]", "\n", "Sigk_pi", "=", "0.5", "*", "(", "\n", "Sigk", "[", "ineq", ",", ":", "]", "[", ":", ",", "ineq", "]", "\n", "-", "1.0", "/", "Sigk_ii", "*", "Sigk", "[", "ineq", ",", ":", "]", "[", ":", ",", "i", ",", "None", "]", "@", "Sigk", "[", "ineq", ",", ":", "]", "[", ":", ",", "i", ",", "None", "]", ".", "T", "\n", "+", "(", "\n", "Sigk", "[", "ineq", ",", ":", "]", "[", ":", ",", "ineq", "]", "-", "1.0", "/", "Sigk_ii", "*", "Sigk", "[", "ineq", ",", ":", "]", "[", ":", ",", "i", ",", "None", "]", "@", "Sigk", "[", "ineq", ",", ":", "]", "[", ":", ",", "i", ",", "None", "]", ".", "T", "\n", ")", ".", "T", "\n", ")", "\n", "Sigk_dx_ii", "=", "Sigk_dx", "[", ":", ",", ":", ",", "i", ",", "i", "]", "\n", "Sigk_dx_ik", "=", "Sigk_dx", "[", ":", ",", ":", ",", "i", ",", "k", "]", "\n", "phi_ik", "=", "np", ".", "max", "(", "[", "scipy", ".", "stats", ".", "multivariate_normal", ".", "pdf", "(", "bk", "[", "i", ",", "0", "]", ",", "mk_i", ",", "Sigk_ii", ")", ",", "1e-11", "]", ")", "\n", "dphi_ik_dSig", "=", "(", "(", "bk_i", "-", "mk_i", ")", "**", "2", "/", "(", "2.0", "*", "Sigk_ii", "**", "2", ")", "-", "0.5", "/", "Sigk_ii", ")", "*", "phi_ik", "\n", "dphi_ik_dm", "=", "(", "bk_i", "-", "mk_i", ")", "/", "Sigk_ii", "*", "phi_ik", "\n", "Phi_ik", "=", "symmetric_term", "[", "k", ",", "i", "]", "/", "phi_ik", "\n", "GPhi_ik", "=", "Phi_gradient", "(", "ck_pi", ",", "np", ".", "zeros", "(", "(", "q", "-", "1", ",", "1", ")", ")", ",", "Sigk_pi", ")", "\n", "HPhi_ik", "=", "Phi_hessian", "(", "ck_pi", ",", "np", ".", "zeros", "(", "(", "q", "-", "1", ",", "1", ")", ")", ",", "Sigk_pi", ",", "GPhi_ik", ")", "\n", "Sigk_mi", "=", "Sigk", "[", "ineq", ",", "i", ",", "None", "]", "\n", "\n", "# Compute the terms pf the gradient", "\n", "for", "l", ",", "j", "in", "itertools", ".", "product", "(", "range", "(", "q", ")", ",", "range", "(", "d", ")", ")", ":", "\n", "# B1: Second row of Equation (6) in the paper", "\n", "                    ", "B1", "[", "l", ",", "j", "]", "=", "B1", "[", "l", ",", "j", "]", "+", "Sigk_dx_ik", "[", "l", ",", "j", "]", "*", "phi_ik", "*", "Phi_ik", "\n", "\n", "# B2: Third row of Equation (6) in the paper", "\n", "B2", "[", "l", ",", "j", "]", "=", "(", "\n", "B2", "[", "l", ",", "j", "]", "+", "Sigk_ik", "*", "(", "mk_dx_i", "[", "l", ",", "j", "]", "*", "dphi_ik_dm", "+", "dphi_ik_dSig", "*", "Sigk_dx_ii", "[", "l", ",", "j", "]", ")", "*", "Phi_ik", "\n", ")", "\n", "\n", "# B3: Fourth row of Equation (6) in the paper", "\n", "dck_pi", "=", "(", "\n", "-", "mk_dx", "[", "l", ",", "j", ",", "ineq", "]", "\n", "+", "(", "mk_dx_i", "[", "l", ",", "j", "]", "*", "Sigk_ii", "+", "(", "bk_i", "-", "mk_i", ")", "*", "Sigk_dx_ii", "[", "l", ",", "j", "]", ")", "/", "(", "Sigk_ii", "**", "2", ")", "*", "Sigk_mi", "[", ":", ",", "0", "]", "\n", "-", "(", "bk", "[", "i", ",", "0", "]", "-", "mk_i", ")", "/", "Sigk_ii", "*", "Sigk_dx", "[", "l", ",", "j", ",", "ineq", ",", "i", "]", "\n", ")", "\n", "SigtCross", "=", "Sigk_dx", "[", "l", ",", "j", ",", "ineq", ",", "i", ",", "None", "]", "@", "Sigk_mi", ".", "T", "\n", "dSigk_pi", "=", "(", "\n", "Sigk_dx", "[", "l", ",", "j", ",", ":", ",", ":", "]", "[", ":", ",", "ineq", "]", "[", "ineq", ",", ":", "]", "\n", "+", "Sigk_dx_ii", "[", "l", ",", "j", "]", "/", "(", "Sigk_ii", "**", "2", ")", "*", "(", "Sigk_mi", "@", "Sigk_mi", ".", "T", ")", "\n", "-", "(", "1.0", "/", "Sigk_ii", ")", "*", "(", "SigtCross", "+", "SigtCross", ".", "T", ")", "\n", ")", "\n", "B3", "[", "l", ",", "j", "]", "=", "B3", "[", "l", ",", "j", "]", "+", "Sigk_ik", "*", "phi_ik", "*", "(", "(", "GPhi_ik", ".", "T", "@", "dck_pi", ")", "+", "0.5", "*", "np", ".", "sum", "(", "HPhi_ik", "*", "dSigk_pi", ")", ")", "\n", "", "", "B", "=", "B1", "+", "B2", "+", "B3", "\n", "", "return", "B", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_standard_normal_pdf_cdf": [[117, 132], ["scipy.stats.norm.pdf", "scipy.stats.norm.cdf"], "function", ["None"], ["", "", "def", "get_standard_normal_pdf_cdf", "(", "\n", "x", ":", "np", ".", "array", ",", "mean", ":", "np", ".", "array", ",", "standard_deviation", ":", "np", ".", "array", "\n", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "    ", "\"\"\"\n    Returns pdf and cdf of standard normal evaluated at (x - mean)/sigma\n\n    :param x: Non-standardized input\n    :param mean: Mean to normalize x with\n    :param standard_deviation: Standard deviation to normalize x with\n    :return: (normalized version of x, pdf of standard normal, cdf of standard normal)\n    \"\"\"", "\n", "u", "=", "(", "x", "-", "mean", ")", "/", "standard_deviation", "\n", "pdf", "=", "scipy", ".", "stats", ".", "norm", ".", "pdf", "(", "u", ")", "\n", "cdf", "=", "scipy", ".", "stats", ".", "norm", ".", "cdf", "(", "u", ")", "\n", "return", "u", ",", "pdf", ",", "cdf", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_covariance_given_smallest": [[496, 515], ["Sigma.copy", "range", "range"], "function", ["None"], ["", "", "def", "get_covariance_given_smallest", "(", "Sigma", ":", "np", ".", "ndarray", ",", "k", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Compute covariance of Y - Y_min given that Y_k is smaller than any other Y_i, i not k\n\n    :param Sigma: Covariance of the (not conditioned) multivariate gaussian.\n    :param k: Index of random variable.\n    :return: Covariance of Y - Y_min given that Y_k is smaller than any other Y_i\n    \"\"\"", "\n", "q", "=", "Sigma", ".", "shape", "[", "0", "]", "\n", "res", "=", "Sigma", ".", "copy", "(", ")", "\n", "neqi", "=", "[", "j", "for", "j", "in", "range", "(", "q", ")", "if", "j", "is", "not", "k", "]", "# Everything else but i", "\n", "for", "i", "in", "neqi", ":", "\n", "        ", "res", "[", "k", ",", "i", "]", "=", "Sigma", "[", "k", ",", "k", "]", "-", "Sigma", "[", "k", ",", "i", "]", "\n", "res", "[", "i", ",", "k", "]", "=", "res", "[", "k", ",", "i", "]", "\n", "", "for", "i", "in", "neqi", ":", "\n", "        ", "for", "j", "in", "[", "j", "for", "j", "in", "range", "(", "i", ",", "q", ")", "if", "j", "is", "not", "k", "]", ":", "\n", "            ", "res", "[", "i", ",", "j", "]", "=", "Sigma", "[", "i", ",", "j", "]", "+", "Sigma", "[", "k", ",", "k", "]", "-", "Sigma", "[", "k", ",", "i", "]", "-", "Sigma", "[", "k", ",", "j", "]", "\n", "res", "[", "j", ",", "i", "]", "=", "res", "[", "i", ",", "j", "]", "\n", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_covariance_given_value_of_i": [[517, 530], ["numpy.zeros_like", "itertools.product", "range"], "function", ["None"], ["", "def", "get_covariance_given_value_of_i", "(", "Sigma", ":", "np", ".", "ndarray", ",", "i", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Covariances of variables k knowing the value of variable i.\n\n    :param Sigma: Covariance of the multivariate Gaussian.\n    :param i: Known variable.\n    :return: Covariance of Y given that Y_i is known\n    \"\"\"", "\n", "result", "=", "np", ".", "zeros_like", "(", "Sigma", ")", "\n", "neqi", "=", "[", "j", "for", "j", "in", "range", "(", "Sigma", ".", "shape", "[", "0", "]", ")", "if", "j", "is", "not", "i", "]", "# Everything else but i", "\n", "for", "u", ",", "v", "in", "itertools", ".", "product", "(", "neqi", ",", "neqi", ")", ":", "\n", "        ", "result", "[", "u", ",", "v", "]", "=", "Sigma", "[", "u", ",", "v", "]", "-", "Sigma", "[", "u", ",", "i", "]", "*", "Sigma", "[", "v", ",", "i", "]", "/", "Sigma", "[", "i", ",", "i", "]", "\n", "", "return", "result", "[", "neqi", ",", ":", "]", "[", ":", ",", "neqi", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.get_correlations_given_value_of_i": [[532, 545], ["numpy.arange"], "function", ["None"], ["", "def", "get_correlations_given_value_of_i", "(", "b", ":", "np", ".", "ndarray", ",", "mu", ":", "np", ".", "ndarray", ",", "Sigma", ":", "np", ".", "ndarray", ",", "i", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Partial correlations of variables k knowing the value of variable i.\n\n    :param b: Known values.\n    :param mu: Mean of the multivariate Gaussian knowing i.\n    :param Sigma: Covariance of the multivariate gaussian knowing i.\n    :param i: known variable.\n    :return: Partial correlations between all variables knowing i.\n    \"\"\"", "\n", "Sigmai", "=", "Sigma", "[", "i", ",", ":", "]", "/", "Sigma", "[", "i", ",", "i", "]", "\n", "result", "=", "(", "b", "-", "mu", ")", "-", "(", "b", "[", "i", "]", "-", "mu", "[", "i", "]", ")", "*", "Sigmai", "\n", "return", "result", "[", "np", ".", "arange", "(", "Sigma", ".", "shape", "[", "0", "]", ")", "!=", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.decompose_mvn": [[547, 580], ["numpy.linalg.inv", "len", "scipy.stats.multivariate_normal.pdf", "min", "numpy.minimum", "scipy.stats.multivariate_normal.pdf", "x.flatten", "mu.flatten", "numpy.arange", "numpy.diag", "numpy.sqrt", "x1.flatten", "mu[].flatten", "scipy.stats.mvn.mvnun", "numpy.diag", "numpy.max", "range", "numpy.diag", "numpy.abs", "range", "len", "len"], "function", ["None"], ["", "def", "decompose_mvn", "(", "x", ":", "np", ".", "ndarray", ",", "mu", ":", "np", ".", "ndarray", ",", "Sigma", ":", "np", ".", "ndarray", ",", "k", ":", "list", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Decompose Multivariate normal to probability of some random variables being smaller than the rest and multiply this\n    with the marginal probability distribution of those random variables.\n\n    :param x: Location of decomposition.\n    :param mu: Mean of the multivariate Gaussian.\n    :param Sigma: Covariance of the multivariate gaussian.\n    :param k: Indices of decomposition.\n    :return: Weighted probabilities of each variable being smaller than the rest.\n    \"\"\"", "\n", "q", "=", "Sigma", ".", "shape", "[", "0", "]", "\n", "if", "len", "(", "k", ")", "==", "q", ":", "\n", "        ", "return", "scipy", ".", "stats", ".", "multivariate_normal", ".", "pdf", "(", "x", ".", "flatten", "(", ")", ",", "mu", ".", "flatten", "(", ")", ",", "Sigma", ")", "\n", "", "neqk", "=", "[", "i", "for", "i", "in", "np", ".", "arange", "(", "q", ")", "if", "i", "not", "in", "k", "]", "\n", "x1", "=", "x", "[", "k", ",", ":", "]", "\n", "x2", "=", "x", "[", "neqk", ",", ":", "]", "\n", "mu1", "=", "mu", "[", "k", ",", ":", "]", "\n", "Sig22", "=", "Sigma", "[", "neqk", ",", ":", "]", "[", ":", ",", "neqk", "]", "\n", "Sig21", "=", "Sigma", "[", "neqk", ",", ":", "]", "[", ":", ",", "k", "]", "\n", "Sig12", "=", "Sig21", ".", "T", "\n", "Sig11", "=", "Sigma", "[", "k", ",", ":", "]", "[", ":", ",", "k", "]", "\n", "Sig11Inv", "=", "np", ".", "linalg", ".", "inv", "(", "Sig11", ")", "\n", "varcov", "=", "Sig22", "-", "Sig21", "@", "Sig11Inv", "@", "Sig12", "\n", "varcov", "=", "0.5", "*", "(", "varcov", "+", "varcov", ".", "T", ")", "\n", "\n", "if", "min", "(", "np", ".", "diag", "(", "varcov", ")", ")", "<=", "0", ":", "\n", "        ", "varcov", "[", "range", "(", "len", "(", "neqk", ")", ")", ",", ":", "]", "[", ":", ",", "range", "(", "len", "(", "neqk", ")", ")", "]", "=", "np", ".", "diag", "(", "varcov", ")", "*", "(", "np", ".", "diag", "(", "varcov", ")", ">=", "0", ")", "+", "1e-9", "\n", "", "moy", "=", "mu", "[", "neqk", "]", "+", "Sig21", "@", "Sig11Inv", "@", "(", "x1", "-", "mu1", ")", "\n", "low", "=", "np", ".", "minimum", "(", "moy", ",", "x2", ")", "-", "5.0", "*", "np", ".", "sqrt", "(", "np", ".", "max", "(", "np", ".", "abs", "(", "varcov", ")", ")", ")", "\n", "return", "(", "\n", "scipy", ".", "stats", ".", "multivariate_normal", ".", "pdf", "(", "x1", ".", "flatten", "(", ")", ",", "mu", "[", "k", "]", ".", "flatten", "(", ")", ",", "Sig11", ")", "\n", "*", "scipy", ".", "stats", ".", "mvn", ".", "mvnun", "(", "low", ",", "x2", ",", "moy", ",", "varcov", ",", "maxpts", "=", "1000", "*", "q", ")", "[", "0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_gradient": [[583, 593], ["numpy.array", "expected_improvement.decompose_mvn", "range"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.decompose_mvn"], ["", "def", "Phi_gradient", "(", "x", ":", "np", ".", "ndarray", ",", "mu", ":", "np", ".", "ndarray", ",", "Sigma", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Compute gradient of CDF of multivariate Gaussian distribution.\n\n    :param x: Location where the gradient is evaluated.\n    :param mu: Mean of the multivariate Gaussian.\n    :param Sigma: Covariance of the multivariate Gaussian.\n    :return: Gradient of the CDF of multivariate Gaussian.\n    \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "decompose_mvn", "(", "x", ",", "mu", ",", "Sigma", ",", "[", "i", "]", ")", "for", "i", "in", "range", "(", "Sigma", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_hessian": [[595, 624], ["range", "numpy.zeros", "range", "scipy.stats.norm.pdf", "expected_improvement.decompose_mvn", "numpy.diag", "numpy.diag", "numpy.sqrt", "numpy.diag().flatten", "numpy.diag().flatten", "numpy.diag().flatten", "numpy.diag().flatten", "numpy.diag", "numpy.diag", "expected_improvement.Phi_gradient", "numpy.diag", "numpy.diag"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.decompose_mvn", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expected_improvement.Phi_gradient"], ["", "def", "Phi_hessian", "(", "x", ":", "np", ".", "ndarray", ",", "mu", ":", "np", ".", "ndarray", ",", "Sigma", ":", "np", ".", "ndarray", ",", "gradient", ":", "np", ".", "ndarray", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Compute hessian matrix of CDF of multivariate Gaussian distribution.\n\n    :param x: Location where the Hessian is evaluated.\n    :param mu: Mean of the multivariate Gaussian.\n    :param Sigma: Covariance of the multivariate Gaussian.\n    :param gradient: Gradient of the multivariate Gaussian at x.\n    :return: Hessian of the CDF of multivariate Gaussian.\n    \"\"\"", "\n", "q", "=", "Sigma", ".", "shape", "[", "0", "]", "\n", "if", "q", "==", "1", ":", "\n", "        ", "res", "=", "-", "(", "x", "-", "mu", ")", "/", "Sigma", "*", "scipy", ".", "stats", ".", "norm", ".", "pdf", "(", "x", ",", "mu", ",", "np", ".", "sqrt", "(", "Sigma", ")", ")", "\n", "", "else", ":", "\n", "        ", "res", "=", "np", ".", "zeros", "(", "(", "q", ",", "q", ")", ")", "\n", "", "for", "i", "in", "range", "(", "q", "-", "1", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "q", ")", ":", "\n", "            ", "res", "[", "i", ",", "j", "]", "=", "decompose_mvn", "(", "x", ",", "mu", ",", "Sigma", ",", "[", "i", ",", "j", "]", ")", "\n", "\n", "", "", "res", "=", "res", "+", "res", ".", "T", "# Hessian matrix is symmetric", "\n", "# diagonal terms can be computed with the gradient of CDF and the other hessian terms", "\n", "if", "gradient", "is", "None", ":", "\n", "        ", "res", "=", "res", "-", "np", ".", "diag", "(", "\n", "(", "(", "x", "-", "mu", ")", ".", "flatten", "(", ")", "*", "Phi_gradient", "(", "x", ",", "mu", ",", "Sigma", ")", "[", ":", ",", "None", "]", "+", "np", ".", "diag", "(", "Sigma", "@", "res", ")", ".", "flatten", "(", ")", ")", "\n", "/", "np", ".", "diag", "(", "Sigma", ")", ".", "flatten", "(", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "res", "=", "res", "-", "np", ".", "diag", "(", "(", "(", "x", "-", "mu", ")", ".", "flatten", "(", ")", "*", "gradient", "+", "np", ".", "diag", "(", "Sigma", "@", "res", ")", ".", "flatten", "(", ")", ")", "/", "np", ".", "diag", "(", "Sigma", ")", ".", "flatten", "(", ")", ")", "\n", "", "return", "res", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.probability_of_feasibility.ProbabilityOfFeasibility.__init__": [[15, 29], ["float"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "Union", "[", "IModel", ",", "IDifferentiable", "]", ",", "jitter", ":", "float", "=", "float", "(", "0", ")", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        This acquisition computes for a given input point the probability of satisfying the constraint\n        C<0. For more information see:\n\n        Michael A. Gelbart, Jasper Snoek, and Ryan P. Adams,\n        Bayesian Optimization with Unknown Constraints,\n        https://arxiv.org/pdf/1403.5607.pdf\n\n        :param model: The underlying model that provides the predictive mean and variance for the given test points\n        :param jitter: Jitter to balance exploration / exploitation\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "jitter", "=", "jitter", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.probability_of_feasibility.ProbabilityOfFeasibility.evaluate": [[30, 42], ["probability_of_feasibility.ProbabilityOfFeasibility.model.predict", "numpy.sqrt", "scipy.stats.norm.cdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the probability of of satisfying the constraint C<0.\n        :param x: points where the acquisition is evaluated, shape (number of points, number of dimensions).\n        :return: numpy array with the probability of satisfying the constraint at the points x.\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "mean", "+=", "self", ".", "jitter", "\n", "\n", "standard_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "cdf", "=", "scipy", ".", "stats", ".", "norm", ".", "cdf", "(", "0", ",", "mean", ",", "standard_deviation", ")", "\n", "return", "cdf", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.probability_of_feasibility.ProbabilityOfFeasibility.evaluate_with_gradients": [[43, 63], ["probability_of_feasibility.ProbabilityOfFeasibility.model.predict", "numpy.sqrt", "probability_of_feasibility.ProbabilityOfFeasibility.model.get_prediction_gradients", "scipy.stats.norm.pdf", "scipy.stats.norm.cdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Computes the  probability of of satisfying the constraint C<0.\n        :param x: points where the acquisition is evaluated, shape (number of points, number of dimensions).\n        :return: tuple of numpy arrays with the probability of satisfying the constraint at the points x\n        and its gradient.\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "standard_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "\n", "dmean_dx", ",", "dvariance_dx", "=", "self", ".", "model", ".", "get_prediction_gradients", "(", "x", ")", "\n", "dstandard_devidation_dx", "=", "dvariance_dx", "/", "(", "2", "*", "standard_deviation", ")", "\n", "\n", "mean", "+=", "self", ".", "jitter", "\n", "u", "=", "-", "mean", "/", "standard_deviation", "\n", "pdf", "=", "scipy", ".", "stats", ".", "norm", ".", "pdf", "(", "0", ",", "mean", ",", "standard_deviation", ")", "\n", "cdf", "=", "scipy", ".", "stats", ".", "norm", ".", "cdf", "(", "0", ",", "mean", ",", "standard_deviation", ")", "\n", "dcdf_dx", "=", "-", "pdf", "*", "(", "dmean_dx", "+", "dstandard_devidation_dx", "*", "u", ")", "\n", "\n", "return", "cdf", ",", "dcdf_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.probability_of_feasibility.ProbabilityOfFeasibility.has_gradients": [[64, 67], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "return", "isinstance", "(", "self", ".", "model", ",", "IDifferentiable", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization.LocalPenalization.__init__": [[20, 29], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "IModel", ")", ":", "\n", "        ", "\"\"\"\n        :param model: Model\n        \"\"\"", "\n", "\n", "self", ".", "x_batch", "=", "None", "\n", "self", ".", "radius", "=", "None", "\n", "self", ".", "scale", "=", "None", "\n", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization.LocalPenalization.has_gradients": [[30, 33], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization.LocalPenalization.update_batches": [[34, 45], ["local_penalization.LocalPenalization._compute_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization.LocalPenalization._compute_parameters"], ["", "def", "update_batches", "(", "self", ",", "x_batch", ":", "np", ".", "ndarray", ",", "lipschitz_constant", ":", "float", ",", "f_min", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Updates the batches internally and pre-computes the parameters of the penalization function\n        \"\"\"", "\n", "self", ".", "x_batch", "=", "x_batch", "\n", "if", "x_batch", "is", "not", "None", ":", "\n", "            ", "self", ".", "_compute_parameters", "(", "x_batch", ",", "lipschitz_constant", ",", "f_min", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "x_batch", "=", "None", "\n", "self", ".", "radius", "=", "None", "\n", "self", ".", "scale", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization.LocalPenalization._compute_parameters": [[46, 64], ["local_penalization.LocalPenalization.model.predict", "numpy.maximum", "numpy.sqrt", "radius.flatten", "scale.flatten"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "", "def", "_compute_parameters", "(", "self", ",", "x_batch", ",", "lipschitz_constant", ",", "f_min", ")", ":", "\n", "        ", "\"\"\"\n        Pre-computes the parameters of a penalization function\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x_batch", ")", "\n", "\n", "# Limit how small the variance can be to avoid numerical issues", "\n", "epsilon", "=", "1e-10", "\n", "variance", "=", "np", ".", "maximum", "(", "epsilon", ",", "variance", ")", "\n", "\n", "std_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "\n", "# Calculate function parameters", "\n", "radius", "=", "(", "mean", "-", "f_min", ")", "/", "lipschitz_constant", "\n", "scale", "=", "std_deviation", "/", "lipschitz_constant", "\n", "self", ".", "radius", "=", "radius", ".", "flatten", "(", ")", "\n", "self", ".", "scale", "=", "scale", ".", "flatten", "(", ")", "\n", "self", ".", "x_batch", "=", "x_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization.LocalPenalization.evaluate": [[65, 76], ["local_penalization._distance_calculation", "scipy.stats.norm.logcdf().sum", "numpy.ones", "scipy.stats.norm.logcdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization._distance_calculation"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluates the penalization function value\n        \"\"\"", "\n", "\n", "if", "self", ".", "x_batch", "is", "None", ":", "\n", "            ", "return", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n", "", "distances", "=", "_distance_calculation", "(", "x", ",", "self", ".", "x_batch", ")", "\n", "normalized_distance", "=", "(", "distances", "-", "self", ".", "radius", ")", "/", "self", ".", "scale", "\n", "return", "norm", ".", "logcdf", "(", "normalized_distance", ")", ".", "sum", "(", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization.LocalPenalization.evaluate_with_gradients": [[77, 96], ["local_penalization._distance_with_gradient", "scipy.stats.norm.cdf", "scipy.stats.norm.logcdf().sum", "d_value_dx.sum", "numpy.ones", "numpy.zeros", "scipy.stats.norm.logcdf", "scipy.stats.norm.pdf"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization._distance_with_gradient"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Evaluates the penalization function value and gradients with respect to x\n        \"\"\"", "\n", "\n", "if", "self", ".", "x_batch", "is", "None", ":", "\n", "            ", "return", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "np", ".", "zeros", "(", "x", ".", "shape", ")", "\n", "\n", "", "distances", ",", "d_dist_dx", "=", "_distance_with_gradient", "(", "x", ",", "self", ".", "x_batch", ")", "\n", "normalized_distance", "=", "(", "distances", "-", "self", ".", "radius", ")", "/", "self", ".", "scale", "\n", "h_func", "=", "norm", ".", "cdf", "(", "normalized_distance", ")", "\n", "d_value_dx", "=", "(", "\n", "0.5", "\n", "*", "(", "1", "/", "h_func", "[", ":", ",", ":", ",", "None", "]", ")", "\n", "*", "norm", ".", "pdf", "(", "normalized_distance", ")", "[", ":", ",", ":", ",", "None", "]", "\n", "*", "d_dist_dx", "\n", "/", "self", ".", "scale", "[", "None", ",", ":", ",", "None", "]", "\n", ")", "\n", "return", "norm", ".", "logcdf", "(", "normalized_distance", ")", ".", "sum", "(", "1", ",", "keepdims", "=", "True", ")", ",", "d_value_dx", ".", "sum", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization._distance_calculation": [[98, 101], ["numpy.sqrt", "numpy.square().sum", "numpy.square"], "function", ["None"], ["", "", "def", "_distance_calculation", "(", "x_1", ",", "x_2", ")", ":", "\n", "    ", "dx", "=", "x_1", "[", ":", ",", "None", ",", ":", "]", "-", "x_2", "[", "None", ",", ":", ",", ":", "]", "\n", "return", "np", ".", "sqrt", "(", "np", ".", "square", "(", "dx", ")", ".", "sum", "(", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization._distance_with_gradient": [[103, 109], ["local_penalization._distance_calculation", "numpy.where"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.local_penalization._distance_calculation"], ["", "def", "_distance_with_gradient", "(", "x_1", ",", "x_2", ")", ":", "\n", "    ", "distances", "=", "_distance_calculation", "(", "x_1", ",", "x_2", ")", "\n", "inv_distance", "=", "np", ".", "where", "(", "distances", "!=", "0.0", ",", "1", "/", "distances", ",", "0", ")", "\n", "dx", "=", "x_1", "[", ":", ",", "None", ",", ":", "]", "-", "x_2", "[", "None", ",", ":", ",", ":", "]", "\n", "d_dist_dx", "=", "2", "*", "dx", "*", "inv_distance", "[", ":", ",", ":", ",", "None", "]", "\n", "return", "distances", ",", "d_dist_dx", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.negative_lower_confidence_bound.NegativeLowerConfidenceBound.__init__": [[14, 30], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "Union", "[", "IModel", ",", "IDifferentiable", "]", ",", "beta", ":", "float", "=", "1.0", ")", "->", "None", ":", "\n", "\n", "        ", "\"\"\"\n        This acquisition computes the negative lower confidence bound for a given input point. This is the same\n        as optimizing the upper confidence bound if we would maximize instead of minimizing the objective function.\n        For information as well as some theoretical insights see:\n\n        Gaussian Process Optimization in the Bandit Setting: No Regret and Experimental Design\n        Niranjan Srinivas, Andreas Krause, Sham Kakade, Matthias Seeger\n        In Proceedings of the 27th International Conference  on  Machine  Learning\n\n        :param model: The underlying model that provides the predictive mean and variance for the given test points\n        :param beta: Is multiplied on the standard deviation to control exploration / exploitation\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "beta", "=", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.negative_lower_confidence_bound.NegativeLowerConfidenceBound.evaluate": [[31, 41], ["negative_lower_confidence_bound.NegativeLowerConfidenceBound.model.predict", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the negative lower confidence bound\n\n        :param x: points where the acquisition is evaluated.\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "standard_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "\n", "return", "-", "(", "mean", "-", "self", ".", "beta", "*", "standard_deviation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.negative_lower_confidence_bound.NegativeLowerConfidenceBound.evaluate_with_gradients": [[42, 59], ["negative_lower_confidence_bound.NegativeLowerConfidenceBound.model.predict", "numpy.sqrt", "negative_lower_confidence_bound.NegativeLowerConfidenceBound.model.get_prediction_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Computes the negative lower confidence bound and its derivative\n\n        :param x: points where the acquisition is evaluated.\n        \"\"\"", "\n", "mean", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "standard_deviation", "=", "np", ".", "sqrt", "(", "variance", ")", "\n", "\n", "dmean_dx", ",", "dvariance_dx", "=", "self", ".", "model", ".", "get_prediction_gradients", "(", "x", ")", "\n", "dstandard_deviation_dx", "=", "dvariance_dx", "/", "(", "2", "*", "standard_deviation", ")", "\n", "\n", "lcb", "=", "-", "(", "mean", "-", "self", ".", "beta", "*", "standard_deviation", ")", "\n", "\n", "dlcb_dx", "=", "-", "(", "dmean_dx", "-", "self", ".", "beta", "*", "dstandard_deviation_dx", ")", "\n", "\n", "return", "lcb", ",", "dlcb_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.negative_lower_confidence_bound.NegativeLowerConfidenceBound.has_gradients": [[60, 63], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "return", "isinstance", "(", "self", ".", "model", ",", "IDifferentiable", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.log_acquisition.LogAcquisition.__init__": [[13, 19], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "acquisition", ":", "Acquisition", ")", ":", "\n", "        ", "\"\"\"\n        :param acquisition: Base acquisition function that is log transformed. This acquisition function must output\n                            positive values only.\n        \"\"\"", "\n", "self", ".", "acquisition", "=", "acquisition", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.log_acquisition.LogAcquisition.evaluate": [[20, 26], ["numpy.log", "log_acquisition.LogAcquisition.acquisition.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :param x: Input location\n        :return: log of original acquisition function at input location(s)\n        \"\"\"", "\n", "return", "np", ".", "log", "(", "self", ".", "acquisition", ".", "evaluate", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.log_acquisition.LogAcquisition.evaluate_with_gradients": [[27, 40], ["log_acquisition.LogAcquisition.acquisition.evaluate_with_gradients", "numpy.maximum", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return log of original acquisition with gradient\n\n        :param x: Input location\n        :return: Tuple of (log value, gradient of log value)\n        \"\"\"", "\n", "value", ",", "gradient", "=", "self", ".", "acquisition", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "\n", "epsilon", "=", "1e-10", "\n", "value", "=", "np", ".", "maximum", "(", "value", ",", "epsilon", ")", "\n", "log_gradient", "=", "1", "/", "value", "*", "gradient", "\n", "return", "np", ".", "log", "(", "value", ")", ",", "log_gradient", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.log_acquisition.LogAcquisition.has_gradients": [[41, 44], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "self", ".", "acquisition", ".", "has_gradients", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.mutual_information.MutualInformation.__init__": [[33, 36], ["squared_correlation.SquaredCorrelation"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "VanillaBayesianQuadrature", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "rho2", "=", "SquaredCorrelation", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.mutual_information.MutualInformation.has_gradients": [[37, 41], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Whether acquisition value has analytical gradient calculation available.\"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.mutual_information.MutualInformation.evaluate": [[42, 51], ["mutual_information.MutualInformation.rho2.evaluate", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Evaluates the acquisition function at x.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim) .\n        :return: The acquisition values at x, shape (n_points, 1).\n        \"\"\"", "\n", "rho2", "=", "self", ".", "rho2", ".", "evaluate", "(", "x", ")", "\n", "mutual_information", "=", "-", "0.5", "*", "np", ".", "log", "(", "1", "-", "rho2", ")", "\n", "return", "mutual_information", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.mutual_information.MutualInformation.evaluate_with_gradients": [[52, 67], ["mutual_information.MutualInformation.MutualInformation.evaluate", "mutual_information.MutualInformation.MutualInformation.rho2.evaluate_with_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Evaluate the acquisition function and its gradient.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim) .\n        :return: The acquisition values and corresponding gradients at x,\n                 shapes (n_points, 1) and (n_points, input_dim)\n        \"\"\"", "\n", "# value", "\n", "mutual_information", "=", "self", ".", "evaluate", "(", "x", ")", "\n", "rho2", ",", "rho2_gradient", "=", "self", ".", "rho2", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "\n", "# gradient", "\n", "mutual_information_gradient", "=", "(", "0.5", "/", "(", "1", "-", "rho2", ")", ")", "*", "rho2_gradient", "\n", "\n", "return", "mutual_information", ",", "mutual_information_gradient", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.uncertainty_sampling.UncertaintySampling.__init__": [[29, 32], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "Union", "[", "WarpedBayesianQuadratureModel", ",", "IDifferentiable", "]", ",", "measure_power", ":", "float", "=", "2", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "_measure_power", "=", "measure_power", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.uncertainty_sampling.UncertaintySampling.has_gradients": [[33, 37], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Whether acquisition value has analytical gradient calculation available.\"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.uncertainty_sampling.UncertaintySampling._evaluate": [[38, 47], ["uncertainty_sampling.UncertaintySampling.model.measure.compute_density().reshape", "uncertainty_sampling.UncertaintySampling.model.predict", "uncertainty_sampling.UncertaintySampling.model.measure.compute_density"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density"], ["", "def", "_evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Evaluate the predictive variances and the acquisition function.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim) .\n        :return: The acquisition values at x and unweighted variances, both of shape (n_points, 1).\n        \"\"\"", "\n", "variances", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "[", "1", "]", "\n", "weights", "=", "self", ".", "model", ".", "measure", ".", "compute_density", "(", "x", ")", ".", "reshape", "(", "variances", ".", "shape", ")", "\n", "return", "variances", "*", "weights", "**", "self", ".", "_measure_power", ",", "variances", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.uncertainty_sampling.UncertaintySampling.evaluate": [[48, 55], ["uncertainty_sampling.UncertaintySampling._evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Evaluates the acquisition function at x.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim) .\n        :return: The acquisition values at x, shape (n_points, 1).\n        \"\"\"", "\n", "return", "self", ".", "_evaluate", "(", "x", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.uncertainty_sampling.UncertaintySampling.evaluate_with_gradients": [[56, 79], ["uncertainty_sampling.UncertaintySampling._evaluate", "uncertainty_sampling.UncertaintySampling.model.measure.compute_density", "uncertainty_sampling.UncertaintySampling.model.measure.compute_density_gradient", "uncertainty_sampling.UncertaintySampling.model.get_prediction_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._evaluate", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density_gradient", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Evaluate the acquisition function and its gradient.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim).\n        :return: The acquisition values and corresponding gradients at x,\n                 shapes (n_points, 1) and (n_points, input_dim)\n        \"\"\"", "\n", "p", "=", "self", ".", "_measure_power", "\n", "variance_weighted", ",", "variance", "=", "self", ".", "_evaluate", "(", "x", ")", "\n", "\n", "variance_gradient", "=", "self", ".", "model", ".", "get_prediction_gradients", "(", "x", ")", "[", "1", "]", "\n", "density", "=", "self", ".", "model", ".", "measure", ".", "compute_density", "(", "x", ")", "\n", "density_gradient", "=", "self", ".", "model", ".", "measure", ".", "compute_density_gradient", "(", "x", ")", "\n", "\n", "if", "p", "==", "1", ":", "\n", "            ", "gradient_weighted", "=", "(", "density", "*", "variance_gradient", ".", "T", ")", ".", "T", "+", "(", "variance", "[", ":", ",", "0", "]", "*", "density_gradient", ".", "T", ")", ".", "T", "\n", "return", "variance_weighted", ",", "gradient_weighted", "\n", "\n", "", "gradient_weighted", "=", "(", "density", "**", "p", "*", "variance_gradient", ".", "T", ")", ".", "T", "+", "(", "\n", "p", "*", "(", "variance", "[", ":", ",", "0", "]", "*", "density", "**", "(", "p", "-", "1", ")", ")", "*", "density_gradient", ".", "T", "\n", ")", ".", "T", "\n", "\n", "return", "variance_weighted", ",", "gradient_weighted", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation.__init__": [[35, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "VanillaBayesianQuadrature", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation.has_gradients": [[38, 42], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Whether acquisition value has analytical gradient calculation available.\"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation.evaluate": [[43, 50], ["squared_correlation.SquaredCorrelation._evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Evaluates the acquisition function at x.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim) .\n        :return: The acquisition values at x, shape (n_points, 1).\n        \"\"\"", "\n", "return", "self", ".", "_evaluate", "(", "x", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._evaluate": [[51, 63], ["squared_correlation.SquaredCorrelation._value_terms"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._value_terms"], ["", "def", "_evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "float", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Evaluates the acquisition function at x.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim) .\n        :return: The acquisition values at x (n_points, 1),\n                 the current integral variance (float),\n                 the predictive variance + noise at x (n_points, 1),\n                 the predictive covariance between integral and x (n_points, 1).\n        \"\"\"", "\n", "integral_current_var", ",", "y_predictive_var", ",", "predictive_cov", "=", "self", ".", "_value_terms", "(", "x", ")", "\n", "squared_correlation", "=", "predictive_cov", "**", "2", "/", "(", "integral_current_var", "*", "y_predictive_var", ")", "\n", "return", "squared_correlation", ",", "integral_current_var", ",", "y_predictive_var", ",", "predictive_cov", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation.evaluate_with_gradients": [[64, 82], ["squared_correlation.SquaredCorrelation._evaluate", "squared_correlation.SquaredCorrelation._gradient_terms"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._gradient_terms"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Evaluate the acquisition function and its gradient.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim).\n        :return: The acquisition values and corresponding gradients at x,\n                 shapes (n_points, 1) and (n_points, input_dim)\n        \"\"\"", "\n", "# value", "\n", "squared_correlation", ",", "integral_current_var", ",", "y_predictive_var", ",", "predictive_cov", "=", "self", ".", "_evaluate", "(", "x", ")", "\n", "\n", "# gradient", "\n", "d_y_predictive_var_dx", ",", "d_predictive_cov_dx", "=", "self", ".", "_gradient_terms", "(", "x", ")", "\n", "first_term", "=", "2.0", "*", "predictive_cov", "*", "d_predictive_cov_dx", "\n", "second_term", "=", "(", "predictive_cov", "**", "2", "/", "y_predictive_var", ")", "*", "d_y_predictive_var_dx", "\n", "normalization", "=", "integral_current_var", "*", "y_predictive_var", "\n", "squared_correlation_gradient", "=", "(", "first_term", "-", "second_term", ")", "/", "normalization", "\n", "\n", "return", "squared_correlation", ",", "squared_correlation_gradient", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._value_terms": [[83, 100], ["squared_correlation.SquaredCorrelation.model.base_gp.kern.qK", "squared_correlation.SquaredCorrelation.model.base_gp.kern.qK", "squared_correlation.SquaredCorrelation.model.base_gp.solve_linear", "numpy.transpose", "squared_correlation.SquaredCorrelation.model.integrate", "squared_correlation.SquaredCorrelation.model.base_gp.kern.K", "squared_correlation.SquaredCorrelation.model.predict", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.solve_linear", "home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.integrate", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "_value_terms", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "float", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Computes the terms needed for the squared correlation.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim).\n        :return: The current integral variance (float),\n                 predictive variance + noise at x (n_points, 1),\n                 predictive covariance between integral and x (n_points, 1).\n        \"\"\"", "\n", "integral_current_var", "=", "self", ".", "model", ".", "integrate", "(", ")", "[", "1", "]", "\n", "y_predictive_var", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "[", "1", "]", "+", "self", ".", "model", ".", "base_gp", ".", "observation_noise_variance", "\n", "\n", "qKx", "=", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "qK", "(", "x", ")", "\n", "qKX", "=", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "qK", "(", "self", ".", "model", ".", "base_gp", ".", "X", ")", "\n", "\n", "graminv_KXx", "=", "self", ".", "model", ".", "base_gp", ".", "solve_linear", "(", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "K", "(", "self", ".", "model", ".", "base_gp", ".", "X", ",", "x", ")", ")", "\n", "predictive_cov", "=", "np", ".", "transpose", "(", "qKx", "-", "np", ".", "dot", "(", "qKX", ",", "graminv_KXx", ")", ")", "\n", "return", "integral_current_var", ",", "y_predictive_var", ",", "predictive_cov", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.squared_correlation.SquaredCorrelation._gradient_terms": [[101, 120], ["numpy.transpose", "squared_correlation.SquaredCorrelation.model.base_gp.kern.qK", "numpy.transpose", "squared_correlation.SquaredCorrelation.model.base_gp.kern.dK_dx2", "squared_correlation.SquaredCorrelation.model.base_gp.kern.dqK_dx", "squared_correlation.SquaredCorrelation.model.base_gp.solve_linear", "numpy.transpose", "squared_correlation.SquaredCorrelation.model.get_prediction_gradients", "numpy.dot", "numpy.transpose"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dK_dx2", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.dqK_dx", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.solve_linear", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "_gradient_terms", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Computes the terms needed for the gradient of the squared correlation.\n\n        :param x: The locations where to evaluate, shape (n_points, input_dim).\n        :return: The gradient of y_predictive_var and predictive_cov wrt. x at x, shapes (n_points, input_dim).\n        \"\"\"", "\n", "# gradient of predictive variance of y", "\n", "d_y_predictive_var_dx", "=", "self", ".", "model", ".", "get_prediction_gradients", "(", "x", ")", "[", "1", "]", ".", "T", "\n", "\n", "# gradient of predictive covariance between integral and (x, y)-pair", "\n", "dqKx_dx", "=", "np", ".", "transpose", "(", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "dqK_dx", "(", "x", ")", ")", "\n", "\n", "qKX", "=", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "qK", "(", "self", ".", "model", ".", "base_gp", ".", "X", ")", "\n", "qKX_graminv", "=", "np", ".", "transpose", "(", "self", ".", "model", ".", "base_gp", ".", "solve_linear", "(", "qKX", ".", "T", ")", ")", "# (1, N)", "\n", "\n", "dKXx_dx2", "=", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "dK_dx2", "(", "self", ".", "model", ".", "X", ",", "x", ")", "\n", "d_predictive_cov_dx", "=", "dqKx_dx", "-", "np", ".", "dot", "(", "qKX_graminv", ",", "np", ".", "transpose", "(", "dKXx_dx2", ")", ")", "[", "0", ",", ":", ",", ":", "]", "\n", "\n", "return", "np", ".", "transpose", "(", "d_y_predictive_var_dx", ")", ",", "d_predictive_cov_dx", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.__init__": [[27, 41], ["thompson_sampling_acquisition.SequentialThompsonSampler.reset", "numpy.array().flatten", "numpy.array().flatten", "int", "numpy.array", "numpy.array", "round", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["def", "__init__", "(", "self", ",", "model", ":", "ComparisonGP", ",", "seed", ":", "float", "=", "None", ",", "delta", ":", "float", "=", "1e-5", ",", "num_points", ":", "int", "=", "None", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "# model", "\n", "self", ".", "posterior", "=", "model", ".", "posterior", "\n", "\n", "self", ".", "d", "=", "self", ".", "model", ".", "X", ".", "shape", "[", "1", "]", "# dimensionality of the input points", "\n", "\n", "self", ".", "seeds", "=", "[", "]", "\n", "self", ".", "reset", "(", "seed", "=", "seed", ")", "\n", "\n", "self", ".", "delta", "=", "delta", "\n", "if", "num_points", "is", "None", ":", "\n", "            ", "num_points", "=", "int", "(", "100", "*", "round", "(", "np", ".", "sqrt", "(", "self", ".", "d", ")", ")", ")", "\n", "", "self", ".", "num_points", "=", "num_points", "\n", "self", ".", "scaling", "=", "np", ".", "array", "(", "[", "model", ".", "kern", ".", "lengthscale", "[", ":", "]", "]", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.reset": [[42, 60], ["numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.random.seed", "numpy.random.seed", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint", "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint", "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint", "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint"], ["", "def", "reset", "(", "self", ",", "seed", ":", "float", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Reset the sampler by forgetting the already drawn samples and resetting the seed.\n\n        :param seed: new seed after reset\n        \"\"\"", "\n", "self", ".", "x_evaluations", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "model", ".", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "self", ".", "f_evaluations", "=", "np", ".", "empty", "(", "(", "0", ",", "1", ")", ")", "\n", "if", "seed", "is", "None", ":", "\n", "            ", "max", "=", "1000000", "\n", "if", "self", ".", "model", ".", "name", "==", "\"MCMC\"", ":", "\n", "                ", "max", "=", "self", ".", "model", ".", "posterior", ".", "samples", "[", "\"f\"", "]", ".", "shape", "[", "0", "]", "\n", "", "seed", "=", "np", ".", "random", ".", "randint", "(", "max", ")", "\n", "# Check if we already have used this seed", "\n", "while", "seed", "in", "self", ".", "seeds", ":", "\n", "                ", "seed", "=", "np", ".", "random", ".", "randint", "(", "max", ")", "\n", "", "", "self", ".", "seeds", "=", "self", ".", "seeds", "+", "[", "seed", "]", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.add_data": [[61, 70], ["numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate"], "methods", ["None"], ["", "def", "add_data", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "f", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Add new points and evaluations to the stack of already evaluated points\n\n        :param x: new locations\n        :param f: new evaluations\n        \"\"\"", "\n", "self", ".", "x_evaluations", "=", "np", ".", "concatenate", "(", "(", "self", ".", "x_evaluations", ",", "x", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "f_evaluations", "=", "np", ".", "concatenate", "(", "(", "self", ".", "f_evaluations", ",", "f", ")", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.get_mu_sigma": [[71, 88], ["mu.reshape.reshape.reshape", "thompson_sampling_acquisition.SequentialThompsonSampler.posterior._get_mu_L", "thompson_sampling_acquisition.SequentialThompsonSampler.model.predict_noiseless", "len", "numpy.eye", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.mcmc_batch_comparison.StanPosterior._get_mu_L", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.predict_noiseless"], ["", "def", "get_mu_sigma", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Returns the posterior predictive distribution at the given locations without conditionin on the already evaluated locatons\n\n        :param x: New locations where the distribution is wanted at\n        :return: Tuple containing the predictive mean and covariance\n        \"\"\"", "\n", "if", "self", ".", "model", ".", "name", "==", "\"MCMC\"", ":", "\n", "            ", "mu", ",", "L", "=", "self", ".", "posterior", ".", "_get_mu_L", "(", "x", ",", "with_index", "=", "self", ".", "seeds", "[", "-", "1", "]", ")", "\n", "Sigma", "=", "L", "[", "0", ",", ":", ",", ":", "]", "@", "L", "[", "0", ",", ":", ",", ":", "]", ".", "T", "\n", "", "else", ":", "\n", "            ", "mu", ",", "Sigma", "=", "self", ".", "model", ".", "predict_noiseless", "(", "x", ",", "full_cov", "=", "True", ")", "\n", "if", "len", "(", "Sigma", ".", "shape", ")", ">", "2", ":", "\n", "                ", "Sigma", "=", "Sigma", "[", ":", ",", ":", ",", "0", "]", "\n", "", "", "mu", "=", "mu", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "Sigma", "=", "Sigma", "+", "1e-7", "*", "np", ".", "eye", "(", "Sigma", ".", "shape", "[", "0", "]", ")", "# noise for robustness", "\n", "return", "mu", ",", "Sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.get_posterior_predictive_distribution": [[89, 111], ["numpy.arange", "numpy.arange", "thompson_sampling_acquisition.SequentialThompsonSampler.get_mu_sigma", "numpy.concatenate", "numpy.concatenate", "numpy.inv", "numpy.inv", "thompson_sampling_acquisition.SequentialThompsonSampler.x_evaluations[].reshape", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "range", "range", "range", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.get_mu_sigma"], ["", "def", "get_posterior_predictive_distribution", "(", "\n", "self", ",", "x", ":", "np", ".", "ndarray", ",", "inds", ":", "int", "=", "np", ".", "arange", "(", "0", ")", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Returns the predictive distribution at the given locations by conditionin on old points and the posterior\n\n        :param x: New location where the distribution is wanted at\n        :param inds: indices of already evaluated points the distribution is conditioned with\n        :return: Tuple containing the predictive mean and covariance\n        \"\"\"", "\n", "n1", ",", "n2", "=", "inds", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "0", "]", "\n", "mu", ",", "Sigma", "=", "self", ".", "get_mu_sigma", "(", "np", ".", "concatenate", "(", "(", "self", ".", "x_evaluations", "[", "inds", ",", ":", "]", ".", "reshape", "(", "-", "1", ",", "self", ".", "d", ")", ",", "x", ")", ",", "axis", "=", "0", ")", ")", "\n", "if", "n1", ">", "0", ":", "\n", "            ", "kXX", "=", "Sigma", "[", "np", ".", "ix_", "(", "range", "(", "n1", ")", ",", "range", "(", "n1", ")", ")", "]", "\n", "kxX", "=", "Sigma", "[", "np", ".", "ix_", "(", "range", "(", "n1", ",", "n1", "+", "n2", ")", ",", "range", "(", "n1", ")", ")", "]", "\n", "kxx", "=", "Sigma", "[", "np", ".", "ix_", "(", "range", "(", "n1", ",", "n1", "+", "n2", ")", ",", "range", "(", "n1", ",", "n1", "+", "n2", ")", ")", "]", "\n", "kXX_inv", "=", "la", ".", "inv", "(", "kXX", ")", "\n", "mu_pred", "=", "mu", "[", "n1", ":", "]", "+", "kxX", "@", "kXX_inv", "@", "(", "self", ".", "f_evaluations", "[", "inds", "]", "-", "mu", "[", ":", "n1", "]", ")", "\n", "Sigma_pred", "=", "kxx", "-", "kxX", "@", "kXX_inv", "@", "kxX", ".", "T", "\n", "return", "mu_pred", ",", "Sigma_pred", "\n", "", "else", ":", "\n", "            ", "return", "mu", ",", "Sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.get_posterior_predictive_distribution_robust": [[112, 140], ["numpy.arange", "numpy.arange", "thompson_sampling_acquisition.SequentialThompsonSampler.get_posterior_predictive_distribution", "numpy.empty", "numpy.empty", "range", "numpy.unique", "numpy.unique", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.unique.flatten", "numpy.argsort", "numpy.argsort"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.get_posterior_predictive_distribution"], ["", "", "def", "get_posterior_predictive_distribution_robust", "(", "self", ",", "x", ",", "num_points", "=", "100", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Returns the predictive distribution at the given locations by conditionin on old points and the posterior\n\n        :param x: new point the sample is wanted to evaluate at\n        :param num_points: number of points taken into account when computing the predictive distribution\n        :return: Tuple containing the predictive mean and covariance\n        \"\"\"", "\n", "N", ",", "n", "=", "self", ".", "x_evaluations", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "0", "]", "\n", "inds", "=", "np", ".", "arange", "(", "N", ")", "\n", "if", "N", ">=", "num_points", ":", "\n", "            ", "inds", "=", "np", ".", "empty", "(", "(", "num_points", ",", "n", ")", ",", "dtype", "=", "int", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "                ", "dists", "=", "np", ".", "linalg", ".", "norm", "(", "\n", "(", "\n", "self", ".", "x_evaluations", "\n", "-", "x", "[", "\n", "None", ",", "\n", "i", ",", "\n", ":", ",", "\n", "]", "\n", ")", "\n", "/", "self", ".", "scaling", "[", "None", ",", ":", "]", ",", "\n", "axis", "=", "1", ",", "\n", ")", "\n", "inds", "[", ":", ",", "i", "]", "=", "np", ".", "argsort", "(", "dists", ")", "[", ":", "num_points", "]", "\n", "", "inds", "=", "np", ".", "unique", "(", "inds", ".", "flatten", "(", ")", ")", "\n", "", "return", "self", ".", "get_posterior_predictive_distribution", "(", "x", ",", "inds", "=", "inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.evaluate_and_add": [[141, 169], ["numpy.atleast_2d().reshape", "numpy.atleast_2d().reshape", "range", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.tile", "numpy.tile", "range", "thompson_sampling_acquisition.SequentialThompsonSampler.get_posterior_predictive_distribution_robust", "numpy.random.multivariate_normal().reshape", "numpy.random.multivariate_normal().reshape", "thompson_sampling_acquisition.SequentialThompsonSampler.add_data", "numpy.empty", "numpy.empty", "range", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate.reshape", "numpy.atleast_2d", "numpy.atleast_2d", "X[].reshape", "numpy.random.multivariate_normal", "numpy.random.multivariate_normal", "mu.flatten"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.get_posterior_predictive_distribution_robust", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.add_data"], ["", "def", "evaluate_and_add", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Returns the value and gradient of the sample at given point\n\n        :param x: new point the sample is wanted to evaluate at\n        :return: Tuple containing the value and gradient\n        \"\"\"", "\n", "X", "=", "np", ".", "atleast_2d", "(", "X", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "d", ")", ")", "\n", "ff", ",", "fgrad", "=", "np", ".", "empty", "(", "(", "0", ")", ")", ",", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "0", "]", ")", ":", "\n", "# deviate to compute the numerical gradients", "\n", "            ", "x", "=", "np", ".", "tile", "(", "X", "[", "i", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "self", ".", "d", ")", ")", ",", "(", "self", ".", "d", "+", "1", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "d", ")", ":", "\n", "                ", "x", "[", "i", "+", "1", ",", "i", "]", "=", "x", "[", "i", "+", "1", ",", "i", "]", "+", "self", ".", "delta", "\n", "# Get predictive distribution", "\n", "", "mu", ",", "k", "=", "self", ".", "get_posterior_predictive_distribution_robust", "(", "x", ",", "num_points", "=", "self", ".", "num_points", ")", "\n", "\n", "# evaluate and add", "\n", "f", "=", "np", ".", "random", ".", "multivariate_normal", "(", "mu", ".", "flatten", "(", ")", ",", "k", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "self", ".", "add_data", "(", "x", ",", "f", ")", "\n", "\n", "# Evaluate numerical gradients", "\n", "grad", "=", "np", ".", "empty", "(", "(", "1", ",", "self", ".", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "d", ")", ":", "\n", "                ", "grad", "[", "0", ",", "i", "]", "=", "(", "f", "[", "i", "+", "1", "]", "-", "f", "[", "0", "]", ")", "/", "self", ".", "delta", "\n", "", "ff", "=", "np", ".", "concatenate", "(", "(", "ff", ",", "f", "[", "0", "]", ")", ",", "axis", "=", "0", ")", "\n", "fgrad", "=", "np", ".", "concatenate", "(", "(", "fgrad", ",", "grad", ")", ",", "axis", "=", "0", ")", "\n", "", "return", "ff", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "fgrad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.ThompsonSampling.acq_fun_optimizer": [[172, 212], ["thompson_sampling_acquisition.SequentialThompsonSampler", "numpy.empty", "numpy.empty", "range", "thompson_sampling_acquisition.ThompsonSampling.sampler.reset", "range", "util.random_sample", "scipy.optimize.minimize", "scipy.optimize.minimize.x.reshape", "len", "get_logger().error", "util.random_sample.flatten", "get_logger"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.random_sample", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger"], ["    ", "def", "acq_fun_optimizer", "(", "\n", "self", ",", "m", ":", "ComparisonGP", ",", "bounds", ":", "np", ".", "ndarray", ",", "batch_size", ":", "int", ",", "get_logger", ":", "Callable", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Implements the optimization scheme for the Thompson sampling acquisition function\n\n        :param m: The model which posterior is used by the acquisition function (from which the samples are drawn from)\n        :param bounds: the optimization bounds of the new sample\n        :param batch_size: How many points are there in the batch\n        :param get_logger: Function for receiving the legger where the prints are forwarded.\n        :return: optimized locations\n        \"\"\"", "\n", "self", ".", "sampler", "=", "SequentialThompsonSampler", "(", "m", ")", "\n", "X_all", "=", "np", ".", "empty", "(", "(", "batch_size", ",", "m", ".", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "self", ".", "sampler", ".", "reset", "(", ")", "# reset the sampling seed", "\n", "yb", "=", "np", ".", "inf", "\n", "Xb", "=", "None", "\n", "for", "j", "in", "range", "(", "self", ".", "acq_opt_restarts", ")", ":", "\n", "                ", "try", ":", "\n", "# Initial point of the optimization", "\n", "                    ", "X0", "=", "util", ".", "random_sample", "(", "bounds", ",", "1", ")", "\n", "res", "=", "sp", ".", "optimize", ".", "minimize", "(", "\n", "fun", "=", "self", ".", "sampler", ".", "evaluate_and_add", ",", "\n", "x0", "=", "X0", ".", "flatten", "(", ")", ",", "\n", "method", "=", "\"L-BFGS-B\"", ",", "\n", "jac", "=", "True", ",", "\n", "bounds", "=", "bounds", ",", "\n", "options", "=", "self", ".", "optimizer_options", ",", "\n", ")", "\n", "X", "=", "res", ".", "x", ".", "reshape", "(", "1", ",", "len", "(", "bounds", ")", ")", "\n", "y", "=", "res", ".", "fun", "\n", "if", "y", "<", "yb", ":", "\n", "                        ", "yb", "=", "y", "\n", "Xb", "=", "X", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "                    ", "get_logger", "(", ")", ".", "error", "(", "\"Solver failed. Below the exception\\n{}\"", ".", "format", "(", "e", ")", ")", "\n", "", "", "assert", "Xb", "is", "not", "None", "\n", "X_all", "[", "i", ",", ":", "]", "=", "Xb", "\n", "", "return", "X_all", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.ThompsonSampling.reset": [[213, 222], ["thompson_sampling_acquisition.ThompsonSampling.sampler.reset", "thompson_sampling_acquisition.SequentialThompsonSampler"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset"], ["", "def", "reset", "(", "self", ",", "model", ":", "ComparisonGPEmukitWrapper", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Some acquisition functions need to be reseted, this method is for that.\n        :param m: the GP model which posterior is used\n        \"\"\"", "\n", "try", ":", "\n", "            ", "self", ".", "sampler", ".", "reset", "(", ")", "\n", "", "except", ":", "\n", "            ", "self", ".", "sampler", "=", "SequentialThompsonSampler", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.ThompsonSampling.evaluate": [[223, 231], ["thompson_sampling_acquisition.ThompsonSampling.sampler.evaluate_and_add"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.evaluate_and_add"], ["", "", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "model", ":", "ComparisonGPEmukitWrapper", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the Expected Improvement.\n        :param x: points where the acquisition is evaluated.\n        :param m: the GP model which posterior is used\n        :return: acquisition function value\n        \"\"\"", "\n", "return", "self", ".", "sampler", ".", "evaluate_and_add", "(", "x", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.ThompsonSampling.evaluate_with_gradients": [[232, 240], ["thompson_sampling_acquisition.ThompsonSampling.sampler.evaluate_and_add"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.thompson_sampling_acquisition.SequentialThompsonSampler.evaluate_and_add"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "model", ":", "ComparisonGPEmukitWrapper", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Computes the Expected Improvement.\n        :param x: points where the acquisition is evaluated.\n        :param model: the GP model which posterior is used\n        :return: A tuple containing the acquisition function values and their gradients\n        \"\"\"", "\n", "return", "self", ".", "sampler", ".", "evaluate_and_add", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.AcquisitionFunction.__init__": [[22, 27], ["options.get", "options.get", "options.get"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get", "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get", "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get"], ["def", "__init__", "(", "self", ",", "options", ":", "Dict", "=", "{", "}", ",", "optimizer_options", ":", "Dict", "=", "{", "}", ")", ":", "\n", "        ", "self", ".", "optimizer_options", "=", "optimizer_options", "\n", "self", ".", "pool_size", "=", "options", ".", "get", "(", "\"pool_size\"", ",", "-", "1", ")", "\n", "self", ".", "acq_samples", "=", "options", ".", "get", "(", "\"acq_samples\"", ",", "1000", ")", "\n", "self", ".", "acq_opt_restarts", "=", "options", ".", "get", "(", "\"acq_opt_restarts\"", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.AcquisitionFunction.acq_fun_optimizer": [[28, 41], ["None"], "methods", ["None"], ["", "def", "acq_fun_optimizer", "(", "\n", "self", ",", "m", ":", "ComparisonGP", ",", "bounds", ":", "np", ".", "ndarray", ",", "batch_size", ":", "int", ",", "get_logger", ":", "Callable", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Implements the optimization scheme for the acquisition function\n\n        :param m: The model which posterior is used by the acquisition function (from which the samples are drawn from)\n        :param bounds: the optimization bounds of the new sample\n        :param batch_size: How many points are there in the batch\n        :param get_logger: Function for receiving the legger where the prints are forwarded.\n        :return: optimized locations\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.AcquisitionFunction.reset": [[42, 48], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ",", "model", ":", "ComparisonGPEmukitWrapper", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Some acquisition functions need to be reseted, this method is for that.\n        :param model: the model to be passed to the acquisition function (some acquisition functions need a model at this point)\n        \"\"\"", "\n", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.EmukitAcquisitionFunctionWrapper.__init__": [[51, 65], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "ComparisonGP", ",", "acquisitionFunction", ":", "AcquisitionFunction", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        This acquisition computes for a given input the improvement over the current best observed value in\n        expectation. For more information see:\n        Efficient Global Optimization of Expensive Black-Box Functions\n        Jones, Donald R. and Schonlau, Matthias and Welch, William J.\n        Journal of Global Optimization\n        :param model: model that is used to compute the improvement.\n        :param acquisitionFunction: The used acquisitionFunction\n        \"\"\"", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "acquisitionFunction", "=", "acquisitionFunction", "\n", "self", ".", "size", "=", "self", ".", "model", ".", "X", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.EmukitAcquisitionFunctionWrapper.evaluate": [[66, 73], ["acquisition_function.EmukitAcquisitionFunctionWrapper.acquisitionFunction.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the Expected Improvement.\n        :param x: points where the acquisition is evaluated.\n        :return: acquisition function values\n        \"\"\"", "\n", "return", "-", "self", ".", "acquisitionFunction", ".", "evaluate", "(", "x", ",", "self", ".", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.EmukitAcquisitionFunctionWrapper.evaluate_with_gradients": [[74, 82], ["acquisition_function.EmukitAcquisitionFunctionWrapper.acquisitionFunction.evaluate_with_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Computes the Expected Improvement.\n        :param x: points where the acquisition is evaluated.\n        :return: a tuple containing the acquisition function values and their gradients\n        \"\"\"", "\n", "f", ",", "g", "=", "self", ".", "acquisitionFunction", ".", "evaluate_with_gradients", "(", "x", ",", "self", ".", "model", ")", "\n", "return", "-", "f", ",", "-", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.EmukitAcquisitionFunctionWrapper.reset": [[83, 89], ["acquisition_function.EmukitAcquisitionFunctionWrapper.acquisitionFunction.reset"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset"], ["", "def", "reset", "(", "self", ",", "model", ":", "ComparisonGPEmukitWrapper", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Some acquisition functions need to be reseted, this method is for that.\n        :param model: the model to be passed to the acquisition function (some acquisition functions need a model at this point)\n        \"\"\"", "\n", "self", ".", "acquisitionFunction", ".", "reset", "(", "model", ".", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.EmukitAcquisitionFunctionWrapper.has_gradients": [[90, 96], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        :return: True as all acquisition functions have gradients\n        \"\"\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.SequentialGradientAcquisitionOptimizer.__init__": [[99, 105], ["emukit.core.optimization.GradientAcquisitionOptimizer.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "space", ":", "ParameterSpace", ",", "batch_size", ":", "int", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param space: The parameter space spanning the search problem.\n        \"\"\"", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "super", "(", ")", ".", "__init__", "(", "space", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.SequentialGradientAcquisitionOptimizer._optimize": [[106, 123], ["range", "acquisition.reset", "super()._optimize", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset", "home.repos.pwc.inspect_result.amzn_emukit.optimization.random_search_acquisition_optimizer.RandomSearchAcquisitionOptimizer._optimize"], ["", "def", "_optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context_manager", ":", "ContextManager", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Implementation of abstract method.\n        Taking into account gradients if acquisition supports them.\n        See AcquisitionOptimizerBase._optimizer for parameter descriptions.\n        See class docstring for implementation details.\n        \"\"\"", "\n", "x_min", ",", "fx_min", "=", "None", ",", "None", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "            ", "acquisition", ".", "reset", "(", "acquisition", ".", "model", ")", "\n", "x_min_i", ",", "fx_min_i", "=", "super", "(", ")", ".", "_optimize", "(", "acquisition", ",", "context_manager", ")", "\n", "\n", "if", "x_min", "is", "None", ":", "\n", "                ", "x_min", ",", "fx_min", "=", "x_min_i", ",", "fx_min_i", "\n", "", "else", ":", "\n", "                ", "x_min", ",", "fx_min", "=", "np", ".", "concatenate", "(", "(", "x_min", ",", "x_min_i", ")", ",", "axis", "=", "1", ")", ",", "fx_min", "+", "fx_min_i", "\n", "", "", "return", "x_min", ",", "fx_min", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.acquisition_function.SequentialGradientAcquisitionOptimizer.optimize": [[124, 150], ["emukit.core.optimization.ContextManager", "acquisition_function.SequentialGradientAcquisitionOptimizer._optimize", "numpy.concatenate", "dict", "acquisition_function.SequentialGradientAcquisitionOptimizer._validate_context_parameters", "tuple", "acquisition_function.SequentialGradientAcquisitionOptimizer.space.round", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.random_search_acquisition_optimizer.RandomSearchAcquisitionOptimizer._optimize", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context", ":", "Optional", "=", "None", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Optimizes the acquisition function.\n        :param acquisition: The acquisition function to be optimized\n        :param context: Optimization context.\n                        Determines whether any variable values should be fixed during the optimization\n        :return: Tuple of (location of maximum, acquisition value at maximizer)\n        \"\"\"", "\n", "if", "context", "is", "None", ":", "\n", "            ", "context", "=", "dict", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_validate_context_parameters", "(", "context", ")", "\n", "", "context_manager", "=", "ContextManager", "(", "self", ".", "space", ",", "context", ")", "\n", "max_x", ",", "max_value", "=", "self", ".", "_optimize", "(", "acquisition", ",", "context_manager", ")", "\n", "\n", "# Optimization might not match any encoding exactly", "\n", "# Rounding operation here finds the closest encoding", "\n", "rounded_max_x", "=", "np", ".", "concatenate", "(", "\n", "tuple", "(", "\n", "self", ".", "space", ".", "round", "(", "max_x", "[", ":", ",", "i", "*", "self", ".", "batch_size", ":", "(", "i", "+", "1", ")", "*", "self", ".", "batch_size", "]", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", "\n", ")", ",", "\n", "axis", "=", "1", ",", "\n", ")", "\n", "\n", "return", "max_x", ",", "max_value", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_ds_via_L": [[46, 60], ["numpy.zeros", "numpy.zeros", "range", "range", "numpy.matmul", "numpy.matmul"], "methods", ["None"], ["def", "dgp_ds_via_L", "(", "self", ",", "s", ":", "np", ".", "ndarray", ",", "dl", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Partial derivatives of the gp posterior samples with respect to the input locations given gradient with respect to cholesky the posterior covariance matrix.\n        The derivative is computed using the generalised chain rule, meaning that derivative with respect to the posterior covariance matrix already exists\n\n        :param s: Samples of observations from the posterior distribution of the model\n        :param dl: Derivatives of the acquisition with respect to the covariance matrix\n        :return: the derivatives of the gp samples with respect to the inputs\n        \"\"\"", "\n", "dls", "=", "np", ".", "zeros", "(", "(", "s", ".", "shape", "[", "0", "]", ",", "dl", ".", "shape", "[", "1", "]", ",", "dl", ".", "shape", "[", "3", "]", ",", "dl", ".", "shape", "[", "4", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "dl", ".", "shape", "[", "3", "]", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "dl", ".", "shape", "[", "4", "]", ")", ":", "\n", "                ", "dls", "[", ":", ",", ":", ",", "i", ",", "j", "]", "=", "np", ".", "matmul", "(", "dl", "[", ":", ",", ":", ",", ":", ",", "i", ",", "j", "]", ",", "s", "[", ":", ",", ":", ",", "None", "]", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "", "", "return", "dls", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dL_via_Sigma": [[61, 80], ["numpy.empty", "numpy.empty", "range", "numpy.tril", "numpy.tril", "numpy.eye", "numpy.eye", "range", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.ones", "numpy.ones", "numpy.swapaxes", "numpy.swapaxes", "numpy.matmul", "numpy.matmul"], "methods", ["None"], ["", "def", "dgp_dL_via_Sigma", "(", "self", ",", "L", ":", "np", ".", "ndarray", ",", "L_inv", ":", "np", ".", "ndarray", ",", "dsigma", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Partial derivatives of the gp posterior samples with respect to the cholesky of the posterior covariance matrix given the partial derivative values with respect to the posterior covariance matrix.\n\n        :param s: Samples of observations from the posterior distribution of the model\n        :param L: Cholesky decomposition(s) of the posterior covariance matrix (samples)\n        :param L_inv: Inverse(s) of Cholesky decomposition(s) of the posterior covariance matrix (samples)\n        :param dsigma: Partial derivatives with respect to the posterior covariance matrix\n        :return: the derivative of the gp samples with respect to the choleskies\n        \"\"\"", "\n", "E", "=", "np", ".", "tril", "(", "2", "*", "np", ".", "ones", "(", "(", "L", ".", "shape", "[", "1", "]", ",", "L", ".", "shape", "[", "2", "]", ")", ")", ",", "-", "1", ")", "+", "np", ".", "eye", "(", "L", ".", "shape", "[", "2", "]", ")", "\n", "dl", "=", "np", ".", "empty", "(", "dsigma", ".", "shape", ")", "# np.empty((N,b,b,b,d))", "\n", "for", "i", "in", "range", "(", "dsigma", ".", "shape", "[", "3", "]", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "dsigma", ".", "shape", "[", "4", "]", ")", ":", "\n", "                ", "tmp1", "=", "np", ".", "matmul", "(", "L_inv", ",", "dsigma", "[", ":", ",", ":", ",", ":", ",", "i", ",", "j", "]", ")", "# N x b x b", "\n", "tmp2", "=", "np", ".", "matmul", "(", "tmp1", ",", "np", ".", "swapaxes", "(", "L_inv", ",", "1", ",", "2", ")", ")", "# N x b x b", "\n", "tmp3", "=", "tmp2", "*", "E", "[", "None", ",", ":", ",", ":", "]", "# N x b x b", "\n", "dl", "[", ":", ",", ":", ",", ":", ",", "i", ",", "j", "]", "=", "0.5", "*", "np", ".", "matmul", "(", "L", ",", "tmp3", ")", "# N x b x b", "\n", "", "", "return", "dl", "# N x b x b", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dSigma": [[81, 115], ["numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty", "range", "kern.K", "numpy.empty", "numpy.empty", "numpy.zeros", "numpy.zeros", "range", "kern.dK_dX", "kern.dK_dX", "range", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.dK_dX", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.dK_dX"], ["", "def", "dgp_dSigma", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "X", ":", "np", ".", "ndarray", ",", "kern", ":", "GPy", ".", "kern", ".", "Kern", ",", "w_inv", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Partial derivatives of the gp posterior samples with respect to the posterior covariance matrix\n\n        :param x: The locations the samples are taken at\n        :param X: The locations used to train the GP model\n        :param kern: Prior covariance matrix\n        :param w_inv: inverses of the woodbury matrix of the model\n        :return: the derivative of the gp samples with respect to the matrix\n        \"\"\"", "\n", "N", ",", "b", ",", "d", ",", "n", "=", "w_inv", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "X", ".", "shape", "[", "0", "]", "\n", "dkxX_dx", "=", "np", ".", "empty", "(", "(", "b", ",", "n", ",", "d", ")", ")", "\n", "dkxx_dx", "=", "np", ".", "empty", "(", "(", "b", ",", "b", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "            ", "dkxX_dx", "[", ":", ",", ":", ",", "i", "]", "=", "kern", ".", "dK_dX", "(", "x", ",", "X", ",", "i", ")", "\n", "dkxx_dx", "[", ":", ",", ":", ",", "i", "]", "=", "kern", ".", "dK_dX", "(", "x", ",", "x", ",", "i", ")", "\n", "", "K", "=", "kern", ".", "K", "(", "x", ",", "X", ")", "\n", "\n", "grad", "=", "np", ".", "empty", "(", "(", "N", ",", "b", ",", "d", ")", ")", "\n", "dsigma", "=", "np", ".", "zeros", "(", "(", "N", ",", "b", ",", "b", ",", "b", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "b", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "d", ")", ":", "\n", "                ", "Ks", "=", "np", ".", "zeros", "(", "(", "b", ",", "n", ")", ")", "\n", "Ks", "[", "i", ",", ":", "]", "=", "dkxX_dx", "[", "i", ",", ":", ",", "j", "]", "\n", "dKss_dxi", "=", "np", ".", "zeros", "(", "(", "b", ",", "b", ")", ")", "\n", "dKss_dxi", "[", "i", ",", ":", "]", "=", "dkxx_dx", "[", "i", ",", ":", ",", "j", "]", "\n", "dKss_dxi", "[", ":", ",", "i", "]", "=", "dkxx_dx", "[", "i", ",", ":", ",", "j", "]", ".", "T", "\n", "dKss_dxi", "[", "i", ",", "i", "]", "=", "0", "\n", "dsigma", "[", ":", ",", ":", ",", ":", ",", "i", ",", "j", "]", "=", "(", "\n", "dKss_dxi", "[", "None", ",", ":", ",", ":", "]", "\n", "-", "np", ".", "matmul", "(", "np", ".", "matmul", "(", "Ks", "[", "None", ",", ":", ",", ":", "]", ",", "w_inv", ")", ",", "(", "K", ".", "T", ")", "[", "None", ",", ":", ",", ":", "]", ")", "\n", "-", "np", ".", "matmul", "(", "np", ".", "matmul", "(", "K", "[", "None", ",", ":", ",", ":", "]", ",", "w_inv", ")", ",", "(", "Ks", ".", "T", ")", "[", "None", ",", ":", ",", ":", "]", ")", "\n", ")", "\n", "", "", "return", "dsigma", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dmean": [[116, 134], ["numpy.empty", "numpy.empty", "numpy.zeros", "numpy.zeros", "range", "kern.dK_dX", "range", "numpy.matmul().flatten", "numpy.matmul().flatten", "numpy.matmul", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.dK_dX"], ["", "def", "dgp_dmean", "(", "self", ",", "kern", ":", "GPy", ".", "kern", ".", "Kern", ",", "w_vec", ":", "np", ".", "ndarray", ",", "x", ":", "np", ".", "ndarray", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Partial derivatives of the gp posterior samples with respect to the posterior mean\n\n        :param kern: Prior covariance matrix\n        :param w_vec: woodbury vectors of the posterior of the model\n        :param x: The locations the samples are taken at\n        :param X: The locations used to train the GP model\n        :return: the derivative of the gp samples with respect to the mean\n        \"\"\"", "\n", "N", ",", "b", ",", "d", ",", "n", "=", "w_vec", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "X", ".", "shape", "[", "0", "]", "\n", "dkxX_dx", "=", "np", ".", "empty", "(", "(", "b", ",", "n", ",", "d", ")", ")", "\n", "dmu", "=", "np", ".", "zeros", "(", "(", "N", ",", "b", ",", "b", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "            ", "dkxX_dx", "[", ":", ",", ":", ",", "i", "]", "=", "kern", ".", "dK_dX", "(", "x", ",", "X", ",", "i", ")", "\n", "for", "j", "in", "range", "(", "b", ")", ":", "\n", "                ", "dmu", "[", ":", ",", "j", ",", "j", ",", "i", "]", "=", "np", ".", "matmul", "(", "dkxX_dx", "[", "j", ",", ":", ",", "i", "]", "[", "None", ",", ":", "]", ",", "w_vec", "[", ":", ",", ":", ",", "None", "]", ")", ".", "flatten", "(", ")", "# d", "\n", "", "", "return", "dmu", "# N x b x b x d", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dx": [[135, 164], ["expectation_acquisition.ExpectationAcquisition.dgp_dmean", "expectation_acquisition.ExpectationAcquisition.dgp_dSigma", "expectation_acquisition.ExpectationAcquisition.dgp_dL_via_Sigma", "expectation_acquisition.ExpectationAcquisition.dgp_ds_via_L"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dmean", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dSigma", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dL_via_Sigma", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_ds_via_L"], ["", "def", "dgp_dx", "(", "\n", "self", ",", "\n", "s", ":", "np", ".", "ndarray", ",", "\n", "L", ":", "np", ".", "ndarray", ",", "\n", "L_inv", ":", "np", ".", "ndarray", ",", "\n", "w_vec", ":", "np", ".", "ndarray", ",", "\n", "w_inv", ":", "np", ".", "ndarray", ",", "\n", "kern", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "x", ":", "np", ".", "ndarray", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Partial derivatives of the acquisition function values with respect to the sampled observations from the GP using generalised chain rule.\n\n        :param s: Samples of observation from the posterior distribution of the model\n        :param L: Cholesky decomposition(s) of the posterior covariance matrix (samples)\n        :param L_inv: Inverse(s) of Cholesky decomposition(s) of the posterior covariance matrix (samples)\n        :param w_vec: woodbury vectors of the posterior of the model\n        :param w_inv: inverses of the woodbury matrix of the model\n        :param kern: Prior covariance matrix\n        :param x: The locations the samples are taken at\n        :param X: The locations used to train the GP model\n        :return: the derivative of the acquisition function values with respect to the samples\n        \"\"\"", "\n", "dmu_dx", "=", "self", ".", "dgp_dmean", "(", "kern", ",", "w_vec", ",", "x", ",", "X", ")", "\n", "dsigma_dx", "=", "self", ".", "dgp_dSigma", "(", "x", ",", "X", ",", "kern", ",", "w_inv", ")", "# N x b x b x b x d", "\n", "dl_dx", "=", "self", ".", "dgp_dL_via_Sigma", "(", "L", ",", "L_inv", ",", "dsigma_dx", ")", "# N x b x b x b x d", "\n", "dls_dx", "=", "self", ".", "dgp_ds_via_L", "(", "s", ",", "dl_dx", ")", "# N x b x b x d", "\n", "return", "dmu_dx", "+", "dls_dx", "# N x b x b x d", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.acquisition_fun": [[165, 230], ["numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros", "range", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.random.normal", "numpy.sqrt", "numpy.sqrt", "expectation_acquisition.ExpectationAcquisition.opt_val", "expectation_acquisition.ExpectationAcquisition.opt_val_grad", "m.posterior._get_mu_L", "numpy.empty", "numpy.empty", "range", "m.predict_noiseless", "numpy.cholesky", "numpy.cholesky", "numpy.inv", "numpy.inv", "numpy.inv", "numpy.inv", "len", "len", "numpy.matmul", "numpy.matmul", "numpy.sqrt", "numpy.sqrt", "numpy.ones", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.QExpectedImprovement.opt_val", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.QExpectedImprovement.opt_val_grad", "home.repos.pwc.inspect_result.amzn_emukit.inferences.mcmc_batch_comparison.StanPosterior._get_mu_L", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.predict_noiseless"], ["", "def", "acquisition_fun", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "m", ":", "ComparisonGP", ")", "->", "Tuple", "[", "float", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Computes the acquisition function value and acquisition function derivatives at the input locations\n\n        :param x: input location the acquisition and its derivative are evaluated at\n        :param m: the GP model which posterior is used\n        :return: Tuple containing the acquisition function value and its gradients\n        \"\"\"", "\n", "pools", "=", "self", ".", "pool_size", "\n", "N", "=", "self", ".", "acq_samples", "\n", "if", "m", ".", "name", "!=", "\"MCMC\"", ":", "\n", "            ", "pools", "=", "1", "\n", "", "else", ":", "\n", "            ", "if", "pools", "!=", "-", "1", ":", "\n", "                ", "N", "=", "N", "//", "pools", "\n", "Np", "=", "1", "\n", "", "else", ":", "\n", "                ", "pools", "=", "1", "\n", "Np", "=", "N", "\n", "\n", "", "", "x", "=", "np", ".", "array", "(", "x", ")", "\n", "# Assign values as class variables so there is no need to pass them", "\n", "b", ",", "d", ",", "n", "=", "(", "\n", "x", ".", "shape", "[", "0", "]", ",", "\n", "x", ".", "shape", "[", "1", "]", ",", "\n", "m", ".", "X", ".", "shape", "[", "0", "]", ",", "\n", ")", "# size of the batch, dimensions of x, number of samples in the training data", "\n", "\n", "opt_val", "=", "0", "\n", "grad", "=", "np", ".", "zeros", "(", "(", "b", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "pools", ")", ":", "\n", "# Take model specific variables", "\n", "            ", "if", "m", ".", "name", "==", "\"MCMC\"", ":", "\n", "# We take predictive mu and L (Sigma = L L^T) of the posterior", "\n", "                ", "mu", ",", "L", ",", "w_inv", ",", "w_vec", "=", "m", ".", "posterior", ".", "_get_mu_L", "(", "x", ",", "N", "=", "Np", ",", "woodbury_inv", "=", "True", ")", "\n", "L_inv", "=", "np", ".", "empty", "(", "L", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "L", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "L_inv", "[", "i", ",", ":", ",", ":", "]", "=", "la", ".", "inv", "(", "L", "[", "i", ",", ":", ",", ":", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "mu", ",", "Sigma", "=", "m", ".", "predict_noiseless", "(", "x", ",", "full_cov", "=", "True", ")", "\n", "if", "len", "(", "Sigma", ".", "shape", ")", "==", "3", ":", "\n", "                    ", "Sigma", "=", "Sigma", "[", ":", ",", ":", ",", "0", "]", "\n", "", "L", "=", "la", ".", "cholesky", "(", "Sigma", ")", "\n", "L_inv", "=", "la", ".", "inv", "(", "L", ")", "\n", "mu", ",", "L", ",", "L_inv", "=", "mu", "[", "None", ",", ":", ",", "0", "]", ",", "L", "[", "None", ",", ":", ",", ":", "]", ",", "L_inv", "[", "None", ",", ":", ",", ":", "]", "\n", "w_inv", "=", "m", ".", "posterior", ".", "woodbury_inv", "[", "None", ",", ":", ",", ":", "]", "\n", "w_vec", "=", "m", ".", "posterior", ".", "woodbury_vector", "[", "None", ",", ":", ",", "0", "]", "\n", "if", "len", "(", "w_inv", ".", "shape", ")", ">", "3", ":", "\n", "                    ", "w_inv", "=", "w_inv", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "\n", "# Sample from N(0,I)", "\n", "", "", "s", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "N", ",", "b", ")", ")", "\n", "s2", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "N", ",", "b", ")", ")", "\n", "# Generate samples for stochastic estimation of the expectation from the", "\n", "f", "=", "mu", "+", "np", ".", "matmul", "(", "L", ",", "s", "[", ":", ",", ":", ",", "None", "]", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "y", "=", "f", "+", "np", ".", "sqrt", "(", "m", ".", "sigma2s", "[", "0", "]", ")", "*", "s2", "[", ":", ",", ":", "]", "\n", "\n", "sqrt_nu", "=", "np", ".", "sqrt", "(", "m", ".", "sigma2s", "[", "0", "]", "*", "np", ".", "ones", "(", "b", ")", ")", "\n", "\n", "# Compute acquisition function value", "\n", "opt_val", "+=", "self", ".", "opt_val", "(", "f", ",", "y", ",", "m", ",", "sqrt_nu", ")", "\n", "\n", "grad", "+=", "self", ".", "opt_val_grad", "(", "s", ",", "f", ",", "y", ",", "m", ",", "sqrt_nu", ",", "L", ",", "L_inv", ",", "w_vec", ",", "w_inv", ",", "x", ")", "\n", "\n", "", "return", "-", "opt_val", "/", "pools", ",", "-", "grad", "/", "pools", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.acquisition_fun_flat": [[231, 251], ["numpy.atleast_2d", "numpy.atleast_2d", "numpy.empty", "numpy.empty", "range", "time.time", "expectation_acquisition.ExpectationAcquisition.acquisition_fun", "numpy.concatenate", "numpy.concatenate", "numpy.array().reshape", "numpy.array().reshape", "X_i.reshape", "dpdX_i.flatten().reshape", "numpy.array", "numpy.array", "dpdX_i.flatten"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.acquisition_fun"], ["", "def", "acquisition_fun_flat", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "m", ":", "ComparisonGP", ")", "->", "Tuple", "[", "float", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Wrapper for acquisition_fun, where X is considered as a vector\n\n        :param X: input location the acquisition and its derivative are evaluated at\n        :param m: the GP model which posterior is used\n        :return: Tuple containing the acquisition function value and its gradients\n        \"\"\"", "\n", "X", "=", "np", ".", "atleast_2d", "(", "X", ")", "\n", "n", "=", "m", ".", "X", ".", "shape", "[", "1", "]", "\n", "k", "=", "X", ".", "shape", "[", "1", "]", "//", "n", "\n", "opt_val", "=", "[", "]", "\n", "dpdX", "=", "np", ".", "empty", "(", "(", "0", ",", "n", "*", "k", ")", ")", "\n", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "X_i", "=", "X", "[", "i", ",", ":", "]", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "(", "opt_val_i", ",", "dpdX_i", ")", "=", "self", ".", "acquisition_fun", "(", "X_i", ".", "reshape", "(", "k", ",", "n", ")", ",", "m", ")", "\n", "opt_val", "+=", "[", "opt_val_i", "]", "\n", "dpdX", "=", "np", ".", "concatenate", "(", "(", "dpdX", ",", "dpdX_i", ".", "flatten", "(", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", ")", ",", "axis", "=", "0", ")", "\n", "", "return", "np", ".", "array", "(", "opt_val", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "dpdX", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.acq_fun_optimizer": [[252, 306], ["numpy.tile", "numpy.tile", "range", "util.random_sample", "get_logger().info", "expectation_acquisition.ExpectationAcquisition.acquisition_fun_flat", "get_logger().debug", "scipy.optimize.minimize", "scipy.optimize.minimize.x.reshape", "get_logger().debug", "X0.reshape.reshape.reshape", "get_logger", "X0.reshape.reshape.flatten", "len", "len", "get_logger().error", "get_logger", "X0.reshape.reshape.flatten", "X0.reshape.reshape.flatten", "get_logger", "get_logger"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.random_sample", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.acquisition_fun_flat", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger"], ["", "def", "acq_fun_optimizer", "(", "\n", "self", ",", "m", ":", "ComparisonGP", ",", "bounds", ":", "np", ".", "ndarray", ",", "batch_size", ":", "int", ",", "get_logger", ":", "Callable", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Implements the optimization scheme for the sampling based acquisition function\n\n        :param m: The model which posterior is used by the acquisition function (from which the samples are drawn from)\n        :param bounds: the optimization bounds of the new sample\n        :param batch_size: How many points are there in the batch\n        :param get_logger: Function for receiving the legger where the prints are forwarded.\n        :return: optimized locations\n        \"\"\"", "\n", "\n", "X", "=", "None", "# Will hold the final choice", "\n", "y", "=", "None", "# Will hold the expected improvement of the final choice", "\n", "\n", "# Run local gradient-descent optimizer multiple times", "\n", "# to avoid getting stuck in a poor local optimum", "\n", "# Tile bounds to match batch size", "\n", "# print(self.batch_size)", "\n", "\n", "bounds_tiled", "=", "np", ".", "tile", "(", "bounds", ",", "(", "batch_size", ",", "1", ")", ")", "\n", "\n", "xss", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "self", ".", "acq_opt_restarts", ")", ":", "\n", "# Initial point of the optimization", "\n", "            ", "X0", "=", "util", ".", "random_sample", "(", "bounds", ",", "batch_size", ")", "\n", "get_logger", "(", ")", ".", "info", "(", "\"acq opt restart {}\"", ".", "format", "(", "j", ")", ")", "\n", "try", ":", "\n", "                ", "f_", ",", "_", "=", "self", ".", "acquisition_fun_flat", "(", "X0", ".", "flatten", "(", ")", ",", "m", ")", "\n", "get_logger", "(", ")", ".", "debug", "(", "\"Starting from: {} with acq {}\"", ".", "format", "(", "X0", ".", "flatten", "(", ")", ",", "f_", ")", ")", "\n", "res", "=", "sp", ".", "optimize", ".", "minimize", "(", "\n", "fun", "=", "self", ".", "acquisition_fun_flat", ",", "\n", "x0", "=", "X0", ".", "flatten", "(", ")", ",", "\n", "args", "=", "(", "m", ")", ",", "\n", "method", "=", "\"L-BFGS-B\"", ",", "\n", "jac", "=", "True", ",", "\n", "bounds", "=", "bounds_tiled", ",", "\n", "options", "=", "self", ".", "optimizer_options", ",", "\n", ")", "\n", "X0", "=", "res", ".", "x", ".", "reshape", "(", "batch_size", ",", "len", "(", "bounds", ")", ")", "\n", "y0", "=", "res", ".", "fun", "\n", "get_logger", "(", ")", ".", "debug", "(", "\"Ended to: {} with acq {}\"", ".", "format", "(", "X0", ",", "y0", ")", ")", "\n", "# Update X if the current local minimum is", "\n", "# the best one found so far", "\n", "X0", "=", "X0", ".", "reshape", "(", "batch_size", ",", "len", "(", "bounds", ")", ")", "\n", "if", "X", "is", "None", "or", "y0", "<", "y", ":", "\n", "                    ", "X", "=", "X0", "\n", "y", "=", "y0", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "                ", "get_logger", "(", ")", ".", "error", "(", "\"Solver failed. Below the exception\\n{}\"", ".", "format", "(", "e", ")", ")", "\n", "# Assert that at least one optimization run succesfully", "\n", "", "", "assert", "X", "is", "not", "None", "\n", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.evaluate": [[307, 315], ["expectation_acquisition.ExpectationAcquisition.acquisition_fun_flat"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.acquisition_fun_flat"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "model", ":", "ComparisonGPEmukitWrapper", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the acquisition function at a batch.\n        :param x: points where the acquisition is evaluated.\n        :param batch_size: How many points are there in the batch.\n        :return: acquisition function value evaluated at the batch\n        \"\"\"", "\n", "return", "self", ".", "acquisition_fun_flat", "(", "x", ",", "model", ".", "model", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.evaluate_with_gradients": [[316, 324], ["expectation_acquisition.ExpectationAcquisition.acquisition_fun_flat"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.acquisition_fun_flat"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "model", ":", "ComparisonGPEmukitWrapper", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Computes the acquisition function at a batch.\n        :param x: points where the acquisition is evaluated.\n        :param batch_size: How many points are there in the batch.\n        :return: A tuple containing acquisition function value evaluated at the batch and its gradient\n        \"\"\"", "\n", "return", "self", ".", "acquisition_fun_flat", "(", "x", ",", "model", ".", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.SumOfVariances.opt_val": [[331, 352], ["numpy.zeros", "numpy.zeros", "range", "numpy.sum", "numpy.sum", "numpy.prod", "numpy.prod", "phi", "numpy.mean", "numpy.mean", "range", "numpy.mean", "numpy.mean"], "methods", ["None"], ["def", "opt_val", "(", "self", ",", "f", ":", "np", ".", "ndarray", ",", "y", ":", "np", ".", "ndarray", ",", "m", ":", "ComparisonGP", ",", "sqrt_nu", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        computes the acquisition function value by sampling\n\n        :param f: latent function samples of the posterior\n        :param y: observations from the latent functio (latent function values corrupted with noise)\n        :param m: the model which posterior is used\n        :param sqrt_nu: noise std for the observations\n        :return: Sum of variances at the input\n        \"\"\"", "\n", "liks", "=", "np", ".", "zeros", "(", "f", ".", "shape", "[", "1", "]", ")", "\n", "for", "i", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", ":", "# Loop through each member being the batch winner (lower value better)", "\n", "            ", "mi", "=", "[", "k", "for", "k", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", "if", "k", "is", "not", "i", "]", "# select all indices but the batch winner", "\n", "prs", "=", "np", ".", "prod", "(", "\n", "phi", "(", "(", "f", "[", ":", ",", "mi", "]", "-", "y", "[", ":", ",", "i", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "mi", "]", ")", ",", "axis", "=", "1", "\n", ")", "# Equation 3 in the draft (or the simplified version of it at the end of Section 2.2)", "\n", "prs2", "=", "prs", "**", "2", "\n", "liks", "[", "i", "]", "=", "(", "\n", "np", ".", "mean", "(", "prs2", ",", "axis", "=", "0", ")", "-", "np", ".", "mean", "(", "prs", ",", "axis", "=", "0", ")", "**", "2", "\n", ")", "# Variance of p(y_i \\leq y_j \\forall i \\neq j) weighted by p(y_i \\leq y_j \\forall i \\neq j)", "\n", "", "return", "np", ".", "sum", "(", "liks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.SumOfVariances.opt_val_grad": [[353, 397], ["expectation_acquisition.SumOfVariances.opt_val_s", "expectation_acquisition.SumOfVariances.opt_val_s_grad", "numpy.zeros", "numpy.zeros", "range", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.SumOfVariances.opt_val_s", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.SumOfVariances.opt_val_s_grad"], ["", "def", "opt_val_grad", "(", "\n", "self", ",", "\n", "s", ":", "np", ".", "ndarray", ",", "\n", "f", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "np", ".", "ndarray", ",", "\n", "m", ":", "ComparisonGP", ",", "\n", "sqrt_nu", ":", "np", ".", "ndarray", ",", "\n", "L", ":", "np", ".", "ndarray", ",", "\n", "L_inv", ":", "np", ".", "ndarray", ",", "\n", "w_vec", ":", "np", ".", "ndarray", ",", "\n", "w_inv", ":", "np", ".", "ndarray", ",", "\n", "x", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        computes the acquisition function value by sampling\n\n        :param f: latent function samples of the posterior\n        :param y: observations from the latent functio (latent function values corrupted with noise)\n        :param m: the model which posterior is used\n        :param sqrt_nu: noise std for the observations\n        :param L: Cholesky decomposition(s) of the posterior covariance matrix (samples)\n        :param L_inv: Inverse(s) of Cholesky decomposition(s) of the posterior covariance matrix (samples)\n        :param w_vec: woodbury vectors of the posterior of the model\n        :param w_inv: inverses of the woodbury matrix of the model\n        :param x: The locations the samples are taken at\n        :return: Gradient of Sum of variances at the input\n        \"\"\"", "\n", "\n", "N", ",", "b", ",", "d", ",", "n", "=", "f", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "m", ".", "X", ".", "shape", "[", "0", "]", "\n", "\n", "# compute the likelihood of each batch sample (equation at the end of 2.2 in the draft)", "\n", "val_s", "=", "self", ".", "opt_val_s", "(", "f", ",", "y", ",", "m", ",", "sqrt_nu", ")", "\n", "\n", "# compute the gradient of the likelihood of each batch sample using generalized chain rule", "\n", "val_s_grad", "=", "self", ".", "opt_val_s_grad", "(", "s", ",", "f", ",", "y", ",", "m", ",", "sqrt_nu", ",", "L", ",", "L_inv", ",", "w_vec", ",", "w_inv", ",", "x", ")", "\n", "\n", "grad", "=", "np", ".", "zeros", "(", "(", "b", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "b", ")", ":", "# Loop through winner index and compute the gradient of the likelihood", "\n", "            ", "grad", "=", "(", "\n", "grad", "\n", "+", "np", ".", "mean", "(", "2.0", "*", "val_s", "[", ":", ",", "i", ",", "None", ",", "None", "]", "*", "val_s_grad", "[", ":", ",", "i", ",", ":", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "-", "2.0", "*", "np", ".", "mean", "(", "val_s", "[", ":", ",", "i", "]", ",", "axis", "=", "0", ")", "*", "np", ".", "mean", "(", "val_s_grad", "[", ":", ",", "i", ",", ":", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", ")", "\n", "", "return", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.SumOfVariances.opt_val_s": [[398, 413], ["numpy.zeros", "numpy.zeros", "range", "numpy.prod", "numpy.prod", "phi", "range"], "methods", ["None"], ["", "def", "opt_val_s", "(", "self", ",", "f", ":", "np", ".", "ndarray", ",", "y", ":", "np", ".", "ndarray", ",", "m", ":", "ComparisonGP", ",", "sqrt_nu", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes $ \\prod_{i=1, i \\neq j}^q p(y_j < y_i)$ for each sample from the latent function.\n\n        :param f: latent function samples of the posterior\n        :param y: observations from the latent functio (latent function values corrupted with noise)\n        :param m: the model which posterior is used\n        :param sqrt_nu: noise std for the observations\n        :return: product of probabilities of comparisons for each sample\n        \"\"\"", "\n", "opt_vals", "=", "np", ".", "zeros", "(", "f", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "mi", "=", "[", "k", "for", "k", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", "if", "k", "is", "not", "i", "]", "\n", "opt_vals", "[", ":", ",", "i", "]", "=", "np", ".", "prod", "(", "phi", "(", "(", "f", "[", ":", ",", "mi", "]", "-", "y", "[", ":", ",", "i", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "mi", "]", ")", ",", "axis", "=", "1", ")", "\n", "", "return", "opt_vals", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.SumOfVariances.opt_val_s_grad": [[414, 448], ["expectation_acquisition.SumOfVariances.dopt_val_s_df", "expectation_acquisition.SumOfVariances.dgp_dx", "numpy.zeros", "numpy.zeros", "range", "range", "range", "numpy.matmul().flatten", "numpy.matmul().flatten", "numpy.matmul", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.SumOfVariances.dopt_val_s_df", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dx"], ["", "def", "opt_val_s_grad", "(", "\n", "self", ",", "\n", "s", ":", "np", ".", "ndarray", ",", "\n", "f", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "np", ".", "ndarray", ",", "\n", "m", ":", "ComparisonGP", ",", "\n", "sqrt_nu", ":", "np", ".", "ndarray", ",", "\n", "L", ":", "np", ".", "ndarray", ",", "\n", "L_inv", ":", "np", ".", "ndarray", ",", "\n", "w_vec", ":", "np", ".", "ndarray", ",", "\n", "w_inv", ":", "np", ".", "ndarray", ",", "\n", "x", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the gradient of $\\prod_{i=1, i \\neq j}^q p(y_j < y_i)$ for each sample from the latent function.\n\n        :param f: latent function samples of the posterior\n        :param y: observations from the latent functio (latent function values corrupted with noise)\n        :param m: the model which posterior is used\n        :param sqrt_nu: noise std for the observations\n        :return: gradient of product of probabilities of comparisons for each sample\n        \"\"\"", "\n", "N", ",", "b", ",", "d", ",", "n", "=", "f", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "m", ".", "X", ".", "shape", "[", "0", "]", "\n", "# Compute gradients using the generalized chain rule:", "\n", "opt_val_s_gradient_f", "=", "self", ".", "dopt_val_s_df", "(", "f", ",", "y", ",", "m", ",", "sqrt_nu", ")", "# N x b x b", "\n", "gradient_f_x", "=", "self", ".", "dgp_dx", "(", "s", ",", "L", ",", "L_inv", ",", "w_vec", ",", "w_inv", ",", "m", ".", "kern", ",", "x", ",", "m", ".", "X", ")", "# N x b x b x d", "\n", "grad", "=", "np", ".", "zeros", "(", "(", "N", ",", "b", ",", "b", ",", "d", ")", ")", "\n", "for", "k", "in", "range", "(", "b", ")", ":", "# batch winner", "\n", "            ", "for", "i", "in", "range", "(", "b", ")", ":", "# batch member", "\n", "                ", "for", "j", "in", "range", "(", "d", ")", ":", "# dimension of the batch member", "\n", "                    ", "grad", "[", ":", ",", "k", ",", "i", ",", "j", "]", "=", "np", ".", "matmul", "(", "\n", "opt_val_s_gradient_f", "[", ":", ",", "k", ",", "None", ",", ":", "]", ",", "gradient_f_x", "[", ":", ",", ":", ",", "None", ",", "i", ",", "j", "]", "\n", ")", ".", "flatten", "(", ")", "\n", "", "", "", "return", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.SumOfVariances.dopt_val_s_df": [[449, 477], ["numpy.zeros", "numpy.zeros", "range", "range", "numpy.prod", "numpy.prod", "numpy.prod", "numpy.prod", "range", "npdf", "phi", "npdf", "phi"], "methods", ["None"], ["", "def", "dopt_val_s_df", "(", "self", ",", "f", ":", "np", ".", "ndarray", ",", "y", ":", "np", ".", "ndarray", ",", "m", ":", "ComparisonGP", ",", "sqrt_nu", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the gradient of $\\prod_{i=1, i \\neq j}^q p(y_j < y_i)$ for each sample from the latent function with respect to the GP\n\n        :param f: latent function samples of the posterior\n        :param y: observations from the latent functio (latent function values corrupted with noise)\n        :param m: the model which posterior is used\n        :param sqrt_nu: noise std for the observations\n        :return: gradient of product of probabilities of comparisons for each sample with respect to the GP\n        \"\"\"", "\n", "dl", "=", "np", ".", "zeros", "(", "(", "f", ".", "shape", "[", "0", "]", ",", "f", ".", "shape", "[", "1", "]", ",", "f", ".", "shape", "[", "1", "]", ")", ")", "# samples, winner , derivative index", "\n", "for", "i", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", ":", "# loop through winner index", "\n", "            ", "for", "j", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", ":", "# loop through f to derivate with respect to", "\n", "                ", "if", "j", "is", "not", "i", ":", "\n", "                    ", "mij", "=", "[", "k", "for", "k", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", "if", "(", "k", "is", "not", "i", ")", "and", "(", "k", "is", "not", "j", ")", "]", "\n", "dl", "[", ":", ",", "i", ",", "i", "]", "+=", "(", "\n", "-", "1.0", "\n", "/", "sqrt_nu", "[", "j", "]", "\n", "*", "npdf", "(", "(", "f", "[", ":", ",", "j", "]", "-", "y", "[", ":", ",", "i", "]", ")", "/", "sqrt_nu", "[", "j", "]", ",", "0", ",", "1", ")", "\n", "*", "np", ".", "prod", "(", "phi", "(", "(", "f", "[", ":", ",", "mij", "]", "-", "y", "[", ":", ",", "i", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "mij", "]", ")", ",", "axis", "=", "1", ")", "\n", ")", "\n", "dl", "[", ":", ",", "i", ",", "j", "]", "=", "(", "\n", "1.0", "\n", "/", "sqrt_nu", "[", "j", "]", "\n", "*", "npdf", "(", "(", "f", "[", ":", ",", "j", "]", "-", "y", "[", ":", ",", "i", "]", ")", "/", "sqrt_nu", "[", "j", "]", ",", "0", ",", "1", ")", "\n", "*", "np", ".", "prod", "(", "phi", "(", "(", "f", "[", ":", ",", "mij", "]", "-", "y", "[", ":", ",", "i", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "mij", "]", ")", ",", "axis", "=", "1", ")", "\n", ")", "\n", "", "", "", "return", "dl", "# n x b x b", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.QExpectedImprovement.opt_val": [[484, 504], ["m.get_current_best", "numpy.zeros", "numpy.zeros", "range", "numpy.mean", "numpy.mean", "numpy.sum", "numpy.sum", "numpy.prod", "numpy.prod", "range", "numpy.array", "numpy.array", "phi"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.get_current_best"], ["def", "opt_val", "(", "self", ",", "f", ":", "np", ".", "ndarray", ",", "y", ":", "np", ".", "ndarray", ",", "m", ":", "ComparisonGP", ",", "sqrt_nu", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        computes the acquisition function value by sampling\n\n        :param f: latent function samples of the posterior\n        :param y: observations from the latent functio (latent function values corrupted with noise)\n        :param m: the model which posterior is used\n        :param sqrt_nu: noise std for the observations\n        :return: q Expected Improvement at the input\n        \"\"\"", "\n", "yw", "=", "m", ".", "get_current_best", "(", ")", "\n", "liks", "=", "np", ".", "zeros", "(", "f", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", ":", "# Loop through batch winners (lower value better)", "\n", "            ", "mi", "=", "[", "k", "for", "k", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", "if", "k", "is", "not", "i", "]", "\n", "liks", "[", ":", ",", "i", "]", "=", "(", "\n", "(", "y", "[", ":", ",", "i", "]", "<", "yw", ")", "\n", "*", "np", ".", "array", "(", "yw", "-", "y", "[", ":", ",", "i", "]", ")", "\n", "*", "np", ".", "prod", "(", "phi", "(", "(", "f", "[", ":", ",", "mi", "]", "-", "y", "[", ":", ",", "i", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "mi", "]", ")", ",", "axis", "=", "1", ")", "\n", ")", "\n", "", "return", "np", ".", "mean", "(", "np", ".", "sum", "(", "liks", ",", "axis", "=", "1", ")", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.QExpectedImprovement.opt_val_grad": [[505, 541], ["expectation_acquisition.QExpectedImprovement.dopt_val_df", "expectation_acquisition.QExpectedImprovement.dgp_dx", "numpy.zeros", "numpy.zeros", "range", "numpy.mean", "numpy.mean", "range", "numpy.matmul().flatten", "numpy.matmul().flatten", "numpy.matmul", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.QExpectedImprovement.dopt_val_df", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.ExpectationAcquisition.dgp_dx"], ["", "def", "opt_val_grad", "(", "\n", "self", ",", "\n", "s", ":", "np", ".", "ndarray", ",", "\n", "f", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "np", ".", "ndarray", ",", "\n", "m", ":", "ComparisonGP", ",", "\n", "sqrt_nu", ":", "np", ".", "ndarray", ",", "\n", "L", ":", "np", ".", "ndarray", ",", "\n", "L_inv", ":", "np", ".", "ndarray", ",", "\n", "w_vec", ":", "np", ".", "ndarray", ",", "\n", "w_inv", ":", "np", ".", "ndarray", ",", "\n", "x", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        computes the acquisition function value by sampling\n\n        :param f: latent function samples of the posterior\n        :param y: observations from the latent functio (latent function values corrupted with noise)\n        :param m: the model which posterior is used\n        :param sqrt_nu: noise std for the observations\n        :param L: Cholesky decomposition(s) of the posterior covariance matrix (samples)\n        :param L_inv: Inverse(s) of Cholesky decomposition(s) of the posterior covariance matrix (samples)\n        :param w_vec: woodbury vectors of the posterior of the model\n        :param w_inv: inverses of the woodbury matrix of the model\n        :param x: The locations the samples are taken at\n        :return: Gradient of q Expected Improvement at the input\n        \"\"\"", "\n", "N", ",", "b", ",", "d", ",", "n", "=", "f", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "m", ".", "X", ".", "shape", "[", "0", "]", "\n", "# Compute gradients using the generalized chain rule:", "\n", "opt_val_gradient_f", "=", "self", ".", "dopt_val_df", "(", "f", ",", "y", ",", "m", ",", "sqrt_nu", ")", "# N x b", "\n", "gradient_f_x", "=", "self", ".", "dgp_dx", "(", "s", ",", "L", ",", "L_inv", ",", "w_vec", ",", "w_inv", ",", "m", ".", "kern", ",", "x", ",", "m", ".", "X", ")", "# N x b x b x d", "\n", "grad", "=", "np", ".", "zeros", "(", "(", "N", ",", "b", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "b", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "d", ")", ":", "\n", "                ", "grad", "[", ":", ",", "i", ",", "j", "]", "=", "np", ".", "matmul", "(", "opt_val_gradient_f", "[", ":", ",", "None", ",", ":", "]", ",", "gradient_f_x", "[", ":", ",", ":", ",", "None", ",", "i", ",", "j", "]", ")", ".", "flatten", "(", ")", "\n", "", "", "return", "np", ".", "mean", "(", "grad", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.QExpectedImprovement.dopt_val_df": [[542, 574], ["m.get_current_best", "numpy.zeros", "numpy.zeros", "range", "range", "range", "numpy.prod", "numpy.prod", "phi", "range", "numpy.prod", "numpy.prod", "numpy.prod", "numpy.prod", "npdf", "phi", "npdf", "phi"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.get_current_best"], ["", "def", "dopt_val_df", "(", "self", ",", "f", ":", "np", ".", "ndarray", ",", "y", ":", "np", ".", "ndarray", ",", "m", ":", "ComparisonGP", ",", "sqrt_nu", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        computes the gradient of the acquisition function value with respect to each input location and gp sample\n\n        :param f: latent function samples of the posterior\n        :param y: observations from the latent functio (latent function values corrupted with noise)\n        :param m: the model which posterior is used\n        :param sqrt_nu: noise std for the observations\n        :return: gradient of the acquisition function value with respect to each input location and gp sample\n        \"\"\"", "\n", "yw", "=", "m", ".", "get_current_best", "(", ")", "\n", "dl", "=", "np", ".", "zeros", "(", "f", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", ":", "# loop through f to derivate with respect to", "\n", "            ", "mi", "=", "[", "k", "for", "k", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", "if", "(", "k", "is", "not", "i", ")", "]", "\n", "dl", "[", ":", ",", "i", "]", "=", "dl", "[", ":", ",", "i", "]", "-", "np", ".", "prod", "(", "phi", "(", "(", "f", "[", ":", ",", "mi", "]", "-", "y", "[", ":", ",", "i", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "mi", "]", ")", ",", "axis", "=", "1", ")", "*", "(", "y", "[", ":", ",", "i", "]", "<", "yw", ")", "\n", "for", "j", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "if", "j", "is", "not", "i", ":", "\n", "                    ", "mij", "=", "[", "k", "for", "k", "in", "range", "(", "f", ".", "shape", "[", "1", "]", ")", "if", "(", "k", "is", "not", "i", ")", "and", "(", "k", "is", "not", "j", ")", "]", "\n", "dl", "[", ":", ",", "i", "]", "=", "(", "\n", "dl", "[", ":", ",", "i", "]", "\n", "-", "(", "y", "[", ":", ",", "i", "]", "<", "yw", ")", "\n", "*", "(", "yw", "-", "y", "[", ":", ",", "i", "]", ")", "\n", "/", "sqrt_nu", "[", "j", "]", "\n", "*", "npdf", "(", "(", "f", "[", ":", ",", "j", "]", "-", "y", "[", ":", ",", "i", "]", ")", "/", "sqrt_nu", "[", "j", "]", ",", "0", ",", "1", ")", "\n", "*", "np", ".", "prod", "(", "phi", "(", "(", "f", "[", ":", ",", "mij", "]", "-", "y", "[", ":", ",", "i", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "mij", "]", ")", ",", "axis", "=", "1", ")", "\n", "+", "(", "y", "[", ":", ",", "j", "]", "<", "yw", ")", "\n", "*", "(", "yw", "-", "y", "[", ":", ",", "j", "]", ")", "\n", "/", "sqrt_nu", "[", "i", "]", "\n", "*", "npdf", "(", "(", "f", "[", ":", ",", "i", "]", "-", "y", "[", ":", ",", "j", "]", ")", "/", "sqrt_nu", "[", "i", "]", ",", "0", ",", "1", ")", "\n", "*", "np", ".", "prod", "(", "phi", "(", "(", "f", "[", ":", ",", "mij", "]", "-", "y", "[", ":", ",", "j", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "mij", "]", ")", ",", "axis", "=", "1", ")", "\n", ")", "# first line: i is winner second line: j is winner", "\n", "", "", "", "return", "dl", "# n x b", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.dK_dX": [[18, 32], ["expectation_acquisition.._scaled_dist", "expectation_acquisition..K_of_r", "numpy.ones"], "function", ["None"], ["def", "dK_dX", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "X2", ":", "np", ".", "ndarray", ",", "dimX", ":", "int", ")", ":", "\n", "    ", "\"\"\"\n    Derivative of RBF kernel with respect to input X\n\n    :param X: First input\n    :param X2: Second input\n    :param dimX: dimension of X the derivative is wanted at\n    :return: Derivative of the kernel with respect to the wanted dimension of X\n    \"\"\"", "\n", "r", "=", "self", ".", "_scaled_dist", "(", "X", ",", "X2", ")", "\n", "K", "=", "self", ".", "K_of_r", "(", "r", ")", "\n", "dist", "=", "X", "[", ":", ",", "None", ",", "dimX", "]", "-", "X2", "[", "None", ",", ":", ",", "dimX", "]", "\n", "lengthscale2inv", "=", "(", "np", ".", "ones", "(", "(", "X", ".", "shape", "[", "1", "]", ")", ")", "/", "(", "self", ".", "lengthscale", "**", "2", ")", ")", "[", "dimX", "]", "\n", "return", "-", "1.0", "*", "K", "*", "dist", "*", "lengthscale2inv", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.integrated_variance.IntegratedVarianceReduction.__init__": [[21, 50], ["int", "core.initial_designs.RandomDesign", "core.initial_designs.RandomDesign.get_samples", "space.check_points_in_domain", "numpy.all", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "ICalculateVarianceReduction", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "x_monte_carlo", "=", "None", ",", "\n", "num_monte_carlo_points", ":", "int", "=", "int", "(", "1e5", ")", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param model: The emulation model\n        :param space: The parameter space to select points within\n        :param x_monte_carlo: The points to evaluate the GP at in order to estimate the integral of the variance.\n                              Can be None and we will randomly sample within the constraints defined by the space.\n        :param num_monte_carlo_points: Number of points to use to do Monte Carlo integration of variance.\n                                       Not used if x_monte_carlo supplied.\n        \"\"\"", "\n", "\n", "self", ".", "model", "=", "model", "\n", "\n", "if", "x_monte_carlo", "is", "None", ":", "\n", "# Use RandomDesign to generate random points to do Monte Carlo integration", "\n", "# while respecting any constraints", "\n", "            ", "random_design", "=", "RandomDesign", "(", "space", ")", "\n", "self", ".", "_x_monte_carlo", "=", "random_design", ".", "get_samples", "(", "num_monte_carlo_points", ")", "\n", "", "else", ":", "\n", "# Use user supplied points", "\n", "            ", "in_domain", "=", "space", ".", "check_points_in_domain", "(", "x_monte_carlo", ")", "\n", "if", "not", "np", ".", "all", "(", "in_domain", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"Some or all of the points in x_monte_carlo are out of the valid domain.\"", ")", "\n", "", "self", ".", "_x_monte_carlo", "=", "x_monte_carlo", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.integrated_variance.IntegratedVarianceReduction.evaluate": [[51, 67], ["numpy.zeros", "range", "np.zeros.IntegratedVarianceReduction.model.calculate_variance_reduction", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.calculate_variance_reduction"], ["", "", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :param x: The new training point(s) to evaluate with shape (n_points x 1)\n        :return: A numpy array with shape (n_points x 1)\n                 containing the values of the acquisition evaluated at each x row\n        \"\"\"", "\n", "\n", "n_eval_points", "=", "x", ".", "shape", "[", "0", "]", "\n", "integrated_variance", "=", "np", ".", "zeros", "(", "(", "n_eval_points", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "n_eval_points", ")", ":", "\n", "# Find variance reduction at each Monte Carlo point", "\n", "            ", "variance_reduction", "=", "self", ".", "model", ".", "calculate_variance_reduction", "(", "x", "[", "[", "i", "]", ",", ":", "]", ",", "self", ".", "_x_monte_carlo", ")", "\n", "# Take mean to approximate integral per unit volume", "\n", "integrated_variance", "[", "i", "]", "=", "np", ".", "mean", "(", "variance_reduction", ")", "\n", "\n", "", "return", "integrated_variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.integrated_variance.IntegratedVarianceReduction.has_gradients": [[68, 71], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.model_variance.ModelVariance.__init__": [[18, 20], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "Union", "[", "IModel", ",", "IDifferentiable", "]", ")", "->", "None", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.model_variance.ModelVariance.evaluate": [[21, 24], ["model_variance.ModelVariance.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "_", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "return", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.model_variance.ModelVariance.evaluate_with_gradients": [[25, 29], ["model_variance.ModelVariance.model.predict", "model_variance.ModelVariance.model.get_prediction_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "_", ",", "variance", "=", "self", ".", "model", ".", "predict", "(", "x", ")", "\n", "_", ",", "dvariance_dx", "=", "self", ".", "model", ".", "get_prediction_gradients", "(", "x", ")", "\n", "return", "variance", ",", "dvariance_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.model_variance.ModelVariance.has_gradients": [[30, 33], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "return", "isinstance", "(", "self", ".", "model", ",", "IDifferentiable", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loops.bayesian_optimization_loop.BayesianOptimizationLoop.__init__": [[23, 70], ["core.loop.FixedIntervalUpdater", "core.loop.loop_state.create_loop_state", "core.loop.OuterLoop.__init__", "acquisitions.ExpectedImprovement", "core.optimization.GradientAcquisitionOptimizer", "_log.info", "core.loop.SequentialPointCalculator", "_log.info", "acquisitions.log_acquisition.LogAcquisition", "local_penalization_calculator.LocalPenalizationPointCalculator", "str"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "model", ":", "IModel", ",", "\n", "acquisition", ":", "Acquisition", "=", "None", ",", "\n", "update_interval", ":", "int", "=", "1", ",", "\n", "batch_size", ":", "int", "=", "1", ",", "\n", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", "=", "None", ",", "\n", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Emukit class that implement a loop for building modular Bayesian optimization\n\n        :param space: Input space where the optimization is carried out.\n        :param model: The model that approximates the underlying function\n        :param acquisition: The acquisition function that will be used to collect new points (default, EI). If batch\n                            size is greater than one, this acquisition must output positive values only.\n        :param update_interval: Number of iterations between optimization of model hyper-parameters. Defaults to 1.\n        :param batch_size: How many points to evaluate in one iteration of the optimization loop. Defaults to 1.\n        :param acquisition_optimizer: Optimizer selecting next evaluation points\n                                      by maximizing acquisition.\n                                      Gradient based optimizer is used if None.\n                                      Defaults to None.\n        \"\"\"", "\n", "\n", "self", ".", "model", "=", "model", "\n", "\n", "if", "acquisition", "is", "None", ":", "\n", "            ", "acquisition", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "", "model_updaters", "=", "FixedIntervalUpdater", "(", "model", ",", "update_interval", ")", "\n", "\n", "if", "acquisition_optimizer", "is", "None", ":", "\n", "            ", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "", "if", "batch_size", "==", "1", ":", "\n", "            ", "_log", ".", "info", "(", "\"Batch size is 1, using SequentialPointCalculator\"", ")", "\n", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ")", "\n", "", "else", ":", "\n", "            ", "_log", ".", "info", "(", "\"Batch size is \"", "+", "str", "(", "batch_size", ")", "+", "\", using LocalPenalizationPointCalculator\"", ")", "\n", "log_acquisition", "=", "LogAcquisition", "(", "acquisition", ")", "\n", "candidate_point_calculator", "=", "LocalPenalizationPointCalculator", "(", "\n", "log_acquisition", ",", "acquisition_optimizer", ",", "model", ",", "space", ",", "batch_size", "\n", ")", "\n", "\n", "", "loop_state", "=", "create_loop_state", "(", "model", ".", "X", ",", "model", ".", "Y", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "candidate_point_calculator", ",", "model_updaters", ",", "loop_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loops.bayesian_optimization_loop.BayesianOptimizationLoop.get_results": [[71, 73], ["bayesian_optimization_loop.BayesianOptimizationResults"], "methods", ["None"], ["", "def", "get_results", "(", "self", ")", ":", "\n", "        ", "return", "BayesianOptimizationResults", "(", "self", ".", "loop_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loops.bayesian_optimization_loop.BayesianOptimizationResults.__init__": [[76, 87], ["numpy.min", "numpy.minimum.accumulate().flatten", "numpy.minimum.accumulate", "numpy.argmin"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "loop_state", ":", "LoopState", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Emukit class that takes as input the loop state and computes some results.\n\n        :param loop_state: The loop state it its current form. Currently it only contains X and Y.\n        \"\"\"", "\n", "\n", "self", ".", "minimum_location", "=", "loop_state", ".", "X", "[", "np", ".", "argmin", "(", "loop_state", ".", "Y", ")", ",", ":", "]", "\n", "self", ".", "minimum_value", "=", "np", ".", "min", "(", "loop_state", ".", "Y", ")", "\n", "self", ".", "best_found_value_per_iteration", "=", "np", ".", "minimum", ".", "accumulate", "(", "loop_state", ".", "Y", ")", ".", "flatten", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loops.cost_sensitive_bayesian_optimization_loop.CostSensitiveBayesianOptimizationLoop.__init__": [[17, 61], ["core.loop.FixedIntervalUpdater", "core.loop.FixedIntervalUpdater", "core.loop.SequentialPointCalculator", "core.loop.loop_state.create_loop_state", "core.loop.OuterLoop.__init__", "numpy.all", "ValueError", "bayesian_optimization.acquisitions.ExpectedImprovement", "core.acquisition.acquisition_per_expected_cost", "core.optimization.GradientAcquisitionOptimizer", "numpy.isclose"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.acquisition_per_expected_cost"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "model_objective", ":", "IModel", ",", "\n", "model_cost", ":", "IModel", ",", "\n", "acquisition", ":", "Acquisition", "=", "None", ",", "\n", "update_interval", ":", "int", "=", "1", ",", "\n", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", "=", "None", ",", "\n", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Emukit class that implements a loop for building modular cost sensitive Bayesian optimization.\n\n        :param space: Input space where the optimization is carried out.\n        :param model_objective: The model that approximates the underlying objective function\n        :param model_cost: The model that approximates the cost of evaluating the objective function\n        :param acquisition: The acquisition function that will be used to collect new points (default, EI).\n        :param update_interval:  Number of iterations between optimization of model hyper-parameters. Defaults to 1.\n        :param acquisition_optimizer: Optimizer selecting next evaluation points\n                                      by maximizing acquisition.\n                                      Gradient based optimizer is used if None.\n                                      Defaults to None.\n        \"\"\"", "\n", "\n", "if", "not", "np", ".", "all", "(", "np", ".", "isclose", "(", "model_objective", ".", "X", ",", "model_cost", ".", "X", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Emukit currently only supports identical \"", "\"training inputs for the cost and objective model\"", "\n", ")", "\n", "\n", "", "if", "acquisition", "is", "None", ":", "\n", "            ", "expected_improvement", "=", "ExpectedImprovement", "(", "model_objective", ")", "\n", "acquisition", "=", "acquisition_per_expected_cost", "(", "expected_improvement", ",", "model_cost", ")", "\n", "\n", "", "model_updater_objective", "=", "FixedIntervalUpdater", "(", "model_objective", ",", "update_interval", ")", "\n", "model_updater_cost", "=", "FixedIntervalUpdater", "(", "model_cost", ",", "update_interval", ",", "lambda", "state", ":", "state", ".", "cost", ")", "\n", "\n", "if", "acquisition_optimizer", "is", "None", ":", "\n", "            ", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ")", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "model_objective", ".", "X", ",", "model_objective", ".", "Y", ",", "cost", "=", "model_cost", ".", "Y", ")", "\n", "\n", "super", "(", "CostSensitiveBayesianOptimizationLoop", ",", "self", ")", ".", "__init__", "(", "\n", "candidate_point_calculator", ",", "[", "model_updater_objective", ",", "model_updater_cost", "]", ",", "loop_state", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loops.unknown_constraint_bayesian_optimization_loop.UnknownConstraintBayesianOptimizationLoop.__init__": [[21, 77], ["bayesian_optimization.acquisitions.ProbabilityOfFeasibility", "core.loop.FixedIntervalUpdater", "core.loop.FixedIntervalUpdater", "core.optimization.GradientAcquisitionOptimizer", "core.loop.loop_state.create_loop_state", "core.loop.OuterLoop.__init__", "numpy.all", "ValueError", "bayesian_optimization.acquisitions.ExpectedImprovement", "core.loop.SequentialPointCalculator", "acquisitions.log_acquisition.LogAcquisition", "local_penalization_calculator.LocalPenalizationPointCalculator", "numpy.isclose"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "model_objective", ":", "Union", "[", "IModel", ",", "IDifferentiable", "]", ",", "\n", "model_constraint", ":", "Union", "[", "IModel", ",", "IDifferentiable", "]", ",", "\n", "acquisition", ":", "Acquisition", "=", "None", ",", "\n", "update_interval", ":", "int", "=", "1", ",", "\n", "batch_size", ":", "int", "=", "1", ",", "\n", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Emukit class that implements a loop for building Bayesian optimization with an unknown constraint.\n        For more information see:\n\n        Michael A. Gelbart, Jasper Snoek, and Ryan P. Adams,\n        Bayesian Optimization with Unknown Constraints,\n        https://arxiv.org/pdf/1403.5607.pdf\n\n        :param space: Input space where the optimization is carried out.\n        :param model_objective: The model that approximates the underlying objective function\n        :param model_constraint: The model that approximates the unknown constraints\n        :param acquisition: The acquisition function for the objective function (default, EI).\n        :param update_interval:  Number of iterations between optimization of model hyper-parameters. Defaults to 1.\n        :param batch_size: How many points to evaluate in one iteration of the optimization loop. Defaults to 1.\n        \"\"\"", "\n", "\n", "if", "not", "np", ".", "all", "(", "np", ".", "isclose", "(", "model_objective", ".", "X", ",", "model_constraint", ".", "X", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Emukit currently only supports identical \"", "\"training inputs for the constrained and objective model\"", "\n", ")", "\n", "\n", "", "if", "acquisition", "is", "None", ":", "\n", "            ", "acquisition", "=", "ExpectedImprovement", "(", "model_objective", ")", "\n", "\n", "", "acquisition_constraint", "=", "ProbabilityOfFeasibility", "(", "model_constraint", ")", "\n", "\n", "acquisition_constrained", "=", "acquisition", "*", "acquisition_constraint", "\n", "\n", "model_updater_objective", "=", "FixedIntervalUpdater", "(", "model_objective", ",", "update_interval", ")", "\n", "model_updater_constraint", "=", "FixedIntervalUpdater", "(", "\n", "model_constraint", ",", "update_interval", ",", "lambda", "state", ":", "state", ".", "Y_constraint", "\n", ")", "\n", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "if", "batch_size", "==", "1", ":", "\n", "            ", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition_constrained", ",", "acquisition_optimizer", ")", "\n", "", "else", ":", "\n", "            ", "log_acquisition", "=", "LogAcquisition", "(", "acquisition_constrained", ")", "\n", "candidate_point_calculator", "=", "LocalPenalizationPointCalculator", "(", "\n", "log_acquisition", ",", "acquisition_optimizer", ",", "model_objective", ",", "space", ",", "batch_size", "\n", ")", "\n", "\n", "", "loop_state", "=", "create_loop_state", "(", "model_objective", ".", "X", ",", "model_objective", ".", "Y", ",", "Y_constraint", "=", "model_constraint", ".", "Y", ")", "\n", "\n", "super", "(", "UnknownConstraintBayesianOptimizationLoop", ",", "self", ")", ".", "__init__", "(", "\n", "candidate_point_calculator", ",", "[", "model_updater_objective", ",", "model_updater_constraint", "]", ",", "loop_state", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureBrownian.__init__": [[41, 60], ["kernels.QuadratureKernel.__init__", "any", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "brownian_kernel", ":", "IBrownian", ",", "\n", "measure", ":", "IntegrationMeasure", ",", "\n", "variable_names", ":", "str", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "if", "measure", ".", "input_dim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Integration measure for Brownian motion kernel must be 1-dimensional. Current dimesnion is ({}).\"", ".", "format", "(", "\n", "measure", ".", "input_dim", "\n", ")", "\n", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "kern", "=", "brownian_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n", "if", "any", "(", "self", ".", "reasonable_box", ".", "lower_bounds", "<", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"The domain defined by the reasonable box seems to allow negative values. \"", "\n", "\"Brownian motion is only defined for positive input values.\"", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureBrownian.variance": [[63, 67], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureBrownianLebesgueMeasure.__init__": [[83, 85], ["quadrature_brownian.QuadratureBrownian.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "brownian_kernel", ":", "IBrownian", ",", "measure", ":", "LebesgueMeasure", ",", "variable_names", ":", "str", "=", "\"\"", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "brownian_kernel", "=", "brownian_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureBrownianLebesgueMeasure.qK": [[86, 91], ["None"], "methods", ["None"], ["", "def", "qK", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "lb", "=", "self", ".", "measure", ".", "domain", ".", "lower_bounds", "[", "None", ",", ":", "]", "\n", "ub", "=", "self", ".", "measure", ".", "domain", ".", "upper_bounds", "[", "None", ",", ":", "]", "\n", "kernel_mean", "=", "ub", "*", "x2", "-", "0.5", "*", "x2", "**", "2", "-", "0.5", "*", "lb", "**", "2", "\n", "return", "(", "self", ".", "variance", "*", "self", ".", "measure", ".", "density", ")", "*", "kernel_mean", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureBrownianLebesgueMeasure.qKq": [[92, 97], ["float"], "methods", ["None"], ["", "def", "qKq", "(", "self", ")", "->", "float", ":", "\n", "        ", "lb", "=", "self", ".", "measure", ".", "domain", ".", "lower_bounds", "[", "None", ",", ":", "]", "\n", "ub", "=", "self", ".", "measure", ".", "domain", ".", "upper_bounds", "[", "None", ",", ":", "]", "\n", "qKq", "=", "0.5", "*", "ub", "*", "(", "ub", "**", "2", "-", "lb", "**", "2", ")", "-", "(", "ub", "**", "3", "-", "lb", "**", "3", ")", "/", "6", "-", "0.5", "*", "lb", "**", "2", "*", "(", "ub", "-", "lb", ")", "\n", "return", "(", "self", ".", "measure", ".", "density", "**", "2", "*", "self", ".", "variance", ")", "*", "float", "(", "qKq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureBrownianLebesgueMeasure.dqK_dx": [[98, 101], ["None"], "methods", ["None"], ["", "def", "dqK_dx", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "ub", "=", "self", ".", "measure", ".", "domain", ".", "upper_bounds", "[", "None", ",", ":", "]", "\n", "return", "(", "self", ".", "measure", ".", "density", "*", "self", ".", "variance", ")", "*", "(", "ub", "-", "x2", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownian.__init__": [[131, 143], ["kernels.QuadratureProductKernel.__init__", "any", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "brownian_kernel", ":", "IProductBrownian", ",", "\n", "measure", ":", "IntegrationMeasure", ",", "\n", "variable_names", ":", "str", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "kern", "=", "brownian_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n", "lower_bounds_x", "=", "self", ".", "reasonable_box", ".", "lower_bounds", "\n", "if", "any", "(", "lower_bounds_x", "<", "self", ".", "offset", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"The domain defined by the reasonable box seems allow to for values smaller than the offset \"", "\n", "f\"({self.offset}). Brownian motion is only defined for input values larger than the offset.\"", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownian.variance": [[146, 150], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownian.offset": [[151, 155], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "offset", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The offset :math:`c` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownianLebesgueMeasure.__init__": [[171, 173], ["quadrature_brownian.QuadratureProductBrownian.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "brownian_kernel", ":", "IProductBrownian", ",", "measure", ":", "LebesgueMeasure", ",", "variable_names", ":", "str", "=", "\"\"", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "brownian_kernel", "=", "brownian_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownianLebesgueMeasure._scale": [[174, 176], ["None"], "methods", ["None"], ["", "def", "_scale", "(", "self", ",", "z", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ")", "->", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "return", "self", ".", "variance", "*", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownianLebesgueMeasure._get_univariate_parameters": [[177, 182], ["None"], "methods", ["None"], ["", "def", "_get_univariate_parameters", "(", "self", ",", "dim", ":", "int", ")", "->", "dict", ":", "\n", "        ", "return", "{", "\n", "\"domain\"", ":", "self", ".", "measure", ".", "domain", ".", "bounds", "[", "dim", "]", ",", "\n", "\"offset\"", ":", "self", ".", "offset", ",", "\n", "\"normalize\"", ":", "self", ".", "measure", ".", "is_normalized", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownianLebesgueMeasure._qK_1d": [[184, 190], ["None"], "methods", ["None"], ["", "def", "_qK_1d", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "**", "parameters", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "offset", "=", "parameters", "[", "\"offset\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "kernel_mean", "=", "b", "*", "x", "-", "0.5", "*", "x", "**", "2", "-", "0.5", "*", "a", "**", "2", "\n", "return", "(", "kernel_mean", ".", "T", "-", "offset", "*", "(", "b", "-", "a", ")", ")", "*", "normalization", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownianLebesgueMeasure._qKq_1d": [[191, 197], ["float"], "methods", ["None"], ["", "def", "_qKq_1d", "(", "self", ",", "**", "parameters", ")", "->", "float", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "offset", "=", "parameters", "[", "\"offset\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "qKq", "=", "0.5", "*", "b", "*", "(", "b", "**", "2", "-", "a", "**", "2", ")", "-", "(", "b", "**", "3", "-", "a", "**", "3", ")", "/", "6", "-", "0.5", "*", "a", "**", "2", "*", "(", "b", "-", "a", ")", "\n", "return", "(", "float", "(", "qKq", ")", "-", "offset", "*", "(", "b", "-", "a", ")", "**", "2", ")", "*", "normalization", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_brownian.QuadratureProductBrownianLebesgueMeasure._dqK_dx_1d": [[198, 202], ["None"], "methods", ["None"], ["", "def", "_dqK_dx_1d", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "**", "parameters", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "return", "(", "b", "-", "x", ")", ".", "T", "*", "normalization", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.__init__": [[34, 50], ["measures.BoxDomain", "measure.reasonable_box"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.reasonable_box"], ["def", "__init__", "(", "\n", "self", ",", "\n", "kern", ":", "IStandardKernel", ",", "\n", "measure", ":", "IntegrationMeasure", ",", "\n", "variable_names", ":", "str", ",", "\n", ")", "->", "None", ":", "\n", "        ", "self", ".", "kern", "=", "kern", "\n", "self", ".", "measure", "=", "measure", "\n", "self", ".", "input_dim", "=", "self", ".", "measure", ".", "input_dim", "\n", "\n", "# Even though the domain of the integration might be unbounded, some subroutines such as the acquisition", "\n", "# optimizer require a bounded box. Hence, below we define a reasonable box for input values of the integrand", "\n", "# that can be used by such methods. The box is defined by the integration measure used (see docs there).", "\n", "# Note that the reasonable box only affects methods that use this box, e.g. the acqusition optimizers.", "\n", "# The kernel embeddings still use the originally defined domain which may be unbounded.", "\n", "self", ".", "reasonable_box", "=", "BoxDomain", "(", "name", "=", "variable_names", ",", "bounds", "=", "measure", ".", "reasonable_box", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.K": [[51, 59], ["quadrature_kernels.QuadratureKernel.kern.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "K", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The kernel k(x1, x2) evaluated at x1 and x2.\n\n        :param x1: First argument of the kernel.\n        :param x2: Second argument of the kernel.\n        :returns: The kernel at x1, x2.\n        \"\"\"", "\n", "return", "self", ".", "kern", ".", "K", "(", "x1", ",", "x2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.qK": [[61, 68], ["None"], "methods", ["None"], ["", "def", "qK", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The kernel with the first argument integrated out (kernel mean) evaluated at x2.\n\n        :param x2: The locations where the kernel mean is evaluated, shape (n_points, input_dim).\n        :returns: The kernel mean at x2, shape (1, n_points).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.Kq": [[69, 76], ["quadrature_kernels.QuadratureKernel.qK"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK"], ["", "def", "Kq", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The kernel with the second argument integrated out (kernel mean) evaluated at x1.\n\n        :param x1: The locations where the kernel mean is evaluated, shape (n_points, input_dim).\n        :returns: The kernel mean at x1, shape (n_points, 1).\n        \"\"\"", "\n", "return", "self", ".", "qK", "(", "x1", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.qKq": [[77, 83], ["None"], "methods", ["None"], ["", "def", "qKq", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"The kernel integrated over both arguments x1 and x2.\n\n        :returns: Double integrated kernel.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dK_dx1": [[85, 93], ["quadrature_kernels.QuadratureKernel.kern.dK_dx1"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dK_dx1"], ["", "def", "dK_dx1", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The gradient of the kernel wrt x1 evaluated at pair x1, x2.\n\n        :param x1: First argument of the kernel, shape (n_points N, input_dim).\n        :param x2: Second argument of the kernel, shape (n_points M, input_dim).\n        :return: The gradient at (x1, x2), shape (input_dim, N, M).\n        \"\"\"", "\n", "return", "self", ".", "kern", ".", "dK_dx1", "(", "x1", ",", "x2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dK_dx2": [[94, 105], ["numpy.transpose", "quadrature_kernels.QuadratureKernel.dK_dx1"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dK_dx1"], ["", "def", "dK_dx2", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The gradient of the kernel wrt x2 evaluated at pair x1, x2.\n\n        Note that this is equal to the transposed gradient of the kernel wrt x1 evaluated\n        at x2 and x1 (swapped arguments).\n\n        :param x1: First argument of the kernel, shape (n_points N, N, input_dim).\n        :param x2: Second argument of the kernel, shape (n_points N, M, input_dim).\n        :return: The gradient at (x1, x2), shape (input_dim, N, M).\n        \"\"\"", "\n", "return", "np", ".", "transpose", "(", "self", ".", "dK_dx1", "(", "x1", "=", "x2", ",", "x2", "=", "x1", ")", ",", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dKdiag_dx": [[106, 113], ["quadrature_kernels.QuadratureKernel.kern.dKdiag_dx"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dKdiag_dx"], ["", "def", "dKdiag_dx", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The gradient of the diagonal of the kernel :math:`v(x):=k(x, x)` evaluated at x.\n\n        :param x: The locations where the gradient is evaluated, shape = (n_points M, input_dim).\n        :return: The gradient at x, shape (input_dim, M).\n        \"\"\"", "\n", "return", "self", ".", "kern", ".", "dKdiag_dx", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dqK_dx": [[114, 121], ["None"], "methods", ["None"], ["", "def", "dqK_dx", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The gradient of the kernel mean (integrated in first argument) evaluated at x2.\n\n        :param x2: The locations where the gradient is evaluated, shape (n_points N, N, input_dim).\n        :return: The gradient at x2, shape (input_dim, N).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureKernel.dKq_dx": [[122, 129], ["quadrature_kernels.QuadratureKernel.dqK_dx"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.dqK_dx"], ["", "def", "dKq_dx", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The gradient of the kernel mean (integrated in second argument) evaluated at x1.\n\n        :param x1: The locations where the gradient is evaluated, shape (n_points N, N, input_dim).\n        :return: The gradient with shape (N, input_dim).\n        \"\"\"", "\n", "return", "self", ".", "dqK_dx", "(", "x1", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel.__init__": [[143, 151], ["quadrature_kernels.QuadratureKernel.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "kern", ":", "IStandardKernel", ",", "\n", "measure", ":", "IntegrationMeasure", ",", "\n", "variable_names", ":", "str", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "kern", "=", "kern", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel._qK_unscaled": [[152, 162], ["numpy.ones", "range", "quadrature_kernels.QuadratureProductKernel._qK_1d", "quadrature_kernels.QuadratureProductKernel._get_univariate_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._qK_1d", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._get_univariate_parameters"], ["", "def", "_qK_unscaled", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ",", "skip", ":", "List", "[", "int", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "skip", "is", "None", ":", "\n", "            ", "skip", "=", "[", "]", "\n", "\n", "", "qK", "=", "np", ".", "ones", "(", "x2", ".", "shape", "[", "0", "]", ")", "\n", "for", "dim", "in", "range", "(", "x2", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "if", "dim", "in", "skip", ":", "\n", "                ", "continue", "\n", "", "qK", "*=", "self", ".", "_qK_1d", "(", "x2", "[", ":", ",", "dim", "]", ",", "**", "self", ".", "_get_univariate_parameters", "(", "dim", ")", ")", "\n", "", "return", "qK", "[", "None", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel.qK": [[163, 165], ["quadrature_kernels.QuadratureProductKernel._scale", "quadrature_kernels.QuadratureProductKernel._qK_unscaled"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._scale", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel._qK_unscaled"], ["", "def", "qK", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ",", "skip", ":", "List", "[", "int", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "_scale", "(", "self", ".", "_qK_unscaled", "(", "x2", ",", "skip", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel.qKq": [[166, 171], ["range", "quadrature_kernels.QuadratureProductKernel._scale", "quadrature_kernels.QuadratureProductKernel._qKq_1d", "quadrature_kernels.QuadratureProductKernel._get_univariate_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._scale", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._qKq_1d", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._get_univariate_parameters"], ["", "def", "qKq", "(", "self", ")", "->", "float", ":", "\n", "        ", "qKq", "=", "1.0", "\n", "for", "dim", "in", "range", "(", "self", ".", "input_dim", ")", ":", "\n", "            ", "qKq", "*=", "self", ".", "_qKq_1d", "(", "**", "self", ".", "_get_univariate_parameters", "(", "dim", ")", ")", "\n", "", "return", "self", ".", "_scale", "(", "qKq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel.dqK_dx": [[172, 179], ["numpy.zeros", "range", "quadrature_kernels.QuadratureProductKernel._scale", "quadrature_kernels.QuadratureProductKernel._dqK_dx_1d", "quadrature_kernels.QuadratureProductKernel._get_univariate_parameters", "quadrature_kernels.QuadratureProductKernel._qK_unscaled"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._scale", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._dqK_dx_1d", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._get_univariate_parameters", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel._qK_unscaled"], ["", "def", "dqK_dx", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "input_dim", "=", "x2", ".", "shape", "[", "1", "]", "\n", "dqK_dx", "=", "np", ".", "zeros", "(", "[", "input_dim", ",", "x2", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "dim", "in", "range", "(", "input_dim", ")", ":", "\n", "            ", "grad_term", "=", "self", ".", "_dqK_dx_1d", "(", "x2", "[", ":", ",", "dim", "]", ",", "**", "self", ".", "_get_univariate_parameters", "(", "dim", ")", ")", "\n", "dqK_dx", "[", "dim", ",", ":", "]", "=", "grad_term", "*", "self", ".", "_qK_unscaled", "(", "x2", ",", "skip", "=", "[", "dim", "]", ")", "[", "0", ",", ":", "]", "\n", "", "return", "self", ".", "_scale", "(", "dqK_dx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel._scale": [[180, 187], ["None"], "methods", ["None"], ["", "def", "_scale", "(", "self", ",", "z", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ")", "->", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Scales the input ``z`` with a scalar value specific to the kernel.\n\n        :param z: The value to be scaled.\n        :return: The scaled value.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel._get_univariate_parameters": [[188, 196], ["None"], "methods", ["None"], ["", "def", "_get_univariate_parameters", "(", "self", ",", "dim", ":", "int", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Keywords arguments used by methods related to the univariate, unscaled version\n         of the kernel of dimension ``dim``.\n\n        :param dim: The dimension.\n        :return: The parameters of dimension ``dim``.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel._qK_1d": [[198, 206], ["None"], "methods", ["None"], ["", "def", "_qK_1d", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "**", "parameters", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Unscaled kernel mean for univariate version of kernel.\n\n        :param x: The locations where the kernel mean is evaluated, shape (n_points, ).\n        :param parameters: The parameters of the univariate kernel.\n        :return: The kernel mean of the univariate kernel evaluated at x, shape (n_points, ).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel._qKq_1d": [[207, 214], ["None"], "methods", ["None"], ["", "def", "_qKq_1d", "(", "self", ",", "**", "parameters", ")", "->", "float", ":", "\n", "        ", "\"\"\"Unscaled kernel integrated over both arguments for univariate version of kernel.\n\n        :param parameters: The parameters of the univariate kernel.\n        :returns: Double integrated univariate kernel.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.QuadratureProductKernel._dqK_dx_1d": [[215, 223], ["None"], "methods", ["None"], ["", "def", "_dqK_dx_1d", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "**", "parameters", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Unscaled gradient of univariate version of the kernel mean.\n\n        :param x: The locations where the kernel mean is evaluated, shape (n_points, ).\n        :param parameters: The parameters of the univariate kernel.\n        :return: The gradient with shape (n_points, ).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.LebesgueEmbedding.from_integral_bounds": [[233, 252], ["measures.BoxDomain", "measures.LebesgueMeasure", "cls"], "methods", ["None"], ["@", "classmethod", "\n", "def", "from_integral_bounds", "(", "\n", "cls", ",", "kern", ":", "IStandardKernel", ",", "integral_bounds", ":", "BoundsType", ",", "normalized", ":", "bool", "=", "False", ",", "variable_names", ":", "str", "=", "\"\"", "\n", ")", ":", "\n", "        ", "\"\"\"Create the quadrature kernel w.r.t. a Lebesgue measure from the integral bounds.\n\n        :param kern: Standard EmuKit kernel.\n        :param integral_bounds: The integral bounds.\n                               List of :math:`d` tuples :math:`[(a_1, b_1), (a_2, b_2), \\dots, (a_d, b_d)]`,\n                               where :math:`d` is the dimensionality of the integral and the tuple :math:`(a_i, b_i)`\n                               contains the lower and upper integration bound of dimension :math:`i`.\n        :param normalized: Weather the Lebesgue measure is normalized.\n        :param variable_names: The (variable) name(s) of the integral\n        :return: An instance of a quadrature kernel w.r.t. Lebesgue measure.\n\n        \"\"\"", "\n", "domain", "=", "BoxDomain", "(", "bounds", "=", "integral_bounds", ")", "\n", "measure", "=", "LebesgueMeasure", "(", "domain", "=", "domain", ",", "normalized", "=", "normalized", ")", "\n", "return", "cls", "(", "kern", ",", "measure", ",", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_kernels.GaussianEmbedding.from_measure_params": [[262, 278], ["measures.GaussianMeasure", "cls"], "methods", ["None"], ["@", "classmethod", "\n", "def", "from_measure_params", "(", "\n", "cls", ",", "kern", ":", "IStandardKernel", ",", "mean", ":", "np", ".", "ndarray", ",", "variance", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ",", "variable_names", ":", "str", "=", "\"\"", "\n", ")", ":", "\n", "        ", "\"\"\"Create the quadrature kernel w.r.t. a Gaussian measure from the measure parameters.\n\n        :param kern: Standard EmuKit kernel.\n        :param mean: The mean of the Gaussian measure, shape (input_dim, ).\n        :param variance: The variances of the Gaussian measure, shape (input_dim, ).\n                         If a scalar value is given, all dimensions will have same variance.\n        :param variable_names: The (variable) name(s) of the integral\n        :return: An instance of a quadrature kernel w.r.t. Gaussian measure.\n\n        \"\"\"", "\n", "measure", "=", "GaussianMeasure", "(", "mean", "=", "mean", ",", "variance", "=", "variance", ")", "\n", "return", "cls", "(", "kern", ",", "measure", ",", "variable_names", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF.__init__": [[42, 49], ["kernels.QuadratureKernel.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "rbf_kernel", ":", "IRBF", ",", "\n", "measure", ":", "IntegrationMeasure", ",", "\n", "variable_names", ":", "str", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "kern", "=", "rbf_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF.lengthscales": [[50, 54], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"The lengthscales :math:`\\lambda` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "lengthscales", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF.variance": [[55, 59], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff": [[61, 79], ["numpy.sqrt"], "methods", ["None"], ["", "def", "_scaled_vector_diff", "(", "\n", "self", ",", "v1", ":", "np", ".", "ndarray", ",", "v2", ":", "np", ".", "ndarray", ",", "scales", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", "=", "None", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"Scaled element-wise vector difference between vectors v1 and v2.\n\n        .. math::\n            \\frac{v_1 - v_2}{\\ell \\sqrt{2}}\n\n        where :math:`\\ell` is the ``scales`` parameter.\n\n        :param v1: First vector.\n        :param v2: Second vector, must have same second dimensions as v1.\n        :param scales: The scales, default is the lengthscales of the kernel.\n        :return: Scaled difference between v1 and v2, same shape as v1 and v2.\n        \"\"\"", "\n", "if", "scales", "is", "None", ":", "\n", "            ", "scales", "=", "self", ".", "lengthscales", "\n", "", "return", "(", "v1", "-", "v2", ")", "/", "(", "scales", "*", "np", ".", "sqrt", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFLebesgueMeasure.__init__": [[95, 97], ["quadrature_rbf.QuadratureRBF.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "rbf_kernel", ":", "IRBF", ",", "measure", ":", "LebesgueMeasure", ",", "variable_names", ":", "str", "=", "\"\"", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "rbf_kernel", "=", "rbf_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFLebesgueMeasure.qK": [[98, 105], ["scipy.special.erf", "scipy.special.erf", "quadrature_rbf.QuadratureRBFLebesgueMeasure._scaled_vector_diff", "quadrature_rbf.QuadratureRBFLebesgueMeasure._scaled_vector_diff", "kernel_mean.reshape", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff"], ["", "def", "qK", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "lb", "=", "self", ".", "measure", ".", "domain", ".", "lower_bounds", "[", "None", ",", ":", "]", "\n", "ub", "=", "self", ".", "measure", ".", "domain", ".", "upper_bounds", "[", "None", ",", ":", "]", "\n", "erf_lo", "=", "erf", "(", "self", ".", "_scaled_vector_diff", "(", "lb", ",", "x2", ")", ")", "\n", "erf_up", "=", "erf", "(", "self", ".", "_scaled_vector_diff", "(", "ub", ",", "x2", ")", ")", "\n", "kernel_mean", "=", "(", "np", ".", "sqrt", "(", "np", ".", "pi", "/", "2.0", ")", "*", "self", ".", "lengthscales", "*", "(", "erf_up", "-", "erf_lo", ")", ")", ".", "prod", "(", "axis", "=", "1", ")", "\n", "return", "(", "self", ".", "variance", "*", "self", ".", "measure", ".", "density", ")", "*", "kernel_mean", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFLebesgueMeasure.qKq": [[106, 114], ["quadrature_rbf.QuadratureRBFLebesgueMeasure._scaled_vector_diff", "numpy.sqrt", "scipy.special.erf", "float", "numpy.exp", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff"], ["", "def", "qKq", "(", "self", ")", "->", "float", ":", "\n", "        ", "lb", "=", "self", ".", "measure", ".", "domain", ".", "lower_bounds", "[", "None", ",", ":", "]", "\n", "ub", "=", "self", ".", "measure", ".", "domain", ".", "upper_bounds", "[", "None", ",", ":", "]", "\n", "diff_bounds_scaled", "=", "self", ".", "_scaled_vector_diff", "(", "ub", ",", "lb", ")", "\n", "exp_term", "=", "(", "np", ".", "exp", "(", "-", "(", "diff_bounds_scaled", "**", "2", ")", ")", "-", "1.0", ")", "/", "np", ".", "sqrt", "(", "np", ".", "pi", ")", "\n", "erf_term", "=", "erf", "(", "diff_bounds_scaled", ")", "*", "diff_bounds_scaled", "\n", "qKq", "=", "(", "(", "2", "*", "np", ".", "sqrt", "(", "np", ".", "pi", ")", "*", "self", ".", "lengthscales", "**", "2", ")", "*", "(", "exp_term", "+", "erf_term", ")", ")", ".", "prod", "(", ")", "\n", "return", "(", "self", ".", "variance", "*", "self", ".", "measure", ".", "density", "**", "2", ")", "*", "float", "(", "qKq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFLebesgueMeasure.dqK_dx": [[115, 124], ["numpy.exp", "numpy.exp", "scipy.special.erf", "scipy.special.erf", "quadrature_rbf.QuadratureRBFLebesgueMeasure._scaled_vector_diff", "quadrature_rbf.QuadratureRBFLebesgueMeasure._scaled_vector_diff", "quadrature_rbf.QuadratureRBFLebesgueMeasure.qK", "quadrature_rbf.QuadratureRBFLebesgueMeasure._scaled_vector_diff", "quadrature_rbf.QuadratureRBFLebesgueMeasure._scaled_vector_diff", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff"], ["", "def", "dqK_dx", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "lb", "=", "self", ".", "measure", ".", "domain", ".", "lower_bounds", "[", "None", ",", ":", "]", "\n", "ub", "=", "self", ".", "measure", ".", "domain", ".", "upper_bounds", "[", "None", ",", ":", "]", "\n", "exp_lo", "=", "np", ".", "exp", "(", "-", "self", ".", "_scaled_vector_diff", "(", "x2", ",", "lb", ")", "**", "2", ")", "\n", "exp_up", "=", "np", ".", "exp", "(", "-", "self", ".", "_scaled_vector_diff", "(", "x2", ",", "ub", ")", "**", "2", ")", "\n", "erf_lo", "=", "erf", "(", "self", ".", "_scaled_vector_diff", "(", "lb", ",", "x2", ")", ")", "\n", "erf_up", "=", "erf", "(", "self", ".", "_scaled_vector_diff", "(", "ub", ",", "x2", ")", ")", "\n", "fraction", "=", "(", "(", "exp_lo", "-", "exp_up", ")", "/", "(", "self", ".", "lengthscales", "*", "np", ".", "sqrt", "(", "np", ".", "pi", "/", "2.0", ")", "*", "(", "erf_up", "-", "erf_lo", ")", ")", ")", ".", "T", "\n", "return", "self", ".", "qK", "(", "x2", ")", "*", "fraction", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.__init__": [[140, 142], ["quadrature_rbf.QuadratureRBF.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "rbf_kernel", ":", "IRBF", ",", "measure", ":", "GaussianMeasure", ",", "variable_names", ":", "str", "=", "\"\"", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "rbf_kernel", "=", "rbf_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK": [[143, 150], ["numpy.sqrt().prod", "numpy.power().sum", "numpy.exp().reshape", "numpy.sqrt", "numpy.power", "quadrature_rbf.QuadratureRBFGaussianMeasure._scaled_vector_diff", "numpy.exp", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBF._scaled_vector_diff"], ["", "def", "qK", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ",", "scale_factor", ":", "float", "=", "1.0", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "ells", "=", "scale_factor", "*", "self", ".", "lengthscales", "\n", "sigma2", "=", "self", ".", "measure", ".", "variance", "\n", "mu", "=", "self", ".", "measure", ".", "mean", "\n", "factor", "=", "np", ".", "sqrt", "(", "ells", "**", "2", "/", "(", "ells", "**", "2", "+", "sigma2", ")", ")", ".", "prod", "(", ")", "\n", "scaled_norm_sq", "=", "np", ".", "power", "(", "self", ".", "_scaled_vector_diff", "(", "x2", ",", "mu", ",", "np", ".", "sqrt", "(", "ells", "**", "2", "+", "sigma2", ")", ")", ",", "2", ")", ".", "sum", "(", "axis", "=", "1", ")", "\n", "return", "(", "self", ".", "variance", "*", "factor", ")", "*", "np", ".", "exp", "(", "-", "scaled_norm_sq", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qKq": [[151, 155], ["numpy.sqrt().prod", "float", "numpy.sqrt"], "methods", ["None"], ["", "def", "qKq", "(", "self", ")", "->", "float", ":", "\n", "        ", "ells", "=", "self", ".", "lengthscales", "\n", "qKq", "=", "np", ".", "sqrt", "(", "ells", "**", "2", "/", "(", "ells", "**", "2", "+", "2", "*", "self", ".", "measure", ".", "variance", ")", ")", ".", "prod", "(", ")", "\n", "return", "self", ".", "variance", "*", "float", "(", "qKq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.dqK_dx": [[156, 159], ["quadrature_rbf.QuadratureRBFGaussianMeasure.qK"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK"], ["", "def", "dqK_dx", "(", "self", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "scaled_diff", "=", "(", "x2", "-", "self", ".", "measure", ".", "mean", ")", "/", "(", "self", ".", "lengthscales", "**", "2", "+", "self", ".", "measure", ".", "variance", ")", "\n", "return", "-", "self", ".", "qK", "(", "x2", ")", "*", "scaled_diff", ".", "T", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32.__init__": [[38, 45], ["quadrature_kernels.QuadratureProductKernel.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "matern_kernel", ":", "IProductMatern32", ",", "\n", "measure", ":", "IntegrationMeasure", ",", "\n", "variable_names", ":", "str", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "kern", "=", "matern_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32.nu": [[46, 50], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "nu", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"The smoothness parameter of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "nu", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32.lengthscales": [[51, 55], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"The lengthscales :math:`\\lambda` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "lengthscales", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32.variance": [[56, 60], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32LebesgueMeasure.__init__": [[76, 78], ["quadrature_matern32.QuadratureProductMatern32.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "matern_kernel", ":", "IProductMatern32", ",", "measure", ":", "LebesgueMeasure", ",", "variable_names", ":", "str", "=", "\"\"", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "matern_kernel", "=", "matern_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32LebesgueMeasure._scale": [[79, 81], ["None"], "methods", ["None"], ["", "def", "_scale", "(", "self", ",", "z", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ")", "->", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "return", "self", ".", "variance", "*", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32LebesgueMeasure._get_univariate_parameters": [[82, 87], ["None"], "methods", ["None"], ["", "def", "_get_univariate_parameters", "(", "self", ",", "dim", ":", "int", ")", "->", "dict", ":", "\n", "        ", "return", "{", "\n", "\"domain\"", ":", "self", ".", "measure", ".", "domain", ".", "bounds", "[", "dim", "]", ",", "\n", "\"ell\"", ":", "self", ".", "lengthscales", "[", "dim", "]", ",", "\n", "\"normalize\"", ":", "self", ".", "measure", ".", "is_normalized", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32LebesgueMeasure._qK_1d": [[89, 98], ["numpy.sqrt", "numpy.exp", "numpy.exp"], "methods", ["None"], ["", "def", "_qK_1d", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "**", "parameters", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "ell", "=", "parameters", "[", "\"ell\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "s3", "=", "np", ".", "sqrt", "(", "3.0", ")", "\n", "first_term", "=", "4.0", "*", "ell", "/", "s3", "\n", "second_term", "=", "-", "np", ".", "exp", "(", "s3", "*", "(", "x", "-", "b", ")", "/", "ell", ")", "*", "(", "b", "+", "2.0", "*", "ell", "/", "s3", "-", "x", ")", "\n", "third_term", "=", "-", "np", ".", "exp", "(", "s3", "*", "(", "a", "-", "x", ")", "/", "ell", ")", "*", "(", "x", "+", "2.0", "*", "ell", "/", "s3", "-", "a", ")", "\n", "return", "(", "first_term", "+", "second_term", "+", "third_term", ")", "*", "normalization", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32LebesgueMeasure._qKq_1d": [[99, 106], ["numpy.sqrt", "float", "numpy.exp"], "methods", ["None"], ["", "def", "_qKq_1d", "(", "self", ",", "**", "parameters", ")", "->", "float", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "ell", "=", "parameters", "[", "\"ell\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "c", "=", "np", ".", "sqrt", "(", "3.0", ")", "*", "(", "b", "-", "a", ")", "\n", "qKq", "=", "2.0", "*", "ell", "/", "3.0", "*", "(", "2.0", "*", "c", "-", "3.0", "*", "ell", "+", "np", ".", "exp", "(", "-", "c", "/", "ell", ")", "*", "(", "c", "+", "3.0", "*", "ell", ")", ")", "\n", "return", "float", "(", "qKq", ")", "*", "normalization", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern32.QuadratureProductMatern32LebesgueMeasure._dqK_dx_1d": [[107, 117], ["numpy.sqrt", "numpy.exp", "numpy.exp"], "methods", ["None"], ["", "def", "_dqK_dx_1d", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "**", "parameters", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "ell", "=", "parameters", "[", "\"ell\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "s3", "=", "np", ".", "sqrt", "(", "3", ")", "\n", "exp_term_b", "=", "np", ".", "exp", "(", "s3", "*", "(", "x", "-", "b", ")", "/", "ell", ")", "\n", "exp_term_a", "=", "np", ".", "exp", "(", "s3", "*", "(", "a", "-", "x", ")", "/", "ell", ")", "\n", "first_term", "=", "exp_term_b", "*", "(", "-", "1", "+", "(", "s3", "/", "ell", ")", "*", "(", "x", "-", "b", ")", ")", "\n", "second_term", "=", "exp_term_a", "*", "(", "+", "1", "-", "(", "s3", "/", "ell", ")", "*", "(", "a", "-", "x", ")", ")", "\n", "return", "(", "first_term", "+", "second_term", ")", "*", "normalization", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52.__init__": [[38, 45], ["quadrature_kernels.QuadratureProductKernel.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "matern_kernel", ":", "IProductMatern52", ",", "\n", "measure", ":", "IntegrationMeasure", ",", "\n", "variable_names", ":", "str", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "kern", "=", "matern_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52.nu": [[46, 50], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "nu", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"The smoothness parameter of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "nu", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52.lengthscales": [[51, 55], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"The lengthscales :math:`\\lambda` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "lengthscales", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52.variance": [[56, 60], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "r\"\"\"The scale :math:`\\sigma^2` of the kernel.\"\"\"", "\n", "return", "self", ".", "kern", ".", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure.__init__": [[76, 78], ["quadrature_matern52.QuadratureProductMatern52.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "matern_kernel", ":", "IProductMatern52", ",", "measure", ":", "LebesgueMeasure", ",", "variable_names", ":", "str", "=", "\"\"", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "matern_kernel", "=", "matern_kernel", ",", "measure", "=", "measure", ",", "variable_names", "=", "variable_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._scale": [[79, 81], ["None"], "methods", ["None"], ["", "def", "_scale", "(", "self", ",", "z", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ")", "->", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "return", "self", ".", "variance", "*", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._get_univariate_parameters": [[82, 87], ["None"], "methods", ["None"], ["", "def", "_get_univariate_parameters", "(", "self", ",", "dim", ":", "int", ")", "->", "dict", ":", "\n", "        ", "return", "{", "\n", "\"domain\"", ":", "self", ".", "measure", ".", "domain", ".", "bounds", "[", "dim", "]", ",", "\n", "\"ell\"", ":", "self", ".", "lengthscales", "[", "dim", "]", ",", "\n", "\"normalize\"", ":", "self", ".", "measure", ".", "is_normalized", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._qK_1d": [[89, 102], ["numpy.sqrt", "numpy.exp", "numpy.exp"], "methods", ["None"], ["", "def", "_qK_1d", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "**", "parameters", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "ell", "=", "parameters", "[", "\"ell\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "s5", "=", "np", ".", "sqrt", "(", "5", ")", "\n", "first_term", "=", "16", "*", "ell", "/", "(", "3", "*", "s5", ")", "\n", "second_term", "=", "(", "\n", "-", "np", ".", "exp", "(", "s5", "*", "(", "x", "-", "b", ")", "/", "ell", ")", "/", "(", "15", "*", "ell", ")", "*", "(", "8", "*", "s5", "*", "ell", "**", "2", "+", "25", "*", "ell", "*", "(", "b", "-", "x", ")", "+", "5", "*", "s5", "*", "(", "b", "-", "x", ")", "**", "2", ")", "\n", ")", "\n", "third_term", "=", "(", "\n", "-", "np", ".", "exp", "(", "s5", "*", "(", "a", "-", "x", ")", "/", "ell", ")", "/", "(", "15", "*", "ell", ")", "*", "(", "8", "*", "s5", "*", "ell", "**", "2", "+", "25", "*", "ell", "*", "(", "x", "-", "a", ")", "+", "5", "*", "s5", "*", "(", "a", "-", "x", ")", "**", "2", ")", "\n", ")", "\n", "return", "(", "first_term", "+", "second_term", "+", "third_term", ")", "*", "normalization", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._qKq_1d": [[103, 111], ["numpy.sqrt", "float", "numpy.exp"], "methods", ["None"], ["", "def", "_qKq_1d", "(", "self", ",", "**", "parameters", ")", "->", "float", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "ell", "=", "parameters", "[", "\"ell\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "c", "=", "np", ".", "sqrt", "(", "5", ")", "*", "(", "b", "-", "a", ")", "\n", "bracket_term", "=", "5", "*", "a", "**", "2", "-", "10", "*", "a", "*", "b", "+", "5", "*", "b", "**", "2", "+", "7", "*", "c", "*", "ell", "+", "15", "*", "ell", "**", "2", "\n", "qKq", "=", "(", "2", "*", "ell", "*", "(", "8", "*", "c", "-", "15", "*", "ell", ")", "+", "2", "*", "np", ".", "exp", "(", "-", "c", "/", "ell", ")", "*", "bracket_term", ")", "/", "15", "\n", "return", "float", "(", "qKq", ")", "*", "normalization", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_matern52.QuadratureProductMatern52LebesgueMeasure._dqK_dx_1d": [[112, 122], ["numpy.sqrt", "numpy.exp", "numpy.exp"], "methods", ["None"], ["", "def", "_dqK_dx_1d", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "**", "parameters", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "a", ",", "b", "=", "parameters", "[", "\"domain\"", "]", "\n", "ell", "=", "parameters", "[", "\"ell\"", "]", "\n", "normalization", "=", "1", "/", "(", "b", "-", "a", ")", "if", "parameters", "[", "\"normalize\"", "]", "else", "1.0", "\n", "s5", "=", "np", ".", "sqrt", "(", "5", ")", "\n", "first_exp", "=", "-", "np", ".", "exp", "(", "s5", "*", "(", "x", "-", "b", ")", "/", "ell", ")", "/", "(", "15", "*", "ell", ")", "\n", "first_term", "=", "first_exp", "*", "(", "15", "*", "ell", "-", "15", "*", "s5", "*", "(", "x", "-", "b", ")", "+", "25", "/", "ell", "*", "(", "x", "-", "b", ")", "**", "2", ")", "\n", "second_exp", "=", "-", "np", ".", "exp", "(", "s5", "*", "(", "a", "-", "x", ")", "/", "ell", ")", "/", "(", "15", "*", "ell", ")", "\n", "second_term", "=", "second_exp", "*", "(", "-", "15", "*", "ell", "+", "15", "*", "s5", "*", "(", "a", "-", "x", ")", "-", "25", "/", "ell", "*", "(", "a", "-", "x", ")", "**", "2", ")", "\n", "return", "(", "first_term", "+", "second_term", ")", "*", "normalization", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.__init__": [[15, 49], ["len", "GPy.kern.src.kern.CombinationKernel.__init__", "GPy.core.parameterization.Param", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.link_parameters", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "kernels", ")", ":", "\n", "        ", "\"\"\"\n        This kernel is used for multi-fidelity problems.\n\n        Args:\n            kernels - List of GPy kernels to use for each fidelity from low\n                      to high fidelity\n\n        Reference:\n\n        Predicting the output from a complex computer code when fast\n        approximations are available. M. C. KENNEDY AND A. O'HAGAN (2000)\n\n        Any number of fidelities are supported.\n\n        Fidelity s is modelled as:\n        f_s(x) = p_t * f_t(x) + d_s(x)\n\n        where:\n        s is the fidelity\n        t is the previous fidelity\n        f_s(x) is the function modelling fidelity s\n        d_s(x) models the difference between fidelity s-1 and s\n        p_t a scaling parameter between fidelity t and s\n        \"\"\"", "\n", "\n", "self", ".", "kernels", "=", "kernels", "\n", "self", ".", "n_fidelities", "=", "len", "(", "kernels", ")", "\n", "\n", "super", "(", "LinearMultiFidelityKernel", ",", "self", ")", ".", "__init__", "(", "kernels", "=", "self", ".", "kernels", ",", "name", "=", "\"multifidelity\"", ",", "extra_dims", "=", "[", "-", "1", "]", ")", "\n", "self", ".", "scaling_param", "=", "Param", "(", "\"scale\"", ",", "np", ".", "ones", "(", "self", ".", "n_fidelities", "-", "1", ")", ")", "\n", "\n", "# Link parameters so paramz knows about them", "\n", "self", ".", "link_parameters", "(", "self", ".", "scaling_param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.K": [[50, 75], ["numpy.zeros", "range", "range", "numpy.ix_", "range", "numpy.min", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.kernels[].K", "numpy.prod", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "K", "(", "self", ",", "X", ",", "X2", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Covariance matrix\n\n        See section 2.5 of Kennedy & O'Hagan paper for details\n        \"\"\"", "\n", "\n", "if", "X2", "is", "None", ":", "\n", "            ", "X2", "=", "X", "\n", "\n", "# Build covariance block by block", "\n", "", "K", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "X2", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "# Looking at block [i, j]", "\n", "                ", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "j", ",", "X2", "[", ":", ",", "-", "1", "]", "==", "i", ")", "\n", "x_this", "=", "X", "[", "X", "[", ":", ",", "-", "1", "]", "==", "j", ",", ":", "]", "\n", "x2_this", "=", "X2", "[", "X2", "[", ":", ",", "-", "1", "]", "==", "i", ",", ":", "]", "\n", "for", "k", "in", "range", "(", "np", ".", "min", "(", "(", "j", "+", "1", ",", "i", "+", "1", ")", ")", ")", ":", "\n", "                    ", "kernel", "=", "self", ".", "kernels", "[", "k", "]", ".", "K", "(", "x_this", ",", "x2_this", ")", "\n", "scale_1", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "k", ":", "i", "]", ")", "\n", "scale_2", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "k", ":", "j", "]", ")", "\n", "scale", "=", "scale_1", "*", "scale_2", "\n", "K", "[", "idx", "]", "+=", "scale", "*", "kernel", "\n", "", "", "", "return", "K", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.Kdiag": [[76, 93], ["numpy.zeros", "range", "numpy.ix_", "range", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.kernels[].Kdiag", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasKernel.Kdiag"], ["", "def", "Kdiag", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Diagonal of covariance matrix\n\n        See section 2.5 of Kennedy & O'Hagan paper for details\n        \"\"\"", "\n", "\n", "k_diag", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "# Looking at block [i, i]", "\n", "            ", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "i", ")", "\n", "for", "j", "in", "range", "(", "i", "+", "1", ")", ":", "\n", "                ", "kernel", "=", "self", ".", "kernels", "[", "j", "]", ".", "Kdiag", "(", "X", "[", "idx", "]", ")", "\n", "scale", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "j", ":", "i", "]", "**", "2", ")", "\n", "k_diag", "[", "idx", "]", "+=", "scale", "*", "kernel", "\n", "\n", "", "", "return", "k_diag", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.gradients_X": [[94, 106], ["numpy.zeros", "range", "range", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel._calculate_block_matrix_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._calculate_block_matrix_gradients"], ["", "def", "gradients_X", "(", "self", ",", "dL_dK", ",", "X", ",", "X2", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Gradients of likelihood wrt X. Gradient wrt fidelity index are set to 0\n        \"\"\"", "\n", "\n", "# Build gradients one block at a time", "\n", "dl_dx", "=", "np", ".", "zeros", "(", "X", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ")", ":", "\n", "# Calculate gradients for block [i, j] and [j, i]", "\n", "                ", "dl_dx", "+=", "self", ".", "_calculate_block_matrix_gradients", "(", "dL_dK", ",", "X", ",", "X2", ",", "i", ",", "j", ")", "\n", "", "", "return", "dl_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._calculate_block_matrix_gradients": [[107, 136], ["numpy.zeros", "numpy.zeros", "range", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.prod", "numpy.prod", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.kernels[].gradients_X"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.gradients_X"], ["", "def", "_calculate_block_matrix_gradients", "(", "self", ",", "dL_dK", ",", "X", ",", "X2", ",", "i", ",", "j", ")", ":", "\n", "        ", "\"\"\"\n        Gradients of likelihood wrt X for block matrix [i, j] and [j, i]\n        \"\"\"", "\n", "\n", "# Find indices for block [i, j] and block [j, i]", "\n", "if", "X2", "is", "None", ":", "\n", "            ", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "i", ",", "X", "[", ":", ",", "-", "1", "]", "==", "j", ")", "\n", "idx_t", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "j", ",", "X", "[", ":", ",", "-", "1", "]", "==", "i", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "i", ",", "X2", "[", ":", ",", "-", "1", "]", "==", "j", ")", "\n", "idx_t", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "j", ",", "X2", "[", ":", ",", "-", "1", "]", "==", "i", ")", "\n", "\n", "# Take elements of dL_dK corresponding to block matrix", "\n", "", "masked_dl_dk", "=", "np", ".", "zeros", "(", "dL_dK", ".", "shape", ")", "\n", "masked_dl_dk", "[", "idx", "]", "=", "dL_dK", "[", "idx", "]", "\n", "\n", "# If block is not on diagonal, make resultant matrix symmetric", "\n", "if", "i", "!=", "j", ":", "\n", "            ", "masked_dl_dk", "[", "idx_t", "]", "=", "dL_dK", "[", "idx_t", "]", "\n", "\n", "", "block_dl_dx", "=", "np", ".", "zeros", "(", "X", ".", "shape", ")", "\n", "for", "k", "in", "range", "(", "0", ",", "j", "+", "1", ")", ":", "\n", "# Find gradients from sub-kernels + product rule", "\n", "            ", "scale_1", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "k", ":", "i", "]", ")", "\n", "scale_2", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "k", ":", "j", "]", ")", "\n", "dl_dk_k", "=", "scale_1", "*", "scale_2", "*", "masked_dl_dk", "\n", "block_dl_dx", "+=", "self", ".", "kernels", "[", "k", "]", ".", "gradients_X", "(", "dl_dk_k", ",", "X", ",", "X2", ")", "\n", "", "return", "block_dl_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.gradients_X_diag": [[137, 155], ["numpy.zeros", "range", "numpy.ix_", "numpy.zeros", "range", "numpy.prod", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.kernels[].gradients_X_diag"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.gradients_X_diag"], ["", "def", "gradients_X_diag", "(", "self", ",", "dL_dKdiag", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Gradients of likelihood wrt X. Gradient wrt fidelity index are set to 0\n        \"\"\"", "\n", "\n", "# Build gradients one fidelity at a time", "\n", "dl_dx", "=", "np", ".", "zeros", "(", "X", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "# Look at all elements at fidelity i", "\n", "            ", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "i", ")", "\n", "\n", "# Take elements of dL_dKdiag corresponding to this fidelity", "\n", "masked_dl_dk", "=", "np", ".", "zeros", "(", "dL_dKdiag", ".", "shape", ")", "\n", "masked_dl_dk", "[", "idx", "]", "=", "dL_dKdiag", "[", "idx", "]", "\n", "for", "j", "in", "range", "(", "i", "+", "1", ")", ":", "\n", "                ", "scale", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "j", ":", "i", "]", "**", "2", ")", "\n", "dl_dx", "+=", "self", ".", "kernels", "[", "j", "]", ".", "gradients_X_diag", "(", "masked_dl_dk", "*", "scale", ",", "X", ")", "\n", "", "", "return", "dl_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.update_gradients_diag": [[156, 164], ["linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_sub_kernel_gradients_diag", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_scaling_parameter_gradients_diag"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_sub_kernel_gradients_diag", "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_scaling_parameter_gradients_diag"], ["", "def", "update_gradients_diag", "(", "self", ",", "dL_dKdiag", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Gradients of likelihood wrt model hyper-parameters\n        \"\"\"", "\n", "\n", "self", ".", "_update_sub_kernel_gradients_diag", "(", "X", ",", "dL_dKdiag", ")", "\n", "\n", "self", ".", "_update_scaling_parameter_gradients_diag", "(", "X", ",", "dL_dKdiag", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_sub_kernel_gradients_diag": [[165, 183], ["range", "range", "dk_dki.append", "numpy.ix_", "range", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.kernels[].update_gradients_diag", "numpy.zeros", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.update_gradients_diag"], ["", "def", "_update_sub_kernel_gradients_diag", "(", "self", ",", "X", ",", "dL_dKdiag", ")", ":", "\n", "        ", "\"\"\"\n        Update gradients of hyper-parameters in sub-kernels\n        \"\"\"", "\n", "\n", "# Find scaling in front of each kernel term", "\n", "dk_dki", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "dk_dki", ".", "append", "(", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "# Look at all X values at fidelity i", "\n", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "i", ")", "\n", "for", "j", "in", "range", "(", "i", "+", "1", ")", ":", "\n", "                ", "scale", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "j", ":", "i", "]", "**", "2", ")", "\n", "dk_dki", "[", "j", "]", "[", "idx", "]", "+=", "scale", "\n", "\n", "# Set gradients in sub-kernels", "\n", "", "", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "self", ".", "kernels", "[", "i", "]", ".", "update_gradients_diag", "(", "dL_dKdiag", "*", "dk_dki", "[", "i", "]", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_scaling_parameter_gradients_diag": [[184, 219], ["range", "numpy.zeros", "range", "k_all_fidelities.append", "numpy.zeros", "range", "numpy.sum", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.kernels[].Kdiag", "numpy.ix_", "range", "numpy.min", "numpy.prod", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasKernel.Kdiag"], ["", "", "def", "_update_scaling_parameter_gradients_diag", "(", "self", ",", "X", ",", "dL_dKdiag", ")", ":", "\n", "        ", "\"\"\"\n        Update gradients of scaling parameters\n        \"\"\"", "\n", "\n", "# Find K matrices for all sub-kernels", "\n", "k_all_fidelities", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "k_all_fidelities", ".", "append", "(", "self", ".", "kernels", "[", "i", "]", ".", "Kdiag", "(", "X", ")", ")", "\n", "\n", "# Calculate gradients of scaling parameters", "\n", "", "scale_grad", "=", "np", ".", "zeros", "(", "self", ".", "n_fidelities", "-", "1", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", "-", "1", ")", ":", "\n", "            ", "dk_dscale", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "# Find gradient for each block matrix at a time", "\n", "for", "j", "in", "range", "(", "i", "+", "1", ",", "self", ".", "n_fidelities", ")", ":", "\n", "# block [j, j]", "\n", "# Indices for kernel matrices", "\n", "                ", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "j", ")", "\n", "for", "k", "in", "range", "(", "0", ",", "np", ".", "min", "(", "[", "i", "+", "1", ",", "j", "+", "1", "]", ")", ")", ":", "\n", "# Find derivative of (coeff * k_l) w.r.t scaling_param[i]", "\n", "# coeff = prod(scaling_param[l:j])^2", "\n", "\n", "# This is the scaling term in front of the sub-kernel term", "\n", "                    ", "tmp1", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "i", "+", "1", ":", "j", "]", ")", "**", "2", "\n", "tmp2", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "k", ":", "i", "]", ")", "**", "2", "\n", "scale", "=", "2", "*", "tmp1", "*", "tmp2", "*", "self", ".", "scaling_param", "[", "i", "]", "\n", "\n", "# If square of scaling term appears we need to multiply", "\n", "# the gradient by 2", "\n", "dk_dscale", "[", "idx", "]", "+=", "scale", "*", "k_all_fidelities", "[", "k", "]", "[", "idx", "]", "\n", "", "", "scale_grad", "[", "i", "]", "=", "np", ".", "sum", "(", "dL_dKdiag", "*", "dk_dscale", ")", "\n", "\n", "", "self", ".", "scaling_param", ".", "gradient", "=", "scale_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel.update_gradients_full": [[220, 232], ["linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_sub_kernel_gradients_full", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_scaling_parameter_gradients_full"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_sub_kernel_gradients_full", "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_scaling_parameter_gradients_full"], ["", "def", "update_gradients_full", "(", "self", ",", "dL_dK", ",", "X", ",", "X2", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Gradients of likelihood wrt model hyper-parameters given dL_dK.\n        \"\"\"", "\n", "\n", "# X2 is None means X2 == X", "\n", "if", "X2", "is", "None", ":", "\n", "            ", "X2", "=", "X", "\n", "\n", "", "self", ".", "_update_sub_kernel_gradients_full", "(", "X", ",", "X2", ",", "dL_dK", ")", "\n", "\n", "self", ".", "_update_scaling_parameter_gradients_full", "(", "X", ",", "X2", ",", "dL_dK", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_sub_kernel_gradients_full": [[233, 259], ["range", "range", "dk_dki.append", "range", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.kernels[].update_gradients_full", "numpy.zeros", "numpy.ix_", "numpy.ix_", "range", "numpy.prod", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasKernel.update_gradients_full"], ["", "def", "_update_sub_kernel_gradients_full", "(", "self", ",", "X", ",", "X2", ",", "dL_dK", ")", ":", "\n", "        ", "\"\"\"\n        Update gradients of likelihood wrt sub-kernel hyper-parameters\n        \"\"\"", "\n", "\n", "# Find the scaling term in front of each sub-kernel", "\n", "dk_dki", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "dk_dki", ".", "append", "(", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "X2", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "for", "j", "in", "range", "(", "i", "+", "1", ")", ":", "\n", "# Looking at block matrix [i, j]", "\n", "                ", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "j", ",", "X2", "[", ":", ",", "-", "1", "]", "==", "i", ")", "\n", "idx_t", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "i", ",", "X2", "[", ":", ",", "-", "1", "]", "==", "j", ")", "\n", "for", "k", "in", "range", "(", "j", "+", "1", ")", ":", "\n", "                    ", "scale_1", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "k", ":", "i", "]", ")", "\n", "scale_2", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "k", ":", "j", "]", ")", "\n", "scale", "=", "scale_1", "*", "scale_2", "\n", "dk_dki", "[", "k", "]", "[", "idx", "]", "+=", "scale", "\n", "\n", "# Ensure symmetric matrix if this is an off-diagonal block", "\n", "if", "i", "!=", "j", ":", "\n", "                        ", "dk_dki", "[", "k", "]", "[", "idx_t", "]", "+=", "scale", "\n", "\n", "# Set gradients in sub-kernels", "\n", "", "", "", "", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "self", ".", "kernels", "[", "i", "]", ".", "update_gradients_full", "(", "dL_dK", "*", "dk_dki", "[", "i", "]", ",", "X", ",", "X2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._update_scaling_parameter_gradients_full": [[260, 275], ["range", "numpy.zeros", "range", "k_all_fidelities.append", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel._calculate_d_likelihood_d_scaling_param", "linear_multi_fidelity_kernel.LinearMultiFidelityKernel.kernels[].K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._calculate_d_likelihood_d_scaling_param", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "", "def", "_update_scaling_parameter_gradients_full", "(", "self", ",", "X", ",", "X2", ",", "dL_dK", ")", ":", "\n", "        ", "\"\"\"\n        Update gradients of likelihood wrt scaling parameters\n        \"\"\"", "\n", "# First find K matrices for all sub-kernels.", "\n", "k_all_fidelities", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "k_all_fidelities", ".", "append", "(", "self", ".", "kernels", "[", "i", "]", ".", "K", "(", "X", ",", "X2", ")", ")", "\n", "\n", "# Calculate gradients of scaling parameters", "\n", "", "scale_grad", "=", "np", ".", "zeros", "(", "self", ".", "n_fidelities", "-", "1", ")", "\n", "for", "i_scale", "in", "range", "(", "self", ".", "n_fidelities", "-", "1", ")", ":", "\n", "            ", "scale_grad", "[", "i_scale", "]", "=", "self", ".", "_calculate_d_likelihood_d_scaling_param", "(", "dL_dK", ",", "X", ",", "X2", ",", "i_scale", ",", "k_all_fidelities", ")", "\n", "\n", "", "self", ".", "scaling_param", ".", "gradient", "=", "scale_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.kernels.linear_multi_fidelity_kernel.LinearMultiFidelityKernel._calculate_d_likelihood_d_scaling_param": [[276, 316], ["numpy.zeros", "range", "numpy.sum", "range", "numpy.min", "numpy.max", "numpy.ix_", "range", "numpy.min", "numpy.prod", "numpy.prod", "numpy.prod"], "methods", ["None"], ["", "def", "_calculate_d_likelihood_d_scaling_param", "(", "self", ",", "dL_dK", ",", "X", ",", "X2", ",", "i_scaling", ",", "k_all_fidelities", ")", ":", "\n", "        ", "\"\"\"\n        Calculates gradient of likelihood wrt one scaling parameter\n\n        i_scaling - index of the scale parameter to calculate gradients for\n        k_all_fidelities - list of covariance matrices for every fidelity\n        \"\"\"", "\n", "\n", "# Initialise matrix", "\n", "dk_dscale", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "X2", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "# Find gradient for each block matrix at a time", "\n", "for", "i_block", "in", "range", "(", "0", ",", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "for", "j_block", "in", "range", "(", "0", ",", "self", ".", "n_fidelities", ")", ":", "\n", "# Block [i_block, j_block]", "\n", "\n", "                ", "min_fidelity", "=", "np", ".", "min", "(", "[", "i_block", ",", "j_block", "]", ")", "\n", "max_fidelity", "=", "np", ".", "max", "(", "[", "i_block", ",", "j_block", "]", ")", "\n", "\n", "if", "max_fidelity", "<=", "i_scaling", ":", "\n", "                    ", "continue", "\n", "\n", "# Indices for this block", "\n", "", "idx", "=", "np", ".", "ix_", "(", "X", "[", ":", ",", "-", "1", "]", "==", "i_block", ",", "X2", "[", ":", ",", "-", "1", "]", "==", "j_block", ")", "\n", "\n", "for", "i_kern", "in", "range", "(", "np", ".", "min", "(", "[", "i_scaling", "+", "1", ",", "min_fidelity", "+", "1", "]", ")", ")", ":", "\n", "# Find derivative of (coeff*k_l) w.r.t scaling_param[i]", "\n", "# coeff = prod(scaling_param[l:max_fidelity])", "\n", "#         *prod(scaling_param[l:min_fidelity])", "\n", "\n", "# Take product of scaling parameters from l to n", "\n", "                    ", "scale_params_1", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "i_kern", ":", "min_fidelity", "]", ")", "\n", "# Product of scaling parameters from l to j, omitting i", "\n", "scale_params_2", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "i_kern", ":", "i_scaling", "]", ")", "\n", "scale_params_3", "=", "np", ".", "prod", "(", "self", ".", "scaling_param", "[", "i_scaling", "+", "1", ":", "max_fidelity", "]", ")", "\n", "scale", "=", "scale_params_1", "*", "scale_params_2", "*", "scale_params_3", "\n", "if", "i_scaling", "<", "min_fidelity", ":", "\n", "                        ", "scale", "*=", "2", "\n", "", "dk_dscale", "[", "idx", "]", "+=", "scale", "*", "k_all_fidelities", "[", "i_kern", "]", "[", "idx", "]", "\n", "", "", "", "return", "np", ".", "sum", "(", "dL_dK", "*", "dk_dscale", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.bayesian_monte_carlo_loop.BayesianMonteCarlo.__init__": [[51, 62], ["core.parameter_space.ParameterSpace", "loop.point_calculators.BayesianMonteCarloPointCalculator", "core.loop.loop_state.create_loop_state", "core.loop.OuterLoop.__init__", "core.loop.FixedIntervalUpdater", "model.reasonable_box_bounds.convert_to_list_of_continuous_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain.convert_to_list_of_continuous_parameters"], ["def", "__init__", "(", "self", ",", "model", ":", "WarpedBayesianQuadratureModel", ",", "model_updater", ":", "ModelUpdater", "=", "None", ")", ":", "\n", "        ", "if", "model_updater", "is", "None", ":", "\n", "            ", "model_updater", "=", "FixedIntervalUpdater", "(", "model", ",", "1", ")", "\n", "\n", "", "space", "=", "ParameterSpace", "(", "model", ".", "reasonable_box_bounds", ".", "convert_to_list_of_continuous_parameters", "(", ")", ")", "\n", "candidate_point_calculator", "=", "BayesianMonteCarloPointCalculator", "(", "model", ",", "space", ")", "\n", "loop_state", "=", "create_loop_state", "(", "model", ".", "X", ",", "model", ".", "Y", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "candidate_point_calculator", ",", "model_updater", ",", "loop_state", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.wsabil_loop.WSABILLoop.__init__": [[30, 49], ["acquisitions.UncertaintySampling", "core.parameter_space.ParameterSpace", "core.loop.SequentialPointCalculator", "core.loop.loop_state.create_loop_state", "core.loop.OuterLoop.__init__", "core.loop.FixedIntervalUpdater", "model.reasonable_box_bounds.convert_to_list_of_continuous_parameters", "core.optimization.GradientAcquisitionOptimizer"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain.convert_to_list_of_continuous_parameters"], ["def", "__init__", "(", "\n", "self", ",", "model", ":", "WSABIL", ",", "model_updater", ":", "ModelUpdater", "=", "None", ",", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", "=", "None", "\n", ")", ":", "\n", "\n", "# WSABI-L is used with uncertainty sampling.", "\n", "        ", "acquisition", "=", "UncertaintySampling", "(", "model", ",", "measure_power", "=", "1", ")", "\n", "\n", "if", "model_updater", "is", "None", ":", "\n", "            ", "model_updater", "=", "FixedIntervalUpdater", "(", "model", ",", "1", ")", "\n", "\n", "", "space", "=", "ParameterSpace", "(", "model", ".", "reasonable_box_bounds", ".", "convert_to_list_of_continuous_parameters", "(", ")", ")", "\n", "if", "acquisition_optimizer", "is", "None", ":", "\n", "            ", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ")", "\n", "loop_state", "=", "create_loop_state", "(", "model", ".", "X", ",", "model", ".", "Y", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "candidate_point_calculator", ",", "model_updater", ",", "loop_state", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.vanilla_bq_loop.VanillaBayesianQuadratureLoop.__init__": [[28, 50], ["core.parameter_space.ParameterSpace", "core.loop.SequentialPointCalculator", "core.loop.loop_state.create_loop_state", "core.loop.OuterLoop.__init__", "acquisitions.IntegralVarianceReduction", "core.loop.FixedIntervalUpdater", "model.reasonable_box_bounds.convert_to_list_of_continuous_parameters", "core.optimization.GradientAcquisitionOptimizer"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain.convert_to_list_of_continuous_parameters"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "VanillaBayesianQuadrature", ",", "\n", "acquisition", ":", "Acquisition", "=", "None", ",", "\n", "model_updater", ":", "ModelUpdater", "=", "None", ",", "\n", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "acquisition", "is", "None", ":", "\n", "            ", "acquisition", "=", "IntegralVarianceReduction", "(", "model", ")", "\n", "\n", "", "if", "model_updater", "is", "None", ":", "\n", "            ", "model_updater", "=", "FixedIntervalUpdater", "(", "model", ",", "1", ")", "\n", "\n", "", "space", "=", "ParameterSpace", "(", "model", ".", "reasonable_box_bounds", ".", "convert_to_list_of_continuous_parameters", "(", ")", ")", "\n", "if", "acquisition_optimizer", "is", "None", ":", "\n", "            ", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ")", "\n", "loop_state", "=", "create_loop_state", "(", "model", ".", "X", ",", "model", ".", "Y", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "candidate_point_calculator", ",", "model_updater", ",", "loop_state", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.LoopState.__init__": [[17, 23], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "initial_results", ":", "List", "[", "UserFunctionResult", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param initial_results: The function results from previous function evaluations\n        \"\"\"", "\n", "self", ".", "results", "=", "initial_results", "\n", "self", ".", "iteration", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.LoopState.update": [[24, 33], ["ValueError"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "results", ":", "List", "[", "UserFunctionResult", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param results: The latest function results since last update\n        \"\"\"", "\n", "if", "not", "results", ":", "\n", "            ", "raise", "ValueError", "(", "\"Cannot update state with empty result list.\"", ")", "\n", "\n", "", "self", ".", "iteration", "+=", "1", "\n", "self", ".", "results", "+=", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.LoopState.X": [[34, 40], ["numpy.array"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :return: Function inputs for all function evaluations in a 2d array: number of points by input dimensions.\n        \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "result", ".", "X", "for", "result", "in", "self", ".", "results", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.LoopState.Y": [[41, 47], ["numpy.array"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :return: Function outputs for all function evaluations in a 2d array: number of points by output dimensions.\n        \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "result", ".", "Y", "for", "result", "in", "self", ".", "results", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.LoopState.__getattr__": [[48, 63], ["all", "numpy.array", "ValueError"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "item", ")", "->", "np", ".", "array", ":", "\n", "        ", "\"\"\"\n        Overriding this method allows us to customise behaviour for accessing attributes. We use this to allow arbitrary\n        fields in the loop state. These are usually extra outputs from the user function such as cost, constraint values\n        etc. These fields are stored in each individual \"UserFunctionResult\" object in the \"extra_outputs\" dictionary\n\n        :param item: The name of the item to acquire. Must match the key value in the \"extra_outputs\" dictionary in the\n                     stored \"UserFunctionResults\" objects\n        :return: The specified output for all function evaluations in a 2d array of size (n_points x n_dimensions)\n        \"\"\"", "\n", "# check key appears in all results objects", "\n", "is_valid", "=", "all", "(", "[", "item", "in", "res", ".", "extra_outputs", "for", "res", "in", "self", ".", "results", "]", ")", "\n", "if", "not", "is_valid", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} not found in results object\"", ".", "format", "(", "item", ")", ")", "\n", "", "return", "np", ".", "array", "(", "[", "result", ".", "extra_outputs", "[", "item", "]", "for", "result", "in", "self", ".", "results", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state": [[65, 93], ["kwargs.items", "range", "loop_state.LoopState", "ValueError", "dict", "initial_results.append", "ValueError", "user_function_result.UserFunctionResult", "kwargs.items"], "function", ["None"], ["", "", "def", "create_loop_state", "(", "x_init", ":", "np", ".", "ndarray", ",", "y_init", ":", "np", ".", "ndarray", ",", "**", "kwargs", ")", "->", "LoopState", ":", "\n", "    ", "\"\"\"\n    Creates a loop state object using the provided data\n\n    :param x_init: x values for initial function evaluations. Shape: (n_initial_points x n_input_dims)\n    :param y_init: y values for initial function evaluations. Shape: (n_initial_points x n_output_dims)\n    :param kwargs: extra outputs observed from a function evaluation. Shape: (n_initial_points x n_dims)\n    \"\"\"", "\n", "if", "x_init", ".", "shape", "[", "0", "]", "!=", "y_init", ".", "shape", "[", "0", "]", ":", "\n", "        ", "error_message", "=", "\"X and Y should have the same length. Actual length x_init {}, y_init {}\"", ".", "format", "(", "\n", "x_init", ".", "shape", "[", "0", "]", ",", "y_init", ".", "shape", "[", "0", "]", "\n", ")", "\n", "raise", "ValueError", "(", "error_message", ")", "\n", "\n", "", "for", "key", ",", "value", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "        ", "if", "value", ".", "shape", "[", "0", "]", "!=", "x_init", ".", "shape", "[", "0", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Expected keyword argument {} to have length {} but actual length is {}\"", ".", "format", "(", "\n", "key", ",", "x_init", ".", "shape", "[", "0", "]", ",", "value", ".", "shape", "[", "0", "]", "\n", ")", "\n", ")", "\n", "\n", "", "", "initial_results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "x_init", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "kwargs_dict", "=", "dict", "(", "[", "(", "key", ",", "vals", "[", "i", "]", ")", "for", "key", ",", "vals", "in", "kwargs", ".", "items", "(", ")", "]", ")", "\n", "initial_results", ".", "append", "(", "UserFunctionResult", "(", "x_init", "[", "i", "]", ",", "y_init", "[", "i", "]", ",", "**", "kwargs_dict", ")", ")", "\n", "\n", "", "return", "LoopState", "(", "initial_results", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.ModelUpdater.update": [[16, 24], ["None"], "methods", ["None"], ["    ", "@", "abc", ".", "abstractmethod", "\n", "def", "update", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Updates the training data of the model. Chooses whether to update hyper-parameters and how to do it\n\n        :param loop_state: Object that contains current state of the loop\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.NoopModelUpdater.update": [[27, 34], ["None"], "methods", ["None"], ["    ", "def", "update", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Dummy model updater that does nothing. It can be used for example for random search\n\n        :param loop_state: Object that contains current state of the loop\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.__init__": [[39, 53], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "IModel", ",", "interval", ":", "int", "=", "1", ",", "targets_extractor_fcn", ":", "Callable", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param model: Emukit emulator model\n        :param interval: Number of function evaluations between optimizing model hyper-parameters\n        :param targets_extractor_fcn: A function that takes in loop state and returns the training targets.\n                                      Defaults to a function returning loop_state.Y\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "interval", "=", "interval", "\n", "\n", "if", "targets_extractor_fcn", "is", "None", ":", "\n", "            ", "self", ".", "targets_extractor_fcn", "=", "lambda", "loop_state", ":", "loop_state", ".", "Y", "\n", "", "else", ":", "\n", "            ", "self", ".", "targets_extractor_fcn", "=", "targets_extractor_fcn", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update": [[54, 63], ["model_updaters.FixedIntervalUpdater.targets_extractor_fcn", "model_updaters.FixedIntervalUpdater.model.set_data", "_log.info", "model_updaters.FixedIntervalUpdater.model.optimize"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "", "def", "update", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param loop_state: Object that contains current state of the loop\n        \"\"\"", "\n", "targets", "=", "self", ".", "targets_extractor_fcn", "(", "loop_state", ")", "\n", "self", ".", "model", ".", "set_data", "(", "loop_state", ".", "X", ",", "targets", ")", "\n", "if", "(", "loop_state", ".", "iteration", "%", "self", ".", "interval", ")", "==", "0", ":", "\n", "            ", "_log", ".", "info", "(", "\"Updating parameters of the model\"", ")", "\n", "self", ".", "model", ".", "optimize", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function_result.UserFunctionResult.__init__": [[13, 33], ["dict", "kwargs.items", "ValueError", "ValueError", "ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ",", "**", "kwargs", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param X: Function input. Shape: (function input dimension,)\n        :param Y: Function output(s). Shape: (function output dimension,)\n        :param kwargs: Extra outputs of the UserFunction to store. Shape: (extra output dimension,)\n        \"\"\"", "\n", "if", "X", ".", "ndim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"x is expected to be 1-dimensional, actual dimensionality is {}\"", ".", "format", "(", "X", ".", "ndim", ")", ")", "\n", "\n", "", "if", "Y", ".", "ndim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"y is expected to be 1-dimensional, actual dimensionality is {}\"", ".", "format", "(", "Y", ".", "ndim", ")", ")", "\n", "\n", "", "self", ".", "extra_outputs", "=", "dict", "(", ")", "\n", "for", "(", "key", ",", "val", ")", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "if", "val", ".", "ndim", "!=", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"Key word arguments must be 1-dimensional but {} is {}d\"", ".", "format", "(", "key", ",", "val", ".", "ndim", ")", ")", "\n", "", "self", ".", "extra_outputs", "[", "key", "]", "=", "val", "\n", "\n", "", "self", ".", "X", "=", "X", "\n", "self", ".", "Y", "=", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function_result.UserFunctionResult.__eq__": [[34, 40], ["all", "all"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "is_eq", "=", "False", "\n", "try", ":", "\n", "            ", "is_eq", "=", "all", "(", "self", ".", "X", "==", "other", ".", "X", ")", "and", "all", "(", "self", ".", "Y", "==", "other", ".", "Y", ")", "and", "self", ".", "extra_outputs", "==", "other", ".", "extra_outputs", "\n", "", "finally", ":", "\n", "            ", "return", "is_eq", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function_result.UserFunctionResult.__getattr__": [[41, 49], ["None"], "methods", ["None"], ["", "", "def", "__getattr__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"\n        Allow extra output values to be accessed as an attribute\n\n        :param item: The name of the extra output to be accessed\n        :return: The value of the extra output\n        \"\"\"", "\n", "return", "self", ".", "extra_outputs", "[", "item", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function_result.UserFunctionResult.__repr__": [[50, 52], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"UserFunctionResult(X: {}, Y: {}, extra_outputs: {})\"", ".", "format", "(", "self", ".", "X", ",", "self", ".", "Y", ",", "self", ".", "extra_outputs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.StoppingCondition.__and__": [[19, 24], ["stopping_conditions.And"], "methods", ["None"], ["def", "__and__", "(", "self", ",", "other", ":", "\"StoppingCondition\"", ")", "->", "\"And\"", ":", "\n", "        ", "\"\"\"\n        Overloads self & other\n        \"\"\"", "\n", "return", "And", "(", "self", ",", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.StoppingCondition.__or__": [[25, 30], ["stopping_conditions.Or"], "methods", ["None"], ["", "def", "__or__", "(", "self", ",", "other", ":", "\"StoppingCondition\"", ")", "->", "\"Or\"", ":", "\n", "        ", "\"\"\"\n        Overloads self | other\n        \"\"\"", "\n", "return", "Or", "(", "self", ",", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.StoppingCondition.should_stop": [[31, 38], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "should_stop", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        :param loop_state: Object that contains current state of the loop\n        :return: Whether to stop collecting new data\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.And.__init__": [[45, 52], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "left", ":", "StoppingCondition", ",", "right", ":", "StoppingCondition", ")", ":", "\n", "        ", "\"\"\"\n        :param left: One stopping condition in AND\n        :param right: Another stopping condition in AND\n        \"\"\"", "\n", "self", ".", "left", "=", "left", "\n", "self", ".", "right", "=", "right", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.And.should_stop": [[53, 61], ["stopping_conditions.And.left.should_stop", "stopping_conditions.And.right.should_stop"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop"], ["", "def", "should_stop", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Evaluate logical AND of two stopping conditions\n\n        :param loop_state: Object that contains current state of the loop\n        :return: Whether to stop collecting new data\n        \"\"\"", "\n", "return", "self", ".", "left", ".", "should_stop", "(", "loop_state", ")", "and", "self", ".", "right", ".", "should_stop", "(", "loop_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.Or.__init__": [[68, 75], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "left", ":", "StoppingCondition", ",", "right", ":", "StoppingCondition", ")", ":", "\n", "        ", "\"\"\"\n        :param left: One stopping condition in OR\n        :param right: Another stopping condition in OR\n        \"\"\"", "\n", "self", ".", "left", "=", "left", "\n", "self", ".", "right", "=", "right", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.Or.should_stop": [[76, 84], ["stopping_conditions.Or.left.should_stop", "stopping_conditions.Or.right.should_stop"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop"], ["", "def", "should_stop", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Evaluate logical OR of two stopping conditions\n\n        :param loop_state: Object that contains current state of the loop\n        :return: Whether to stop collecting new data\n        \"\"\"", "\n", "return", "self", ".", "left", ".", "should_stop", "(", "loop_state", ")", "or", "self", ".", "right", ".", "should_stop", "(", "loop_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.FixedIterationsStoppingCondition.__init__": [[89, 95], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "i_max", ":", "int", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param i_max: Maximum number of function\n            observations within the loop, excluding initial points\n        \"\"\"", "\n", "self", ".", "i_max", "=", "i_max", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.FixedIterationsStoppingCondition.should_stop": [[96, 105], ["_log.info"], "methods", ["None"], ["", "def", "should_stop", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        :param loop_state: Object that contains current state of the loop\n        :return: True if maximum number of iterations has been reached\n        \"\"\"", "\n", "should_stop", "=", "loop_state", ".", "iteration", ">=", "self", ".", "i_max", "\n", "if", "should_stop", "is", "True", ":", "\n", "            ", "_log", ".", "info", "(", "\"Stopped after {} evaluations\"", ".", "format", "(", "self", ".", "i_max", ")", ")", "\n", "", "return", "should_stop", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.ConvergenceStoppingCondition.__init__": [[114, 120], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "eps", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param eps: minimum distance between\n        two consecutive x's to keep running the model\n        \"\"\"", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.stopping_conditions.ConvergenceStoppingCondition.should_stop": [[121, 134], ["numpy.linalg.norm().item", "_log.info", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "should_stop", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        :param loop_state: Object that contains current state of the loop\n        :return: True if the euclidean distance between the last two evaluations\n                    is smaller than the specified eps.\n        \"\"\"", "\n", "if", "loop_state", ".", "iteration", "<", "2", ":", "\n", "# less than 2 evaluations so cannot calculate distance", "\n", "            ", "return", "False", "\n", "", "should_stop", "=", "np", ".", "linalg", ".", "norm", "(", "loop_state", ".", "X", "[", "-", "1", ",", ":", "]", "-", "loop_state", ".", "X", "[", "-", "2", ",", ":", "]", ")", ".", "item", "(", ")", "<=", "self", ".", "eps", "\n", "if", "should_stop", "is", "True", ":", "\n", "            ", "_log", ".", "info", "(", "\"Stopped as consecutive evaluations are within {}\"", ".", "format", "(", "self", ".", "eps", ")", ")", "\n", "", "return", "should_stop", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.__init__": [[36, 60], ["isinstance", "event_handler.EventHandler", "event_handler.EventHandler", "loop_state.LoopState"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "candidate_point_calculator", ":", "CandidatePointCalculator", ",", "\n", "model_updaters", ":", "Union", "[", "ModelUpdater", ",", "List", "[", "ModelUpdater", "]", "]", ",", "\n", "loop_state", ":", "LoopState", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param candidate_point_calculator: Finds next points to evaluate by optimizing the acquisition function\n        :param model_updaters: Updates the data in the model(s) and the model hyper-parameters when we observe new data\n        :param loop_state: Object that keeps track of the history of the loop.\n                           Default: None, resulting in empty initial state\n        \"\"\"", "\n", "self", ".", "candidate_point_calculator", "=", "candidate_point_calculator", "\n", "\n", "if", "isinstance", "(", "model_updaters", ",", "list", ")", ":", "\n", "            ", "self", ".", "model_updaters", "=", "model_updaters", "\n", "", "else", ":", "\n", "            ", "self", ".", "model_updaters", "=", "[", "model_updaters", "]", "\n", "", "self", ".", "loop_state", "=", "loop_state", "\n", "if", "self", ".", "loop_state", "is", "None", ":", "\n", "            ", "self", ".", "loop_state", "=", "LoopState", "(", "[", "]", ")", "\n", "\n", "", "self", ".", "loop_start_event", "=", "EventHandler", "(", ")", "\n", "self", ".", "iteration_end_event", "=", "EventHandler", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop": [[61, 110], ["isinstance", "isinstance", "isinstance", "_log.info", "outer_loop.OuterLoop.loop_start_event", "outer_loop.OuterLoop._update_models", "_log.info", "ValueError", "isinstance", "user_function.UserFunctionWrapper.UserFunctionWrapper", "stopping_conditions.FixedIterationsStoppingCondition", "stopping_conditions.FixedIterationsStoppingCondition.should_stop", "_log.info", "outer_loop.OuterLoop._update_models", "outer_loop.OuterLoop.candidate_point_calculator.compute_next_points", "_log.debug", "user_function.UserFunctionWrapper.UserFunctionWrapper.evaluate", "_log.debug", "outer_loop.OuterLoop.loop_state.update", "outer_loop.OuterLoop.iteration_end_event", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop._update_models", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop._update_models", "home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update"], ["", "def", "run_loop", "(", "\n", "self", ",", "\n", "user_function", ":", "Union", "[", "UserFunction", ",", "Callable", "]", ",", "\n", "stopping_condition", ":", "Union", "[", "StoppingCondition", ",", "int", "]", ",", "\n", "context", ":", "dict", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param user_function: The function that we are emulating\n        :param stopping_condition: If integer - a number of iterations to run, or an object - a stopping\n                        condition object that decides whether we should stop collecting more points.\n                        Note that stopping conditions can be logically combined (&, |)\n                        to represent complex stopping criteria.\n        :param context: The context is used to force certain parameters of the inputs to the function of interest to\n                        have a given value. It is a dictionary whose keys are the parameter names to fix and the values\n                        are the values to fix the parameters to.\n        \"\"\"", "\n", "\n", "is_int", "=", "isinstance", "(", "stopping_condition", ",", "int", ")", "\n", "is_single_condition", "=", "isinstance", "(", "stopping_condition", ",", "StoppingCondition", ")", "\n", "\n", "if", "not", "(", "is_int", "or", "is_single_condition", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Expected stopping_condition to be an int or a StoppingCondition instance,\"", "\n", "\"but received {}\"", ".", "format", "(", "type", "(", "stopping_condition", ")", ")", "\n", ")", "\n", "\n", "", "if", "not", "isinstance", "(", "user_function", ",", "UserFunction", ")", ":", "\n", "            ", "user_function", "=", "UserFunctionWrapper", "(", "user_function", ")", "\n", "\n", "", "if", "isinstance", "(", "stopping_condition", ",", "int", ")", ":", "\n", "            ", "stopping_condition", "=", "FixedIterationsStoppingCondition", "(", "stopping_condition", "+", "self", ".", "loop_state", ".", "iteration", ")", "\n", "\n", "", "_log", ".", "info", "(", "\"Starting outer loop\"", ")", "\n", "\n", "self", ".", "loop_start_event", "(", "self", ",", "self", ".", "loop_state", ")", "\n", "\n", "while", "not", "stopping_condition", ".", "should_stop", "(", "self", ".", "loop_state", ")", ":", "\n", "            ", "_log", ".", "info", "(", "\"Iteration {}\"", ".", "format", "(", "self", ".", "loop_state", ".", "iteration", ")", ")", "\n", "\n", "self", ".", "_update_models", "(", ")", "\n", "new_x", "=", "self", ".", "candidate_point_calculator", ".", "compute_next_points", "(", "self", ".", "loop_state", ",", "context", ")", "\n", "_log", ".", "debug", "(", "\"Next suggested point(s): {}\"", ".", "format", "(", "new_x", ")", ")", "\n", "results", "=", "user_function", ".", "evaluate", "(", "new_x", ")", "\n", "_log", ".", "debug", "(", "\"User function returned: {}\"", ".", "format", "(", "results", ")", ")", "\n", "self", ".", "loop_state", ".", "update", "(", "results", ")", "\n", "self", ".", "iteration_end_event", "(", "self", ",", "self", ".", "loop_state", ")", "\n", "\n", "", "self", ".", "_update_models", "(", ")", "\n", "_log", ".", "info", "(", "\"Finished outer loop\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop._update_models": [[111, 114], ["model_updater.update"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update"], ["", "def", "_update_models", "(", "self", ")", ":", "\n", "        ", "for", "model_updater", "in", "self", ".", "model_updaters", ":", "\n", "            ", "model_updater", ".", "update", "(", "self", ".", "loop_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.get_next_points": [[115, 130], ["outer_loop.OuterLoop.candidate_point_calculator.compute_next_points", "outer_loop.OuterLoop.loop_state.update", "outer_loop.OuterLoop._update_models"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points", "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop._update_models"], ["", "", "def", "get_next_points", "(", "self", ",", "results", ":", "List", "[", "UserFunctionResult", "]", "=", "None", ",", "context", ":", "dict", "=", "{", "}", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        This method is used when the user doesn't want Emukit to evaluate the function of interest but rather just wants\n        the input locations to evaluate the function at. This method calculates the new input locations.\n\n        :param results: Function results since last loop step\n        :param context: A dictionary of fixed parameters, identical to the context used in\n                        self.run_loop()\n        :return: Next batch of points to run\n        \"\"\"", "\n", "if", "results", ":", "\n", "            ", "self", ".", "loop_state", ".", "update", "(", "results", ")", "\n", "self", ".", "_update_models", "(", ")", "\n", "", "new_x", "=", "self", ".", "candidate_point_calculator", ".", "compute_next_points", "(", "self", ".", "loop_state", ",", "context", ")", "\n", "return", "new_x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function.UserFunction.evaluate": [[26, 29], ["None"], "methods", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "evaluate", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "List", "[", "UserFunctionResult", "]", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function.UserFunction.__call__": [[30, 32], ["user_function.UserFunction.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "__call__", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "List", "[", "UserFunctionResult", "]", ":", "\n", "        ", "return", "self", ".", "evaluate", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function.UserFunctionWrapper.__init__": [[37, 48], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "f", ":", "Callable", ",", "extra_output_names", ":", "List", "[", "str", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param f: A python function that takes in a 2d numpy ndarray of inputs and returns a either a 2d numpy array\n                  of function outputs or a tuple of (outputs, auxillary_output_1, auxilary_output_2, ...)\n                  where all outputs are 2d\n        :param extra_output_names: If the function f returns a tuple, the first output should be the value of the\n                                   objective, which will be named \"Y\", names for subsequent outputs should be included\n                                   in this list.\n        \"\"\"", "\n", "self", ".", "f", "=", "f", "\n", "self", ".", "extra_output_names", "=", "[", "]", "if", "extra_output_names", "is", "None", "else", "extra_output_names", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function.UserFunctionWrapper.evaluate": [[49, 97], ["_log.info", "user_function.UserFunctionWrapper.f", "isinstance", "range", "ValueError", "isinstance", "len", "len", "ValueError", "ValueError", "dict", "results.append", "tuple", "ValueError", "user_function_result.UserFunctionResult", "type", "len", "len", "zip"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["", "def", "evaluate", "(", "self", ",", "inputs", ":", "np", ".", "ndarray", ")", "->", "List", "[", "UserFunctionResult", "]", ":", "\n", "        ", "\"\"\"\n        Evaluates python function by providing it with numpy types and converts the output\n        to a List of UserFunctionResults\n\n        :param inputs: List of function inputs at which to evaluate function\n        :return: List of function results\n        \"\"\"", "\n", "if", "inputs", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"User function should receive 2d array as an input, \"", "\n", "\"actual input dimensionality is {}\"", ".", "format", "(", "inputs", ".", "ndim", ")", "\n", ")", "\n", "\n", "", "_log", ".", "info", "(", "\"Evaluating user function for {} point(s)\"", ".", "format", "(", "inputs", ".", "shape", "[", "0", "]", ")", ")", "\n", "outputs", "=", "self", ".", "f", "(", "inputs", ")", "\n", "\n", "if", "isinstance", "(", "outputs", ",", "tuple", ")", ":", "\n", "            ", "user_fcn_outputs", "=", "outputs", "[", "0", "]", "\n", "extra_outputs", "=", "outputs", "[", "1", ":", "]", "\n", "", "elif", "isinstance", "(", "outputs", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "user_fcn_outputs", "=", "outputs", "\n", "extra_outputs", "=", "tuple", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"User provided function should return a tuple or an ndarray, \"", "\"{} received\"", ".", "format", "(", "type", "(", "outputs", ")", ")", "\n", ")", "\n", "\n", "# Validate number of outputs returned by the user function", "\n", "", "if", "len", "(", "extra_outputs", ")", "!=", "len", "(", "self", ".", "extra_output_names", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"User function provided {} outputs but UserFunctionWrapper expected {}\"", ".", "format", "(", "\n", "len", "(", "extra_outputs", ")", "+", "1", ",", "len", "(", "self", ".", "extra_output_names", ")", "+", "1", "\n", ")", "\n", ")", "\n", "\n", "", "if", "user_fcn_outputs", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"User function should return 2d array or a tuple of 2d arrays as an output, \"", "\n", "\"actual output dimensionality is {}\"", ".", "format", "(", "outputs", ".", "ndim", ")", "\n", ")", "\n", "\n", "", "results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "user_fcn_outputs", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "kwargs", "=", "dict", "(", "[", "(", "name", ",", "val", "[", "i", "]", ")", "for", "name", ",", "val", "in", "zip", "(", "self", ".", "extra_output_names", ",", "extra_outputs", ")", "]", ")", "\n", "results", ".", "append", "(", "UserFunctionResult", "(", "inputs", "[", "i", "]", ",", "user_fcn_outputs", "[", "i", "]", ",", "**", "kwargs", ")", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function.MultiSourceFunctionWrapper.__init__": [[104, 117], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "f", ":", "List", ",", "source_index", ":", "int", "=", "-", "1", ",", "extra_output_names", ":", "List", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param f: A list of python function that take in a 2d numpy ndarrays of inputs and return 2d numpy ndarrays\n                  of outputs.\n        :param source_index: An integer indicating which column of X contains the index of the information source.\n                             Default to the last dimension of the input.\n        :param extra_output_names: If the function f returns a tuple, the first output should be the value of the\n                                   objective, which will be named \"Y\", names for subsequent outputs should be included\n                                   in this list.\n        \"\"\"", "\n", "self", ".", "f", "=", "f", "\n", "self", ".", "source_index", "=", "source_index", "\n", "self", ".", "extra_output_names", "=", "[", "]", "if", "extra_output_names", "is", "None", "else", "extra_output_names", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.user_function.MultiSourceFunctionWrapper.evaluate": [[118, 191], ["len", "_log.info", "numpy.delete", "range", "numpy.argsort", "numpy.concatenate", "len", "range", "enumerate", "ValueError", "numpy.flatnonzero", "indices.append", "isinstance", "numpy.concatenate", "range", "dict", "results.append", "numpy.concatenate.append", "extra_outputs.append", "isinstance", "range", "extra_output_lists[].extend", "user_function_result.UserFunctionResult", "len", "len", "ValueError", "numpy.concatenate.append", "extra_outputs.append", "ValueError", "len", "ValueError", "tuple", "zip", "type", "len", "len", "len"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "inputs", ":", "np", ".", "ndarray", ")", "->", "List", "[", "UserFunctionResult", "]", ":", "\n", "        ", "\"\"\"\n        Evaluates the python functions corresponding to the appropriate information source\n\n        :param inputs: A list of inputs to evaluate the function at\n                       with information source index appended as last column\n        :return: A list of function outputs\n        \"\"\"", "\n", "\n", "if", "inputs", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"User function should receive 2d array as an input, \"", "\n", "\"actual input dimensionality is {}\"", ".", "format", "(", "inputs", ".", "ndim", ")", "\n", ")", "\n", "\n", "", "n_sources", "=", "len", "(", "self", ".", "f", ")", "\n", "\n", "_log", ".", "info", "(", "\"Evaluating multi-source user function for {} point(s)\"", ".", "format", "(", "inputs", ".", "shape", "[", "0", "]", ")", ")", "\n", "# Run each source function for all inputs at that source", "\n", "indices", ",", "outputs", ",", "extra_outputs", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "source_indices", "=", "inputs", "[", ":", ",", "self", ".", "source_index", "]", "\n", "source_inputs", "=", "np", ".", "delete", "(", "inputs", ",", "self", ".", "source_index", ",", "axis", "=", "1", ")", "\n", "for", "i_source", "in", "range", "(", "n_sources", ")", ":", "\n", "# Find inputs at that source", "\n", "            ", "this_source_input_indices", "=", "np", ".", "flatnonzero", "(", "source_indices", "==", "i_source", ")", "\n", "indices", ".", "append", "(", "this_source_input_indices", ")", "\n", "this_source_inputs", "=", "source_inputs", "[", "this_source_input_indices", "]", "\n", "this_outputs", "=", "self", ".", "f", "[", "i_source", "]", "(", "this_source_inputs", ")", "\n", "\n", "if", "isinstance", "(", "this_outputs", ",", "tuple", ")", ":", "\n", "                ", "outputs", ".", "append", "(", "this_outputs", "[", "0", "]", ")", "\n", "extra_outputs", ".", "append", "(", "this_outputs", "[", "1", ":", "]", ")", "\n", "\n", "# Check correct number of outputs from user function", "\n", "if", "len", "(", "extra_outputs", "[", "-", "1", "]", ")", "!=", "len", "(", "self", ".", "extra_output_names", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"Expected {} outputs from user function but got {}\"", ".", "format", "(", "\n", "len", "(", "self", ".", "extra_output_names", ")", "+", "1", ",", "len", "(", "extra_outputs", "[", "-", "1", "]", ")", "+", "1", "\n", ")", "\n", ")", "\n", "", "", "elif", "isinstance", "(", "this_outputs", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "outputs", ".", "append", "(", "this_outputs", ")", "\n", "\n", "# Check correct number of outputs from user function", "\n", "if", "len", "(", "self", ".", "extra_output_names", ")", "!=", "0", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"Expected {} output from user function but got 1\"", ".", "format", "(", "len", "(", "self", ".", "extra_output_names", ")", "+", "1", ")", "\n", ")", "\n", "\n", "# Dummy extra outputs - won't be used below", "\n", "", "extra_outputs", ".", "append", "(", "tuple", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"User provided function should return a tuple or an ndarray, \"", "\n", "\"{} received\"", ".", "format", "(", "type", "(", "this_outputs", ")", ")", "\n", ")", "\n", "\n", "", "", "sort_indices", "=", "np", ".", "argsort", "(", "np", ".", "concatenate", "(", "indices", ",", "axis", "=", "0", ")", ")", "\n", "outputs", "=", "np", ".", "concatenate", "(", "outputs", ",", "axis", "=", "0", ")", "\n", "\n", "# Concatenate list of lists to single list", "\n", "n_extra_outputs", "=", "len", "(", "self", ".", "extra_output_names", ")", "\n", "extra_output_lists", "=", "[", "[", "]", "for", "_", "in", "range", "(", "n_extra_outputs", ")", "]", "\n", "for", "i_source", "in", "range", "(", "n_sources", ")", ":", "\n", "            ", "for", "i_output", "in", "range", "(", "n_extra_outputs", ")", ":", "\n", "                ", "extra_output_lists", "[", "i_output", "]", ".", "extend", "(", "extra_outputs", "[", "i_source", "]", "[", "i_output", "]", ")", "\n", "\n", "", "", "results", "=", "[", "]", "\n", "for", "i", ",", "idx_sorted", "in", "enumerate", "(", "sort_indices", ")", ":", "\n", "# Put extra outputs into a dictionary so we can pass them as key word arguments", "\n", "            ", "kwargs", "=", "dict", "(", "[", "(", "name", ",", "val", "[", "idx_sorted", "]", ")", "for", "name", ",", "val", "in", "zip", "(", "self", ".", "extra_output_names", ",", "extra_output_lists", ")", "]", ")", "\n", "results", ".", "append", "(", "UserFunctionResult", "(", "inputs", "[", "i", "]", ",", "outputs", "[", "idx_sorted", "]", ",", "**", "kwargs", ")", ")", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop.candidate_point_calculators.CandidatePointCalculator.compute_next_points": [[20, 29], ["None"], "methods", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "compute_next_points", "(", "self", ",", "loop_state", ":", "LoopState", ",", "context", ":", "dict", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :param loop_state: Object that contains current state of the loop\n        :param context: Contains variables to fix through optimization of acquisition function. The dictionary key is\n                        the parameter name and the value is the value to fix the parameter to.\n        :return: (n_points x n_dims) array of next inputs to evaluate the function at\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.candidate_point_calculators.SequentialPointCalculator.__init__": [[34, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param acquisition: Acquisition function to maximise\n        :param acquisition_optimizer: Optimizer of acquisition function\n        \"\"\"", "\n", "self", ".", "acquisition", "=", "acquisition", "\n", "self", ".", "acquisition_optimizer", "=", "acquisition_optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.candidate_point_calculators.SequentialPointCalculator.compute_next_points": [[42, 54], ["candidate_point_calculators.SequentialPointCalculator.acquisition.update_parameters", "candidate_point_calculators.SequentialPointCalculator.acquisition_optimizer.optimize"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "compute_next_points", "(", "self", ",", "loop_state", ":", "LoopState", ",", "context", ":", "dict", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes point(s) to evaluate next\n\n        :param loop_state: Object that contains current state of the loop\n        :param context: Contains variables to fix through optimization of acquisition function. The dictionary key is\n                        the parameter name and the value is the value to fix the parameter to.\n        :return: List of function inputs to evaluate the function at next\n        \"\"\"", "\n", "self", ".", "acquisition", ".", "update_parameters", "(", ")", "\n", "x", ",", "_", "=", "self", ".", "acquisition_optimizer", ".", "optimize", "(", "self", ".", "acquisition", ",", "context", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.candidate_point_calculators.GreedyBatchPointCalculator.__init__": [[64, 84], ["ValueError", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "IModel", ",", "\n", "acquisition", ":", "Acquisition", ",", "\n", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", ",", "\n", "batch_size", ":", "int", "=", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param model: Model that is used by the acquisition function\n        :param acquisition: Acquisition to be optimized to find each point in batch\n        :param acquisition_optimizer: Acquisition optimizer that optimizes acquisition function\n                                      to find each point in batch\n        :param batch_size: Number of points to calculate in batch\n        \"\"\"", "\n", "if", "(", "not", "isinstance", "(", "batch_size", ",", "int", ")", ")", "or", "(", "batch_size", "<", "1", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Batch size should be a positive integer\"", ")", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "acquisition", "=", "acquisition", "\n", "self", ".", "acquisition_optimizer", "=", "acquisition_optimizer", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.candidate_point_calculators.GreedyBatchPointCalculator.compute_next_points": [[85, 108], ["candidate_point_calculators.GreedyBatchPointCalculator.acquisition.update_parameters", "range", "candidate_point_calculators.GreedyBatchPointCalculator.model.set_data", "numpy.concatenate", "candidate_point_calculators.GreedyBatchPointCalculator.acquisition_optimizer.optimize", "new_xs.append", "numpy.concatenate", "numpy.concatenate", "candidate_point_calculators.GreedyBatchPointCalculator.model.set_data", "candidate_point_calculators.GreedyBatchPointCalculator.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "compute_next_points", "(", "self", ",", "loop_state", ":", "LoopState", ",", "context", ":", "dict", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :param loop_state: Object containing history of the loop\n        :param context: Contains variables to fix through optimization of acquisition function. The dictionary key is\n                        the parameter name and the value is the value to fix the parameter to.\n        :return: 2d array of size (batch_size x input dimensions) of new points to evaluate\n        \"\"\"", "\n", "self", ".", "acquisition", ".", "update_parameters", "(", ")", "\n", "new_xs", "=", "[", "]", "\n", "original_data", "=", "(", "self", ".", "model", ".", "X", ",", "self", ".", "model", ".", "Y", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "            ", "new_x", ",", "_", "=", "self", ".", "acquisition_optimizer", ".", "optimize", "(", "self", ".", "acquisition", ",", "context", ")", "\n", "new_xs", ".", "append", "(", "new_x", ")", "\n", "new_y", "=", "self", ".", "model", ".", "predict", "(", "new_x", ")", "[", "0", "]", "\n", "\n", "# Add new point as fake observation in model", "\n", "all_x", "=", "np", ".", "concatenate", "(", "[", "self", ".", "model", ".", "X", ",", "new_x", "]", ",", "axis", "=", "0", ")", "\n", "all_y", "=", "np", ".", "concatenate", "(", "[", "self", ".", "model", ".", "Y", ",", "new_y", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "model", ".", "set_data", "(", "all_x", ",", "all_y", ")", "\n", "\n", "# Reset data", "\n", "", "self", ".", "model", ".", "set_data", "(", "*", "original_data", ")", "\n", "return", "np", ".", "concatenate", "(", "new_xs", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.candidate_point_calculators.RandomSampling.__init__": [[116, 121], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "parameter_space", ":", "ParameterSpace", ")", ":", "\n", "        ", "\"\"\"\n        :param parameter_space: Input space\n        \"\"\"", "\n", "self", ".", "parameter_space", "=", "parameter_space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop.candidate_point_calculators.RandomSampling.compute_next_points": [[122, 137], ["optimization.context_manager.ContextManager", "optimization.context_manager.ContextManager.contextfree_space.sample_uniform", "optimization.context_manager.ContextManager.expand_vector", "candidate_point_calculators.RandomSampling.parameter_space.sample_uniform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform"], ["", "def", "compute_next_points", "(", "self", ",", "loop_state", ":", "LoopState", ",", "context", ":", "dict", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :param loop_state: Object that contains current state of the loop\n        :param context: Contains variables to fix through optimization of acquisition function. The dictionary key is\n                        the parameter name and the value is the value to fix the parameter to.\n        :return: (1 x n_dims) array of next inputs to evaluate the function at\n        \"\"\"", "\n", "\n", "if", "context", "is", "not", "None", ":", "\n", "            ", "context_manager", "=", "ContextManager", "(", "self", ".", "parameter_space", ",", "context", ")", "\n", "sample", "=", "context_manager", ".", "contextfree_space", ".", "sample_uniform", "(", "1", ")", "\n", "sample", "=", "context_manager", ".", "expand_vector", "(", "sample", ")", "\n", "", "else", ":", "\n", "            ", "sample", "=", "self", ".", "parameter_space", ".", "sample_uniform", "(", "1", ")", "\n", "", "return", "sample", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.__init__": [[36, 45], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "WarpedBayesianQuadratureModel", ",", "parameter_space", ":", "ParameterSpace", ")", ":", "\n", "        ", "self", ".", "parameter_space", "=", "parameter_space", "\n", "self", ".", "model", "=", "model", "\n", "\n", "# if measure is probability measure, check if it has sampling capabilities", "\n", "if", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "measure", "is", "not", "None", ":", "\n", "            ", "if", "not", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "measure", ".", "can_sample", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"The given probability measure does not support sampling, but Bayesian Monte Carlo \"", "\n", "\"requires sampling capability.\"", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points": [[48, 76], ["quadrature_point_calculators.BayesianMonteCarloPointCalculator.parameter_space.sample_uniform", "core.optimization.context_manager.ContextManager", "core.optimization.context_manager.ContextManager.contextfree_space.sample_uniform", "core.optimization.context_manager.ContextManager.expand_vector", "measure.sample", "core.optimization.context_manager.ContextManager", "measure.sample"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample"], ["", "", "", "def", "compute_next_points", "(", "self", ",", "loop_state", ":", "LoopState", ",", "context", ":", "dict", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Computes the next point.\n\n        :param loop_state: Object that contains current state of the loop.\n        :param context: Contains variables to fix and the values to fix them to. The dictionary key is the parameter\n                        name and the value is the value to fix the parameter to.\n        :return: The next point to evaluate the function at, shape (1, input_dim).\n        \"\"\"", "\n", "\n", "measure", "=", "self", ".", "model", ".", "base_gp", ".", "kern", ".", "measure", "\n", "\n", "# Lebesgue measure", "\n", "if", "measure", "is", "None", ":", "\n", "            ", "if", "context", "is", "None", ":", "\n", "                ", "return", "self", ".", "parameter_space", ".", "sample_uniform", "(", "1", ")", "\n", "", "else", ":", "\n", "                ", "context_manager", "=", "ContextManager", "(", "self", ".", "parameter_space", ",", "context", ")", "\n", "samples", "=", "context_manager", ".", "contextfree_space", ".", "sample_uniform", "(", "1", ")", "\n", "return", "context_manager", ".", "expand_vector", "(", "samples", ")", "\n", "\n", "# probability measure", "\n", "", "", "else", ":", "\n", "            ", "if", "context", "is", "None", ":", "\n", "                ", "return", "measure", ".", "sample", "(", "1", ")", "\n", "", "else", ":", "\n", "                ", "context_manager", "=", "ContextManager", "(", "self", ".", "parameter_space", ",", "context", ")", "\n", "samples", "=", "measure", ".", "sample", "(", "1", ",", "context_manager", ")", "\n", "return", "samples", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.__init__": [[31, 48], ["integration_measure.IntegrationMeasure.__init__", "numpy.array", "numpy.prod", "float", "lebesgue_measure.NumericalPrecisionError"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "domain", ":", "BoxDomain", ",", "normalized", ":", "bool", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "domain", "=", "domain", ",", "name", "=", "\"LebesgueMeasure\"", ")", "\n", "\n", "density", "=", "1.0", "\n", "if", "normalized", ":", "\n", "            ", "differences", "=", "np", ".", "array", "(", "[", "x", "[", "1", "]", "-", "x", "[", "0", "]", "for", "x", "in", "self", ".", "domain", ".", "bounds", "]", ")", "\n", "volume", "=", "np", ".", "prod", "(", "differences", ")", "\n", "\n", "if", "volume", "<=", "0", ":", "\n", "                ", "raise", "NumericalPrecisionError", "(", "\n", "\"Domain volume of uniform measure is not positive. Its value is {}.\"", ".", "format", "(", "volume", ")", "\n", ")", "\n", "", "density", "=", "float", "(", "1.0", "/", "volume", ")", "\n", "\n", "", "self", ".", "density", "=", "density", "\n", "self", ".", "is_normalized", "=", "normalized", "\n", "self", ".", "_input_dim", "=", "self", ".", "domain", ".", "dim", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.input_dim": [[49, 52], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "input_dim", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_input_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.can_sample": [[53, 56], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "can_sample", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.compute_density": [[57, 68], ["numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "compute_density", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "# Compute density: (i) check if points are inside the box. (ii) multiply this bool value with density.", "\n", "        ", "bounds_lower", "=", "np", ".", "array", "(", "[", "b", "[", "0", "]", "for", "b", "in", "self", ".", "domain", ".", "bounds", "]", ")", "\n", "bounds_upper", "=", "np", ".", "array", "(", "[", "b", "[", "1", "]", "for", "b", "in", "self", ".", "domain", ".", "bounds", "]", ")", "\n", "inside_lower", "=", "1", "-", "(", "x", "<", "bounds_lower", ")", "# contains 1 if element in x is above its lower bound, 0 otherwise", "\n", "inside_upper", "=", "1", "-", "(", "x", ">", "bounds_upper", ")", "# contains 1 if element in x is below its upper bound, 0 otherwise", "\n", "\n", "# Contains True if element in x is inside box, False otherwise.", "\n", "# The returned array thus contains self._density for each point inside the box and 0 otherwise.", "\n", "inside_upper_lower", "=", "(", "inside_lower", "*", "inside_upper", ")", ".", "sum", "(", "axis", "=", "1", ")", "==", "x", ".", "shape", "[", "1", "]", "\n", "return", "inside_upper_lower", "*", "self", ".", "density", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.compute_density_gradient": [[69, 71], ["numpy.zeros"], "methods", ["None"], ["", "def", "compute_density_gradient", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "x", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.reasonable_box": [[72, 74], ["None"], "methods", ["None"], ["", "def", "reasonable_box", "(", "self", ")", "->", "BoundsType", ":", "\n", "        ", "return", "self", ".", "domain", ".", "bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.sample": [[75, 84], ["numpy.asarray", "numpy.random.rand"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "num_samples", ":", "int", ",", "context_manager", ":", "ContextManager", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "bounds", "=", "np", ".", "asarray", "(", "self", ".", "domain", ".", "bounds", ")", "\n", "\n", "samples", "=", "np", ".", "random", ".", "rand", "(", "num_samples", ",", "self", ".", "input_dim", ")", "*", "(", "bounds", "[", ":", ",", "1", "]", "-", "bounds", "[", ":", ",", "0", "]", ")", "+", "bounds", "[", ":", ",", "0", "]", "\n", "\n", "if", "context_manager", "is", "not", "None", ":", "\n", "            ", "samples", "[", ":", ",", "context_manager", ".", "context_idxs", "]", "=", "context_manager", ".", "context_values", "\n", "\n", "", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds": [[85, 101], ["domain.BoxDomain.BoxDomain", "cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_bounds", "(", "cls", ",", "bounds", ":", "BoundsType", ",", "normalized", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Creates and instance of this class from integration bounds.\n\n        .. seealso::\n            * :class:`emukit.quadrature.measures.BoxDomain`\n\n        :param bounds: List of :math:`d` tuples :math:`[(a_1, b_1), (a_2, b_2), \\dots, (a_d, b_d)]`,\n                       where :math:`d` is the dimensionality of the domain and the tuple :math:`(a_i, b_i)`\n                       contains the lower and upper bound of dimension :math:`i` defining the box domain.\n        :param normalized: Weather the Lebesgue measure is normalized.\n        :return: An instance of LebesgueMeasure.\n\n        \"\"\"", "\n", "domain", "=", "BoxDomain", "(", "name", "=", "\"\"", ",", "bounds", "=", "bounds", ")", "\n", "return", "cls", "(", "domain", "=", "domain", ",", "normalized", "=", "normalized", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.integration_measure.IntegrationMeasure.__init__": [[22, 25], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "domain", ":", "Optional", "[", "BoxDomain", "]", ",", "name", ":", "str", ")", ":", "\n", "        ", "self", ".", "domain", "=", "domain", "\n", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.integration_measure.IntegrationMeasure.input_dim": [[26, 30], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "input_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"The input dimensionality.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.integration_measure.IntegrationMeasure.can_sample": [[31, 38], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "can_sample", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Indicates whether the measure has sampling available.\n\n        :return: ``True`` if sampling is available. ``False`` otherwise.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.integration_measure.IntegrationMeasure.compute_density": [[39, 46], ["None"], "methods", ["None"], ["", "def", "compute_density", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Evaluates the density at x.\n\n        :param x: Points at which density is evaluated, shape (n_points, input_dim).\n        :return: The density at x, shape (n_points, ).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.integration_measure.IntegrationMeasure.compute_density_gradient": [[47, 54], ["None"], "methods", ["None"], ["", "def", "compute_density_gradient", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Evaluates the gradient of the density at x.\n\n        :param x: Points at which the gradient is evaluated, shape (n_points, input_dim).\n        :return: The gradient of the density at x, shape (n_points, input_dim).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.integration_measure.IntegrationMeasure.reasonable_box": [[55, 63], ["None"], "methods", ["None"], ["", "def", "reasonable_box", "(", "self", ")", "->", "BoundsType", ":", "\n", "        ", "\"\"\"A reasonable box containing the measure.\n\n        Outside this box, the measure should be zero or virtually zero.\n\n        :return: The reasonable box.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.integration_measure.IntegrationMeasure.sample": [[64, 73], ["None"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "num_samples", ":", "int", ",", "context_manager", ":", "ContextManager", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Samples from the measure.\n\n        :param num_samples: The number of samples to be taken.\n        :param context_manager: The context manager that contains variables to fix and the values to fix them to.\n                                If a context is given, this method samples from the conditional distribution.\n        :return: The samples, shape (num_samples, input_dim).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain.__init__": [[24, 34], ["domain.BoxDomain._check_bound_validity", "len", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain._check_bound_validity"], ["def", "__init__", "(", "self", ",", "bounds", ":", "BoundsType", ",", "name", ":", "str", "=", "\"\"", ")", ":", "\n", "        ", "self", ".", "_check_bound_validity", "(", "bounds", ")", "\n", "self", ".", "_bounds", "=", "bounds", "\n", "self", ".", "dim", "=", "len", "(", "bounds", ")", "\n", "self", ".", "name", "=", "name", "\n", "\n", "# set upper and lower bounds arrays for convenience", "\n", "bounds", "=", "np", ".", "array", "(", "bounds", ")", "\n", "self", ".", "lower_bounds", "=", "bounds", "[", ":", ",", "0", "]", "\n", "self", ".", "upper_bounds", "=", "bounds", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain.bounds": [[40, 58], ["domain.BoxDomain._check_bound_validity", "numpy.array", "ValueError", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain._check_bound_validity"], ["", "@", "bounds", ".", "setter", "\n", "def", "bounds", "(", "self", ",", "new_bounds", ":", "BoundsType", ")", "->", "None", ":", "\n", "        ", "\"\"\"Sets new box bounds and checks their validity.\n\n        :param new_bounds: The new bounds.\n\n        :raises ValueError: If ``new_bounds`` is not equal to dimensionality of measure.\n\n        \"\"\"", "\n", "if", "not", "len", "(", "new_bounds", ")", "==", "self", ".", "dim", ":", "\n", "            ", "raise", "ValueError", "(", "\"Length of new box bounds is {} (length {} expected).\"", ".", "format", "(", "len", "(", "new_bounds", ")", ",", "self", ".", "dim", ")", ")", "\n", "\n", "", "self", ".", "_check_bound_validity", "(", "new_bounds", ")", "\n", "self", ".", "_bounds", "=", "new_bounds", "\n", "\n", "new_bounds", "=", "np", ".", "array", "(", "new_bounds", ")", "\n", "self", ".", "lower_bounds", "=", "new_bounds", "[", ":", ",", "0", "]", "\n", "self", ".", "upper_bounds", "=", "new_bounds", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain._check_bound_validity": [[59, 77], ["len", "ValueError", "ValueError"], "methods", ["None"], ["", "def", "_check_bound_validity", "(", "self", ",", "bounds", ":", "BoundsType", ")", "->", "None", ":", "\n", "        ", "\"\"\"Checks if domain is not empty.\n\n        :param bounds: The bounds to be checked.\n\n        :raises ValueError: If bounds list is empty.\n        :raises ValueError: If volume of hypercube defined by the bounds is emtpy.\n\n        \"\"\"", "\n", "if", "len", "(", "bounds", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Length of bound list must be > 0; empty list found.\"", ")", "\n", "\n", "", "for", "bounds_d", "in", "bounds", ":", "\n", "            ", "lb_d", ",", "ub_d", "=", "bounds_d", "\n", "if", "lb_d", ">=", "ub_d", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Upper box bound must be larger than lower bound. Found a pair containing ({}, \"", "\n", "\"{}).\"", ".", "format", "(", "lb_d", ",", "ub_d", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.domain.BoxDomain.convert_to_list_of_continuous_parameters": [[79, 91], ["enumerate", "core.continuous_parameter.ContinuousParameter", "continuous_parameters.append", "str"], "methods", ["None"], ["", "", "", "def", "convert_to_list_of_continuous_parameters", "(", "self", ")", "->", "List", "[", "ContinuousParameter", "]", ":", "\n", "        ", "\"\"\"Converts the box bounds into a list of :class:`ContinuousParameter` objects.\n\n        :return: The continuous parameters (one for each dimension of the box).\n        \"\"\"", "\n", "continuous_parameters", "=", "[", "]", "\n", "for", "i", ",", "bounds_d", "in", "enumerate", "(", "self", ".", "_bounds", ")", ":", "\n", "            ", "lb_d", ",", "ub_d", "=", "bounds_d", "\n", "name_d", "=", "self", ".", "name", "+", "\"_\"", "+", "str", "(", "i", ")", "\n", "param", "=", "ContinuousParameter", "(", "name", "=", "name_d", ",", "min_value", "=", "lb_d", ",", "max_value", "=", "ub_d", ")", "\n", "continuous_parameters", ".", "append", "(", "param", ")", "\n", "", "return", "continuous_parameters", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.__init__": [[36, 71], ["integration_measure.IntegrationMeasure.__init__", "isinstance", "isinstance", "TypeError", "ValueError", "numpy.full", "isinstance", "ValueError", "any", "TypeError", "type", "ValueError", "ValueError", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "mean", ":", "np", ".", "ndarray", ",", "variance", ":", "Union", "[", "float", ",", "np", ".", "ndarray", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "domain", "=", "None", ",", "name", "=", "\"GaussianMeasure\"", ")", "\n", "# check mean", "\n", "if", "not", "isinstance", "(", "mean", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"Mean must be of type numpy.ndarray, {} given.\"", ".", "format", "(", "type", "(", "mean", ")", ")", ")", "\n", "\n", "", "if", "mean", ".", "ndim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Dimension of mean must be 1, dimension {} given.\"", ".", "format", "(", "mean", ".", "ndim", ")", ")", "\n", "\n", "# check covariance", "\n", "", "is_isotropic", "=", "False", "\n", "\n", "if", "isinstance", "(", "variance", ",", "float", ")", ":", "\n", "            ", "if", "variance", "<=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"Variance must be positive, current value is {}.\"", ".", "format", "(", "variance", ")", ")", "\n", "", "variance", "=", "np", ".", "full", "(", "(", "mean", ".", "shape", "[", "0", "]", ",", ")", ",", "variance", ")", "\n", "is_isotropic", "=", "True", "\n", "\n", "", "elif", "isinstance", "(", "variance", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "if", "variance", ".", "shape", "!=", "mean", ".", "shape", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Variance has wrong shape; {} given but {} expected.\"", ".", "format", "(", "variance", ".", "shape", ",", "mean", ".", "shape", ")", "\n", ")", "\n", "", "if", "any", "(", "variance", "<=", "0", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"All elements of variance must be positive. At least one value seems to be non positive.\"", "\n", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"Variance must be of type float or numpy.ndarray, {} given.\"", ".", "format", "(", "type", "(", "variance", ")", ")", ")", "\n", "\n", "", "self", ".", "mean", "=", "mean", "\n", "self", ".", "variance", "=", "variance", "\n", "self", ".", "_input_dim", "=", "mean", ".", "shape", "[", "0", "]", "\n", "self", ".", "is_isotropic", "=", "is_isotropic", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.input_dim": [[72, 75], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "input_dim", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_input_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.full_covariance_matrix": [[76, 80], ["numpy.diag"], "methods", ["None"], ["", "@", "property", "\n", "def", "full_covariance_matrix", "(", "self", ")", ":", "\n", "        ", "\"\"\"The full covariance matrix of the Gaussian measure.\"\"\"", "\n", "return", "np", ".", "diag", "(", "self", ".", "variance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.can_sample": [[81, 84], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "can_sample", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density": [[85, 89], ["numpy.prod", "numpy.sqrt", "numpy.exp", "numpy.sqrt", "numpy.sum"], "methods", ["None"], ["", "def", "compute_density", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "factor", "=", "(", "2", "*", "np", ".", "pi", ")", "**", "(", "self", ".", "input_dim", "/", "2", ")", "*", "np", ".", "prod", "(", "np", ".", "sqrt", "(", "self", ".", "variance", ")", ")", "\n", "scaled_diff", "=", "(", "x", "-", "self", ".", "mean", ")", "/", "(", "np", ".", "sqrt", "(", "2", "*", "self", ".", "variance", ")", ")", "\n", "return", "np", ".", "exp", "(", "-", "np", ".", "sum", "(", "scaled_diff", "**", "2", ",", "axis", "=", "1", ")", ")", "/", "factor", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density_gradient": [[90, 94], ["gaussian_measure.GaussianMeasure.compute_density"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.compute_density"], ["", "def", "compute_density_gradient", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "values", "=", "self", ".", "compute_density", "(", "x", ")", "\n", "diff", "=", "(", "x", "-", "self", ".", "mean", ")", "/", "self", ".", "variance", "\n", "return", "-", "diff", "*", "values", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.reasonable_box": [[95, 104], ["list", "zip", "numpy.sqrt", "numpy.sqrt"], "methods", ["None"], ["", "def", "reasonable_box", "(", "self", ")", "->", "BoundsType", ":", "\n", "# The reasonable box is defined as the hypercube centered at the mean of the Gaussian with 10 standard", "\n", "# deviations expanding to either side (edge length of the cube are thus 20 standard deviations).", "\n", "# The factor 10 is somewhat arbitrary but well motivated as the Gaussian measure if virtually zero", "\n", "# outside of 10 standard deviations. See also the docstring of IntegrationMeasure.reasonable_box.", "\n", "        ", "factor", "=", "10", "\n", "lower", "=", "self", ".", "mean", "-", "factor", "*", "np", ".", "sqrt", "(", "self", ".", "variance", ")", "\n", "upper", "=", "self", ".", "mean", "+", "factor", "*", "np", ".", "sqrt", "(", "self", ".", "variance", ")", "\n", "return", "list", "(", "zip", "(", "lower", ",", "upper", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample": [[105, 114], ["numpy.sqrt", "numpy.random.randn"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "num_samples", ":", "int", ",", "context_manager", ":", "ContextManager", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "samples", "=", "self", ".", "mean", "+", "np", ".", "sqrt", "(", "self", ".", "variance", ")", "*", "np", ".", "random", ".", "randn", "(", "num_samples", ",", "self", ".", "input_dim", ")", "\n", "\n", "if", "context_manager", "is", "not", "None", ":", "\n", "# Since the Gaussian is diagonal, fixing the value after sampling the joint is equal to sampling the", "\n", "# conditional.", "\n", "            ", "samples", "[", ":", ",", "context_manager", ".", "context_idxs", "]", "=", "context_manager", ".", "context_values", "\n", "\n", "", "return", "samples", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.methods.bounded_bq_model.BoundedBayesianQuadrature.__init__": [[44, 74], ["warped_bq_model.WarpedBayesianQuadratureModel.__init__", "ValueError", "ValueError", "isinstance", "ValueError", "warpings.SquareRootWarping", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "base_gp", ":", "IBaseGaussianProcess", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "lower_bound", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "upper_bound", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "lower_bound", "is", "None", "and", "upper_bound", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either a lower or an upper bound needs to be given. Currently neither is given.\"", ")", "\n", "", "if", "lower_bound", "is", "not", "None", "and", "upper_bound", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either a lower or an upper bound needs to be given. Currently both are given.\"", ")", "\n", "\n", "", "bound", "=", "lower_bound", "\n", "is_lower_bounded", "=", "True", "\n", "\n", "if", "lower_bound", "is", "None", ":", "\n", "            ", "bound", "=", "upper_bound", "\n", "is_lower_bounded", "=", "False", "\n", "\n", "# The integrate method is specific to QuadratureRBFGaussianMeasure, predict methods are only specific to", "\n", "# the approximation method used (Taylor expansion of the GP in this case).", "\n", "", "if", "not", "isinstance", "(", "base_gp", ".", "kern", ",", "QuadratureRBFGaussianMeasure", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"{self.__class__.__name__} can only be used with QuadratureRBFGaussianMeasure kernel. \"", "\n", "f\"Instead {type(base_gp.kern)} is given.\"", "\n", ")", "\n", "\n", "", "super", "(", "BoundedBayesianQuadrature", ",", "self", ")", ".", "__init__", "(", "\n", "base_gp", "=", "base_gp", ",", "warping", "=", "SquareRootWarping", "(", "offset", "=", "bound", ",", "is_inverted", "=", "not", "is_lower_bounded", ")", ",", "X", "=", "X", ",", "Y", "=", "Y", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.bounded_bq_model.BoundedBayesianQuadrature.bound": [[76, 80], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bound", "(", "self", ")", ":", "\n", "        ", "\"\"\"The bound :math:`f^*` or :math:`f_*` as defined in the model.\"\"\"", "\n", "return", "self", ".", "_warping", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.bounded_bq_model.BoundedBayesianQuadrature.is_lower_bounded": [[81, 85], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_lower_bounded", "(", "self", ")", ":", "\n", "        ", "\"\"\"``True`` if the model is lower bounded, ``False`` if it is upper bounded.\"\"\"", "\n", "return", "not", "self", ".", "_warping", ".", "is_inverted", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.bounded_bq_model.BoundedBayesianQuadrature.predict_base": [[86, 92], ["bounded_bq_model.BoundedBayesianQuadrature.base_gp.predict", "bounded_bq_model.BoundedBayesianQuadrature.transform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform"], ["", "def", "predict_base", "(", "self", ",", "X_pred", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "mean_base", ",", "var_base", "=", "self", ".", "base_gp", ".", "predict", "(", "X_pred", ")", "\n", "\n", "mean_approx", "=", "self", ".", "transform", "(", "mean_base", ")", "\n", "var_approx", "=", "var_base", "*", "(", "mean_base", "**", "2", ")", "\n", "return", "mean_approx", ",", "var_approx", ",", "mean_base", ",", "var_base", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.bounded_bq_model.BoundedBayesianQuadrature.predict_base_with_full_covariance": [[93, 102], ["bounded_bq_model.BoundedBayesianQuadrature.base_gp.predict_with_full_covariance", "bounded_bq_model.BoundedBayesianQuadrature.transform", "bounded_bq_model.BoundedBayesianQuadrature.symmetrize_matrix", "numpy.outer"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.predict_with_full_covariance", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.symmetrize_matrix"], ["", "def", "predict_base_with_full_covariance", "(", "\n", "self", ",", "X_pred", ":", "np", ".", "ndarray", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "mean_base", ",", "cov_base", "=", "self", ".", "base_gp", ".", "predict_with_full_covariance", "(", "X_pred", ")", "\n", "\n", "mean_approx", "=", "self", ".", "transform", "(", "mean_base", ")", "\n", "cov_approx", "=", "np", ".", "outer", "(", "mean_base", ",", "mean_base", ")", "*", "cov_base", "\n", "cov_approx", "=", "self", ".", "symmetrize_matrix", "(", "cov_approx", ")", "# force symmetry for numerical stability", "\n", "return", "mean_approx", ",", "cov_approx", ",", "mean_base", ",", "cov_base", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.bounded_bq_model.BoundedBayesianQuadrature.integrate": [[103, 128], ["bounded_bq_model.BoundedBayesianQuadrature.base_gp.kern.K", "bounded_bq_model.BoundedBayesianQuadrature.base_gp.graminv_residual", "numpy.outer", "bounded_bq_model.BoundedBayesianQuadrature.base_gp.kern.qK().reshape", "numpy.sqrt", "numpy.sum", "float", "bounded_bq_model.BoundedBayesianQuadrature.base_gp.kern.qK", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.graminv_residual", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK"], ["", "def", "integrate", "(", "self", ")", "->", "Tuple", "[", "float", ",", "float", "]", ":", "\n", "        ", "n_points", ",", "input_dim", "=", "self", ".", "X", ".", "shape", "\n", "\n", "# weights and kernel", "\n", "X", "=", "self", ".", "X", "/", "np", ".", "sqrt", "(", "2", ")", "# this is equivalent to scaling the lengthscale with sqrt(2)", "\n", "K", "=", "self", ".", "base_gp", ".", "kern", ".", "K", "(", "X", ",", "X", ")", "\n", "weights", "=", "self", ".", "base_gp", ".", "graminv_residual", "(", ")", "\n", "Weights_outer", "=", "np", ".", "outer", "(", "weights", ",", "weights", ")", "\n", "\n", "# kernel mean but with scaled lengthscale (multiplicative factor of 1/sqrt(2))", "\n", "X_means_vec", "=", "0.5", "*", "(", "self", ".", "X", ".", "T", "[", ":", ",", ":", ",", "None", "]", "+", "self", ".", "X", ".", "T", "[", ":", ",", "None", ",", ":", "]", ")", ".", "reshape", "(", "input_dim", ",", "-", "1", ")", ".", "T", "\n", "qK", "=", "self", ".", "base_gp", ".", "kern", ".", "qK", "(", "X_means_vec", ",", "scale_factor", "=", "1.0", "/", "np", ".", "sqrt", "(", "2", ")", ")", ".", "reshape", "(", "n_points", ",", "n_points", ")", "\n", "\n", "# integral mean", "\n", "integral_mean_second_term", "=", "0.5", "*", "np", ".", "sum", "(", "Weights_outer", "*", "qK", "*", "K", ")", "\n", "if", "self", ".", "is_lower_bounded", ":", "\n", "            ", "integral_mean", "=", "self", ".", "bound", "+", "integral_mean_second_term", "\n", "", "else", ":", "\n", "            ", "integral_mean", "=", "self", ".", "bound", "-", "integral_mean_second_term", "\n", "\n", "# integral variance", "\n", "# The integral variance is not needed for the WSABI loop as WSABI uses uncertainty sampling.", "\n", "# For completeness, the integral variance will need to be implemented at a later point.", "\n", "", "integral_variance", "=", "None", "\n", "return", "float", "(", "integral_mean", ")", ",", "integral_variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.bounded_bq_model.BoundedBayesianQuadrature.get_prediction_gradients": [[129, 146], ["bounded_bq_model.BoundedBayesianQuadrature.base_gp.predict", "bounded_bq_model.BoundedBayesianQuadrature.base_gp.get_prediction_gradients", "bounded_bq_model.BoundedBayesianQuadrature.base_gp.kern.dK_dx1", "bounded_bq_model.BoundedBayesianQuadrature.base_gp.graminv_residual"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dK_dx1", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.graminv_residual"], ["", "def", "get_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "# predictions and gradients of base model", "\n", "        ", "mean_base", ",", "var_base", "=", "self", ".", "base_gp", ".", "predict", "(", "X", ")", "\n", "d_mean_dx_base", ",", "d_var_dx_base", "=", "self", ".", "base_gp", ".", "get_prediction_gradients", "(", "X", ")", "\n", "\n", "# gradient of mean", "\n", "d_mean_dx", "=", "(", "self", ".", "base_gp", ".", "kern", ".", "dK_dx1", "(", "X", ",", "self", ".", "X", ")", "@", "self", ".", "base_gp", ".", "graminv_residual", "(", ")", ")", "[", ":", ",", ":", ",", "0", "]", ".", "T", "\n", "d_mean_dx", "=", "mean_base", "*", "d_mean_dx", "# broadcasting  (n_points, 1) and (n_points, input_dim)", "\n", "\n", "# gradient of variance", "\n", "d_var_dx", "=", "(", "mean_base", "**", "2", ")", "*", "d_var_dx_base", "+", "(", "2", "*", "var_base", "*", "mean_base", ")", "*", "d_mean_dx_base", "# broadcasting", "\n", "\n", "# the gradient of the mean of the lower bounded model is the negative gradient of the upper bounded model.", "\n", "if", "not", "self", ".", "is_lower_bounded", ":", "\n", "            ", "d_mean_dx", "*=", "-", "1.0", "\n", "\n", "", "return", "d_mean_dx", ",", "d_var_dx", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.methods.wsabi.WSABIL.__init__": [[46, 52], ["wsabi.WSABIL._compute_alpha", "BoundedBayesianQuadrature.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.methods.wsabi.WSABIL._compute_alpha", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "base_gp", ":", "IBaseGaussianProcess", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ",", "adapt_alpha", ":", "bool", "=", "True", ")", ":", "\n", "        ", "self", ".", "adapt_alpha", "=", "adapt_alpha", "\n", "self", ".", "_small_alpha", "=", "1e-8", "# only used if alpha is not adapted", "\n", "alpha", "=", "self", ".", "_compute_alpha", "(", "X", ",", "Y", ")", "\n", "\n", "super", "(", "WSABIL", ",", "self", ")", ".", "__init__", "(", "base_gp", "=", "base_gp", ",", "X", "=", "X", ",", "Y", "=", "Y", ",", "lower_bound", "=", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.wsabi.WSABIL._compute_alpha": [[53, 63], ["min"], "methods", ["None"], ["", "def", "_compute_alpha", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "        ", "\"\"\"Compute the offset :math:`\\alpha`.\n\n        :param X: Observation locations, shape (n_points, input_dim)\n        :param Y: Values of observations, shape (n_points, 1)\n        :return: The offset :math:`\\alpha`.\n        \"\"\"", "\n", "if", "self", ".", "adapt_alpha", ":", "\n", "            ", "return", "0.8", "*", "min", "(", "Y", ")", "[", "0", "]", "\n", "", "return", "self", ".", "_small_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.wsabi.WSABIL.compute_warping_params": [[64, 73], ["wsabi.WSABIL._compute_alpha"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.methods.wsabi.WSABIL._compute_alpha"], ["", "def", "compute_warping_params", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "dict", ":", "\n", "        ", "r\"\"\"Computes the new :math:`\\alpha` parameter from data.\n\n        :param X: Observation locations, shape (n_points, input_dim).\n        :param Y: Integrand observations at X, shape (n_points, 1).\n        :return: Dictionary containing new value of :math:`\\alpha`.\n        \"\"\"", "\n", "new_offset", "=", "self", ".", "_compute_alpha", "(", "X", ",", "Y", ")", "\n", "return", "{", "\"offset\"", ":", "new_offset", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.__init__": [[31, 42], ["warped_bq_model.WarpedBayesianQuadratureModel.set_data"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["def", "__init__", "(", "self", ",", "base_gp", ":", "IBaseGaussianProcess", ",", "warping", ":", "Warping", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "\"\"\"\n        :param base_gp: The underlying Gaussian process model.\n        :param warping: The warping of the underlying Gaussian process model.\n        :param X: The initial locations of integrand evaluations, shape (n_points, input_dim).\n        :param Y: The values of the integrand at X, shape (n_points, 1).\n        \"\"\"", "\n", "self", ".", "_warping", "=", "warping", "\n", "self", ".", "base_gp", "=", "base_gp", "\n", "# set data to ensure that the base_gp get the correctly transformed observations.", "\n", "self", ".", "set_data", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.X": [[43, 47], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The data nodes.\"\"\"", "\n", "return", "self", ".", "base_gp", ".", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.Y": [[48, 52], ["warped_bq_model.WarpedBayesianQuadratureModel._warping.transform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The data evaluations at the nodes.\"\"\"", "\n", "return", "self", ".", "_warping", ".", "transform", "(", "self", ".", "base_gp", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.integral_bounds": [[53, 57], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "integral_bounds", "(", "self", ")", "->", "Union", "[", "None", ",", "BoxDomain", "]", ":", "\n", "        ", "\"\"\"The integration bounds. ``None`` if integration domain is not bounded.\"\"\"", "\n", "return", "self", ".", "base_gp", ".", "kern", ".", "integral_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.reasonable_box_bounds": [[58, 71], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "reasonable_box_bounds", "(", "self", ")", "->", "BoxDomain", ":", "\n", "        ", "\"\"\"Reasonable box bounds.\n\n        This box is used by the acquisition optimizer even when ``integral_bounds`` is ``None``.\n        By default it is set to :meth:`get_box()` of the integration measure used, or, if not available,\n        to the ``integral_bounds``.\n\n        .. seealso::\n            :class:`emukit.quadrature.measures.IntegrationMeasure.get_box`\n\n        \"\"\"", "\n", "return", "self", ".", "base_gp", ".", "kern", ".", "reasonable_box", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.measure": [[72, 76], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "measure", "(", "self", ")", "->", "Union", "[", "None", ",", "IntegrationMeasure", "]", ":", "\n", "        ", "\"\"\"The measure used for integration. ``None`` for standard Lebesgue measure.\"\"\"", "\n", "return", "self", ".", "base_gp", ".", "kern", ".", "measure", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.transform": [[77, 80], ["warped_bq_model.WarpedBayesianQuadratureModel._warping.transform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform"], ["", "def", "transform", "(", "self", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The transform from base-GP to integrand implicitly defined by the warping used.\"\"\"", "\n", "return", "self", ".", "_warping", ".", "transform", "(", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.inverse_transform": [[81, 84], ["warped_bq_model.WarpedBayesianQuadratureModel._warping.inverse_transform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform"], ["", "def", "inverse_transform", "(", "self", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The transform from integrand to base-GP implicitly defined by the warping used.\"\"\"", "\n", "return", "self", ".", "_warping", ".", "inverse_transform", "(", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.predict_base": [[85, 93], ["None"], "methods", ["None"], ["", "def", "predict_base", "(", "self", ",", "X_pred", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Compute predictive means and variances of the warped GP as well as the base GP.\n\n        :param X_pred: Locations at which to predict, shape (n_points, input_dim).\n        :returns: Predictive mean and variances of warped GP, and predictive mean and variances of base-GP in that order\n                  all shapes (n_points, 1).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.predict_base_with_full_covariance": [[94, 104], ["None"], "methods", ["None"], ["", "def", "predict_base_with_full_covariance", "(", "\n", "self", ",", "X_pred", ":", "np", ".", "ndarray", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Compute predictive means and covariance of the warped GP as well as the base GP.\n\n        :param X_pred: Locations at which to predict, shape (n_points, input_dim)\n        :returns: Predictive mean and covariance of warped GP, predictive mean and covariance of base-GP in that order.\n                  mean shapes both (n_points, 1) and covariance shapes both (n_points, n_points)\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.predict_with_full_covariance": [[105, 112], ["warped_bq_model.WarpedBayesianQuadratureModel.predict_base_with_full_covariance"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.predict_base_with_full_covariance"], ["", "def", "predict_with_full_covariance", "(", "self", ",", "X_pred", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Compute predictive means and covariance of warped GP.\n\n        :param X_pred: Locations at which to predict, shape (n_points, input_dim)\n        :return: predictive mean, predictive full covariance of warped-GP, shapes (n_points, 1) and (n_points, n_points)\n        \"\"\"", "\n", "return", "self", ".", "predict_base_with_full_covariance", "(", "X_pred", ")", "[", ":", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.predict": [[113, 120], ["warped_bq_model.WarpedBayesianQuadratureModel.predict_base"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.predict_base"], ["", "def", "predict", "(", "self", ",", "X_pred", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Compute predictive means and variances of warped-GP.\n\n        :param X_pred: Locations at which to predict, shape (n_points, input_dim)\n        :return: predictive mean, predictive variances of warped-GP, both shapes (n_points, 1)\n        \"\"\"", "\n", "return", "self", ".", "predict_base", "(", "X_pred", ")", "[", ":", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.set_data": [[121, 133], ["warped_bq_model.WarpedBayesianQuadratureModel._warping.update_parameters", "warped_bq_model.WarpedBayesianQuadratureModel.base_gp.set_data", "warped_bq_model.WarpedBayesianQuadratureModel._warping.inverse_transform", "warped_bq_model.WarpedBayesianQuadratureModel.compute_warping_params"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data", "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform", "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.compute_warping_params"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"Set the new data in the model.\n\n        First, potential warping parameters that are not being optimized but do depend on the data\n        in an analytic way are updated. This is done via the method :meth:`compute_warping_params`.\n        Then, the new data is automatically transformed and set in the model.\n\n        :param X: Observation locations, shape (n_points, input_dim).\n        :param Y: Integrand observations at X, shape (n_points, 1).\n        \"\"\"", "\n", "self", ".", "_warping", ".", "update_parameters", "(", "**", "self", ".", "compute_warping_params", "(", "X", ",", "Y", ")", ")", "\n", "self", ".", "base_gp", ".", "set_data", "(", "X", ",", "self", ".", "_warping", ".", "inverse_transform", "(", "Y", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.compute_warping_params": [[134, 149], ["None"], "methods", ["None"], ["", "def", "compute_warping_params", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Compute new parameters of the warping that are dependent on data, and that are not being optimized.\n\n        This method is called by default when new data is being set in :meth:`set_data`.\n        By default, this method returns an empty dict (no warping params need to be updated).\n        Override this method in case warping parameters are data dependent.\n\n        .. seealso::\n            :class:`emukit.quadrature.methods.warpings.Warping.update_parameters`\n\n        :param X: Observation locations, shape (n_points, input_dim).\n        :param Y: Integrand observations at X, shape (n_points, 1).\n        :return: Dictionary containing new warping parameters. Names of parameters are the keys.\n        \"\"\"", "\n", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.optimize": [[150, 153], ["warped_bq_model.WarpedBayesianQuadratureModel.base_gp.optimize"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Optimizes the hyperparameters of the base GP.\"\"\"", "\n", "self", ".", "base_gp", ".", "optimize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.integrate": [[154, 160], ["None"], "methods", ["None"], ["", "def", "integrate", "(", "self", ")", "->", "Tuple", "[", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"Compute an estimator of the integral as well as its variance.\n\n        :returns: Estimator of integral and its variance.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warped_bq_model.WarpedBayesianQuadratureModel.symmetrize_matrix": [[161, 171], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "symmetrize_matrix", "(", "A", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"Symmetrize a matrix.\n\n        The symmetrized matrix is computed as :math:`A_{sym} = \\frac{1}{2} (A + A^{\\intercal})`.\n\n        :param A: The square matrix :math:`A`, shape (N, N)\n        :return: The symmetrized matrix :math:`A_{sym}`, shape (N, N).\n        \"\"\"", "\n", "return", "0.5", "*", "(", "A", "+", "A", ".", "T", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.Warping.transform": [[19, 27], ["None"], "methods", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "transform", "(", "self", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Transform from base-GP to integrand.\n\n        :param Y: Function values of latent function, shape (n_points, 1).\n        :return: Transformed values, shape (n_points, 1).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.Warping.inverse_transform": [[28, 36], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "inverse_transform", "(", "self", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Transform from integrand to base-GP.\n\n        :param Y: Function values of integrand, shape (n_points, 1).\n        :return: Transformed values, shape (n_points, 1).\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.Warping.update_parameters": [[37, 45], ["new_parameters.items", "setattr"], "methods", ["None"], ["", "def", "update_parameters", "(", "self", ",", "**", "new_parameters", ")", "->", "None", ":", "\n", "        ", "\"\"\"Update the warping parameters.\n\n        :param new_parameters: Contains the parameter names as keys with the new values.\n                               An empty dictionary will do nothing.\n        \"\"\"", "\n", "for", "parameter", ",", "new_value", "in", "new_parameters", ".", "items", "(", ")", ":", "\n", "            ", "setattr", "(", "self", ",", "parameter", ",", "new_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.IdentityWarping.transform": [[55, 57], ["None"], "methods", ["None"], ["def", "transform", "(", "self", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.IdentityWarping.inverse_transform": [[58, 60], ["None"], "methods", ["None"], ["", "def", "inverse_transform", "(", "self", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.__init__": [[78, 81], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "offset", ":", "float", ",", "is_inverted", ":", "Optional", "[", "bool", "]", "=", "False", ")", ":", "\n", "        ", "self", ".", "offset", "=", "offset", "\n", "self", ".", "is_inverted", "=", "is_inverted", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.transform": [[82, 87], ["None"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "is_inverted", ":", "\n", "            ", "return", "self", ".", "offset", "-", "0.5", "*", "(", "Y", "*", "Y", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "offset", "+", "0.5", "*", "(", "Y", "*", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.warpings.SquareRootWarping.inverse_transform": [[88, 93], ["numpy.sqrt", "numpy.sqrt"], "methods", ["None"], ["", "", "def", "inverse_transform", "(", "self", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "is_inverted", ":", "\n", "            ", "return", "np", ".", "sqrt", "(", "2.0", "*", "(", "self", ".", "offset", "-", "Y", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "sqrt", "(", "2.0", "*", "(", "Y", "-", "self", ".", "offset", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.__init__": [[26, 28], ["warped_bq_model.WarpedBayesianQuadratureModel.__init__", "warpings.IdentityWarping"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "base_gp", ":", "IBaseGaussianProcess", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "super", "(", "VanillaBayesianQuadrature", ",", "self", ")", ".", "__init__", "(", "base_gp", "=", "base_gp", ",", "warping", "=", "IdentityWarping", "(", ")", ",", "X", "=", "X", ",", "Y", "=", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.predict_base": [[29, 32], ["vanilla_bq.VanillaBayesianQuadrature.base_gp.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_base", "(", "self", ",", "X_pred", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "m", ",", "cov", "=", "self", ".", "base_gp", ".", "predict", "(", "X_pred", ")", "\n", "return", "m", ",", "cov", ",", "m", ",", "cov", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.predict_base_with_full_covariance": [[33, 38], ["vanilla_bq.VanillaBayesianQuadrature.base_gp.predict_with_full_covariance"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.predict_with_full_covariance"], ["", "def", "predict_base_with_full_covariance", "(", "\n", "self", ",", "X_pred", ":", "np", ".", "ndarray", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "m", ",", "cov", "=", "self", ".", "base_gp", ".", "predict_with_full_covariance", "(", "X_pred", ")", "\n", "return", "m", ",", "cov", ",", "m", ",", "cov", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.integrate": [[39, 44], ["vanilla_bq.VanillaBayesianQuadrature.base_gp.kern.qK", "numpy.dot", "vanilla_bq.VanillaBayesianQuadrature.base_gp.kern.qKq", "vanilla_bq.VanillaBayesianQuadrature.base_gp.graminv_residual", "vanilla_bq.VanillaBayesianQuadrature.base_gp.solve_linear"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qK", "home.repos.pwc.inspect_result.amzn_emukit.kernels.quadrature_rbf.QuadratureRBFGaussianMeasure.qKq", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.graminv_residual", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.solve_linear"], ["", "def", "integrate", "(", "self", ")", "->", "Tuple", "[", "float", ",", "float", "]", ":", "\n", "        ", "kernel_mean_X", "=", "self", ".", "base_gp", ".", "kern", ".", "qK", "(", "self", ".", "X", ")", "\n", "integral_mean", "=", "np", ".", "dot", "(", "kernel_mean_X", ",", "self", ".", "base_gp", ".", "graminv_residual", "(", ")", ")", "[", "0", ",", "0", "]", "\n", "integral_var", "=", "self", ".", "base_gp", ".", "kern", ".", "qKq", "(", ")", "-", "(", "kernel_mean_X", "@", "self", ".", "base_gp", ".", "solve_linear", "(", "kernel_mean_X", ".", "T", ")", ")", "[", "0", ",", "0", "]", "\n", "return", "integral_mean", ",", "integral_var", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.methods.vanilla_bq.VanillaBayesianQuadrature.get_prediction_gradients": [[45, 47], ["vanilla_bq.VanillaBayesianQuadrature.base_gp.get_prediction_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "get_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "return", "self", ".", "base_gp", ".", "get_prediction_gradients", "(", "X", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.examples.test_simple_gp_model.x": [[7, 10], ["numpy.linspace"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "x", "(", ")", ":", "\n", "    ", "return", "np", ".", "linspace", "(", "-", "3", ",", "3", ",", "20", ")", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.examples.test_simple_gp_model.simple_gp": [[12, 16], ["emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel", "test_simple_gp_model.x", "test_simple_gp_model.x", "test_simple_gp_model.x"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.examples.test_simple_gp_model.x", "home.repos.pwc.inspect_result.amzn_emukit.examples.test_simple_gp_model.x", "home.repos.pwc.inspect_result.amzn_emukit.examples.test_simple_gp_model.x"], ["", "@", "pytest", ".", "fixture", "\n", "def", "simple_gp", "(", "x", ",", "y", ")", ":", "\n", "    ", "gp", "=", "SimpleGaussianProcessModel", "(", "x", ",", "y", ")", "\n", "return", "gp", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.examples.test_simple_gp_model.y": [[18, 21], ["None"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "y", "(", "x", ")", ":", "\n", "    ", "return", "x", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.examples.test_simple_gp_model.test_simple_gp_model_predict": [[23, 31], ["simple_gp.optimize", "simple_gp.predict", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_simple_gp_model_predict", "(", "simple_gp", ",", "x", ",", "y", ")", ":", "\n", "    ", "simple_gp", ".", "optimize", "(", ")", "\n", "mean", ",", "var", "=", "simple_gp", ".", "predict", "(", "x", ")", "\n", "\n", "assert", "mean", ".", "shape", "==", "x", ".", "shape", "\n", "assert", "var", ".", "shape", "==", "x", ".", "shape", "\n", "# predicting at training locations should give mean results close to training targets", "\n", "assert", "np", ".", "allclose", "(", "mean", ",", "y", ",", "atol", "=", "1e-3", ",", "rtol", "=", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.examples.test_simple_gp_model.test_set_new_data": [[33, 43], ["simple_gp.optimize", "simple_gp.predict", "simple_gp.set_data", "simple_gp.predict", "numpy.allclose", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_set_new_data", "(", "simple_gp", ",", "x", ",", "y", ")", ":", "\n", "    ", "simple_gp", ".", "optimize", "(", ")", "\n", "mean", ",", "var", "=", "simple_gp", ".", "predict", "(", "x", ")", "\n", "\n", "simple_gp", ".", "set_data", "(", "simple_gp", ".", "X", ",", "2", "*", "simple_gp", ".", "Y", ")", "\n", "\n", "mean_2", ",", "var_2", "=", "simple_gp", ".", "predict", "(", "x", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "2", "*", "mean", ",", "mean_2", ")", "\n", "assert", "np", ".", "allclose", "(", "var", ",", "var_2", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.dynamic_negative_lower_confidence_bound.dnlcb.DynamicNegativeLowerConfidenceBound.__init__": [[10, 27], ["emukit.bayesian_optimization.acquisitions.NegativeLowerConfidenceBound.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "Union", "[", "IModel", ",", "IDifferentiable", "]", ",", "input_space_size", ":", "int", ",", "delta", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Dynamic extension of the LCB acquisition. The beta coefficient is updated at each iteration, based on the explorativeness parameter delta which is inversely\n        proportional to beta itself - the higher the delta the less explorative the selection will be.\n        Please consider that regret bounds based on the dynamic exploration coefficient only hold for selected kernel classes exhibiting boundedness and smoothness.\n        See the base class for paper references.\n        This class may also be taken as a reference for acquisition functions that dynamically update their parameters thanks to the update_parameters() hook; the implicit assumption is that this method is invoked once per iteration (it is no big deal if this is the case for a constant number of times per iteration; should it be more then we are increasing the beta too fast).\n        :param model: The underlying model that provides the predictive mean and variance for the given test points\n        :param input_space_size: the size of the finite D grid on which the function is evaluated\n        :param delta: the exploration parameter determining the beta exploration coefficient; delta must be in (0, 1) and it is inversely related to beta\n        \"\"\"", "\n", "assert", "input_space_size", ">", "0", ",", "\"Invalid dimension provided\"", "\n", "assert", "0", "<", "delta", "<", "1", ",", "\"Delta must be in (0, 1)\"", "\n", "super", "(", ")", ".", "__init__", "(", "model", ")", "\n", "self", ".", "input_space_size", "=", "input_space_size", "\n", "self", ".", "delta", "=", "delta", "\n", "self", ".", "iteration", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.dynamic_negative_lower_confidence_bound.dnlcb.DynamicNegativeLowerConfidenceBound.optimal_beta_selection": [[28, 30], ["numpy.log"], "methods", ["None"], ["", "def", "optimal_beta_selection", "(", "self", ")", "->", "float", ":", "\n", "        ", "return", "2", "*", "np", ".", "log", "(", "self", ".", "input_space_size", "*", "(", "self", ".", "iteration", "**", "2", ")", "*", "(", "np", ".", "pi", "**", "2", ")", "/", "(", "6", "*", "self", ".", "delta", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.dynamic_negative_lower_confidence_bound.dnlcb.DynamicNegativeLowerConfidenceBound.update_parameters": [[31, 34], ["dnlcb.DynamicNegativeLowerConfidenceBound.optimal_beta_selection"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.dynamic_negative_lower_confidence_bound.dnlcb.DynamicNegativeLowerConfidenceBound.optimal_beta_selection"], ["", "def", "update_parameters", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "iteration", "+=", "1", "\n", "self", ".", "beta", "=", "self", ".", "optimal_beta_selection", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization.__init__": [[28, 82], ["int", "core.parameter_space.ParameterSpace", "single_objective_bayesian_optimization.GPBayesianOptimization._model_chooser", "single_objective_bayesian_optimization.GPBayesianOptimization._acquisition_chooser", "bayesian_optimization.loops.BayesianOptimizationLoop.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._model_chooser", "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._acquisition_chooser", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "variables_list", ":", "list", ",", "\n", "X", ":", "np", ".", "array", ",", "\n", "Y", ":", "np", ".", "array", ",", "\n", "noiseless", ":", "bool", "=", "False", ",", "\n", "acquisition_type", ":", "AcquisitionType", "=", "AcquisitionType", ".", "EI", ",", "\n", "normalize_Y", ":", "bool", "=", "True", ",", "\n", "acquisition_optimizer_type", ":", "OptimizerType", "=", "OptimizerType", ".", "LBFGS", ",", "\n", "model_update_interval", ":", "int", "=", "int", "(", "1", ")", ",", "\n", "batch_size", ":", "int", "=", "1", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "\"\"\"\n        Generic class to run Bayesian optimization with GPyRegression model.\n\n        Dependencies:\n            GPy (https://github.com/SheffieldML/GPy)\n\n        :param variables_list: list containing the definition of the variables of the input space.\n        :param noiseless:  determines whether the objective function is noisy or not\n        :param X: initial input values where the objective has been evaluated.\n        :param Y: initial output values where the objective has been evaluated.\n        :param acquisition_type: type of acquisition to use during optimization.\n            - EI: Expected improvement\n            - PI: Probability of improvement\n            - NLCB: Negative lower confidence bound\n        :param normalize_Y: whether the outputs of Y are normalized in the model.\n        :param acquisition_optimizer_type: selects the type of optimizer of the acquisition.\n            - LBFGS: uses L-BFGS with multiple initializations.\n        :param model_update_interval: interval of interactions in which the model is updated.\n        :param batch_size: How many points to evaluate in one iteration of the optimization loop. Defaults to 1.\n        \"\"\"", "\n", "\n", "self", ".", "variables_list", "=", "variables_list", "\n", "self", ".", "noiseless", "=", "noiseless", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "Y", "=", "Y", "\n", "self", ".", "acquisition_type", "=", "acquisition_type", "\n", "self", ".", "normalize_Y", "=", "normalize_Y", "\n", "self", ".", "acquisition_optimizer_type", "=", "acquisition_optimizer_type", "\n", "self", ".", "model_update_interval", "=", "model_update_interval", "\n", "\n", "# 1. Crete the internal object to handle the input space", "\n", "self", ".", "space", "=", "ParameterSpace", "(", "variables_list", ")", "\n", "\n", "# 2. Select the model to use in the optimization", "\n", "self", ".", "_model_chooser", "(", ")", "\n", "\n", "# 3. Select the acquisition function", "\n", "self", ".", "_acquisition_chooser", "(", ")", "\n", "\n", "super", "(", "GPBayesianOptimization", ",", "self", ")", ".", "__init__", "(", "\n", "model", "=", "self", ".", "model", ",", "space", "=", "self", ".", "space", ",", "acquisition", "=", "self", ".", "acquisition", ",", "batch_size", "=", "batch_size", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization._model_chooser": [[84, 93], ["GPy.kern.Matern52", "GPy.models.GPRegression", "GPy.models.GPRegression.optimize", "model_wrappers.gpy_model_wrappers.GPyModelWrapper", "model_wrappers.gpy_model_wrappers.GPyModelWrapper", "len", "GPy.models.GPRegression.Gaussian_noise.constrain_fixed"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "_model_chooser", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the model used for the optimization\"\"\"", "\n", "kernel", "=", "Matern52", "(", "len", "(", "self", ".", "variables_list", ")", ",", "variance", "=", "1.0", ",", "ARD", "=", "False", ")", "\n", "gpmodel", "=", "GPRegression", "(", "self", ".", "X", ",", "self", ".", "Y", ",", "kernel", ")", "\n", "gpmodel", ".", "optimize", "(", ")", "\n", "self", ".", "model", "=", "GPyModelWrapper", "(", "gpmodel", ")", "\n", "if", "self", ".", "noiseless", ":", "\n", "            ", "gpmodel", ".", "Gaussian_noise", ".", "constrain_fixed", "(", "0.001", ")", "\n", "", "self", ".", "model", "=", "GPyModelWrapper", "(", "gpmodel", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization._acquisition_chooser": [[94, 102], ["bayesian_optimization.acquisitions.ExpectedImprovement", "bayesian_optimization.acquisitions.ProbabilityOfImprovement", "bayesian_optimization.acquisitions.NegativeLowerConfidenceBound"], "methods", ["None"], ["", "def", "_acquisition_chooser", "(", "self", ")", ":", "\n", "        ", "\"\"\"Select the acquisition function used in the optimization\"\"\"", "\n", "if", "self", ".", "acquisition_type", "is", "AcquisitionType", ".", "EI", ":", "\n", "            ", "self", ".", "acquisition", "=", "ExpectedImprovement", "(", "self", ".", "model", ")", "\n", "", "elif", "self", ".", "acquisition_type", "is", "AcquisitionType", ".", "PI", ":", "\n", "            ", "self", ".", "acquisition", "=", "ProbabilityOfImprovement", "(", "self", ".", "model", ")", "\n", "", "elif", "self", ".", "acquisition_type", "is", "AcquisitionType", ".", "NLCB", ":", "\n", "            ", "self", ".", "acquisition", "=", "NegativeLowerConfidenceBound", "(", "self", ".", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization.suggest_new_locations": [[103, 106], ["single_objective_bayesian_optimization.GPBayesianOptimization.candidate_point_calculator.compute_next_points"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "", "def", "suggest_new_locations", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns one or a batch of locations without evaluating the objective\"\"\"", "\n", "return", "self", ".", "candidate_point_calculator", ".", "compute_next_points", "(", "self", ".", "loop_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.single_objective_bayesian_optimization.GPBayesianOptimization.run_optimization": [[107, 113], ["single_objective_bayesian_optimization.GPBayesianOptimization.run_loop", "core.loop.FixedIterationsStoppingCondition"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "run_optimization", "(", "self", ",", "user_function", ":", "UserFunction", ",", "num_iterations", ":", "int", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param user_function: The function that we want to optimize\n        :param num_iterations: The number of iterations to run the Bayesian optimization loop.\n        \"\"\"", "\n", "self", ".", "run_loop", "(", "user_function", ",", "FixedIterationsStoppingCondition", "(", "num_iterations", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.optimization_loops.create_bayesian_optimization_loop": [[17, 74], ["core.loop.SequentialPointCalculator", "core.loop.FixedIntervalUpdater", "core.loop.OuterLoop", "dict", "models.random_forest.RandomForest", "bayesian_optimization.acquisitions.ExpectedImprovement", "core.optimization.GradientAcquisitionOptimizer", "core.loop.loop_state.create_loop_state", "core.loop.loop_state.create_loop_state", "models.bohamiann.Bohamiann", "ValueError", "bayesian_optimization.acquisitions.ProbabilityOfImprovement", "bayesian_optimization.acquisitions.NegativeLowerConfidenceBound", "ValueError", "str", "str"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state"], ["def", "create_bayesian_optimization_loop", "(", "\n", "x_init", ":", "np", ".", "ndarray", ",", "\n", "y_init", ":", "np", ".", "ndarray", ",", "\n", "parameter_space", ":", "ParameterSpace", ",", "\n", "acquisition_type", ":", "AcquisitionType", ",", "\n", "model_type", ":", "ModelType", ",", "\n", "cost_init", ":", "np", ".", "ndarray", "=", "None", ",", "\n", "model_kwargs", ":", "dict", "=", "None", ",", "\n", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", "=", "None", ",", "\n", ")", "->", "OuterLoop", ":", "\n", "    ", "\"\"\"\n    Creates Bayesian optimization loop for Bayesian neural network or random forest models.\n\n    :param x_init: 2d numpy array of shape (no. points x no. input features) of initial X data\n    :param y_init: 2d numpy array of shape (no. points x no. targets) of initial Y data\n    :param cost_init: 2d numpy array of shape (no. points x no. targets) of initial cost of each function evaluation\n    :param parameter_space: parameter space describing input domain\n    :param acquisition_type: an AcquisitionType enumeration object describing which acquisition function to use\n    :param model_type: A ModelType enumeration object describing which model to use.\n    :param model_kwargs: Key work arguments for the model constructor. See individual models for details.\n    :param acquisition_optimizer: Optimizer selecting next evaluation points by maximizing acquisition.\n                                  Gradient based optimizer is used if None. Defaults to None.\n    :return: OuterLoop instance\n    \"\"\"", "\n", "\n", "if", "model_kwargs", "is", "None", ":", "\n", "        ", "model_kwargs", "=", "dict", "(", ")", "\n", "\n", "# Create model", "\n", "", "if", "model_type", "is", "ModelType", ".", "RandomForest", ":", "\n", "        ", "model", "=", "RandomForest", "(", "x_init", ",", "y_init", ",", "**", "model_kwargs", ")", "\n", "", "elif", "model_type", "is", "ModelType", ".", "BayesianNeuralNetwork", ":", "\n", "        ", "model", "=", "Bohamiann", "(", "x_init", ",", "y_init", ",", "**", "model_kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unrecognised model type: \"", "+", "str", "(", "model_type", ")", ")", "\n", "\n", "# Create acquisition", "\n", "", "if", "acquisition_type", "is", "AcquisitionType", ".", "EI", ":", "\n", "        ", "acquisition", "=", "ExpectedImprovement", "(", "model", ")", "\n", "", "elif", "acquisition_type", "is", "AcquisitionType", ".", "PI", ":", "\n", "        ", "acquisition", "=", "ProbabilityOfImprovement", "(", "model", ")", "\n", "", "elif", "acquisition_type", "is", "AcquisitionType", ".", "NLCB", ":", "\n", "        ", "acquisition", "=", "NegativeLowerConfidenceBound", "(", "model", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unrecognised acquisition type: \"", "+", "str", "(", "acquisition_type", ")", ")", "\n", "\n", "", "if", "acquisition_optimizer", "is", "None", ":", "\n", "        ", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "parameter_space", ")", "\n", "", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ")", "\n", "\n", "if", "cost_init", "is", "None", ":", "\n", "        ", "loop_state", "=", "create_loop_state", "(", "x_init", ",", "y_init", ")", "\n", "", "else", ":", "\n", "        ", "loop_state", "=", "create_loop_state", "(", "x_init", ",", "y_init", ",", "cost", "=", "cost_init", ")", "\n", "\n", "", "model_updater", "=", "FixedIntervalUpdater", "(", "model", ",", "1", ")", "\n", "return", "OuterLoop", "(", "candidate_point_calculator", ",", "model_updater", ",", "loop_state", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization.__init__": [[27, 90], ["int", "core.parameter_space.ParameterSpace", "unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._model_chooser", "unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._model_chooser_constraint", "unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._acquisition_chooser", "bayesian_optimization.loops.UnknownConstraintBayesianOptimizationLoop.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._model_chooser", "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._model_chooser_constraint", "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._acquisition_chooser", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "variables_list", ":", "list", ",", "\n", "X", ":", "np", ".", "array", ",", "\n", "Y", ":", "np", ".", "array", ",", "\n", "Yc", ":", "np", ".", "array", ",", "\n", "noiseless", ":", "bool", "=", "False", ",", "\n", "acquisition_type", ":", "AcquisitionType", "=", "AcquisitionType", ".", "EI", ",", "\n", "normalize_Y", ":", "bool", "=", "True", ",", "\n", "acquisition_optimizer_type", ":", "OptimizerType", "=", "OptimizerType", ".", "LBFGS", ",", "\n", "batch_size", ":", "int", "=", "1", ",", "\n", "model_update_interval", ":", "int", "=", "int", "(", "1", ")", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "\"\"\"\n        Class to run Bayesian optimization with unknown contraints with GPyRegression model.\n\n        Dependencies:\n            GPy (https://github.com/SheffieldML/GPy)\n\n        :param variables_list: list containing the definition of the variables of the input space.\n        :param noiseless:  determines whether the objective function is noisy or not\n        :param X: initial input values where the objective has been evaluated.\n        :param Y: initial output values where the objective has been evaluated.\n        :param Yc: initial output values where the constraint has been evaluated.\n        :param acquisition_type: type of acquisition to use during optimization.\n            - EI: Expected improvement\n            - PI: Probability of improvement\n            - NLCB: Negative lower confidence bound\n        :param normalize_Y: whether the outputs of Y are normalized in the model.\n        :param acquisition_optimizer_type: selects the type of optimizer of the acquisition.\n            - LBFGS: uses L-BFGS with multiple initializations.\n        :param model_update_interval: interval of interactions in which the model is updated.\n        :batch_size: interval of interactions in which the model is updated.\n        \"\"\"", "\n", "\n", "self", ".", "variables_list", "=", "variables_list", "\n", "self", ".", "noiseless", "=", "noiseless", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "Y", "=", "Y", "\n", "self", ".", "Yc", "=", "Yc", "\n", "self", ".", "acquisition_type", "=", "acquisition_type", "\n", "self", ".", "normalize_Y", "=", "normalize_Y", "\n", "self", ".", "acquisition_optimizer_type", "=", "acquisition_optimizer_type", "\n", "self", ".", "model_update_interval", "=", "model_update_interval", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "# 1. Crete the internal object to handle the input space", "\n", "self", ".", "space", "=", "ParameterSpace", "(", "variables_list", ")", "\n", "\n", "# 2. Select the models to use in the optimization", "\n", "self", ".", "_model_chooser", "(", ")", "\n", "self", ".", "_model_chooser_constraint", "(", ")", "\n", "\n", "# 3. Select the acquisition function", "\n", "self", ".", "_acquisition_chooser", "(", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "model_objective", "=", "self", ".", "model_objective", ",", "\n", "model_constraint", "=", "self", ".", "model_constraint", ",", "\n", "space", "=", "self", ".", "space", ",", "\n", "acquisition", "=", "self", ".", "acquisition", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._model_chooser": [[92, 101], ["GPy.kern.Matern52", "GPy.models.GPRegression", "GPy.models.GPRegression.optimize", "model_wrappers.gpy_model_wrappers.GPyModelWrapper", "model_wrappers.gpy_model_wrappers.GPyModelWrapper", "len", "GPy.models.GPRegression.Gaussian_noise.constrain_fixed"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "_model_chooser", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the model used for the objective function\"\"\"", "\n", "kernel", "=", "Matern52", "(", "len", "(", "self", ".", "variables_list", ")", ",", "variance", "=", "1.0", ",", "ARD", "=", "False", ")", "\n", "gpmodel", "=", "GPRegression", "(", "self", ".", "X", ",", "self", ".", "Y", ",", "kernel", ")", "\n", "gpmodel", ".", "optimize", "(", ")", "\n", "self", ".", "model_objective", "=", "GPyModelWrapper", "(", "gpmodel", ")", "\n", "if", "self", ".", "noiseless", ":", "\n", "            ", "gpmodel", ".", "Gaussian_noise", ".", "constrain_fixed", "(", "0.001", ")", "\n", "", "self", ".", "model_objective", "=", "GPyModelWrapper", "(", "gpmodel", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._model_chooser_constraint": [[102, 111], ["GPy.kern.Matern52", "GPy.models.GPRegression", "GPy.models.GPRegression.optimize", "model_wrappers.gpy_model_wrappers.GPyModelWrapper", "model_wrappers.gpy_model_wrappers.GPyModelWrapper", "len", "GPy.models.GPRegression.Gaussian_noise.constrain_fixed"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "_model_chooser_constraint", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the model used for the constraint\"\"\"", "\n", "kernel", "=", "Matern52", "(", "len", "(", "self", ".", "variables_list", ")", ",", "variance", "=", "1.0", ",", "ARD", "=", "False", ")", "\n", "gpmodel", "=", "GPRegression", "(", "self", ".", "X", ",", "self", ".", "Yc", ",", "kernel", ")", "\n", "gpmodel", ".", "optimize", "(", ")", "\n", "self", ".", "model_constraint", "=", "GPyModelWrapper", "(", "gpmodel", ")", "\n", "if", "self", ".", "noiseless", ":", "\n", "            ", "gpmodel", ".", "Gaussian_noise", ".", "constrain_fixed", "(", "0.001", ")", "\n", "", "self", ".", "model_constraint", "=", "GPyModelWrapper", "(", "gpmodel", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization._acquisition_chooser": [[112, 120], ["bayesian_optimization.acquisitions.ExpectedImprovement", "bayesian_optimization.acquisitions.ProbabilityOfImprovement", "bayesian_optimization.acquisitions.NegativeLowerConfidenceBound"], "methods", ["None"], ["", "def", "_acquisition_chooser", "(", "self", ")", ":", "\n", "        ", "\"\"\"Select the acquisition function used in the optimization\"\"\"", "\n", "if", "self", ".", "acquisition_type", "is", "AcquisitionType", ".", "EI", ":", "\n", "            ", "self", ".", "acquisition", "=", "ExpectedImprovement", "(", "self", ".", "model_objective", ")", "\n", "", "elif", "self", ".", "acquisition_type", "is", "AcquisitionType", ".", "PI", ":", "\n", "            ", "self", ".", "acquisition", "=", "ProbabilityOfImprovement", "(", "self", ".", "model_objective", ")", "\n", "", "elif", "self", ".", "acquisition_type", "is", "AcquisitionType", ".", "NLCB", ":", "\n", "            ", "self", ".", "acquisition", "=", "NegativeLowerConfidenceBound", "(", "self", ".", "model_objective", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.gp_bayesian_optimization.unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization.suggest_new_locations": [[121, 124], ["unknown_constraint_bayesian_optimization.UnknownConstraintGPBayesianOptimization.candidate_point_calculator.compute_next_points"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "", "def", "suggest_new_locations", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns one or a batch of locations without evaluating the objective\"\"\"", "\n", "return", "self", ".", "candidate_point_calculator", ".", "compute_next_points", "(", "self", ".", "loop_state", ")", "[", "0", "]", ".", "X", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.base_models.SIR.__init__": [[11, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "N", ":", "int", ",", "alpha", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        :param N: the population size\n        :param alpha: the ratio of infection rate and recovery rate\n        \"\"\"", "\n", "self", ".", "N", "=", "N", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.base_models.SIR.set_alpha": [[19, 21], ["None"], "methods", ["None"], ["", "def", "set_alpha", "(", "self", ",", "alpha", ":", "float", ")", "->", "None", ":", "\n", "        ", "self", ".", "alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.base_models.SEIR.__init__": [[29, 37], ["base_models.SIR.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "N", ":", "int", ",", "alpha", ":", "float", ",", "beta", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        :param N: the population size\n        :param alpha: the ratio of infection rate and recovery rate\n        :param beta: the ratio of incubation rate and recovery rate\n        \"\"\"", "\n", "super", "(", "SEIR", ",", "self", ")", ".", "__init__", "(", "N", "=", "N", ",", "alpha", "=", "alpha", ")", "\n", "self", ".", "beta", "=", "beta", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.AlphaPrior.__init__": [[16, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.AlphaPrior.evaluate": [[19, 25], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "alpha", ":", "float", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        :param alpha: the ratio of infection rate and recovery rate\n        :return: the probability density at alpha\n        \"\"\"", "\n", "raise", "NotImplemented", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.GammaPrior.__init__": [[30, 41], ["scipy.stats.gamma", "gillespie_analysis.AlphaPrior.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "a", ":", "int", ",", "loc", ":", "float", ",", "scale", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        :param a: shape parameter\n        :param loc: shift the gamma distribution\n        :param scale: scale parameter for controlling the width\n        \"\"\"", "\n", "self", ".", "a", "=", "a", "\n", "self", ".", "loc", "=", "loc", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "gamma", "=", "gamma", "(", "a", ",", "loc", ",", "scale", ")", "\n", "super", "(", "GammaPrior", ",", "self", ")", ".", "__init__", "(", "name", "=", "\"gamma prior\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.GammaPrior.evaluate": [[42, 48], ["gillespie_analysis.GammaPrior.gamma.pdf"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "alpha", ":", "float", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        :param alpha: the ratio of infection rate and recovery rate\n        :return: the probability density at alpha\n        \"\"\"", "\n", "return", "self", ".", "gamma", ".", "pdf", "(", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.UniformPrior.__init__": [[53, 61], ["gillespie_analysis.AlphaPrior.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "alpha_min", ":", "float", ",", "alpha_max", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        :param alpha_min: left interval bound\n        :param alpha_max: right interval bound\n        \"\"\"", "\n", "self", ".", "alpha_min", "=", "alpha_min", "\n", "self", ".", "alpha_max", "=", "alpha_max", "\n", "super", "(", "UniformPrior", ",", "self", ")", ".", "__init__", "(", "name", "=", "\"uniform prior\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.UniformPrior.evaluate": [[62, 68], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "alpha", ":", "float", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        :param alpha: the ratio of infection rate and recovery rate\n        :return: the probability density at alpha\n        \"\"\"", "\n", "return", "1.0", "/", "(", "self", ".", "alpha_max", "-", "self", ".", "alpha_min", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.__init__": [[75, 86], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "gillespie_model", ":", "SIRGillespie", ",", "num_gil", ":", "int", ",", "time_end", ":", "float", ",", "alpha_prior", ":", "AlphaPrior", ")", ":", "\n", "        ", "\"\"\"\n        :param gillespie_model: a SIRGillespie model\n        :param alpha_prior: the prior over alpha\n        :param num_gil: number of Gillespie samples to average over\n        :param time_end: end time of simulation\n        \"\"\"", "\n", "self", ".", "gillespie", "=", "gillespie_model", "\n", "self", ".", "alpha_prior", "=", "alpha_prior", "\n", "self", ".", "num_gil", "=", "num_gil", "\n", "self", ".", "time_end", "=", "time_end", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_bare": [[87, 95], ["gillespie_analysis.MeanMaxInfectionGillespie.gillespie.model.set_alpha", "gillespie_analysis.MeanMaxInfectionGillespie.gillespie.run_simulation_height_and_time_of_peak"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.base_models.SIR.set_alpha", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase.run_simulation_height_and_time_of_peak"], ["", "def", "evaluate_bare", "(", "self", ",", "alpha", ":", "float", ")", "->", "Tuple", "[", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"\n        :param alpha: the ratio of infection rate and recovery rate\n        :return: Estimated (mean over num_gil simulations runs) time and height of the infection peak for given alpha.\n        \"\"\"", "\n", "self", ".", "gillespie", ".", "model", ".", "set_alpha", "(", "alpha", ")", "\n", "peak_time", ",", "peak_height", "=", "self", ".", "gillespie", ".", "run_simulation_height_and_time_of_peak", "(", "self", ".", "num_gil", ",", "self", ".", "time_end", ")", "\n", "return", "peak_time", ",", "peak_height", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate": [[96, 105], ["gillespie_analysis.MeanMaxInfectionGillespie.evaluate_bare", "gillespie_analysis.MeanMaxInfectionGillespie.alpha_prior.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_bare", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "alpha", ":", "float", ")", "->", "Tuple", "[", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"\n        :param alpha: the ratio of infection rate and recovery rate\n        :return: Estimated (mean over num_gil simulations runs) time and height of the infection peak for given alpha\n        scaled with the prior over alpha.\n        \"\"\"", "\n", "peak_time", ",", "peak_height", "=", "self", ".", "evaluate_bare", "(", "alpha", ")", "\n", "alpha_weight", "=", "self", ".", "alpha_prior", ".", "evaluate", "(", "alpha", ")", "\n", "return", "peak_time", "*", "alpha_weight", ",", "peak_height", "*", "alpha_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_time_bare": [[106, 108], ["gillespie_analysis.MeanMaxInfectionGillespie.evaluate_bare"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_bare"], ["", "def", "evaluate_time_bare", "(", "self", ",", "alpha", ":", "float", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "evaluate_bare", "(", "alpha", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_height_bare": [[109, 111], ["gillespie_analysis.MeanMaxInfectionGillespie.evaluate_bare"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_bare"], ["", "def", "evaluate_height_bare", "(", "self", ",", "alpha", ":", "float", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "evaluate_bare", "(", "alpha", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_time": [[112, 114], ["gillespie_analysis.MeanMaxInfectionGillespie.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate_time", "(", "self", ",", "alpha", ":", "float", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "evaluate", "(", "alpha", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_height": [[115, 117], ["gillespie_analysis.MeanMaxInfectionGillespie.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate_height", "(", "self", ",", "alpha", ":", "float", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "evaluate", "(", "alpha", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis._f_height_of_peak_weighted": [[121, 126], ["isinstance", "numpy.asarray", "numpy.asarray", "meanmax.evaluate_height", "meanmax.evaluate_height", "float"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_height", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_height"], ["", "", "def", "_f_height_of_peak_weighted", "(", "alpha", ",", "meanmax", ":", "MeanMaxInfectionGillespie", ")", ":", "\n", "    ", "if", "isinstance", "(", "alpha", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "meanmax", ".", "evaluate_height", "(", "float", "(", "alpha_i", ")", ")", "for", "alpha_i", "in", "alpha", "]", ")", "[", ":", ",", "None", "]", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "meanmax", ".", "evaluate_height", "(", "alpha", ")", "]", ")", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis._f_time_of_peak_weighted": [[128, 133], ["isinstance", "numpy.asarray", "numpy.asarray", "meanmax.evaluate_time", "meanmax.evaluate_time", "float"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_time", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_time"], ["", "", "def", "_f_time_of_peak_weighted", "(", "alpha", ",", "meanmax", ":", "MeanMaxInfectionGillespie", ")", ":", "\n", "    ", "if", "isinstance", "(", "alpha", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "meanmax", ".", "evaluate_time", "(", "float", "(", "alpha_i", ")", ")", "for", "alpha_i", "in", "alpha", "]", ")", "[", ":", ",", "None", "]", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "meanmax", ".", "evaluate_time", "(", "alpha", ")", "]", ")", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis._f_height_of_peak": [[135, 140], ["isinstance", "numpy.asarray", "numpy.asarray", "meanmax.evaluate_height_bare", "meanmax.evaluate_height_bare", "float"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_height_bare", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_height_bare"], ["", "", "def", "_f_height_of_peak", "(", "alpha", ",", "meanmax", ":", "MeanMaxInfectionGillespie", ")", ":", "\n", "    ", "if", "isinstance", "(", "alpha", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "meanmax", ".", "evaluate_height_bare", "(", "float", "(", "alpha_i", ")", ")", "for", "alpha_i", "in", "alpha", "]", ")", "[", ":", ",", "None", "]", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "meanmax", ".", "evaluate_height_bare", "(", "alpha", ")", "]", ")", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis._f_time_of_peak": [[142, 147], ["isinstance", "numpy.asarray", "numpy.asarray", "meanmax.evaluate_time_bare", "meanmax.evaluate_time_bare", "float"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_time_bare", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.MeanMaxInfectionGillespie.evaluate_time_bare"], ["", "", "def", "_f_time_of_peak", "(", "alpha", ",", "meanmax", ":", "MeanMaxInfectionGillespie", ")", ":", "\n", "    ", "if", "isinstance", "(", "alpha", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "meanmax", ".", "evaluate_time_bare", "(", "float", "(", "alpha_i", ")", ")", "for", "alpha_i", "in", "alpha", "]", ")", "[", ":", ",", "None", "]", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "meanmax", ".", "evaluate_time_bare", "(", "alpha", ")", "]", ")", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.height_of_peak_weighted": [[149, 151], ["gillespie_analysis._f_height_of_peak_weighted"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis._f_height_of_peak_weighted"], ["", "", "def", "height_of_peak_weighted", "(", "meanmax", ":", "MeanMaxInfectionGillespie", ")", ":", "\n", "    ", "return", "lambda", "alpha", ":", "_f_height_of_peak_weighted", "(", "alpha", ",", "meanmax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.time_of_peak_weighted": [[153, 155], ["gillespie_analysis._f_time_of_peak_weighted"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis._f_time_of_peak_weighted"], ["", "def", "time_of_peak_weighted", "(", "meanmax", ":", "MeanMaxInfectionGillespie", ")", ":", "\n", "    ", "return", "lambda", "alpha", ":", "_f_time_of_peak_weighted", "(", "alpha", ",", "meanmax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.height_of_peak": [[157, 159], ["gillespie_analysis._f_height_of_peak"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis._f_height_of_peak"], ["", "def", "height_of_peak", "(", "meanmax", ":", "MeanMaxInfectionGillespie", ")", ":", "\n", "    ", "return", "lambda", "alpha", ":", "_f_height_of_peak", "(", "alpha", ",", "meanmax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis.time_of_peak": [[161, 163], ["gillespie_analysis._f_time_of_peak"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_analysis._f_time_of_peak"], ["", "def", "time_of_peak", "(", "meanmax", ":", "MeanMaxInfectionGillespie", ")", ":", "\n", "    ", "return", "lambda", "alpha", ":", "_f_time_of_peak", "(", "alpha", ",", "meanmax", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.sir_gillespie.SIRGillespie.__init__": [[20, 25], ["gillespie_base.GillespieBase.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "model", ":", "SIR", ")", ":", "\n", "        ", "\"\"\"x\n        :param model: A SIR model\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.sir_gillespie.SIRGillespie._get_initial_state": [[26, 28], ["numpy.asarray"], "methods", ["None"], ["", "def", "_get_initial_state", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "self", ".", "model", ".", "N", "-", "1", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.sir_gillespie.SIRGillespie._get_state_index_infected": [[29, 31], ["int"], "methods", ["None"], ["", "def", "_get_state_index_infected", "(", "self", ")", ":", "\n", "        ", "return", "int", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.sir_gillespie.SIRGillespie._get_possible_state_updates": [[32, 35], ["numpy.array"], "methods", ["None"], ["", "def", "_get_possible_state_updates", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"possible updates of compartment counts\"\"\"", "\n", "return", "np", ".", "array", "(", "[", "[", "-", "1", ",", "1", "]", ",", "[", "0", ",", "-", "1", "]", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.sir_gillespie.SIRGillespie._get_current_rates": [[36, 44], ["numpy.asarray"], "methods", ["None"], ["", "def", "_get_current_rates", "(", "self", ",", "state", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns an array of the current rates of infection/recovery (1/2),\n        i.e. the un-normalized probabilities for these events to occur next\n        \"\"\"", "\n", "rate_1", "=", "self", ".", "model", ".", "alpha", "*", "state", "[", "0", "]", "*", "state", "[", "1", "]", "/", "self", ".", "model", ".", "N", "\n", "rate_2", "=", "state", "[", "1", "]", "\n", "return", "np", ".", "asarray", "(", "[", "rate_1", ",", "rate_2", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase.__init__": [[15, 21], ["gillespie_base.GillespieBase._get_initial_state"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_initial_state"], ["def", "__init__", "(", "self", ",", "model", ":", "SIR", ")", ":", "\n", "        ", "\"\"\"\n        :param model: A SEIR model\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "initial_state", "=", "self", ".", "_get_initial_state", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._get_initial_state": [[22, 25], ["None"], "methods", ["None"], ["", "def", "_get_initial_state", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"returns the initial state\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._get_state_index_infected": [[26, 29], ["None"], "methods", ["None"], ["", "def", "_get_state_index_infected", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"returns the index of the state that represents the infected\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._get_possible_state_updates": [[30, 33], ["None"], "methods", ["None"], ["", "def", "_get_possible_state_updates", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"returns  possible updates of compartment counts\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._get_current_rates": [[34, 40], ["None"], "methods", ["None"], ["", "def", "_get_current_rates", "(", "self", ",", "state", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns an array of the current rates of infection/recovery (1/2),\n        i.e. the un-normalized probabilities for these events to occur next\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._draw_next_event": [[41, 56], ["gillespie_base.GillespieBase._get_current_rates", "gillespie_base.GillespieBase.sum", "numpy.random.exponential", "numpy.random.choice", "numpy.asarray", "range", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_current_rates"], ["", "def", "_draw_next_event", "(", "self", ",", "state", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"Draws which event of infection or recovery happens next\"\"\"", "\n", "# Compute current rates and the sum thereof", "\n", "rates", "=", "self", ".", "_get_current_rates", "(", "state", ")", "\n", "sum_of_rates", "=", "rates", ".", "sum", "(", ")", "\n", "\n", "# draw timestep from exponential distribution", "\n", "dt", "=", "np", ".", "random", ".", "exponential", "(", "1.0", "/", "sum_of_rates", ")", "\n", "\n", "# draw occurring event according to current rates", "\n", "event", "=", "np", ".", "random", ".", "choice", "(", "\n", "np", ".", "asarray", "(", "[", "i", "for", "i", "in", "range", "(", "len", "(", "self", ".", "initial_state", ")", ")", "]", ",", "dtype", "=", "int", ")", ",", "p", "=", "rates", "/", "sum_of_rates", "\n", ")", "\n", "\n", "return", "event", ",", "dt", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._draw_gillespie": [[57, 94], ["numpy.asarray", "numpy.append", "gillespie_base.GillespieBase.initial_state.copy", "gillespie_base.GillespieBase._draw_next_event", "numpy.append", "numpy.append", "gillespie_base.GillespieBase._get_current_rates().sum", "numpy.append", "numpy.append", "numpy.append.sum", "gillespie_base.GillespieBase._get_current_rates", "gillespie_base.GillespieBase._get_possible_state_updates"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._draw_next_event", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_current_rates", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_possible_state_updates"], ["", "def", "_draw_gillespie", "(", "self", ",", "time_end", ":", "float", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Draw one realisation of the gillespie simulation. Note that time intervals are given by the random draws of\n        the state changes.\n\n        :param time_end: the maximum time\n        :return: tuple of (times, compartments) with shapes times (num_gil_times, ) and variable length and\n        compartments of shape (num_gil_times, num_compartments). Note that each draw might yield a different\n        num_gil_times.\n        \"\"\"", "\n", "# initialize", "\n", "t", "=", "0.0", "\n", "times", "=", "np", ".", "asarray", "(", "[", "t", "]", ")", "\n", "states", "=", "self", ".", "initial_state", ".", "copy", "(", ")", "[", "None", ",", ":", "]", "\n", "\n", "# Perform simulation", "\n", "while", "t", "<", "time_end", ":", "\n", "            ", "if", "self", ".", "_get_current_rates", "(", "states", "[", "-", "1", ",", ":", "]", ")", ".", "sum", "(", ")", "==", "0.0", ":", "\n", "# make sure to stop when all individuals are recovered", "\n", "                ", "t", "=", "time_end", "\n", "states", "=", "np", ".", "append", "(", "states", ",", "states", "[", "-", "1", ":", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "times", "=", "np", ".", "append", "(", "times", ",", "t", ")", "\n", "break", "\n", "\n", "# draw the event and time step", "\n", "", "event", ",", "dt", "=", "self", ".", "_draw_next_event", "(", "states", "[", "-", "1", ",", ":", "]", ")", "\n", "\n", "# increment time that elapsed for this event to happen", "\n", "t", "+=", "dt", "\n", "\n", "# Update the states and times", "\n", "states", "=", "np", ".", "append", "(", "states", ",", "(", "states", "[", "-", "1", ",", ":", "]", "+", "self", ".", "_get_possible_state_updates", "(", ")", "[", "event", ",", ":", "]", ")", "[", "None", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "times", "=", "np", ".", "append", "(", "times", ",", "t", ")", "\n", "\n", "", "recovered", "=", "(", "self", ".", "model", ".", "N", "-", "states", ".", "sum", "(", "axis", "=", "1", ")", ")", "[", ":", ",", "None", "]", "\n", "compartments", "=", "np", ".", "append", "(", "states", ",", "recovered", ",", "axis", "=", "1", ")", "\n", "return", "times", ",", "compartments", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._draw_gillespie_fixed_time": [[96, 107], ["gillespie_base.GillespieBase._draw_gillespie", "gillespie_base.GillespieBase._map_gillespie_times_to_fixed_times"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._draw_gillespie", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._map_gillespie_times_to_fixed_times"], ["", "def", "_draw_gillespie_fixed_time", "(", "self", ",", "times_fixed", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Draw one realisation of the SIR model with outputs evaluated at given times times_fixed. Note that the length\n        of times_fixed might differ from the length of the gillespie path.\n\n        :param times_fixed: array of ordered time points at which to sort into the gillespie compartments,\n        shape (num_time_points, )\n        :return: a Gillespie sample, with shape (num_time_points, num_compartments)\n        \"\"\"", "\n", "gillespie_path", "=", "self", ".", "_draw_gillespie", "(", "times_fixed", "[", "-", "1", "]", ")", "\n", "return", "self", ".", "_map_gillespie_times_to_fixed_times", "(", "gillespie_path", ",", "times_fixed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._map_gillespie_times_to_fixed_times": [[108, 125], ["numpy.searchsorted"], "methods", ["None"], ["", "def", "_map_gillespie_times_to_fixed_times", "(", "\n", "self", ",", "gillespie_path", ":", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ",", "times_fixed", ":", "np", ".", "ndarray", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Maps a given sample onto a given ordered time array\n\n        :param gillespie_path: tuple containing times and compartment paths\n        :param times_fixed: ordered time points at which to record the current compartments, shape (num_time_points, )\n        :return: the remapped compartments, with shape (num_time_points, num_compartments)\n        \"\"\"", "\n", "# check that start of paths coincide", "\n", "assert", "times_fixed", "[", "0", "]", "==", "0", "\n", "\n", "times_path", ",", "compartments_path", "=", "gillespie_path", "\n", "idx_new", "=", "np", ".", "searchsorted", "(", "times_path", ",", "times_fixed", ",", "side", "=", "\"right\"", ")", "-", "1", "\n", "compartments_new", "=", "compartments_path", "[", "idx_new", ",", ":", "]", "\n", "return", "compartments_new", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase.run_simulation_fixed_time": [[126, 140], ["numpy.zeros", "range", "len", "gillespie_base.GillespieBase._draw_gillespie_fixed_time"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._draw_gillespie_fixed_time"], ["", "def", "run_simulation_fixed_time", "(", "self", ",", "num_gil", ":", "int", ",", "t_eval", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Draw num_gil Gillespie samples\n\n        :param num_gil: number of samples (gillespie runs)\n        :param t_eval: ordered time points at which to record the current state, shape (number of time points)\n        :return: num_gil samples, shape (t_eval.size, number of compartments, num_gil)\n        \"\"\"", "\n", "num_compartments", "=", "len", "(", "self", ".", "initial_state", ")", "+", "1", "\n", "gillespie_paths", "=", "np", ".", "zeros", "(", "(", "t_eval", ".", "size", ",", "num_compartments", ",", "num_gil", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_gil", ")", ":", "\n", "            ", "gillespie_paths", "[", ":", ",", ":", ",", "i", "]", "=", "self", ".", "_draw_gillespie_fixed_time", "(", "t_eval", ")", "\n", "", "return", "gillespie_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._compute_height_and_time_of_peak": [[142, 152], ["numpy.argmax", "gillespie_base.GillespieBase._get_state_index_infected", "gillespie_base.GillespieBase._get_state_index_infected"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_state_index_infected", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_state_index_infected"], ["", "def", "_compute_height_and_time_of_peak", "(", "self", ",", "gillespie_path", ":", "Tuple", "[", "np", ".", "array", ",", "np", ".", "ndarray", "]", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        compute the time when the maximum number of objects infected and how many\n\n        :param gillespie_path: tuple of an array with times and and an array with states\n        :return: time when maximum occurs, value of maximum\n        \"\"\"", "\n", "t", ",", "height", "=", "gillespie_path", "\n", "idx_of_max_time", "=", "np", ".", "argmax", "(", "height", "[", ":", ",", "self", ".", "_get_state_index_infected", "(", ")", "]", ")", "\n", "return", "t", "[", "idx_of_max_time", "]", ",", "height", "[", "idx_of_max_time", ",", "self", ".", "_get_state_index_infected", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase.run_simulation_height_and_time_of_peak": [[153, 173], ["numpy.zeros", "numpy.zeros", "range", "idx_of_peaks.sum", "gillespie_base.GillespieBase._draw_gillespie", "gillespie_base.GillespieBase._compute_height_and_time_of_peak", "t[].sum", "state[].sum"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._draw_gillespie", "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.gillespie_base.GillespieBase._compute_height_and_time_of_peak"], ["", "def", "run_simulation_height_and_time_of_peak", "(", "self", ",", "num_gil", ":", "int", ",", "time_end", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Compute the mean of the location and value of maximum across simulations\n\n        :param num_gil: the number of samples (simulation runs)\n        :param time_end: end time of simulation\n        :return:\n        \"\"\"", "\n", "t", "=", "np", ".", "zeros", "(", "(", "num_gil", ",", ")", ")", "\n", "state", "=", "np", ".", "zeros", "(", "(", "num_gil", ",", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_gil", ")", ":", "\n", "            ", "gillespie_path", "=", "self", ".", "_draw_gillespie", "(", "time_end", ")", "\n", "t", "[", "i", "]", ",", "state", "[", "i", "]", "=", "self", ".", "_compute_height_and_time_of_peak", "(", "gillespie_path", ")", "\n", "\n", "# only count the maxima where at least one infection has occurred", "\n", "", "idx_of_peaks", "=", "t", "!=", "0.0", "\n", "num_of_peaks", "=", "idx_of_peaks", ".", "sum", "(", ")", "\n", "\n", "return", "t", "[", "idx_of_peaks", "]", ".", "sum", "(", ")", "/", "num_of_peaks", ",", "state", "[", "idx_of_peaks", "]", ".", "sum", "(", ")", "/", "num_of_peaks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie.__init__": [[19, 24], ["gillespie_base.GillespieBase.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "model", ":", "SEIR", ")", ":", "\n", "        ", "\"\"\"\n        :param model: A SEIR model\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_initial_state": [[25, 27], ["numpy.asarray"], "methods", ["None"], ["", "def", "_get_initial_state", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "[", "self", ".", "model", ".", "N", "-", "1", ",", "0", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_state_index_infected": [[28, 30], ["int"], "methods", ["None"], ["", "def", "_get_state_index_infected", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "int", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_possible_state_updates": [[31, 34], ["numpy.array"], "methods", ["None"], ["", "def", "_get_possible_state_updates", "(", "self", ")", ":", "\n", "        ", "\"\"\"possible updates of compartment counts\"\"\"", "\n", "return", "np", ".", "array", "(", "[", "[", "-", "1", ",", "1", ",", "0", "]", ",", "[", "0", ",", "-", "1", ",", "1", "]", ",", "[", "0", ",", "0", ",", "-", "1", "]", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.Emukit_task_seir_model.seir_gillespie.SEIRGillespie._get_current_rates": [[35, 44], ["numpy.asarray"], "methods", ["None"], ["", "def", "_get_current_rates", "(", "self", ",", "state", ")", ":", "\n", "        ", "\"\"\"\n        Returns an array of the current rates of infection/incubation/recovery (1/2/3),\n        i.e. the un-normalized probabilities for these events to occur next\n        \"\"\"", "\n", "rate_1", "=", "self", ".", "model", ".", "alpha", "*", "state", "[", "0", "]", "*", "state", "[", "2", "]", "/", "self", ".", "model", ".", "N", "\n", "rate_2", "=", "self", ".", "model", ".", "beta", "*", "state", "[", "1", "]", "\n", "rate_3", "=", "state", "[", "2", "]", "\n", "return", "np", ".", "asarray", "(", "[", "rate_1", ",", "rate_2", ",", "rate_3", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.__init__": [[83, 122], ["gpflow.models.model.Model.__init__", "len", "gpflow.ParamList", "doubly_stochastic_dgp.utils.BroadcastingLikelihood", "enumerate", "enumerate", "zip", "setattr", "setattr", "setattr", "zip", "setattr", "setattr", "setattr", "gpflow.params.Minibatch", "gpflow.params.Minibatch", "gpflow.params.DataHolder", "gpflow.params.DataHolder", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "X", ",", "Y", ",", "likelihood", ",", "layers", ",", "minibatch_size", "=", "None", ",", "num_samples", "=", "1", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n\n        :param X: List of training inputs where each element of the list is a numpy array corresponding to the inputs of one fidelity.\n        :param Y: List of training targets where each element of the list is a numpy array corresponding to the inputs of one fidelity.\n        :param likelihood: gpflow likelihood object for use at the final layer\n        :param layers: List of doubly_stochastic_dgp.layers.Layer objects\n        :param minibatch_size: Minibatch size if using minibatch trainingz\n        :param num_samples: Number of samples when propagating predictions through layers\n        :param kwargs: kwarg inputs to gpflow.models.Model\n        \"\"\"", "\n", "\n", "Model", ".", "__init__", "(", "self", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "Y_list", "=", "Y", "\n", "self", ".", "X_list", "=", "X", "\n", "self", ".", "minibatch_size", "=", "minibatch_size", "\n", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "\n", "# This allows a training regime where the first layer is trained first by itself, then the subsequent layer", "\n", "# and so on.", "\n", "self", ".", "_train_upto_fidelity", "=", "-", "1", "\n", "\n", "if", "minibatch_size", ":", "\n", "            ", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "zip", "(", "X", ",", "Y", ")", ")", ":", "\n", "                ", "setattr", "(", "self", ",", "\"num_data\"", "+", "str", "(", "i", ")", ",", "x", ".", "shape", "[", "0", "]", ")", "\n", "setattr", "(", "self", ",", "\"X\"", "+", "str", "(", "i", ")", ",", "Minibatch", "(", "x", ",", "minibatch_size", ",", "seed", "=", "0", ")", ")", "\n", "setattr", "(", "self", ",", "\"Y\"", "+", "str", "(", "i", ")", ",", "Minibatch", "(", "y", ",", "minibatch_size", ",", "seed", "=", "0", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "zip", "(", "X", ",", "Y", ")", ")", ":", "\n", "                ", "setattr", "(", "self", ",", "\"num_data\"", "+", "str", "(", "i", ")", ",", "x", ".", "shape", "[", "0", "]", ")", "\n", "setattr", "(", "self", ",", "\"X\"", "+", "str", "(", "i", ")", ",", "DataHolder", "(", "x", ")", ")", "\n", "setattr", "(", "self", ",", "\"Y\"", "+", "str", "(", "i", ")", ",", "DataHolder", "(", "y", ")", ")", "\n", "\n", "", "", "self", ".", "num_layers", "=", "len", "(", "layers", ")", "\n", "self", ".", "layers", "=", "ParamList", "(", "layers", ")", "\n", "\n", "self", ".", "likelihood", "=", "BroadcastingLikelihood", "(", "likelihood", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.propagate": [[123, 161], ["tf.tile", "enumerate", "tf.expand_dims", "zip", "Fs.append", "Fmeans.append", "Fvars.append", "len", "layer.sample_from_conditional", "tf.concat", "layer.sample_from_conditional"], "methods", ["None"], ["", "@", "params_as_tensors", "\n", "def", "propagate", "(", "self", ",", "X", ",", "full_cov", "=", "False", ",", "S", "=", "1", ",", "zs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Propagate some prediction to the final layer and return predictions at each intermediate layer\n\n        :param X: Input(s) at which to predict at\n        :param full_cov: Whether the predict with the full covariance matrix\n        :param S: Number of samples to use for sampling at intermediate layers\n        :param zs: ??\n        :return:\n        \"\"\"", "\n", "sX", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "X", ",", "0", ")", ",", "[", "S", ",", "1", ",", "1", "]", ")", "\n", "\n", "Fs", ",", "Fmeans", ",", "Fvars", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "F", "=", "sX", "\n", "zs", "=", "zs", "or", "[", "\n", "None", ",", "\n", "]", "*", "len", "(", "self", ".", "layers", ")", "\n", "\n", "for", "i", ",", "(", "layer", ",", "z", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "layers", ",", "zs", ")", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "F", ",", "Fmean", ",", "Fvar", "=", "layer", ".", "sample_from_conditional", "(", "F", ",", "z", "=", "z", ",", "full_cov", "=", "full_cov", ")", "\n", "", "else", ":", "\n", "                ", "\"\"\"\n\n                KC - At all layers 1..L, the input to the next layer is original input augmented with\n                the realisation of the function at the previous layer at that input.\n\n                \"\"\"", "\n", "F_aug", "=", "tf", ".", "concat", "(", "[", "sX", ",", "F", "]", ",", "2", ")", "\n", "F", ",", "Fmean", ",", "Fvar", "=", "layer", ".", "sample_from_conditional", "(", "F_aug", ",", "z", "=", "z", ",", "full_cov", "=", "full_cov", ")", "\n", "\n", "", "Fs", ".", "append", "(", "F", ")", "\n", "Fmeans", ".", "append", "(", "Fmean", ")", "\n", "Fvars", ".", "append", "(", "Fvar", ")", "\n", "\n", "", "return", "Fs", ",", "Fmeans", ",", "Fvars", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._build_predict": [[162, 179], ["multi_fidelity_deep_gp.DGP_Base.propagate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.propagate"], ["", "@", "params_as_tensors", "\n", "def", "_build_predict", "(", "self", ",", "X", ",", "full_cov", "=", "False", ",", "S", "=", "1", ",", "fidelity", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Predicts from the fidelity level specified. If fidelity is not specified, return prediction at highest fidelity.\n\n        :param X: Location at which to predict\n        :param full_cov: Whether to predict full covariance matrix\n        :param S: Number of samples to use for MC sampling between layers\n        :param fidelity: zero based fidelity index at which to predict\n        :return: (mean, variance) where each is [S, N, 1] where S is number of samples and N is number of predicted points.\n        \"\"\"", "\n", "\n", "if", "fidelity", "is", "None", ":", "\n", "            ", "fidelity", "=", "-", "1", "\n", "\n", "", "_", ",", "Fmeans", ",", "Fvars", "=", "self", ".", "propagate", "(", "X", ",", "full_cov", "=", "full_cov", ",", "S", "=", "S", ")", "\n", "return", "Fmeans", "[", "fidelity", "]", ",", "Fvars", "[", "fidelity", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._likelihood_at_fidelity": [[180, 191], ["numpy.log", "tf.log", "tf.square"], "methods", ["None"], ["", "def", "_likelihood_at_fidelity", "(", "self", ",", "Fmu", ",", "Fvar", ",", "Y", ",", "variance", ")", ":", "\n", "        ", "\"\"\"\n        Calculate likelihood term for observations corresponding to one fidelity\n\n        :param Fmu: Posterior mean\n        :param Fvar: Posterior variance\n        :param Y: training observations\n        :param variance: likelihood variance\n        :return:\n        \"\"\"", "\n", "return", "-", "0.5", "*", "np", ".", "log", "(", "2", "*", "np", ".", "pi", ")", "-", "0.5", "*", "tf", ".", "log", "(", "variance", ")", "-", "0.5", "*", "(", "tf", ".", "square", "(", "Y", "-", "Fmu", ")", "+", "Fvar", ")", "/", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.E_log_p_Y": [[192, 226], ["multi_fidelity_deep_gp.DGP_Base._build_predict", "tf.reduce_mean", "multi_fidelity_deep_gp.DGP_Base.likelihood.variational_expectations", "f", "multi_fidelity_deep_gp.DGP_Base._likelihood_at_fidelity", "tf.expand_dims"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._build_predict", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._likelihood_at_fidelity"], ["", "def", "E_log_p_Y", "(", "self", ",", "X_f", ",", "Y_f", ",", "fidelity", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Calculate the expectation of the data log likelihood under the variational distribution with MC samples\n\n        :param X_f: Training inputs for a given\n        :param Y_f:\n        :param fidelity:\n        :return:\n        \"\"\"", "\n", "\n", "Fmean", ",", "Fvar", "=", "self", ".", "_build_predict", "(", "X_f", ",", "full_cov", "=", "False", ",", "S", "=", "self", ".", "num_samples", ",", "fidelity", "=", "fidelity", ")", "\n", "\n", "if", "fidelity", "==", "(", "self", ".", "num_layers", "-", "1", ")", ":", "\n", "            ", "\"\"\"\n            KC - The likelihood of the observations at the last layer is computed using the model's 'likelihood' object\n            \"\"\"", "\n", "var_exp", "=", "self", ".", "likelihood", ".", "variational_expectations", "(", "Fmean", ",", "Fvar", ",", "Y_f", ")", "# S, N, D", "\n", "", "else", ":", "\n", "            ", "\"\"\"\n            KC - The Gaussian likelihood of the observations at the intermediate layers is computed using the noise\n            parameter pertaining to the White noise kernel.\n\n            This assumes that a White kernel should be added to all layers except for the last!\n            If no noise is desired, the variance parameter in the White kernel should be set to zero and fixed.\n            \"\"\"", "\n", "variance", "=", "self", ".", "layers", "[", "fidelity", "]", ".", "kern", ".", "kernels", "[", "-", "1", "]", ".", "variance", "\n", "\n", "f", "=", "lambda", "vars_SND", ",", "vars_ND", ",", "vars_N", ":", "self", ".", "_likelihood_at_fidelity", "(", "\n", "vars_SND", "[", "0", "]", ",", "vars_SND", "[", "1", "]", ",", "vars_ND", "[", "0", "]", ",", "vars_N", "\n", ")", "\n", "\n", "var_exp", "=", "f", "(", "[", "Fmean", ",", "Fvar", "]", ",", "[", "tf", ".", "expand_dims", "(", "Y_f", ",", "0", ")", "]", ",", "variance", ")", "\n", "\n", "", "return", "tf", ".", "reduce_mean", "(", "var_exp", ",", "0", ")", "# N, D", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._build_likelihood": [[227, 253], ["range", "getattr", "getattr", "getattr", "tf.reduce_sum", "tf.cast", "tf.cast", "tf.reduce_sum", "multi_fidelity_deep_gp.DGP_Base.layers[].KL", "str", "str", "str", "multi_fidelity_deep_gp.DGP_Base.E_log_p_Y", "tf.shape"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.E_log_p_Y"], ["", "@", "params_as_tensors", "\n", "def", "_build_likelihood", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        ELBO calculation\n        :return: MC estimate of lower bound\n        \"\"\"", "\n", "L", "=", "0.0", "\n", "KL", "=", "0.0", "\n", "for", "fidelity", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "\n", "            ", "if", "(", "self", ".", "_train_upto_fidelity", "!=", "-", "1", ")", "and", "(", "fidelity", ">", "self", ".", "_train_upto_fidelity", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "X_l", "=", "getattr", "(", "self", ",", "\"X\"", "+", "str", "(", "fidelity", ")", ")", "\n", "Y_l", "=", "getattr", "(", "self", ",", "\"Y\"", "+", "str", "(", "fidelity", ")", ")", "\n", "\n", "n_data", "=", "getattr", "(", "self", ",", "\"num_data\"", "+", "str", "(", "fidelity", ")", ")", "\n", "scale", "=", "tf", ".", "cast", "(", "n_data", ",", "float_type", ")", "/", "tf", ".", "cast", "(", "tf", ".", "shape", "(", "X_l", ")", "[", "0", "]", ",", "float_type", ")", "\n", "\n", "L", "+=", "tf", ".", "reduce_sum", "(", "self", ".", "E_log_p_Y", "(", "X_l", ",", "Y_l", ",", "fidelity", ")", ")", "*", "scale", "\n", "KL", "+=", "tf", ".", "reduce_sum", "(", "self", ".", "layers", "[", "fidelity", "]", ".", "KL", "(", ")", ")", "\n", "\n", "", "self", ".", "L", "=", "L", "\n", "self", ".", "KL", "=", "KL", "\n", "\n", "return", "self", ".", "L", "-", "self", ".", "KL", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.predict_f": [[254, 257], ["gpflow.autoflow", "multi_fidelity_deep_gp.DGP_Base._build_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._build_predict"], ["", "@", "autoflow", "(", "(", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "tf", ".", "int32", ",", "[", "]", ")", ")", "\n", "def", "predict_f", "(", "self", ",", "Xnew", ",", "num_samples", ",", "fidelity", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "_build_predict", "(", "Xnew", ",", "full_cov", "=", "False", ",", "S", "=", "num_samples", ",", "fidelity", "=", "fidelity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.predict_f_full_cov": [[258, 261], ["gpflow.autoflow", "multi_fidelity_deep_gp.DGP_Base._build_predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._build_predict"], ["", "@", "autoflow", "(", "(", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "tf", ".", "int32", ",", "[", "]", ")", ")", "\n", "def", "predict_f_full_cov", "(", "self", ",", "Xnew", ",", "num_samples", ",", "fidelity", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "_build_predict", "(", "Xnew", ",", "full_cov", "=", "True", ",", "S", "=", "num_samples", ",", "fidelity", "=", "fidelity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.predict_all_layers": [[262, 265], ["gpflow.autoflow", "multi_fidelity_deep_gp.DGP_Base.propagate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.propagate"], ["", "@", "autoflow", "(", "(", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "tf", ".", "int32", ",", "[", "]", ")", ")", "\n", "def", "predict_all_layers", "(", "self", ",", "Xnew", ",", "num_samples", ")", ":", "\n", "        ", "return", "self", ".", "propagate", "(", "Xnew", ",", "full_cov", "=", "False", ",", "S", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.predict_all_layers_full_cov": [[266, 269], ["gpflow.autoflow", "multi_fidelity_deep_gp.DGP_Base.propagate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.propagate"], ["", "@", "autoflow", "(", "(", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "tf", ".", "int32", ",", "[", "]", ")", ")", "\n", "def", "predict_all_layers_full_cov", "(", "self", ",", "Xnew", ",", "num_samples", ")", ":", "\n", "        ", "return", "self", ".", "propagate", "(", "Xnew", ",", "full_cov", "=", "True", ",", "S", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.predict_y": [[270, 274], ["gpflow.autoflow", "multi_fidelity_deep_gp.DGP_Base._build_predict", "multi_fidelity_deep_gp.DGP_Base.likelihood.predict_mean_and_var"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._build_predict"], ["", "@", "autoflow", "(", "(", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "tf", ".", "int32", ",", "[", "]", ")", ")", "\n", "def", "predict_y", "(", "self", ",", "Xnew", ",", "num_samples", ")", ":", "\n", "        ", "Fmean", ",", "Fvar", "=", "self", ".", "_build_predict", "(", "Xnew", ",", "full_cov", "=", "False", ",", "S", "=", "num_samples", ")", "\n", "return", "self", ".", "likelihood", ".", "predict_mean_and_var", "(", "Fmean", ",", "Fvar", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.predict_density": [[275, 281], ["gpflow.autoflow", "multi_fidelity_deep_gp.DGP_Base._build_predict", "multi_fidelity_deep_gp.DGP_Base.likelihood.predict_density", "tf.log", "tf.reduce_logsumexp", "tf.cast"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base._build_predict", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.predict_density"], ["", "@", "autoflow", "(", "(", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "float_type", ",", "[", "None", ",", "None", "]", ")", ",", "(", "tf", ".", "int32", ",", "[", "]", ")", ")", "\n", "def", "predict_density", "(", "self", ",", "Xnew", ",", "Ynew", ",", "num_samples", ")", ":", "\n", "        ", "Fmean", ",", "Fvar", "=", "self", ".", "_build_predict", "(", "Xnew", ",", "full_cov", "=", "False", ",", "S", "=", "num_samples", ")", "\n", "l", "=", "self", ".", "likelihood", ".", "predict_density", "(", "Fmean", ",", "Fvar", ",", "Ynew", ")", "\n", "log_num_samples", "=", "tf", ".", "log", "(", "tf", ".", "cast", "(", "num_samples", ",", "float_type", ")", ")", "\n", "return", "tf", ".", "reduce_logsumexp", "(", "l", "-", "log_num_samples", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.make_mf_dgp": [[282, 336], ["len", "range", "enumerate", "range", "multi_fidelity_deep_gp.init_layers_mf", "multi_fidelity_deep_gp.DGP_Base", "gpflow.kernels.RBF", "list", "gpflow.kernels.RBF", "gpflow.kernels.RBF", "gpflow.kernels.RBF", "kernels.append", "gpflow.kernels.White", "len", "_log.info", "_log.info", "_log.info", "_log.info", "gpflow.likelihoods.Gaussian", "range", "list", "range", "gpflow.kernels.Linear"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.init_layers_mf"], ["", "@", "classmethod", "\n", "def", "make_mf_dgp", "(", "cls", ",", "X", ",", "Y", ",", "Z", ",", "add_linear", "=", "True", ",", "minibatch_size", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor for convenience. Constructs a mf-dgp model from training data and inducing point locations\n\n        :param X: List of target\n        :param Y:\n        :param Z:\n        :param add_linear:\n        :return:\n        \"\"\"", "\n", "\n", "n_fidelities", "=", "len", "(", "X", ")", "\n", "\n", "Din", "=", "X", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "Dout", "=", "Y", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "\n", "kernels", "=", "[", "RBF", "(", "Din", ",", "active_dims", "=", "list", "(", "range", "(", "Din", ")", ")", ",", "variance", "=", "1.0", ",", "lengthscales", "=", "1", ",", "ARD", "=", "True", ")", "]", "\n", "for", "l", "in", "range", "(", "1", ",", "n_fidelities", ")", ":", "\n", "            ", "D", "=", "Din", "+", "Dout", "\n", "D_range", "=", "list", "(", "range", "(", "D", ")", ")", "\n", "k_corr", "=", "RBF", "(", "Din", ",", "active_dims", "=", "D_range", "[", ":", "Din", "]", ",", "lengthscales", "=", "1", ",", "variance", "=", "1.0", ",", "ARD", "=", "True", ")", "\n", "k_prev", "=", "RBF", "(", "Dout", ",", "active_dims", "=", "D_range", "[", "Din", ":", "]", ",", "variance", "=", "1.0", ",", "lengthscales", "=", "1.0", ")", "\n", "k_in", "=", "RBF", "(", "Din", ",", "active_dims", "=", "D_range", "[", ":", "Din", "]", ",", "variance", "=", "1.0", ",", "lengthscales", "=", "1", ",", "ARD", "=", "True", ")", "\n", "if", "add_linear", ":", "\n", "                ", "k_l", "=", "k_corr", "*", "(", "k_prev", "+", "Linear", "(", "Dout", ",", "active_dims", "=", "D_range", "[", "Din", ":", "]", ",", "variance", "=", "1.0", ")", ")", "+", "k_in", "\n", "", "else", ":", "\n", "                ", "k_l", "=", "k_corr", "*", "k_prev", "+", "k_in", "\n", "", "kernels", ".", "append", "(", "k_l", ")", "\n", "\n", "", "\"\"\"\n        A White noise kernel is currently expected by Mf-DGP at all layers except the last.\n        In cases where no noise is desired, this should be set to 0 and fixed, as follows:\n\n            white = White(1, variance=0.)\n            white.variance.trainable = False\n            kernels[i] += white\n        \"\"\"", "\n", "for", "i", ",", "kernel", "in", "enumerate", "(", "kernels", "[", ":", "-", "1", "]", ")", ":", "\n", "            ", "kernels", "[", "i", "]", "+=", "White", "(", "1", ",", "variance", "=", "1e-6", ")", "\n", "\n", "", "num_data", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "X", ")", ")", ":", "\n", "            ", "_log", ".", "info", "(", "\"\\nData at Fidelity {}\"", ".", "format", "(", "i", "+", "1", ")", ")", "\n", "_log", ".", "info", "(", "\"X - {}\"", ".", "format", "(", "X", "[", "i", "]", ".", "shape", ")", ")", "\n", "_log", ".", "info", "(", "\"Y - {}\"", ".", "format", "(", "Y", "[", "i", "]", ".", "shape", ")", ")", "\n", "_log", ".", "info", "(", "\"Z - {}\"", ".", "format", "(", "Z", "[", "i", "]", ".", "shape", ")", ")", "\n", "num_data", "+=", "X", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "layers", "=", "init_layers_mf", "(", "Y", ",", "Z", ",", "kernels", ",", "num_outputs", "=", "Dout", ")", "\n", "\n", "model", "=", "DGP_Base", "(", "X", ",", "Y", ",", "Gaussian", "(", ")", ",", "layers", ",", "num_samples", "=", "10", ",", "minibatch_size", "=", "minibatch_size", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.multi_step_training": [[337, 360], ["multi_fidelity_deep_gp.DGP_Base.run_adam", "multi_fidelity_deep_gp.DGP_Base.run_adam", "multi_fidelity_deep_gp.DGP_Base.Y_list[].var", "multi_fidelity_deep_gp.DGP_Base.Y_list[].var"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.run_adam", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.run_adam"], ["", "def", "multi_step_training", "(", "self", ",", "n_iter", "=", "5000", ",", "n_iter_2", "=", "15000", ")", ":", "\n", "        ", "\"\"\"\n        Train with variational covariance fixed to be small first, then free up and train covariance alongside other\n        parameters. Inducing point locations are fixed throughout.\n        \"\"\"", "\n", "for", "layer", "in", "self", ".", "layers", "[", ":", "-", "1", "]", ":", "\n", "            ", "layer", ".", "q_sqrt", "=", "layer", ".", "q_sqrt", ".", "value", "*", "1e-8", "\n", "layer", ".", "q_sqrt", ".", "trainable", "=", "False", "\n", "", "self", ".", "layers", "[", "-", "1", "]", ".", "q_sqrt", "=", "self", ".", "layers", "[", "-", "1", "]", ".", "q_sqrt", ".", "value", "*", "self", ".", "Y_list", "[", "-", "1", "]", ".", "var", "(", ")", "*", "0.01", "\n", "self", ".", "layers", "[", "-", "1", "]", ".", "q_sqrt", ".", "trainable", "=", "False", "\n", "self", ".", "likelihood", ".", "likelihood", ".", "variance", "=", "self", ".", "Y_list", "[", "-", "1", "]", ".", "var", "(", ")", "*", "0.01", "\n", "self", ".", "likelihood", ".", "likelihood", ".", "variance", ".", "trainable", "=", "False", "\n", "\n", "# Run with covariance fixed", "\n", "self", ".", "run_adam", "(", "3e-3", ",", "n_iter", ")", "\n", "\n", "# Run with covariance free", "\n", "self", ".", "likelihood", ".", "likelihood", ".", "variance", ".", "trainable", "=", "True", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "layer", ".", "q_sqrt", ".", "trainable", "=", "True", "\n", "\n", "", "self", ".", "run_adam", "(", "1e-3", ",", "n_iter_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.fix_inducing_point_locations": [[361, 367], ["None"], "methods", ["None"], ["", "def", "fix_inducing_point_locations", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Fix all inducing point locations\n        \"\"\"", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "layer", ".", "feature", ".", "Z", ".", "trainable", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.run_adam": [[368, 373], ["gpflow.training.AdamOptimizer().make_optimize_action", "multi_fidelity_deep_gp.DGP_Base.anchor", "multi_fidelity_deep_gp.PrintAction", "gpflow.actions.Loop", "multi_fidelity_deep_gp.DGP_Base.enquire_session", "gpflow.training.AdamOptimizer"], "methods", ["None"], ["", "", "def", "run_adam", "(", "self", ",", "lr", ",", "iterations", ")", ":", "\n", "        ", "adam", "=", "AdamOptimizer", "(", "lr", ")", ".", "make_optimize_action", "(", "self", ")", "\n", "actions", "=", "[", "adam", ",", "PrintAction", "(", "self", ",", "\"MF-DGP with Adam\"", ")", "]", "\n", "loop", "=", "Loop", "(", "actions", ",", "stop", "=", "iterations", ")", "(", ")", "\n", "self", ".", "anchor", "(", "self", ".", "enquire_session", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.PrintAction.__init__": [[380, 383], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "text", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "text", "=", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.PrintAction.run": [[384, 389], ["ctx.session.run", "_log.info", "_log.info", "ctx.session.run", "ctx.session.run"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.PrintAction.run", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.PrintAction.run", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.PrintAction.run"], ["", "def", "run", "(", "self", ",", "ctx", ")", ":", "\n", "        ", "if", "ctx", ".", "iteration", "%", "2000", "==", "0", ":", "\n", "            ", "objective", "=", "ctx", ".", "session", ".", "run", "(", "self", ".", "model", ".", "objective", ")", "\n", "_log", ".", "info", "(", "\"ELBO {:.4f};  KL {:.4f}\"", ".", "format", "(", "ctx", ".", "session", ".", "run", "(", "self", ".", "model", ".", "L", ")", ",", "ctx", ".", "session", ".", "run", "(", "self", ".", "model", ".", "KL", ")", ")", ")", "\n", "_log", ".", "info", "(", "\"{}: iteration {} objective {:.4f}\"", ".", "format", "(", "self", ".", "text", ",", "ctx", ".", "iteration", ",", "objective", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP.__init__": [[397, 414], ["multi_fidelity_deep_gp.MultiFidelityDeepGP._get_model", "len", "multi_fidelity_deep_gp.MultiFidelityDeepGP.model.fix_inducing_point_locations", "multi_fidelity_deep_gp.MultiFidelityDeepGP._make_inducing_points"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP._get_model", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.fix_inducing_point_locations", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP._make_inducing_points"], ["def", "__init__", "(", "self", ",", "X", ",", "Y", ",", "Z", "=", "None", ",", "n_iter", "=", "5000", ",", "fix_inducing", "=", "True", ",", "multi_step_training", "=", "True", ",", "minibatch_size", "=", "None", ")", ":", "\n", "        ", "self", ".", "_Y", "=", "Y", "\n", "self", ".", "_X", "=", "X", "\n", "self", ".", "minibatch_size", "=", "minibatch_size", "\n", "\n", "if", "Z", "is", "None", ":", "\n", "            ", "self", ".", "Z", "=", "self", ".", "_make_inducing_points", "(", "X", ",", "Y", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "Z", "=", "Z", "\n", "\n", "", "self", ".", "model", "=", "self", ".", "_get_model", "(", "X", ",", "Y", ",", "self", ".", "Z", ")", "\n", "self", ".", "name", "=", "\"mfdgp\"", "\n", "self", ".", "n_fidelities", "=", "len", "(", "X", ")", "\n", "self", ".", "n_iter", "=", "n_iter", "\n", "self", ".", "fix_inducing", "=", "fix_inducing", "\n", "self", ".", "model", ".", "fix_inducing_point_locations", "(", ")", "\n", "self", ".", "multi_step_training", "=", "multi_step_training", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP.set_data": [[415, 417], ["NotImplementedError"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP._get_model": [[418, 420], ["multi_fidelity_deep_gp.DGP_Base.make_mf_dgp"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.make_mf_dgp"], ["", "def", "_get_model", "(", "self", ",", "X", ",", "Y", ",", "Z", ")", ":", "\n", "        ", "return", "DGP_Base", ".", "make_mf_dgp", "(", "X", ",", "Y", ",", "Z", ",", "minibatch_size", "=", "self", ".", "minibatch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP.predict": [[421, 430], ["numpy.all", "multi_fidelity_deep_gp.MultiFidelityDeepGP.model.predict_y", "numpy.mean().flatten", "numpy.mean().flatten", "numpy.var().flatten", "numpy.mean", "numpy.mean", "numpy.var"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.predict_y"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "array", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "# assume high fidelity only!!!!", "\n", "        ", "assert", "np", ".", "all", "(", "X", "[", ":", ",", "-", "1", "]", "==", "(", "self", ".", "n_fidelities", "-", "1", ")", ")", "\n", "\n", "x_test", "=", "X", "[", ":", ",", ":", "-", "1", "]", "\n", "y_m", ",", "y_v", "=", "self", ".", "model", ".", "predict_y", "(", "x_test", ",", "250", ")", "\n", "y_mean_high", "=", "np", ".", "mean", "(", "y_m", ",", "axis", "=", "0", ")", ".", "flatten", "(", ")", "\n", "y_var_high", "=", "np", ".", "mean", "(", "y_v", ",", "axis", "=", "0", ")", ".", "flatten", "(", ")", "+", "np", ".", "var", "(", "y_m", ",", "axis", "=", "0", ")", ".", "flatten", "(", ")", "\n", "return", "y_mean_high", "[", ":", ",", "None", "]", ",", "y_var_high", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP.optimize": [[431, 453], ["_log.info", "enumerate", "multi_fidelity_deep_gp.MultiFidelityDeepGP.model.fix_inducing_point_locations", "multi_fidelity_deep_gp.MultiFidelityDeepGP.model.multi_step_training", "multi_fidelity_deep_gp.MultiFidelityDeepGP.model.run_adam", "multi_fidelity_deep_gp.MultiFidelityDeepGP.model.run_adam"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.fix_inducing_point_locations", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.multi_step_training", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.run_adam", "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.DGP_Base.run_adam"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Optimize variational parameters alongside kernel and likelihood parameters using the following regime:\n            1. Optimize the parameters while fixing the intermediate layer mean variational parameters\n            2. Free the mean of the variational distribution and optimize all parameters together\n        \"\"\"", "\n", "\n", "if", "self", ".", "multi_step_training", ":", "\n", "            ", "_log", ".", "info", "(", "\"\\n--- Optimization: {} ---\\n\"", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "self", ".", "model", ".", "layers", "[", "0", "]", ".", "q_mu", "=", "self", ".", "_Y", "[", "0", "]", "\n", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "model", ".", "layers", "[", "1", ":", "-", "1", "]", ")", ":", "\n", "                ", "layer", ".", "q_mu", "=", "self", ".", "_Y", "[", "i", "]", "[", ":", ":", "2", "]", "\n", "layer", ".", "q_mu", ".", "trainable", "=", "False", "\n", "\n", "", "self", ".", "model", ".", "fix_inducing_point_locations", "(", ")", "\n", "self", ".", "model", ".", "multi_step_training", "(", "self", ".", "n_iter", ")", "\n", "\n", "for", "layer", "in", "self", ".", "model", ".", "layers", "[", ":", "-", "1", "]", ":", "\n", "                ", "layer", ".", "q_mu", ".", "trainable", "=", "True", "\n", "", "self", ".", "model", ".", "run_adam", "(", "1e-3", ",", "15000", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "model", ".", "run_adam", "(", "1e-3", ",", "20000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP._make_inducing_points": [[454, 468], ["zip", "X[].copy", "Z.append", "numpy.concatenate", "x.copy", "y.copy"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_make_inducing_points", "(", "X", ":", "List", ",", "Y", ":", "List", ")", "->", "List", ":", "\n", "        ", "\"\"\"\n        Makes inducing points at every other training point location which is deafult behaviour if no inducing point\n        locations are passed\n\n        :param X: training locations\n        :param Y: training targets\n        :return: List of numpy arrays containing inducing point locations\n        \"\"\"", "\n", "Z", "=", "[", "X", "[", "0", "]", ".", "copy", "(", ")", "]", "\n", "for", "x", ",", "y", "in", "zip", "(", "X", "[", ":", "-", "1", "]", ",", "Y", "[", ":", "-", "1", "]", ")", ":", "\n", "            ", "Z", ".", "append", "(", "np", ".", "concatenate", "(", "(", "x", ".", "copy", "(", ")", "[", ":", ":", "2", "]", ",", "y", ".", "copy", "(", ")", "[", ":", ":", "2", "]", ")", ",", "axis", "=", "1", ")", ")", "\n", "", "return", "Z", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP.X": [[469, 472], ["multi_fidelity.convert_lists_to_array.convert_x_list_to_array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_x_list_to_array"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "array", ":", "\n", "        ", "return", "convert_x_list_to_array", "(", "self", ".", "_X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.MultiFidelityDeepGP.Y": [[473, 476], ["multi_fidelity.convert_lists_to_array.convert_y_list_to_array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_y_list_to_array"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "array", ":", "\n", "        ", "return", "convert_y_list_to_array", "(", "self", ".", "_Y", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.multi_fidelity_deep_gp.init_layers_mf": [[55, 74], ["len", "range", "layers.append", "Layer", "gpflow.mean_functions.Zero"], "function", ["None"], ["def", "init_layers_mf", "(", "Y", ",", "Z", ",", "kernels", ",", "num_outputs", "=", "None", ",", "Layer", "=", "SVGP_Layer", ")", ":", "\n", "    ", "\"\"\"\n    Creates layer objects from initial data\n\n    :param Y: Numpy array of training targets\n    :param Z: List of numpy arrays of inducing point locations for each layer\n    :param kernels: List of kernels for each layer\n    :param num_outputs: Number of outputs (same for each layer)\n    :param Layer: The layer object to use\n    :return: List of layer objects with which to build a multi-fidelity deep Gaussian process model\n    \"\"\"", "\n", "num_outputs", "=", "num_outputs", "or", "Y", "[", "-", "1", "]", ".", "shape", "[", "1", "]", "\n", "\n", "layers", "=", "[", "]", "\n", "num_layers", "=", "len", "(", "Z", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "num_layers", ")", ":", "\n", "        ", "layers", ".", "append", "(", "Layer", "(", "kernels", "[", "i", "]", ",", "Z", "[", "i", "]", ",", "num_outputs", ",", "Zero", "(", ")", ")", ")", "\n", "", "return", "layers", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.HighFidelityGp.__init__": [[32, 37], ["GPy.kern.RBF", "GPy.models.GPRegression"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "kern", "=", "GPy", ".", "kern", ".", "RBF", "(", "X", "[", "1", "]", ".", "shape", "[", "1", "]", ",", "ARD", "=", "True", ")", "\n", "self", ".", "model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "X", "[", "1", "]", ",", "Y", "[", "1", "]", ",", "kernel", "=", "kern", ")", "\n", "self", ".", "model", ".", "Gaussian_noise", ".", "variance", "=", "1e-6", "\n", "self", ".", "name", "=", "\"hf_gp\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.HighFidelityGp.optimize": [[38, 41], ["_log.info", "baseline_model_wrappers.HighFidelityGp.model.optimize_restarts"], "methods", ["None"], ["", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "_log", ".", "info", "(", "\"\\n--- Optimization: ---\\n\"", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "self", ".", "model", ".", "optimize_restarts", "(", "10", ",", "robust", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.HighFidelityGp.predict": [[42, 47], ["baseline_model_wrappers.HighFidelityGp.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Predict from high fidelity\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "X", "[", ":", ",", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.HighFidelityGp.set_data": [[48, 50], ["NotImplementedError"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.HighFidelityGp.X": [[51, 54], ["NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.HighFidelityGp.Y": [[55, 58], ["NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.LinearAutoRegressiveModel.__init__": [[66, 86], ["multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays", "multi_fidelity.kernels.LinearMultiFidelityKernel", "multi_fidelity.models.GPyLinearMultiFidelityModel", "multi_fidelity.models.GPyLinearMultiFidelityModel.mixed_noise.Gaussian_noise.fix", "multi_fidelity.models.GPyLinearMultiFidelityModel.mixed_noise.Gaussian_noise_1.fix", "model_wrappers.GPyMultiOutputWrapper", "len", "GPy.kern.RBF", "len", "multi_fidelity.models.GPyLinearMultiFidelityModel.mixed_noise.Gaussian_noise_2.fix", "len", "range", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays"], ["def", "__init__", "(", "self", ",", "X", ",", "Y", ",", "n_restarts", "=", "10", ")", ":", "\n", "        ", "\"\"\"\n\n        :param X: List of training data at each fidelity\n        :param Y: List of training targets at each fidelity\n        :param n_restarts: Number of restarts during optimization of hyper-parameters\n        \"\"\"", "\n", "x_train", ",", "y_train", "=", "convert_xy_lists_to_arrays", "(", "X", ",", "Y", ")", "\n", "n_dims", "=", "X", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "kernels", "=", "[", "GPy", ".", "kern", ".", "RBF", "(", "n_dims", ",", "ARD", "=", "True", ")", "for", "_", "in", "range", "(", "len", "(", "X", ")", ")", "]", "\n", "lin_mf_kernel", "=", "LinearMultiFidelityKernel", "(", "kernels", ")", "\n", "gpy_lin_mf_model", "=", "GPyLinearMultiFidelityModel", "(", "x_train", ",", "y_train", ",", "lin_mf_kernel", ",", "n_fidelities", "=", "len", "(", "X", ")", ")", "\n", "gpy_lin_mf_model", ".", "mixed_noise", ".", "Gaussian_noise", ".", "fix", "(", "1e-6", ")", "\n", "gpy_lin_mf_model", ".", "mixed_noise", ".", "Gaussian_noise_1", ".", "fix", "(", "1e-6", ")", "\n", "if", "len", "(", "Y", ")", "==", "3", ":", "\n", "            ", "gpy_lin_mf_model", ".", "mixed_noise", ".", "Gaussian_noise_2", ".", "fix", "(", "1e-6", ")", "\n", "\n", "", "self", ".", "model", "=", "GPyMultiOutputWrapper", "(", "gpy_lin_mf_model", ",", "len", "(", "X", ")", ",", "n_optimization_restarts", "=", "n_restarts", ")", "\n", "self", ".", "name", "=", "\"ar1\"", "\n", "self", ".", "n_fidelities", "=", "len", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.LinearAutoRegressiveModel.predict": [[87, 92], ["baseline_model_wrappers.LinearAutoRegressiveModel.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Predict from high fidelity\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.LinearAutoRegressiveModel.optimize": [[93, 101], ["_log.info", "baseline_model_wrappers.LinearAutoRegressiveModel.model.optimize", "baseline_model_wrappers.LinearAutoRegressiveModel.model.gpy_model.mixed_noise.Gaussian_noise.unfix", "baseline_model_wrappers.LinearAutoRegressiveModel.model.gpy_model.mixed_noise.Gaussian_noise_1.unfix", "baseline_model_wrappers.LinearAutoRegressiveModel.model.optimize", "baseline_model_wrappers.LinearAutoRegressiveModel.model.gpy_model.mixed_noise.Gaussian_noise_2.unfix"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "_log", ".", "info", "(", "\"\\n--- Optimization: ---\\n\"", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "self", ".", "model", ".", "optimize", "(", ")", "\n", "self", ".", "model", ".", "gpy_model", ".", "mixed_noise", ".", "Gaussian_noise", ".", "unfix", "(", ")", "\n", "self", ".", "model", ".", "gpy_model", ".", "mixed_noise", ".", "Gaussian_noise_1", ".", "unfix", "(", ")", "\n", "if", "self", ".", "n_fidelities", "==", "3", ":", "\n", "            ", "self", ".", "model", ".", "gpy_model", ".", "mixed_noise", ".", "Gaussian_noise_2", ".", "unfix", "(", ")", "\n", "", "self", ".", "model", ".", "optimize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.LinearAutoRegressiveModel.set_data": [[102, 104], ["NotImplementedError"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.LinearAutoRegressiveModel.X": [[105, 108], ["NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.LinearAutoRegressiveModel.Y": [[109, 112], ["NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.NonLinearAutoRegressiveModel.__init__": [[119, 127], ["multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays", "multi_fidelity.models.non_linear_multi_fidelity_model.make_non_linear_kernels", "multi_fidelity.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_xy_lists_to_arrays", "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.make_non_linear_kernels"], ["def", "__init__", "(", "self", ",", "X", ",", "Y", ",", "n_restarts", "=", "10", ")", ":", "\n", "        ", "x_train", ",", "y_train", "=", "convert_xy_lists_to_arrays", "(", "X", ",", "Y", ")", "\n", "base_kernel", "=", "GPy", ".", "kern", ".", "RBF", "\n", "kernels", "=", "make_non_linear_kernels", "(", "base_kernel", ",", "len", "(", "X", ")", ",", "x_train", ".", "shape", "[", "1", "]", "-", "1", ",", "ARD", "=", "True", ")", "\n", "self", ".", "model", "=", "NonLinearMultiFidelityModel", "(", "\n", "x_train", ",", "y_train", ",", "n_fidelities", "=", "len", "(", "X", ")", ",", "kernels", "=", "kernels", ",", "verbose", "=", "True", ",", "optimization_restarts", "=", "n_restarts", "\n", ")", "\n", "self", ".", "name", "=", "\"nargp\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.NonLinearAutoRegressiveModel.predict": [[128, 133], ["baseline_model_wrappers.NonLinearAutoRegressiveModel.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Predict from high fidelity\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.NonLinearAutoRegressiveModel.optimize": [[134, 137], ["_log.info", "baseline_model_wrappers.NonLinearAutoRegressiveModel.model.optimize"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "_log", ".", "info", "(", "\"\\n--- Optimization: ---\\n\"", ".", "format", "(", "self", ".", "name", ")", ")", "\n", "self", ".", "model", ".", "optimize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.NonLinearAutoRegressiveModel.set_data": [[138, 140], ["NotImplementedError"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.NonLinearAutoRegressiveModel.X": [[141, 144], ["NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity_dgp.baseline_model_wrappers.NonLinearAutoRegressiveModel.Y": [[145, 148], ["NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.plot_control.__init__": [[167, 170], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "velocity_emulator", ",", "fidelity", "=", "\"single\"", ")", ":", "\n", "        ", "self", ".", "velocity_emulator", "=", "velocity_emulator", "\n", "self", ".", "fidelity", "=", "fidelity", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.plot_control.plot_slices": [[171, 208], ["numpy.linspace", "numpy.linspace", "numpy.meshgrid", "range", "mountain_car.evaluate_model", "numpy.zeros", "range", "matplotlib.subplots", "ax[].set_title", "ax[].contourf", "ax[].set_title", "ax[].contourf", "matplotlib.tight_layout", "ax[].set_xlabel", "ax[].set_xlabel", "ax[].set_ylabel", "numpy.ones", "len", "x_contour_grid[].flatten", "mountain_car.v_simulation", "numpy.reshape", "numpy.reshape"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.evaluate_model", "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.v_simulation"], ["", "def", "plot_slices", "(", "self", ",", "control", ")", ":", "\n", "        ", "n_points_contour", "=", "50", "\n", "position_contour", "=", "np", ".", "linspace", "(", "-", "1.2", ",", "0.6", ",", "n_points_contour", ")", "\n", "velocity_contour", "=", "np", ".", "linspace", "(", "-", "1", "/", "0.07", ",", "1", "/", "0.07", ",", "n_points_contour", ")", "\n", "x_contour_grid", "=", "np", ".", "meshgrid", "(", "position_contour", ",", "velocity_contour", ")", "\n", "x_contour", "=", "np", ".", "ones", "(", "(", "n_points_contour", "**", "2", ",", "3", ")", ")", "*", "control", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "x_contour_grid", ")", ")", ":", "\n", "            ", "x_contour", "[", ":", ",", "i", "]", "=", "x_contour_grid", "[", "i", "]", ".", "flatten", "(", ")", "\n", "\n", "# evaluate emulator", "\n", "", "y_emulator", "=", "evaluate_model", "(", "self", ".", "velocity_emulator", ",", "x_contour", ",", "self", ".", "fidelity", ")", "\n", "\n", "# evaluate simulator", "\n", "y_simulator", "=", "np", ".", "zeros", "(", "x_contour", ".", "shape", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "x_contour", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "y_simulator", "[", "i", "]", "=", "v_simulation", "(", "x_contour", "[", "i", ",", ":", "]", ")", "\n", "\n", "# Do plots", "\n", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "2", ",", "figsize", "=", "(", "12", ",", "4", ")", ")", "\n", "ax", "[", "0", "]", ".", "set_title", "(", "\"Acceleration from Emulator\"", ")", "\n", "ax", "[", "0", "]", ".", "contourf", "(", "\n", "position_contour", ",", "\n", "velocity_contour", ",", "\n", "np", ".", "reshape", "(", "y_emulator", ",", "(", "n_points_contour", ",", "n_points_contour", ")", ")", ",", "\n", "cmap", "=", "cm", ".", "RdBu", ",", "\n", ")", "\n", "ax", "[", "1", "]", ".", "set_title", "(", "\"Acceleration from Simulator\"", ")", "\n", "ax", "[", "1", "]", ".", "contourf", "(", "\n", "position_contour", ",", "\n", "velocity_contour", ",", "\n", "np", ".", "reshape", "(", "y_simulator", ",", "(", "n_points_contour", ",", "n_points_contour", ")", ")", ",", "\n", "cmap", "=", "cm", ".", "RdBu", ",", "\n", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "ax", "[", "1", "]", ".", "set_xlabel", "(", "\"Car Position\"", ")", "\n", "ax", "[", "0", "]", ".", "set_xlabel", "(", "\"Car Position\"", ")", "\n", "ax", "[", "0", "]", ".", "set_ylabel", "(", "\"Car Velocity\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.display_frames_as_gif": [[11, 25], ["matplotlib.figure", "matplotlib.title", "matplotlib.imshow", "matplotlib.axis", "matplotlib.animation.FuncAnimation", "IPython.display.display", "plt.imshow.set_data", "matplotlib.gcf", "JSAnimation.IPython_display.display_animation", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["def", "display_frames_as_gif", "(", "frames", ",", "title", ")", ":", "\n", "    ", "\"\"\"\n    Displays a list of frames as a gif, with controls\n    \"\"\"", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "frames", "[", "0", "]", ".", "shape", "[", "1", "]", "/", "72.0", ",", "frames", "[", "0", "]", ".", "shape", "[", "0", "]", "/", "72.0", ")", ",", "dpi", "=", "72", ")", "\n", "plt", ".", "title", "(", "title", ")", "\n", "patch", "=", "plt", ".", "imshow", "(", "frames", "[", "0", "]", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "\n", "def", "animate", "(", "i", ")", ":", "\n", "        ", "patch", ".", "set_data", "(", "frames", "[", "i", "]", ")", "\n", "\n", "", "anim", "=", "animation", ".", "FuncAnimation", "(", "plt", ".", "gcf", "(", ")", ",", "animate", ",", "frames", "=", "len", "(", "frames", ")", ",", "interval", "=", "30", ")", "\n", "display", "(", "display_animation", "(", "anim", ",", "default_mode", "=", "\"loop\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.simulation": [[28, 43], ["numpy.clip", "numpy.clip", "numpy.cos"], "function", ["None"], ["", "def", "simulation", "(", "state", ")", ":", "\n", "    ", "power", "=", "0.0015", "\n", "max_speed", "=", "0.07", "\n", "min_position", "=", "-", "1.2", "\n", "max_position", "=", "0.6", "\n", "position", "=", "state", "[", "0", "]", "\n", "velocity", "=", "state", "[", "1", "]", "\n", "action", "=", "state", "[", "2", "]", "\n", "new_velocity", "=", "velocity", "+", "power", "*", "action", "-", "0.0025", "*", "np", ".", "cos", "(", "3", "*", "position", ")", "\n", "new_velocity", "=", "np", ".", "clip", "(", "new_velocity", ",", "-", "max_speed", ",", "max_speed", ")", "\n", "d_velocity", "=", "new_velocity", "-", "velocity", "\n", "new_position", "=", "position", "+", "new_velocity", "\n", "new_position", "=", "np", ".", "clip", "(", "new_position", ",", "min_position", ",", "max_position", ")", "\n", "d_position", "=", "new_position", "-", "position", "\n", "return", "d_position", ",", "d_velocity", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.low_cost_simulation": [[46, 54], ["numpy.cos"], "function", ["None"], ["", "def", "low_cost_simulation", "(", "state", ")", ":", "\n", "# A corrupted version of the function above", "\n", "    ", "power", "=", "0.002", "\n", "position", "=", "state", "[", "0", "]", "\n", "action", "=", "state", "[", "2", "]", "\n", "d_velocity", "=", "power", "*", "action", "-", "0.004", "*", "(", "np", ".", "cos", "(", "3.3", "*", "position", "-", "0.3", ")", ")", "**", "2", "-", "0.001", "\n", "d_position", "=", "d_velocity", "\n", "return", "d_position", ",", "d_velocity", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.plot_emu_sim_comparison": [[56, 78], ["mountain_car.run_simulation", "mountain_car.run_emulation", "matplotlib.subplots", "axarr[].plot", "axarr[].plot", "axarr[].set_title", "axarr[].plot", "axarr[].plot", "axarr[].set_title", "axarr[].plot", "axarr[].plot", "axarr[].set_title", "f.legend", "matplotlib.tight_layout", "matplotlib.show", "state_trajectory[].copy"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.run_simulation", "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.run_emulation"], ["", "def", "plot_emu_sim_comparison", "(", "env", ",", "control_params", ",", "emulator", ",", "fidelity", "=", "\"single\"", ")", ":", "\n", "    ", "reward", ",", "state_trajectory", ",", "control_inputs", ",", "_", "=", "run_simulation", "(", "env", ",", "control_params", ")", "\n", "\n", "reward_emu", ",", "state_trajectory_emu_mean", ",", "control_inputs_emu_mean", "=", "run_emulation", "(", "\n", "emulator", ",", "control_params", ",", "state_trajectory", "[", "0", ",", ":", "]", ".", "copy", "(", ")", ",", "fidelity", "=", "fidelity", "\n", ")", "\n", "\n", "f", ",", "axarr", "=", "plt", ".", "subplots", "(", "1", ",", "3", ",", "figsize", "=", "(", "10", ",", "3", ")", ")", "\n", "(", "h1", ",", ")", "=", "axarr", "[", "0", "]", ".", "plot", "(", "state_trajectory_emu_mean", "[", ":", ",", "0", "]", ")", "\n", "\n", "(", "h2", ",", ")", "=", "axarr", "[", "0", "]", ".", "plot", "(", "state_trajectory", "[", ":", ",", "0", "]", ")", "\n", "axarr", "[", "0", "]", ".", "set_title", "(", "\"Position\"", ")", "\n", "axarr", "[", "1", "]", ".", "plot", "(", "state_trajectory_emu_mean", "[", ":", ",", "1", "]", ")", "\n", "axarr", "[", "1", "]", ".", "plot", "(", "state_trajectory", "[", ":", ",", "1", "]", ")", "\n", "axarr", "[", "1", "]", ".", "set_title", "(", "\"Velocity\"", ")", "\n", "\n", "axarr", "[", "2", "]", ".", "plot", "(", "control_inputs_emu_mean", ")", "\n", "axarr", "[", "2", "]", ".", "plot", "(", "control_inputs", ")", "\n", "axarr", "[", "2", "]", ".", "set_title", "(", "\"Control Input\"", ")", "\n", "f", ".", "legend", "(", "[", "h1", ",", "h2", "]", ",", "[", "\"Emulation\"", ",", "\"Simulation\"", "]", ",", "loc", "=", "4", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.run_simulation": [[80, 105], ["env.seed", "env.reset", "numpy.ndarray", "numpy.ndarray", "range", "mountain_car.calculate_linear_control", "numpy.concatenate", "numpy.concatenate", "env.step", "frames.append", "numpy.concatenate", "env.render"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset", "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.calculate_linear_control"], ["", "def", "run_simulation", "(", "env", ",", "controller_gains", ",", "render", "=", "False", ")", ":", "\n", "# Reset environment to starting point", "\n", "    ", "env", ".", "seed", "(", "0", ")", "\n", "observation", "=", "env", ".", "reset", "(", ")", "\n", "\n", "# Initialize matrices to store state + control inputs", "\n", "state_trajectory", "=", "np", ".", "ndarray", "(", "(", "0", ",", "observation", ".", "shape", "[", "0", "]", ")", ")", "\n", "control_inputs", "=", "np", ".", "ndarray", "(", "(", "0", ",", "env", ".", "action_space", ".", "shape", "[", "0", "]", ")", ")", "\n", "frames", "=", "[", "]", "\n", "cost", "=", "0", "\n", "for", "i", "in", "range", "(", "0", ",", "N_STEPS_MAX", ")", ":", "\n", "# Calculate control input", "\n", "        ", "control_input", "=", "calculate_linear_control", "(", "observation", ",", "controller_gains", ")", "\n", "if", "render", ":", "\n", "            ", "frames", ".", "append", "(", "env", ".", "render", "(", "mode", "=", "\"rgb_array\"", ")", ")", "\n", "# Save current state + control", "\n", "", "state_trajectory", "=", "np", ".", "concatenate", "(", "[", "state_trajectory", ",", "observation", "[", "np", ".", "newaxis", ",", ":", "]", "]", ",", "axis", "=", "0", ")", "\n", "control_inputs", "=", "np", ".", "concatenate", "(", "[", "control_inputs", ",", "control_input", "[", "np", ".", "newaxis", ",", ":", "]", "]", ")", "\n", "\n", "observation", ",", "reward", ",", "done", ",", "info", "=", "env", ".", "step", "(", "control_input", ")", "\n", "cost", "-=", "reward", "-", "1", "\n", "if", "done", ":", "\n", "            ", "state_trajectory", "=", "np", ".", "concatenate", "(", "[", "state_trajectory", ",", "observation", "[", "np", ".", "newaxis", ",", ":", "]", "]", ",", "axis", "=", "0", ")", "\n", "return", "cost", ",", "state_trajectory", ",", "control_inputs", ",", "frames", "\n", "", "", "return", "cost", ",", "state_trajectory", ",", "control_inputs", ",", "frames", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.run_emulation": [[107, 133], ["X_0.copy", "range", "numpy.ndarray", "numpy.ndarray", "mountain_car.calculate_linear_control", "numpy.concatenate", "numpy.concatenate", "mountain_car.evaluate_model", "mountain_car.evaluate_model", "numpy.hstack", "numpy.concatenate", "numpy.power"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.calculate_linear_control", "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.evaluate_model", "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.evaluate_model"], ["", "def", "run_emulation", "(", "dynamics_models", ",", "controller_gains", ",", "X_0", ",", "fidelity", "=", "\"single\"", ")", ":", "\n", "    ", "observation", "=", "X_0", ".", "copy", "(", ")", "\n", "state_trajectory", "=", "np", ".", "ndarray", "(", "(", "0", ",", "observation", ".", "shape", "[", "0", "]", ")", ")", "*", "np", ".", "nan", "\n", "control_inputs", "=", "np", ".", "ndarray", "(", "(", "0", ",", "1", ")", ")", "*", "np", ".", "nan", "\n", "cost", "=", "0", "\n", "\n", "for", "_", "in", "range", "(", "0", ",", "N_STEPS_MAX", ")", ":", "\n", "# Evaluate controller", "\n", "        ", "control_input", "=", "calculate_linear_control", "(", "observation", ",", "controller_gains", ")", "\n", "cost", "+=", "np", ".", "power", "(", "control_input", "[", "0", "]", ",", "2", ")", "*", "0.1", "+", "1", "\n", "\n", "# Store state + control", "\n", "state_trajectory", "=", "np", ".", "concatenate", "(", "[", "state_trajectory", ",", "observation", "[", "np", ".", "newaxis", ",", ":", "]", "]", ",", "axis", "=", "0", ")", "\n", "control_inputs", "=", "np", ".", "concatenate", "(", "[", "control_inputs", ",", "control_input", "[", "np", ".", "newaxis", ",", ":", "]", "]", ")", "\n", "\n", "# Evaluate emulator", "\n", "gp_input", "=", "np", ".", "hstack", "(", "[", "observation", ",", "control_input", "]", ")", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "next_state_mean", "=", "evaluate_model", "(", "dynamics_models", "[", "0", "]", ",", "gp_input", ",", "fidelity", ")", "\n", "observation", "[", "0", "]", "+=", "next_state_mean", "\n", "next_state_mean", "=", "evaluate_model", "(", "dynamics_models", "[", "1", "]", ",", "gp_input", ",", "fidelity", ")", "\n", "observation", "[", "1", "]", "+=", "next_state_mean", "\n", "\n", "if", "observation", "[", "0", "]", ">", "0.45", ":", "\n", "            ", "state_trajectory", "=", "np", ".", "concatenate", "(", "[", "state_trajectory", ",", "observation", "[", "np", ".", "newaxis", ",", ":", "]", "]", ",", "axis", "=", "0", ")", "\n", "return", "cost", "-", "100", ",", "state_trajectory", ",", "control_inputs", "\n", "", "", "return", "cost", ",", "state_trajectory", ",", "control_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.calculate_linear_control": [[135, 138], ["numpy.clip", "numpy.dot"], "function", ["None"], ["", "def", "calculate_linear_control", "(", "state", ",", "gains", ")", ":", "\n", "    ", "control_input", "=", "(", "np", ".", "dot", "(", "gains", "[", "0", ",", "0", ":", "2", "]", ",", "state", ")", "+", "gains", "[", "0", ",", "2", "]", ")", "[", "np", ".", "newaxis", "]", "\n", "return", "np", ".", "clip", "(", "control_input", ",", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.add_data_to_gp": [[140, 145], ["numpy.concatenate", "numpy.concatenate", "gp_model.set_XY"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY"], ["", "def", "add_data_to_gp", "(", "gp_model", ",", "new_x", ",", "new_y", ")", ":", "\n", "    ", "all_X", "=", "np", ".", "concatenate", "(", "[", "gp_model", ".", "X", ",", "new_x", "]", ")", "\n", "all_y", "=", "np", ".", "concatenate", "(", "[", "gp_model", ".", "Y", ",", "new_y", "]", ")", "\n", "gp_model", ".", "set_XY", "(", "all_X", ",", "all_y", ")", "\n", "return", "gp_model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.make_gp_inputs": [[147, 151], ["numpy.concatenate", "numpy.diff"], "function", ["None"], ["", "def", "make_gp_inputs", "(", "control_inputs", ",", "state_trajectory", ")", ":", "\n", "    ", "X", "=", "np", ".", "concatenate", "(", "[", "state_trajectory", "[", ":", "-", "1", ",", ":", "]", ",", "control_inputs", "]", ",", "axis", "=", "1", ")", "\n", "y", "=", "np", ".", "diff", "(", "state_trajectory", ",", "axis", "=", "0", ")", "\n", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.v_simulation": [[153, 164], ["state.copy().flatten.copy().flatten", "numpy.clip", "numpy.asarray", "state.copy().flatten.copy", "numpy.cos"], "function", ["None"], ["", "def", "v_simulation", "(", "state", ")", ":", "\n", "    ", "state", "=", "state", ".", "copy", "(", ")", ".", "flatten", "(", ")", "\n", "power", "=", "0.0015", "\n", "max_speed", "=", "0.07", "\n", "position", "=", "state", "[", "0", "]", "\n", "velocity", "=", "state", "[", "1", "]", "\n", "action", "=", "state", "[", "2", "]", "\n", "new_velocity", "=", "velocity", "+", "power", "*", "action", "-", "0.0025", "*", "np", ".", "cos", "(", "3", "*", "position", ")", "\n", "new_velocity", "=", "np", ".", "clip", "(", "new_velocity", ",", "-", "max_speed", ",", "max_speed", ")", "\n", "d_velocity", "=", "new_velocity", "-", "velocity", "\n", "return", "np", ".", "asarray", "(", "[", "d_velocity", "]", ")", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.emulation_mountain_car_simulator.mountain_car.evaluate_model": [[210, 220], ["model.predict", "numpy.hstack", "ValueError", "model.predict", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "", "def", "evaluate_model", "(", "model", ",", "x", ",", "fidelity", ")", ":", "\n", "# Evaluate emulator", "\n", "    ", "if", "fidelity", "==", "\"single\"", ":", "\n", "        ", "y", "=", "model", ".", "predict", "(", "x", ")", "[", "0", "]", "\n", "", "elif", "fidelity", "==", "\"multi-linear\"", ":", "\n", "        ", "x_extended", "=", "np", ".", "hstack", "(", "[", "x", ",", "np", ".", "ones", "(", "[", "x", ".", "shape", "[", "0", "]", ",", "1", "]", ")", "]", ")", "\n", "y", "=", "model", ".", "predict", "(", "x_extended", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown fidelity\"", ")", "\n", "", "return", "y", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.models.random_forest.RandomForest.__init__": [[23, 50], ["core.interfaces.models.IModel.__init__", "RandomForestRegressor", "random_forest.RandomForest.rf.fit"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "X_init", ":", "np", ".", "ndarray", ",", "\n", "Y_init", ":", "np", ".", "ndarray", ",", "\n", "num_trees", ":", "int", "=", "30", ",", "\n", "do_bootstrapping", ":", "bool", "=", "True", ",", "\n", "seed", ":", "int", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Interface to random forests for Bayesian optimization based on Scikit Learn package.\n\n        Dependencies:\n            Scikit Learn (http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html)\n\n        :param X_init: Initial input data points to train the model\n        :param Y_init: Initial target values\n        :param num_trees: Specifies the number of trees to build the random forest\n        :param do_bootstrapping: Defines if we use boostrapping for the individual trees or not\n        :param seed: Used to seed the random number generator for the random forest (None means random seed)\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "_X", "=", "X_init", "\n", "self", ".", "_Y", "=", "Y_init", "\n", "\n", "self", ".", "rf", "=", "RandomForestRegressor", "(", "n_estimators", "=", "num_trees", ",", "bootstrap", "=", "do_bootstrapping", ",", "random_state", "=", "seed", ")", "\n", "self", ".", "rf", ".", "fit", "(", "X_init", ",", "Y_init", "[", ":", ",", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.random_forest.RandomForest.predict": [[51, 66], ["estimator.predict", "preds.append", "numpy.array().mean", "numpy.array().var", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Predict values for given points\n\n        :param X: points to run prediction for\n        :return: Tuple of mean and variance which are 2d arrays of shape (n_points x n_outputs)\n        \"\"\"", "\n", "\n", "preds", "=", "[", "]", "\n", "for", "estimator", "in", "self", ".", "rf", ".", "estimators_", ":", "\n", "            ", "pred", "=", "estimator", ".", "predict", "(", "X", ")", "\n", "preds", ".", "append", "(", "pred", ")", "\n", "", "mean", "=", "np", ".", "array", "(", "preds", ")", ".", "mean", "(", "axis", "=", "0", ")", "[", ":", ",", "None", "]", "\n", "var", "=", "np", ".", "array", "(", "preds", ")", ".", "var", "(", "axis", "=", "0", ")", "[", ":", ",", "None", "]", "\n", "return", "mean", ",", "var", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.random_forest.RandomForest.set_data": [[67, 78], ["random_forest.RandomForest.rf.fit"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Sets training data in model\n\n        :param X: new points\n        :param Y: function values at new points X\n        \"\"\"", "\n", "self", ".", "_X", "=", "X", "\n", "self", ".", "_Y", "=", "Y", "\n", "\n", "self", ".", "rf", ".", "fit", "(", "X", ",", "Y", "[", ":", ",", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.random_forest.RandomForest.optimize": [[79, 81], ["None"], "methods", ["None"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.random_forest.RandomForest.get_f_minimum": [[82, 85], ["numpy.min"], "methods", ["None"], ["", "def", "get_f_minimum", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the minimum value that has been observed\"\"\"", "\n", "return", "np", ".", "min", "(", "self", ".", "_Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.random_forest.RandomForest.X": [[86, 89], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.random_forest.RandomForest.Y": [[90, 93], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_Y", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.Bohamiann.__init__": [[50, 97], ["core.interfaces.models.IModel.__init__", "bohamiann.Bohamiann", "bohamiann.Bohamiann.model.train"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "X_init", ":", "np", ".", "ndarray", ",", "\n", "Y_init", ":", "np", ".", "ndarray", ",", "\n", "num_steps", ":", "int", "=", "5000", ",", "\n", "num_burnin", ":", "int", "=", "5000", ",", "\n", "lr", ":", "float", "=", "1e-2", ",", "\n", "get_architecture", "=", "get_default_network", ",", "\n", "**", "kwargs", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Implements Bayesian neural networks as described by Springenberg et. al[1] based on\n        stochastic gradient Hamiltonian monte carlo sampling[2].\n\n        Dependencies:\n            AutoML pybnn (https://github.com/automl/pybnn)\n\n        [1] J. T. Springenberg, A. Klein, S. Falkner, F. Hutter\n            Bayesian Optimization with Robust Bayesian Neural Networks.\n            In Advances in Neural Information Processing Systems 29 (2016).\n        [2] T. Chen, E. B. Fox, C. Guestrin\n            Stochastic Gradient Hamiltonian Monte Carlo\n            Proceedings of the 31st International Conference on Machine Learning\n\n        :param X_init: training data points\n        :param Y_init: training function values\n        :param num_steps: number of MCMC steps (after the burnin)\n        :param num_burnin: number of burnin steps\n        :param lr: learning rate or step length of the MCMC sampler\n        :param get_architecture: function handle that returns an architecture for the Bayesian neural network\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "model", "=", "bohamiann", ".", "Bohamiann", "(", "get_network", "=", "get_architecture", ")", "\n", "self", ".", "num_steps", "=", "num_steps", "\n", "self", ".", "num_burnin", "=", "num_burnin", "\n", "self", ".", "_X", "=", "X_init", "\n", "self", ".", "_Y", "=", "Y_init", "\n", "\n", "self", ".", "model", ".", "train", "(", "\n", "X_init", ",", "\n", "Y_init", ",", "\n", "num_steps", "=", "self", ".", "num_steps", "+", "self", ".", "num_burnin", ",", "\n", "lr", "=", "lr", ",", "\n", "num_burn_in_steps", "=", "self", ".", "num_burnin", ",", "\n", "keep_every", "=", "100", ",", "\n", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.Bohamiann.X": [[99, 102], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.Bohamiann.Y": [[103, 106], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.Bohamiann.predict": [[107, 116], ["bohamiann.Bohamiann.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Predict values for given points\n\n        :param X: points to run prediction for\n        \"\"\"", "\n", "m", ",", "v", "=", "self", ".", "model", ".", "predict", "(", "X", ")", "\n", "\n", "return", "m", "[", ":", ",", "None", "]", ",", "v", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.Bohamiann.set_data": [[117, 129], ["bohamiann.Bohamiann.model.train"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Sets training data in model\n\n        :param X: new points\n        :param Y: function values at new points X\n        \"\"\"", "\n", "self", ".", "_X", "=", "X", "\n", "self", ".", "_Y", "=", "Y", "\n", "\n", "self", ".", "model", ".", "train", "(", "\n", "self", ".", "_X", ",", "self", ".", "_Y", ",", "num_steps", "=", "self", ".", "num_steps", ",", "num_burn_in_steps", "=", "self", ".", "num_burnin", ",", "keep_every", "=", "100", ",", "verbose", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.Bohamiann.optimize": [[131, 133], ["None"], "methods", ["None"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.Bohamiann.get_f_minimum": [[134, 136], ["numpy.min"], "methods", ["None"], ["", "def", "get_f_minimum", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "min", "(", "self", ".", "_Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.Bohamiann.get_prediction_gradients": [[137, 147], ["numpy.array", "numpy.array", "bohamiann.Bohamiann.model.predictive_mean_gradient", "bohamiann.Bohamiann.model.predictive_variance_gradient"], "methods", ["None"], ["", "def", "get_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes and returns model gradients at given points\n\n        :param X: points to compute gradients at\n        \"\"\"", "\n", "dm", "=", "np", ".", "array", "(", "[", "self", ".", "model", ".", "predictive_mean_gradient", "(", "xi", ")", "for", "xi", "in", "X", "]", ")", "\n", "dv", "=", "np", ".", "array", "(", "[", "self", ".", "model", ".", "predictive_variance_gradient", "(", "xi", ")", "for", "xi", "in", "X", "]", ")", "\n", "\n", "return", "dm", ",", "dv", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.models.bohamiann.get_default_network": [[25, 47], ["torch.Sequential().apply", "super().__init__", "torch.cat", "torch.cat", "type", "torch.init.constant_", "torch.Sequential", "torch.Parameter", "bohamiann..register_parameter", "type", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.Linear", "torch.Tanh", "torch.Linear", "torch.Tanh", "torch.Linear", "AppendLayer", "torch.Tensor", "torch.Tensor", "numpy.log", "torch.ones_like", "torch.ones_like"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "get_default_network", "(", "input_dimensionality", ":", "int", ")", "->", "torch", ".", "nn", ".", "Module", ":", "\n", "    ", "class", "AppendLayer", "(", "nn", ".", "Module", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "bias", "=", "True", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "if", "bias", ":", "\n", "                ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "register_parameter", "(", "\"bias\"", ",", "None", ")", "\n", "\n", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "            ", "return", "torch", ".", "cat", "(", "(", "x", ",", "self", ".", "bias", "*", "torch", ".", "ones_like", "(", "x", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "", "def", "init_weights", "(", "module", ")", ":", "\n", "        ", "if", "type", "(", "module", ")", "==", "AppendLayer", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "val", "=", "np", ".", "log", "(", "1e-3", ")", ")", "\n", "", "elif", "type", "(", "module", ")", "==", "nn", ".", "Linear", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "module", ".", "weight", ",", "mode", "=", "\"fan_in\"", ",", "nonlinearity", "=", "\"linear\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "val", "=", "0.0", ")", "\n", "\n", "", "", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "input_dimensionality", ",", "50", ")", ",", "nn", ".", "Tanh", "(", ")", ",", "nn", ".", "Linear", "(", "50", ",", "50", ")", ",", "nn", ".", "Tanh", "(", ")", ",", "nn", ".", "Linear", "(", "50", ",", "1", ")", ",", "AppendLayer", "(", ")", "\n", ")", ".", "apply", "(", "init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.linear_model.GPyLinearMultiFidelityModel.__init__": [[18, 59], ["numpy.any", "super().__init__", "isinstance", "ValueError", "isinstance", "ValueError", "ValueError", "ValueError", "ValueError", "GPy.likelihoods.mixed_noise.MixedNoise", "X[].astype", "GPy.likelihoods.Gaussian", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "kernel", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "n_fidelities", ":", "int", ",", "\n", "likelihood", ":", "GPy", ".", "likelihoods", ".", "Likelihood", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n\n        :param X: Training data features with fidelity input appended as last column\n        :param Y: Training data targets\n        :param kernel: Multi-fidelity kernel\n        :param n_fidelities: Number of fidelities in problem\n        :param likelihood: GPy likelihood object.\n                           Defaults to MixedNoise which has different noise levels for each fidelity\n        \"\"\"", "\n", "\n", "# Input checks", "\n", "if", "not", "isinstance", "(", "X", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"X should be an array\"", ")", "\n", "\n", "", "if", "not", "isinstance", "(", "Y", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Y should be an array\"", ")", "\n", "\n", "", "if", "X", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"X should be 2d\"", ")", "\n", "\n", "", "if", "Y", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Y should be 2d\"", ")", "\n", "\n", "", "if", "np", ".", "any", "(", "X", "[", ":", ",", "-", "1", "]", ">=", "n_fidelities", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"One or more points has a higher fidelity index than number of fidelities\"", ")", "\n", "\n", "# Make default likelihood as different noise for each fidelity", "\n", "", "if", "likelihood", "is", "None", ":", "\n", "            ", "likelihood", "=", "GPy", ".", "likelihoods", ".", "mixed_noise", ".", "MixedNoise", "(", "\n", "[", "GPy", ".", "likelihoods", ".", "Gaussian", "(", "variance", "=", "1.0", ")", "for", "_", "in", "range", "(", "n_fidelities", ")", "]", "\n", ")", "\n", "", "y_metadata", "=", "{", "\"output_index\"", ":", "X", "[", ":", ",", "-", "1", "]", ".", "astype", "(", "int", ")", "}", "\n", "super", "(", ")", ".", "__init__", "(", "X", ",", "Y", ",", "kernel", ",", "likelihood", ",", "Y_metadata", "=", "y_metadata", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.__init__": [[68, 129], ["non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models.append", "range", "isinstance", "TypeError", "isinstance", "TypeError", "numpy.random.randn", "GPy.models.GPRegression", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_deterministic", "numpy.concatenate", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models.append", "model.Gaussian_noise.fix", "GPy.models.GPRegression"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_deterministic"], ["def", "__init__", "(", "\n", "self", ",", "\n", "X_init", ":", "np", ".", "ndarray", ",", "\n", "Y_init", ":", "np", ".", "ndarray", ",", "\n", "n_fidelities", ",", "\n", "kernels", ":", "List", "[", "GPy", ".", "kern", ".", "Kern", "]", ",", "\n", "n_samples", "=", "100", ",", "\n", "verbose", "=", "False", ",", "\n", "optimization_restarts", "=", "5", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        By default the noise at intermediate levels will be fixed to 1e-4.\n\n        :param X_init: Initial X values.\n        :param Y_init: Initial Y values.\n        :param n_fidelities: Number of fidelities in problem.\n        :param kernels: List of kernels for each GP model at each fidelity. The first kernel should take input of\n                        dimension d_in and each subsequent kernel should take input of dimension (d_in+1) where d_in is\n                        the dimensionality of the features.\n        :param n_samples: Number of samples to use to do quasi-Monte-Carlo integration at each fidelity. Default 100\n        :param verbose: Whether to output messages during optimization. Defaults to False.\n        :param optimization_restarts: Number of random restarts\n                                      when optimizing the Gaussian processes' hyper-parameters.\n        \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "X_init", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"X_init expected to be a numpy array\"", ")", "\n", "\n", "", "if", "not", "isinstance", "(", "Y_init", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"Y_init expected to be a numpy array\"", ")", "\n", "\n", "", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "optimization_restarts", "=", "optimization_restarts", "\n", "\n", "self", ".", "n_fidelities", "=", "n_fidelities", "\n", "\n", "# Generate random numbers from standardized gaussian for monte-carlo integration", "\n", "self", ".", "monte_carlo_rand_numbers", "=", "np", ".", "random", ".", "randn", "(", "n_samples", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "# Make lowest fidelity model", "\n", "self", ".", "models", "=", "[", "]", "\n", "\n", "self", ".", "_fidelity_idx", "=", "-", "1", "\n", "\n", "is_lowest_fidelity", "=", "X_init", "[", ":", ",", "self", ".", "_fidelity_idx", "]", "==", "0", "\n", "self", ".", "models", ".", "append", "(", "\n", "GPy", ".", "models", ".", "GPRegression", "(", "X_init", "[", "is_lowest_fidelity", ",", ":", "-", "1", "]", ",", "Y_init", "[", "is_lowest_fidelity", ",", ":", "]", ",", "kernels", "[", "0", "]", ")", "\n", ")", "\n", "\n", "# Make models for fidelities but lowest fidelity", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "is_ith_fidelity", "=", "X_init", "[", ":", ",", "self", ".", "_fidelity_idx", "]", "==", "i", "\n", "# Append previous fidelity mean to X", "\n", "previous_mean", ",", "_", "=", "self", ".", "_predict_deterministic", "(", "X_init", "[", "is_ith_fidelity", ",", ":", "-", "1", "]", ",", "i", ")", "\n", "\n", "augmented_input", "=", "np", ".", "concatenate", "(", "[", "X_init", "[", "is_ith_fidelity", ",", ":", "-", "1", "]", ",", "previous_mean", "]", ",", "axis", "=", "1", ")", "\n", "self", ".", "models", ".", "append", "(", "GPy", ".", "models", ".", "GPRegression", "(", "augmented_input", ",", "Y_init", "[", "is_ith_fidelity", ",", ":", "]", ",", "kernels", "[", "i", "]", ")", ")", "\n", "\n", "# Fix noise parameters for all models except top fidelity", "\n", "", "for", "model", "in", "self", ".", "models", "[", ":", "-", "1", "]", ":", "\n", "            ", "model", ".", "Gaussian_noise", ".", "fix", "(", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.set_data": [[130, 148], ["non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].set_XY", "range", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_deterministic", "numpy.concatenate", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].set_XY"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY", "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_deterministic", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY"], ["", "", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Updates training data in the model.\n\n        :param X: New training features.\n        :param Y: New training targets.\n        \"\"\"", "\n", "is_lowest_fidelity", "=", "0", "==", "X", "[", ":", ",", "-", "1", "]", "\n", "X_low_fidelity", "=", "X", "[", "is_lowest_fidelity", ",", ":", "-", "1", "]", "\n", "Y_low_fidelity", "=", "Y", "[", "is_lowest_fidelity", ",", ":", "]", "\n", "self", ".", "models", "[", "0", "]", ".", "set_XY", "(", "X_low_fidelity", ",", "Y_low_fidelity", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "n_fidelities", ")", ":", "\n", "            ", "is_this_fidelity", "=", "i", "==", "X", "[", ":", ",", "-", "1", "]", "\n", "X_this_fidelity", "=", "X", "[", "is_this_fidelity", ",", ":", "-", "1", "]", "\n", "Y_this_fidelity", "=", "Y", "[", "is_this_fidelity", ",", ":", "]", "\n", "previous_mean", ",", "_", "=", "self", ".", "_predict_deterministic", "(", "X_this_fidelity", ",", "i", ")", "\n", "augmented_input", "=", "np", ".", "concatenate", "(", "[", "X_this_fidelity", ",", "previous_mean", "]", ",", "axis", "=", "1", ")", "\n", "self", ".", "models", "[", "i", "]", ".", "set_XY", "(", "augmented_input", ",", "Y_this_fidelity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.X": [[149, 159], ["convert_lists_to_array.convert_x_list_to_array", "x_list.append"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_x_list_to_array"], ["", "", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        :return: input array of size (n_points x n_inputs_dims) across every fidelity in original input domain meaning\n                 it excludes inputs to models that come from the output of the previous level\n        \"\"\"", "\n", "x_list", "=", "[", "self", ".", "models", "[", "0", "]", ".", "X", "]", "\n", "for", "model", "in", "self", ".", "models", "[", "1", ":", "]", ":", "\n", "            ", "x_list", ".", "append", "(", "model", ".", "X", "[", ":", ",", ":", "-", "1", "]", ")", "\n", "", "return", "convert_x_list_to_array", "(", "x_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.Y": [[160, 166], ["convert_lists_to_array.convert_y_list_to_array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.multi_fidelity.convert_lists_to_array.convert_y_list_to_array"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        :return: output array of size (n_points x n_outputs) across every fidelity level\n        \"\"\"", "\n", "return", "convert_y_list_to_array", "(", "[", "model", ".", "Y", "for", "model", "in", "self", ".", "models", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.n_samples": [[167, 170], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_samples", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "monte_carlo_rand_numbers", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.predict": [[171, 195], ["numpy.zeros", "numpy.zeros", "range", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_samples", "numpy.mean", "numpy.mean", "numpy.var"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_samples"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Predicts mean and variance at fidelity given by the last column of X\n\n        Note that the posterior isn't Gaussian and so this function doesn't tell us everything about our posterior\n        distribution.\n\n        :param X: Input locations with fidelity index appended.\n        :returns: mean and variance of posterior distribution at X.\n        \"\"\"", "\n", "\n", "fidelity", "=", "X", "[", ":", ",", "self", ".", "_fidelity_idx", "]", "\n", "\n", "# Do prediction 1 test point at a time", "\n", "variance", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "mean", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "sample_mean", ",", "sample_var", "=", "self", ".", "_predict_samples", "(", "X", "[", "[", "i", "]", ",", ":", "-", "1", "]", ",", "fidelity", "[", "i", "]", ")", "\n", "# Calculate total variance and mean from samples", "\n", "variance", "[", "i", ",", ":", "]", "=", "np", ".", "mean", "(", "sample_var", ")", "+", "np", ".", "var", "(", "sample_mean", ")", "\n", "mean", "[", "i", ",", ":", "]", "=", "np", ".", "mean", "(", "sample_mean", ")", "\n", "\n", "", "return", "mean", ",", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.get_prediction_gradients": [[196, 229], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.mean", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_samples_with_gradients", "numpy.mean", "numpy.mean", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_samples_with_gradients"], ["", "def", "get_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Predicts mean and variance and the gradients of the mean and variance with respect to X.\n\n        :param X: input location.\n        :returns: (mean, mean gradient, variance, variance gradient) Gradients will be shape (n_points x (d-1)) because\n                  we don't return the gradient with respect to the fidelity index.\n        \"\"\"", "\n", "\n", "fidelity", "=", "X", "[", ":", ",", "self", ".", "_fidelity_idx", "]", "\n", "\n", "# Initialise vectors", "\n", "sample_mean", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_samples", "**", "(", "self", ".", "n_fidelities", "-", "1", ")", ",", "X", ".", "shape", "[", "0", "]", ")", ")", "\n", "d_sample_mean_dx", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_samples", "**", "(", "self", ".", "n_fidelities", "-", "1", ")", ",", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "1", "]", "-", "1", ")", ")", "\n", "d_sample_var_dx", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_samples", "**", "(", "self", ".", "n_fidelities", "-", "1", ")", ",", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "1", "]", "-", "1", ")", ")", "\n", "\n", "# Iteratively obtain predictions and associated gradients for each input point", "\n", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "mean", ",", "dmean_dx", ",", "var", ",", "dvar_dx", "=", "self", ".", "_predict_samples_with_gradients", "(", "X", "[", "[", "i", "]", ",", ":", "-", "1", "]", ",", "fidelity", "[", "i", "]", ")", "\n", "# Assign to outputs", "\n", "sample_mean", "[", ":", ",", "[", "i", "]", "]", "=", "mean", "\n", "d_sample_mean_dx", "[", ":", ",", "i", ",", ":", "]", "=", "dmean_dx", "\n", "d_sample_var_dx", "[", ":", ",", "i", ",", ":", "]", "=", "dvar_dx", "\n", "\n", "# Calculate means + total variance", "\n", "", "total_mean", "=", "np", ".", "mean", "(", "sample_mean", ",", "axis", "=", "0", ",", "keepdims", "=", "True", ")", ".", "T", "\n", "total_mean_grad", "=", "np", ".", "mean", "(", "d_sample_mean_dx", ",", "axis", "=", "0", ")", "\n", "\n", "# Calculate total variance derivative", "\n", "tmp", "=", "2", "*", "np", ".", "mean", "(", "d_sample_mean_dx", "*", "sample_mean", "[", ":", ",", ":", ",", "None", "]", ",", "axis", "=", "0", ")", "\n", "total_variance_grad", "=", "np", ".", "mean", "(", "d_sample_var_dx", ",", "axis", "=", "0", ")", "+", "tmp", "-", "2", "*", "total_mean", "*", "total_mean_grad", "\n", "\n", "return", "total_mean_grad", ",", "total_variance_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_samples": [[230, 248], ["int", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].predict", "range", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._propagate_samples_through_level"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._propagate_samples_through_level"], ["", "def", "_predict_samples", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "fidelity", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Draw samples from model at given fidelity. Returns samples of mean and variance at specified fidelity.\n        :param X: Input array without output of previous layer appended.\n        :param fidelity: zero based fidelity index.\n        :returns sample_mean, sample_variance: mean and variance predictions at input points.\n        \"\"\"", "\n", "\n", "fidelity", "=", "int", "(", "fidelity", ")", "\n", "\n", "# Predict at first fidelity", "\n", "sample_mean", ",", "sample_variance", "=", "self", ".", "models", "[", "0", "]", ".", "predict", "(", "X", ")", "\n", "\n", "# Predict at all fidelities up until the one we are interested in", "\n", "for", "i", "in", "range", "(", "1", ",", "fidelity", "+", "1", ")", ":", "\n", "# Draw samples from posterior of previous fidelity", "\n", "            ", "sample_mean", ",", "sample_variance", ",", "_", "=", "self", ".", "_propagate_samples_through_level", "(", "X", ",", "i", ",", "sample_mean", ",", "sample_variance", ")", "\n", "", "return", "sample_mean", ",", "sample_variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_samples_with_gradients": [[249, 278], ["int", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].predictive_gradients", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].predict", "range", "sample_variance.copy", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._propagate_samples_through_level", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._propagate_samples_through_level_gradient"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._propagate_samples_through_level", "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._propagate_samples_through_level_gradient"], ["", "def", "_predict_samples_with_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "fidelity", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Draw samples of mean and variance from model at given fidelity and the gradients of these samples wrt X.\n\n        We calculate the gradients by applying the chain rule as the gradients of each Gaussian process is known wrt\n        its inputs.\n\n        :param X: Input array without output of previous layer appended.\n        :param fidelity: zero based fidelity index.\n        :returns mean, mean gradient, variance, variance gradient: mean and variance predictions at input points.\n        \"\"\"", "\n", "\n", "fidelity", "=", "int", "(", "fidelity", ")", "\n", "\n", "# Predict at first fidelity", "\n", "dsample_mean_dx", ",", "dsample_var_dx", "=", "self", ".", "models", "[", "0", "]", ".", "predictive_gradients", "(", "X", ")", "\n", "dsample_mean_dx", "=", "dsample_mean_dx", "[", ":", ",", ":", ",", "0", "]", "\n", "sample_mean", ",", "sample_variance", "=", "self", ".", "models", "[", "0", "]", ".", "predict", "(", "X", ")", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "fidelity", "+", "1", ")", ":", "\n", "            ", "previous_sample_variance", "=", "sample_variance", ".", "copy", "(", ")", "\n", "# Predict at all fidelities up until the one we are interested in", "\n", "sample_mean", ",", "sample_variance", ",", "x_augmented", "=", "self", ".", "_propagate_samples_through_level", "(", "\n", "X", ",", "i", ",", "sample_mean", ",", "sample_variance", "\n", ")", "\n", "dsample_mean_dx", ",", "dsample_var_dx", "=", "self", ".", "_propagate_samples_through_level_gradient", "(", "\n", "dsample_mean_dx", ",", "dsample_var_dx", ",", "i", ",", "previous_sample_variance", ",", "x_augmented", "\n", ")", "\n", "", "return", "sample_mean", ",", "dsample_mean_dx", ",", "sample_variance", ",", "dsample_var_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._propagate_samples_through_level": [[279, 298], ["numpy.repeat", "numpy.concatenate", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].predict", "samples.flatten", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "_propagate_samples_through_level", "(", "self", ",", "X", ",", "i_level", ",", "sample_mean", ",", "sample_variance", ")", ":", "\n", "        ", "\"\"\"\n        Sample from the posterior of level i - 1 and propagates these samples through level i.\n\n        :param X: Input array without output of previous layer appended.\n        :param i_level: level to push through\n        :param sample_mean: mean from previous level\n        :param sample_variance: variance from previous level\n        \"\"\"", "\n", "# Draw samples from posterior of previous fidelity", "\n", "samples", "=", "self", ".", "monte_carlo_rand_numbers", "*", "np", ".", "sqrt", "(", "sample_variance", ")", "+", "sample_mean", ".", "T", "\n", "samples", "=", "samples", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "# Create inputs for each sample", "\n", "x_repeat", "=", "np", ".", "repeat", "(", "X", ",", "self", ".", "n_samples", "**", "i_level", ",", "axis", "=", "0", ")", "\n", "# Augment input with mean of previous fidelity", "\n", "x_augmented", "=", "np", ".", "concatenate", "(", "[", "x_repeat", ",", "samples", "]", ",", "axis", "=", "1", ")", "\n", "# Predict mean and variance and fidelity i", "\n", "sample_mean", ",", "sample_variance", "=", "self", ".", "models", "[", "i_level", "]", ".", "predict", "(", "x_augmented", ")", "\n", "return", "sample_mean", ",", "sample_variance", ",", "x_augmented", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._propagate_samples_through_level_gradient": [[299, 330], ["numpy.clip", "numpy.reshape", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].predictive_gradients", "numpy.sqrt"], "methods", ["None"], ["", "def", "_propagate_samples_through_level_gradient", "(", "\n", "self", ",", "dsample_mean_dx", ",", "dsample_var_dx", ",", "i_fidelity", ",", "sample_variance", ",", "x_augmented", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Calculates gradients of sample mean and variance with respect to X when propagated through a level\n\n        :param dsample_mean_dx: Gradients of mean prediction of samples from previous level\n        :param dsample_var_dx: Gradients of variance prediction of samples from previous level\n        :param i_fidelity: level index\n        :param sample_variance: The variance prediction of the samples from the previous level\n        :param x_augmented: The X input for this level augmented with the outputs\n                            from the previous level as the final column\n        \"\"\"", "\n", "# Convert variance derivative to std derivative", "\n", "clipped_var", "=", "np", ".", "clip", "(", "sample_variance", ",", "1e-10", ",", "np", ".", "inf", ")", "\n", "dsample_std_dx", "=", "dsample_var_dx", "/", "(", "2", "*", "np", ".", "sqrt", "(", "clipped_var", ")", ")", "\n", "# Calculate gradients of samples wrt x", "\n", "# This calculates a (n_samples**(i-1), n_samples, n_dims) matrix", "\n", "tmp", "=", "self", ".", "monte_carlo_rand_numbers", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", "*", "dsample_std_dx", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", "\n", "dsamples_dx", "=", "dsample_mean_dx", "[", "np", ".", "newaxis", ",", ":", ",", ":", "]", "+", "tmp", "\n", "dsamples_dx_reshaped", "=", "np", ".", "reshape", "(", "dsamples_dx", ",", "(", "self", ".", "n_samples", "**", "i_fidelity", ",", "dsample_std_dx", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "# Get partial derivatives of mean and variance with respect to", "\n", "# both X and output of previous fidelity", "\n", "dmean_dx", ",", "dvar_dx", "=", "self", ".", "models", "[", "i_fidelity", "]", ".", "predictive_gradients", "(", "x_augmented", ")", "\n", "dmean_dx", "=", "dmean_dx", "[", ":", ",", ":", ",", "0", "]", "\n", "\n", "# Combine partial derivatives to get full derivative wrt X", "\n", "dsample_mean_dx", "=", "dmean_dx", "[", ":", ",", ":", "-", "1", "]", "+", "dmean_dx", "[", ":", ",", "[", "-", "1", "]", "]", "*", "dsamples_dx_reshaped", "\n", "dsample_var_dx", "=", "dvar_dx", "[", ":", ",", ":", "-", "1", "]", "+", "dvar_dx", "[", ":", ",", "[", "-", "1", "]", "]", "*", "dsamples_dx_reshaped", "\n", "return", "dsample_mean_dx", ",", "dsample_var_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.optimize": [[331, 349], ["non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].optimize_restarts", "range", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_deterministic", "numpy.concatenate", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].set_X", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].optimize_restarts"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_deterministic"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Optimize the full model\n        \"\"\"", "\n", "\n", "# Optimize the first model", "\n", "self", ".", "models", "[", "0", "]", ".", "optimize_restarts", "(", "self", ".", "optimization_restarts", ",", "verbose", "=", "self", ".", "verbose", ",", "robust", "=", "True", ")", "\n", "\n", "# Optimize all models for all fidelities but lowest fidelity", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "n_fidelities", ")", ":", "\n", "# Set new X values because previous model has changed", "\n", "            ", "is_ith_fidelity", "=", "self", ".", "X", "[", ":", ",", "self", ".", "_fidelity_idx", "]", "==", "i", "\n", "previous_mean", ",", "_", "=", "self", ".", "_predict_deterministic", "(", "self", ".", "X", "[", "is_ith_fidelity", ",", ":", "-", "1", "]", ",", "i", ")", "\n", "augmented_input", "=", "np", ".", "concatenate", "(", "[", "self", ".", "models", "[", "i", "]", ".", "X", "[", ":", ",", ":", "-", "1", "]", ",", "previous_mean", "]", ",", "axis", "=", "1", ")", "\n", "self", ".", "models", "[", "i", "]", ".", "set_X", "(", "augmented_input", ")", "\n", "\n", "# Optimize parameters", "\n", "self", ".", "models", "[", "i", "]", ".", "optimize_restarts", "(", "self", ".", "optimization_restarts", ",", "verbose", "=", "self", ".", "verbose", ",", "robust", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.get_f_minimum": [[350, 355], ["numpy.min"], "methods", ["None"], ["", "", "def", "get_f_minimum", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Get the minimum of the top fidelity model.\n        \"\"\"", "\n", "return", "np", ".", "min", "(", "self", ".", "models", "[", "-", "1", "]", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.NonLinearMultiFidelityModel._predict_deterministic": [[356, 368], ["non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].predict", "range", "numpy.concatenate", "non_linear_multi_fidelity_model.NonLinearMultiFidelityModel.models[].predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "_predict_deterministic", "(", "self", ",", "X", ",", "fidelity", ")", ":", "\n", "        ", "\"\"\"\n        This is a helper function when predicting at points that are in the training set. It is more efficient than\n        sampling and is useful when constructing the model.\n        \"\"\"", "\n", "# Predict at first fidelity", "\n", "mean", ",", "variance", "=", "self", ".", "models", "[", "0", "]", ".", "predict", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "fidelity", ")", ":", "\n", "# Push samples through this fidelity model", "\n", "            ", "augmented_input", "=", "np", ".", "concatenate", "(", "[", "X", ",", "mean", "]", ",", "axis", "=", "1", ")", "\n", "mean", ",", "variance", "=", "self", ".", "models", "[", "i", "]", ".", "predict", "(", "augmented_input", ")", "\n", "", "return", "mean", ",", "variance", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.models.non_linear_multi_fidelity_model.make_non_linear_kernels": [[23, 58], ["list", "range", "range", "base_kernel_class", "base_kernel_class", "base_kernel_class", "base_kernel_class", "kernels.append", "str"], "function", ["None"], ["def", "make_non_linear_kernels", "(", "\n", "base_kernel_class", ":", "Type", "[", "GPy", ".", "kern", ".", "Kern", "]", ",", "n_fidelities", ":", "int", ",", "n_input_dims", ":", "int", ",", "ARD", ":", "bool", "=", "False", "\n", ")", "->", "List", ":", "\n", "    ", "\"\"\"\n    This function takes a base kernel class and constructs the structured multi-fidelity kernels\n\n    At the first level the kernel is simply:\n    .. math\n        k_{base}(x, x')\n\n    At subsequent levels the kernels are of the form\n    .. math\n        k_{base}(x, x')k_{base}(y_{i-1}, y{i-1}') + k_{base}(x, x')\n\n    :param base_kernel_class: GPy class definition of the kernel type to construct the kernels at\n    :param n_fidelities: Number of fidelities in the model. A kernel will be returned for each fidelity\n    :param n_input_dims: The dimensionality of the input.\n    :param ARD: If True, uses different lengthscales for different dimensions. Otherwise the same lengthscale is used\n                for all dimensions. Default False.\n    :return: A list of kernels with one entry for each fidelity starting from lowest to highest fidelity.\n    \"\"\"", "\n", "\n", "base_dims_list", "=", "list", "(", "range", "(", "n_input_dims", ")", ")", "\n", "kernels", "=", "[", "base_kernel_class", "(", "n_input_dims", ",", "active_dims", "=", "base_dims_list", ",", "ARD", "=", "ARD", ",", "name", "=", "\"kern_fidelity_1\"", ")", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n_fidelities", ")", ":", "\n", "        ", "fidelity_name", "=", "\"fidelity\"", "+", "str", "(", "i", "+", "1", ")", "\n", "interaction_kernel", "=", "base_kernel_class", "(", "\n", "n_input_dims", ",", "active_dims", "=", "base_dims_list", ",", "ARD", "=", "ARD", ",", "name", "=", "\"scale_kernel_\"", "+", "fidelity_name", "\n", ")", "\n", "scale_kernel", "=", "base_kernel_class", "(", "1", ",", "active_dims", "=", "[", "n_input_dims", "]", ",", "name", "=", "\"previous_fidelity_\"", "+", "fidelity_name", ")", "\n", "bias_kernel", "=", "base_kernel_class", "(", "\n", "n_input_dims", ",", "active_dims", "=", "base_dims_list", ",", "ARD", "=", "ARD", ",", "name", "=", "\"bias_kernel_\"", "+", "fidelity_name", "\n", ")", "\n", "kernels", ".", "append", "(", "interaction_kernel", "*", "scale_kernel", "+", "bias_kernel", ")", "\n", "", "return", "kernels", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_sklearn_model_wrapper.model": [[8, 19], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "sklearn.gaussian_process.GaussianProcessRegressor", "emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper", "emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper.set_data", "emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper.optimize"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["@", "pytest", ".", "fixture", "\n", "def", "model", "(", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "x_init", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "y_init", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "sklearn_model", "=", "GaussianProcessRegressor", "(", ")", "\n", "model", "=", "SklearnGPRWrapper", "(", "sklearn_model", ")", "\n", "model", ".", "set_data", "(", "x_init", ",", "y_init", ")", "\n", "model", ".", "optimize", "(", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_sklearn_model_wrapper.test_predict_shape": [[21, 28], ["numpy.random.RandomState", "np.random.RandomState.rand", "model.predict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_predict_shape", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "x_test", "=", "rng", ".", "rand", "(", "10", ",", "2", ")", "\n", "\n", "m", ",", "v", "=", "model", ".", "predict", "(", "x_test", ")", "\n", "assert", "m", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "assert", "v", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_sklearn_model_wrapper.test_update_data": [[30, 38], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "model.set_data"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["", "def", "test_update_data", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "x_new", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "y_new", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "model", ".", "set_data", "(", "x_new", ",", "y_new", ")", "\n", "\n", "assert", "model", ".", "X", ".", "shape", "==", "x_new", ".", "shape", "\n", "assert", "model", ".", "Y", ".", "shape", "==", "y_new", ".", "shape", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_random_forest.model": [[7, 14], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "emukit.examples.models.random_forest.RandomForest"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "model", "(", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "x_init", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "y_init", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "model", "=", "RandomForest", "(", "x_init", ",", "y_init", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_random_forest.test_predict_shape": [[16, 24], ["numpy.random.RandomState", "np.random.RandomState.rand", "model.predict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_predict_shape", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "\n", "x_test", "=", "rng", ".", "rand", "(", "10", ",", "2", ")", "\n", "m", ",", "v", "=", "model", ".", "predict", "(", "x_test", ")", "\n", "\n", "assert", "m", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "assert", "v", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_random_forest.test_update_data": [[26, 34], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "model.set_data"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["", "def", "test_update_data", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "x_new", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "y_new", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "model", ".", "set_data", "(", "x_new", ",", "y_new", ")", "\n", "\n", "assert", "model", ".", "X", ".", "shape", "==", "x_new", ".", "shape", "\n", "assert", "model", ".", "Y", ".", "shape", "==", "y_new", ".", "shape", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_bohamiann.model": [[11, 18], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "Bohamiann"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "model", "(", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "x_init", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "y_init", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "model", "=", "Bohamiann", "(", "x_init", ",", "y_init", ",", "num_burnin", "=", "100", ",", "num_steps", "=", "200", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_bohamiann.test_predict_shape": [[20, 28], ["numpy.random.RandomState", "np.random.RandomState.rand", "model.predict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_predict_shape", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "\n", "x_test", "=", "rng", ".", "rand", "(", "10", ",", "2", ")", "\n", "m", ",", "v", "=", "model", ".", "predict", "(", "x_test", ")", "\n", "\n", "assert", "m", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "assert", "v", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_bohamiann.test_update_data": [[30, 38], ["numpy.random.RandomState", "np.random.RandomState.rand", "np.random.RandomState.rand", "model.set_data"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["", "def", "test_update_data", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "x_new", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "y_new", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "model", ".", "set_data", "(", "x_new", ",", "y_new", ")", "\n", "\n", "assert", "model", ".", "X", ".", "shape", "==", "x_new", ".", "shape", "\n", "assert", "model", ".", "Y", ".", "shape", "==", "y_new", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.models.test_bohamiann.test_get_prediction_gradients_shape": [[40, 48], ["numpy.random.RandomState", "np.random.RandomState.rand", "model.get_prediction_gradients"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "test_get_prediction_gradients_shape", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "\n", "x_test", "=", "rng", ".", "rand", "(", "10", ",", "2", ")", "\n", "dm", ",", "dv", "=", "model", ".", "get_prediction_gradients", "(", "x_test", ")", "\n", "\n", "assert", "dm", ".", "shape", "==", "x_test", ".", "shape", "\n", "assert", "dv", ".", "shape", "==", "x_test", ".", "shape", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.get_current_best": [[30, 35], ["min"], "methods", ["None"], ["def", "get_current_best", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        :return: minimum of means of predictions at all input locations (needed by q-EI)\n        \"\"\"", "\n", "return", "min", "(", "self", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.get_y_pred": [[36, 42], ["gp_models.ComparisonGP.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "get_y_pred", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :return: GP mean at inputs used to compute the posterior approximation (needed by q-EI)\n        \"\"\"", "\n", "y_pred", ",", "_", "=", "self", ".", "predict", "(", "self", ".", "X", ",", "include_likelihood", "=", "False", ")", "\n", "return", "y_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.log_likelihood": [[43, 48], ["None"], "methods", ["None"], ["", "def", "log_likelihood", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        :return: log marginal likelihood needed for optimizing hyper parameters and performing model comparison\n        \"\"\"", "\n", "return", "self", ".", "_log_marginal_likelihood", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.predict": [[49, 65], ["gp_models.ComparisonGP.posterior._raw_predict"], "methods", ["None"], ["", "def", "predict", "(", "\n", "self", ",", "Xnew", ":", "np", ".", "ndarray", ",", "full_cov", ":", "bool", "=", "False", ",", "include_likelihood", "=", "True", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Predictive mean and covariance of the GP at the input location\n        :param Xnew: Locations the prections are wanted at\n        :param full_cov: If the user wants the function to return the full covariance or only the diagonal\n        :param include_likelihood: If the user wants the function to add the noise of the observations to the prediction covariance\n        :return: predictive mean and predictive covariance\n        \"\"\"", "\n", "pred_mean", ",", "pred_var", "=", "self", ".", "posterior", ".", "_raw_predict", "(", "\n", "self", ".", "kern", ",", "Xnew", ",", "self", ".", "X", ",", "full_cov", "=", "full_cov", "\n", ")", "# self.posterior._raw_predict(self.kern, np.hstack([Xnew,ki]), np.hstack([self.X, self.ki]), full_cov=full_cov)", "\n", "if", "include_likelihood", ":", "\n", "            ", "pred_var", "=", "pred_var", "+", "self", ".", "likelihood", ".", "variance", "\n", "", "return", "pred_mean", ",", "pred_var", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.predict_noiseless": [[66, 74], ["gp_models.ComparisonGP.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_noiseless", "(", "self", ",", "Xnew", ",", "full_cov", "=", "False", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Predictive mean and covariance of the GP latent function at the input location\n        :param Xnew: Locations the prections are wanted at\n        :param full_cov: If the user wants the function to return the full covariance or only the diagonal\n        :return: predictive latent mean and predictive latent covariance\n        \"\"\"", "\n", "return", "self", ".", "predict", "(", "Xnew", ",", "full_cov", "=", "full_cov", ",", "include_likelihood", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.posterior_samples_f": [[75, 101], ["gp_models.ComparisonGP.predict", "numpy.empty", "range", "numpy.random.multivariate_normal", "gp_models.ComparisonGP.posterior_samples_f.sim_one_dim"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "posterior_samples_f", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "size", ":", "int", "=", "10", ",", "**", "predict_kwargs", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Draw random samples from the posterior predictive distribution\n\n        :param X: Locations where the posterior samples should be drawn at\n        :param size: Number of posterior samples\n        :return: Simulated posterior samples\n        \"\"\"", "\n", "predict_kwargs", "[", "\"full_cov\"", "]", "=", "True", "# Always use the full covariance for posterior samples.", "\n", "predict_kwargs", "[", "\"include_likelihood\"", "]", "=", "False", "\n", "m", ",", "v", "=", "self", ".", "predict", "(", "X", ",", "**", "predict_kwargs", ")", "\n", "\n", "def", "sim_one_dim", "(", "m", ",", "v", ")", ":", "\n", "# Draw posterior sample in one dimension", "\n", "            ", "return", "np", ".", "random", ".", "multivariate_normal", "(", "m", ",", "v", ",", "size", ")", ".", "T", "\n", "\n", "", "if", "self", ".", "output_dim", "==", "1", ":", "\n", "            ", "return", "sim_one_dim", "(", "m", ".", "flatten", "(", ")", ",", "v", ")", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "fsim", "=", "np", ".", "empty", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "output_dim", ",", "size", ")", ")", "\n", "for", "d", "in", "range", "(", "self", ".", "output_dim", ")", ":", "\n", "                ", "if", "v", ".", "ndim", "==", "3", ":", "\n", "                    ", "fsim", "[", ":", ",", "d", ",", ":", "]", "=", "sim_one_dim", "(", "m", "[", ":", ",", "d", "]", ",", "v", "[", ":", ",", ":", ",", "d", "]", ")", "\n", "", "else", ":", "\n", "                    ", "fsim", "[", ":", ",", "d", ",", ":", "]", "=", "sim_one_dim", "(", "m", "[", ":", ",", "d", "]", ",", "v", ")", "\n", "", "", "", "return", "fsim", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.EPComparisonGP.__init__": [[119, 158], ["super().__init__", "gp_models.EPComparisonGP.link_parameter", "gp_models.EPComparisonGP.link_parameter", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "kernel", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "likelihood", ":", "GPy", ".", "likelihoods", ".", "Gaussian", ",", "\n", "name", ":", "str", "=", "\"EPComparisonGP\"", ",", "\n", "ep_max_itt", ":", "int", "=", "100", ",", "\n", "delta", ":", "float", "=", "0.5", ",", "\n", "eta", ":", "float", "=", "0.5", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", ":", "\n", "\n", "        ", "super", "(", "EPComparisonGP", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "\n", "self", ".", "N", ",", "self", ".", "D", "=", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "1", "]", "\n", "\n", "self", ".", "output_dim", "=", "1", "# hard coded, the code doesn't support multi output case", "\n", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "yc", "=", "yc", "\n", "\n", "self", ".", "kern", "=", "kernel", "\n", "self", ".", "likelihood", "=", "likelihood", "\n", "\n", "# A helper parameter for EP. Each observation could possibly come from different kernels and likelihoods.", "\n", "# The inference supports this already, but this GPy wrapper doesn't", "\n", "self", ".", "sigma2s", "=", "self", ".", "likelihood", ".", "variance", "*", "np", ".", "ones", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "int", ")", "\n", "\n", "self", ".", "ep_max_itt", "=", "ep_max_itt", "\n", "self", ".", "eta", "=", "eta", "\n", "self", ".", "delta", "=", "delta", "\n", "\n", "self", ".", "link_parameter", "(", "self", ".", "kern", ")", "\n", "self", ".", "link_parameter", "(", "self", ".", "likelihood", ")", "\n", "self", ".", "posterior", ",", "self", ".", "ga_approx", ",", "self", ".", "Y", "=", "None", ",", "None", ",", "None", "\n", "self", ".", "get_logger", "=", "get_logger", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.EPComparisonGP.parameters_changed": [[159, 180], ["inferences.ep_batch_comparison.ep_comparison", "gp_models.EPComparisonGP.get_y_pred"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.ep_comparison", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.get_y_pred"], ["", "def", "parameters_changed", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update the posterior approximation after kernel or likelihood parameters have changed or there are new observations\n        \"\"\"", "\n", "# Recompute the posterior approximation", "\n", "self", ".", "posterior", ",", "self", ".", "_log_marginal_likelihood", ",", "self", ".", "grad_dict", ",", "self", ".", "ga_approx", "=", "ep", ".", "ep_comparison", "(", "\n", "self", ".", "X", ",", "\n", "self", ".", "y", ",", "\n", "self", ".", "yc", ",", "\n", "self", ".", "kern", ",", "\n", "self", ".", "sigma2s", ",", "\n", "max_itt", "=", "self", ".", "ep_max_itt", ",", "\n", "tol", "=", "1e-6", ",", "\n", "delta", "=", "self", ".", "delta", ",", "\n", "eta", "=", "self", ".", "eta", ",", "\n", "ga_approx_old", "=", "self", ".", "ga_approx", ",", "\n", "get_logger", "=", "self", ".", "get_logger", ",", "\n", ")", "\n", "\n", "# predict Y at inputs (needed by q-EI)", "\n", "self", ".", "Y", "=", "self", ".", "get_y_pred", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.EPComparisonGP.set_XY": [[181, 194], ["gp_models.EPComparisonGP.parameters_changed", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.parameters_changed"], ["", "def", "set_XY", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Set new observations and recompute the posterior\n\n        :param X: All locations of both direct observations and batch comparisons\n        :param y: Direct observations in as a list of tuples telling location index (row in X) and observation value.\n        :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n        \"\"\"", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "yc", "=", "yc", "\n", "self", ".", "sigma2s", "=", "self", ".", "likelihood", ".", "variance", "*", "np", ".", "ones", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "int", ")", "\n", "self", ".", "parameters_changed", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.VIComparisonGP.__init__": [[211, 255], ["super().__init__", "gp_models.VIComparisonGP.kern.K", "numpy.linalg.cholesky", "numpy.zeros", "numpy.ones", "numpy.ones", "inferences.vi_batch_comparison.vi_comparison", "GPy.util.choleskies._triang_to_flat_pure", "numpy.identity", "GPy.util.linalg.jitchol"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.vi_comparison"], ["def", "__init__", "(", "\n", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "kernel", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "likelihood", ":", "Gaussian", ",", "\n", "vi_mode", ":", "str", "=", "\"fr\"", ",", "\n", "name", ":", "str", "=", "\"VIComparisonGP\"", ",", "\n", "max_iters", ":", "int", "=", "50", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "VIComparisonGP", ",", "self", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "\n", "self", ".", "N", ",", "self", ".", "D", "=", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "1", "]", "\n", "\n", "self", ".", "output_dim", "=", "1", "\n", "self", ".", "get_logger", "=", "get_logger", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "yc", "=", "yc", "\n", "\n", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "vi_mode", "=", "vi_mode", "\n", "\n", "self", ".", "kern", "=", "kernel", "\n", "self", ".", "likelihood", "=", "likelihood", "\n", "\n", "self", ".", "sigma2s", "=", "self", ".", "likelihood", ".", "variance", "*", "np", ".", "ones", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "int", ")", "\n", "jitter", "=", "1e-6", "\n", "K", "=", "self", ".", "kern", ".", "K", "(", "X", ")", "\n", "L", "=", "np", ".", "linalg", ".", "cholesky", "(", "K", "+", "np", ".", "identity", "(", "K", ".", "shape", "[", "0", "]", ")", "*", "jitter", ")", "\n", "\n", "self", ".", "alpha", "=", "np", ".", "zeros", "(", "(", "self", ".", "N", ",", "1", ")", ")", "\n", "self", ".", "beta", "=", "np", ".", "ones", "(", "(", "self", ".", "N", ",", "1", ")", ")", "\n", "\n", "self", ".", "posterior", "=", "None", "\n", "\n", "# If we are using full rank VI, we initialize it with mean field VI", "\n", "if", "self", ".", "vi_mode", "==", "\"FRVI\"", ":", "\n", "            ", "self", ".", "posterior", ",", "_", ",", "_", ",", "self", ".", "alpha", ",", "self", ".", "beta", "=", "vi", ".", "vi_comparison", "(", "\n", "self", ".", "X", ",", "self", ".", "y", ",", "self", ".", "yc", ",", "self", ".", "kern", ",", "self", ".", "sigma2s", ",", "self", ".", "alpha", ",", "self", ".", "beta", ",", "max_iters", "=", "50", ",", "method", "=", "\"mf\"", "\n", ")", "\n", "self", ".", "beta", "=", "choleskies", ".", "_triang_to_flat_pure", "(", "jitchol", "(", "self", ".", "posterior", ".", "covariance", ")", "[", "None", ",", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.VIComparisonGP.parameters_changed": [[256, 281], ["inferences.vi_batch_comparison.vi_comparison", "gp_models.VIComparisonGP.get_y_pred"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.vi_comparison", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.get_y_pred"], ["", "", "def", "parameters_changed", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update the posterior approximation after kernel or likelihood parameters have changed or there are new observations\n        \"\"\"", "\n", "if", "self", ".", "vi_mode", "==", "\"fr\"", ":", "\n", "            ", "method", "=", "\"fr\"", "\n", "", "else", ":", "\n", "            ", "method", "=", "\"mf\"", "\n", "\n", "", "self", ".", "posterior", ",", "self", ".", "_log_marginal_likelihood", ",", "self", ".", "grad_dict", ",", "alpha", ",", "beta", "=", "vi", ".", "vi_comparison", "(", "\n", "self", ".", "X", ",", "\n", "self", ".", "y", ",", "\n", "self", ".", "yc", ",", "\n", "self", ".", "kern", ",", "\n", "self", ".", "sigma2s", ",", "\n", "self", ".", "alpha", ",", "\n", "self", ".", "beta", ",", "\n", "max_iters", "=", "self", ".", "max_iters", ",", "\n", "method", "=", "method", ",", "\n", "get_logger", "=", "self", ".", "get_logger", ",", "\n", ")", "\n", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "Y", "=", "self", ".", "get_y_pred", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.VIComparisonGP.set_XY": [[282, 307], ["numpy.zeros", "range", "range", "gp_models.VIComparisonGP.parameters_changed", "numpy.ones", "numpy.ones", "numpy.ones", "len", "len", "int"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.parameters_changed"], ["", "def", "set_XY", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Set new observations and recompute the posterior\n\n        :param X: All locations of both direct observations and batch comparisons\n        :param y: Direct observations in as a list of tuples telling location index (row in X) and observation value.\n        :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n        \"\"\"", "\n", "self", ".", "N", ",", "self", ".", "D", "=", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "1", "]", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "yc", "=", "yc", "\n", "self", ".", "sigma2s", "=", "self", ".", "likelihood", ".", "variance", "*", "np", ".", "ones", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "int", ")", "\n", "alpha", "=", "np", ".", "zeros", "(", "(", "self", ".", "N", ",", "1", ")", ")", "\n", "if", "self", ".", "vi_mode", "==", "\"fr\"", ":", "\n", "            ", "beta", "=", "np", ".", "ones", "(", "(", "int", "(", "(", "self", ".", "N", "**", "2", "+", "self", ".", "N", ")", "/", "2", ")", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "beta", "=", "np", ".", "ones", "(", "(", "self", ".", "N", ",", "1", ")", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "alpha", ")", ")", ":", "\n", "            ", "alpha", "[", "i", "]", "=", "self", ".", "alpha", "[", "i", "]", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "beta", ")", ")", ":", "\n", "            ", "beta", "[", "i", "]", "=", "self", ".", "beta", "[", "i", "]", "\n", "", "self", ".", "alpha", ",", "self", ".", "beta", "=", "alpha", ",", "beta", "\n", "self", ".", "posterior", "=", "None", "\n", "self", ".", "parameters_changed", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.VIComparisonGPMF.__init__": [[314, 327], ["gp_models.VIComparisonGP.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "kernel", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "likelihood", ":", "Gaussian", ",", "\n", "name", ":", "str", "=", "\"VIComparisonGPMF\"", ",", "\n", "max_iters", ":", "int", "=", "50", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "VIComparisonGPMF", ",", "self", ")", ".", "__init__", "(", "\n", "X", ",", "y", ",", "yc", ",", "kernel", ",", "likelihood", ",", "name", "=", "name", ",", "max_iters", "=", "max_iters", ",", "vi_mode", "=", "\"mf\"", ",", "get_logger", "=", "get_logger", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.VIComparisonGPFR.__init__": [[335, 348], ["gp_models.VIComparisonGP.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "kernel", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "likelihood", ":", "Gaussian", ",", "\n", "name", ":", "str", "=", "\"VIComparisonGPFR\"", ",", "\n", "max_iters", ":", "int", "=", "50", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "VIComparisonGPFR", ",", "self", ")", ".", "__init__", "(", "\n", "X", ",", "y", ",", "yc", ",", "kernel", ",", "likelihood", ",", "name", "=", "name", ",", "max_iters", "=", "max_iters", ",", "vi_mode", "=", "\"fr\"", ",", "get_logger", "=", "get_logger", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.__init__": [[365, 395], ["super().__init__", "numpy.sqrt", "numpy.array().flatten", "stan_utility.compile_model", "gp_models.MCMCComparisonGP.parameters_changed", "numpy.ones", "os.path.exists", "os.makedirs", "os.path.join", "numpy.array", "stan_utility.file_utils.get_path_of_cache", "stan_utility.file_utils.get_path_of_cache", "os.path.dirname"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.parameters_changed"], ["def", "__init__", "(", "\n", "self", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "kernel", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "likelihood", ":", "Gaussian", ",", "\n", "posterior_samples", ":", "int", "=", "45", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "MCMCComparisonGP", ",", "self", ")", ".", "__init__", "(", "name", "=", "\"MCMC\"", ")", "\n", "self", ".", "N", ",", "self", ".", "D", "=", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "1", "]", "\n", "self", ".", "output_dim", "=", "1", "## hard coded", "\n", "self", ".", "posterior_samples", "=", "posterior_samples", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "yc", "=", "yc", "\n", "self", ".", "noise_std", "=", "np", ".", "sqrt", "(", "likelihood", ".", "variance", "[", "0", "]", ")", "\n", "self", ".", "sigma2s", "=", "(", "likelihood", ".", "variance", "[", "0", "]", ")", "*", "np", ".", "ones", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "int", ")", "\n", "self", ".", "variance", "=", "kernel", ".", "variance", "[", "0", "]", "\n", "self", ".", "lengthscale", "=", "np", ".", "array", "(", "[", "kernel", ".", "lengthscale", "[", ":", "]", "]", ")", ".", "flatten", "(", ")", "\n", "self", ".", "kern", "=", "kernel", "\n", "self", ".", "posterior", "=", "None", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "stan_utility", ".", "file_utils", ".", "get_path_of_cache", "(", ")", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "stan_utility", ".", "file_utils", ".", "get_path_of_cache", "(", ")", ")", "\n", "", "self", ".", "model", "=", "stan_utility", ".", "compile_model", "(", "\n", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "\"inferences/sexpgp_comparison.stan\"", ")", ",", "model_name", "=", "\"comparison_model\"", "\n", ")", "\n", "self", ".", "get_logger", "=", "get_logger", "\n", "self", ".", "parameters_changed", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP._fit_stan": [[396, 440], ["gp_models.MCMCComparisonGP.model.sampling", "len", "len", "numpy.array().flatten", "numpy.array", "numpy.array", "numpy.array", "numpy.sqrt", "int", "gp_models.MCMCComparisonGP.get_logger().info", "gp_models.MCMCComparisonGP.get_logger().info", "numpy.zeros", "list", "itertools.chain", "numpy.array", "gp_models.MCMCComparisonGP.get_logger", "gp_models.MCMCComparisonGP.get_logger", "list", "list", "itertools.chain", "itertools.chain"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger"], ["", "def", "_fit_stan", "(", "self", ")", "->", "Dict", ":", "\n", "        ", "\"\"\"\n        Fit stan using the given observations and return a wrapper object that allows a simple framework for handling the posterior samples\n\n        :return: A pystan fit object containing the posterior fit for the model\n        \"\"\"", "\n", "\n", "def", "inits", "(", ")", ":", "\n", "            ", "return", "{", "\"eta\"", ":", "np", ".", "zeros", "(", "(", "self", ".", "X", ".", "shape", "[", "0", "]", ",", ")", ")", "}", "\n", "\n", "", "dat", "=", "{", "\n", "\"N\"", ":", "len", "(", "self", ".", "y", ")", ",", "\n", "\"N_comp\"", ":", "len", "(", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "yc", ")", ")", ")", ",", "\n", "\"Nf\"", ":", "self", ".", "X", ".", "shape", "[", "0", "]", ",", "\n", "\"d\"", ":", "self", ".", "X", ".", "shape", "[", "1", "]", ",", "\n", "\"y\"", ":", "np", ".", "array", "(", "[", "yi", "[", "1", "]", "for", "yi", "in", "self", ".", "y", "]", ")", ".", "flatten", "(", ")", ",", "\n", "\"yi\"", ":", "np", ".", "array", "(", "[", "yi", "[", "0", "]", "+", "1", "for", "yi", "in", "self", ".", "y", "]", ",", "dtype", "=", "int", ")", ",", "\n", "\"y_comp1\"", ":", "np", ".", "array", "(", "[", "i", "[", "0", "]", "+", "1", "for", "i", "in", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "yc", ")", ")", "]", ",", "dtype", "=", "int", ")", ",", "\n", "\"y_comp2\"", ":", "np", ".", "array", "(", "[", "i", "[", "1", "]", "+", "1", "for", "i", "in", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "yc", ")", ")", "]", ",", "dtype", "=", "int", ")", ",", "\n", "\"x\"", ":", "self", ".", "X", ",", "\n", "\"rho\"", ":", "self", ".", "lengthscale", ",", "\n", "\"alpha\"", ":", "np", ".", "sqrt", "(", "self", ".", "variance", ")", ",", "\n", "\"sigma\"", ":", "self", ".", "noise_std", ",", "\n", "\"delta\"", ":", "1e-9", ",", "\n", "}", "\n", "iter", "=", "3000", "\n", "chains", "=", "6", "\n", "warmup", "=", "iter", "-", "int", "(", "self", ".", "posterior_samples", "//", "chains", ")", "\n", "if", "self", ".", "get_logger", "is", "not", "None", ":", "\n", "            ", "self", ".", "get_logger", "(", ")", ".", "info", "(", "\"Starting to sample from the posterior\"", ")", "\n", "", "fit", "=", "self", ".", "model", ".", "sampling", "(", "\n", "data", "=", "dat", ",", "\n", "seed", "=", "194838", ",", "\n", "chains", "=", "6", ",", "\n", "n_jobs", "=", "1", ",", "\n", "iter", "=", "iter", ",", "\n", "warmup", "=", "warmup", ",", "\n", "refresh", "=", "-", "1", ",", "\n", "control", "=", "{", "\"adapt_delta\"", ":", "0.9999", ",", "\"max_treedepth\"", ":", "12", "}", ",", "\n", "init", "=", "inits", ",", "\n", ")", "\n", "if", "self", ".", "get_logger", "is", "not", "None", ":", "\n", "            ", "self", ".", "get_logger", "(", ")", ".", "info", "(", "\"Sampling finished\"", ")", "\n", "", "return", "fit", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.parameters_changed": [[441, 465], ["gp_models.MCMCComparisonGP._fit_stan", "gp_models.MCMCComparisonGP.extract", "inferences.StanPosterior", "gp_models.MCMCComparisonGP.get_y_pred", "len", "numpy.array().flatten", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP._fit_stan", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGP.get_y_pred"], ["", "def", "parameters_changed", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update the posterior approximation after kernel or likelihood parameters have changed or there are new observations\n        \"\"\"", "\n", "# Run Stan:", "\n", "fit", "=", "self", ".", "_fit_stan", "(", ")", "\n", "self", ".", "samples", "=", "fit", ".", "extract", "(", "permuted", "=", "True", ")", "\n", "remove_levels", "=", "True", "\n", "if", "len", "(", "self", ".", "y", ")", ">", "0", ":", "\n", "            ", "remove_levels", "=", "False", "\n", "", "self", ".", "posterior", "=", "StanPosterior", "(", "\n", "self", ".", "samples", ",", "\n", "self", ".", "X", ",", "\n", "self", ".", "kern", ",", "\n", "self", ".", "noise_std", ",", "\n", "Y", "=", "np", ".", "array", "(", "[", "yi", "[", "1", "]", "for", "yi", "in", "self", ".", "y", "]", ")", ".", "flatten", "(", ")", ",", "\n", "remove_levels", "=", "remove_levels", ",", "\n", "y", "=", "self", ".", "y", ",", "\n", "yc", "=", "self", ".", "yc", ",", "\n", "get_logger", "=", "self", ".", "get_logger", ",", "\n", ")", "\n", "self", ".", "_log_marginal_likelihood", ",", "self", ".", "grad_dict", "=", "None", ",", "{", "}", "\n", "self", ".", "y_pred", "=", "self", ".", "get_y_pred", "(", ")", "\n", "self", ".", "Y", "=", "self", ".", "y_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY": [[466, 478], ["gp_models.MCMCComparisonGP.parameters_changed"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.parameters_changed"], ["", "def", "set_XY", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Set new observations and recompute the posterior\n\n        :param X: All locations of both direct observations and batch comparisons\n        :param y: Direct observations in as a list of tuples telling location index (row in X) and observation value.\n        :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n        \"\"\"", "\n", "self", ".", "X", "=", "X", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "yc", "=", "yc", "\n", "self", ".", "parameters_changed", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGPEmukitWrapper.__init__": [[485, 493], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "gpy_model", ":", "ComparisonGP", ",", "batch_size", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        :param gpy_model: GPy model object to wrap\n        :param batch_size: Number of samples in a batch\n        \"\"\"", "\n", "self", ".", "model", "=", "gpy_model", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "g", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGPEmukitWrapper.predict": [[494, 500], ["gp_models.ComparisonGPEmukitWrapper.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param X: (n_points x n_dimensions) array containing locations at which to get predictions\n        :return: (mean, variance) Arrays of size n_points x 1 of the predictive distribution at each input location\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGPEmukitWrapper.predict_with_full_covariance": [[501, 508], ["gp_models.ComparisonGPEmukitWrapper.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_with_full_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param X: (n_points x n_dimensions) array containing locations at which to get predictions\n        :return: (mean, variance) Arrays of size n_points x 1 and n_points x n_points of the predictive\n                 mean and variance at each input location\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "X", ",", "full_cov", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGPEmukitWrapper.set_data": [[509, 534], ["X[].reshape", "Y[].reshape", "gp_models.ComparisonGPEmukitWrapper.model.set_XY", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "tuple", "range", "len", "util.comparison_form", "range", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.comparison_form"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Sets training data in model\n\n        :param X: New training features\n        :param Y: New training outputs\n        \"\"\"", "\n", "if", "X", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "X", "=", "X", "[", "0", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "Y", "=", "Y", "[", "0", ",", ":", "]", ".", "reshape", "(", "(", "-", "1", ")", ")", "\n", "ind", "=", "self", ".", "model", ".", "X", ".", "shape", "[", "0", "]", "\n", "X_set", "=", "self", ".", "model", ".", "X", "\n", "y_set", "=", "self", ".", "model", ".", "y", "\n", "yc_set", "=", "self", ".", "model", ".", "yc", "\n", "if", "X", ".", "shape", "[", "1", "]", "==", "self", ".", "model", ".", "X", ".", "shape", "[", "1", "]", ":", "# Direct observation", "\n", "                ", "X_set", "=", "np", ".", "concatenate", "(", "(", "self", ".", "model", ".", "X", ",", "X", ")", ",", "axis", "=", "0", ")", "\n", "y_set", "+=", "[", "(", "i", "+", "ind", ",", "Y", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "Y", ")", ")", "]", "\n", "", "else", ":", "\n", "                ", "X_tmp", "=", "np", ".", "concatenate", "(", "\n", "tuple", "(", "X", "[", ":", ",", "i", "*", "self", ".", "batch_size", ":", "(", "i", "+", "1", ")", "*", "self", ".", "batch_size", "]", "for", "i", "in", "range", "(", "len", "(", "Y", ")", ")", ")", ",", "axis", "=", "0", "\n", ")", "\n", "X_set", "=", "np", ".", "concatenate", "(", "(", "self", ".", "model", ".", "X", ",", "X_tmp", ")", ",", "axis", "=", "0", ")", "\n", "yc_set", "+=", "[", "[", "(", "yc", "[", "0", "]", "+", "ind", ",", "yc", "[", "1", "]", "+", "ind", ")", "for", "yc", "in", "util", ".", "comparison_form", "(", "Y", ")", "]", "]", "\n", "\n", "", "self", ".", "model", ".", "set_XY", "(", "X_set", ",", "y_set", ",", "yc_set", ")", "\n", "#", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGPEmukitWrapper.predict_covariance": [[537, 548], ["gp_models.ComparisonGPEmukitWrapper.model.predict", "numpy.clip"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "", "def", "predict_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "with_noise", ":", "bool", "=", "True", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculates posterior covariance between points in X\n        :param X: Array of size n_points x n_dimensions containing input locations to compute posterior covariance at\n        :param with_noise: Whether to include likelihood noise in the covariance matrix\n        :return: Posterior covariance matrix of size n_points x n_points\n        \"\"\"", "\n", "_", ",", "v", "=", "self", ".", "model", ".", "predict", "(", "X", ",", "full_cov", "=", "True", ",", "include_likelihood", "=", "with_noise", ")", "\n", "v", "=", "np", ".", "clip", "(", "v", ",", "1e-10", ",", "np", ".", "inf", ")", "\n", "\n", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGPEmukitWrapper.X": [[549, 555], ["numpy.empty"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :return: An array of shape n_points x n_dimensions containing training inputs\n        \"\"\"", "\n", "return", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "model", ".", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGPEmukitWrapper.Y": [[556, 562], ["numpy.empty"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :return: An array of shape n_points x 1 containing training outputs\n        \"\"\"", "\n", "return", "np", ".", "empty", "(", "(", "0", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.ComparisonGPEmukitWrapper.optimize": [[563, 568], ["None"], "methods", ["None"], ["", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Optimizes the model. In this case does nothing since the parameters are fixed\n        \"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.__init__": [[74, 100], ["options.copy", "options[].copy", "math.ceil", "options.get", "options.get", "options.get", "options.get", "options.get", "util.configure_logger", "float", "float"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get", "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get", "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get", "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get", "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.configure_logger"], ["def", "__init__", "(", "self", ",", "options", ":", "Dict", ")", ":", "\n", "        ", "self", ".", "options", "=", "options", ".", "copy", "(", ")", "\n", "\n", "self", ".", "kernel", "=", "options", "[", "\"kernel\"", "]", ".", "copy", "(", ")", "# GPy kernel used for the optimization", "\n", "self", ".", "inference", "=", "options", "[", "\"inference\"", "]", "# Inference method used to approximate the posterior", "\n", "self", ".", "acquisition", "=", "options", "[", "\"acquisition\"", "]", "# The acquisition function used to get new points", "\n", "self", ".", "batch_size", "=", "options", "[", "\"batch_size\"", "]", "# Number of observations in a batch", "\n", "self", ".", "max_num_observations", "=", "options", "[", "\"max_num_observations\"", "]", "# Maximum number of observations allowed", "\n", "\n", "# Number of iterations the BO loop is ran can be computed from the max number of observations and batch size", "\n", "self", ".", "iterations", "=", "math", ".", "ceil", "(", "float", "(", "self", ".", "max_num_observations", ")", "/", "float", "(", "self", ".", "batch_size", ")", ")", "\n", "\n", "# Optional parameters that have defaults", "\n", "self", ".", "noise", "=", "options", ".", "get", "(", "\"noise\"", ",", "1e-6", ")", "# Noise std the likelihood uses for observations", "\n", "\n", "# If we use comparative observations from the objective function before starting", "\n", "self", ".", "use_comparative_observations_in_init", "=", "options", ".", "get", "(", "\"use_comparative_observations_in_init\"", ",", "False", ")", "\n", "# If we use direct observations from the objective function before starting", "\n", "self", ".", "use_direct_observations_in_init", "=", "options", ".", "get", "(", "\"use_direct_observations_in_init\"", ",", "False", ")", "\n", "# Boolean indicating if the locations for the initial draws are chosen at random or selected uniformly from a grid", "\n", "self", ".", "random", "=", "options", ".", "get", "(", "\"random\"", ",", "False", ")", "\n", "\n", "self", ".", "log_file", "=", "options", ".", "get", "(", "\"log_file\"", ",", "None", ")", "# Log file used to store all print outputs during the BO", "\n", "\n", "# Configure logger", "\n", "util", ".", "configure_logger", "(", "log_file", "=", "self", ".", "log_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger": [[101, 107], ["logging.getLogger"], "methods", ["None"], ["", "def", "get_logger", "(", "self", ")", "->", "logging", ".", "Logger", ":", "\n", "        ", "\"\"\"\n        Get the logging function used to save the print outputs\n        :return: a logger where the prints are directed\n        \"\"\"", "\n", "return", "logging", ".", "getLogger", "(", "self", ".", "log_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.bayesian_optimization": [[108, 176], ["len", "GPy.likelihoods.Gaussian", "GPy.likelihoods.Gaussian.variance.constrain_fixed", "numpy.empty", "bayesian_optimization.create_bayesian_optimization_loop", "create_bayesian_optimization_loop.run_loop", "numpy.concatenate", "util.give_comparisons", "objective.f().reshape", "numpy.concatenate", "bayesian_optimization.BayesianOptimization.inference", "bayesian_optimization.BayesianOptimization.inference", "functools.partial", "tuple", "util.random_sample", "util.grid_sample", "util.random_sample", "util.grid_sample", "util.static_sample", "bayesian_optimization.BayesianOptimization.kernel.copy", "bayesian_optimization.BayesianOptimization.kernel.copy", "objective.f", "enumerate", "f().reshape", "enumerate", "range", "numpy.array", "f"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.create_bayesian_optimization_loop", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.give_comparisons", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.random_sample", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.grid_sample", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.random_sample", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.grid_sample", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.static_sample", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["", "def", "bayesian_optimization", "(", "self", ",", "objective", ":", "evalset", ".", "test_funcs", ".", "TestFunction", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        This function implements the main loop of Bayesian Optimization,\n\n        The function takes the objective\n\n        The function returns the final set of points X_all, the respective\n        batch feedbacks yc_all\n\n        :param objective: The black box function to be optimized\n        :return: The locations the function has been evaluated so far and the comparison outcomes\n        \"\"\"", "\n", "\n", "# SET UP THE GP MODEL #", "\n", "bounds", "=", "objective", ".", "bounds", "\n", "dim", "=", "len", "(", "bounds", ")", "\n", "\n", "lik", "=", "GPy", ".", "likelihoods", ".", "Gaussian", "(", ")", "\n", "lik", ".", "variance", ".", "constrain_fixed", "(", "self", ".", "noise", "**", "2", ",", "warning", "=", "False", ")", "\n", "noise", "=", "self", ".", "noise", "\n", "\n", "X0", "=", "np", ".", "empty", "(", "(", "0", ",", "dim", ")", ")", "\n", "y", "=", "[", "]", "\n", "yc", "=", "[", "]", "\n", "\n", "def", "objective_modifier", "(", "x", ",", "f", "=", "None", ",", "batch_size", "=", "1", ")", ":", "\n", "            ", "return", "np", ".", "concatenate", "(", "\n", "tuple", "(", "\n", "f", "(", "x", "[", ":", ",", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "x", ".", "shape", "[", "1", "]", "//", "batch_size", ")", "\n", ")", ",", "\n", "axis", "=", "1", ",", "\n", ")", "\n", "\n", "# Initial observations:", "\n", "", "if", "self", ".", "use_comparative_observations_in_init", ":", "\n", "            ", "if", "self", ".", "random", ":", "\n", "                ", "X0", "=", "util", ".", "random_sample", "(", "bounds", ",", "2", "**", "dim", ")", "\n", "", "else", ":", "\n", "                ", "X0", "=", "util", ".", "grid_sample", "(", "dim", ")", "\n", "", "yc", "=", "util", ".", "give_comparisons", "(", "objective", ".", "f", ",", "X0", ")", "\n", "", "if", "self", ".", "use_direct_observations_in_init", ":", "\n", "            ", "if", "self", ".", "random", ":", "\n", "                ", "Xn", "=", "util", ".", "random_sample", "(", "bounds", ",", "2", "**", "dim", ")", "\n", "", "else", ":", "\n", "                ", "Xn", "=", "util", ".", "grid_sample", "(", "dim", ")", "\n", "", "yn", "=", "objective", ".", "f", "(", "Xn", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "y", "=", "[", "(", "X0", ".", "shape", "[", "0", "]", "+", "i", ",", "yi", ")", "for", "i", ",", "yi", "in", "enumerate", "(", "yn", ")", "]", "\n", "X0", "=", "np", ".", "concatenate", "(", "(", "X0", ",", "Xn", ")", ",", "axis", "=", "0", ")", "\n", "\n", "", "if", "not", "self", ".", "use_comparative_observations_in_init", "and", "not", "self", ".", "use_direct_observations_in_init", ":", "\n", "            ", "m", "=", "self", ".", "inference", "(", "\n", "util", ".", "static_sample", "(", "bounds", ")", ",", "\n", "[", "(", "i", ",", "yi", ")", "for", "i", ",", "yi", "in", "enumerate", "(", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "0", "]", "]", ")", ")", "]", ",", "\n", "yc", ",", "\n", "self", ".", "kernel", ".", "copy", "(", ")", ",", "\n", "lik", ",", "\n", "get_logger", "=", "self", ".", "get_logger", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "m", "=", "self", ".", "inference", "(", "X0", ",", "y", ",", "yc", ",", "self", ".", "kernel", ".", "copy", "(", ")", ",", "lik", ",", "get_logger", "=", "self", ".", "get_logger", ")", "\n", "\n", "# CREATE BO LOOP #", "\n", "", "bo_loop", "=", "create_bayesian_optimization_loop", "(", "m", ",", "bounds", ",", "self", ".", "batch_size", ",", "self", ".", "acquisition", ")", "\n", "\n", "# RUN THE LOOP #", "\n", "bo_loop", ".", "run_loop", "(", "partial", "(", "objective_modifier", ",", "f", "=", "objective", ".", "f", ",", "batch_size", "=", "self", ".", "batch_size", ")", ",", "self", ".", "iterations", ")", "\n", "return", "m", ".", "X", ",", "m", ".", "yc", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.create_bayesian_optimization_loop": [[24, 59], ["ComparisonGPEmukitWrapper", "acquisitions.EmukitAcquisitionFunctionWrapper", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop", "type", "range", "emukit.core.ParameterSpace", "acquisitions.SequentialGradientAcquisitionOptimizer", "range", "emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "len", "range", "emukit.core.ContinuousParameter", "len", "emukit.core.ContinuousParameter"], "function", ["None"], ["def", "create_bayesian_optimization_loop", "(", "\n", "gpy_model", ":", "ComparisonGP", ",", "lims", ":", "np", ".", "array", ",", "batch_size", ":", "int", ",", "acquisition", ":", "AcquisitionFunction", "\n", ")", "->", "BayesianOptimizationLoop", ":", "\n", "    ", "\"\"\"\n    Creates Bayesian optimization loop for Bayesian neural network or random forest models.\n    :param gpy_model: the GPy model used in optimization\n    :param lims: Optimization limits for the inputs\n    :param batch_size: number of observations used in batch\n    :param acquisition: acquisition function used in the bayesian optimization\n    :return: emukit BO loop\n    \"\"\"", "\n", "\n", "# Create model", "\n", "model", "=", "ComparisonGPEmukitWrapper", "(", "gpy_model", ",", "batch_size", ")", "\n", "\n", "# Create acquisition", "\n", "emukit_acquisition", "=", "EmukitAcquisitionFunctionWrapper", "(", "model", ",", "acquisition", ")", "\n", "\n", "if", "type", "(", "emukit_acquisition", ".", "acquisitionFunction", ")", "is", "ThompsonSampling", ":", "\n", "        ", "parameter_space", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "lims", ")", ")", ":", "\n", "            ", "parameter_space", "+=", "[", "ContinuousParameter", "(", "\"x{}\"", ".", "format", "(", "j", ")", ",", "lims", "[", "j", "]", "[", "0", "]", ",", "lims", "[", "j", "]", "[", "1", "]", ")", "]", "\n", "", "parameter_space", "=", "ParameterSpace", "(", "parameter_space", ")", "\n", "acquisition_optimizer", "=", "SequentialGradientAcquisitionOptimizer", "(", "parameter_space", ",", "batch_size", ")", "\n", "", "else", ":", "\n", "        ", "parameter_space", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "len", "(", "lims", ")", ")", ":", "\n", "                ", "parameter_space", "+=", "[", "ContinuousParameter", "(", "\"x{}{}\"", ".", "format", "(", "k", ",", "j", ")", ",", "lims", "[", "j", "]", "[", "0", "]", ",", "lims", "[", "j", "]", "[", "1", "]", ")", "]", "\n", "", "", "parameter_space", "=", "ParameterSpace", "(", "parameter_space", ")", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "parameter_space", ")", "\n", "\n", "", "bo", "=", "BayesianOptimizationLoop", "(", "model", "=", "model", ",", "space", "=", "parameter_space", ",", "acquisition", "=", "emukit_acquisition", ")", "\n", "return", "BayesianOptimizationLoop", "(", "\n", "model", "=", "model", ",", "space", "=", "parameter_space", ",", "acquisition", "=", "emukit_acquisition", ",", "acquisition_optimizer", "=", "acquisition_optimizer", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.random_sample": [[8, 23], ["len", "numpy.zeros", "range", "numpy.random.uniform"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform"], ["def", "random_sample", "(", "bounds", ":", "np", ".", "ndarray", ",", "k", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Generate a set of k n-dimensional points sampled uniformly at random\n    :param bounds: n x 2 dimenional array containing upper/lower bounds for each dimension\n    :param k: number of samples\n    :return: k x n array containing the sampled points\n    \"\"\"", "\n", "\n", "# k: Number of points", "\n", "n", "=", "len", "(", "bounds", ")", "# Dimensionality of each point", "\n", "X", "=", "np", ".", "zeros", "(", "(", "k", ",", "n", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "X", "[", ":", ",", "i", "]", "=", "np", ".", "random", ".", "uniform", "(", "bounds", "[", "i", "]", "[", "0", "]", ",", "bounds", "[", "i", "]", "[", "1", "]", ",", "k", ")", "\n", "\n", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.static_sample": [[25, 38], ["len", "numpy.zeros", "range"], "function", ["None"], ["", "def", "static_sample", "(", "bounds", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Generate two locations outside the bounds\n\n    :param bounds: n x 2 dimenional array containing upper/lower bounds for each dimension\n    :return: 2 x n array containing the sampled points\n    \"\"\"", "\n", "n", "=", "len", "(", "bounds", ")", "# Dimensionality of each point", "\n", "X", "=", "np", ".", "zeros", "(", "(", "2", ",", "n", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "X", "[", "0", ",", "i", "]", "=", "bounds", "[", "i", "]", "[", "1", "]", "+", "5", "*", "(", "bounds", "[", "i", "]", "[", "1", "]", "-", "bounds", "[", "i", "]", "[", "0", "]", ")", "\n", "X", "[", "1", ",", "i", "]", "=", "bounds", "[", "i", "]", "[", "0", "]", "-", "5", "*", "(", "bounds", "[", "i", "]", "[", "1", "]", "-", "bounds", "[", "i", "]", "[", "0", "]", ")", "\n", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.grid_sample": [[40, 112], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "grid_sample", "(", "n", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Get a grid with equally distanced points\n\n    :param n: dimensionality of the data\n    :return: 2^n samples that are placed in a n dimendional grid\n    \"\"\"", "\n", "if", "n", "==", "1", ":", "\n", "        ", "ret", "=", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "1", "]", "]", ")", "\n", "", "if", "n", "==", "2", ":", "\n", "        ", "ret", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "1", "]", ",", "[", "1", ",", "0", "]", ",", "[", "1", ",", "1", "]", "]", ")", "\n", "", "if", "n", "==", "3", ":", "\n", "        ", "ret", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", ",", "[", "0", ",", "1", ",", "1", "]", ",", "[", "1", ",", "0", ",", "0", "]", ",", "[", "1", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", "]", ",", "[", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "", "if", "n", "==", "4", ":", "\n", "        ", "ret", "=", "np", ".", "array", "(", "\n", "[", "\n", "[", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "]", "\n", ")", "\n", "", "if", "n", "==", "5", ":", "\n", "        ", "ret", "=", "np", ".", "array", "(", "\n", "[", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "]", "\n", ")", "\n", "", "return", "(", "ret", ")", "*", "(", "0.5", ")", "+", "0.25", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.give_comparisons": [[114, 127], ["numpy.random.permutation", "func().reshape", "func", "range", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.func"], ["", "def", "give_comparisons", "(", "func", ":", "Callable", ",", "points", ":", "np", ".", "ndarray", ",", "si", ":", "int", "=", "0", ")", "->", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Evaluates the function in given batch and returns the batch winner in a form accepted by the inference algorithms\n\n    :param func: the black box objective\n    :param points: batch locations\n    :param si: starting index of the batch (the number of points evaluated so far)\n    :return: Compar\n    \"\"\"", "\n", "ind", "=", "np", ".", "random", ".", "permutation", "(", "points", ".", "shape", "[", "0", "]", ")", "\n", "y", "=", "func", "(", "points", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "s1", ",", "s2", "=", "ind", "[", ":", ":", "2", "]", ",", "ind", "[", "1", ":", ":", "2", "]", "\n", "return", "[", "[", "(", "s1", "[", "i", "]", "+", "si", ",", "s2", "[", "i", "]", "+", "si", ")", "]", "if", "y", "[", "s1", "[", "i", "]", "]", "<", "y", "[", "s2", "[", "i", "]", "]", "else", "[", "(", "s1", "[", "i", "]", "+", "si", ",", "s2", "[", "i", "]", "+", "si", ")", "]", "for", "i", "in", "range", "(", "len", "(", "s1", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.boundit": [[129, 143], ["enumerate"], "function", ["None"], ["", "def", "boundit", "(", "x", ":", "np", ".", "ndarray", ",", "bounds", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Projects input to be within the bounds\n\n    :param x: The point to be projected\n    :param bounds: bounds of the hyper rectangle the point should be within\n    :return: the point projected to be within the inputs\n    \"\"\"", "\n", "for", "i", ",", "bound", "in", "enumerate", "(", "bounds", ")", ":", "\n", "        ", "if", "x", "[", "i", "]", "<", "bound", "[", "0", "]", ":", "\n", "            ", "x", "[", "i", "]", "=", "bound", "[", "0", "]", "\n", "", "elif", "x", "[", "i", "]", ">", "bound", "[", "1", "]", ":", "\n", "            ", "x", "[", "i", "]", "=", "bound", "[", "1", "]", "\n", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.running_mean": [[145, 155], ["numpy.cumsum", "numpy.insert", "float"], "function", ["None"], ["", "def", "running_mean", "(", "x", ":", "np", ".", "ndarray", ",", "N", ":", "int", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Computes the running mean of N members for the array. The returned array is of length len(x)-N\n\n    :param x: the input array for which we want to compute the running mean\n    :param N: The length of the running mean window\n    :return: The running mean of the array. Te returned array is of length len(x)-N\n    \"\"\"", "\n", "cumsum", "=", "np", ".", "cumsum", "(", "np", ".", "insert", "(", "x", ",", "0", ",", "0", ")", ")", "\n", "return", "(", "cumsum", "[", "N", ":", "]", "-", "cumsum", "[", ":", "-", "N", "]", ")", "/", "float", "(", "N", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.max_difference": [[157, 174], ["max", "min"], "function", ["None"], ["", "def", "max_difference", "(", "xs", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "\"\"\"\n    Computes the maximum change in the input when iterating through it and moving from the previus value to the next one\n\n    :param xs: array from which the max difference is wanted to be computed\n    :return: maximum difference between the proceeding indices\n    \"\"\"", "\n", "min_elem", "=", "xs", "[", "0", "]", "\n", "max_elem", "=", "xs", "[", "0", "]", "\n", "max_diff", "=", "-", "1", "\n", "\n", "for", "elem", "in", "xs", "[", "1", ":", "]", ":", "\n", "        ", "min_elem", "=", "min", "(", "elem", ",", "min_elem", ")", "\n", "if", "elem", ">", "max_elem", ":", "\n", "            ", "max_elem", "=", "elem", "\n", "", "", "max_diff", "=", "max", "(", "max_diff", ",", "max_elem", "-", "min_elem", ")", "\n", "return", "max_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.adam": [[176, 242], ["objective", "get_logger().debug", "get_logger().debug", "numpy.mean", "numpy.mean", "objective", "util.boundit", "len", "get_logger", "numpy.sqrt", "util.max_difference", "get_logger", "get_logger().error", "util.running_mean", "get_logger"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.objective", "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.objective", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.boundit", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.max_difference", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.running_mean", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger"], ["", "def", "adam", "(", "\n", "objective", ":", "Callable", ",", "\n", "x0", ":", "np", ".", "ndarray", ",", "\n", "args", ":", "Dict", ",", "\n", "max_it", ":", "int", "=", "500", ",", "\n", "alpha", ":", "float", "=", "0.01", ",", "\n", "beta1", ":", "float", "=", "0.9", ",", "\n", "beta2", ":", "float", "=", "0.999", ",", "\n", "eps", ":", "float", "=", "1e-8", ",", "\n", "tol", ":", "float", "=", "1e-3", ",", "\n", "lag", ":", "int", "=", "100", ",", "\n", "bounds", ":", "np", ".", "ndarray", "=", "None", ",", "\n", "Nw", ":", "int", "=", "20", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "float", ",", "float", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Runs adam optimization algorithm for the objective\n\n    :param objective: The function to be optimized\n    :param x0: starting location\n    :param args: additional arguments for objective\n    :param max_it: maximum number of iterations\n    :param alpha: learning rate\n    :param beta1: tuning parameter between [0,1], generally close to 1\n    :param beta2: tuning parameter between [0,1], generally close to 1\n    :param eps: a pparameter that helps avoid division by zero when computing the new parameter\n    :param tol: tolerance the optimization is ended after which the running mean goes\n    :param lag: how many iterations are waited and the change in the running mean must be less than the tolerance\n    :param bounds: optimization bounds\n    :param Nw: how many iterations are used t ovompute the running mean\n    :param get_logger: Function for receiving the legger where the prints are forwarded.\n    :return: A tuple that contain the optimized location, mean of the 5 last iterations, and the whole optimization history of points\n    \"\"\"", "\n", "x", "=", "x0", "\n", "c", "=", "0", "\n", "mt", ",", "vt", "=", "0.0", ",", "0.0", "# moving average of gradient and squared gradient", "\n", "fs", "=", "[", "]", "\n", "xs", "=", "[", "x0", "]", "\n", "if", "get_logger", "is", "not", "None", ":", "\n", "        ", "f", ",", "grad", "=", "objective", "(", "x", ",", "args", ")", "\n", "get_logger", "(", ")", ".", "debug", "(", "\"Starting from: {} with acq {}\"", ".", "format", "(", "x", ",", "f", ")", ")", "\n", "", "it", "=", "0", "\n", "while", "it", "<", "max_it", ":", "\n", "        ", "try", ":", "\n", "            ", "f", ",", "grad", "=", "objective", "(", "x", ",", "args", ")", "\n", "", "except", ":", "\n", "            ", "if", "get_logger", "is", "not", "None", ":", "\n", "                ", "get_logger", "(", ")", ".", "error", "(", "\"Error in objective when optimizing with Adam. Location:\\n\"", ".", "format", "(", "x", ")", ")", "\n", "", "break", "\n", "", "mt", "=", "beta1", "*", "mt", "+", "(", "1", "-", "beta1", ")", "*", "grad", "# update the moving averages of the gradient", "\n", "vt", "=", "beta2", "*", "vt", "+", "(", "1", "-", "beta2", ")", "*", "(", "grad", "**", "2", ")", "# updates the moving averages of the squared gradient", "\n", "m_cap", "=", "mt", "/", "(", "1", "-", "(", "beta1", "**", "(", "it", "+", "1", ")", ")", ")", "# calculates the bias-corrected estimates", "\n", "v_cap", "=", "vt", "/", "(", "1", "-", "(", "beta2", "**", "(", "it", "+", "1", ")", ")", ")", "# calculates the bias-corrected estimates", "\n", "delta", "=", "(", "alpha", "*", "m_cap", ")", "/", "(", "np", ".", "sqrt", "(", "v_cap", ")", "+", "eps", ")", "\n", "x", "=", "x", "-", "delta", "\n", "if", "bounds", "is", "not", "None", ":", "\n", "            ", "x", "=", "boundit", "(", "x", ",", "bounds", ")", "\n", "", "fs", "+=", "[", "f", "]", "\n", "xs", "+=", "[", "x", "]", "\n", "if", "(", "it", ">", "lag", "+", "Nw", "-", "1", ")", "and", "(", "max_difference", "(", "running_mean", "(", "fs", ",", "Nw", ")", "[", "-", "lag", ":", "]", ")", "<", "tol", ")", ":", "\n", "            ", "break", "\n", "", "it", "+=", "1", "\n", "", "if", "get_logger", "is", "not", "None", ":", "\n", "        ", "get_logger", "(", ")", ".", "debug", "(", "\"Ended to: {} with acq {} and gradient {} in {} iterations\"", ".", "format", "(", "x", ",", "f", ",", "grad", ",", "it", ")", ")", "\n", "", "fsr", "=", "np", ".", "mean", "(", "fs", "[", "-", "5", ":", "]", ")", "if", "len", "(", "fs", ")", ">", "4", "else", "np", ".", "mean", "(", "fs", ")", "\n", "return", "x", ",", "fsr", ",", "xs", "# return the mean of the 5 previous values to reduce stochasticity", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.configure_logger": [[244, 261], ["logging.getLogger.addHandler", "logging.getLogger.setLevel", "logging.getLogger", "logging.StreamHandler", "logging.getLogger", "logging.Formatter", "logging.FileHandler", "logging.FileHandler.setFormatter"], "function", ["None"], ["", "def", "configure_logger", "(", "log_file", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Configures the file the prints are forwarded to\n\n    :param log_file: The file the prints are forwarded to\n    \"\"\"", "\n", "if", "log_file", "is", "None", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"logger.log\"", ")", "# default logger", "\n", "file_handler", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "", "else", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "log_file", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "\"%(asctime)s - %(levelname)-8s \\n %(message)s\"", ")", "\n", "file_handler", "=", "logging", ".", "FileHandler", "(", "log_file", ",", "mode", "=", "\"w\"", ")", "\n", "file_handler", ".", "setFormatter", "(", "formatter", ")", "\n", "", "logger", ".", "addHandler", "(", "file_handler", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.comparison_form": [[263, 274], ["len", "numpy.argsort", "y.flatten", "range"], "function", ["None"], ["", "def", "comparison_form", "(", "y", ":", "np", ".", "ndarray", ")", "->", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Transforms the already existing observations to the comparison form\n\n    :param y: function evaluations in a batch\n    :return: comparison form for the outputs\n    \"\"\"", "\n", "m", "=", "len", "(", "y", ")", "\n", "assert", "m", ">", "1", "\n", "ind", "=", "np", ".", "argsort", "(", "y", ".", "flatten", "(", ")", ")", "\n", "return", "[", "(", "ind", "[", "0", "]", ",", "ind", "[", "i", "]", ")", "for", "i", "in", "range", "(", "1", ",", "m", ")", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.dL_fr": [[26, 47], ["numpy.zeros_like", "range", "range", "numpy.zeros_like", "numpy.trace"], "function", ["None"], ["def", "dL_fr", "(", "L", ":", "np", ".", "ndarray", ",", "dsigma", ":", "np", ".", "ndarray", ",", "alpha", ":", "np", ".", "ndarray", ",", "beta", ":", "np", ".", "ndarray", ",", "K", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "\"\"\"\n    Partial derivative of function with respect to beta using cholesky decomposition and the generalized matrix chain rule\n    The ending _fr comes from \"full rank\", this method should be used when we use the full rank parametrization\n\n    :param L: Cholesky decomposition of Sigma: Sigma= L L^T\n    :param dsigma: derivative of the function with respect to Sigma\n    :param alpha: alpha parameter\n    :param beta: beta parameter, the vector the derivative is taken with respect to\n    :param K: prior covariance matrix\n    :return: The derivative of function with respect to beta\n    \"\"\"", "\n", "Sigma", "=", "L", "@", "L", ".", "T", "\n", "t2", "=", "np", ".", "zeros_like", "(", "dsigma", ")", "\n", "for", "m", "in", "range", "(", "t2", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "n", "in", "range", "(", "m", "+", "1", ")", ":", "\n", "            ", "dl", "=", "np", ".", "zeros_like", "(", "dsigma", ")", "\n", "dl", "[", "m", ",", ":", "]", "=", "L", "[", ":", ",", "n", "]", ".", "T", "\n", "dl", "+=", "dl", ".", "T", "\n", "t2", "[", "m", ",", "n", "]", "=", "np", ".", "trace", "(", "dsigma", ".", "T", "@", "dl", ")", "\n", "", "", "return", "t2", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.dL_mf": [[49, 72], ["numpy.zeros", "numpy.zeros", "numpy.zeros_like", "range", "range", "numpy.trace", "range"], "function", ["None"], ["", "def", "dL_mf", "(", "L", ":", "np", ".", "ndarray", ",", "dsigma", ":", "np", ".", "ndarray", ",", "alpha", ":", "np", ".", "ndarray", ",", "beta", ":", "np", ".", "ndarray", ",", "K", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "\"\"\"\n    Partial derivative of function with respect to beta using cholesky decomposition and the generalized matrix chain rule\n    The ending _fr comes from \"mean field\", this method should be used when we use the meaan field parametrization\n\n    :param L: Cholesky decomposition of Sigma: Sigma= L L^T\n    :param dsigma: derivative of the function with respect to Sigma\n    :param alpha: alpha parameter\n    :param beta: beta parameter, the vector the derivative is taken with respect to\n    :param K: prior covariance matrix\n    :return: The derivative of function with respect to beta\n    \"\"\"", "\n", "dL", "=", "np", ".", "zeros", "(", "(", "L", ".", "shape", "[", "0", "]", ",", "L", ".", "shape", "[", "1", "]", ",", "beta", ".", "shape", "[", "0", "]", ")", ")", "\n", "dL2", "=", "np", ".", "zeros", "(", "(", "L", ".", "shape", "[", "0", "]", ",", "L", ".", "shape", "[", "1", "]", ",", "beta", ".", "shape", "[", "0", "]", ")", ")", "\n", "res", "=", "np", ".", "zeros_like", "(", "beta", ")", "\n", "\n", "S", "=", "L", "@", "L", ".", "T", "\n", "for", "k", "in", "range", "(", "beta", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "L", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "L", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "dL", "[", "i", ",", "j", ",", "k", "]", "=", "-", "2.0", "*", "beta", "[", "k", "]", "*", "S", "[", "i", ",", "k", "]", "*", "S", "[", "j", ",", "k", "]", "\n", "", "", "res", "[", "k", "]", "+=", "np", ".", "trace", "(", "dsigma", ".", "T", "@", "dL", "[", ":", ",", ":", ",", "k", "]", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.dSigma_dLmn": [[74, 89], ["L.copy"], "function", ["None"], ["", "def", "dSigma_dLmn", "(", "L", ":", "np", ".", "ndarray", ",", "m", ":", "int", ",", "n", ":", "int", ")", ":", "\n", "    ", "\"\"\"\n    Partial derivative of Sigma with respect to one element of L when Sigma=L L^T\n\n    :param L: Cholesky decomposition of sigma\n    :param m: row index in L\n    :param n: column index in L\n    :return: partial derivative of Sigma\n    \"\"\"", "\n", "delta", "=", "1e-5", "\n", "L_new", "=", "L", ".", "copy", "(", ")", "\n", "L_new", "[", "m", ",", "n", "]", "+=", "delta", "\n", "Sigma_new", "=", "L_new", "@", "L_new", ".", "T", "\n", "Sigma", "=", "L", "@", "L", ".", "T", "\n", "return", "(", "Sigma_new", "-", "Sigma", ")", "/", "delta", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.comp_y_ij": [[91, 103], ["numpy.sqrt"], "function", ["None"], ["", "def", "comp_y_ij", "(", "mu", ":", "np", ".", "ndarray", ",", "Sigma", ":", "np", ".", "ndarray", ",", "i", ":", "int", ",", "j", ":", "int", ",", "epsilon", ":", "float", ")", ":", "\n", "    ", "\"\"\"\n    A helper method to compute the mean and covariance of y_j-y_j when we know the joint distribution of f and y=f+noise, where noise has standard deviation epsilon\n    :param mu: mean of latent function f\n    :param Sigma: covariance of latent function f\n    :param i: index i in y_j - y_i\n    :param j: index j in y_j - y_i\n    :param epsilon: noise standard deviation of y\n    \"\"\"", "\n", "m_diff", "=", "mu", "[", "j", "]", "-", "mu", "[", "i", "]", "\n", "sigma_diff", "=", "np", ".", "sqrt", "(", "Sigma", "[", "i", ",", "i", "]", "+", "Sigma", "[", "j", ",", "j", "]", "+", "2", "*", "Sigma", "[", "i", ",", "j", "]", ")", "\n", "return", "m_diff", "+", "sigma_diff", "*", "epsilon", ",", "sigma_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.variational_expectations_ove_full_rank": [[105, 144], ["numpy.zeros", "numpy.zeros", "numpy.polynomial.hermite.hermgauss", "numpy.sqrt", "vi_batch_comparison.comp_y_ij", "numpy.sum", "sigmoid", "numpy.sum", "numpy.sum", "dF_dSigma[].copy", "numpy.sum", "numpy.log", "sigmoid", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.comp_y_ij"], ["", "def", "variational_expectations_ove_full_rank", "(", "\n", "mf", ":", "np", ".", "ndarray", ",", "Sigma", ":", "np", ".", "ndarray", ",", "ind_winners", ":", "List", "[", "int", "]", ",", "ind_loosers", ":", "List", "[", "int", "]", ",", "sigma2s", ":", "float", "=", "1.0", "\n", ")", "->", "Tuple", "[", "float", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Computes the variational expectation and derivatives for the full rank approximation for a single batch\n\n    :param mf: mean of the latent function approximation of the batch\n    :param Sigma: Covariance of the latent function approximation of the batch\n    :param ind_winners: List of batch winners in each pairwise comparisons. We assume that the feedback is given as batch winner form\n    :param ind_loosers: List of batch loosers in each pairwise comparisons\n    :param sigma2s: noise variance of the observations\n    :return: expectation and its derivatives with respect to mean and covariance\n    \"\"\"", "\n", "N", "=", "mf", ".", "shape", "[", "0", "]", "\n", "\n", "dF_dm", "=", "np", ".", "zeros", "(", "(", "N", ",", "1", ")", ")", "\n", "dF_dSigma", "=", "np", ".", "zeros", "(", "(", "N", ",", "N", ")", ")", "\n", "\n", "# Integration by quadrature", "\n", "gh_x", ",", "gh_w", "=", "np", ".", "polynomial", ".", "hermite", ".", "hermgauss", "(", "25", ")", "\n", "gh_w", "=", "gh_w", "/", "np", ".", "sqrt", "(", "np", ".", "pi", ")", "\n", "\n", "# to make sigmoid look more like probit", "\n", "sigma2s", "=", "sigma2s", "/", "1.6", "\n", "\n", "F", "=", "0", "\n", "\n", "# i is the winner:", "\n", "i", "=", "ind_winners", "[", "0", "]", "\n", "for", "j", "in", "ind_loosers", ":", "\n", "        ", "y_ij", ",", "sigma_ij", "=", "comp_y_ij", "(", "mf", ",", "Sigma", ",", "i", ",", "j", ",", "gh_x", ")", "\n", "F", "+=", "np", ".", "sum", "(", "np", ".", "log", "(", "sigmoid", "(", "y_ij", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma2s", "[", "i", "]", ")", ")", ")", "*", "gh_w", ")", "\n", "ms_y_ij", "=", "sigmoid", "(", "-", "y_ij", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma2s", "[", "i", "]", ")", ")", "\n", "dF_dm", "[", "i", ",", "0", "]", "+=", "np", ".", "sum", "(", "-", "gh_w", "*", "ms_y_ij", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma2s", "[", "i", "]", ")", ")", "\n", "dF_dm", "[", "j", ",", "0", "]", "=", "np", ".", "sum", "(", "gh_w", "*", "ms_y_ij", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma2s", "[", "i", "]", ")", ")", "\n", "dF_dSigma", "[", "j", ",", "j", "]", "=", "0.5", "*", "np", ".", "sum", "(", "gh_w", "*", "ms_y_ij", "/", "sigma_ij", "*", "gh_x", "/", "(", "np", ".", "sqrt", "(", "2", ")", "*", "sigma2s", "[", "i", "]", ")", ")", "\n", "dF_dSigma", "[", "i", ",", "i", "]", "+=", "dF_dSigma", "[", "j", ",", "j", "]", ".", "copy", "(", ")", "\n", "dF_dSigma", "[", "i", ",", "j", "]", "=", "2.0", "*", "dF_dSigma", "[", "j", ",", "j", "]", "\n", "", "return", "F", ",", "dF_dm", ",", "dF_dSigma", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.df_d": [[146, 223], ["numpy.zeros_like", "numpy.zeros_like", "numpy.random.choice", "s_to_l", "range", "numpy.sort", "vi_batch_comparison.variational_expectations_ove_full_rank", "len", "numpy.zeros", "numpy.zeros", "range", "GPy.util.choleskies._triang_to_flat_pure", "len", "len", "numpy.unique", "len", "len", "numpy.sum", "sigma2s[].reshape", "sigma2s[].reshape", "numpy.ix_", "len", "range", "range", "numpy.ix_", "sigma2s[].reshape", "len", "len", "numpy.where", "numpy.where", "Sigma[].reshape"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.variational_expectations_ove_full_rank"], ["", "def", "df_d", "(", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "m", ":", "np", ".", "ndarray", ",", "\n", "L", ":", "np", ".", "ndarray", ",", "\n", "L_inv", ":", "np", ".", "ndarray", ",", "\n", "K", ":", "np", ".", "ndarray", ",", "\n", "sigma2s", ":", "np", ".", "ndarray", ",", "\n", "alpha", ":", "np", ".", "ndarray", ",", "\n", "beta", ":", "np", ".", "ndarray", ",", "\n", "s_to_l", ":", "Callable", "=", "dL_fr", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Computes the log marginal likelihood and its derivatives with respect to alpha and beta. Works for both mean feald and full rank approximations\n\n    :param y: Direct observations in as a list of tuples telling location index (row in X) and observation value.\n    :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n    :param m: mean of the latent values\n    :param L: Cholesky decomposition of the latent value covariance\n    :param L_inv: inverse of the cholesky decomposition\n    :param K: prior covariance\n    :param sigma2s: noise variance of the observations\n    :param alpha: Alpha vector used to parametrize the posterior approximation\n    :param beta: Beta vector/matrix used to parametrize the posterior approximation\n    :param s_to_l: A function to compute the derivative of log likelihood with respect to beta using the generalized chain rule and when we know the derivative of log likelihood with respect to Sigma\n    :return: A tuple containing log marginal likelihood, its derivative with respect to alpha and its derivative with respect to beta\n    \"\"\"", "\n", "Sigma", "=", "L", "@", "L", ".", "T", "\n", "\n", "dF_dm_full", "=", "np", ".", "zeros_like", "(", "m", ")", "\n", "dF_dSigma_full", "=", "np", ".", "zeros_like", "(", "Sigma", ")", "\n", "F_full", "=", "0", "\n", "# log_marginal = 0", "\n", "d_list", "=", "np", ".", "random", ".", "choice", "(", "range", "(", "len", "(", "yc", ")", ")", ",", "size", "=", "len", "(", "yc", ")", ",", "replace", "=", "False", ")", "\n", "for", "batch_idx", "in", "d_list", ":", "\n", "        ", "loc_inds_winners", ",", "loc_inds_losers", "=", "[", "yc", "[", "batch_idx", "]", "[", "k", "]", "[", "0", "]", "for", "k", "in", "range", "(", "len", "(", "yc", "[", "batch_idx", "]", ")", ")", "]", ",", "[", "\n", "yc", "[", "batch_idx", "]", "[", "k", "]", "[", "1", "]", "for", "k", "in", "range", "(", "len", "(", "yc", "[", "batch_idx", "]", ")", ")", "\n", "]", "\n", "loc_inds_batch", "=", "np", ".", "sort", "(", "np", ".", "unique", "(", "loc_inds_winners", "+", "loc_inds_losers", ")", ")", "\n", "# get winners", "\n", "ind_winners", ",", "ind_losers", "=", "[", "np", ".", "where", "(", "loc_inds_batch", "==", "it", ")", "[", "0", "]", "[", "0", "]", "for", "it", "in", "loc_inds_winners", "]", ",", "[", "\n", "np", ".", "where", "(", "loc_inds_batch", "==", "it", ")", "[", "0", "]", "[", "0", "]", "for", "it", "in", "loc_inds_losers", "\n", "]", "\n", "\n", "# get variational moments", "\n", "F_batch", ",", "dF_dm_batch", ",", "dF_dSigma_batch", "=", "variational_expectations_ove_full_rank", "(", "\n", "m", "[", "loc_inds_batch", "]", ",", "\n", "Sigma", "[", "np", ".", "ix_", "(", "loc_inds_batch", ",", "loc_inds_batch", ")", "]", ",", "\n", "ind_winners", ",", "\n", "ind_losers", ",", "\n", "sigma2s", "[", "loc_inds_batch", "]", ",", "\n", ")", "\n", "dF_dm_full", "[", "loc_inds_batch", "]", "+=", "dF_dm_batch", "\n", "dF_dSigma_full", "[", "np", ".", "ix_", "(", "loc_inds_batch", ",", "loc_inds_batch", ")", "]", "+=", "dF_dSigma_batch", "\n", "F_full", "+=", "F_batch", "\n", "\n", "# delta = 1e-5", "\n", "", "if", "len", "(", "y", ")", ">", "0", ":", "\n", "        ", "ys", "=", "np", ".", "zeros", "(", "(", "len", "(", "y", ")", ",", "1", ")", ")", "\n", "y_inds", "=", "np", ".", "zeros", "(", "len", "(", "y", ")", ",", "dtype", "=", "int", ")", "\n", "# dir_list = np.random.choice(range(len(y)), size=len(y), replace=False)", "\n", "for", "ind", "in", "range", "(", "len", "(", "y", ")", ")", ":", "\n", "            ", "(", "y_inds", "[", "ind", "]", ",", "ys", "[", "ind", ",", "0", "]", ")", "=", "y", "[", "ind", "]", "# index in kernel, y value", "\n", "", "F_full", "+=", "-", "0.5", "*", "np", ".", "sum", "(", "\n", "(", "(", "m", "[", "y_inds", "]", "-", "ys", ")", "**", "2", "+", "Sigma", "[", "y_inds", ",", "y_inds", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ")", "/", "sigma2s", "[", "y_inds", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", ")", "\n", "dF_dm_full", "[", "y_inds", "]", "+=", "(", "ys", "-", "m", "[", "y_inds", "]", ")", "/", "sigma2s", "[", "y_inds", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "dF_dSigma_full", "[", "y_inds", ",", "y_inds", "]", "+=", "-", "0.5", "/", "sigma2s", "[", "y_inds", "]", ".", "reshape", "(", "(", "-", "1", ")", ")", "\n", "\n", "", "alpha_grad", "=", "K", "@", "dF_dm_full", "\n", "\n", "beta_grad", "=", "s_to_l", "(", "L", ",", "dF_dSigma_full", ",", "alpha", ",", "beta", ",", "K", ")", "\n", "\n", "log_marginal", "=", "F_full", "\n", "if", "beta_grad", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "        ", "beta_grad", "=", "choleskies", ".", "_triang_to_flat_pure", "(", "beta_grad", ")", "\n", "", "return", "log_marginal", ",", "alpha_grad", ",", "beta_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.recompute_posterior_fr": [[225, 262], ["GPy.util.choleskies._flat_to_triang_pure", "numpy.diag", "m.copy", "numpy.linalg.inv", "numpy.linalg.inv", "numpy.empty", "numpy.dot", "numpy.linalg.inv", "GPy.util.choleskies._triang_to_flat_pure", "vi_batch_comparison.dL_fr", "numpy.log", "numpy.eye", "numpy.trace", "numpy.linalg.det", "numpy.linalg.inv"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.dL_fr"], ["", "def", "recompute_posterior_fr", "(", "\n", "alpha", ":", "np", ".", "ndarray", ",", "beta", ":", "np", ".", "ndarray", ",", "K", ":", "np", ".", "ndarray", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Recompute the posterior approximation (for the full rank approximation) mean: K alpha, covariance inv(K + beta)\n    :param alpha: Alpha vector used to parametrize the posterior approximation\n    :param beta: Beta vector/matrix used to parametrize the posterior approximation\n    :param K: prior covariance\n    :return: Tuple containing the mean and cholesky of the covariance, its inverse and derivatives of the KL divergence with respect to beta and alpha\n    \"\"\"", "\n", "N", "=", "K", ".", "shape", "[", "0", "]", "\n", "L", "=", "choleskies", ".", "_flat_to_triang_pure", "(", "beta", ")", "\n", "assert", "L", ".", "shape", "[", "0", "]", "==", "1", "\n", "L", "=", "L", "[", "0", ",", ":", ",", ":", "]", "\n", "lam_sqrt", "=", "np", ".", "diag", "(", "L", ")", "\n", "lam", "=", "lam_sqrt", "**", "2", "\n", "\n", "# Compute Mean", "\n", "m", "=", "K", "@", "alpha", "\n", "jitter", "=", "1e-5", "\n", "dKL_da", "=", "m", ".", "copy", "(", ")", "\n", "Kinv", "=", "np", ".", "linalg", ".", "inv", "(", "K", "+", "np", ".", "eye", "(", "N", ")", "*", "jitter", ")", "\n", "L_inv", "=", "np", ".", "linalg", ".", "inv", "(", "L", ")", "\n", "\n", "Sigma", "=", "np", ".", "empty", "(", "(", "alpha", ".", "size", ",", "alpha", ".", "shape", "[", "0", "]", ")", ")", "\n", "Lamda_full_rank", "=", "np", ".", "dot", "(", "L", ",", "L", ".", "T", ")", "\n", "\n", "dKL_db_triang", "=", "-", "dL_fr", "(", "L", ",", "0.5", "*", "(", "np", ".", "linalg", ".", "inv", "(", "Lamda_full_rank", ")", "-", "Kinv", ")", ",", "None", ",", "None", ",", "None", ")", "\n", "\n", "mat1", "=", "np", ".", "linalg", ".", "inv", "(", "K", "+", "Lamda_full_rank", ")", "\n", "# Sigma = np.linalg.inv(Kinv + np.linalg.inv(Lamda_full_rank))", "\n", "Sigma", "=", "Lamda_full_rank", "\n", "# Compute KL", "\n", "KL", "=", "0.5", "*", "(", "-", "N", "+", "(", "m", ".", "T", "@", "Kinv", "@", "m", ")", "+", "np", ".", "trace", "(", "Kinv", "@", "Sigma", ")", "-", "np", ".", "log", "(", "np", ".", "linalg", ".", "det", "(", "Sigma", "@", "Kinv", ")", ")", ")", "\n", "dKL_db", "=", "choleskies", ".", "_triang_to_flat_pure", "(", "dKL_db_triang", ")", "\n", "\n", "return", "m", ",", "L", ",", "L_inv", ",", "KL", ",", "dKL_db", ",", "dKL_da", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.recompute_posterior_mf": [[264, 307], ["beta.ravel", "GPy.util.linalg.pdinv", "numpy.diag().reshape", "m.copy", "GPy.util.linalg.jitchol", "numpy.linalg.inv", "beta.ravel", "numpy.diag", "numpy.diag", "numpy.eye", "numpy.diag", "numpy.diag", "Ai.dot", "numpy.sum", "numpy.diag", "numpy.dot", "numpy.trace"], "function", ["None"], ["", "def", "recompute_posterior_mf", "(", "\n", "alpha", ":", "np", ".", "ndarray", ",", "beta", ":", "np", ".", "ndarray", ",", "K", ":", "np", ".", "ndarray", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Recompute the posterior approximation (for the mean field approximation) mean: K alpha, covariance inv(K + beta)\n    :param alpha: Alpha vector used to parametrize the posterior approximation\n    :param beta: Beta vector/matrix used to parametrize the posterior approximation\n    :param K: prior covariance\n    :return: Tuple containing the mean and cholesky of the covariance, its inverse and derivatives of the KL divergence with respect to beta and alpha\n    \"\"\"", "\n", "N", "=", "alpha", ".", "shape", "[", "0", "]", "\n", "# Lambda = diag(lam) = diag(beta.^2)", "\n", "lam_sqrt", "=", "beta", ".", "ravel", "(", ")", "\n", "lam", "=", "beta", ".", "ravel", "(", ")", "**", "2", "\n", "\n", "# Handle A = I + Lambda*K*Lambda", "\n", "KB", "=", "K", "@", "np", ".", "diag", "(", "lam_sqrt", ")", "\n", "BKB", "=", "np", ".", "diag", "(", "lam_sqrt", ")", "@", "KB", "\n", "A", "=", "np", ".", "eye", "(", "N", ")", "+", "BKB", "\n", "Ai", ",", "LA", ",", "Li", ",", "Alogdet", "=", "pdinv", "(", "A", ")", "\n", "\n", "# Compute Mean", "\n", "m", "=", "K", "@", "alpha", "\n", "\n", "# Compute covariance matrix", "\n", "W", "=", "Li", "@", "np", ".", "diag", "(", "1.0", "/", "lam_sqrt", ")", "# can be accelerated using broadcasting instead of matrix multiplication", "\n", "Sigma", "=", "(", "\n", "np", ".", "diag", "(", "1.0", "/", "lam", ")", "-", "W", ".", "T", "@", "W", "\n", ")", "# computes np.diag(1./lam) - np.diag(1. / lam_sqrt) @ Ai @ np.diag(1. / lam_sqrt)", "\n", "\n", "# Compute KL", "\n", "KL", "=", "0.5", "*", "(", "Alogdet", "+", "np", ".", "trace", "(", "Ai", ")", "-", "N", "+", "np", ".", "sum", "(", "m", "*", "alpha", ")", ")", "\n", "\n", "# Compute Gradients", "\n", "A_A2", "=", "Ai", "-", "Ai", ".", "dot", "(", "Ai", ")", "\n", "dKL_db", "=", "np", ".", "diag", "(", "np", ".", "dot", "(", "KB", ".", "T", ",", "A_A2", ")", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "# dKL_da = K @ alpha", "\n", "dKL_da", "=", "m", ".", "copy", "(", ")", "\n", "\n", "L", "=", "GPy", ".", "util", ".", "linalg", ".", "jitchol", "(", "Sigma", ")", "\n", "L_inv", "=", "np", ".", "linalg", ".", "inv", "(", "L", ")", "\n", "\n", "return", "m", ",", "L", ",", "L_inv", ",", "KL", ",", "dKL_db", ",", "dKL_da", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.log_lik": [[309, 344], ["x[].reshape", "x[].reshape", "recompute_posterior", "vi_batch_comparison.df_d", "KL.sum", "isinstance", "numpy.ones", "numpy.r_[].reshape"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.df_d"], ["", "def", "log_lik", "(", "\n", "x", ":", "np", ".", "ndarray", ",", "arg_list", ":", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "Callable", "]", "\n", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "    ", "\"\"\"\n    Computes the log likelihood and gradients for specific alpha and beta values concatenated in x.\n\n    :param x: Concatenated and flattened alpha and beta\n    :param arg_list: List of arguments that don't change during the optimization\n                     (prior covariance, noise of the observations, observations,\n                     comparisons, function to transfer the partial derivative)\n    :return: Tuple containing the log marginal and its derivative with respect to alpha and beta.\n    \"\"\"", "\n", "\n", "K", ",", "sigma2s", ",", "y", ",", "yc", ",", "recompute_posterior", ",", "s_to_l", "=", "(", "\n", "arg_list", "[", "0", "]", ",", "\n", "arg_list", "[", "1", "]", ",", "\n", "arg_list", "[", "2", "]", ",", "\n", "arg_list", "[", "3", "]", ",", "\n", "arg_list", "[", "4", "]", ",", "\n", "arg_list", "[", "5", "]", ",", "\n", ")", "\n", "alpha", "=", "x", "[", ":", "K", ".", "shape", "[", "0", "]", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "beta", "=", "x", "[", "K", ".", "shape", "[", "0", "]", ":", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "if", "not", "isinstance", "(", "sigma2s", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "sigma2s", "=", "sigma2s", "*", "np", ".", "ones", "(", "(", "K", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n", "", "m", ",", "L", ",", "L_inv", ",", "KL", ",", "dKL_db", ",", "dKL_da", "=", "recompute_posterior", "(", "alpha", ",", "beta", ",", "K", ")", "\n", "\n", "log_marginal", ",", "alpha_grad", ",", "beta_grad", "=", "df_d", "(", "y", ",", "yc", ",", "m", ",", "L", ",", "L_inv", ",", "K", ",", "sigma2s", ",", "alpha", ",", "beta", ",", "s_to_l", "=", "s_to_l", ")", "\n", "\n", "log_marginal", "-=", "KL", ".", "sum", "(", ")", "\n", "alpha_grad", "-=", "dKL_da", "\n", "beta_grad", "-=", "dKL_db", "\n", "return", "-", "log_marginal", ",", "-", "np", ".", "r_", "[", "alpha_grad", ",", "beta_grad", "]", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.vi_batch_comparison.vi_comparison": [[346, 402], ["kern.K", "X[].reshape", "X[].reshape", "recompute_posterior", "GPy.inference.latent_function_inference.posterior.Posterior", "util.adam", "scipy.optimize.minimize", "sp.optimize.minimize.x.reshape", "numpy.identity", "X0.flatten", "len", "X0.flatten"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.util.adam"], ["", "def", "vi_comparison", "(", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "kern", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "sigma2s", ":", "np", ".", "ndarray", ",", "\n", "alpha", ":", "np", ".", "ndarray", ",", "\n", "beta", ":", "np", ".", "ndarray", ",", "\n", "max_iters", ":", "int", "=", "200", ",", "\n", "lr", ":", "float", "=", "1e-3", ",", "\n", "method", ":", "str", "=", "\"fr\"", ",", "\n", "optimize", ":", "str", "=", "\"adam\"", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Posterior", ",", "float", ",", "Dict", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    :param X: All locations of both direct observations and batch comparisons\n    :param y: Direct observations in as a list of tuples telling location index (row in X) and observation value.\n    :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n    :param kern: Prior covariance kernel\n    :param sigma2s: Noise variance of the observations\n    :param alpha: Initial values for alpha\n    :param beta: Initial values for beta\n    :param max_iter: macimum number of optimization iterations\n    :param method: full rank 'fr' or mean field 'mf' methods\n    :param optimize: optimization algorithm. adam or l-bfgs-B\n    :param get_logger: Function for receiving the legger where the prints are forwarded.\n    :return: A Tuple containing the posterior, log marginal likelihood, its gradients with respect to hyper parameters (not supported at the moment) and alpha and beta values\n    \"\"\"", "\n", "if", "method", "==", "\"fr\"", ":", "\n", "        ", "recompute_posterior", "=", "recompute_posterior_fr", "\n", "s_to_l", "=", "dL_fr", "\n", "", "else", ":", "\n", "        ", "recompute_posterior", "=", "recompute_posterior_mf", "\n", "s_to_l", "=", "dL_mf", "\n", "\n", "", "K", "=", "kern", ".", "K", "(", "X", ")", "\n", "K", "=", "K", "+", "1e-6", "*", "np", ".", "identity", "(", "len", "(", "K", ")", ")", "\n", "N", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "X0", "=", "np", ".", "r_", "[", "alpha", ",", "beta", "]", "\n", "args", "=", "[", "K", ",", "sigma2s", ",", "y", ",", "yc", ",", "recompute_posterior", ",", "s_to_l", "]", "\n", "if", "optimize", "==", "\"adam\"", ":", "\n", "        ", "X", ",", "log_marginal", ",", "_", "=", "adam", "(", "log_lik", ",", "X0", ".", "flatten", "(", ")", ",", "args", ",", "bounds", "=", "None", ",", "max_it", "=", "max_iters", ",", "get_logger", "=", "get_logger", ")", "\n", "", "else", ":", "\n", "        ", "res", "=", "sp", ".", "optimize", ".", "minimize", "(", "fun", "=", "log_lik", ",", "x0", "=", "X0", ".", "flatten", "(", ")", ",", "args", "=", "args", ",", "method", "=", "\"L-BFGS-B\"", ",", "jac", "=", "True", ",", "bounds", "=", "None", ")", "\n", "X", "=", "res", ".", "x", ".", "reshape", "(", "-", "1", ")", "\n", "log_marginal", "=", "res", ".", "fun", "\n", "", "alpha", "=", "X", "[", ":", "K", ".", "shape", "[", "0", "]", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "beta", "=", "X", "[", "K", ".", "shape", "[", "0", "]", ":", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "# Create posterior instance", "\n", "m", ",", "L", ",", "L_inv", ",", "KL", ",", "dKL_db_", ",", "dKL_da_", "=", "recompute_posterior", "(", "alpha", ",", "beta", ",", "K", ")", "\n", "posterior", "=", "Posterior", "(", "mean", "=", "m", ",", "cov", "=", "L", "@", "L", ".", "T", ",", "K", "=", "K", ")", "\n", "grad_dict", "=", "{", "}", "# {'dL_dK': dF_dK - dKL_dK, 'dL_dthetaL':dL_dthetaL}", "\n", "# return posterior, log_marginal, grad_dict", "\n", "return", "posterior", ",", "log_marginal", ",", "grad_dict", ",", "alpha", ",", "beta", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.mcmc_batch_comparison.StanPosterior.__init__": [[52, 91], ["numpy.set_printoptions", "numpy.atleast_2d", "numpy.array().reshape", "numpy.cov", "numpy.atleast_2d", "mcmc_batch_comparison.StanPosterior.kern.K", "mcmc_batch_comparison.remove_level_uncertainty", "get_logger().info", "numpy.array", "numpy.mean", "get_logger"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.inferences.mcmc_batch_comparison.remove_level_uncertainty", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger"], ["def", "__init__", "(", "\n", "self", ",", "\n", "samples", ":", "Dict", ",", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "kern", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "noise", ":", "float", ",", "\n", "remove_levels", ":", "bool", "=", "True", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", "=", "None", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", "=", "None", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", "Y", ":", "np", ".", "ndarray", "=", "None", ",", "\n", ")", ":", "\n", "        ", "np", ".", "set_printoptions", "(", "precision", "=", "3", ",", "linewidth", "=", "500", ")", "\n", "self", ".", "_K_chol", ",", "self", ".", "_precision", ",", "self", ".", "_woodbury_inv", ",", "self", ".", "_woodbury_chol", ",", "self", ".", "_woodbury_vector", "=", "(", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", ")", "\n", "samples", "[", "\"f\"", "]", "=", "np", ".", "atleast_2d", "(", "samples", "[", "\"f\"", "]", ")", "\n", "if", "remove_levels", ":", "\n", "            ", "if", "get_logger", "is", "not", "None", ":", "\n", "                ", "get_logger", "(", ")", ".", "info", "(", "\"Removed level uncertainty\"", ")", "\n", "", "samples", "[", "\"f\"", "]", "=", "remove_level_uncertainty", "(", "samples", "[", "\"f\"", "]", ")", "\n", "", "self", ".", "_mean", "=", "np", ".", "array", "(", "np", ".", "mean", "(", "samples", "[", "\"f\"", "]", ".", "T", ",", "axis", "=", "1", ")", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "self", ".", "_covariance", "=", "np", ".", "cov", "(", "samples", "[", "\"f\"", "]", ".", "T", ")", "\n", "\n", "self", ".", "_prior_mean", "=", "0", "\n", "\n", "self", ".", "samples", "=", "samples", "\n", "\n", "self", ".", "X", "=", "np", ".", "atleast_2d", "(", "X", ")", "\n", "\n", "self", ".", "Y", "=", "Y", "\n", "self", ".", "noise", "=", "noise", "\n", "self", ".", "kern", "=", "kern", "\n", "self", ".", "_K", "=", "self", ".", "kern", ".", "K", "(", "self", ".", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.mcmc_batch_comparison.StanPosterior._get_mu_L": [[92, 135], ["numpy.arange", "len", "numpy.atleast_2d", "numpy.empty", "numpy.empty", "mcmc_batch_comparison.StanPosterior.kern.K", "mcmc_batch_comparison.StanPosterior.kern.K", "enumerate", "numpy.random.choice", "numpy.array", "scipy.solve_triangular", "numpy.dot", "GPy.util.linalg.jitchol", "numpy.empty", "numpy.empty", "enumerate", "numpy.dot", "scipy.inv"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "_get_mu_L", "(", "self", ",", "x_pred", ":", "np", ".", "ndarray", ",", "N", ":", "int", "=", "None", ",", "woodbury_inv", ":", "bool", "=", "False", ",", "with_index", ":", "int", "=", "None", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Returns posterior mean and cholesky decomposition of the posterior samples\n\n        :param x_pred: locations where the mean and posterior covariance are computed\n        :param N: number of posterior samples\n        :param woodbury_inv: boolean indicating whether the function should return woodbury_inv vector as well\n        :param with_index: index of the specific posterior sample the function should return\n        :return params: tuple containing the posterior means and choleskies of the covariances. Also woodbury inverses and woodbury choleskies if woodbury_inv is true\n        \"\"\"", "\n", "indices", "=", "np", ".", "arange", "(", "self", ".", "samples", "[", "\"f\"", "]", ".", "shape", "[", "0", "]", ")", "\n", "if", "N", "is", "not", "None", ":", "\n", "            ", "indices", "=", "np", ".", "random", ".", "choice", "(", "indices", ",", "N", ")", "\n", "", "if", "with_index", "is", "not", "None", ":", "\n", "            ", "indices", "=", "np", ".", "array", "(", "[", "with_index", "]", ",", "dtype", "=", "int", ")", "\n", "", "N", "=", "len", "(", "indices", ")", "\n", "x_pred", "=", "np", ".", "atleast_2d", "(", "x_pred", ")", "\n", "f2_mu", "=", "np", ".", "empty", "(", "(", "N", ",", "x_pred", ".", "shape", "[", "0", "]", ")", ")", "\n", "f2_L", "=", "np", ".", "empty", "(", "(", "N", ",", "x_pred", ".", "shape", "[", "0", "]", ",", "x_pred", ".", "shape", "[", "0", "]", ")", ")", "\n", "k_x1_x2", "=", "self", ".", "kern", ".", "K", "(", "self", ".", "X", ",", "x_pred", ")", "\n", "k_x2_x2", "=", "self", ".", "kern", ".", "K", "(", "x_pred", ")", "\n", "for", "ni", ",", "i", "in", "enumerate", "(", "indices", ")", ":", "\n", "            ", "L_div_k_x1_x2", "=", "la", ".", "solve_triangular", "(", "self", ".", "samples", "[", "\"L_K\"", "]", "[", "i", ",", ":", ",", ":", "]", ",", "k_x1_x2", ",", "lower", "=", "True", ",", "overwrite_b", "=", "False", ")", "\n", "f2_mu", "[", "ni", ",", ":", "]", "=", "np", ".", "dot", "(", "L_div_k_x1_x2", ".", "T", ",", "self", ".", "samples", "[", "\"eta\"", "]", "[", "i", ",", ":", "]", ")", "# self.L_div_f[i,:])", "\n", "f2_cov", "=", "k_x2_x2", "-", "np", ".", "dot", "(", "L_div_k_x1_x2", ".", "T", ",", "L_div_k_x1_x2", ")", "\n", "f2_L", "[", "ni", ",", ":", ",", ":", "]", "=", "jitchol", "(", "f2_cov", ")", "\n", "", "if", "woodbury_inv", ":", "\n", "            ", "w_inv", "=", "np", ".", "empty", "(", "(", "N", ",", "self", ".", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "X", ".", "shape", "[", "0", "]", ")", ")", "\n", "w_chol", "=", "np", ".", "empty", "(", "\n", "(", "\n", "N", ",", "\n", "self", ".", "X", ".", "shape", "[", "0", "]", ",", "\n", ")", "\n", ")", "\n", "for", "ni", ",", "i", "in", "enumerate", "(", "indices", ")", ":", "\n", "                ", "L_Kinv", "=", "la", ".", "inv", "(", "self", ".", "samples", "[", "\"L_K\"", "]", "[", "i", ",", ":", ",", ":", "]", ")", "\n", "w_inv", "[", "ni", ",", ":", ",", ":", "]", "=", "L_Kinv", ".", "T", "@", "L_Kinv", "\n", "w_chol", "[", "ni", ",", ":", "]", "=", "(", "L_Kinv", ".", "T", "@", "self", ".", "samples", "[", "\"eta\"", "]", "[", "i", ",", ":", ",", "None", "]", ")", "[", "\n", ":", ",", "0", "\n", "]", "# (Kinv @ self.samples['eta'][i,:, None])[:, 0] # (L_Kinv.T @ self.samples['eta'][i,:, None])[:, 0]  # self.L_div_f[i,:]", "\n", "", "return", "f2_mu", ",", "f2_L", ",", "w_inv", ",", "w_chol", "\n", "", "else", ":", "\n", "            ", "return", "f2_mu", ",", "f2_L", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.mcmc_batch_comparison.StanPosterior._raw_predict_raw": [[136, 151], ["numpy.atleast_2d", "mcmc_batch_comparison.StanPosterior._get_mu_L", "numpy.matmul", "numpy.random.normal", "numpy.random.normal"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.mcmc_batch_comparison.StanPosterior._get_mu_L"], ["", "", "def", "_raw_predict_raw", "(", "self", ",", "x_pred", ":", "np", ".", "ndarray", ",", "include_likelihood", ":", "bool", "=", "False", ",", "samples", ":", "int", "=", "2000", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Draw posterior predictive samples from the posterior distribution\n\n        :param x_pred: locations at which the samples are wanted\n        :param include_likelihood: boolean indicating if observation noise should be added to the samples\n        :param samples: number of posterior predictive samples\n        :return samples: posterior predictive samples\n        \"\"\"", "\n", "x_pred", "=", "np", ".", "atleast_2d", "(", "x_pred", ")", "\n", "f2_mu", ",", "f2_L", "=", "self", ".", "_get_mu_L", "(", "x_pred", ",", "N", "=", "samples", ")", "\n", "f2", "=", "f2_mu", "+", "np", ".", "matmul", "(", "f2_L", ",", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "samples", ",", "x_pred", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "if", "include_likelihood", ":", "\n", "            ", "f2", "=", "f2", "+", "self", ".", "noise", "*", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "samples", ",", "x_pred", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "return", "f2", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.mcmc_batch_comparison.remove_level_uncertainty": [[22, 37], ["samples.max", "numpy.median", "samples.mean", "numpy.tile", "references.reshape"], "function", ["None"], ["def", "remove_level_uncertainty", "(", "samples", ":", "np", ".", "ndarray", ",", "mean_same", ":", "bool", "=", "True", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Removes level uncertainty in the samples. If only comparison observations are used, exact latent value doesn't matter.\n    Thus in this case we make all samples have same maximum/mean\n    :param samples: posterior samples\n    :param mean_same: if True, all samples have same mean. If False, they have same maximum\n    :return prosessed_samples: samples without level uncertainty\n    \"\"\"", "\n", "maxes", "=", "samples", ".", "max", "(", "axis", "=", "1", ")", "\n", "if", "mean_same", ":", "\n", "        ", "maxes", "=", "samples", ".", "mean", "(", "axis", "=", "1", ")", "\n", "", "reference", "=", "np", ".", "median", "(", "maxes", ")", "\n", "references", "=", "maxes", "-", "reference", "\n", "samples", "=", "samples", "-", "np", ".", "tile", "(", "references", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "(", "1", ",", "samples", ".", "shape", "[", "1", "]", ")", ")", "\n", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.MarginalMoments.__init__": [[66, 70], ["numpy.empty", "numpy.empty", "numpy.empty"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_data", ")", ":", "\n", "        ", "self", ".", "logZ_hat", "=", "np", ".", "empty", "(", "num_data", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "mu_hat", "=", "np", ".", "empty", "(", "num_data", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "sigma2_hat", "=", "np", ".", "empty", "(", "(", "num_data", ",", "num_data", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.GaussianApproximation.__init__": [[79, 82], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "v", ",", "tau", ")", ":", "\n", "        ", "self", ".", "v", "=", "v", "\n", "self", ".", "tau", "=", "tau", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.GaussianApproximation._update_batch": [[83, 130], ["GPy.util.linalg.pdinv", "GPy.util.linalg.pdinv", "nearestPD.nearest_pd.nearestPD", "numpy.dot", "numpy.dot", "numpy.ix_", "get_logger().error", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "get_logger"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger"], ["", "def", "_update_batch", "(", "\n", "self", ",", "\n", "eta", ":", "float", ",", "\n", "delta", ":", "float", ",", "\n", "post_params", ":", "posteriorParams", ",", "\n", "marg_moments", ":", "MarginalMoments", ",", "\n", "batch", ":", "List", "[", "int", "]", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", "sigma2s", ":", "np", ".", "ndarray", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Computes new gaussian approximation for a batch given posterior and marginal moments. See e.g. 3.59 in http://www.gaussianprocess.org/gpml/chapters/RW.pdf\n        :param eta: parameter for fractional updates.\n        :param delta: damping updates factor.\n        :param post_params: Posterior approximation\n        :param marg_moments: Marginal moments at this iteration\n        :param batch: list of indices of the parameters to be updated\n        :param get_logger: Function for receiving the legger where the prints are forwarded.\n        \"\"\"", "\n", "sigma_hat_inv", ",", "_", ",", "_", ",", "_", "=", "pdinv", "(", "marg_moments", ".", "sigma2_hat", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", ")", "\n", "post_sigma_inv", ",", "_", ",", "_", ",", "_", "=", "pdinv", "(", "post_params", ".", "Sigma", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", ")", "\n", "\n", "tmp0", "=", "sigma_hat_inv", "-", "post_sigma_inv", "\n", "\n", "delta_tau", "=", "delta", "/", "eta", "*", "tmp0", "\n", "delta_v", "=", "(", "\n", "delta", "\n", "/", "eta", "\n", "*", "(", "np", ".", "dot", "(", "marg_moments", ".", "mu_hat", "[", "batch", "]", ",", "sigma_hat_inv", ")", "-", "np", ".", "dot", "(", "post_params", ".", "mu", "[", "batch", "]", ",", "post_sigma_inv", ")", ")", "\n", ")", "\n", "tau_tilde_prev", "=", "self", ".", "tau", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", "\n", "tmp", "=", "(", "1", "-", "delta", ")", "*", "self", ".", "tau", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", "+", "delta_tau", "\n", "\n", "# Let us umake sure that sigma_hat_inv-post_sigma_inv is positive definite", "\n", "tmp", ",", "added_value", "=", "nearestPD", ".", "nearest_pd", ".", "nearestPD", "(", "tmp", ")", "\n", "update", "=", "True", "\n", "if", "(", "added_value", ">", "1", ")", "and", "(", "sigma2s", "is", "not", "None", ")", ":", "\n", "            ", "update", "=", "False", "\n", "sigma2s", "*=", "1.05", "\n", "if", "get_logger", "is", "not", "None", ":", "\n", "                ", "get_logger", "(", ")", ".", "error", "(", "\n", "\"Increasing batch noise. Not updating gaussian approximation ({})\"", ".", "format", "(", "sigma2s", "[", "0", "]", ")", "\n", ")", "\n", "", "", "if", "update", ":", "\n", "            ", "self", ".", "tau", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", "=", "tmp", "\n", "self", ".", "v", "[", "batch", "]", "=", "(", "1", "-", "delta", ")", "*", "self", ".", "v", "[", "batch", "]", "+", "delta_v", "\n", "", "return", "(", "delta_tau", ",", "delta_v", ")", ",", "sigma2s", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.CavityParams.__init__": [[138, 141], ["numpy.zeros", "numpy.zeros"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_data", ":", "int", ")", ":", "\n", "        ", "self", ".", "v", "=", "np", ".", "zeros", "(", "num_data", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "tau", "=", "np", ".", "zeros", "(", "(", "num_data", ",", "num_data", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.CavityParams._update_i": [[142, 152], ["None"], "methods", ["None"], ["", "def", "_update_i", "(", "self", ",", "eta", ":", "float", ",", "ga_approx", ":", "GaussianApproximation", ",", "post_params", ":", "posteriorParams", ",", "i", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Computes the cavity params for specific index\n        :param eta: parameter for fractional updates.\n        :param ga_approx: Gaussian approximation\n        :param post_params: Posterior approximation\n        :param i: index of the parameters to be updated\n        \"\"\"", "\n", "self", ".", "tau", "[", "i", ",", "i", "]", "=", "1.0", "/", "post_params", ".", "Sigma", "[", "i", ",", "i", "]", "-", "eta", "*", "ga_approx", ".", "tau", "[", "i", ",", "i", "]", "\n", "self", ".", "v", "[", "i", "]", "=", "post_params", ".", "mu", "[", "i", "]", "/", "post_params", ".", "Sigma", "[", "i", ",", "i", "]", "-", "eta", "*", "ga_approx", ".", "v", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.CavityParams._update_batch": [[153, 173], ["scipy.linalg.inv", "nearestPD.nearest_pd.nearestPD", "numpy.dot", "numpy.ix_", "numpy.ix_", "numpy.ix_"], "methods", ["None"], ["", "def", "_update_batch", "(", "\n", "self", ",", "\n", "eta", ":", "float", ",", "\n", "ga_approx", ":", "GaussianApproximation", ",", "\n", "post_params", ":", "posteriorParams", ",", "\n", "batch", ":", "List", "[", "int", "]", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Computes the cavity params for specific batch\n        :param eta: parameter for fractional updates.\n        :param ga_approx: Gaussian approximation\n        :param post_params: Posterior approximation\n        :param batch: list of indices of the parameters to be updated\n        :param get_logger: Function for receiving the legger where the prints are forwarded.\n        \"\"\"", "\n", "post_sigma_inv", "=", "inv", "(", "post_params", ".", "Sigma", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", ")", "\n", "tmp", "=", "post_sigma_inv", "-", "eta", "*", "ga_approx", ".", "tau", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", "\n", "self", ".", "tau", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", ",", "_", "=", "nearestPD", ".", "nearest_pd", ".", "nearestPD", "(", "tmp", ")", "\n", "self", ".", "v", "[", "batch", "]", "=", "np", ".", "dot", "(", "post_sigma_inv", ",", "post_params", ".", "mu", "[", "batch", "]", ")", "-", "eta", "*", "ga_approx", ".", "v", "[", "batch", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.posdef_sqrtm": [[27, 36], ["scipy.linalg.svd", "numpy.diag", "numpy.sqrt"], "function", ["None"], ["def", "posdef_sqrtm", "(", "M", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Returns a square root of a positive definite matrix\n    :param M: A positive definite matrix\n    :return: Squarte root of M\n    \"\"\"", "\n", "(", "U", ",", "S", ",", "VT", ")", "=", "svd", "(", "M", ")", "\n", "D", "=", "np", ".", "diag", "(", "np", ".", "sqrt", "(", "S", ")", ")", "\n", "return", "U", "@", "D", "@", "VT", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.sqrtm_block": [[38, 58], ["numpy.zeros", "len", "len", "numpy.sqrt", "numpy.sort", "ep_batch_comparison.posdef_sqrtm", "numpy.unique", "numpy.ix_", "range", "range", "numpy.ix_", "len", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.posdef_sqrtm"], ["", "def", "sqrtm_block", "(", "M", ":", "np", ".", "ndarray", ",", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Returns a square root of a positive definite matrix\n    :param M: A positive definite block matrix\n    :param y: Observations indicating where we have a diagonal element\n    :param yc: Comparisons indicating where we have a block diagonal element\n    :return: Squarte root of M\n    \"\"\"", "\n", "Msqrtm", "=", "np", ".", "zeros", "(", "M", ".", "shape", ")", "\n", "if", "len", "(", "y", ")", ">", "0", ":", "\n", "        ", "for", "yi", ",", "yval", "in", "y", ":", "\n", "            ", "Msqrtm", "[", "yi", ",", "yi", "]", "=", "np", ".", "sqrt", "(", "M", "[", "yi", ",", "yi", "]", ")", "\n", "", "", "if", "len", "(", "yc", ")", ">", "0", ":", "\n", "        ", "for", "ycb", "in", "yc", ":", "\n", "            ", "loc_inds_winners", ",", "loc_inds_loosers", "=", "[", "ycb", "[", "k", "]", "[", "0", "]", "for", "k", "in", "range", "(", "len", "(", "ycb", ")", ")", "]", ",", "[", "\n", "ycb", "[", "k", "]", "[", "1", "]", "for", "k", "in", "range", "(", "len", "(", "ycb", ")", ")", "\n", "]", "\n", "batch", "=", "np", ".", "sort", "(", "np", ".", "unique", "(", "loc_inds_winners", "+", "loc_inds_loosers", ")", ")", "\n", "Msqrtm", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", "=", "posdef_sqrtm", "(", "M", "[", "np", ".", "ix_", "(", "batch", ",", "batch", ")", "]", ")", "\n", "", "", "return", "Msqrtm", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.update_posterior": [[175, 206], ["ep_batch_comparison.sqrtm_block", "numpy.dot", "GPy.util.linalg.jitchol", "numpy.linalg.solve", "numpy.dot", "numpy.diag", "GPy.inference.latent_function_inference.expectation_propagation.posteriorParams", "numpy.identity", "numpy.dot", "numpy.dot", "numpy.diag", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.sqrtm_block"], ["", "", "def", "update_posterior", "(", "\n", "K", ":", "np", ".", "ndarray", ",", "\n", "v", ":", "np", ".", "ndarray", ",", "\n", "tau", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "jitter", ":", "float", "=", "1e-9", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", "->", "posteriorParams", ":", "\n", "    ", "\"\"\"\n    Update the posterior approximation. See e.g. 3.59 in http://www.gaussianprocess.org/gpml/chapters/RW.pdf\n    :param K: prior covariance matrix\n    :param v: Scale of the Gaussian approximation\n    :param tau: Precision of the Gaussian approximation\n    :param y: Observations indicating where we have a diagonal element\n    :param yc: Comparisons indicating where we have a block diagonal element\n    :param jitter: small number added to the diagonal to increase robustness.\n    :param get_logger: Function for receiving the legger where the prints are forwarded.\n    :return: posterior approximation\n    \"\"\"", "\n", "D", "=", "K", ".", "shape", "[", "0", "]", "\n", "sqrt_tau", "=", "sqrtm_block", "(", "tau", "+", "np", ".", "diag", "(", "jitter", "*", "np", ".", "ones", "(", "(", "D", ")", ")", ")", ",", "y", ",", "yc", ")", "\n", "G", "=", "np", ".", "dot", "(", "sqrt_tau", ",", "K", ")", "\n", "B", "=", "np", ".", "identity", "(", "D", ")", "+", "np", ".", "dot", "(", "G", ",", "sqrt_tau", ")", "\n", "L", "=", "jitchol", "(", "B", ")", "\n", "V", "=", "np", ".", "linalg", ".", "solve", "(", "L", ",", "G", ")", "\n", "Sigma_full", "=", "K", "-", "np", ".", "dot", "(", "V", ".", "T", ",", "V", ")", "\n", "mu", "=", "np", ".", "dot", "(", "Sigma_full", ",", "v", ")", "\n", "Sigma", "=", "np", ".", "diag", "(", "Sigma_full", ")", "\n", "\n", "return", "posteriorParams", "(", "mu", "=", "mu", ",", "Sigma", "=", "Sigma_full", ",", "L", "=", "L", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.ep_comparison": [[208, 361], ["time.time", "len", "len", "kern.K", "ep_batch_comparison.MarginalMoments", "ep_batch_comparison.GaussianApproximation", "ep_batch_comparison.CavityParams", "range", "ep_batch_comparison.update_posterior", "numpy.any", "range", "range", "ep_batch_comparison._log_Z_tilde", "ep_batch_comparison._inference", "numpy.zeros", "numpy.zeros", "numpy.isnan", "numpy.hstack", "ep_batch_comparison.update_posterior", "numpy.hstack", "ep_batch_comparison.CavityParams._update_i", "log_npdf", "get_logger().error", "get_logger().info", "len", "numpy.random.choice", "numpy.sort", "ep_batch_comparison.CavityParams._update_batch", "ep_batch_comparison.GaussianApproximation._update_batch", "numpy.any", "numpy.any", "update_posterior.mu.copy", "update_posterior.Sigma_diag.copy", "range", "numpy.unique", "ep_batch_comparison._match_moments_batch", "numpy.isnan", "numpy.isnan", "get_logger().error", "update_posterior.mu.copy", "update_posterior.Sigma_diag.copy", "numpy.mean", "numpy.mean", "time.time", "get_logger().info", "numpy.ix_", "get_logger", "get_logger", "len", "len", "numpy.arange", "numpy.arange", "range", "range", "get_logger().error", "get_logger", "get_logger", "len", "len", "numpy.ix_", "numpy.ix_", "numpy.where", "numpy.where", "get_logger"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.update_posterior", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._log_Z_tilde", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._inference", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.update_posterior", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.CavityParams._update_i", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.CavityParams._update_batch", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.CavityParams._update_batch", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._match_moments_batch", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger"], ["", "def", "ep_comparison", "(", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", "kern", ":", "GPy", ".", "kern", ".", "Kern", ",", "\n", "sigma2s", ":", "np", ".", "ndarray", ",", "\n", "max_itt", ":", "int", "=", "50", ",", "\n", "delta", ":", "float", "=", "0.9", ",", "\n", "eta", ":", "float", "=", "1.0", ",", "\n", "tol", ":", "float", "=", "1e-6", ",", "\n", "ga_approx_old", ":", "GaussianApproximation", "=", "None", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Posterior", ",", "int", ",", "Dict", ",", "GaussianApproximation", "]", ":", "\n", "    ", "\"\"\"\n    :param X: All locations of both direct observations and batch comparisons\n    :param y: Direct observations as a list of tuples telling location index (row in X) and observation value.\n    :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n    :param kern: GP kernel\n    :param sigma2s: noise variance of observations\n    :param max_itt: maximum number of iterations\n    :param delta: damping updates factor.\n    :param eta: parameter for fractional updates.\n    :param tol: tolerance after which the EP is stopped unless too many iterations have passed\n    :param ga_approx_old: If there has been previous gaussian approximation, it should be passed\n    :param get_logger: Function for receiving the legger where the prints are forwarded.\n    :return: A tuple consisting of the posterior approximation, log marginal likelihood, radient dictionary and gaussian approximations of the batches\n    \"\"\"", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "N", "=", "X", ".", "shape", "[", "0", "]", "\n", "Ndir", "=", "len", "(", "y", ")", "\n", "Ncomp", "=", "len", "(", "yc", ")", "\n", "###################################################################################", "\n", "# Contruct observations and kernels", "\n", "###################################################################################", "\n", "K", "=", "kern", ".", "K", "(", "X", ")", "\n", "\n", "###################################################################################", "\n", "# Prepare marginal moments, site approximation and cavity containers", "\n", "###################################################################################", "\n", "\n", "f_marg_moments", "=", "MarginalMoments", "(", "N", ")", "\n", "f_ga_approx", "=", "GaussianApproximation", "(", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "np", ".", "float64", ")", ",", "np", ".", "zeros", "(", "(", "N", ",", "N", ")", ",", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "f_cavity", "=", "CavityParams", "(", "N", ")", "\n", "\n", "# insert likelihood information to each gaussian approximation", "\n", "for", "i", "in", "range", "(", "Ndir", ")", ":", "\n", "        ", "(", "ii", ",", "yi", ")", "=", "y", "[", "i", "]", "# index in kernel, y value", "\n", "f_ga_approx", ".", "v", "[", "ii", "]", "=", "yi", "/", "sigma2s", "[", "i", "]", "\n", "f_ga_approx", ".", "tau", "[", "ii", ",", "ii", "]", "=", "1.0", "/", "sigma2s", "[", "i", "]", "\n", "\n", "", "if", "ga_approx_old", "is", "not", "None", ":", "# If there exists old gaussian approximation, we reuse it", "\n", "        ", "N_old", "=", "ga_approx_old", ".", "tau", ".", "shape", "[", "0", "]", "\n", "if", "N", "-", "N_old", ">", "-", "1", ":", "\n", "            ", "f_ga_approx", ".", "v", "[", ":", "N_old", "]", "=", "ga_approx_old", ".", "v", "\n", "f_ga_approx", ".", "tau", "[", "np", ".", "ix_", "(", "np", ".", "arange", "(", "N_old", ")", ",", "np", ".", "arange", "(", "N_old", ")", ")", "]", "=", "ga_approx_old", ".", "tau", "\n", "\n", "###################################################################################", "\n", "# Prepare global approximations", "\n", "###################################################################################", "\n", "", "", "f_post_params", "=", "update_posterior", "(", "K", ",", "f_ga_approx", ".", "v", ",", "f_ga_approx", ".", "tau", ",", "y", ",", "yc", ")", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "f_post_params", ".", "mu", ")", ")", ":", "\n", "        ", "if", "get_logger", "is", "not", "None", ":", "\n", "            ", "get_logger", "(", ")", ".", "error", "(", "\"Posterior mean contains nan in the EP approximation\"", ")", "\n", "\n", "###################################################################################", "\n", "# Iterate", "\n", "###################################################################################", "\n", "", "", "for", "itt", "in", "range", "(", "max_itt", ")", ":", "\n", "        ", "old_params", "=", "np", ".", "hstack", "(", "(", "f_post_params", ".", "mu", ".", "copy", "(", ")", ",", "f_post_params", ".", "Sigma_diag", ".", "copy", "(", ")", ")", ")", "\n", "\n", "if", "get_logger", "is", "not", "None", ":", "\n", "            ", "get_logger", "(", ")", ".", "info", "(", "\"Iteration %d\"", "%", "(", "itt", "+", "1", ")", ")", "\n", "", "d_list", "=", "[", "]", "\n", "if", "len", "(", "yc", ")", ">", "0", ":", "\n", "            ", "d_list", "=", "np", ".", "random", ".", "choice", "(", "range", "(", "len", "(", "yc", ")", ")", ",", "size", "=", "len", "(", "yc", ")", ",", "replace", "=", "False", ")", "\n", "", "for", "d", "in", "d_list", ":", "# iterate through batches", "\n", "            ", "loc_inds_winners", ",", "loc_inds_loosers", "=", "[", "yc", "[", "d", "]", "[", "k", "]", "[", "0", "]", "for", "k", "in", "range", "(", "len", "(", "yc", "[", "d", "]", ")", ")", "]", ",", "[", "\n", "yc", "[", "d", "]", "[", "k", "]", "[", "1", "]", "for", "k", "in", "range", "(", "len", "(", "yc", "[", "d", "]", ")", ")", "\n", "]", "\n", "loc_inds_batch", "=", "np", ".", "sort", "(", "np", ".", "unique", "(", "loc_inds_winners", "+", "loc_inds_loosers", ")", ")", "\n", "# get relevant EP parameters for comparison points", "\n", "f_cavity", ".", "_update_batch", "(", "\n", "eta", "=", "eta", ",", "ga_approx", "=", "f_ga_approx", ",", "post_params", "=", "f_post_params", ",", "batch", "=", "loc_inds_batch", ",", "get_logger", "=", "get_logger", "\n", ")", "\n", "\n", "try", ":", "\n", "# get cavity parameters of the batch", "\n", "                ", "ind_winners", ",", "ind_loosers", "=", "[", "np", ".", "where", "(", "loc_inds_batch", "==", "it", ")", "[", "0", "]", "[", "0", "]", "for", "it", "in", "loc_inds_winners", "]", ",", "[", "\n", "np", ".", "where", "(", "loc_inds_batch", "==", "it", ")", "[", "0", "]", "[", "0", "]", "for", "it", "in", "loc_inds_loosers", "\n", "]", "# indices within a batch", "\n", "(", "\n", "f_marg_moments", ".", "logZ_hat", "[", "loc_inds_batch", "]", ",", "\n", "f_marg_moments", ".", "mu_hat", "[", "loc_inds_batch", "]", ",", "\n", "f_marg_moments", ".", "sigma2_hat", "[", "np", ".", "ix_", "(", "loc_inds_batch", ",", "loc_inds_batch", ")", "]", ",", "\n", "sigma2s", "[", "loc_inds_batch", "]", ",", "\n", ")", "=", "_match_moments_batch", "(", "\n", "f_cavity", ".", "v", "[", "loc_inds_batch", "]", ",", "\n", "f_cavity", ".", "tau", "[", "np", ".", "ix_", "(", "loc_inds_batch", ",", "loc_inds_batch", ")", "]", ",", "\n", "ind_winners", ",", "\n", "ind_loosers", ",", "\n", "sigma2s", "[", "loc_inds_batch", "]", ",", "\n", "N", "=", "100000", ",", "\n", "get_logger", "=", "get_logger", ",", "\n", ")", "\n", "", "except", "AssertionError", "as", "e", ":", "\n", "                ", "if", "get_logger", "is", "not", "None", ":", "\n", "                    ", "get_logger", "(", ")", ".", "error", "(", "\"Numerical problem with feedback %d in iteration %d. Skipping update\"", "%", "(", "d", ",", "itt", ")", ")", "\n", "", "", "_", ",", "sigma2s", "[", "loc_inds_batch", "]", "=", "f_ga_approx", ".", "_update_batch", "(", "\n", "eta", "=", "eta", ",", "\n", "delta", "=", "delta", ",", "\n", "post_params", "=", "f_post_params", ",", "\n", "marg_moments", "=", "f_marg_moments", ",", "\n", "batch", "=", "loc_inds_batch", ",", "\n", "get_logger", "=", "get_logger", ",", "\n", "sigma2s", "=", "sigma2s", "[", "loc_inds_batch", "]", ",", "\n", ")", "\n", "", "f_post_params", "=", "update_posterior", "(", "K", ",", "f_ga_approx", ".", "v", ",", "f_ga_approx", ".", "tau", ",", "y", ",", "yc", ",", "get_logger", "=", "get_logger", ")", "\n", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "f_post_params", ".", "mu", ")", ")", "or", "np", ".", "any", "(", "np", ".", "isnan", "(", "f_post_params", ".", "mu", ")", ")", ":", "\n", "            ", "if", "get_logger", "is", "not", "None", ":", "\n", "                ", "get_logger", "(", ")", ".", "error", "(", "\"Posterior mean contains nan in the EP approximation\"", ")", "\n", "\n", "# check for convergence", "\n", "", "", "new_params", "=", "np", ".", "hstack", "(", "(", "f_post_params", ".", "mu", ".", "copy", "(", ")", ",", "f_post_params", ".", "Sigma_diag", ".", "copy", "(", ")", ")", ")", "\n", "converged", "=", "True", "\n", "if", "np", ".", "mean", "(", "(", "new_params", "-", "old_params", ")", "**", "2", ")", "/", "np", ".", "mean", "(", "old_params", "**", "2", ")", "<", "tol", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "converged", "=", "False", "\n", "", "if", "converged", ":", "\n", "            ", "run_time", "=", "time", ".", "time", "(", ")", "-", "t0", "\n", "if", "get_logger", "is", "not", "None", ":", "\n", "                ", "get_logger", "(", ")", ".", "info", "(", "\"Converged in %d iterations in %4.3fs\"", "%", "(", "itt", "+", "1", ",", "run_time", ")", ")", "\n", "", "break", "\n", "#############################################################################3", "\n", "# Marginal likelihood & gradients", "\n", "#############################################################################3", "\n", "\n", "# compute normalization constant for likelihoods", "\n", "", "", "for", "i", "in", "range", "(", "Ndir", ")", ":", "\n", "        ", "(", "ii", ",", "yi", ")", "=", "y", "[", "i", "]", "# index in kernel, y value", "\n", "f_cavity", ".", "_update_i", "(", "eta", "=", "eta", ",", "ga_approx", "=", "f_ga_approx", ",", "post_params", "=", "f_post_params", ",", "i", "=", "ii", ")", "\n", "f_marg_moments", ".", "logZ_hat", "[", "ii", "]", "=", "log_npdf", "(", "\n", "yi", ",", "f_cavity", ".", "v", "[", "ii", "]", "/", "f_cavity", ".", "tau", "[", "ii", ",", "ii", "]", ",", "1.0", "/", "f_cavity", ".", "tau", "[", "ii", ",", "ii", "]", "+", "sigma2s", "[", "i", "]", "\n", ")", "\n", "\n", "# marginal likelihood and gradient contribution from each f", "\n", "\n", "", "Z_tilde", "=", "_log_Z_tilde", "(", "f_marg_moments", ",", "f_ga_approx", ",", "f_cavity", ",", "y", ",", "yc", ")", "\n", "f_posterior", ",", "f_logZ", ",", "f_grad", "=", "_inference", "(", "K", ",", "f_ga_approx", ",", "f_cavity", ",", "Z_tilde", ",", "y", ",", "yc", ")", "\n", "return", "f_posterior", ",", "f_logZ", ",", "f_grad", ",", "f_ga_approx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._match_moments_batch": [[363, 409], ["scipy.linalg.inv", "ep_batch_comparison._compute_moments_sampling", "numpy.min", "numpy.dot", "numpy.real", "numpy.isnan", "numpy.any", "numpy.any", "AssertionError", "numpy.array", "site_m.reshape", "numpy.eye", "get_logger().error", "numpy.isnan", "numpy.isnan", "scipy.eig", "get_logger", "range"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._compute_moments_sampling", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.bayesian_optimization.BayesianOptimization.get_logger"], ["", "def", "_match_moments_batch", "(", "\n", "v_cav", ":", "np", ".", "ndarray", ",", "\n", "tau_cav", ":", "np", ".", "ndarray", ",", "\n", "ind_winners", ":", "List", "[", "int", "]", ",", "\n", "ind_loosers", ":", "List", "[", "int", "]", ",", "\n", "nu2", ":", "np", ".", "ndarray", ",", "\n", "N", ":", "int", "=", "10000", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "int", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Computes the moments of the given batch\n    :param v_cav: Scale of the cavity distribution\n    :param tau_cav: Precision of the cavity distribution\n    :param ind_winners: Indices of winners in each pairwise comparison of the batch\n    :param ind_loosers: Indices of loosers in each pairwise comparison of the batch\n    :param nu2: Noise variance of each batch member likelihood\n    :param N: Number of parameters used to compute the moments\n    :param get_logger: Function for receiving the legger where the prints are forwarded.\n    :return: Tuple containing the integral, mean and variance\n    \"\"\"", "\n", "n", "=", "tau_cav", ".", "shape", "[", "0", "]", "\n", "tau_cav_inv", "=", "inv", "(", "tau_cav", ")", "\n", "m_cav", ",", "sigma_cav", "=", "np", ".", "dot", "(", "v_cav", ",", "tau_cav_inv", ")", ",", "tau_cav_inv", "\n", "logZ", ",", "site_m", ",", "site_m2", "=", "_compute_moments_sampling", "(", "\n", "m_cav", ",", "sigma_cav", ",", "ind_winners", ",", "ind_loosers", ",", "nu2", ",", "N", "=", "N", ",", "get_logger", "=", "get_logger", "\n", ")", "\n", "\n", "min_eig0", "=", "np", ".", "min", "(", "np", ".", "real", "(", "la", ".", "eig", "(", "site_m2", ")", "[", "0", "]", ")", ")", "\n", "if", "min_eig0", "<", "0", ":", "\n", "        ", "site_m2", "-=", "min_eig0", "*", "np", ".", "eye", "(", "site_m2", ".", "shape", "[", "0", "]", ")", "\n", "if", "get_logger", "is", "not", "None", ":", "\n", "            ", "get_logger", "(", ")", ".", "error", "(", "\n", "\"marginal moment not suitable in moment matching, adding smallest eigenvalue ({}) to the diagonal to guarantee PD\"", ".", "format", "(", "\n", "-", "1", "*", "min_eig0", "\n", ")", "\n", ")", "\n", "\n", "", "", "if", "np", ".", "isnan", "(", "logZ", ")", "or", "np", ".", "any", "(", "np", ".", "isnan", "(", "site_m", ")", ")", "or", "np", ".", "any", "(", "np", ".", "isnan", "(", "site_m2", ")", ")", ":", "\n", "        ", "raise", "AssertionError", "(", ")", "\n", "", "return", "(", "\n", "np", ".", "array", "(", "[", "logZ", "/", "n", "for", "i", "in", "range", "(", "n", ")", "]", ")", ",", "\n", "site_m", ".", "reshape", "(", "\n", "n", ",", "\n", ")", ",", "\n", "site_m2", ",", "\n", "nu2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._log_Z_tilde": [[412, 466], ["range", "numpy.sum", "numpy.array", "len", "range", "numpy.sort", "len", "numpy.unique", "numpy.log", "numpy.linalg.multi_dot", "range", "range", "numpy.log", "numpy.linalg.multi_dot", "len", "len", "numpy.linalg.det", "scipy.linalg.inv", "scipy.linalg.inv", "numpy.linalg.multi_dot", "numpy.eye", "numpy.dot", "len", "scipy.linalg.inv", "scipy.linalg.inv", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_", "numpy.ix_"], "function", ["None"], ["", "def", "_log_Z_tilde", "(", "\n", "marg_moments", ":", "MarginalMoments", ",", "\n", "ga_approx", ":", "GaussianApproximation", ",", "\n", "cav_params", ":", "CavityParams", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Give the log marginal likelihood of the posterior approximation\n    :param marg_moments: Marginal moments of the posterior\n    :param ga_approx: Gaussian approximation of the batches\n    :param cav_params: Cavity parameters of the posterior\n    :param y: Direct observations as a list of tuples telling location index (row in X) and observation value.\n    :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n    :return: log marginal likleihood of the posterior\n    \"\"\"", "\n", "\n", "# go through direct observations:", "\n", "inds", "=", "[", "np", ".", "array", "(", "[", "y", "[", "i", "]", "[", "0", "]", "]", ")", "for", "i", "in", "range", "(", "len", "(", "y", ")", ")", "]", "# direct observations", "\n", "for", "d", "in", "range", "(", "len", "(", "yc", ")", ")", ":", "# iterate through batches", "\n", "        ", "loc_inds_winners", ",", "loc_inds_loosers", "=", "[", "yc", "[", "d", "]", "[", "k", "]", "[", "0", "]", "for", "k", "in", "range", "(", "len", "(", "yc", "[", "d", "]", ")", ")", "]", ",", "[", "\n", "yc", "[", "d", "]", "[", "k", "]", "[", "1", "]", "for", "k", "in", "range", "(", "len", "(", "yc", "[", "d", "]", ")", ")", "\n", "]", "\n", "inds", "+=", "[", "np", ".", "sort", "(", "np", ".", "unique", "(", "loc_inds_winners", "+", "loc_inds_loosers", ")", ")", "]", "\n", "", "log_Z_tilde", "=", "np", ".", "sum", "(", "marg_moments", ".", "logZ_hat", "+", "0.5", "*", "np", ".", "log", "(", "2", "*", "np", ".", "pi", ")", ")", "\n", "for", "ind", "in", "inds", ":", "\n", "        ", "log_Z_tilde", "+=", "(", "\n", "0.5", "\n", "*", "np", ".", "log", "(", "\n", "np", ".", "linalg", ".", "det", "(", "\n", "np", ".", "eye", "(", "len", "(", "ind", ")", ")", "+", "np", ".", "dot", "(", "ga_approx", ".", "tau", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", ",", "inv", "(", "cav_params", ".", "tau", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", ")", ")", "\n", ")", "\n", ")", "\n", "-", "0.5", "\n", "*", "np", ".", "linalg", ".", "multi_dot", "(", "\n", "[", "\n", "ga_approx", ".", "v", "[", "ind", "]", ".", "T", ",", "\n", "inv", "(", "cav_params", ".", "tau", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", "+", "ga_approx", ".", "tau", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", ")", ",", "\n", "ga_approx", ".", "v", "[", "ind", "]", ",", "\n", "]", "\n", ")", "\n", "+", "0.5", "\n", "*", "np", ".", "linalg", ".", "multi_dot", "(", "\n", "[", "\n", "cav_params", ".", "v", "[", "ind", "]", ".", "T", ",", "\n", "inv", "(", "cav_params", ".", "tau", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", "+", "ga_approx", ".", "tau", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", ")", ",", "\n", "np", ".", "linalg", ".", "multi_dot", "(", "\n", "[", "ga_approx", ".", "tau", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", ",", "inv", "(", "cav_params", ".", "tau", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", ")", ",", "cav_params", ".", "v", "[", "ind", "]", "]", "\n", ")", "\n", "-", "2.0", "*", "ga_approx", ".", "v", "[", "ind", "]", ",", "\n", "]", "\n", ")", "\n", ")", "\n", "", "return", "log_Z_tilde", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._ep_marginal": [[468, 494], ["ep_batch_comparison.update_posterior", "numpy.sum", "numpy.log", "numpy.sum", "numpy.diag", "numpy.dot", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.update_posterior"], ["", "def", "_ep_marginal", "(", "\n", "K", ":", "np", ".", "ndarray", ",", "\n", "ga_approx", ":", "GaussianApproximation", ",", "\n", "Z_tilde", ":", "float", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", ")", "->", "Tuple", "[", "float", ",", "posteriorParams", "]", ":", "\n", "    ", "\"\"\"\n    Compute Gaussian log marginal and posterior\n    :param K: prior covariance matrix\n    :param ga_approx: Gaussian approximation of the batches\n    :param Z_tilde: log marginal of the posterior\n    :param y: Direct observations as a list of tuples telling location index (row in X) and observation value.\n    :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n    \"\"\"", "\n", "post_params", "=", "update_posterior", "(", "K", ",", "ga_approx", ".", "v", ",", "ga_approx", ".", "tau", ",", "y", ",", "yc", ")", "\n", "\n", "# Gaussian log marginal excluding terms that can go to infinity due to arbitrarily small tau_tilde.", "\n", "# These terms cancel out with the terms excluded from Z_tilde", "\n", "B_logdet", "=", "np", ".", "sum", "(", "2.0", "*", "np", ".", "log", "(", "np", ".", "diag", "(", "post_params", ".", "L", ")", ")", ")", "\n", "log_marginal", "=", "0.5", "*", "(", "\n", "-", "len", "(", "ga_approx", ".", "v", ")", "*", "log_2_pi", "-", "B_logdet", "+", "np", ".", "sum", "(", "ga_approx", ".", "v", "*", "np", ".", "dot", "(", "post_params", ".", "Sigma", ",", "ga_approx", ".", "v", ")", ")", "\n", ")", "\n", "log_marginal", "+=", "Z_tilde", "\n", "\n", "return", "log_marginal", ",", "post_params", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._inference": [[496, 530], ["ep_batch_comparison._ep_marginal", "ep_batch_comparison.sqrtm_block", "numpy.dot", "GPy.util.linalg.dpotrs", "GPy.util.linalg.dtrtrs", "numpy.dot", "GPy.util.linalg.symmetrify", "numpy.dot", "GPy.inference.latent_function_inference.posterior.PosteriorEP", "numpy.dot", "GPy.util.linalg.tdot", "numpy.asfortranarray"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._ep_marginal", "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison.sqrtm_block"], ["", "def", "_inference", "(", "\n", "K", ":", "np", ".", "ndarray", ",", "\n", "ga_approx", ":", "GaussianApproximation", ",", "\n", "cav_params", ":", "CavityParams", ",", "\n", "Z_tilde", ":", "float", ",", "\n", "y", ":", "List", "[", "Tuple", "[", "int", ",", "float", "]", "]", ",", "\n", "yc", ":", "List", "[", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", "]", ",", "\n", ")", "->", "Tuple", "[", "Posterior", ",", "int", ",", "Dict", "]", ":", "\n", "    ", "\"\"\"\n    Compute the posterior approximation\n    :param K: prior covariance matrix\n    :param ga_approx: Gaussian approximation of the batches\n    :param cav_params: Cavity parameters of the posterior\n    :param Z_tilde: Log marginal likelihood\n    :param y: Direct observations as a list of tuples telling location index (row in X) and observation value.\n    :param yc: Batch comparisons in a list of lists of tuples. Each batch is a list and tuples tell the comparisons (winner index, loser index)\n    :return: A tuple consisting of the posterior approximation, log marginal likelihood and gradient dictionary\n    \"\"\"", "\n", "\n", "log_marginal", ",", "post_params", "=", "_ep_marginal", "(", "K", ",", "ga_approx", ",", "Z_tilde", ",", "y", ",", "yc", ")", "\n", "tau_tilde_root", "=", "sqrtm_block", "(", "ga_approx", ".", "tau", ",", "y", ",", "yc", ")", "\n", "Sroot_tilde_K", "=", "np", ".", "dot", "(", "tau_tilde_root", ",", "K", ")", "\n", "aux_alpha", ",", "_", "=", "dpotrs", "(", "post_params", ".", "L", ",", "np", ".", "dot", "(", "Sroot_tilde_K", ",", "ga_approx", ".", "v", ")", ",", "lower", "=", "1", ")", "\n", "alpha", "=", "(", "ga_approx", ".", "v", "-", "np", ".", "dot", "(", "tau_tilde_root", ",", "aux_alpha", ")", ")", "[", ":", ",", "None", "]", "# (K + Sigma^(\\tilde))^(-1) /mu^(/tilde)", "\n", "LWi", ",", "_", "=", "dtrtrs", "(", "post_params", ".", "L", ",", "tau_tilde_root", ",", "lower", "=", "1", ")", "\n", "\n", "Wi", "=", "np", ".", "dot", "(", "LWi", ".", "T", ",", "LWi", ")", "\n", "symmetrify", "(", "Wi", ")", "# (K + Sigma^(\\tilde))^(-1)", "\n", "dL_dK", "=", "0.5", "*", "(", "tdot", "(", "alpha", ")", "-", "Wi", ")", "\n", "dL_dthetaL", "=", "0", "\n", "return", "(", "\n", "Posterior", "(", "woodbury_inv", "=", "np", ".", "asfortranarray", "(", "Wi", ")", ",", "woodbury_vector", "=", "alpha", ",", "K", "=", "K", ")", ",", "\n", "log_marginal", ",", "\n", "{", "\"dL_dK\"", ":", "dL_dK", ",", "\"dL_dthetaL\"", ":", "dL_dthetaL", ",", "\"dL_dm\"", ":", "alpha", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.inferences.ep_batch_comparison._compute_moments_sampling": [[533, 581], ["numpy.sqrt", "numpy.random.multivariate_normal", "phi", "numpy.exp", "np.exp.copy", "numpy.mean", "max", "numpy.sqrt", "numpy.log().sum", "numpy.prod", "numpy.random.randn", "numpy.sum", "numpy.log"], "function", ["None"], ["", "def", "_compute_moments_sampling", "(", "\n", "mf", ":", "np", ".", "ndarray", ",", "\n", "vf", ":", "np", ".", "ndarray", ",", "\n", "ind_winners", ":", "List", "[", "int", "]", ",", "\n", "ind_loosers", ":", "List", "[", "int", "]", ",", "\n", "nu2", ":", "np", ".", "ndarray", ",", "\n", "N", ":", "int", "=", "10000", ",", "\n", "get_logger", ":", "Callable", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "float", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Compute the marginal moments of a batch using numerical integration\n    :param mf: cavity mean of the batch\n    :params vf: cavity covariance of the batch\n    :params ind_winners: indices of comparison winners\n    :params ind_loosers: indices of comparison loosers\n    :param nu2: noise variance of the batch members\n    :param N: number of samples used for approximating the moments\n    :param get_logger: Function for receiving the logger where the prints are forwarded.\n    :return: Tuple containing the integral, first and second moments\n    \"\"\"", "\n", "m", "=", "vf", ".", "shape", "[", "0", "]", "\n", "sqrt_nu", "=", "np", ".", "sqrt", "(", "nu2", ")", "\n", "\n", "f", "=", "np", ".", "random", ".", "multivariate_normal", "(", "mf", ",", "vf", ",", "N", ")", "\n", "\n", "# Generate samples to compute likelihood", "\n", "if", "not", "(", "np", ".", "prod", "(", "ind_winners", "==", "ind_winners", "[", "0", "]", ")", "==", "1", ")", ":", "# batch winner case", "\n", "        ", "return", "\n", "\n", "", "ind_winner", "=", "ind_winners", "[", "0", "]", "\n", "s", "=", "f", "[", ":", ",", "ind_winner", "]", "+", "sqrt_nu", "[", "ind_winner", "]", "*", "np", ".", "random", ".", "randn", "(", "N", ")", "\n", "s_compare", "=", "phi", "(", "(", "f", "[", ":", ",", "ind_loosers", "]", "-", "s", "[", ":", ",", "None", "]", ")", "/", "sqrt_nu", "[", "None", ",", "ind_loosers", ",", "0", "]", ")", "\n", "s_compare", "=", "np", ".", "exp", "(", "np", ".", "log", "(", "s_compare", ")", ".", "sum", "(", "axis", "=", "1", ")", ")", "\n", "likelihood", "=", "s_compare", ".", "copy", "(", ")", "\n", "qs0_", "=", "np", ".", "mean", "(", "likelihood", ")", "\n", "qs0_", "=", "max", "(", "[", "qs0_", ",", "1e-9", "]", ")", "\n", "\n", "# First moments:", "\n", "f_nonzero", "=", "likelihood", "[", ":", ",", "None", "]", "*", "f", "\n", "likelihood_sqrt", "=", "np", ".", "sqrt", "(", "likelihood", ")", "\n", "f_nonzero_sqrt", "=", "likelihood_sqrt", "[", ":", ",", "None", "]", "*", "f", "\n", "qs1_", "=", "np", ".", "sum", "(", "f_nonzero", ",", "axis", "=", "0", ")", "/", "qs0_", "/", "N", "\n", "\n", "# Second moments", "\n", "diff_f", "=", "f_nonzero_sqrt", "-", "qs1_", "[", "None", ",", ":", "]", "*", "likelihood_sqrt", "[", ":", ",", "None", "]", "\n", "qs2_", "=", "diff_f", ".", "T", "@", "diff_f", "/", "qs0_", "/", "N", "\n", "\n", "return", "qs0_", ",", "qs1_", ",", "qs2_", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.vanilla_bayesian_quadrature_with_rbf.vanilla_bq_loop_with_rbf.create_vanilla_bq_loop_with_rbf_kernel": [[17, 69], ["GPy.models.GPRegression", "emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model", "emukit.quadrature.methods.vanilla_bq.VanillaBayesianQuadrature", "emukit.quadrature.loop.VanillaBayesianQuadratureLoop", "ValueError", "ValueError", "ValueError", "ValueError", "len", "GPy.kern.RBF", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model"], ["def", "create_vanilla_bq_loop_with_rbf_kernel", "(", "\n", "X", ":", "np", ".", "ndarray", ",", "\n", "Y", ":", "np", ".", "ndarray", ",", "\n", "integral_bounds", ":", "Optional", "[", "BoundsType", "]", "=", "None", ",", "\n", "measure", ":", "Optional", "[", "IntegrationMeasure", "]", "=", "None", ",", "\n", "rbf_lengthscale", ":", "float", "=", "1.0", ",", "\n", "rbf_variance", ":", "float", "=", "1.0", ",", "\n", ")", "->", "VanillaBayesianQuadratureLoop", ":", "\n", "    ", "\"\"\"Creates a quadrature loop with a standard (vanilla) model.\n\n    :param X: Initial training point locations, shape (n_points, input_dim).\n    :param Y: Initial training point function values, shape (n_points, 1).\n    :param integral_bounds: List of d tuples, where d is the dimensionality of the integral and the tuples contain the\n                            lower and upper bounds of the integral\n                            i.e., [(lb_1, ub_1), (lb_2, ub_2), ..., (lb_d, ub_d)].\n                            Only used if ``measure`` is not given in which case the unnormalized Lebesgue measure is used.\n    :param measure: An integration measure. Either ``measure`` or ``integral_bounds`` must be given.\n                    If both ``integral_bounds`` and ``measure`` are given, ``integral_bounds`` is disregarded.\n    :param rbf_lengthscale: The lengthscale of the rbf kernel, defaults to 1.\n    :param rbf_variance: The variance of the rbf kernel, defaults to 1.\n    :return: The vanilla BQ loop.\n\n    \"\"\"", "\n", "\n", "if", "measure", "is", "not", "None", "and", "measure", ".", "input_dim", "!=", "X", ".", "shape", "[", "1", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Dimensionality of measure ({measure.input_dim}) does not match the dimensionality of \"", "\n", "f\"the data ({X.shape[1]}).\"", "\n", ")", "\n", "\n", "", "if", "(", "integral_bounds", "is", "not", "None", ")", "and", "(", "len", "(", "integral_bounds", ")", "!=", "X", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Dimension of integral bounds ({len(integral_bounds)}) does not match the input dimension \"", "\n", "f\"of X ({X.shape[1]}).\"", "\n", ")", "\n", "\n", "", "if", "rbf_lengthscale", "<=", "0", ":", "\n", "        ", "raise", "ValueError", "(", "f\"rbf lengthscale must be positive. The current value is {rbf_lengthscale}.\"", ")", "\n", "", "if", "rbf_variance", "<=", "0", ":", "\n", "        ", "raise", "ValueError", "(", "f\"rbf variance must be positive. The current value is {rbf_variance}.\"", ")", "\n", "\n", "", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "\n", "X", "=", "X", ",", "Y", "=", "Y", ",", "kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "X", ".", "shape", "[", "1", "]", ",", "lengthscale", "=", "rbf_lengthscale", ",", "variance", "=", "rbf_variance", ")", "\n", ")", "\n", "\n", "# This function handles the omittion if the integral bounds in case measure is also given.", "\n", "emukit_model", "=", "create_emukit_model_from_gpy_model", "(", "\n", "gpy_model", "=", "gpy_model", ",", "integral_bounds", "=", "integral_bounds", ",", "measure", "=", "measure", "\n", ")", "\n", "emukit_method", "=", "VanillaBayesianQuadrature", "(", "base_gp", "=", "emukit_model", ",", "X", "=", "X", ",", "Y", "=", "Y", ")", "\n", "emukit_loop", "=", "VanillaBayesianQuadratureLoop", "(", "model", "=", "emukit_method", ")", "\n", "return", "emukit_loop", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fmin.fmin_fabolas": [[9, 76], ["emukit.core.initial_designs.latin_design.LatinDesign", "emukit.core.initial_designs.latin_design.LatinDesign.get_samples", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "emukit.examples.fabolas.FabolasLoop", "emukit.examples.fabolas.FabolasLoop.run_loop", "numpy.array", "numpy.where", "func", "numpy.concatenate", "func", "numpy.array", "numpy.array", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.FixedIterationsStoppingCondition", "numpy.array", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.func", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_wsabil_loop.func"], ["def", "fmin_fabolas", "(", "\n", "func", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "s_min", ":", "float", ",", "\n", "s_max", ":", "float", ",", "\n", "n_iters", ":", "int", ",", "\n", "n_init", ":", "int", "=", "20", ",", "\n", "marginalize_hypers", ":", "bool", "=", "True", ",", "\n", ")", "->", "LoopState", ":", "\n", "    ", "\"\"\"\n    Simple interface for Fabolas which optimizes the hyperparameters of machine learning algorithms\n    by reasoning across training data set subsets. For further details see:\n\n    Fast Bayesian hyperparameter optimization on large datasets\n    A. Klein and S. Falkner and S. Bartels and P. Hennig and F. Hutter\n    Electronic Journal of Statistics (2017)\n\n    :param func: objective function which gets a hyperparameter configuration x and training dataset size s as input,\n    and return the validation error and the runtime after training x on s datapoints.\n    :param space: input space\n    :param s_min: minimum training dataset size (linear scale)\n    :param s_max: maximum training dataset size (linear scale)\n    :param n_iters: number of iterations\n    :param n_init: number of initial design points (needs to be smaller than num_iters)\n    :param marginalize_hypers: determines whether to use a MAP estimate or to marginalize over the GP hyperparameters\n\n    :return: LoopState with all evaluated data points\n    \"\"\"", "\n", "initial_design", "=", "LatinDesign", "(", "space", ")", "\n", "\n", "grid", "=", "initial_design", ".", "get_samples", "(", "n_init", ")", "\n", "X_init", "=", "np", ".", "zeros", "(", "[", "n_init", ",", "grid", ".", "shape", "[", "1", "]", "+", "1", "]", ")", "\n", "Y_init", "=", "np", ".", "zeros", "(", "[", "n_init", ",", "1", "]", ")", "\n", "cost_init", "=", "np", ".", "zeros", "(", "[", "n_init", "]", ")", "\n", "\n", "subsets", "=", "np", ".", "array", "(", "[", "s_max", "//", "2", "**", "i", "for", "i", "in", "range", "(", "2", ",", "10", ")", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "idx", "=", "np", ".", "where", "(", "subsets", "<", "s_min", ")", "[", "0", "]", "\n", "\n", "subsets", "[", "idx", "]", "=", "s_min", "\n", "\n", "for", "it", "in", "range", "(", "n_init", ")", ":", "\n", "        ", "func_val", ",", "cost", "=", "func", "(", "x", "=", "grid", "[", "it", "]", ",", "s", "=", "subsets", "[", "it", "%", "len", "(", "subsets", ")", "]", ")", "\n", "\n", "X_init", "[", "it", "]", "=", "np", ".", "concatenate", "(", "(", "grid", "[", "it", "]", ",", "np", ".", "array", "(", "[", "subsets", "[", "it", "%", "len", "(", "subsets", ")", "]", "]", ")", ")", ")", "\n", "Y_init", "[", "it", "]", "=", "func_val", "\n", "cost_init", "[", "it", "]", "=", "cost", "\n", "\n", "", "def", "wrapper", "(", "x", ")", ":", "\n", "        ", "y", ",", "c", "=", "func", "(", "x", "[", "0", ",", ":", "-", "1", "]", ",", "x", "[", "0", ",", "-", "1", "]", ")", "\n", "\n", "return", "np", ".", "array", "(", "[", "[", "y", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "c", "]", "]", ")", "\n", "\n", "", "loop", "=", "FabolasLoop", "(", "\n", "X_init", "=", "X_init", ",", "\n", "Y_init", "=", "Y_init", ",", "\n", "cost_init", "=", "cost_init", ",", "\n", "space", "=", "space", ",", "\n", "s_min", "=", "s_min", ",", "\n", "s_max", "=", "s_max", ",", "\n", "marginalize_hypers", "=", "marginalize_hypers", ",", "\n", ")", "\n", "loop", ".", "run_loop", "(", "\n", "user_function", "=", "UserFunctionWrapper", "(", "wrapper", ",", "extra_output_names", "=", "[", "\"cost\"", "]", ")", ",", "\n", "stopping_condition", "=", "FixedIterationsStoppingCondition", "(", "n_iters", "-", "n_init", ")", ",", "\n", ")", "\n", "\n", "return", "loop", ".", "loop_state", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasKernel.__init__": [[11, 23], ["super().__init__", "GPy.core.parameterization.Param", "GPy.core.parameterization.Param", "fabolas_model.FabolasKernel.link_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_dim", ",", "basis_func", ",", "a", "=", "1.0", ",", "b", "=", "1.0", ",", "active_dims", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", "FabolasKernel", ",", "self", ")", ".", "__init__", "(", "input_dim", ",", "active_dims", ",", "\"fabolas_kernel\"", ")", "\n", "\n", "assert", "input_dim", "==", "1", "\n", "\n", "self", ".", "basis_func", "=", "basis_func", "\n", "\n", "self", ".", "a", "=", "GPy", ".", "core", ".", "parameterization", ".", "Param", "(", "\"a\"", ",", "a", ")", "\n", "self", ".", "b", "=", "GPy", ".", "core", ".", "parameterization", ".", "Param", "(", "\"b\"", ",", "b", ")", "\n", "\n", "self", ".", "link_parameters", "(", "self", ".", "a", ",", "self", ".", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasKernel.K": [[24, 33], ["fabolas_model.FabolasKernel.basis_func", "fabolas_model.FabolasKernel.basis_func", "numpy.dot"], "methods", ["None"], ["", "def", "K", "(", "self", ",", "X", ",", "X2", ")", ":", "\n", "        ", "if", "X2", "is", "None", ":", "\n", "            ", "X2", "=", "X", "\n", "\n", "", "X_", "=", "self", ".", "basis_func", "(", "X", ")", "\n", "X2_", "=", "self", ".", "basis_func", "(", "X2", ")", "\n", "k", "=", "np", ".", "dot", "(", "X_", "*", "self", ".", "b", ",", "X2_", ".", "T", ")", "+", "self", ".", "a", "\n", "\n", "return", "k", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasKernel.update_gradients_full": [[34, 41], ["fabolas_model.FabolasKernel.basis_func", "fabolas_model.FabolasKernel.basis_func", "numpy.sum", "numpy.sum", "numpy.dot", "numpy.dot"], "methods", ["None"], ["", "def", "update_gradients_full", "(", "self", ",", "dL_dK", ",", "X", ",", "X2", ")", ":", "\n", "        ", "if", "X2", "is", "None", ":", "\n", "            ", "X2", "=", "X", "\n", "", "X_", "=", "self", ".", "basis_func", "(", "X", ")", "\n", "X2_", "=", "self", ".", "basis_func", "(", "X2", ")", "\n", "self", ".", "a", ".", "gradient", "=", "np", ".", "sum", "(", "dL_dK", ")", "\n", "self", ".", "b", ".", "gradient", "=", "np", ".", "sum", "(", "np", ".", "dot", "(", "np", ".", "dot", "(", "X_", ",", "X2_", ".", "T", ")", ",", "dL_dK", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasKernel.Kdiag": [[42, 44], ["numpy.diag", "fabolas_model.FabolasKernel.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "Kdiag", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "np", ".", "diag", "(", "self", ".", "K", "(", "X", ",", "X", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.__init__": [[65, 98], ["copy.deepcopy", "fabolas_model.transform", "GPy.kern.Matern52", "fabolas_model.FabolasKernel", "GPy.kern.White", "GPy.models.GPRegression", "GPy.models.GPRegression.kern.set_prior", "GPy.models.GPRegression.likelihood.constrain_positive", "emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.__init__", "GPy.priors.Uniform", "numpy.var", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "X_init", ":", "np", ".", "ndarray", ",", "Y_init", ":", "np", ".", "ndarray", ",", "s_min", ":", "float", ",", "s_max", ":", "float", ",", "basis_func", "=", "linear", ",", "noise", ":", "float", "=", "1e-6", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Fabolas Gaussian processes model which models the validation error / cost of\n        hyperparameter configurations across training dataset subsets.\n\n        :param X_init: training data points\n        :param Y_init: training targets\n        :param basis_func: basis function which describes the change in performance across dataset subsets\n        :param noise: observation noise added to the diagonal of the kernel matrix\n        \"\"\"", "\n", "\n", "self", ".", "noise", "=", "noise", "\n", "self", ".", "s_min", "=", "s_min", "\n", "self", ".", "s_max", "=", "s_max", "\n", "self", ".", "_X", "=", "deepcopy", "(", "X_init", ")", "\n", "self", ".", "_X", "[", ":", ",", "-", "1", "]", "=", "transform", "(", "self", ".", "_X", "[", ":", ",", "-", "1", "]", ",", "self", ".", "s_min", ",", "self", ".", "s_max", ")", "\n", "self", ".", "_Y", "=", "Y_init", "\n", "self", ".", "basis_func", "=", "basis_func", "\n", "kernel", "=", "GPy", ".", "kern", ".", "Matern52", "(", "\n", "input_dim", "=", "self", ".", "_X", ".", "shape", "[", "1", "]", "-", "1", ",", "\n", "active_dims", "=", "[", "i", "for", "i", "in", "range", "(", "self", ".", "_X", ".", "shape", "[", "1", "]", "-", "1", ")", "]", ",", "\n", "variance", "=", "np", ".", "var", "(", "self", ".", "_Y", ")", ",", "\n", "ARD", "=", "True", ",", "\n", ")", "\n", "kernel", "*=", "FabolasKernel", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "self", ".", "_X", ".", "shape", "[", "1", "]", "-", "1", "]", ",", "basis_func", "=", "basis_func", ")", "\n", "kernel", "+=", "GPy", ".", "kern", ".", "White", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "self", ".", "_X", ".", "shape", "[", "1", "]", "-", "1", "]", ",", "variance", "=", "1e-6", ")", "\n", "\n", "gp", "=", "GPy", ".", "models", ".", "GPRegression", "(", "self", ".", "_X", ",", "self", ".", "_Y", ",", "kernel", "=", "kernel", ",", "noise_var", "=", "noise", ")", "\n", "gp", ".", "kern", ".", "set_prior", "(", "GPy", ".", "priors", ".", "Uniform", "(", "0", ",", "5", ")", ")", "\n", "gp", ".", "likelihood", ".", "constrain_positive", "(", ")", "\n", "super", "(", "FabolasModel", ",", "self", ")", ".", "__init__", "(", "gpy_model", "=", "gp", ",", "n_restarts", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.predict": [[99, 107], ["copy.deepcopy", "fabolas_model.transform", "super().predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        :param X: (n_points x n_dimensions) array containing locations at which to get predictions\n        :return: (mean, variance) Arrays of size n_points x 1 of the predictive distribution at each input location\n        \"\"\"", "\n", "X_", "=", "deepcopy", "(", "X", ")", "\n", "X_", "[", ":", ",", "-", "1", "]", "=", "transform", "(", "X_", "[", ":", ",", "-", "1", "]", ",", "self", ".", "s_min", ",", "self", ".", "s_max", ")", "\n", "return", "super", "(", "FabolasModel", ",", "self", ")", ".", "predict", "(", "X_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.set_data": [[108, 132], ["copy.deepcopy", "fabolas_model.transform", "fabolas_model.FabolasModel.model.set_XY", "GPy.kern.Matern52", "fabolas_model.FabolasKernel", "GPy.kern.OU", "GPy.models.GPRegression", "fabolas_model.FabolasModel.model.likelihood.constrain_positive", "numpy.var", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY"], ["", "def", "set_data", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "\"\"\"\n        Sets training data in model\n\n        :param X: New training features\n        :param Y: New training outputs\n        \"\"\"", "\n", "self", ".", "_X", "=", "deepcopy", "(", "X", ")", "\n", "self", ".", "_X", "[", ":", ",", "-", "1", "]", "=", "transform", "(", "self", ".", "_X", "[", ":", ",", "-", "1", "]", ",", "self", ".", "s_min", ",", "self", ".", "s_max", ")", "\n", "self", ".", "_Y", "=", "Y", "\n", "try", ":", "\n", "            ", "self", ".", "model", ".", "set_XY", "(", "self", ".", "_X", ",", "self", ".", "Y", ")", "\n", "", "except", ":", "\n", "            ", "kernel", "=", "GPy", ".", "kern", ".", "Matern52", "(", "\n", "input_dim", "=", "self", ".", "_X", ".", "shape", "[", "1", "]", "-", "1", ",", "\n", "active_dims", "=", "[", "i", "for", "i", "in", "range", "(", "self", ".", "_X", ".", "shape", "[", "1", "]", "-", "1", ")", "]", ",", "\n", "variance", "=", "np", ".", "var", "(", "self", ".", "Y", ")", ",", "\n", "ARD", "=", "True", ",", "\n", ")", "\n", "kernel", "*=", "FabolasKernel", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "self", ".", "_X", ".", "shape", "[", "1", "]", "-", "1", "]", ",", "basis_func", "=", "self", ".", "basis_func", ")", "\n", "kernel", "*=", "GPy", ".", "kern", ".", "OU", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "self", ".", "_X", ".", "shape", "[", "1", "]", "-", "1", "]", ")", "\n", "\n", "self", ".", "model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "self", ".", "_X", ",", "self", ".", "Y", ",", "kernel", "=", "kernel", ",", "noise_var", "=", "self", ".", "noise", ")", "\n", "self", ".", "model", ".", "likelihood", ".", "constrain_positive", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.get_f_minimum": [[133, 145], ["copy.deepcopy", "fabolas_model.FabolasModel.model.predict", "numpy.min", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "", "def", "get_f_minimum", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Predicts for all observed data points the validation error on the full dataset and returns\n        the smallest mean prediciton\n\n        :return: Array of size 1 x 1\n        \"\"\"", "\n", "proj_X", "=", "deepcopy", "(", "self", ".", "_X", ")", "\n", "proj_X", "[", ":", ",", "-", "1", "]", "=", "np", ".", "ones", "(", "proj_X", ".", "shape", "[", "0", "]", ")", "*", "self", ".", "s_max", "\n", "mean_highest_dataset", "=", "self", ".", "model", ".", "predict", "(", "proj_X", ")", "\n", "\n", "return", "np", ".", "min", "(", "mean_highest_dataset", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.X": [[146, 151], ["copy.deepcopy", "fabolas_model.retransform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.retransform"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "X", "=", "deepcopy", "(", "self", ".", "_X", ")", "\n", "X", "[", ":", ",", "-", "1", "]", "=", "retransform", "(", "X", "[", ":", ",", "-", "1", "]", ",", "self", ".", "s_min", ",", "self", ".", "s_max", ")", "\n", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.Y": [[152, 155], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.get_prediction_gradients": [[156, 166], ["copy.deepcopy", "fabolas_model.transform", "super().get_prediction_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "get_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param X: (n_points x n_dimensions) array containing locations at which to get gradient of the predictions\n        :return: (mean gradient, variance gradient) n_points x n_dimensions arrays of the gradients of the predictive\n                 distribution at each input location\n        \"\"\"", "\n", "X_", "=", "deepcopy", "(", "X", ")", "\n", "X_", "[", ":", ",", "-", "1", "]", "=", "transform", "(", "X_", "[", ":", ",", "-", "1", "]", ",", "self", ".", "s_min", ",", "self", ".", "s_max", ")", "\n", "\n", "return", "super", "(", "FabolasModel", ",", "self", ")", ".", "get_prediction_gradients", "(", "X_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.predict_covariance": [[167, 178], ["copy.deepcopy", "fabolas_model.transform", "super().predict_covariance"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.predict_covariance"], ["", "def", "predict_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "with_noise", ":", "bool", "=", "True", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculates posterior covariance between points in X\n        :param X: Array of size n_points x n_dimensions containing input locations to compute posterior covariance at\n        :param with_noise: Whether to include likelihood noise in the covariance matrix\n        :return: Posterior covariance matrix of size n_points x n_points\n        \"\"\"", "\n", "X_", "=", "deepcopy", "(", "X", ")", "\n", "X_", "[", ":", ",", "-", "1", "]", "=", "transform", "(", "X_", "[", ":", ",", "-", "1", "]", ",", "self", ".", "s_min", ",", "self", ".", "s_max", ")", "\n", "\n", "return", "super", "(", "FabolasModel", ",", "self", ")", ".", "predict_covariance", "(", "X_", ",", "with_noise", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.FabolasModel.get_covariance_between_points": [[179, 194], ["copy.deepcopy", "fabolas_model.transform", "copy.deepcopy", "fabolas_model.transform", "super().get_covariance_between_points"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_covariance_between_points"], ["", "def", "get_covariance_between_points", "(", "self", ",", "X1", ":", "np", ".", "ndarray", ",", "X2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculate posterior covariance between two points\n        :param X1: An array of shape 1 x n_dimensions that contains a data single point. It is the first argument of the\n                   posterior covariance function\n        :param X2: An array of shape n_points x n_dimensions that may contain multiple data points. This is the second\n                   argument to the posterior covariance function.\n        :return: An array of shape n_points x 1 of posterior covariances between X1 and X2\n        \"\"\"", "\n", "X_1", "=", "deepcopy", "(", "X1", ")", "\n", "X_1", "[", ":", ",", "-", "1", "]", "=", "transform", "(", "X_1", "[", ":", ",", "-", "1", "]", ",", "self", ".", "s_min", ",", "self", ".", "s_max", ")", "\n", "X_2", "=", "deepcopy", "(", "X2", ")", "\n", "X_2", "[", ":", ",", "-", "1", "]", "=", "transform", "(", "X_2", "[", ":", ",", "-", "1", "]", ",", "self", ".", "s_min", ",", "self", ".", "s_max", ")", "\n", "\n", "return", "super", "(", "FabolasModel", ",", "self", ")", ".", "get_covariance_between_points", "(", "X1", ",", "X2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.linear": [[46, 48], ["None"], "function", ["None"], ["", "", "def", "linear", "(", "s", ")", ":", "\n", "    ", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.quad": [[50, 52], ["None"], "function", ["None"], ["", "def", "quad", "(", "s", ")", ":", "\n", "    ", "return", "(", "1", "-", "s", ")", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.transform": [[54, 57], ["numpy.log2", "numpy.log2", "numpy.log2", "numpy.log2"], "function", ["None"], ["", "def", "transform", "(", "s", ",", "s_min", ",", "s_max", ")", ":", "\n", "    ", "s_transform", "=", "(", "np", ".", "log2", "(", "s", ")", "-", "np", ".", "log2", "(", "s_min", ")", ")", "/", "(", "np", ".", "log2", "(", "s_max", ")", "-", "np", ".", "log2", "(", "s_min", ")", ")", "\n", "return", "s_transform", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_model.retransform": [[59, 62], ["numpy.rint", "numpy.log2", "numpy.log2", "numpy.log2"], "function", ["None"], ["", "def", "retransform", "(", "s_transform", ",", "s_min", ",", "s_max", ")", ":", "\n", "    ", "s", "=", "np", ".", "rint", "(", "2", "**", "(", "s_transform", "*", "(", "np", ".", "log2", "(", "s_max", ")", "-", "np", ".", "log2", "(", "s_min", ")", ")", "+", "np", ".", "log2", "(", "s_min", ")", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.example.wrapper": [[30, 33], ["svm.objective_function"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.meta_surrogates.objective_function"], ["def", "wrapper", "(", "x", ",", "s", ")", ":", "\n", "    ", "res", "=", "svm", ".", "objective_function", "(", "x", ",", "dataset_fraction", "=", "s", "/", "s_max", ")", "\n", "return", "res", "[", "\"function_value\"", "]", ",", "res", "[", "\"cost\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.fabolas_loop.FabolasLoop.__init__": [[16, 75], ["l.extend", "emukit.core.ParameterSpace", "emukit.examples.fabolas.fabolas_model.FabolasModel", "emukit.examples.fabolas.fabolas_model.FabolasModel", "emukit.core.acquisition.acquisition_per_expected_cost", "emukit.core.loop.FixedIntervalUpdater", "emukit.core.loop.FixedIntervalUpdater", "emukit.core.optimization.RandomSearchAcquisitionOptimizer", "emukit.core.loop.SequentialPointCalculator", "emukit.core.loop.loop_state.create_loop_state", "emukit.bayesian_optimization.loops.cost_sensitive_bayesian_optimization_loop.CostSensitiveBayesianOptimizationLoop.__init__", "emukit.core.acquisition.IntegratedHyperParameterAcquisition", "emukit.examples.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch", "emukit.core.ContinuousParameter", "emukit.examples.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.acquisition_per_expected_cost", "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "X_init", ":", "np", ".", "ndarray", ",", "\n", "Y_init", ":", "np", ".", "ndarray", ",", "\n", "cost_init", ":", "np", ".", "ndarray", ",", "\n", "s_min", ":", "float", ",", "\n", "s_max", ":", "float", ",", "\n", "update_interval", ":", "int", "=", "1", ",", "\n", "num_eval_points", ":", "int", "=", "2000", ",", "\n", "marginalize_hypers", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Implements FAst Bayesian Optimization for LArge DataSets as described in:\n\n        Fast Bayesian hyperparameter optimization on large datasets\n        A. Klein and S. Falkner and S. Bartels and P. Hennig and F. Hutter\n        Electronic Journal of Statistics (2017)\n\n        :param space: input space where the optimization is carried out.\n        :param X_init: initial data points\n        :param Y_init: initial function values\n        :param cost_init: initial costs\n        :param s_min: smallest possible dataset size\n        :param s_max: highest possible dataset size\n        :param update_interval:  number of iterations between optimization of model hyper-parameters. Defaults to 1.\n        :param num_eval_points: number of points to evaluate the acquisition function\n        :param marginalize_hypers: if true, marginalize over the GP hyperparameters\n        \"\"\"", "\n", "\n", "l", "=", "space", ".", "parameters", "\n", "l", ".", "extend", "(", "[", "ContinuousParameter", "(", "\"s\"", ",", "s_min", ",", "s_max", ")", "]", ")", "\n", "extended_space", "=", "ParameterSpace", "(", "l", ")", "\n", "\n", "model_objective", "=", "FabolasModel", "(", "X_init", "=", "X_init", ",", "Y_init", "=", "Y_init", ",", "s_min", "=", "s_min", ",", "s_max", "=", "s_max", ")", "\n", "model_cost", "=", "FabolasModel", "(", "X_init", "=", "X_init", ",", "Y_init", "=", "cost_init", "[", ":", ",", "None", "]", ",", "s_min", "=", "s_min", ",", "s_max", "=", "s_max", ")", "\n", "\n", "if", "marginalize_hypers", ":", "\n", "            ", "acquisition_generator", "=", "lambda", "model", ":", "ContinuousFidelityEntropySearch", "(", "\n", "model_objective", ",", "space", "=", "extended_space", ",", "target_fidelity_index", "=", "len", "(", "extended_space", ".", "parameters", ")", "-", "1", "\n", ")", "\n", "entropy_search", "=", "IntegratedHyperParameterAcquisition", "(", "model_objective", ",", "acquisition_generator", ")", "\n", "", "else", ":", "\n", "            ", "entropy_search", "=", "ContinuousFidelityEntropySearch", "(", "\n", "model_objective", ",", "space", "=", "extended_space", ",", "target_fidelity_index", "=", "len", "(", "extended_space", ".", "parameters", ")", "-", "1", "\n", ")", "\n", "\n", "", "acquisition", "=", "acquisition_per_expected_cost", "(", "entropy_search", ",", "model_cost", ")", "\n", "\n", "model_updater_objective", "=", "FixedIntervalUpdater", "(", "model_objective", ",", "update_interval", ")", "\n", "model_updater_cost", "=", "FixedIntervalUpdater", "(", "model_cost", ",", "update_interval", ",", "lambda", "state", ":", "state", ".", "cost", ")", "\n", "\n", "acquisition_optimizer", "=", "RandomSearchAcquisitionOptimizer", "(", "extended_space", ",", "num_eval_points", "=", "num_eval_points", ")", "\n", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ")", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "model_objective", ".", "X", ",", "model_objective", ".", "Y", ",", "cost", "=", "model_cost", ".", "Y", ")", "\n", "\n", "super", "(", "CostSensitiveBayesianOptimizationLoop", ",", "self", ")", ".", "__init__", "(", "\n", "candidate_point_calculator", ",", "[", "model_updater_objective", ",", "model_updater_cost", "]", ",", "loop_state", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch.__init__": [[19, 56], ["space.parameters.copy", "space.parameters.copy.remove", "emukit.core.parameter_space.ParameterSpace", "emukit.samplers.AffineInvariantEnsembleSampler", "continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch._get_proposal_function", "emukit.bayesian_optimization.acquisitions.entropy_search.EntropySearch.__init__", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch._get_proposal_function", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Union", "[", "IModel", ",", "IEntropySearchModel", "]", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "target_fidelity_index", ":", "int", "=", "None", ",", "\n", "num_samples", ":", "int", "=", "100", ",", "\n", "num_representer_points", ":", "int", "=", "50", ",", "\n", "burn_in_steps", ":", "int", "=", "50", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param model: Gaussian process model of the objective function that implements IEntropySearchModel\n        :param space: Parameter space of the input domain\n        :param target_fidelity_index: The index of the parameter which defines the fidelity\n        :param num_samples: Integer determining how many samples to draw for each candidate input\n        :param num_representer_points: Integer determining how many representer points to sample\n        :param burn_in_steps: Integer that defines the number of burn-in steps when sampling the representer points\n        \"\"\"", "\n", "\n", "# Find fidelity parameter in parameter space", "\n", "if", "target_fidelity_index", "is", "None", ":", "\n", "            ", "self", ".", "target_fidelity_index", "=", "len", "(", "space", ".", "parameters", ")", "-", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "target_fidelity_index", "=", "target_fidelity_index", "\n", "", "self", ".", "fidelity_parameter", "=", "space", ".", "parameters", "[", "self", ".", "target_fidelity_index", "]", "\n", "self", ".", "high_fidelity", "=", "self", ".", "fidelity_parameter", ".", "max", "\n", "\n", "# Sampler of representer points should sample x location at the highest fidelity", "\n", "parameters_without_info_source", "=", "space", ".", "parameters", ".", "copy", "(", ")", "\n", "parameters_without_info_source", ".", "remove", "(", "self", ".", "fidelity_parameter", ")", "\n", "space_without_info_source", "=", "ParameterSpace", "(", "parameters_without_info_source", ")", "\n", "\n", "# Create sampler of representer points", "\n", "sampler", "=", "AffineInvariantEnsembleSampler", "(", "space_without_info_source", ")", "\n", "\n", "proposal_func", "=", "self", ".", "_get_proposal_function", "(", "model", ",", "space", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "model", ",", "space", ",", "sampler", ",", "num_samples", ",", "num_representer_points", ",", "proposal_func", ",", "burn_in_steps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch._sample_representer_points": [[57, 64], ["super()._sample_representer_points", "numpy.insert", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch._sample_representer_points"], ["", "def", "_sample_representer_points", "(", "self", ")", ":", "\n", "        ", "repr_points", ",", "repr_points_log", "=", "super", "(", ")", ".", "_sample_representer_points", "(", ")", "\n", "\n", "# Add fidelity index to representer points", "\n", "idx", "=", "np", ".", "ones", "(", "(", "repr_points", ".", "shape", "[", "0", "]", ")", ")", "*", "self", ".", "high_fidelity", "\n", "repr_points", "=", "np", ".", "insert", "(", "repr_points", ",", "self", ".", "target_fidelity_index", ",", "idx", ",", "axis", "=", "1", ")", "\n", "return", "repr_points", ",", "repr_points_log", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch._get_proposal_function": [[65, 87], ["emukit.bayesian_optimization.acquisitions.ExpectedImprovement", "numpy.insert", "space.check_points_in_domain", "numpy.ones", "numpy.log", "numpy.any", "numpy.array", "numpy.clip", "numpy.isnan", "numpy.array", "emukit.bayesian_optimization.acquisitions.ExpectedImprovement.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "_get_proposal_function", "(", "self", ",", "model", ",", "space", ")", ":", "\n", "\n", "# Define proposal function for multi-fidelity", "\n", "        ", "ei", "=", "ExpectedImprovement", "(", "model", ")", "\n", "\n", "def", "proposal_func", "(", "x", ")", ":", "\n", "            ", "x_", "=", "x", "[", "None", ",", ":", "]", "\n", "# Map to highest fidelity", "\n", "idx", "=", "np", ".", "ones", "(", "(", "x_", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "*", "self", ".", "high_fidelity", "\n", "\n", "x_", "=", "np", ".", "insert", "(", "x_", ",", "self", ".", "target_fidelity_index", ",", "idx", ",", "axis", "=", "1", ")", "\n", "\n", "if", "space", ".", "check_points_in_domain", "(", "x_", ")", ":", "\n", "                ", "val", "=", "np", ".", "log", "(", "np", ".", "clip", "(", "ei", ".", "evaluate", "(", "x_", ")", "[", "0", "]", ",", "0.0", ",", "np", ".", "PINF", ")", ")", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "val", ")", ")", ":", "\n", "                    ", "return", "np", ".", "array", "(", "[", "np", ".", "NINF", "]", ")", "\n", "", "else", ":", "\n", "                    ", "return", "val", "\n", "", "", "else", ":", "\n", "                ", "return", "np", ".", "array", "(", "[", "np", ".", "NINF", "]", ")", "\n", "\n", "", "", "return", "proposal_func", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.test_continuous_entropy_search.test_continuous_entropy_search": [[8, 25], ["numpy.random.RandomState", "np.random.RandomState.rand", "numpy.random.uniform", "numpy.concatenate", "np.random.RandomState.rand", "emukit.examples.fabolas.FabolasModel", "emukit.core.ParameterSpace", "emukit.examples.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch", "emukit.examples.fabolas.continuous_fidelity_entropy_search.ContinuousFidelityEntropySearch.update_pmin", "numpy.all", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "numpy.log", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.entropy_search.EntropySearch.update_pmin"], ["def", "test_continuous_entropy_search", "(", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "x_init", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "s_min", "=", "10", "\n", "s_max", "=", "10000", "\n", "s", "=", "np", ".", "random", ".", "uniform", "(", "s_min", ",", "s_max", ",", "x_init", ".", "shape", "[", "0", "]", ")", "\n", "x_init", "=", "np", ".", "concatenate", "(", "(", "x_init", ",", "s", "[", ":", ",", "None", "]", ")", ",", "axis", "=", "1", ")", "\n", "y_init", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "model", "=", "FabolasModel", "(", "X_init", "=", "x_init", ",", "Y_init", "=", "y_init", ",", "s_min", "=", "s_min", ",", "s_max", "=", "s_max", ")", "\n", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"s\"", ",", "np", ".", "log", "(", "s_min", ")", ",", "np", ".", "log", "(", "s_max", ")", ")", "]", ")", "\n", "\n", "es", "=", "ContinuousFidelityEntropySearch", "(", "model", ",", "space", ",", "num_representer_points", "=", "10", ")", "\n", "es", ".", "update_pmin", "(", ")", "\n", "\n", "assert", "np", ".", "all", "(", "es", ".", "representer_points", "[", ":", ",", "-", "1", "]", "==", "np", ".", "log", "(", "s_max", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.test_fabolas_model.model": [[7, 19], ["numpy.random.RandomState", "np.random.RandomState.rand", "numpy.random.uniform", "numpy.concatenate", "np.random.RandomState.rand", "emukit.examples.fabolas.FabolasModel"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform"], ["@", "pytest", ".", "fixture", "\n", "def", "model", "(", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "x_init", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "s_min", "=", "10", "\n", "s_max", "=", "10000", "\n", "s", "=", "np", ".", "random", ".", "uniform", "(", "s_min", ",", "s_max", ",", "x_init", ".", "shape", "[", "0", "]", ")", "\n", "x_init", "=", "np", ".", "concatenate", "(", "(", "x_init", ",", "s", "[", ":", ",", "None", "]", ")", ",", "axis", "=", "1", ")", "\n", "y_init", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "model", "=", "FabolasModel", "(", "X_init", "=", "x_init", ",", "Y_init", "=", "y_init", ",", "s_min", "=", "s_min", ",", "s_max", "=", "s_max", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.test_fabolas_model.test_predict_shape": [[21, 31], ["numpy.random.RandomState", "np.random.RandomState.rand", "numpy.random.uniform", "numpy.concatenate", "model.predict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "test_predict_shape", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "\n", "x_test", "=", "rng", ".", "rand", "(", "10", ",", "2", ")", "\n", "s", "=", "np", ".", "random", ".", "uniform", "(", "model", ".", "s_min", ",", "model", ".", "s_max", ",", "x_test", ".", "shape", "[", "0", "]", ")", "\n", "x_test", "=", "np", ".", "concatenate", "(", "(", "x_test", ",", "s", "[", ":", ",", "None", "]", ")", ",", "axis", "=", "1", ")", "\n", "m", ",", "v", "=", "model", ".", "predict", "(", "x_test", ")", "\n", "\n", "assert", "m", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "assert", "v", ".", "shape", "==", "(", "10", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.fabolas.test_fabolas_model.test_update_data": [[33, 43], ["numpy.random.RandomState", "np.random.RandomState.rand", "numpy.random.uniform", "numpy.concatenate", "np.random.RandomState.rand", "model.set_data"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["", "def", "test_update_data", "(", "model", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "43", ")", "\n", "x_new", "=", "rng", ".", "rand", "(", "5", ",", "2", ")", "\n", "s", "=", "np", ".", "random", ".", "uniform", "(", "model", ".", "s_min", ",", "model", ".", "s_max", ",", "x_new", ".", "shape", "[", "0", "]", ")", "\n", "x_new", "=", "np", ".", "concatenate", "(", "(", "x_new", ",", "s", "[", ":", ",", "None", "]", ")", ",", "axis", "=", "1", ")", "\n", "y_new", "=", "rng", ".", "rand", "(", "5", ",", "1", ")", "\n", "model", ".", "set_data", "(", "x_new", ",", "y_new", ")", "\n", "\n", "assert", "model", ".", "X", ".", "shape", "==", "x_new", ".", "shape", "\n", "assert", "model", ".", "Y", ".", "shape", "==", "y_new", ".", "shape", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.profet.train_meta_model.download_data": [[35, 42], ["tarfile.open", "tarfile.open.extractall", "tarfile.open.close", "urllib.request.urlretrieve"], "function", ["None"], ["def", "download_data", "(", "path", ",", "source", "=", "\"http://www.ml4aad.org/wp-content/uploads/2019/05/profet_data.tar.gz\"", ")", ":", "\n", "\n", "    ", "l", "=", "urlretrieve", "(", "source", ")", "[", "0", "]", "\n", "\n", "tar", "=", "tarfile", ".", "open", "(", "l", ")", "\n", "tar", ".", "extractall", "(", "path", "=", "path", ")", "\n", "tar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.profet.train_meta_model.load_data": [[44, 47], ["json.load", "open", "numpy.array", "numpy.array", "numpy.array", "os.path.join"], "function", ["None"], ["", "def", "load_data", "(", "path", ",", "filename", ")", ":", "\n", "    ", "res", "=", "json", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "path", ",", "filename", ")", ",", "\"r\"", ")", ")", "\n", "return", "np", ".", "array", "(", "res", "[", "\"X\"", "]", ")", ",", "np", ".", "array", "(", "res", "[", "\"Y\"", "]", ")", ",", "np", ".", "array", "(", "res", "[", "\"C\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.profet.train_meta_model.normalize_Y": [[49, 58], ["numpy.max", "numpy.zeros", "numpy.zeros", "range", "Y[].mean", "Y[].std"], "function", ["None"], ["", "def", "normalize_Y", "(", "Y", ",", "indexD", ")", ":", "\n", "    ", "max_idx", "=", "np", ".", "max", "(", "indexD", ")", "\n", "Y_mean", "=", "np", ".", "zeros", "(", "max_idx", "+", "1", ")", "\n", "Y_std", "=", "np", ".", "zeros", "(", "max_idx", "+", "1", ")", "\n", "for", "i", "in", "range", "(", "max_idx", "+", "1", ")", ":", "\n", "        ", "Y_mean", "[", "i", "]", "=", "Y", "[", "indexD", "==", "i", "]", ".", "mean", "(", ")", "\n", "Y_std", "[", "i", "]", "=", "Y", "[", "indexD", "==", "i", "]", ".", "std", "(", ")", "+", "1e-8", "\n", "Y", "[", "indexD", "==", "i", "]", "=", "(", "Y", "[", "indexD", "==", "i", "]", "-", "Y_mean", "[", "i", "]", ")", "/", "Y_std", "[", "i", "]", "\n", "", "return", "Y", ",", "Y_mean", "[", ":", ",", "None", "]", ",", "Y_std", "[", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.profet.performance_assessment.compute_runtime_feval": [[5, 20], ["numpy.where", "len"], "function", ["None"], ["def", "compute_runtime_feval", "(", "trajectory", ":", "np", ".", "ndarray", ",", "target", ":", "float", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Computes the runtime in terms of number of function evaluations until a performance smaller or\n    equal than a specified target value is achieved.\n\n    :param trajectory: trajectory of the performance of an optimizer after each function evaluation\n    :param target: target value\n    :return: runtime\n    \"\"\"", "\n", "rt", "=", "np", ".", "where", "(", "trajectory", "<=", "target", ")", "[", "0", "]", "\n", "if", "len", "(", "rt", ")", "==", "0", ":", "\n", "        ", "rt", "=", "np", ".", "inf", "\n", "return", "rt", "\n", "", "else", ":", "\n", "        ", "return", "rt", "[", "0", "]", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.profet.performance_assessment.compute_ecdf": [[22, 47], ["range", "numpy.sort", "range", "numpy.arange", "float", "np.sort.tolist", "yvals.tolist", "range", "len", "len", "performance_assessment.compute_runtime_feval", "runtime.append"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.profet.performance_assessment.compute_runtime_feval"], ["", "", "def", "compute_ecdf", "(", "error", ":", "np", ".", "ndarray", ",", "targets", ":", "np", ".", "ndarray", ")", "->", "tuple", ":", "\n", "    ", "\"\"\"\n    Computes the empirical cumulative distribution (ECDF) of the runtime of an optimizer\n    across different targets and tasks.\n\n    :param error: matrix with I x R x N entries, where I are the number of instances or tasks,\n    R is the number of runs per task and N are the number of function evaluations per task and run\n    :param targets: matrix with I x T entries, where I are the number of instances or tasks and T are the number\n    of targets values\n    :return: ECDF as tuple, where the first entries defines the runtime and the second the CDF\n    \"\"\"", "\n", "n_instances", "=", "error", ".", "shape", "[", "0", "]", "\n", "n_runs", "=", "error", ".", "shape", "[", "1", "]", "\n", "n_targets", "=", "targets", ".", "shape", "[", "1", "]", "\n", "\n", "runtime", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_instances", ")", ":", "\n", "        ", "for", "t", "in", "range", "(", "n_targets", ")", ":", "\n", "            ", "for", "r", "in", "range", "(", "n_runs", ")", ":", "\n", "                ", "rt", "=", "compute_runtime_feval", "(", "error", "[", "i", ",", "r", "]", ",", "targets", "[", "i", ",", "t", "]", ")", "\n", "runtime", ".", "append", "(", "rt", ")", "\n", "", "", "", "sorted_error", "=", "np", ".", "sort", "(", "runtime", ")", "\n", "yvals", "=", "np", ".", "arange", "(", "len", "(", "sorted_error", ")", ")", "/", "float", "(", "len", "(", "sorted_error", ")", ")", "\n", "\n", "return", "sorted_error", ".", "tolist", "(", ")", ",", "yvals", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.profet.performance_assessment.compute_ranks": [[49, 77], ["numpy.zeros", "range", "range", "numpy.random.randint", "scipy.rankdata", "numpy.array", "range", "range", "enumerate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint"], ["", "def", "compute_ranks", "(", "errors", ",", "n_bootstrap", "=", "1000", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Computes the averaged ranking score in every iteration and for every task..\n\n    :param errors: matrix with M x I x R x N entries, where M are the number of optimizers,\n    I are the number of instances or tasks, R is the number of runs per task and\n    N are the number of function evaluations per task and run\n    :param n_bootstrap: number bootstrap samples to compute the ranks\n    :return: the ranks after each iteration as a MxN ndarray, where, as for errors, M are the number of optimizers\n    and N are the number of function evaluations\n    \"\"\"", "\n", "n_methods", "=", "errors", ".", "shape", "[", "0", "]", "\n", "n_instances", "=", "errors", ".", "shape", "[", "1", "]", "\n", "n_runs", "=", "errors", ".", "shape", "[", "2", "]", "\n", "n_iters", "=", "errors", ".", "shape", "[", "3", "]", "\n", "\n", "ranks", "=", "np", ".", "zeros", "(", "[", "n_methods", ",", "n_iters", "]", ")", "\n", "for", "instance_id", "in", "range", "(", "n_instances", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "n_bootstrap", ")", ":", "\n", "            ", "runs", "=", "[", "np", ".", "random", ".", "randint", "(", "n_runs", ")", "for", "i", "in", "range", "(", "n_methods", ")", "]", "\n", "\n", "rank_samples", "=", "[", "\n", "stats", ".", "rankdata", "(", "[", "errors", "[", "i", ",", "instance_id", ",", "ri", ",", "t", "]", "for", "i", ",", "ri", "in", "enumerate", "(", "runs", ")", "]", ")", "for", "t", "in", "range", "(", "n_iters", ")", "\n", "]", "\n", "ranks", "+=", "np", ".", "array", "(", "rank_samples", ")", ".", "T", "\n", "", "", "ranks", "/=", "n_instances", "*", "n_bootstrap", "\n", "\n", "return", "ranks", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.profet.test_performance_assessment.test_compute_runtime_feval": [[6, 11], ["emukit.examples.profet.performance_assessment.compute_runtime_feval", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.profet.performance_assessment.compute_runtime_feval"], ["def", "test_compute_runtime_feval", "(", ")", ":", "\n", "    ", "traj", "=", "np", ".", "arange", "(", "0", ",", "10", ")", "[", ":", ":", "-", "1", "]", "\n", "rt", "=", "compute_runtime_feval", "(", "traj", ",", "5", ")", "\n", "\n", "assert", "rt", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.profet.test_performance_assessment.test_compute_ecdf": [[13, 20], ["numpy.random.randn", "numpy.random.rand", "emukit.examples.profet.performance_assessment.compute_ecdf", "len", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.profet.performance_assessment.compute_ecdf"], ["", "def", "test_compute_ecdf", "(", ")", ":", "\n", "    ", "error", "=", "np", ".", "random", ".", "randn", "(", "100", ",", "20", ",", "50", ")", "\n", "targets", "=", "np", ".", "random", ".", "rand", "(", "100", ",", "10", ")", "\n", "\n", "error_range", ",", "cdf", "=", "compute_ecdf", "(", "error", ",", "targets", ")", "\n", "\n", "assert", "len", "(", "error_range", ")", "==", "len", "(", "cdf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.profet.test_performance_assessment.compute_ranks": [[22, 28], ["numpy.random.rand", "emukit.examples.profet.performance_assessment.compute_ranks"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.profet.test_performance_assessment.compute_ranks"], ["", "def", "compute_ranks", "(", ")", ":", "\n", "    ", "error", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "10", ",", "10", ",", "20", ")", "\n", "ranks", "=", "compute_ranks", "(", "error", ")", "\n", "\n", "assert", "ranks", ".", "shape", "[", "0", "]", "==", "2", "\n", "assert", "ranks", ".", "shape", "[", "1", "]", "==", "20", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.meta_surrogates.objective_function": [[5, 57], ["numpy.repeat", "numpy.concatenate", "torch.from_numpy().float", "model_objective.forward().data.numpy", "numpy.repeat", "numpy.concatenate", "torch.from_numpy().float", "model_cost.forward().data.numpy", "numpy.exp", "torch.from_numpy", "numpy.random.randn", "numpy.sqrt", "torch.from_numpy", "numpy.random.randn", "numpy.sqrt", "numpy.exp", "model_objective.forward", "numpy.exp", "model_cost.forward", "numpy.exp"], "function", ["None"], ["def", "objective_function", "(", "\n", "config", ",", "\n", "model_objective", ",", "\n", "model_cost", ",", "\n", "task_feature_objective", ",", "\n", "task_feature_cost", ",", "\n", "x_mean_objective", ",", "\n", "x_std_objective", ",", "\n", "x_mean_cost", ",", "\n", "x_std_cost", ",", "\n", "y_mean_objective", "=", "None", ",", "\n", "y_std_objective", "=", "None", ",", "\n", "y_mean_cost", "=", "None", ",", "\n", "y_std_cost", "=", "None", ",", "\n", "log_objective", "=", "False", ",", "\n", "with_noise", "=", "True", ",", "\n", ")", ":", "\n", "\n", "    ", "Ht", "=", "np", ".", "repeat", "(", "task_feature_objective", "[", "None", ",", ":", "]", ",", "config", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "x", "=", "np", ".", "concatenate", "(", "(", "config", ",", "Ht", ")", ",", "axis", "=", "1", ")", "\n", "x_norm", "=", "torch", ".", "from_numpy", "(", "(", "x", "-", "x_mean_objective", ")", "/", "x_std_objective", ")", ".", "float", "(", ")", "\n", "output", "=", "model_objective", ".", "forward", "(", "x_norm", ")", ".", "data", ".", "numpy", "(", ")", "\n", "\n", "mean", "=", "output", "[", ":", ",", "0", "]", "\n", "log_variance", "=", "output", "[", ":", ",", "1", "]", "\n", "if", "y_mean_objective", "is", "not", "None", "or", "y_std_objective", "is", "not", "None", ":", "\n", "        ", "mean", "=", "mean", "*", "y_std_objective", "+", "y_mean_objective", "\n", "log_variance", "*=", "y_std_objective", "**", "2", "\n", "\n", "", "feval", "=", "mean", "\n", "if", "with_noise", ":", "\n", "        ", "feval", "+=", "np", ".", "random", ".", "randn", "(", ")", "*", "np", ".", "sqrt", "(", "np", ".", "exp", "(", "log_variance", ")", ")", "\n", "\n", "", "if", "log_objective", ":", "\n", "        ", "feval", "=", "np", ".", "exp", "(", "feval", ")", "\n", "\n", "", "Ht", "=", "np", ".", "repeat", "(", "task_feature_cost", "[", "None", ",", ":", "]", ",", "config", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "x", "=", "np", ".", "concatenate", "(", "(", "config", ",", "Ht", ")", ",", "axis", "=", "1", ")", "\n", "x_norm", "=", "torch", ".", "from_numpy", "(", "(", "x", "-", "x_mean_cost", ")", "/", "x_std_cost", ")", ".", "float", "(", ")", "\n", "output", "=", "model_cost", ".", "forward", "(", "x_norm", ")", ".", "data", ".", "numpy", "(", ")", "\n", "\n", "log_mean", "=", "output", "[", ":", ",", "0", "]", "\n", "log_log_variance", "=", "output", "[", ":", ",", "1", "]", "\n", "if", "y_mean_cost", "is", "not", "None", "or", "y_std_cost", "is", "not", "None", ":", "\n", "        ", "log_mean", "=", "log_mean", "*", "y_std_cost", "+", "y_mean_cost", "\n", "log_log_variance", "*=", "y_std_cost", "**", "2", "\n", "\n", "", "log_cost", "=", "log_mean", "\n", "if", "with_noise", ":", "\n", "        ", "log_cost", "+=", "np", ".", "random", ".", "randn", "(", ")", "*", "np", ".", "sqrt", "(", "np", ".", "exp", "(", "log_log_variance", ")", ")", "\n", "\n", "", "return", "feval", "[", ":", ",", "None", "]", ",", "np", ".", "exp", "(", "log_cost", ")", "[", ":", ",", "None", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.meta_fcnet.meta_fcnet": [[17, 88], ["emukit.core.ParameterSpace", "pickle.load", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture().float", "get_default_architecture().float.load_state_dict", "pickle.load", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture().float", "get_default_architecture().float.load_state_dict", "functools.partial", "open", "open", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.architecture.get_default_architecture", "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.architecture.get_default_architecture"], ["def", "meta_fcnet", "(", "fname_objective", ":", "str", ",", "fname_cost", ":", "str", ",", "noise", ":", "bool", "=", "True", ")", "->", "Tuple", "[", "UserFunctionWrapper", ",", "ParameterSpace", "]", ":", "\n", "    ", "\"\"\"\n    Interface to the Meta-FCNet benchmark which imitates the hyperparameter optimization of a\n    fully connected neural network on OpenML like classification datasets.\n    Offline generated function samples can be download here:\n\n    http://www.ml4aad.org/wp-content/uploads/2019/05/profet_data.tar.gz\n\n    NOTE: make sure that the index for the objective function and the cost function match,\n    e.g for sample_objective_i.pkl and sample_cost_i.pkl the index i should be the same.\n    Each of those files contain the parameters of a neural network which represents a single function sample and\n    some additional information, such as the mean and variance of the input normalization.\n\n    For further information about Profet and the generated meta-surrogate benchmarks see:\n\n    Meta-Surrogate Benchmarking for Hyperparameter Optimization\n    A. Klein and Z. Dai and F. Hutter and N. Lawrence and J. Gonzalez\n    arXiv:1905.12982 [cs.LG] (2019)\n\n    :param fname_objective: filename for the objective function\n    :param fname_cost: filename for the cost function\n    :param noise: determines whether to add noise on the function value or not\n    :return: Tuple of user function object and parameter space\n    \"\"\"", "\n", "parameter_space", "=", "ParameterSpace", "(", "\n", "[", "\n", "ContinuousParameter", "(", "\"lr\"", ",", "0", ",", "1", ")", ",", "# original space [1e-6, 1e-1]", "\n", "ContinuousParameter", "(", "\"batch_size\"", ",", "0", ",", "1", ")", ",", "# original space [8, 128]", "\n", "ContinuousParameter", "(", "\"n_units_1\"", ",", "0", ",", "1", ")", ",", "# original space [16, 512]", "\n", "ContinuousParameter", "(", "\"n_units_2\"", ",", "0", ",", "1", ")", ",", "# original space [16, 512]", "\n", "ContinuousParameter", "(", "\"dropout_1\"", ",", "0", ",", "1", ")", ",", "# original space [0, 0.99]", "\n", "ContinuousParameter", "(", "\"dropout_2\"", ",", "0", ",", "1", ")", ",", "# original space [0, 0.99]", "\n", "]", "\n", ")", "\n", "data", "=", "pickle", ".", "load", "(", "open", "(", "fname_objective", ",", "\"rb\"", ")", ")", "\n", "\n", "x_mean_objective", "=", "data", "[", "\"x_mean\"", "]", "\n", "x_std_objective", "=", "data", "[", "\"x_std\"", "]", "\n", "task_feature_objective", "=", "data", "[", "\"task_feature\"", "]", "\n", "objective", "=", "get_default_architecture", "(", "x_mean_objective", ".", "shape", "[", "0", "]", ",", "classification", "=", "True", ")", ".", "float", "(", ")", "\n", "objective", ".", "load_state_dict", "(", "data", "[", "\"state_dict\"", "]", ")", "\n", "\n", "data", "=", "pickle", ".", "load", "(", "open", "(", "fname_cost", ",", "\"rb\"", ")", ")", "\n", "\n", "x_mean_cost", "=", "data", "[", "\"x_mean\"", "]", "\n", "x_std_cost", "=", "data", "[", "\"x_std\"", "]", "\n", "y_mean_cost", "=", "data", "[", "\"y_mean\"", "]", "\n", "y_std_cost", "=", "data", "[", "\"y_std\"", "]", "\n", "task_feature_cost", "=", "data", "[", "\"task_feature\"", "]", "\n", "cost", "=", "get_default_architecture", "(", "x_mean_cost", ".", "shape", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "cost", ".", "load_state_dict", "(", "data", "[", "\"state_dict\"", "]", ")", "\n", "\n", "f", "=", "partial", "(", "\n", "objective_function", ",", "\n", "model_objective", "=", "objective", ",", "\n", "model_cost", "=", "cost", ",", "\n", "task_feature_objective", "=", "task_feature_objective", ",", "\n", "task_feature_cost", "=", "task_feature_cost", ",", "\n", "x_mean_objective", "=", "x_mean_objective", ",", "\n", "x_std_objective", "=", "x_std_objective", ",", "\n", "x_mean_cost", "=", "x_mean_cost", ",", "\n", "x_std_cost", "=", "x_std_cost", ",", "\n", "y_mean_objective", "=", "None", ",", "\n", "y_std_objective", "=", "None", ",", "\n", "y_mean_cost", "=", "y_mean_cost", ",", "\n", "y_std_cost", "=", "y_std_cost", ",", "\n", "log_objective", "=", "False", ",", "\n", "with_noise", "=", "noise", ",", "\n", ")", "\n", "\n", "return", "f", ",", "parameter_space", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.architecture.get_default_architecture": [[13, 47], ["Architecture", "super().__init__", "nn.Linear", "nn.Linear", "nn.Linear", "AppendLayer", "torch.tanh", "torch.tanh", "architecture..fc3", "architecture..sigma_layer", "architecture..fc1", "architecture..fc2", "torch.sigmoid"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["", "def", "get_default_architecture", "(", "\n", "input_dimensionality", ":", "int", ",", "classification", ":", "bool", "=", "False", ",", "n_hidden", ":", "int", "=", "500", "\n", ")", "->", "torch", ".", "nn", ".", "Module", ":", "\n", "    ", "\"\"\"\n    Defines the architecture that is used for Meta-Surrogate benchmarks.\n    In the case of emulating a classification benchmark, we pass the mean prediction through a sigmoid\n    to make sure that the mean prediction values are in [0, 1].\n\n    :param input_dimensionality: dimensionality of the benchmark\n    :param classification: defined whether we emulate a classification benchmark\n    :param n_hidden: number of units in the hidden layer\n    :return: nn.Module\n    \"\"\"", "\n", "\n", "class", "Architecture", "(", "nn", ".", "Module", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "n_inputs", ",", "n_hidden", "=", "500", ",", "classification", "=", "False", ")", ":", "\n", "            ", "super", "(", "Architecture", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "n_inputs", ",", "n_hidden", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_hidden", ")", "\n", "self", ".", "fc3", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "1", ")", "\n", "self", ".", "sigma_layer", "=", "AppendLayer", "(", "noise", "=", "1e-3", ")", "\n", "self", ".", "classification", "=", "classification", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "            ", "x", "=", "torch", ".", "tanh", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "x", "=", "torch", ".", "tanh", "(", "self", ".", "fc2", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "fc3", "(", "x", ")", "\n", "if", "self", ".", "classification", ":", "\n", "                ", "mean", "=", "torch", ".", "sigmoid", "(", "x", ")", "\n", "", "else", ":", "\n", "                ", "mean", "=", "x", "\n", "", "return", "self", ".", "sigma_layer", "(", "mean", ")", "\n", "\n", "", "", "return", "Architecture", "(", "n_inputs", "=", "input_dimensionality", ",", "n_hidden", "=", "n_hidden", ",", "classification", "=", "classification", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.meta_svm.meta_svm": [[17, 84], ["emukit.core.ParameterSpace", "pickle.load", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture().float", "get_default_architecture().float.load_state_dict", "pickle.load", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture().float", "get_default_architecture().float.load_state_dict", "functools.partial", "open", "open", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.architecture.get_default_architecture", "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.architecture.get_default_architecture"], ["def", "meta_svm", "(", "fname_objective", ":", "str", ",", "fname_cost", ":", "str", ",", "noise", ":", "bool", "=", "True", ")", "->", "Tuple", "[", "UserFunctionWrapper", ",", "ParameterSpace", "]", ":", "\n", "    ", "\"\"\"\n    Interface to the Meta-SVM benchmark which imitates the hyperparameter optimization of a\n    support vector machine on OpenML like classification datasets.\n    Offline generated function samples can be download here:\n\n    http://www.ml4aad.org/wp-content/uploads/2019/05/profet_data.tar.gz\n\n    NOTE: make sure that the index for the objective function and the cost function match,\n    e.g for sample_objective_i.pkl and sample_cost_i.pkl the index i should be the same.\n    Each of those files contain the parameters of a neural network which represents a single function sample and\n    some additional information, such as the mean and variance of the input normalization.\n\n    For further information about Profet and the generated meta-surrogate benchmarks see:\n\n    Meta-Surrogate Benchmarking for Hyperparameter Optimization\n    A. Klein and Z. Dai and F. Hutter and N. Lawrence and J. Gonzalez\n    arXiv:1905.12982 [cs.LG] (2019)\n\n    :param fname_objective: filename for the objective function\n    :param fname_cost: filename for the cost function\n    :param noise: determines whether to add noise on the function value or not\n    :return: Tuple of user function object and parameter space\n    \"\"\"", "\n", "parameter_space", "=", "ParameterSpace", "(", "\n", "[", "\n", "ContinuousParameter", "(", "\"log_C\"", ",", "0", ",", "1", ")", ",", "# scaled to [0, 1], original space was in [-10, 10]", "\n", "ContinuousParameter", "(", "\"log_gamma\"", ",", "0", ",", "1", ")", ",", "\n", "]", "\n", ")", "# scaled to [0, 1] original space was in [-10, 10]", "\n", "data", "=", "pickle", ".", "load", "(", "open", "(", "fname_objective", ",", "\"rb\"", ")", ")", "\n", "\n", "x_mean_objective", "=", "data", "[", "\"x_mean\"", "]", "\n", "x_std_objective", "=", "data", "[", "\"x_std\"", "]", "\n", "task_feature_objective", "=", "data", "[", "\"task_feature\"", "]", "\n", "objective", "=", "get_default_architecture", "(", "x_mean_objective", ".", "shape", "[", "0", "]", ",", "classification", "=", "True", ")", ".", "float", "(", ")", "\n", "objective", ".", "load_state_dict", "(", "data", "[", "\"state_dict\"", "]", ")", "\n", "\n", "data", "=", "pickle", ".", "load", "(", "open", "(", "fname_cost", ",", "\"rb\"", ")", ")", "\n", "\n", "x_mean_cost", "=", "data", "[", "\"x_mean\"", "]", "\n", "x_std_cost", "=", "data", "[", "\"x_std\"", "]", "\n", "y_mean_cost", "=", "data", "[", "\"y_mean\"", "]", "\n", "y_std_cost", "=", "data", "[", "\"y_std\"", "]", "\n", "task_feature_cost", "=", "data", "[", "\"task_feature\"", "]", "\n", "cost", "=", "get_default_architecture", "(", "x_mean_cost", ".", "shape", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "cost", ".", "load_state_dict", "(", "data", "[", "\"state_dict\"", "]", ")", "\n", "\n", "f", "=", "partial", "(", "\n", "objective_function", ",", "\n", "model_objective", "=", "objective", ",", "\n", "model_cost", "=", "cost", ",", "\n", "task_feature_objective", "=", "task_feature_objective", ",", "\n", "task_feature_cost", "=", "task_feature_cost", ",", "\n", "x_mean_objective", "=", "x_mean_objective", ",", "\n", "x_std_objective", "=", "x_std_objective", ",", "\n", "x_mean_cost", "=", "x_mean_cost", ",", "\n", "x_std_cost", "=", "x_std_cost", ",", "\n", "y_mean_objective", "=", "None", ",", "\n", "y_std_objective", "=", "None", ",", "\n", "y_mean_cost", "=", "y_mean_cost", ",", "\n", "y_std_cost", "=", "y_std_cost", ",", "\n", "log_objective", "=", "False", ",", "\n", "with_noise", "=", "noise", ",", "\n", ")", "\n", "\n", "return", "f", ",", "parameter_space", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.meta_xgboost.meta_xgboost": [[18, 96], ["emukit.core.ParameterSpace", "pickle.load", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture().float", "get_default_architecture().float.load_state_dict", "pickle.load", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture().float", "get_default_architecture().float.load_state_dict", "functools.partial", "open", "open", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture", "emukit.examples.profet.meta_benchmarks.architecture.get_default_architecture"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.architecture.get_default_architecture", "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.architecture.get_default_architecture"], ["def", "meta_xgboost", "(", "\n", "fname_objective", ":", "str", ",", "fname_cost", ":", "str", ",", "noise", ":", "bool", "=", "True", "\n", ")", "->", "Tuple", "[", "UserFunctionWrapper", ",", "ParameterSpace", "]", ":", "\n", "    ", "\"\"\"\n    Interface to the Meta-XGBoost benchmark which imitates the hyperparameter optimization of\n    XGBoost on UCI like regression datasets.\n    Offline generated function samples can be download here:\n\n    http://www.ml4aad.org/wp-content/uploads/2019/05/profet_data.tar.gz\n\n    NOTE: make sure that the index for the objective function and the cost function match,\n    e.g for sample_objective_i.pkl and sample_cost_i.pkl the index i should be the same.\n    Each of those files contain the parameters of a neural network which represents a single function sample and\n    some additional information, such as the mean and variance of the input normalization.\n\n    For further information about Profet and the generated meta-surrogate benchmarks see:\n\n    Meta-Surrogate Benchmarking for Hyperparameter Optimization\n    A. Klein and Z. Dai and F. Hutter and N. Lawrence and J. Gonzalez\n    arXiv:1905.12982 [cs.LG] (2019)\n\n    :param fname_objective: filename for the objective function\n    :param fname_cost: filename for the cost function\n    :param noise: determines whether to add noise on the function value or not\n    :return: Tuple of user function object and parameter space\n    \"\"\"", "\n", "parameter_space", "=", "ParameterSpace", "(", "\n", "[", "\n", "ContinuousParameter", "(", "\"learning_rate\"", ",", "0", ",", "1", ")", ",", "# original space was in [1e-6, 1e-1]", "\n", "ContinuousParameter", "(", "\"gamma\"", ",", "0", ",", "1", ")", ",", "# original space was in [0, 2]", "\n", "ContinuousParameter", "(", "\"reg_alpha\"", ",", "0", ",", "1", ")", ",", "# original space was in [1e-5, 1e3]", "\n", "ContinuousParameter", "(", "\"reg_lambda\"", ",", "0", ",", "1", ")", ",", "# original space was in [1e-4, 1e3]", "\n", "ContinuousParameter", "(", "\"n_estimators\"", ",", "0", ",", "1", ")", ",", "# original space was in [10, 500]", "\n", "ContinuousParameter", "(", "\"subsample\"", ",", "0", ",", "1", ")", ",", "# original space was in [1e-1, 1]", "\n", "ContinuousParameter", "(", "\"max_depth\"", ",", "0", ",", "1", ")", ",", "# original space was in [1, 15]", "\n", "ContinuousParameter", "(", "\"min_child_weight\"", ",", "0", ",", "1", ")", ",", "\n", "]", "\n", ")", "# original space was in [0, 20]", "\n", "\n", "data", "=", "pickle", ".", "load", "(", "open", "(", "fname_objective", ",", "\"rb\"", ")", ")", "\n", "\n", "x_mean_objective", "=", "data", "[", "\"x_mean\"", "]", "\n", "x_std_objective", "=", "data", "[", "\"x_std\"", "]", "\n", "y_mean_objective", "=", "data", "[", "\"y_mean\"", "]", "\n", "y_std_objective", "=", "data", "[", "\"y_std\"", "]", "\n", "task_feature_objective", "=", "data", "[", "\"task_feature\"", "]", "\n", "objective", "=", "get_default_architecture", "(", "x_mean_objective", ".", "shape", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "objective", ".", "load_state_dict", "(", "data", "[", "\"state_dict\"", "]", ")", "\n", "\n", "data", "=", "pickle", ".", "load", "(", "open", "(", "fname_cost", ",", "\"rb\"", ")", ")", "\n", "\n", "x_mean_cost", "=", "data", "[", "\"x_mean\"", "]", "\n", "x_std_cost", "=", "data", "[", "\"x_std\"", "]", "\n", "y_mean_cost", "=", "data", "[", "\"y_mean\"", "]", "\n", "y_std_cost", "=", "data", "[", "\"y_std\"", "]", "\n", "task_feature_cost", "=", "data", "[", "\"task_feature\"", "]", "\n", "cost", "=", "get_default_architecture", "(", "x_mean_cost", ".", "shape", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "cost", ".", "load_state_dict", "(", "data", "[", "\"state_dict\"", "]", ")", "\n", "\n", "f", "=", "partial", "(", "\n", "objective_function", ",", "\n", "model_objective", "=", "objective", ",", "\n", "model_cost", "=", "cost", ",", "\n", "task_feature_objective", "=", "task_feature_objective", ",", "\n", "task_feature_cost", "=", "task_feature_cost", ",", "\n", "x_mean_objective", "=", "x_mean_objective", ",", "\n", "x_std_objective", "=", "x_std_objective", ",", "\n", "x_mean_cost", "=", "x_mean_cost", ",", "\n", "x_std_cost", "=", "x_std_cost", ",", "\n", "y_mean_objective", "=", "y_mean_objective", ",", "\n", "y_std_objective", "=", "y_std_objective", ",", "\n", "y_mean_cost", "=", "y_mean_cost", ",", "\n", "y_std_cost", "=", "y_std_cost", ",", "\n", "log_objective", "=", "True", ",", "\n", "with_noise", "=", "noise", ",", "\n", ")", "\n", "\n", "return", "f", ",", "parameter_space", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.meta_forrester.get_architecture_forrester": [[22, 37], ["Architecture", "super().__init__", "nn.Linear", "nn.Linear", "AppendLayer", "torch.tanh", "meta_forrester..fc2", "meta_forrester..sigma_layer", "meta_forrester..fc1"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "get_architecture_forrester", "(", "input_dimensionality", ":", "int", ")", "->", "torch", ".", "nn", ".", "Module", ":", "\n", "    ", "class", "Architecture", "(", "nn", ".", "Module", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "n_inputs", ",", "n_hidden", "=", "100", ")", ":", "\n", "            ", "super", "(", "Architecture", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "n_inputs", ",", "n_hidden", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "2", ")", "\n", "self", ".", "sigma_layer", "=", "AppendLayer", "(", "noise", "=", "1e-3", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "            ", "x", "=", "torch", ".", "tanh", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "mean", "=", "x", "[", ":", ",", "None", ",", "0", "]", "\n", "return", "self", ".", "sigma_layer", "(", "mean", ")", "\n", "\n", "", "", "return", "Architecture", "(", "n_inputs", "=", "input_dimensionality", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.meta_forrester.meta_forrester": [[39, 82], ["emukit.core.ParameterSpace", "pickle.load", "get_architecture_forrester().float", "get_architecture_forrester().float.load_state_dict", "functools.partial", "open", "numpy.repeat", "numpy.concatenate", "torch.from_numpy().float", "get_architecture_forrester().float.forward().data.numpy", "emukit.core.ContinuousParameter", "meta_forrester.get_architecture_forrester", "torch.from_numpy", "get_architecture_forrester().float.forward"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.meta_benchmarks.meta_forrester.get_architecture_forrester"], ["", "def", "meta_forrester", "(", "fname_objective", ":", "str", ")", "->", "Tuple", "[", "UserFunctionWrapper", ",", "ParameterSpace", "]", ":", "\n", "    ", "\"\"\"\n    Interface to the Meta-Forrester benchmark.\n\n    Offline generated function samples can be download here:\n\n    http://www.ml4aad.org/wp-content/uploads/2019/05/profet_data.tar.gz\n\n    For further information about Profet and the generated meta-surrogate benchmarks see:\n\n    Meta-Surrogate Benchmarking for Hyperparameter Optimization\n    A. Klein and Z. Dai and F. Hutter and N. Lawrence and J. Gonzalez\n    arXiv:1905.12982 [cs.LG] (2019)\n\n    :param fname_objective: filename for the objective function\n    :return: Tuple of user function object and parameter space\n    \"\"\"", "\n", "parameter_space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "data", "=", "pickle", ".", "load", "(", "open", "(", "fname_objective", ",", "\"rb\"", ")", ")", "\n", "x_mean_objective", "=", "data", "[", "\"x_mean\"", "]", "\n", "x_std_objective", "=", "data", "[", "\"x_std\"", "]", "\n", "y_mean_objective", "=", "data", "[", "\"y_mean\"", "]", "\n", "y_std_objective", "=", "data", "[", "\"y_std\"", "]", "\n", "task_feature_objective", "=", "data", "[", "\"task_feature\"", "]", "\n", "\n", "objective", "=", "get_architecture_forrester", "(", "x_mean_objective", ".", "shape", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "objective", ".", "load_state_dict", "(", "data", "[", "\"state_dict\"", "]", ")", "\n", "\n", "def", "objective_function", "(", "config", ")", ":", "\n", "\n", "        ", "Ht", "=", "np", ".", "repeat", "(", "task_feature_objective", "[", "None", ",", ":", "]", ",", "config", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "x", "=", "np", ".", "concatenate", "(", "(", "config", ",", "Ht", ")", ",", "axis", "=", "1", ")", "\n", "x_norm", "=", "torch", ".", "from_numpy", "(", "(", "x", "-", "x_mean_objective", ")", "/", "x_std_objective", ")", ".", "float", "(", ")", "\n", "output", "=", "objective", ".", "forward", "(", "x_norm", ")", ".", "data", ".", "numpy", "(", ")", "\n", "mean", "=", "output", "[", ":", ",", "0", "]", "\n", "\n", "feval", "=", "mean", "*", "y_std_objective", "+", "y_mean_objective", "\n", "\n", "return", "feval", "[", ":", ",", "None", "]", "\n", "\n", "", "f", "=", "partial", "(", "objective_function", ")", "\n", "\n", "return", "f", ",", "parameter_space", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.samplers.mcmc_sampler.McmcSampler.__init__": [[9, 17], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "space", ")", ":", "\n", "        ", "\"\"\"\n        Creates an instance of the sampler.\n\n        Parameters:\n            space - variable space\n        \"\"\"", "\n", "self", ".", "space", "=", "space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.samplers.mcmc_sampler.McmcSampler.get_samples": [[18, 31], ["None"], "methods", ["None"], ["", "def", "get_samples", "(", "self", ",", "n_samples", ",", "log_p_function", ",", "burn_in_steps", "=", "50", ")", ":", "\n", "        ", "\"\"\"\n        Generates samples.\n\n        Parameters:\n            n_samples - number of samples to generate\n            log_p_function - a function that returns log density for a specific sample\n            burn_in_steps - number of burn-in steps for sampling\n\n        Returns a tuple of two lists: (samples, log_p_function values for samples)\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.samplers.mcmc_sampler.AffineInvariantEnsembleSampler.__init__": [[34, 42], ["mcmc_sampler.McmcSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "space", ")", ":", "\n", "        ", "\"\"\"\n        Creates an instance of the affine invariant ensemble sampler.\n\n        Parameters:\n            space - variable space\n        \"\"\"", "\n", "super", "(", "AffineInvariantEnsembleSampler", ",", "self", ")", ".", "__init__", "(", "space", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.samplers.mcmc_sampler.AffineInvariantEnsembleSampler.get_samples": [[43, 73], ["mcmc_sampler.AffineInvariantEnsembleSampler.space.sample_uniform", "emcee.EnsembleSampler", "list", "list", "samples_log.reshape.reshape.reshape", "emcee.EnsembleSampler.run_mcmc", "emcee.EnsembleSampler.run_mcmc", "len", "samples.reshape.reshape.reshape"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform"], ["", "def", "get_samples", "(", "self", ",", "n_samples", ",", "log_p_function", ",", "burn_in_steps", "=", "50", ",", "n_steps", "=", "100", ")", ":", "\n", "        ", "\"\"\"\n        Generates samples.\n\n        Parameters:\n            n_samples - number of samples to generate\n            log_p_function - a function that returns log density for a specific sample\n            burn_in_steps - number of burn-in steps for sampling\n\n        Returns a tuple of two array: (samples, log_p_function values for samples)\n        \"\"\"", "\n", "X_init", "=", "self", ".", "space", ".", "sample_uniform", "(", "n_samples", ")", "\n", "sampler", "=", "emcee", ".", "EnsembleSampler", "(", "n_samples", ",", "X_init", ".", "shape", "[", "1", "]", ",", "log_p_function", ")", "\n", "\n", "# Burn-In", "\n", "state", "=", "list", "(", "sampler", ".", "run_mcmc", "(", "X_init", ",", "burn_in_steps", ")", ")", "# compatible with both emcee 2 and 3", "\n", "samples", "=", "state", "[", "0", "]", "\n", "samples_log", "=", "state", "[", "1", "]", "\n", "\n", "# MCMC Sampling", "\n", "state", "=", "list", "(", "sampler", ".", "run_mcmc", "(", "samples", ",", "n_steps", ")", ")", "\n", "samples", "=", "state", "[", "0", "]", "\n", "samples_log", "=", "state", "[", "1", "]", "\n", "\n", "# make sure we have an array of shape (n samples, space input dim)", "\n", "if", "len", "(", "samples", ".", "shape", ")", "==", "1", ":", "\n", "            ", "samples", "=", "samples", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "", "samples_log", "=", "samples_log", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "return", "samples", ",", "samples_log", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmark_result.test_benchmark_result_initialization": [[8, 17], ["emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array"], ["def", "test_benchmark_result_initialization", "(", ")", ":", "\n", "    ", "br", "=", "BenchmarkResult", "(", "[", "\"loop1\"", ",", "\"loop2\"", "]", ",", "5", ",", "[", "\"mae\"", ",", "\"mse\"", "]", ")", "\n", "\n", "for", "loop", "in", "[", "\"loop1\"", ",", "\"loop2\"", "]", ":", "\n", "        ", "for", "metric", "in", "[", "\"mae\"", ",", "\"mse\"", "]", ":", "\n", "            ", "metric_data", "=", "br", ".", "extract_metric_as_array", "(", "loop", ",", "metric", ")", "\n", "\n", "assert", "metric_data", ".", "size", "==", "0", "\n", "assert", "metric_data", ".", "shape", "==", "(", "5", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmark_result.test_benchmark_result_extract_invalid_names": [[19, 27], ["emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult", "pytest.raises", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array", "pytest.raises", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array"], ["", "", "", "def", "test_benchmark_result_extract_invalid_names", "(", ")", ":", "\n", "    ", "br", "=", "BenchmarkResult", "(", "[", "\"loop1\"", ",", "\"loop2\"", "]", ",", "5", ",", "[", "\"mae\"", ",", "\"mse\"", "]", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "        ", "br", ".", "extract_metric_as_array", "(", "\"invalid loop\"", ",", "\"mse\"", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "        ", "br", ".", "extract_metric_as_array", "(", "\"loop1\"", ",", "\"invalid metric\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmark_result.test_benchmark_result_add_data": [[29, 44], ["emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array", "numpy.testing.assert_array_equal", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array"], ["", "", "def", "test_benchmark_result_add_data", "(", ")", ":", "\n", "    ", "br", "=", "BenchmarkResult", "(", "[", "\"loop1\"", "]", ",", "2", ",", "[", "\"mae\"", ",", "\"mse\"", "]", ")", "\n", "\n", "br", ".", "add_results", "(", "\"loop1\"", ",", "0", ",", "\"mae\"", ",", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop1\"", ",", "0", ",", "\"mse\"", ",", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop1\"", ",", "1", ",", "\"mae\"", ",", "np", ".", "array", "(", "[", "4", ",", "5", ",", "6", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop1\"", ",", "1", ",", "\"mse\"", ",", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", ")", "\n", "\n", "mae_data", "=", "br", ".", "extract_metric_as_array", "(", "\"loop1\"", ",", "\"mae\"", ")", "\n", "\n", "assert_array_equal", "(", "mae_data", ",", "np", ".", "array", "(", "[", "[", "1", ",", "2", ",", "3", "]", ",", "[", "4", ",", "5", ",", "6", "]", "]", ")", ")", "\n", "\n", "mse_data", "=", "br", ".", "extract_metric_as_array", "(", "\"loop1\"", ",", "\"mse\"", ")", "\n", "\n", "assert_array_equal", "(", "mse_data", ",", "np", ".", "array", "(", "[", "[", "1", ",", "2", "]", ",", "[", "1", ",", "2", "]", "]", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_random_search.test_random_search": [[8, 16], ["numpy.random.seed", "emukit.test_functions.branin_function", "emukit.benchmarking.loop_benchmarking.random_search.RandomSearch", "emukit.benchmarking.loop_benchmarking.random_search.RandomSearch.run_loop", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin.branin_function", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["def", "test_random_search", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "branin_fcn", ",", "parameter_space", "=", "branin_function", "(", ")", "\n", "\n", "rs", "=", "RandomSearch", "(", "parameter_space", ")", "\n", "rs", ".", "run_loop", "(", "branin_fcn", ",", "5", ")", "\n", "\n", "assert", "len", "(", "rs", ".", "loop_state", ".", "Y", ")", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_random_search.test_random_search_with_init_data": [[18, 37], ["numpy.random.seed", "emukit.test_functions.branin_function", "emukit.core.loop.UserFunctionWrapper", "parameter_space.sample_uniform", "branin_fcn", "numpy.ones", "emukit.benchmarking.loop_benchmarking.random_search.RandomSearch", "emukit.benchmarking.loop_benchmarking.random_search.RandomSearch.run_loop", "len", "len", "len", "branin_fcn", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.branin.branin_function", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_random_search_with_init_data", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "branin_fcn", ",", "parameter_space", "=", "branin_function", "(", ")", "\n", "\n", "branin_fcn_with_cost", "=", "lambda", "x", ":", "(", "branin_fcn", "(", "x", ")", ",", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ")", "\n", "\n", "# Ensure function returns a value for cost", "\n", "wrapped_fcn", "=", "UserFunctionWrapper", "(", "branin_fcn_with_cost", ",", "extra_output_names", "=", "[", "\"cost\"", "]", ")", "\n", "\n", "x_init", "=", "parameter_space", ".", "sample_uniform", "(", "5", ")", "\n", "y_init", "=", "branin_fcn", "(", "x_init", ")", "\n", "cost_init", "=", "np", ".", "ones", "(", "[", "5", ",", "1", "]", ")", "\n", "\n", "rs", "=", "RandomSearch", "(", "parameter_space", ",", "x_init", "=", "x_init", ",", "y_init", "=", "y_init", ",", "cost_init", "=", "cost_init", ")", "\n", "rs", ".", "run_loop", "(", "wrapped_fcn", ",", "5", ")", "\n", "\n", "assert", "len", "(", "rs", ".", "loop_state", ".", "Y", ")", "==", "10", "\n", "assert", "len", "(", "rs", ".", "loop_state", ".", "X", ")", "==", "10", "\n", "assert", "len", "(", "rs", ".", "loop_state", ".", "cost", ")", "==", "10", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_metrics.test_mean_squared_error_metric": [[15, 33], ["numpy.random.rand", "numpy.random.rand", "mock.create_autospec", "mock.create_autospec", "mock.create_autospec", "emukit.core.loop.LoopState", "dict", "emukit.benchmarking.loop_benchmarking.metrics.MeanSquaredErrorMetric", "emukit.benchmarking.loop_benchmarking.metrics.MeanSquaredErrorMetric.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["def", "test_mean_squared_error_metric", "(", ")", ":", "\n", "    ", "x_test", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", "\n", "y_test", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", "\n", "\n", "mock_model", "=", "mock", ".", "create_autospec", "(", "IModel", ")", "\n", "mock_model", ".", "predict", ".", "return_value", "=", "(", "y_test", ",", "y_test", "*", "10", ")", "\n", "model_updater_mock", "=", "mock", ".", "create_autospec", "(", "ModelUpdater", ")", "\n", "model_updater_mock", ".", "model", "=", "mock_model", "\n", "mock_loop", "=", "mock", ".", "create_autospec", "(", "OuterLoop", ")", "\n", "mock_loop", ".", "model_updaters", "=", "[", "model_updater_mock", "]", "\n", "\n", "loop_state", "=", "LoopState", "(", "[", "]", ")", "\n", "loop_state", ".", "metrics", "=", "dict", "(", ")", "\n", "\n", "mse", "=", "MeanSquaredErrorMetric", "(", "x_test", ",", "y_test", ")", "\n", "metric_value", "=", "mse", ".", "evaluate", "(", "mock_loop", ",", "loop_state", ")", "\n", "\n", "assert", "metric_value", ".", "shape", "==", "(", "2", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_metrics.test_minimum_observed_value_metric": [[35, 53], ["numpy.random.rand", "numpy.random.rand", "mock.create_autospec", "mock.create_autospec", "mock.create_autospec", "emukit.core.loop.loop_state.create_loop_state", "dict", "emukit.benchmarking.loop_benchmarking.metrics.MinimumObservedValueMetric", "emukit.benchmarking.loop_benchmarking.metrics.MinimumObservedValueMetric.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_minimum_observed_value_metric", "(", ")", ":", "\n", "    ", "x_observations", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", "\n", "y_observations", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", "\n", "\n", "mock_model", "=", "mock", ".", "create_autospec", "(", "IModel", ")", "\n", "\n", "model_updater_mock", "=", "mock", ".", "create_autospec", "(", "ModelUpdater", ")", "\n", "model_updater_mock", ".", "model", "=", "mock_model", "\n", "mock_loop", "=", "mock", ".", "create_autospec", "(", "OuterLoop", ")", "\n", "mock_loop", ".", "model_updaters", "=", "[", "model_updater_mock", "]", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "x_observations", ",", "y_observations", ")", "\n", "loop_state", ".", "metrics", "=", "dict", "(", ")", "\n", "\n", "metric", "=", "MinimumObservedValueMetric", "(", ")", "\n", "metric_value", "=", "metric", ".", "evaluate", "(", "mock_loop", ",", "loop_state", ")", "\n", "\n", "assert", "metric_value", ".", "shape", "==", "(", "2", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_metrics.test_time_metric": [[55, 75], ["numpy.random.rand", "numpy.random.rand", "mock.create_autospec", "mock.create_autospec", "mock.create_autospec", "emukit.core.loop.loop_state.create_loop_state", "dict", "emukit.benchmarking.loop_benchmarking.metrics.TimeMetric", "emukit.benchmarking.loop_benchmarking.metrics.TimeMetric.reset", "emukit.benchmarking.loop_benchmarking.metrics.TimeMetric.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_time_metric", "(", ")", ":", "\n", "    ", "x_observations", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", "\n", "y_observations", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", "\n", "\n", "mock_model", "=", "mock", ".", "create_autospec", "(", "IModel", ")", "\n", "\n", "model_updater_mock", "=", "mock", ".", "create_autospec", "(", "ModelUpdater", ")", "\n", "model_updater_mock", ".", "model", "=", "mock_model", "\n", "mock_loop", "=", "mock", ".", "create_autospec", "(", "OuterLoop", ")", "\n", "mock_loop", ".", "model_updater", "=", "model_updater_mock", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "x_observations", ",", "y_observations", ")", "\n", "loop_state", ".", "metrics", "=", "dict", "(", ")", "\n", "\n", "name", "=", "\"time\"", "\n", "metric", "=", "TimeMetric", "(", "name", ")", "\n", "metric", ".", "reset", "(", ")", "\n", "metric_value", "=", "metric", ".", "evaluate", "(", "mock_loop", ",", "loop_state", ")", "\n", "\n", "assert", "metric_value", ".", "shape", "==", "(", "1", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_metrics.test_cumulative_costs": [[77, 98], ["numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "mock.create_autospec", "mock.create_autospec", "mock.create_autospec", "emukit.core.loop.loop_state.create_loop_state", "dict", "emukit.benchmarking.loop_benchmarking.metrics.CumulativeCostMetric", "emukit.benchmarking.loop_benchmarking.metrics.CumulativeCostMetric.reset", "emukit.benchmarking.loop_benchmarking.metrics.CumulativeCostMetric.evaluate", "numpy.cumsum"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_cumulative_costs", "(", ")", ":", "\n", "    ", "x_observations", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", "\n", "y_observations", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", "\n", "c_observations", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "1", ")", "\n", "mock_model", "=", "mock", ".", "create_autospec", "(", "IModel", ")", "\n", "\n", "model_updater_mock", "=", "mock", ".", "create_autospec", "(", "ModelUpdater", ")", "\n", "model_updater_mock", ".", "model", "=", "mock_model", "\n", "mock_loop", "=", "mock", ".", "create_autospec", "(", "OuterLoop", ")", "\n", "mock_loop", ".", "model_updater", "=", "model_updater_mock", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "x_observations", ",", "y_observations", ",", "cost", "=", "c_observations", ")", "\n", "loop_state", ".", "metrics", "=", "dict", "(", ")", "\n", "\n", "name", "=", "\"cost\"", "\n", "metric", "=", "CumulativeCostMetric", "(", "name", ")", "\n", "metric", ".", "reset", "(", ")", "\n", "metric_value", "=", "metric", ".", "evaluate", "(", "mock_loop", ",", "loop_state", ")", "\n", "\n", "assert", "metric_value", "==", "np", ".", "cumsum", "(", "c_observations", ")", "[", "-", "1", "]", "\n", "assert", "metric_value", ".", "shape", "==", "(", "1", ",", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmark_plot.benchmark_result": [[8, 23], ["emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "emukit.benchmarking.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results"], ["@", "pytest", ".", "fixture", "\n", "def", "benchmark_result", "(", ")", ":", "\n", "    ", "br", "=", "BenchmarkResult", "(", "[", "\"loop1\"", ",", "\"loop2\"", "]", ",", "2", ",", "[", "\"mae\"", ",", "\"mse\"", "]", ")", "\n", "\n", "br", ".", "add_results", "(", "\"loop1\"", ",", "0", ",", "\"mae\"", ",", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop1\"", ",", "0", ",", "\"mse\"", ",", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop1\"", ",", "1", ",", "\"mae\"", ",", "np", ".", "array", "(", "[", "4", ",", "5", ",", "6", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop1\"", ",", "1", ",", "\"mse\"", ",", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", ")", "\n", "\n", "br", ".", "add_results", "(", "\"loop2\"", ",", "0", ",", "\"mae\"", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop2\"", ",", "0", ",", "\"mse\"", ",", "np", ".", "array", "(", "[", "2", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop2\"", ",", "1", ",", "\"mae\"", ",", "np", ".", "array", "(", "[", "4", "]", ")", ")", "\n", "br", ".", "add_results", "(", "\"loop2\"", ",", "1", ",", "\"mse\"", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", "\n", "\n", "return", "br", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmark_plot.test_benchmark_plot_metrics_to_plot": [[25, 36], ["emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot", "emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot", "pytest.raises", "emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot"], "function", ["None"], ["", "def", "test_benchmark_plot_metrics_to_plot", "(", "benchmark_result", ")", ":", "\n", "    ", "bp", "=", "BenchmarkPlot", "(", "benchmark_result", ")", "\n", "\n", "assert", "bp", ".", "metrics_to_plot", "==", "benchmark_result", ".", "metric_names", "\n", "\n", "bp", "=", "BenchmarkPlot", "(", "benchmark_result", ",", "metrics_to_plot", "=", "[", "\"mae\"", "]", ")", "\n", "\n", "assert", "bp", ".", "metrics_to_plot", "==", "[", "\"mae\"", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "BenchmarkPlot", "(", "benchmark_result", ",", "metrics_to_plot", "=", "[", "\"invalid metric\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmark_plot.test_benchmark_plot_x_axis_metric_name": [[38, 53], ["emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot", "emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot", "pytest.raises", "emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot"], "function", ["None"], ["", "", "def", "test_benchmark_plot_x_axis_metric_name", "(", "benchmark_result", ")", ":", "\n", "    ", "bp", "=", "BenchmarkPlot", "(", "benchmark_result", ")", "\n", "\n", "assert", "bp", ".", "x_label", "==", "\"Iteration\"", "\n", "assert", "bp", ".", "x_axis", "is", "None", "\n", "assert", "bp", ".", "metrics_to_plot", "==", "benchmark_result", ".", "metric_names", "\n", "\n", "bp", "=", "BenchmarkPlot", "(", "benchmark_result", ",", "x_axis_metric_name", "=", "\"mae\"", ")", "\n", "\n", "assert", "bp", ".", "x_label", "==", "\"mae\"", "\n", "assert", "bp", ".", "x_axis", "==", "\"mae\"", "\n", "assert", "\"mae\"", "not", "in", "bp", ".", "metrics_to_plot", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "BenchmarkPlot", "(", "benchmark_result", ",", "x_axis_metric_name", "=", "\"invalid metric\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmark_plot.test_benchmark_plot_make_plot": [[55, 61], ["emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot", "emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot.make_plot", "len", "len", "emukit.benchmarking.loop_benchmarking.benchmark_plot.BenchmarkPlot.fig_handle.get_axes"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_plot.BenchmarkPlot.make_plot"], ["", "", "def", "test_benchmark_plot_make_plot", "(", "benchmark_result", ")", ":", "\n", "    ", "bp", "=", "BenchmarkPlot", "(", "benchmark_result", ")", "\n", "bp", ".", "make_plot", "(", ")", "\n", "\n", "assert", "bp", ".", "fig_handle", "is", "not", "None", "\n", "assert", "len", "(", "bp", ".", "fig_handle", ".", "get_axes", "(", ")", ")", "==", "len", "(", "benchmark_result", ".", "metric_names", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmarker.loops": [[13, 23], ["emukit.core.ParameterSpace", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "emukit.bayesian_optimization.loops.BayesianOptimizationLoop", "emukit.core.ContinuousParameter"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "loops", "(", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "\n", "def", "make_loop", "(", "loop_state", ")", ":", "\n", "        ", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "loop_state", ".", "X", ",", "loop_state", ".", "Y", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "return", "BayesianOptimizationLoop", "(", "space", ",", "model", ")", "\n", "\n", "", "return", "[", "(", "\"GP\"", ",", "make_loop", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmarker.test_benchmarker_runs": [[25, 36], ["emukit.test_functions.forrester_function", "numpy.random.rand", "emukit.benchmarking.loop_benchmarking.benchmarker.Benchmarker", "emukit.benchmarking.loop_benchmarking.benchmarker.Benchmarker.run_benchmark", "emukit.benchmarking.loop_benchmarking.metrics.MinimumObservedValueMetric", "emukit.benchmarking.loop_benchmarking.metrics.TimeMetric", "emukit.benchmarking.loop_benchmarking.metrics.MeanSquaredErrorMetric", "test_fcn"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_function", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker.Benchmarker.run_benchmark"], ["", "def", "test_benchmarker_runs", "(", "loops", ")", ":", "\n", "    ", "test_fcn", ",", "parameter_space", "=", "emukit", ".", "test_functions", ".", "forrester_function", "(", ")", "\n", "\n", "x_test", "=", "np", ".", "random", ".", "rand", "(", "50", ",", "1", ")", "\n", "benchmark", "=", "Benchmarker", "(", "\n", "loops", ",", "\n", "test_fcn", ",", "\n", "parameter_space", ",", "\n", "[", "MinimumObservedValueMetric", "(", ")", ",", "TimeMetric", "(", ")", ",", "MeanSquaredErrorMetric", "(", "x_test", ",", "test_fcn", "(", "x_test", ")", ")", "]", ",", "\n", ")", "\n", "results", "=", "benchmark", ".", "run_benchmark", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.benchmarking.test_benchmarker.test_non_unique_metric_names_fail": [[38, 43], ["emukit.test_functions.forrester_function", "pytest.raises", "emukit.benchmarking.loop_benchmarking.benchmarker.Benchmarker", "emukit.benchmarking.loop_benchmarking.metrics.MinimumObservedValueMetric", "emukit.benchmarking.loop_benchmarking.metrics.MinimumObservedValueMetric"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.forrester_function"], ["", "def", "test_non_unique_metric_names_fail", "(", "loops", ")", ":", "\n", "    ", "test_fcn", ",", "parameter_space", "=", "emukit", ".", "test_functions", ".", "forrester_function", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "Benchmarker", "(", "\n", "loops", ",", "test_fcn", ",", "parameter_space", ",", "[", "MinimumObservedValueMetric", "(", "\"x\"", ")", ",", "MinimumObservedValueMetric", "(", "\"x\"", ")", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.random_search.RandomSearch.__init__": [[14, 38], ["core.loop.model_updaters.NoopModelUpdater", "core.loop.candidate_point_calculators.RandomSampling", "core.loop.outer_loop.OuterLoop.__init__", "core.loop.loop_state.create_loop_state"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state"], ["    ", "def", "__init__", "(", "\n", "self", ",", "space", ":", "ParameterSpace", ",", "x_init", ":", "np", ".", "ndarray", "=", "None", ",", "y_init", ":", "np", ".", "ndarray", "=", "None", ",", "cost_init", ":", "np", ".", "ndarray", "=", "None", "\n", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Simple loop to perform random search where in each iteration points are sampled uniformly at random\n        over the input space.\n\n        :param space: Input space where the optimization is carried out.\n        :param x_init: 2d numpy array of shape (no. points x no. input features) of initial X data\n        :param y_init: 2d numpy array of shape (no. points x no. targets) of initial Y data\n        :param cost_init: 2d numpy array of shape (no. points x no. targets) of initial cost of each function evaluation\n        \"\"\"", "\n", "\n", "model_updaters", "=", "NoopModelUpdater", "(", ")", "\n", "\n", "candidate_point_calculator", "=", "RandomSampling", "(", "parameter_space", "=", "space", ")", "\n", "\n", "if", "x_init", "is", "not", "None", "and", "y_init", "is", "not", "None", ":", "\n", "            ", "loop_state", "=", "create_loop_state", "(", "x_init", ",", "y_init", ",", "cost", "=", "cost_init", ")", "\n", "", "else", ":", "\n", "            ", "loop_state", "=", "None", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "candidate_point_calculator", ",", "model_updaters", ",", "loop_state", "=", "loop_state", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.__init__": [[7, 26], ["dict", "dict", "range", "[].append"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "loop_names", ":", "List", "[", "str", "]", ",", "n_repeats", ":", "int", ",", "metric_names", ":", "List", "[", "str", "]", ")", ":", "\n", "        ", "\"\"\"\n\n        :param loop_names: List of loop names\n        :param n_repeats: Number of random restarts in benchmarking\n        :param metric_names: List of metric names\n        \"\"\"", "\n", "\n", "self", ".", "loop_names", "=", "loop_names", "\n", "self", ".", "n_repeats", "=", "n_repeats", "\n", "self", ".", "metric_names", "=", "metric_names", "\n", "\n", "self", ".", "_results", "=", "dict", "(", ")", "\n", "for", "loop_name", "in", "loop_names", ":", "\n", "            ", "self", ".", "_results", "[", "loop_name", "]", "=", "dict", "(", ")", "\n", "for", "metric_name", "in", "metric_names", ":", "\n", "                ", "self", ".", "_results", "[", "loop_name", "]", "[", "metric_name", "]", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_repeats", ")", ":", "\n", "                    ", "self", ".", "_results", "[", "loop_name", "]", "[", "metric_name", "]", ".", "append", "(", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results": [[27, 37], ["metric_values.flatten"], "methods", ["None"], ["", "", "", "", "def", "add_results", "(", "self", ",", "loop_name", ":", "str", ",", "i_repeat", ":", "int", ",", "metric_name", ":", "str", ",", "metric_values", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Add results for a specific loop, metric and repeat combination\n\n        :param loop_name: Name of loop\n        :param i_repeat: Index of repeat\n        :param metric_name: Name of metric\n        :param metric_values: Metric values to add\n        \"\"\"", "\n", "self", ".", "_results", "[", "loop_name", "]", "[", "metric_name", "]", "[", "i_repeat", "]", "=", "metric_values", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array": [[38, 47], ["numpy.array"], "methods", ["None"], ["", "def", "extract_metric_as_array", "(", "self", ",", "loop_name", ":", "str", ",", "metric_name", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns results over all repeats and iterations for a specific metric and loop name pair\n\n        :param loop_name: Name of loop to return results for\n        :param metric_name: Name of metric to extract\n        :return: 2-d numpy array of shape (n_repeats x n_iterations)\n        \"\"\"", "\n", "return", "np", ".", "array", "(", "self", ".", "_results", "[", "loop_name", "]", "[", "metric_name", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.Metric.evaluate": [[9, 11], ["None"], "methods", ["None"], ["    ", "def", "evaluate", "(", "self", ",", "loop", ":", "OuterLoop", ",", "loop_state", ":", "LoopState", ")", "->", "None", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.Metric.reset": [[12, 14], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", "->", "None", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.MeanSquaredErrorMetric.__init__": [[21, 29], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "x_test", ":", "np", ".", "ndarray", ",", "y_test", ":", "np", ".", "ndarray", ",", "name", ":", "str", "=", "\"mean_squared_error\"", ")", ":", "\n", "        ", "\"\"\"\n        :param x_test: Input locations of test data\n        :param y_test: Test targets\n        \"\"\"", "\n", "self", ".", "x_test", "=", "x_test", "\n", "self", ".", "y_test", "=", "y_test", "\n", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.MeanSquaredErrorMetric.evaluate": [[30, 41], ["numpy.mean", "loop.model_updaters[].model.predict", "numpy.square"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "evaluate", "(", "self", ",", "loop", ":", "OuterLoop", ",", "loop_state", ":", "LoopState", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculate and store mean squared error\n\n        :param loop: Outer loop\n        :param loop_state: Object containing history of the loop that we add results to\n        \"\"\"", "\n", "# Calculate mean squared error", "\n", "predictions", "=", "loop", ".", "model_updaters", "[", "0", "]", ".", "model", ".", "predict", "(", "self", ".", "x_test", ")", "[", "0", "]", "\n", "mse", "=", "np", ".", "mean", "(", "np", ".", "square", "(", "self", ".", "y_test", "-", "predictions", ")", ",", "axis", "=", "0", ")", "\n", "return", "mse", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.MinimumObservedValueMetric.__init__": [[48, 50], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ":", "str", "=", "\"minimum_observed_value\"", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.MinimumObservedValueMetric.evaluate": [[51, 60], ["numpy.min"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "loop", ":", "OuterLoop", ",", "loop_state", ":", "LoopState", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluates minimum observed value\n\n        :param loop: Outer loop\n        :param loop_state: Object containing history of the loop that we add results to\n        \"\"\"", "\n", "y_min", "=", "np", ".", "min", "(", "loop_state", ".", "Y", ",", "axis", "=", "0", ")", "\n", "return", "y_min", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.TimeMetric.__init__": [[67, 73], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ":", "str", "=", "\"time\"", ")", ":", "\n", "        ", "\"\"\"\n        :param name: Name of the metric. Defaults to \"time\"\n        \"\"\"", "\n", "self", ".", "start_time", "=", "None", "\n", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.TimeMetric.evaluate": [[74, 81], ["numpy.array", "time.time.time"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "loop", ":", "OuterLoop", ",", "loop_state", ":", "LoopState", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns difference between time now and when the reset method was last called\n        \"\"\"", "\n", "time_since_start", "=", "time", "(", ")", "-", "self", ".", "start_time", "\n", "# Add to metrics dictionary in loop state", "\n", "return", "np", ".", "array", "(", "[", "time_since_start", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.TimeMetric.reset": [[82, 87], ["time.time.time"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Resets the start time\n        \"\"\"", "\n", "self", ".", "start_time", "=", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.__init__": [[96, 100], ["numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ":", "str", "=", "\"cumulative_costs\"", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "cumulative_costs", "=", "np", ".", "array", "(", "[", "0.0", "]", ")", "\n", "self", ".", "last_observed_iter", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.evaluate": [[101, 115], ["numpy.cumsum"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "loop", ":", "OuterLoop", ",", "loop_state", ":", "LoopState", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the cumulative cost of all function evaluations after the last observed iteration\n\n        :param loop: Outer loop\n        :param loop_state: Object containing history of the loop that we add results to\n\n        :return cumulative cost\n        \"\"\"", "\n", "if", "loop_state", ".", "cost", "[", "-", "1", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "cumulative_costs", "+=", "np", ".", "cumsum", "(", "loop_state", ".", "cost", "[", "self", ".", "last_observed_iter", ":", "]", ")", "[", "-", "1", "]", "\n", "self", ".", "last_observed_iter", "=", "loop_state", ".", "cost", ".", "shape", "[", "0", "]", "\n", "\n", "", "return", "self", ".", "cumulative_costs", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset": [[116, 122], ["numpy.array"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Resets the cumulative cost and the internal counter back to 0\n        \"\"\"", "\n", "self", ".", "last_observed_iter", "=", "0", "\n", "self", ".", "cumulative_costs", "=", "np", ".", "array", "(", "[", "0.0", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker.Benchmarker.__init__": [[18, 54], ["isinstance", "core.loop.UserFunctionWrapper", "core.initial_designs.RandomDesign", "len", "len", "ValueError", "set"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "loops_with_names", ":", "List", "[", "Tuple", "[", "str", ",", "Callable", "]", "]", ",", "\n", "test_function", ":", "Union", "[", "Callable", ",", "UserFunction", "]", ",", "\n", "parameter_space", ":", "ParameterSpace", ",", "\n", "metrics", ":", "List", "[", "Metric", "]", ",", "\n", "initial_design", ":", "ModelFreeDesignBase", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param loops_with_names: A list of tuples where the first entry is the name of the loop and the second is a\n                                 function that takes in initial x and y training data and returns a loop to be\n                                 benchmarked\n        :param test_function: The function to benchmark the loop against\n        :param parameter_space: Parameter space describing the input domain of the function to be benchmarked against\n        :param metrics: List of metric objects that assess the performance of the loop at every iteration\n        :param initial_design: An object that returns a set of samples in the input domain that are used as the initial\n                               data set\n        \"\"\"", "\n", "\n", "self", ".", "loop_names", "=", "[", "loop", "[", "0", "]", "for", "loop", "in", "loops_with_names", "]", "\n", "self", ".", "loops", "=", "[", "loop", "[", "1", "]", "for", "loop", "in", "loops_with_names", "]", "\n", "\n", "if", "isinstance", "(", "test_function", ",", "UserFunction", ")", ":", "\n", "            ", "self", ".", "test_function", "=", "test_function", "\n", "", "else", ":", "\n", "            ", "self", ".", "test_function", "=", "UserFunctionWrapper", "(", "test_function", ")", "\n", "", "self", ".", "parameter_space", "=", "parameter_space", "\n", "\n", "if", "initial_design", "is", "None", ":", "\n", "            ", "initial_design", "=", "RandomDesign", "(", "parameter_space", ")", "\n", "", "self", ".", "initial_design", "=", "initial_design", "\n", "self", ".", "metrics", "=", "metrics", "\n", "self", ".", "metric_names", "=", "[", "metric", ".", "name", "for", "metric", "in", "metrics", "]", "\n", "\n", "if", "len", "(", "set", "(", "self", ".", "metric_names", ")", ")", "!=", "len", "(", "self", ".", "metric_names", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Names of metrics are not unique\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker.Benchmarker.run_benchmark": [[55, 80], ["benchmark_result.BenchmarkResult", "range", "benchmarker.Benchmarker._create_initial_loop_state", "enumerate", "zip", "_log.info", "loop", "dict", "benchmarker.Benchmarker._subscribe_metrics_to_loop_events", "loop.run_loop", "loop.loop_state.metrics.items", "benchmark_result.BenchmarkResult.add_results", "str", "str"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker.Benchmarker._create_initial_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.quadrature.test_bayesian_monte_carlo_loop.loop", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker.Benchmarker._subscribe_metrics_to_loop_events", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.add_results"], ["", "", "def", "run_benchmark", "(", "self", ",", "n_initial_data", ":", "int", "=", "10", ",", "n_iterations", ":", "int", "=", "10", ",", "n_repeats", ":", "int", "=", "10", ")", "->", "BenchmarkResult", ":", "\n", "        ", "\"\"\"\n        Runs the benchmarking. For each initial data set, every loop is created and run for the specified number of\n        iterations and the results are collected.\n\n        :param n_initial_data: Number of points in the initial data set\n        :param n_iterations: Number of iterations to run the loop for\n        :param n_repeats: Number of times to run each loop with a different initial data set\n        :return: An instance of BenchmarkResult that contains all the tracked metrics for each loop\n        \"\"\"", "\n", "result", "=", "BenchmarkResult", "(", "self", ".", "loop_names", ",", "n_repeats", ",", "self", ".", "metric_names", ")", "\n", "for", "j", "in", "range", "(", "n_repeats", ")", ":", "\n", "            ", "initial_loop_state", "=", "self", ".", "_create_initial_loop_state", "(", "n_initial_data", ")", "\n", "for", "i", ",", "(", "loop", ",", "loop_name", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "loops", ",", "self", ".", "loop_names", ")", ")", ":", "\n", "                ", "_log", ".", "info", "(", "\"Benchmarking loop \"", "+", "str", "(", "i", ")", "+", "\" for repeat \"", "+", "str", "(", "j", ")", ")", "\n", "\n", "this_loop", "=", "loop", "(", "initial_loop_state", ")", "\n", "this_loop", ".", "loop_state", ".", "metrics", "=", "dict", "(", ")", "\n", "self", ".", "_subscribe_metrics_to_loop_events", "(", "this_loop", ")", "\n", "\n", "this_loop", ".", "run_loop", "(", "self", ".", "test_function", ",", "n_iterations", ")", "\n", "\n", "for", "metric_name", ",", "metric_value", "in", "this_loop", ".", "loop_state", ".", "metrics", ".", "items", "(", ")", ":", "\n", "                    ", "result", ".", "add_results", "(", "loop_name", ",", "j", ",", "metric_name", ",", "metric_value", ")", "\n", "", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker.Benchmarker._subscribe_metrics_to_loop_events": [[81, 97], ["metric.reset", "functools.partial", "outer_loop.loop_start_event.append", "outer_loop.iteration_end_event.append", "metric.evaluate", "benchmarker._add_value_to_metrics_dict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.metrics.CumulativeCostMetric.reset", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker._add_value_to_metrics_dict"], ["", "def", "_subscribe_metrics_to_loop_events", "(", "self", ",", "outer_loop", ")", ":", "\n", "        ", "\"\"\"\n        Subscribe metric calls to events on outer loop object\n        \"\"\"", "\n", "if", "self", ".", "metrics", "is", "not", "None", ":", "\n", "            ", "for", "metric", "in", "self", ".", "metrics", ":", "\n", "                ", "metric", ".", "reset", "(", ")", "\n", "\n", "def", "update_metric", "(", "loop", ",", "loop_state", ",", "metric", ")", ":", "\n", "                    ", "value", "=", "metric", ".", "evaluate", "(", "loop", ",", "loop_state", ")", "\n", "_add_value_to_metrics_dict", "(", "loop_state", ",", "value", ",", "metric", ".", "name", ")", "\n", "\n", "# Subscribe to events", "\n", "", "func", "=", "partial", "(", "update_metric", ",", "metric", "=", "metric", ")", "\n", "outer_loop", ".", "loop_start_event", ".", "append", "(", "func", ")", "\n", "outer_loop", ".", "iteration_end_event", ".", "append", "(", "func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker.Benchmarker._create_initial_loop_state": [[98, 102], ["benchmarker.Benchmarker.initial_design.get_samples", "benchmarker.Benchmarker.test_function.evaluate", "core.loop.LoopState"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "", "def", "_create_initial_loop_state", "(", "self", ",", "n_initial_data", ")", ":", "\n", "        ", "x_init", "=", "self", ".", "initial_design", ".", "get_samples", "(", "n_initial_data", ")", "\n", "results", "=", "self", ".", "test_function", ".", "evaluate", "(", "x_init", ")", "\n", "return", "LoopState", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmarker._add_value_to_metrics_dict": [[104, 115], ["numpy.concatenate", "numpy.array"], "function", ["None"], ["", "", "def", "_add_value_to_metrics_dict", "(", "loop_state", ",", "value", ",", "key_name", ")", ":", "\n", "    ", "\"\"\"\n    Add new metric evaluation to dictionary in loop state using the metric name as the key in the dictionary\n    \"\"\"", "\n", "\n", "if", "key_name", "in", "loop_state", ".", "metrics", ":", "\n", "# Array already exists - append new value", "\n", "        ", "loop_state", ".", "metrics", "[", "key_name", "]", "=", "np", ".", "concatenate", "(", "[", "loop_state", ".", "metrics", "[", "key_name", "]", ",", "[", "value", "]", "]", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "# Initialise array", "\n", "        ", "loop_state", ".", "metrics", "[", "key_name", "]", "=", "np", ".", "array", "(", "[", "value", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_plot.BenchmarkPlot.__init__": [[19, 69], ["benchmark_plot._get_default_colours", "benchmark_plot.BenchmarkPlot.metrics_to_plot.remove", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_plot._get_default_colours"], ["def", "__init__", "(", "\n", "self", ",", "\n", "benchmark_results", ":", "BenchmarkResult", ",", "\n", "loop_colours", ":", "List", "=", "None", ",", "\n", "loop_line_styles", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "x_axis_metric_name", ":", "str", "=", "None", ",", "\n", "metrics_to_plot", ":", "List", "[", "str", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param benchmark_results: The output of a benchmark run\n        :param loop_colours: Colours to use for each loop. Defaults to standard matplotlib colour palette\n        :param loop_line_styles: Line style to use for each loop. Defaults to solid line style for all lines\n        :param x_axis_metric_name: Which metric to use as the x axis in plots.\n                                   None means it will be plotted against iteration number.\n        :param metrics_to_plot: A list of metric names to plot. Defaults to all metrics apart from the one used as the\n                                x axis.\n        \"\"\"", "\n", "self", ".", "benchmark_results", "=", "benchmark_results", "\n", "self", ".", "loop_names", "=", "benchmark_results", ".", "loop_names", "\n", "\n", "if", "loop_colours", "is", "None", ":", "\n", "            ", "self", ".", "loop_colours", "=", "_get_default_colours", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "loop_colours", "=", "loop_colours", "\n", "\n", "", "if", "loop_line_styles", "is", "None", ":", "\n", "            ", "self", ".", "loop_line_styles", "=", "[", "\"-\"", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "loop_line_styles", "=", "loop_line_styles", "\n", "\n", "", "if", "metrics_to_plot", "is", "None", ":", "\n", "            ", "self", ".", "metrics_to_plot", "=", "self", ".", "benchmark_results", ".", "metric_names", "\n", "", "else", ":", "\n", "            ", "for", "metric_name", "in", "metrics_to_plot", ":", "\n", "                ", "if", "metric_name", "not", "in", "self", ".", "benchmark_results", ".", "metric_names", ":", "\n", "                    ", "raise", "ValueError", "(", "metric_name", "+", "\" not found in saved metrics from benchmark results.\"", ")", "\n", "", "", "self", ".", "metrics_to_plot", "=", "metrics_to_plot", "\n", "\n", "", "if", "x_axis_metric_name", "is", "not", "None", ":", "\n", "            ", "if", "x_axis_metric_name", "not", "in", "self", ".", "metrics_to_plot", ":", "\n", "                ", "raise", "ValueError", "(", "\"x_axis \"", "+", "x_axis_metric_name", "+", "\" is not a valid metric name\"", ")", "\n", "", "self", ".", "metrics_to_plot", ".", "remove", "(", "x_axis_metric_name", ")", "\n", "\n", "", "if", "x_axis_metric_name", "is", "None", ":", "\n", "            ", "self", ".", "x_label", "=", "\"Iteration\"", "\n", "", "else", ":", "\n", "            ", "self", ".", "x_label", "=", "x_axis_metric_name", "\n", "\n", "", "self", ".", "fig_handle", "=", "None", "\n", "self", ".", "x_axis", "=", "x_axis_metric_name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_plot.BenchmarkPlot.make_plot": [[70, 118], ["len", "plt.subplots", "enumerate", "plt.subplot", "plt.title", "itertools.cycle", "itertools.cycle", "enumerate", "plt.legend", "plt.tight_layout", "plt.xlim", "benchmark_plot.BenchmarkPlot.benchmark_results.extract_metric_as_array", "next", "next", "benchmark_plot._get_metric_stats", "numpy.min", "numpy.max", "plt.plot", "plt.xlabel", "plt.fill_between", "numpy.mean", "numpy.arange", "benchmark_plot.BenchmarkPlot.benchmark_results.extract_metric_as_array", "numpy.min", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_plot._get_metric_stats", "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_result.BenchmarkResult.extract_metric_as_array"], ["", "def", "make_plot", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Make one plot for each metric measured, comparing the different loop results against each other\n        \"\"\"", "\n", "\n", "n_metrics", "=", "len", "(", "self", ".", "metrics_to_plot", ")", "\n", "self", ".", "fig_handle", ",", "_", "=", "plt", ".", "subplots", "(", "n_metrics", ",", "1", ")", "\n", "\n", "for", "i", ",", "metric_name", "in", "enumerate", "(", "self", ".", "metrics_to_plot", ")", ":", "\n", "# Initialise plot", "\n", "            ", "plt", ".", "subplot", "(", "n_metrics", ",", "1", ",", "i", "+", "1", ")", "\n", "plt", ".", "title", "(", "metric_name", ")", "\n", "\n", "colours", "=", "cycle", "(", "self", ".", "loop_colours", ")", "\n", "line_styles", "=", "cycle", "(", "self", ".", "loop_line_styles", ")", "\n", "min_x", "=", "np", ".", "inf", "\n", "max_x", "=", "-", "np", ".", "inf", "\n", "\n", "for", "j", ",", "loop_name", "in", "enumerate", "(", "self", ".", "loop_names", ")", ":", "\n", "# Get all results for this metric", "\n", "                ", "metric", "=", "self", ".", "benchmark_results", ".", "extract_metric_as_array", "(", "loop_name", ",", "metric_name", ")", "\n", "\n", "# Get plot options", "\n", "colour", "=", "next", "(", "colours", ")", "\n", "line_style", "=", "next", "(", "line_styles", ")", "\n", "\n", "# Get data to plot", "\n", "mean", ",", "std", "=", "_get_metric_stats", "(", "metric", ")", "\n", "\n", "if", "self", ".", "x_axis", "is", "not", "None", ":", "\n", "                    ", "x", "=", "np", ".", "mean", "(", "self", ".", "benchmark_results", ".", "extract_metric_as_array", "(", "loop_name", ",", "self", ".", "x_axis", ")", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "                    ", "x", "=", "np", ".", "arange", "(", "0", ",", "mean", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# Save min/max of data to set the axis limits later", "\n", "", "min_x", "=", "np", ".", "min", "(", "[", "np", ".", "min", "(", "x", ")", ",", "min_x", "]", ")", "\n", "max_x", "=", "np", ".", "max", "(", "[", "np", ".", "max", "(", "x", ")", ",", "max_x", "]", ")", "\n", "\n", "# Plot", "\n", "plt", ".", "plot", "(", "x", ",", "mean", ",", "color", "=", "colour", ",", "linestyle", "=", "line_style", ")", "\n", "plt", ".", "xlabel", "(", "self", ".", "x_label", ")", "\n", "plt", ".", "fill_between", "(", "x", ",", "mean", "-", "std", ",", "mean", "+", "std", ",", "alpha", "=", "0.2", ",", "color", "=", "colour", ")", "\n", "\n", "# Make legend", "\n", "", "plt", ".", "legend", "(", "self", ".", "loop_names", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "plt", ".", "xlim", "(", "min_x", ",", "max_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_plot.BenchmarkPlot.save_plot": [[119, 130], ["ValueError", "open", "benchmark_plot.BenchmarkPlot.fig_handle.savefig"], "methods", ["None"], ["", "", "def", "save_plot", "(", "self", ",", "file_name", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Save plot to file\n\n        :param file_name:\n        \"\"\"", "\n", "if", "self", ".", "fig_handle", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Please call make_plots method before saving to file\"", ")", "\n", "\n", "", "with", "open", "(", "file_name", ")", "as", "file", ":", "\n", "            ", "self", ".", "fig_handle", ".", "savefig", "(", "file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_plot._get_metric_stats": [[132, 134], ["metric.mean", "metric.std"], "function", ["None"], ["", "", "", "def", "_get_metric_stats", "(", "metric", ")", ":", "\n", "    ", "return", "metric", ".", "mean", "(", "axis", "=", "0", ")", ",", "metric", ".", "std", "(", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.loop_benchmarking.benchmark_plot._get_default_colours": [[136, 138], ["plt.rcParams[].by_key"], "function", ["None"], ["", "def", "_get_default_colours", "(", ")", ":", "\n", "    ", "return", "plt", ".", "rcParams", "[", "\"axes.prop_cycle\"", "]", ".", "by_key", "(", ")", "[", "\"color\"", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.__init__": [[28, 35], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "gpy_model", ":", "GPy", ".", "core", ".", "Model", ",", "n_restarts", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        :param gpy_model: GPy model object to wrap\n        :param n_restarts: Number of restarts during hyper-parameter optimization\n        \"\"\"", "\n", "self", ".", "model", "=", "gpy_model", "\n", "self", ".", "n_restarts", "=", "n_restarts", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.predict": [[36, 42], ["gpy_model_wrappers.GPyModelWrapper.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param X: (n_points x n_dimensions) array containing locations at which to get predictions\n        :return: (mean, variance) Arrays of size n_points x 1 of the predictive distribution at each input location\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.predict_noiseless": [[43, 49], ["gpy_model_wrappers.GPyModelWrapper.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_noiseless", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param X: (n_points x n_dimensions) array containing locations at which to get predictions\n        :return: (mean, variance) Arrays of size n_points x 1 of the predictive distribution at each input location\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "X", ",", "include_likelihood", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.predict_with_full_covariance": [[50, 57], ["gpy_model_wrappers.GPyModelWrapper.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_with_full_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param X: (n_points x n_dimensions) array containing locations at which to get predictions\n        :return: (mean, variance) Arrays of size n_points x 1 and n_points x n_points of the predictive\n                 mean and variance at each input location\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "predict", "(", "X", ",", "full_cov", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.get_prediction_gradients": [[58, 66], ["gpy_model_wrappers.GPyModelWrapper.model.predictive_gradients"], "methods", ["None"], ["", "def", "get_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param X: (n_points x n_dimensions) array containing locations at which to get gradient of the predictions\n        :return: (mean gradient, variance gradient) n_points x n_dimensions arrays of the gradients of the predictive\n                 distribution at each input location\n        \"\"\"", "\n", "d_mean_dx", ",", "d_variance_dx", "=", "self", ".", "model", ".", "predictive_gradients", "(", "X", ")", "\n", "return", "d_mean_dx", "[", ":", ",", ":", ",", "0", "]", ",", "d_variance_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.get_joint_prediction_gradients": [[67, 79], ["gpy_model_wrappers.dmean", "gpy_model_wrappers.dSigma"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.dmean", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.dSigma"], ["", "def", "get_joint_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Computes and returns model gradients of mean and full covariance matrix at given points\n\n        :param X: points to compute gradients at, nd array of shape (q, d)\n        :return: Tuple with first item being gradient of the mean of shape (q) at X with respect to X (return shape is (q, q, d)).\n                 The second item is the gradient of the full covariance matrix of shape (q, q) at X with respect to X\n                 (return shape is (q, q, q, d)).\n        \"\"\"", "\n", "dmean_dx", "=", "dmean", "(", "X", ",", "self", ".", "model", ".", "X", ",", "self", ".", "model", ".", "kern", ",", "self", ".", "model", ".", "posterior", ".", "woodbury_vector", "[", ":", ",", "0", "]", ")", "\n", "dvariance_dx", "=", "dSigma", "(", "X", ",", "self", ".", "model", ".", "X", ",", "self", ".", "model", ".", "kern", ",", "self", ".", "model", ".", "posterior", ".", "woodbury_inv", ")", "\n", "return", "dmean_dx", ",", "dvariance_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.set_data": [[80, 88], ["gpy_model_wrappers.GPyModelWrapper.model.set_XY"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Sets training data in model\n\n        :param X: New training features\n        :param Y: New training outputs\n        \"\"\"", "\n", "self", ".", "model", ".", "set_XY", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.optimize": [[89, 94], ["gpy_model_wrappers.GPyModelWrapper.model.optimize_restarts"], "methods", ["None"], ["", "def", "optimize", "(", "self", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Optimizes model hyper-parameters\n        \"\"\"", "\n", "self", ".", "model", ".", "optimize_restarts", "(", "self", ".", "n_restarts", ",", "verbose", "=", "verbose", ",", "robust", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.calculate_variance_reduction": [[95, 102], ["gpy_model_wrappers.GPyModelWrapper.model.posterior_covariance_between_points", "gpy_model_wrappers.GPyModelWrapper.model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "calculate_variance_reduction", "(", "self", ",", "x_train_new", ":", "np", ".", "ndarray", ",", "x_test", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the variance reduction at x_test, if a new point at x_train_new is acquired\n        \"\"\"", "\n", "covariance", "=", "self", ".", "model", ".", "posterior_covariance_between_points", "(", "x_train_new", ",", "x_test", ",", "include_likelihood", "=", "False", ")", "\n", "variance_prediction", "=", "self", ".", "model", ".", "predict", "(", "x_train_new", ")", "[", "1", "]", "\n", "return", "covariance", "**", "2", "/", "variance_prediction", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.predict_covariance": [[103, 114], ["gpy_model_wrappers.GPyModelWrapper.model.predict", "numpy.clip"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "with_noise", ":", "bool", "=", "True", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculates posterior covariance between points in X\n        :param X: Array of size n_points x n_dimensions containing input locations to compute posterior covariance at\n        :param with_noise: Whether to include likelihood noise in the covariance matrix\n        :return: Posterior covariance matrix of size n_points x n_points\n        \"\"\"", "\n", "_", ",", "v", "=", "self", ".", "model", ".", "predict", "(", "X", ",", "full_cov", "=", "True", ",", "include_likelihood", "=", "with_noise", ")", "\n", "v", "=", "np", ".", "clip", "(", "v", ",", "1e-10", ",", "np", ".", "inf", ")", "\n", "\n", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.get_covariance_between_points": [[115, 127], ["gpy_model_wrappers.GPyModelWrapper.model.posterior_covariance_between_points"], "methods", ["None"], ["", "def", "get_covariance_between_points", "(", "self", ",", "X1", ":", "np", ".", "ndarray", ",", "X2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculate posterior covariance between two sets of points.\n        :param X1: An array of shape n_points1 x n_dimensions. This is the first argument of the\n                   posterior covariance function.\n        :param X2: An array of shape n_points2 x n_dimensions. This is the second argument of the\n                   posterior covariance function.\n        :return: An array of shape n_points1 x n_points2 of posterior covariances between X1 and X2.\n            Namely, [i, j]-th entry of the returned array will represent the posterior covariance\n            between i-th point in X1 and j-th point in X2.\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "posterior_covariance_between_points", "(", "X1", ",", "X2", ",", "include_likelihood", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.X": [[128, 134], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :return: An array of shape n_points x n_dimensions containing training inputs\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.Y": [[135, 141], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :return: An array of shape n_points x 1 containing training outputs\n        \"\"\"", "\n", "return", "self", ".", "model", ".", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.generate_hyperparameters_samples": [[142, 167], ["gpy_model_wrappers.GPyModelWrapper.model.optimize", "GPy.inference.mcmc.HMC", "GPy.inference.mcmc.HMC.sample", "numpy.random.lognormal", "numpy.log", "numpy.sqrt", "numpy.log", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample"], ["", "def", "generate_hyperparameters_samples", "(", "\n", "self", ",", "n_samples", "=", "20", ",", "n_burnin", "=", "100", ",", "subsample_interval", "=", "10", ",", "step_size", "=", "1e-1", ",", "leapfrog_steps", "=", "20", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates the samples from the hyper-parameters and returns them.\n        :param n_samples: Number of generated samples.\n        :param n_burnin: Number of initial samples not used.\n        :param subsample_interval: Interval of subsampling from HMC samples.\n        :param step_size: Size of the gradient steps in the HMC sampler.\n        :param leapfrog_steps: Number of gradient steps before each Metropolis Hasting step.\n        :return: A numpy array whose rows are samples of the hyper-parameters.\n\n        \"\"\"", "\n", "self", ".", "model", ".", "optimize", "(", "max_iters", "=", "self", ".", "n_restarts", ")", "\n", "# Add jitter to all unfixed parameters. After optimizing the hyperparameters, the gradient of the", "\n", "# posterior probability of the parameters wrt. the parameters will be close to 0.0, which is a poor", "\n", "# initialization for HMC", "\n", "unfixed_params", "=", "[", "param", "for", "param", "in", "self", ".", "model", ".", "flattened_parameters", "if", "not", "param", ".", "is_fixed", "]", "\n", "for", "param", "in", "unfixed_params", ":", "\n", "# Add jitter by\u00a0multiplying with log-normal noise with mean 1 and standard deviation 0.01", "\n", "# This ensures the sign of the parameter remains the same", "\n", "            ", "param", "*=", "np", ".", "random", ".", "lognormal", "(", "np", ".", "log", "(", "1.0", "/", "np", ".", "sqrt", "(", "1.0001", ")", ")", ",", "np", ".", "sqrt", "(", "np", ".", "log", "(", "1.0001", ")", ")", ",", "size", "=", "param", ".", "size", ")", "\n", "", "hmc", "=", "GPy", ".", "inference", ".", "mcmc", ".", "HMC", "(", "self", ".", "model", ",", "stepsize", "=", "step_size", ")", "\n", "samples", "=", "hmc", ".", "sample", "(", "num_samples", "=", "n_burnin", "+", "n_samples", "*", "subsample_interval", ",", "hmc_iters", "=", "leapfrog_steps", ")", "\n", "return", "samples", "[", "n_burnin", ":", ":", "subsample_interval", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyModelWrapper.fix_model_hyperparameters": [[168, 178], ["gpy_model_wrappers.GPyModelWrapper.model._trigger_params_changed"], "methods", ["None"], ["", "def", "fix_model_hyperparameters", "(", "self", ",", "sample_hyperparameters", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Fix model hyperparameters\n\n        \"\"\"", "\n", "if", "self", ".", "model", ".", "_fixes_", "is", "None", ":", "\n", "            ", "self", ".", "model", "[", ":", "]", "=", "sample_hyperparameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "model", "[", "self", ".", "model", ".", "_fixes_", "]", "=", "sample_hyperparameters", "\n", "", "self", ".", "model", ".", "_trigger_params_changed", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.__init__": [[237, 251], ["core.interfaces.IModel.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "gpy_model", ":", "GPy", ".", "core", ".", "GP", ",", "n_outputs", ":", "int", ",", "n_optimization_restarts", ":", "int", ",", "verbose_optimization", ":", "bool", "=", "True", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param gpy_model: GPy multi-output model\n        :param n_outputs: Number of outputs in the problem\n        :param n_optimization_restarts: Number of restarts from random starting points when optimizing hyper-parameters\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gpy_model", "=", "gpy_model", "\n", "self", ".", "n_optimization_restarts", "=", "n_optimization_restarts", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "self", ".", "verbose_optimization", "=", "verbose_optimization", "\n", "self", ".", "samples", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.calculate_variance_reduction": [[252, 265], ["gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.posterior_covariance_between_points", "fidelities_train_new.astype", "gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "calculate_variance_reduction", "(", "self", ",", "x_train_new", ":", "np", ".", "ndarray", ",", "x_test", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculates reduction in variance at x_test due to observing training point x_train_new\n\n        :param x_train_new: New training point\n        :param x_test: Test points to calculate variance reduction at\n        :return: Array of variance reduction at each test point\n        \"\"\"", "\n", "fidelities_train_new", "=", "x_train_new", "[", ":", ",", "-", "1", "]", "\n", "y_metadata", "=", "{", "\"output_index\"", ":", "fidelities_train_new", ".", "astype", "(", "int", ")", "}", "\n", "covariance", "=", "self", ".", "gpy_model", ".", "posterior_covariance_between_points", "(", "x_train_new", ",", "x_test", ",", "include_likelihood", "=", "False", ")", "\n", "variance_prediction", "=", "self", ".", "gpy_model", ".", "predict", "(", "x_train_new", ",", "Y_metadata", "=", "y_metadata", ")", "[", "1", "]", "\n", "return", "covariance", "**", "2", "/", "variance_prediction", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients": [[266, 274], ["gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.predictive_gradients"], "methods", ["None"], ["", "def", "get_prediction_gradients", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Calculates gradients of predictions with respect to X, excluding with respect to the output index\n        :param X: Point at which to predict gradients\n        :return: (mean gradient, variance gradient)\n        \"\"\"", "\n", "dmean_dx", ",", "dvar_dx", "=", "self", ".", "gpy_model", ".", "predictive_gradients", "(", "X", ")", "\n", "return", "dmean_dx", "[", ":", ",", ":", "-", "1", "]", ",", "dvar_dx", "[", ":", ",", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.predict": [[275, 284], ["gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.predict", "output_index.astype"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Predicts mean and variance for output specified by last column of X\n        :param X: point(s) at which to predict\n        :return: predicted (mean, variance) at X\n        \"\"\"", "\n", "output_index", "=", "X", "[", ":", ",", "-", "1", "]", "\n", "y_metadata", "=", "{", "\"output_index\"", ":", "output_index", ".", "astype", "(", "int", ")", "}", "\n", "return", "self", ".", "gpy_model", ".", "predict", "(", "X", ",", "Y_metadata", "=", "y_metadata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.set_data": [[285, 296], ["gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.update_model", "gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.set_XY", "gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.update_model", "X[].astype"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Updates model with new training data\n        :param X: New training features with output index as last column\n        :param Y: New training targets with output index as last column\n        \"\"\"", "\n", "y_metadata", "=", "{", "\"output_index\"", ":", "X", "[", ":", ",", "-", "1", "]", ".", "astype", "(", "int", ")", "}", "\n", "self", ".", "gpy_model", ".", "update_model", "(", "False", ")", "\n", "self", ".", "gpy_model", ".", "Y_metadata", "=", "y_metadata", "\n", "self", ".", "gpy_model", ".", "set_XY", "(", "X", ",", "Y", ")", "\n", "self", ".", "gpy_model", ".", "update_model", "(", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.optimize": [[297, 308], ["gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.optimize", "gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.optimize_restarts"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Optimizes hyper-parameters of model. Starts the optimization at random locations equal to the values of the\n        \"n_optimization_restarts\" attribute.\n        \"\"\"", "\n", "# Optimize the model if optimization_restarts > 0", "\n", "if", "self", ".", "n_optimization_restarts", "==", "1", ":", "\n", "            ", "self", ".", "gpy_model", ".", "optimize", "(", ")", "\n", "", "elif", "self", ".", "n_optimization_restarts", ">=", "1", ":", "\n", "            ", "self", ".", "gpy_model", ".", "optimize_restarts", "(", "\n", "self", ".", "n_optimization_restarts", ",", "verbose", "=", "self", ".", "verbose_optimization", ",", "robust", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.X": [[310, 313], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "gpy_model", ".", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.Y": [[314, 317], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "gpy_model", ".", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.predict_covariance": [[318, 331], ["numpy.maximum", "output_index.astype", "gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_covariance", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "with_noise", ":", "bool", "=", "True", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculates posterior covariance between points in X\n\n        :param X: Array of size n_points x n_dimensions containing input locations to compute posterior covariance at\n        :param with_noise: Whether to include likelihood noise in the covariance matrix\n        :return: Posterior covariance matrix of size n_points x n_points\n        \"\"\"", "\n", "output_index", "=", "X", "[", ":", ",", "-", "1", "]", "\n", "y_metadata", "=", "{", "\"output_index\"", ":", "output_index", ".", "astype", "(", "int", ")", "}", "\n", "variance", "=", "self", ".", "gpy_model", ".", "predict", "(", "X", ",", "Y_metadata", "=", "y_metadata", ",", "full_cov", "=", "True", ")", "[", "1", "]", "\n", "variance", "=", "np", ".", "maximum", "(", "variance", ",", "1e-10", ")", "\n", "return", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_covariance_between_points": [[332, 342], ["gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.posterior_covariance_between_points"], "methods", ["None"], ["", "def", "get_covariance_between_points", "(", "self", ",", "X1", ":", "np", ".", "ndarray", ",", "X2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Calculate posterior covariance between two points\n        :param X1: An array of shape 1 x n_dimensions that contains a data single point. It is the first argument of the\n                   posterior covariance function\n        :param X2: An array of shape n_points x n_dimensions that may contain multiple data points. This is the second\n                   argument to the posterior covariance function.\n        :return: An array of shape n_points x 1 of posterior covariances between X1 and X2\n        \"\"\"", "\n", "return", "self", ".", "gpy_model", ".", "posterior_covariance_between_points", "(", "X1", ",", "X2", ",", "include_likelihood", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.generate_hyperparameters_samples": [[343, 362], ["gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model.optimize", "GPy.inference.mcmc.HMC", "GPy.inference.mcmc.HMC.sample", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.measures.gaussian_measure.GaussianMeasure.sample"], ["", "def", "generate_hyperparameters_samples", "(", "\n", "self", ",", "n_samples", "=", "10", ",", "n_burnin", "=", "5", ",", "subsample_interval", "=", "1", ",", "step_size", "=", "1e-1", ",", "leapfrog_steps", "=", "1", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates the samples from the hyper-parameters, and returns them (a numpy array whose rows are\n        samples of the hyper-parameters).\n        :param n_samples: Number of generated samples.\n        :param n_burnin: Number of initial samples not used.\n        :param subsample_interval: Interval of subsampling from HMC samples.\n        :param step_size: Size of the gradient steps in the HMC sampler.\n        :param leapfrog_steps: Number of gradient steps before each Metropolis Hasting step.\n        \"\"\"", "\n", "self", ".", "gpy_model", ".", "optimize", "(", "max_iters", "=", "self", ".", "n_optimization_restarts", ")", "\n", "self", ".", "gpy_model", ".", "param_array", "[", ":", "]", "=", "self", ".", "gpy_model", ".", "param_array", "*", "(", "\n", "1.0", "+", "np", ".", "random", ".", "randn", "(", "self", ".", "gpy_model", ".", "param_array", ".", "size", ")", "*", "0.01", "\n", ")", "\n", "hmc", "=", "GPy", ".", "inference", ".", "mcmc", ".", "HMC", "(", "self", ".", "gpy_model", ",", "stepsize", "=", "step_size", ")", "\n", "samples", "=", "hmc", ".", "sample", "(", "num_samples", "=", "n_burnin", "+", "n_samples", "*", "subsample_interval", ",", "hmc_iters", "=", "leapfrog_steps", ")", "\n", "return", "samples", "[", "n_burnin", ":", ":", "subsample_interval", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.fix_model_hyperparameters": [[363, 373], ["gpy_model_wrappers.GPyMultiOutputWrapper.gpy_model._trigger_params_changed"], "methods", ["None"], ["", "def", "fix_model_hyperparameters", "(", "self", ",", "sample_hyperparameters", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Fix model hyperparameters\n\n        \"\"\"", "\n", "if", "self", ".", "gpy_model", ".", "_fixes_", "is", "None", ":", "\n", "            ", "self", ".", "gpy_model", "[", ":", "]", "=", "sample_hyperparameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "gpy_model", "[", "self", ".", "gpy_model", ".", "_fixes_", "]", "=", "sample_hyperparameters", "\n", "", "self", ".", "gpy_model", ".", "_trigger_params_changed", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.dSigma": [[180, 209], ["numpy.empty", "numpy.empty", "range", "kern.K", "numpy.zeros", "range", "kern.dK_dX", "kern.dK_dX", "range", "numpy.zeros", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.dK_dX", "home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.dK_dX"], ["", "", "def", "dSigma", "(", "x_predict", ":", "np", ".", "ndarray", ",", "x_train", ":", "np", ".", "ndarray", ",", "kern", ":", "GPy", ".", "kern", ",", "w_inv", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Compute the derivative of the posterior covariance with respect to the prediction input\n\n    :param x_predict: Prediction inputs of shape (q, d)\n    :param x_train: Training inputs of shape (n, d)\n    :param kern: Covariance of the GP model\n    :param w_inv: Woodbury inverse of the posterior fit of the GP\n    :return: Gradient of the posterior covariance of shape (q, q, q, d)\n    \"\"\"", "\n", "q", ",", "d", ",", "n", "=", "x_predict", ".", "shape", "[", "0", "]", ",", "x_predict", ".", "shape", "[", "1", "]", ",", "x_train", ".", "shape", "[", "0", "]", "\n", "dkxX_dx", "=", "np", ".", "empty", "(", "(", "q", ",", "n", ",", "d", ")", ")", "\n", "dkxx_dx", "=", "np", ".", "empty", "(", "(", "q", ",", "q", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "        ", "dkxX_dx", "[", ":", ",", ":", ",", "i", "]", "=", "kern", ".", "dK_dX", "(", "x_predict", ",", "x_train", ",", "i", ")", "\n", "dkxx_dx", "[", ":", ",", ":", ",", "i", "]", "=", "kern", ".", "dK_dX", "(", "x_predict", ",", "x_predict", ",", "i", ")", "\n", "", "K", "=", "kern", ".", "K", "(", "x_predict", ",", "x_train", ")", "\n", "\n", "dsigma", "=", "np", ".", "zeros", "(", "(", "q", ",", "q", ",", "q", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "q", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "d", ")", ":", "\n", "            ", "Ks", "=", "np", ".", "zeros", "(", "(", "q", ",", "n", ")", ")", "\n", "Ks", "[", "i", ",", ":", "]", "=", "dkxX_dx", "[", "i", ",", ":", ",", "j", "]", "\n", "dKss_dxi", "=", "np", ".", "zeros", "(", "(", "q", ",", "q", ")", ")", "\n", "dKss_dxi", "[", "i", ",", ":", "]", "=", "dkxx_dx", "[", "i", ",", ":", ",", "j", "]", "\n", "dKss_dxi", "[", ":", ",", "i", "]", "=", "dkxx_dx", "[", "i", ",", ":", ",", "j", "]", ".", "T", "\n", "dKss_dxi", "[", "i", ",", "i", "]", "=", "0", "\n", "dsigma", "[", ":", ",", ":", ",", "i", ",", "j", "]", "=", "dKss_dxi", "-", "Ks", "@", "w_inv", "@", "K", ".", "T", "-", "K", "@", "w_inv", "@", "Ks", ".", "T", "\n", "", "", "return", "dsigma", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.dmean": [[211, 229], ["numpy.empty", "numpy.zeros", "range", "kern.dK_dX", "range"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisitions.expectation_acquisition.dK_dX"], ["", "def", "dmean", "(", "x_predict", ":", "np", ".", "ndarray", ",", "x_train", ":", "np", ".", "ndarray", ",", "kern", ":", "GPy", ".", "kern", ",", "w_vec", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Compute the derivative of the posterior mean with respect to prediction input\n\n    :param x_predict: Prediction inputs of shape (q, d)\n    :param x_train: Training inputs of shape (n, d)\n    :param kern: Covariance of the GP model\n    :param w_vec: Woodbury vector of the posterior fit of the GP\n    :return: Gradient of the posterior mean of shape (q, q, d)\n    \"\"\"", "\n", "q", ",", "d", ",", "n", "=", "x_predict", ".", "shape", "[", "0", "]", ",", "x_predict", ".", "shape", "[", "1", "]", ",", "x_train", ".", "shape", "[", "0", "]", "\n", "dkxX_dx", "=", "np", ".", "empty", "(", "(", "q", ",", "n", ",", "d", ")", ")", "\n", "dmu", "=", "np", ".", "zeros", "(", "(", "q", ",", "q", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "        ", "dkxX_dx", "[", ":", ",", ":", ",", "i", "]", "=", "kern", ".", "dK_dX", "(", "x_predict", ",", "x_train", ",", "i", ")", "\n", "for", "j", "in", "range", "(", "q", ")", ":", "\n", "            ", "dmu", "[", "j", ",", "j", ",", "i", "]", "=", "(", "dkxX_dx", "[", "j", ",", ":", ",", "i", "]", "[", "None", ",", ":", "]", "@", "w_vec", "[", ":", ",", "None", "]", ")", ".", "flatten", "(", ")", "\n", "", "", "return", "dmu", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel.__init__": [[16, 27], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "x", ":", "np", ".", "ndarray", ",", "y", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "\"\"\"\n        :param x: (n_points, n_dims) array containing training features\n        :param y: (n_points, 1) array containing training targets\n        \"\"\"", "\n", "self", ".", "x", "=", "x", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "lengthscale", "=", "1", "\n", "self", ".", "kernel_variance", "=", "1", "\n", "self", ".", "likelihood_variance", "=", "1", "\n", "self", ".", "jitter", "=", "1e-6", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel.__repr__": [[28, 34], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Prints the hyper-parameters\n        \"\"\"", "\n", "return", "\"Lengthscale: {:.4f} \\n Kernel variance: {:.4f} \\n Likelihood variance: {:.4f}\"", ".", "format", "(", "\n", "self", ".", "lengthscale", ",", "self", ".", "kernel_variance", ",", "self", ".", "likelihood_variance", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel.optimize": [[36, 58], ["numpy.log", "numpy.log", "scipy.optimize.minimize", "scipy.optimize.minimize", "scipy.optimize.minimize", "scipy.optimize.minimize", "numpy.exp", "simple_gp_model.SimpleGaussianProcessModel._negative_marginal_log_likelihood", "numpy.log", "range", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel._negative_marginal_log_likelihood"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Optimize the three hyperparameters of the model, namely the kernel variance, kernel lengthscale and likelihood\n        variance\n        \"\"\"", "\n", "\n", "def", "optimize_fcn", "(", "log_hyper_parameters", ")", ":", "\n", "# take exponential to ensure positive values", "\n", "            ", "hyper_parameters", "=", "np", ".", "exp", "(", "log_hyper_parameters", ")", "\n", "self", ".", "lengthscale", "=", "hyper_parameters", "[", "0", "]", "\n", "self", ".", "kernel_variance", "=", "hyper_parameters", "[", "1", "]", "\n", "self", ".", "likelihood_variance", "=", "hyper_parameters", "[", "2", "]", "\n", "return", "self", ".", "_negative_marginal_log_likelihood", "(", ")", "\n", "\n", "", "lower_bound", "=", "np", ".", "log", "(", "1e-6", ")", "\n", "upper_bound", "=", "np", ".", "log", "(", "1e8", ")", "\n", "\n", "bounds", "=", "[", "(", "lower_bound", ",", "upper_bound", ")", "for", "_", "in", "range", "(", "3", ")", "]", "\n", "scipy", ".", "optimize", ".", "minimize", "(", "\n", "optimize_fcn", ",", "\n", "np", ".", "log", "(", "np", ".", "array", "(", "[", "self", ".", "lengthscale", ",", "self", ".", "kernel_variance", ",", "self", ".", "likelihood_variance", "]", ")", ")", ",", "\n", "bounds", "=", "bounds", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel.predict": [[60, 81], ["simple_gp_model.SimpleGaussianProcessModel._calc_kernel", "numpy.linalg.cholesky", "simple_gp_model.SimpleGaussianProcessModel._calc_kernel", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "numpy.dot", "numpy.identity", "numpy.sum", "numpy.square"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel._calc_kernel", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel._calc_kernel"], ["", "def", "predict", "(", "self", ",", "x_new", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Predict from model\n\n        :param x_new: (n_points, n_dims) array containing points at which the predictive distributions will be computed\n        :return: Tuple containing two (n_points, 1) arrays representing the mean and variance of the predictive\n                 distribution at the specified input locations\n        \"\"\"", "\n", "K", "=", "self", ".", "_calc_kernel", "(", "self", ".", "x", ")", "\n", "K", "+=", "np", ".", "identity", "(", "self", ".", "x", ".", "shape", "[", "0", "]", ")", "*", "(", "self", ".", "jitter", "+", "self", ".", "likelihood_variance", ")", "\n", "\n", "L", "=", "np", ".", "linalg", ".", "cholesky", "(", "K", ")", "\n", "\n", "K_xs", "=", "self", ".", "_calc_kernel", "(", "self", ".", "x", ",", "x_new", ")", "\n", "\n", "tmp", "=", "scipy", ".", "linalg", ".", "solve_triangular", "(", "L", ",", "K_xs", ",", "lower", "=", "True", ")", "\n", "tmp2", "=", "scipy", ".", "linalg", ".", "solve_triangular", "(", "L", ",", "self", ".", "y", ",", "lower", "=", "True", ")", "\n", "\n", "mean", "=", "np", ".", "dot", "(", "tmp", ".", "T", ",", "tmp2", ")", "\n", "variance", "=", "(", "self", ".", "kernel_variance", "-", "np", ".", "sum", "(", "np", ".", "square", "(", "tmp", ")", ",", "axis", "=", "0", ")", ")", "[", ":", ",", "None", "]", "\n", "return", "mean", ",", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel._calc_kernel": [[82, 99], ["numpy.sum", "numpy.sum", "numpy.clip", "numpy.square", "numpy.square", "numpy.exp", "numpy.dot"], "methods", ["None"], ["", "def", "_calc_kernel", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "X2", ":", "np", ".", "ndarray", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Implements an RBF kernel with no ARD\n\n        :param X: array of shape (n_points_1, n_dims) containing input points of first argument to kernel function\n        :param X2: array of shape (n_points_2, n_dims) containing input points of second argument to kernel function.\n                   If not supplied K(X, X) is computed.\n        :return: Kernel matrix K(X, X2) or K(X, X) if X2 not supplied.\n        \"\"\"", "\n", "if", "X2", "is", "None", ":", "\n", "            ", "X2", "=", "X", "\n", "\n", "", "X1sq", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "X", ")", ",", "1", ")", "\n", "X2sq", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "X2", ")", ",", "1", ")", "\n", "r2", "=", "-", "2.0", "*", "np", ".", "dot", "(", "X", ",", "X2", ".", "T", ")", "+", "(", "X1sq", "[", ":", ",", "None", "]", "+", "X2sq", "[", "None", ",", ":", "]", ")", "\n", "r2", "=", "np", ".", "clip", "(", "r2", ",", "0", ",", "np", ".", "inf", ")", "\n", "return", "self", ".", "kernel_variance", "*", "np", ".", "exp", "(", "-", "0.5", "*", "r2", "/", "self", ".", "lengthscale", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel._negative_marginal_log_likelihood": [[100, 120], ["simple_gp_model.SimpleGaussianProcessModel._calc_kernel", "numpy.linalg.cholesky", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "scipy.linalg.solve_triangular", "numpy.log", "numpy.identity", "numpy.sum", "numpy.log", "numpy.sum", "numpy.diag"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel._calc_kernel"], ["", "def", "_negative_marginal_log_likelihood", "(", "self", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        :return: Negative marginal log likelihood of model with current hyper-parameters\n        \"\"\"", "\n", "K", "=", "self", ".", "_calc_kernel", "(", "self", ".", "x", ")", "\n", "\n", "# Add some jitter to the diagonal", "\n", "K", "+=", "np", ".", "identity", "(", "self", ".", "x", ".", "shape", "[", "0", "]", ")", "*", "(", "self", ".", "jitter", "+", "self", ".", "likelihood_variance", ")", "\n", "\n", "# cholesky decomposition of covariance matrix", "\n", "L", "=", "np", ".", "linalg", ".", "cholesky", "(", "K", ")", "\n", "\n", "# Log determinant of the covariance matrix", "\n", "log_det", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diag", "(", "L", ")", ")", ")", "\n", "\n", "# calculate y^T K^{-1} y using the cholesky of K", "\n", "tmp", "=", "scipy", ".", "linalg", ".", "solve_triangular", "(", "L", ",", "self", ".", "y", ",", "lower", "=", "True", ")", "\n", "alpha", "=", "scipy", ".", "linalg", ".", "solve_triangular", "(", "L", ".", "T", ",", "tmp", ",", "lower", "=", "False", ")", "\n", "log_2_pi", "=", "np", ".", "log", "(", "2", "*", "np", ".", "pi", ")", "\n", "return", "-", "0.5", "*", "(", "-", "self", ".", "y", ".", "size", "*", "log_2_pi", "-", "self", ".", "y", ".", "shape", "[", "1", "]", "*", "log_det", "-", "np", ".", "sum", "(", "alpha", "*", "self", ".", "y", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel.set_data": [[121, 130], ["None"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Set training data to new values\n\n        :param X: (n_points, n_dims) array containing training features\n        :param Y: (n_points, 1) array containing training targets\n        \"\"\"", "\n", "self", ".", "x", "=", "X", "\n", "self", ".", "y", "=", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel.X": [[131, 134], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.simple_gp_model.SimpleGaussianProcessModel.Y": [[135, 138], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "y", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.__init__": [[49, 59], ["quadrature.interfaces.IBaseGaussianProcess.__init__", "isinstance", "gpy_model.Gaussian_noise.constrain_fixed", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "kern", ":", "QuadratureKernel", ",", "gpy_model", ":", "GPy", ".", "models", ".", "GPRegression", ",", "noise_free", ":", "bool", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "kern", "=", "kern", ")", "\n", "if", "noise_free", ":", "\n", "            ", "gpy_model", ".", "Gaussian_noise", ".", "constrain_fixed", "(", "1.0e-10", ")", "\n", "", "self", ".", "gpy_model", "=", "gpy_model", "\n", "\n", "if", "isinstance", "(", "kern", ",", "QuadratureProductBrownian", ")", ":", "\n", "            ", "if", "kern", ".", "offset", "!=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"The wrapper BaseGaussianProcessGPy does not support EmuKit product Brownian \"", "\n", "\"motion kernels with non-zero offset as these are not supported in GPy.\"", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.X": [[62, 66], ["None"], "methods", ["None"], ["", "", "", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The data nodes.\"\"\"", "\n", "return", "self", ".", "gpy_model", ".", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.Y": [[67, 71], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The data evaluations at the nodes.\"\"\"", "\n", "return", "self", ".", "gpy_model", ".", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.observation_noise_variance": [[72, 75], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "observation_noise_variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "gpy_model", ".", "Gaussian_noise", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.set_data": [[76, 83], ["gpy_quadrature_wrappers.BaseGaussianProcessGPy.gpy_model.set_XY"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.pbbo.gp_models.MCMCComparisonGP.set_XY"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"Sets training data in model.\n\n        :param X: New training features, shape (num_points, input_dim).\n        :param Y: New training outputs, shape (num_points, 1).\n        \"\"\"", "\n", "self", ".", "gpy_model", ".", "set_XY", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.predict": [[84, 91], ["gpy_quadrature_wrappers.BaseGaussianProcessGPy.gpy_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X_pred", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Predictive mean and covariance at the locations X_pred.\n\n        :param X_pred: Points at which to predict, with shape (number of points, input_dim).\n        :return: Predictive mean, predictive variances shapes (num_points, 1) and (num_points, 1).\n        \"\"\"", "\n", "return", "self", ".", "gpy_model", ".", "predict", "(", "X_pred", ",", "full_cov", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.predict_with_full_covariance": [[92, 99], ["gpy_quadrature_wrappers.BaseGaussianProcessGPy.gpy_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict_with_full_covariance", "(", "self", ",", "X_pred", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Predictive mean and covariance at the locations X_pred.\n\n        :param X_pred: Points at which to predict, with shape (num_points, input_dim).\n        :return: Predictive mean, predictive full covariance shapes (num_points, 1) and (num_points, num_points).\n        \"\"\"", "\n", "return", "self", ".", "gpy_model", ".", "predict", "(", "X_pred", ",", "full_cov", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.solve_linear": [[100, 103], ["scipy.linalg.lapack.dtrtrs", "scipy.linalg.lapack.dtrtrs"], "methods", ["None"], ["", "def", "solve_linear", "(", "self", ",", "z", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "lower_chol", "=", "self", ".", "gpy_model", ".", "posterior", ".", "woodbury_chol", "\n", "return", "lapack", ".", "dtrtrs", "(", "lower_chol", ".", "T", ",", "(", "lapack", ".", "dtrtrs", "(", "lower_chol", ",", "z", ",", "lower", "=", "1", ")", "[", "0", "]", ")", ",", "lower", "=", "0", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.graminv_residual": [[104, 106], ["None"], "methods", ["None"], ["", "def", "graminv_residual", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "gpy_model", ".", "posterior", ".", "woodbury_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy.optimize": [[107, 110], ["gpy_quadrature_wrappers.BaseGaussianProcessGPy.gpy_model.optimize"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Optimize the hyperparameters of the GP.\"\"\"", "\n", "self", ".", "gpy_model", ".", "optimize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy.__init__": [[126, 128], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "gpy_rbf", ":", "GPy", ".", "kern", ".", "RBF", ")", ":", "\n", "        ", "self", ".", "gpy_rbf", "=", "gpy_rbf", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy.lengthscales": [[129, 134], ["numpy.full"], "methods", ["None"], ["", "@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "self", ".", "gpy_rbf", ".", "ARD", ":", "\n", "            ", "return", "self", ".", "gpy_rbf", ".", "lengthscale", ".", "values", "\n", "", "return", "np", ".", "full", "(", "(", "self", ".", "gpy_rbf", ".", "input_dim", ",", ")", ",", "self", ".", "gpy_rbf", ".", "lengthscale", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy.variance": [[135, 138], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "gpy_rbf", ".", "variance", ".", "values", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy.K": [[139, 141], ["gpy_quadrature_wrappers.RBFGPy.gpy_rbf.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "K", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "gpy_rbf", ".", "K", "(", "x1", ",", "x2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern32GPy.__init__": [[171, 198], ["ValueError", "len", "GPy.kern.Matern32", "range", "ValueError", "GPy.kern.Matern32", "GPy.kern.Matern32.unlink_parameter"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "gpy_matern", ":", "Optional", "[", "Union", "[", "GPy", ".", "kern", ".", "Matern32", ",", "GPy", ".", "kern", ".", "Prod", "]", "]", "=", "None", ",", "\n", "lengthscales", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "variance", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "gpy_matern", "is", "None", "and", "lengthscales", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either lengthscales or a GPy product matern kernel must be given.\"", ")", "\n", "\n", "# product kernel from parameters", "\n", "", "if", "gpy_matern", "is", "None", ":", "\n", "\n", "            ", "input_dim", "=", "len", "(", "lengthscales", ")", "\n", "if", "input_dim", "<", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"'lengthscales' must contain at least 1 value.\"", ")", "\n", "\n", "# default variance", "\n", "", "if", "variance", "is", "None", ":", "\n", "                ", "variance", "=", "1.0", "\n", "\n", "", "gpy_matern", "=", "GPy", ".", "kern", ".", "Matern32", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "0", "]", ",", "lengthscale", "=", "lengthscales", "[", "0", "]", ",", "variance", "=", "variance", ")", "\n", "for", "dim", "in", "range", "(", "1", ",", "input_dim", ")", ":", "\n", "                ", "k", "=", "GPy", ".", "kern", ".", "Matern32", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "dim", "]", ",", "lengthscale", "=", "lengthscales", "[", "dim", "]", ")", "\n", "k", ".", "unlink_parameter", "(", "k", ".", "variance", ")", "\n", "gpy_matern", "=", "gpy_matern", "*", "k", "\n", "\n", "", "", "self", ".", "gpy_matern", "=", "gpy_matern", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern32GPy.lengthscales": [[199, 208], ["isinstance", "numpy.array", "numpy.array", "lengthscales.append"], "methods", ["None"], ["", "@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "gpy_matern", ",", "GPy", ".", "kern", ".", "Matern32", ")", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "self", ".", "gpy_matern", ".", "lengthscale", "[", "0", "]", "]", ")", "\n", "\n", "", "lengthscales", "=", "[", "]", "\n", "for", "kern", "in", "self", ".", "gpy_matern", ".", "parameters", ":", "\n", "            ", "lengthscales", ".", "append", "(", "kern", ".", "lengthscale", "[", "0", "]", ")", "\n", "", "return", "np", ".", "array", "(", "lengthscales", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern32GPy.variance": [[209, 215], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "gpy_matern", ",", "GPy", ".", "kern", ".", "Matern32", ")", ":", "\n", "            ", "return", "self", ".", "gpy_matern", ".", "variance", "[", "0", "]", "\n", "\n", "", "return", "self", ".", "gpy_matern", ".", "parameters", "[", "0", "]", ".", "variance", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern32GPy.K": [[216, 218], ["gpy_quadrature_wrappers.ProductMatern32GPy.gpy_matern.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "K", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "gpy_matern", ".", "K", "(", "x1", ",", "x2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern32GPy._K_from_prod": [[219, 240], ["numpy.ones", "enumerate", "kern.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "_K_from_prod", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ",", "skip", ":", "List", "[", "int", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The kernel k(x1, x2) evaluated at x1 and x2 computed as product from the\n        individual 1d kernels.\n\n        :param x1: First argument of the kernel.\n        :param x2: Second argument of the kernel.\n        :param skip: Skip these dimensions if specified.\n        :returns: Kernel evaluated at x1, x2.\n        \"\"\"", "\n", "if", "skip", "is", "None", ":", "\n", "            ", "skip", "=", "[", "]", "\n", "", "K", "=", "np", ".", "ones", "(", "[", "x1", ".", "shape", "[", "0", "]", ",", "x2", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "dim", ",", "kern", "in", "enumerate", "(", "self", ".", "gpy_matern", ".", "parameters", ")", ":", "\n", "            ", "if", "dim", "in", "skip", ":", "\n", "                ", "continue", "\n", "", "K", "*=", "kern", ".", "K", "(", "x1", ",", "x2", ")", "\n", "\n", "# correct for missing variance", "\n", "", "if", "0", "in", "skip", ":", "\n", "            ", "K", "*=", "self", ".", "variance", "\n", "", "return", "K", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern32GPy.dK_dx1": [[241, 252], ["isinstance", "numpy.ones", "enumerate", "gpy_quadrature_wrappers.ProductMatern32GPy._K_from_prod", "gpy_quadrature_wrappers.ProductMatern32GPy._dK_dx1_1d", "gpy_quadrature_wrappers.ProductMatern32GPy._dK_dx1_1d"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy._K_from_prod", "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian._dK_dx1_1d", "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian._dK_dx1_1d"], ["", "def", "dK_dx1", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "gpy_matern", ",", "GPy", ".", "kern", ".", "Matern32", ")", ":", "\n", "            ", "return", "self", ".", "_dK_dx1_1d", "(", "x1", "[", ":", ",", "0", "]", ",", "x2", "[", ":", ",", "0", "]", ",", "self", ".", "gpy_matern", ".", "lengthscale", "[", "0", "]", ")", "[", "None", ",", ":", ",", ":", "]", "\n", "\n", "# product kernel", "\n", "", "dK_dx1", "=", "np", ".", "ones", "(", "[", "x1", ".", "shape", "[", "1", "]", ",", "x1", ".", "shape", "[", "0", "]", ",", "x2", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "dim", ",", "kern", "in", "enumerate", "(", "self", ".", "gpy_matern", ".", "parameters", ")", ":", "\n", "            ", "prod_term", "=", "self", ".", "_K_from_prod", "(", "x1", ",", "x2", ",", "skip", "=", "[", "dim", "]", ")", "# N x M", "\n", "grad_term", "=", "self", ".", "_dK_dx1_1d", "(", "x1", "[", ":", ",", "dim", "]", ",", "x2", "[", ":", ",", "dim", "]", ",", "kern", ".", "lengthscale", "[", "0", "]", ")", "# N x M", "\n", "dK_dx1", "[", "dim", ",", ":", ",", ":", "]", "*=", "prod_term", "*", "grad_term", "\n", "", "return", "dK_dx1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern52GPy.__init__": [[282, 309], ["ValueError", "len", "GPy.kern.Matern52", "range", "ValueError", "GPy.kern.Matern52", "GPy.kern.Matern52.unlink_parameter"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "gpy_matern", ":", "Optional", "[", "Union", "[", "GPy", ".", "kern", ".", "Matern52", ",", "GPy", ".", "kern", ".", "Prod", "]", "]", "=", "None", ",", "\n", "lengthscales", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "variance", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "gpy_matern", "is", "None", "and", "lengthscales", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either lengthscales or a GPy product matern kernel must be given.\"", ")", "\n", "\n", "# product kernel from parameters", "\n", "", "if", "gpy_matern", "is", "None", ":", "\n", "\n", "            ", "input_dim", "=", "len", "(", "lengthscales", ")", "\n", "if", "input_dim", "<", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"'lengthscales' must contain at least 1 value.\"", ")", "\n", "\n", "# default variance", "\n", "", "if", "variance", "is", "None", ":", "\n", "                ", "variance", "=", "1.0", "\n", "\n", "", "gpy_matern", "=", "GPy", ".", "kern", ".", "Matern52", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "0", "]", ",", "lengthscale", "=", "lengthscales", "[", "0", "]", ",", "variance", "=", "variance", ")", "\n", "for", "dim", "in", "range", "(", "1", ",", "input_dim", ")", ":", "\n", "                ", "k", "=", "GPy", ".", "kern", ".", "Matern52", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "dim", "]", ",", "lengthscale", "=", "lengthscales", "[", "dim", "]", ")", "\n", "k", ".", "unlink_parameter", "(", "k", ".", "variance", ")", "\n", "gpy_matern", "=", "gpy_matern", "*", "k", "\n", "\n", "", "", "self", ".", "gpy_matern", "=", "gpy_matern", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern52GPy.lengthscales": [[310, 319], ["isinstance", "numpy.array", "numpy.array", "lengthscales.append"], "methods", ["None"], ["", "@", "property", "\n", "def", "lengthscales", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "gpy_matern", ",", "GPy", ".", "kern", ".", "Matern52", ")", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "self", ".", "gpy_matern", ".", "lengthscale", "[", "0", "]", "]", ")", "\n", "\n", "", "lengthscales", "=", "[", "]", "\n", "for", "kern", "in", "self", ".", "gpy_matern", ".", "parameters", ":", "\n", "            ", "lengthscales", ".", "append", "(", "kern", ".", "lengthscale", "[", "0", "]", ")", "\n", "", "return", "np", ".", "array", "(", "lengthscales", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern52GPy.variance": [[320, 326], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "gpy_matern", ",", "GPy", ".", "kern", ".", "Matern52", ")", ":", "\n", "            ", "return", "self", ".", "gpy_matern", ".", "variance", "[", "0", "]", "\n", "\n", "", "return", "self", ".", "gpy_matern", ".", "parameters", "[", "0", "]", ".", "variance", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern52GPy.K": [[327, 329], ["gpy_quadrature_wrappers.ProductMatern52GPy.gpy_matern.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "K", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "gpy_matern", ".", "K", "(", "x1", ",", "x2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern52GPy._K_from_prod": [[330, 351], ["numpy.ones", "enumerate", "kern.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "_K_from_prod", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ",", "skip", ":", "List", "[", "int", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The kernel k(x1, x2) evaluated at x1 and x2 computed as product from the\n        individual 1d kernels.\n\n        :param x1: First argument of the kernel.\n        :param x2: Second argument of the kernel.\n        :param skip: Skip these dimensions if specified.\n        :returns: Kernel evaluated at x1, x2.\n        \"\"\"", "\n", "if", "skip", "is", "None", ":", "\n", "            ", "skip", "=", "[", "]", "\n", "", "K", "=", "np", ".", "ones", "(", "[", "x1", ".", "shape", "[", "0", "]", ",", "x2", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "dim", ",", "kern", "in", "enumerate", "(", "self", ".", "gpy_matern", ".", "parameters", ")", ":", "\n", "            ", "if", "dim", "in", "skip", ":", "\n", "                ", "continue", "\n", "", "K", "*=", "kern", ".", "K", "(", "x1", ",", "x2", ")", "\n", "\n", "# correct for missing variance", "\n", "", "if", "0", "in", "skip", ":", "\n", "            ", "K", "*=", "self", ".", "variance", "\n", "", "return", "K", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern52GPy.dK_dx1": [[352, 363], ["isinstance", "numpy.ones", "enumerate", "gpy_quadrature_wrappers.ProductMatern52GPy._K_from_prod", "gpy_quadrature_wrappers.ProductMatern52GPy._dK_dx1_1d", "gpy_quadrature_wrappers.ProductMatern52GPy._dK_dx1_1d"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy._K_from_prod", "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian._dK_dx1_1d", "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian._dK_dx1_1d"], ["", "def", "dK_dx1", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "gpy_matern", ",", "GPy", ".", "kern", ".", "Matern52", ")", ":", "\n", "            ", "return", "self", ".", "_dK_dx1_1d", "(", "x1", "[", ":", ",", "0", "]", ",", "x2", "[", ":", ",", "0", "]", ",", "self", ".", "gpy_matern", ".", "lengthscale", "[", "0", "]", ")", "[", "None", ",", ":", ",", ":", "]", "\n", "\n", "# product kernel", "\n", "", "dK_dx1", "=", "np", ".", "ones", "(", "[", "x1", ".", "shape", "[", "1", "]", ",", "x1", ".", "shape", "[", "0", "]", ",", "x2", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "dim", ",", "kern", "in", "enumerate", "(", "self", ".", "gpy_matern", ".", "parameters", ")", ":", "\n", "            ", "prod_term", "=", "self", ".", "_K_from_prod", "(", "x1", ",", "x2", ",", "skip", "=", "[", "dim", "]", ")", "# N x M", "\n", "grad_term", "=", "self", ".", "_dK_dx1_1d", "(", "x1", "[", ":", ",", "dim", "]", ",", "x2", "[", ":", ",", "dim", "]", ",", "kern", ".", "lengthscale", "[", "0", "]", ")", "# N x M", "\n", "dK_dx1", "[", "dim", ",", ":", ",", ":", "]", "*=", "prod_term", "*", "grad_term", "\n", "", "return", "dK_dx1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BrownianGPy.__init__": [[376, 378], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "gpy_brownian", ":", "GPy", ".", "kern", ".", "Brownian", ")", ":", "\n", "        ", "self", ".", "gpy_brownian", "=", "gpy_brownian", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BrownianGPy.variance": [[379, 382], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "gpy_brownian", ".", "variance", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.BrownianGPy.K": [[383, 385], ["gpy_quadrature_wrappers.BrownianGPy.gpy_brownian.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "K", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "gpy_brownian", ".", "K", "(", "x1", ",", "x2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.__init__": [[413, 444], ["GPy.kern.Brownian", "range", "warnings.warn", "ValueError", "GPy.kern.Brownian", "GPy.kern.Brownian.unlink_parameter"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "gpy_brownian", ":", "Optional", "[", "Union", "[", "GPy", ".", "kern", ".", "Brownian", ",", "GPy", ".", "kern", ".", "Prod", "]", "]", "=", "None", ",", "\n", "offset", ":", "float", "=", "0.0", ",", "\n", "variance", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "input_dim", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", ":", "\n", "\n", "        ", "if", "gpy_brownian", "is", "not", "None", ":", "\n", "            ", "if", "input_dim", "is", "not", "None", "or", "variance", "is", "not", "None", ":", "\n", "                ", "warnings", ".", "warn", "(", "\"gpy_brownian and variance is given. The variance will be ignore.\"", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "input_dim", "is", "None", "or", "variance", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Please provide a GPy product Brownian kernel or alternitvely the the variance and input_dim.\"", "\n", ")", "\n", "\n", "# default variance", "\n", "", "", "if", "variance", "is", "None", ":", "\n", "            ", "variance", "=", "1.0", "\n", "\n", "# product kernel from parameters", "\n", "", "if", "gpy_brownian", "is", "None", ":", "\n", "            ", "gpy_brownian", "=", "GPy", ".", "kern", ".", "Brownian", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "0", "]", ",", "variance", "=", "variance", ")", "\n", "for", "dim", "in", "range", "(", "1", ",", "input_dim", ")", ":", "\n", "                ", "k", "=", "GPy", ".", "kern", ".", "Brownian", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "dim", "]", ")", "\n", "k", ".", "unlink_parameter", "(", "k", ".", "variance", ")", "\n", "gpy_brownian", "=", "gpy_brownian", "*", "k", "\n", "\n", "", "", "self", ".", "gpy_brownian", "=", "gpy_brownian", "\n", "self", ".", "_offset", "=", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.variance": [[445, 451], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", "->", "float", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "gpy_brownian", ",", "GPy", ".", "kern", ".", "Brownian", ")", ":", "\n", "            ", "return", "self", ".", "gpy_brownian", ".", "variance", "[", "0", "]", "\n", "\n", "", "return", "self", ".", "gpy_brownian", ".", "parameters", "[", "0", "]", ".", "variance", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.offset": [[452, 455], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "offset", "(", "self", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "_offset", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K": [[456, 458], ["gpy_quadrature_wrappers.ProductBrownianGPy.gpy_brownian.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "K", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "gpy_brownian", ".", "K", "(", "x1", "-", "self", ".", "_offset", ",", "x2", "-", "self", ".", "offset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy._K_from_prod": [[459, 480], ["numpy.ones", "enumerate", "kern.K"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.K"], ["", "def", "_K_from_prod", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ",", "skip", ":", "List", "[", "int", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The kernel k(x1, x2) with offset=0 evaluated at x1 and x2 computed as product from the\n        individual 1d kernels.\n\n        :param x1: First argument of the kernel.\n        :param x2: Second shifted argument of the kernel.\n        :param skip: Skip these dimensions if specified.\n        :returns: Kernel evaluated at x1, x2.\n        \"\"\"", "\n", "if", "skip", "is", "None", ":", "\n", "            ", "skip", "=", "[", "]", "\n", "", "K", "=", "np", ".", "ones", "(", "[", "x1", ".", "shape", "[", "0", "]", ",", "x2", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "dim", ",", "kern", "in", "enumerate", "(", "self", ".", "gpy_brownian", ".", "parameters", ")", ":", "\n", "            ", "if", "dim", "in", "skip", ":", "\n", "                ", "continue", "\n", "", "K", "*=", "kern", ".", "K", "(", "x1", ",", "x2", ")", "\n", "\n", "# correct for missing variance", "\n", "", "if", "0", "in", "skip", ":", "\n", "            ", "K", "*=", "self", ".", "variance", "\n", "", "return", "K", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dK_dx1": [[481, 494], ["isinstance", "numpy.ones", "enumerate", "gpy_quadrature_wrappers.ProductBrownianGPy._K_from_prod", "gpy_quadrature_wrappers.ProductBrownianGPy._dK_dx1_1d", "gpy_quadrature_wrappers.ProductBrownianGPy._dK_dx1_1d"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy._K_from_prod", "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian._dK_dx1_1d", "home.repos.pwc.inspect_result.amzn_emukit.interfaces.standard_kernels.IProductBrownian._dK_dx1_1d"], ["", "def", "dK_dx1", "(", "self", ",", "x1", ":", "np", ".", "ndarray", ",", "x2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "gpy_brownian", ",", "GPy", ".", "kern", ".", "Brownian", ")", ":", "\n", "            ", "return", "self", ".", "_dK_dx1_1d", "(", "x1", "[", ":", ",", "0", "]", ",", "x2", "[", ":", ",", "0", "]", ")", "[", "None", ",", ":", ",", ":", "]", "\n", "\n", "# product kernel", "\n", "", "x1", "=", "x1", "-", "self", ".", "offset", "\n", "x2", "=", "x2", "-", "self", ".", "offset", "\n", "dK_dx1", "=", "np", ".", "ones", "(", "[", "x1", ".", "shape", "[", "1", "]", ",", "x1", ".", "shape", "[", "0", "]", ",", "x2", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "dim", ",", "kern", "in", "enumerate", "(", "self", ".", "gpy_brownian", ".", "parameters", ")", ":", "\n", "            ", "prod_term", "=", "self", ".", "_K_from_prod", "(", "x1", ",", "x2", ",", "skip", "=", "[", "dim", "]", ")", "# N x M", "\n", "grad_term", "=", "self", ".", "_dK_dx1_1d", "(", "x1", "[", ":", ",", "dim", "]", ",", "x2", "[", ":", ",", "dim", "]", ")", "# N x M", "\n", "dK_dx1", "[", "dim", ",", ":", ",", ":", "]", "*=", "prod_term", "*", "grad_term", "\n", "", "return", "dK_dx1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy.dKdiag_dx": [[495, 511], ["isinstance", "numpy.ones", "enumerate", "numpy.ones", "numpy.prod"], "methods", ["None"], ["", "def", "dKdiag_dx", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"The gradient of the diagonal of the kernel (the variance) v(x):=k(x, x) evaluated at x.\n\n        :param x: The locations where the gradient is evaluated, shape (n_points, input_dim).\n        :return: The gradient of the diagonal of the kernel evaluated at x, shape (input_dim, n_points).\n        \"\"\"", "\n", "if", "isinstance", "(", "self", ".", "gpy_brownian", ",", "GPy", ".", "kern", ".", "Brownian", ")", ":", "\n", "            ", "return", "self", ".", "variance", "*", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "", "x", "=", "x", "-", "self", ".", "offset", "\n", "dKdiag_dx", "=", "np", ".", "ones", "(", "(", "x", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "dim", ",", "kern", "in", "enumerate", "(", "self", ".", "gpy_brownian", ".", "parameters", ")", ":", "\n", "            ", "prod_term", "=", "np", ".", "prod", "(", "x", ",", "axis", "=", "1", ")", "/", "x", "[", ":", ",", "dim", "]", "# N,", "\n", "grad_term", "=", "1.0", "\n", "dKdiag_dx", "[", "dim", ",", ":", "]", "*=", "prod_term", "*", "grad_term", "\n", "", "return", "self", ".", "variance", "*", "dKdiag_dx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model": [[516, 597], ["isinstance", "gpy_quadrature_wrappers.BaseGaussianProcessGPy", "ValueError", "warnings.warn", "quadrature.measures.BoxDomain", "quadrature.measures.LebesgueMeasure", "isinstance", "isinstance", "gpy_quadrature_wrappers.RBFGPy", "isinstance", "gpy_quadrature_wrappers.create_emukit_model_from_gpy_model._check_is_gpy_product_kernel"], "function", ["None"], ["", "", "def", "create_emukit_model_from_gpy_model", "(", "\n", "gpy_model", ":", "GPy", ".", "models", ".", "GPRegression", ",", "\n", "integral_bounds", ":", "Optional", "[", "BoundsType", "]", "=", "None", ",", "\n", "measure", ":", "Optional", "[", "IntegrationMeasure", "]", "=", "None", ",", "\n", "integral_name", ":", "str", "=", "\"\"", ",", "\n", ")", "->", "BaseGaussianProcessGPy", ":", "\n", "    ", "\"\"\"Wraps a GPy model and returns an EmuKit quadrature model.\n\n    :param gpy_model: A GPy Gaussian process regression model ``GPy.models.GPRegression``.\n    :param integral_bounds: List of d tuples, where d is the dimensionality of the integral and the tuples contain the\n                            lower and upper bounds of the integral\n                            i.e., [(lb_1, ub_1), (lb_2, ub_2), ..., (lb_d, ub_d)].\n                            Only used if ``measure`` is not given in which case the unnormalized Lebesgue measure is used.\n    :param measure: An integration measure. Either ``measure`` or ``integral_bounds`` must be given.\n                    If both ``integral_bounds`` and ``measure`` are given, ``integral_bounds`` is disregarded.\n    :param integral_name: The (variable) name(s) of the integral.\n    :return: An EmuKit GP model for quadrature with GPy backend.\n\n    \"\"\"", "\n", "\n", "if", "(", "integral_bounds", "is", "None", ")", "and", "(", "measure", "is", "None", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Either measure or integral bounds must be given.\"", ")", "\n", "\n", "", "if", "(", "integral_bounds", "is", "not", "None", ")", "and", "(", "measure", "is", "not", "None", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "\"Both measure and integral bounds are given. Bounds are being ignored.\"", ")", "\n", "\n", "", "if", "measure", "is", "None", ":", "\n", "        ", "domain", "=", "BoxDomain", "(", "name", "=", "\"\"", ",", "bounds", "=", "integral_bounds", ")", "\n", "measure", "=", "LebesgueMeasure", "(", "domain", "=", "domain", ")", "\n", "\n", "", "def", "_check_is_gpy_product_kernel", "(", "k", ",", "k_type", ")", ":", "\n", "        ", "is_type", "=", "isinstance", "(", "gpy_model", ".", "kern", ",", "k_type", ")", "\n", "if", "isinstance", "(", "k", ",", "GPy", ".", "kern", ".", "Prod", ")", ":", "\n", "            ", "all_type", "=", "all", "(", "isinstance", "(", "kern", ",", "k_type", ")", "for", "kern", "in", "k", ".", "parameters", ")", "\n", "all_univariante", "=", "all", "(", "kern", ".", "input_dim", "==", "1", "for", "kern", "in", "k", ".", "parameters", ")", "\n", "if", "all_type", "and", "all_univariante", ":", "\n", "                ", "is_type", "=", "True", "\n", "", "", "return", "is_type", "\n", "\n", "# wrap standard kernel", "\n", "# RBF", "\n", "", "qkern_emukit", "=", "None", "\n", "if", "isinstance", "(", "gpy_model", ".", "kern", ",", "GPy", ".", "kern", ".", "RBF", ")", ":", "\n", "        ", "skern_emukit", "=", "RBFGPy", "(", "gpy_model", ".", "kern", ")", "\n", "if", "isinstance", "(", "measure", ",", "LebesgueMeasure", ")", ":", "\n", "            ", "qkern_emukit", "=", "QuadratureRBFLebesgueMeasure", "(", "skern_emukit", ",", "measure", ",", "integral_name", ")", "\n", "", "elif", "isinstance", "(", "measure", ",", "GaussianMeasure", ")", ":", "\n", "            ", "qkern_emukit", "=", "QuadratureRBFGaussianMeasure", "(", "skern_emukit", ",", "measure", ",", "integral_name", ")", "\n", "\n", "# Univariate Matern32 or ProductMatern32", "\n", "", "", "elif", "_check_is_gpy_product_kernel", "(", "gpy_model", ".", "kern", ",", "GPy", ".", "kern", ".", "Matern32", ")", ":", "\n", "        ", "skern_emukit", "=", "ProductMatern32GPy", "(", "gpy_model", ".", "kern", ")", "\n", "if", "isinstance", "(", "measure", ",", "LebesgueMeasure", ")", ":", "\n", "            ", "qkern_emukit", "=", "QuadratureProductMatern32LebesgueMeasure", "(", "skern_emukit", ",", "measure", ",", "integral_name", ")", "\n", "\n", "# Univariate Matern52 or ProductMatern52", "\n", "", "", "elif", "_check_is_gpy_product_kernel", "(", "gpy_model", ".", "kern", ",", "GPy", ".", "kern", ".", "Matern52", ")", ":", "\n", "        ", "skern_emukit", "=", "ProductMatern52GPy", "(", "gpy_model", ".", "kern", ")", "\n", "if", "isinstance", "(", "measure", ",", "LebesgueMeasure", ")", ":", "\n", "            ", "qkern_emukit", "=", "QuadratureProductMatern52LebesgueMeasure", "(", "skern_emukit", ",", "measure", ",", "integral_name", ")", "\n", "\n", "# Brownian", "\n", "", "", "elif", "isinstance", "(", "gpy_model", ".", "kern", ",", "GPy", ".", "kern", ".", "Brownian", ")", ":", "\n", "        ", "skern_emukit", "=", "BrownianGPy", "(", "gpy_model", ".", "kern", ")", "\n", "if", "isinstance", "(", "measure", ",", "LebesgueMeasure", ")", ":", "\n", "            ", "qkern_emukit", "=", "QuadratureBrownianLebesgueMeasure", "(", "skern_emukit", ",", "measure", ",", "integral_name", ")", "\n", "\n", "# ProductBrownian", "\n", "", "", "elif", "_check_is_gpy_product_kernel", "(", "gpy_model", ".", "kern", ",", "GPy", ".", "kern", ".", "Brownian", ")", ":", "\n", "        ", "skern_emukit", "=", "ProductBrownianGPy", "(", "gpy_model", ".", "kern", ")", "\n", "if", "isinstance", "(", "measure", ",", "LebesgueMeasure", ")", ":", "\n", "            ", "qkern_emukit", "=", "QuadratureProductBrownianLebesgueMeasure", "(", "skern_emukit", ",", "measure", ",", "integral_name", ")", "\n", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"There is no GPy wrapper for the provided GPy kernel ({gpy_model.kern.name}).\"", ")", "\n", "\n", "", "if", "qkern_emukit", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Kernel embedding not available for provided kernel-measure combination.\"", ")", "\n", "\n", "# wrap the base-gp model", "\n", "", "return", "BaseGaussianProcessGPy", "(", "kern", "=", "qkern_emukit", ",", "gpy_model", "=", "gpy_model", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper.__init__": [[14, 19], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "sklearn_model", ":", "GaussianProcessRegressor", ")", ":", "\n", "        ", "\"\"\"\n        :param sklearn_model: Scikit-learn GPR model to wrap\n        \"\"\"", "\n", "self", ".", "model", "=", "sklearn_model", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper.predict": [[20, 31], ["sklearn_model_wrapper.SklearnGPRWrapper.model.predict", "numpy.power().reshape", "numpy.power"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Predict mean and variance values for given points\n\n        :param X: array of shape (n_points x n_inputs) of points to run prediction for\n        :return: Tuple of mean and variance which are 2d arrays of shape (n_points x n_outputs)\n        \"\"\"", "\n", "mean", ",", "std", "=", "self", ".", "model", ".", "predict", "(", "X", ",", "return_std", "=", "True", ")", "\n", "if", "mean", ".", "ndim", "==", "1", ":", "\n", "            ", "mean", "=", "mean", "[", ":", ",", "None", "]", "\n", "", "return", "mean", ",", "np", ".", "power", "(", "std", ",", "2.0", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper.set_data": [[32, 40], ["None"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Sets training data in model\n        :param X: new points\n        :param Y: function values at new points X\n\n        \"\"\"", "\n", "self", ".", "model", ".", "X_train_", ",", "self", ".", "model", ".", "y_train_", "=", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper.optimize": [[41, 46], ["sklearn_model_wrapper.SklearnGPRWrapper.model.fit"], "methods", ["None"], ["", "def", "optimize", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Optimize hyper-parameters of model\n        \"\"\"", "\n", "self", ".", "model", ".", "fit", "(", "self", ".", "X", ",", "self", ".", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper.X": [[47, 50], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "model", ".", "X_train_", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.sklearn_model_wrapper.SklearnGPRWrapper.Y": [[51, 54], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "model", ".", "y_train_", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_prod_kernel": [[28, 33], ["kernel_type", "range", "kernel_type", "test_gpy_wrappers_quadrature.dim2", "test_gpy_wrappers_quadrature.dim2", "test_gpy_wrappers_quadrature.dim2"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2"], ["def", "get_prod_kernel", "(", "kernel_type", ",", "n_dim", ")", ":", "\n", "    ", "k", "=", "kernel_type", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_dim", ")", ":", "\n", "        ", "k", "=", "k", "*", "kernel_type", "(", "input_dim", "=", "1", ",", "active_dims", "=", "[", "i", "]", ")", "\n", "", "return", "k", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.data": [[35, 37], ["numpy.ones", "numpy.ones"], "function", ["None"], ["", "def", "data", "(", "n_dim", ":", "int", ")", ":", "\n", "    ", "return", "np", ".", "ones", "(", "[", "3", ",", "n_dim", "]", ")", ",", "np", ".", "ones", "(", "[", "3", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.integral_bounds": [[39, 41], ["None"], "function", ["None"], ["", "def", "integral_bounds", "(", "n_dim", ":", "int", ")", ":", "\n", "    ", "return", "n_dim", "*", "[", "(", "0", ",", "1", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_lebesgue": [[43, 45], ["emukit.quadrature.measures.LebesgueMeasure.from_bounds"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "def", "measure_lebesgue", "(", "n_dim", ":", "int", ")", ":", "\n", "    ", "return", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "n_dim", "*", "[", "(", "0", ",", "1", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_gaussian": [[47, 49], ["emukit.quadrature.measures.GaussianMeasure", "numpy.ones"], "function", ["None"], ["", "def", "measure_gaussian", "(", "n_dim", ":", "int", ")", ":", "\n", "    ", "return", "GaussianMeasure", "(", "mean", "=", "np", ".", "ones", "(", "n_dim", ")", ",", "variance", "=", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2": [[52, 55], ["None"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "dim2", "(", ")", ":", "\n", "    ", "return", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim1": [[57, 60], ["None"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "dim1", "(", ")", ":", "\n", "    ", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_brownian": [[63, 67], ["kernel_type"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_brownian", "(", "dim1", ")", ":", "\n", "    ", "kernel_type", "=", "GPy", ".", "kern", ".", "Brownian", "\n", "return", "kernel_type", "(", "input_dim", "=", "dim1", ")", ",", "kernel_type", ",", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_matern32": [[69, 73], ["kernel_type"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_matern32", "(", "dim1", ")", ":", "\n", "    ", "kernel_type", "=", "GPy", ".", "kern", ".", "Matern32", "\n", "return", "kernel_type", "(", "input_dim", "=", "dim1", ")", ",", "kernel_type", ",", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_matern52": [[75, 79], ["kernel_type"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_matern52", "(", "dim1", ")", ":", "\n", "    ", "kernel_type", "=", "GPy", ".", "kern", ".", "Matern52", "\n", "return", "kernel_type", "(", "input_dim", "=", "dim1", ")", ",", "kernel_type", ",", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_rbf": [[82, 86], ["kernel_type"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_rbf", "(", "dim2", ")", ":", "\n", "    ", "kernel_type", "=", "GPy", ".", "kern", ".", "RBF", "\n", "return", "kernel_type", "(", "input_dim", "=", "dim2", ")", ",", "kernel_type", ",", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_prodbrownian": [[88, 92], ["test_gpy_wrappers_quadrature.get_prod_kernel"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_prod_kernel"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_prodbrownian", "(", "dim2", ")", ":", "\n", "    ", "kernel_type", "=", "GPy", ".", "kern", ".", "Brownian", "\n", "return", "get_prod_kernel", "(", "kernel_type", ",", "dim2", ")", ",", "kernel_type", ",", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_prodmatern32": [[94, 98], ["test_gpy_wrappers_quadrature.get_prod_kernel"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_prod_kernel"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_prodmatern32", "(", "dim2", ")", ":", "\n", "    ", "kernel_type", "=", "GPy", ".", "kern", ".", "Matern32", "\n", "return", "get_prod_kernel", "(", "kernel_type", ",", "dim2", ")", ",", "kernel_type", ",", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_prodmatern52": [[100, 104], ["test_gpy_wrappers_quadrature.get_prod_kernel"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_prod_kernel"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gpy_prodmatern52", "(", "dim2", ")", ":", "\n", "    ", "kernel_type", "=", "GPy", ".", "kern", ".", "Matern52", "\n", "return", "get_prod_kernel", "(", "kernel_type", ",", "dim2", ")", ",", "kernel_type", ",", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict": [[106, 116], ["test_gpy_wrappers_quadrature.data", "test_gpy_wrappers_quadrature.dim2", "test_gpy_wrappers_quadrature.measure_lebesgue", "test_gpy_wrappers_quadrature.gpy_rbf", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy", "emukit.quadrature.kernels.QuadratureRBFLebesgueMeasure", "test_gpy_wrappers_quadrature.dim2", "test_gpy_wrappers_quadrature.measure_gaussian", "test_gpy_wrappers_quadrature.gpy_rbf", "emukit.model_wrappers.gpy_quadrature_wrappers.RBFGPy", "emukit.quadrature.kernels.QuadratureRBFGaussianMeasure", "test_gpy_wrappers_quadrature.dim1", "test_gpy_wrappers_quadrature.measure_lebesgue", "test_gpy_wrappers_quadrature.gpy_brownian", "emukit.model_wrappers.gpy_quadrature_wrappers.BrownianGPy", "emukit.quadrature.kernels.QuadratureBrownianLebesgueMeasure", "test_gpy_wrappers_quadrature.dim2", "test_gpy_wrappers_quadrature.measure_lebesgue", "test_gpy_wrappers_quadrature.gpy_prodbrownian", "emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy", "emukit.quadrature.kernels.QuadratureProductBrownianLebesgueMeasure", "test_gpy_wrappers_quadrature.dim2", "test_gpy_wrappers_quadrature.measure_lebesgue", "test_gpy_wrappers_quadrature.gpy_prodmatern32", "emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern32GPy", "emukit.quadrature.kernels.QuadratureProductMatern32LebesgueMeasure", "test_gpy_wrappers_quadrature.dim1", "test_gpy_wrappers_quadrature.measure_lebesgue", "test_gpy_wrappers_quadrature.gpy_matern32", "emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern32GPy", "emukit.quadrature.kernels.QuadratureProductMatern32LebesgueMeasure", "test_gpy_wrappers_quadrature.dim2", "test_gpy_wrappers_quadrature.measure_lebesgue", "test_gpy_wrappers_quadrature.gpy_prodmatern52", "emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern52GPy", "emukit.quadrature.kernels.QuadratureProductMatern52LebesgueMeasure", "test_gpy_wrappers_quadrature.dim1", "test_gpy_wrappers_quadrature.measure_lebesgue", "test_gpy_wrappers_quadrature.gpy_matern52", "emukit.model_wrappers.gpy_quadrature_wrappers.ProductMatern52GPy", "emukit.quadrature.kernels.QuadratureProductMatern52LebesgueMeasure"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.data", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_rbf", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_gaussian", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_rbf", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim1", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_brownian", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_prodbrownian", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_prodmatern32", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim1", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_matern32", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim2", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_prodmatern52", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.dim1", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.measure_lebesgue", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.gpy_matern52"], ["", "def", "get_wrapper_dict", "(", "n_dim", ",", "measure", ",", "gpy_kern", ",", "gpy_kernel_wrapper_type", ",", "emukit_qkernel_type", ")", ":", "\n", "    ", "gpy_kernel", ",", "gpy_kernel_type", ",", "is_prod", "=", "gpy_kern", "\n", "return", "{", "\n", "\"data\"", ":", "data", "(", "n_dim", ")", ",", "\n", "\"measure\"", ":", "measure", "(", "n_dim", ")", ",", "\n", "\"gpy_kernel\"", ":", "gpy_kernel", ",", "\n", "\"gpy_kernel_type\"", ":", "gpy_kernel_type", ",", "\n", "\"is_prod\"", ":", "is_prod", ",", "\n", "\"gpy_kernel_wrapper_type\"", ":", "gpy_kernel_wrapper_type", ",", "\n", "\"emukit_qkernel_type\"", ":", "emukit_qkernel_type", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.wrapper_rbf_1": [[120, 123], ["test_gpy_wrappers_quadrature.get_wrapper_dict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wrapper_rbf_1", "(", "dim2", ",", "gpy_rbf", ")", ":", "\n", "    ", "return", "get_wrapper_dict", "(", "dim2", ",", "measure_lebesgue", ",", "gpy_rbf", ",", "RBFGPy", ",", "QuadratureRBFLebesgueMeasure", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.wrapper_rbf_2": [[125, 128], ["test_gpy_wrappers_quadrature.get_wrapper_dict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wrapper_rbf_2", "(", "dim2", ",", "gpy_rbf", ")", ":", "\n", "    ", "return", "get_wrapper_dict", "(", "dim2", ",", "measure_gaussian", ",", "gpy_rbf", ",", "RBFGPy", ",", "QuadratureRBFGaussianMeasure", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.wrapper_brownian_1": [[131, 134], ["test_gpy_wrappers_quadrature.get_wrapper_dict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wrapper_brownian_1", "(", "dim1", ",", "gpy_brownian", ")", ":", "\n", "    ", "return", "get_wrapper_dict", "(", "dim1", ",", "measure_lebesgue", ",", "gpy_brownian", ",", "BrownianGPy", ",", "QuadratureBrownianLebesgueMeasure", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.wrapper_brownian_2": [[136, 140], ["test_gpy_wrappers_quadrature.get_wrapper_dict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wrapper_brownian_2", "(", "dim2", ",", "gpy_prodbrownian", ")", ":", "\n", "    ", "return", "get_wrapper_dict", "(", "\n", "dim2", ",", "measure_lebesgue", ",", "gpy_prodbrownian", ",", "ProductBrownianGPy", ",", "QuadratureProductBrownianLebesgueMeasure", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.wrapper_matern32_1": [[144, 148], ["test_gpy_wrappers_quadrature.get_wrapper_dict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wrapper_matern32_1", "(", "dim2", ",", "gpy_prodmatern32", ")", ":", "\n", "    ", "return", "get_wrapper_dict", "(", "\n", "dim2", ",", "measure_lebesgue", ",", "gpy_prodmatern32", ",", "ProductMatern32GPy", ",", "QuadratureProductMatern32LebesgueMeasure", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.wrapper_matern32_2": [[151, 155], ["test_gpy_wrappers_quadrature.get_wrapper_dict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wrapper_matern32_2", "(", "dim1", ",", "gpy_matern32", ")", ":", "\n", "    ", "return", "get_wrapper_dict", "(", "\n", "dim1", ",", "measure_lebesgue", ",", "gpy_matern32", ",", "ProductMatern32GPy", ",", "QuadratureProductMatern32LebesgueMeasure", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.wrapper_matern52_1": [[159, 163], ["test_gpy_wrappers_quadrature.get_wrapper_dict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wrapper_matern52_1", "(", "dim2", ",", "gpy_prodmatern52", ")", ":", "\n", "    ", "return", "get_wrapper_dict", "(", "\n", "dim2", ",", "measure_lebesgue", ",", "gpy_prodmatern52", ",", "ProductMatern52GPy", ",", "QuadratureProductMatern52LebesgueMeasure", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.wrapper_matern52_2": [[166, 170], ["test_gpy_wrappers_quadrature.get_wrapper_dict"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.get_wrapper_dict"], ["", "@", "pytest", ".", "fixture", "\n", "def", "wrapper_matern52_2", "(", "dim1", ",", "gpy_matern52", ")", ":", "\n", "    ", "return", "get_wrapper_dict", "(", "\n", "dim1", ",", "measure_lebesgue", ",", "gpy_matern52", ",", "ProductMatern52GPy", ",", "QuadratureProductMatern52LebesgueMeasure", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.test_create_emukit_model_from_gpy_model_types": [[185, 202], ["pytest.mark.parametrize", "GPy.models.GPRegression", "emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"wrapper\"", ",", "gpy_test_list", ")", "\n", "def", "test_create_emukit_model_from_gpy_model_types", "(", "wrapper", ")", ":", "\n", "\n", "    ", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "kernel", "=", "wrapper", "[", "\"gpy_kernel\"", "]", ",", "X", "=", "wrapper", "[", "\"data\"", "]", "[", "0", "]", ",", "Y", "=", "wrapper", "[", "\"data\"", "]", "[", "1", "]", ")", "\n", "emukit_gp", "=", "create_emukit_model_from_gpy_model", "(", "gpy_model", "=", "gpy_model", ",", "measure", "=", "wrapper", "[", "\"measure\"", "]", ")", "\n", "\n", "assert", "isinstance", "(", "emukit_gp", ".", "kern", ",", "wrapper", "[", "\"emukit_qkernel_type\"", "]", ")", "\n", "assert", "isinstance", "(", "emukit_gp", ".", "kern", ".", "kern", ",", "wrapper", "[", "\"gpy_kernel_wrapper_type\"", "]", ")", "\n", "\n", "# product kernel", "\n", "if", "wrapper", "[", "\"is_prod\"", "]", ":", "\n", "        ", "assert", "isinstance", "(", "wrapper", "[", "\"gpy_kernel\"", "]", ",", "GPy", ".", "kern", ".", "Prod", ")", "\n", "for", "k", "in", "wrapper", "[", "\"gpy_kernel\"", "]", ".", "parameters", ":", "\n", "            ", "assert", "isinstance", "(", "k", ",", "wrapper", "[", "\"gpy_kernel_type\"", "]", ")", "\n", "assert", "k", ".", "input_dim", "==", "1", "\n", "", "", "else", ":", "\n", "        ", "assert", "isinstance", "(", "emukit_gp", ".", "gpy_model", ".", "kern", ",", "wrapper", "[", "\"gpy_kernel_type\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.test_create_emukit_model_from_gpy_model_raises_warns": [[204, 219], ["GPy.kern.RBF", "GPy.models.GPRegression", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "pytest.raises", "emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model", "pytest.warns", "emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model", "numpy.ones", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_quadrature_wrappers.create_emukit_model_from_gpy_model"], ["", "", "def", "test_create_emukit_model_from_gpy_model_raises_warns", "(", ")", ":", "\n", "    ", "input_dim", "=", "2", "\n", "gpy_kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "input_dim", ")", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "kernel", "=", "gpy_kernel", ",", "X", "=", "np", ".", "ones", "(", "[", "3", ",", "input_dim", "]", ")", ",", "Y", "=", "np", ".", "ones", "(", "[", "3", ",", "1", "]", ")", ")", "\n", "\n", "bounds", "=", "input_dim", "*", "[", "(", "0", ",", "1", ")", "]", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "bounds", ")", "\n", "\n", "# Neither measure nor bounds given", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "create_emukit_model_from_gpy_model", "(", "gpy_model", "=", "gpy_model", ")", "\n", "\n", "# both measure and bounds are given. Bounds will be ignored.", "\n", "", "with", "pytest", ".", "warns", "(", "UserWarning", ")", ":", "\n", "        ", "create_emukit_model_from_gpy_model", "(", "gpy_model", "=", "gpy_model", ",", "integral_bounds", "=", "bounds", ",", "measure", "=", "measure", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.test_base_gp_gpy_raises": [[221, 236], ["test_gpy_wrappers_quadrature.data", "emukit.model_wrappers.gpy_quadrature_wrappers.ProductBrownianGPy", "emukit.quadrature.measures.LebesgueMeasure.from_bounds", "emukit.quadrature.kernels.QuadratureProductBrownianLebesgueMeasure", "GPy.models.GPRegression", "pytest.raises", "emukit.model_wrappers.gpy_quadrature_wrappers.BaseGaussianProcessGPy"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.test_gpy_wrappers_quadrature.data", "home.repos.pwc.inspect_result.amzn_emukit.measures.lebesgue_measure.LebesgueMeasure.from_bounds"], ["", "", "def", "test_base_gp_gpy_raises", "(", "gpy_prodbrownian", ")", ":", "\n", "    ", "incompatible_offset", "=", "-", "3", "\n", "\n", "n_dim", "=", "2", "\n", "dat", "=", "data", "(", "n_dim", "=", "n_dim", ")", "\n", "kern", "=", "ProductBrownianGPy", "(", "variance", "=", "1.0", ",", "input_dim", "=", "n_dim", ",", "offset", "=", "incompatible_offset", ")", "\n", "measure", "=", "LebesgueMeasure", ".", "from_bounds", "(", "bounds", "=", "n_dim", "*", "[", "(", "0", ",", "1", ")", "]", ")", "\n", "qkern", "=", "QuadratureProductBrownianLebesgueMeasure", "(", "brownian_kernel", "=", "kern", ",", "measure", "=", "measure", ")", "\n", "\n", "# this GPy model and hence the emukit base_gp wrapper are not compatible with the kernel wrapper", "\n", "# for offsets other than zero.", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "kernel", "=", "kern", ".", "gpy_brownian", ",", "X", "=", "dat", "[", "0", "]", ",", "Y", "=", "dat", "[", "1", "]", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "BaseGaussianProcessGPy", "(", "kern", "=", "qkern", ",", "gpy_model", "=", "gpy_model", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.continuous_parameter.ContinuousParameter.__init__": [[17, 26], ["parameter.Parameter.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "str", ",", "min_value", ":", "float", ",", "max_value", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        :param name: Name of parameter\n        :param min_value: Minimum value the parameter is allowed to take\n        :param max_value: Maximum value the parameter is allowed to take\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", ")", "\n", "self", ".", "min", "=", "min_value", "\n", "self", ".", "max", "=", "max_value", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.continuous_parameter.ContinuousParameter.__str__": [[27, 29], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "f\"<ContinuousParameter: {self.name} {self.bounds}>\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.continuous_parameter.ContinuousParameter.__repr__": [[30, 32], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"ContinuousParameter({self.name}, {self.min}, {self.max})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.continuous_parameter.ContinuousParameter.check_in_domain": [[33, 48], ["isinstance", "numpy.all", "x.ravel.ravel.ravel", "ValueError"], "methods", ["None"], ["", "def", "check_in_domain", "(", "self", ",", "x", ":", "Union", "[", "np", ".", "ndarray", ",", "float", "]", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Checks if all the points in x lie between the min and max allowed values\n\n        :param x:    1d numpy array of points to check\n                  or 2d numpy array with shape (n_points, 1) of points to check\n                  or float of single point to check\n        :return: A boolean value which indicates whether all points lie in the domain\n        \"\"\"", "\n", "if", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "if", "x", ".", "ndim", "==", "2", "and", "x", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "                ", "x", "=", "x", ".", "ravel", "(", ")", "\n", "", "elif", "x", ".", "ndim", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"Expected x shape (n,) or (n, 1), actual is {}\"", ".", "format", "(", "x", ".", "shape", ")", ")", "\n", "", "", "return", "np", ".", "all", "(", "[", "self", ".", "min", "<=", "x", ",", "x", "<=", "self", ".", "max", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.continuous_parameter.ContinuousParameter.bounds": [[49, 55], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bounds", "(", "self", ")", "->", "List", "[", "Tuple", "]", ":", "\n", "        ", "\"\"\"\n        Returns a list containing one tuple of minimum and maximum values parameter can take\n        \"\"\"", "\n", "return", "[", "(", "self", ".", "min", ",", "self", ".", "max", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.continuous_parameter.ContinuousParameter.sample_uniform": [[56, 64], ["numpy.random.uniform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform"], ["", "def", "sample_uniform", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates multiple uniformly distributed random parameter points.\n\n        :param point_count: number of data points to generate.\n        :returns: Generated points with shape (point_count, num_features)\n        \"\"\"", "\n", "return", "np", ".", "random", ".", "uniform", "(", "low", "=", "self", ".", "min", ",", "high", "=", "self", ".", "max", ",", "size", "=", "(", "point_count", ",", "1", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.__init__": [[15, 24], ["numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "categories", ":", "List", "[", "str", "]", ",", "encodings", ":", "List", ")", ":", "\n", "        ", "\"\"\"\n        Initializes an instance of Encoding class\n\n        :param categories: List of categories to encode\n        :param encodings: List of corresponding encodings\n        \"\"\"", "\n", "self", ".", "categories", "=", "categories", "\n", "self", ".", "encodings", "=", "np", ".", "array", "(", "encodings", ",", "dtype", "=", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.dimension": [[31, 37], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dimension", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Dimension of the encoding\n        \"\"\"", "\n", "return", "self", ".", "encodings", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.round": [[38, 58], ["numpy.row_stack", "ValueError", "ValueError", "encodings.Encoding.round_row", "x_rounded.append", "str"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.encodings.OrdinalEncoding.round_row"], ["", "def", "round", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Rounds each row in 2d array x to represent one of encodings.\n\n        :param x: A 2d array to be rounded\n        :returns: An array where each row represents an encoding\n                  that is closest to the corresponding row in x\n        \"\"\"", "\n", "if", "x", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Expected 2d array, got \"", "+", "str", "(", "x", ".", "ndim", ")", ")", "\n", "\n", "", "if", "x", ".", "shape", "[", "1", "]", "!=", "self", ".", "dimension", ":", "\n", "            ", "raise", "ValueError", "(", "\"Encoding dimension mismatch, expected {} got {}\"", ".", "format", "(", "self", ".", "dimension", ",", "x", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "x_rounded", "=", "[", "]", "\n", "for", "row", "in", "x", ":", "\n", "            ", "row_rounded", "=", "self", ".", "round_row", "(", "row", ")", "\n", "x_rounded", ".", "append", "(", "row_rounded", ")", "\n", "\n", "", "return", "np", ".", "row_stack", "(", "x_rounded", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.round_row": [[59, 71], ["numpy.linalg.norm().argmin", "encodings.Encoding.encodings[].copy", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "round_row", "(", "self", ",", "x_row", ")", ":", "\n", "        ", "\"\"\"\n        Rounds the given row. See \"round\" method docsting for details.\n\n        When subclassing Encoding, it is best to override this method instead of \"round\".\n\n        :param x_row: A row to round.\n        :returns: A rounded row.\n        \"\"\"", "\n", "\n", "idx", "=", "(", "np", ".", "linalg", ".", "norm", "(", "self", ".", "encodings", "-", "x_row", ",", "axis", "=", "1", ")", ")", ".", "argmin", "(", ")", "\n", "return", "self", ".", "encodings", "[", "idx", "]", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_category": [[72, 86], ["numpy.where", "numpy.all", "ValueError", "len", "numpy.array"], "methods", ["None"], ["", "def", "get_category", "(", "self", ",", "encoding", ":", "Union", "[", "List", ",", "np", ".", "ndarray", "]", ")", "->", "str", ":", "\n", "        ", "\"\"\"\n        Gets the category corresponding to the encoding.\n\n        :param encoding: An encoded value.\n        :returns: A category.\n        \"\"\"", "\n", "\n", "indices", "=", "np", ".", "where", "(", "np", ".", "all", "(", "self", ".", "encodings", "==", "np", ".", "array", "(", "encoding", ")", ",", "axis", "=", "1", ")", ")", "\n", "if", "len", "(", "indices", ")", "==", "0", "or", "indices", "[", "0", "]", ".", "size", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Given encoding {} does not correspond to any category\"", ".", "format", "(", "encoding", ")", ")", "\n", "\n", "", "category_idx", "=", "indices", "[", "0", "]", "[", "0", "]", "\n", "return", "self", ".", "categories", "[", "category_idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_encoding": [[87, 100], ["encodings.Encoding.encodings[].tolist", "encodings.Encoding.categories.index", "ValueError", "str"], "methods", ["None"], ["", "def", "get_encoding", "(", "self", ",", "category", ":", "str", ")", "->", "List", ":", "\n", "        ", "\"\"\"\n        Gets the encoding corresponding to the category.\n\n        :param category: A category.\n        :returns: An encoding as a list.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "index", "=", "self", ".", "categories", ".", "index", "(", "category", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown category {}\"", "+", "str", "(", "category", ")", ")", "\n", "\n", "", "return", "self", ".", "encodings", "[", "index", "]", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.OneHotEncoding.__init__": [[103, 121], ["enumerate", "encodings.Encoding.__init__", "encodings.append", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "categories", ":", "List", ")", ":", "\n", "        ", "\"\"\"\n        Initializes an instance of OneHotEncoding class\n        and generates one hot encodings for given categories.\n        Categories are assigned 1's in the order they appear in the provided list.\n\n        An example reference about one hot encoding:\n        https://www.kaggle.com/dansbecker/using-categorical-data-with-one-hot-encoding\n\n        :param categories: List of categories to encode\n        \"\"\"", "\n", "encodings", "=", "[", "]", "\n", "for", "i", ",", "_", "in", "enumerate", "(", "categories", ")", ":", "\n", "            ", "e", "=", "[", "0", "]", "*", "len", "(", "categories", ")", "\n", "e", "[", "i", "]", "=", "1", "\n", "encodings", ".", "append", "(", "e", ")", "\n", "\n", "", "super", "(", "OneHotEncoding", ",", "self", ")", ".", "__init__", "(", "categories", ",", "encodings", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.OneHotEncoding.round_row": [[122, 134], ["x_row.argmax", "numpy.zeros"], "methods", ["None"], ["", "def", "round_row", "(", "self", ",", "x_row", ")", ":", "\n", "        ", "\"\"\"\n        Rounds the given row. The highest value is rounded to 1\n        all other values are rounded to 0\n\n        :param x_row: A row to round.\n        :returns: A rounded row.\n        \"\"\"", "\n", "idx", "=", "x_row", ".", "argmax", "(", ")", "\n", "row_rounded", "=", "np", ".", "zeros", "(", "x_row", ".", "shape", ")", "\n", "row_rounded", "[", "idx", "]", "=", "1", "\n", "return", "row_rounded", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.OrdinalEncoding.__init__": [[137, 152], ["encodings.Encoding.__init__", "enumerate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "categories", ":", "List", ")", ":", "\n", "        ", "\"\"\"\n        Initializes an instance of OrdinalEncoding class\n        and generates ordinal encodings for given categories.\n        The encoding is a list of integer numbers [1, .. , n]\n        where n is the number of categories.\n        Categories are assigned codes in the order they appear in the provided list.\n\n        Note that encoding categories with ordinal encoding is effectively the same as\n        treating them as a discrete variable.\n\n        :param categories: List of categories to encode\n        \"\"\"", "\n", "encodings", "=", "[", "[", "i", "+", "1", "]", "for", "i", ",", "_", "in", "enumerate", "(", "categories", ")", "]", "\n", "super", "(", "OrdinalEncoding", ",", "self", ")", ".", "__init__", "(", "categories", ",", "encodings", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.OrdinalEncoding.round_row": [[153, 169], ["int", "numpy.array", "ValueError", "len", "len", "round", "str"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "round_row", "(", "self", ",", "x_row", ")", ":", "\n", "# since we used just one column for this encoding", "\n", "# x_row should contain a single number", "\n", "\n", "        ", "if", "x_row", ".", "shape", "[", "0", "]", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Expected a single valued array, got array of {}\"", "+", "str", "(", "x_row", ".", "shape", ")", ")", "\n", "\n", "", "x_value", "=", "x_row", "[", "0", "]", "\n", "if", "x_value", "<", "1", ":", "\n", "            ", "x_value", "=", "1", "\n", "", "if", "x_value", ">", "len", "(", "self", ".", "categories", ")", ":", "\n", "            ", "x_value", "=", "len", "(", "self", ".", "categories", ")", "\n", "\n", "", "rounded_value", "=", "int", "(", "round", "(", "x_value", ")", ")", "\n", "\n", "return", "np", ".", "array", "(", "[", "rounded_value", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.event_handler.EventHandler.__call__": [[12, 15], ["f"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "for", "f", "in", "self", ":", "\n", "            ", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.event_handler.EventHandler.__repr__": [[16, 18], ["list.__repr__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.__repr__"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"Event(%s)\"", "%", "list", ".", "__repr__", "(", "self", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.__init__": [[22, 37], ["parameter.Parameter.__init__", "bandit_parameter.BanditParameter._create_parameters", "isinstance", "ValueError", "ValueError", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter._create_parameters"], ["def", "__init__", "(", "self", ",", "name", ":", "str", ",", "domain", ":", "np", ".", "ndarray", ",", "sub_parameter_names", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param name: Name of parameter\n        :param domain: List of tuples representing valid values\n        :param sub_parameter_names: List of parameters, must correspond to domain if provided,\n            otherwise will be reflected from the domain\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", ")", "\n", "if", "not", "isinstance", "(", "domain", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Domain must be a 2D np.ndarray, got type: {}\"", ".", "format", "(", "type", "(", "domain", ")", ")", ")", "\n", "", "if", "not", "domain", ".", "ndim", "==", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Domain must be a 2D np.ndarray, got dimensions: {}\"", ".", "format", "(", "domain", ".", "shape", ")", ")", "\n", "", "self", ".", "domain", "=", "domain", "# each column is homogeneously typed thanks to numpy.ndarray", "\n", "self", ".", "parameters", "=", "self", ".", "_create_parameters", "(", "domain", ",", "sub_parameter_names", ")", "\n", "self", ".", "_sub_parameter_names", "=", "sub_parameter_names", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.__str__": [[38, 44], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "msg", "=", "f\"<BanditParameter: {self.name} ndim={self.domain.ndim}\"", "\n", "if", "self", ".", "_sub_parameter_names", ":", "\n", "            ", "msg", "=", "msg", "+", "f\" ({','.join(self._sub_parameter_names)})\"", "\n", "", "msg", "=", "msg", "+", "\">\"", "\n", "return", "msg", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.__repr__": [[45, 47], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"BanditParameter({self.name}, {self.domain}, {self._sub_parameter_names})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter._create_parameter_names": [[48, 56], ["range"], "methods", ["None"], ["", "def", "_create_parameter_names", "(", "self", ",", "domain", ":", "np", ".", "ndarray", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"\n        Create names for sub-parameters, used when names are not already provided.\n\n        :param domain: 2D array (n by p) of valid states, each row represents one valid state\n        :returns: List of names\n        \"\"\"", "\n", "return", "[", "f\"{self.name}_{i}\"", "for", "i", "in", "range", "(", "domain", ".", "shape", "[", "1", "]", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter._create_parameters": [[57, 86], ["enumerate", "bandit_parameter.BanditParameter._create_parameter_names", "len", "ValueError", "numpy.unique", "numpy.issubdtype", "parameters.append", "discrete_parameter.DiscreteParameter", "encodings.OneHotEncoding", "categorical_parameter.CategoricalParameter", "NotImplementedError", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter._create_parameter_names"], ["", "def", "_create_parameters", "(", "self", ",", "domain", ":", "np", ".", "ndarray", ",", "parameter_names", ":", "Optional", "[", "List", "[", "str", "]", "]", ")", "->", "List", "[", "Parameter", "]", ":", "\n", "        ", "\"\"\"\n        Reflect parameters from domain.\n\n        :param domain: 2D array (n by p) of valid states, each row represents one valid state\n        :param parameter_names: Optional list of names for sub-parameters. If not provided,\n            sub-parameter names will be automatically generated.\n        :returns: List of sub-parameters\n        \"\"\"", "\n", "parameters", "=", "[", "]", "\n", "parameter_names", "=", "parameter_names", "if", "parameter_names", "else", "self", ".", "_create_parameter_names", "(", "domain", ")", "\n", "if", "domain", ".", "shape", "[", "1", "]", "!=", "len", "(", "parameter_names", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Provided domain shape {} != number of parameter names {}\"", ".", "format", "(", "domain", ".", "shape", "[", "1", "]", ",", "len", "(", "parameter_names", ")", ")", "\n", ")", "\n", "", "for", "cix", ",", "parameter_name", "in", "enumerate", "(", "parameter_names", ")", ":", "\n", "            ", "sub_param_domain", "=", "domain", "[", ":", ",", "cix", "]", "\n", "domain_unq", "=", "np", ".", "unique", "(", "sub_param_domain", ")", "\n", "if", "np", ".", "issubdtype", "(", "sub_param_domain", ".", "dtype", ",", "np", ".", "number", ")", ":", "# make discrete", "\n", "                ", "parameter", "=", "DiscreteParameter", "(", "name", "=", "parameter_name", ",", "domain", "=", "domain_unq", ")", "\n", "", "else", ":", "# make categorical", "\n", "                ", "encoding", "=", "OneHotEncoding", "(", "domain_unq", ")", "\n", "parameter", "=", "CategoricalParameter", "(", "name", "=", "parameter_name", ",", "encoding", "=", "encoding", ")", "\n", "raise", "NotImplementedError", "(", "\"Categorical sub-parameters not yet fully supported\"", ")", "\n", "# NOTE Categorical sub-parameters not yet implemented because inputs are", "\n", "# homogeneously typed np.ndarrays rather than structured arrays. In the future,", "\n", "# using structured arrays for all inputs may be more appropriate.", "\n", "", "parameters", ".", "append", "(", "parameter", ")", "\n", "", "return", "parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.model_parameters": [[87, 90], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "model_parameters", "(", "self", ")", "->", "List", ":", "\n", "        ", "return", "self", ".", "parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.check_in_domain": [[91, 124], ["isinstance", "isinstance", "x.ravel.ravel.ravel", "ValueError", "isinstance", "numpy.array", "numpy.array.any", "ValueError", "ValueError", "ValueError", "bandit_parameter.BanditParameter.check_in_domain", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "check_in_domain", "(", "self", ",", "x", ":", "Union", "[", "np", ".", "ndarray", ",", "float", ",", "list", "]", ")", "->", "Union", "[", "bool", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Checks if all the points in x lie in the domain set\n\n        :param x:    1d numpy array of points to check\n                  or 2d numpy array with shape (n_points, 1) of points to check\n                  or float of single point to check\n        :return: A boolean value which indicates whether all points lie in the domain\n        \"\"\"", "\n", "if", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "if", "x", ".", "ndim", "==", "2", "and", "x", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "                ", "x", "=", "x", ".", "ravel", "(", ")", "\n", "", "elif", "x", ".", "ndim", "==", "2", "and", "x", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "                ", "result", "=", "np", ".", "array", "(", "[", "self", ".", "check_in_domain", "(", "xx", ")", "for", "xx", "in", "x", "]", ")", "\n", "return", "result", ".", "any", "(", ")", "\n", "", "elif", "x", ".", "ndim", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"Expected x shape (n,) or (n, 1), actual is {}\"", ".", "format", "(", "x", ".", "shape", ")", ")", "\n", "", "if", "x", ".", "shape", "[", "0", "]", "!=", "self", ".", "domain", ".", "shape", "[", "1", "]", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Received x with dimension {}, expected dimension is {}\"", ".", "format", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "domain", ".", "shape", "[", "1", "]", ")", "\n", ")", "\n", "", "result", "=", "(", "self", ".", "domain", "==", "x", ")", ".", "all", "(", "axis", "=", "1", ")", ".", "any", "(", ")", "\n", "", "elif", "isinstance", "(", "x", ",", "float", ")", ":", "\n", "            ", "if", "self", ".", "domain", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Received x with dimension 1, expected dimension is {}\"", ".", "format", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "domain", ".", "shape", "[", "1", "]", ")", "\n", ")", "\n", "", "result", "=", "(", "self", ".", "domain", "==", "x", ")", ".", "all", "(", "axis", "=", "1", ")", ".", "any", "(", ")", "\n", "", "elif", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "            ", "result", "=", "(", "self", ".", "domain", "==", "x", ")", ".", "all", "(", "axis", "=", "1", ")", ".", "any", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unsupported type for point x: {}\"", ".", "format", "(", "type", "(", "x", ")", ")", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.bounds": [[125, 133], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bounds", "(", "self", ")", "->", "List", "[", "Tuple", "]", ":", "\n", "        ", "\"\"\"\n        Calculate the limiting bounds of the sub-parameters\n\n        :returns: a list containing tuples (min, max) for each constituent sub-parameter\n        \"\"\"", "\n", "return", "[", "pb", "for", "p", "in", "self", ".", "parameters", "for", "pb", "in", "p", ".", "bounds", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.round": [[134, 158], ["numpy.row_stack", "ValueError", "ValueError", "numpy.sqrt", "min", "x_rounded.append", "all", "ValueError", "numpy.sum", "bandit_parameter.BanditParameter.check_in_domain", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "round", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Rounds each row in x to represent a valid value for this bandit variable. Note that this\n        valid value may be 'far' from the suggested value.\n\n        :param x: A 2d array NxD to be rounded (D is len(self.parameters))\n        :returns: An array NxD where each row represents a value from the domain\n                  that is closest to the corresponding row in x\n        \"\"\"", "\n", "if", "x", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Expected 2d array, got {}\"", ".", "format", "(", "x", ".", "ndim", ")", ")", "\n", "\n", "", "if", "x", ".", "shape", "[", "1", "]", "!=", "self", ".", "dimension", ":", "\n", "            ", "raise", "ValueError", "(", "\"Expected {} column array, got {}\"", ".", "format", "(", "self", ".", "dimension", ",", "x", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "x_rounded", "=", "[", "]", "\n", "for", "row", "in", "x", ":", "\n", "            ", "dists", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "(", "self", ".", "domain", "-", "row", ")", "**", "2", ")", ")", "\n", "rounded_value", "=", "min", "(", "self", ".", "domain", ",", "key", "=", "lambda", "d", ":", "np", ".", "linalg", ".", "norm", "(", "d", "-", "row", ")", ")", "\n", "x_rounded", ".", "append", "(", "rounded_value", ")", "\n", "\n", "", "if", "not", "all", "(", "[", "self", ".", "check_in_domain", "(", "xr", ")", "for", "xr", "in", "x_rounded", "]", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Rounding error encountered, not all rounded values in domain.\"", ")", "\n", "", "return", "np", ".", "row_stack", "(", "x_rounded", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.dimension": [[159, 177], ["isinstance", "isinstance", "isinstance", "Exception"], "methods", ["None"], ["", "@", "property", "\n", "def", "dimension", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Calculate the aggregate dimensionality of the sub-parameters\n\n        :returns: dimensionality of the BanditParameter\n        \"\"\"", "\n", "d", "=", "0", "\n", "for", "p", "in", "self", ".", "parameters", ":", "\n", "            ", "if", "isinstance", "(", "p", ",", "ContinuousParameter", ")", ":", "\n", "                ", "d", "+=", "1", "\n", "", "elif", "isinstance", "(", "p", ",", "DiscreteParameter", ")", ":", "\n", "                ", "d", "+=", "1", "\n", "", "elif", "isinstance", "(", "p", ",", "CategoricalParameter", ")", ":", "\n", "                ", "d", "+=", "p", ".", "dimension", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\"Parameter type {type(p)} not supported.\"", ")", "\n", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.bandit_parameter.BanditParameter.sample_uniform": [[178, 186], ["numpy.random.choice"], "methods", ["None"], ["", "def", "sample_uniform", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates multiple uniformly distributed random parameter points.\n\n        :param point_count: number of data points to generate.\n        :returns: Generated points with shape (point_count, num_features)\n        \"\"\"", "\n", "return", "self", ".", "domain", "[", "np", ".", "random", ".", "choice", "(", "self", ".", "domain", ".", "shape", "[", "0", "]", ",", "point_count", ")", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.constraints.IConstraint.evaluate": [[10, 17], ["None"], "methods", ["None"], ["    ", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :param x: Array of shape (n_points x n_dims) containing input locations to evaluate constraint at\n        :return: Numpy array of shape (n_input,) where an element will be 1 if the corresponding input satisfies the\n                 constraint and zero if the constraint is violated\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.constraints.InequalityConstraint.__init__": [[20, 44], ["numpy.any", "numpy.any", "ValueError", "numpy.full", "numpy.full", "ValueError", "ValueError"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "lower_bound", ":", "np", ".", "ndarray", ",", "upper_bound", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "\"\"\"\n        :param lower_bound: Lower bound vector of size (n_constraint,). Can be -np.inf for one sided constraint\n        :param upper_bound: Upper bound vector of size (n_constraint,). Can be np.inf for one sided constraint\n        \"\"\"", "\n", "if", "(", "lower_bound", "is", "None", ")", "and", "(", "upper_bound", "is", "None", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Neither lower nor upper bounds is set, at least one must be specified\"", ")", "\n", "\n", "# Default lower bound to -infinity", "\n", "", "if", "lower_bound", "is", "None", ":", "\n", "            ", "lower_bound", "=", "np", ".", "full", "(", "[", "upper_bound", ".", "shape", "[", "0", "]", "]", ",", "-", "np", ".", "inf", ")", "\n", "\n", "# Default upper bound to +infinity", "\n", "", "if", "upper_bound", "is", "None", ":", "\n", "            ", "upper_bound", "=", "np", ".", "full", "(", "[", "lower_bound", ".", "shape", "[", "0", "]", "]", ",", "np", ".", "inf", ")", "\n", "\n", "", "if", "np", ".", "any", "(", "(", "lower_bound", "==", "-", "np", ".", "inf", ")", "&", "(", "upper_bound", "==", "np", ".", "inf", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"One or more inequality constraints are unbounded\"", ")", "\n", "\n", "", "if", "np", ".", "any", "(", "lower_bound", ">=", "upper_bound", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Lower bound is greater than or equal to upper bound for one or more constraints\"", ")", "\n", "\n", "", "self", ".", "lower_bound", "=", "lower_bound", "\n", "self", ".", "upper_bound", "=", "upper_bound", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.constraints.LinearInequalityConstraint.__init__": [[51, 67], ["constraints.InequalityConstraint.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "constraint_matrix", ":", "np", ".", "ndarray", ",", "lower_bound", ":", "np", ".", "ndarray", "=", "None", ",", "upper_bound", ":", "np", ".", "ndarray", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\n        :param constraint_matrix: (n_constraint, n_x_dims) matrix in b_lower <= Ax <= b_upper\n        :param lower_bound: Lower bound vector of size (n_constraint,). Can be -np.inf for one sided constraint\n        :param upper_bound: Upper bound vector of size (n_constraint,). Can be np.inf for one sided constraint\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "lower_bound", ",", "upper_bound", ")", "\n", "if", "(", "constraint_matrix", ".", "shape", "[", "0", "]", "!=", "lower_bound", ".", "shape", "[", "0", "]", ")", "or", "(", "constraint_matrix", ".", "shape", "[", "0", "]", "!=", "upper_bound", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Shape mismatch between constraint matrix {} and lower {} or upper {} bounds\"", ".", "format", "(", "\n", "constraint_matrix", ".", "shape", ",", "lower_bound", ".", "shape", ",", "upper_bound", ".", "shape", "\n", ")", "\n", ")", "\n", "\n", "", "self", ".", "constraint_matrix", "=", "constraint_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.constraints.LinearInequalityConstraint.evaluate": [[68, 86], ["numpy.all", "ValueError", "constraints.LinearInequalityConstraint.constraint_matrix.dot"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluate whether constraints are violated or satisfied at a set of x locations\n\n        :param x: Array of shape (n_points x n_dims) containing input locations to evaluate constraint at\n        :return: Numpy array of shape (n_points, ) where an element will be 1 if the corresponding input satisfies all\n                 constraints and zero if any constraint is violated\n        \"\"\"", "\n", "if", "self", ".", "constraint_matrix", ".", "shape", "[", "1", "]", "!=", "x", ".", "shape", "[", "1", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Dimension mismatch between constraint matrix (second dim {})\"", "\n", "+", "\" and input x (second dim {})\"", ".", "format", "(", "self", ".", "constraint_matrix", ".", "shape", "[", "1", "]", ",", "x", ".", "shape", "[", "1", "]", ")", "\n", ")", "\n", "\n", "# Transpose here is needed to handle input dimensions", "\n", "# that is, A is (n_const, n_dims) and x is (n_points, n_dims)", "\n", "", "ax", "=", "self", ".", "constraint_matrix", ".", "dot", "(", "x", ".", "T", ")", ".", "T", "\n", "return", "np", ".", "all", "(", "(", "ax", ">=", "self", ".", "lower_bound", ")", "&", "(", "ax", "<=", "self", ".", "upper_bound", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.constraints.NonlinearInequalityConstraint.__init__": [[93, 113], ["constraints.InequalityConstraint.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "constraint_function", ":", "Callable", ",", "\n", "lower_bound", ":", "np", ".", "ndarray", ",", "\n", "upper_bound", ":", "np", ".", "ndarray", ",", "\n", "jacobian_fun", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param constraint_function: function defining constraint in b_lower <= fun(x) <= b_upper.\n                                    Has signature f(x) -> array, shape(m,) where x is 1d and m is the number of constraints\n        :param lower_bound: Lower bound vector of size (n_constraint,). Can be -np.inf for one sided constraint\n        :param upper_bound: Upper bound vector of size (n_constraint,). Can be np.inf for one sided constraint\n        :param jacobian_fun: Function returning the jacobian of the constraint function. Optional, if not supplied\n                             the optimizer will use finite differences to calculate the gradients of the constraint\n        \"\"\"", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "lower_bound", ",", "upper_bound", ")", "\n", "\n", "self", ".", "fun", "=", "constraint_function", "\n", "self", ".", "jacobian_fun", "=", "jacobian_fun", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.constraints.NonlinearInequalityConstraint.evaluate": [[114, 124], ["numpy.array", "numpy.all", "constraints.NonlinearInequalityConstraint.fun"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluate whether constraints are violated or satisfied at a set of x locations\n\n        :param x: Array of shape (n_points x n_dims) containing input locations to evaluate constraint at\n        :return: Numpy array of shape (n_input,) where an element will be 1 if the corresponding input satisfies the\n                 constraint and zero if the constraint is violated\n        \"\"\"", "\n", "fun_x", "=", "np", ".", "array", "(", "[", "self", ".", "fun", "(", "x", ")", "for", "x", "in", "x", "]", ")", "\n", "return", "np", ".", "all", "(", "[", "fun_x", ">=", "self", ".", "lower_bound", ",", "fun_x", "<=", "self", ".", "upper_bound", "]", ",", "axis", "=", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.__init__": [[15, 29], ["parameter.Parameter.__init__", "range", "continuous_parameter.ContinuousParameter", "categorical_parameter.CategoricalParameter._cont_params.append", "numpy.min", "numpy.max", "str"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "name", ":", "str", ",", "encoding", ":", "Encoding", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", ")", "\n", "\n", "# ensure float just in case we were given integers", "\n", "self", ".", "encoding", "=", "encoding", "\n", "\n", "self", ".", "_cont_params", "=", "[", "]", "\n", "for", "column_idx", "in", "range", "(", "self", ".", "encodings", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "cont_param", "=", "ContinuousParameter", "(", "\n", "name", "+", "\"_\"", "+", "str", "(", "column_idx", ")", ",", "\n", "np", ".", "min", "(", "self", ".", "encodings", "[", ":", ",", "column_idx", "]", ")", ",", "\n", "np", ".", "max", "(", "self", ".", "encodings", "[", ":", ",", "column_idx", "]", ")", ",", "\n", ")", "\n", "self", ".", "_cont_params", ".", "append", "(", "cont_param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.__str__": [[30, 32], ["None"], "methods", ["None"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "f\"<CategoricalParameter: {self.name} n_cat={self.dimension}>\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.__repr__": [[33, 35], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"CategoricalParameter({self.name}, {self.encoding})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.encodings": [[36, 39], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "encodings", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "encoding", ".", "encodings", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.model_parameters": [[40, 43], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "model_parameters", "(", "self", ")", "->", "List", ":", "\n", "        ", "return", "self", ".", "_cont_params", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.round": [[44, 46], ["categorical_parameter.CategoricalParameter.encoding.round"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "round", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "self", ".", "encoding", ".", "round", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.bounds": [[47, 54], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bounds", "(", "self", ")", "->", "List", "[", "Tuple", "]", ":", "\n", "        ", "\"\"\"\n        Returns a list of tuples containing where each tuple contains the minimum and maximum of the variables used to\n        encode the categorical parameter..\n        \"\"\"", "\n", "return", "[", "(", "param", ".", "min", ",", "param", ".", "max", ")", "for", "param", "in", "self", ".", "_cont_params", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.dimension": [[55, 58], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dimension", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "encodings", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.check_in_domain": [[59, 76], ["enumerate", "ValueError", "param.check_in_domain"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "check_in_domain", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Verifies that given values lie within the parameter's domain\n\n        :param x: 2d numpy array with shape (points, encoding) of points to check\n        :return: A boolean value which indicates whether all points lie in the domain\n        \"\"\"", "\n", "if", "x", ".", "ndim", "!=", "2", "or", "x", ".", "shape", "[", "1", "]", "!=", "self", ".", "dimension", ":", "\n", "            ", "raise", "ValueError", "(", "\"Expected x shape (points, {}), actual is {}\"", ".", "format", "(", "self", ".", "dimension", ",", "x", ".", "shape", ")", ")", "\n", "\n", "", "for", "i", ",", "param", "in", "enumerate", "(", "self", ".", "_cont_params", ")", ":", "\n", "# First check if this particular parameter is in domain", "\n", "            ", "param_in_domain", "=", "param", ".", "check_in_domain", "(", "x", "[", ":", ",", "i", "]", ")", "\n", "if", "not", "param_in_domain", ":", "\n", "                ", "return", "False", "\n", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.categorical_parameter.CategoricalParameter.sample_uniform": [[77, 86], ["numpy.random.randint"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint"], ["", "def", "sample_uniform", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates multiple uniformly distributed random parameter points.\n\n        :param point_count: number of data points to generate.\n        :returns: Generated points with shape (point_count, num_features)\n        \"\"\"", "\n", "indices", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "self", ".", "encodings", ".", "shape", "[", "0", "]", ",", "point_count", ")", "\n", "return", "self", ".", "encodings", "[", "indices", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.discrete_parameter.DiscreteParameter.__init__": [[17, 24], ["parameter.Parameter.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "str", ",", "domain", ":", "Iterable", ")", ":", "\n", "        ", "\"\"\"\n        :param name: Name of parameter\n        :param domain: valid values the parameter can have\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", ")", "\n", "self", ".", "domain", "=", "domain", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.discrete_parameter.DiscreteParameter.__str__": [[25, 27], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "f\"<DiscreteParameter: {self.name} {self.bounds}>\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.discrete_parameter.DiscreteParameter.__repr__": [[28, 30], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"DiscreteParameter({self.name}, {self.domain})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.discrete_parameter.DiscreteParameter.check_in_domain": [[31, 50], ["numpy.isscalar", "set().issubset", "isinstance", "set", "set", "x.ravel.ravel.ravel", "ValueError"], "methods", ["None"], ["", "def", "check_in_domain", "(", "self", ",", "x", ":", "Union", "[", "np", ".", "ndarray", ",", "Iterable", ",", "float", "]", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Checks if the points in x are in the set of allowed values\n\n        :param x: 1d numpy array of points to check\n        :param x:    1d numpy array of points to check\n                  or 2d numpy array with shape (n_points, 1) of points to check\n                  or Iterable of points to check\n                  or float of single point to check\n        :return: A boolean indicating whether each point is in domain\n        \"\"\"", "\n", "if", "np", ".", "isscalar", "(", "x", ")", ":", "\n", "            ", "x", "=", "[", "x", "]", "\n", "", "elif", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "if", "x", ".", "ndim", "==", "2", "and", "x", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "                ", "x", "=", "x", ".", "ravel", "(", ")", "\n", "", "elif", "x", ".", "ndim", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"Expected x shape (n,) or (n, 1), actual is {}\"", ".", "format", "(", "x", ".", "shape", ")", ")", "\n", "", "", "return", "set", "(", "x", ")", ".", "issubset", "(", "set", "(", "self", ".", "domain", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.discrete_parameter.DiscreteParameter.bounds": [[51, 57], ["min", "max"], "methods", ["None"], ["", "@", "property", "\n", "def", "bounds", "(", "self", ")", "->", "List", "[", "Tuple", "]", ":", "\n", "        ", "\"\"\"\n        Returns a list containing one tuple of min and max values parameter can take\n        \"\"\"", "\n", "return", "[", "(", "min", "(", "self", ".", "domain", ")", ",", "max", "(", "self", ".", "domain", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.discrete_parameter.DiscreteParameter.round": [[58, 79], ["numpy.row_stack", "ValueError", "ValueError", "min", "x_rounded.append", "str", "abs"], "methods", ["None"], ["", "def", "round", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Rounds each row in x to represent a valid value for this discrete variable\n\n        :param x: A 2d array Nx1 to be rounded\n        :returns: An array Nx1 where each row represents a value from the domain\n                  that is closest to the corresponding row in x\n        \"\"\"", "\n", "if", "x", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Expected 2d array, got \"", "+", "str", "(", "x", ".", "ndim", ")", ")", "\n", "\n", "", "if", "x", ".", "shape", "[", "1", "]", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Expected single column array, got {}\"", ".", "format", "(", "x", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "x_rounded", "=", "[", "]", "\n", "for", "row", "in", "x", ":", "\n", "            ", "value", "=", "row", "[", "0", "]", "\n", "rounded_value", "=", "min", "(", "self", ".", "domain", ",", "key", "=", "lambda", "d", ":", "abs", "(", "d", "-", "value", ")", ")", "\n", "x_rounded", ".", "append", "(", "[", "rounded_value", "]", ")", "\n", "\n", "", "return", "np", ".", "row_stack", "(", "x_rounded", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.discrete_parameter.DiscreteParameter.sample_uniform": [[80, 89], ["numpy.random.randint", "len", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint"], ["", "def", "sample_uniform", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates multiple uniformly distributed random parameter points.\n\n        :param point_count: number of data points to generate.\n        :returns: Generated points with shape (point_count, num_features)\n        \"\"\"", "\n", "indices", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "domain", ")", ",", "point_count", ")", "\n", "return", "np", ".", "asarray", "(", "self", ".", "domain", ")", "[", "indices", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.discrete_parameter.InformationSourceParameter.__init__": [[92, 97], ["discrete_parameter.DiscreteParameter.__init__", "list", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_sources", ":", "int", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param n_sources: Number of information sources in the problem\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\"source\"", ",", "list", "(", "range", "(", "n_sources", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.__init__": [[18, 41], ["len", "ValueError", "ValueError", "isinstance", "len", "len", "set"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "parameters", ":", "List", ",", "constraints", ":", "Optional", "[", "List", "[", "IConstraint", "]", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Creates a new instance of a parameter space.\n\n        :param parameters: A list of parameters in the space.\n        :param constraints: A list of constraints on the input domain\n        \"\"\"", "\n", "self", ".", "_parameters", "=", "parameters", "\n", "\n", "if", "constraints", ":", "\n", "            ", "self", ".", "constraints", "=", "constraints", "\n", "", "else", ":", "\n", "            ", "self", ".", "constraints", "=", "[", "]", "\n", "\n", "# Check no more than one InformationSource parameter", "\n", "", "source_parameter", "=", "[", "param", "for", "param", "in", "self", ".", "parameters", "if", "isinstance", "(", "param", ",", "InformationSourceParameter", ")", "]", "\n", "if", "len", "(", "source_parameter", ")", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"More than one source parameter found\"", ")", "\n", "\n", "# Check uniqueness of parameter names", "\n", "", "names", "=", "self", ".", "parameter_names", "\n", "if", "not", "len", "(", "names", ")", "==", "len", "(", "set", "(", "names", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Parameter names are not unique\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.find_parameter_index_in_model": [[42, 56], ["ValueError", "list", "range"], "methods", ["None"], ["", "", "def", "find_parameter_index_in_model", "(", "self", ",", "parameter_name", ":", "str", ")", "->", "List", "[", "int", "]", ":", "\n", "        ", "\"\"\"\n        Find the indices of the encoding of the specified parameter in the input vector\n\n        :param parameter_name: Parameter name to find indices for\n        :return: List of indices\n        \"\"\"", "\n", "i_start", "=", "0", "\n", "for", "param", "in", "self", ".", "_parameters", ":", "\n", "            ", "if", "param", ".", "name", "==", "parameter_name", ":", "\n", "                ", "return", "list", "(", "range", "(", "i_start", ",", "i_start", "+", "param", ".", "dimension", ")", ")", "\n", "", "else", ":", "\n", "                ", "i_start", "+=", "param", ".", "dimension", "\n", "", "", "raise", "ValueError", "(", "\"Parameter {} not found\"", ".", "format", "(", "parameter_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.dimensionality": [[57, 60], ["sum"], "methods", ["None"], ["", "@", "property", "\n", "def", "dimensionality", "(", "self", ")", ":", "\n", "        ", "return", "sum", "(", "[", "p", ".", "dimension", "for", "p", "in", "self", ".", "_parameters", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.parameters": [[61, 68], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "parameters", "(", "self", ")", "->", "List", ":", "\n", "        ", "\"\"\"\n        Returns the list of parameters in the space.\n        \"\"\"", "\n", "\n", "return", "self", ".", "_parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.parameter_names": [[69, 76], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "parameter_names", "(", "self", ")", "->", "List", ":", "\n", "        ", "\"\"\"\n        Returns the list of names of parameters in the space.\n        \"\"\"", "\n", "\n", "return", "[", "p", ".", "name", "for", "p", "in", "self", ".", "_parameters", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_parameter_by_name": [[77, 89], ["ValueError"], "methods", ["None"], ["", "def", "get_parameter_by_name", "(", "self", ",", "name", ":", "str", ")", "->", "Parameter", ":", "\n", "        ", "\"\"\"\n        Returns parameter with the given name\n\n        :param name: Parameter name\n        :returns: A parameter object\n        \"\"\"", "\n", "\n", "for", "param", "in", "self", ".", "parameters", ":", "\n", "            ", "if", "param", ".", "name", "==", "name", ":", "\n", "                ", "return", "param", "\n", "", "", "raise", "ValueError", "(", "\"Parameter with name \"", "+", "name", "+", "\" not found.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_bounds": [[90, 102], ["list", "itertools.chain.from_iterable"], "methods", ["None"], ["", "def", "get_bounds", "(", "self", ")", "->", "List", "[", "Tuple", "]", ":", "\n", "        ", "\"\"\"\n        Returns a list of tuples containing the min and max value each parameter can take.\n\n        If the parameter space contains categorical variables, the min and max values correspond to each variable used\n        to encode the categorical variables.\n        \"\"\"", "\n", "\n", "# bounds is a list of lists", "\n", "bounds", "=", "[", "param", ".", "bounds", "for", "param", "in", "self", ".", "parameters", "]", "\n", "# Convert list of lists to one list", "\n", "return", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "bounds", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.round": [[103, 119], ["numpy.column_stack", "x_rounded.append", "param.round"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "round", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Rounds given values x to closest valid values within the space.\n\n        :param x: A 2d array of values to be rounded\n        :returns: A 2d array of rounded values\n        \"\"\"", "\n", "\n", "x_rounded", "=", "[", "]", "\n", "current_idx", "=", "0", "\n", "for", "param", "in", "self", ".", "parameters", ":", "\n", "            ", "param_columns", "=", "x", "[", ":", ",", "current_idx", ":", "(", "current_idx", "+", "param", ".", "dimension", ")", "]", "\n", "x_rounded", ".", "append", "(", "param", ".", "round", "(", "param_columns", ")", ")", "\n", "current_idx", "+=", "param", ".", "dimension", "\n", "\n", "", "return", "np", ".", "column_stack", "(", "x_rounded", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain": [[120, 146], ["sum", "numpy.ones", "ValueError", "numpy.all", "len", "param.check_in_domain", "range"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "check_points_in_domain", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Checks that each column of x lies in the domain of the corresponding parameter\n\n        :param x: 2d numpy array of points to check\n        :return: A 1d numpy array which contains a boolean indicating whether each point is in domain\n        \"\"\"", "\n", "len_encoding", "=", "sum", "(", "len", "(", "param", ".", "model_parameters", ")", "for", "param", "in", "self", ".", "parameters", ")", "\n", "if", "x", ".", "shape", "[", "1", "]", "!=", "len_encoding", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"x should have number of columns equal to the sum\"", "\n", "\"of all parameter encodings, expected {} actual {}\"", ".", "format", "(", "x", ".", "shape", "[", "1", "]", ",", "len_encoding", ")", "\n", ")", "\n", "\n", "", "in_domain", "=", "np", ".", "ones", "(", "x", ".", "shape", "[", "0", "]", ",", "dtype", "=", "bool", ")", "\n", "encoding_index", "=", "0", "\n", "for", "param", "in", "self", ".", "_parameters", ":", "\n", "# First check if this particular parameter is in domain", "\n", "            ", "param_in_domain", "=", "[", "\n", "param", ".", "check_in_domain", "(", "x", "[", "[", "point_ix", "]", ",", "encoding_index", ":", "(", "encoding_index", "+", "param", ".", "dimension", ")", "]", ")", "\n", "for", "point_ix", "in", "range", "(", "x", ".", "shape", "[", "0", "]", ")", "\n", "]", "\n", "# Set in_domain to be False if this parameter or any previous parameter is out of domain", "\n", "in_domain", "=", "np", ".", "all", "(", "[", "in_domain", ",", "param_in_domain", "]", ",", "axis", "=", "0", ")", "\n", "encoding_index", "+=", "param", ".", "dimension", "\n", "", "return", "in_domain", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.sample_uniform": [[147, 156], ["numpy.hstack", "param.sample_uniform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform"], ["", "def", "sample_uniform", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates multiple uniformly distributed random parameter points.\n\n        :param point_count: number of data points to generate.\n        :returns: Generated points with shape (point_count, num_features)\n        \"\"\"", "\n", "parameter_samples", "=", "[", "param", ".", "sample_uniform", "(", "point_count", ")", "for", "param", "in", "self", ".", "parameters", "]", "\n", "return", "np", ".", "hstack", "(", "parameter_samples", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.__init__": [[11, 13], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.__str__": [[14, 16], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "f\"<Parameter: {self.name}>\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.__repr__": [[17, 19], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"Parameter({self.name})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.dimension": [[20, 26], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dimension", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Gives the dimension of the parameter.\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.model_parameters": [[27, 33], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "model_parameters", "(", "self", ")", "->", "List", ":", "\n", "        ", "\"\"\"\n        Gives the list of single dimensional model parameters the parameter corresponds to.\n        \"\"\"", "\n", "return", "[", "self", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.bounds": [[34, 40], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bounds", "(", "self", ")", "->", "List", "[", "Tuple", "]", ":", "\n", "        ", "\"\"\"\n        Returns bounds of the parameter in a form of list of tuples\n        \"\"\"", "\n", "raise", "NotImplemented", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round": [[41, 49], ["None"], "methods", ["None"], ["", "def", "round", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Rounds the values of x to fit to the parameter domain, if needed.\n\n        :param x: 2d array of values to be rounded.\n        :returns: A 2d array of rounded values.\n        \"\"\"", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain": [[50, 58], ["None"], "methods", ["None"], ["", "def", "check_in_domain", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Verifies that given values lie within the parameter's domain\n\n        :param x: Value to be checked\n        :return: A boolean value which indicates whether all points lie in the domain\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform": [[59, 67], ["None"], "methods", ["None"], ["", "def", "sample_uniform", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates multiple uniformly distributed random parameter points.\n\n        :param point_count: number of data points to generate.\n        :returns: Generated points with shape (point_count, num_features)\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_model_free_designs.create_model_free_designs": [[7, 9], ["emukit.core.initial_designs.RandomDesign", "emukit.core.initial_designs.latin_design.LatinDesign", "emukit.core.initial_designs.sobol_design.SobolDesign"], "function", ["None"], ["def", "create_model_free_designs", "(", "space", ":", "ParameterSpace", ")", ":", "\n", "    ", "return", "[", "RandomDesign", "(", "space", ")", ",", "LatinDesign", "(", "space", ")", ",", "SobolDesign", "(", "space", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_model_free_designs.test_design_returns_correct_number_of_points": [[11, 23], ["emukit.core.ContinuousParameter", "emukit.core.ParameterSpace", "test_model_free_designs.create_model_free_designs", "design.get_samples", "all", "len", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_model_free_designs.create_model_free_designs", "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples"], ["", "def", "test_design_returns_correct_number_of_points", "(", ")", ":", "\n", "    ", "p", "=", "ContinuousParameter", "(", "\"c\"", ",", "1.0", ",", "5.0", ")", "\n", "space", "=", "ParameterSpace", "(", "[", "p", "]", ")", "\n", "points_count", "=", "5", "\n", "\n", "designs", "=", "create_model_free_designs", "(", "space", ")", "\n", "for", "design", "in", "designs", ":", "\n", "        ", "points", "=", "design", ".", "get_samples", "(", "points_count", ")", "\n", "\n", "assert", "points_count", "==", "len", "(", "points", ")", "\n", "columns_count", "=", "1", "\n", "assert", "all", "(", "[", "len", "(", "p", ")", "==", "columns_count", "for", "p", "in", "points", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_model_free_designs.test_design_with_mixed_domain": [[25, 40], ["emukit.core.ContinuousParameter", "emukit.core.CategoricalParameter", "emukit.core.DiscreteParameter", "emukit.core.ParameterSpace", "test_model_free_designs.create_model_free_designs", "design.get_samples", "all", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_model_free_designs.create_model_free_designs", "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples"], ["", "", "def", "test_design_with_mixed_domain", "(", "encoding", ")", ":", "\n", "    ", "p1", "=", "ContinuousParameter", "(", "\"p1\"", ",", "1.0", ",", "5.0", ")", "\n", "p2", "=", "CategoricalParameter", "(", "\"p2\"", ",", "encoding", ")", "\n", "p3", "=", "DiscreteParameter", "(", "\"p3\"", ",", "[", "1", ",", "2", ",", "5", ",", "6", "]", ")", "\n", "space", "=", "ParameterSpace", "(", "[", "p1", ",", "p2", ",", "p3", "]", ")", "\n", "points_count", "=", "5", "\n", "\n", "designs", "=", "create_model_free_designs", "(", "space", ")", "\n", "for", "design", "in", "designs", ":", "\n", "        ", "points", "=", "design", ".", "get_samples", "(", "points_count", ")", "\n", "\n", "assert", "points_count", "==", "len", "(", "points", ")", "\n", "# columns count is 1 for continuous plus 1 for discrete plus number of categories", "\n", "columns_count", "=", "1", "+", "1", "+", "len", "(", "encoding", ".", "categories", ")", "\n", "assert", "all", "(", "[", "len", "(", "p", ")", "==", "columns_count", "for", "p", "in", "points", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform": [[121, 124], ["numpy.linspace().reshape", "numpy.linspace", "numpy.product"], "methods", ["None"], ["@", "classmethod", "\n", "def", "uniform", "(", "cls", ",", "low", ",", "high", ",", "size", ")", ":", "\n", "        ", "return", "np", ".", "linspace", "(", "low", ",", "high", "-", "10e-8", ",", "np", ".", "product", "(", "size", ")", ")", ".", "reshape", "(", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint": [[125, 128], ["cls.uniform().astype", "cls.uniform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.uniform"], ["", "@", "classmethod", "\n", "def", "randint", "(", "cls", ",", "low", ",", "high", ",", "size", ")", ":", "\n", "        ", "return", "cls", ".", "uniform", "(", "low", ",", "high", ",", "size", ")", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.space_2d": [[18, 24], ["emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.ParameterSpace"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "space_2d", "(", ")", ":", "\n", "    ", "p1", "=", "ContinuousParameter", "(", "\"c\"", ",", "1.0", ",", "5.0", ")", "\n", "p2", "=", "ContinuousParameter", "(", "\"d\"", ",", "1.0", ",", "6.0", ")", "\n", "\n", "return", "ParameterSpace", "(", "[", "p1", ",", "p2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.space_3d_mixed": [[26, 32], ["emukit.core.ContinuousParameter", "emukit.core.DiscreteParameter", "emukit.core.CategoricalParameter", "emukit.core.ParameterSpace", "emukit.core.OneHotEncoding"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "space_3d_mixed", "(", ")", ":", "\n", "    ", "p1", "=", "ContinuousParameter", "(", "\"c\"", ",", "1.0", ",", "5.0", ")", "\n", "p2", "=", "DiscreteParameter", "(", "\"d\"", ",", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "p3", "=", "CategoricalParameter", "(", "\"cat\"", ",", "OneHotEncoding", "(", "[", "\"Maine Coon\"", ",", "\"Siamese\"", "]", ")", ")", "\n", "return", "ParameterSpace", "(", "[", "p1", ",", "p2", ",", "p3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_parameter_space_has_all_parameters": [[34, 36], ["len"], "function", ["None"], ["", "def", "test_parameter_space_has_all_parameters", "(", "space_2d", ")", ":", "\n", "    ", "assert", "len", "(", "space_2d", ".", "parameters", ")", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_check_in_domain": [[38, 46], ["numpy.array", "space_2d.check_points_in_domain", "numpy.array_equal", "numpy.array", "space_3d_mixed.check_points_in_domain", "numpy.array_equal", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain"], ["", "def", "test_check_in_domain", "(", "space_2d", ",", "space_3d_mixed", ")", ":", "\n", "    ", "x_test", "=", "np", ".", "array", "(", "[", "[", "1.5", ",", "6.1", "]", ",", "[", "1.5", ",", "2.0", "]", "]", ")", "\n", "in_domain", "=", "space_2d", ".", "check_points_in_domain", "(", "x_test", ")", "\n", "assert", "np", ".", "array_equal", "(", "in_domain", ",", "np", ".", "array", "(", "[", "False", ",", "True", "]", ")", ")", "\n", "\n", "x_mixed_test", "=", "np", ".", "array", "(", "[", "[", "1.5", ",", "0", ",", "1", ",", "1", "]", ",", "[", "1.5", ",", "1", ",", "1.0", ",", "0.0", "]", "]", ")", "\n", "in_domain", "=", "space_3d_mixed", ".", "check_points_in_domain", "(", "x_mixed_test", ")", "\n", "assert", "np", ".", "array_equal", "(", "in_domain", ",", "np", ".", "array", "(", "[", "False", ",", "True", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_check_in_domain_with_only_bandit_parameters": [[48, 61], ["emukit.core.BanditParameter", "emukit.core.BanditParameter", "emukit.core.ParameterSpace", "numpy.array", "emukit.core.ParameterSpace.check_points_in_domain", "numpy.array_equal", "emukit.core.ParameterSpace", "numpy.array", "emukit.core.ParameterSpace.check_points_in_domain", "numpy.array_equal", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain"], ["", "def", "test_check_in_domain_with_only_bandit_parameters", "(", ")", ":", "\n", "    ", "p1", "=", "BanditParameter", "(", "\"bandit1\"", ",", "np", ".", "array", "(", "[", "[", "3", ",", "4.0", ",", "0", "]", ",", "[", "3", ",", "4", ",", "0", "]", ",", "[", "4", ",", "4", ",", "1", "]", "]", ")", ")", "\n", "p2", "=", "BanditParameter", "(", "\"bandit2\"", ",", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1.0", ",", "0", "]", "]", ")", ")", "\n", "\n", "one_bandit_space", "=", "ParameterSpace", "(", "[", "p1", "]", ")", "\n", "x_test", "=", "np", ".", "array", "(", "[", "[", "3.0", ",", "4", ",", "0", "]", ",", "[", "4.0", ",", "3", ",", "0", "]", "]", ")", "\n", "in_domain", "=", "one_bandit_space", ".", "check_points_in_domain", "(", "x_test", ")", "\n", "assert", "np", ".", "array_equal", "(", "in_domain", ",", "np", ".", "array", "(", "[", "True", ",", "False", "]", ")", ")", "\n", "\n", "two_bandits_space", "=", "ParameterSpace", "(", "[", "p1", ",", "p2", "]", ")", "\n", "x_test", "=", "np", ".", "array", "(", "[", "[", "3.0", ",", "4", ",", "0", ",", "0", ",", "1", "]", ",", "[", "4.0", ",", "3", ",", "0", ",", "0", ",", "1", "]", ",", "[", "3", ",", "4", ",", "0", ",", "1", ",", "1", "]", "]", ")", "\n", "in_domain", "=", "two_bandits_space", ".", "check_points_in_domain", "(", "x_test", ")", "\n", "assert", "np", ".", "array_equal", "(", "in_domain", ",", "np", ".", "array", "(", "[", "True", ",", "False", ",", "True", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_check_in_domain_with_bandit_parameter": [[63, 75], ["emukit.core.ParameterSpace", "numpy.array", "emukit.core.ParameterSpace.check_points_in_domain", "numpy.array_equal", "numpy.array", "emukit.core.ContinuousParameter", "emukit.core.DiscreteParameter", "emukit.core.CategoricalParameter", "emukit.core.BanditParameter", "emukit.core.OneHotEncoding", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain"], ["", "def", "test_check_in_domain_with_bandit_parameter", "(", ")", ":", "\n", "    ", "mixed_space_with_bandit", "=", "ParameterSpace", "(", "\n", "[", "\n", "ContinuousParameter", "(", "\"c\"", ",", "1.0", ",", "5.0", ")", ",", "\n", "DiscreteParameter", "(", "\"d\"", ",", "[", "0", ",", "1", ",", "2", "]", ")", ",", "\n", "CategoricalParameter", "(", "\"cat\"", ",", "OneHotEncoding", "(", "[", "\"blue\"", ",", "\"red\"", "]", ")", ")", ",", "\n", "BanditParameter", "(", "\"bandit\"", ",", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1.0", ",", "0", "]", "]", ")", ")", ",", "\n", "]", "\n", ")", "\n", "x_test", "=", "np", ".", "array", "(", "[", "[", "1.5", ",", "0", ",", "1.0", ",", "0.0", ",", "0", ",", "1", "]", ",", "[", "1.5", ",", "0", ",", "1.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "in_domain", "=", "mixed_space_with_bandit", ".", "check_points_in_domain", "(", "x_test", ")", "\n", "assert", "np", ".", "array_equal", "(", "in_domain", ",", "np", ".", "array", "(", "[", "True", ",", "False", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_check_in_domain_fails": [[77, 81], ["numpy.array", "pytest.raises", "space_2d.check_points_in_domain"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.check_points_in_domain"], ["", "def", "test_check_in_domain_fails", "(", "space_2d", ")", ":", "\n", "    ", "x_test", "=", "np", ".", "array", "(", "[", "[", "1.5", ",", "6.0", ",", "7.0", "]", ",", "[", "1.5", ",", "2.0", ",", "7.0", "]", "]", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "space_2d", ".", "check_points_in_domain", "(", "x_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_two_information_source_parameters_fail": [[83, 86], ["pytest.raises", "emukit.core.ParameterSpace", "emukit.core.InformationSourceParameter", "emukit.core.InformationSourceParameter"], "function", ["None"], ["", "", "def", "test_two_information_source_parameters_fail", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ParameterSpace", "(", "[", "InformationSourceParameter", "(", "2", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_get_parameter_by_name": [[88, 91], ["space_2d.get_parameter_by_name"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_parameter_by_name"], ["", "", "def", "test_get_parameter_by_name", "(", "space_2d", ")", ":", "\n", "    ", "param", "=", "space_2d", ".", "get_parameter_by_name", "(", "\"c\"", ")", "\n", "assert", "param", ".", "max", "==", "5.0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_get_parameter_name_fails_with_wrong_name": [[93, 96], ["pytest.raises", "space_2d.get_parameter_by_name"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_parameter_by_name"], ["", "def", "test_get_parameter_name_fails_with_wrong_name", "(", "space_2d", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "space_2d", ".", "get_parameter_by_name", "(", "\"invalid_name\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_duplicate_parameter_names_fail": [[98, 104], ["emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "pytest.raises", "emukit.core.ParameterSpace"], "function", ["None"], ["", "", "def", "test_duplicate_parameter_names_fail", "(", ")", ":", "\n", "    ", "p1", "=", "ContinuousParameter", "(", "\"c\"", ",", "1.0", ",", "5.0", ")", "\n", "p2", "=", "ContinuousParameter", "(", "\"c\"", ",", "1.0", ",", "6.0", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ParameterSpace", "(", "[", "p1", ",", "p2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_get_bounds": [[106, 108], ["space_3d_mixed.get_bounds"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_bounds"], ["", "", "def", "test_get_bounds", "(", "space_3d_mixed", ")", ":", "\n", "    ", "assert", "space_3d_mixed", ".", "get_bounds", "(", ")", "==", "[", "(", "1.0", ",", "5.0", ")", ",", "(", "1.0", ",", "3.0", ")", ",", "(", "0", ",", "1", ")", ",", "(", "0", ",", "1", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.test_sample_uniform": [[130, 137], ["unittest.mock.patch", "space_3d_mixed.sample_uniform", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "test_parameter_space.MockRandom", "numpy.repeat", "numpy.bincount", "numpy.bincount", "numpy.bincount", "numpy.histogram", "X[].astype", "X[].astype", "X[].astype"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform"], ["", "", "@", "mock", ".", "patch", "(", "\"numpy.random\"", ",", "MockRandom", "(", ")", ")", "\n", "def", "test_sample_uniform", "(", "space_3d_mixed", ")", ":", "\n", "    ", "X", "=", "space_3d_mixed", ".", "sample_uniform", "(", "90", ")", "\n", "assert_array_equal", "(", "np", ".", "histogram", "(", "X", "[", ":", ",", "0", "]", ",", "9", ")", "[", "0", "]", ",", "np", ".", "repeat", "(", "10", ",", "9", ")", ")", "\n", "assert_array_equal", "(", "np", ".", "bincount", "(", "X", "[", ":", ",", "1", "]", ".", "astype", "(", "int", ")", ")", ",", "[", "0", ",", "30", ",", "30", ",", "30", "]", ")", "\n", "assert_array_equal", "(", "np", ".", "bincount", "(", "X", "[", ":", ",", "2", "]", ".", "astype", "(", "int", ")", ")", ",", "[", "45", ",", "45", "]", ")", "\n", "assert_array_equal", "(", "np", ".", "bincount", "(", "X", "[", ":", ",", "3", "]", ".", "astype", "(", "int", ")", ")", ",", "[", "45", ",", "45", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_bandit_parameter": [[7, 26], ["numpy.array", "emukit.core.BanditParameter", "emukit.core.BanditParameter.check_in_domain", "emukit.core.BanditParameter.check_in_domain", "all", "emukit.core.BanditParameter.check_in_domain", "emukit.core.BanditParameter.check_in_domain", "numpy.array", "numpy.array", "emukit.core.BanditParameter.sample_uniform", "pytest.raises", "emukit.core.BanditParameter.check_in_domain", "pytest.raises", "emukit.core.BanditParameter.check_in_domain", "pytest.raises", "emukit.core.BanditParameter.check_in_domain", "pytest.raises", "emukit.core.BanditParameter.check_in_domain", "numpy.array", "isinstance", "numpy.array", "numpy.array", "emukit.core.BanditParameter.round", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["def", "test_bandit_parameter", "(", ")", ":", "\n", "    ", "domain", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "2", "]", ",", "[", "2", ",", "2", "]", "]", ")", "\n", "param", "=", "BanditParameter", "(", "\"x\"", ",", "domain", ")", "\n", "assert", "param", ".", "name", "==", "\"x\"", "\n", "assert", "not", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "1", ",", "3", "]", ")", ")", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", ")", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "2", "]", "]", ")", ")", "\n", "assert", "(", "param", ".", "round", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1.2", "]", "]", ")", ")", "==", "[", "1", ",", "1", "]", ")", ".", "all", "(", ")", "\n", "assert", "all", "(", "[", "isinstance", "(", "sp", ",", "DiscreteParameter", ")", "for", "sp", "in", "param", ".", "parameters", "]", ")", "\n", "assert", "param", ".", "check_in_domain", "(", "param", ".", "sample_uniform", "(", "10", ")", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# too many columns", "\n", "        ", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", ",", "[", "0", ",", "2", ",", "0", "]", "]", ")", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# not a 1d/2d array", "\n", "        ", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "[", "1", "]", "]", "]", ")", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# wrong type", "\n", "        ", "param", ".", "check_in_domain", "(", "(", "1", ",", "1", ")", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# wrong type", "\n", "        ", "param", ".", "check_in_domain", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_bandit_parameter_str_repr": [[28, 34], ["numpy.array", "emukit.core.BanditParameter", "str", "repr"], "function", ["None"], ["", "", "def", "test_bandit_parameter_str_repr", "(", ")", ":", "\n", "    ", "domain", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", ",", "3", "]", ",", "[", "2", ",", "3", ",", "4", "]", "]", ")", "\n", "for", "subparam_names", "in", "[", "[", "\"foo\"", ",", "\"bar\"", "]", ",", "None", "]", ":", "\n", "        ", "param", "=", "BanditParameter", "(", "\"foobar\"", ",", "domain", ".", "T", ",", "subparam_names", ")", "\n", "_", "=", "str", "(", "param", ")", "\n", "_", "=", "repr", "(", "param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_continuous_parameter": [[36, 49], ["emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter.check_in_domain", "emukit.core.ContinuousParameter.check_in_domain", "emukit.core.ContinuousParameter.check_in_domain", "numpy.array", "numpy.array", "emukit.core.ContinuousParameter.check_in_domain", "emukit.core.ContinuousParameter.check_in_domain", "pytest.raises", "emukit.core.ContinuousParameter.check_in_domain", "pytest.raises", "emukit.core.ContinuousParameter.check_in_domain", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "", "def", "test_continuous_parameter", "(", ")", ":", "\n", "    ", "param", "=", "ContinuousParameter", "(", "\"x\"", ",", "1", ",", "10", ")", "\n", "assert", "param", ".", "name", "==", "\"x\"", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "1", ",", "3", "]", ")", ")", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "3", "]", "]", ")", ")", "\n", "assert", "param", ".", "check_in_domain", "(", "3", ")", "\n", "assert", "not", "param", ".", "check_in_domain", "(", "0.9", ")", "\n", "assert", "not", "param", ".", "check_in_domain", "(", "0", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# too many columns", "\n", "        ", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "2", "]", "]", ")", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# not a 1d/2d array", "\n", "        ", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "[", "1", "]", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_continuous_parameter_str_repr": [[51, 55], ["emukit.core.ContinuousParameter", "str", "repr"], "function", ["None"], ["", "", "def", "test_continuous_parameter_str_repr", "(", ")", ":", "\n", "    ", "param", "=", "ContinuousParameter", "(", "\"x\"", ",", "1", ",", "10", ")", "\n", "_", "=", "str", "(", "param", ")", "\n", "_", "=", "repr", "(", "param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_discrete_parameter": [[57, 71], ["emukit.core.DiscreteParameter", "emukit.core.DiscreteParameter.check_in_domain", "emukit.core.DiscreteParameter.check_in_domain", "emukit.core.DiscreteParameter.check_in_domain", "emukit.core.DiscreteParameter.check_in_domain", "emukit.core.DiscreteParameter.check_in_domain", "emukit.core.DiscreteParameter.check_in_domain", "pytest.raises", "emukit.core.DiscreteParameter.check_in_domain", "pytest.raises", "emukit.core.DiscreteParameter.check_in_domain", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "test_discrete_parameter", "(", ")", ":", "\n", "    ", "param", "=", "DiscreteParameter", "(", "\"x\"", ",", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "assert", "param", ".", "name", "==", "\"x\"", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", ")", "is", "True", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "3", "]", ")", ")", "is", "False", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "0", "]", "]", ")", ")", "is", "True", "\n", "assert", "param", ".", "check_in_domain", "(", "[", "1", ",", "0", "]", ")", "is", "True", "\n", "assert", "param", ".", "check_in_domain", "(", "1", ")", "is", "True", "\n", "assert", "param", ".", "check_in_domain", "(", "0.5", ")", "is", "False", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# too many columns", "\n", "        ", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "2", "]", "]", ")", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# not a 1d/2d array", "\n", "        ", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "[", "1", "]", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_discrete_parameter_str_repr": [[73, 77], ["emukit.core.DiscreteParameter", "str", "repr"], "function", ["None"], ["", "", "def", "test_discrete_parameter_str_repr", "(", ")", ":", "\n", "    ", "param", "=", "DiscreteParameter", "(", "\"x\"", ",", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "_", "=", "str", "(", "param", ")", "\n", "_", "=", "repr", "(", "param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_single_value_in_domain_discrete_parameter": [[79, 83], ["emukit.core.DiscreteParameter", "emukit.core.DiscreteParameter.check_in_domain", "emukit.core.DiscreteParameter.check_in_domain"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "test_single_value_in_domain_discrete_parameter", "(", ")", ":", "\n", "    ", "param", "=", "DiscreteParameter", "(", "\"x\"", ",", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "assert", "param", ".", "check_in_domain", "(", "0", ")", "is", "True", "\n", "assert", "param", ".", "check_in_domain", "(", "3", ")", "is", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_information_source_parameter": [[85, 91], ["emukit.core.InformationSourceParameter", "emukit.core.InformationSourceParameter.check_in_domain", "emukit.core.InformationSourceParameter.check_in_domain", "emukit.core.InformationSourceParameter.check_in_domain", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "test_information_source_parameter", "(", ")", ":", "\n", "    ", "param", "=", "InformationSourceParameter", "(", "5", ")", "\n", "assert", "param", ".", "name", "==", "\"source\"", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", ")", "is", "True", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "4", "]", ")", ")", "is", "True", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "5", "]", ")", ")", "is", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameters.test_single_value_in_domain_information_source_parameter": [[93, 97], ["emukit.core.InformationSourceParameter", "emukit.core.InformationSourceParameter.check_in_domain", "emukit.core.InformationSourceParameter.check_in_domain"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "test_single_value_in_domain_information_source_parameter", "(", ")", ":", "\n", "    ", "param", "=", "InformationSourceParameter", "(", "5", ")", "\n", "assert", "param", ".", "check_in_domain", "(", "2", ")", "is", "True", "\n", "assert", "param", ".", "check_in_domain", "(", "7", ")", "is", "False", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.mock_updater": [[24, 30], ["mock.create_autospec"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "mock_updater", "(", ")", ":", "\n", "    ", "updater", "=", "mock", ".", "create_autospec", "(", "ModelUpdater", ")", "\n", "updater", ".", "update", ".", "return_value", "=", "None", "\n", "\n", "return", "updater", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.mock_next_point_calculator": [[32, 41], ["numpy.array", "mock.create_autospec", "mock.PropertyMock"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "mock_next_point_calculator", "(", ")", ":", "\n", "    ", "next_point", "=", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", "\n", "\n", "next_point_calculator", "=", "mock", ".", "create_autospec", "(", "CandidatePointCalculator", ")", "\n", "next_point_calculator", ".", "compute_next_points", ".", "return_value", "=", "next_point", "\n", "next_point_calculator", ".", "return_value", ".", "acquisition", "=", "mock", ".", "PropertyMock", "(", "None", ")", "\n", "\n", "return", "next_point_calculator", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.mock_user_function": [[43, 51], ["mock.create_autospec", "emukit.core.loop.UserFunctionResult", "numpy.array", "numpy.array"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "mock_user_function", "(", ")", ":", "\n", "    ", "user_function_results", "=", "[", "UserFunctionResult", "(", "np", ".", "array", "(", "[", "0", "]", ")", ",", "np", ".", "array", "(", "[", "0", "]", ")", ")", "]", "\n", "\n", "user_function", "=", "mock", ".", "create_autospec", "(", "UserFunction", ")", "\n", "user_function", ".", "evaluate", ".", "return_value", "=", "user_function_results", "\n", "\n", "return", "user_function", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.test_outer_loop": [[53, 64], ["mock.create_autospec", "emukit.core.loop.OuterLoop", "emukit.core.loop.OuterLoop.run_loop", "numpy.array_equal", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_outer_loop", "(", "mock_next_point_calculator", ",", "mock_updater", ",", "mock_user_function", ")", ":", "\n", "    ", "\"\"\"Example of automatic outer loop\"\"\"", "\n", "\n", "stopping_condition", "=", "mock", ".", "create_autospec", "(", "StoppingCondition", ")", "\n", "stopping_condition", ".", "should_stop", ".", "side_effect", "=", "[", "False", ",", "False", ",", "True", "]", "\n", "\n", "loop", "=", "OuterLoop", "(", "mock_next_point_calculator", ",", "mock_updater", ")", "\n", "loop", ".", "run_loop", "(", "mock_user_function", ",", "stopping_condition", ")", "\n", "\n", "assert", "loop", ".", "loop_state", ".", "iteration", "==", "2", "\n", "assert", "np", ".", "array_equal", "(", "loop", ".", "loop_state", ".", "X", ",", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "0", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.test_outer_loop_model_update": [[66, 104], ["MockModel", "MockModelUpdater", "emukit.core.loop.OuterLoop", "emukit.core.loop.OuterLoop.run_loop", "test_outer_loop..model.set_data"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data"], ["", "def", "test_outer_loop_model_update", "(", "mock_next_point_calculator", ",", "mock_user_function", ")", ":", "\n", "    ", "\"\"\"Checks the model has the correct number of data points\"\"\"", "\n", "\n", "class", "MockModelUpdater", "(", "ModelUpdater", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "model", ")", ":", "\n", "            ", "self", ".", "model", "=", "model", "\n", "\n", "", "def", "update", "(", "self", ",", "loop_state", ")", ":", "\n", "            ", "self", ".", "model", ".", "set_data", "(", "loop_state", ".", "X", ",", "loop_state", ".", "Y", ")", "\n", "\n", "", "", "class", "MockModel", "(", "IModel", ")", ":", "\n", "        ", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "_X", "\n", "\n", "", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "_Y", "\n", "\n", "", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "            ", "pass", "\n", "\n", "", "def", "set_data", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "            ", "self", ".", "_X", "=", "x", "\n", "self", ".", "_Y", "=", "y", "\n", "\n", "", "def", "optimize", "(", "self", ")", ":", "\n", "            ", "pass", "\n", "\n", "", "", "mock_model", "=", "MockModel", "(", ")", "\n", "model_updater", "=", "MockModelUpdater", "(", "mock_model", ")", "\n", "\n", "loop", "=", "OuterLoop", "(", "mock_next_point_calculator", ",", "model_updater", ")", "\n", "loop", ".", "run_loop", "(", "mock_user_function", ",", "2", ")", "\n", "\n", "# Check update was last called with a loop state with all the collected data points", "\n", "assert", "mock_model", ".", "X", ".", "shape", "[", "0", "]", "==", "2", "\n", "assert", "mock_model", ".", "Y", ".", "shape", "[", "0", "]", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.test_accept_non_wrapped_function": [[106, 118], ["mock.create_autospec", "emukit.core.loop.OuterLoop", "emukit.core.loop.OuterLoop.run_loop", "numpy.array_equal", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_accept_non_wrapped_function", "(", "mock_next_point_calculator", ",", "mock_updater", ")", ":", "\n", "    ", "stopping_condition", "=", "mock", ".", "create_autospec", "(", "StoppingCondition", ")", "\n", "stopping_condition", ".", "should_stop", ".", "side_effect", "=", "[", "False", ",", "False", ",", "True", "]", "\n", "\n", "def", "user_function", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", "\n", "\n", "", "loop", "=", "OuterLoop", "(", "mock_next_point_calculator", ",", "mock_updater", ")", "\n", "loop", ".", "run_loop", "(", "user_function", ",", "stopping_condition", ")", "\n", "\n", "assert", "loop", ".", "loop_state", ".", "iteration", "==", "2", "\n", "assert", "np", ".", "array_equal", "(", "loop", ".", "loop_state", ".", "X", ",", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "0", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.test_default_condition": [[120, 127], ["emukit.core.loop.OuterLoop", "emukit.core.loop.OuterLoop.run_loop"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_default_condition", "(", "mock_next_point_calculator", ",", "mock_updater", ",", "mock_user_function", ")", ":", "\n", "    ", "n_iter", "=", "10", "\n", "\n", "loop", "=", "OuterLoop", "(", "mock_next_point_calculator", ",", "mock_updater", ")", "\n", "loop", ".", "run_loop", "(", "mock_user_function", ",", "n_iter", ")", "\n", "\n", "assert", "loop", ".", "loop_state", ".", "iteration", "==", "n_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.test_condition_invalid_type": [[129, 135], ["emukit.core.loop.OuterLoop", "pytest.raises", "emukit.core.loop.OuterLoop.run_loop"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_condition_invalid_type", "(", "mock_next_point_calculator", ",", "mock_updater", ",", "mock_user_function", ")", ":", "\n", "    ", "invalid_n_iter", "=", "10.0", "\n", "loop", "=", "OuterLoop", "(", "mock_next_point_calculator", ",", "mock_updater", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "loop", ".", "run_loop", "(", "mock_user_function", ",", "invalid_n_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_outer_loop.test_iteration_end_event": [[137, 169], ["emukit.core.ParameterSpace", "test_outer_loop.test_accept_non_wrapped_function.user_function"], "function", ["None"], ["", "", "def", "test_iteration_end_event", "(", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "\n", "def", "user_function", "(", "x", ")", ":", "\n", "        ", "return", "x", "\n", "\n", "", "x_test", "=", "np", ".", "linspace", "(", "0", ",", "1", ")", "[", ":", ",", "None", "]", "\n", "y_test", "=", "user_function", "(", "x_test", ")", "\n", "\n", "x_init", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "5", ")", "[", ":", ",", "None", "]", "\n", "y_init", "=", "user_function", "(", "x_init", ")", "\n", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "mse", "=", "[", "]", "\n", "\n", "def", "compute_mse", "(", "self", ",", "loop_state", ")", ":", "\n", "        ", "mse", ".", "append", "(", "np", ".", "mean", "(", "np", ".", "square", "(", "model", ".", "predict", "(", "x_test", ")", "[", "0", "]", "-", "y_test", ")", ")", ")", "\n", "\n", "", "loop_state", "=", "create_loop_state", "(", "x_init", ",", "y_init", ")", "\n", "\n", "acquisition", "=", "ModelVariance", "(", "model", ")", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ")", "\n", "model_updater", "=", "FixedIntervalUpdater", "(", "model", ")", "\n", "\n", "loop", "=", "OuterLoop", "(", "candidate_point_calculator", ",", "model_updater", ",", "loop_state", ")", "\n", "loop", ".", "iteration_end_event", ".", "append", "(", "compute_mse", ")", "\n", "loop", ".", "run_loop", "(", "user_function", ",", "5", ")", "\n", "\n", "assert", "len", "(", "mse", ")", "==", "5", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.DummyAcquisition.__init__": [[10, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.DummyAcquisition.evaluate": [[13, 15], ["numpy.ones"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "np", ".", "ones", "(", "x", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.DummyAcquisition.has_gradients": [[16, 19], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.DummyAcquisitionWithGradients.__init__": [[22, 24], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.DummyAcquisitionWithGradients.evaluate": [[25, 27], ["numpy.ones"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "np", ".", "ones", "(", "x", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.DummyAcquisitionWithGradients.evaluate_with_gradients": [[28, 30], ["numpy.ones", "numpy.ones"], "methods", ["None"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "np", ".", "ones", "(", "x", ".", "shape", "[", "0", "]", ")", ",", "-", "np", ".", "ones", "(", "x", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.DummyAcquisitionWithGradients.has_gradients": [[31, 34], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.test_acquisition_adding": [[36, 40], ["acquisition_sum.evaluate", "numpy.array_equal", "test_acquisition.DummyAcquisition", "test_acquisition.DummyAcquisition", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_acquisition_adding", "(", ")", ":", "\n", "    ", "acquisition_sum", "=", "DummyAcquisition", "(", ")", "+", "DummyAcquisition", "(", ")", "\n", "acquisition_value", "=", "acquisition_sum", ".", "evaluate", "(", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "acquisition_value", ",", "np", ".", "array", "(", "[", "2.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.test_acquisition_adding_with_gradients": [[42, 47], ["acquisition_sum.evaluate_with_gradients", "numpy.array_equal", "numpy.array_equiv", "test_acquisition.DummyAcquisitionWithGradients", "test_acquisition.DummyAcquisitionWithGradients", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "test_acquisition_adding_with_gradients", "(", ")", ":", "\n", "    ", "acquisition_sum", "=", "DummyAcquisitionWithGradients", "(", ")", "+", "DummyAcquisitionWithGradients", "(", ")", "\n", "acquisition_value", ",", "acquisition_grads", "=", "acquisition_sum", ".", "evaluate_with_gradients", "(", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "acquisition_value", ",", "np", ".", "array", "(", "[", "2.0", "]", ")", ")", "\n", "assert", "np", ".", "array_equiv", "(", "acquisition_grads", ",", "-", "np", ".", "array", "(", "[", "2.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.test_acquistion_adding_with_gradients_fails": [[49, 56], ["test_acquisition.DummyAcquisitionWithGradients", "test_acquisition.DummyAcquisition", "pytest.raises", "acquisition_sum.evaluate_with_gradients", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "test_acquistion_adding_with_gradients_fails", "(", ")", ":", "\n", "    ", "\"\"\"\n    Checks that trying to evaluate gradients when one of the acquisitions doesn't implement them fails\n    \"\"\"", "\n", "acquisition_sum", "=", "DummyAcquisitionWithGradients", "(", ")", "+", "DummyAcquisition", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "acquisition_sum", ".", "evaluate_with_gradients", "(", "np", ".", "array", "(", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.test_acquisition_multiplying": [[58, 62], ["acquisition_sum.evaluate", "numpy.array_equal", "test_acquisition.DummyAcquisition", "test_acquisition.DummyAcquisition", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_acquisition_multiplying", "(", ")", ":", "\n", "    ", "acquisition_sum", "=", "DummyAcquisition", "(", ")", "*", "DummyAcquisition", "(", ")", "\n", "acquisition_value", "=", "acquisition_sum", ".", "evaluate", "(", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "acquisition_value", ",", "np", ".", "array", "(", "[", "1.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.test_acquisition_multiplying_with_gradients": [[64, 68], ["acquisition_sum.evaluate_with_gradients", "numpy.array_equal", "test_acquisition.DummyAcquisitionWithGradients", "test_acquisition.DummyAcquisitionWithGradients", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "test_acquisition_multiplying_with_gradients", "(", ")", ":", "\n", "    ", "acquisition_sum", "=", "DummyAcquisitionWithGradients", "(", ")", "*", "DummyAcquisitionWithGradients", "(", ")", "\n", "acquisition_value", ",", "acquisition_grads", "=", "acquisition_sum", ".", "evaluate_with_gradients", "(", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "acquisition_grads", ",", "-", "np", ".", "array", "(", "[", "2.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.test_acquisition_division": [[70, 74], ["acquisition_sum.evaluate", "numpy.array_equal", "test_acquisition.DummyAcquisition", "test_acquisition.DummyAcquisition", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_acquisition_division", "(", ")", ":", "\n", "    ", "acquisition_sum", "=", "DummyAcquisition", "(", ")", "/", "DummyAcquisition", "(", ")", "\n", "acquisition_value", "=", "acquisition_sum", ".", "evaluate", "(", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "acquisition_value", ",", "np", ".", "array", "(", "[", "1.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.test_acquisition_division_with_gradients": [[76, 80], ["acquisition_sum.evaluate_with_gradients", "numpy.array_equal", "test_acquisition.DummyAcquisitionWithGradients", "test_acquisition.DummyAcquisitionWithGradients", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "test_acquisition_division_with_gradients", "(", ")", ":", "\n", "    ", "acquisition_sum", "=", "DummyAcquisitionWithGradients", "(", ")", "/", "DummyAcquisitionWithGradients", "(", ")", "\n", "acquisition_value", ",", "acquisition_grads", "=", "acquisition_sum", ".", "evaluate_with_gradients", "(", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "acquisition_grads", ",", "np", ".", "array", "(", "[", "0.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_acquisition.test_integrated_acquisition_gradients": [[82, 100], ["mock.create_autospec", "mock.create_autospec", "emukit.core.acquisition.IntegratedHyperParameterAcquisition", "emukit.core.acquisition.IntegratedHyperParameterAcquisition"], "function", ["None"], ["", "def", "test_integrated_acquisition_gradients", "(", ")", ":", "\n", "    ", "\"\"\"\n    Check that the integrated hyper parameter acquisition \"has_gradients\" flag reflects the base acquisition function\n    :return:\n    \"\"\"", "\n", "mock_model", "=", "mock", ".", "create_autospec", "(", "IPriorHyperparameters", ")", "\n", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "\n", "# Check if false", "\n", "mock_acquisition", ".", "has_gradients", "=", "False", "\n", "mock_acquisition_generator", "=", "lambda", "x", ":", "mock_acquisition", "\n", "acq", "=", "IntegratedHyperParameterAcquisition", "(", "mock_model", ",", "mock_acquisition_generator", ")", "\n", "assert", "acq", ".", "has_gradients", "==", "False", "\n", "\n", "# Check if true", "\n", "mock_acquisition", ".", "has_gradients", "=", "True", "\n", "acq", "=", "IntegratedHyperParameterAcquisition", "(", "mock_model", ",", "mock_acquisition_generator", ")", "\n", "assert", "acq", ".", "has_gradients", "==", "True", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.categories": [[8, 11], ["None"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "categories", "(", ")", ":", "\n", "    ", "return", "[", "\"one\"", ",", "\"two\"", ",", "\"three\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.test_one_hot_encoding": [[13, 25], ["emukit.core.OneHotEncoding", "emukit.core.OneHotEncoding.get_category", "emukit.core.OneHotEncoding.get_encoding", "pytest.raises", "emukit.core.OneHotEncoding.get_category", "pytest.raises", "emukit.core.OneHotEncoding.get_encoding"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_category", "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_encoding", "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_category", "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_encoding"], ["", "def", "test_one_hot_encoding", "(", "categories", ")", ":", "\n", "    ", "encoding", "=", "OneHotEncoding", "(", "categories", ")", "\n", "\n", "assert", "encoding", ".", "dimension", "==", "3", "\n", "assert", "encoding", ".", "get_category", "(", "[", "1", ",", "0", ",", "0", "]", ")", "==", "\"one\"", "\n", "assert", "encoding", ".", "get_encoding", "(", "\"three\"", ")", "==", "[", "0", ",", "0", ",", "1", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "encoding", ".", "get_category", "(", "[", "1", ",", "1", ",", "0", "]", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "encoding", ".", "get_encoding", "(", "\"four\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.test_one_hot_encoding_rounding": [[27, 40], ["emukit.core.OneHotEncoding", "test_encodings.check_rounding", "test_encodings.check_rounding", "test_encodings.check_rounding", "test_encodings.check_rounding", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "pytest.raises", "emukit.core.OneHotEncoding.round", "pytest.raises", "emukit.core.OneHotEncoding.round", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding", "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding", "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding", "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "", "def", "test_one_hot_encoding_rounding", "(", "categories", ")", ":", "\n", "    ", "encoding", "=", "OneHotEncoding", "(", "categories", ")", "\n", "\n", "check_rounding", "(", "encoding", ",", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", "]", ")", ")", "\n", "check_rounding", "(", "encoding", ",", "np", ".", "array", "(", "[", "[", "0.5", ",", "0.1", ",", "0.1", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", "]", ")", ")", "\n", "check_rounding", "(", "encoding", ",", "np", ".", "array", "(", "[", "[", "2", ",", "0", ",", "1.5", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", "]", ")", ")", "\n", "check_rounding", "(", "encoding", ",", "np", ".", "array", "(", "[", "[", "0.7", ",", "0.75", ",", "0.5", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", "]", "]", ")", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "encoding", ".", "round", "(", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "encoding", ".", "round", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.test_ordinal_encoding": [[42, 48], ["emukit.core.OrdinalEncoding", "emukit.core.OrdinalEncoding.get_category", "emukit.core.OrdinalEncoding.get_encoding"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_category", "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_encoding"], ["", "", "def", "test_ordinal_encoding", "(", "categories", ")", ":", "\n", "    ", "encoding", "=", "OrdinalEncoding", "(", "categories", ")", "\n", "\n", "assert", "encoding", ".", "dimension", "==", "1", "\n", "assert", "encoding", ".", "get_category", "(", "[", "1", "]", ")", "==", "\"one\"", "\n", "assert", "encoding", ".", "get_encoding", "(", "\"three\"", ")", "==", "[", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.test_ordinal_encoding_rounding": [[50, 63], ["emukit.core.OrdinalEncoding", "test_encodings.check_rounding", "test_encodings.check_rounding", "test_encodings.check_rounding", "test_encodings.check_rounding", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "pytest.raises", "emukit.core.OrdinalEncoding.round", "pytest.raises", "emukit.core.OrdinalEncoding.round", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding", "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding", "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding", "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "test_ordinal_encoding_rounding", "(", "categories", ")", ":", "\n", "    ", "encoding", "=", "OrdinalEncoding", "(", "categories", ")", "\n", "\n", "check_rounding", "(", "encoding", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ")", "\n", "check_rounding", "(", "encoding", ",", "np", ".", "array", "(", "[", "[", "0.5", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ")", "\n", "check_rounding", "(", "encoding", ",", "np", ".", "array", "(", "[", "[", "2", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "2", "]", "]", ")", ")", "\n", "check_rounding", "(", "encoding", ",", "np", ".", "array", "(", "[", "[", "5", "]", "]", ")", ",", "np", ".", "array", "(", "[", "[", "3", "]", "]", ")", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "encoding", ".", "round", "(", "np", ".", "array", "(", "[", "1", "]", ")", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "encoding", ".", "round", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_encodings.check_rounding": [[65, 68], ["encoding.round", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "", "def", "check_rounding", "(", "encoding", ",", "x", ",", "expected", ")", ":", "\n", "    ", "rounded_x", "=", "encoding", ".", "round", "(", "x", ")", "\n", "assert_array_equal", "(", "expected", ",", "rounded_x", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_user_function_wrapper_evaluation_single_output": [[9, 20], ["numpy.array", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.UserFunctionWrapper.evaluate", "enumerate", "len", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "function"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["def", "test_user_function_wrapper_evaluation_single_output", "(", ")", ":", "\n", "    ", "function", "=", "lambda", "x", ":", "2", "*", "x", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "ufw", "=", "UserFunctionWrapper", "(", "function", ")", "\n", "\n", "output", "=", "ufw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "assert", "len", "(", "output", ")", "==", "function_input", ".", "shape", "[", "0", "]", "\n", "for", "i", ",", "record", "in", "enumerate", "(", "output", ")", ":", "\n", "        ", "assert_array_equal", "(", "output", "[", "i", "]", ".", "X", ",", "function_input", "[", "i", "]", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "Y", ",", "function", "(", "function_input", "[", "i", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_user_function_wrapper_callable_single_output": [[22, 31], ["numpy.array", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.UserFunctionWrapper.evaluate", "emukit.core.loop.UserFunctionWrapper.", "all", "len", "len", "zip"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_user_function_wrapper_callable_single_output", "(", ")", ":", "\n", "    ", "function", "=", "lambda", "x", ":", "2", "*", "x", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "ufw", "=", "UserFunctionWrapper", "(", "function", ")", "\n", "\n", "evaluated_output", "=", "ufw", ".", "evaluate", "(", "function_input", ")", "\n", "called_output", "=", "ufw", "(", "function_input", ")", "\n", "assert", "len", "(", "evaluated_output", ")", "==", "len", "(", "called_output", ")", "\n", "assert", "all", "(", "eo", "==", "co", "for", "(", "eo", ",", "co", ")", "in", "zip", "(", "evaluated_output", ",", "called_output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_user_function_wrapper_evaluation_with_cost": [[33, 45], ["numpy.array", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.UserFunctionWrapper.evaluate", "enumerate", "len", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "function", "function"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_user_function_wrapper_evaluation_with_cost", "(", ")", ":", "\n", "    ", "function", "=", "lambda", "x", ":", "(", "2", "*", "x", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "ufw", "=", "UserFunctionWrapper", "(", "function", ",", "extra_output_names", "=", "[", "\"cost\"", "]", ")", "\n", "\n", "output", "=", "ufw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "assert", "len", "(", "output", ")", "==", "function_input", ".", "shape", "[", "0", "]", "\n", "for", "i", ",", "record", "in", "enumerate", "(", "output", ")", ":", "\n", "        ", "assert_array_equal", "(", "output", "[", "i", "]", ".", "X", ",", "function_input", "[", "i", "]", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "Y", ",", "function", "(", "function_input", "[", "i", "]", ")", "[", "0", "]", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "cost", ",", "function", "(", "function_input", "[", "i", "]", ")", "[", "1", "]", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_user_function_wrapper_invalid_input": [[47, 68], ["pytest.raises", "numpy.array", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.UserFunctionWrapper.evaluate", "pytest.raises", "numpy.array", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.UserFunctionWrapper.evaluate", "pytest.raises", "numpy.array", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.UserFunctionWrapper.evaluate", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_user_function_wrapper_invalid_input", "(", ")", ":", "\n", "# invalid input", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "function", "=", "lambda", "x", ":", "2", "*", "x", "\n", "function_input", "=", "np", ".", "array", "(", "[", "1", "]", ")", "\n", "ufw", "=", "UserFunctionWrapper", "(", "function", ")", "\n", "ufw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "# invalid function output", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "function", "=", "lambda", "x", ":", "np", ".", "array", "(", "[", "2", "]", ")", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", "\n", "ufw", "=", "UserFunctionWrapper", "(", "function", ")", "\n", "ufw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "# invalid function output type", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "function", "=", "lambda", "x", ":", "[", "2", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", "\n", "ufw", "=", "UserFunctionWrapper", "(", "function", ")", "\n", "ufw", ".", "evaluate", "(", "function_input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_multi_source_function_wrapper_evaluation_single_output": [[70, 84], ["numpy.array", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "emukit.core.loop.user_function.MultiSourceFunctionWrapper.evaluate", "enumerate", "len", "numpy.testing.assert_array_equal", "numpy.delete", "numpy.testing.assert_array_equal", "this_function"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_multi_source_function_wrapper_evaluation_single_output", "(", ")", ":", "\n", "    ", "functions", "=", "[", "lambda", "x", ":", "2", "*", "x", ",", "lambda", "x", ":", "4", "*", "x", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", ",", "[", "3", ",", "0", "]", ",", "[", "4", ",", "0", "]", ",", "[", "5", ",", "1", "]", "]", ")", "\n", "source_index", "=", "-", "1", "\n", "msfw", "=", "MultiSourceFunctionWrapper", "(", "functions", ",", "source_index", ")", "\n", "\n", "output", "=", "msfw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "assert", "len", "(", "output", ")", "==", "function_input", ".", "shape", "[", "0", "]", "\n", "for", "i", ",", "record", "in", "enumerate", "(", "output", ")", ":", "\n", "        ", "assert_array_equal", "(", "output", "[", "i", "]", ".", "X", ",", "function_input", "[", "i", "]", ")", "\n", "this_function", "=", "functions", "[", "function_input", "[", "i", ",", "source_index", "]", "]", "\n", "this_function_input", "=", "np", ".", "delete", "(", "function_input", "[", "i", "]", ",", "source_index", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "Y", ",", "this_function", "(", "this_function_input", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_multi_source_function_wrapper_evaluation_with_cost": [[86, 101], ["numpy.array", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "emukit.core.loop.user_function.MultiSourceFunctionWrapper.evaluate", "enumerate", "len", "numpy.testing.assert_array_equal", "numpy.delete", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "this_function", "this_function"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_multi_source_function_wrapper_evaluation_with_cost", "(", ")", ":", "\n", "    ", "functions", "=", "[", "lambda", "x", ":", "(", "2", "*", "x", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ")", ",", "lambda", "x", ":", "(", "4", "*", "x", ",", "np", ".", "array", "(", "[", "[", "2", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ")", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", ",", "[", "3", ",", "0", "]", ",", "[", "4", ",", "0", "]", ",", "[", "5", ",", "1", "]", "]", ")", "\n", "source_index", "=", "-", "1", "\n", "msfw", "=", "MultiSourceFunctionWrapper", "(", "functions", ",", "source_index", ",", "extra_output_names", "=", "[", "\"cost\"", "]", ")", "\n", "\n", "output", "=", "msfw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "assert", "len", "(", "output", ")", "==", "function_input", ".", "shape", "[", "0", "]", "\n", "for", "i", ",", "record", "in", "enumerate", "(", "output", ")", ":", "\n", "        ", "assert_array_equal", "(", "output", "[", "i", "]", ".", "X", ",", "function_input", "[", "i", "]", ")", "\n", "this_function", "=", "functions", "[", "function_input", "[", "i", ",", "source_index", "]", "]", "\n", "this_function_input", "=", "np", ".", "delete", "(", "function_input", "[", "i", "]", ",", "source_index", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "Y", ",", "this_function", "(", "this_function_input", ")", "[", "0", "]", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "cost", ",", "this_function", "(", "this_function_input", ")", "[", "1", "]", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_multi_source_function_wrapper_evaluation_with_multiple_extra_arguments": [[103, 122], ["numpy.array", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "emukit.core.loop.user_function.MultiSourceFunctionWrapper.evaluate", "enumerate", "len", "numpy.testing.assert_array_equal", "numpy.delete", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "this_function", "this_function", "this_function"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_multi_source_function_wrapper_evaluation_with_multiple_extra_arguments", "(", ")", ":", "\n", "    ", "functions", "=", "[", "\n", "lambda", "x", ":", "(", "2", "*", "x", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ")", ",", "\n", "lambda", "x", ":", "(", "4", "*", "x", ",", "np", ".", "array", "(", "[", "[", "2", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ")", ",", "\n", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", ",", "[", "3", ",", "0", "]", ",", "[", "4", ",", "0", "]", ",", "[", "5", ",", "1", "]", "]", ")", "\n", "source_index", "=", "-", "1", "\n", "msfw", "=", "MultiSourceFunctionWrapper", "(", "functions", ",", "source_index", ",", "extra_output_names", "=", "[", "\"cost\"", ",", "\"constraint\"", "]", ")", "\n", "\n", "output", "=", "msfw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "assert", "len", "(", "output", ")", "==", "function_input", ".", "shape", "[", "0", "]", "\n", "for", "i", ",", "record", "in", "enumerate", "(", "output", ")", ":", "\n", "        ", "assert_array_equal", "(", "output", "[", "i", "]", ".", "X", ",", "function_input", "[", "i", "]", ")", "\n", "this_function", "=", "functions", "[", "function_input", "[", "i", ",", "source_index", "]", "]", "\n", "this_function_input", "=", "np", ".", "delete", "(", "function_input", "[", "i", "]", ",", "source_index", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "Y", ",", "this_function", "(", "this_function_input", ")", "[", "0", "]", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "cost", ",", "this_function", "(", "this_function_input", ")", "[", "1", "]", "[", "0", "]", ")", "\n", "assert_array_equal", "(", "output", "[", "i", "]", ".", "constraint", ",", "this_function", "(", "this_function_input", ")", "[", "2", "]", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_multi_source_function_wrapper_invalid_input": [[124, 145], ["pytest.raises", "numpy.array", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "emukit.core.loop.user_function.MultiSourceFunctionWrapper.evaluate", "pytest.raises", "numpy.array", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "emukit.core.loop.user_function.MultiSourceFunctionWrapper.evaluate", "pytest.raises", "numpy.array", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "emukit.core.loop.user_function.MultiSourceFunctionWrapper.evaluate", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_multi_source_function_wrapper_invalid_input", "(", ")", ":", "\n", "# invalid input", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "functions", "=", "[", "lambda", "x", ":", "2", "*", "x", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "1", ",", "0", "]", ")", "\n", "msfw", "=", "MultiSourceFunctionWrapper", "(", "functions", ")", "\n", "msfw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "# invalid function output", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "functions", "=", "[", "lambda", "x", ":", "np", ".", "array", "(", "[", "2", "]", ")", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", "]", ")", "\n", "msfw", "=", "MultiSourceFunctionWrapper", "(", "functions", ")", "\n", "msfw", ".", "evaluate", "(", "function_input", ")", "\n", "\n", "# invalid function output type", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "functions", "=", "[", "lambda", "x", ":", "[", "2", "]", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", "]", ")", "\n", "msfw", "=", "MultiSourceFunctionWrapper", "(", "functions", ")", "\n", "msfw", ".", "evaluate", "(", "function_input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_user_function_result_validation": [[147, 159], ["pytest.raises", "emukit.core.loop.UserFunctionResult", "pytest.raises", "emukit.core.loop.UserFunctionResult", "pytest.raises", "emukit.core.loop.UserFunctionResult", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["", "", "def", "test_user_function_result_validation", "(", ")", ":", "\n", "# 2d x", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "UserFunctionResult", "(", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", "\n", "\n", "# 2d y", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "UserFunctionResult", "(", "np", ".", "array", "(", "[", "1", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ")", "\n", "\n", "# 2d cost", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "UserFunctionResult", "(", "np", ".", "array", "(", "[", "1", "]", ")", ",", "np", ".", "array", "(", "[", "1", "]", ")", ",", "cost", "=", "np", ".", "array", "(", "[", "[", "1", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_user_function_too_many_outputs_outputs_fails": [[161, 167], ["numpy.array", "emukit.core.loop.UserFunctionWrapper", "pytest.raises", "emukit.core.loop.UserFunctionWrapper.evaluate", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_user_function_too_many_outputs_outputs_fails", "(", ")", ":", "\n", "    ", "function", "=", "lambda", "x", ":", "(", "2", "*", "x", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "ufw", "=", "UserFunctionWrapper", "(", "function", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ufw", ".", "evaluate", "(", "function_input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_user_function_too_few_outputs_outputs_fails": [[169, 175], ["numpy.array", "emukit.core.loop.UserFunctionWrapper", "pytest.raises", "emukit.core.loop.UserFunctionWrapper.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_user_function_too_few_outputs_outputs_fails", "(", ")", ":", "\n", "    ", "function", "=", "lambda", "x", ":", "2", "*", "x", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "ufw", "=", "UserFunctionWrapper", "(", "function", ",", "extra_output_names", "=", "[", "\"cost\"", "]", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ufw", ".", "evaluate", "(", "function_input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_multi_source_function_wrapper_too_many_outputs_outputs_fails": [[177, 188], ["numpy.array", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "pytest.raises", "emukit.core.loop.user_function.MultiSourceFunctionWrapper.evaluate", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_multi_source_function_wrapper_too_many_outputs_outputs_fails", "(", ")", ":", "\n", "    ", "functions", "=", "[", "\n", "lambda", "x", ":", "(", "2", "*", "x", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ")", ",", "\n", "lambda", "x", ":", "(", "4", "*", "x", ",", "np", ".", "array", "(", "[", "[", "2", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ",", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "x", ".", "shape", "[", "0", "]", ")", ")", ",", "\n", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", ",", "[", "3", ",", "0", "]", ",", "[", "4", ",", "0", "]", ",", "[", "5", ",", "1", "]", "]", ")", "\n", "source_index", "=", "-", "1", "\n", "msfw", "=", "MultiSourceFunctionWrapper", "(", "functions", ",", "source_index", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "msfw", ".", "evaluate", "(", "function_input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_user_function.test_multi_source_function_wrapper_too_few_outputs_outputs_fails": [[190, 198], ["numpy.array", "emukit.core.loop.user_function.MultiSourceFunctionWrapper", "pytest.raises", "emukit.core.loop.user_function.MultiSourceFunctionWrapper.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_multi_source_function_wrapper_too_few_outputs_outputs_fails", "(", ")", ":", "\n", "    ", "functions", "=", "[", "lambda", "x", ":", "2", "*", "x", ",", "lambda", "x", ":", "4", "*", "x", "]", "\n", "function_input", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "2", ",", "1", "]", ",", "[", "3", ",", "0", "]", ",", "[", "4", ",", "0", "]", ",", "[", "5", ",", "1", "]", "]", ")", "\n", "source_index", "=", "-", "1", "\n", "msfw", "=", "MultiSourceFunctionWrapper", "(", "functions", ",", "source_index", ",", "extra_output_names", "=", "[", "\"cost\"", "]", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "msfw", ".", "evaluate", "(", "function_input", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_multi_source_optimizer.multi_source_optimizer": [[12, 18], ["mock.create_autospec", "emukit.core.ParameterSpace", "emukit.core.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer", "numpy.array", "emukit.core.ContinuousParameter", "emukit.core.InformationSourceParameter"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "multi_source_optimizer", "(", ")", ":", "\n", "    ", "mock_acquisition_optimizer", "=", "mock", ".", "create_autospec", "(", "GradientAcquisitionOptimizer", ")", "\n", "mock_acquisition_optimizer", ".", "optimize", ".", "return_value", "=", "(", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", ",", "None", ")", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", ")", "\n", "return", "MultiSourceAcquisitionOptimizer", "(", "mock_acquisition_optimizer", ",", "space", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_multi_source_optimizer.test_multi_source_optimizer_returns_one_point": [[20, 26], ["multi_source_optimizer.optimize", "mock.create_autospec", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "test_multi_source_optimizer_returns_one_point", "(", "multi_source_optimizer", ")", ":", "\n", "# SequentialPointCalculator should just return result of the acquisition optimizer", "\n", "    ", "next_points", ",", "_", "=", "multi_source_optimizer", ".", "optimize", "(", "mock", ".", "create_autospec", "(", "Acquisition", ")", ")", "\n", "\n", "# \"SequentialPointCalculator\" should only ever return 1 value", "\n", "assert", "len", "(", "next_points", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_multi_source_optimizer.test_multi_source_optimizer_returns_2d_array": [[28, 34], ["multi_source_optimizer.optimize", "mock.create_autospec"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "test_multi_source_optimizer_returns_2d_array", "(", "multi_source_optimizer", ")", ":", "\n", "# SequentialPointCalculator should just return result of the acquisition optimizer", "\n", "    ", "next_points", ",", "_", "=", "multi_source_optimizer", ".", "optimize", "(", "mock", ".", "create_autospec", "(", "Acquisition", ")", ")", "\n", "\n", "# Check output is 2d", "\n", "assert", "next_points", ".", "ndim", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_multi_source_optimizer.test_multi_source_optimizer_returns_correct_result": [[36, 41], ["multi_source_optimizer.optimize", "numpy.equal", "mock.create_autospec", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "test_multi_source_optimizer_returns_correct_result", "(", "multi_source_optimizer", ")", ":", "\n", "# SequentialPointCalculator should just return result of the acquisition optimizer", "\n", "    ", "next_points", "=", "multi_source_optimizer", ".", "optimize", "(", "mock", ".", "create_autospec", "(", "Acquisition", ")", ")", "\n", "# Value should be result of acquisition optimization", "\n", "assert", "np", ".", "equal", "(", "np", ".", "array", "(", "[", "0.0", "]", ")", ",", "next_points", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_multi_source_optimizer.test_multi_source_sequential_with_context": [[43, 62], ["mock.create_autospec", "emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "emukit.core.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer", "mock.create_autospec", "emukit.core.loop.SequentialPointCalculator", "emukit.core.loop.SequentialPointCalculator.compute_next_points", "numpy.isclose", "len", "numpy.sum", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.InformationSourceParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "def", "test_multi_source_sequential_with_context", "(", ")", ":", "\n", "# Check that we can fix a non-information source parameter with context", "\n", "    ", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "mock_acquisition", ".", "has_gradients", "=", "False", "\n", "mock_acquisition", ".", "evaluate", "=", "lambda", "x", ":", "np", ".", "sum", "(", "x", "**", "2", ",", "axis", "=", "1", ")", "[", ":", ",", "None", "]", "\n", "space", "=", "ParameterSpace", "(", "\n", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"y\"", ",", "0", ",", "1", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", "\n", ")", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "multi_source_acquisition_optimizer", "=", "MultiSourceAcquisitionOptimizer", "(", "acquisition_optimizer", ",", "space", ")", "\n", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "seq", "=", "SequentialPointCalculator", "(", "mock_acquisition", ",", "multi_source_acquisition_optimizer", ")", "\n", "next_points", "=", "seq", ".", "compute_next_points", "(", "loop_state_mock", ",", "context", "=", "{", "\"x\"", ":", "0.25", "}", ")", "\n", "\n", "# \"SequentialPointCalculator\" should only ever return 1 value", "\n", "assert", "len", "(", "next_points", ")", "==", "1", "\n", "# Context value should be what we set", "\n", "assert", "np", ".", "isclose", "(", "next_points", "[", "0", ",", "0", "]", ",", "0.25", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_multi_source_optimizer.test_multi_source_sequential_with_source_context": [[64, 83], ["mock.create_autospec", "emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "emukit.core.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer", "mock.create_autospec", "emukit.core.loop.SequentialPointCalculator", "emukit.core.loop.SequentialPointCalculator.compute_next_points", "numpy.isclose", "len", "numpy.sum", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter", "emukit.core.InformationSourceParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "def", "test_multi_source_sequential_with_source_context", "(", ")", ":", "\n", "# Check that we can fix a non-information source parameter with context", "\n", "    ", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "mock_acquisition", ".", "has_gradients", "=", "False", "\n", "mock_acquisition", ".", "evaluate", "=", "lambda", "x", ":", "np", ".", "sum", "(", "x", "**", "2", ",", "axis", "=", "1", ")", "[", ":", ",", "None", "]", "\n", "space", "=", "ParameterSpace", "(", "\n", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"y\"", ",", "0", ",", "1", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", "\n", ")", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "multi_source_acquisition_optimizer", "=", "MultiSourceAcquisitionOptimizer", "(", "acquisition_optimizer", ",", "space", ")", "\n", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "seq", "=", "SequentialPointCalculator", "(", "mock_acquisition", ",", "multi_source_acquisition_optimizer", ")", "\n", "next_points", "=", "seq", ".", "compute_next_points", "(", "loop_state_mock", ",", "context", "=", "{", "\"source\"", ":", "1.0", "}", ")", "\n", "\n", "# \"SequentialPointCalculator\" should only ever return 1 value", "\n", "assert", "len", "(", "next_points", ")", "==", "1", "\n", "# Context value should be what we set", "\n", "assert", "np", ".", "isclose", "(", "next_points", "[", "0", ",", "1", "]", ",", "1.0", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_steps.test_every_iteration_model_updater": [[18, 29], ["mock.create_autospec", "mock.create_autospec.optimize.return_value", "emukit.core.loop.FixedIntervalUpdater", "mock.create_autospec", "mock.create_autospec.X.return_value", "mock.create_autospec.Y.return_value", "emukit.core.loop.FixedIntervalUpdater.update", "mock.create_autospec.optimize.assert_called_once", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update"], ["def", "test_every_iteration_model_updater", "(", ")", ":", "\n", "    ", "mock_model", "=", "mock", ".", "create_autospec", "(", "IModel", ")", "\n", "mock_model", ".", "optimize", ".", "return_value", "(", "None", ")", "\n", "updater", "=", "FixedIntervalUpdater", "(", "mock_model", ",", "1", ")", "\n", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "loop_state_mock", ".", "iteration", "=", "1", "\n", "loop_state_mock", ".", "X", ".", "return_value", "(", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", ")", "\n", "loop_state_mock", ".", "Y", ".", "return_value", "(", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", ")", "\n", "updater", ".", "update", "(", "loop_state_mock", ")", "\n", "mock_model", ".", "optimize", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_steps.test_every_iteration_model_updater_with_cost": [[31, 66], ["MockModel", "emukit.core.loop.FixedIntervalUpdater", "mock.create_autospec", "mock.create_autospec.X.return_value", "numpy.random.rand", "numpy.random.rand", "emukit.core.loop.FixedIntervalUpdater.update", "numpy.array_equiv", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update"], ["", "def", "test_every_iteration_model_updater_with_cost", "(", ")", ":", "\n", "    ", "\"\"\"\n    Tests that the model updater can use a different attribute\n    from loop_state as the training targets\n    \"\"\"", "\n", "\n", "class", "MockModel", "(", "IModel", ")", ":", "\n", "        ", "def", "optimize", "(", "self", ")", ":", "\n", "            ", "pass", "\n", "\n", "", "def", "set_data", "(", "self", ",", "X", ":", "np", ".", "ndarray", ",", "Y", ":", "np", ".", "ndarray", ")", ":", "\n", "            ", "self", ".", "_X", "=", "X", "\n", "self", ".", "_Y", "=", "Y", "\n", "\n", "", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "_X", "\n", "\n", "", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "_Y", "\n", "\n", "", "", "mock_model", "=", "MockModel", "(", ")", "\n", "updater", "=", "FixedIntervalUpdater", "(", "mock_model", ",", "1", ",", "lambda", "loop_state", ":", "loop_state", ".", "cost", ")", "\n", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "loop_state_mock", ".", "iteration", "=", "1", "\n", "loop_state_mock", ".", "X", ".", "return_value", "(", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", ")", "\n", "\n", "loop_state_mock", ".", "cost", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "cost", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "loop_state_mock", ".", "cost", "=", "cost", "\n", "updater", ".", "update", "(", "loop_state_mock", ")", "\n", "assert", "np", ".", "array_equiv", "(", "mock_model", ".", "X", ",", "cost", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_steps.test_sequential_evaluator": [[68, 81], ["mock.create_autospec", "mock.create_autospec", "mock.create_autospec", "emukit.core.loop.SequentialPointCalculator", "emukit.core.loop.SequentialPointCalculator.compute_next_points", "numpy.equal", "numpy.array", "len", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "def", "test_sequential_evaluator", "(", ")", ":", "\n", "# SequentialPointCalculator should just return result of the acquisition optimizer", "\n", "    ", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "mock_acquisition_optimizer", "=", "mock", ".", "create_autospec", "(", "GradientAcquisitionOptimizer", ")", "\n", "mock_acquisition_optimizer", ".", "optimize", ".", "return_value", "=", "(", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", ",", "None", ")", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "seq", "=", "SequentialPointCalculator", "(", "mock_acquisition", ",", "mock_acquisition_optimizer", ")", "\n", "next_points", "=", "seq", ".", "compute_next_points", "(", "loop_state_mock", ")", "\n", "\n", "# \"SequentialPointCalculator\" should only ever return 1 value", "\n", "assert", "len", "(", "next_points", ")", "==", "1", "\n", "# Value should be result of acquisition optimization", "\n", "assert", "np", ".", "equal", "(", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", ",", "next_points", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_steps.test_sequential_with_context": [[83, 98], ["mock.create_autospec", "emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "mock.create_autospec", "emukit.core.loop.SequentialPointCalculator", "emukit.core.loop.SequentialPointCalculator.compute_next_points", "numpy.isclose", "len", "numpy.sum", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "def", "test_sequential_with_context", "(", ")", ":", "\n", "    ", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "mock_acquisition", ".", "has_gradients", "=", "False", "\n", "mock_acquisition", ".", "evaluate", "=", "lambda", "x", ":", "np", ".", "sum", "(", "x", "**", "2", ",", "axis", "=", "1", ")", "[", ":", ",", "None", "]", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"y\"", ",", "0", ",", "1", ")", "]", ")", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "seq", "=", "SequentialPointCalculator", "(", "mock_acquisition", ",", "acquisition_optimizer", ")", "\n", "next_points", "=", "seq", ".", "compute_next_points", "(", "loop_state_mock", ",", "context", "=", "{", "\"x\"", ":", "0.25", "}", ")", "\n", "\n", "# \"SequentialPointCalculator\" should only ever return 1 value", "\n", "assert", "len", "(", "next_points", ")", "==", "1", "\n", "# Context value should be what we set", "\n", "assert", "np", ".", "isclose", "(", "next_points", "[", "0", ",", "0", "]", ",", "0.25", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_steps.test_sequential_with_all_parameters_fixed": [[100, 111], ["mock.create_autospec", "emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "mock.create_autospec", "emukit.core.loop.SequentialPointCalculator", "emukit.core.loop.SequentialPointCalculator.compute_next_points", "numpy.array_equiv", "numpy.array", "numpy.sum", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "def", "test_sequential_with_all_parameters_fixed", "(", ")", ":", "\n", "    ", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "mock_acquisition", ".", "has_gradients", "=", "False", "\n", "mock_acquisition", ".", "evaluate", "=", "lambda", "x", ":", "np", ".", "sum", "(", "x", "**", "2", ",", "axis", "=", "1", ")", "[", ":", ",", "None", "]", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"y\"", ",", "0", ",", "1", ")", "]", ")", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "seq", "=", "SequentialPointCalculator", "(", "mock_acquisition", ",", "acquisition_optimizer", ")", "\n", "next_points", "=", "seq", ".", "compute_next_points", "(", "loop_state_mock", ",", "context", "=", "{", "\"x\"", ":", "0.25", ",", "\"y\"", ":", "0.25", "}", ")", "\n", "assert", "np", ".", "array_equiv", "(", "next_points", ",", "np", ".", "array", "(", "[", "0.25", ",", "0.25", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_steps.test_random_sampling_without_context": [[113, 119], ["emukit.core.ParameterSpace", "emukit.core.loop.RandomSampling", "mock.create_autospec", "emukit.core.loop.RandomSampling.compute_next_points", "len", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "def", "test_random_sampling_without_context", "(", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"y\"", ",", "0", ",", "1", ")", "]", ")", "\n", "rs", "=", "RandomSampling", "(", "space", ")", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "next_points", "=", "rs", ".", "compute_next_points", "(", "loop_state_mock", ")", "\n", "assert", "len", "(", "next_points", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_steps.test_random_sampling_with_context": [[121, 129], ["emukit.core.ParameterSpace", "emukit.core.loop.RandomSampling", "mock.create_autospec", "emukit.core.loop.RandomSampling.compute_next_points", "numpy.isclose", "len", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "def", "test_random_sampling_with_context", "(", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "ContinuousParameter", "(", "\"y\"", ",", "0", ",", "1", ")", "]", ")", "\n", "rs", "=", "RandomSampling", "(", "space", ")", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "next_points", "=", "rs", ".", "compute_next_points", "(", "loop_state_mock", ",", "context", "=", "{", "\"x\"", ":", "0.25", "}", ")", "\n", "assert", "len", "(", "next_points", ")", "==", "1", "\n", "# Context value should be what we set", "\n", "assert", "np", ".", "isclose", "(", "next_points", "[", "0", ",", "0", "]", ",", "0.25", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_steps.test_user_function_wrapper": [[131, 142], ["emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.UserFunctionWrapper.evaluate", "numpy.random.rand", "len"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_user_function_wrapper", "(", ")", ":", "\n", "    ", "def", "function_test", "(", "x", ")", ":", "\n", "        ", "return", "x", "[", ":", ",", "0", ":", "1", "]", "**", "2", "+", "x", "[", ":", ",", "1", ":", "2", "]", "**", "2", "\n", "\n", "", "user_function", "=", "UserFunctionWrapper", "(", "function_test", ")", "\n", "results", "=", "user_function", ".", "evaluate", "(", "np", ".", "random", ".", "rand", "(", "10", ",", "2", ")", ")", "\n", "\n", "assert", "len", "(", "results", ")", "==", "10", ",", "\"A different number of results were expected\"", "\n", "for", "res", "in", "results", ":", "\n", "        ", "assert", "res", ".", "X", ".", "ndim", "==", "1", ",", "\"X results are expected to be 1 dimensional\"", "\n", "assert", "res", ".", "Y", ".", "ndim", "==", "1", ",", "\"Y results are expected to be 1 dimensional\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.linear_constraint": [[7, 13], ["numpy.array", "numpy.array", "numpy.array", "emukit.core.constraints.LinearInequalityConstraint"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "linear_constraint", "(", ")", ":", "\n", "    ", "A", "=", "np", ".", "array", "(", "[", "[", "1.0", ",", "0.5", "]", "]", ")", "\n", "b_lower", "=", "np", ".", "array", "(", "[", "-", "5", "]", ")", "\n", "b_upper", "=", "np", ".", "array", "(", "[", "5", "]", ")", "\n", "return", "LinearInequalityConstraint", "(", "A", ",", "b_lower", ",", "b_upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.linear_constraint_2d": [[15, 21], ["numpy.array", "numpy.array", "numpy.array", "emukit.core.constraints.LinearInequalityConstraint"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "linear_constraint_2d", "(", ")", ":", "\n", "    ", "A", "=", "np", ".", "array", "(", "[", "[", "1.0", ",", "0.5", "]", ",", "[", "0.5", ",", "1.0", "]", "]", ")", "\n", "b_lower", "=", "np", ".", "array", "(", "[", "-", "5", ",", "-", "5", "]", ")", "\n", "b_upper", "=", "np", ".", "array", "(", "[", "5", ",", "5", "]", ")", "\n", "return", "LinearInequalityConstraint", "(", "A", ",", "b_lower", ",", "b_upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.nonlinear_constraint_no_jac": [[23, 29], ["numpy.array", "numpy.array", "emukit.core.constraints.NonlinearInequalityConstraint"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "nonlinear_constraint_no_jac", "(", ")", ":", "\n", "    ", "fun", "=", "lambda", "x", ":", "x", "[", "0", "]", "**", "2", "+", "x", "[", "1", "]", "**", "2", "\n", "b_lower", "=", "np", ".", "array", "(", "[", "-", "1", "]", ")", "\n", "b_upper", "=", "np", ".", "array", "(", "[", "1", "]", ")", "\n", "return", "NonlinearInequalityConstraint", "(", "fun", ",", "b_lower", ",", "b_upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_linear_inequality_constraint_input_dims_mismatch": [[31, 35], ["numpy.array", "pytest.raises", "linear_constraint.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_linear_inequality_constraint_input_dims_mismatch", "(", "linear_constraint", ")", ":", "\n", "    ", "x_test", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", "]", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "linear_constraint", ".", "evaluate", "(", "x_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_linear_inequality_constraint_bounds_dims_mismatch": [[37, 43], ["numpy.array", "numpy.array", "numpy.array", "pytest.raises", "emukit.core.constraints.LinearInequalityConstraint"], "function", ["None"], ["", "", "def", "test_linear_inequality_constraint_bounds_dims_mismatch", "(", ")", ":", "\n", "    ", "A", "=", "np", ".", "array", "(", "[", "[", "1.0", ",", "0.5", "]", ",", "[", "0.5", ",", "1.0", "]", "]", ")", "\n", "b_lower", "=", "np", ".", "array", "(", "[", "-", "5", ",", "-", "5", "]", ")", "\n", "b_upper", "=", "np", ".", "array", "(", "[", "5", "]", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "LinearInequalityConstraint", "(", "A", ",", "b_lower", ",", "b_upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_linear_inequality_constraint_satisfied": [[45, 48], ["numpy.array", "numpy.all", "linear_constraint.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "", "def", "test_linear_inequality_constraint_satisfied", "(", "linear_constraint", ")", ":", "\n", "    ", "x_test", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", "]", ")", "\n", "assert", "np", ".", "all", "(", "linear_constraint", ".", "evaluate", "(", "x_test", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_linear_inequality_constraint_satisfied_2d": [[50, 53], ["numpy.array", "numpy.all", "linear_constraint_2d.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_linear_inequality_constraint_satisfied_2d", "(", "linear_constraint_2d", ")", ":", "\n", "    ", "x_test", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", "]", ")", "\n", "assert", "np", ".", "all", "(", "linear_constraint_2d", ".", "evaluate", "(", "x_test", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_linear_inequality_constraint_violated": [[55, 58], ["numpy.array", "numpy.all", "linear_constraint.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_linear_inequality_constraint_violated", "(", "linear_constraint", ")", ":", "\n", "    ", "x_test", "=", "np", ".", "array", "(", "[", "[", "50", ",", "50", "]", ",", "[", "20", ",", "20", "]", "]", ")", "\n", "assert", "np", ".", "all", "(", "linear_constraint", ".", "evaluate", "(", "x_test", ")", ")", "==", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_linear_inequality_constraint_violated_2d": [[60, 63], ["numpy.array", "numpy.all", "linear_constraint_2d.evaluate"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_linear_inequality_constraint_violated_2d", "(", "linear_constraint_2d", ")", ":", "\n", "    ", "x_test", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "20", ",", "20", "]", "]", ")", "\n", "assert", "np", ".", "all", "(", "linear_constraint_2d", ".", "evaluate", "(", "x_test", ")", ")", "==", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_nonlinear_inequality_constraint_satisfied": [[65, 67], ["nonlinear_constraint_no_jac.evaluate", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_nonlinear_inequality_constraint_satisfied", "(", "nonlinear_constraint_no_jac", ")", ":", "\n", "    ", "assert", "nonlinear_constraint_no_jac", ".", "evaluate", "(", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", "]", ")", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_nonlinear_inequality_constraint_violated": [[69, 71], ["nonlinear_constraint_no_jac.evaluate", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "test_nonlinear_inequality_constraint_violated", "(", "nonlinear_constraint_no_jac", ")", ":", "\n", "    ", "assert", "nonlinear_constraint_no_jac", ".", "evaluate", "(", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", "]", ")", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_inequality_constraint_no_bounds": [[73, 76], ["pytest.raises", "emukit.core.constraints.InequalityConstraint"], "function", ["None"], ["", "def", "test_inequality_constraint_no_bounds", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "InequalityConstraint", "(", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_inequality_constraint_all_inf_bound": [[78, 84], ["numpy.array", "numpy.array", "pytest.raises", "emukit.core.constraints.InequalityConstraint"], "function", ["None"], ["", "", "def", "test_inequality_constraint_all_inf_bound", "(", ")", ":", "\n", "\n", "    ", "lower", "=", "np", ".", "array", "(", "[", "-", "np", ".", "inf", ",", "0", "]", ")", "\n", "upper", "=", "np", ".", "array", "(", "[", "np", ".", "inf", ",", "1", "]", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "InequalityConstraint", "(", "lower", ",", "upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_inequality_constraint_unbounded": [[86, 92], ["numpy.array", "pytest.raises", "emukit.core.constraints.InequalityConstraint"], "function", ["None"], ["", "", "def", "test_inequality_constraint_unbounded", "(", ")", ":", "\n", "\n", "    ", "lower", "=", "np", ".", "array", "(", "[", "-", "np", ".", "inf", ",", "0", "]", ")", "\n", "upper", "=", "None", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "InequalityConstraint", "(", "lower", ",", "upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_constraints.test_inequality_constraint_lower_bound_above_upper": [[94, 99], ["numpy.array", "numpy.array", "pytest.raises", "emukit.core.constraints.InequalityConstraint"], "function", ["None"], ["", "", "def", "test_inequality_constraint_lower_bound_above_upper", "(", ")", ":", "\n", "    ", "lower", "=", "np", ".", "array", "(", "[", "1", ",", "0", "]", ")", "\n", "upper", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "InequalityConstraint", "(", "lower", ",", "upper", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_state.test_create_loop_state": [[9, 18], ["numpy.array", "numpy.array", "emukit.core.loop.loop_state.create_loop_state", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state"], ["def", "test_create_loop_state", "(", ")", ":", "\n", "    ", "x_init", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "y_init", "=", "np", ".", "array", "(", "[", "[", "4", "]", ",", "[", "5", "]", ",", "[", "6", "]", "]", ")", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "x_init", ",", "y_init", ")", "\n", "\n", "assert_array_equal", "(", "loop_state", ".", "X", ",", "x_init", ")", "\n", "assert_array_equal", "(", "loop_state", ".", "Y", ",", "y_init", ")", "\n", "assert", "loop_state", ".", "iteration", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_state.test_create_loop_state_with_cost": [[20, 31], ["numpy.array", "numpy.array", "numpy.array", "emukit.core.loop.loop_state.create_loop_state", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state"], ["", "def", "test_create_loop_state_with_cost", "(", ")", ":", "\n", "    ", "x_init", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "y_init", "=", "np", ".", "array", "(", "[", "[", "4", "]", ",", "[", "5", "]", ",", "[", "6", "]", "]", ")", "\n", "cost", "=", "np", ".", "array", "(", "[", "[", "5", "]", ",", "[", "2", "]", ",", "[", "0", "]", "]", ")", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "x_init", ",", "y_init", ",", "cost", "=", "cost", ")", "\n", "\n", "assert_array_equal", "(", "loop_state", ".", "X", ",", "x_init", ")", "\n", "assert_array_equal", "(", "loop_state", ".", "Y", ",", "y_init", ")", "\n", "assert_array_equal", "(", "loop_state", ".", "cost", ",", "cost", ")", "\n", "assert", "loop_state", ".", "iteration", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_state.test_create_loop_error": [[33, 39], ["numpy.array", "numpy.array", "pytest.raises", "emukit.core.loop.loop_state.create_loop_state"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state"], ["", "def", "test_create_loop_error", "(", ")", ":", "\n", "    ", "x_init", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", "]", ")", "\n", "y_init", "=", "np", ".", "array", "(", "[", "[", "4", "]", ",", "[", "5", "]", "]", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "create_loop_state", "(", "x_init", ",", "y_init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_state.test_loop_state_update": [[41, 52], ["numpy.array", "numpy.array", "emukit.core.loop.loop_state.create_loop_state", "emukit.core.loop.user_function_result.UserFunctionResult", "emukit.core.loop.loop_state.create_loop_state.update", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update"], ["", "", "def", "test_loop_state_update", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", ",", "[", "4", "]", "]", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "[", "4", "]", ",", "[", "5", "]", ",", "[", "6", "]", ",", "[", "7", "]", "]", ")", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "x", "[", ":", "3", ",", ":", "]", ",", "y", "[", ":", "3", ",", ":", "]", ")", "\n", "step_result", "=", "UserFunctionResult", "(", "x", "[", "3", ",", ":", "]", ",", "y", "[", "3", ",", ":", "]", ")", "\n", "loop_state", ".", "update", "(", "[", "step_result", "]", ")", "\n", "\n", "assert_array_equal", "(", "loop_state", ".", "X", ",", "x", ")", "\n", "assert_array_equal", "(", "loop_state", ".", "Y", ",", "y", ")", "\n", "assert", "loop_state", ".", "iteration", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_state.test_loop_state_update_error": [[54, 64], ["numpy.array", "numpy.array", "emukit.core.loop.loop_state.create_loop_state", "pytest.raises", "emukit.core.loop.loop_state.create_loop_state.update", "pytest.raises", "emukit.core.loop.loop_state.create_loop_state.update"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update", "home.repos.pwc.inspect_result.amzn_emukit.loop.model_updaters.FixedIntervalUpdater.update"], ["", "def", "test_loop_state_update_error", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", ",", "[", "4", "]", "]", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "[", "4", "]", ",", "[", "5", "]", ",", "[", "6", "]", ",", "[", "7", "]", "]", ")", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "x", "[", ":", "3", ",", ":", "]", ",", "y", "[", ":", "3", ",", ":", "]", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "loop_state", ".", "update", "(", "None", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "loop_state", ".", "update", "(", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_loop_state.test_create_loop_state_wrong_size_input_fails": [[66, 73], ["numpy.array", "numpy.array", "numpy.array", "pytest.raises", "emukit.core.loop.loop_state.create_loop_state"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state"], ["", "", "def", "test_create_loop_state_wrong_size_input_fails", "(", ")", ":", "\n", "    ", "x", "=", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", ",", "[", "4", "]", "]", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "[", "4", "]", ",", "[", "5", "]", ",", "[", "6", "]", ",", "[", "7", "]", "]", ")", "\n", "c", "=", "np", ".", "array", "(", "[", "[", "4", "]", ",", "[", "5", "]", ",", "[", "6", "]", ",", "[", "7", "]", ",", "[", "8", "]", "]", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "create_loop_state", "(", "x", ",", "y", ",", "cost", "=", "c", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_categorical_parameter.test_categorical_parameter": [[9, 14], ["emukit.core.CategoricalParameter", "len"], "function", ["None"], ["def", "test_categorical_parameter", "(", "encoding", ")", ":", "\n", "    ", "param", "=", "CategoricalParameter", "(", "\"v\"", ",", "encoding", ")", "\n", "assert", "param", ".", "name", "==", "\"v\"", "\n", "assert", "param", ".", "dimension", "==", "3", "\n", "assert", "len", "(", "param", ".", "model_parameters", ")", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_categorical_parameter.test_categorical_parameter_rounding": [[16, 22], ["numpy.array", "mock.MagicMock", "emukit.core.CategoricalParameter", "numpy.testing.assert_array_equal", "emukit.core.CategoricalParameter.round", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "test_categorical_parameter_rounding", "(", "encoding", ")", ":", "\n", "    ", "expected", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", ",", "4", "]", ",", "[", "2", ",", "3", ",", "5", "]", "]", ")", "\n", "encoding", ".", "round", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "expected", ")", "\n", "param", "=", "CategoricalParameter", "(", "\"v\"", ",", "encoding", ")", "\n", "\n", "assert_array_equal", "(", "param", ".", "round", "(", "np", ".", "ones", "(", "(", "2", ",", "3", ")", ")", ")", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_categorical_parameter.test_categorical_parameter_check_in_domain": [[24, 34], ["emukit.core.CategoricalParameter", "emukit.core.CategoricalParameter.check_in_domain", "numpy.array", "emukit.core.CategoricalParameter.check_in_domain", "pytest.raises", "emukit.core.CategoricalParameter.check_in_domain", "pytest.raises", "emukit.core.CategoricalParameter.check_in_domain", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain"], ["", "def", "test_categorical_parameter_check_in_domain", "(", "encoding", ")", ":", "\n", "    ", "param", "=", "CategoricalParameter", "(", "\"v\"", ",", "encoding", ")", "\n", "\n", "assert", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0.5", ",", "0", "]", "]", ")", ")", "\n", "assert", "not", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "2", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0.5", ",", "0", "]", "]", ")", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# wrong encoding dimension", "\n", "        ", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0.5", "]", "]", ")", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "# not a 2d array", "\n", "        ", "param", ".", "check_in_domain", "(", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_categorical_parameter.test_categorical_parameter_str_repr": [[36, 40], ["emukit.core.CategoricalParameter", "str", "repr"], "function", ["None"], ["", "", "def", "test_categorical_parameter_str_repr", "(", "encoding", ")", ":", "\n", "    ", "param", "=", "CategoricalParameter", "(", "\"v\"", ",", "encoding", ")", "\n", "_", "=", "str", "(", "param", ")", "\n", "_", "=", "repr", "(", "param", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop": [[13, 15], ["None"], "methods", ["None"], ["    ", "def", "should_stop", "(", "self", ",", "loop_state", ":", "LoopState", ")", "->", "bool", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.test_fixed_iteration_stopping_condition": [[17, 31], ["emukit.core.loop.FixedIterationsStoppingCondition", "mock.create_autospec", "emukit.core.loop.FixedIterationsStoppingCondition.should_stop", "emukit.core.loop.FixedIterationsStoppingCondition.should_stop", "emukit.core.loop.FixedIterationsStoppingCondition.should_stop"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop"], ["", "", "def", "test_fixed_iteration_stopping_condition", "(", ")", ":", "\n", "    ", "n_iterations", "=", "5", "\n", "\n", "stopping_condition", "=", "FixedIterationsStoppingCondition", "(", "n_iterations", ")", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "\n", "loop_state_mock", ".", "iteration", "=", "0", "\n", "assert", "stopping_condition", ".", "should_stop", "(", "loop_state_mock", ")", "is", "False", "\n", "\n", "loop_state_mock", ".", "iteration", "=", "n_iterations", "-", "1", "\n", "assert", "stopping_condition", ".", "should_stop", "(", "loop_state_mock", ")", "is", "False", "\n", "\n", "loop_state_mock", ".", "iteration", "=", "n_iterations", "\n", "assert", "stopping_condition", ".", "should_stop", "(", "loop_state_mock", ")", "is", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.test_convergence_stopping_condition": [[33, 53], ["emukit.core.loop.ConvergenceStoppingCondition", "mock.create_autospec", "numpy.array", "mock.create_autospec", "numpy.array", "mock.create_autospec", "mock.create_autospec.X.return_value", "emukit.core.loop.ConvergenceStoppingCondition.should_stop", "emukit.core.loop.ConvergenceStoppingCondition.should_stop", "numpy.array", "emukit.core.loop.ConvergenceStoppingCondition.should_stop"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop"], ["", "def", "test_convergence_stopping_condition", "(", ")", ":", "\n", "    ", "stopping_condition", "=", "ConvergenceStoppingCondition", "(", "0.1", ")", "\n", "\n", "# check if we stop before criterion can be calculated", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "loop_state_mock", ".", "iteration", "=", "1", "\n", "loop_state_mock", ".", "X", "=", "np", ".", "array", "(", "[", "[", "0", "]", "]", ")", "\n", "assert", "stopping_condition", ".", "should_stop", "(", "loop_state_mock", ")", "is", "False", "\n", "\n", "# check if we stop when we should not", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "loop_state_mock", ".", "iteration", "=", "5", "\n", "loop_state_mock", ".", "X", "=", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "10", "]", ",", "[", "20", "]", ",", "[", "30", "]", ",", "[", "40", "]", "]", ")", "\n", "assert", "stopping_condition", ".", "should_stop", "(", "loop_state_mock", ")", "is", "False", "\n", "\n", "# check if we stop when we should", "\n", "loop_state_mock", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "loop_state_mock", ".", "iteration", "=", "5", "\n", "loop_state_mock", ".", "X", ".", "return_value", "(", "np", ".", "array", "(", "[", "[", "0", "]", ",", "[", "1", "]", ",", "[", "2", "]", ",", "[", "3", "]", ",", "[", "3.01", "]", "]", ")", ")", "\n", "assert", "stopping_condition", ".", "should_stop", "(", "loop_state_mock", ")", "is", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.test_operations_with_conditions": [[55, 87], ["test_stopping_conditions.DummyStoppingCondition", "test_stopping_conditions.DummyStoppingCondition", "mock.create_autospec", "mock.MagicMock", "mock.MagicMock", "mock.MagicMock", "mock.MagicMock", "mock.MagicMock", "mock.MagicMock", "mock.MagicMock", "mock.MagicMock", "mock.MagicMock", "mock.MagicMock", "or_condition.should_stop", "and_condition.should_stop", "or_condition.should_stop", "and_condition.should_stop", "or_condition.should_stop", "and_condition.should_stop", "or_condition.should_stop", "and_condition.should_stop", "complex_combination.should_stop"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop", "home.repos.pwc.inspect_result.amzn_emukit.core.test_stopping_conditions.DummyStoppingCondition.should_stop"], ["", "def", "test_operations_with_conditions", "(", ")", ":", "\n", "    ", "left_condition", "=", "DummyStoppingCondition", "(", ")", "\n", "right_condition", "=", "DummyStoppingCondition", "(", ")", "\n", "mock_loop_state", "=", "mock", ".", "create_autospec", "(", "LoopState", ")", "\n", "\n", "or_condition", "=", "left_condition", "|", "right_condition", "\n", "and_condition", "=", "left_condition", "&", "right_condition", "\n", "\n", "left_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "True", ")", "\n", "right_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "True", ")", "\n", "assert", "or_condition", ".", "should_stop", "(", "mock_loop_state", ")", "is", "True", "\n", "assert", "and_condition", ".", "should_stop", "(", "mock_loop_state", ")", "is", "True", "\n", "\n", "left_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "True", ")", "\n", "right_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "False", ")", "\n", "assert", "or_condition", ".", "should_stop", "(", "mock_loop_state", ")", "is", "True", "\n", "assert", "and_condition", ".", "should_stop", "(", "mock_loop_state", ")", "is", "False", "\n", "\n", "left_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "False", ")", "\n", "right_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "True", ")", "\n", "assert", "or_condition", ".", "should_stop", "(", "mock_loop_state", ")", "is", "True", "\n", "assert", "and_condition", ".", "should_stop", "(", "mock_loop_state", ")", "is", "False", "\n", "\n", "left_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "False", ")", "\n", "right_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "False", ")", "\n", "assert", "or_condition", ".", "should_stop", "(", "mock_loop_state", ")", "is", "False", "\n", "assert", "and_condition", ".", "should_stop", "(", "mock_loop_state", ")", "is", "False", "\n", "\n", "complex_combination", "=", "(", "left_condition", "|", "right_condition", ")", "&", "left_condition", "\n", "left_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "False", ")", "\n", "right_condition", ".", "should_stop", "=", "mock", ".", "MagicMock", "(", "return_value", "=", "True", ")", "\n", "assert", "complex_combination", ".", "should_stop", "(", "mock_loop_state", ")", "is", "False", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.__init__": [[21, 56], ["ParameterSpace", "ParameterSpace", "context.items", "list", "context_manager.ContextManager.space.find_parameter_index_in_model", "context_manager.ContextManager.space.get_parameter_by_name", "hasattr", "range", "context_manager.ContextManager.check_in_domain", "context_manager.ContextManager.context_values.append", "_log.info", "context_manager.ContextManager.context_values.extend", "ValueError", "_log.info", "_log.warning", "context_manager.ContextManager.encoding.get_encoding"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.find_parameter_index_in_model", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_parameter_by_name", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.check_in_domain", "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.Encoding.get_encoding"], ["def", "__init__", "(", "self", ",", "space", ":", "ParameterSpace", ",", "context", ":", "Context", ")", ":", "\n", "        ", "\"\"\"\n        :param space: Parameter space of the search problem.\n        :param context: Dictionary of variables and their context values.\n                        These values are fixed while optimization.\n        \"\"\"", "\n", "self", ".", "context", "=", "context", "\n", "self", ".", "space", "=", "space", "\n", "self", ".", "contextfree_space", "=", "ParameterSpace", "(", "[", "param", "for", "param", "in", "self", ".", "space", ".", "parameters", "if", "param", ".", "name", "not", "in", "context", "]", ")", "\n", "self", ".", "context_space", "=", "ParameterSpace", "(", "[", "param", "for", "param", "in", "self", ".", "space", ".", "parameters", "if", "param", ".", "name", "in", "context", "]", ")", "\n", "\n", "# Find indices of context and non context variables", "\n", "self", ".", "context_idxs", "=", "[", "]", "\n", "self", ".", "context_values", "=", "[", "]", "\n", "for", "context_name", ",", "context_value", "in", "context", ".", "items", "(", ")", ":", "\n", "# Find indices of variable in the input domain", "\n", "            ", "self", ".", "context_idxs", "+=", "self", ".", "space", ".", "find_parameter_index_in_model", "(", "context_name", ")", "\n", "\n", "# Find encoded values of context variable", "\n", "param", "=", "self", ".", "space", ".", "get_parameter_by_name", "(", "context_name", ")", "\n", "if", "hasattr", "(", "param", ",", "\"encoding\"", ")", ":", "\n", "                ", "if", "context_value", "in", "param", ".", "encoding", ".", "categories", ":", "\n", "                    ", "_log", ".", "info", "(", "f\"Parameter {context_name} fixed to {context_value}\"", ")", "\n", "self", ".", "context_values", ".", "extend", "(", "param", ".", "encoding", ".", "get_encoding", "(", "context_value", ")", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "f\"Context value {context_value} not found in encoding for {context_name}\"", ")", "\n", "", "", "else", ":", "\n", "                ", "if", "param", ".", "check_in_domain", "(", "context_value", ")", ":", "\n", "                    ", "_log", ".", "info", "(", "f\"Parameter {context_name} fixed to {context_value}\"", ")", "\n", "", "else", ":", "\n", "                    ", "_log", ".", "warning", "(", "f\"{context_name} with value {context_value} is out of the domain\"", ")", "\n", "", "self", ".", "context_values", ".", "append", "(", "context_value", ")", "\n", "\n", "", "", "all_idxs", "=", "list", "(", "range", "(", "space", ".", "dimensionality", ")", ")", "\n", "self", ".", "non_context_idxs", "=", "[", "idx", "for", "idx", "in", "all_idxs", "if", "idx", "not", "in", "self", ".", "context_idxs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector": [[57, 72], ["len", "numpy.atleast_2d", "numpy.zeros", "numpy.array().astype", "numpy.array().astype", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "expand_vector", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Expand context free parameter vector by values of the context.\n\n        :param x: Context free parameter values as 2d-array\n        :return: Parameter values with inserted context values\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "context_space", ".", "parameters", ")", "==", "0", ":", "\n", "            ", "return", "x", "\n", "", "else", ":", "\n", "            ", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "x_expanded", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "space", ".", "dimensionality", ")", ")", "\n", "x_expanded", "[", ":", ",", "np", ".", "array", "(", "self", ".", "non_context_idxs", ")", ".", "astype", "(", "int", ")", "]", "=", "x", "\n", "x_expanded", "[", ":", ",", "np", ".", "array", "(", "self", ".", "context_idxs", ")", ".", "astype", "(", "int", ")", "]", "=", "self", ".", "context_values", "\n", "return", "x_expanded", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer.__init__": [[21, 31], ["acquisition_optimizer.AcquisitionOptimizerBase.__init__", "multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer._get_information_source_parameter", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer._get_information_source_parameter"], ["def", "__init__", "(", "self", ",", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", ",", "space", ":", "ParameterSpace", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param acquisition_optimizer: Optimizer to use for optimizing the acquisition once the information source\n                                      has been fixed\n        :param space: Domain to search for maximum over\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "space", ")", "\n", "self", ".", "acquisition_optimizer", "=", "acquisition_optimizer", "\n", "self", ".", "source_parameter", "=", "self", ".", "_get_information_source_parameter", "(", ")", "\n", "self", ".", "n_sources", "=", "np", ".", "array", "(", "self", ".", "source_parameter", ".", "domain", ")", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer._get_information_source_parameter": [[32, 40], ["len", "ValueError", "isinstance"], "methods", ["None"], ["", "def", "_get_information_source_parameter", "(", "self", ")", "->", "InformationSourceParameter", ":", "\n", "        ", "\"\"\"\n        :return: The parameter containing the index of the information source\n        \"\"\"", "\n", "source_parameter", "=", "[", "param", "for", "param", "in", "self", ".", "space", ".", "parameters", "if", "isinstance", "(", "param", ",", "InformationSourceParameter", ")", "]", "\n", "if", "len", "(", "source_parameter", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"No source parameter found\"", ")", "\n", "", "return", "source_parameter", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer._optimize": [[41, 49], ["None"], "methods", ["None"], ["", "def", "_optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context_manager", ":", "ContextManager", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Implementation of abstract method. Does nothing, optimize overwritten instead.\n\n        See AcquisitionOptimizerBase._optimizer for parameter descriptions.\n        See class docstring for implementation details.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer.optimize": [[50, 79], ["numpy.zeros", "range", "numpy.argmax", "len", "dict", "len", "multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer.acquisition_optimizer.optimize", "x_opts.append", "numpy.max", "multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer.acquisition_optimizer.optimize"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context", ":", "Optional", "[", "Context", "]", "=", "None", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Computes the location and source of the next point to evaluate by finding the maximum input location at each\n        information source, then picking the information source where the value of the acquisition at the optimum input\n        location is highest.\n\n        :param acquisition: The acquisition function to be optimized\n        :param context: Contains variables to fix through optimization of acquisition function. The dictionary key is\n                        the parameter name and the value is the value to fix the parameter to.\n        :return: A tuple of (location of maximum, acquisition value at maximum)\n        \"\"\"", "\n", "f_maxs", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "source_parameter", ".", "domain", ")", ")", ")", "\n", "x_opts", "=", "[", "]", "\n", "\n", "if", "context", "is", "None", ":", "\n", "            ", "context", "=", "dict", "(", ")", "\n", "", "elif", "self", ".", "source_parameter", ".", "name", "in", "context", ":", "\n", "# Information source parameter already has a context so just optimise the acquisition at this source", "\n", "            ", "return", "self", ".", "acquisition_optimizer", ".", "optimize", "(", "acquisition", ",", "context", ")", "\n", "\n", "# Optimize acquisition for each information source", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "source_parameter", ".", "domain", ")", ")", ":", "\n", "# Fix the source using a dictionary, the key is the name of the parameter to fix and the value is the", "\n", "# value to which the parameter is fixed", "\n", "            ", "context", "[", "self", ".", "source_parameter", ".", "name", "]", "=", "self", ".", "source_parameter", ".", "domain", "[", "i", "]", "\n", "x", ",", "f_maxs", "[", "i", "]", "=", "self", ".", "acquisition_optimizer", ".", "optimize", "(", "acquisition", ",", "context", ")", "\n", "x_opts", ".", "append", "(", "x", ")", "\n", "", "best_source", "=", "np", ".", "argmax", "(", "f_maxs", ")", "\n", "return", "x_opts", "[", "best_source", "]", ",", "np", ".", "max", "(", "f_maxs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.gradient_acquisition_optimizer.GradientAcquisitionOptimizer.__init__": [[24, 31], ["acquisition_optimizer.AcquisitionOptimizerBase.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "space", ":", "ParameterSpace", ",", "num_samples", "=", "1000", ",", "num_anchor", "=", "1", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param space: The parameter space spanning the search problem.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "space", ")", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "self", ".", "num_anchor", "=", "num_anchor", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.gradient_acquisition_optimizer.GradientAcquisitionOptimizer._optimize": [[32, 75], ["gradient_acquisition_optimizer.GradientAcquisitionOptimizer._get_optimizer", "anchor_points_generator.ObjectiveAnchorPointsGenerator.ObjectiveAnchorPointsGenerator", "anchor_points_generator.ObjectiveAnchorPointsGenerator.ObjectiveAnchorPointsGenerator.get", "_log.info", "min", "len", "_log.warning", "gradient_acquisition_optimizer.GradientAcquisitionOptimizer.apply_optimizer", "optimized_points.append", "acquisition.evaluate", "numpy.array", "f", "acquisition.evaluate_with_gradients", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.gradient_acquisition_optimizer.GradientAcquisitionOptimizer._get_optimizer", "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "_optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context_manager", ":", "ContextManager", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Implementation of abstract method.\n        Taking into account gradients if acquisition supports them.\n\n        See AcquisitionOptimizerBase._optimizer for parameter descriptions.\n        See class docstring for implementation details.\n        \"\"\"", "\n", "\n", "# Take negative of acquisition function because they are to be maximised and the optimizers minimise", "\n", "f", "=", "lambda", "x", ":", "-", "acquisition", ".", "evaluate", "(", "x", ")", "\n", "\n", "# Context validation", "\n", "if", "len", "(", "context_manager", ".", "contextfree_space", ".", "parameters", ")", "==", "0", ":", "\n", "            ", "_log", ".", "warning", "(", "\"All parameters are fixed through context\"", ")", "\n", "x", "=", "np", ".", "array", "(", "context_manager", ".", "context_values", ")", "[", "None", ",", ":", "]", "\n", "return", "x", ",", "f", "(", "x", ")", "\n", "\n", "", "if", "acquisition", ".", "has_gradients", ":", "\n", "\n", "            ", "def", "f_df", "(", "x", ")", ":", "\n", "                ", "f_value", ",", "df_value", "=", "acquisition", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "return", "-", "f_value", ",", "-", "df_value", "\n", "\n", "", "", "else", ":", "\n", "            ", "f_df", "=", "None", "\n", "\n", "", "optimizer", "=", "self", ".", "_get_optimizer", "(", "context_manager", ")", "\n", "anchor_points_generator", "=", "ObjectiveAnchorPointsGenerator", "(", "self", ".", "space", ",", "acquisition", ",", "num_samples", "=", "self", ".", "num_samples", ")", "\n", "\n", "# Select the anchor points (with context)", "\n", "anchor_points", "=", "anchor_points_generator", ".", "get", "(", "num_anchor", "=", "self", ".", "num_anchor", ",", "context_manager", "=", "context_manager", ")", "\n", "\n", "_log", ".", "info", "(", "\"Starting gradient-based optimization of acquisition function {}\"", ".", "format", "(", "type", "(", "acquisition", ")", ")", ")", "\n", "optimized_points", "=", "[", "]", "\n", "for", "a", "in", "anchor_points", ":", "\n", "            ", "optimized_point", "=", "apply_optimizer", "(", "\n", "optimizer", ",", "a", ",", "space", "=", "self", ".", "space", ",", "f", "=", "f", ",", "df", "=", "None", ",", "f_df", "=", "f_df", ",", "context_manager", "=", "context_manager", "\n", ")", "\n", "optimized_points", ".", "append", "(", "optimized_point", ")", "\n", "\n", "", "x_min", ",", "fx_min", "=", "min", "(", "optimized_points", ",", "key", "=", "lambda", "t", ":", "t", "[", "1", "]", ")", "\n", "return", "x_min", ",", "-", "fx_min", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.gradient_acquisition_optimizer.GradientAcquisitionOptimizer._get_optimizer": [[76, 81], ["len", "optimizer.OptLbfgs", "optimizer.OptTrustRegionConstrained", "context_manager.contextfree_space.get_bounds", "context_manager.contextfree_space.get_bounds"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_bounds", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_bounds"], ["", "def", "_get_optimizer", "(", "self", ",", "context_manager", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "space", ".", "constraints", ")", "==", "0", ":", "\n", "            ", "return", "OptLbfgs", "(", "context_manager", ".", "contextfree_space", ".", "get_bounds", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "OptTrustRegionConstrained", "(", "context_manager", ".", "contextfree_space", ".", "get_bounds", "(", ")", ",", "self", ".", "space", ".", "constraints", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.__init__": [[22, 31], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "space", ":", "ParameterSpace", ",", "num_samples", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n\n        :param space: Parameter space describing the input domain of the model\n        :param num_samples: Number of initial samples to draw uniformly from the input domain. These points are then\n                            evaluated according to logic implemented in the subclasses, and the best are picked\n        \"\"\"", "\n", "self", ".", "space", "=", "space", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get_anchor_point_scores": [[32, 41], ["NotImplementedError"], "methods", ["None"], ["", "def", "get_anchor_point_scores", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        This abstract method should contain the logic to ascribe scores to different points in the input domain.\n        Points with higher scores will be chosen over points with lower scores.\n\n        :param X: (n_samples x n_inputs_dims) arrays containing the points at which to evaluate the anchor point scores\n        :return: Array containing score for each input point\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"get_anchor_point_scores is not implemented in the parent class.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get": [[42, 70], ["space.sample_uniform", "anchor_points_generator.AnchorPointsGenerator.get_anchor_point_scores", "ValueError", "context_manager.expand_vector", "numpy.argsort", "min", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator.get_anchor_point_scores", "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector"], ["", "def", "get", "(", "self", ",", "num_anchor", ":", "int", "=", "5", ",", "context_manager", ":", "ContextManager", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :param num_anchor: Number of points to return\n        :param context_manager: Describes any fixed parameters in the optimization\n        :return: A (num_anchor x n_dims) array containing the anchor points\n        \"\"\"", "\n", "if", "num_anchor", ">", "self", ".", "num_samples", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Cannot return more points than were originally sampled, got {num_anchor} num_anchor for {self.num_samples} points sampled.\"", "\n", ")", "\n", "\n", "# We use the context handler to remove duplicates only over the non-context variables", "\n", "", "if", "context_manager", "is", "not", "None", ":", "\n", "            ", "space", "=", "context_manager", ".", "contextfree_space", "\n", "", "else", ":", "\n", "            ", "space", "=", "self", ".", "space", "\n", "\n", "# Generate initial design", "\n", "", "X", "=", "space", ".", "sample_uniform", "(", "self", ".", "num_samples", ")", "\n", "\n", "# Add context variables", "\n", "if", "context_manager", ":", "\n", "            ", "X", "=", "context_manager", ".", "expand_vector", "(", "X", ")", "\n", "", "scores", "=", "self", ".", "get_anchor_point_scores", "(", "X", ")", "\n", "sorted_idxs", "=", "np", ".", "argsort", "(", "scores", ")", "[", ":", ":", "-", "1", "]", "\n", "anchor_points", "=", "X", "[", "sorted_idxs", "[", ":", "min", "(", "len", "(", "scores", ")", ",", "num_anchor", ")", "]", ",", ":", "]", "\n", "\n", "return", "anchor_points", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator.__init__": [[77, 85], ["anchor_points_generator.AnchorPointsGenerator.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "space", ":", "ParameterSpace", ",", "acquisition", ":", "Acquisition", ",", "num_samples", ":", "int", "=", "1000", ")", ":", "\n", "        ", "\"\"\"\n        :param space: The parameter space describing the input domain of the non-context variables\n        :param acquisition: The acquisition function\n        :param num_samples: The number of points at which the anchor point scores are calculated\n        \"\"\"", "\n", "self", ".", "acquisition", "=", "acquisition", "\n", "super", "(", "ObjectiveAnchorPointsGenerator", ",", "self", ")", ".", "__init__", "(", "space", ",", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator.get_anchor_point_scores": [[86, 98], ["numpy.all", "numpy.zeros", "anchor_points_generator.ObjectiveAnchorPointsGenerator.acquisition.evaluate", "numpy.ones", "c.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "get_anchor_point_scores", "(", "self", ",", "X", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        :param X: The samples at which to evaluate the criterion\n        :return:\n        \"\"\"", "\n", "are_constraints_satisfied", "=", "np", ".", "all", "(", "\n", "[", "np", ".", "ones", "(", "X", ".", "shape", "[", "0", "]", ")", "]", "+", "[", "c", ".", "evaluate", "(", "X", ")", "for", "c", "in", "self", ".", "space", ".", "constraints", "]", ",", "axis", "=", "0", "\n", ")", "\n", "scores", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "scores", "[", "~", "are_constraints_satisfied", "]", "=", "-", "np", ".", "inf", "\n", "scores", "[", "are_constraints_satisfied", "]", "=", "self", ".", "acquisition", ".", "evaluate", "(", "X", "[", "are_constraints_satisfied", ",", ":", "]", ")", "[", ":", ",", "0", "]", "\n", "return", "scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer.__init__": [[56, 76], ["acquisition_optimizer.AcquisitionOptimizerBase.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "num_steps", ":", "int", "=", "10", ",", "\n", "num_init_points", ":", "int", "=", "5", ",", "\n", "std_dev", ":", "float", "=", "0.02", ",", "\n", "num_continuous", ":", "int", "=", "4", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param space: The parameter space spanning the search problem.\n        :param num_steps: Maximum number of steps to follow from each start point.\n        :param num_init_points: Number of initial sampled points where the local search starts.\n        :param std_dev: Neighbourhood sampling standard deviation of continuous parameters.\n        :param num_continuous: Number of sampled neighbourhoods per continuous parameter.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "space", ")", "\n", "self", ".", "num_steps", "=", "num_steps", "\n", "self", ".", "num_init_points", "=", "num_init_points", "\n", "self", ".", "std_dev", "=", "std_dev", "\n", "self", ".", "num_continuous", "=", "num_continuous", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._neighbours_per_parameter": [[77, 121], ["parameter.round().ravel", "isinstance", "isinstance", "isinstance", "parameter.round", "numpy.unique", "neighbours.append", "isinstance", "numpy.argmin", "neighbours.append", "isinstance", "all_features[].reshape", "left_right[].reshape", "neighbours.append", "TypeError", "numpy.abs", "this_neighbours.append", "this_neighbours.append", "numpy.asarray().reshape", "neighbours.append", "TypeError", "parameter.encoding.round_row", "parameter.encoding.round_row", "numpy.subtract", "len", "len", "numpy.random.normal", "numpy.vstack", "type", "parameter.round().ravel.item", "numpy.asarray", "parameter.round().ravel.item", "samples.append", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round", "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.OrdinalEncoding.round_row", "home.repos.pwc.inspect_result.amzn_emukit.core.encodings.OrdinalEncoding.round_row"], ["", "def", "_neighbours_per_parameter", "(", "self", ",", "all_features", ":", "np", ".", "ndarray", ",", "parameters", ":", "Sequence", "[", "Parameter", "]", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Generates parameter encodings for one-exchange neighbours of\n            parameters encoded in parameter feature vector\n\n        :param all_features: The encoded parameter point (1d-array)\n        :return: List of numpy arrays. Each array contains all one-exchange encodings of a parameter\n        \"\"\"", "\n", "neighbours", "=", "[", "]", "\n", "current_feature", "=", "0", "\n", "for", "parameter", "in", "parameters", ":", "\n", "            ", "features", "=", "parameter", ".", "round", "(", "\n", "all_features", "[", "current_feature", ":", "(", "current_feature", "+", "parameter", ".", "dimension", ")", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", ")", ".", "ravel", "(", ")", "\n", "if", "isinstance", "(", "parameter", ",", "CategoricalParameter", ")", ":", "\n", "                ", "if", "isinstance", "(", "parameter", ".", "encoding", ",", "OrdinalEncoding", ")", ":", "\n", "                    ", "left_right", "=", "np", ".", "unique", "(", "\n", "[", "parameter", ".", "encoding", ".", "round_row", "(", "features", "-", "1", ")", ",", "parameter", ".", "encoding", ".", "round_row", "(", "features", "+", "1", ")", "]", "\n", ")", "\n", "neighbours", ".", "append", "(", "left_right", "[", "left_right", "!=", "features", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "", "elif", "isinstance", "(", "parameter", ".", "encoding", ",", "OneHotEncoding", ")", ":", "\n", "# All categories apart from current one are valid neighbours with one hot encoding", "\n", "                    ", "neighbours", ".", "append", "(", "parameter", ".", "encodings", "[", "(", "parameter", ".", "encodings", "!=", "features", ")", ".", "any", "(", "axis", "=", "1", ")", "]", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "TypeError", "(", "\"{} not a supported parameter encoding.\"", ".", "format", "(", "type", "(", "parameter", ".", "encoding", ")", ")", ")", "\n", "", "", "elif", "isinstance", "(", "parameter", ",", "DiscreteParameter", ")", ":", "\n", "# Find current position in domain while being robust to numerical precision problems", "\n", "                ", "current_index", "=", "np", ".", "argmin", "(", "np", ".", "abs", "(", "np", ".", "subtract", "(", "parameter", ".", "domain", ",", "features", ".", "item", "(", ")", ")", ")", ")", "\n", "this_neighbours", "=", "[", "]", "\n", "if", "current_index", ">", "0", ":", "\n", "                    ", "this_neighbours", ".", "append", "(", "[", "parameter", ".", "domain", "[", "current_index", "-", "1", "]", "]", ")", "\n", "", "if", "current_index", "<", "len", "(", "parameter", ".", "domain", ")", "-", "1", ":", "\n", "                    ", "this_neighbours", ".", "append", "(", "[", "parameter", ".", "domain", "[", "current_index", "+", "1", "]", "]", ")", "\n", "", "neighbours", ".", "append", "(", "np", ".", "asarray", "(", "this_neighbours", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "", "elif", "isinstance", "(", "parameter", ",", "ContinuousParameter", ")", ":", "\n", "                ", "samples", ",", "param_range", "=", "[", "]", ",", "parameter", ".", "max", "-", "parameter", ".", "min", "\n", "while", "len", "(", "samples", ")", "<", "self", ".", "num_continuous", ":", "\n", "                    ", "sample", "=", "np", ".", "random", ".", "normal", "(", "features", ".", "item", "(", ")", ",", "self", ".", "std_dev", "*", "param_range", ",", "(", "1", ",", "1", ")", ")", "\n", "if", "parameter", ".", "min", "<=", "sample", "<=", "parameter", ".", "max", ":", "\n", "                        ", "samples", ".", "append", "(", "sample", ")", "\n", "", "", "neighbours", ".", "append", "(", "np", ".", "vstack", "(", "samples", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "\"{} not a supported parameter type.\"", ".", "format", "(", "type", "(", "parameter", ")", ")", ")", "\n", "", "current_feature", "+=", "parameter", ".", "dimension", "\n", "", "return", "neighbours", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._neighbours": [[122, 138], ["local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._neighbours_per_parameter", "sum", "numpy.full"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._neighbours_per_parameter"], ["", "def", "_neighbours", "(", "self", ",", "all_features", ":", "np", ".", "ndarray", ",", "parameters", ":", "Sequence", "[", "Parameter", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Generates one-exchange neighbours of encoded parameter point.\n\n        :param all_features: The encoded parameter point (1d-array)\n        :return: All one-exchange neighbours as 2d-array (neighbours, features)\n        \"\"\"", "\n", "neighbours_per_param", "=", "self", ".", "_neighbours_per_parameter", "(", "all_features", ",", "parameters", ")", "\n", "num_neighbours", "=", "sum", "(", "param", ".", "shape", "[", "0", "]", "for", "param", "in", "neighbours_per_param", ")", "\n", "neighbours", "=", "np", ".", "full", "(", "(", "num_neighbours", ",", "all_features", ".", "shape", "[", "0", "]", ")", ",", "all_features", ")", "\n", "current_neighbour", ",", "current_feature", "=", "0", ",", "0", "\n", "for", "this_neighbours", "in", "neighbours_per_param", ":", "\n", "            ", "next_neighbour", "=", "current_neighbour", "+", "this_neighbours", ".", "shape", "[", "0", "]", "\n", "next_feature", "=", "current_feature", "+", "this_neighbours", ".", "shape", "[", "1", "]", "\n", "neighbours", "[", "current_neighbour", ":", "next_neighbour", ",", "current_feature", ":", "next_feature", "]", "=", "this_neighbours", "\n", "current_neighbour", ",", "current_feature", "=", "next_neighbour", ",", "next_feature", "\n", "", "return", "neighbours", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._one_local_search": [[139, 167], ["acquisition.evaluate().item", "_log.debug", "range", "_log.debug", "local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._neighbours", "context_manager.expand_vector", "acquisition.evaluate", "numpy.argmax", "acquisition_values[].item", "acquisition.evaluate", "str", "_log.debug", "str", "x.reshape", "str"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._neighbours", "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "_one_local_search", "(", "\n", "self", ",", "acquisition", ":", "Acquisition", ",", "x", ":", "np", ".", "ndarray", ",", "context_manager", ":", "Optional", "[", "ContextManager", "]", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"Local maximum search on acquisition starting at a single point.\n\n        :param acquisition: The acquisition the maximum is searched of.\n        :param x: The initial point.\n        :return: Tuple of (maximum point as 1d-array, value of acquisition at this point)\n        \"\"\"", "\n", "incumbent_value", "=", "acquisition", ".", "evaluate", "(", "x", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ".", "item", "(", ")", "\n", "_log", ".", "debug", "(", "\"Start local search with acquisition={:.4f} at {}\"", ".", "format", "(", "incumbent_value", ",", "str", "(", "x", ")", ")", ")", "\n", "for", "step", "in", "range", "(", "self", ".", "num_steps", ")", ":", "\n", "            ", "neighbours", "=", "self", ".", "_neighbours", "(", "x", ",", "context_manager", ".", "contextfree_space", ".", "parameters", ")", "\n", "neighbours_with_context", "=", "context_manager", ".", "expand_vector", "(", "neighbours", ")", "\n", "acquisition_values", "=", "acquisition", ".", "evaluate", "(", "neighbours_with_context", ")", "\n", "max_index", "=", "np", ".", "argmax", "(", "acquisition_values", ")", "\n", "max_neighbour", "=", "neighbours", "[", "max_index", "]", "\n", "max_value", "=", "acquisition_values", "[", "max_index", "]", ".", "item", "(", ")", "\n", "if", "max_value", "<", "incumbent_value", ":", "\n", "                ", "_log", ".", "debug", "(", "\n", "\"End after {} steps at maximum of acquisition={:.4f} at {}\"", ".", "format", "(", "step", ",", "incumbent_value", ",", "str", "(", "x", ")", ")", "\n", ")", "\n", "return", "x", ",", "incumbent_value", "\n", "", "else", ":", "\n", "                ", "incumbent_value", "=", "max_value", "\n", "x", "=", "max_neighbour", "\n", "", "", "_log", ".", "debug", "(", "\"End at step limit with acquisition={:.4f} at {}\"", ".", "format", "(", "incumbent_value", ",", "str", "(", "x", ")", ")", ")", "\n", "return", "x", ",", "incumbent_value", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._optimize": [[168, 184], ["context_manager.contextfree_space.sample_uniform", "numpy.empty_like", "numpy.empty", "_log.info", "range", "numpy.argmax", "context_manager.expand_vector", "local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._one_local_search", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector", "home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._one_local_search"], ["", "def", "_optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context_manager", ":", "ContextManager", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Implementation of abstract method.\n\n        See AcquisitionOptimizerBase._optimizer for parameter descriptions.\n        See class docstring for implementation details.\n        \"\"\"", "\n", "X_init", "=", "context_manager", ".", "contextfree_space", ".", "sample_uniform", "(", "self", ".", "num_init_points", ")", "\n", "X_max", "=", "np", ".", "empty_like", "(", "X_init", ")", "\n", "acq_max", "=", "np", ".", "empty", "(", "(", "self", ".", "num_init_points", ",", "1", ")", ")", "\n", "_log", ".", "info", "(", "\"Starting local optimization of acquisition function {}\"", ".", "format", "(", "type", "(", "acquisition", ")", ")", ")", "\n", "for", "sample", "in", "range", "(", "self", ".", "num_init_points", ")", ":", "# this loop could be parallelized", "\n", "            ", "X_max", "[", "sample", "]", ",", "acq_max", "[", "sample", "]", "=", "self", ".", "_one_local_search", "(", "acquisition", ",", "X_init", "[", "sample", "]", ",", "context_manager", ")", "\n", "", "max_index", "=", "np", ".", "argmax", "(", "acq_max", ")", "\n", "X_max_with_context", "=", "context_manager", ".", "expand_vector", "(", "X_max", ")", "\n", "return", "X_max_with_context", "[", "[", "max_index", "]", "]", ",", "acq_max", "[", "[", "max_index", "]", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.acquisition_optimizer.AcquisitionOptimizerBase.__init__": [[19, 24], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "space", ":", "ParameterSpace", ")", ":", "\n", "        ", "\"\"\"\n        :param space: Parameter space containing entire input domain including any context variables\n        \"\"\"", "\n", "self", ".", "space", "=", "space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.acquisition_optimizer.AcquisitionOptimizerBase._optimize": [[25, 35], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "_optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context_manager", ":", "ContextManager", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Implementation of optimization. See class docstring for details.\n\n        :param acquisition: The acquisition function to be optimized\n        :param context_manager: Optimization context manager.\n        :return: Tuple of (location of maximum, acquisition value at maximizer)\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.acquisition_optimizer.AcquisitionOptimizerBase.optimize": [[36, 59], ["context_manager.ContextManager.ContextManager", "acquisition_optimizer.AcquisitionOptimizerBase._optimize", "acquisition_optimizer.AcquisitionOptimizerBase.space.round", "dict", "numpy.array_equal", "acquisition.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.random_search_acquisition_optimizer.RandomSearchAcquisitionOptimizer._optimize", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context", ":", "Optional", "[", "Context", "]", "=", "None", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Optimizes the acquisition function.\n\n        :param acquisition: The acquisition function to be optimized\n        :param context: Optimization context.\n                        Determines whether any variable values should be fixed during the optimization\n        :return: Tuple of (location of maximum, acquisition value at maximizer)\n        \"\"\"", "\n", "if", "context", "is", "None", ":", "\n", "            ", "context", "=", "dict", "(", ")", "\n", "", "context_manager", "=", "ContextManager", "(", "self", ".", "space", ",", "context", ")", "\n", "max_x", ",", "max_value", "=", "self", ".", "_optimize", "(", "acquisition", ",", "context_manager", ")", "\n", "\n", "# Optimization might not match any encoding exactly", "\n", "# Rounding operation here finds the closest encoding", "\n", "rounded_max_x", "=", "self", ".", "space", ".", "round", "(", "max_x", ")", "\n", "\n", "if", "not", "np", ".", "array_equal", "(", "max_x", ",", "rounded_max_x", ")", ":", "\n", "# re-evaluate if x changed while rounding to make sure value is correct", "\n", "            ", "return", "rounded_max_x", ",", "acquisition", ".", "evaluate", "(", "rounded_max_x", ")", "\n", "", "else", ":", "\n", "            ", "return", "max_x", ",", "max_value", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.Optimizer.__init__": [[19, 24], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "bounds", ":", "List", "[", "Tuple", "]", ")", ":", "\n", "        ", "\"\"\"\n        :param bounds: List of min/max values for each dimension of x\n        \"\"\"", "\n", "self", ".", "bounds", "=", "bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.Optimizer.optimize": [[25, 36], ["NotImplementedError"], "methods", ["None"], ["", "def", "optimize", "(", "\n", "self", ",", "x0", ":", "np", ".", "ndarray", ",", "f", ":", "Callable", "=", "None", ",", "df", ":", "Callable", "=", "None", ",", "f_df", ":", "Callable", "=", "None", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param x0: initial point for a local optimizer.\n        :param f: function to optimize.\n        :param df: gradient of the function to optimize.\n        :param f_df: returns both the function to optimize and its gradient.\n        :return: Location of optimum and value at optimum\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"The optimize method is not implemented in the parent class.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptLbfgs.__init__": [[43, 46], ["optimizer.Optimizer.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "bounds", ",", "max_iterations", "=", "1000", ")", ":", "\n", "        ", "super", "(", "OptLbfgs", ",", "self", ")", ".", "__init__", "(", "bounds", ")", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptLbfgs.optimize": [[47, 81], ["scipy.optimize.fmin_l_bfgs_b", "scipy.optimize.fmin_l_bfgs_b", "numpy.atleast_2d", "numpy.atleast_2d", "numpy.atleast_2d", "numpy.atleast_2d", "f", "float", "df", "f", "f", "f_df"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["", "def", "optimize", "(", "\n", "self", ",", "x0", ":", "np", ".", "ndarray", ",", "f", ":", "Callable", "=", "None", ",", "df", ":", "Callable", "=", "None", ",", "f_df", ":", "Callable", "=", "None", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        :param x0: initial point for a local optimizer.\n        :param f: function to optimize.\n        :param df: gradient of the function to optimize.\n        :param f_df: returns both the function to optimize and its gradient.\n        :return: Location of optimum and value at optimum\n        \"\"\"", "\n", "\n", "if", "f_df", "is", "None", "and", "df", "is", "not", "None", ":", "\n", "            ", "f_df", "=", "lambda", "x", ":", "(", "float", "(", "f", "(", "x", ")", ")", ",", "df", "(", "x", ")", ")", "\n", "", "if", "f_df", "is", "not", "None", ":", "\n", "\n", "            ", "def", "_f_df", "(", "x", ")", ":", "\n", "                ", "return", "f", "(", "x", ")", ",", "f_df", "(", "x", ")", "[", "1", "]", "[", "0", "]", "\n", "\n", "", "", "if", "f_df", "is", "None", "and", "df", "is", "None", ":", "\n", "            ", "res", "=", "scipy", ".", "optimize", ".", "fmin_l_bfgs_b", "(", "\n", "f", ",", "x0", "=", "x0", ",", "bounds", "=", "self", ".", "bounds", ",", "approx_grad", "=", "True", ",", "maxiter", "=", "self", ".", "max_iterations", "\n", ")", "\n", "", "else", ":", "\n", "            ", "res", "=", "scipy", ".", "optimize", ".", "fmin_l_bfgs_b", "(", "_f_df", ",", "x0", "=", "x0", ",", "bounds", "=", "self", ".", "bounds", ",", "maxiter", "=", "self", ".", "max_iterations", ")", "\n", "\n", "# We check here if the the optimizer moved. It it didn't we report x0 and f(x0) as scipy can return NaNs", "\n", "", "if", "res", "[", "2", "]", "[", "\"task\"", "]", "==", "b\"ABNORMAL_TERMINATION_IN_LNSRCH\"", ":", "\n", "            ", "result_x", "=", "np", ".", "atleast_2d", "(", "x0", ")", "\n", "result_fx", "=", "np", ".", "atleast_2d", "(", "f", "(", "x0", ")", ")", "\n", "", "else", ":", "\n", "            ", "result_x", "=", "np", ".", "atleast_2d", "(", "res", "[", "0", "]", ")", "\n", "result_fx", "=", "np", ".", "atleast_2d", "(", "res", "[", "1", "]", ")", "\n", "\n", "", "return", "result_x", ",", "result_fx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptimizationWithContext.__init__": [[144, 176], ["numpy.atleast_2d"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "x0", ":", "np", ".", "ndarray", ",", "\n", "f", ":", "Callable", ",", "\n", "df", ":", "Callable", "=", "None", ",", "\n", "f_df", ":", "Callable", "=", "None", ",", "\n", "context_manager", ":", "ContextManager", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of an objective function that takes as input a vector x of the non context variables\n        and returns a value in which the context variables have been fixed.\n        \"\"\"", "\n", "self", ".", "x0", "=", "np", ".", "atleast_2d", "(", "x0", ")", "\n", "self", ".", "f", "=", "f", "\n", "self", ".", "df", "=", "df", "\n", "self", ".", "f_df", "=", "f_df", "\n", "self", ".", "context_manager", "=", "context_manager", "\n", "\n", "if", "not", "context_manager", ":", "\n", "            ", "self", ".", "x0_no_context", "=", "x0", "\n", "self", ".", "f_no_context", "=", "self", ".", "f", "\n", "self", ".", "df_no_context", "=", "self", ".", "df", "\n", "self", ".", "f_df_no_context", "=", "self", ".", "f_df", "\n", "", "else", ":", "\n", "            ", "self", ".", "x0_no_context", "=", "self", ".", "x0", "[", ":", ",", "self", ".", "context_manager", ".", "non_context_idxs", "]", "\n", "self", ".", "f_no_context", "=", "self", ".", "f_no_context", "\n", "if", "self", ".", "f_df", "is", "None", ":", "\n", "                ", "self", ".", "df_no_context", "=", "None", "\n", "self", ".", "f_df_no_context", "=", "None", "\n", "", "else", ":", "\n", "                ", "self", ".", "df_no_context", "=", "self", ".", "df_no_context", "\n", "self", ".", "f_df_no_context", "=", "self", ".", "f_df_no_context", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptimizationWithContext.f_no_context": [[177, 189], ["numpy.atleast_2d", "optimizer.OptimizationWithContext.context_manager.expand_vector", "optimizer.OptimizationWithContext.f", "optimizer.OptimizationWithContext.f"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["", "", "", "def", "f_no_context", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Wrapper of optimization objective function which deals with adding context variables to x\n\n        :param x: Input without context variables\n        \"\"\"", "\n", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "xx", "=", "self", ".", "context_manager", ".", "expand_vector", "(", "x", ")", "\n", "if", "x", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "            ", "return", "self", ".", "f", "(", "xx", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "f", "(", "xx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptimizationWithContext.df_no_context": [[190, 201], ["numpy.atleast_2d", "optimizer.OptimizationWithContext.context_manager.expand_vector", "optimizer.OptimizationWithContext.f_df", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector"], ["", "", "def", "df_no_context", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Wrapper of the derivative of optimization objective function which deals with adding context variables to x\n\n        :param x: Input without context variables\n        \"\"\"", "\n", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "xx", "=", "self", ".", "context_manager", ".", "expand_vector", "(", "x", ")", "\n", "_", ",", "df_no_context_xx", "=", "self", ".", "f_df", "(", "xx", ")", "\n", "df_no_context_xx", "=", "df_no_context_xx", "[", ":", ",", "np", ".", "array", "(", "self", ".", "context_manager", ".", "non_context_idxs", ")", "]", "\n", "return", "df_no_context_xx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptimizationWithContext.f_df_no_context": [[202, 213], ["numpy.atleast_2d", "optimizer.OptimizationWithContext.context_manager.expand_vector", "optimizer.OptimizationWithContext.f_df", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector"], ["", "def", "f_df_no_context", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Wrapper of optimization objective function and its derivative which deals with adding context variables to x\n\n        :param x: Input without context variables\n        \"\"\"", "\n", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "xx", "=", "self", ".", "context_manager", ".", "expand_vector", "(", "x", ")", "\n", "f_no_context_xx", ",", "df_no_context_xx", "=", "self", ".", "f_df", "(", "xx", ")", "\n", "df_no_context_xx", "=", "df_no_context_xx", "[", ":", ",", "np", ".", "array", "(", "self", ".", "context_manager", ".", "non_context_idxs", ")", "]", "\n", "return", "f_no_context_xx", ",", "df_no_context_xx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.__init__": [[220, 229], ["optimizer.Optimizer.__init__", "optimizer._get_scipy_constraints"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer._get_scipy_constraints"], ["def", "__init__", "(", "self", ",", "bounds", ":", "List", "[", "Tuple", "]", ",", "constraints", ":", "List", "[", "IConstraint", "]", ",", "max_iterations", ":", "int", "=", "1000", ")", ":", "\n", "        ", "\"\"\"\n        :param bounds: List of tuples containing (lower_bound, upper_bound) for each parameter\n        :param constraints: List of constraints, can contain a mix of linear and non-linear constraints\n        :param max_iterations: Maximum number of iterations before the optimizer is stopped\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "bounds", ")", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "constraints", "=", "_get_scipy_constraints", "(", "constraints", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize": [[230, 288], ["numpy.atleast_2d", "numpy.atleast_2d", "ValueError", "scipy.optimize.minimize", "scipy.optimize.minimize", "f_df", "scipy.optimize.BFGS", "scipy.optimize.BFGS", "f_df", "df"], "methods", ["None"], ["", "def", "optimize", "(", "\n", "self", ",", "x0", ":", "np", ".", "ndarray", ",", "f", ":", "Callable", "=", "None", ",", "df", ":", "Callable", "=", "None", ",", "f_df", ":", "Callable", "=", "None", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Run Trust region constrained optimization algorithm\n\n        :param x0: Initial start point\n        :param f: Function to optimize\n        :param df: Derivative of function to optimize\n        :param f_df: Function returning both value of objective and its gradient\n        :return: Location of optimum and function value at optimum\n        \"\"\"", "\n", "\n", "if", "(", "f", "is", "None", ")", "and", "(", "f_df", "is", "None", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Neither f nor f_df are supplied - you must supply an objective function\"", ")", "\n", "\n", "# If f not supplied, make lambda that returns objective only from f_df", "\n", "", "if", "f", "is", "None", ":", "\n", "            ", "f", "=", "lambda", "x", ":", "f_df", "(", "x", ")", "[", "0", "]", "\n", "\n", "", "if", "df", "is", "None", "and", "f_df", "is", "not", "None", ":", "\n", "# If df not supplied and f_df is, make lambda that returns gradient only from f_df", "\n", "            ", "df_1d", "=", "lambda", "x", ":", "f_df", "(", "x", ")", "[", "1", "]", "[", "0", ",", ":", "]", "\n", "", "elif", "df", "is", "not", "None", ":", "\n", "# If df is supplied, convert the 2d output to 1d", "\n", "            ", "df_1d", "=", "lambda", "x", ":", "df", "(", "x", ")", "[", "0", ",", ":", "]", "\n", "", "else", ":", "\n", "# Gradient not supplied", "\n", "            ", "df_1d", "=", "None", "\n", "\n", "", "options", "=", "{", "\"maxiter\"", ":", "self", ".", "max_iterations", "}", "\n", "\n", "if", "df_1d", "is", "None", ":", "\n", "            ", "res", "=", "scipy", ".", "optimize", ".", "minimize", "(", "\n", "f", ",", "\n", "x0", "=", "x0", "[", "0", ",", ":", "]", ",", "\n", "method", "=", "\"trust-constr\"", ",", "\n", "bounds", "=", "self", ".", "bounds", ",", "\n", "jac", "=", "\"2-point\"", ",", "\n", "options", "=", "options", ",", "\n", "constraints", "=", "self", ".", "constraints", ",", "\n", "hess", "=", "scipy", ".", "optimize", ".", "BFGS", "(", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "res", "=", "scipy", ".", "optimize", ".", "minimize", "(", "\n", "f", ",", "\n", "x0", "=", "x0", "[", "0", ",", ":", "]", ",", "\n", "method", "=", "\"trust-constr\"", ",", "\n", "bounds", "=", "self", ".", "bounds", ",", "\n", "jac", "=", "df_1d", ",", "\n", "options", "=", "options", ",", "\n", "constraints", "=", "self", ".", "constraints", ",", "\n", "hess", "=", "scipy", ".", "optimize", ".", "BFGS", "(", ")", ",", "\n", ")", "\n", "\n", "", "result_x", "=", "np", ".", "atleast_2d", "(", "res", ".", "x", ")", "\n", "result_fx", "=", "np", ".", "atleast_2d", "(", "res", ".", "fun", ")", "\n", "return", "result_x", ",", "result_fx", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer": [[83, 141], ["optimizer.OptimizationWithContext", "optimizer.optimize", "add_context", "space.round", "context_manager.ContextManager", "context_manager.ContextManager.expand_vector", "f_df", "f"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round", "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f"], ["", "", "def", "apply_optimizer", "(", "\n", "optimizer", ":", "Optimizer", ",", "\n", "x0", ":", "np", ".", "ndarray", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "f", ":", "Callable", "=", "None", ",", "\n", "df", ":", "Callable", "=", "None", ",", "\n", "f_df", ":", "Callable", "=", "None", ",", "\n", "context_manager", ":", "ContextManager", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Optimizes f using the optimizer supplied, deals with potential context variables.\n\n    :param optimizer: The optimizer object that will perform the optimization\n    :param x0: initial point for a local optimizer (x0 can be defined with or without the context included).\n    :param f: function to optimize.\n    :param df: gradient of the function to optimize.\n    :param f_df: returns both the function to optimize and its gradient.\n    :param context_manager: If provided, x0 (and the optimizer) operates in the space without the context\n    :param space: Parameter space describing input domain, including any context variables\n    :return: Location of optimum and value at optimum\n    \"\"\"", "\n", "\n", "if", "context_manager", "is", "None", ":", "\n", "        ", "context_manager", "=", "ContextManager", "(", "space", ",", "{", "}", ")", "\n", "\n", "# Compute new objective that inputs non context variables but takes into account the values of the context ones.", "\n", "# It does nothing if no context is passed", "\n", "", "problem", "=", "OptimizationWithContext", "(", "x0", "=", "x0", ",", "f", "=", "f", ",", "df", "=", "df", ",", "f_df", "=", "f_df", ",", "context_manager", "=", "context_manager", ")", "\n", "\n", "add_context", "=", "lambda", "x", ":", "context_manager", ".", "expand_vector", "(", "x", ")", "\n", "\n", "# Optimize point", "\n", "if", "f", "is", "None", ":", "\n", "        ", "f_no_context", "=", "None", "\n", "", "else", ":", "\n", "        ", "f_no_context", "=", "problem", ".", "f_no_context", "\n", "\n", "", "if", "df", "is", "None", ":", "\n", "        ", "df_no_context", "=", "None", "\n", "", "else", ":", "\n", "        ", "df_no_context", "=", "problem", ".", "df_no_context", "\n", "\n", "", "if", "f_df", "is", "None", ":", "\n", "        ", "f_df_no_context", "=", "None", "\n", "", "else", ":", "\n", "        ", "f_df_no_context", "=", "problem", ".", "f_df_no_context", "\n", "\n", "", "optimized_x", ",", "_", "=", "optimizer", ".", "optimize", "(", "problem", ".", "x0_no_context", ",", "f_no_context", ",", "df_no_context", ",", "f_df_no_context", ")", "\n", "\n", "# Add context and round according to the type of variables of the design space", "\n", "suggested_x_with_context", "=", "add_context", "(", "optimized_x", ")", "\n", "suggested_x_with_context_rounded", "=", "space", ".", "round", "(", "suggested_x_with_context", ")", "\n", "\n", "if", "f", "is", "None", ":", "\n", "        ", "f_opt", ",", "_", "=", "f_df", "(", "suggested_x_with_context_rounded", ")", "\n", "", "else", ":", "\n", "        ", "f_opt", "=", "f", "(", "suggested_x_with_context_rounded", ")", "\n", "", "return", "suggested_x_with_context_rounded", ",", "f_opt", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer._get_scipy_constraints": [[290, 322], ["isinstance", "scipy_constraints.append", "isinstance", "scipy.optimize.NonlinearConstraint", "scipy_constraints.append", "ValueError", "scipy.optimize.LinearConstraint", "type"], "function", ["None"], ["", "", "def", "_get_scipy_constraints", "(", "constraint_list", ":", "List", "[", "IConstraint", "]", ")", "->", "List", ":", "\n", "    ", "\"\"\"\n    Converts list of emukit constraint objects to list of scipy constraint objects\n\n    :param constraint_list: List of Emukit constraint objects\n    :return: List of scipy constraint objects\n    \"\"\"", "\n", "\n", "scipy_constraints", "=", "[", "]", "\n", "for", "constraint", "in", "constraint_list", ":", "\n", "        ", "if", "isinstance", "(", "constraint", ",", "NonlinearInequalityConstraint", ")", ":", "\n", "            ", "if", "constraint", ".", "jacobian_fun", "is", "None", ":", "\n", "# No jacobian supplied -> tell scipy to use finite difference method", "\n", "                ", "jacobian", "=", "\"2-point\"", "\n", "", "else", ":", "\n", "# Jacobian is supplied -> tell scipy to use it", "\n", "                ", "jacobian", "=", "constraint", ".", "jacobian_fun", "\n", "\n", "", "scipy_constraints", ".", "append", "(", "\n", "scipy", ".", "optimize", ".", "NonlinearConstraint", "(", "\n", "constraint", ".", "fun", ",", "constraint", ".", "lower_bound", ",", "constraint", ".", "upper_bound", ",", "jacobian", "\n", ")", "\n", ")", "\n", "", "elif", "isinstance", "(", "constraint", ",", "LinearInequalityConstraint", ")", ":", "\n", "            ", "scipy_constraints", ".", "append", "(", "\n", "scipy", ".", "optimize", ".", "LinearConstraint", "(", "\n", "constraint", ".", "constraint_matrix", ",", "constraint", ".", "lower_bound", ",", "constraint", ".", "upper_bound", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Constraint type {} not recognised\"", ".", "format", "(", "type", "(", "constraint", ")", ")", ")", "\n", "", "", "return", "scipy_constraints", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.random_search_acquisition_optimizer.RandomSearchAcquisitionOptimizer.__init__": [[23, 30], ["acquisition_optimizer.AcquisitionOptimizerBase.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "space", ":", "ParameterSpace", ",", "num_eval_points", ":", "int", "=", "10", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param space: The parameter space spanning the search problem.\n        :param num_eval_points: Number of random sampled points which are evaluated per optimization.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "space", ")", "\n", "self", ".", "num_eval_points", "=", "num_eval_points", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.random_search_acquisition_optimizer.RandomSearchAcquisitionOptimizer._optimize": [[31, 45], ["_log.info", "context_manager.contextfree_space.sample_uniform", "context_manager.expand_vector", "acquisition.evaluate", "numpy.argmax", "type"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform", "home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "_optimize", "(", "self", ",", "acquisition", ":", "Acquisition", ",", "context_manager", ":", "ContextManager", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Implementation of abstract method.\n\n        See AcquisitionOptimizerBase._optimizer for parameter descriptions.\n        See class docstring for implementation details.\n        \"\"\"", "\n", "_log", ".", "info", "(", "\"Starting random search optimization of acquisition function {}\"", ".", "format", "(", "type", "(", "acquisition", ")", ")", ")", "\n", "samples_contextfree", "=", "context_manager", ".", "contextfree_space", ".", "sample_uniform", "(", "self", ".", "num_eval_points", ")", "\n", "samples", "=", "context_manager", ".", "expand_vector", "(", "samples_contextfree", ")", "\n", "acquisition_values", "=", "acquisition", ".", "evaluate", "(", "samples", ")", "\n", "max_index", "=", "np", ".", "argmax", "(", "acquisition_values", ")", "\n", "\n", "return", "samples", "[", "[", "max_index", "]", "]", ",", "acquisition_values", "[", "[", "max_index", "]", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_context_manager.space": [[8, 11], ["emukit.core.ParameterSpace", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "space", "(", ")", ":", "\n", "    ", "return", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x1\"", ",", "0", ",", "15", ")", ",", "ContinuousParameter", "(", "\"x2\"", ",", "0", ",", "15", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_context_manager.context": [[13, 16], ["None"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "context", "(", ")", ":", "\n", "    ", "return", "{", "\"x1\"", ":", "0.3", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_context_manager.test_context_manager_idxs": [[18, 23], ["emukit.core.optimization.ContextManager"], "function", ["None"], ["", "def", "test_context_manager_idxs", "(", "space", ",", "context", ")", ":", "\n", "    ", "context_manager", "=", "ContextManager", "(", "space", ",", "context", ")", "\n", "assert", "context_manager", ".", "non_context_idxs", "==", "[", "1", "]", "\n", "assert", "context_manager", ".", "context_idxs", "==", "[", "0", "]", "\n", "assert", "context_manager", ".", "context_values", "==", "[", "0.3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_context_manager.test_context_manager_expand_vector": [[25, 31], ["emukit.core.optimization.ContextManager", "numpy.array", "emukit.core.optimization.ContextManager.expand_vector", "numpy.array_equal", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector"], ["", "def", "test_context_manager_expand_vector", "(", "space", ",", "context", ")", ":", "\n", "    ", "context_manager", "=", "ContextManager", "(", "space", ",", "context", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "0.5", "]", "]", ")", "\n", "x_expanded", "=", "context_manager", ".", "expand_vector", "(", "x", ")", "\n", "assert", "x_expanded", ".", "ndim", "==", "2", "\n", "assert", "np", ".", "array_equal", "(", "x_expanded", ",", "np", ".", "array", "(", "[", "[", "0.3", ",", "0.5", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_context_manager.catg_space": [[33, 41], ["emukit.core.ParameterSpace", "emukit.core.ContinuousParameter", "emukit.core.CategoricalParameter", "emukit.core.CategoricalParameter", "emukit.core.ContinuousParameter", "emukit.core.OneHotEncoding", "emukit.core.OneHotEncoding"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "catg_space", "(", ")", ":", "\n", "    ", "return", "ParameterSpace", "(", "\n", "[", "\n", "ContinuousParameter", "(", "\"x1\"", ",", "0", ",", "15", ")", ",", "\n", "CategoricalParameter", "(", "\"x2\"", ",", "OneHotEncoding", "(", "[", "\"A\"", ",", "\"B\"", ",", "\"C\"", ",", "\"D\"", "]", ")", ")", ",", "\n", "CategoricalParameter", "(", "\"x3\"", ",", "OneHotEncoding", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", ")", ",", "\n", "ContinuousParameter", "(", "\"x4\"", ",", "-", "2", ",", "3", ")", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_context_manager.catg_context": [[45, 48], ["None"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "catg_context", "(", ")", ":", "\n", "    ", "return", "{", "\"x2\"", ":", "\"A\"", ",", "\"x3\"", ":", "3", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_context_manager.test_context_manager_catg_expand_vector": [[50, 58], ["emukit.core.optimization.ContextManager", "numpy.array", "emukit.core.optimization.ContextManager.expand_vector", "numpy.array_equal", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.context_manager.ContextManager.expand_vector"], ["", "def", "test_context_manager_catg_expand_vector", "(", "catg_space", ",", "catg_context", ")", ":", "\n", "    ", "context_manager", "=", "ContextManager", "(", "catg_space", ",", "catg_context", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "[", "4.0", ",", "-", "1", "]", ",", "[", "3", ",", "0.0", "]", "]", ")", "\n", "x_expanded", "=", "context_manager", ".", "expand_vector", "(", "x", ")", "\n", "assert", "context_manager", ".", "space", ".", "dimensionality", "==", "11", "\n", "assert", "x_expanded", ".", "shape", "==", "(", "2", ",", "context_manager", ".", "space", ".", "dimensionality", ")", "\n", "assert", "np", ".", "array_equal", "(", "\n", "x_expanded", ",", "np", ".", "array", "(", "[", "[", "4.0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "-", "1.0", "]", ",", "[", "3", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0.0", "]", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_context_manager.test_context_manager_incorrect_category": [[61, 65], ["pytest.raises", "emukit.core.optimization.ContextManager"], "function", ["None"], ["", "def", "test_context_manager_incorrect_category", "(", "catg_space", ")", ":", "\n", "    ", "erroneous_context", "=", "{", "\"x2\"", ":", "0", ",", "\"x3\"", ":", "3", "}", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "context_manager", "=", "ContextManager", "(", "catg_space", ",", "erroneous_context", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_multi_source_acquisition_optimizer.test_multi_source_acquisition_optimizer": [[8, 16], ["emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "emukit.core.optimization.MultiSourceAcquisitionOptimizer", "emukit.core.optimization.MultiSourceAcquisitionOptimizer.optimize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "emukit.core.ContinuousParameter", "emukit.core.InformationSourceParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["def", "test_multi_source_acquisition_optimizer", "(", "simple_square_acquisition", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "InformationSourceParameter", "(", "2", ")", "]", ")", "\n", "single_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "optimizer", "=", "MultiSourceAcquisitionOptimizer", "(", "single_optimizer", ",", "space", ")", "\n", "\n", "opt_x", ",", "opt_val", "=", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ")", "\n", "assert_array_equal", "(", "opt_x", ",", "np", ".", "array", "(", "[", "[", "0.0", ",", "1.0", "]", "]", ")", ")", "\n", "assert_array_equal", "(", "opt_val", ",", "np", ".", "array", "(", "[", "[", "2.0", "]", "]", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.objective": [[9, 12], ["None"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "objective", "(", ")", ":", "\n", "    ", "return", "lambda", "x", ":", "(", "x", "[", ":", ",", "0", "]", "**", "2", "+", "x", "[", ":", ",", "1", "]", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.gradient": [[14, 17], ["numpy.stack"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gradient", "(", ")", ":", "\n", "    ", "return", "lambda", "x", ":", "np", ".", "stack", "(", "[", "2", "*", "x", "[", ":", ",", "0", "]", ",", "2", "*", "x", "[", ":", ",", "1", "]", "]", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.space": [[19, 22], ["emukit.core.ParameterSpace", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "space", "(", ")", ":", "\n", "    ", "return", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "-", "1", ",", "1", ")", ",", "ContinuousParameter", "(", "\"y\"", ",", "-", "1", ",", "1", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.trust_region_constr_linear_constraint": [[24, 28], ["emukit.core.optimization.optimizer.OptTrustRegionConstrained", "emukit.core.constraints.LinearInequalityConstraint", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "trust_region_constr_linear_constraint", "(", ")", ":", "\n", "    ", "constraints", "=", "[", "LinearInequalityConstraint", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", "]", ")", ",", "np", ".", "array", "(", "[", "0.5", "]", ")", ",", "np", ".", "array", "(", "[", "np", ".", "inf", "]", ")", ")", "]", "\n", "return", "OptTrustRegionConstrained", "(", "[", "(", "-", "1", ",", "1", ")", ",", "(", "-", "1", ",", "1", ")", "]", ",", "constraints", ",", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.trust_region_constr_nonlinear_constraint": [[30, 35], ["emukit.core.optimization.optimizer.OptTrustRegionConstrained", "emukit.core.constraints.NonlinearInequalityConstraint", "numpy.array", "numpy.array"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "trust_region_constr_nonlinear_constraint", "(", ")", ":", "\n", "    ", "constraint_function", "=", "lambda", "x", ":", "(", "x", "[", "0", "]", "+", "x", "[", "1", "]", ")", "**", "2", "\n", "constraints", "=", "[", "NonlinearInequalityConstraint", "(", "constraint_function", ",", "np", ".", "array", "(", "[", "2.0", "]", ")", ",", "np", ".", "array", "(", "[", "np", ".", "inf", "]", ")", ")", "]", "\n", "return", "OptTrustRegionConstrained", "(", "[", "(", "-", "1", ",", "1", ")", ",", "(", "-", "1", ",", "1", ")", "]", ",", "constraints", ",", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.test_trust_region_constrained_no_context": [[43, 47], ["numpy.array", "emukit.core.optimization.optimizer.apply_optimizer", "numpy.all", "numpy.isclose", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer"], ["", "def", "test_trust_region_constrained_no_context", "(", "trust_region_constr_linear_constraint", ",", "objective", ",", "space", ")", ":", "\n", "    ", "x0", "=", "np", ".", "array", "(", "[", "1", ",", "1", "]", ")", "\n", "x", ",", "f", "=", "apply_optimizer", "(", "trust_region_constr_linear_constraint", ",", "x0", ",", "space", ",", "objective", ",", "None", ",", "None", ",", "None", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "np", ".", "array", "(", "[", "0", ",", "0.5", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.test_trust_region_constrained_no_context_with_gradient": [[49, 56], ["numpy.array", "emukit.core.optimization.optimizer.apply_optimizer", "numpy.all", "numpy.isclose", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer"], ["", "def", "test_trust_region_constrained_no_context_with_gradient", "(", "\n", "trust_region_constr_linear_constraint", ",", "objective", ",", "gradient", ",", "space", "\n", ")", ":", "\n", "# Tests the optimizer when passing in f and df as separate function handles", "\n", "    ", "x0", "=", "np", ".", "array", "(", "[", "1", ",", "1", "]", ")", "\n", "x", ",", "f", "=", "apply_optimizer", "(", "trust_region_constr_linear_constraint", ",", "x0", ",", "space", ",", "objective", ",", "gradient", ",", "None", ",", "None", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "np", ".", "array", "(", "[", "0", ",", "0.5", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.test_trust_region_constrained_nonlinear_constraint": [[58, 65], ["numpy.array", "emukit.core.optimization.optimizer.apply_optimizer", "numpy.all", "numpy.isclose", "numpy.array", "numpy.sqrt", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer"], ["", "def", "test_trust_region_constrained_nonlinear_constraint", "(", "\n", "trust_region_constr_nonlinear_constraint", ",", "objective", ",", "gradient", ",", "space", "\n", ")", ":", "\n", "# Tests the optimizer when passing in f and df as separate function handles", "\n", "    ", "x0", "=", "np", ".", "array", "(", "[", "1", ",", "1", "]", ")", "\n", "x", ",", "f", "=", "apply_optimizer", "(", "trust_region_constr_nonlinear_constraint", ",", "x0", ",", "space", ",", "objective", ",", "gradient", ",", "None", ",", "None", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "np", ".", "array", "(", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", ")", ",", "atol", "=", "1e-3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.test_trust_region_constrained_no_context_with_f_df": [[67, 75], ["numpy.array", "emukit.core.optimization.optimizer.apply_optimizer", "numpy.all", "numpy.isclose", "test_trust_region_constrained_optimizer.objective", "test_trust_region_constrained_optimizer.gradient", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer", "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.objective", "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.gradient"], ["", "def", "test_trust_region_constrained_no_context_with_f_df", "(", "\n", "trust_region_constr_linear_constraint", ",", "objective", ",", "gradient", ",", "space", "\n", ")", ":", "\n", "# Tests the optimizer when passing in f and df as a single function handle", "\n", "    ", "f_df", "=", "lambda", "x", ":", "(", "objective", "(", "x", ")", ",", "gradient", "(", "x", ")", ")", "\n", "x0", "=", "np", ".", "array", "(", "[", "1", ",", "1", "]", ")", "\n", "x", ",", "f", "=", "apply_optimizer", "(", "trust_region_constr_linear_constraint", ",", "x0", ",", "space", ",", "None", ",", "None", ",", "f_df", ",", "None", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "np", ".", "array", "(", "[", "0", ",", "0.5", "]", ")", ",", "atol", "=", "1e-3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_trust_region_constrained_optimizer.test_invalid_constraint_object": [[77, 81], ["pytest.raises", "emukit.core.optimization.optimizer.OptTrustRegionConstrained"], "function", ["None"], ["", "def", "test_invalid_constraint_object", "(", ")", ":", "\n", "    ", "constraint_function", "=", "lambda", "x", ":", "(", "x", "[", "0", "]", "+", "x", "[", "1", "]", ")", "**", "2", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "return", "OptTrustRegionConstrained", "(", "[", "(", "-", "1", ",", "1", ")", ",", "(", "-", "1", ",", "1", ")", "]", ",", "[", "constraint_function", "]", ",", "1000", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_gradient_acquisition_optimizer.test_gradient_acquisition_optimizer": [[9, 15], ["emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "emukit.core.optimization.GradientAcquisitionOptimizer.optimize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["def", "test_gradient_acquisition_optimizer", "(", "simple_square_acquisition", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "opt_x", ",", "opt_val", "=", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ")", "\n", "assert_array_equal", "(", "opt_x", ",", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", ")", "\n", "assert_array_equal", "(", "opt_val", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_gradient_acquisition_optimizer.test_gradient_acquisition_optimizer_categorical": [[17, 24], ["emukit.core.ParameterSpace", "emukit.core.optimization.GradientAcquisitionOptimizer", "emukit.core.optimization.GradientAcquisitionOptimizer.optimize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "emukit.core.ContinuousParameter", "emukit.core.CategoricalParameter", "emukit.core.OneHotEncoding"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "test_gradient_acquisition_optimizer_categorical", "(", "simple_square_acquisition", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", ",", "CategoricalParameter", "(", "\"y\"", ",", "OneHotEncoding", "(", "[", "\"A\"", ",", "\"B\"", "]", ")", ")", "]", ")", "\n", "optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "context", "=", "{", "\"y\"", ":", "\"B\"", "}", "\n", "opt_x", ",", "opt_val", "=", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ",", "context", ")", "\n", "assert_array_equal", "(", "opt_x", ",", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.0", ",", "1.0", "]", "]", ")", ")", "\n", "assert_array_equal", "(", "opt_val", ",", "np", ".", "array", "(", "[", "[", "2.0", "]", "]", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.lbfgs": [[9, 12], ["emukit.core.optimization.optimizer.OptLbfgs"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "lbfgs", "(", ")", ":", "\n", "    ", "return", "OptLbfgs", "(", "bounds", "=", "[", "(", "-", "1", ",", "1", ")", ",", "(", "-", "1", ",", "1", ")", "]", ",", "max_iterations", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.lbfgs_context": [[14, 17], ["emukit.core.optimization.optimizer.OptLbfgs"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "lbfgs_context", "(", ")", ":", "\n", "    ", "return", "OptLbfgs", "(", "bounds", "=", "[", "(", "-", "1", ",", "1", ")", "]", ",", "max_iterations", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.objective": [[19, 25], ["None"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "objective", "(", ")", ":", "\n", "    ", "def", "objective", "(", "x", ")", ":", "\n", "        ", "return", "x", "[", ":", ",", "0", "]", "**", "2", "+", "x", "[", ":", ",", "1", "]", "**", "2", "\n", "\n", "", "return", "objective", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.gradient": [[27, 30], ["numpy.array"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gradient", "(", ")", ":", "\n", "    ", "return", "lambda", "x", ":", "np", ".", "array", "(", "[", "2", "*", "x", "[", ":", ",", "0", "]", ",", "2", "*", "x", "[", ":", ",", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.space": [[32, 35], ["emukit.core.ParameterSpace", "emukit.core.ContinuousParameter", "emukit.core.ContinuousParameter"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "space", "(", ")", ":", "\n", "    ", "return", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "-", "1", ",", "1", ")", ",", "ContinuousParameter", "(", "\"y\"", ",", "-", "1", ",", "1", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.test_lbfgs_with_gradient_no_context": [[37, 41], ["numpy.array", "emukit.core.optimization.optimizer.apply_optimizer", "numpy.all", "numpy.isclose", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer"], ["", "def", "test_lbfgs_with_gradient_no_context", "(", "lbfgs", ",", "objective", ",", "gradient", ",", "space", ")", ":", "\n", "    ", "x0", "=", "np", ".", "array", "(", "[", "1", ",", "1", "]", ")", "\n", "x", ",", "f", "=", "apply_optimizer", "(", "lbfgs", ",", "x0", ",", "space", ",", "objective", ",", "gradient", ",", "None", ",", "None", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "np", ".", "array", "(", "[", "0", ",", "0", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.test_lbfgs_no_gradient_no_context": [[43, 47], ["numpy.array", "emukit.core.optimization.optimizer.apply_optimizer", "numpy.all", "numpy.isclose", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer"], ["", "def", "test_lbfgs_no_gradient_no_context", "(", "lbfgs", ",", "objective", ",", "space", ")", ":", "\n", "    ", "x0", "=", "np", ".", "array", "(", "[", "1", ",", "1", "]", ")", "\n", "x", ",", "f", "=", "apply_optimizer", "(", "lbfgs", ",", "x0", ",", "space", ",", "objective", ",", "None", ",", "None", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "np", ".", "array", "(", "[", "0", ",", "0", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.test_lbfgs_with_gradient_and_context": [[49, 54], ["emukit.core.optimization.ContextManager", "numpy.array", "emukit.core.optimization.optimizer.apply_optimizer", "numpy.all", "numpy.isclose", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer"], ["", "def", "test_lbfgs_with_gradient_and_context", "(", "lbfgs_context", ",", "objective", ",", "gradient", ",", "space", ")", ":", "\n", "    ", "context", "=", "ContextManager", "(", "space", ",", "{", "\"x\"", ":", "0.5", "}", ")", "\n", "x0", "=", "np", ".", "array", "(", "[", "1", ",", "1", "]", ")", "\n", "x", ",", "f", "=", "apply_optimizer", "(", "lbfgs_context", ",", "x0", ",", "space", ",", "objective", ",", "gradient", ",", "None", ",", "context", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "np", ".", "array", "(", "[", "0.5", ",", "0", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.test_lbfgs_no_gradient_with_context": [[56, 61], ["emukit.core.optimization.ContextManager", "numpy.array", "emukit.core.optimization.optimizer.apply_optimizer", "numpy.all", "numpy.isclose", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.apply_optimizer"], ["", "def", "test_lbfgs_no_gradient_with_context", "(", "lbfgs_context", ",", "objective", ",", "space", ")", ":", "\n", "    ", "context", "=", "ContextManager", "(", "space", ",", "{", "\"x\"", ":", "0.5", "}", ")", "\n", "x0", "=", "np", ".", "array", "(", "[", "1", ",", "1", "]", ")", "\n", "x", ",", "f", "=", "apply_optimizer", "(", "lbfgs_context", ",", "x0", ",", "space", ",", "objective", ",", "None", ",", "None", ",", "context", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "np", ".", "array", "(", "[", "0.5", ",", "0", "]", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_random_search_acquisition_optimizer.test_random_search_acquisition_optimizer": [[8, 16], ["emukit.core.ParameterSpace", "emukit.core.optimization.RandomSearchAcquisitionOptimizer", "emukit.core.optimization.RandomSearchAcquisitionOptimizer.optimize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "emukit.core.CategoricalParameter", "emukit.core.OrdinalEncoding", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["def", "test_random_search_acquisition_optimizer", "(", "simple_square_acquisition", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "CategoricalParameter", "(", "\"x\"", ",", "OrdinalEncoding", "(", "np", ".", "arange", "(", "0", ",", "100", ")", ")", ")", "]", ")", "\n", "optimizer", "=", "RandomSearchAcquisitionOptimizer", "(", "space", ",", "1000", ")", "\n", "\n", "opt_x", ",", "opt_val", "=", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ")", "\n", "# ordinal encoding is as integers 1, 2, ...", "\n", "assert_array_equal", "(", "opt_x", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", ")", "\n", "assert_array_equal", "(", "opt_val", ",", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_random_search_acquisition_optimizer.test_random_search_acquisition_optimizer_with_context": [[18, 28], ["emukit.core.ParameterSpace", "emukit.core.optimization.RandomSearchAcquisitionOptimizer", "emukit.core.optimization.RandomSearchAcquisitionOptimizer.optimize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "emukit.core.CategoricalParameter", "emukit.core.InformationSourceParameter", "emukit.core.OrdinalEncoding", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "test_random_search_acquisition_optimizer_with_context", "(", "simple_square_acquisition", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "\n", "[", "CategoricalParameter", "(", "\"x\"", ",", "OrdinalEncoding", "(", "np", ".", "arange", "(", "0", ",", "100", ")", ")", ")", ",", "InformationSourceParameter", "(", "10", ")", "]", "\n", ")", "\n", "optimizer", "=", "RandomSearchAcquisitionOptimizer", "(", "space", ",", "1000", ")", "\n", "\n", "source_encoding", "=", "1", "\n", "opt_x", ",", "opt_val", "=", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ",", "{", "\"source\"", ":", "source_encoding", "}", ")", "\n", "assert_array_equal", "(", "opt_x", ",", "np", ".", "array", "(", "[", "[", "1.0", ",", "source_encoding", "]", "]", ")", ")", "\n", "assert_array_equal", "(", "opt_val", ",", "np", ".", "array", "(", "[", "[", "0.0", "+", "source_encoding", "]", "]", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_anchor_points_generator.test_objective_anchor_point_generator": [[11, 25], ["mock.create_autospec", "mock.create_autospec", "emukit.core.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator", "emukit.core.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator.get", "numpy.array_equal", "numpy.arange", "numpy.arange", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get"], ["def", "test_objective_anchor_point_generator", "(", ")", ":", "\n", "    ", "num_samples", "=", "5", "\n", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "mock_acquisition", ".", "evaluate", ".", "return_value", "=", "np", ".", "arange", "(", "num_samples", ")", "[", ":", ",", "None", "]", "\n", "\n", "space", "=", "mock", ".", "create_autospec", "(", "ParameterSpace", ")", "\n", "space", ".", "sample_uniform", ".", "return_value", "=", "np", ".", "arange", "(", "num_samples", ")", "[", ":", ",", "None", "]", "\n", "space", ".", "constraints", "=", "[", "]", "\n", "\n", "generator", "=", "ObjectiveAnchorPointsGenerator", "(", "space", ",", "mock_acquisition", ",", "num_samples", "=", "num_samples", ")", "\n", "anchor_points", "=", "generator", ".", "get", "(", "1", ")", "\n", "\n", "# Check that the X that is picked corresponds to the highest acquisition value", "\n", "assert", "np", ".", "array_equal", "(", "anchor_points", ",", "np", ".", "array", "(", "[", "[", "num_samples", "-", "1", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_anchor_points_generator.test_constrained_objective_anchor_point_generator": [[27, 45], ["mock.create_autospec", "mock.create_autospec", "mock.create_autospec", "numpy.array", "emukit.core.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator", "emukit.core.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator.get", "numpy.array_equal", "numpy.arange", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get"], ["", "def", "test_constrained_objective_anchor_point_generator", "(", ")", ":", "\n", "    ", "num_samples", "=", "5", "\n", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "mock_acquisition", ".", "evaluate", "=", "lambda", "x", ":", "x", "\n", "\n", "space", "=", "mock", ".", "create_autospec", "(", "ParameterSpace", ")", "\n", "space", ".", "sample_uniform", ".", "return_value", "=", "np", ".", "arange", "(", "num_samples", ")", "[", ":", ",", "None", "]", "\n", "\n", "constraint", "=", "mock", ".", "create_autospec", "(", "IConstraint", ")", "\n", "constraint", ".", "evaluate", ".", "return_value", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "0", ",", "0", "]", ")", "\n", "\n", "space", ".", "constraints", "=", "[", "constraint", "]", "\n", "\n", "generator", "=", "ObjectiveAnchorPointsGenerator", "(", "space", ",", "mock_acquisition", ",", "num_samples", "=", "num_samples", ")", "\n", "anchor_points", "=", "generator", ".", "get", "(", "1", ")", "\n", "\n", "# Check that the X that is picked corresponds to the highest acquisition value", "\n", "assert", "np", ".", "array_equal", "(", "anchor_points", ",", "np", ".", "array", "(", "[", "[", "2", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_anchor_points_generator.test_num_anchor_greater_than_num_samples_error": [[47, 65], ["mock.create_autospec", "mock.create_autospec", "mock.create_autospec", "numpy.array", "emukit.core.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator", "numpy.arange", "pytest.raises", "emukit.core.optimization.anchor_points_generator.ObjectiveAnchorPointsGenerator.get"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.anchor_points_generator.AnchorPointsGenerator.get"], ["", "def", "test_num_anchor_greater_than_num_samples_error", "(", ")", ":", "\n", "    ", "num_samples", "=", "5", "\n", "num_anchor", "=", "10", "\n", "mock_acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "mock_acquisition", ".", "evaluate", "=", "lambda", "x", ":", "x", "\n", "\n", "space", "=", "mock", ".", "create_autospec", "(", "ParameterSpace", ")", "\n", "space", ".", "sample_uniform", ".", "return_value", "=", "np", ".", "arange", "(", "num_samples", ")", "[", ":", ",", "None", "]", "\n", "\n", "constraint", "=", "mock", ".", "create_autospec", "(", "IConstraint", ")", "\n", "constraint", ".", "evaluate", ".", "return_value", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "0", ",", "0", "]", ")", "\n", "\n", "space", ".", "constraints", "=", "[", "constraint", "]", "\n", "\n", "generator", "=", "ObjectiveAnchorPointsGenerator", "(", "space", ",", "mock_acquisition", ",", "num_samples", "=", "num_samples", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "anchor_points", "=", "generator", ".", "get", "(", "num_anchor", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_local_search_acquisition_optimizer.test_local_search_acquisition_optimizer": [[19, 48], ["emukit.core.ParameterSpace", "emukit.core.optimization.LocalSearchAcquisitionOptimizer", "emukit.core.optimization.LocalSearchAcquisitionOptimizer.optimize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "emukit.core.ParameterSpace.parameters.append", "emukit.core.ParameterSpace.parameters.pop", "emukit.core.ParameterSpace.parameters.append", "emukit.core.ParameterSpace.parameters.pop", "numpy.array", "numpy.array", "UnknownParameter", "pytest.raises", "emukit.core.optimization.LocalSearchAcquisitionOptimizer.optimize", "emukit.core.CategoricalParameter", "pytest.raises", "emukit.core.optimization.LocalSearchAcquisitionOptimizer.optimize", "emukit.core.CategoricalParameter", "numpy.random.randint", "super().__init__", "UnknownEncoding", "emukit.core.OrdinalEncoding", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize", "home.repos.pwc.inspect_result.amzn_emukit.core.test_parameter_space.MockRandom.randint", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "test_local_search_acquisition_optimizer", "(", "simple_square_acquisition", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "CategoricalParameter", "(", "\"x\"", ",", "OrdinalEncoding", "(", "np", ".", "arange", "(", "0", ",", "100", ")", ")", ")", "]", ")", "\n", "optimizer", "=", "LocalSearchAcquisitionOptimizer", "(", "space", ",", "1000", ",", "3", ")", "\n", "\n", "opt_x", ",", "opt_val", "=", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ")", "\n", "# ordinal encoding is as integers 1, 2, ...", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "opt_x", ",", "np", ".", "array", "(", "[", "[", "1.0", "]", "]", ")", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "opt_val", ",", "np", ".", "array", "(", "[", "[", "0.0", "]", "]", ")", ")", "\n", "\n", "class", "UnknownParameter", "(", "Parameter", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "            ", "self", ".", "name", "=", "name", "\n", "\n", "", "def", "sample_uniform", "(", "num_points", ")", ":", "\n", "            ", "return", "np", ".", "random", ".", "randint", "(", "0", ",", "1", ",", "(", "num_points", ",", "1", ")", ")", "\n", "\n", "", "", "space", ".", "parameters", ".", "append", "(", "UnknownParameter", "(", "\"y\"", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "        ", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ")", "\n", "", "space", ".", "parameters", ".", "pop", "(", ")", "\n", "\n", "class", "UnknownEncoding", "(", "Encoding", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ")", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "[", "1", "]", ",", "[", "[", "1", "]", "]", ")", "\n", "\n", "", "", "space", ".", "parameters", ".", "append", "(", "CategoricalParameter", "(", "\"y\"", ",", "UnknownEncoding", "(", ")", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "        ", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ")", "\n", "", "space", ".", "parameters", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_local_search_acquisition_optimizer.test_local_search_acquisition_optimizer_with_context": [[50, 60], ["emukit.core.ParameterSpace", "emukit.core.optimization.LocalSearchAcquisitionOptimizer", "emukit.core.optimization.LocalSearchAcquisitionOptimizer.optimize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.array", "numpy.array", "emukit.core.CategoricalParameter", "emukit.core.InformationSourceParameter", "emukit.core.OrdinalEncoding", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.optimizer.OptTrustRegionConstrained.optimize"], ["", "def", "test_local_search_acquisition_optimizer_with_context", "(", "simple_square_acquisition", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "\n", "[", "CategoricalParameter", "(", "\"x\"", ",", "OrdinalEncoding", "(", "np", ".", "arange", "(", "0", ",", "100", ")", ")", ")", ",", "InformationSourceParameter", "(", "10", ")", "]", "\n", ")", "\n", "optimizer", "=", "LocalSearchAcquisitionOptimizer", "(", "space", ",", "1000", ",", "3", ")", "\n", "\n", "source_encoding", "=", "1", "\n", "opt_x", ",", "opt_val", "=", "optimizer", ".", "optimize", "(", "simple_square_acquisition", ",", "{", "\"source\"", ":", "source_encoding", "}", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "opt_x", ",", "np", ".", "array", "(", "[", "[", "1.0", ",", "source_encoding", "]", "]", ")", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "opt_val", ",", "np", ".", "array", "(", "[", "[", "0.0", "+", "source_encoding", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_local_search_acquisition_optimizer.test_local_search_acquisition_optimizer_neighbours": [[62, 103], ["numpy.random.seed", "emukit.core.ParameterSpace", "numpy.array", "emukit.core.optimization.LocalSearchAcquisitionOptimizer", "emukit.core.optimization.LocalSearchAcquisitionOptimizer._neighbours_per_parameter", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_almost_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "emukit.core.optimization.LocalSearchAcquisitionOptimizer._neighbours", "numpy.testing.assert_almost_equal", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.empty", "numpy.array", "numpy.array", "emukit.core.ParameterSpace.round", "emukit.core.CategoricalParameter", "emukit.core.CategoricalParameter", "emukit.core.CategoricalParameter", "emukit.core.DiscreteParameter", "emukit.core.ContinuousParameter", "emukit.core.DiscreteParameter", "emukit.core.DiscreteParameter", "emukit.core.OneHotEncoding", "emukit.core.OrdinalEncoding", "emukit.core.OrdinalEncoding"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._neighbours_per_parameter", "home.repos.pwc.inspect_result.amzn_emukit.optimization.local_search_acquisition_optimizer.LocalSearchAcquisitionOptimizer._neighbours", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "test_local_search_acquisition_optimizer_neighbours", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "space", "=", "ParameterSpace", "(", "\n", "[", "\n", "CategoricalParameter", "(", "\"a\"", ",", "OneHotEncoding", "(", "[", "1", ",", "2", ",", "3", "]", ")", ")", ",", "\n", "CategoricalParameter", "(", "\"b\"", ",", "OrdinalEncoding", "(", "[", "0.1", ",", "1", ",", "2", "]", ")", ")", ",", "\n", "CategoricalParameter", "(", "\"c\"", ",", "OrdinalEncoding", "(", "[", "0.1", ",", "1", ",", "2", "]", ")", ")", ",", "\n", "DiscreteParameter", "(", "\"d\"", ",", "[", "0.1", ",", "1.2", ",", "2.3", "]", ")", ",", "\n", "ContinuousParameter", "(", "\"e\"", ",", "0", ",", "100", ")", ",", "\n", "DiscreteParameter", "(", "\"no_neighbours\"", ",", "[", "1", "]", ")", ",", "\n", "DiscreteParameter", "(", "\"f\"", ",", "[", "0.1", ",", "1.2", ",", "2.3", "]", ")", ",", "\n", "]", "\n", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", ",", "1.6", ",", "2.9", ",", "0.1", ",", "50", ",", "1.2", ",", "1.0", "]", ")", "\n", "optimizer", "=", "LocalSearchAcquisitionOptimizer", "(", "space", ",", "1000", ",", "3", ",", "num_continuous", "=", "1", ")", "\n", "\n", "neighbourhood", "=", "optimizer", ".", "_neighbours_per_parameter", "(", "x", ",", "space", ".", "parameters", ")", "\n", "assert_equal", "(", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "neighbourhood", "[", "0", "]", ")", "\n", "assert_equal", "(", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "3", "]", "]", ")", ",", "neighbourhood", "[", "1", "]", ")", "\n", "assert_equal", "(", "np", ".", "array", "(", "[", "[", "2", "]", "]", ")", ",", "neighbourhood", "[", "2", "]", ")", "\n", "assert_equal", "(", "np", ".", "array", "(", "[", "[", "1.2", "]", "]", ")", ",", "neighbourhood", "[", "3", "]", ")", "\n", "assert_almost_equal", "(", "np", ".", "array", "(", "[", "[", "53.5281047", "]", "]", ")", ",", "neighbourhood", "[", "4", "]", ")", "\n", "assert_equal", "(", "np", ".", "empty", "(", "(", "0", ",", "1", ")", ")", ",", "neighbourhood", "[", "5", "]", ")", "\n", "assert_equal", "(", "np", ".", "array", "(", "[", "[", "0.1", "]", ",", "[", "2.3", "]", "]", ")", ",", "neighbourhood", "[", "6", "]", ")", "\n", "\n", "neighbours", "=", "optimizer", ".", "_neighbours", "(", "x", ",", "space", ".", "parameters", ")", "\n", "assert_almost_equal", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "0", ",", "1", ",", "0", ",", "2.0", ",", "3.0", ",", "0.1", ",", "50.0", ",", "1.0", ",", "1.2", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "2.0", ",", "3.0", ",", "0.1", ",", "50.0", ",", "1.0", ",", "1.2", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "1.0", ",", "3.0", ",", "0.1", ",", "50.0", ",", "1.0", ",", "1.2", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "3.0", ",", "3.0", ",", "0.1", ",", "50.0", ",", "1.0", ",", "1.2", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "2.0", ",", "2.0", ",", "0.1", ",", "50.0", ",", "1.0", ",", "1.2", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "2.0", ",", "3.0", ",", "1.2", ",", "50.0", ",", "1.0", ",", "1.2", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "2.0", ",", "3.0", ",", "0.1", ",", "50.80031442", ",", "1.0", ",", "1.2", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "2.0", ",", "3.0", ",", "0.1", ",", "50.0", ",", "1.0", ",", "0.1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "2.0", ",", "3.0", ",", "0.1", ",", "50.0", ",", "1.0", ",", "2.3", "]", ",", "\n", "]", "\n", ")", ",", "\n", "space", ".", "round", "(", "neighbours", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.optimization.conftest.simple_square_acquisition": [[7, 22], ["pytest.fixture", "SimpleSquareAcquisition", "numpy.atleast_2d", "numpy.sum"], "function", ["None"], ["import", "pytest", "\n", "\n", "from", "emukit", ".", "core", "import", "ContinuousParameter", ",", "OneHotEncoding", ",", "ParameterSpace", "\n", "from", "emukit", ".", "model_wrappers", "import", "GPyModelWrapper", "\n", "\n", "\n", "@", "pytest", ".", "fixture", "\n", "def", "n_dims", "(", ")", ":", "\n", "# default to 2 dimensional inputs for tests, but can be overridden by individual tests if desired by using the", "\n", "# following decorator: @pytest.mark.parametrize('n_dims', [xxx]) where xxx is the number of desired dimensions", "\n", "    ", "return", "2", "\n", "\n", "\n", "", "@", "pytest", ".", "fixture", "\n", "def", "gpy_model", "(", "n_dims", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.__init__": [[14, 45], ["integrated_acquisition.IntegratedHyperParameterAcquisition.update_parameters", "integrated_acquisition.IntegratedHyperParameterAcquisition.acquisition_generator"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Union", "[", "IModel", ",", "IPriorHyperparameters", "]", ",", "\n", "acquisition_generator", ":", "Callable", ",", "\n", "n_samples", ":", "int", "=", "10", ",", "\n", "n_burnin", ":", "int", "=", "100", ",", "\n", "subsample_interval", ":", "int", "=", "10", ",", "\n", "step_size", ":", "float", "=", "1e-1", ",", "\n", "leapfrog_steps", ":", "int", "=", "20", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param model: An emukit model that implements IPriorHyperparameters\n        :param acquisition_generator: Function that returns acquisition object when given the model as the only argument\n        :param n_samples: Number of hyper-parameter samples\n        :param n_burnin: Number of initial samples not used.\n        :param subsample_interval: Interval of subsampling from HMC samples.\n        :param step_size: Size of the gradient steps in the HMC sampler.\n        :param leapfrog_steps: Number of gradient steps before each Metropolis Hasting step.\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "acquisition_generator", "=", "acquisition_generator", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "self", ".", "n_burnin", "=", "n_burnin", "\n", "self", ".", "subsample_interval", "=", "subsample_interval", "\n", "self", ".", "step_size", "=", "step_size", "\n", "self", ".", "leapfrog_steps", "=", "leapfrog_steps", "\n", "\n", "self", ".", "update_parameters", "(", ")", "\n", "\n", "acquisition", "=", "self", ".", "acquisition_generator", "(", "model", ")", "\n", "self", ".", "_has_gradients", "=", "acquisition", ".", "has_gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.evaluate": [[46, 59], ["integrated_acquisition.IntegratedHyperParameterAcquisition.model.fix_model_hyperparameters", "integrated_acquisition.IntegratedHyperParameterAcquisition.acquisition_generator", "integrated_acquisition.IntegratedHyperParameterAcquisition.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.fix_model_hyperparameters", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluate acquisition by integrating over the hyper-parameters of the model\n        :param x: locations where the evaluation is done.\n        :return: Array with integrated acquisition value at all input locations\n        \"\"\"", "\n", "acquisition_value", "=", "0", "\n", "for", "sample", "in", "self", ".", "samples", ":", "\n", "            ", "self", ".", "model", ".", "fix_model_hyperparameters", "(", "sample", ")", "\n", "acquisition", "=", "self", ".", "acquisition_generator", "(", "self", ".", "model", ")", "\n", "acquisition_value", "+=", "acquisition", ".", "evaluate", "(", "x", ")", "\n", "\n", "", "return", "acquisition_value", "/", "self", ".", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.evaluate_with_gradients": [[60, 82], ["integrated_acquisition.IntegratedHyperParameterAcquisition.model.fix_model_hyperparameters", "integrated_acquisition.IntegratedHyperParameterAcquisition.acquisition_generator", "integrated_acquisition.IntegratedHyperParameterAcquisition.evaluate_with_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.fix_model_hyperparameters", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Computes the acquisition value and its derivative integrating over the hyper-parameters of the model\n\n        :param x: locations where the evaluation with gradients is done.\n        :return: tuple containing the integrated expected improvement at the points x and its gradient.\n        \"\"\"", "\n", "\n", "if", "x", ".", "ndim", "==", "1", ":", "\n", "            ", "x", "=", "x", "[", "None", ",", ":", "]", "\n", "\n", "", "acquisition_value", "=", "0", "\n", "d_acquisition_dx", "=", "0", "\n", "\n", "for", "sample", "in", "self", ".", "samples", ":", "\n", "            ", "self", ".", "model", ".", "fix_model_hyperparameters", "(", "sample", ")", "\n", "acquisition", "=", "self", ".", "acquisition_generator", "(", "self", ".", "model", ")", "\n", "improvement_sample", ",", "d_improvement_dx_sample", "=", "acquisition", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "acquisition_value", "+=", "improvement_sample", "\n", "d_acquisition_dx", "+=", "d_improvement_dx_sample", "\n", "\n", "", "return", "acquisition_value", "/", "self", ".", "n_samples", ",", "d_acquisition_dx", "/", "self", ".", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_parameters": [[83, 86], ["integrated_acquisition.IntegratedHyperParameterAcquisition.model.generate_hyperparameters_samples"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.generate_hyperparameters_samples"], ["", "def", "update_parameters", "(", "self", ")", ":", "\n", "        ", "self", ".", "samples", "=", "self", ".", "model", ".", "generate_hyperparameters_samples", "(", "\n", "self", ".", "n_samples", ",", "self", ".", "n_burnin", ",", "self", ".", "subsample_interval", ",", "self", ".", "step_size", ",", "self", ".", "leapfrog_steps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.has_gradients": [[88, 92], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Returns that this acquisition has gradients\"\"\"", "\n", "return", "self", ".", "_has_gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches": [[93, 96], ["integrated_acquisition.IntegratedHyperParameterAcquisition.acquisition_generator", "integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.integrated_acquisition.IntegratedHyperParameterAcquisition.update_batches"], ["", "def", "update_batches", "(", "self", ",", "x_batch", ",", "lipschitz_constant", ",", "f_min", ")", ":", "\n", "        ", "acquisition", "=", "self", ".", "acquisition_generator", "(", "self", ".", "model", ")", "\n", "acquisition", ".", "update_batches", "(", "x_batch", ",", "lipschitz_constant", ",", "f_min", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Acquisition.__add__": [[14, 20], ["acquisition.Sum"], "methods", ["None"], ["def", "__add__", "(", "self", ",", "other", ":", "\"Acquisition\"", ")", "->", "\"Sum\"", ":", "\n", "        ", "\"\"\"\n        Overloads self + other\n        \"\"\"", "\n", "# If both acquisitions implement gradients, the gradients can be available in the sum", "\n", "return", "Sum", "(", "self", ",", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Acquisition.__mul__": [[21, 26], ["acquisition.Product"], "methods", ["None"], ["", "def", "__mul__", "(", "self", ",", "other", ":", "\"Acquisition\"", ")", "->", "\"Product\"", ":", "\n", "        ", "\"\"\"\n        Overloads self * other\n        \"\"\"", "\n", "return", "Product", "(", "self", ",", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Acquisition.__rmul__": [[27, 32], ["acquisition.Product"], "methods", ["None"], ["", "def", "__rmul__", "(", "self", ",", "other", ":", "\"Acquisition\"", ")", "->", "\"Product\"", ":", "\n", "        ", "\"\"\"\n        Overloads other * self\n        \"\"\"", "\n", "return", "Product", "(", "other", ",", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Acquisition.__truediv__": [[33, 38], ["acquisition.Quotient"], "methods", ["None"], ["", "def", "__truediv__", "(", "self", ",", "denominator", ":", "\"Acquisition\"", ")", "->", "\"Quotient\"", ":", "\n", "        ", "\"\"\"\n        Overloads self / other\n        \"\"\"", "\n", "return", "Quotient", "(", "self", ",", "denominator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Acquisition.evaluate": [[39, 48], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Abstract method. Evaluates the acquisition function.\n\n        :param x: (n_points x n_dims) array of points at which to calculate acquisition function values\n        :return: (n_points x 1) array of acquisition function values\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Acquisition.has_gradients": [[49, 58], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Abstract property. Whether acquisition value has analytical gradient calculation available.\n\n        :return: True if gradients are available\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Acquisition.evaluate_with_gradients": [[59, 69], ["NotImplementedError"], "methods", ["None"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Optional abstract method that must be implemented if has_gradients returns True.\n        Evaluates value and gradient of acquisition function at x.\n\n        :param x: (n_points x n_dims) array of points at which to calculate acquisition function values and gradient\n        :return: Tuple contains an (n_points x 1) array of acquisition function values and (n_points x n_dims) array of\n                 acquisition function gradients with respect to x\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Gradients not implemented for this acquisition function\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Acquisition.update_parameters": [[70, 75], ["None"], "methods", ["None"], ["", "def", "update_parameters", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Performs any updates to parameters that needs to be done once per outer loop iteration\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Quotient.__init__": [[82, 90], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "numerator", ":", "Acquisition", ",", "denominator", ":", "Acquisition", ")", ":", "\n", "        ", "\"\"\"\n\n        :param numerator: Acquisition function to act as numerator in quotient\n        :param denominator: Acquisition function to act as denominator in quotient\n        \"\"\"", "\n", "self", ".", "numerator", "=", "numerator", "\n", "self", ".", "denominator", "=", "denominator", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Quotient.evaluate": [[91, 99], ["acquisition.Quotient.numerator.evaluate", "acquisition.Quotient.denominator.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluate division of the two acquisition functions\n\n        :param x: (n_points x n_dims) array of points at which to calculate acquisition function values\n        :return: (n_points x 1) array of acquisition function values\n        \"\"\"", "\n", "return", "self", ".", "numerator", ".", "evaluate", "(", "x", ")", "/", "self", ".", "denominator", ".", "evaluate", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Quotient.evaluate_with_gradients": [[100, 118], ["acquisition.Quotient.numerator.evaluate_with_gradients", "acquisition.Quotient.denominator.evaluate_with_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Evaluate value and gradient of acquisition function at x\n\n        :param x: (n_points x n_dims) array of points at which to calculate acquisition function values and gradient\n        :return: Tuple contains an (n_points x 1) array of acquisition function values and (n_points x n_dims) array of\n                 acquisition function gradients with respect to x\n        \"\"\"", "\n", "# Evaluate both acquisition functions", "\n", "numerator_value", ",", "numerator_gradients", "=", "self", ".", "numerator", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "denominator_value", ",", "denominator_gradients", "=", "self", ".", "denominator", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "\n", "value", "=", "numerator_value", "/", "denominator_value", "\n", "# Calculate gradient of acquisition", "\n", "gradient", "=", "(", "numerator_gradients", "/", "denominator_value", ")", "-", "(", "\n", "(", "denominator_gradients", "*", "numerator_value", ")", "/", "(", "denominator_value", "**", "2", ")", "\n", ")", "\n", "return", "value", ",", "gradient", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Quotient.has_gradients": [[119, 127], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Whether acquisition value has analytical gradient calculation available.\n\n        :return: True if gradients are available\n        \"\"\"", "\n", "return", "self", ".", "denominator", ".", "has_gradients", "and", "self", ".", "numerator", ".", "has_gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Quotient.update_parameters": [[128, 134], ["acquisition.Quotient.denominator.update_parameters", "acquisition.Quotient.numerator.update_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters"], ["", "def", "update_parameters", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Performs any updates to parameters that needs to be done once per outer loop iteration\n        \"\"\"", "\n", "self", ".", "denominator", ".", "update_parameters", "(", ")", "\n", "self", ".", "numerator", ".", "update_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Product.__init__": [[141, 149], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "acquisition_1", ":", "Acquisition", ",", "acquisition_2", ":", "Acquisition", ")", ":", "\n", "        ", "\"\"\"\n\n        :param acquisition_1: Acquisition function in product\n        :param acquisition_2: Other acquisition function in product\n        \"\"\"", "\n", "self", ".", "acquisition_1", "=", "acquisition_1", "\n", "self", ".", "acquisition_2", "=", "acquisition_2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Product.evaluate": [[150, 158], ["acquisition.Product.acquisition_1.evaluate", "acquisition.Product.acquisition_2.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluate product of the two acquisition functions\n\n        :param x: (n_points x n_dims) array of points at which to calculate acquisition function values\n        :return: (n_points x 1) array of acquisition function values\n        \"\"\"", "\n", "return", "self", ".", "acquisition_1", ".", "evaluate", "(", "x", ")", "*", "self", ".", "acquisition_2", ".", "evaluate", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Product.evaluate_with_gradients": [[159, 175], ["acquisition.Product.acquisition_1.evaluate_with_gradients", "acquisition.Product.acquisition_2.evaluate_with_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Evaluate value and gradient of acquisition function at x\n\n        :param x: (n_points x n_dims) array of points at which to calculate acquisition function values and gradient\n        :return: Tuple contains an (n_points x 1) array of acquisition function values and (n_points x n_dims) array of\n                 acquisition function gradients with respect to x\n        \"\"\"", "\n", "# Evaluate acquisitions", "\n", "value_1", ",", "grad_1", "=", "self", ".", "acquisition_1", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "value_2", ",", "grad_2", "=", "self", ".", "acquisition_2", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "\n", "# Calculate gradient", "\n", "grad_total", "=", "value_1", "*", "grad_2", "+", "value_2", "*", "grad_1", "\n", "\n", "return", "value_1", "*", "value_2", ",", "grad_total", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Product.has_gradients": [[176, 184], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Whether acquisition value has analytical gradient calculation available.\n\n        :return: True if gradients are available\n        \"\"\"", "\n", "return", "self", ".", "acquisition_1", ".", "has_gradients", "and", "self", ".", "acquisition_2", ".", "has_gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Product.update_parameters": [[185, 191], ["acquisition.Product.acquisition_1.update_parameters", "acquisition.Product.acquisition_2.update_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters"], ["", "def", "update_parameters", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Performs any updates to parameters that needs to be done once per outer loop iteration\n        \"\"\"", "\n", "self", ".", "acquisition_1", ".", "update_parameters", "(", ")", "\n", "self", ".", "acquisition_2", ".", "update_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.__init__": [[198, 205], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "acquisition_1", ":", "Acquisition", ",", "acquisition_2", ":", "Acquisition", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param acquisition_1: An acquisition function in sum\n        :param acquisition_2: Other acquisition function in sum\n        \"\"\"", "\n", "self", ".", "acquisition_1", "=", "acquisition_1", "\n", "self", ".", "acquisition_2", "=", "acquisition_2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.evaluate": [[206, 214], ["acquisition.Sum.acquisition_1.evaluate", "acquisition.Sum.acquisition_2.evaluate"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluate sum of the two acquisition functions\n\n        :param x: (n_points x n_dims) array of points at which to calculate acquisition function values\n        :return: (n_points x 1) array of acquisition function values\n        \"\"\"", "\n", "return", "self", ".", "acquisition_1", ".", "evaluate", "(", "x", ")", "+", "self", ".", "acquisition_2", ".", "evaluate", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.evaluate_with_gradients": [[215, 228], ["acquisition.Sum.acquisition_1.evaluate_with_gradients", "acquisition.Sum.acquisition_2.evaluate_with_gradients"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Evaluate value and gradient of acquisition function at x\n\n        :param x: (n_points x n_dims) array of points at which to calculate acquisition function values and gradient\n        :return: Tuple contains an (n_points x 1) array of acquisition function values and (n_points x n_dims) array of\n                 acquisition function gradients with respect to x\n        \"\"\"", "\n", "# Evaluate first acquisition with gradients", "\n", "value_1", ",", "grad_1", "=", "self", ".", "acquisition_1", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "value_2", ",", "grad_2", "=", "self", ".", "acquisition_2", ".", "evaluate_with_gradients", "(", "x", ")", "\n", "\n", "return", "value_1", "+", "value_2", ",", "grad_1", "+", "grad_2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.has_gradients": [[229, 237], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Whether acquisition value has analytical gradient calculation available.\n\n        :return: True if gradients are available\n        \"\"\"", "\n", "return", "self", ".", "acquisition_1", ".", "has_gradients", "and", "self", ".", "acquisition_2", ".", "has_gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters": [[238, 244], ["acquisition.Sum.acquisition_1.update_parameters", "acquisition.Sum.acquisition_2.update_parameters"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition.Sum.update_parameters"], ["", "def", "update_parameters", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Performs any updates to parameters that needs to be done once per outer loop iteration\n        \"\"\"", "\n", "self", ".", "acquisition_1", ".", "update_parameters", "(", ")", "\n", "self", ".", "acquisition_2", ".", "update_parameters", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.__init__": [[26, 34], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "cost_model", ":", "IModel", ",", "min_cost", ":", "float", "=", "1e-4", ")", ":", "\n", "        ", "\"\"\"\n        :param cost_model: Model of cost. Should return only positive predictions\n        :param min_cost: A minimum value for the cost. The cost model prediction will be clipped to this value if\n                         required\n        \"\"\"", "\n", "self", ".", "cost_model", "=", "cost_model", "\n", "self", ".", "min_cost", "=", "min_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate": [[35, 44], ["numpy.maximum", "acquisition_per_cost.CostAcquisition.cost_model.predict"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict"], ["", "def", "evaluate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Evaluate acquisition function\n\n        :param x: A numpy array of shape (n_inputs x n_input_features) containing input locations at which to evaluate\n                  the cost\n        :return: Value of expected cost at input locations\n        \"\"\"", "\n", "return", "np", ".", "maximum", "(", "self", ".", "cost_model", ".", "predict", "(", "x", ")", "[", "0", "]", ",", "self", ".", "min_cost", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.has_gradients": [[45, 51], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_gradients", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Whether gradients of the cost function with respect to input location are available\n        \"\"\"", "\n", "return", "isinstance", "(", "self", ".", "cost_model", ",", "IDifferentiable", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate_with_gradients": [[52, 64], ["acquisition_per_cost.CostAcquisition.cost_model.predict", "acquisition_per_cost.CostAcquisition.cost_model.get_prediction_gradients", "numpy.maximum"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict", "home.repos.pwc.inspect_result.amzn_emukit.model_wrappers.gpy_model_wrappers.GPyMultiOutputWrapper.get_prediction_gradients"], ["", "def", "evaluate_with_gradients", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n\n        :param x: A numpy array of shape (n_inputs x n_input_features) containing input locations at which to evaluate\n                  the cost\n        :return: Tuple of numpy arrays: (cost value, cost gradients)\n        \"\"\"", "\n", "expected_cost", "=", "self", ".", "cost_model", ".", "predict", "(", "x", ")", "[", "0", "]", "\n", "is_below_min_cost", "=", "(", "expected_cost", "<", "self", ".", "min_cost", ")", ".", "flatten", "(", ")", "\n", "grad", "=", "self", ".", "cost_model", ".", "get_prediction_gradients", "(", "x", ")", "[", "0", "]", "\n", "grad", "[", "is_below_min_cost", ",", ":", "]", "=", "0", "\n", "return", "np", ".", "maximum", "(", "expected_cost", ",", "self", ".", "min_cost", ")", ",", "grad", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.acquisition_per_expected_cost": [[9, 19], ["acquisition_per_cost.CostAcquisition"], "function", ["None"], ["def", "acquisition_per_expected_cost", "(", "acquisition", ":", "Acquisition", ",", "cost_model", ":", "IModel", ",", "min_cost", ":", "float", "=", "1e-4", ")", "->", "Acquisition", ":", "\n", "    ", "\"\"\"\n    Creates an acquisition function that is the original acquisition scaled by the expected value of the evaluation\n    cost of the user function.\n\n    :param acquisition: Base acquisition function\n    :param cost_model: Model of the evaluation cost. Should return positive values only.\n    :return: Scaled acquisition function\n    \"\"\"", "\n", "return", "acquisition", "/", "CostAcquisition", "(", "cost_model", ",", "min_cost", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.base.ModelFreeDesignBase.__init__": [[14, 19], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "parameter_space", ":", "ParameterSpace", ")", ":", "\n", "        ", "\"\"\"\n        :param parameter_space: The parameter space to generate design for.\n        \"\"\"", "\n", "self", ".", "parameter_space", "=", "parameter_space", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.base.ModelFreeDesignBase.get_samples": [[20, 28], ["NotImplementedError"], "methods", ["None"], ["", "def", "get_samples", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates requested amount of points.\n\n        :param point_count: Number of points required.\n        :return: A numpy array of generated samples, shape (point_count x space_dim)\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Subclasses should implement this method.\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.random_design.RandomDesign.__init__": [[16, 21], ["base.ModelFreeDesignBase.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "parameter_space", ":", "ParameterSpace", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param parameter_space: The parameter space to generate design for.\n        \"\"\"", "\n", "super", "(", "RandomDesign", ",", "self", ")", ".", "__init__", "(", "parameter_space", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.random_design.RandomDesign.get_samples": [[22, 30], ["random_design.RandomDesign.parameter_space.sample_uniform"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.sample_uniform"], ["", "def", "get_samples", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates requested amount of points.\n\n        :param point_count: Number of points required.\n        :return: A numpy array of generated samples, shape (point_count x space_dim)\n        \"\"\"", "\n", "return", "self", ".", "parameter_space", ".", "sample_uniform", "(", "point_count", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.sobol_design.SobolDesign.__init__": [[22, 27], ["base.ModelFreeDesignBase.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "parameter_space", ":", "ParameterSpace", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        param parameter_space: The parameter space to generate design for.\n        \"\"\"", "\n", "super", "(", "SobolDesign", ",", "self", ")", ".", "__init__", "(", "parameter_space", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.sobol_design.SobolDesign.get_samples": [[28, 45], ["sobol_design.SobolDesign.parameter_space.get_bounds", "[].reshape", "[].reshape", "sobol_design.SobolDesign.parameter_space.round", "len", "len", "numpy.dot", "i4_sobol_generate", "numpy.diag", "numpy.asarray", "numpy.asarray", "len"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_bounds", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "get_samples", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates requested amount of points.\n\n        :param point_count: Number of points required.\n        :return: A numpy array of generated samples, shape (point_count x space_dim)\n        \"\"\"", "\n", "bounds", "=", "self", ".", "parameter_space", ".", "get_bounds", "(", ")", "\n", "lower_bound", "=", "np", ".", "asarray", "(", "bounds", ")", "[", ":", ",", "0", "]", ".", "reshape", "(", "1", ",", "len", "(", "bounds", ")", ")", "\n", "upper_bound", "=", "np", ".", "asarray", "(", "bounds", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "1", ",", "len", "(", "bounds", ")", ")", "\n", "diff", "=", "upper_bound", "-", "lower_bound", "\n", "\n", "X_design", "=", "np", ".", "dot", "(", "i4_sobol_generate", "(", "len", "(", "bounds", ")", ",", "point_count", ")", ",", "np", ".", "diag", "(", "diff", "[", "0", ",", ":", "]", ")", ")", "+", "lower_bound", "\n", "\n", "samples", "=", "self", ".", "parameter_space", ".", "round", "(", "X_design", ")", "\n", "\n", "return", "samples", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.__init__": [[23, 28], ["base.ModelFreeDesignBase.__init__"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["def", "__init__", "(", "self", ",", "parameter_space", ":", "ParameterSpace", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        :param parameter_space: The parameter space to generate design for.\n        \"\"\"", "\n", "super", "(", "LatinDesign", ",", "self", ")", ".", "__init__", "(", "parameter_space", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples": [[29, 49], ["latin_design.LatinDesign.parameter_space.get_bounds", "pyDOE.lhs", "numpy.ones", "[].reshape", "[].reshape", "latin_design.LatinDesign.parameter_space.round", "len", "len", "len", "numpy.dot", "numpy.dot", "numpy.asarray", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.core.parameter_space.ParameterSpace.get_bounds", "home.repos.pwc.inspect_result.amzn_emukit.core.parameter.Parameter.round"], ["", "def", "get_samples", "(", "self", ",", "point_count", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generates requested amount of points.\n\n        :param point_count: Number of points required.\n        :return: A numpy array of generated samples, shape (point_count x space_dim)\n        \"\"\"", "\n", "bounds", "=", "self", ".", "parameter_space", ".", "get_bounds", "(", ")", "\n", "X_design_aux", "=", "pyDOE", ".", "lhs", "(", "len", "(", "bounds", ")", ",", "point_count", ",", "criterion", "=", "\"center\"", ")", "\n", "ones", "=", "np", ".", "ones", "(", "(", "X_design_aux", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n", "lower_bound", "=", "np", ".", "asarray", "(", "bounds", ")", "[", ":", ",", "0", "]", ".", "reshape", "(", "1", ",", "len", "(", "bounds", ")", ")", "\n", "upper_bound", "=", "np", ".", "asarray", "(", "bounds", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "1", ",", "len", "(", "bounds", ")", ")", "\n", "diff", "=", "upper_bound", "-", "lower_bound", "\n", "\n", "X_design", "=", "np", ".", "dot", "(", "ones", ",", "lower_bound", ")", "+", "X_design_aux", "*", "np", ".", "dot", "(", "ones", ",", "diff", ")", "\n", "\n", "samples", "=", "self", ".", "parameter_space", ".", "round", "(", "X_design", ")", "\n", "\n", "return", "samples", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.experimental_design_loop.ExperimentalDesignLoop.__init__": [[14, 60], ["core.loop.FixedIntervalUpdater", "core.loop.loop_state.create_loop_state", "core.loop.OuterLoop.__init__", "acquisitions.ModelVariance", "core.optimization.GradientAcquisitionOptimizer", "core.loop.SequentialPointCalculator", "core.loop.candidate_point_calculators.GreedyBatchPointCalculator", "ValueError", "str"], "methods", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "space", ":", "ParameterSpace", ",", "\n", "model", ":", "IModel", ",", "\n", "acquisition", ":", "Acquisition", "=", "None", ",", "\n", "update_interval", ":", "int", "=", "1", ",", "\n", "batch_size", ":", "int", "=", "1", ",", "\n", "acquisition_optimizer", ":", "AcquisitionOptimizerBase", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        An outer loop class for use with Experimental design\n\n        :param space: Definition of domain bounds to collect points within\n        :param model: The model that approximates the underlying function\n        :param acquisition: experimental design acquisition function object. Default: ModelVariance acquisition\n        :param update_interval: How many iterations pass before next model optimization\n        :param batch_size: Number of points to collect in a batch. Defaults to one.\n        :param acquisition_optimizer: Optimizer selecting next evaluation points\n                                      by maximizing acquisition.\n                                      Gradient based optimizer is used if None.\n                                      Defaults to None.\n        \"\"\"", "\n", "\n", "if", "acquisition", "is", "None", ":", "\n", "            ", "acquisition", "=", "ModelVariance", "(", "model", ")", "\n", "\n", "# This AcquisitionOptimizer object deals with optimizing the acquisition to find the next point to collect", "\n", "", "if", "acquisition_optimizer", "is", "None", ":", "\n", "            ", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "\n", "# Construct emukit classes", "\n", "", "if", "batch_size", "==", "1", ":", "\n", "            ", "candidate_point_calculator", "=", "SequentialPointCalculator", "(", "acquisition", ",", "acquisition_optimizer", ")", "\n", "", "elif", "batch_size", ">", "1", ":", "\n", "            ", "candidate_point_calculator", "=", "GreedyBatchPointCalculator", "(", "\n", "model", ",", "acquisition", ",", "acquisition_optimizer", ",", "batch_size", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Batch size value of \"", "+", "str", "(", "batch_size", ")", "+", "\" is invalid.\"", ")", "\n", "\n", "", "model_updater", "=", "FixedIntervalUpdater", "(", "model", ",", "update_interval", ")", "\n", "loop_state", "=", "create_loop_state", "(", "model", ".", "X", ",", "model", ".", "Y", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "candidate_point_calculator", ",", "model_updater", ",", "loop_state", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.f": [[13, 15], ["None"], "function", ["None"], ["def", "f", "(", "x", ")", ":", "\n", "    ", "return", "x", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.test_loop_initial_state": [[17, 30], ["numpy.random.rand", "numpy.random.rand", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "emukit.core.parameter_space.ParameterSpace", "emukit.experimental_design.ExperimentalDesignLoop", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "emukit.core.continuous_parameter.ContinuousParameter"], "function", ["None"], ["", "def", "test_loop_initial_state", "(", ")", ":", "\n", "    ", "x_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "\n", "exp_design", "=", "ExperimentalDesignLoop", "(", "space", ",", "model", ")", "\n", "\n", "# test loop state initialization", "\n", "assert_array_equal", "(", "exp_design", ".", "loop_state", ".", "X", ",", "x_init", ")", "\n", "assert_array_equal", "(", "exp_design", ".", "loop_state", ".", "Y", ",", "y_init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_loop.test_loop": [[32, 51], ["numpy.random.rand", "numpy.random.rand", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "emukit.core.parameter_space.ParameterSpace", "emukit.experimental_design.acquisitions.ModelVariance", "emukit.experimental_design.ExperimentalDesignLoop", "emukit.experimental_design.ExperimentalDesignLoop.run_loop", "emukit.core.loop.UserFunctionWrapper", "emukit.core.loop.FixedIterationsStoppingCondition", "emukit.core.continuous_parameter.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_loop", "(", ")", ":", "\n", "    ", "n_iterations", "=", "5", "\n", "\n", "x_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "y_init", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "1", ")", "\n", "\n", "# Make GPy model", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "1", ")", "]", ")", "\n", "acquisition", "=", "ModelVariance", "(", "model", ")", "\n", "\n", "# Make loop and collect points", "\n", "exp_design", "=", "ExperimentalDesignLoop", "(", "space", ",", "model", ",", "acquisition", ")", "\n", "exp_design", ".", "run_loop", "(", "UserFunctionWrapper", "(", "f", ")", ",", "FixedIterationsStoppingCondition", "(", "n_iterations", ")", ")", "\n", "\n", "# Check we got the correct number of points", "\n", "assert", "exp_design", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "10", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.__init__": [[17, 20], ["numpy.zeros", "numpy.zeros"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_X", "=", "np", ".", "zeros", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "_Y", "=", "np", ".", "zeros", "(", "(", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.set_data": [[21, 24], ["None"], "methods", ["None"], ["", "def", "set_data", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "self", ".", "_X", "=", "X", "\n", "self", ".", "_Y", "=", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.predict": [[25, 27], ["numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.X": [[28, 31], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "X", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_X", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.MockModel.Y": [[32, 35], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "Y", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_Y", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.mock_model": [[37, 40], ["pytest.fixture", "test_batch_experimental_design.MockModel"], "function", ["None"], ["", "", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "mock_model", "(", ")", ":", "\n", "    ", "return", "MockModel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.test_batch_experimental_design_loop": [[42, 63], ["emukit.core.ParameterSpace", "user_function", "GPy.models.GPRegression", "MockGPyModel", "emukit.experimental_design.ExperimentalDesignLoop", "emukit.experimental_design.ExperimentalDesignLoop.run_loop", "numpy.linspace", "emukit.core.ContinuousParameter"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["", "def", "test_batch_experimental_design_loop", "(", ")", ":", "\n", "    ", "class", "MockGPyModel", "(", "GPyModelWrapper", ")", ":", "\n", "        ", "def", "optimize", "(", "self", ")", ":", "\n", "# speed up test by skipping the actual hyper-parameter optimization", "\n", "            ", "pass", "\n", "\n", "", "", "user_function", "=", "lambda", "x", ":", "x", "\n", "\n", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "3", ")", "]", ")", "\n", "\n", "# Make model", "\n", "x_init", "=", "np", ".", "linspace", "(", "0", ",", "3", ",", "5", ")", "[", ":", ",", "None", "]", "\n", "y_init", "=", "user_function", "(", "x_init", ")", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "MockGPyModel", "(", "gpy_model", ")", "\n", "\n", "loop", "=", "ExperimentalDesignLoop", "(", "space", ",", "model", ",", "batch_size", "=", "5", ")", "\n", "loop", ".", "run_loop", "(", "user_function", ",", "5", ")", "\n", "\n", "assert", "loop", ".", "loop_state", ".", "iteration", "==", "5", "\n", "assert", "loop", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "30", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.test_batch_point_calculator": [[65, 77], ["mock.create_autospec", "mock.create_autospec", "emukit.core.loop.candidate_point_calculators.GreedyBatchPointCalculator", "emukit.core.loop.loop_state.create_loop_state", "emukit.core.loop.candidate_point_calculators.GreedyBatchPointCalculator.compute_next_points", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.loop.loop_state.create_loop_state", "home.repos.pwc.inspect_result.amzn_emukit.point_calculators.quadrature_point_calculators.BayesianMonteCarloPointCalculator.compute_next_points"], ["", "def", "test_batch_point_calculator", "(", "mock_model", ")", ":", "\n", "\n", "    ", "acquisition", "=", "mock", ".", "create_autospec", "(", "Acquisition", ")", "\n", "acquisition_optimizer", "=", "mock", ".", "create_autospec", "(", "GradientAcquisitionOptimizer", ")", "\n", "acquisition_optimizer", ".", "optimize", ".", "return_value", "=", "(", "np", ".", "zeros", "(", "(", "1", ",", "1", ")", ")", ",", "0", ")", "\n", "batch_size", "=", "10", "\n", "\n", "calculator", "=", "GreedyBatchPointCalculator", "(", "mock_model", ",", "acquisition", ",", "acquisition_optimizer", ",", "batch_size", ")", "\n", "\n", "loop_state", "=", "create_loop_state", "(", "np", ".", "zeros", "(", "(", "1", ",", "1", ")", ")", ",", "np", ".", "zeros", "(", "(", "1", ",", "1", ")", ")", ")", "\n", "next_points", "=", "calculator", ".", "compute_next_points", "(", "loop_state", ")", "\n", "assert", "next_points", ".", "shape", "[", "0", "]", "==", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.test_zero_batch_size": [[79, 85], ["emukit.core.ParameterSpace", "pytest.raises", "emukit.experimental_design.ExperimentalDesignLoop", "emukit.core.ContinuousParameter"], "function", ["None"], ["", "def", "test_zero_batch_size", "(", "mock_model", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "3", ")", "]", ")", "\n", "\n", "# Make model", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ExperimentalDesignLoop", "(", "space", ",", "mock_model", ",", "batch_size", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_batch_experimental_design.test_non_integer_batch_size": [[87, 93], ["emukit.core.ParameterSpace", "pytest.raises", "emukit.experimental_design.ExperimentalDesignLoop", "emukit.core.ContinuousParameter"], "function", ["None"], ["", "", "def", "test_non_integer_batch_size", "(", "mock_model", ")", ":", "\n", "    ", "space", "=", "ParameterSpace", "(", "[", "ContinuousParameter", "(", "\"x\"", ",", "0", ",", "3", ")", "]", ")", "\n", "\n", "# Make model", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ExperimentalDesignLoop", "(", "space", ",", "mock_model", ",", "batch_size", "=", "3.5", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_integrated_variance.test_integrated_variance_fails_with_out_of_domain_test_points": [[7, 16], ["numpy.array", "pytest.raises", "emukit.experimental_design.acquisitions.integrated_variance.IntegratedVarianceReduction"], "function", ["None"], ["def", "test_integrated_variance_fails_with_out_of_domain_test_points", "(", "gpy_model", ",", "continuous_space", ")", ":", "\n", "    ", "\"\"\"\n    Checks that if the user supplies x_monte_carlo to the function\n    and they are out of the domain of the parameter space a ValueError is raised.\n    \"\"\"", "\n", "x_monte_carlo", "=", "np", ".", "array", "(", "[", "[", "0.5", ",", "20.0", "]", ",", "[", "0.2", ",", "0.3", "]", "]", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "IntegratedVarianceReduction", "(", "gpy_model", ",", "continuous_space", ",", "x_monte_carlo", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_multi_source_experimental_design.test_multi_source_batch_experimental_design": [[15, 45], ["emukit.test_functions.multi_fidelity_forrester_function", "emukit.core.initial_designs.RandomDesign", "emukit.core.initial_designs.RandomDesign.get_samples", "objective.evaluate", "numpy.array", "emukit.core.optimization.GradientAcquisitionOptimizer", "emukit.core.optimization.multi_source_acquisition_optimizer.MultiSourceAcquisitionOptimizer", "GPy.models.GPRegression", "emukit.model_wrappers.GPyModelWrapper", "emukit.experimental_design.acquisitions.ModelVariance", "emukit.core.loop.candidate_point_calculators.GreedyBatchPointCalculator", "emukit.core.loop.loop_state.LoopState", "emukit.core.loop.OuterLoop", "emukit.core.loop.OuterLoop.run_loop", "emukit.core.loop.FixedIntervalUpdater"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.test_functions.forrester.multi_fidelity_forrester_function", "home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples", "home.repos.pwc.inspect_result.amzn_emukit.acquisition.acquisition_per_cost.CostAcquisition.evaluate", "home.repos.pwc.inspect_result.amzn_emukit.loop.outer_loop.OuterLoop.run_loop"], ["def", "test_multi_source_batch_experimental_design", "(", ")", ":", "\n", "    ", "objective", ",", "space", "=", "multi_fidelity_forrester_function", "(", ")", "\n", "\n", "# Create initial data", "\n", "random_design", "=", "RandomDesign", "(", "space", ")", "\n", "x_init", "=", "random_design", ".", "get_samples", "(", "10", ")", "\n", "intiial_results", "=", "objective", ".", "evaluate", "(", "x_init", ")", "\n", "y_init", "=", "np", ".", "array", "(", "[", "res", ".", "Y", "for", "res", "in", "intiial_results", "]", ")", "\n", "\n", "# Create multi source acquisition optimizer", "\n", "acquisition_optimizer", "=", "GradientAcquisitionOptimizer", "(", "space", ")", "\n", "multi_source_acquisition_optimizer", "=", "MultiSourceAcquisitionOptimizer", "(", "acquisition_optimizer", ",", "space", ")", "\n", "\n", "# Create GP model", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "# Create acquisition", "\n", "acquisition", "=", "ModelVariance", "(", "model", ")", "\n", "\n", "# Create batch candidate point calculator", "\n", "batch_candidate_point_calculator", "=", "GreedyBatchPointCalculator", "(", "\n", "model", ",", "acquisition", ",", "multi_source_acquisition_optimizer", ",", "batch_size", "=", "5", "\n", ")", "\n", "\n", "initial_loop_state", "=", "LoopState", "(", "intiial_results", ")", "\n", "loop", "=", "OuterLoop", "(", "batch_candidate_point_calculator", ",", "FixedIntervalUpdater", "(", "model", ",", "1", ")", ",", "initial_loop_state", ")", "\n", "\n", "loop", ".", "run_loop", "(", "objective", ",", "10", ")", "\n", "assert", "loop", ".", "loop_state", ".", "X", ".", "shape", "[", "0", "]", "==", "60", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.experimental_design.test_experimental_design_with_categorical.test_categorical_variables": [[10, 39], ["numpy.random.seed", "emukit.core.OneHotEncoding", "emukit.core.ParameterSpace", "emukit.core.initial_designs.latin_design.LatinDesign", "emukit.core.initial_designs.latin_design.LatinDesign.get_samples", "numpy.all", "test_experimental_design_with_categorical.test_categorical_variables.objective"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.initial_designs.latin_design.LatinDesign.get_samples", "home.repos.pwc.inspect_result.amzn_emukit.optimization.test_optimizer.objective"], ["def", "test_categorical_variables", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "\n", "def", "objective", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "np", ".", "sum", "(", "x", ",", "axis", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "", "carol_spirits", "=", "[", "\"past\"", ",", "\"present\"", ",", "\"yet to come\"", "]", "\n", "encoding", "=", "OneHotEncoding", "(", "carol_spirits", ")", "\n", "parameter_space", "=", "ParameterSpace", "(", "\n", "[", "ContinuousParameter", "(", "\"real_param\"", ",", "0.0", ",", "1.0", ")", ",", "CategoricalParameter", "(", "\"categorical_param\"", ",", "encoding", ")", "]", "\n", ")", "\n", "\n", "random_design", "=", "LatinDesign", "(", "parameter_space", ")", "\n", "x_init", "=", "random_design", ".", "get_samples", "(", "10", ")", "\n", "\n", "assert", "x_init", ".", "shape", "==", "(", "10", ",", "4", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "logical_or", "(", "x_init", "[", ":", ",", "1", ":", "3", "]", "==", "0.0", ",", "x_init", "[", ":", ",", "1", ":", "3", "]", "==", "1.0", ")", ")", "\n", "\n", "y_init", "=", "objective", "(", "x_init", ")", "\n", "\n", "gpy_model", "=", "GPy", ".", "models", ".", "GPRegression", "(", "x_init", ",", "y_init", ")", "\n", "gpy_model", ".", "Gaussian_noise", ".", "fix", "(", "1", ")", "\n", "model", "=", "GPyModelWrapper", "(", "gpy_model", ")", "\n", "\n", "loop", "=", "ExperimentalDesignLoop", "(", "parameter_space", ",", "model", ")", "\n", "loop", ".", "run_loop", "(", "objective", ",", "5", ")", "\n", "\n", "assert", "len", "(", "loop", ".", "loop_state", ".", "Y", ")", "==", "15", "\n", "assert", "np", ".", "all", "(", "np", ".", "logical_or", "(", "loop", ".", "loop_state", ".", "X", "[", ":", ",", "1", ":", "3", "]", "==", "0.0", ",", "loop", ".", "loop_state", ".", "X", "[", ":", ",", "1", ":", "3", "]", "==", "1.0", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amzn_emukit.notebooks.test_notebooks.get_notebook_names": [[16, 29], ["os.listdir", "file.endswith", "notebook_names.append"], "function", ["None"], ["def", "get_notebook_names", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get names of all notebooks in notebook directory\n    :return:\n    \"\"\"", "\n", "extension", "=", "'.ipynb'", "\n", "\n", "notebook_names", "=", "[", "]", "\n", "for", "file", "in", "os", ".", "listdir", "(", "notebook_directory", ")", ":", "\n", "        ", "if", "file", ".", "endswith", "(", "extension", ")", "and", "(", "file", "not", "in", "excluded_notebooks", ")", ":", "\n", "            ", "notebook_names", ".", "append", "(", "file", ")", "\n", "\n", "", "", "return", "notebook_names", "\n", "\n"]], "home.repos.pwc.inspect_result.amzn_emukit.notebooks.test_notebooks.test_notebook_runs_without_errors": [[31, 37], ["pytest.mark.parametrize", "nbconvert.preprocessors.ExecutePreprocessor", "nbconvert.preprocessors.ExecutePreprocessor.preprocess", "test_notebooks.get_notebook_names", "open", "nbformat.read", "os.path.join"], "function", ["home.repos.pwc.inspect_result.amzn_emukit.notebooks.test_notebooks.get_notebook_names"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"name\"", ",", "get_notebook_names", "(", ")", ")", "\n", "def", "test_notebook_runs_without_errors", "(", "name", ")", ":", "\n", "    ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "notebook_directory", ",", "name", ")", ")", "as", "f", ":", "\n", "        ", "nb", "=", "nbformat", ".", "read", "(", "f", ",", "as_version", "=", "4", ")", "\n", "", "ep", "=", "ExecutePreprocessor", "(", "timeout", "=", "120", ")", "\n", "ep", ".", "preprocess", "(", "nb", ",", "{", "'metadata'", ":", "{", "'path'", ":", "notebook_directory", "}", "}", ")", "\n", "", ""]]}