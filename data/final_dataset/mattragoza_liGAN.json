{"home.repos.pwc.inspect_result.mattragoza_liGAN.None.generate.parse_args": [[7, 14], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.None.train.parse_args"], ["def", "parse_args", "(", "argv", "=", "None", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate atomic density grids from generative model'", "\n", ")", "\n", "parser", ".", "add_argument", "(", "'config_file'", ")", "\n", "parser", ".", "add_argument", "(", "'--debug'", ",", "default", "=", "False", ",", "action", "=", "'store_true'", ")", "\n", "return", "parser", ".", "parse_args", "(", "argv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.None.generate.main": [[16, 45], ["generate.parse_args", "liGAN.set_random_seed", "getattr", "getattr.", "generator_type.generate", "print", "open", "yaml.safe_load", "yaml.safe_load.get", "yaml.safe_load.get", "config[].get", "yaml.safe_load.get", "yaml.safe_load.get", "yaml.safe_load.get", "yaml.safe_load.get"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.None.train.parse_args", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.generate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "def", "main", "(", "argv", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", "argv", ")", "\n", "\n", "with", "open", "(", "args", ".", "config_file", ")", "as", "f", ":", "\n", "        ", "config", "=", "yaml", ".", "safe_load", "(", "f", ")", "\n", "\n", "", "device", "=", "'cuda'", "\n", "liGAN", ".", "set_random_seed", "(", "config", ".", "get", "(", "'random_seed'", ",", "None", ")", ")", "\n", "\n", "generator_type", "=", "config", ".", "get", "(", "'model_type'", ",", "None", ")", "or", "'Molecule'", "\n", "generator_type", "=", "getattr", "(", "\n", "liGAN", ".", "generating", ",", "generator_type", "+", "'Generator'", "\n", ")", "\n", "generator", "=", "generator_type", "(", "\n", "out_prefix", "=", "config", "[", "'out_prefix'", "]", ",", "\n", "n_samples", "=", "config", "[", "'generate'", "]", "[", "'n_samples'", "]", ",", "\n", "fit_atoms", "=", "config", "[", "'generate'", "]", ".", "get", "(", "'fit_atoms'", ",", "True", ")", ",", "\n", "data_kws", "=", "config", "[", "'data'", "]", ",", "\n", "gen_model_kws", "=", "config", ".", "get", "(", "'gen_model'", ",", "{", "}", ")", ",", "\n", "prior_model_kws", "=", "config", ".", "get", "(", "'prior_model'", ",", "{", "}", ")", ",", "\n", "atom_fitting_kws", "=", "config", ".", "get", "(", "'atom_fitting'", ",", "{", "}", ")", ",", "\n", "bond_adding_kws", "=", "config", ".", "get", "(", "'bond_adding'", ",", "{", "}", ")", ",", "\n", "output_kws", "=", "config", "[", "'output'", "]", ",", "\n", "device", "=", "'cuda'", ",", "\n", "verbose", "=", "config", "[", "'verbose'", "]", ",", "\n", "debug", "=", "args", ".", "debug", ",", "\n", ")", "\n", "generator", ".", "generate", "(", "**", "config", "[", "'generate'", "]", ")", "\n", "print", "(", "'Done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.None.train.parse_args": [[8, 18], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.None.train.parse_args"], ["def", "parse_args", "(", "argv", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'train a deep neural network to generate atomic density grids'", ")", "\n", "parser", ".", "add_argument", "(", "'config_file'", ")", "\n", "parser", ".", "add_argument", "(", "'--debug'", ",", "default", "=", "False", ",", "action", "=", "'store_true'", ")", "\n", "# TODO reimplement the following arguments", "\n", "parser", ".", "add_argument", "(", "'--instance_noise'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "'standard deviation of disc instance noise (default 0.0)'", ")", "\n", "# removing wandb option in place of putting wandb configs in the config file", "\n", "# parser.add_argument('--wandb', action='store_true', help='enable weights and biases')", "\n", "parser", ".", "add_argument", "(", "'--lr_policy'", ",", "type", "=", "str", ",", "help", "=", "'learning rate policy'", ")", "\n", "return", "parser", ".", "parse_args", "(", "argv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.None.train.main": [[20, 88], ["openbabel.openbabel.obErrorLog.SetOutputLevel", "train.parse_args", "liGAN.set_random_seed", "getattr", "getattr.", "solver_type.train_and_test", "open", "yaml.safe_load", "Exception", "yaml.safe_load.get", "min", "wandb.init", "wandb.init", "sys.stderr.write", "yaml.safe_load.get", "yaml.safe_load.get", "yaml.safe_load.get", "yaml.safe_load.get", "yaml.safe_load.get", "yaml.safe_load.get", "yaml.safe_load.get", "solver_type.load_state_and_metrics", "os.mkdir", "wandb.Settings", "wandb.Settings"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.None.train.parse_args", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_and_test", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.load_state_and_metrics"], ["", "def", "main", "(", "argv", ")", ":", "\n", "    ", "ob", ".", "obErrorLog", ".", "SetOutputLevel", "(", "0", ")", "\n", "args", "=", "parse_args", "(", "argv", ")", "\n", "\n", "with", "open", "(", "args", ".", "config_file", ")", "as", "f", ":", "\n", "        ", "config", "=", "yaml", ".", "safe_load", "(", "f", ")", "\n", "\n", "", "if", "'wandb'", "in", "config", "and", "'use_wandb'", "not", "in", "config", "[", "'wandb'", "]", ":", "\n", "        ", "raise", "Exception", "(", "'use_wandb must be included in wandb configs'", ")", "\n", "\n", "", "if", "'wandb'", "in", "config", "and", "config", "[", "'wandb'", "]", "[", "'use_wandb'", "]", ":", "\n", "        ", "import", "wandb", "\n", "if", "'init_kwargs'", "in", "config", "[", "'wandb'", "]", ":", "\n", "            ", "wandb", ".", "init", "(", "settings", "=", "wandb", ".", "Settings", "(", "start_method", "=", "\"fork\"", ")", ",", "\n", "config", "=", "config", ",", "**", "config", "[", "'wandb'", "]", "[", "'init_kwargs'", "]", ")", "\n", "", "else", ":", "\n", "            ", "wandb", ".", "init", "(", "settings", "=", "wandb", ".", "Settings", "(", "start_method", "=", "\"fork\"", ")", ",", "config", "=", "config", ")", "\n", "", "if", "'out_prefix'", "not", "in", "config", ":", "\n", "            ", "try", ":", "\n", "                ", "os", ".", "mkdir", "(", "'wandb_output'", ")", "\n", "", "except", "FileExistsError", ":", "\n", "                ", "pass", "\n", "", "config", "[", "'out_prefix'", "]", "=", "'wandb_output/'", "+", "wandb", ".", "run", ".", "id", "\n", "sys", ".", "stderr", ".", "write", "(", "\n", "'Setting output prefix to {}\\n'", ".", "format", "(", "config", "[", "'out_prefix'", "]", ")", "\n", ")", "\n", "\n", "", "", "device", "=", "'cuda'", "\n", "liGAN", ".", "set_random_seed", "(", "config", ".", "get", "(", "'random_seed'", ",", "None", ")", ")", "\n", "\n", "solver_type", "=", "getattr", "(", "\n", "liGAN", ".", "training", ",", "config", "[", "'model_type'", "]", "+", "'Solver'", "\n", ")", "\n", "solver", "=", "solver_type", "(", "\n", "data_kws", "=", "config", "[", "'data'", "]", ",", "\n", "wandb_kws", "=", "config", ".", "get", "(", "'wandb'", ",", "{", "'use_wandb'", ":", "False", "}", ")", ",", "\n", "gen_model_kws", "=", "config", "[", "'gen_model'", "]", ",", "\n", "disc_model_kws", "=", "config", ".", "get", "(", "'disc_model'", ",", "{", "}", ")", ",", "\n", "prior_model_kws", "=", "config", ".", "get", "(", "'prior_model'", ",", "{", "}", ")", ",", "\n", "loss_fn_kws", "=", "config", "[", "'loss_fn'", "]", ",", "\n", "gen_optim_kws", "=", "config", "[", "'gen_optim'", "]", ",", "\n", "disc_optim_kws", "=", "config", ".", "get", "(", "'disc_optim'", ",", "{", "}", ")", ",", "\n", "prior_optim_kws", "=", "config", ".", "get", "(", "'prior_optim'", ",", "{", "}", ")", ",", "\n", "atom_fitting_kws", "=", "config", "[", "'atom_fitting'", "]", ",", "\n", "bond_adding_kws", "=", "config", ".", "get", "(", "'bond_adding'", ",", "{", "}", ")", ",", "\n", "out_prefix", "=", "config", "[", "'out_prefix'", "]", ",", "\n", "device", "=", "device", ",", "\n", "debug", "=", "args", ".", "debug", ",", "\n", "sync_cuda", "=", "config", ".", "get", "(", "'sync_cuda'", ",", "False", ")", "\n", ")", "\n", "\n", "if", "config", "[", "'continue'", "]", ":", "\n", "        ", "if", "config", "[", "'continue'", "]", "is", "True", ":", "\n", "            ", "cont_iter", "=", "None", "\n", "", "else", ":", "\n", "            ", "cont_iter", "=", "config", "[", "'continue'", "]", "\n", "", "try", ":", "\n", "            ", "solver", ".", "load_state_and_metrics", "(", "cont_iter", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "            ", "pass", "\n", "\n", "", "", "if", "'max_n_iters'", "in", "config", ":", "\n", "        ", "config", "[", "'train'", "]", "[", "'max_iter'", "]", "=", "min", "(", "\n", "config", "[", "'train'", "]", "[", "'max_iter'", "]", ",", "\n", "solver", ".", "gen_iter", "+", "config", "[", "'max_n_iters'", "]", "\n", ")", "\n", "\n", "", "solver", ".", "train_and_test", "(", "**", "config", "[", "'train'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.convert_checkpoint.stdize_gen_layers": [[15, 21], ["list", "state_dict.keys", "state_dict.pop"], "function", ["None"], ["def", "stdize_gen_layers", "(", "state_dict", ")", ":", "\n", "    ", "for", "old_key", "in", "list", "(", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "        ", "if", "old_key", "in", "layer_map", ":", "\n", "            ", "new_key", "=", "layer_map", "[", "old_key", "]", "\n", "state_dict", "[", "new_key", "]", "=", "state_dict", ".", "pop", "(", "old_key", ")", "\n", "", "", "return", "state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.__init__": [[11, 30], ["os.mkfifo", "os.mkfifo", "open", "open", "open", "open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "end", "=", "0", ",", "mode", "=", "0o666", ")", ":", "\n", "        ", "\"\"\"Open a pair of pipes, name.in and name.out for communication\n        with another process.  One process should pass 1 for end, and the\n        other 0.  Data is marshalled with pickle.\"\"\"", "\n", "self", ".", "in_name", ",", "self", ".", "out_name", "=", "name", "+", "'.in'", ",", "name", "+", "'.out'", ",", "\n", "try", ":", "os", ".", "mkfifo", "(", "self", ".", "in_name", ",", "mode", ")", "\n", "except", "OSError", ":", "pass", "\n", "try", ":", "os", ".", "mkfifo", "(", "self", ".", "out_name", ",", "mode", ")", "\n", "except", "OSError", ":", "pass", "\n", "\n", "# NOTE: The order the ends are opened in is important - both ends", "\n", "# of pipe 1 must be opened before the second pipe can be opened.", "\n", "if", "end", ":", "\n", "            ", "self", ".", "inp", "=", "open", "(", "self", ".", "out_name", ",", "'rb'", ")", "\n", "self", ".", "out", "=", "open", "(", "self", ".", "in_name", ",", "'wb'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "out", "=", "open", "(", "self", ".", "out_name", ",", "'wb'", ")", "\n", "self", ".", "inp", "=", "open", "(", "self", ".", "in_name", ",", "'rb'", ")", "\n", "", "self", ".", "_open", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.is_open": [[31, 33], ["None"], "methods", ["None"], ["", "def", "is_open", "(", "self", ")", ":", "\n", "        ", "return", "not", "(", "self", ".", "inp", ".", "closed", "or", "self", ".", "out", ".", "closed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.put": [[34, 42], ["interrupt.NamedPipe.is_open", "pickle.dumps", "interrupt.NamedPipe.out.write", "interrupt.NamedPipe.out.write", "interrupt.NamedPipe.out.flush", "Exception", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.is_open", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write"], ["", "def", "put", "(", "self", ",", "msg", ")", ":", "\n", "        ", "if", "self", ".", "is_open", "(", ")", ":", "\n", "            ", "data", "=", "pickle", ".", "dumps", "(", "msg", ",", "1", ")", "\n", "self", ".", "out", ".", "write", "(", "b\"%d\\n\"", "%", "len", "(", "data", ")", ")", "\n", "self", ".", "out", ".", "write", "(", "data", ")", "\n", "self", ".", "out", ".", "flush", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Pipe closed\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get": [[43, 52], ["interrupt.NamedPipe.inp.readline", "interrupt.NamedPipe.inp.close", "int", "interrupt.NamedPipe.inp.read", "pickle.loads", "len", "interrupt.NamedPipe.inp.close"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close"], ["", "", "def", "get", "(", "self", ")", ":", "\n", "        ", "txt", "=", "self", ".", "inp", ".", "readline", "(", ")", "\n", "if", "not", "txt", ":", "\n", "            ", "self", ".", "inp", ".", "close", "(", ")", "\n", "", "else", ":", "\n", "            ", "l", "=", "int", "(", "txt", ")", "\n", "data", "=", "self", ".", "inp", ".", "read", "(", "l", ")", "\n", "if", "len", "(", "data", ")", "<", "l", ":", "self", ".", "inp", ".", "close", "(", ")", "\n", "return", "pickle", ".", "loads", "(", "data", ")", "# Convert back to python object.", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close": [[53, 60], ["interrupt.NamedPipe.inp.close", "interrupt.NamedPipe.out.close", "os.remove", "os.remove"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "inp", ".", "close", "(", ")", "\n", "self", ".", "out", ".", "close", "(", ")", "\n", "try", ":", "os", ".", "remove", "(", "self", ".", "in_name", ")", "\n", "except", "OSError", ":", "pass", "\n", "try", ":", "os", ".", "remove", "(", "self", ".", "out_name", ")", "\n", "except", "OSError", ":", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.__del__": [[61, 63], ["interrupt.NamedPipe.close"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "self", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.pipename": [[6, 9], ["os.path.join", "tempfile.gettempdir"], "function", ["None"], ["def", "pipename", "(", "pid", ")", ":", "\n", "    ", "\"\"\"Return name of pipe to use\"\"\"", "\n", "return", "os", ".", "path", ".", "join", "(", "tempfile", ".", "gettempdir", "(", ")", ",", "'debug-%d'", "%", "pid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.remote_debug": [[64, 115], ["locs.update", "os.getpid", "interrupt.NamedPipe", "interrupt.NamedPipe.put", "interrupt.pipename", "interrupt.NamedPipe.close", "traceback.print_exc", "interrupt.NamedPipe.is_open", "interrupt.NamedPipe.get", "codeop.compile_command", "traceback.format_stack", "io.StringIO", "exec", "interrupt.NamedPipe.put", "interrupt.NamedPipe.put", "io.StringIO", "traceback.print_exc", "interrupt.NamedPipe.put", "sys.stdout.getvalue", "sys.stdout.getvalue"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.put", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.pipename", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.is_open", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.put", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.put", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.put"], ["", "", "def", "remote_debug", "(", "sig", ",", "frame", ")", ":", "\n", "    ", "\"\"\"Handler to allow process to be remotely debugged.\"\"\"", "\n", "def", "_raiseEx", "(", "ex", ")", ":", "\n", "        ", "\"\"\"Raise specified exception in the remote process\"\"\"", "\n", "_raiseEx", ".", "ex", "=", "ex", "\n", "", "_raiseEx", ".", "ex", "=", "None", "\n", "\n", "try", ":", "\n", "# Provide some useful functions.", "\n", "        ", "locs", "=", "{", "'_raiseEx'", ":", "_raiseEx", "}", "\n", "locs", ".", "update", "(", "frame", ".", "f_locals", ")", "# Unless shadowed.", "\n", "globs", "=", "frame", ".", "f_globals", "\n", "\n", "pid", "=", "os", ".", "getpid", "(", ")", "# Use pipe name based on pid", "\n", "pipe", "=", "NamedPipe", "(", "pipename", "(", "pid", ")", ")", "\n", "\n", "old_stdout", ",", "old_stderr", "=", "sys", ".", "stdout", ",", "sys", ".", "stderr", "\n", "txt", "=", "''", "\n", "pipe", ".", "put", "(", "\"Interrupting process at following point:\\n\"", "+", "\n", "''", ".", "join", "(", "traceback", ".", "format_stack", "(", "frame", ")", ")", "+", "\">>> \"", ")", "\n", "\n", "try", ":", "\n", "            ", "while", "pipe", ".", "is_open", "(", ")", "and", "_raiseEx", ".", "ex", "is", "None", ":", "\n", "                ", "line", "=", "pipe", ".", "get", "(", ")", "\n", "if", "line", "is", "None", ":", "continue", "# EOF", "\n", "txt", "+=", "line", "\n", "try", ":", "\n", "                    ", "code", "=", "codeop", ".", "compile_command", "(", "txt", ")", "\n", "if", "code", ":", "\n", "                        ", "sys", ".", "stdout", "=", "io", ".", "StringIO", "(", ")", "\n", "sys", ".", "stderr", "=", "sys", ".", "stdout", "\n", "exec", "(", "code", ",", "globs", ",", "locs", ")", "\n", "txt", "=", "''", "\n", "pipe", ".", "put", "(", "sys", ".", "stdout", ".", "getvalue", "(", ")", "+", "'>>> '", ")", "\n", "", "else", ":", "\n", "                        ", "pipe", ".", "put", "(", "'... '", ")", "\n", "", "", "except", ":", "\n", "                    ", "txt", "=", "''", "# May be syntax err.", "\n", "sys", ".", "stdout", "=", "io", ".", "StringIO", "(", ")", "\n", "sys", ".", "stderr", "=", "sys", ".", "stdout", "\n", "traceback", ".", "print_exc", "(", ")", "\n", "pipe", ".", "put", "(", "sys", ".", "stdout", ".", "getvalue", "(", ")", "+", "'>>> '", ")", "\n", "", "", "", "finally", ":", "\n", "            ", "sys", ".", "stdout", "=", "old_stdout", "# Restore redirected output.", "\n", "sys", ".", "stderr", "=", "old_stderr", "\n", "pipe", ".", "close", "(", ")", "\n", "\n", "", "", "except", "Exception", ":", "# Don't allow debug exceptions to propogate to real program.", "\n", "        ", "traceback", ".", "print_exc", "(", ")", "\n", "\n", "", "if", "_raiseEx", ".", "ex", "is", "not", "None", ":", "raise", "_raiseEx", ".", "ex", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.debug_process": [[116, 127], ["os.kill", "interrupt.NamedPipe", "interrupt.NamedPipe.close", "interrupt.pipename", "interrupt.NamedPipe.is_open", "interrupt.NamedPipe.put", "input", "interrupt.NamedPipe.get"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.pipename", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.is_open", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.put", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "def", "debug_process", "(", "pid", ")", ":", "\n", "    ", "\"\"\"Interrupt a running process and debug it.\"\"\"", "\n", "os", ".", "kill", "(", "pid", ",", "signal", ".", "SIGUSR1", ")", "# Signal process.", "\n", "pipe", "=", "NamedPipe", "(", "pipename", "(", "pid", ")", ",", "1", ")", "\n", "try", ":", "\n", "        ", "while", "pipe", ".", "is_open", "(", ")", ":", "\n", "            ", "txt", "=", "input", "(", "pipe", ".", "get", "(", ")", ")", "+", "'\\n'", "\n", "pipe", ".", "put", "(", "txt", ")", "\n", "", "", "except", "EOFError", ":", "\n", "        ", "pass", "# Exit.", "\n", "", "pipe", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.listen": [[128, 130], ["signal.signal"], "function", ["None"], ["", "def", "listen", "(", ")", ":", "\n", "    ", "signal", ".", "signal", "(", "signal", ".", "SIGUSR1", ",", "remote_debug", ")", "# Register for remote debugging.", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.split_sdf.split_sdf": [[8, 26], ["os.path.isfile", "print", "os.path.split", "collections.defaultdict", "liGAN.molecules.read_rd_mols_from_sdf_file", "in_base.split", "os.path.join", "liGAN.molecules.write_rd_mol_to_sdf_file", "print"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_rd_mols_from_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mol_to_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["def", "split_sdf", "(", "sdf_file", ")", ":", "\n", "    ", "'''\n    Split an sdf file into several files\n    that each contain one molecular pose.\n    '''", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "sdf_file", ")", ",", "sdf_file", "+", "' does not exist'", "\n", "print", "(", "'Splitting'", ",", "sdf_file", ")", "\n", "in_dir", ",", "in_base", "=", "os", ".", "path", ".", "split", "(", "sdf_file", ")", "\n", "mol_name", "=", "in_base", ".", "split", "(", "'.'", ",", "1", ")", "[", "0", "]", "\n", "pose_count", "=", "defaultdict", "(", "int", ")", "\n", "for", "mol", "in", "m", ".", "read_rd_mols_from_sdf_file", "(", "sdf_file", ",", "sanitize", "=", "False", ")", ":", "\n", "#mol_name = mol.GetProp('_Name')", "\n", "        ", "pose_index", "=", "pose_count", "[", "mol_name", "]", "\n", "out_base", "=", "'{}_{}.sdf.gz'", ".", "format", "(", "mol_name", ",", "pose_index", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "in_dir", ",", "out_base", ")", "\n", "m", ".", "write_rd_mol_to_sdf_file", "(", "out_file", ",", "mol", ",", "name", "=", "mol_name", ",", "kekulize", "=", "True", ")", "\n", "print", "(", "'\\tWriting'", ",", "out_file", ")", "\n", "pose_count", "[", "mol_name", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.split_sdf.find_and_split_sdf": [[28, 42], ["os.path.isfile", "split_sdf.split_sdf", "os.path.isfile", "print", "sdf_file.split", "in_prefix.rsplit"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.convert_types.split_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "find_and_split_sdf", "(", "sdf_file", ")", ":", "\n", "    ", "'''\n    Given the name of a single-pose sdf file,\n    find and split the multi-pose sdf file.\n    '''", "\n", "if", "os", ".", "path", ".", "isfile", "(", "sdf_file", ")", ":", "\n", "        ", "print", "(", "'Found'", ",", "sdf_file", ")", "\n", "return", "\n", "# need to find and split multi-pose file", "\n", "", "in_prefix", "=", "sdf_file", ".", "split", "(", "'.'", ",", "1", ")", "[", "0", "]", "# strip file extension", "\n", "in_prefix", "=", "in_prefix", ".", "rsplit", "(", "'_'", ",", "1", ")", "[", "0", "]", "# strip pose index", "\n", "multi_sdf_file", "=", "in_prefix", "+", "'.sdf.gz'", "\n", "split_sdf", "(", "multi_sdf_file", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "sdf_file", ")", ",", "sdf_file", "+", "' was not created'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.convert_types.split_sdf": [[5, 18], ["openbabel.pybel.readfile", "os.path.splitext", "os.path.isfile", "gzip.open", "f.write", "mol.write"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write"], ["def", "split_sdf", "(", "sdf_file", ")", ":", "\n", "\t", "'''\n\tSplit an sdf file into several with one\n\tpose per file, and write them gzipped.\n\tDon't overwrite existing file.\n\t'''", "\n", "out_name", "=", "os", ".", "path", ".", "splitext", "(", "sdf_file", ")", "[", "0", "]", "\n", "for", "i", ",", "mol", "in", "pybel", ".", "readfile", "(", "'sdf'", ",", "sdf_file", ")", ":", "\n", "\t\t", "out_file", "=", "f'{out_name}_{i}.sdf.gz'", "\n", "if", "os", ".", "path", ".", "isfile", "(", "out_file", ")", ":", "\n", "\t\t\t", "continue", "\n", "", "with", "gzip", ".", "open", "(", "out_file", ",", "'wt'", ")", "as", "f", ":", "\n", "\t\t\t", "f", ".", "write", "(", "mol", ".", "write", "(", "'sdf'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.memory.get_cuda_memory": [[8, 35], ["copy.deepcopy", "torch.cuda.reset_max_memory_allocated", "getattr", "getattr.", "solver_type.test", "torch.cuda.max_memory_allocated", "config[].pop", "config[].pop", "copy.deepcopy.get", "copy.deepcopy.get", "copy.deepcopy.get"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["def", "get_cuda_memory", "(", "config", ",", "batch_size", ")", ":", "\n", "    ", "config", "=", "copy", ".", "deepcopy", "(", "config", ")", "\n", "config", "[", "'data'", "]", "[", "'batch_size'", "]", "=", "batch_size", "\n", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "\n", "solver_type", "=", "getattr", "(", "\n", "liGAN", ".", "training", ",", "config", "[", "'model_type'", "]", "+", "'Solver'", "\n", ")", "\n", "solver", "=", "solver_type", "(", "\n", "train_file", "=", "config", "[", "'data'", "]", ".", "pop", "(", "'train_file'", ")", ",", "\n", "test_file", "=", "config", "[", "'data'", "]", ".", "pop", "(", "'test_file'", ")", ",", "\n", "data_kws", "=", "config", "[", "'data'", "]", ",", "\n", "gen_model_kws", "=", "config", "[", "'gen_model'", "]", ",", "\n", "disc_model_kws", "=", "config", ".", "get", "(", "'disc_model'", ",", "None", ")", ",", "\n", "loss_fn_kws", "=", "config", "[", "'loss_fn'", "]", ",", "\n", "gen_optim_kws", "=", "config", "[", "'gen_optim'", "]", ",", "\n", "disc_optim_kws", "=", "config", ".", "get", "(", "'disc_optim'", ",", "None", ")", ",", "\n", "atom_fitting_kws", "=", "config", "[", "'atom_fitting'", "]", ",", "\n", "bond_adding_kws", "=", "config", ".", "get", "(", "'bond_adding'", ",", "{", "}", ")", ",", "\n", "out_prefix", "=", "config", "[", "'out_prefix'", "]", ",", "\n", "caffe_init", "=", "config", "[", "'caffe_init'", "]", ",", "\n", "balance", "=", "config", "[", "'balance'", "]", ",", "\n", "device", "=", "'cuda'", ",", "\n", ")", "\n", "solver", ".", "test", "(", "n_batches", "=", "1", ")", "\n", "\n", "return", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.__init__": [[14, 39], ["atom_structs.AtomStruct.check_shapes", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.check_shapes"], ["def", "__init__", "(", "\n", "self", ",", "\n", "coords", ",", "\n", "types", ",", "\n", "typer", ",", "\n", "dtype", "=", "None", ",", "\n", "device", "=", "None", ",", "\n", "**", "info", "\n", ")", ":", "\n", "        ", "self", ".", "check_shapes", "(", "coords", ",", "types", ",", "typer", ")", "\n", "\n", "# omit atoms with zero type vectors", "\n", "nonzero", "=", "(", "types", ">", "0", ")", ".", "any", "(", "axis", "=", "1", ")", "\n", "coords", "=", "coords", "[", "nonzero", "]", "\n", "types", "=", "types", "[", "nonzero", "]", "\n", "\n", "self", ".", "coords", "=", "torch", ".", "as_tensor", "(", "coords", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "self", ".", "types", "=", "torch", ".", "as_tensor", "(", "types", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "self", ".", "typer", "=", "typer", "\n", "\n", "self", ".", "info", "=", "info", "\n", "\n", "# compute these lazily, since they're expensive and not always needed", "\n", "self", ".", "_atom_types", "=", "None", "\n", "self", ".", "_atomic_radii", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.check_shapes": [[40, 48], ["set", "len", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "check_shapes", "(", "coords", ",", "types", ",", "typer", ")", ":", "\n", "        ", "assert", "len", "(", "coords", ".", "shape", ")", "==", "2", ",", "coords", ".", "shape", "\n", "assert", "len", "(", "types", ".", "shape", ")", "==", "2", ",", "types", ".", "shape", "\n", "assert", "coords", ".", "shape", "[", "0", "]", "==", "types", ".", "shape", "[", "0", "]", ",", "(", "coords", ".", "shape", "[", "0", "]", ",", "types", ".", "shape", "[", "0", "]", ")", "\n", "assert", "coords", ".", "shape", "[", "1", "]", "==", "3", ",", "coords", ".", "shape", "[", "1", "]", "\n", "assert", "types", ".", "shape", "[", "1", "]", "==", "typer", ".", "n_types", ",", "(", "types", ".", "shape", "[", "1", "]", ",", "typer", ".", "n_types", ")", "\n", "assert", "(", "(", "0", "<=", "types", ")", "&", "(", "types", "<=", "1", ")", ")", ".", "all", "(", ")", ",", "set", "(", "types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_coord_set": [[49, 74], ["cls", "coord_set.has_vector_types", "coord_set.make_vector_types", "coord_set.coords.ongpu", "coord_set.type_vector.ongpu", "coord_set.coords.tonumpy", "coord_set.type_vector.tonumpy", "os.path.join"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_coord_set", "(", "\n", "cls", ",", "\n", "coord_set", ",", "\n", "typer", ",", "\n", "data_root", "=", "''", ",", "\n", "dtype", "=", "None", ",", "\n", "device", "=", "None", ",", "\n", "**", "info", "\n", ")", ":", "\n", "        ", "if", "not", "coord_set", ".", "has_vector_types", "(", ")", ":", "\n", "            ", "coord_set", ".", "make_vector_types", "(", ")", "\n", "\n", "# if already on gpu, we shouldn't copy back and forth", "\n", "", "assert", "not", "coord_set", ".", "coords", ".", "ongpu", "(", ")", ",", "'coords on gpu'", "\n", "assert", "not", "coord_set", ".", "type_vector", ".", "ongpu", "(", ")", ",", "'types on gpu'", "\n", "\n", "return", "cls", "(", "\n", "coords", "=", "coord_set", ".", "coords", ".", "tonumpy", "(", ")", ",", "\n", "types", "=", "coord_set", ".", "type_vector", ".", "tonumpy", "(", ")", ",", "# should be float", "\n", "typer", "=", "typer", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "typer", ".", "device", "if", "device", "is", "None", "else", "device", ",", "\n", "src_file", "=", "os", ".", "path", ".", "join", "(", "data_root", ",", "coord_set", ".", "src", ")", "if", "data_root", "else", "coord_set", ".", "src", ",", "\n", "**", "info", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_gninatypes": [[76, 80], ["atom_structs.read_gninatypes_file", "atom_structs.AtomStruct"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.read_gninatypes_file"], ["", "@", "classmethod", "\n", "def", "from_gninatypes", "(", "cls", ",", "gtypes_file", ",", "typer", ",", "**", "info", ")", ":", "\n", "        ", "coords", ",", "types", "=", "read_gninatypes_file", "(", "gtypes_file", ",", "typer", ")", "\n", "return", "AtomStruct", "(", "coords", ",", "types", ",", "typer", ",", "**", "info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_rd_mol": [[81, 85], ["rd_mol.GetConformer().GetPositions", "cls", "rd_mol.GetConformer"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_rd_mol", "(", "cls", ",", "rd_mol", ",", "types", ",", "typer", ",", "**", "info", ")", ":", "\n", "        ", "coords", "=", "rd_mol", ".", "GetConformer", "(", "0", ")", ".", "GetPositions", "(", ")", "\n", "return", "cls", "(", "coords", ",", "types", ",", "typer", ",", "**", "info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_sdf": [[86, 92], ["atom_structs.read_channels_from_file", "cls.from_rd_mol", "molecules.read_rd_mols_from_sdf_file", "os.path.splitext"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.read_channels_from_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_rd_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_rd_mols_from_sdf_file"], ["", "@", "classmethod", "\n", "def", "from_sdf", "(", "cls", ",", "sdf_file", ",", "typer", ",", "**", "info", ")", ":", "\n", "        ", "rd_mol", "=", "molecules", ".", "read_rd_mols_from_sdf_file", "(", "sdf_file", ")", "[", "0", "]", "\n", "channels_file", "=", "os", ".", "path", ".", "splitext", "(", "sdf_file", ")", "[", "0", "]", "+", "'.channels'", "\n", "types", "=", "read_channels_from_file", "(", "channels_file", ",", "channels", ")", "\n", "return", "cls", ".", "from_rd_mol", "(", "rd_mol", ",", "types", ",", "channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.atom_types": [[93, 100], ["atom_structs.AtomStruct.typer.get_atom_type"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_atom_type"], ["", "@", "property", "\n", "def", "atom_types", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_atom_types", "is", "None", ":", "\n", "            ", "self", ".", "_atom_types", "=", "[", "\n", "self", ".", "typer", ".", "get_atom_type", "(", "t", ")", "for", "t", "in", "self", ".", "types", "\n", "]", "\n", "", "return", "self", ".", "_atom_types", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.atomic_radii": [[101, 108], ["torch.as_tensor", "atom_structs.AtomStruct.typer.radius_func"], "methods", ["None"], ["", "@", "property", "\n", "def", "atomic_radii", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_atomic_radii", "is", "None", ":", "\n", "            ", "self", ".", "_atomic_radii", "=", "torch", ".", "as_tensor", "(", "[", "\n", "self", ".", "typer", ".", "radius_func", "(", "a", ".", "atomic_num", ")", "for", "a", "in", "self", ".", "atom_types", "\n", "]", ",", "dtype", "=", "self", ".", "dtype", ",", "device", "=", "self", ".", "device", ")", "\n", "", "return", "self", ".", "_atomic_radii", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.n_atoms": [[109, 112], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_atoms", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "coords", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.type_counts": [[113, 116], ["atom_structs.AtomStruct.types.sum"], "methods", ["None"], ["", "@", "property", "\n", "def", "type_counts", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "types", ".", "sum", "(", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.elem_counts": [[117, 120], ["atom_structs.AtomStruct.types[].sum"], "methods", ["None"], ["", "@", "property", "\n", "def", "elem_counts", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "types", "[", ":", ",", ":", "self", ".", "typer", ".", "n_elem_types", "]", ".", "sum", "(", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.prop_counts": [[121, 124], ["atom_structs.AtomStruct.types[].sum"], "methods", ["None"], ["", "@", "property", "\n", "def", "prop_counts", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "types", "[", ":", ",", "self", ".", "typer", ".", "n_elem_types", ":", "]", ".", "sum", "(", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.center": [[125, 131], ["atom_structs.AtomStruct.coords.mean"], "methods", ["None"], ["", "@", "property", "\n", "def", "center", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "n_atoms", ">", "0", ":", "\n", "            ", "return", "self", ".", "coords", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "nan", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.radius": [[132, 138], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "radius", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "n_atoms", ">", "0", ":", "\n", "            ", "return", "(", "self", ".", "coords", "-", "self", ".", "center", ")", ".", "norm", "(", "dim", "=", "1", ")", ".", "max", "(", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "nan", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.dtype": [[139, 142], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "coords", ".", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.device": [[143, 146], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "coords", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.to": [[147, 155], ["atom_structs.AtomStruct"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "dtype", ",", "device", ")", ":", "\n", "        ", "return", "AtomStruct", "(", "\n", "coords", "=", "self", ".", "coords", ",", "\n", "types", "=", "self", ".", "types", ",", "\n", "typer", "=", "self", ".", "typer", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "device", ",", "\n", "**", "self", ".", "info", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.to_ob_mol": [[157, 163], ["molecules.make_ob_mol", "atom_structs.AtomStruct.coords.cpu().numpy", "atom_structs.AtomStruct.types.cpu().numpy", "atom_structs.AtomStruct.coords.cpu", "atom_structs.AtomStruct.types.cpu"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.make_ob_mol"], ["", "def", "to_ob_mol", "(", "self", ")", ":", "\n", "        ", "return", "molecules", ".", "make_ob_mol", "(", "\n", "coords", "=", "self", ".", "coords", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "types", "=", "self", ".", "types", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "bonds", "=", "None", ",", "\n", "typer", "=", "self", ".", "typer", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.to_rd_mol": [[165, 171], ["molecules.make_rd_mol", "atom_structs.AtomStruct.coords.cpu().numpy().astype", "atom_structs.AtomStruct.types.cpu().numpy", "atom_structs.AtomStruct.coords.cpu().numpy", "atom_structs.AtomStruct.types.cpu", "atom_structs.AtomStruct.coords.cpu"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.make_rd_mol"], ["", "def", "to_rd_mol", "(", "self", ")", ":", "\n", "        ", "return", "molecules", ".", "make_rd_mol", "(", "\n", "coords", "=", "self", ".", "coords", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", ",", "\n", "types", "=", "self", ".", "types", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "bonds", "=", "None", ",", "\n", "typer", "=", "self", ".", "typer", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.to_sdf": [[173, 180], ["sdf_file.endswith", "molecules.write_rd_mol_to_sdf_file", "open.close", "gzip.open", "open", "atom_structs.AtomStruct.to_rd_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mol_to_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.to_rd_mol"], ["", "def", "to_sdf", "(", "self", ",", "sdf_file", ")", ":", "\n", "        ", "if", "sdf_file", ".", "endswith", "(", "'.gz'", ")", ":", "\n", "            ", "outfile", "=", "gzip", ".", "open", "(", "sdf_file", ",", "'wt'", ")", "\n", "", "else", ":", "\n", "            ", "outfile", "=", "open", "(", "sdf_file", ",", "'wt'", ")", "\n", "", "molecules", ".", "write_rd_mol_to_sdf_file", "(", "outfile", ",", "self", ".", "to_rd_mol", "(", ")", ")", "\n", "outfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.read_gninatypes_file": [[182, 200], ["typer.get_type_names", "open", "f.read", "numpy.array", "numpy.array", "enumerate", "struct.unpack", "f.read", "typer.get_type_names.index", "xyz.append", "c.append"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_names"], ["", "", "def", "read_gninatypes_file", "(", "gtypes_file", ",", "typer", ")", ":", "\n", "# TODO allow vector typed gninatypes files?", "\n", "    ", "channel_names", "=", "typer", ".", "get_type_names", "(", ")", "\n", "channel_name_idx", "=", "{", "n", ":", "i", "for", "i", ",", "n", "in", "enumerate", "(", "channel_names", ")", "}", "\n", "xyz", ",", "c", "=", "[", "]", ",", "[", "]", "\n", "with", "open", "(", "gtypes_file", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "atom_bytes", "=", "f", ".", "read", "(", "16", ")", "\n", "while", "atom_bytes", ":", "\n", "            ", "x", ",", "y", ",", "z", ",", "t", "=", "struct", ".", "unpack", "(", "'fffi'", ",", "atom_bytes", ")", "\n", "smina_type", "=", "atom_types", ".", "smina_types", "[", "t", "]", "\n", "channel_name", "=", "'Ligand'", "+", "smina_type", ".", "name", "\n", "if", "channel_name", "in", "channel_name_idx", ":", "\n", "                ", "c_", "=", "channel_names", ".", "index", "(", "channel_name", ")", "\n", "xyz", ".", "append", "(", "[", "x", ",", "y", ",", "z", "]", ")", "\n", "c", ".", "append", "(", "c_", ")", "\n", "", "atom_bytes", "=", "f", ".", "read", "(", "16", ")", "\n", "", "", "assert", "xyz", "and", "c", ",", "lig_file", "\n", "return", "np", ".", "array", "(", "xyz", ")", ",", "np", ".", "array", "(", "c", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.read_channels_from_file": [[202, 207], ["open", "numpy.array", "int", "f.read().rstrip().split", "f.read().rstrip", "f.read"], "function", ["None"], ["", "def", "read_channels_from_file", "(", "channels_file", ")", ":", "\n", "# TODO allow vector typed channels files", "\n", "    ", "with", "open", "(", "channels_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "\n", "int", "(", "c", ")", "for", "c", "in", "f", ".", "read", "(", ")", ".", "rstrip", "(", ")", ".", "split", "(", "' '", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.count_index_types": [[210, 220], ["torch.zeros"], "function", ["None"], ["", "", "def", "count_index_types", "(", "types", ",", "n_types", ",", "dtype", "=", "None", ")", ":", "\n", "    ", "'''\n    Provided a vector of index types, return a\n    vector of type counts where type_counts[i] is\n    the number of occurences of type index i in c.\n    '''", "\n", "type_counts", "=", "torch", ".", "zeros", "(", "n_types", ",", "dtype", "=", "dtype", ",", "device", "=", "c", ".", "device", ")", "\n", "for", "i", "in", "types", ":", "\n", "        ", "type_counts", "[", "i", "]", "+=", "1", "\n", "", "return", "type_counts", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DReLU.__init__": [[156, 187], ["torch.nn.Sequential.__init__", "models.Conv3DReLU.conv_type", "torch.nn.LeakyReLU", "modules.insert", "torch.nn.utils.spectral_norm", "torch.nn.BatchNorm3d"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_channels_in", ",", "\n", "n_channels_out", ",", "\n", "kernel_size", "=", "3", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "batch_norm", "=", "False", ",", "\n", "spectral_norm", "=", "False", ",", "\n", ")", ":", "\n", "        ", "modules", "=", "[", "\n", "self", ".", "conv_type", "(", "\n", "in_channels", "=", "n_channels_in", ",", "\n", "out_channels", "=", "n_channels_out", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "kernel_size", "//", "2", ",", "\n", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "\n", "negative_slope", "=", "relu_leak", ",", "\n", "inplace", "=", "True", ",", "\n", ")", "\n", "]", "\n", "\n", "if", "batch_norm", ">", "0", ":", "# value indicates order wrt conv and relu", "\n", "            ", "modules", ".", "insert", "(", "batch_norm", ",", "nn", ".", "BatchNorm3d", "(", "n_channels_out", ")", ")", "\n", "\n", "", "if", "spectral_norm", ">", "0", ":", "# value indicates num power iterations", "\n", "            ", "modules", "[", "0", "]", "=", "nn", ".", "utils", ".", "spectral_norm", "(", "\n", "modules", "[", "0", "]", ",", "n_power_iterations", "=", "spectral_norm", "\n", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "*", "modules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.__init__": [[208, 248], ["torch.nn.Module.__init__", "models.Conv3DBlock.init_conv_sequence", "models.Conv3DBlock.init_skip_conv", "models.Conv3DBlock.init_final_conv"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.init_conv_sequence", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.init_skip_conv", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.init_final_conv"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_convs", ",", "\n", "n_channels_in", ",", "\n", "n_channels_out", ",", "\n", "block_type", "=", "'c'", ",", "\n", "growth_rate", "=", "8", ",", "\n", "bottleneck_factor", "=", "0", ",", "\n", "debug", "=", "False", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "block_type", "in", "{", "'c'", ",", "'r'", ",", "'d'", "}", ",", "block_type", "\n", "self", ".", "residual", "=", "(", "block_type", "==", "'r'", ")", "\n", "self", ".", "dense", "=", "(", "block_type", "==", "'d'", ")", "\n", "\n", "if", "self", ".", "residual", ":", "\n", "            ", "self", ".", "init_skip_conv", "(", "\n", "n_channels_in", "=", "n_channels_in", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "**", "kwargs", "\n", ")", "\n", "\n", "", "if", "self", ".", "dense", ":", "\n", "            ", "self", ".", "init_final_conv", "(", "\n", "n_channels_in", "=", "n_channels_in", ",", "\n", "n_convs", "=", "n_convs", ",", "\n", "growth_rate", "=", "growth_rate", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "**", "kwargs", "\n", ")", "\n", "n_channels_out", "=", "growth_rate", "\n", "\n", "", "self", ".", "init_conv_sequence", "(", "\n", "n_convs", "=", "n_convs", ",", "\n", "n_channels_in", "=", "n_channels_in", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "bottleneck_factor", "=", "bottleneck_factor", ",", "\n", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.init_skip_conv": [[250, 264], ["models.Conv3DBlock.conv_type", "torch.nn.Identity"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type"], ["", "def", "init_skip_conv", "(", "\n", "self", ",", "n_channels_in", ",", "n_channels_out", ",", "kernel_size", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "if", "n_channels_out", "!=", "n_channels_in", ":", "\n", "\n", "# 1x1x1 conv to map input to output channels", "\n", "            ", "self", ".", "skip_conv", "=", "self", ".", "conv_type", "(", "\n", "n_channels_in", "=", "n_channels_in", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "kernel_size", "=", "1", ",", "\n", "**", "kwargs", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "skip_conv", "=", "nn", ".", "Identity", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.init_final_conv": [[265, 280], ["models.Conv3DBlock.conv_type"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type"], ["", "", "def", "init_final_conv", "(", "\n", "self", ",", "\n", "n_channels_in", ",", "\n", "n_convs", ",", "\n", "growth_rate", ",", "\n", "n_channels_out", ",", "\n", "kernel_size", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "# 1x1x1 final \"compression\" convolution", "\n", "        ", "self", ".", "final_conv", "=", "self", ".", "conv_type", "(", "\n", "n_channels_in", "=", "n_channels_in", "+", "n_convs", "*", "growth_rate", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "kernel_size", "=", "1", ",", "\n", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.bottleneck_conv": [[282, 311], ["torch.nn.Sequential", "models.Conv3DBlock.conv_type", "models.Conv3DBlock.conv_type", "models.Conv3DBlock.conv_type"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type"], ["", "def", "bottleneck_conv", "(", "\n", "self", ",", "\n", "n_channels_in", ",", "\n", "n_channels_bn", ",", "\n", "n_channels_out", ",", "\n", "kernel_size", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "assert", "n_channels_bn", ">", "0", ",", "(", "n_channels_in", ",", "n_channels_bn", ",", "n_channels_out", ")", "\n", "\n", "return", "nn", ".", "Sequential", "(", "\n", "self", ".", "conv_type", "(", "\n", "n_channels_in", "=", "n_channels_in", ",", "\n", "n_channels_out", "=", "n_channels_bn", ",", "\n", "kernel_size", "=", "1", ",", "\n", "**", "kwargs", ",", "\n", ")", ",", "\n", "self", ".", "conv_type", "(", "\n", "n_channels_in", "=", "n_channels_bn", ",", "\n", "n_channels_out", "=", "n_channels_bn", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "**", "kwargs", "\n", ")", ",", "\n", "self", ".", "conv_type", "(", "\n", "n_channels_in", "=", "n_channels_bn", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "kernel_size", "=", "1", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.init_conv_sequence": [[314, 345], ["range", "models.Conv3DBlock.conv_modules.append", "models.Conv3DBlock.add_module", "models.Conv3DBlock.bottleneck_conv", "models.Conv3DBlock.conv_type", "str"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.bottleneck_conv", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type"], ["", "def", "init_conv_sequence", "(", "\n", "self", ",", "\n", "n_convs", ",", "\n", "n_channels_in", ",", "\n", "n_channels_out", ",", "\n", "bottleneck_factor", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "self", ".", "conv_modules", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_convs", ")", ":", "\n", "\n", "            ", "if", "bottleneck_factor", ":", "# bottleneck convolution", "\n", "                ", "conv", "=", "self", ".", "bottleneck_conv", "(", "\n", "n_channels_in", "=", "n_channels_in", ",", "\n", "n_channels_bn", "=", "n_channels_in", "//", "bottleneck_factor", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "**", "kwargs", "\n", ")", "\n", "", "else", ":", "# single convolution", "\n", "                ", "conv", "=", "self", ".", "conv_type", "(", "\n", "n_channels_in", "=", "n_channels_in", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "**", "kwargs", "\n", ")", "\n", "", "self", ".", "conv_modules", ".", "append", "(", "conv", ")", "\n", "self", ".", "add_module", "(", "str", "(", "i", ")", ",", "conv", ")", "\n", "\n", "if", "self", ".", "dense", ":", "\n", "                ", "n_channels_in", "+=", "n_channels_out", "\n", "", "else", ":", "\n", "                ", "n_channels_in", "=", "n_channels_out", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.__len__": [[346, 348], ["len"], "methods", ["None"], ["", "", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "conv_modules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Conv3DBlock.forward": [[349, 376], ["enumerate", "models.Conv3DBlock.final_conv", "f", "all_inputs.append", "torch.cat", "models.Conv3DBlock.skip_conv", "f"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "\n", "        ", "if", "not", "self", ".", "conv_modules", ":", "\n", "            ", "return", "inputs", "\n", "\n", "", "if", "self", ".", "dense", ":", "\n", "            ", "all_inputs", "=", "[", "inputs", "]", "\n", "\n", "# convolution sequence", "\n", "", "for", "i", ",", "f", "in", "enumerate", "(", "self", ".", "conv_modules", ")", ":", "\n", "\n", "            ", "if", "self", ".", "residual", ":", "\n", "                ", "identity", "=", "self", ".", "skip_conv", "(", "inputs", ")", "if", "i", "==", "0", "else", "inputs", "\n", "outputs", "=", "f", "(", "inputs", ")", "+", "identity", "\n", "", "else", ":", "\n", "                ", "outputs", "=", "f", "(", "inputs", ")", "\n", "\n", "", "if", "self", ".", "dense", ":", "\n", "                ", "all_inputs", ".", "append", "(", "outputs", ")", "\n", "inputs", "=", "torch", ".", "cat", "(", "all_inputs", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "inputs", "=", "outputs", "\n", "\n", "", "", "if", "self", ".", "dense", ":", "\n", "            ", "outputs", "=", "self", ".", "final_conv", "(", "inputs", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Pool3D.__init__": [[392, 419], ["torch.nn.Sequential.__init__", "torch.nn.MaxPool3d", "torch.nn.AvgPool3d", "torch.nn.Conv3d", "ValueError", "repr"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "self", ",", "n_channels", ",", "pool_type", ",", "pool_factor", ")", ":", "\n", "\n", "        ", "if", "pool_type", "==", "'m'", ":", "\n", "            ", "pool", "=", "nn", ".", "MaxPool3d", "(", "\n", "kernel_size", "=", "pool_factor", ",", "\n", "stride", "=", "pool_factor", ",", "\n", ")", "\n", "\n", "", "elif", "pool_type", "==", "'a'", ":", "\n", "            ", "pool", "=", "nn", ".", "AvgPool3d", "(", "\n", "kernel_size", "=", "pool_factor", ",", "\n", "stride", "=", "pool_factor", ",", "\n", ")", "\n", "\n", "", "elif", "pool_type", "==", "'c'", ":", "\n", "            ", "pool", "=", "nn", ".", "Conv3d", "(", "\n", "in_channels", "=", "n_channels", ",", "\n", "out_channels", "=", "n_channels", ",", "\n", "groups", "=", "n_channels", ",", "\n", "kernel_size", "=", "pool_factor", ",", "\n", "stride", "=", "pool_factor", ",", "\n", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'unknown pool_type '", "+", "repr", "(", "pool_type", ")", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "pool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Unpool3D.__init__": [[428, 451], ["torch.nn.Sequential.__init__", "torch.nn.Upsample", "torch.nn.ConvTranspose3d", "ValueError", "repr"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "self", ",", "n_channels", ",", "unpool_type", ",", "unpool_factor", ")", ":", "\n", "\n", "        ", "if", "unpool_type", "in", "unpool_type_map", ":", "\n", "\n", "            ", "unpool", "=", "nn", ".", "Upsample", "(", "\n", "scale_factor", "=", "unpool_factor", ",", "\n", "mode", "=", "unpool_type_map", "[", "unpool_type", "]", ",", "\n", ")", "\n", "\n", "", "elif", "unpool_type", "==", "'c'", ":", "\n", "\n", "            ", "unpool", "=", "nn", ".", "ConvTranspose3d", "(", "\n", "in_channels", "=", "n_channels", ",", "\n", "out_channels", "=", "n_channels", ",", "\n", "groups", "=", "n_channels", ",", "\n", "kernel_size", "=", "unpool_factor", ",", "\n", "stride", "=", "unpool_factor", ",", "\n", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'unknown unpool_type '", "+", "repr", "(", "unpool_type", ")", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "unpool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Reshape.__init__": [[457, 460], ["torch.nn.Module.__init__", "tuple"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "self", ",", "shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "shape", "=", "tuple", "(", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Reshape.__repr__": [[461, 463], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'Reshape(shape={})'", ".", "format", "(", "self", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Reshape.forward": [[464, 466], ["x.reshape"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", ".", "reshape", "(", "self", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Grid2Vec.__init__": [[474, 492], ["numpy.prod", "torch.nn.Sequential.__init__", "models.Reshape", "torch.nn.Linear", "modules.append", "torch.nn.utils.spectral_norm"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "\n", "self", ",", "in_shape", ",", "n_output", ",", "activ_fn", "=", "None", ",", "spectral_norm", "=", "0", "\n", ")", ":", "\n", "        ", "n_input", "=", "np", ".", "prod", "(", "in_shape", ")", "\n", "modules", "=", "[", "\n", "Reshape", "(", "shape", "=", "(", "-", "1", ",", "n_input", ")", ")", ",", "\n", "nn", ".", "Linear", "(", "n_input", ",", "n_output", ")", "\n", "]", "\n", "\n", "if", "activ_fn", ":", "\n", "            ", "modules", ".", "append", "(", "activ_fn", ")", "\n", "\n", "", "if", "spectral_norm", ">", "0", ":", "\n", "            ", "modules", "[", "1", "]", "=", "nn", ".", "utils", ".", "spectral_norm", "(", "\n", "modules", "[", "1", "]", ",", "n_power_iterations", "=", "spectral_norm", "\n", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "*", "modules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Vec2Grid.__init__": [[500, 519], ["numpy.prod", "torch.nn.Sequential.__init__", "torch.nn.Linear", "models.Reshape", "torch.nn.LeakyReLU", "modules.insert", "torch.nn.utils.spectral_norm", "torch.nn.BatchNorm3d"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "\n", "self", ",", "n_input", ",", "out_shape", ",", "relu_leak", ",", "batch_norm", ",", "spectral_norm", "\n", ")", ":", "\n", "        ", "n_output", "=", "np", ".", "prod", "(", "out_shape", ")", "\n", "modules", "=", "[", "\n", "nn", ".", "Linear", "(", "n_input", ",", "n_output", ")", ",", "\n", "Reshape", "(", "shape", "=", "(", "-", "1", ",", "*", "out_shape", ")", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "relu_leak", ",", "inplace", "=", "True", ")", ",", "\n", "]", "\n", "\n", "if", "batch_norm", ">", "0", ":", "\n", "            ", "modules", ".", "insert", "(", "batch_norm", "+", "1", ",", "nn", ".", "BatchNorm3d", "(", "out_shape", "[", "0", "]", ")", ")", "\n", "\n", "", "if", "spectral_norm", ">", "0", ":", "\n", "            ", "modules", "[", "0", "]", "=", "nn", ".", "utils", ".", "spectral_norm", "(", "\n", "modules", "[", "0", "]", ",", "n_power_iterations", "=", "spectral_norm", "\n", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "*", "modules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.__init__": [[531, 624], ["torch.nn.Module.__init__", "range", "models.as_list", "models.as_list", "len", "enumerate", "models.GridEncoder.add_conv3d", "models.GridEncoder.add_pool3d", "models.GridEncoder.add_conv3d_block", "all", "len", "len", "len", "len", "zip", "models.GridEncoder.add_grid2vec", "models.GridEncoder.add_pool3d", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.as_list", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.as_list", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_conv3d", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_pool3d", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_conv3d_block", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_grid2vec", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_pool3d"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_channels", ",", "\n", "grid_size", "=", "48", ",", "\n", "n_filters", "=", "32", ",", "\n", "width_factor", "=", "2", ",", "\n", "n_levels", "=", "4", ",", "\n", "conv_per_level", "=", "3", ",", "\n", "kernel_size", "=", "3", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "batch_norm", "=", "0", ",", "\n", "spectral_norm", "=", "0", ",", "\n", "pool_type", "=", "'a'", ",", "\n", "pool_factor", "=", "2", ",", "\n", "n_output", "=", "1", ",", "\n", "output_activ_fn", "=", "None", ",", "\n", "init_conv_pool", "=", "False", ",", "\n", "block_type", "=", "'c'", ",", "\n", "growth_rate", "=", "8", ",", "\n", "bottleneck_factor", "=", "0", ",", "\n", "debug", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "debug", "=", "debug", "\n", "\n", "# sequence of convs and/or pools", "\n", "self", ".", "grid_modules", "=", "[", "]", "\n", "\n", "# track changing grid dimensions", "\n", "self", ".", "n_channels", "=", "n_channels", "\n", "self", ".", "grid_size", "=", "grid_size", "\n", "\n", "if", "init_conv_pool", ":", "\n", "\n", "            ", "self", ".", "add_conv3d", "(", "\n", "name", "=", "'init_conv'", ",", "\n", "n_filters", "=", "n_filters", ",", "\n", "kernel_size", "=", "kernel_size", "+", "2", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", ")", "\n", "self", ".", "add_pool3d", "(", "\n", "name", "=", "'init_pool'", ",", "\n", "pool_type", "=", "pool_type", ",", "\n", "pool_factor", "=", "pool_factor", "\n", ")", "\n", "n_filters", "*=", "width_factor", "\n", "\n", "", "for", "i", "in", "range", "(", "n_levels", ")", ":", "\n", "\n", "            ", "if", "i", ">", "0", ":", "# downsample between conv blocks", "\n", "                ", "self", ".", "add_pool3d", "(", "\n", "name", "=", "'level'", "+", "str", "(", "i", ")", "+", "'_pool'", ",", "\n", "pool_type", "=", "pool_type", ",", "\n", "pool_factor", "=", "pool_factor", "\n", ")", "\n", "n_filters", "*=", "width_factor", "\n", "\n", "", "self", ".", "add_conv3d_block", "(", "\n", "name", "=", "'level'", "+", "str", "(", "i", ")", ",", "\n", "n_convs", "=", "conv_per_level", ",", "\n", "n_filters", "=", "n_filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", "block_type", "=", "block_type", ",", "\n", "growth_rate", "=", "growth_rate", ",", "\n", "bottleneck_factor", "=", "bottleneck_factor", ",", "\n", "debug", "=", "debug", ",", "\n", ")", "\n", "\n", "# fully-connected outputs", "\n", "", "n_output", "=", "as_list", "(", "n_output", ")", "\n", "assert", "n_output", "and", "all", "(", "n_o", ">", "0", "for", "n_o", "in", "n_output", ")", "\n", "\n", "output_activ_fn", "=", "as_list", "(", "output_activ_fn", ")", "\n", "if", "len", "(", "output_activ_fn", ")", "==", "1", ":", "\n", "            ", "output_activ_fn", "*=", "len", "(", "n_output", ")", "\n", "", "assert", "len", "(", "output_activ_fn", ")", "==", "len", "(", "n_output", ")", "\n", "\n", "self", ".", "n_tasks", "=", "len", "(", "n_output", ")", "\n", "self", ".", "task_modules", "=", "[", "]", "\n", "\n", "for", "i", ",", "(", "n_output_i", ",", "activ_fn_i", ")", "in", "enumerate", "(", "\n", "zip", "(", "n_output", ",", "output_activ_fn", ")", "\n", ")", ":", "\n", "            ", "self", ".", "add_grid2vec", "(", "\n", "name", "=", "'fc'", "+", "str", "(", "i", ")", ",", "\n", "n_output", "=", "n_output_i", ",", "\n", "activ_fn", "=", "activ_fn_i", ",", "\n", "spectral_norm", "=", "spectral_norm", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.print": [[626, 629], ["models.GridEncoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "print", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "self", ".", "debug", ":", "\n", "            ", "print", "(", "'DEBUG'", ",", "*", "args", ",", "**", "kwargs", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_conv3d": [[630, 640], ["models.Conv3DReLU", "models.GridEncoder.add_module", "models.GridEncoder.grid_modules.append", "models.GridEncoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "add_conv3d", "(", "self", ",", "name", ",", "n_filters", ",", "**", "kwargs", ")", ":", "\n", "        ", "conv", "=", "Conv3DReLU", "(", "\n", "n_channels_in", "=", "self", ".", "n_channels", ",", "\n", "n_channels_out", "=", "n_filters", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "add_module", "(", "name", ",", "conv", ")", "\n", "self", ".", "grid_modules", ".", "append", "(", "conv", ")", "\n", "self", ".", "n_channels", "=", "n_filters", "\n", "self", ".", "print", "(", "name", ",", "self", ".", "n_channels", ",", "self", ".", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_pool3d": [[641, 655], ["models.Pool3D", "models.GridEncoder.add_module", "models.GridEncoder.grid_modules.append", "models.GridEncoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "add_pool3d", "(", "self", ",", "name", ",", "pool_factor", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "self", ".", "grid_size", "%", "pool_factor", "==", "0", ",", "'cannot pool remaining spatial dims ({} % {})'", ".", "format", "(", "\n", "self", ".", "grid_size", ",", "pool_factor", "\n", ")", "\n", "pool", "=", "Pool3D", "(", "\n", "n_channels", "=", "self", ".", "n_channels", ",", "\n", "pool_factor", "=", "pool_factor", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "add_module", "(", "name", ",", "pool", ")", "\n", "self", ".", "grid_modules", ".", "append", "(", "pool", ")", "\n", "self", ".", "grid_size", "//=", "pool_factor", "\n", "self", ".", "print", "(", "name", ",", "self", ".", "n_channels", ",", "self", ".", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_conv3d_block": [[656, 666], ["models.Conv3DBlock", "models.GridEncoder.add_module", "models.GridEncoder.grid_modules.append", "models.GridEncoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "add_conv3d_block", "(", "self", ",", "name", ",", "n_filters", ",", "**", "kwargs", ")", ":", "\n", "        ", "conv_block", "=", "Conv3DBlock", "(", "\n", "n_channels_in", "=", "self", ".", "n_channels", ",", "\n", "n_channels_out", "=", "n_filters", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "add_module", "(", "name", ",", "conv_block", ")", "\n", "self", ".", "grid_modules", ".", "append", "(", "conv_block", ")", "\n", "self", ".", "n_channels", "=", "n_filters", "\n", "self", ".", "print", "(", "name", ",", "self", ".", "n_channels", ",", "self", ".", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.add_grid2vec": [[667, 675], ["models.Grid2Vec", "models.GridEncoder.add_module", "models.GridEncoder.task_modules.append", "models.GridEncoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "add_grid2vec", "(", "self", ",", "name", ",", "**", "kwargs", ")", ":", "\n", "        ", "fc", "=", "Grid2Vec", "(", "\n", "in_shape", "=", "(", "self", ".", "n_channels", ",", ")", "+", "(", "self", ".", "grid_size", ",", ")", "*", "3", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "add_module", "(", "name", ",", "fc", ")", "\n", "self", ".", "task_modules", ".", "append", "(", "fc", ")", "\n", "self", ".", "print", "(", "name", ",", "self", ".", "n_channels", ",", "self", ".", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridEncoder.forward": [[676, 695], ["models.GridEncoder.print", "f", "models.GridEncoder.print", "f", "models.reduce_list", "isinstance", "conv_features.append"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.reduce_list"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "\n", "# conv-pool sequence", "\n", "        ", "conv_features", "=", "[", "]", "\n", "for", "f", "in", "self", ".", "grid_modules", ":", "\n", "\n", "            ", "outputs", "=", "f", "(", "inputs", ")", "\n", "self", ".", "print", "(", "inputs", ".", "shape", ",", "'->'", ",", "f", ",", "'->'", ",", "outputs", ".", "shape", ")", "\n", "\n", "if", "not", "isinstance", "(", "f", ",", "Pool3D", ")", ":", "\n", "                ", "conv_features", ".", "append", "(", "outputs", ")", "\n", "", "inputs", "=", "outputs", "\n", "\n", "# fully-connected outputs", "\n", "", "outputs", "=", "[", "f", "(", "inputs", ")", "for", "f", "in", "self", ".", "task_modules", "]", "\n", "outputs_shape", "=", "[", "o", ".", "shape", "for", "o", "in", "outputs", "]", "\n", "self", ".", "print", "(", "inputs", ".", "shape", ",", "'->'", ",", "self", ".", "task_modules", ",", "'->'", ",", "outputs_shape", ")", "\n", "\n", "return", "reduce_list", "(", "outputs", ")", ",", "conv_features", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.__init__": [[712, 820], ["torch.nn.Module.__init__", "bool", "models.GridDecoder.add_vec2grid", "reversed", "range", "models.GridDecoder.add_tconv3d_block", "models.GridDecoder.add_unpool3d", "models.GridDecoder.add_tconv3d_block", "models.GridDecoder.add_tconv3d", "models.GridDecoder.add_unpool3d", "str", "str"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_vec2grid", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_tconv3d_block", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_unpool3d", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_tconv3d_block", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_tconv3d", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_unpool3d"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ",", "\n", "grid_size", ",", "\n", "n_channels", ",", "\n", "width_factor", ",", "\n", "n_levels", ",", "\n", "tconv_per_level", ",", "\n", "kernel_size", ",", "\n", "relu_leak", ",", "\n", "batch_norm", ",", "\n", "spectral_norm", ",", "\n", "unpool_type", ",", "\n", "unpool_factor", ",", "\n", "n_channels_out", ",", "\n", "final_unpool", "=", "False", ",", "\n", "skip_connect", "=", "False", ",", "\n", "block_type", "=", "'c'", ",", "\n", "growth_rate", "=", "8", ",", "\n", "bottleneck_factor", "=", "0", ",", "\n", "debug", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "skip_connect", "=", "bool", "(", "skip_connect", ")", "\n", "self", ".", "debug", "=", "debug", "\n", "\n", "# first fc layer maps to initial grid shape", "\n", "self", ".", "fc_modules", "=", "[", "]", "\n", "self", ".", "n_input", "=", "n_input", "\n", "self", ".", "add_vec2grid", "(", "\n", "name", "=", "'fc'", ",", "\n", "n_input", "=", "n_input", ",", "\n", "n_channels", "=", "n_channels", ",", "\n", "grid_size", "=", "grid_size", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", ")", "\n", "n_filters", "=", "n_channels", "\n", "\n", "self", ".", "grid_modules", "=", "[", "]", "\n", "for", "i", "in", "reversed", "(", "range", "(", "n_levels", ")", ")", ":", "\n", "\n", "            ", "if", "i", "+", "1", "<", "n_levels", ":", "# unpool between deconv blocks", "\n", "                ", "unpool_name", "=", "'level'", "+", "str", "(", "i", ")", "+", "'_unpool'", "\n", "self", ".", "add_unpool3d", "(", "\n", "name", "=", "unpool_name", ",", "\n", "unpool_type", "=", "unpool_type", ",", "\n", "unpool_factor", "=", "unpool_factor", "\n", ")", "\n", "n_filters", "//=", "width_factor", "\n", "\n", "", "if", "skip_connect", ":", "\n", "                ", "n_skip_channels", "=", "self", ".", "n_channels", "\n", "if", "i", "<", "n_levels", "-", "1", ":", "\n", "                    ", "n_skip_channels", "//=", "width_factor", "\n", "", "", "else", ":", "\n", "                ", "n_skip_channels", "=", "0", "\n", "\n", "", "tconv_block_name", "=", "'level'", "+", "str", "(", "i", ")", "\n", "self", ".", "add_tconv3d_block", "(", "\n", "name", "=", "tconv_block_name", ",", "\n", "n_convs", "=", "tconv_per_level", ",", "\n", "n_filters", "=", "n_filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", "block_type", "=", "block_type", ",", "\n", "growth_rate", "=", "growth_rate", ",", "\n", "bottleneck_factor", "=", "bottleneck_factor", ",", "\n", "n_skip_channels", "=", "n_skip_channels", ",", "\n", "debug", "=", "debug", ",", "\n", ")", "\n", "\n", "", "if", "final_unpool", ":", "\n", "\n", "            ", "self", ".", "add_unpool3d", "(", "\n", "name", "=", "'final_unpool'", ",", "\n", "unpool_type", "=", "unpool_type", ",", "\n", "unpool_factor", "=", "unpool_factor", ",", "\n", ")", "\n", "n_skip_channels", "//=", "width_factor", "\n", "\n", "self", ".", "add_tconv3d_block", "(", "\n", "name", "=", "'final_conv'", ",", "\n", "n_convs", "=", "tconv_per_level", ",", "\n", "n_filters", "=", "n_channels_out", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", "block_type", "=", "block_type", ",", "\n", "growth_rate", "=", "growth_rate", ",", "\n", "bottleneck_factor", "=", "bottleneck_factor", ",", "\n", "n_skip_channels", "=", "n_skip_channels", ",", "\n", "debug", "=", "debug", ",", "\n", ")", "\n", "\n", "", "else", ":", "# final tconv maps to correct n_output channels", "\n", "\n", "            ", "self", ".", "add_tconv3d", "(", "\n", "name", "=", "'final_conv'", ",", "\n", "n_filters", "=", "n_channels_out", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.print": [[822, 825], ["models.GridDecoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "print", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "self", ".", "debug", ":", "\n", "            ", "print", "(", "'DEBUG'", ",", "*", "args", ",", "**", "kwargs", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_vec2grid": [[826, 836], ["models.Vec2Grid", "models.GridDecoder.add_module", "models.GridDecoder.fc_modules.append", "models.GridDecoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "add_vec2grid", "(", "self", ",", "name", ",", "n_channels", ",", "grid_size", ",", "**", "kwargs", ")", ":", "\n", "        ", "vec2grid", "=", "Vec2Grid", "(", "\n", "out_shape", "=", "(", "n_channels", ",", ")", "+", "(", "grid_size", ",", ")", "*", "3", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "add_module", "(", "name", ",", "vec2grid", ")", "\n", "self", ".", "fc_modules", ".", "append", "(", "vec2grid", ")", "\n", "self", ".", "n_channels", "=", "n_channels", "\n", "self", ".", "grid_size", "=", "grid_size", "\n", "self", ".", "print", "(", "name", ",", "self", ".", "n_channels", ",", "self", ".", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_unpool3d": [[837, 847], ["models.Unpool3D", "models.GridDecoder.add_module", "models.GridDecoder.grid_modules.append", "models.GridDecoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "add_unpool3d", "(", "self", ",", "name", ",", "unpool_factor", ",", "**", "kwargs", ")", ":", "\n", "        ", "unpool", "=", "Unpool3D", "(", "\n", "n_channels", "=", "self", ".", "n_channels", ",", "\n", "unpool_factor", "=", "unpool_factor", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "add_module", "(", "name", ",", "unpool", ")", "\n", "self", ".", "grid_modules", ".", "append", "(", "unpool", ")", "\n", "self", ".", "grid_size", "*=", "unpool_factor", "\n", "self", ".", "print", "(", "name", ",", "self", ".", "n_channels", ",", "self", ".", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_tconv3d": [[848, 858], ["models.TConv3DReLU", "models.GridDecoder.add_module", "models.GridDecoder.grid_modules.append", "models.GridDecoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "add_tconv3d", "(", "self", ",", "name", ",", "n_filters", ",", "**", "kwargs", ")", ":", "\n", "        ", "tconv", "=", "TConv3DReLU", "(", "\n", "n_channels_in", "=", "self", ".", "n_channels", ",", "\n", "n_channels_out", "=", "n_filters", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "add_module", "(", "name", ",", "tconv", ")", "\n", "self", ".", "grid_modules", ".", "append", "(", "tconv", ")", "\n", "self", ".", "n_channels", "=", "n_filters", "\n", "self", ".", "print", "(", "name", ",", "self", ".", "n_channels", ",", "self", ".", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.add_tconv3d_block": [[859, 871], ["models.TConv3DBlock", "models.GridDecoder.add_module", "models.GridDecoder.grid_modules.append", "models.GridDecoder.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "add_tconv3d_block", "(", "\n", "self", ",", "name", ",", "n_filters", ",", "n_skip_channels", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "tconv_block", "=", "TConv3DBlock", "(", "\n", "n_channels_in", "=", "self", ".", "n_channels", "+", "n_skip_channels", ",", "\n", "n_channels_out", "=", "n_filters", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "add_module", "(", "name", ",", "tconv_block", ")", "\n", "self", ".", "grid_modules", ".", "append", "(", "tconv_block", ")", "\n", "self", ".", "n_channels", "=", "n_filters", "\n", "self", ".", "print", "(", "name", ",", "self", ".", "n_channels", ",", "self", ".", "grid_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridDecoder.forward": [[872, 893], ["f", "models.GridDecoder.print", "f", "models.GridDecoder.print", "isinstance", "skip_features.pop", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "skip_features", "=", "None", ")", ":", "\n", "\n", "        ", "for", "f", "in", "self", ".", "fc_modules", ":", "\n", "            ", "outputs", "=", "f", "(", "inputs", ")", "\n", "self", ".", "print", "(", "inputs", ".", "shape", ",", "'->'", ",", "f", ",", "'->'", ",", "outputs", ".", "shape", ")", "\n", "inputs", "=", "outputs", "\n", "\n", "", "for", "f", "in", "self", ".", "grid_modules", ":", "\n", "\n", "            ", "if", "self", ".", "skip_connect", "and", "isinstance", "(", "f", ",", "TConv3DBlock", ")", ":", "\n", "                ", "skip_inputs", "=", "skip_features", ".", "pop", "(", ")", "\n", "inputs", "=", "torch", ".", "cat", "(", "[", "inputs", ",", "skip_inputs", "]", ",", "dim", "=", "1", ")", "\n", "inputs_shape", "=", "[", "inputs", ".", "shape", ",", "skip_inputs", ".", "shape", "]", "\n", "", "else", ":", "\n", "                ", "inputs_shape", "=", "inputs", ".", "shape", "\n", "\n", "", "outputs", "=", "f", "(", "inputs", ")", "\n", "self", ".", "print", "(", "inputs_shape", ",", "'->'", ",", "f", ",", "'->'", ",", "outputs", ".", "shape", ")", "\n", "inputs", "=", "outputs", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridGenerator.__init__": [[907, 1027], ["torch.nn.Sequential.__init__", "models.GridGenerator.check_encoder_channels", "models.is_positive_int", "models.is_positive_int", "models.GridDecoder", "interpolation.Interpolation", "super().to", "type", "models.GridEncoder", "models.GridEncoder"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridGenerator.check_encoder_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.is_positive_int", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.is_positive_int", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_channels_in", "=", "None", ",", "\n", "n_channels_cond", "=", "None", ",", "\n", "n_channels_out", "=", "19", ",", "\n", "grid_size", "=", "48", ",", "\n", "n_filters", "=", "32", ",", "\n", "width_factor", "=", "2", ",", "\n", "n_levels", "=", "4", ",", "\n", "conv_per_level", "=", "3", ",", "\n", "kernel_size", "=", "3", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "batch_norm", "=", "0", ",", "\n", "spectral_norm", "=", "0", ",", "\n", "pool_type", "=", "'a'", ",", "\n", "unpool_type", "=", "'n'", ",", "\n", "pool_factor", "=", "2", ",", "\n", "n_latent", "=", "1024", ",", "\n", "init_conv_pool", "=", "False", ",", "\n", "skip_connect", "=", "False", ",", "\n", "block_type", "=", "'c'", ",", "\n", "growth_rate", "=", "8", ",", "\n", "bottleneck_factor", "=", "0", ",", "\n", "n_samples", "=", "0", ",", "\n", "device", "=", "'cuda'", ",", "\n", "debug", "=", "False", ",", "\n", ")", ":", "\n", "        ", "assert", "type", "(", "self", ")", "!=", "GridGenerator", ",", "'GridGenerator is abstract'", "\n", "self", ".", "debug", "=", "debug", "\n", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "check_encoder_channels", "(", "n_channels_in", ",", "n_channels_cond", ")", "\n", "assert", "is_positive_int", "(", "n_channels_out", ")", "\n", "assert", "is_positive_int", "(", "n_latent", ")", "\n", "\n", "self", ".", "n_channels_in", "=", "n_channels_in", "\n", "self", ".", "n_channels_cond", "=", "n_channels_cond", "\n", "self", ".", "n_channels_out", "=", "n_channels_out", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "\n", "if", "self", ".", "has_input_encoder", ":", "\n", "\n", "            ", "if", "self", ".", "is_variational", ":", "# means and log_stds", "\n", "                ", "encoder_output", "=", "[", "n_latent", ",", "n_latent", "]", "\n", "", "else", ":", "\n", "                ", "encoder_output", "=", "n_latent", "\n", "\n", "", "self", ".", "input_encoder", "=", "GridEncoder", "(", "\n", "n_channels", "=", "n_channels_in", ",", "\n", "grid_size", "=", "grid_size", ",", "\n", "n_filters", "=", "n_filters", ",", "\n", "width_factor", "=", "width_factor", ",", "\n", "n_levels", "=", "n_levels", ",", "\n", "conv_per_level", "=", "conv_per_level", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", "pool_type", "=", "pool_type", ",", "\n", "pool_factor", "=", "pool_factor", ",", "\n", "n_output", "=", "encoder_output", ",", "\n", "init_conv_pool", "=", "init_conv_pool", ",", "\n", "block_type", "=", "block_type", ",", "\n", "growth_rate", "=", "growth_rate", ",", "\n", "bottleneck_factor", "=", "bottleneck_factor", ",", "\n", "debug", "=", "debug", ",", "\n", ")", "\n", "\n", "", "if", "self", ".", "has_conditional_encoder", ":", "\n", "\n", "            ", "self", ".", "conditional_encoder", "=", "GridEncoder", "(", "\n", "n_channels", "=", "n_channels_cond", ",", "\n", "grid_size", "=", "grid_size", ",", "\n", "n_filters", "=", "n_filters", ",", "\n", "width_factor", "=", "width_factor", ",", "\n", "n_levels", "=", "n_levels", ",", "\n", "conv_per_level", "=", "conv_per_level", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", "pool_type", "=", "pool_type", ",", "\n", "pool_factor", "=", "pool_factor", ",", "\n", "n_output", "=", "n_latent", ",", "\n", "init_conv_pool", "=", "init_conv_pool", ",", "\n", "block_type", "=", "block_type", ",", "\n", "growth_rate", "=", "growth_rate", ",", "\n", "bottleneck_factor", "=", "bottleneck_factor", ",", "\n", "debug", "=", "debug", ",", "\n", ")", "\n", "\n", "", "n_pools", "=", "n_levels", "-", "1", "+", "init_conv_pool", "\n", "\n", "self", ".", "decoder", "=", "GridDecoder", "(", "\n", "n_input", "=", "self", ".", "n_decoder_input", ",", "\n", "grid_size", "=", "grid_size", "//", "pool_factor", "**", "n_pools", ",", "\n", "n_channels", "=", "n_filters", "*", "width_factor", "**", "n_pools", ",", "\n", "width_factor", "=", "width_factor", ",", "\n", "n_levels", "=", "n_levels", ",", "\n", "tconv_per_level", "=", "conv_per_level", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "relu_leak", "=", "relu_leak", ",", "\n", "batch_norm", "=", "batch_norm", ",", "\n", "spectral_norm", "=", "spectral_norm", ",", "\n", "unpool_type", "=", "unpool_type", ",", "\n", "unpool_factor", "=", "pool_factor", ",", "\n", "n_channels_out", "=", "n_channels_out", ",", "\n", "final_unpool", "=", "init_conv_pool", ",", "\n", "skip_connect", "=", "skip_connect", ",", "\n", "block_type", "=", "block_type", ",", "\n", "growth_rate", "=", "growth_rate", ",", "\n", "bottleneck_factor", "=", "bottleneck_factor", ",", "\n", "debug", "=", "debug", ",", "\n", ")", "\n", "\n", "# latent interpolation state", "\n", "self", ".", "latent_interp", "=", "Interpolation", "(", "n_samples", "=", "n_samples", ")", "\n", "\n", "super", "(", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridGenerator.check_encoder_channels": [[1028, 1038], ["models.is_positive_int", "models.is_positive_int"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.is_positive_int", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.is_positive_int"], ["", "def", "check_encoder_channels", "(", "self", ",", "n_channels_in", ",", "n_channels_cond", ")", ":", "\n", "        ", "if", "self", ".", "has_input_encoder", ":", "\n", "            ", "assert", "is_positive_int", "(", "n_channels_in", ")", ",", "n_channels_in", "\n", "", "else", ":", "\n", "            ", "assert", "n_channels_in", "is", "None", ",", "n_channels_in", "\n", "\n", "", "if", "self", ".", "has_conditional_encoder", ":", "\n", "            ", "assert", "is_positive_int", "(", "n_channels_cond", ")", ",", "n_channels_cond", "\n", "", "else", ":", "\n", "            ", "assert", "n_channels_cond", "is", "None", ",", "n_channels_cond", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridGenerator.n_decoder_input": [[1039, 1047], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "n_decoder_input", "(", "self", ")", ":", "\n", "        ", "n", "=", "0", "\n", "if", "self", ".", "has_input_encoder", "or", "self", ".", "is_variational", ":", "\n", "            ", "n", "+=", "self", ".", "n_latent", "\n", "", "if", "self", ".", "has_conditional_encoder", ":", "\n", "            ", "n", "+=", "self", ".", "n_latent", "\n", "", "return", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GridGenerator.sample_latent": [[1048, 1071], ["models.GridGenerator.sample_latent"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["", "def", "sample_latent", "(", "\n", "self", ",", "batch_size", ",", "means", "=", "None", ",", "log_stds", "=", "None", ",", "interpolate", "=", "False", ",", "spherical", "=", "False", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "latent_vecs", "=", "sample_latent", "(", "\n", "batch_size", "=", "batch_size", ",", "\n", "n_latent", "=", "self", ".", "n_latent", ",", "\n", "means", "=", "means", ",", "\n", "log_stds", "=", "log_stds", ",", "\n", "device", "=", "self", ".", "device", ",", "\n", "**", "kwargs", "\n", ")", "\n", "\n", "if", "interpolate", ":", "\n", "            ", "if", "not", "self", ".", "latent_interp", ".", "is_initialized", ":", "\n", "                ", "self", ".", "latent_interp", ".", "initialize", "(", "sample_latent", "(", "\n", "batch_size", "=", "1", ",", "\n", "n_latent", "=", "self", ".", "n_latent", ",", "\n", "device", "=", "self", ".", "device", ",", "\n", "**", "kwargs", "\n", ")", "[", "0", "]", ")", "\n", "", "latent_vecs", "=", "self", ".", "latent_interp", "(", "latent_vecs", ",", "spherical", "=", "spherical", ")", "\n", "\n", "", "return", "latent_vecs", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.AE.forward": [[1078, 1087], ["models.AE.decoder", "models.AE.sample_latent", "models.AE.input_encoder"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["def", "forward", "(", "self", ",", "inputs", "=", "None", ",", "conditions", "=", "None", ",", "batch_size", "=", "None", ")", ":", "\n", "\n", "        ", "if", "inputs", "is", "None", ":", "# \"prior\", not expected to work", "\n", "            ", "in_latents", "=", "self", ".", "sample_latent", "(", "batch_size", ")", "\n", "", "else", ":", "# posterior", "\n", "            ", "in_latents", ",", "_", "=", "self", ".", "input_encoder", "(", "inputs", ")", "\n", "\n", "", "outputs", "=", "self", ".", "decoder", "(", "inputs", "=", "in_latents", ")", "\n", "return", "outputs", ",", "in_latents", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.VAE.forward": [[1094, 1104], ["models.VAE.sample_latent", "models.VAE.decoder", "models.VAE.input_encoder"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["def", "forward", "(", "self", ",", "inputs", "=", "None", ",", "conditions", "=", "None", ",", "batch_size", "=", "None", ")", ":", "\n", "\n", "        ", "if", "inputs", "is", "None", ":", "# prior", "\n", "            ", "means", ",", "log_stds", "=", "None", ",", "None", "\n", "", "else", ":", "# posterior", "\n", "            ", "(", "means", ",", "log_stds", ")", ",", "_", "=", "self", ".", "input_encoder", "(", "inputs", ")", "\n", "\n", "", "var_latents", "=", "self", ".", "sample_latent", "(", "batch_size", ",", "means", ",", "log_stds", ")", "\n", "outputs", "=", "self", ".", "decoder", "(", "inputs", "=", "var_latents", ")", "\n", "return", "outputs", ",", "var_latents", ",", "means", ",", "log_stds", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.CE.forward": [[1111, 1117], ["models.CE.conditional_encoder", "models.CE.decoder"], "methods", ["None"], ["def", "forward", "(", "self", ",", "inputs", "=", "None", ",", "conditions", "=", "None", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "cond_latents", ",", "cond_features", "=", "self", ".", "conditional_encoder", "(", "conditions", ")", "\n", "outputs", "=", "self", ".", "decoder", "(", "\n", "inputs", "=", "cond_latents", ",", "skip_features", "=", "cond_features", "\n", ")", "\n", "return", "outputs", ",", "cond_latents", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.CVAE.forward": [[1124, 1140], ["models.CVAE.sample_latent", "models.CVAE.conditional_encoder", "torch.cat", "models.CVAE.decoder", "models.CVAE.input_encoder"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["def", "forward", "(", "\n", "self", ",", "inputs", "=", "None", ",", "conditions", "=", "None", ",", "batch_size", "=", "None", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "if", "inputs", "is", "None", ":", "# prior", "\n", "            ", "means", ",", "log_stds", "=", "None", ",", "None", "\n", "", "else", ":", "# posterior", "\n", "            ", "(", "means", ",", "log_stds", ")", ",", "_", "=", "self", ".", "input_encoder", "(", "inputs", ")", "\n", "\n", "", "in_latents", "=", "self", ".", "sample_latent", "(", "batch_size", ",", "means", ",", "log_stds", ",", "**", "kwargs", ")", "\n", "cond_latents", ",", "cond_features", "=", "self", ".", "conditional_encoder", "(", "conditions", ")", "\n", "cat_latents", "=", "torch", ".", "cat", "(", "[", "in_latents", ",", "cond_latents", "]", ",", "dim", "=", "1", ")", "\n", "\n", "outputs", "=", "self", ".", "decoder", "(", "\n", "inputs", "=", "cat_latents", ",", "skip_features", "=", "cond_features", "\n", ")", "\n", "return", "outputs", ",", "in_latents", ",", "means", ",", "log_stds", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.GAN.forward": [[1147, 1151], ["models.GAN.sample_latent", "models.GAN.decoder"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["def", "forward", "(", "self", ",", "inputs", "=", "None", ",", "conditions", "=", "None", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "var_latents", "=", "self", ".", "sample_latent", "(", "batch_size", ")", "\n", "outputs", "=", "self", ".", "decoder", "(", "inputs", "=", "var_latents", ")", "\n", "return", "outputs", ",", "var_latents", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.CGAN.forward": [[1158, 1166], ["models.CGAN.sample_latent", "models.CGAN.conditional_encoder", "torch.cat", "models.CGAN.decoder"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["def", "forward", "(", "self", ",", "inputs", "=", "None", ",", "conditions", "=", "None", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "var_latents", "=", "self", ".", "sample_latent", "(", "batch_size", ")", "\n", "cond_latents", ",", "cond_features", "=", "self", ".", "conditional_encoder", "(", "conditions", ")", "\n", "cat_latents", "=", "torch", ".", "cat", "(", "[", "var_latents", ",", "cond_latents", "]", ",", "dim", "=", "1", ")", "\n", "outputs", "=", "self", ".", "decoder", "(", "\n", "inputs", "=", "cat_latents", ",", "skip_features", "=", "cond_features", "\n", ")", "\n", "return", "outputs", ",", "var_latents", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.VAE2.forward2": [[1180, 1206], ["prior_model", "models.VAE2.decoder", "models.VAE2.input_encoder", "models.VAE2.sample_latent"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["def", "forward2", "(", "\n", "self", ",", "\n", "prior_model", ",", "\n", "inputs", "=", "None", ",", "\n", "conditions", "=", "None", ",", "\n", "batch_size", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "if", "inputs", "is", "None", ":", "# prior", "\n", "            ", "var_latents", "=", "means", "=", "log_stds", "=", "None", "\n", "\n", "", "else", ":", "# stage-1 posterior", "\n", "            ", "(", "means", ",", "log_stds", ")", ",", "_", "=", "self", ".", "input_encoder", "(", "inputs", ")", "\n", "var_latents", "=", "self", ".", "sample_latent", "(", "\n", "batch_size", ",", "means", ",", "log_stds", ",", "**", "kwargs", "\n", ")", "\n", "\n", "# insert prior model (output is stage-2 posterior or prior)", "\n", "", "gen_latents", ",", "_", ",", "means2", ",", "log_stds2", "=", "prior_model", "(", "\n", "inputs", "=", "var_latents", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "outputs", "=", "self", ".", "decoder", "(", "inputs", "=", "gen_latents", ")", "\n", "return", "(", "\n", "outputs", ",", "var_latents", ",", "means", ",", "log_stds", ",", "\n", "gen_latents", ",", "means2", ",", "log_stds2", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.CVAE2.forward2": [[1214, 1245], ["prior_model", "models.CVAE2.conditional_encoder", "torch.cat", "models.CVAE2.decoder", "models.CVAE2.input_encoder", "models.CVAE2.sample_latent"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["def", "forward2", "(", "\n", "self", ",", "\n", "prior_model", ",", "\n", "inputs", "=", "None", ",", "\n", "conditions", "=", "None", ",", "\n", "batch_size", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "if", "inputs", "is", "None", ":", "# prior", "\n", "            ", "in_latents", "=", "means", "=", "log_stds", "=", "None", "\n", "\n", "", "else", ":", "# stage-1 posterior", "\n", "            ", "(", "means", ",", "log_stds", ")", ",", "_", "=", "self", ".", "input_encoder", "(", "inputs", ")", "\n", "in_latents", "=", "self", ".", "sample_latent", "(", "\n", "batch_size", ",", "means", ",", "log_stds", ",", "**", "kwargs", "\n", ")", "\n", "\n", "# insert prior model (output is stage-2 posterior or prior)", "\n", "", "gen_latents", ",", "_", ",", "means2", ",", "log_stds2", "=", "prior_model", "(", "\n", "inputs", "=", "in_latents", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "cond_latents", ",", "cond_features", "=", "self", ".", "conditional_encoder", "(", "conditions", ")", "\n", "cat_latents", "=", "torch", ".", "cat", "(", "[", "gen_latents", ",", "cond_latents", "]", ",", "dim", "=", "1", ")", "\n", "\n", "outputs", "=", "self", ".", "decoder", "(", "\n", "inputs", "=", "cat_latents", ",", "skip_features", "=", "cond_features", "\n", ")", "\n", "return", "(", "\n", "outputs", ",", "in_latents", ",", "means", ",", "log_stds", ",", "\n", "gen_latents", ",", "means2", ",", "log_stds2", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Stage2VAE.__init__": [[1250, 1291], ["torch.nn.Module.__init__", "range", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "reversed", "torch.nn.Sequential", "modules.append", "modules.append", "n_inputs.append", "torch.nn.Linear", "torch.nn.LeakyReLU", "modules.append", "modules.append", "torch.nn.Linear", "torch.nn.LeakyReLU", "torch.nn.Linear", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ",", "\n", "n_h_layers", ",", "\n", "n_h_units", ",", "\n", "n_latent", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "device", "=", "'cuda'", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# track dimensions for decoder", "\n", "n_inputs", "=", "[", "]", "\n", "\n", "modules", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_h_layers", ")", ":", "# build encoder", "\n", "            ", "modules", ".", "append", "(", "nn", ".", "Linear", "(", "n_input", ",", "n_h_units", ")", ")", "\n", "modules", ".", "append", "(", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "relu_leak", ")", ")", "\n", "n_inputs", ".", "append", "(", "n_input", ")", "\n", "n_input", "=", "n_h_units", "\n", "\n", "", "self", ".", "encoder", "=", "nn", ".", "Sequential", "(", "*", "modules", ")", "\n", "\n", "# variational latent space", "\n", "self", ".", "fc_mean", "=", "nn", ".", "Linear", "(", "n_input", ",", "n_latent", ")", "\n", "self", ".", "fc_log_std", "=", "nn", ".", "Linear", "(", "n_input", ",", "n_latent", ")", "\n", "\n", "modules", "=", "[", "# decoder input fc", "\n", "nn", ".", "Linear", "(", "n_latent", ",", "n_input", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "relu_leak", ")", "\n", "]", "\n", "\n", "for", "n_output", "in", "reversed", "(", "n_inputs", ")", ":", "# build decoder", "\n", "            ", "modules", ".", "append", "(", "nn", ".", "Linear", "(", "n_input", ",", "n_output", ")", ")", "\n", "modules", ".", "append", "(", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "relu_leak", ")", ")", "\n", "n_input", "=", "n_output", "\n", "\n", "", "self", ".", "decoder", "=", "nn", ".", "Sequential", "(", "*", "modules", ")", "\n", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Stage2VAE.forward": [[1292, 1305], ["models.Stage2VAE.sample_latent", "models.Stage2VAE.decoder", "models.Stage2VAE.encoder", "models.Stage2VAE.fc_mean", "models.Stage2VAE.fc_log_std"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["", "def", "forward", "(", "self", ",", "inputs", "=", "None", ",", "batch_size", "=", "None", ")", ":", "\n", "\n", "        ", "if", "inputs", "is", "None", ":", "# prior", "\n", "            ", "means", ",", "log_stds", "=", "None", ",", "None", "\n", "\n", "", "else", ":", "# posterior", "\n", "            ", "enc_outputs", "=", "self", ".", "encoder", "(", "inputs", ")", "\n", "means", "=", "self", ".", "fc_mean", "(", "enc_outputs", ")", "\n", "log_stds", "=", "self", ".", "fc_log_std", "(", "enc_outputs", ")", "\n", "\n", "", "var_latents", "=", "self", ".", "sample_latent", "(", "batch_size", ",", "means", ",", "log_stds", ")", "\n", "outputs", "=", "self", ".", "decoder", "(", "var_latents", ")", "\n", "return", "outputs", ",", "var_latents", ",", "means", ",", "log_stds", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.Stage2VAE.sample_latent": [[1306, 1316], ["models.Stage2VAE.sample_latent"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent"], ["", "def", "sample_latent", "(", "\n", "self", ",", "batch_size", ",", "means", "=", "None", ",", "log_stds", "=", "None", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "return", "sample_latent", "(", "\n", "batch_size", "=", "batch_size", ",", "\n", "n_latent", "=", "self", ".", "n_latent", ",", "\n", "means", "=", "means", ",", "\n", "log_stds", "=", "log_stds", ",", "\n", "device", "=", "self", ".", "device", ",", "\n", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.as_list": [[16, 18], ["isinstance"], "function", ["None"], ["def", "as_list", "(", "obj", ")", ":", "\n", "    ", "return", "obj", "if", "isinstance", "(", "obj", ",", "list", ")", "else", "[", "obj", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.reduce_list": [[20, 22], ["isinstance", "len"], "function", ["None"], ["", "def", "reduce_list", "(", "obj", ")", ":", "\n", "    ", "return", "obj", "[", "0", "]", "if", "isinstance", "(", "obj", ",", "list", ")", "and", "len", "(", "obj", ")", "==", "1", "else", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.is_positive_int": [[24, 26], ["isinstance"], "function", ["None"], ["", "def", "is_positive_int", "(", "x", ")", ":", "\n", "    ", "return", "isinstance", "(", "x", ",", "int", ")", "and", "x", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.get_n_params": [[28, 36], ["list", "model.parameters"], "function", ["None"], ["", "def", "get_n_params", "(", "model", ")", ":", "\n", "    ", "total", "=", "0", "\n", "for", "p", "in", "list", "(", "model", ".", "parameters", "(", ")", ")", ":", "\n", "        ", "n", "=", "1", "\n", "for", "dim", "in", "p", ".", "shape", ":", "\n", "            ", "n", "*=", "dim", "\n", "", "total", "+=", "n", "\n", "", "return", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.caffe_init_weights": [[38, 48], ["isinstance", "torch.nn.init._calculate_correct_fan", "numpy.sqrt", "torch.nn.init.uniform_", "torch.nn.init.constant_"], "function", ["None"], ["", "def", "caffe_init_weights", "(", "module", ")", ":", "\n", "    ", "'''\n    Xavier initialization with fan-in variance\n    norm mode, as implemented in caffe.\n    '''", "\n", "if", "isinstance", "(", "module", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Conv3d", ",", "nn", ".", "ConvTranspose3d", ")", ")", ":", "\n", "        ", "fan_in", "=", "nn", ".", "init", ".", "_calculate_correct_fan", "(", "module", ".", "weight", ",", "'fan_in'", ")", "\n", "scale", "=", "np", ".", "sqrt", "(", "3", "/", "fan_in", ")", "\n", "nn", ".", "init", ".", "uniform_", "(", "module", ".", "weight", ",", "-", "scale", ",", "scale", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.compute_grad_norm": [[50, 61], ["model.parameters"], "function", ["None"], ["", "", "def", "compute_grad_norm", "(", "model", ")", ":", "\n", "    ", "'''\n    Compute the L2 norm of the gradient\n    on model parameters.\n    '''", "\n", "grad_norm2", "=", "0", "\n", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "if", "p", ".", "grad", "is", "None", ":", "\n", "            ", "continue", "\n", "", "grad_norm2", "+=", "(", "p", ".", "grad", ".", "data", "**", "2", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "return", "grad_norm2", "**", "(", "1", "/", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.clip_grad_norm": [[63, 65], ["torch.nn.utils.clip_grad_norm_", "model.parameters"], "function", ["None"], ["", "def", "clip_grad_norm", "(", "model", ",", "max_norm", ")", ":", "\n", "    ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "model", ".", "parameters", "(", ")", ",", "max_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.sample_latent": [[67, 142], ["torch.randn", "torch.as_tensor", "torch.exp", "scipy.stats.truncnorm.rvs", "torch.as_tensor.norm"], "function", ["None"], ["", "def", "sample_latent", "(", "\n", "batch_size", ",", "\n", "n_latent", ",", "\n", "means", "=", "None", ",", "\n", "log_stds", "=", "None", ",", "\n", "var_factor", "=", "1.0", ",", "\n", "post_factor", "=", "1.0", ",", "\n", "truncate", "=", "None", ",", "\n", "z_score", "=", "None", ",", "\n", "device", "=", "'cuda'", ",", "\n", ")", ":", "\n", "    ", "'''\n    Draw batch_size latent vectors of size n_latent\n    from a standard normal distribution (the prior)\n    and reparameterize them using the posterior pa-\n    rameters (means and log_stds), if provided.\n\n    The standard deviation of the latent distribution\n    is scaled by var_factor.\n\n    If posterior parameters are provided, they are\n    linearly interpolated with the prior parameters\n    according to post_factor, where post_factor=1.0\n    is purely posterior and 0.0 is purely prior.\n\n    If truncate is provided, samples are instead drawn\n    from a normal distribution truncated at that value.\n\n    If z_score is provided, the magnitude of each\n    vector is normalized and then scaled by z_score.\n    '''", "\n", "assert", "batch_size", "is", "not", "None", ",", "batch_size", "\n", "\n", "# draw samples from standard normal distribution", "\n", "if", "not", "truncate", ":", "\n", "#print('Drawing latent samples from normal distribution')", "\n", "        ", "latents", "=", "torch", ".", "randn", "(", "(", "batch_size", ",", "n_latent", ")", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "#print('Drawing latent samples from truncated normal distribution')", "\n", "        ", "latents", "=", "torch", ".", "as_tensor", "(", "stats", ".", "truncnorm", ".", "rvs", "(", "\n", "a", "=", "-", "truncate", ",", "\n", "b", "=", "truncate", ",", "\n", "size", "=", "(", "batch_size", ",", "n_latent", ")", "\n", ")", ")", "\n", "\n", "", "if", "z_score", "not", "in", "{", "None", ",", "False", "}", ":", "\n", "# normalize and scale by z_score", "\n", "#  CAUTION: don't know how applicable this is in high-dims", "\n", "#print('Normalizing and scaling latent samples')", "\n", "        ", "latents", "=", "latents", "/", "latents", ".", "norm", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "*", "z_score", "\n", "\n", "#print(f'var_factor = {var_factor}, post_factor = {post_factor}')", "\n", "\n", "", "if", "log_stds", "is", "not", "None", ":", "# posterior stds", "\n", "        ", "stds", "=", "torch", ".", "exp", "(", "log_stds", ")", "\n", "\n", "# interpolate b/tw posterior and prior", "\n", "#   post_factor*stds + (1-post_factor)*1", "\n", "stds", "=", "post_factor", "*", "stds", "+", "(", "1", "-", "post_factor", ")", "\n", "\n", "# scale by standard deviation", "\n", "latents", "*=", "stds", "\n", "\n", "", "latents", "*=", "var_factor", "\n", "\n", "if", "means", "is", "not", "None", ":", "\n", "\n", "# interpolate b/tw posterior and prior", "\n", "#   post_factor*means + (1-post_factor)*0", "\n", "        ", "means", "=", "post_factor", "*", "means", "\n", "\n", "# shift by mean", "\n", "latents", "+=", "means", "\n", "\n", "", "return", "latents", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.Interpolation.__init__": [[7, 13], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_samples", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "endpoints", "=", "None", "\n", "self", ".", "center", "=", "None", "# sphere center", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "self", ".", "curr_step", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.Interpolation.is_initialized": [[14, 17], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_initialized", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "endpoints", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.Interpolation.initialize": [[18, 23], ["init_point.unsqueeze", "center.unsqueeze"], "methods", ["None"], ["", "def", "initialize", "(", "self", ",", "init_point", ",", "center", "=", "None", ")", ":", "\n", "        ", "assert", "not", "self", ".", "is_initialized", "\n", "self", ".", "endpoints", "=", "init_point", ".", "unsqueeze", "(", "0", ")", "\n", "if", "center", "is", "not", "None", ":", "\n", "            ", "self", ".", "center", "=", "center", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.Interpolation.forward": [[24, 57], ["torch.arange", "torch.cat", "len", "interpolation.slerp", "interpolation.lerp", "lerp.isnan().any", "lerp.isnan"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.slerp", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.lerp"], ["", "", "def", "forward", "(", "self", ",", "inputs", ",", "spherical", "=", "False", ")", ":", "\n", "\n", "        ", "assert", "len", "(", "inputs", ".", "shape", ")", "==", "2", ",", "'inputs must be vectors'", "\n", "batch_size", "=", "inputs", ".", "shape", "[", "0", "]", "\n", "\n", "# whether each input is an interpolation endpoint", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "batch_size", ",", "device", "=", "inputs", ".", "device", ")", "\n", "is_endpoint", "=", "(", "self", ".", "curr_step", "+", "batch_idx", ")", "%", "self", ".", "n_samples", "==", "0", "\n", "\n", "# concat the new endpoints to the list of all endpoints", "\n", "self", ".", "endpoints", "=", "torch", ".", "cat", "(", "[", "self", ".", "endpoints", ",", "inputs", "[", "is_endpoint", "]", "]", ")", "\n", "\n", "# get start and stop points for each batch idx", "\n", "start_idx", "=", "(", "self", ".", "curr_step", "+", "batch_idx", ")", "//", "self", ".", "n_samples", "\n", "start_points", "=", "self", ".", "endpoints", "[", "start_idx", "]", "\n", "stop_points", "=", "self", ".", "endpoints", "[", "start_idx", "+", "1", "]", "\n", "\n", "# get amount to interpolate vectors at each batch_idx", "\n", "k_interp", "=", "(", "\n", "(", "self", ".", "curr_step", "+", "batch_idx", ")", "%", "self", ".", "n_samples", "+", "1", "\n", ")", ".", "unsqueeze", "(", "1", ")", "/", "self", ".", "n_samples", "\n", "\n", "# do interpolation", "\n", "if", "spherical", ":", "\n", "            ", "outputs", "=", "slerp", "(", "start_points", ",", "stop_points", ",", "k_interp", ",", "self", ".", "center", ")", "\n", "", "else", ":", "\n", "            ", "outputs", "=", "lerp", "(", "start_points", ",", "stop_points", ",", "k_interp", ")", "\n", "", "assert", "not", "outputs", ".", "isnan", "(", ")", ".", "any", "(", ")", "\n", "\n", "self", ".", "curr_step", "+=", "batch_size", "\n", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.TransformInterpolation.initialize": [[61, 68], ["tuple", "tuple", "interpolation.Interpolation.initialize", "rec_coord_set.center", "lig_coord_set.center", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.TransformInterpolation.initialize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.center", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.center"], ["    ", "def", "initialize", "(", "self", ",", "example", ")", ":", "\n", "        ", "rec_coord_set", ",", "lig_coord_set", "=", "example", ".", "coord_sets", "\n", "rec_center", "=", "tuple", "(", "rec_coord_set", ".", "center", "(", ")", ")", "\n", "lig_center", "=", "tuple", "(", "lig_coord_set", ".", "center", "(", ")", ")", "\n", "super", "(", ")", ".", "initialize", "(", "\n", "init_point", "=", "torch", ".", "as_tensor", "(", "lig_center", ")", ",", "\n", "center", "=", "torch", ".", "as_tensor", "(", "rec_center", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.TransformInterpolation.forward": [[70, 84], ["torch.tensor", "interpolation.Interpolation.forward", "molgrid.Transform", "tuple", "t.get_quaternion", "tuple", "t.get_translation", "zip", "t.get_rotation_center", "center.numpy"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "forward", "(", "self", ",", "transforms", ",", "**", "kwargs", ")", ":", "\n", "\n", "# just interpolate the centers for now", "\n", "        ", "centers", "=", "torch", ".", "tensor", "(", "\n", "[", "tuple", "(", "t", ".", "get_rotation_center", "(", ")", ")", "for", "t", "in", "transforms", "]", ",", "\n", "dtype", "=", "float", "\n", ")", "\n", "centers", "=", "super", "(", ")", ".", "forward", "(", "centers", ",", "**", "kwargs", ")", "\n", "return", "[", "\n", "molgrid", ".", "Transform", "(", "\n", "t", ".", "get_quaternion", "(", ")", ",", "\n", "tuple", "(", "center", ".", "numpy", "(", ")", ")", ",", "\n", "t", ".", "get_translation", "(", ")", ",", "\n", ")", "for", "t", ",", "center", "in", "zip", "(", "transforms", ",", "centers", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.lerp": [[87, 94], ["None"], "function", ["None"], ["", "", "def", "lerp", "(", "v0", ",", "v1", ",", "t", ")", ":", "\n", "    ", "'''\n    Linear interpolation between\n    vectors v0 and v1 at steps t.\n    '''", "\n", "k0", ",", "k1", "=", "(", "1", "-", "t", ")", ",", "t", "\n", "return", "k0", "*", "v0", "+", "k1", "*", "v1", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.slerp": [[96, 117], ["v0.norm", "v1.norm", "torch.sin", "torch.acos", "torch.sin", "torch.sin"], "function", ["None"], ["", "def", "slerp", "(", "v0", ",", "v1", ",", "t", ",", "center", "=", "None", ")", ":", "\n", "    ", "'''\n    Spherical linear interpolation between\n    vectors v0 and v1 at steps t.\n    '''", "\n", "eps", "=", "1e-6", "\n", "if", "center", "is", "not", "None", ":", "\n", "        ", "v0", "-=", "center", "\n", "v1", "-=", "center", "\n", "", "norm_v0", "=", "v0", ".", "norm", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "norm_v1", "=", "v1", ".", "norm", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "dot_v0_v1", "=", "(", "v0", "*", "v1", ")", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "cos_theta", "=", "dot_v0_v1", "/", "(", "norm_v0", "*", "norm_v1", ")", "\n", "theta", "=", "torch", ".", "acos", "(", "cos_theta", ")", "+", "eps", "# angle between the vectors", "\n", "sin_theta", "=", "torch", ".", "sin", "(", "theta", ")", "\n", "k0", "=", "torch", ".", "sin", "(", "(", "1", "-", "t", ")", "*", "theta", ")", "/", "sin_theta", "\n", "k1", "=", "torch", ".", "sin", "(", "t", "*", "theta", ")", "/", "sin_theta", "\n", "if", "center", "is", "not", "None", ":", "\n", "        ", "return", "k0", "*", "v0", "+", "k1", "*", "v1", "+", "center", "\n", "", "else", ":", "\n", "        ", "return", "k0", "*", "v0", "+", "k1", "*", "v1", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.__init__": [[32, 38], ["torch.nn.Module.__init__", "loss_fns.LossFunction.init_loss_weights", "loss_fns.LossFunction.init_loss_types", "loss_fns.LossFunction.init_loss_schedules"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.init_loss_weights", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.init_loss_types", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.init_loss_schedules"], ["def", "__init__", "(", "self", ",", "types", ",", "weights", ",", "schedules", "=", "{", "}", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "init_loss_weights", "(", "**", "weights", ")", "\n", "self", ".", "init_loss_types", "(", "**", "types", ")", "\n", "self", ".", "init_loss_schedules", "(", "**", "schedules", ")", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.init_loss_weights": [[39, 54], ["float", "float", "float", "float", "float", "float"], "methods", ["None"], ["", "def", "init_loss_weights", "(", "\n", "self", ",", "\n", "kldiv_loss", "=", "0", ",", "\n", "recon_loss", "=", "0", ",", "\n", "gan_loss", "=", "0", ",", "\n", "steric_loss", "=", "0", ",", "\n", "kldiv2_loss", "=", "0", ",", "\n", "recon2_loss", "=", "0", ",", "\n", ")", ":", "\n", "        ", "self", ".", "kldiv_loss_wt", "=", "float", "(", "kldiv_loss", ")", "\n", "self", ".", "recon_loss_wt", "=", "float", "(", "recon_loss", ")", "\n", "self", ".", "gan_loss_wt", "=", "float", "(", "gan_loss", ")", "\n", "self", ".", "steric_loss_wt", "=", "float", "(", "steric_loss", ")", "\n", "self", ".", "kldiv2_loss_wt", "=", "float", "(", "kldiv2_loss", ")", "\n", "self", ".", "recon2_loss_wt", "=", "float", "(", "recon2_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.init_loss_types": [[55, 70], ["loss_fns.get_kldiv_loss_fn", "loss_fns.get_recon_loss_fn", "loss_fns.get_gan_loss_fn", "loss_fns.get_steric_loss_fn", "loss_fns.get_kldiv_loss_fn", "loss_fns.get_recon_loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_kldiv_loss_fn", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_recon_loss_fn", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_gan_loss_fn", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_steric_loss_fn", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_kldiv_loss_fn", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_recon_loss_fn"], ["", "def", "init_loss_types", "(", "\n", "self", ",", "\n", "kldiv_loss", "=", "'k'", ",", "\n", "recon_loss", "=", "'2'", ",", "\n", "gan_loss", "=", "'x'", ",", "\n", "steric_loss", "=", "'p'", ",", "\n", "kldiv2_loss", "=", "'k'", ",", "\n", "recon2_loss", "=", "'2'", ",", "\n", ")", ":", "\n", "        ", "self", ".", "kldiv_loss_fn", "=", "get_kldiv_loss_fn", "(", "kldiv_loss", ")", "\n", "self", ".", "recon_loss_fn", "=", "get_recon_loss_fn", "(", "recon_loss", ")", "\n", "self", ".", "gan_loss_fn", "=", "get_gan_loss_fn", "(", "gan_loss", ")", "\n", "self", ".", "steric_loss_fn", "=", "get_steric_loss_fn", "(", "steric_loss", ")", "\n", "self", ".", "kldiv2_loss_fn", "=", "get_kldiv_loss_fn", "(", "kldiv2_loss", ")", "\n", "self", ".", "recon2_loss_fn", "=", "get_recon_loss_fn", "(", "recon2_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.init_loss_schedules": [[71, 97], ["loss_fns.get_loss_schedule", "loss_fns.get_loss_schedule", "loss_fns.get_loss_schedule", "loss_fns.get_loss_schedule", "loss_fns.get_loss_schedule", "loss_fns.get_loss_schedule"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_loss_schedule", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_loss_schedule", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_loss_schedule", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_loss_schedule", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_loss_schedule", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_loss_schedule"], ["", "def", "init_loss_schedules", "(", "\n", "self", ",", "\n", "kldiv_loss", "=", "{", "}", ",", "\n", "recon_loss", "=", "{", "}", ",", "\n", "gan_loss", "=", "{", "}", ",", "\n", "steric_loss", "=", "{", "}", ",", "\n", "kldiv2_loss", "=", "{", "}", ",", "\n", "recon2_loss", "=", "{", "}", ",", "\n", ")", ":", "\n", "        ", "self", ".", "kldiv_loss_schedule", ",", "_", "=", "get_loss_schedule", "(", "\n", "start_wt", "=", "self", ".", "kldiv_loss_wt", ",", "**", "kldiv_loss", "\n", ")", "\n", "self", ".", "recon_loss_schedule", ",", "_", "=", "get_loss_schedule", "(", "\n", "start_wt", "=", "self", ".", "recon_loss_wt", ",", "**", "recon_loss", "\n", ")", "\n", "self", ".", "gan_loss_schedule", ",", "self", ".", "end_gan_loss_wt", "=", "get_loss_schedule", "(", "\n", "start_wt", "=", "self", ".", "gan_loss_wt", ",", "**", "gan_loss", "\n", ")", "\n", "self", ".", "steric_loss_schedule", ",", "self", ".", "end_steric_loss_wt", "=", "get_loss_schedule", "(", "\n", "start_wt", "=", "self", ".", "steric_loss_wt", ",", "**", "steric_loss", "\n", ")", "\n", "self", ".", "kldiv2_loss_schedule", ",", "_", "=", "get_loss_schedule", "(", "\n", "start_wt", "=", "self", ".", "kldiv2_loss_wt", ",", "**", "kldiv2_loss", "\n", ")", "\n", "self", ".", "recon2_loss_schedule", ",", "_", "=", "get_loss_schedule", "(", "\n", "start_wt", "=", "self", ".", "recon2_loss_wt", ",", "**", "recon2_loss", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.has_prior_loss": [[99, 108], ["bool"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_prior_loss", "(", "self", ")", ":", "\n", "        ", "'''\n        Whether the loss function ever has\n        non-zero value on prior samples.\n        '''", "\n", "return", "bool", "(", "\n", "self", ".", "gan_loss_wt", "or", "self", ".", "end_gan_loss_wt", "or", "\n", "self", ".", "steric_loss_wt", "or", "self", ".", "end_steric_loss_wt", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.LossFunction.forward": [[110, 199], ["torch.zeros", "torch.zeros", "torch.zeros", "collections.OrderedDict", "has_both", "has_both", "has_both", "has_both", "has_both", "has_both", "torch.zeros.item", "loss_fns.LossFunction.recon_loss_fn", "loss_fns.LossFunction.recon_loss_schedule", "loss_fns.LossFunction.item", "loss_fns.LossFunction.item", "gen_log_var.item", "loss_fns.LossFunction.kldiv_loss_fn", "loss_fns.LossFunction.kldiv_loss_schedule", "loss_fns.LossFunction.item", "loss_fns.LossFunction.item", "loss_fns.LossFunction.gan_loss_fn", "loss_fns.LossFunction.gan_loss_schedule", "loss_fns.LossFunction.item", "loss_fns.LossFunction.item", "loss_fns.LossFunction.steric_loss_fn", "loss_fns.LossFunction.steric_loss_schedule", "loss_fns.LossFunction.item", "loss_fns.LossFunction.item", "loss_fns.LossFunction.kldiv2_loss_fn", "loss_fns.LossFunction.kldiv2_loss_schedule", "loss_fns.LossFunction.item", "loss_fns.LossFunction.item", "loss_fns.LossFunction.recon2_loss_fn", "loss_fns.LossFunction.recon2_loss_schedule", "loss_fns.LossFunction.item", "loss_fns.LossFunction.item", "prior_log_var.item"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "latent_means", "=", "None", ",", "\n", "latent_log_stds", "=", "None", ",", "\n", "lig_grids", "=", "None", ",", "\n", "lig_gen_grids", "=", "None", ",", "\n", "disc_labels", "=", "None", ",", "\n", "disc_preds", "=", "None", ",", "\n", "rec_grids", "=", "None", ",", "\n", "rec_lig_grids", "=", "None", ",", "\n", "latent2_means", "=", "None", ",", "\n", "latent2_log_stds", "=", "None", ",", "\n", "real_latents", "=", "None", ",", "\n", "gen_latents", "=", "None", ",", "\n", "gen_log_var", "=", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "prior_log_var", "=", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "use_loss_wt", "=", "True", ",", "\n", "iteration", "=", "0", ",", "\n", ")", ":", "\n", "        ", "'''\n        Computes the loss as follows:\n\n        = kldiv_loss_wt * \n            kldiv_loss_fn(latent_means, latent_log_stds)\n        + recon_loss_wt * \n            recon_loss_fn(lig_gen_grids, lig_grids)\n        + gan_loss_wt * \n            gan_loss_fn(disc_preds, disc_labels)\n        + steric_loss_wt * \n            steric_loss_fn(rec_grids, rec_lig_grids)\n        + ...\n\n        Each term is computed iff both of its inputs are\n        provided to the method, and each computed term is\n        also returned as values in an OrderedDict.\n        '''", "\n", "loss", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "self", ".", "device", ")", "\n", "losses", "=", "odict", "(", ")", "# track each loss term", "\n", "\n", "if", "has_both", "(", "lig_grids", ",", "lig_gen_grids", ")", ":", "\n", "            ", "recon_loss", "=", "self", ".", "recon_loss_fn", "(", "\n", "lig_gen_grids", ",", "lig_grids", ",", "gen_log_var", "\n", ")", "\n", "recon_loss_wt", "=", "self", ".", "recon_loss_schedule", "(", "iteration", ",", "use_loss_wt", ")", "\n", "loss", "+=", "recon_loss_wt", "*", "recon_loss", "\n", "losses", "[", "'recon_loss'", "]", "=", "recon_loss", ".", "item", "(", ")", "\n", "losses", "[", "'recon_loss_wt'", "]", "=", "recon_loss_wt", ".", "item", "(", ")", "\n", "losses", "[", "'recon_log_var'", "]", "=", "gen_log_var", ".", "item", "(", ")", "\n", "\n", "", "if", "has_both", "(", "latent_means", ",", "latent_log_stds", ")", ":", "\n", "            ", "kldiv_loss", "=", "self", ".", "kldiv_loss_fn", "(", "latent_means", ",", "latent_log_stds", ")", "\n", "kldiv_loss_wt", "=", "self", ".", "kldiv_loss_schedule", "(", "iteration", ",", "use_loss_wt", ")", "\n", "loss", "+=", "kldiv_loss_wt", "*", "kldiv_loss", "\n", "losses", "[", "'kldiv_loss'", "]", "=", "kldiv_loss", ".", "item", "(", ")", "\n", "losses", "[", "'kldiv_loss_wt'", "]", "=", "kldiv_loss_wt", ".", "item", "(", ")", "\n", "\n", "", "if", "has_both", "(", "disc_labels", ",", "disc_preds", ")", ":", "\n", "            ", "gan_loss", "=", "self", ".", "gan_loss_fn", "(", "disc_preds", ",", "disc_labels", ")", "\n", "gan_loss_wt", "=", "self", ".", "gan_loss_schedule", "(", "iteration", ",", "use_loss_wt", ")", "\n", "loss", "+=", "gan_loss_wt", "*", "gan_loss", "\n", "losses", "[", "'gan_loss'", "]", "=", "gan_loss", ".", "item", "(", ")", "\n", "losses", "[", "'gan_loss_wt'", "]", "=", "gan_loss_wt", ".", "item", "(", ")", "\n", "\n", "", "if", "has_both", "(", "rec_grids", ",", "rec_lig_grids", ")", ":", "\n", "            ", "steric_loss", "=", "self", ".", "steric_loss_fn", "(", "rec_grids", ",", "rec_lig_grids", ")", "\n", "steric_loss_wt", "=", "self", ".", "steric_loss_schedule", "(", "iteration", ",", "use_loss_wt", ")", "\n", "loss", "+=", "steric_loss_wt", "*", "steric_loss", "\n", "losses", "[", "'steric_loss'", "]", "=", "steric_loss", ".", "item", "(", ")", "\n", "losses", "[", "'steric_loss_wt'", "]", "=", "steric_loss_wt", ".", "item", "(", ")", "\n", "\n", "", "if", "has_both", "(", "latent2_means", ",", "latent2_log_stds", ")", ":", "\n", "            ", "kldiv2_loss", "=", "self", ".", "kldiv2_loss_fn", "(", "latent2_means", ",", "latent2_log_stds", ")", "\n", "kldiv2_loss_wt", "=", "self", ".", "kldiv2_loss_schedule", "(", "iteration", ",", "use_loss_wt", ")", "\n", "loss", "+=", "kldiv2_loss_wt", "*", "kldiv2_loss", "\n", "losses", "[", "'kldiv2_loss'", "]", "=", "kldiv2_loss", ".", "item", "(", ")", "\n", "losses", "[", "'kldiv2_loss_wt'", "]", "=", "kldiv2_loss_wt", ".", "item", "(", ")", "\n", "\n", "", "if", "has_both", "(", "real_latents", ",", "gen_latents", ")", ":", "\n", "            ", "recon2_loss", "=", "self", ".", "recon2_loss_fn", "(", "\n", "gen_latents", ",", "real_latents", ",", "prior_log_var", "\n", ")", "\n", "recon2_loss_wt", "=", "self", ".", "recon2_loss_schedule", "(", "iteration", ",", "use_loss_wt", ")", "\n", "loss", "+=", "recon2_loss_wt", "*", "recon2_loss", "\n", "losses", "[", "'recon2_loss'", "]", "=", "recon2_loss", ".", "item", "(", ")", "\n", "losses", "[", "'recon2_loss_wt'", "]", "=", "recon2_loss_wt", ".", "item", "(", ")", "\n", "losses", "[", "'recon2_log_var'", "]", "=", "prior_log_var", ".", "item", "(", ")", "\n", "\n", "", "losses", "[", "'loss'", "]", "=", "loss", ".", "item", "(", ")", "\n", "return", "loss", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_loss_schedule": [[203, 238], ["torch.tensor", "torch.as_tensor", "torch.as_tensor", "torch.cos"], "function", ["None"], ["", "", "def", "get_loss_schedule", "(", "\n", "start_wt", ",", "\n", "start_iter", "=", "500000", ",", "\n", "end_wt", "=", "None", ",", "\n", "period", "=", "100000", ",", "\n", "type", "=", "'d'", ",", "\n", ")", ":", "\n", "    ", "'''\n    Return a function that takes the\n    iteration as input and returns a\n    modulated loss weight as output.\n    '''", "\n", "no_schedule", "=", "(", "\n", "type", "==", "'n'", "or", "end_wt", "is", "None", "or", "end_wt", "==", "start_wt", "\n", ")", "\n", "assert", "no_schedule", "or", "period", ">", "0", ",", "period", "\n", "assert", "type", "in", "{", "'n'", ",", "'d'", ",", "'c'", ",", "'r'", "}", ",", "type", "\n", "periodic", "=", "(", "type", "==", "'c '", "or", "type", "==", "'r'", ")", "\n", "restart", "=", "(", "type", "==", "'r'", ")", "\n", "end_iter", "=", "start_iter", "+", "period", "\n", "\n", "def", "loss_schedule", "(", "iteration", ",", "use_loss_wt", ")", ":", "\n", "        ", "if", "not", "use_loss_wt", ":", "\n", "            ", "return", "torch", ".", "tensor", "(", "1", ")", "\n", "", "if", "no_schedule", "or", "iteration", "<", "start_iter", ":", "\n", "            ", "return", "torch", ".", "as_tensor", "(", "start_wt", ")", "\n", "", "if", "iteration", ">=", "end_iter", "and", "not", "periodic", ":", "\n", "            ", "return", "torch", ".", "as_tensor", "(", "end_wt", ")", "\n", "", "wt_range", "=", "(", "end_wt", "-", "start_wt", ")", "\n", "theta", "=", "(", "iteration", "-", "start_iter", ")", "/", "period", "*", "pi", "\n", "if", "restart", ":", "# jump from end_wt to start_wt", "\n", "            ", "theta", "%=", "pi", "\n", "", "return", "end_wt", "-", "wt_range", "*", "0.5", "*", "(", "1", "+", "torch", ".", "cos", "(", "theta", ")", ")", "\n", "\n", "", "return", "loss_schedule", ",", "end_wt", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_kldiv_loss_fn": [[243, 246], ["None"], "function", ["None"], ["", "def", "get_kldiv_loss_fn", "(", "type", ")", ":", "\n", "    ", "assert", "type", "==", "'k'", ",", "type", "\n", "return", "kl_divergence", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_recon_loss_fn": [[248, 254], ["None"], "function", ["None"], ["", "def", "get_recon_loss_fn", "(", "type", ")", ":", "\n", "    ", "assert", "type", "in", "{", "'1'", ",", "'2'", "}", ",", "type", "\n", "if", "type", "==", "'1'", ":", "\n", "        ", "return", "L1_loss", "\n", "", "else", ":", "# '2'", "\n", "        ", "return", "L2_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_gan_loss_fn": [[256, 262], ["torch.nn.BCEWithLogitsLoss"], "function", ["None"], ["", "", "def", "get_gan_loss_fn", "(", "type", ")", ":", "\n", "    ", "assert", "type", "in", "{", "'x'", ",", "'w'", "}", ",", "type", "\n", "if", "type", "==", "'w'", ":", "\n", "        ", "return", "wasserstein_loss", "\n", "", "else", ":", "# 'x'", "\n", "        ", "return", "torch", ".", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_steric_loss_fn": [[264, 267], ["None"], "function", ["None"], ["", "", "def", "get_steric_loss_fn", "(", "type", ")", ":", "\n", "    ", "assert", "type", "==", "'p'", ",", "type", "\n", "return", "product_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.kl_divergence": [[272, 279], ["torch.exp"], "function", ["None"], ["", "def", "kl_divergence", "(", "means", ",", "log_stds", ")", ":", "\n", "    ", "stds", "=", "torch", ".", "exp", "(", "log_stds", ")", "\n", "means2", "=", "means", "*", "means", "\n", "vars_", "=", "stds", "*", "stds", "\n", "return", "(", "\n", "-", "log_stds", "+", "means2", "/", "2", "+", "vars_", "/", "2", "-", "0.5", "\n", ")", ".", "sum", "(", ")", "/", "means", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.L1_loss": [[281, 285], ["torch.sum", "torch.exp"], "function", ["None"], ["", "def", "L1_loss", "(", "predictions", ",", "labels", ",", "log_var", "=", "0", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "\n", "(", "(", "labels", "-", "predictions", ")", "/", "torch", ".", "exp", "(", "log_var", ")", ")", ".", "abs", "(", ")", "+", "log_var", "\n", ")", "/", "labels", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.L2_loss": [[287, 292], ["torch.sum", "torch.exp"], "function", ["None"], ["", "def", "L2_loss", "(", "predictions", ",", "labels", ",", "log_var", "=", "0", ")", ":", "\n", "# https://github.com/daib13/TwoStageVAE/blob/master/network/two_stage_vae_model.py#L39", "\n", "    ", "return", "torch", ".", "sum", "(", "\n", "(", "(", "labels", "-", "predictions", ")", "/", "torch", ".", "exp", "(", "log_var", ")", ")", "**", "2", "/", "2.0", "+", "log_var", "\n", ")", "/", "labels", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.wasserstein_loss": [[294, 297], ["None"], "function", ["None"], ["", "def", "wasserstein_loss", "(", "predictions", ",", "labels", ")", ":", "\n", "    ", "labels", "=", "(", "2", "*", "labels", "-", "1", ")", "# convert {0, 1} to {-1, 1}", "\n", "return", "(", "labels", "*", "predictions", ")", ".", "sum", "(", ")", "/", "labels", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.product_loss": [[299, 308], ["rec_grids.sum", "lig_grids.clamp().sum", "lig_grids.clamp"], "function", ["None"], ["", "def", "product_loss", "(", "rec_grids", ",", "lig_grids", ")", ":", "\n", "    ", "'''\n    Minimize receptor-ligand overlap\n    by summing the pointwise products\n    of total density at each point.\n    '''", "\n", "return", "(", "\n", "rec_grids", ".", "sum", "(", "dim", "=", "1", ")", "*", "lig_grids", ".", "clamp", "(", "min", "=", "0", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", ")", ".", "sum", "(", ")", "/", "lig_grids", ".", "shape", "[", "0", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.get_unique_seed": [[7, 12], ["time.sleep", "int", "time.time", "time.time"], "function", ["None"], ["def", "get_unique_seed", "(", ")", ":", "\n", "# wait some fraction of a ms to avoid overlap", "\n", "    ", "time", ".", "sleep", "(", "(", "time", ".", "time", "(", ")", "%", "1", ")", "/", "1000", ")", "\n", "# return current time in ns mod the max allowed seed", "\n", "return", "int", "(", "time", ".", "time", "(", ")", "*", "1e6", ")", "%", "4294967295", "# 2**32 - 1", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed": [[14, 22], ["print", "random.seed", "numpy.random.seed", "torch.manual_seed", "molgrid.set_random_seed", "common.get_unique_seed"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.get_unique_seed"], ["", "def", "set_random_seed", "(", "random_seed", "=", "None", ")", ":", "\n", "    ", "if", "random_seed", "is", "None", ":", "\n", "        ", "random_seed", "=", "get_unique_seed", "(", ")", "\n", "", "print", "(", "'Setting random seed to'", ",", "random_seed", ")", "\n", "random", ".", "seed", "(", "random_seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "random_seed", ")", "\n", "torch", ".", "manual_seed", "(", "random_seed", ")", "\n", "molgrid", ".", "set_random_seed", "(", "random_seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.catch_exception": [[24, 57], ["func", "func"], "function", ["None"], ["", "def", "catch_exception", "(", "func", "=", "None", ",", "exc_type", "=", "Exception", ",", "default", "=", "np", ".", "nan", ")", ":", "\n", "    ", "'''\n    Wrap a function in a try-except block and\n    return a default value when a specific type\n    of Exception is raised.\n\n    Can be used in two different ways:\n\n    1) Simple decorator\n        wrapped = catch_exception(func, exc_type, default)\n\n    2) Decorator factory (must use keywords args)\n        @catch_exception(exc_type=..., default=...)\n        def func(*args, **kwargs):\n            ...\n    '''", "\n", "if", "func", "is", "None", ":", "# use as a decorator factory", "\n", "        ", "def", "decorator", "(", "func", ")", ":", "\n", "            ", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "except", "exc_type", ":", "\n", "                    ", "return", "default", "\n", "", "", "return", "wrapper", "\n", "", "return", "decorator", "\n", "\n", "", "else", ":", "# use as a simple decorator", "\n", "        ", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "except", "exc_type", ":", "\n", "                ", "return", "default", "\n", "", "", "return", "wrapper", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_scalar_metrics": [[8, 13], ["collections.OrderedDict", "scalars.mean().item", "scalars.var().item", "scalars.mean", "scalars.var"], "function", ["None"], ["def", "compute_scalar_metrics", "(", "scalar_type", ",", "scalars", ")", ":", "\n", "    ", "m", "=", "OrderedDict", "(", ")", "\n", "m", "[", "scalar_type", "+", "'_mean'", "]", "=", "scalars", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "m", "[", "scalar_type", "+", "'_variance'", "]", "=", "scalars", ".", "var", "(", "unbiased", "=", "False", ")", ".", "item", "(", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_grid_norm": [[15, 18], ["tuple", "grids.detach().norm().mean().item", "range", "grids.detach().norm().mean", "grids.detach().norm", "grids.detach"], "function", ["None"], ["", "def", "compute_mean_grid_norm", "(", "grids", ")", ":", "\n", "    ", "dim", "=", "tuple", "(", "range", "(", "1", ",", "grids", ".", "ndim", ")", ")", "\n", "return", "grids", ".", "detach", "(", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "dim", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_grid_variance": [[20, 23], ["grids.detach().mean", "grids.detach", "grids.detach"], "function", ["None"], ["", "def", "compute_grid_variance", "(", "grids", ")", ":", "\n", "    ", "mean_grid", "=", "grids", ".", "detach", "(", ")", ".", "mean", "(", "dim", "=", "0", ")", "\n", "return", "(", "(", "(", "grids", ".", "detach", "(", ")", "-", "mean_grid", ")", "**", "2", ")", ".", "sum", "(", ")", "/", "grids", ".", "shape", "[", "0", "]", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_grid_metrics": [[25, 30], ["collections.OrderedDict", "metrics.compute_mean_grid_norm", "metrics.compute_grid_variance"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_grid_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_grid_variance"], ["", "def", "compute_grid_metrics", "(", "grid_type", ",", "grids", ")", ":", "\n", "    ", "m", "=", "OrderedDict", "(", ")", "\n", "m", "[", "grid_type", "+", "'_norm'", "]", "=", "compute_mean_grid_norm", "(", "grids", ")", "\n", "m", "[", "grid_type", "+", "'_variance'", "]", "=", "compute_grid_variance", "(", "grids", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_L2_loss": [[33, 37], ["ref_grids.detach", "grids.detach"], "function", ["None"], ["", "def", "compute_L2_loss", "(", "grids", ",", "ref_grids", ")", ":", "\n", "    ", "return", "(", "\n", "(", "ref_grids", ".", "detach", "(", ")", "-", "grids", ".", "detach", "(", ")", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "2", "/", "grids", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_paired_grid_metrics": [[39, 44], ["metrics.compute_grid_metrics", "compute_grid_metrics.update", "metrics.compute_L2_loss", "metrics.compute_grid_metrics"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_grid_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_L2_loss", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_grid_metrics"], ["", "def", "compute_paired_grid_metrics", "(", "grid_type", ",", "grids", ",", "ref_grid_type", ",", "ref_grids", ")", ":", "\n", "    ", "m", "=", "compute_grid_metrics", "(", "ref_grid_type", ",", "ref_grids", ")", "\n", "m", ".", "update", "(", "compute_grid_metrics", "(", "grid_type", ",", "grids", ")", ")", "\n", "m", "[", "grid_type", "+", "'_L2_loss'", "]", "=", "compute_L2_loss", "(", "grids", ",", "ref_grids", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_n_atoms": [[46, 48], ["numpy.mean"], "function", ["None"], ["", "def", "compute_mean_n_atoms", "(", "structs", ")", ":", "\n", "    ", "return", "np", ".", "mean", "(", "[", "s", ".", "n_atoms", "for", "s", "in", "structs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_n_atoms_variance": [[50, 53], ["numpy.mean", "numpy.mean"], "function", ["None"], ["", "def", "compute_n_atoms_variance", "(", "structs", ")", ":", "\n", "    ", "m", "=", "np", ".", "mean", "(", "[", "s", ".", "n_atoms", "for", "s", "in", "structs", "]", ")", "\n", "return", "np", ".", "mean", "(", "[", "(", "s", ".", "n_atoms", "-", "m", ")", "**", "2", "for", "s", "in", "structs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_radius": [[55, 57], ["numpy.mean"], "function", ["None"], ["", "def", "compute_mean_radius", "(", "structs", ")", ":", "\n", "    ", "return", "np", ".", "mean", "(", "[", "s", ".", "radius", "for", "s", "in", "structs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_type_variance": [[59, 73], ["torch.stack().mean", "numpy.mean", "torch.stack"], "function", ["None"], ["", "def", "compute_type_variance", "(", "structs", ",", "which", "=", "None", ")", ":", "\n", "\n", "    ", "if", "which", "is", "None", ":", "\n", "        ", "type_counts", "=", "[", "s", ".", "type_counts", "for", "s", "in", "structs", "]", "\n", "\n", "", "elif", "which", "==", "'elem'", ":", "\n", "        ", "type_counts", "=", "[", "s", ".", "elem_counts", "for", "s", "in", "structs", "]", "\n", "\n", "", "elif", "which", "==", "'prop'", ":", "\n", "        ", "type_counts", "=", "[", "s", ".", "prop_counts", "for", "s", "in", "structs", "]", "\n", "\n", "", "m", "=", "torch", ".", "stack", "(", "type_counts", ")", ".", "mean", "(", "dim", "=", "0", ")", "\n", "return", "np", ".", "mean", "(", "[", "\n", "(", "t", "-", "m", ")", ".", "norm", "(", "p", "=", "1", ")", ".", "item", "(", ")", "for", "t", "in", "type_counts", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_struct_metrics": [[76, 89], ["collections.OrderedDict", "metrics.compute_mean_n_atoms", "metrics.compute_n_atoms_variance", "metrics.compute_mean_radius", "metrics.compute_type_variance", "metrics.compute_type_variance", "metrics.compute_type_variance"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_n_atoms", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_n_atoms_variance", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_radius", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_type_variance", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_type_variance", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_type_variance"], ["", "def", "compute_struct_metrics", "(", "struct_type", ",", "structs", ")", ":", "\n", "    ", "m", "=", "OrderedDict", "(", ")", "\n", "m", "[", "struct_type", "+", "'_n_atoms'", "]", "=", "compute_mean_n_atoms", "(", "structs", ")", "\n", "m", "[", "struct_type", "+", "'_n_atoms_variance'", "]", "=", "compute_n_atoms_variance", "(", "structs", ")", "\n", "m", "[", "struct_type", "+", "'_radius'", "]", "=", "compute_mean_radius", "(", "structs", ")", "\n", "m", "[", "struct_type", "+", "'_type_variance'", "]", "=", "compute_type_variance", "(", "structs", ")", "\n", "m", "[", "struct_type", "+", "'_elem_variance'", "]", "=", "compute_type_variance", "(", "\n", "structs", ",", "which", "=", "'elem'", "\n", ")", "\n", "m", "[", "struct_type", "+", "'_prop_variance'", "]", "=", "compute_type_variance", "(", "\n", "structs", ",", "which", "=", "'prop'", "\n", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_type_diff": [[91, 105], ["numpy.array", "numpy.mean", "numpy.mean", "zip"], "function", ["None"], ["", "def", "compute_mean_type_diff", "(", "structs", ",", "ref_structs", ",", "which", "=", "None", ")", ":", "\n", "    ", "if", "which", "is", "None", ":", "\n", "        ", "type_counts", "=", "[", "s", ".", "type_counts", "for", "s", "in", "structs", "]", "\n", "ref_type_counts", "=", "[", "s", ".", "type_counts", "for", "s", "in", "ref_structs", "]", "\n", "", "elif", "which", "==", "'elem'", ":", "\n", "        ", "type_counts", "=", "[", "s", ".", "elem_counts", "for", "s", "in", "structs", "]", "\n", "ref_type_counts", "=", "[", "s", ".", "elem_counts", "for", "s", "in", "ref_structs", "]", "\n", "", "elif", "which", "==", "'prop'", ":", "\n", "        ", "type_counts", "=", "[", "s", ".", "prop_counts", "for", "s", "in", "structs", "]", "\n", "ref_type_counts", "=", "[", "s", ".", "prop_counts", "for", "s", "in", "ref_structs", "]", "\n", "", "type_diffs", "=", "np", ".", "array", "(", "[", "\n", "(", "t", "-", "r", ")", ".", "norm", "(", "p", "=", "1", ")", ".", "item", "(", ")", "for", "t", ",", "r", "in", "zip", "(", "type_counts", ",", "ref_type_counts", ")", "\n", "]", ")", "\n", "return", "np", ".", "mean", "(", "type_diffs", ")", ",", "np", ".", "mean", "(", "type_diffs", "==", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_min_rmsd": [[107, 151], ["len", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "np.array.sum", "np.array.sum", "numpy.abs().sum", "numpy.unique", "numpy.sqrt", "len", "len", "scipy.optimize.linear_sum_assignment", "dist2_t[].sum", "numpy.abs", "len", "len"], "function", ["None"], ["", "def", "compute_min_rmsd", "(", "coords1", ",", "types1", ",", "coords2", ",", "types2", ")", ":", "\n", "    ", "'''\n    Compute an RMSD between two sets of positions of the same\n    atom types with no prior mapping between particular atom\n    positions of a given type. Returns the minimum RMSD across\n    all permutations of this mapping.\n    '''", "\n", "# check that structs are same size", "\n", "n1", ",", "n2", "=", "len", "(", "coords1", ")", ",", "len", "(", "coords2", ")", "\n", "assert", "n1", "==", "n2", ",", "'structs must have same num atoms ({} vs. {})'", ".", "format", "(", "n1", ",", "n2", ")", "\n", "n_atoms", "=", "len", "(", "coords1", ")", "\n", "\n", "# copy everything into arrays", "\n", "coords1", "=", "np", ".", "array", "(", "coords1", ")", "\n", "coords2", "=", "np", ".", "array", "(", "coords2", ")", "\n", "types1", "=", "np", ".", "array", "(", "types1", ")", "\n", "types2", "=", "np", ".", "array", "(", "types2", ")", "\n", "\n", "# check that atom types are compatible", "\n", "# CAUTION this may not be sufficient for vector types", "\n", "#   we could have two structs with the same element", "\n", "#   counts and property counts, but the properties", "\n", "#   could be on different atoms/elements- do we care?", "\n", "type_counts1", "=", "types1", ".", "sum", "(", "axis", "=", "0", ")", "\n", "type_counts2", "=", "types2", ".", "sum", "(", "axis", "=", "0", ")", "\n", "type_diff", "=", "np", ".", "abs", "(", "type_counts1", "-", "type_counts2", ")", ".", "sum", "(", ")", "\n", "assert", "(", "type_counts1", "==", "type_counts2", ")", ".", "all", "(", ")", ",", "'structs must have same type counts ({:.2f})'", ".", "format", "(", "type_diff", ")", "\n", "\n", "# find min rmsd by solving linear sum assignment", "\n", "# problem on squared dist matrix for each type", "\n", "ssd", "=", "0.0", "\n", "nax", "=", "np", ".", "newaxis", "\n", "for", "t", "in", "np", ".", "unique", "(", "types1", ",", "axis", "=", "0", ")", ":", "\n", "        ", "coords1_t", "=", "coords1", "[", "(", "types1", "==", "t", "[", "nax", ",", ":", "]", ")", ".", "all", "(", "axis", "=", "1", ")", "]", "\n", "coords2_t", "=", "coords2", "[", "(", "types2", "==", "t", "[", "nax", ",", ":", "]", ")", ".", "all", "(", "axis", "=", "1", ")", "]", "\n", "assert", "len", "(", "coords1_t", ")", "==", "len", "(", "coords2_t", ")", ",", "'structs must have same num atoms of each type'", "\n", "dist2_t", "=", "(", "(", "coords1_t", "[", ":", ",", "nax", ",", ":", "]", "-", "coords2_t", "[", "nax", ",", ":", ",", ":", "]", ")", "**", "2", ")", ".", "sum", "(", "axis", "=", "2", ")", "\n", "idx1", ",", "idx2", "=", "sp", ".", "optimize", ".", "linear_sum_assignment", "(", "dist2_t", ")", "\n", "ssd", "+=", "dist2_t", "[", "idx1", ",", "idx2", "]", ".", "sum", "(", ")", "\n", "\n", "", "return", "np", ".", "sqrt", "(", "ssd", "/", "n_atoms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_struct_rmsd": [[153, 165], ["metrics.compute_min_rmsd", "struct1.coords.cpu", "struct1.types[].cpu", "struct2.coords.cpu", "struct2.types[].cpu"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_min_rmsd"], ["", "def", "compute_struct_rmsd", "(", "struct1", ",", "struct2", ",", "catch_exc", "=", "True", ")", ":", "\n", "    ", "assert", "struct1", ".", "typer", "==", "struct2", ".", "typer", ",", "'structs have different typers'", "\n", "n_elem_types", "=", "struct1", ".", "typer", ".", "n_elem_types", "\n", "try", ":", "\n", "        ", "return", "compute_min_rmsd", "(", "# ignore property channels", "\n", "struct1", ".", "coords", ".", "cpu", "(", ")", ",", "struct1", ".", "types", "[", ":", ",", ":", "n_elem_types", "]", ".", "cpu", "(", ")", ",", "\n", "struct2", ".", "coords", ".", "cpu", "(", ")", ",", "struct2", ".", "types", "[", ":", ",", ":", "n_elem_types", "]", ".", "cpu", "(", ")", ",", "\n", ")", "\n", "", "except", "(", "AssertionError", ",", "ZeroDivisionError", ")", ":", "\n", "        ", "if", "catch_exc", ":", "\n", "            ", "return", "np", ".", "nan", "\n", "", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_atom_rmsd": [[167, 174], ["numpy.mean", "metrics.compute_struct_rmsd", "zip"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_struct_rmsd"], ["", "", "def", "compute_mean_atom_rmsd", "(", "structs", ",", "ref_structs", ")", ":", "\n", "    ", "atom_rmsds", "=", "[", "\n", "compute_struct_rmsd", "(", "s", ",", "r", ")", "for", "s", ",", "r", "in", "zip", "(", "\n", "structs", ",", "ref_structs", "\n", ")", "\n", "]", "\n", "return", "np", ".", "mean", "(", "atom_rmsds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_paired_struct_metrics": [[176, 192], ["metrics.compute_struct_metrics", "compute_struct_metrics.update", "metrics.compute_mean_type_diff", "metrics.compute_mean_type_diff", "metrics.compute_mean_type_diff", "metrics.compute_mean_atom_rmsd", "metrics.compute_struct_metrics"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_struct_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_type_diff", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_type_diff", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_type_diff", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_mean_atom_rmsd", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_struct_metrics"], ["", "def", "compute_paired_struct_metrics", "(", "\n", "struct_type", ",", "\n", "structs", ",", "\n", "ref_struct_type", ",", "\n", "ref_structs", "\n", ")", ":", "\n", "    ", "m", "=", "compute_struct_metrics", "(", "struct_type", ",", "structs", ")", "\n", "m", ".", "update", "(", "compute_struct_metrics", "(", "ref_struct_type", ",", "ref_structs", ")", ")", "\n", "m", "[", "struct_type", "+", "'_type_diff'", "]", ",", "m", "[", "struct_type", "+", "'_exact_types'", "]", "=", "compute_mean_type_diff", "(", "structs", ",", "ref_structs", ")", "\n", "m", "[", "struct_type", "+", "'_elem_diff'", "]", ",", "m", "[", "struct_type", "+", "'_exact_elems'", "]", "=", "compute_mean_type_diff", "(", "structs", ",", "ref_structs", ",", "which", "=", "'elem'", ")", "\n", "m", "[", "struct_type", "+", "'_prop_diff'", "]", ",", "m", "[", "struct_type", "+", "'_exact_props'", "]", "=", "compute_mean_type_diff", "(", "structs", ",", "ref_structs", ",", "which", "=", "'prop'", ")", "\n", "m", "[", "struct_type", "+", "'_atom_rmsd'", "]", "=", "compute_mean_atom_rmsd", "(", "structs", ",", "ref_structs", ")", "\n", "return", "m", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.grid_to_xyz": [[18, 20], ["numpy.array"], "function", ["None"], ["def", "grid_to_xyz", "(", "gcoords", ",", "mgrid", ")", ":", "\n", "    ", "return", "mgrid", ".", "center", "+", "(", "np", ".", "array", "(", "gcoords", ")", "-", "(", "(", "mgrid", ".", "size", "-", "1", ")", "/", "2", ")", ")", "*", "mgrid", ".", "resolution", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.select_atom_starts": [[22, 73], ["G.cpu().numpy().copy", "G.cpu().numpy", "numpy.unravel_index", "range", "G.cpu().numpy().copy.argmax", "skimage.segmentation.flood_fill", "numpy.unravel_index", "masks.append", "G.cpu().numpy", "G.cpu().numpy.flatten", "float", "int", "numpy.random.choice", "dkoes_fitting.grid_to_xyz", "list", "G.cpu().numpy", "G.cpu", "G.cpu().numpy().copy.argmax", "maskedG.flatten.sum", "numpy.ceil", "range", "numpy.array", "G.cpu", "len", "maskedG.flatten.sum", "numpy.unravel_index", "G.cpu"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.unravel_index", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.unravel_index", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.grid_to_xyz", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.unravel_index"], ["", "def", "select_atom_starts", "(", "mgrid", ",", "G", ",", "radius", ")", ":", "\n", "    ", "'''Given a single channel grid and the atomic radius for that type,\n    select initial positions using a weight random selection that treats \n    each disconnected volume of density separately'''", "\n", "per_atom_volume", "=", "radius", "**", "3", "*", "(", "(", "2", "*", "np", ".", "pi", ")", "**", "1.5", ")", "\n", "\n", "mask", "=", "G", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "copy", "(", ")", "\n", "\n", "#look for islands of density greater than 0.5 (todo: parameterize this threshold?)", "\n", "#label each island in mask", "\n", "THRESHOLD", "=", "0.5", "\n", "values", "=", "G", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mask", "[", "values", ">=", "THRESHOLD", "]", "=", "1.0", "\n", "mask", "[", "values", "<", "THRESHOLD", "]", "=", "0", "\n", "\n", "maxpos", "=", "np", ".", "unravel_index", "(", "mask", ".", "argmax", "(", ")", ",", "mask", ".", "shape", ")", "\n", "masks", "=", "[", "]", "\n", "which", "=", "-", "1", "\n", "while", "mask", "[", "maxpos", "]", ">", "0", ":", "\n", "        ", "flood_fill", "(", "mask", ",", "maxpos", ",", "which", ",", "in_place", "=", "True", ")", "#identify and mark the connected region", "\n", "maxpos", "=", "np", ".", "unravel_index", "(", "mask", ".", "argmax", "(", ")", ",", "mask", ".", "shape", ")", "\n", "which", "-=", "1", "\n", "\n", "", "for", "selector", "in", "range", "(", "-", "1", ",", "which", ",", "-", "1", ")", ":", "\n", "         ", "masks", ".", "append", "(", "mask", "==", "selector", ")", "\n", "\n", "", "retcoords", "=", "[", "]", "\n", "\n", "#print(\"#masks\",len(masks))", "\n", "for", "M", "in", "masks", ":", "\n", "        ", "maskedG", "=", "G", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "maskedG", "[", "~", "M", "]", "=", "0", "\n", "flatG", "=", "maskedG", ".", "flatten", "(", ")", "\n", "total", "=", "float", "(", "flatG", ".", "sum", "(", ")", ")", "\n", "\n", "if", "total", "<", ".1", "*", "per_atom_volume", ":", "\n", "            ", "continue", "#should be very conservative given a 0.5 THRESHOLD", "\n", "", "cnt", "=", "int", "(", "np", ".", "ceil", "(", "total", "/", "per_atom_volume", ")", ")", "#pretty sure this can only underestimate", "\n", "#counting this way is especially problematic for large molecules that go to the box edge", "\n", "if", "cnt", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "flatG", "[", "flatG", ">", "1.0", "]", "=", "1.0", "\n", "rand", "=", "np", ".", "random", ".", "choice", "(", "range", "(", "len", "(", "flatG", ")", ")", ",", "cnt", ",", "False", ",", "flatG", "/", "flatG", ".", "sum", "(", ")", ")", "\n", "gcoords", "=", "np", ".", "array", "(", "np", ".", "unravel_index", "(", "rand", ",", "G", ".", "shape", ")", ")", ".", "T", "\n", "ccoords", "=", "grid_to_xyz", "(", "gcoords", ",", "mgrid", ")", "\n", "\n", "retcoords", "+=", "list", "(", "ccoords", ")", "\n", "\n", "#print(\"coords\",len(retcoords))", "\n", "", "return", "retcoords", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.simple_atom_fit": [[75, 276], ["time.time", "torch.tensor", "torch.tensor", "enumerate", "numpy.array", "numpy.array", "numpy.array", "tuple", "molgrid.Coords2Grid", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.zeros", "torch.zeros", "range", "gridder.forward.clone", "atom_structs.AtomStruct", "dkoes_fitting.select_atom_starts", "molgrid.GridMaker", "len", "atom_structs.AtomStruct", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS.step", "coords.detach().cpu.numpy", "numpy.zeros", "len", "float", "numpy.zeros", "numpy.zeros", "torch.optim.LBFGS.zero_grad", "molgrid.Coords2Grid.forward", "loss.backward", "torch.cat.detach().cpu", "torch.no_grad", "torch.no_grad", "molgrid.Coords2Grid.forward", "torch.no_grad", "torch.no_grad", "molgrid.Coords2Grid.forward", "len", "float", "float", "len", "torch.square().sum", "torch.square().sum", "len", "float", "torch.square().max", "torch.square().max", "coords[].detach().cpu().numpy", "float", "float", "float", "float", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS.step", "molgrid.Coords2Grid.forward", "float", "time.time", "torch.tensor.square().sum", "torch.tensor.numel", "time.time", "torch.optim.LBFGS.state_dict", "torch.cat.detach", "torch.square().max", "torch.square().max", "dkoes_fitting.select_atom_starts", "enumerate", "float", "diff[].sum", "diff[].sum", "diff.max", "diff.min", "int", "dkoes_fitting.grid_to_xyz", "numpy.insert", "torch.square().max", "torch.square().max", "torch.cat.detach().cpu", "np.insert.copy", "gridder.forward.clone", "torch.square", "torch.square", "torch.tensor", "torch.tensor", "torch.square", "torch.square", "coords[].detach().cpu", "numpy.unravel_index", "torch.no_grad", "torch.no_grad", "torch.tensor", "torch.tensor", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.requires_grad_", "torch.cat.requires_grad_", "torch.cat.requires_grad_", "print", "int", "int", "dkoes_fitting.grid_to_xyz", "dkoes_fitting.grid_to_xyz", "numpy.square().sum", "numpy.argmin", "torch.tensor.square", "torch.square", "torch.square", "numpy.unravel_index", "numpy.unravel_index", "torch.no_grad", "torch.no_grad", "torch.tensor", "torch.tensor", "torch.optim.LBFGS.state_dict", "torch.square", "torch.square", "torch.cat.detach", "coords[].detach", "numpy.square"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.select_atom_starts", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.select_atom_starts", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.grid_to_xyz", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.unravel_index", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.grid_to_xyz", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.grid_to_xyz", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.unravel_index", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.unravel_index"], ["", "def", "simple_atom_fit", "(", "mgrid", ",", "types", ",", "iters", "=", "10", ",", "tol", "=", "0.01", ",", "device", "=", "'cuda'", ",", "grm", "=", "-", "1.5", ")", ":", "\n", "    ", "'''Fit atoms to AtomGrid.  types are ignored as the number of \n    atoms of each type is always inferred from the density.\n    Returns the AtomGrid of the placed atoms and the AtomStruct'''", "\n", "\n", "t_start", "=", "time", ".", "time", "(", ")", "\n", "#for every channel, select some coordinates and setup the type/radius vectors", "\n", "initcoords", "=", "[", "]", "\n", "typevecs", "=", "[", "]", "\n", "radii", "=", "[", "]", "\n", "typeindices", "=", "[", "]", "\n", "numatoms", "=", "0", "\n", "tcnts", "=", "{", "}", "\n", "values", "=", "torch", ".", "tensor", "(", "mgrid", ".", "values", ",", "device", "=", "device", ")", "\n", "\n", "for", "(", "t", ",", "G", ")", "in", "enumerate", "(", "values", ")", ":", "\n", "        ", "ch", "=", "mgrid", ".", "channels", "[", "t", "]", "\n", "coords", "=", "select_atom_starts", "(", "mgrid", ",", "G", ",", "ch", ".", "atomic_radius", ")", "\n", "if", "coords", ":", "\n", "            ", "tvec", "=", "np", ".", "zeros", "(", "len", "(", "mgrid", ".", "channels", ")", ")", "\n", "tvec", "[", "t", "]", "=", "1.0", "\n", "tcnt", "=", "len", "(", "coords", ")", "\n", "numatoms", "+=", "tcnt", "\n", "\n", "r", "=", "mgrid", ".", "channels", "[", "t", "]", ".", "atomic_radius", "\n", "initcoords", "+=", "coords", "\n", "typevecs", "+=", "[", "tvec", "]", "*", "tcnt", "\n", "typeindices", "+=", "[", "t", "]", "*", "tcnt", "\n", "radii", "+=", "[", "r", "]", "*", "tcnt", "\n", "tcnts", "[", "t", "]", "=", "tcnt", "\n", "\n", "", "", "typevecs", "=", "np", ".", "array", "(", "typevecs", ")", "\n", "initcoords", "=", "np", ".", "array", "(", "initcoords", ")", "\n", "typeindices", "=", "np", ".", "array", "(", "typeindices", ")", "\n", "#print('typeindices',typeindices)", "\n", "#setup gridder", "\n", "center", "=", "tuple", "(", "[", "float", "(", "c", ")", "for", "c", "in", "mgrid", ".", "center", "]", ")", "\n", "gridder", "=", "molgrid", ".", "Coords2Grid", "(", "molgrid", ".", "GridMaker", "(", "dimension", "=", "mgrid", ".", "dimension", ",", "resolution", "=", "mgrid", ".", "resolution", ",", "\n", "gaussian_radius_multiple", "=", "grm", ")", ",", "center", "=", "center", ")", "\n", "\n", "#having setup input coordinates, optimize with BFGS", "\n", "coords", "=", "torch", ".", "tensor", "(", "initcoords", ",", "dtype", "=", "torch", ".", "float32", ",", "requires_grad", "=", "True", ",", "device", "=", "device", ")", "\n", "types", "=", "torch", ".", "tensor", "(", "typevecs", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "radii", "=", "torch", ".", "tensor", "(", "radii", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "best_loss", "=", "np", ".", "inf", "\n", "best_coords", "=", "None", "\n", "best_typeindices", "=", "typeindices", "#save in case number of atoms changes", "\n", "goodcoords", "=", "False", "\n", "bestagrid", "=", "torch", ".", "zeros", "(", "values", ".", "shape", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "\n", "if", "len", "(", "initcoords", ")", "==", "0", ":", "#no atoms", "\n", "        ", "mol", "=", "AtomStruct", "(", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ")", ",", "np", ".", "zeros", "(", "0", ")", ",", "mgrid", ".", "channels", ",", "\n", "L2_loss", "=", "values", ".", "square", "(", ")", ".", "sum", "(", ")", "/", "values", ".", "numel", "(", ")", ",", "\n", "time", "=", "time", ".", "time", "(", ")", "-", "t_start", ",", "\n", "iterations", "=", "0", ",", "\n", "numfixes", "=", "0", ",", "\n", "type_diff", "=", "0", ",", "\n", "est_type_diff", "=", "0", ",", "\n", "visited_structs", "=", "[", "]", "\n", ")", "\n", "return", "mol", ",", "bestagrid", "\n", "\n", "", "for", "inum", "in", "range", "(", "iters", ")", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "LBFGS", "(", "[", "coords", "]", ",", "max_iter", "=", "20000", ",", "tolerance_grad", "=", "1e-9", ",", "line_search_fn", "=", "'strong_wolfe'", ")", "\n", "def", "closure", "(", ")", ":", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "agrid", "=", "gridder", ".", "forward", "(", "coords", ",", "types", ",", "radii", ")", "\n", "loss", "=", "torch", ".", "square", "(", "agrid", "-", "values", ")", ".", "sum", "(", ")", "/", "numatoms", "\n", "loss", ".", "backward", "(", ")", "\n", "return", "loss", "\n", "\n", "", "optimizer", ".", "step", "(", "closure", ")", "\n", "final_loss", "=", "optimizer", ".", "state_dict", "(", ")", "[", "'state'", "]", "[", "0", "]", "[", "'prev_loss'", "]", "#todo - check for convergence?", "\n", "\n", "if", "final_loss", "<", "best_loss", ":", "\n", "            ", "best_loss", "=", "final_loss", "\n", "best_coords", "=", "coords", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "\n", "", "if", "inum", "==", "iters", "-", "1", ":", "#stick with these coordinates", "\n", "            ", "break", ";", "\n", "#otherwise, try different starting coordinates for only those", "\n", "#atom types that have errors", "\n", "", "goodcoords", "=", "True", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "offset", "=", "0", "\n", "agrid", "=", "gridder", ".", "forward", "(", "coords", ",", "types", ",", "radii", ")", "\n", "t", "=", "0", "\n", "while", "offset", "<", "len", "(", "typeindices", ")", ":", "\n", "                ", "t", "=", "typeindices", "[", "offset", "]", "\n", "#eval max error - mse will downplay a single atom of many being off", "\n", "maxerr", "=", "float", "(", "torch", ".", "square", "(", "agrid", "[", "t", "]", "-", "values", "[", "t", "]", ")", ".", "max", "(", ")", ")", "\n", "if", "maxerr", ">", "tol", ":", "\n", "                    ", "goodcoords", "=", "False", "\n", "ch", "=", "mgrid", ".", "channels", "[", "t", "]", "\n", "newcoords", "=", "select_atom_starts", "(", "mgrid", ",", "values", "[", "t", "]", ",", "ch", ".", "atomic_radius", ")", "\n", "for", "(", "i", ",", "coord", ")", "in", "enumerate", "(", "newcoords", ")", ":", "\n", "                        ", "coords", "[", "i", "+", "offset", "]", "=", "torch", ".", "tensor", "(", "coord", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "", "", "offset", "+=", "tcnts", "[", "t", "]", "\n", "", "", "if", "goodcoords", ":", "\n", "            ", "break", "\n", "", "", "bestagrid", "=", "agrid", ".", "clone", "(", ")", "\n", "numfixes", "=", "0", "\n", "if", "not", "goodcoords", ":", "\n", "#try to fix up an atom at a time", "\n", "        ", "offset", "=", "0", "\n", "#reset corods to best found so far", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "coords", "[", ":", "]", "=", "best_coords", "\n", "agrid", "=", "gridder", ".", "forward", "(", "coords", ",", "types", ",", "radii", ")", "\n", "", "t", "=", "0", "\n", "while", "offset", "<", "len", "(", "typeindices", ")", ":", "\n", "            ", "t", "=", "typeindices", "[", "offset", "]", "\n", "maxerr", "=", "float", "(", "torch", ".", "square", "(", "agrid", "[", "t", "]", "-", "values", "[", "t", "]", ")", ".", "max", "(", ")", ")", "\n", "#print('maxerr',maxerr)", "\n", "per_atom_volume", "=", "float", "(", "radii", "[", "offset", "]", ")", "**", "3", "*", "(", "(", "2", "*", "np", ".", "pi", ")", "**", "1.5", ")", "\n", "while", "maxerr", ">", "tol", ":", "\n", "#identify the atom of this type closest to the place with too much density", "\n", "#and move it to the location with too little density", "\n", "                ", "tcoords", "=", "coords", "[", "offset", ":", "offset", "+", "tcnts", "[", "t", "]", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "#coordinates for this type", "\n", "\n", "diff", "=", "agrid", "[", "t", "]", "-", "values", "[", "t", "]", "\n", "possum", "=", "float", "(", "diff", "[", "diff", ">", "0", "]", ".", "sum", "(", ")", ")", "\n", "negsum", "=", "float", "(", "diff", "[", "diff", "<", "0", "]", ".", "sum", "(", ")", ")", "\n", "maxdiff", "=", "float", "(", "diff", ".", "max", "(", ")", ")", "\n", "mindiff", "=", "float", "(", "diff", ".", "min", "(", ")", ")", "\n", "missing_density", "=", "-", "(", "negsum", "+", "possum", ")", "\n", "#print('Type %d numcoords %d maxdiff %.5f mindiff %.5f missing %.5f'%(t,len(tcoords),maxdiff,mindiff,missing_density))", "\n", "if", "missing_density", ">", ".25", "*", "per_atom_volume", ":", "#add atom  MAGIC NUMBER ALERT", "\n", "#needs to be enough total missing density to be close to a whole atom,", "\n", "#but the missing density also needs to be somewhat concentrated", "\n", "#print(\"Missing density - not enough atoms?\")", "\n", "                    ", "numfixes", "+=", "1", "\n", "minpos", "=", "int", "(", "(", "agrid", "[", "t", "]", "-", "values", "[", "t", "]", ")", ".", "argmin", "(", ")", ")", "\n", "minpos", "=", "grid_to_xyz", "(", "np", ".", "unravel_index", "(", "minpos", ",", "agrid", "[", "t", "]", ".", "shape", ")", ",", "mgrid", ")", "\n", "#add atom: change coords, types, radii, typeindices and tcnts, numatoms", "\n", "numatoms", "+=", "1", "\n", "typeindices", "=", "np", ".", "insert", "(", "typeindices", ",", "offset", ",", "t", ")", "\n", "tcnts", "[", "t", "]", "+=", "1", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "newcoord", "=", "torch", ".", "tensor", "(", "[", "minpos", "]", ",", "device", "=", "coords", ".", "device", ",", "dtype", "=", "coords", ".", "dtype", ",", "requires_grad", "=", "True", ")", "\n", "coords", "=", "torch", ".", "cat", "(", "(", "coords", "[", ":", "offset", "]", ",", "newcoord", ",", "coords", "[", "offset", ":", "]", ")", ")", "\n", "radii", "=", "torch", ".", "cat", "(", "(", "radii", "[", ":", "offset", "]", ",", "radii", "[", "offset", ":", "offset", "+", "1", "]", ",", "radii", "[", "offset", ":", "]", ")", ")", "\n", "types", "=", "torch", ".", "cat", "(", "(", "types", "[", ":", "offset", "]", ",", "types", "[", "offset", ":", "offset", "+", "1", "]", ",", "types", "[", "offset", ":", "]", ")", ")", "\n", "\n", "coords", ".", "requires_grad_", "(", "True", ")", "\n", "radii", ".", "requires_grad_", "(", "True", ")", "\n", "types", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "", "elif", "missing_density", "<", "-", ".75", "*", "per_atom_volume", ":", "\n", "                    ", "print", "(", "\"Too many atoms?\"", ")", "\n", "break", "\n", "#todo, remove atom", "\n", "", "else", ":", "#move an atom", "\n", "                    ", "numfixes", "+=", "1", "\n", "maxpos", "=", "int", "(", "(", "agrid", "[", "t", "]", "-", "values", "[", "t", "]", ")", ".", "argmax", "(", ")", ")", "\n", "minpos", "=", "int", "(", "(", "agrid", "[", "t", "]", "-", "values", "[", "t", "]", ")", ".", "argmin", "(", ")", ")", "\n", "maxpos", "=", "grid_to_xyz", "(", "np", ".", "unravel_index", "(", "maxpos", ",", "agrid", "[", "t", "]", ".", "shape", ")", ",", "mgrid", ")", "\n", "minpos", "=", "grid_to_xyz", "(", "np", ".", "unravel_index", "(", "minpos", ",", "agrid", "[", "t", "]", ".", "shape", ")", ",", "mgrid", ")", "\n", "\n", "dists", "=", "np", ".", "square", "(", "tcoords", "-", "maxpos", ")", ".", "sum", "(", "axis", "=", "1", ")", "\n", "closesti", "=", "np", ".", "argmin", "(", "dists", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "coords", "[", "offset", "+", "closesti", "]", "=", "torch", ".", "tensor", "(", "minpos", ")", "\n", "\n", "#reoptimize", "\n", "", "", "optimizer", "=", "torch", ".", "optim", ".", "LBFGS", "(", "[", "coords", "]", ",", "max_iter", "=", "20000", ",", "tolerance_grad", "=", "1e-9", ",", "line_search_fn", "=", "'strong_wolfe'", ")", "\n", "#TODO: only optimize this grid", "\n", "optimizer", ".", "step", "(", "closure", ")", "\n", "final_loss", "=", "optimizer", ".", "state_dict", "(", ")", "[", "'state'", "]", "[", "0", "]", "[", "'prev_loss'", "]", "#todo - check for convergence?", "\n", "agrid", "=", "gridder", ".", "forward", "(", "coords", ",", "types", ",", "radii", ")", "#recompute grid", "\n", "\n", "#if maxerr hasn't improved, give up", "\n", "newerr", "=", "float", "(", "torch", ".", "square", "(", "agrid", "[", "t", "]", "-", "values", "[", "t", "]", ")", ".", "max", "(", ")", ")", "\n", "#print(t,'newerr',newerr,'maxerr',maxerr,'maxdiff',maxdiff,'mindiff',mindiff,'missing',missing_density)", "\n", "if", "newerr", ">=", "maxerr", ":", "\n", "#don't give up if there's still a lot left to fit", "\n", "#and the missing density isn't all (very) shallow", "\n", "                    ", "if", "missing_density", "<", "per_atom_volume", "or", "mindiff", ">", "-", "0.1", ":", "#magic number! ", "\n", "                        ", "break", "\n", "", "", "else", ":", "\n", "                    ", "maxerr", "=", "newerr", "\n", "best_loss", "=", "final_loss", "\n", "best_coords", "=", "coords", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "best_typeindices", "=", "typeindices", ".", "copy", "(", ")", "\n", "bestagrid", "=", "agrid", ".", "clone", "(", ")", "\n", "\n", "#otherwise update coordinates and repeat", "\n", "\n", "", "", "offset", "+=", "tcnts", "[", "t", "]", "\n", "\n", "#create struct from coordinates", "\n", "", "", "mol", "=", "AtomStruct", "(", "best_coords", ".", "numpy", "(", ")", ",", "best_typeindices", ",", "mgrid", ".", "channels", ",", "\n", "L2_loss", "=", "float", "(", "best_loss", ")", ",", "\n", "time", "=", "time", ".", "time", "(", ")", "-", "t_start", ",", "\n", "iterations", "=", "inum", ",", "\n", "numfixes", "=", "numfixes", ",", "\n", "type_diff", "=", "0", ",", "\n", "est_type_diff", "=", "0", ",", "\n", "visited_structs", "=", "[", "]", ")", "\n", "# print('losses',final_loss,best_loss,len(best_coords))", "\n", "return", "mol", ",", "bestagrid", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGridder.__init__": [[11, 14], ["molgrid.GridMaker", "molgrid.Coords2Grid.__init__"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "self", ",", "resolution", "=", "0.5", ",", "dimension", "=", "23.5", ")", ":", "\n", "        ", "gmaker", "=", "molgrid", ".", "GridMaker", "(", "resolution", ",", "dimension", ",", "gaussian_radius_multiple", "=", "-", "1.5", ")", "\n", "super", "(", ")", ".", "__init__", "(", "gmaker", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGridder.resolution": [[15, 18], ["atom_grids.AtomGridder.gmaker.get_resolution"], "methods", ["None"], ["", "@", "property", "\n", "def", "resolution", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "gmaker", ".", "get_resolution", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGridder.forward": [[19, 25], ["tuple", "super().forward", "atom_grids.AtomGrid", "float"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "forward", "(", "self", ",", "struct", ")", ":", "\n", "        ", "self", ".", "center", "=", "tuple", "(", "float", "(", "v", ")", "for", "v", "in", "struct", ".", "center", ")", "\n", "values", "=", "super", "(", ")", ".", "forward", "(", "\n", "struct", ".", "coords", ",", "struct", ".", "types", ",", "struct", ".", "atomic_radii", "\n", ")", "\n", "return", "AtomGrid", "(", "values", ",", "struct", ".", "center", ",", "self", ".", "resolution", ",", "struct", ".", "typer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.__init__": [[35, 51], ["atom_grids.AtomGrid.check_shapes", "torch.as_tensor", "torch.as_tensor", "float"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.check_shapes"], ["def", "__init__", "(", "\n", "self", ",", "\n", "values", ",", "\n", "center", ",", "\n", "resolution", ",", "\n", "typer", ",", "\n", "dtype", "=", "None", ",", "\n", "device", "=", "None", ",", "\n", "**", "info", "\n", ")", ":", "\n", "        ", "self", ".", "check_shapes", "(", "values", ",", "center", ",", "typer", ")", "\n", "self", ".", "values", "=", "torch", ".", "as_tensor", "(", "values", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "self", ".", "center", "=", "torch", ".", "as_tensor", "(", "center", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "self", ".", "resolution", "=", "float", "(", "resolution", ")", "\n", "self", ".", "typer", "=", "typer", "\n", "self", ".", "info", "=", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.check_shapes": [[52, 58], ["len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "check_shapes", "(", "values", ",", "center", ",", "typer", ")", ":", "\n", "        ", "assert", "len", "(", "values", ".", "shape", ")", "==", "4", ",", "values", ".", "shape", "\n", "assert", "values", ".", "shape", "[", "0", "]", "==", "typer", ".", "n_types", ",", "(", "values", ".", "shape", "[", "0", "]", ",", "typer", ".", "n_types", ")", "\n", "assert", "values", ".", "shape", "[", "1", "]", "==", "values", ".", "shape", "[", "2", "]", "==", "values", ".", "shape", "[", "3", "]", ",", "values", ".", "shape", "[", "1", ":", "]", "\n", "assert", "center", ".", "shape", "==", "(", "3", ",", ")", ",", "center", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.from_dx": [[59, 64], ["atom_grids.read_grid_from_dx_files", "cls"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.read_grid_from_dx_files"], ["", "@", "classmethod", "\n", "def", "from_dx", "(", "cls", ",", "dx_prefix", ",", "typer", ",", "dtype", "=", "None", ",", "device", "=", "None", ",", "**", "info", ")", ":", "\n", "        ", "values", ",", "center", ",", "resolution", "=", "read_grid_from_dx_files", "(", "dx_prefix", ",", "typer", ")", "\n", "return", "cls", "(", "\n", "values", ",", "center", ",", "resolution", ",", "typer", ",", "dtype", ",", "device", ",", "**", "info", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.shape": [[66, 69], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "values", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.n_channels": [[70, 73], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_channels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "values", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.size": [[74, 77], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "values", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.dimension": [[78, 81], ["atom_grids.size_to_dimension"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.size_to_dimension"], ["", "@", "property", "\n", "def", "dimension", "(", "self", ")", ":", "\n", "        ", "return", "size_to_dimension", "(", "self", ".", "size", ",", "self", ".", "resolution", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.origin": [[82, 85], ["atom_grids.center_to_origin"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.center_to_origin"], ["", "@", "property", "\n", "def", "origin", "(", "self", ")", ":", "\n", "        ", "return", "center_to_origin", "(", "self", ".", "center", ",", "self", ".", "size", ",", "self", ".", "resolution", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.n_elem_channels": [[86, 89], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_elem_channels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "typer", ".", "n_elem_types", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.n_prop_channels": [[90, 93], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_prop_channels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_channels", "-", "self", ".", "n_elem_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.elem_values": [[94, 97], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "elem_values", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "values", "[", ":", "self", ".", "n_elem_channels", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.prop_values": [[98, 101], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "prop_values", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "values", "[", "self", ".", "n_elem_channels", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.dtype": [[102, 105], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "values", ".", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.device": [[106, 109], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "values", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to": [[110, 112], ["atom_grids.AtomGrid.new_like"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.new_like"], ["", "def", "to", "(", "self", ",", "device", ",", "dtype", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "new_like", "(", "values", "=", "self", ".", "values", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to_dx": [[113, 120], ["atom_grids.write_grid_to_dx_files", "atom_grids.AtomGrid.values.to", "atom_grids.AtomGrid.center.cpu().numpy", "atom_grids.AtomGrid.center.cpu"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.write_grid_to_dx_files", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["", "def", "to_dx", "(", "self", ",", "dx_prefix", ",", "center", "=", "None", ")", ":", "\n", "        ", "return", "write_grid_to_dx_files", "(", "\n", "dx_prefix", "=", "dx_prefix", ",", "\n", "values", "=", "self", ".", "values", ".", "to", "(", "'cpu'", ",", "dtype", "=", "torch", ".", "float64", ")", ",", "\n", "center", "=", "self", ".", "center", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "if", "center", "is", "None", "else", "center", ",", "\n", "resolution", "=", "self", ".", "resolution", ",", "\n", "typer", "=", "self", ".", "typer", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.new_like": [[122, 134], ["atom_grids.AtomGrid"], "methods", ["None"], ["", "def", "new_like", "(", "self", ",", "values", ",", "dtype", "=", "None", ",", "device", "=", "None", ",", "**", "info", ")", ":", "\n", "        ", "'''\n        Return an AtomGrid with the same grid settings but new values.\n        '''", "\n", "return", "AtomGrid", "(", "\n", "values", "=", "values", ",", "\n", "center", "=", "self", ".", "center", ",", "\n", "resolution", "=", "self", ".", "resolution", ",", "\n", "typer", "=", "self", ".", "typer", ",", "\n", "dtype", "=", "self", ".", "dtype", "if", "dtype", "is", "None", "else", "dtype", ",", "\n", "device", "=", "self", ".", "device", "if", "device", "is", "None", "else", "device", ",", "\n", "**", "info", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.get_coords": [[136, 147], ["atom_grids.spatial_index_to_coords"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.spatial_index_to_coords"], ["", "def", "get_coords", "(", "self", ",", "idx_xyz", ")", ":", "\n", "        ", "'''\n        Return the 3D coordinates located\n        at each of the provided (x,y,z)\n        spatial indices of the grid.\n        '''", "\n", "return", "spatial_index_to_coords", "(", "\n", "idx_xyz", ",", "\n", "self", ".", "center", ",", "\n", "self", ".", "size", ",", "\n", "self", ".", "resolution", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.center_to_origin": [[150, 157], ["None"], "function", ["None"], ["", "", "def", "center_to_origin", "(", "center", ",", "size", ",", "resolution", ")", ":", "\n", "    ", "'''\n    Compute the coordinates of the origin of\n    a grid with the provided center, size,\n    and resolution.\n    '''", "\n", "return", "center", "-", "resolution", "*", "(", "size", "-", "1", ")", "/", "2.0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.unravel_index": [[159, 165], ["torch.stack", "ret.append"], "function", ["None"], ["", "def", "unravel_index", "(", "idx", ",", "shape", ")", ":", "\n", "    ", "ret", "=", "[", "]", "\n", "for", "dim", "in", "shape", ":", "\n", "        ", "ret", ".", "append", "(", "idx", "%", "dim", ")", "\n", "idx", "=", "idx", "//", "dim", "\n", "", "return", "torch", ".", "stack", "(", "ret", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.spatial_index_to_coords": [[167, 175], ["atom_grids.center_to_origin", "idx_xyz.float"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.center_to_origin"], ["", "def", "spatial_index_to_coords", "(", "idx_xyz", ",", "center", ",", "size", ",", "resolution", ")", ":", "\n", "    ", "'''\n    Compute 3D coordinates located at each of\n    the provided (x,y,z) spatial indices of a\n    grid with center, size, and resolution.\n    '''", "\n", "origin", "=", "center_to_origin", "(", "center", ",", "size", ",", "resolution", ")", "\n", "return", "origin", "+", "resolution", "*", "idx_xyz", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.size_to_dimension": [[177, 184], ["None"], "function", ["None"], ["", "def", "size_to_dimension", "(", "size", ",", "resolution", ")", ":", "\n", "    ", "'''\n    Compute the side length of a cubic grid with\n    the given size (num. points along each axis)\n    and resolution.\n    '''", "\n", "return", "(", "size", "-", "1", ")", "*", "resolution", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.dimension_to_size": [[186, 193], ["int", "numpy.ceil"], "function", ["None"], ["", "def", "dimension_to_size", "(", "dimension", ",", "resolution", ")", ":", "\n", "    ", "'''\n    Compute the number of points along each axis\n    of a cubic grid spanning the given dimension\n    (side length) at the given resolution.\n    '''", "\n", "return", "int", "(", "np", ".", "ceil", "(", "dimension", "/", "resolution", "+", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.round_dimension": [[195, 204], ["atom_grids.size_to_dimension", "atom_grids.dimension_to_size"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.size_to_dimension", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.dimension_to_size"], ["", "def", "round_dimension", "(", "dimension", ",", "resolution", ")", ":", "\n", "    ", "'''\n    Return the actual dimension of a grid\n    with the provided resolution that fits\n    the provided dimension within it.\n    '''", "\n", "return", "size_to_dimension", "(", "\n", "dimension_to_size", "(", "dimension", ",", "resolution", ")", ",", "\n", "resolution", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.write_grid_to_dx_file": [[207, 251], ["range", "len", "len", "numpy.array", "range", "lines.append", "open", "f.write", "range", "lines.append"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write"], ["", "def", "write_grid_to_dx_file", "(", "dx_file", ",", "values", ",", "center", ",", "resolution", ")", ":", "\n", "    ", "'''\n    Write a grid with the provided values,\n    center, and resolution to a .dx file.\n    '''", "\n", "assert", "len", "(", "values", ".", "shape", ")", "==", "3", "\n", "assert", "values", ".", "shape", "[", "0", "]", "==", "values", ".", "shape", "[", "1", "]", "==", "values", ".", "shape", "[", "2", "]", "\n", "assert", "len", "(", "center", ")", "==", "3", "\n", "\n", "size", "=", "values", ".", "shape", "[", "0", "]", "\n", "origin", "=", "np", ".", "array", "(", "center", ")", "-", "resolution", "*", "(", "size", "-", "1", ")", "/", "2.", "\n", "\n", "lines", "=", "[", "\n", "'object 1 class gridpositions counts {:d} {:d} {:d}\\n'", ".", "format", "(", "\n", "size", ",", "size", ",", "size", "\n", ")", ",", "\n", "'origin {:.5f} {:.5f} {:.5f}\\n'", ".", "format", "(", "*", "origin", ")", ",", "\n", "'delta {:.5f} 0 0\\n'", ".", "format", "(", "resolution", ")", ",", "\n", "'delta 0 {:.5f} 0\\n'", ".", "format", "(", "resolution", ")", ",", "\n", "'delta 0 0 {:.5f}\\n'", ".", "format", "(", "resolution", ")", ",", "\n", "'object 2 class gridconnections counts {:d} {:d} {:d}\\n'", ".", "format", "(", "\n", "size", ",", "size", ",", "size", "\n", ")", ",", "\n", "'object 3 class array type double rank 0 items '", "+", "'[ {:d} ] data follows\\n'", ".", "format", "(", "size", "**", "3", ")", ",", "\n", "]", "\n", "n_points", "=", "0", "\n", "line", "=", "''", "\n", "for", "i", "in", "range", "(", "size", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "size", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "size", ")", ":", "\n", "                ", "line", "+=", "'{:.10f}'", ".", "format", "(", "values", "[", "i", "]", "[", "j", "]", "[", "k", "]", ")", "\n", "n_points", "+=", "1", "\n", "if", "n_points", "%", "3", "==", "0", ":", "\n", "                    ", "lines", ".", "append", "(", "line", "+", "'\\n'", ")", "\n", "line", "=", "''", "\n", "", "else", ":", "\n", "                    ", "line", "+=", "' '", "\n", "\n", "", "", "", "", "if", "line", ":", "# if n_points is not divisible by 3, need last line", "\n", "        ", "lines", ".", "append", "(", "line", ")", "\n", "\n", "", "with", "open", "(", "dx_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "''", ".", "join", "(", "lines", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.write_grid_to_dx_files": [[253, 266], ["enumerate", "typer.get_type_names", "atom_grids.write_grid_to_dx_file", "dx_files.append"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_names", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.write_grid_to_dx_file"], ["", "", "def", "write_grid_to_dx_files", "(", "dx_prefix", ",", "values", ",", "center", ",", "resolution", ",", "typer", ")", ":", "\n", "    ", "'''\n    Write each a multi-channel grid with the provided\n    values, center, and resolution to .dx files, using\n    the prefix and type names.\n    '''", "\n", "assert", "values", ".", "shape", "[", "0", "]", "==", "typer", ".", "n_types", "\n", "dx_files", "=", "[", "]", "\n", "for", "i", ",", "type_name", "in", "enumerate", "(", "typer", ".", "get_type_names", "(", ")", ")", ":", "\n", "        ", "dx_file", "=", "'{}_{}.dx'", ".", "format", "(", "dx_prefix", ",", "type_name", ")", "\n", "write_grid_to_dx_file", "(", "dx_file", ",", "values", "[", "i", "]", ",", "center", ",", "resolution", ")", "\n", "dx_files", ".", "append", "(", "dx_file", ")", "\n", "", "return", "dx_files", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.parse_vector": [[268, 271], ["numpy.array", "line.rstrip().rsplit", "line.rstrip"], "function", ["None"], ["", "def", "parse_vector", "(", "line", ",", "dtype", ",", "n", "=", "3", ",", "delim", "=", "' '", ")", ":", "\n", "    ", "fields", "=", "line", ".", "rstrip", "(", ")", ".", "rsplit", "(", "delim", ",", "n", ")", "[", "-", "n", ":", "]", "\n", "return", "np", ".", "array", "(", "fields", ",", "dtype", "=", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.read_grid_from_dx_file": [[273, 298], ["atom_grids.parse_vector", "atom_grids.parse_vector", "atom_grids.parse_vector", "atom_grids.parse_vector", "atom_grids.parse_vector", "open", "f.readlines", "values.extend", "len", "numpy.array().reshape", "atom_grids.parse_vector", "numpy.array"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.parse_vector", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.parse_vector", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.parse_vector", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.parse_vector", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.parse_vector", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.parse_vector"], ["", "def", "read_grid_from_dx_file", "(", "dx_file", ")", ":", "\n", "\n", "    ", "with", "open", "(", "dx_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "shape", "=", "parse_vector", "(", "lines", "[", "0", "]", ",", "dtype", "=", "int", ")", "\n", "assert", "shape", "[", "0", "]", "==", "shape", "[", "1", "]", "==", "shape", "[", "2", "]", "\n", "size", "=", "shape", "[", "0", "]", "\n", "\n", "origin", "=", "parse_vector", "(", "lines", "[", "1", "]", ",", "dtype", "=", "float", ")", "\n", "\n", "delta0", "=", "parse_vector", "(", "lines", "[", "2", "]", ",", "dtype", "=", "float", ")", "\n", "delta1", "=", "parse_vector", "(", "lines", "[", "3", "]", ",", "dtype", "=", "float", ")", "\n", "delta2", "=", "parse_vector", "(", "lines", "[", "4", "]", ",", "dtype", "=", "float", ")", "\n", "assert", "delta0", "[", "0", "]", "==", "delta1", "[", "1", "]", "==", "delta2", "[", "2", "]", "\n", "resolution", "=", "delta0", "[", "0", "]", "\n", "\n", "center", "=", "origin", "+", "resolution", "*", "(", "size", "-", "1", ")", "/", "2", "\n", "\n", "values", "=", "[", "]", "\n", "for", "line", "in", "lines", "[", "7", ":", "]", ":", "\n", "        ", "values", ".", "extend", "(", "parse_vector", "(", "line", ",", "dtype", "=", "float", ")", ")", "\n", "\n", "", "assert", "len", "(", "values", ")", "==", "size", "**", "3", "\n", "return", "np", ".", "array", "(", "values", ")", ".", "reshape", "(", "*", "shape", ")", ",", "center", ",", "resolution", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.read_grid_from_dx_files": [[300, 312], ["enumerate", "typer.get_type_names", "atom_grids.read_grid_from_dx_file", "values.append", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_names", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.read_grid_from_dx_file"], ["", "def", "read_grid_from_dx_files", "(", "dx_prefix", ",", "typer", ")", ":", "\n", "    ", "values", "=", "[", "]", "\n", "for", "i", ",", "type_name", "in", "enumerate", "(", "typer", ".", "get_type_names", "(", ")", ")", ":", "\n", "        ", "dx_file", "=", "'{}_{}.dx'", ".", "format", "(", "dx_prefix", ",", "type_name", ")", "\n", "values_i", ",", "center_i", ",", "resolution_i", "=", "read_grid_from_dx_file", "(", "dx_file", ")", "\n", "values", ".", "append", "(", "values_i", ")", "\n", "if", "i", "==", "0", ":", "\n", "            ", "center", ",", "resolution", "=", "center_i", ",", "resolution_i", "\n", "", "else", ":", "\n", "            ", "assert", "center_i", "==", "center", "\n", "assert", "resolution_i", "==", "resolution", "\n", "", "", "return", "np", ".", "stack", "(", "values", ")", ",", "center", ",", "resolution", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.__init__": [[15, 49], ["super().__init__", "pandas.read_csv", "openbabel.openbabel.openbabel.OBConversion", "openbabel.openbabel.OBConversion.SetInFormat", "openbabel.openbabel.openbabel.OBConversion", "openbabel.openbabel.OBConversion.SetInFormat", "dict"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "rec_typer", ",", "lig_typer", ",", "data_file", ",", "data_root", ",", "verbose", "=", "False", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# what is this unknown column?", "\n", "#  it's positive for low_rmsd, negative for ~low_rmsd,", "\n", "#  but otherwise same absolute distributions...", "\n", "data_cols", "=", "[", "\n", "'low_rmsd'", ",", "\n", "'true_aff'", ",", "\n", "'xtal_rmsd'", ",", "\n", "'rec_src'", ",", "\n", "'lig_src'", ",", "\n", "'vina_aff'", "\n", "]", "\n", "self", ".", "data", "=", "pd", ".", "read_csv", "(", "\n", "data_file", ",", "sep", "=", "' '", ",", "names", "=", "data_cols", ",", "index_col", "=", "False", "\n", ")", "\n", "self", ".", "root_dir", "=", "data_root", "\n", "\n", "ob_conv", "=", "ob", ".", "OBConversion", "(", ")", "\n", "ob_conv", ".", "SetInFormat", "(", "'pdb'", ")", "\n", "self", ".", "read_pdb", "=", "ob_conv", ".", "ReadFile", "\n", "\n", "ob_conv", "=", "ob", ".", "OBConversion", "(", ")", "\n", "ob_conv", ".", "SetInFormat", "(", "'sdf'", ")", "\n", "self", ".", "read_sdf", "=", "ob_conv", ".", "ReadFile", "\n", "\n", "self", ".", "mol_cache", "=", "dict", "(", ")", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "rec_typer", "=", "rec_typer", "\n", "self", ".", "lig_typer", "=", "lig_typer", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.read_mol": [[50, 69], ["os.path.join", "os.path.isfile", "openbabel.openbabel.openbabel.OBMol", "openbabel.openbabel.OBMol.AddHydrogens", "openbabel.openbabel.OBMol.SetTitle", "print", "data.MolDataset.read_pdb", "data.MolDataset.read_sdf", "openbabel.openbabel.OBMol.NumAtoms"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "read_mol", "(", "self", ",", "mol_src", ",", "pdb", "=", "False", ")", ":", "\n", "\n", "        ", "mol_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root_dir", ",", "mol_src", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Reading '", "+", "mol_file", ")", "\n", "\n", "", "assert", "os", ".", "path", ".", "isfile", "(", "mol_file", ")", ",", "'file does not exist'", "\n", "\n", "mol", "=", "ob", ".", "OBMol", "(", ")", "\n", "if", "pdb", ":", "\n", "            ", "assert", "self", ".", "read_pdb", "(", "mol", ",", "mol_file", ")", ",", "'failed to read mol'", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "read_sdf", "(", "mol", ",", "mol_file", ")", ",", "'failed to read mol'", "\n", "\n", "", "mol", ".", "AddHydrogens", "(", ")", "\n", "assert", "mol", ".", "NumAtoms", "(", ")", ">", "0", ",", "'mol has zero atoms'", "\n", "\n", "mol", ".", "SetTitle", "(", "mol_src", ")", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.get_rec_mol": [[70, 74], ["data.MolDataset.read_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.read_mol"], ["", "def", "get_rec_mol", "(", "self", ",", "mol_src", ")", ":", "\n", "        ", "if", "mol_src", "not", "in", "self", ".", "mol_cache", ":", "\n", "            ", "self", ".", "mol_cache", "[", "mol_src", "]", "=", "self", ".", "read_mol", "(", "mol_src", ",", "pdb", "=", "True", ")", "\n", "", "return", "self", ".", "mol_cache", "[", "mol_src", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.get_lig_mol": [[75, 79], ["data.MolDataset.read_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.read_mol"], ["", "def", "get_lig_mol", "(", "self", ",", "mol_src", ")", ":", "\n", "        ", "if", "mol_src", "not", "in", "self", ".", "mol_cache", ":", "\n", "            ", "self", ".", "mol_cache", "[", "mol_src", "]", "=", "self", ".", "read_mol", "(", "mol_src", ",", "pdb", "=", "False", ")", "\n", "", "return", "self", ".", "mol_cache", "[", "mol_src", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.__len__": [[80, 82], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.__getitem__": [[83, 88], ["data.MolDataset.get_rec_mol", "data.MolDataset.get_lig_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.get_rec_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.get_lig_mol"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "example", "=", "self", ".", "data", ".", "iloc", "[", "idx", "]", "\n", "rec_mol", "=", "self", ".", "get_rec_mol", "(", "example", ".", "rec_src", ")", "\n", "lig_mol", "=", "self", ".", "get_lig_mol", "(", "example", ".", "lig_src", ")", "\n", "return", "rec_mol", ",", "lig_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.__iter__": [[89, 94], ["zip", "data.MolDataset.get_rec_mol", "data.MolDataset.get_lig_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.get_rec_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.MolDataset.get_lig_mol"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "rec_src", ",", "lig_src", "in", "zip", "(", "self", ".", "data", ".", "rec_src", ",", "self", ".", "data", ".", "lig_src", ")", ":", "\n", "            ", "rec_mol", "=", "self", ".", "get_rec_mol", "(", "rec_src", ")", "\n", "lig_mol", "=", "self", ".", "get_lig_mol", "(", "lig_src", ")", "\n", "yield", "rec_mol", ",", "lig_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.__init__": [[98, 169], ["object.__init__", "atom_types.AtomTyper.get_typer", "atom_types.AtomTyper.get_typer", "molgrid.ExampleProvider", "molgrid.GridMaker", "interpolation.TransformInterpolation", "data.AtomGridData.ex_provider.populate", "atom_grids.size_to_dimension", "lig_typer.split", "rec_typer.split"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.size_to_dimension"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "data_file", ",", "\n", "data_root", ",", "\n", "batch_size", ",", "\n", "rec_typer", ",", "\n", "lig_typer", ",", "\n", "use_rec_elems", "=", "True", ",", "\n", "resolution", "=", "0.5", ",", "\n", "dimension", "=", "None", ",", "\n", "grid_size", "=", "None", ",", "\n", "shuffle", "=", "False", ",", "\n", "random_rotation", "=", "False", ",", "\n", "random_translation", "=", "0.0", ",", "\n", "diff_cond_transform", "=", "False", ",", "\n", "diff_cond_structs", "=", "False", ",", "\n", "n_samples", "=", "1", ",", "\n", "rec_molcache", "=", "None", ",", "\n", "lig_molcache", "=", "None", ",", "\n", "cache_structs", "=", "True", ",", "\n", "device", "=", "'cuda'", ",", "\n", "debug", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "(", "dimension", "or", "grid_size", ")", "and", "not", "(", "dimension", "and", "grid_size", ")", ",", "'must specify one of either dimension or grid_size'", "\n", "if", "grid_size", ":", "\n", "            ", "dimension", "=", "atom_grids", ".", "size_to_dimension", "(", "grid_size", ",", "resolution", ")", "\n", "\n", "# create receptor and ligand atom typers", "\n", "", "self", ".", "lig_typer", "=", "AtomTyper", ".", "get_typer", "(", "*", "lig_typer", ".", "split", "(", "'-'", ")", ",", "rec", "=", "False", ")", "\n", "self", ".", "rec_typer", "=", "AtomTyper", ".", "get_typer", "(", "*", "rec_typer", ".", "split", "(", "'-'", ")", ",", "rec", "=", "use_rec_elems", ")", "\n", "\n", "atom_typers", "=", "[", "self", ".", "rec_typer", ",", "self", ".", "lig_typer", "]", "\n", "if", "diff_cond_structs", ":", "# duplicate atom typers", "\n", "            ", "atom_typers", "*=", "2", "\n", "\n", "# create example provider", "\n", "", "self", ".", "ex_provider", "=", "molgrid", ".", "ExampleProvider", "(", "\n", "*", "atom_typers", ",", "\n", "data_root", "=", "data_root", ",", "\n", "recmolcache", "=", "rec_molcache", "or", "''", ",", "\n", "ligmolcache", "=", "lig_molcache", "or", "''", ",", "\n", "cache_structs", "=", "cache_structs", ",", "\n", "shuffle", "=", "shuffle", ",", "\n", "num_copies", "=", "n_samples", ",", "\n", ")", "\n", "\n", "# create molgrid maker", "\n", "self", ".", "grid_maker", "=", "molgrid", ".", "GridMaker", "(", "\n", "resolution", "=", "resolution", ",", "\n", "dimension", "=", "dimension", ",", "\n", "gaussian_radius_multiple", "=", "-", "1.5", ",", "\n", ")", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "# transformation settings", "\n", "self", ".", "random_rotation", "=", "random_rotation", "\n", "self", ".", "random_translation", "=", "random_translation", "\n", "self", ".", "diff_cond_transform", "=", "diff_cond_transform", "\n", "self", ".", "diff_cond_structs", "=", "diff_cond_structs", "\n", "self", ".", "debug", "=", "debug", "\n", "self", ".", "device", "=", "device", "\n", "\n", "# transform interpolation state", "\n", "self", ".", "cond_interp", "=", "TransformInterpolation", "(", "n_samples", "=", "n_samples", ")", "\n", "\n", "# load data from file", "\n", "self", ".", "ex_provider", ".", "populate", "(", "data_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.from_param": [[170, 187], ["cls", "atom_grids.dimension_to_size"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.dimension_to_size"], ["", "@", "classmethod", "\n", "def", "from_param", "(", "cls", ",", "param", ")", ":", "\n", "\n", "        ", "return", "cls", "(", "\n", "data_root", "=", "param", ".", "root_folder", ",", "\n", "batch_size", "=", "param", ".", "batch_size", ",", "\n", "rec_typer", "=", "param", ".", "recmap", ",", "\n", "lig_typer", "=", "param", ".", "ligmap", ",", "\n", "resolution", "=", "param", ".", "resolution", ",", "\n", "grid_size", "=", "atom_grids", ".", "dimension_to_size", "(", "\n", "param", ".", "dimension", ",", "param", ".", "resolution", "\n", ")", ",", "\n", "shuffle", "=", "param", ".", "shuffle", ",", "\n", "random_rotation", "=", "param", ".", "random_rotation", ",", "\n", "random_translation", "=", "param", ".", "random_translate", ",", "\n", "rec_molcache", "=", "param", ".", "recmolcache", ",", "\n", "lig_molcache", "=", "param", ".", "ligmolcache", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.root_dir": [[189, 192], ["data.AtomGridData.ex_provider.settings"], "methods", ["None"], ["", "@", "property", "\n", "def", "root_dir", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ex_provider", ".", "settings", "(", ")", ".", "data_root", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.n_rec_channels": [[193, 196], ["data.AtomGridData.rec_typer.num_types"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_rec_channels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "rec_typer", ".", "num_types", "(", ")", "if", "self", ".", "rec_typer", "else", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.n_lig_channels": [[197, 200], ["data.AtomGridData.lig_typer.num_types"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_lig_channels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "lig_typer", ".", "num_types", "(", ")", "if", "self", ".", "lig_typer", "else", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.n_channels": [[201, 204], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_channels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_rec_channels", "+", "self", ".", "n_lig_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.resolution": [[205, 208], ["data.AtomGridData.grid_maker.get_resolution"], "methods", ["None"], ["", "@", "property", "\n", "def", "resolution", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "grid_maker", ".", "get_resolution", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.dimension": [[209, 212], ["data.AtomGridData.grid_maker.get_dimension"], "methods", ["None"], ["", "@", "property", "\n", "def", "dimension", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "grid_maker", ".", "get_dimension", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.grid_size": [[213, 216], ["atom_grids.dimension_to_size"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.dimension_to_size"], ["", "@", "property", "\n", "def", "grid_size", "(", "self", ")", ":", "\n", "        ", "return", "atom_grids", ".", "dimension_to_size", "(", "self", ".", "dimension", ",", "self", ".", "resolution", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.__len__": [[217, 219], ["data.AtomGridData.ex_provider.size"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.size"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ex_provider", ".", "size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.forward": [[220, 368], ["data.AtomGridData.ex_provider.next_batch", "torch.zeros", "data.AtomGridData.extract_label", "batch_list", "batch_list", "batch_list", "batch_list", "batch_list", "batch_list", "batch_list", "batch_list", "torch.zeros", "torch.zeros", "enumerate", "range", "len", "atom_structs.AtomStruct.from_coord_set", "atom_structs.AtomStruct.from_coord_set", "molgrid.Transform", "data.AtomGridData.cond_interp", "data.AtomGridData.grid_maker.forward", "data.AtomGridData.grid_maker.spatial_grid_dimensions", "data.AtomGridData.grid_maker.spatial_grid_dimensions", "molgrid.Example", "molgrid.Example.coord_sets.append", "molgrid.Example.coord_sets.append", "molgrid.Example", "molgrid.Example.coord_sets.append", "molgrid.Example.coord_sets.append", "atom_structs.AtomStruct.from_coord_set", "atom_structs.AtomStruct.from_coord_set", "molgrid.Transform", "data.AtomGridData.cond_interp.initialize", "data.AtomGridData.grid_maker.forward", "input_lig_coord_set.center", "cond_lig_coord_set.center"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_coord_set", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_coord_set", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_coord_set", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_coord_set", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.TransformInterpolation.initialize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.center", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.center"], ["", "def", "forward", "(", "self", ",", "interpolate", "=", "False", ",", "spherical", "=", "False", ")", ":", "\n", "        ", "assert", "len", "(", "self", ")", ">", "0", ",", "'data is empty'", "\n", "\n", "# get next batch of structures", "\n", "examples", "=", "self", ".", "ex_provider", ".", "next_batch", "(", "self", ".", "batch_size", ")", "\n", "labels", "=", "torch", ".", "zeros", "(", "self", ".", "batch_size", ",", "device", "=", "self", ".", "device", ")", "\n", "examples", ".", "extract_label", "(", "0", ",", "labels", ")", "\n", "\n", "# create lists for examples, structs and transforms", "\n", "batch_list", "=", "lambda", ":", "[", "None", "]", "*", "self", ".", "batch_size", "\n", "\n", "input_examples", "=", "batch_list", "(", ")", "\n", "input_rec_structs", "=", "batch_list", "(", ")", "\n", "input_lig_structs", "=", "batch_list", "(", ")", "\n", "input_transforms", "=", "batch_list", "(", ")", "\n", "\n", "cond_examples", "=", "batch_list", "(", ")", "\n", "cond_rec_structs", "=", "batch_list", "(", ")", "\n", "cond_lig_structs", "=", "batch_list", "(", ")", "\n", "cond_transforms", "=", "batch_list", "(", ")", "\n", "\n", "# create output tensors for atomic density grids", "\n", "input_grids", "=", "torch", ".", "zeros", "(", "\n", "self", ".", "batch_size", ",", "\n", "self", ".", "n_channels", ",", "\n", "*", "self", ".", "grid_maker", ".", "spatial_grid_dimensions", "(", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "self", ".", "device", ",", "\n", ")", "\n", "cond_grids", "=", "torch", ".", "zeros", "(", "\n", "self", ".", "batch_size", ",", "\n", "self", ".", "n_channels", ",", "\n", "*", "self", ".", "grid_maker", ".", "spatial_grid_dimensions", "(", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "self", ".", "device", ",", "\n", ")", "\n", "\n", "# split examples, create structs and transforms", "\n", "for", "i", ",", "ex", "in", "enumerate", "(", "examples", ")", ":", "\n", "\n", "            ", "if", "self", ".", "diff_cond_structs", ":", "\n", "\n", "# different input and conditional molecules", "\n", "                ", "input_rec_coord_set", ",", "input_lig_coord_set", ",", "cond_rec_coord_set", ",", "cond_lig_coord_set", "=", "ex", ".", "coord_sets", "\n", "\n", "# split example into inputs and conditions", "\n", "input_ex", "=", "molgrid", ".", "Example", "(", ")", "\n", "input_ex", ".", "coord_sets", ".", "append", "(", "input_rec_coord_set", ")", "\n", "input_ex", ".", "coord_sets", ".", "append", "(", "input_lig_coord_set", ")", "\n", "\n", "cond_ex", "=", "molgrid", ".", "Example", "(", ")", "\n", "cond_ex", ".", "coord_sets", ".", "append", "(", "cond_rec_coord_set", ")", "\n", "cond_ex", ".", "coord_sets", ".", "append", "(", "cond_lig_coord_set", ")", "\n", "\n", "", "else", ":", "# same conditional molecules as input", "\n", "                ", "input_rec_coord_set", ",", "input_lig_coord_set", "=", "ex", ".", "coord_sets", "\n", "cond_rec_coord_set", ",", "cond_lig_coord_set", "=", "ex", ".", "coord_sets", "\n", "input_ex", "=", "cond_ex", "=", "ex", "\n", "\n", "# store split examples for gridding", "\n", "", "input_examples", "[", "i", "]", "=", "input_ex", "\n", "cond_examples", "[", "i", "]", "=", "cond_ex", "\n", "\n", "# convert coord sets to atom structs", "\n", "input_rec_structs", "[", "i", "]", "=", "atom_structs", ".", "AtomStruct", ".", "from_coord_set", "(", "\n", "input_rec_coord_set", ",", "\n", "typer", "=", "self", ".", "rec_typer", ",", "\n", "data_root", "=", "self", ".", "root_dir", ",", "\n", "device", "=", "self", ".", "device", "\n", ")", "\n", "input_lig_structs", "[", "i", "]", "=", "atom_structs", ".", "AtomStruct", ".", "from_coord_set", "(", "\n", "input_lig_coord_set", ",", "\n", "typer", "=", "self", ".", "lig_typer", ",", "\n", "data_root", "=", "self", ".", "root_dir", ",", "\n", "device", "=", "self", ".", "device", "\n", ")", "\n", "if", "self", ".", "diff_cond_structs", ":", "\n", "                ", "cond_rec_structs", "[", "i", "]", "=", "atom_structs", ".", "AtomStruct", ".", "from_coord_set", "(", "\n", "cond_rec_coord_set", ",", "\n", "typer", "=", "self", ".", "rec_typer", ",", "\n", "data_root", "=", "self", ".", "root_dir", ",", "\n", "device", "=", "self", ".", "device", "\n", ")", "\n", "cond_lig_structs", "[", "i", "]", "=", "atom_structs", ".", "AtomStruct", ".", "from_coord_set", "(", "\n", "cond_lig_coord_set", ",", "\n", "typer", "=", "self", ".", "lig_typer", ",", "\n", "data_root", "=", "self", ".", "root_dir", ",", "\n", "device", "=", "self", ".", "device", "\n", ")", "\n", "", "else", ":", "# same structs as input", "\n", "                ", "cond_rec_structs", "[", "i", "]", "=", "input_rec_structs", "[", "i", "]", "\n", "cond_lig_structs", "[", "i", "]", "=", "input_lig_structs", "[", "i", "]", "\n", "\n", "# create input transform", "\n", "", "input_transforms", "[", "i", "]", "=", "molgrid", ".", "Transform", "(", "\n", "center", "=", "input_lig_coord_set", ".", "center", "(", ")", ",", "\n", "random_translate", "=", "self", ".", "random_translation", ",", "\n", "random_rotation", "=", "self", ".", "random_rotation", ",", "\n", ")", "\n", "if", "self", ".", "diff_cond_transform", ":", "\n", "\n", "# create conditional transform", "\n", "                ", "cond_transforms", "[", "i", "]", "=", "molgrid", ".", "Transform", "(", "\n", "center", "=", "cond_lig_coord_set", ".", "center", "(", ")", ",", "\n", "random_translate", "=", "self", ".", "random_translation", ",", "\n", "random_rotation", "=", "self", ".", "random_rotation", ",", "\n", ")", "\n", "", "else", ":", "# same transform as input", "\n", "                ", "cond_transforms", "[", "i", "]", "=", "input_transforms", "[", "i", "]", "\n", "\n", "", "", "if", "interpolate", ":", "# interpolate conditional transforms", "\n", "# i.e. location and orientation of conditional grid", "\n", "            ", "if", "not", "self", ".", "cond_interp", ".", "is_initialized", ":", "\n", "                ", "self", ".", "cond_interp", ".", "initialize", "(", "cond_examples", "[", "0", "]", ")", "\n", "", "cond_transforms", "=", "self", ".", "cond_interp", "(", "\n", "transforms", "=", "cond_transforms", ",", "\n", "spherical", "=", "spherical", ",", "\n", ")", "\n", "\n", "# create density grids", "\n", "", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "\n", "# create input density grid", "\n", "            ", "self", ".", "grid_maker", ".", "forward", "(", "\n", "input_examples", "[", "i", "]", ",", "\n", "input_transforms", "[", "i", "]", ",", "\n", "input_grids", "[", "i", "]", "\n", ")", "\n", "if", "(", "\n", "self", ".", "diff_cond_transform", "or", "self", ".", "diff_cond_structs", "or", "interpolate", "\n", ")", ":", "\n", "# create conditional density grid", "\n", "                ", "self", ".", "grid_maker", ".", "forward", "(", "\n", "cond_examples", "[", "i", "]", ",", "\n", "cond_transforms", "[", "i", "]", ",", "\n", "cond_grids", "[", "i", "]", "\n", ")", "\n", "", "else", ":", "# same density grid as input", "\n", "                ", "cond_grids", "[", "i", "]", "=", "input_grids", "[", "i", "]", "\n", "\n", "", "", "input_structs", "=", "(", "input_rec_structs", ",", "input_lig_structs", ")", "\n", "cond_structs", "=", "(", "cond_rec_structs", ",", "cond_lig_structs", ")", "\n", "transforms", "=", "(", "input_transforms", ",", "cond_transforms", ")", "\n", "return", "(", "\n", "input_grids", ",", "cond_grids", ",", "\n", "input_structs", ",", "cond_structs", ",", "\n", "transforms", ",", "labels", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.split_channels": [[370, 376], ["torch.split"], "methods", ["None"], ["", "def", "split_channels", "(", "self", ",", "grids", ")", ":", "\n", "        ", "'''\n        Split receptor and ligand grid channels.\n        '''", "\n", "return", "torch", ".", "split", "(", "\n", "grids", ",", "[", "self", ".", "n_rec_channels", ",", "self", ".", "n_lig_channels", "]", ",", "dim", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.find_real_mol": [[378, 380], ["data.AtomGridData.find_real_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.find_real_mol"], ["", "def", "find_real_mol", "(", "self", ",", "mol_src", ",", "ext", ")", ":", "\n", "        ", "return", "find_real_mol", "(", "mol_src", ",", "self", ".", "root_dir", ",", "ext", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.find_real_mol": [[382, 395], ["re.match", "os.path.join", "re.match.group", "int", "re.match", "re.match.group", "re.match.group"], "function", ["None"], ["", "", "def", "find_real_mol", "(", "mol_src", ",", "data_root", ",", "ext", ")", ":", "\n", "\n", "    ", "m", "=", "re", ".", "match", "(", "r'(.+)_(\\d+)((\\..*)+)'", ",", "mol_src", ")", "\n", "if", "m", ":", "\n", "        ", "mol_name", "=", "m", ".", "group", "(", "1", ")", "\n", "pose_idx", "=", "int", "(", "m", ".", "group", "(", "2", ")", ")", "\n", "", "else", ":", "\n", "        ", "m", "=", "re", ".", "match", "(", "r'(.+)((\\..*)+)'", ",", "mol_src", ")", "\n", "mol_name", "=", "m", ".", "group", "(", "1", ")", "\n", "pose_idx", "=", "0", "\n", "\n", "", "mol_file", "=", "os", ".", "path", ".", "join", "(", "data_root", ",", "mol_name", "+", "ext", ")", "\n", "return", "mol_file", ",", "mol_name", ",", "pose_idx", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.__init__": [[34, 42], ["hasattr", "rdkit.Chem.RWMol.__init__", "info.update"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "self", ",", "rd_mol", ",", "**", "info", ")", ":", "\n", "\n", "        ", "if", "hasattr", "(", "rd_mol", ",", "'info'", ")", ":", "# copy over", "\n", "            ", "new_info", ",", "info", "=", "info", ",", "rd_mol", ".", "info", "\n", "info", ".", "update", "(", "new_info", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "rd_mol", ")", "\n", "self", ".", "info", "=", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_smi": [[43, 46], ["cls", "rdkit.Chem.MolFromSmiles"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_smi", "(", "cls", ",", "smi", ",", "sanitize", "=", "True", ")", ":", "\n", "        ", "return", "cls", "(", "Chem", ".", "MolFromSmiles", "(", "smi", ",", "sanitize", "=", "sanitize", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_struct": [[47, 51], ["cls", "molecules.make_rd_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.make_rd_mol"], ["", "@", "classmethod", "\n", "def", "from_struct", "(", "cls", ",", "struct", ")", ":", "\n", "        ", "return", "cls", "(", "\n", "make_rd_mol", "(", "struct", ".", "xyz", ",", "struct", ".", "c", ",", "struct", ".", "bonds", ",", "struct", ".", "channels", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_ob_mol": [[53, 56], ["cls", "molecules.ob_mol_to_rd_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_rd_mol"], ["", "@", "classmethod", "\n", "def", "from_ob_mol", "(", "cls", ",", "ob_mol", ")", ":", "\n", "        ", "return", "cls", "(", "ob_mol_to_rd_mol", "(", "ob_mol", ")", ",", "ob_mol", "=", "ob_mol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_sdf": [[57, 61], ["cls", "molecules.read_rd_mols_from_sdf_file", "mol.GetPropsAsDict"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_rd_mols_from_sdf_file"], ["", "@", "classmethod", "\n", "def", "from_sdf", "(", "cls", ",", "sdf_file", ",", "sanitize", "=", "True", ",", "idx", "=", "0", ")", ":", "\n", "        ", "mol", "=", "read_rd_mols_from_sdf_file", "(", "sdf_file", ",", "sanitize", "=", "sanitize", ")", "[", "idx", "]", "\n", "return", "cls", "(", "mol", ",", "src_file", "=", "sdf_file", ",", "src_idx", "=", "idx", ",", "**", "mol", ".", "GetPropsAsDict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.all_from_sdf": [[62, 68], ["molecules.read_rd_mols_from_sdf_file", "cls", "enumerate", "mol.GetPropsAsDict"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_rd_mols_from_sdf_file"], ["", "@", "classmethod", "\n", "def", "all_from_sdf", "(", "cls", ",", "sdf_file", ",", "sanitize", "=", "True", ")", ":", "\n", "        ", "mols", "=", "read_rd_mols_from_sdf_file", "(", "sdf_file", ",", "sanitize", "=", "sanitize", ")", "\n", "return", "[", "\n", "cls", "(", "mol", ",", "src_file", "=", "sdf_file", ",", "src_idx", "=", "idx", ",", "**", "mol", ".", "GetPropsAsDict", "(", ")", ")", "\n", "for", "idx", ",", "mol", "in", "enumerate", "(", "mols", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_pdb": [[70, 74], ["molecules.read_rd_mol_from_pdb_file", "cls", "read_rd_mol_from_pdb_file.GetPropsAsDict"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_rd_mol_from_pdb_file"], ["", "@", "classmethod", "\n", "def", "from_pdb", "(", "cls", ",", "pdb_file", ",", "sanitize", "=", "True", ")", ":", "\n", "        ", "mol", "=", "read_rd_mol_from_pdb_file", "(", "pdb_file", ",", "sanitize", "=", "sanitize", ")", "\n", "return", "cls", "(", "mol", ",", "src_file", "=", "pdb_file", ",", "**", "mol", ".", "GetPropsAsDict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_sdf": [[75, 77], ["molecules.write_rd_mol_to_sdf_file"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mol_to_sdf_file"], ["", "def", "to_sdf", "(", "self", ",", "sdf_file", ",", "name", "=", "''", ",", "kekulize", "=", "True", ")", ":", "\n", "        ", "write_rd_mol_to_sdf_file", "(", "sdf_file", ",", "self", ",", "name", ",", "kekulize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_pdb": [[78, 80], ["molecules.write_rd_mol_to_pdb_file"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mol_to_pdb_file"], ["", "def", "to_pdb", "(", "self", ",", "pdb_file", ",", "name", "=", "''", ")", ":", "\n", "        ", "write_rd_mol_to_pdb_file", "(", "pdb_file", ",", "self", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_smi": [[81, 83], ["molecules.get_smiles_string"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_smiles_string"], ["", "def", "to_smi", "(", "self", ")", ":", "\n", "        ", "return", "get_smiles_string", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol": [[84, 86], ["molecules.rd_mol_to_ob_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.rd_mol_to_ob_mol"], ["", "def", "to_ob_mol", "(", "self", ")", ":", "\n", "        ", "return", "rd_mol_to_ob_mol", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.n_atoms": [[87, 90], ["molecules.Molecule.GetNumAtoms"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_atoms", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetNumAtoms", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.n_bonds": [[91, 94], ["molecules.Molecule.GetNumBonds"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_bonds", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetNumBonds", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.n_hydros": [[95, 98], ["molecules.Molecule.GetNumAtoms", "molecules.Molecule.GetNumHeavyAtoms"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_hydros", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetNumAtoms", "(", ")", "-", "self", ".", "GetNumHeavyAtoms", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.n_frags": [[99, 102], ["len", "rdkit.Chem.GetMolFrags"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_frags", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "Chem", ".", "GetMolFrags", "(", "self", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.atoms": [[103, 106], ["molecules.Molecule.GetAtomWithIdx", "range"], "methods", ["None"], ["", "@", "property", "\n", "def", "atoms", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "GetAtomWithIdx", "(", "i", ")", "for", "i", "in", "range", "(", "self", ".", "n_atoms", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.bonds": [[107, 110], ["molecules.Molecule.GetBondWithIdx", "range"], "methods", ["None"], ["", "@", "property", "\n", "def", "bonds", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "GetBondWithIdx", "(", "i", ")", "for", "i", "in", "range", "(", "self", ".", "n_bonds", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.coords": [[111, 114], ["molecules.Molecule.GetConformer().GetPositions", "molecules.Molecule.GetConformer"], "methods", ["None"], ["", "@", "property", "\n", "def", "coords", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetConformer", "(", ")", ".", "GetPositions", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.center": [[115, 120], ["molecules.Molecule.coords[].mean", "a.GetAtomicNum"], "methods", ["None"], ["", "@", "property", "\n", "def", "center", "(", "self", ")", ":", "\n", "# return heavy atom centroid", "\n", "        ", "not_h", "=", "[", "a", ".", "GetAtomicNum", "(", ")", "!=", "1", "for", "a", "in", "self", ".", "atoms", "]", "\n", "return", "self", ".", "coords", "[", "not_h", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.translate": [[121, 127], ["molecules.Molecule.GetConformer", "range", "molecules.Molecule.GetNumAtoms", "molecules.Molecule.GetAtomPosition", "molecules.Molecule.SetAtomPosition"], "methods", ["None"], ["", "def", "translate", "(", "self", ",", "xyz", ")", ":", "\n", "        ", "dx", ",", "dy", ",", "dz", "=", "xyz", "\n", "rd_conf", "=", "self", ".", "GetConformer", "(", "0", ")", "\n", "for", "i", "in", "range", "(", "rd_conf", ".", "GetNumAtoms", "(", ")", ")", ":", "\n", "            ", "x", ",", "y", ",", "z", "=", "rd_conf", ".", "GetAtomPosition", "(", "i", ")", "\n", "rd_conf", ".", "SetAtomPosition", "(", "i", ",", "(", "x", "+", "dx", ",", "y", "+", "dy", ",", "z", "+", "dz", ")", ")", "# must be float64", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.aligned_rmsd": [[128, 131], ["molecules.get_rd_mol_rmsd"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_rmsd"], ["", "", "def", "aligned_rmsd", "(", "self", ",", "mol", ")", ":", "\n", "# aligns self to mol", "\n", "        ", "return", "get_rd_mol_rmsd", "(", "self", ",", "mol", ",", "align", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.sanitize": [[132, 134], ["rdkit.Chem.SanitizeMol"], "methods", ["None"], ["", "def", "sanitize", "(", "self", ")", ":", "\n", "        ", "return", "Chem", ".", "SanitizeMol", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.add_hs": [[135, 137], ["type", "rdkit.Chem.AddHs"], "methods", ["None"], ["", "def", "add_hs", "(", "self", ")", ":", "\n", "        ", "return", "type", "(", "self", ")", "(", "Chem", ".", "AddHs", "(", "self", ",", "addCoords", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.remove_hs": [[138, 140], ["type", "rdkit.Chem.RemoveHs"], "methods", ["None"], ["", "def", "remove_hs", "(", "self", ")", ":", "\n", "        ", "return", "type", "(", "self", ")", "(", "Chem", ".", "RemoveHs", "(", "self", ",", "sanitize", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.validate": [[141, 153], ["molecules.Molecule.sanitize"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.sanitize"], ["", "def", "validate", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "n_atoms", "==", "0", ":", "\n", "            ", "return", "False", ",", "'No atoms'", "\n", "", "if", "self", ".", "n_frags", ">", "1", ":", "\n", "            ", "return", "False", ",", "'Multiple fragments'", "\n", "", "try", ":", "\n", "            ", "self", ".", "sanitize", "(", ")", "\n", "return", "True", ",", "'Valid molecule'", "\n", "", "except", "Chem", ".", "AtomValenceException", ":", "\n", "            ", "return", "False", ",", "'Invalid valence'", "\n", "", "except", "(", "Chem", ".", "AtomKekulizeException", ",", "Chem", ".", "KekulizeException", ")", ":", "\n", "            ", "return", "False", ",", "'Failed to kekulize'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.get_pocket": [[154, 156], ["molecules.get_rd_mol_pocket"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_pocket"], ["", "", "def", "get_pocket", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "get_rd_mol_pocket", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.uff_minimize": [[157, 174], ["time.time", "molecules.uff_minimize_rd_mol", "molecules.Molecule", "molecules.get_rd_mol_rmsd", "time.time"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.uff_minimize_rd_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_rmsd"], ["", "def", "uff_minimize", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''\n        Minimize molecular geometry using UFF.\n        The minimization results are stored in\n        the info attribute of the returned mol.\n        '''", "\n", "t_start", "=", "time", ".", "time", "(", ")", "\n", "min_mol", ",", "E_init", ",", "E_min", ",", "error", "=", "uff_minimize_rd_mol", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "rmsd", "=", "min_mol", "\n", "return", "Molecule", "(", "\n", "min_mol", ",", "\n", "E_init", "=", "E_init", ",", "\n", "E_min", "=", "E_min", ",", "\n", "min_rmsd", "=", "get_rd_mol_rmsd", "(", "self", ",", "min_mol", ",", "align", "=", "False", ")", ",", "\n", "min_error", "=", "error", ",", "\n", "min_time", "=", "time", ".", "time", "(", ")", "-", "t_start", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.gnina_minimize": [[176, 183], ["molecules.gnina_minimize_rd_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.gnina_minimize_rd_mol"], ["", "def", "gnina_minimize", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''\n        Minimize receptor-ligand pose with gnina.\n        The minimization results are stored in \n        the info attribute of the returned mol.\n        '''", "\n", "return", "gnina_minimize_rd_mol", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.make_rd_mol": [[185, 217], ["rdkit.Chem.RWMol", "Chem.RWMol.GetNumAtoms", "rdkit.Chem.Conformer", "enumerate", "Chem.RWMol.AddConformer", "typer.get_atom_type", "rdkit.Chem.Atom", "Chem.RWMol.AddAtom", "Chem.Conformer.SetAtomPosition", "numpy.any", "range", "float", "range", "Chem.RWMol.AddBond"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_atom_type"], ["", "", "def", "make_rd_mol", "(", "coords", ",", "types", ",", "bonds", ",", "typer", ")", ":", "\n", "    ", "'''\n    Create an RWMol from numpy arrays of coords\n    and types, optional bonds, and an AtomTyper.\n    No atomic properties other than the elements\n    and coordinates are set.\n    '''", "\n", "rd_mol", "=", "Chem", ".", "RWMol", "(", ")", "\n", "\n", "for", "type_vec", "in", "types", ":", "\n", "        ", "atom_type", "=", "typer", ".", "get_atom_type", "(", "type_vec", ")", "\n", "rd_atom", "=", "Chem", ".", "Atom", "(", "atom_type", ".", "atomic_num", ")", "\n", "rd_mol", ".", "AddAtom", "(", "rd_atom", ")", "\n", "\n", "", "n_atoms", "=", "rd_mol", ".", "GetNumAtoms", "(", ")", "\n", "rd_conf", "=", "Chem", ".", "Conformer", "(", "n_atoms", ")", "\n", "\n", "for", "i", ",", "coord", "in", "enumerate", "(", "coords", ")", ":", "\n", "        ", "x", ",", "y", ",", "z", "=", "[", "float", "(", "c", ")", "for", "c", "in", "coord", "]", "\n", "rd_conf", ".", "SetAtomPosition", "(", "i", ",", "(", "x", ",", "y", ",", "z", ")", ")", "# must be float64", "\n", "\n", "", "rd_mol", ".", "AddConformer", "(", "rd_conf", ")", "\n", "\n", "if", "bonds", "is", "not", "None", "and", "np", ".", "any", "(", "bonds", ")", ":", "\n", "        ", "n_bonds", "=", "0", "\n", "for", "i", "in", "range", "(", "n_atoms", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "n_atoms", ")", ":", "\n", "                ", "if", "bonds", "[", "i", ",", "j", "]", ":", "\n", "                    ", "rd_mol", ".", "AddBond", "(", "i", ",", "j", ",", "Chem", ".", "BondType", ".", "SINGLE", ")", "\n", "n_bonds", "+=", "1", "\n", "\n", "", "", "", "", "return", "rd_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_rd_mol_from_pdb_file": [[219, 221], ["rdkit.Chem.MolFromPDBFile"], "function", ["None"], ["", "def", "read_rd_mol_from_pdb_file", "(", "pdb_file", ",", "sanitize", "=", "True", ")", ":", "\n", "    ", "return", "Chem", ".", "MolFromPDBFile", "(", "pdb_file", ",", "sanitize", "=", "sanitize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_rd_mols_from_sdf_file": [[223, 231], ["sdf_file.endswith", "rdkit.Chem.SDMolSupplier", "gzip.open", "rdkit.Chem.ForwardSDMolSupplier", "molecules.Molecule", "molecules.Molecule"], "function", ["None"], ["", "def", "read_rd_mols_from_sdf_file", "(", "sdf_file", ",", "sanitize", "=", "True", ")", ":", "\n", "    ", "if", "sdf_file", ".", "endswith", "(", "'.gz'", ")", ":", "\n", "        ", "with", "gzip", ".", "open", "(", "sdf_file", ")", "as", "f", ":", "\n", "            ", "suppl", "=", "Chem", ".", "ForwardSDMolSupplier", "(", "f", ",", "sanitize", "=", "sanitize", ")", "\n", "return", "[", "Molecule", "(", "mol", ")", "for", "mol", "in", "suppl", "]", "\n", "", "", "else", ":", "\n", "        ", "suppl", "=", "Chem", ".", "SDMolSupplier", "(", "sdf_file", ",", "sanitize", "=", "sanitize", ")", "\n", "return", "[", "Molecule", "(", "mol", ")", "for", "mol", "in", "suppl", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mol_to_sdf_file": [[233, 235], ["molecules.write_rd_mols_to_sdf_file"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mols_to_sdf_file"], ["", "", "def", "write_rd_mol_to_sdf_file", "(", "sdf_file", ",", "mol", ",", "name", "=", "''", ",", "kekulize", "=", "True", ")", ":", "\n", "    ", "return", "write_rd_mols_to_sdf_file", "(", "sdf_file", ",", "[", "mol", "]", ",", "name", ",", "kekulize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mols_to_sdf_file": [[237, 256], ["rdkit.Chem.SDWriter", "Chem.SDWriter.SetKekulize", "Chem.SDWriter.close", "isinstance", "gzip.open.endswith", "gzip.open", "Chem.SDWriter.write", "gzip.open.close", "mol.SetProp"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close"], ["", "def", "write_rd_mols_to_sdf_file", "(", "sdf_file", ",", "mols", ",", "name", "=", "''", ",", "kekulize", "=", "True", ")", ":", "\n", "    ", "'''\n    Write a list of rdkit molecules to a file\n    or io stream in sdf format.\n    '''", "\n", "use_gzip", "=", "(", "\n", "isinstance", "(", "sdf_file", ",", "str", ")", "and", "sdf_file", ".", "endswith", "(", "'.gz'", ")", "\n", ")", "\n", "if", "use_gzip", ":", "\n", "        ", "sdf_file", "=", "gzip", ".", "open", "(", "sdf_file", ",", "'wt'", ")", "\n", "", "writer", "=", "Chem", ".", "SDWriter", "(", "sdf_file", ")", "\n", "writer", ".", "SetKekulize", "(", "kekulize", ")", "\n", "for", "mol", "in", "mols", ":", "\n", "        ", "if", "name", ":", "\n", "            ", "mol", ".", "SetProp", "(", "'_Name'", ",", "name", ")", "\n", "", "writer", ".", "write", "(", "mol", ")", "\n", "", "writer", ".", "close", "(", ")", "\n", "if", "use_gzip", ":", "\n", "        ", "sdf_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mol_to_pdb_file": [[258, 270], ["rdkit.Chem.PDBWriter", "mol.SetProp", "Chem.PDBWriter.write", "Chem.PDBWriter.close", "isinstance", "gzip.open.endswith", "gzip.open", "gzip.open.close"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close"], ["", "", "def", "write_rd_mol_to_pdb_file", "(", "pdb_file", ",", "mol", ",", "name", "=", "''", ")", ":", "\n", "    ", "use_gzip", "=", "(", "\n", "isinstance", "(", "pdb_file", ",", "str", ")", "and", "pdb_file", ".", "endswith", "(", "'.gz'", ")", "\n", ")", "\n", "if", "use_gzip", ":", "\n", "        ", "pdb_file", "=", "gzip", ".", "open", "(", "pdb_file", ",", "'wt'", ")", "\n", "", "writer", "=", "Chem", ".", "PDBWriter", "(", "pdb_file", ")", "\n", "mol", ".", "SetProp", "(", "'_Name'", ",", "name", ")", "\n", "writer", ".", "write", "(", "mol", ")", "\n", "writer", ".", "close", "(", ")", "\n", "if", "use_gzip", ":", "\n", "        ", "pdb_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.make_ob_mol": [[272, 310], ["openbabel.openbabel.OBMol", "ob.OBMol.BeginModify", "zip", "len", "ob.OBMol.EndModify", "ob.OBMol.NewAtom", "ob_mol.NewAtom.SetVector", "typer.get_atom_type", "ob_mol.NewAtom.SetAtomicNum", "atoms.append", "enumerate", "float", "enumerate", "ob.OBMol.AddBond", "atom_i.GetIdx", "atom_j.GetIdx"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_atom_type"], ["", "", "def", "make_ob_mol", "(", "coords", ",", "types", ",", "bonds", ",", "typer", ")", ":", "\n", "    ", "'''\n    Create an OBMol from numpy arrays of coords\n    and types, optional bonds, and an AtomTyper.\n    No atomic properties other than the elements\n    and coordinates are set.\n\n    Also returns a list of the created atoms in\n    the same order as struct, which is needed for\n    other methods that add hydrogens and change\n    the indexing of atoms in the molecule.\n    '''", "\n", "ob_mol", "=", "ob", ".", "OBMol", "(", ")", "\n", "ob_mol", ".", "BeginModify", "(", ")", "\n", "\n", "atoms", "=", "[", "]", "\n", "for", "coord", ",", "type_vec", "in", "zip", "(", "coords", ",", "types", ")", ":", "\n", "        ", "atom", "=", "ob_mol", ".", "NewAtom", "(", ")", "\n", "\n", "x", ",", "y", ",", "z", "=", "[", "float", "(", "c", ")", "for", "c", "in", "coord", "]", "\n", "atom", ".", "SetVector", "(", "x", ",", "y", ",", "z", ")", "\n", "\n", "atom_type", "=", "typer", ".", "get_atom_type", "(", "type_vec", ")", "\n", "atom", ".", "SetAtomicNum", "(", "atom_type", ".", "atomic_num", ")", "\n", "atoms", ".", "append", "(", "atom", ")", "\n", "\n", "", "n_atoms", "=", "len", "(", "atoms", ")", "\n", "\n", "if", "bonds", "is", "not", "None", ":", "\n", "        ", "for", "i", ",", "atom_i", "in", "enumerate", "(", "atoms", ")", ":", "\n", "            ", "for", "j", ",", "atom_j", "in", "enumerate", "(", "atoms", ")", ":", "\n", "                ", "if", "bonds", "[", "i", ",", "j", "]", ":", "\n", "                    ", "ob_mol", ".", "AddBond", "(", "\n", "atom_i", ".", "GetIdx", "(", ")", ",", "atom_j", ".", "GetIdx", "(", ")", ",", "1", ",", "0", "\n", ")", "\n", "\n", "", "", "", "", "ob_mol", ".", "EndModify", "(", ")", "\n", "return", "ob_mol", ",", "atoms", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.copy_ob_mol": [[312, 319], ["openbabel.openbabel.OBMol", "zip", "ob.OBMol.HasAromaticPerceived", "ob_mol.HasAromaticPerceived", "ob.OBMol.HasHybridizationPerceived", "ob_mol.HasHybridizationPerceived", "openbabel.openbabel.OBMolAtomIter", "openbabel.openbabel.OBMolAtomIter", "a.GetImplicitHCount", "b.GetImplicitHCount"], "function", ["None"], ["", "def", "copy_ob_mol", "(", "ob_mol", ")", ":", "\n", "    ", "copy_mol", "=", "ob", ".", "OBMol", "(", "ob_mol", ")", "\n", "assert", "copy_mol", ".", "HasAromaticPerceived", "(", ")", "==", "ob_mol", ".", "HasAromaticPerceived", "(", ")", "\n", "assert", "copy_mol", ".", "HasHybridizationPerceived", "(", ")", "==", "ob_mol", ".", "HasHybridizationPerceived", "(", ")", "\n", "for", "a", ",", "b", "in", "zip", "(", "ob", ".", "OBMolAtomIter", "(", "ob_mol", ")", ",", "ob", ".", "OBMolAtomIter", "(", "copy_mol", ")", ")", ":", "\n", "        ", "assert", "a", ".", "GetImplicitHCount", "(", ")", "==", "b", ".", "GetImplicitHCount", "(", ")", "\n", "", "return", "copy_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file": [[322, 338], ["os.path.isfile", "openbabel.openbabel.OBConversion", "ob.OBConversion.SetInFormat", "openbabel.openbabel.OBMol", "ob.OBConversion.ReadFile", "openbabel.openbabel.OBMol", "ob.OBConversion.Read", "ob_mols.append", "mol_file.split", "ob.OBMol.AddHydrogens", "len"], "function", ["None"], ["", "def", "read_ob_mols_from_file", "(", "mol_file", ",", "in_format", "=", "None", ",", "n_mols", "=", "None", ",", "add_h", "=", "False", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "isfile", "(", "mol_file", ")", ",", "mol_file", "+", "' does not exist'", "\n", "if", "in_format", "is", "None", ":", "\n", "        ", "in_format", "=", "mol_file", ".", "split", "(", "'.'", ",", "1", ")", "[", "1", "]", "\n", "", "ob_conv", "=", "ob", ".", "OBConversion", "(", ")", "\n", "ob_conv", ".", "SetInFormat", "(", "in_format", ")", "\n", "ob_mol", "=", "ob", ".", "OBMol", "(", ")", "\n", "not_at_end", "=", "ob_conv", ".", "ReadFile", "(", "ob_mol", ",", "mol_file", ")", "\n", "ob_mols", "=", "[", "ob_mol", "]", "\n", "while", "not_at_end", "and", "(", "n_mols", "is", "None", "or", "len", "(", "ob_mols", ")", "<", "n_mols", ")", ":", "\n", "        ", "ob_mol", "=", "ob", ".", "OBMol", "(", ")", "\n", "not_at_end", "=", "ob_conv", ".", "Read", "(", "ob_mol", ")", "\n", "if", "add_h", ":", "\n", "            ", "ob_mol", ".", "AddHydrogens", "(", ")", "\n", "", "ob_mols", ".", "append", "(", "ob_mol", ")", "\n", "", "return", "ob_mols", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.set_ob_conv_opts": [[340, 343], ["ob_conv.AddOption"], "function", ["None"], ["", "def", "set_ob_conv_opts", "(", "ob_conv", ",", "options", ")", ":", "\n", "    ", "for", "o", "in", "options", ":", "\n", "        ", "ob_conv", ".", "AddOption", "(", "o", ",", "ob_conv", ".", "OUTOPTIONS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_ob_mols_to_sdf_file": [[345, 358], ["openbabel.openbabel.OBConversion", "sdf_file.endswith", "molecules.set_ob_conv_opts", "enumerate", "ob.OBConversion.CloseOutFile", "ob.OBConversion.SetOutFormat", "ob.OBConversion.SetOutFormat", "ob.OBConversion.WriteFile", "ob.OBConversion.Write"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.set_ob_conv_opts"], ["", "", "def", "write_ob_mols_to_sdf_file", "(", "sdf_file", ",", "ob_mols", ",", "options", "=", "'h'", ")", ":", "\n", "    ", "ob_conv", "=", "ob", ".", "OBConversion", "(", ")", "\n", "if", "sdf_file", ".", "endswith", "(", "'.gz'", ")", ":", "\n", "        ", "ob_conv", ".", "SetOutFormat", "(", "'sdf.gz'", ")", "\n", "", "else", ":", "\n", "        ", "ob_conv", ".", "SetOutFormat", "(", "'sdf'", ")", "\n", "", "set_ob_conv_opts", "(", "ob_conv", ",", "options", ")", "\n", "for", "i", ",", "ob_mol", "in", "enumerate", "(", "ob_mols", ")", ":", "\n", "        ", "if", "i", "==", "0", ":", "\n", "            ", "ob_conv", ".", "WriteFile", "(", "ob_mol", ",", "sdf_file", ")", "\n", "", "else", ":", "\n", "            ", "ob_conv", ".", "Write", "(", "ob_mol", ")", "\n", "", "", "ob_conv", ".", "CloseOutFile", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_center": [[360, 369], ["openbabel.openbabel.OBMolAtomIter", "ob_mol.NumAtoms", "a.GetX", "a.GetY", "a.GetZ"], "function", ["None"], ["", "def", "ob_mol_center", "(", "ob_mol", ")", ":", "\n", "    ", "assert", "ob_mol", ".", "NumAtoms", "(", ")", ">", "0", "\n", "x", ",", "y", ",", "z", ",", "n", "=", "0", "\n", "for", "a", "in", "ob", ".", "OBMolAtomIter", "(", "ob_mol", ")", ":", "\n", "        ", "x", "+=", "a", ".", "GetX", "(", ")", "\n", "y", "+=", "a", ".", "GetY", "(", ")", "\n", "z", "+=", "a", ".", "GetZ", "(", ")", "\n", "n", "+=", "1", "\n", "", "return", "(", "x", "/", "n", ",", "y", "/", "n", ",", "z", "/", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_count_elems": [[371, 373], ["collections.Counter", "a.GetAtomicNum", "openbabel.openbabel.OBMolAtomIter"], "function", ["None"], ["", "def", "ob_mol_count_elems", "(", "ob_mol", ")", ":", "\n", "    ", "return", "Counter", "(", "a", ".", "GetAtomicNum", "(", ")", "for", "a", "in", "ob", ".", "OBMolAtomIter", "(", "ob_mol", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_smi": [[375, 380], ["openbabel.openbabel.OBConversion", "ob.OBConversion.SetOutFormat", "molecules.set_ob_conv_opts", "ob.OBConversion.WriteString().rstrip", "ob.OBConversion.WriteString"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.set_ob_conv_opts"], ["", "def", "ob_mol_to_smi", "(", "ob_mol", ",", "options", "=", "'cnh'", ")", ":", "\n", "    ", "ob_conv", "=", "ob", ".", "OBConversion", "(", ")", "\n", "ob_conv", ".", "SetOutFormat", "(", "'smi'", ")", "\n", "set_ob_conv_opts", "(", "ob_conv", ",", "options", ")", "\n", "return", "ob_conv", ".", "WriteString", "(", "ob_mol", ")", ".", "rstrip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_delete_bonds": [[382, 387], ["openbabel.openbabel.OBMol", "openbabel.openbabel.OBMolBondIter", "ob.OBMol.DeleteBond"], "function", ["None"], ["", "def", "ob_mol_delete_bonds", "(", "ob_mol", ")", ":", "\n", "    ", "ob_mol", "=", "ob", ".", "OBMol", "(", "ob_mol", ")", "\n", "for", "bond", "in", "ob", ".", "OBMolBondIter", "(", "ob_mol", ")", ":", "\n", "        ", "ob_mol", ".", "DeleteBond", "(", "bond", ")", "\n", "", "return", "ob_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_hyb_to_rd_hyb": [[389, 417], ["ob_atom.GetHyb", "ob_atom.GetAtomicNum"], "function", ["None"], ["", "def", "ob_hyb_to_rd_hyb", "(", "ob_atom", ")", ":", "\n", "    ", "'''\n    Get the rdkit hybridization state\n    for an openbabel atom. See below:\n\n            OpenBabel   RDkit\n    unk     0           0\n    s       1           1\n    sp      1           2\n    sp2     2           3\n    sp3     3           4\n    sp3d    4           5\n    sp3d2   5           6\n    other   6+          7\n    '''", "\n", "ob_hyb", "=", "ob_atom", ".", "GetHyb", "(", ")", "\n", "rd_hybs", "=", "Chem", ".", "HybridizationType", "\n", "if", "1", "<", "ob_hyb", "<", "6", ":", "\n", "        ", "return", "rd_hybs", ".", "values", "[", "ob_hyb", "+", "1", "]", "\n", "", "elif", "ob_hyb", "==", "1", ":", "# s or sp", "\n", "        ", "if", "ob_atom", ".", "GetAtomicNum", "(", ")", ">", "4", ":", "\n", "            ", "return", "rd_hybs", ".", "SP", "\n", "", "else", ":", "# no p orbitals", "\n", "            ", "return", "rd_hybs", ".", "S", "\n", "", "", "elif", "ob_hyb", "==", "0", ":", "\n", "        ", "return", "rd_hybs", ".", "UNSPECIFIED", "\n", "", "else", ":", "\n", "        ", "return", "rd_hybs", ".", "OTHER", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_rd_mol": [[419, 471], ["ob_mol.NumAtoms", "rdkit.Chem.RWMol", "rdkit.Chem.Conformer", "openbabel.openbabel.OBMolAtomIter", "Chem.RWMol.AddConformer", "openbabel.openbabel.OBMolBondIter", "rdkit.Chem.GetSSSR", "Chem.RWMol.UpdatePropertyCache", "rdkit.Chem.Atom", "Chem.Atom.SetFormalCharge", "Chem.Atom.SetIsAromatic", "Chem.Atom.SetNumExplicitHs", "Chem.Atom.SetNoImplicit", "Chem.Atom.SetHybridization", "Chem.RWMol.AddAtom", "rdkit.Geometry.Point3D", "Chem.Conformer.SetAtomPosition", "ob_bond.GetBondOrder", "Chem.RWMol.AddBond", "Chem.RWMol.GetBondBetweenAtoms", "rd_mol.GetBondBetweenAtoms.SetIsAromatic", "ob_atom.GetAtomicNum", "ob_atom.GetFormalCharge", "ob_atom.IsAromatic", "ob_atom.GetImplicitHCount", "molecules.ob_hyb_to_rd_hyb", "ob_atom.GetX", "ob_atom.GetY", "ob_atom.GetZ", "ob_bond.GetBeginAtomIdx", "ob_bond.GetEndAtomIdx", "ob_bond.IsAromatic", "Exception"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_hyb_to_rd_hyb"], ["", "", "def", "ob_mol_to_rd_mol", "(", "ob_mol", ")", ":", "\n", "    ", "'''\n    Convert an OBMol to an RWMol, copying\n    over the elements, coordinates, formal\n    charges, bonds and aromaticity.\n    '''", "\n", "n_atoms", "=", "ob_mol", ".", "NumAtoms", "(", ")", "\n", "rd_mol", "=", "Chem", ".", "RWMol", "(", ")", "\n", "rd_conf", "=", "Chem", ".", "Conformer", "(", "n_atoms", ")", "\n", "\n", "for", "ob_atom", "in", "ob", ".", "OBMolAtomIter", "(", "ob_mol", ")", ":", "\n", "\n", "        ", "rd_atom", "=", "Chem", ".", "Atom", "(", "ob_atom", ".", "GetAtomicNum", "(", ")", ")", "\n", "rd_atom", ".", "SetFormalCharge", "(", "ob_atom", ".", "GetFormalCharge", "(", ")", ")", "\n", "rd_atom", ".", "SetIsAromatic", "(", "ob_atom", ".", "IsAromatic", "(", ")", ")", "\n", "rd_atom", ".", "SetNumExplicitHs", "(", "ob_atom", ".", "GetImplicitHCount", "(", ")", ")", "\n", "rd_atom", ".", "SetNoImplicit", "(", "True", ")", "# don't use rdkit valence model", "\n", "rd_atom", ".", "SetHybridization", "(", "ob_hyb_to_rd_hyb", "(", "ob_atom", ")", ")", "\n", "\n", "idx", "=", "rd_mol", ".", "AddAtom", "(", "rd_atom", ")", "\n", "\n", "rd_coords", "=", "Geometry", ".", "Point3D", "(", "\n", "ob_atom", ".", "GetX", "(", ")", ",", "ob_atom", ".", "GetY", "(", ")", ",", "ob_atom", ".", "GetZ", "(", ")", "\n", ")", "\n", "rd_conf", ".", "SetAtomPosition", "(", "idx", ",", "rd_coords", ")", "\n", "\n", "", "rd_mol", ".", "AddConformer", "(", "rd_conf", ")", "\n", "\n", "for", "ob_bond", "in", "ob", ".", "OBMolBondIter", "(", "ob_mol", ")", ":", "\n", "\n", "# OB uses 1-indexing, rdkit uses 0", "\n", "        ", "i", "=", "ob_bond", ".", "GetBeginAtomIdx", "(", ")", "-", "1", "\n", "j", "=", "ob_bond", ".", "GetEndAtomIdx", "(", ")", "-", "1", "\n", "\n", "bond_order", "=", "ob_bond", ".", "GetBondOrder", "(", ")", "\n", "if", "bond_order", "==", "1", ":", "\n", "            ", "bond_type", "=", "Chem", ".", "BondType", ".", "SINGLE", "\n", "", "elif", "bond_order", "==", "2", ":", "\n", "            ", "bond_type", "=", "Chem", ".", "BondType", ".", "DOUBLE", "\n", "", "elif", "bond_order", "==", "3", ":", "\n", "            ", "bond_type", "=", "Chem", ".", "BondType", ".", "TRIPLE", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'unknown bond order {}'", ".", "format", "(", "bond_order", ")", ")", "\n", "\n", "", "rd_mol", ".", "AddBond", "(", "i", ",", "j", ",", "bond_type", ")", "\n", "rd_bond", "=", "rd_mol", ".", "GetBondBetweenAtoms", "(", "i", ",", "j", ")", "\n", "rd_bond", ".", "SetIsAromatic", "(", "ob_bond", ".", "IsAromatic", "(", ")", ")", "\n", "\n", "", "Chem", ".", "GetSSSR", "(", "rd_mol", ")", "# initialize ring info", "\n", "rd_mol", ".", "UpdatePropertyCache", "(", "strict", "=", "False", ")", "# compute valence", "\n", "\n", "return", "rd_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.rd_mol_to_ob_mol": [[473, 516], ["openbabel.openbabel.OBMol", "ob.OBMol.BeginModify", "rd_mol.GetConformer", "enumerate", "rd_mol.GetBonds", "ob.OBMol.EndModify", "rd_mol.GetAtoms", "ob.OBMol.NewAtom", "ob_mol.NewAtom.SetAtomicNum", "ob_mol.NewAtom.SetFormalCharge", "ob_mol.NewAtom.SetAromatic", "ob_mol.NewAtom.SetImplicitHCount", "rd_mol.GetConformer.GetAtomPosition", "ob_mol.NewAtom.SetVector", "rd_bond.GetBondType", "ob.OBMol.AddBond", "ob.OBMol.GetBond", "ob_mol.GetBond.SetAromatic", "rd_atom.GetAtomicNum", "rd_atom.GetFormalCharge", "rd_atom.GetIsAromatic", "rd_atom.GetNumExplicitHs", "rd_bond.GetBeginAtomIdx", "rd_bond.GetEndAtomIdx", "rd_bond.GetIsAromatic", "Exception"], "function", ["None"], ["", "def", "rd_mol_to_ob_mol", "(", "rd_mol", ")", ":", "\n", "    ", "'''\n    Convert an RWMol to an OBMol, copying\n    over the elements, coordinates, formal\n    charges, bonds and aromaticity.\n    '''", "\n", "ob_mol", "=", "ob", ".", "OBMol", "(", ")", "\n", "ob_mol", ".", "BeginModify", "(", ")", "\n", "rd_conf", "=", "rd_mol", ".", "GetConformer", "(", "0", ")", "\n", "\n", "for", "idx", ",", "rd_atom", "in", "enumerate", "(", "rd_mol", ".", "GetAtoms", "(", ")", ")", ":", "\n", "\n", "        ", "ob_atom", "=", "ob_mol", ".", "NewAtom", "(", ")", "\n", "ob_atom", ".", "SetAtomicNum", "(", "rd_atom", ".", "GetAtomicNum", "(", ")", ")", "\n", "ob_atom", ".", "SetFormalCharge", "(", "rd_atom", ".", "GetFormalCharge", "(", ")", ")", "\n", "ob_atom", ".", "SetAromatic", "(", "rd_atom", ".", "GetIsAromatic", "(", ")", ")", "\n", "ob_atom", ".", "SetImplicitHCount", "(", "rd_atom", ".", "GetNumExplicitHs", "(", ")", ")", "\n", "\n", "rd_coords", "=", "rd_conf", ".", "GetAtomPosition", "(", "idx", ")", "\n", "ob_atom", ".", "SetVector", "(", "rd_coords", ".", "x", ",", "rd_coords", ".", "y", ",", "rd_coords", ".", "z", ")", "\n", "\n", "", "for", "rd_bond", "in", "rd_mol", ".", "GetBonds", "(", ")", ":", "\n", "\n", "# OB uses 1-indexing, rdkit uses 0", "\n", "        ", "i", "=", "rd_bond", ".", "GetBeginAtomIdx", "(", ")", "+", "1", "\n", "j", "=", "rd_bond", ".", "GetEndAtomIdx", "(", ")", "+", "1", "\n", "\n", "bond_type", "=", "rd_bond", ".", "GetBondType", "(", ")", "\n", "if", "bond_type", "==", "Chem", ".", "BondType", ".", "SINGLE", ":", "\n", "            ", "bond_order", "=", "1", "\n", "", "elif", "bond_type", "==", "Chem", ".", "BondType", ".", "DOUBLE", ":", "\n", "            ", "bond_order", "=", "2", "\n", "", "elif", "bond_type", "==", "Chem", ".", "BondType", ".", "TRIPLE", ":", "\n", "            ", "bond_order", "=", "3", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'unknown bond type {}'", ".", "format", "(", "bond_type", ")", ")", "\n", "\n", "", "ob_mol", ".", "AddBond", "(", "i", ",", "j", ",", "bond_order", ")", "\n", "ob_bond", "=", "ob_mol", ".", "GetBond", "(", "i", ",", "j", ")", "\n", "ob_bond", ".", "SetAromatic", "(", "rd_bond", ".", "GetIsAromatic", "(", ")", ")", "\n", "\n", "", "ob_mol", ".", "EndModify", "(", ")", "\n", "return", "ob_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_validity": [[518, 535], ["rd_mol.GetNumAtoms", "len", "rdkit.Chem.GetMolFrags", "rdkit.Chem.SanitizeMol", "str"], "function", ["None"], ["", "def", "get_rd_mol_validity", "(", "rd_mol", ")", ":", "\n", "    ", "'''\n    A molecule is considered valid iff it has at\n    least one atom, all atoms are connected in a\n    single fragment, and it raises no errors when\n    passed to rdkit.Chem.SanitizeMol, indicating\n    valid valences and successful kekulization.\n    '''", "\n", "n_atoms", "=", "rd_mol", ".", "GetNumAtoms", "(", ")", "\n", "n_frags", "=", "len", "(", "Chem", ".", "GetMolFrags", "(", "rd_mol", ")", ")", "\n", "try", ":", "\n", "        ", "Chem", ".", "SanitizeMol", "(", "rd_mol", ")", "\n", "error", "=", "None", "\n", "", "except", "Chem", ".", "MolSanitizeException", "as", "e", ":", "\n", "        ", "error", "=", "str", "(", "e", ")", "\n", "", "valid", "=", "(", "n_atoms", ">", "0", "and", "n_frags", "==", "1", "and", "error", "is", "None", ")", "\n", "return", "n_atoms", ",", "n_frags", ",", "error", ",", "valid", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_rmsd": [[537, 553], ["rdkit.Chem.RWMol", "rdkit.Chem.AllChem.GetBestRMS"], "function", ["None"], ["", "def", "get_rd_mol_rmsd", "(", "rd_mol1", ",", "rd_mol2", ",", "align", "=", "False", ")", ":", "\n", "\n", "# NOTE rd_mol RMSD is undefined b/tw diff molecules", "\n", "#   (even if they have the same type counts)", "\n", "\n", "# GetBestRMS(mol1, mol2) aligns mol1 to mol2", "\n", "#   if we don't want this, copy mol1 first", "\n", "    ", "if", "not", "align", ":", "\n", "        ", "rd_mol1", "=", "Chem", ".", "RWMol", "(", "rd_mol1", ")", "\n", "\n", "", "try", ":", "\n", "        ", "return", "AllChem", ".", "GetBestRMS", "(", "rd_mol1", ",", "rd_mol2", ")", "\n", "", "except", "RuntimeError", ":", "\n", "#RuntimeError: No sub-structure match found ", "\n", "#  between the reference and probe mol", "\n", "        ", "return", "np", ".", "nan", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_NPS_model": [[572, 579], ["functools.lru_cache", "NP_Score.npscorer.readNPModel"], "function", ["None"], ["@", "lru_cache", "(", "maxsize", "=", "1", ")", "\n", "def", "get_NPS_model", "(", ")", ":", "\n", "    ", "'''\n    Read NPS scoring model on first call,\n    and cache it for subsequent calls.\n    '''", "\n", "return", "npscorer", ".", "readNPModel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_NPS": [[581, 583], ["NP_Score.npscorer.scoreMol", "molecules.get_NPS_model"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_NPS_model"], ["", "def", "get_rd_mol_NPS", "(", "rd_mol", ")", ":", "\n", "    ", "return", "npscorer", ".", "scoreMol", "(", "rd_mol", ",", "get_NPS_model", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_smiles_string": [[585, 587], ["rdkit.Chem.MolToSmiles"], "function", ["None"], ["", "def", "get_smiles_string", "(", "rd_mol", ")", ":", "\n", "    ", "return", "Chem", ".", "MolToSmiles", "(", "rd_mol", ",", "canonical", "=", "True", ",", "isomericSmiles", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_similarity": [[590, 606], ["rdkit.DataStructs.TanimotoSimilarity", "rdkit.Chem.AllChem.GetMorganFingerprintAsBitVect", "rdkit.Chem.AllChem.GetMorganFingerprintAsBitVect", "rdkit.Chem.Fingerprints.FingerprintMols.FingerprintMol", "rdkit.Chem.Fingerprints.FingerprintMols.FingerprintMol", "rdkit.Chem.AllChem.GetMACCSKeysFingerprint", "rdkit.Chem.AllChem.GetMACCSKeysFingerprint"], "function", ["None"], ["", "def", "get_rd_mol_similarity", "(", "rd_mol1", ",", "rd_mol2", ",", "fingerprint", "=", "'rdkit'", ")", ":", "\n", "\n", "    ", "if", "fingerprint", "==", "'morgan'", ":", "\n", "# this can raise RingInfo not initialized even when valid??", "\n", "        ", "fgp1", "=", "AllChem", ".", "GetMorganFingerprintAsBitVect", "(", "rd_mol1", ",", "2", ",", "1024", ")", "\n", "fgp2", "=", "AllChem", ".", "GetMorganFingerprintAsBitVect", "(", "rd_mol2", ",", "2", ",", "1024", ")", "\n", "\n", "", "elif", "fingerprint", "==", "'rdkit'", ":", "\n", "        ", "fgp1", "=", "Chem", ".", "Fingerprints", ".", "FingerprintMols", ".", "FingerprintMol", "(", "rd_mol1", ")", "\n", "fgp2", "=", "Chem", ".", "Fingerprints", ".", "FingerprintMols", ".", "FingerprintMol", "(", "rd_mol2", ")", "\n", "\n", "", "elif", "fingerprint", "==", "'maccs'", ":", "\n", "        ", "fgp1", "=", "AllChem", ".", "GetMACCSKeysFingerprint", "(", "rd_mol1", ")", "\n", "fgp2", "=", "AllChem", ".", "GetMACCSKeysFingerprint", "(", "rd_mol2", ")", "\n", "\n", "", "return", "DataStructs", ".", "TanimotoSimilarity", "(", "fgp1", ",", "fgp2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_ob_smi_similarity": [[608, 613], ["common.catch_exception", "openbabel.pybel.readstring().calcfp", "openbabel.pybel.readstring().calcfp", "openbabel.pybel.readstring", "openbabel.pybel.readstring"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.catch_exception"], ["", "@", "catch_exception", "(", "exc_type", "=", "SyntaxError", ")", "\n", "def", "get_ob_smi_similarity", "(", "smi1", ",", "smi2", ")", ":", "\n", "    ", "fgp1", "=", "pybel", ".", "readstring", "(", "'smi'", ",", "smi1", ")", ".", "calcfp", "(", ")", "\n", "fgp2", "=", "pybel", ".", "readstring", "(", "'smi'", ",", "smi2", ")", ".", "calcfp", "(", ")", "\n", "return", "fgp1", "|", "fgp2", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_pocket": [[615, 646], ["scipy.spatial.distance.cdist", "set", "set", "molecules.Molecule", "list", "molecules.Molecule.sanitize", "rec_mol.GetAtomWithIdx", "molecules.get_rd_atom_res_id", "set.add", "Molecule.GetAtoms", "molecules.get_rd_atom_res_id", "numpy.nonzero", "int", "Molecule.RemoveAtom", "rec_mol.GetAtomWithIdx.GetIdx"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.sanitize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_atom_res_id", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_atom_res_id"], ["", "def", "get_rd_mol_pocket", "(", "rec_mol", ",", "lig_mol", ",", "max_dist", "=", "8", ")", ":", "\n", "    ", "'''\n    Return a molecule containing only\n    the residues from rec_mol that are\n    within max_dist of lig_mol.\n    '''", "\n", "# get distances b/tw rec and lig atoms", "\n", "lig_coords", "=", "lig_mol", ".", "coords", "\n", "rec_coords", "=", "rec_mol", ".", "coords", "\n", "dist", "=", "sp", ".", "spatial", ".", "distance", ".", "cdist", "(", "lig_coords", ",", "rec_coords", ")", "\n", "\n", "# indexes of atoms in rec_mol that are", "\n", "#   within max_dist of an atom in lig_mol", "\n", "pocket_atom_idxs", "=", "set", "(", "np", ".", "nonzero", "(", "(", "dist", "<", "max_dist", ")", ")", "[", "1", "]", ")", "\n", "\n", "# determine pocket residues", "\n", "pocket_res_ids", "=", "set", "(", ")", "\n", "for", "i", "in", "pocket_atom_idxs", ":", "\n", "        ", "atom", "=", "rec_mol", ".", "GetAtomWithIdx", "(", "int", "(", "i", ")", ")", "\n", "res_id", "=", "get_rd_atom_res_id", "(", "atom", ")", "\n", "pocket_res_ids", ".", "add", "(", "res_id", ")", "\n", "\n", "# copy mol and delete atoms", "\n", "", "pkt_mol", "=", "Molecule", "(", "rec_mol", ",", "src_mol", "=", "rec_mol", ")", "\n", "for", "atom", "in", "list", "(", "pkt_mol", ".", "GetAtoms", "(", ")", ")", ":", "\n", "        ", "res_id", "=", "get_rd_atom_res_id", "(", "atom", ")", "\n", "if", "res_id", "not", "in", "pocket_res_ids", ":", "\n", "            ", "pkt_mol", ".", "RemoveAtom", "(", "atom", ".", "GetIdx", "(", ")", ")", "\n", "\n", "", "", "pkt_mol", ".", "sanitize", "(", ")", "\n", "return", "pkt_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_atom_res_id": [[648, 658], ["rd_atom.GetPDBResidueInfo", "rd_atom.GetPDBResidueInfo.GetChainId", "rd_atom.GetPDBResidueInfo.GetResidueNumber"], "function", ["None"], ["", "def", "get_rd_atom_res_id", "(", "rd_atom", ")", ":", "\n", "    ", "'''\n    Return an object that uniquely\n    identifies the residue that the\n    atom belongs to in a given PDB.\n    '''", "\n", "res_info", "=", "rd_atom", ".", "GetPDBResidueInfo", "(", ")", "\n", "return", "(", "\n", "res_info", ".", "GetChainId", "(", ")", ",", "\n", "res_info", ".", "GetResidueNumber", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.uff_minimize_rd_mol": [[661, 753], ["rdkit.Chem.RWMol", "rdkit.Chem.AddHs", "Chem.AddHs.GetNumAtoms", "rdkit.Chem.RemoveHs", "rdkit.Chem.CombineMols", "rdkit.Chem.SanitizeMol", "rdkit.Chem.AllChem.UFFGetMoleculeForceField", "AllChem.UFFGetMoleculeForceField.Initialize", "AllChem.UFFGetMoleculeForceField.CalcEnergy", "print", "molecules.write_rd_mol_to_sdf_file", "range", "print", "AllChem.UFFGetMoleculeForceField.CalcEnergy", "Chem.CombineMols.GetConformer().GetPositions", "Chem.AddHs.GetConformer", "enumerate", "str", "str", "rec_mol.GetNumAtoms", "AllChem.UFFGetMoleculeForceField.AddFixedPoint", "print", "print", "str", "molecules.write_rd_mol_to_sdf_file", "traceback.print_exc", "lig_mol.GetConformer.SetAtomPosition", "AllChem.UFFGetMoleculeForceField.Minimize", "Chem.CombineMols.GetConformer", "Chem.AddHs.GetNumAtoms"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mol_to_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mol_to_sdf_file"], ["", "def", "uff_minimize_rd_mol", "(", "lig_mol", ",", "rec_mol", "=", "None", ",", "n_iters", "=", "200", ",", "n_tries", "=", "2", ")", ":", "\n", "    ", "'''\n    Attempt to minimize rd_mol with UFF.\n    If rec_mol is provided, minimize in\n    the context of the fixed receptor.\n\n    Returns (min_mol, E_init, E_final, error).\n    '''", "\n", "lig_mol", "=", "Chem", ".", "RWMol", "(", "lig_mol", ")", "\n", "if", "lig_mol", ".", "GetNumAtoms", "(", ")", "==", "0", ":", "\n", "        ", "return", "lig_mol", ",", "np", ".", "nan", ",", "np", ".", "nan", ",", "'No atoms'", "\n", "\n", "", "E_init", "=", "np", ".", "nan", "\n", "E_final", "=", "np", ".", "nan", "\n", "error", "=", "None", "\n", "\n", "# regenerate hydrogen coords with rdkit", "\n", "lig_mol", "=", "Chem", ".", "AddHs", "(", "\n", "Chem", ".", "RemoveHs", "(", "lig_mol", ",", "updateExplicitCount", "=", "True", ",", "sanitize", "=", "False", ")", ",", "\n", "explicitOnly", "=", "True", ",", "\n", "addCoords", "=", "True", "\n", ")", "\n", "\n", "if", "rec_mol", ":", "# combine into complex", "\n", "        ", "uff_mol", "=", "Chem", ".", "CombineMols", "(", "rec_mol", ",", "lig_mol", ")", "\n", "", "else", ":", "# just use the ligand", "\n", "        ", "uff_mol", "=", "lig_mol", "\n", "\n", "", "try", ":", "\n", "        ", "Chem", ".", "SanitizeMol", "(", "uff_mol", ")", "\n", "", "except", "Chem", ".", "AtomValenceException", ":", "\n", "        ", "error", "=", "'Invalid valence'", "\n", "", "except", "(", "Chem", ".", "AtomKekulizeException", ",", "Chem", ".", "KekulizeException", ")", ":", "\n", "        ", "error", "=", "'Failed to kekulize'", "\n", "\n", "", "if", "error", ":", "\n", "        ", "return", "lig_mol", ",", "E_init", ",", "E_final", ",", "error", "\n", "\n", "", "try", ":", "\n", "# initialize force field", "\n", "        ", "uff", "=", "AllChem", ".", "UFFGetMoleculeForceField", "(", "\n", "uff_mol", ",", "confId", "=", "0", ",", "ignoreInterfragInteractions", "=", "False", "\n", ")", "\n", "uff", ".", "Initialize", "(", ")", "\n", "\n", "# get the initial energy", "\n", "E_init", "=", "uff", ".", "CalcEnergy", "(", ")", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "if", "'getNumImplicitHs'", "in", "str", "(", "e", ")", ":", "\n", "            ", "return", "lig_mol", ",", "E_init", ",", "E_final", ",", "'No implicit valence'", "\n", "", "if", "'bad params pointer'", "in", "str", "(", "e", ")", ":", "\n", "            ", "return", "lig_mol", ",", "E_init", ",", "E_final", ",", "'Invalid atom type'", "\n", "", "print", "(", "'UFF1 exception'", ")", "\n", "write_rd_mol_to_sdf_file", "(", "'badmol_uff1.sdf'", ",", "uff_mol", ",", "kekulize", "=", "False", ")", "\n", "raise", "e", "\n", "\n", "", "if", "not", "error", "and", "n_tries", "*", "n_iters", ">", "0", ":", "\n", "\n", "        ", "if", "rec_mol", ":", "# fix receptor atoms", "\n", "            ", "for", "i", "in", "range", "(", "rec_mol", ".", "GetNumAtoms", "(", ")", ")", ":", "\n", "                ", "uff", ".", "AddFixedPoint", "(", "i", ")", "\n", "", "", "try", ":", "\n", "# minimize with force field", "\n", "            ", "converged", "=", "False", "\n", "while", "n_tries", ">", "0", "and", "not", "converged", ":", "\n", "                ", "print", "(", "'.'", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "converged", "=", "not", "uff", ".", "Minimize", "(", "maxIts", "=", "n_iters", ")", "\n", "n_tries", "-=", "1", "\n", "", "print", "(", "flush", "=", "True", ")", "\n", "\n", "# get the final energy", "\n", "E_final", "=", "uff", ".", "CalcEnergy", "(", ")", "\n", "if", "not", "converged", ":", "\n", "                ", "error", "=", "'Not converged'", "\n", "\n", "", "", "except", "RuntimeError", "as", "e", ":", "\n", "            ", "print", "(", "'UFF2 exception'", ")", "\n", "error", "=", "str", "(", "e", ")", "\n", "write_rd_mol_to_sdf_file", "(", "\n", "'badmol_uff2.sdf'", ",", "uff_mol", ",", "kekulize", "=", "True", "\n", ")", "\n", "traceback", ".", "print_exc", "(", "file", "=", "sys", ".", "stdout", ")", "\n", "\n", "", "if", "rec_mol", ":", "\n", "# copy minimized coords back to ligand", "\n", "            ", "coords", "=", "uff_mol", ".", "GetConformer", "(", ")", ".", "GetPositions", "(", ")", "\n", "lig_conf", "=", "lig_mol", ".", "GetConformer", "(", ")", "\n", "for", "i", ",", "xyz", "in", "enumerate", "(", "coords", "[", "-", "lig_mol", ".", "GetNumAtoms", "(", ")", ":", "]", ")", ":", "\n", "                ", "lig_conf", ".", "SetAtomPosition", "(", "i", ",", "xyz", ")", "\n", "\n", "", "", "", "return", "lig_mol", ",", "E_init", ",", "E_final", ",", "error", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.gnina_minimize_rd_mol": [[755, 818], ["molecules.gnina_minimize_rd_mol.get_mol_as_file"], "function", ["None"], ["", "def", "gnina_minimize_rd_mol", "(", "lig_mol", ",", "rec_mol", ")", ":", "\n", "    ", "'''\n    Minimize lig_mol wrt rec_mol using gnina.\n    gnina is run as a subprocess, which needs\n    the mols to be present on disk. Check for\n    src_file or out_file, else use temp_file.\n    '''", "\n", "if", "lig_mol", ".", "n_atoms", "==", "0", ":", "\n", "        ", "return", "Molecule", "(", "Chem", ".", "RWMol", "(", "lig_mol", ")", ",", "error", "=", "'No atoms'", ")", "\n", "\n", "", "def", "get_temp_file", "(", ")", ":", "\n", "        ", "with", "tempfile", ".", "NamedTemporaryFile", "(", ")", "as", "f", ":", "\n", "            ", "return", "f", ".", "name", "+", "'.sdf.gz'", "\n", "\n", "", "", "def", "get_mol_as_file", "(", "mol", ")", ":", "\n", "\n", "        ", "if", "'src_file'", "in", "mol", ".", "info", ":", "\n", "            ", "return", "mol", ".", "info", "[", "'src_file'", "]", "\n", "", "elif", "'out_file'", "in", "mol", ".", "info", ":", "\n", "            ", "return", "mol", ".", "info", "[", "'out_file'", "]", "\n", "", "else", ":", "\n", "            ", "tmp_file", "=", "get_temp_file", "(", ")", "\n", "mol", ".", "to_sdf", "(", "tmp_file", ",", "kekulize", "=", "False", ")", "\n", "return", "tmp_file", "\n", "\n", "", "", "rec_file", "=", "get_mol_as_file", "(", "rec_mol", ")", "\n", "lig_file", "=", "get_mol_as_file", "(", "lig_mol", ")", "\n", "out_file", "=", "get_temp_file", "(", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "lig_file", ")", ",", "'lig file does not exist'", "\n", "\n", "cmd", "=", "f'{GNINA_CMD} --minimize -r {rec_file} -l {lig_file} '", "f'--autobox_ligand {lig_file} -o {out_file}'", "\n", "\n", "error", "=", "None", "\n", "last_stdout", "=", "''", "\n", "proc", "=", "Popen", "(", "shlex", ".", "split", "(", "cmd", ")", ",", "stdout", "=", "PIPE", ",", "stderr", "=", "PIPE", ")", "\n", "for", "c", "in", "iter", "(", "lambda", ":", "proc", ".", "stdout", ".", "read", "(", "1", ")", ",", "b''", ")", ":", "\n", "        ", "sys", ".", "stdout", ".", "buffer", ".", "write", "(", "c", ")", "\n", "last_stdout", "+=", "c", ".", "decode", "(", ")", "\n", "if", "c", "==", "b'*'", "or", "c", "==", "b'\\n'", ":", "# progress bar or new line", "\n", "            ", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "if", "last_stdout", ".", "startswith", "(", "'WARNING'", ")", ":", "\n", "                ", "error", "=", "last_stdout", "\n", "", "last_stdout", "=", "''", "\n", "\n", "", "", "stderr", "=", "proc", ".", "stderr", ".", "read", "(", ")", ".", "decode", "(", ")", "\n", "for", "stderr_line", "in", "stderr", ".", "split", "(", "'\\n'", ")", ":", "\n", "        ", "if", "stderr_line", ".", "startswith", "(", "'CUDNN Error'", ")", ":", "\n", "            ", "error", "=", "stderr_line", "\n", "\n", "", "", "print", "(", "'GNINA STDERR'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "stderr", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'END GNINA STDERR'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "try", ":", "# get top-ranked pose according to gnina", "\n", "        ", "out_mol", "=", "Molecule", ".", "from_sdf", "(", "out_file", ",", "idx", "=", "0", ",", "sanitize", "=", "False", ")", "\n", "", "except", "IndexError", ":", "\n", "        ", "out_mol", "=", "Molecule", "(", "Chem", ".", "RWMol", "(", "lig_mol", ")", ")", "\n", "if", "not", "error", ":", "\n", "            ", "error", "=", "stderr", "\n", "\n", "", "", "out_mol", ".", "info", "[", "'error'", "]", "=", "error", "\n", "return", "out_mol", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.symbol": [[179, 181], ["ob.GetSymbol", "atom_types.Atom.GetAtomicNum"], "methods", ["None"], ["def", "symbol", "(", "self", ")", ":", "\n", "        ", "return", "ob", ".", "GetSymbol", "(", "self", ".", "GetAtomicNum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.atomic_num": [[182, 184], ["atom_types.Atom.GetAtomicNum"], "methods", ["None"], ["", "def", "atomic_num", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetAtomicNum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.aromatic": [[185, 187], ["atom_types.Atom.IsAromatic"], "methods", ["None"], ["", "def", "aromatic", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "IsAromatic", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.h_acceptor": [[188, 190], ["atom_types.Atom.IsHbondAcceptor"], "methods", ["None"], ["", "def", "h_acceptor", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "IsHbondAcceptor", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.h_donor": [[191, 193], ["atom_types.Atom.IsHbondDonor"], "methods", ["None"], ["", "def", "h_donor", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "IsHbondDonor", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.formal_charge": [[194, 196], ["atom_types.Atom.GetFormalCharge"], "methods", ["None"], ["", "def", "formal_charge", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetFormalCharge", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.h_count": [[197, 200], ["atom_types.Atom.GetTotalDegree", "atom_types.Atom.GetHvyDegree"], "methods", ["None"], ["", "def", "h_count", "(", "self", ")", ":", "\n", "# this includes both explicit and implicit Hs", "\n", "        ", "return", "self", ".", "GetTotalDegree", "(", ")", "-", "self", ".", "GetHvyDegree", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.imp_h_count": [[201, 203], ["atom_types.Atom.GetImplicitHCount"], "methods", ["None"], ["", "def", "imp_h_count", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetImplicitHCount", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.exp_h_count": [[204, 206], ["atom_types.Atom.GetExplicitDegree", "atom_types.Atom.GetHvyDegree"], "methods", ["None"], ["", "def", "exp_h_count", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetExplicitDegree", "(", ")", "-", "self", ".", "GetHvyDegree", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.hybridization": [[207, 209], ["atom_types.Atom.GetHyb"], "methods", ["None"], ["", "def", "hybridization", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "GetHyb", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.vdw_radius": [[210, 213], ["ob.GetVdwRad"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "vdw_radius", "(", "atomic_num", ")", ":", "\n", "        ", "return", "ob", ".", "GetVdwRad", "(", "atomic_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.cov_radius": [[214, 217], ["ob.GetCovalentRad"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "cov_radius", "(", "atomic_num", ")", ":", "\n", "        ", "return", "ob", ".", "GetCovalentRad", "(", "atomic_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.__init__": [[244, 284], ["atom_types.AtomTyper.check_args", "sum", "molgrid.PythonCallbackVectorTyper.__init__", "dict", "zip", "torch.tensor", "collections.namedtuple", "slice", "len", "len", "enumerate", "radius_func", "atom_types.AtomTyper.get_type_vector", "atom_types.AtomTyper.get_radius", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.check_args", "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_vector", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_radius"], ["def", "__init__", "(", "\n", "self", ",", "\n", "prop_funcs", ",", "\n", "prop_ranges", ",", "\n", "radius_func", ",", "\n", "explicit_h", "=", "False", ",", "\n", "device", "=", "'cuda'", ",", "\n", ")", ":", "\n", "        ", "self", ".", "check_args", "(", "prop_funcs", ",", "prop_ranges", ",", "radius_func", ",", "explicit_h", ")", "\n", "self", ".", "prop_funcs", "=", "prop_funcs", "\n", "self", ".", "prop_ranges", "=", "prop_ranges", "\n", "self", ".", "radius_func", "=", "radius_func", "\n", "self", ".", "explicit_h", "=", "explicit_h", "\n", "\n", "# cached properties", "\n", "self", ".", "_n_types", "=", "sum", "(", "len", "(", "r", ")", "for", "r", "in", "self", ".", "prop_ranges", ")", "\n", "\n", "# initialize the inherited molgrid.AtomTyper", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "lambda", "a", ":", "(", "self", ".", "get_type_vector", "(", "a", ")", ",", "self", ".", "get_radius", "(", "a", ")", ")", ",", "\n", "self", ".", "n_types", "\n", ")", "\n", "\n", "# inverted indexes", "\n", "self", ".", "prop_idx", "=", "{", "p", ":", "i", "for", "i", ",", "p", "in", "enumerate", "(", "self", ".", "prop_funcs", ")", "}", "\n", "self", ".", "type_vec_idx", "=", "dict", "(", ")", "\n", "i", "=", "0", "\n", "for", "prop", ",", "range_", "in", "zip", "(", "self", ".", "prop_funcs", ",", "self", ".", "prop_ranges", ")", ":", "\n", "            ", "self", ".", "type_vec_idx", "[", "prop", "]", "=", "slice", "(", "i", ",", "i", "+", "len", "(", "range_", ")", ")", "\n", "i", "+=", "len", "(", "range_", ")", "\n", "\n", "# precomputed atomic radii", "\n", "", "self", ".", "elem_radii", "=", "torch", ".", "tensor", "(", "\n", "[", "radius_func", "(", "v", ")", "for", "v", "in", "self", ".", "elem_range", "]", ",", "\n", "device", "=", "device", "\n", ")", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "atom_type", "=", "namedtuple", "(", "\n", "'atom_type'", ",", "[", "f", ".", "__name__", "for", "f", "in", "prop_funcs", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.check_args": [[286, 294], ["all", "all", "len", "len", "bool"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "check_args", "(", "prop_funcs", ",", "prop_ranges", ",", "radius_func", ",", "explicit_h", ")", ":", "\n", "        ", "assert", "len", "(", "prop_funcs", ")", "==", "len", "(", "prop_ranges", ")", "\n", "assert", "all", "(", "f", ".", "__call__", "for", "f", "in", "prop_funcs", ")", "\n", "assert", "all", "(", "r", ".", "__len__", "for", "r", "in", "prop_ranges", ")", "\n", "assert", "radius_func", ".", "__call__", "\n", "assert", "prop_funcs", "[", "0", "]", "==", "Atom", ".", "atomic_num", "\n", "assert", "bool", "(", "explicit_h", ")", "==", "(", "1", "in", "prop_ranges", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.n_types": [[295, 298], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_types", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n_types", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.n_elem_types": [[299, 302], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_elem_types", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "elem_range", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.n_prop_types": [[303, 306], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_prop_types", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_types", "-", "self", ".", "n_elem_types", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.elem_range": [[311, 316], ["len", "bool"], "methods", ["None"], ["", "@", "elem_range", ".", "setter", "\n", "def", "elem_range", "(", "self", ",", "new_elem_range", ")", ":", "\n", "        ", "assert", "len", "(", "new_elem_range", ")", ">", "0", ",", "'empty element range'", "\n", "assert", "bool", "(", "self", ".", "explicit_h", ")", "==", "(", "1", "in", "new_elem_range", ")", "\n", "self", ".", "prop_ranges", "[", "0", "]", "=", "new_elem_range", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.__contains__": [[317, 319], ["None"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "prop", ")", ":", "\n", "        ", "return", "prop", "in", "self", ".", "prop_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_names": [[320, 324], ["zip"], "methods", ["None"], ["", "def", "get_type_names", "(", "self", ")", ":", "\n", "        ", "for", "func", ",", "range_", "in", "zip", "(", "self", ".", "prop_funcs", ",", "self", ".", "prop_ranges", ")", ":", "\n", "            ", "for", "value", "in", "range_", ":", "\n", "                ", "yield", "'{}={}'", ".", "format", "(", "func", ".", "__name__", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_vector": [[325, 332], ["tuple", "atom_types.AtomTyper.get_type_vec_from_prop_values", "ob_atom.GetAtomicNum", "f"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_vec_from_prop_values"], ["", "", "", "def", "get_type_vector", "(", "self", ",", "ob_atom", ")", ":", "\n", "\n", "        ", "if", "not", "self", ".", "explicit_h", "and", "ob_atom", ".", "GetAtomicNum", "(", ")", "==", "1", ":", "\n", "            ", "return", "[", "0", "]", "*", "self", ".", "n_types", "\n", "\n", "", "prop_values", "=", "tuple", "(", "f", "(", "ob_atom", ")", "for", "f", "in", "self", ".", "prop_funcs", ")", "\n", "return", "self", ".", "get_type_vec_from_prop_values", "(", "prop_values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_vec_from_prop_values": [[333, 341], ["functools.lru_cache", "zip", "atom_types.make_one_hot"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot"], ["", "@", "lru_cache", "(", "maxsize", "=", "65536", ")", "\n", "def", "get_type_vec_from_prop_values", "(", "self", ",", "prop_values", ")", ":", "\n", "\n", "        ", "type_vec", "=", "[", "]", "\n", "for", "value", ",", "range_", "in", "zip", "(", "prop_values", ",", "self", ".", "prop_ranges", ")", ":", "\n", "            ", "type_vec", "+=", "make_one_hot", "(", "value", ",", "range_", ")", "\n", "\n", "", "return", "type_vec", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_radius": [[342, 344], ["atom_types.AtomTyper.radius_func", "ob_atom.GetAtomicNum"], "methods", ["None"], ["", "def", "get_radius", "(", "self", ",", "ob_atom", ")", ":", "\n", "        ", "return", "self", ".", "radius_func", "(", "ob_atom", ".", "GetAtomicNum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct": [[345, 367], ["ob_mol.NumAtoms", "numpy.zeros", "numpy.zeros", "enumerate", "atom_structs.AtomStruct", "ob.OBMolAtomIter", "atom_types.AtomTyper.get_type_vector", "ob_atom.GetX", "ob_atom.GetY", "ob_atom.GetZ"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_vector"], ["", "def", "make_struct", "(", "self", ",", "ob_mol", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "'cuda'", ",", "**", "info", ")", ":", "\n", "        ", "'''\n        Convert an OBMol to an AtomStruct\n        by assigning each atom a type vector\n        based on its atomic properties.\n        '''", "\n", "n_atoms", "=", "ob_mol", ".", "NumAtoms", "(", ")", "\n", "coords", "=", "np", ".", "zeros", "(", "(", "n_atoms", ",", "3", ")", ")", "\n", "types", "=", "np", ".", "zeros", "(", "(", "n_atoms", ",", "self", ".", "n_types", ")", ")", "\n", "\n", "for", "i", ",", "ob_atom", "in", "enumerate", "(", "ob", ".", "OBMolAtomIter", "(", "ob_mol", ")", ")", ":", "\n", "            ", "coords", "[", "i", "]", "=", "ob_atom", ".", "GetX", "(", ")", ",", "ob_atom", ".", "GetY", "(", ")", ",", "ob_atom", ".", "GetZ", "(", ")", "\n", "types", "[", "i", "]", "=", "self", ".", "get_type_vector", "(", "ob_atom", ")", "\n", "\n", "", "return", "AtomStruct", "(", "\n", "coords", "=", "coords", ",", "\n", "types", "=", "types", ",", "\n", "typer", "=", "self", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "self", ".", "device", "if", "device", "is", "None", "else", "device", ",", "\n", "src_mol", "=", "ob_mol", ",", "# caution: src_mol is an rd_mol elsewhere", "\n", "**", "info", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_atom_type": [[369, 388], ["zip", "atom_types.AtomTyper.atom_type", "values.append", "len", "len", "any", "len", "prop_vec.argmax().item", "prop_vec.argmax"], "methods", ["None"], ["", "def", "get_atom_type", "(", "self", ",", "type_vec", ")", ":", "\n", "        ", "'''\n        Return a named tuple that has atomic properties\n        and values defined as represented by the given\n        type_vec.\n        '''", "\n", "i", "=", "0", "\n", "values", "=", "[", "]", "\n", "for", "prop", ",", "range_", "in", "zip", "(", "self", ".", "prop_funcs", ",", "self", ".", "prop_ranges", ")", ":", "\n", "            ", "prop_vec", "=", "type_vec", "[", "i", ":", "i", "+", "len", "(", "range_", ")", "]", "\n", "if", "len", "(", "range_", ")", ">", "1", ":", "# argmax", "\n", "                ", "assert", "any", "(", "prop_vec", ">", "0", ")", ",", "'missing value for {}'", ".", "format", "(", "prop", ".", "__name__", ")", "\n", "value", "=", "range_", "[", "prop_vec", ".", "argmax", "(", ")", ".", "item", "(", ")", "]", "\n", "", "else", ":", "# boolean", "\n", "                ", "value", "=", "(", "prop_vec", ">", "0.5", ")", ".", "item", "(", ")", "\n", "", "values", ".", "append", "(", "value", ")", "\n", "i", "+=", "len", "(", "range_", ")", "\n", "", "return", "self", ".", "atom_type", "(", "*", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_default_rec_typer": [[389, 392], ["cls.get_typer"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer"], ["", "@", "classmethod", "\n", "def", "get_default_rec_typer", "(", "cls", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "return", "cls", ".", "get_typer", "(", "prop_funcs", "=", "'oadc'", ",", "radius_func", "=", "1.0", ",", "rec", "=", "True", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_default_lig_typer": [[393, 396], ["cls.get_typer"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer"], ["", "@", "classmethod", "\n", "def", "get_default_lig_typer", "(", "cls", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "return", "cls", ".", "get_typer", "(", "prop_funcs", "=", "'oadc'", ",", "radius_func", "=", "1.0", ",", "rec", "=", "False", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer": [[397, 479], ["cls", "prop_ranges[].insert", "float", "list", "list"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "get_typer", "(", "cls", ",", "prop_funcs", "=", "'oadc'", ",", "radius_func", "=", "1.0", ",", "rec", "=", "False", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "'''\n        Factory method for creating AtomTypers\n        using simple string codes that specify\n        which property channels to include after\n        the element channels.\n\n        The ranges for these channels are all\n        set automatically, and were selected\n        for the Crossdock2020 dataset.\n\n        prop_funcs (default: 'oadc')\n          o -> aromatic [False, True]\n          a -> h bond acceptor [True]\n          d -> h bond donor [True]\n          c -> formal charge [-1, 0, 1]\n          n -> hydrogen count [0, 1, 2, 3, 4]\n          h -> use explicit hydrogens\n\n        radius_func (default: 1.0)\n          v -> van der Waals radius\n          c -> covalent radius\n          # -> fixed radius size (in angstroms)\n\n        rec (default: False)\n          False -> use ligand elements\n            [B, C, N, O, F, P, S, Cl, Br, I, Fe]\n          True -> use receptor elements\n            [C, N, O, Na, Mg, P, S, Cl, K, Ca, Zn]\n\n        Out-of-range heavy elements are converted\n        to the last elements in the range.\n        '''", "\n", "pf", ",", "rf", "=", "prop_funcs", ",", "radius_func", "\n", "\n", "# first property is always atomic number", "\n", "prop_funcs", "=", "[", "Atom", ".", "atomic_num", "]", "\n", "\n", "# use different ranges for receptors than ligands", "\n", "if", "rec", ":", "\n", "            ", "prop_ranges", "=", "[", "list", "(", "cls", ".", "rec_elem_range", ")", "]", "\n", "", "else", ":", "# ligand", "\n", "            ", "prop_ranges", "=", "[", "list", "(", "cls", ".", "lig_elem_range", ")", "]", "\n", "\n", "", "explicit_h", "=", "(", "'h'", "in", "pf", ")", "\n", "if", "explicit_h", ":", "\n", "            ", "prop_ranges", "[", "0", "]", ".", "insert", "(", "0", ",", "1", ")", "\n", "\n", "", "if", "'o'", "in", "pf", ":", "\n", "            ", "prop_funcs", "+=", "[", "Atom", ".", "aromatic", "]", "\n", "prop_ranges", "+=", "[", "[", "0", ",", "1", "]", "]", "\n", "\n", "", "if", "'a'", "in", "pf", ":", "\n", "            ", "prop_funcs", "+=", "[", "Atom", ".", "h_acceptor", "]", "\n", "prop_ranges", "+=", "[", "[", "1", "]", "]", "\n", "\n", "", "if", "'d'", "in", "pf", ":", "\n", "            ", "prop_funcs", "+=", "[", "Atom", ".", "h_donor", "]", "\n", "prop_ranges", "+=", "[", "[", "1", "]", "]", "\n", "\n", "", "if", "'c'", "in", "pf", ":", "\n", "            ", "prop_funcs", "+=", "[", "Atom", ".", "formal_charge", "]", "\n", "prop_ranges", "+=", "[", "[", "-", "1", ",", "0", ",", "1", "]", "]", "\n", "\n", "", "if", "'n'", "in", "pf", ":", "\n", "            ", "prop_funcs", "+=", "[", "Atom", ".", "h_count", "]", "\n", "prop_ranges", "+=", "[", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", "]", "]", "\n", "\n", "", "try", ":", "# interpret as fixed radius", "\n", "            ", "fixed_radius", "=", "float", "(", "rf", ")", "\n", "radius_func", "=", "lambda", "x", ":", "fixed_radius", "\n", "\n", "", "except", ":", "# element-specific radius", "\n", "\n", "            ", "if", "rf", "==", "'v'", ":", "# van der Waals", "\n", "                ", "radius_func", "=", "Atom", ".", "vdw_radius", "\n", "\n", "", "elif", "rf", "==", "'c'", ":", "# covalent", "\n", "                ", "radius_func", "=", "Atom", ".", "cov_radius", "\n", "\n", "", "", "return", "cls", "(", "prop_funcs", ",", "prop_ranges", ",", "radius_func", ",", "explicit_h", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.make_one_hot": [[485, 494], ["len", "len", "range_.index", "len"], "function", ["None"], ["def", "make_one_hot", "(", "value", ",", "range_", ")", ":", "\n", "    ", "assert", "len", "(", "range_", ")", ">", "0", "\n", "vec", "=", "[", "0", "]", "*", "len", "(", "range_", ")", "\n", "try", ":", "\n", "        ", "vec", "[", "range_", ".", "index", "(", "value", ")", "]", "=", "1", "\n", "", "except", "ValueError", ":", "\n", "        ", "if", "len", "(", "range_", ")", ">", "1", ":", "\n", "            ", "vec", "[", "-", "1", "]", "=", "1", "\n", "", "", "return", "vec", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channel_color": [[496, 507], ["get_rgb"], "function", ["None"], ["", "def", "get_channel_color", "(", "channel", ")", ":", "\n", "    ", "if", "'LigandAliphatic'", "in", "channel", ".", "name", ":", "\n", "        ", "return", "[", "1.00", ",", "1.00", ",", "1.00", "]", "#[1.00, 0.50, 1.00]", "\n", "", "elif", "'LigandAromatic'", "in", "channel", ".", "name", ":", "\n", "        ", "return", "[", "0.83", ",", "0.83", ",", "0.83", "]", "#[1.00, 0.00, 1.00]", "\n", "", "elif", "'ReceptorAliphatic'", "in", "channel", ".", "name", ":", "\n", "        ", "return", "[", "1.00", ",", "1.00", ",", "1.00", "]", "\n", "", "elif", "'ReceptorAromatic'", "in", "channel", ".", "name", ":", "\n", "        ", "return", "[", "0.83", ",", "0.83", ",", "0.83", "]", "\n", "", "else", ":", "\n", "        ", "return", "get_rgb", "(", "channel", ".", "atomic_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channel": [[509, 513], ["channel"], "function", ["None"], ["", "", "def", "get_channel", "(", "t", ",", "use_covalent_radius", ",", "name_prefix", ")", ":", "\n", "    ", "name", "=", "name_prefix", "+", "t", ".", "name", "\n", "atomic_radius", "=", "t", ".", "covalent_radius", "if", "use_covalent_radius", "else", "t", ".", "xs_radius", "\n", "return", "channel", "(", "name", ",", "t", ".", "atomic_num", ",", "t", ".", "symbol", ",", "atomic_radius", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_by_index": [[515, 522], ["atom_types.get_channel", "channels.append"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channel"], ["", "def", "get_channels_by_index", "(", "type_idx", ",", "use_covalent_radius", "=", "False", ",", "name_prefix", "=", "''", ")", ":", "\n", "    ", "channels", "=", "[", "]", "\n", "for", "i", "in", "type_idx", ":", "\n", "        ", "t", "=", "smina_types", "[", "i", "]", "\n", "c", "=", "get_channel", "(", "t", ",", "use_covalent_radius", ",", "name_prefix", ")", "\n", "channels", ".", "append", "(", "c", ")", "\n", "", "return", "channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_by_name": [[524, 531], ["atom_types.get_channel", "channels.append"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channel"], ["", "def", "get_channels_by_name", "(", "type_names", ",", "use_covalent_radius", "=", "False", ",", "name_prefix", "=", "''", ")", ":", "\n", "    ", "channels", "=", "[", "]", "\n", "for", "type_name", "in", "type_names", ":", "\n", "        ", "t", "=", "smina_types_by_name", "[", "type_name", "]", "\n", "c", "=", "get_channel", "(", "t", ",", "use_covalent_radius", ",", "name_prefix", ")", "\n", "channels", ".", "append", "(", "c", ")", "\n", "", "return", "channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_from_map": [[533, 535], ["atom_types.get_channels_by_name", "map_.get_type_names"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_by_name", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_names"], ["", "def", "get_channels_from_map", "(", "map_", ",", "use_covalent_radius", "=", "False", ",", "name_prefix", "=", "''", ")", ":", "\n", "    ", "return", "get_channels_by_name", "(", "map_", ".", "get_type_names", "(", ")", ",", "use_covalent_radius", ",", "name_prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_from_file": [[537, 541], ["molgrid.FileMappedGninaTyper", "atom_types.get_channels_from_map"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_from_map"], ["", "def", "get_channels_from_file", "(", "map_file", ",", "use_covalent_radius", "=", "False", ",", "name_prefix", "=", "''", ")", ":", "\n", "    ", "import", "molgrid", "\n", "map_", "=", "molgrid", ".", "FileMappedGninaTyper", "(", "map_file", ")", "\n", "return", "get_channels_from_map", "(", "map_", ",", "use_covalent_radius", ",", "name_prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_n_unknown_channels": [[542, 547], ["range", "channels.append", "channel"], "function", ["None"], ["", "def", "get_n_unknown_channels", "(", "n", ",", "radius", "=", "1.0", ")", ":", "\n", "    ", "channels", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "channels", ".", "append", "(", "channel", "(", "'Unknown'", ",", "0", ",", "'X'", ",", "radius", ")", ")", "\n", "", "return", "channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_default_rec_channels": [[549, 552], ["atom_types.get_channels_by_index"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_by_index"], ["", "def", "get_default_rec_channels", "(", "use_covalent_radius", "=", "False", ",", "name_prefix", "=", "''", ")", ":", "\n", "    ", "idx", "=", "[", "2", ",", "3", ",", "4", ",", "5", ",", "24", ",", "25", ",", "21", ",", "6", ",", "9", ",", "7", ",", "8", ",", "13", ",", "12", ",", "16", ",", "14", ",", "23", "]", "\n", "return", "get_channels_by_index", "(", "idx", ",", "use_covalent_radius", ",", "name_prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_default_lig_channels": [[554, 557], ["atom_types.get_channels_by_index"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_by_index"], ["", "def", "get_default_lig_channels", "(", "use_covalent_radius", "=", "False", ",", "name_prefix", "=", "''", ")", ":", "\n", "    ", "idx", "=", "[", "2", ",", "3", ",", "4", ",", "5", ",", "19", ",", "18", ",", "17", ",", "6", ",", "9", ",", "7", ",", "8", ",", "10", ",", "13", ",", "12", ",", "16", ",", "14", ",", "15", ",", "20", ",", "27", "]", "\n", "return", "get_channels_by_index", "(", "idx", ",", "use_covalent_radius", ",", "name_prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_default_channels": [[559, 563], ["atom_types.get_default_rec_channels", "atom_types.get_default_lig_channels"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_default_rec_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_default_lig_channels"], ["", "def", "get_default_channels", "(", "use_covalent_radius", "=", "False", ")", ":", "\n", "    ", "rec_channels", "=", "get_default_rec_channels", "(", "use_covalent_radius", ")", "\n", "lig_channels", "=", "get_default_lig_channels", "(", "use_covalent_radius", ")", "\n", "return", "rec_channels", "+", "lig_channels", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.__init__": [[76, 157], ["torch.nn.Module.__init__", "print", "training.GenerativeSolver.init_data", "loss_fn_kws.pop", "print", "training.GenerativeSolver.init_gen_model", "training.GenerativeSolver.init_gen_optimizer", "training.GenerativeSolver.init_loss_fn", "print", "atom_fitting.AtomFitter", "bond_adding.BondAdder", "pandas.DataFrame", "training.GenerativeSolver.metrics.set_index", "training.GenerativeSolver.wandb_kws.get", "print", "training.GenerativeSolver.init_disc_model", "training.GenerativeSolver.init_disc_optimizer", "print", "training.GenerativeSolver.init_prior_model", "training.GenerativeSolver.init_prior_optimizer", "ImportError"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_data", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_gen_model", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_gen_optimizer", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_loss_fn", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_disc_model", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_disc_optimizer", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_prior_model", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_prior_optimizer"], ["def", "__init__", "(", "\n", "self", ",", "\n", "out_prefix", ",", "\n", "data_kws", "=", "{", "}", ",", "\n", "wandb_kws", ":", "dict", "=", "{", "}", ",", "\n", "gen_model_kws", "=", "{", "}", ",", "\n", "disc_model_kws", "=", "{", "}", ",", "\n", "prior_model_kws", "=", "{", "}", ",", "\n", "loss_fn_kws", "=", "{", "}", ",", "\n", "gen_optim_kws", "=", "{", "}", ",", "\n", "disc_optim_kws", "=", "{", "}", ",", "\n", "prior_optim_kws", "=", "{", "}", ",", "\n", "atom_fitting_kws", "=", "{", "}", ",", "\n", "bond_adding_kws", "=", "{", "}", ",", "\n", "device", "=", "'cuda'", ",", "\n", "debug", "=", "False", ",", "\n", "sync_cuda", "=", "False", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "device", "=", "device", "\n", "\n", "print", "(", "'Loading data'", ")", "\n", "self", ".", "init_data", "(", "device", "=", "device", ",", "**", "data_kws", ")", "\n", "\n", "# learn recon loss variance as a parameter", "\n", "self", ".", "learn_recon_var", "=", "loss_fn_kws", ".", "pop", "(", "'learn_recon_var'", ",", "False", ")", "\n", "\n", "print", "(", "'Initializing generative model and optimizer'", ")", "\n", "self", ".", "init_gen_model", "(", "device", "=", "device", ",", "**", "gen_model_kws", ")", "\n", "self", ".", "init_gen_optimizer", "(", "**", "gen_optim_kws", ")", "\n", "\n", "if", "self", ".", "has_disc_model", ":", "\n", "\n", "            ", "print", "(", "'Initializing discriminative model and optimizer'", ")", "\n", "self", ".", "init_disc_model", "(", "device", "=", "device", ",", "**", "disc_model_kws", ")", "\n", "self", ".", "init_disc_optimizer", "(", "**", "disc_optim_kws", ")", "\n", "\n", "", "else", ":", "# needed for df index", "\n", "            ", "self", ".", "disc_iter", "=", "0", "\n", "\n", "", "if", "self", ".", "has_prior_model", ":", "\n", "\n", "            ", "print", "(", "'Initializing prior model and optimizer'", ")", "\n", "self", ".", "init_prior_model", "(", "device", "=", "device", ",", "**", "prior_model_kws", ")", "\n", "self", ".", "init_prior_optimizer", "(", "**", "prior_optim_kws", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_iter", "=", "0", "\n", "\n", "", "self", ".", "init_loss_fn", "(", "device", "=", "device", ",", "**", "loss_fn_kws", ")", "\n", "\n", "print", "(", "'Initializing atom fitter and bond adder'", ")", "\n", "self", ".", "atom_fitter", "=", "atom_fitting", ".", "AtomFitter", "(", "\n", "device", "=", "device", ",", "**", "atom_fitting_kws", "\n", ")", "\n", "self", ".", "bond_adder", "=", "bond_adding", ".", "BondAdder", "(", "\n", "debug", "=", "debug", ",", "**", "bond_adding_kws", "\n", ")", "\n", "\n", "# set up a data frame of training metrics", "\n", "self", ".", "index_cols", "=", "[", "\n", "'iteration'", ",", "# gen model iteration", "\n", "'disc_iter'", ",", "# disc model iteration", "\n", "'data_phase'", ",", "# train/test data", "\n", "'model_phase'", ",", "# gen/disc model", "\n", "'grid_phase'", ",", "# real, prior, poster", "\n", "'batch'", "# batch in current iteration", "\n", "]", "\n", "self", ".", "metrics", "=", "pd", ".", "DataFrame", "(", "columns", "=", "self", ".", "index_cols", ")", "\n", "self", ".", "metrics", ".", "set_index", "(", "self", ".", "index_cols", ",", "inplace", "=", "True", ")", "\n", "\n", "self", ".", "out_prefix", "=", "out_prefix", "\n", "self", ".", "debug", "=", "debug", "\n", "self", ".", "sync_cuda", "=", "sync_cuda", "\n", "\n", "self", ".", "wandb_kws", "=", "wandb_kws", "\n", "self", ".", "use_wandb", ":", "bool", "=", "self", ".", "wandb_kws", ".", "get", "(", "'use_wandb'", ",", "False", ")", "\n", "if", "self", ".", "use_wandb", ":", "\n", "            ", "try", ":", "\n", "                ", "wandb", "\n", "", "except", "NameError", ":", "\n", "                ", "raise", "ImportError", "(", "'wandb is not installed'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_data": [[159, 164], ["data.AtomGridData", "data.AtomGridData"], "methods", ["None"], ["", "", "", "def", "init_data", "(", "self", ",", "device", ",", "train_file", ",", "test_file", ",", "**", "data_kws", ")", ":", "\n", "        ", "self", ".", "train_data", "=", "data", ".", "AtomGridData", "(", "device", "=", "device", ",", "data_file", "=", "train_file", ",", "**", "data_kws", ")", "\n", "self", ".", "test_data", "=", "data", ".", "AtomGridData", "(", "device", "=", "device", ",", "data_file", "=", "test_file", ",", "**", "data_kws", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_gen_model": [[165, 192], ["training.GenerativeSolver.gen_model_type", "training.GenerativeSolver.gen_model.apply", "torch.nn.Parameter", "torch.zeros", "training.GenerativeSolver.gen_model.load_state_dict", "torch.zeros", "torch.load"], "methods", ["None"], ["", "def", "init_gen_model", "(", "\n", "self", ",", "\n", "device", ",", "\n", "caffe_init", "=", "False", ",", "\n", "state", "=", "None", ",", "\n", "**", "gen_model_kws", "\n", ")", ":", "\n", "        ", "self", ".", "gen_model", "=", "self", ".", "gen_model_type", "(", "\n", "n_channels_in", "=", "self", ".", "n_channels_in", ",", "\n", "n_channels_cond", "=", "self", ".", "n_channels_cond", ",", "\n", "n_channels_out", "=", "self", ".", "n_channels_out", ",", "\n", "grid_size", "=", "self", ".", "train_data", ".", "grid_size", ",", "\n", "device", "=", "device", ",", "\n", "**", "gen_model_kws", "\n", ")", "\n", "if", "caffe_init", ":", "\n", "            ", "self", ".", "gen_model", ".", "apply", "(", "models", ".", "caffe_init_weights", ")", "\n", "\n", "", "if", "self", ".", "learn_recon_var", ":", "\n", "            ", "self", ".", "gen_model", ".", "log_recon_var", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "gen_model", ".", "log_recon_var", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", "\n", "", "if", "state", ":", "\n", "            ", "self", ".", "gen_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "state", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_disc_model": [[193, 211], ["models.Discriminator().to", "training.GenerativeSolver.disc_model.apply", "training.GenerativeSolver.disc_model.load_state_dict", "models.Discriminator", "torch.load"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["", "", "def", "init_disc_model", "(", "\n", "self", ",", "\n", "device", ",", "\n", "caffe_init", "=", "False", ",", "\n", "state", "=", "None", ",", "\n", "**", "disc_model_kws", "\n", ")", ":", "\n", "        ", "self", ".", "disc_model", "=", "models", ".", "Discriminator", "(", "\n", "n_channels", "=", "self", ".", "n_channels_disc", ",", "\n", "grid_size", "=", "self", ".", "train_data", ".", "grid_size", ",", "\n", "**", "disc_model_kws", "\n", ")", ".", "to", "(", "device", ")", "\n", "\n", "if", "caffe_init", ":", "\n", "            ", "self", ".", "disc_model", ".", "apply", "(", "models", ".", "caffe_init_weights", ")", "\n", "\n", "", "if", "state", ":", "\n", "            ", "self", ".", "disc_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "state", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_prior_model": [[212, 236], ["models.Stage2VAE().to", "training.GenerativeSolver.prior_model.apply", "torch.nn.Parameter", "torch.zeros", "training.GenerativeSolver.prior_model.load_state_dict", "models.Stage2VAE", "torch.zeros", "torch.load"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["", "", "def", "init_prior_model", "(", "\n", "self", ",", "\n", "device", ",", "\n", "caffe_init", "=", "False", ",", "\n", "state", "=", "None", ",", "\n", "**", "prior_model_kws", "\n", ")", ":", "\n", "        ", "self", ".", "prior_model", "=", "models", ".", "Stage2VAE", "(", "\n", "n_input", "=", "self", ".", "gen_model", ".", "n_latent", ",", "\n", "**", "prior_model_kws", "\n", ")", ".", "to", "(", "device", ")", "\n", "\n", "if", "caffe_init", ":", "\n", "            ", "self", ".", "prior_model", ".", "apply", "(", "models", ".", "caffe_init_weights", ")", "\n", "\n", "", "if", "self", ".", "learn_recon_var", ":", "\n", "            ", "self", ".", "prior_model", ".", "log_recon_var", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_model", ".", "log_recon_var", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", "\n", "", "if", "state", ":", "\n", "            ", "self", ".", "prior_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "state", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_gen_optimizer": [[237, 246], ["getattr", "training.GenerativeSolver.gen_model.parameters"], "methods", ["None"], ["", "", "def", "init_gen_optimizer", "(", "\n", "self", ",", "type", ",", "n_train_iters", "=", "1", ",", "clip_gradient", "=", "0", ",", "**", "gen_optim_kws", "\n", ")", ":", "\n", "        ", "self", ".", "n_gen_train_iters", "=", "n_train_iters", "\n", "self", ".", "gen_clip_grad", "=", "clip_gradient", "\n", "self", ".", "gen_optimizer", "=", "getattr", "(", "optim", ",", "type", ")", "(", "\n", "self", ".", "gen_model", ".", "parameters", "(", ")", ",", "**", "gen_optim_kws", "\n", ")", "\n", "self", ".", "gen_iter", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_disc_optimizer": [[247, 256], ["getattr", "training.GenerativeSolver.disc_model.parameters"], "methods", ["None"], ["", "def", "init_disc_optimizer", "(", "\n", "self", ",", "type", ",", "n_train_iters", "=", "2", ",", "clip_gradient", "=", "0", ",", "**", "disc_optim_kws", "\n", ")", ":", "\n", "        ", "self", ".", "n_disc_train_iters", "=", "n_train_iters", "\n", "self", ".", "disc_clip_grad", "=", "clip_gradient", "\n", "self", ".", "disc_optimizer", "=", "getattr", "(", "optim", ",", "type", ")", "(", "\n", "self", ".", "disc_model", ".", "parameters", "(", ")", ",", "**", "disc_optim_kws", "\n", ")", "\n", "self", ".", "disc_iter", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_prior_optimizer": [[257, 267], ["getattr", "training.GenerativeSolver.prior_model.parameters"], "methods", ["None"], ["", "def", "init_prior_optimizer", "(", "\n", "self", ",", "type", ",", "n_train_iters", "=", "1", ",", "clip_gradient", "=", "0", ",", "**", "prior_optim_kws", "\n", ")", ":", "\n", "        ", "assert", "n_train_iters", "==", "self", ".", "n_gen_train_iters", "\n", "self", ".", "n_prior_train_iters", "=", "n_train_iters", "\n", "self", ".", "prior_clip_grad", "=", "clip_gradient", "\n", "self", ".", "prior_optimizer", "=", "getattr", "(", "optim", ",", "type", ")", "(", "\n", "self", ".", "prior_model", ".", "parameters", "(", ")", ",", "**", "prior_optim_kws", "\n", ")", "\n", "self", ".", "prior_iter", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.init_loss_fn": [[268, 300], ["loss_fns.LossFunction"], "methods", ["None"], ["", "def", "init_loss_fn", "(", "\n", "self", ",", "device", ",", "balance", "=", "False", ",", "**", "loss_fn_kws", ",", "\n", ")", ":", "\n", "        ", "self", ".", "loss_fn", "=", "loss_fns", ".", "LossFunction", "(", "device", "=", "device", ",", "**", "loss_fn_kws", ")", "\n", "\n", "if", "self", ".", "has_disc_model", ":", "\n", "            ", "assert", "self", ".", "loss_fn", ".", "gan_loss_wt", "!=", "0", ",", "'GAN loss weight is zero'", "\n", "\n", "if", "balance", ":", "\n", "                ", "self", ".", "disc_gan_loss", "=", "-", "1", "\n", "self", ".", "gen_gan_loss", "=", "0", "\n", "", "", "else", ":", "\n", "            ", "assert", "self", ".", "loss_fn", ".", "gan_loss_wt", "==", "0", ",", "'non-zero GAN loss weight in non-GAN model'", "\n", "assert", "balance", "==", "False", ",", "'can only balance GAN loss'", "\n", "\n", "", "if", "self", ".", "has_prior_model", ":", "\n", "            ", "assert", "self", ".", "loss_fn", ".", "kldiv2_loss_wt", "!=", "0", ",", "'2-stage VAE kldiv2 loss weight is zero'", "\n", "assert", "self", ".", "loss_fn", ".", "recon2_loss_wt", "!=", "0", ",", "'2-stage VAE recon2 loss weight is zero'", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "loss_fn", ".", "kldiv2_loss_wt", "==", "0", ",", "'non-zero kldiv2 weight, but no stage 2 VAE'", "\n", "assert", "self", ".", "loss_fn", ".", "recon2_loss_wt", "==", "0", ",", "'non-zero recon2 weight, but no stage 2 VAE'", "\n", "\n", "", "if", "not", "self", ".", "gen_model_type", ".", "has_conditional_encoder", ":", "\n", "            ", "assert", "self", ".", "loss_fn", ".", "steric_loss_wt", "==", "0", ",", "'non-zero steric loss but no rec'", "\n", "\n", "", "self", ".", "balance", "=", "balance", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.n_channels_in": [[301, 309], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_channels_in", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "gen_model_type", ".", "has_input_encoder", ":", "\n", "            ", "data", "=", "self", ".", "train_data", "\n", "if", "self", ".", "has_complex_input", ":", "\n", "                ", "return", "data", ".", "n_rec_channels", "+", "data", ".", "n_lig_channels", "\n", "", "else", ":", "\n", "                ", "return", "data", ".", "n_lig_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.n_channels_cond": [[310, 314], ["None"], "methods", ["None"], ["", "", "", "@", "property", "\n", "def", "n_channels_cond", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "gen_model_type", ".", "has_conditional_encoder", ":", "\n", "            ", "return", "self", ".", "train_data", ".", "n_rec_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.n_channels_out": [[315, 318], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "n_channels_out", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "train_data", ".", "n_lig_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.n_channels_disc": [[319, 327], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_channels_disc", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "has_disc_model", ":", "\n", "            ", "data", "=", "self", ".", "train_data", "\n", "if", "self", ".", "gen_model_type", ".", "has_conditional_encoder", ":", "\n", "                ", "return", "data", ".", "n_rec_channels", "+", "data", ".", "n_lig_channels", "\n", "", "else", ":", "\n", "                ", "return", "data", ".", "n_lig_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.state_prefix": [[328, 331], ["training.get_state_prefix"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.get_state_prefix"], ["", "", "", "@", "property", "\n", "def", "state_prefix", "(", "self", ")", ":", "\n", "        ", "return", "get_state_prefix", "(", "self", ".", "out_prefix", ",", "self", ".", "gen_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_model_state_file": [[332, 335], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "gen_model_state_file", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state_prefix", "+", "'.gen_model_state'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_solver_state_file": [[336, 339], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "gen_solver_state_file", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state_prefix", "+", "'.gen_solver_state'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_model_state_file": [[340, 343], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "disc_model_state_file", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state_prefix", "+", "'.disc_model_state'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_solver_state_file": [[344, 347], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "disc_solver_state_file", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state_prefix", "+", "'.disc_solver_state'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.prior_model_state_file": [[348, 351], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "prior_model_state_file", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state_prefix", "+", "'.prior_model_state'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.prior_solver_state_file": [[352, 355], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "prior_solver_state_file", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state_prefix", "+", "'.prior_solver_state'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.metrics_file": [[356, 359], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "metrics_file", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "out_prefix", "+", "'.train_metrics'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_state": [[360, 408], ["training.GenerativeSolver.gen_model.cpu", "print", "torch.save", "print", "collections.OrderedDict", "training.GenerativeSolver.gen_optimizer.state_dict", "torch.save", "training.GenerativeSolver.gen_model.to", "training.GenerativeSolver.gen_model.state_dict", "training.GenerativeSolver.disc_model.cpu", "print", "torch.save", "print", "collections.OrderedDict", "training.GenerativeSolver.disc_optimizer.state_dict", "torch.save", "training.GenerativeSolver.disc_model.to", "training.GenerativeSolver.prior_model.cpu", "print", "torch.save", "print", "collections.OrderedDict", "training.GenerativeSolver.prior_optimizer.state_dict", "torch.save", "training.GenerativeSolver.prior_model.to", "training.GenerativeSolver.disc_model.state_dict", "training.GenerativeSolver.prior_model.state_dict"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["", "def", "save_state", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "gen_model", ".", "cpu", "(", ")", "\n", "\n", "state_file", "=", "self", ".", "gen_model_state_file", "\n", "print", "(", "'Saving generative model state to '", "+", "state_file", ")", "\n", "torch", ".", "save", "(", "self", ".", "gen_model", ".", "state_dict", "(", ")", ",", "state_file", ")", "\n", "\n", "state_file", "=", "self", ".", "gen_solver_state_file", "\n", "print", "(", "'Saving generative solver state to '", "+", "state_file", ")", "\n", "state_dict", "=", "OrderedDict", "(", ")", "\n", "state_dict", "[", "'optim_state'", "]", "=", "self", ".", "gen_optimizer", ".", "state_dict", "(", ")", "\n", "state_dict", "[", "'iter'", "]", "=", "self", ".", "gen_iter", "\n", "torch", ".", "save", "(", "state_dict", ",", "state_file", ")", "\n", "\n", "self", ".", "gen_model", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "if", "self", ".", "has_disc_model", ":", "\n", "            ", "self", ".", "disc_model", ".", "cpu", "(", ")", "\n", "\n", "state_file", "=", "self", ".", "disc_model_state_file", "\n", "print", "(", "'Saving discriminative model state to '", "+", "state_file", ")", "\n", "torch", ".", "save", "(", "self", ".", "disc_model", ".", "state_dict", "(", ")", ",", "state_file", ")", "\n", "\n", "state_file", "=", "self", ".", "disc_solver_state_file", "\n", "print", "(", "'Saving discriminative solver state to '", "+", "state_file", ")", "\n", "state_dict", "=", "OrderedDict", "(", ")", "\n", "state_dict", "[", "'optim_state'", "]", "=", "self", ".", "disc_optimizer", ".", "state_dict", "(", ")", "\n", "state_dict", "[", "'iter'", "]", "=", "self", ".", "disc_iter", "\n", "torch", ".", "save", "(", "state_dict", ",", "state_file", ")", "\n", "\n", "self", ".", "disc_model", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "self", ".", "has_prior_model", ":", "\n", "            ", "self", ".", "prior_model", ".", "cpu", "(", ")", "\n", "\n", "state_file", "=", "self", ".", "prior_model_state_file", "\n", "print", "(", "'Saving prior model state to '", "+", "state_file", ")", "\n", "torch", ".", "save", "(", "self", ".", "prior_model", ".", "state_dict", "(", ")", ",", "state_file", ")", "\n", "\n", "state_file", "=", "self", ".", "prior_solver_state_file", "\n", "print", "(", "'Saving prior solver state to '", "+", "state_file", ")", "\n", "state_dict", "=", "OrderedDict", "(", ")", "\n", "state_dict", "[", "'optim_state'", "]", "=", "self", ".", "prior_optimizer", ".", "state_dict", "(", ")", "\n", "state_dict", "[", "'iter'", "]", "=", "self", ".", "prior_iter", "\n", "torch", ".", "save", "(", "state_dict", ",", "state_file", ")", "\n", "\n", "self", ".", "prior_model", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.load_state": [[409, 450], ["print", "training.GenerativeSolver.gen_model.load_state_dict", "print", "torch.load", "training.GenerativeSolver.gen_optimizer.load_state_dict", "training.GenerativeSolver.find_last_iter", "torch.load", "print", "training.GenerativeSolver.disc_model.load_state_dict", "print", "torch.load", "training.GenerativeSolver.disc_optimizer.load_state_dict", "print", "training.GenerativeSolver.prior_model.load_state_dict", "print", "torch.load", "training.GenerativeSolver.prior_optimizer.load_state_dict", "torch.load", "torch.load"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.find_last_iter", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "load_state", "(", "self", ",", "cont_iter", "=", "None", ")", ":", "\n", "\n", "        ", "if", "cont_iter", "is", "None", ":", "\n", "            ", "self", ".", "gen_iter", "=", "self", ".", "find_last_iter", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "gen_iter", "=", "cont_iter", "\n", "\n", "", "state_file", "=", "self", ".", "state_prefix", "+", "'.gen_model_state'", "\n", "print", "(", "'Loading generative model state from '", "+", "state_file", ")", "\n", "self", ".", "gen_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "state_file", ")", ")", "\n", "\n", "state_file", "=", "self", ".", "state_prefix", "+", "'.gen_solver_state'", "\n", "print", "(", "'Loading generative solver state from '", "+", "state_file", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "state_file", ")", "\n", "\n", "self", ".", "gen_optimizer", ".", "load_state_dict", "(", "state_dict", "[", "'optim_state'", "]", ")", "\n", "self", ".", "gen_iter", "=", "state_dict", "[", "'iter'", "]", "\n", "\n", "if", "self", ".", "has_disc_model", ":", "\n", "\n", "            ", "state_file", "=", "self", ".", "state_prefix", "+", "'.disc_model_state'", "\n", "print", "(", "'Loading discriminative model state from '", "+", "state_file", ")", "\n", "self", ".", "disc_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "state_file", ")", ")", "\n", "\n", "state_file", "=", "self", ".", "state_prefix", "+", "'.disc_solver_state'", "\n", "print", "(", "'Loading discriminative solver state from '", "+", "state_file", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "state_file", ")", "\n", "self", ".", "disc_optimizer", ".", "load_state_dict", "(", "state_dict", "[", "'optim_state'", "]", ")", "\n", "self", ".", "disc_iter", "=", "state_dict", "[", "'iter'", "]", "\n", "\n", "", "if", "self", ".", "has_prior_model", ":", "\n", "\n", "            ", "state_file", "=", "self", ".", "state_prefix", "+", "'.prior_model_state'", "\n", "print", "(", "'Loading prior model state from '", "+", "state_file", ")", "\n", "self", ".", "prior_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "state_file", ")", ")", "\n", "\n", "state_file", "=", "self", ".", "state_prefix", "+", "'.prior_solver_state'", "\n", "print", "(", "'Loading prior solver state from '", "+", "state_file", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "state_file", ")", "\n", "self", ".", "prior_optimizer", ".", "load_state_dict", "(", "state_dict", "[", "'optim_state'", "]", ")", "\n", "self", ".", "prior_iter", "=", "state_dict", "[", "'iter'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.find_last_iter": [[451, 453], ["training.GenerativeSolver.find_last_iter"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.find_last_iter"], ["", "", "def", "find_last_iter", "(", "self", ")", ":", "\n", "        ", "return", "find_last_iter", "(", "self", ".", "out_prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_metrics": [[454, 458], ["print", "training.GenerativeSolver.metrics.to_csv"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "save_metrics", "(", "self", ")", ":", "\n", "        ", "csv_file", "=", "self", ".", "metrics_file", "\n", "print", "(", "'Writing training metrics to '", "+", "csv_file", ")", "\n", "self", ".", "metrics", ".", "to_csv", "(", "csv_file", ",", "sep", "=", "' '", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.load_metrics": [[459, 465], ["print", "pandas.read_csv().set_index", "pandas.read_csv"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "load_metrics", "(", "self", ")", ":", "\n", "        ", "csv_file", "=", "self", ".", "metrics_file", "\n", "print", "(", "'Reading training metrics from '", "+", "csv_file", ")", "\n", "self", ".", "metrics", "=", "pd", ".", "read_csv", "(", "\n", "csv_file", ",", "sep", "=", "' '", "\n", ")", ".", "set_index", "(", "self", ".", "index_cols", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.load_state_and_metrics": [[466, 473], ["training.GenerativeSolver.load_state", "training.GenerativeSolver.load_metrics"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.load_state", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.load_metrics"], ["", "def", "load_state_and_metrics", "(", "self", ",", "cont_iter", "=", "None", ")", ":", "\n", "        ", "self", ".", "load_state", "(", "cont_iter", ")", "\n", "try", ":", "\n", "            ", "self", ".", "load_metrics", "(", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "            ", "if", "self", ".", "gen_iter", ">", "0", ":", "\n", "                ", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_state_and_metrics": [[474, 477], ["training.GenerativeSolver.save_metrics", "training.GenerativeSolver.save_state"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_state"], ["", "", "", "def", "save_state_and_metrics", "(", "self", ")", ":", "\n", "        ", "self", ".", "save_metrics", "(", ")", "\n", "self", ".", "save_state", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.print_metrics": [[478, 486], ["print", "zip", "metrics.items"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "print_metrics", "(", "self", ",", "idx", ",", "metrics", ")", ":", "\n", "        ", "index_str", "=", "' '", ".", "join", "(", "\n", "'{}={}'", ".", "format", "(", "*", "kv", ")", "for", "kv", "in", "zip", "(", "self", ".", "index_cols", ",", "idx", ")", "\n", ")", "\n", "metrics_str", "=", "' '", ".", "join", "(", "\n", "'{}={:.4f}'", ".", "format", "(", "*", "kv", ")", "for", "kv", "in", "metrics", ".", "items", "(", ")", "\n", ")", "\n", "print", "(", "'[{}] {}'", ".", "format", "(", "index_str", ",", "metrics_str", ")", ",", "flush", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.insert_metrics": [[487, 494], ["metrics.items", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "insert_metrics", "(", "self", ",", "idx", ",", "metrics", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "metrics", ".", "loc", "[", "idx", ",", "k", "]", "=", "v", "\n", "", "except", "AttributeError", ":", "\n", "                ", "print", "(", "idx", ",", "k", ")", "\n", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_mols": [[495, 501], ["print", "molecules.write_rd_mols_to_sdf_file"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mols_to_sdf_file"], ["", "", "", "def", "save_mols", "(", "self", ",", "mols", ",", "grid_type", ")", ":", "\n", "        ", "sdf_file", "=", "'{}_iter_{}_{}.sdf'", ".", "format", "(", "\n", "self", ".", "out_prefix", ",", "self", ".", "gen_iter", ",", "grid_type", "\n", ")", "\n", "print", "(", "'Writing generated molecules to '", "+", "sdf_file", ")", "\n", "molecules", ".", "write_rd_mols_to_sdf_file", "(", "sdf_file", ",", "mols", ",", "kekulize", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.has_prior_phase": [[502, 505], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_prior_phase", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "gen_model_type", ".", "is_variational", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.has_posterior_phase": [[506, 511], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_posterior_phase", "(", "self", ")", ":", "\n", "        ", "return", "(", "\n", "self", ".", "gen_model_type", ".", "has_input_encoder", "or", "\n", "not", "self", ".", "has_prior_phase", "# CE exception", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.get_gen_grid_phase": [[513, 538], ["grid_phases.append", "grid_phases.append", "grid_phases.extend", "len"], "methods", ["None"], ["", "def", "get_gen_grid_phase", "(", "self", ",", "batch_idx", ",", "test", "=", "False", ")", ":", "\n", "        ", "'''\n        Determine whether to sample prior or\n        posterior grids in the next gen batch.\n        '''", "\n", "has_prior_phase", "=", "self", ".", "has_prior_phase", "\n", "if", "not", "test", ":", "# only train on prior if there's a loss fn", "\n", "            ", "has_prior_phase", "&=", "self", ".", "loss_fn", ".", "has_prior_loss", "\n", "\n", "", "has_posterior_phase", "=", "self", ".", "has_posterior_phase", "\n", "assert", "has_prior_phase", "or", "has_posterior_phase", ",", "'no gen grid phases'", "\n", "\n", "grid_phases", "=", "[", "]", "\n", "if", "has_posterior_phase", ":", "\n", "            ", "grid_phases", ".", "append", "(", "'poster'", ")", "\n", "\n", "", "if", "has_prior_phase", ":", "\n", "            ", "grid_phases", ".", "append", "(", "'prior'", ")", "\n", "\n", "", "if", "self", ".", "has_prior_model", "and", "test", ":", "\n", "# get metrics on grids decoded from prior model", "\n", "            ", "grid_phases", ".", "extend", "(", "[", "'poster2'", ",", "'prior2'", "]", ")", "\n", "\n", "", "phase_idx", "=", "(", "self", ".", "gen_iter", "+", "batch_idx", ")", "\n", "return", "grid_phases", "[", "phase_idx", "%", "len", "(", "grid_phases", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.get_disc_grid_phase": [[539, 559], ["len"], "methods", ["None"], ["", "def", "get_disc_grid_phase", "(", "self", ",", "batch_idx", ",", "test", "=", "False", ")", ":", "\n", "        ", "'''\n        Determine whether to sample real, prior,\n        or posterior grids in the next disc batch.\n\n        NOT integrated with stage-2 VAE.\n        '''", "\n", "has_prior_phase", "=", "self", ".", "has_prior_phase", "\n", "has_posterior_phase", "=", "self", ".", "has_posterior_phase", "\n", "assert", "has_prior_phase", "or", "has_posterior_phase", ",", "'no disc grid phases'", "\n", "\n", "grid_phases", "=", "[", "]", "\n", "if", "has_posterior_phase", ":", "\n", "            ", "grid_phases", "+=", "[", "'real'", ",", "'poster'", "]", "\n", "\n", "", "if", "has_prior_phase", ":", "\n", "            ", "grid_phases", "+=", "[", "'real'", ",", "'prior'", "]", "\n", "\n", "", "phase_idx", "=", "(", "self", ".", "disc_iter", "+", "batch_idx", ")", "\n", "return", "grid_phases", "[", "phase_idx", "%", "len", "(", "grid_phases", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward": [[560, 729], ["set", "time.time", "time.time", "time.time", "training.GenerativeSolver.loss_fn", "time.time", "time.time", "time.time", "set.add", "set.add", "set.add", "set.add", "repr", "data.forward", "data.split_channels", "data.split_channels", "torch.cuda.synchronize", "training.GenerativeSolver.gen_model.forward2", "training.GenerativeSolver.gen_model", "torch.cuda.synchronize", "torch.ones", "training.GenerativeSolver.disc_model", "torch.cuda.synchronize", "training.GenerativeSolver.atom_fitter.fit_batch", "training.GenerativeSolver.bond_adder.make_batch", "training.GenerativeSolver.save_mols", "torch.cuda.synchronize", "metrics.update", "metrics.update", "metrics.update", "metrics.update", "torch.cuda.synchronize", "latent_vecs.detach.detach.detach", "training.GenerativeSolver.prior_model", "torch.cat", "metrics.compute_paired_grid_metrics", "metrics.compute_grid_metrics", "metrics.compute_paired_grid_metrics", "metrics.compute_scalar_metrics", "metrics.update", "metrics.update", "metrics.update", "torch.zeros", "metrics.compute_paired_struct_metrics", "metrics.compute_struct_metrics", "metrics.compute_paired_struct_metrics"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.split_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.split_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.CVAE2.forward2", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.fit_batch", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_batch", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_mols", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_paired_grid_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_grid_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_paired_grid_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_scalar_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_paired_struct_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_struct_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_paired_struct_metrics"], ["", "def", "gen_forward", "(", "self", ",", "data", ",", "grid_type", ",", "fit_atoms", "=", "False", ")", ":", "\n", "        ", "'''\n        Compute loss and other metrics for the\n        generative model's ability to produce\n        realistic atomic density grids.\n        '''", "\n", "is_varial", "=", "self", ".", "gen_model", ".", "is_variational", "\n", "has_input", "=", "self", ".", "gen_model", ".", "has_input_encoder", "\n", "has_cond", "=", "self", ".", "gen_model_type", ".", "has_conditional_encoder", "\n", "has_disc", "=", "self", ".", "has_disc_model", "\n", "\n", "valid_grid_types", "=", "set", "(", ")", "\n", "if", "self", ".", "has_prior_phase", ":", "\n", "            ", "valid_grid_types", ".", "add", "(", "'prior'", ")", "\n", "", "if", "self", ".", "has_posterior_phase", ":", "\n", "            ", "valid_grid_types", ".", "add", "(", "'poster'", ")", "\n", "", "if", "self", ".", "has_prior_model", ":", "\n", "            ", "valid_grid_types", ".", "add", "(", "'prior2'", ")", "\n", "valid_grid_types", ".", "add", "(", "'poster2'", ")", "\n", "\n", "", "assert", "grid_type", "in", "valid_grid_types", ",", "'invalid grid type '", "+", "repr", "(", "grid_type", ")", "\n", "\n", "if", "grid_type", "[", "-", "1", "]", "==", "'2'", ":", "# decode grids using prior model", "\n", "            ", "grid_type", "=", "grid_type", "[", ":", "-", "1", "]", "\n", "decode_stage2_vecs", "=", "True", "\n", "", "else", ":", "\n", "            ", "decode_stage2_vecs", "=", "False", "\n", "\n", "", "prior", "=", "(", "grid_type", "==", "'prior'", ")", "\n", "posterior", "=", "(", "grid_type", "==", "'poster'", ")", "\n", "\n", "# this flag indicate whether we compute loss for", "\n", "#  the 2nd stage VAE, which we do regardless of", "\n", "#  whether we decode the latent vecs it generates", "\n", "compute_stage2_loss", "=", "(", "posterior", "and", "self", ".", "has_prior_model", ")", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "if", "posterior", "or", "has_cond", ":", "# get real examples", "\n", "            ", "input_grids", ",", "cond_grids", ",", "input_structs", ",", "cond_structs", ",", "_", ",", "_", "=", "data", ".", "forward", "(", ")", "\n", "input_rec_structs", ",", "input_lig_structs", "=", "input_structs", "\n", "cond_rec_structs", ",", "cond_lig_structs", "=", "cond_structs", "\n", "input_rec_grids", ",", "input_lig_grids", "=", "data", ".", "split_channels", "(", "input_grids", ")", "\n", "cond_rec_grids", ",", "cond_lig_grids", "=", "data", ".", "split_channels", "(", "cond_grids", ")", "\n", "\n", "", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "t1", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "posterior", ":", "# set generator input grids", "\n", "            ", "gen_input_grids", "=", "input_grids", "if", "self", ".", "has_complex_input", "else", "input_lig_grids", "\n", "\n", "", "if", "decode_stage2_vecs", ":", "# should only do this in test phase", "\n", "            ", "lig_gen_grids", ",", "latent_vecs", ",", "latent_means", ",", "latent_log_stds", ",", "latent_vecs_gen", ",", "latent2_means", ",", "latent2_log_stds", "=", "self", ".", "gen_model", ".", "forward2", "(", "\n", "prior_model", "=", "self", ".", "prior_model", ",", "\n", "inputs", "=", "gen_input_grids", "if", "posterior", "else", "None", ",", "\n", "conditions", "=", "cond_rec_grids", "if", "has_cond", "else", "None", ",", "\n", "batch_size", "=", "data", ".", "batch_size", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "lig_gen_grids", ",", "latent_vecs", ",", "latent_means", ",", "latent_log_stds", "=", "self", ".", "gen_model", "(", "\n", "inputs", "=", "gen_input_grids", "if", "posterior", "else", "None", ",", "\n", "conditions", "=", "cond_rec_grids", "if", "has_cond", "else", "None", ",", "\n", "batch_size", "=", "data", ".", "batch_size", ",", "\n", ")", "\n", "if", "compute_stage2_loss", ":", "\n", "                ", "latent_vecs", "=", "latent_vecs", ".", "detach", "(", ")", "# don't back prop", "\n", "latent_vecs_gen", ",", "_", ",", "latent2_means", ",", "latent2_log_stds", "=", "self", ".", "prior_model", "(", "\n", "inputs", "=", "latent_vecs", ",", "batch_size", "=", "data", ".", "batch_size", "\n", ")", "\n", "\n", "", "", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "t2", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "has_disc", ":", "# get discriminator predictions", "\n", "            ", "if", "has_cond", ":", "\n", "                ", "disc_input_grids", "=", "torch", ".", "cat", "(", "[", "cond_rec_grids", ",", "lig_gen_grids", "]", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "disc_input_grids", "=", "lig_gen_grids", "\n", "\n", "", "disc_labels", "=", "torch", ".", "ones", "(", "data", ".", "batch_size", ",", "1", ",", "device", "=", "self", ".", "device", ")", "\n", "disc_preds", ",", "_", "=", "self", ".", "disc_model", "(", "inputs", "=", "disc_input_grids", ")", "\n", "\n", "", "loss", ",", "metrics", "=", "self", ".", "loss_fn", "(", "\n", "lig_grids", "=", "cond_lig_grids", "if", "posterior", "else", "None", ",", "\n", "lig_gen_grids", "=", "lig_gen_grids", "if", "posterior", "else", "None", ",", "\n", "disc_labels", "=", "disc_labels", "if", "has_disc", "else", "None", ",", "\n", "disc_preds", "=", "disc_preds", "if", "has_disc", "else", "None", ",", "\n", "latent_means", "=", "latent_means", "if", "posterior", "else", "None", ",", "\n", "latent_log_stds", "=", "latent_log_stds", "if", "posterior", "else", "None", ",", "\n", "rec_grids", "=", "cond_rec_grids", "if", "has_cond", "else", "None", ",", "\n", "rec_lig_grids", "=", "lig_gen_grids", "if", "has_cond", "else", "None", ",", "\n", "latent2_means", "=", "latent2_means", "if", "compute_stage2_loss", "else", "None", ",", "\n", "latent2_log_stds", "=", "latent2_log_stds", "if", "compute_stage2_loss", "else", "None", ",", "\n", "real_latents", "=", "latent_vecs", "if", "compute_stage2_loss", "else", "None", ",", "\n", "gen_latents", "=", "latent_vecs_gen", "if", "compute_stage2_loss", "else", "None", ",", "\n", "gen_log_var", "=", "self", ".", "gen_model", ".", "log_recon_var", "if", "posterior", "else", "None", ",", "\n", "prior_log_var", "=", "self", ".", "prior_model", ".", "log_recon_var", "if", "compute_stage2_loss", "else", "None", ",", "\n", "iteration", "=", "self", ".", "gen_iter", ",", "\n", ")", "\n", "\n", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "t3", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "fit_atoms", ":", "\n", "            ", "lig_gen_fit_structs", ",", "_", "=", "self", ".", "atom_fitter", ".", "fit_batch", "(", "\n", "batch_values", "=", "lig_gen_grids", ",", "\n", "center", "=", "torch", ".", "zeros", "(", "3", ")", ",", "\n", "resolution", "=", "data", ".", "resolution", ",", "\n", "typer", "=", "data", ".", "lig_typer", ",", "\n", ")", "\n", "lig_gen_fit_mols", ",", "_", "=", "self", ".", "bond_adder", ".", "make_batch", "(", "\n", "structs", "=", "lig_gen_fit_structs", "\n", ")", "\n", "self", ".", "save_mols", "(", "lig_gen_fit_mols", ",", "grid_type", ")", "\n", "\n", "", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "t4", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "posterior", ":", "\n", "            ", "metrics", ".", "update", "(", "compute_paired_grid_metrics", "(", "\n", "'lig_gen'", ",", "lig_gen_grids", ",", "'lig'", ",", "input_lig_grids", "\n", ")", ")", "\n", "", "else", ":", "\n", "            ", "metrics", ".", "update", "(", "compute_grid_metrics", "(", "\n", "'lig_gen'", ",", "lig_gen_grids", "\n", ")", ")", "\n", "", "if", "has_cond", ":", "\n", "            ", "metrics", ".", "update", "(", "compute_paired_grid_metrics", "(", "\n", "'lig_gen'", ",", "lig_gen_grids", ",", "'cond_lig'", ",", "cond_lig_grids", "\n", ")", ")", "\n", "\n", "", "if", "has_disc", ":", "\n", "            ", "metrics", ".", "update", "(", "compute_scalar_metrics", "(", "'pred'", ",", "disc_preds", ")", ")", "\n", "\n", "", "if", "fit_atoms", ":", "\n", "            ", "if", "posterior", ":", "\n", "                ", "metrics", ".", "update", "(", "compute_paired_struct_metrics", "(", "\n", "'lig_gen_fit'", ",", "lig_gen_fit_structs", ",", "'lig'", ",", "input_lig_structs", "\n", ")", ")", "\n", "", "else", ":", "\n", "                ", "metrics", ".", "update", "(", "compute_struct_metrics", "(", "\n", "'lig_gen_fit'", ",", "lig_gen_fit_structs", "\n", ")", ")", "\n", "", "if", "has_cond", ":", "\n", "                ", "metrics", ".", "update", "(", "compute_paired_struct_metrics", "(", "\n", "'lig_gen_fit'", ",", "lig_gen_fit_structs", ",", "'cond_lig'", ",", "cond_lig_structs", "\n", ")", ")", "\n", "\n", "", "", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "t5", "=", "time", ".", "time", "(", ")", "\n", "\n", "metrics", "[", "'forward_data_time'", "]", "=", "t1", "-", "t0", "\n", "metrics", "[", "'forward_gen_time'", "]", "=", "t2", "-", "t1", "\n", "metrics", "[", "'forward_disc_time'", "]", "=", "t3", "-", "t2", "\n", "metrics", "[", "'forward_fit_time'", "]", "=", "t4", "-", "t3", "\n", "metrics", "[", "'forward_metrics_time'", "]", "=", "t5", "-", "t4", "\n", "return", "loss", ",", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward": [[730, 813], ["time.time", "torch.full", "training.GenerativeSolver.disc_model", "training.GenerativeSolver.loss_fn", "time.time", "metrics.update", "metrics.update", "time.time", "valid_grid_types.add", "valid_grid_types.add", "torch.no_grad", "time.time", "time.time", "metrics.compute_grid_metrics", "metrics.compute_scalar_metrics", "data.forward", "data.split_channels", "training.GenerativeSolver.gen_model", "torch.cat", "data.split_channels"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_grid_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_scalar_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.split_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.split_channels"], ["", "def", "disc_forward", "(", "self", ",", "data", ",", "grid_type", ")", ":", "\n", "        ", "'''\n        Compute loss and other metrics for the\n        discriminative model's ability to tell\n        apart real and generated data.\n        '''", "\n", "is_varial", "=", "self", ".", "gen_model", ".", "is_variational", "\n", "has_input", "=", "self", ".", "gen_model", ".", "has_input_encoder", "\n", "has_cond", "=", "self", ".", "gen_model_type", ".", "has_conditional_encoder", "\n", "\n", "valid_grid_types", "=", "{", "'real'", "}", "\n", "if", "is_varial", ":", "\n", "            ", "valid_grid_types", ".", "add", "(", "'prior'", ")", "\n", "", "if", "has_input", ":", "\n", "            ", "valid_grid_types", ".", "add", "(", "'poster'", ")", "\n", "\n", "", "assert", "grid_type", "in", "valid_grid_types", ",", "'invalid grid type'", "\n", "real", "=", "(", "grid_type", "==", "'real'", ")", "\n", "prior", "=", "(", "grid_type", "==", "'prior'", ")", "\n", "posterior", "=", "(", "grid_type", "==", "'poster'", ")", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "# do not backprop to generator or data", "\n", "\n", "            ", "if", "real", "or", "posterior", "or", "has_cond", ":", "# get real examples", "\n", "                ", "input_grids", ",", "cond_grids", ",", "input_structs", ",", "cond_structs", ",", "_", ",", "_", "=", "data", ".", "forward", "(", ")", "\n", "rec_structs", ",", "lig_structs", "=", "input_structs", "\n", "input_rec_grids", ",", "input_lig_grids", "=", "data", ".", "split_channels", "(", "input_grids", ")", "\n", "if", "data", ".", "diff_cond_transform", ":", "\n", "                    ", "cond_rec_grids", ",", "cond_lig_grids", "=", "data", ".", "split_channels", "(", "cond_grids", ")", "\n", "", "else", ":", "# same as input grids", "\n", "                    ", "cond_grids", "=", "input_grids", "\n", "cond_rec_grids", "=", "input_rec_grids", "\n", "cond_lig_grids", "=", "input_lig_grids", "\n", "\n", "", "", "t1", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "not", "real", ":", "# get generated ligand grids", "\n", "\n", "                ", "if", "posterior", ":", "# set generator input grids", "\n", "                    ", "gen_input_grids", "=", "input_grids", "if", "self", ".", "has_complex_input", "else", "input_lig_grids", "\n", "\n", "", "lig_gen_grids", ",", "latent_vecs", ",", "latent_means", ",", "latent_log_stds", "=", "self", ".", "gen_model", "(", "\n", "inputs", "=", "gen_input_grids", "if", "posterior", "else", "None", ",", "\n", "conditions", "=", "cond_rec_grids", "if", "has_cond", "else", "None", ",", "\n", "batch_size", "=", "data", ".", "batch_size", "\n", ")", "\n", "", "t2", "=", "time", ".", "time", "(", ")", "\n", "\n", "# get discriminator predictions", "\n", "", "if", "real", ":", "\n", "            ", "disc_grids", "=", "cond_grids", "if", "has_cond", "else", "cond_lig_grids", "\n", "", "elif", "has_cond", ":", "\n", "            ", "disc_grids", "=", "torch", ".", "cat", "(", "[", "cond_rec_grids", ",", "lig_gen_grids", "]", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "disc_grids", "=", "lig_gen_grids", "\n", "\n", "", "disc_labels", "=", "torch", ".", "full", "(", "\n", "(", "data", ".", "batch_size", ",", "1", ")", ",", "real", ",", "device", "=", "self", ".", "device", "\n", ")", "\n", "disc_preds", ",", "_", "=", "self", ".", "disc_model", "(", "inputs", "=", "disc_grids", ")", "\n", "loss", ",", "metrics", "=", "self", ".", "loss_fn", "(", "\n", "disc_labels", "=", "disc_labels", ",", "disc_preds", "=", "disc_preds", ",", "use_loss_wt", "=", "False", "\n", ")", "\n", "t3", "=", "time", ".", "time", "(", ")", "\n", "\n", "metrics", ".", "update", "(", "compute_grid_metrics", "(", "\n", "'lig'", "if", "real", "else", "'lig_gen'", ",", "\n", "cond_lig_grids", "if", "real", "else", "lig_gen_grids", "\n", ")", ")", "\n", "metrics", ".", "update", "(", "compute_scalar_metrics", "(", "'disc_pred'", ",", "disc_preds", ")", ")", "\n", "t4", "=", "time", ".", "time", "(", ")", "\n", "\n", "metrics", "[", "'forward_data_time'", "]", "=", "t1", "-", "t0", "\n", "metrics", "[", "'forward_gen_time'", "]", "=", "t2", "-", "t1", "\n", "metrics", "[", "'forward_disc_time'", "]", "=", "t3", "-", "t2", "\n", "metrics", "[", "'forward_metrics_time'", "]", "=", "t4", "-", "t3", "\n", "return", "loss", ",", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward": [[814, 860], ["collections.OrderedDict", "time.time", "training.GenerativeSolver.gen_optimizer.zero_grad", "loss.backward", "time.time", "time.time", "time.time", "models.clip_grad_norm", "models.clip_grad_norm", "models.compute_grad_norm", "training.GenerativeSolver.gen_optimizer.step", "models.compute_grad_norm", "training.GenerativeSolver.prior_optimizer.step"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.clip_grad_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.clip_grad_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.compute_grad_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.compute_grad_norm"], ["", "def", "gen_backward", "(", "self", ",", "loss", ",", "update", "=", "False", ",", "compute_norm", "=", "False", ")", ":", "\n", "        ", "'''\n        Backpropagate loss gradient onto\n        generative model parameters, op-\n        tionally computing the gradient\n        norm and/or updating parameters.\n        '''", "\n", "metrics", "=", "OrderedDict", "(", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "# compute gradient of loss wrt parameters", "\n", "self", ".", "gen_optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "t1", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "self", ".", "gen_clip_grad", ":", "# clip norm of parameter gradient", "\n", "            ", "models", ".", "clip_grad_norm", "(", "self", ".", "gen_model", ",", "self", ".", "gen_clip_grad", ")", "\n", "", "if", "self", ".", "has_prior_model", "and", "self", ".", "prior_clip_grad", ":", "\n", "            ", "models", ".", "clip_grad_norm", "(", "self", ".", "prior_model", ",", "self", ".", "prior_clip_grad", ")", "\n", "\n", "", "if", "compute_norm", ":", "# compute parameter gradient norm", "\n", "            ", "grad_norm", "=", "models", ".", "compute_grad_norm", "(", "self", ".", "gen_model", ")", "\n", "if", "self", ".", "has_prior_model", ":", "\n", "                ", "prior_grad_norm", "=", "models", ".", "compute_grad_norm", "(", "self", ".", "prior_model", ")", "\n", "\n", "", "", "t2", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "update", ":", "# descend gradient on parameters", "\n", "            ", "self", ".", "gen_optimizer", ".", "step", "(", ")", "\n", "self", ".", "gen_iter", "+=", "1", "\n", "\n", "# update the prior model on each gen step, also", "\n", "if", "self", ".", "has_prior_model", ":", "\n", "                ", "self", ".", "prior_optimizer", ".", "step", "(", ")", "\n", "self", ".", "prior_iter", "+=", "1", "\n", "\n", "", "", "t3", "=", "time", ".", "time", "(", ")", "\n", "if", "compute_norm", ":", "\n", "            ", "metrics", "[", "'gen_grad_norm'", "]", "=", "grad_norm", "\n", "if", "self", ".", "has_prior_model", ":", "\n", "                ", "metrics", "[", "'prior_grad_norm'", "]", "=", "prior_grad_norm", "\n", "", "", "metrics", "[", "'backward_grad_time'", "]", "=", "t1", "-", "t0", "\n", "metrics", "[", "'backward_norm_time'", "]", "=", "t2", "-", "t1", "\n", "metrics", "[", "'backward_update_time'", "]", "=", "t3", "-", "t2", "\n", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_backward": [[861, 896], ["collections.OrderedDict", "time.time", "training.GenerativeSolver.disc_optimizer.zero_grad", "loss.backward", "time.time", "time.time", "time.time", "models.clip_grad_norm", "models.compute_grad_norm", "training.GenerativeSolver.disc_optimizer.step"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.clip_grad_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.compute_grad_norm"], ["", "def", "disc_backward", "(", "self", ",", "loss", ",", "update", "=", "False", ",", "compute_norm", "=", "False", ")", ":", "\n", "        ", "'''\n        Backpropagate loss gradient onto\n        discriminative model parameters,\n        optionally computing the gradient\n        norm and/or updating parameters.\n        '''", "\n", "metrics", "=", "OrderedDict", "(", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "# compute gradient of loss wrt parameters", "\n", "self", ".", "disc_optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "t1", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "self", ".", "disc_clip_grad", ":", "# clip norm of parameter gradient", "\n", "            ", "models", ".", "clip_grad_norm", "(", "self", ".", "disc_model", ",", "self", ".", "disc_clip_grad", ")", "\n", "\n", "", "if", "compute_norm", ":", "# compute parameter gradient norm", "\n", "            ", "grad_norm", "=", "models", ".", "compute_grad_norm", "(", "self", ".", "disc_model", ")", "\n", "\n", "", "t2", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "update", ":", "# descend gradient on parameters", "\n", "            ", "self", ".", "disc_optimizer", ".", "step", "(", ")", "\n", "self", ".", "disc_iter", "+=", "1", "\n", "\n", "", "t3", "=", "time", ".", "time", "(", ")", "\n", "if", "compute_norm", ":", "\n", "            ", "metrics", "[", "'disc_grad_norm'", "]", "=", "grad_norm", "\n", "", "metrics", "[", "'backward_grad_time'", "]", "=", "t1", "-", "t0", "\n", "metrics", "[", "'backward_norm_time'", "]", "=", "t2", "-", "t1", "\n", "metrics", "[", "'backward_update_time'", "]", "=", "t3", "-", "t2", "\n", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_step": [[897, 948], ["torch.cuda.reset_max_memory_allocated", "time.time", "training.GenerativeSolver.gen_forward", "torch.cuda.max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "time.time", "torch.cuda.max_memory_allocated", "time.time", "training.GenerativeSolver.insert_metrics", "training.GenerativeSolver.print_metrics", "torch.cuda.synchronize", "metrics.update", "torch.cuda.synchronize", "training.get_memory_used", "loss.isnan", "training.GenerativeSolver.gen_backward", "numpy.isnan", "numpy.isclose"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.insert_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.print_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.get_memory_used", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward"], ["", "def", "gen_step", "(", "\n", "self", ",", "grid_type", ",", "update", "=", "True", ",", "compute_norm", "=", "True", ",", "batch_idx", "=", "0", "\n", ")", ":", "\n", "        ", "'''\n        Perform a single forward-backward pass\n        on the generative model, optionally\n        updating model parameters and/or comp-\n        uting the parameter gradient norm.\n        '''", "\n", "idx", "=", "(", "\n", "self", ".", "gen_iter", ",", "self", ".", "disc_iter", ",", "'train'", ",", "\n", "'gen'", ",", "grid_type", ",", "batch_idx", ",", "\n", ")", "\n", "need_gradient", "=", "(", "update", "or", "compute_norm", ")", "\n", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "# forward pass", "\n", "loss", ",", "metrics", "=", "self", ".", "gen_forward", "(", "self", ".", "train_data", ",", "grid_type", ")", "\n", "\n", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "m1", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "\n", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "t1", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "need_gradient", ":", "# backward pass", "\n", "            ", "metrics", ".", "update", "(", "self", ".", "gen_backward", "(", "loss", ",", "update", ",", "compute_norm", ")", ")", "\n", "\n", "", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "m2", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "\n", "t2", "=", "time", ".", "time", "(", ")", "\n", "\n", "metrics", "[", "'memory'", "]", "=", "get_memory_used", "(", ")", "/", "MB", "\n", "metrics", "[", "'forward_time'", "]", "=", "t1", "-", "t0", "\n", "metrics", "[", "'forward_gpu'", "]", "=", "m1", "/", "MB", "\n", "metrics", "[", "'backward_time'", "]", "=", "t2", "-", "t1", "\n", "metrics", "[", "'backward_gpu'", "]", "=", "m2", "/", "MB", "\n", "self", ".", "insert_metrics", "(", "idx", ",", "metrics", ")", "\n", "\n", "metrics", "=", "self", ".", "metrics", ".", "loc", "[", "idx", "]", "\n", "self", ".", "print_metrics", "(", "idx", "[", ":", "-", "1", "]", ",", "metrics", ")", "\n", "\n", "assert", "not", "loss", ".", "isnan", "(", ")", ",", "'generator loss is nan'", "\n", "if", "compute_norm", ":", "\n", "            ", "grad_norm", "=", "metrics", "[", "'gen_grad_norm'", "]", "\n", "assert", "not", "np", ".", "isnan", "(", "grad_norm", ")", ",", "'generator gradient is nan'", "\n", "assert", "not", "np", ".", "isclose", "(", "0", ",", "grad_norm", ")", ",", "'generator gradient is zero'", "\n", "\n", "", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_step": [[949, 1000], ["torch.cuda.reset_max_memory_allocated", "time.time", "training.GenerativeSolver.disc_forward", "torch.cuda.max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "time.time", "torch.cuda.max_memory_allocated", "time.time", "training.GenerativeSolver.insert_metrics", "training.GenerativeSolver.print_metrics", "torch.cuda.synchronize", "metrics.update", "torch.cuda.synchronize", "training.get_memory_used", "loss.isnan", "training.GenerativeSolver.disc_backward", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.insert_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.print_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.get_memory_used", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_backward"], ["", "def", "disc_step", "(", "\n", "self", ",", "grid_type", ",", "update", "=", "True", ",", "compute_norm", "=", "True", ",", "batch_idx", "=", "0", "\n", ")", ":", "\n", "        ", "'''\n        Perform a single forward-backward pass\n        on the discriminative model, optionally\n        updating model parameters and/or comp-\n        uting the parameter gradient norm.\n        '''", "\n", "idx", "=", "(", "\n", "self", ".", "gen_iter", ",", "self", ".", "disc_iter", ",", "'train'", ",", "\n", "'disc'", ",", "grid_type", ",", "batch_idx", ",", "\n", ")", "\n", "need_gradient", "=", "(", "update", "or", "compute_norm", ")", "\n", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "# forward pass", "\n", "loss", ",", "metrics", "=", "self", ".", "disc_forward", "(", "self", ".", "train_data", ",", "grid_type", ")", "\n", "\n", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "m1", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "\n", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "t1", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "need_gradient", ":", "# backward pass", "\n", "            ", "metrics", ".", "update", "(", "self", ".", "disc_backward", "(", "loss", ",", "update", ",", "compute_norm", ")", ")", "\n", "\n", "", "if", "self", ".", "sync_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "m2", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "\n", "t2", "=", "time", ".", "time", "(", ")", "\n", "\n", "metrics", "[", "'memory'", "]", "=", "get_memory_used", "(", ")", "/", "MB", "\n", "metrics", "[", "'forward_time'", "]", "=", "t1", "-", "t0", "\n", "metrics", "[", "'forward_gpu'", "]", "=", "m1", "/", "MB", "\n", "metrics", "[", "'backward_time'", "]", "=", "t2", "-", "t1", "\n", "metrics", "[", "'backward_gpu'", "]", "=", "m2", "/", "MB", "\n", "self", ".", "insert_metrics", "(", "idx", ",", "metrics", ")", "\n", "\n", "metrics", "=", "self", ".", "metrics", ".", "loc", "[", "idx", "]", "\n", "self", ".", "print_metrics", "(", "idx", "[", ":", "-", "1", "]", ",", "metrics", ")", "\n", "\n", "assert", "not", "loss", ".", "isnan", "(", ")", ",", "'discriminator loss is nan'", "\n", "if", "compute_norm", ":", "\n", "            ", "grad_norm", "=", "metrics", "[", "'disc_grad_norm'", "]", "\n", "assert", "not", "np", ".", "isnan", "(", "grad_norm", ")", ",", "'discriminator gradient is nan'", "\n", "#assert not np.isclose(0, grad_norm), 'discriminator gradient is zero'", "\n", "\n", "", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_model": [[1001, 1047], ["range", "training.GenerativeSolver.metrics.loc[].mean", "training.GenerativeSolver.print_metrics", "valid_model_types.add", "torch.cuda.reset_max_memory_allocated", "time.time", "training.GenerativeSolver.insert_metrics", "training.GenerativeSolver.get_disc_grid_phase", "training.GenerativeSolver.disc_forward", "training.GenerativeSolver.get_gen_grid_phase", "training.GenerativeSolver.gen_forward", "training.get_memory_used", "time.time", "torch.cuda.max_memory_allocated", "training.GenerativeSolver.copy", "training.GenerativeSolver.copy.update", "wandb.log", "dict", "zip"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.print_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.insert_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.get_disc_grid_phase", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.get_gen_grid_phase", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.get_memory_used"], ["", "def", "test_model", "(", "self", ",", "n_batches", ",", "model_type", ",", "fit_atoms", "=", "False", ")", ":", "\n", "        ", "'''\n        Evaluate a model's performance on\n        n_batches of test data, optionally\n        performing atom fitting.\n        '''", "\n", "valid_model_types", "=", "{", "'gen'", "}", "\n", "if", "self", ".", "has_disc_model", ":", "\n", "            ", "valid_model_types", ".", "add", "(", "'disc'", ")", "\n", "", "test_disc", "=", "(", "model_type", "==", "'disc'", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_batches", ")", ":", "\n", "            ", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "test_disc", ":", "# test discriminative model", "\n", "                ", "grid_type", "=", "self", ".", "get_disc_grid_phase", "(", "i", ",", "test", "=", "True", ")", "\n", "loss", ",", "metrics", "=", "self", ".", "disc_forward", "(", "\n", "data", "=", "self", ".", "test_data", ",", "grid_type", "=", "grid_type", "\n", ")", "\n", "", "else", ":", "# test generative model", "\n", "                ", "grid_type", "=", "self", ".", "get_gen_grid_phase", "(", "i", ",", "test", "=", "True", ")", "\n", "loss", ",", "metrics", "=", "self", ".", "gen_forward", "(", "\n", "data", "=", "self", ".", "test_data", ",", "\n", "grid_type", "=", "grid_type", ",", "\n", "fit_atoms", "=", "fit_atoms", "\n", ")", "\n", "\n", "", "metrics", "[", "'memory'", "]", "=", "get_memory_used", "(", ")", "/", "MB", "\n", "metrics", "[", "'forward_time'", "]", "=", "time", ".", "time", "(", ")", "-", "t0", "\n", "metrics", "[", "'forward_gpu'", "]", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "/", "MB", "\n", "idx", "=", "(", "\n", "self", ".", "gen_iter", ",", "self", ".", "disc_iter", ",", "\n", "'test'", ",", "model_type", ",", "grid_type", ",", "i", "\n", ")", "\n", "self", ".", "insert_metrics", "(", "idx", ",", "metrics", ")", "\n", "\n", "# log metrics to wandb", "\n", "if", "self", ".", "use_wandb", ":", "\n", "                ", "wandb_metrics", "=", "metrics", ".", "copy", "(", ")", "\n", "wandb_metrics", ".", "update", "(", "dict", "(", "zip", "(", "self", ".", "index_cols", ",", "idx", ")", ")", ")", "\n", "wandb", ".", "log", "(", "wandb_metrics", ")", "\n", "\n", "", "", "idx", "=", "idx", "[", ":", "-", "1", "]", "\n", "metrics", "=", "self", ".", "metrics", ".", "loc", "[", "idx", "]", ".", "mean", "(", ")", "\n", "self", ".", "print_metrics", "(", "idx", ",", "metrics", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_models": [[1048, 1060], ["training.GenerativeSolver.test_model", "training.GenerativeSolver.save_metrics", "training.GenerativeSolver.test_model"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_model", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_model"], ["", "def", "test_models", "(", "self", ",", "n_batches", ",", "fit_atoms", ")", ":", "\n", "        ", "'''\n        Evaluate each model on n_batches of test\n        data, optionally performing atom fitting.\n        '''", "\n", "if", "self", ".", "has_disc_model", ":", "\n", "            ", "self", ".", "test_model", "(", "n_batches", "=", "n_batches", ",", "model_type", "=", "'disc'", ")", "\n", "\n", "", "self", ".", "test_model", "(", "\n", "n_batches", "=", "n_batches", ",", "model_type", "=", "'gen'", ",", "fit_atoms", "=", "fit_atoms", "\n", ")", "\n", "self", ".", "save_metrics", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_model": [[1061, 1103], ["range", "valid_model_types.add", "training.GenerativeSolver.get_disc_grid_phase", "training.GenerativeSolver.disc_step", "training.GenerativeSolver.get_gen_grid_phase", "training.GenerativeSolver.gen_step", "training.GenerativeSolver.get", "training.GenerativeSolver.get"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.get_disc_grid_phase", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.get_gen_grid_phase", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "def", "train_model", "(", "\n", "self", ",", "n_iters", ",", "model_type", ",", "update", "=", "True", ",", "compute_norm", "=", "True", "\n", ")", ":", "\n", "        ", "'''\n        Perform n_iters forward-backward passes\n        on one of the models, optionally updating\n        its parameters.\n        '''", "\n", "valid_model_types", "=", "{", "'gen'", "}", "\n", "if", "self", ".", "has_disc_model", ":", "\n", "            ", "valid_model_types", ".", "add", "(", "'disc'", ")", "\n", "", "train_disc", "=", "(", "model_type", "==", "'disc'", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_iters", ")", ":", "\n", "            ", "batch_idx", "=", "0", "if", "update", "else", "i", "\n", "\n", "if", "train_disc", ":", "# train discriminative model", "\n", "                ", "grid_type", "=", "self", ".", "get_disc_grid_phase", "(", "batch_idx", ",", "test", "=", "False", ")", "\n", "\n", "metrics", "=", "self", ".", "disc_step", "(", "\n", "grid_type", "=", "grid_type", ",", "\n", "update", "=", "update", ",", "\n", "compute_norm", "=", "compute_norm", ",", "\n", "batch_idx", "=", "batch_idx", "\n", ")", "\n", "\n", "if", "grid_type", "==", "'real'", ":", "\n", "                    ", "disc_gan_loss", "=", "metrics", ".", "get", "(", "'gan_loss'", ",", "-", "1", ")", "\n", "self", ".", "disc_gan_loss", "=", "disc_gan_loss", "\n", "\n", "", "", "else", ":", "# train generative model", "\n", "                ", "grid_type", "=", "self", ".", "get_gen_grid_phase", "(", "batch_idx", ",", "test", "=", "False", ")", "\n", "\n", "metrics", "=", "self", ".", "gen_step", "(", "\n", "grid_type", "=", "grid_type", ",", "\n", "update", "=", "update", ",", "\n", "compute_norm", "=", "compute_norm", ",", "\n", "batch_idx", "=", "batch_idx", "\n", ")", "\n", "\n", "gen_gan_loss", "=", "metrics", ".", "get", "(", "'gan_loss'", ",", "0", ")", "\n", "self", ".", "gen_gan_loss", "=", "gen_gan_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_models": [[1104, 1135], ["training.GenerativeSolver.train_model", "training.GenerativeSolver.train_model"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_model", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_model"], ["", "", "", "def", "train_models", "(", "self", ",", "update", "=", "True", ",", "compute_norm", "=", "False", ")", ":", "\n", "        ", "'''\n        Train each model on training data for\n        a pre-determined number of iterations.\n        '''", "\n", "if", "update", ":", "# determine which models to update", "\n", "\n", "            ", "if", "self", ".", "balance", ":", "# only update gen if disc is better", "\n", "                ", "update_disc", "=", "True", "\n", "update_gen", "=", "(", "self", ".", "disc_gan_loss", "<", "self", ".", "gen_gan_loss", ")", "\n", "\n", "", "else", ":", "# update both models", "\n", "                ", "update_disc", "=", "update_gen", "=", "True", "\n", "\n", "", "", "else", ":", "# don't update, just evaluate", "\n", "            ", "update_disc", "=", "update_gen", "=", "False", "\n", "\n", "", "if", "self", ".", "has_disc_model", ":", "\n", "\n", "            ", "self", ".", "train_model", "(", "\n", "n_iters", "=", "self", ".", "n_disc_train_iters", ",", "\n", "model_type", "=", "'disc'", ",", "\n", "update", "=", "update_disc", ",", "\n", "compute_norm", "=", "compute_norm", "\n", ")", "\n", "\n", "", "self", ".", "train_model", "(", "\n", "n_iters", "=", "self", ".", "n_gen_train_iters", ",", "\n", "model_type", "=", "'gen'", ",", "\n", "update", "=", "update_gen", ",", "\n", "compute_norm", "=", "compute_norm", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_and_test": [[1137, 1175], ["training.GenerativeSolver.save_state_and_metrics", "training.GenerativeSolver.train_models", "divides", "training.GenerativeSolver.save_state", "divides", "training.GenerativeSolver.test_models", "divides", "divides"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_state_and_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_models", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_state", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_models"], ["", "@", "save_on_exception", "\n", "def", "train_and_test", "(", "\n", "self", ",", "\n", "max_iter", ",", "\n", "test_interval", ",", "\n", "n_test_batches", ",", "\n", "fit_interval", ",", "\n", "norm_interval", ",", "\n", "save_interval", ",", "\n", ")", ":", "\n", "        ", "init_iter", "=", "self", ".", "gen_iter", "\n", "last_save", "=", "None", "\n", "last_test", "=", "None", "\n", "divides", "=", "lambda", "d", ",", "n", ":", "(", "n", "%", "d", "==", "0", ")", "\n", "\n", "while", "self", ".", "gen_iter", "<=", "max_iter", ":", "\n", "            ", "i", "=", "self", ".", "gen_iter", "\n", "\n", "# save model and optimizer states", "\n", "if", "last_save", "!=", "i", "and", "divides", "(", "save_interval", ",", "i", ")", ":", "\n", "                ", "self", ".", "save_state", "(", ")", "\n", "last_save", "=", "i", "\n", "\n", "# test models on test data", "\n", "", "if", "last_test", "!=", "i", "and", "divides", "(", "test_interval", ",", "i", ")", ":", "\n", "                ", "fit_atoms", "=", "(", "fit_interval", ">", "0", "and", "divides", "(", "fit_interval", ",", "i", ")", ")", "\n", "self", ".", "test_models", "(", "n_batches", "=", "n_test_batches", ",", "fit_atoms", "=", "fit_atoms", ")", "\n", "last_test", "=", "i", "\n", "\n", "# train models on training data", "\n", "", "update", "=", "(", "i", "<", "max_iter", ")", "\n", "compute_norm", "=", "(", "norm_interval", ">", "0", "and", "divides", "(", "norm_interval", ",", "i", ")", ")", "\n", "self", ".", "train_models", "(", "update", "=", "update", ",", "compute_norm", "=", "compute_norm", ")", "\n", "\n", "if", "i", "==", "max_iter", ":", "\n", "                ", "break", "\n", "\n", "", "", "self", ".", "save_state_and_metrics", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.get_memory_used": [[30, 32], ["psutil.Process().memory_info", "psutil.Process", "os.getpid"], "function", ["None"], ["def", "get_memory_used", "(", ")", ":", "\n", "    ", "return", "psutil", ".", "Process", "(", "os", ".", "getpid", "(", ")", ")", ".", "memory_info", "(", ")", ".", "rss", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.save_on_exception": [[34, 42], ["method", "training..save_state_and_metrics"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_state_and_metrics"], ["", "def", "save_on_exception", "(", "method", ")", ":", "\n", "    ", "def", "wrapper", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "method", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "except", ":", "\n", "            ", "self", ".", "save_state_and_metrics", "(", ")", "\n", "raise", "\n", "", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.get_state_prefix": [[44, 46], ["None"], "function", ["None"], ["", "def", "get_state_prefix", "(", "out_prefix", ",", "iter_", ")", ":", "\n", "    ", "return", "'{}_iter_{}'", ".", "format", "(", "out_prefix", ",", "iter_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.find_last_iter": [[48, 63], ["re.compile", "glob.glob", "re.compile.match", "FileNotFoundError", "re.escape", "max", "int", "print", "print", "state_file_re.match.group"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "find_last_iter", "(", "out_prefix", ",", "min_iter", "=", "-", "1", ")", ":", "\n", "    ", "last_iter", "=", "min_iter", "\n", "state_file_re", "=", "re", ".", "compile", "(", "re", ".", "escape", "(", "out_prefix", ")", "+", "r'_iter_(\\d+).*state'", ")", "\n", "for", "state_file", "in", "glob", ".", "glob", "(", "out_prefix", "+", "'_iter_*state'", ")", ":", "\n", "        ", "m", "=", "state_file_re", ".", "match", "(", "state_file", ")", "\n", "try", ":", "\n", "            ", "last_iter", "=", "max", "(", "last_iter", ",", "int", "(", "m", ".", "group", "(", "1", ")", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "print", "(", "state_file_re", ".", "pattern", ")", "\n", "print", "(", "state_file", ")", "\n", "raise", "\n", "", "", "if", "last_iter", ">", "min_iter", ":", "\n", "        ", "return", "last_iter", "\n", "", "else", ":", "\n", "        ", "raise", "FileNotFoundError", "(", "'could not find state files ({})'", ".", "format", "(", "last_iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.__init__": [[32, 99], ["dict", "molgrid.GridMaker", "molgrid.Coords2Grid"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "beam_size", "=", "1", ",", "\n", "multi_atom", "=", "False", ",", "\n", "n_atoms_detect", "=", "1", ",", "\n", "apply_conv", "=", "False", ",", "\n", "threshold", "=", "0.1", ",", "\n", "peak_value", "=", "1.5", ",", "\n", "min_dist", "=", "0.0", ",", "\n", "apply_prop_conv", "=", "False", ",", "\n", "constrain_types", "=", "False", ",", "\n", "constrain_frags", "=", "False", ",", "\n", "estimate_types", "=", "False", ",", "\n", "fit_L1_loss", "=", "False", ",", "\n", "interm_gd_iters", "=", "10", ",", "\n", "final_gd_iters", "=", "100", ",", "\n", "gd_kwargs", "=", "dict", "(", "\n", "lr", "=", "0.1", ",", "\n", "betas", "=", "(", "0.9", ",", "0.999", ")", ",", "\n", "weight_decay", "=", "0.0", ",", "\n", ")", ",", "\n", "dkoes_make_mol", "=", "True", ",", "\n", "use_openbabel", "=", "False", ",", "\n", "output_kernel", "=", "False", ",", "\n", "device", "=", "'cuda'", ",", "\n", "verbose", "=", "0", ",", "\n", "debug", "=", "False", ",", "\n", ")", ":", "\n", "# number of best structures to store and expand during search", "\n", "        ", "self", ".", "beam_size", "=", "beam_size", "\n", "\n", "# maximum number of atoms to detect in remaining density", "\n", "self", ".", "n_atoms_detect", "=", "n_atoms_detect", "\n", "\n", "# try placing all detected atoms at once, then try individually", "\n", "self", ".", "multi_atom", "=", "multi_atom", "\n", "\n", "# settings for detecting atoms in element channels", "\n", "self", ".", "apply_conv", "=", "apply_conv", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "peak_value", "=", "peak_value", "\n", "self", ".", "min_dist", "=", "min_dist", "\n", "\n", "# setting for detecting properties in property channels", "\n", "self", ".", "apply_prop_conv", "=", "apply_prop_conv", "\n", "\n", "# can constrain to find exact atom type counts or single fragment", "\n", "self", ".", "constrain_types", "=", "constrain_types", "\n", "self", ".", "constrain_frags", "=", "constrain_frags", "\n", "self", ".", "estimate_types", "=", "estimate_types", "\n", "\n", "# can perform gradient descent at each step and/or at final step", "\n", "self", ".", "fit_L1_loss", "=", "fit_L1_loss", "\n", "self", ".", "interm_gd_iters", "=", "interm_gd_iters", "\n", "self", ".", "final_gd_iters", "=", "final_gd_iters", "\n", "self", ".", "gd_kwargs", "=", "gd_kwargs", "\n", "\n", "self", ".", "output_kernel", "=", "output_kernel", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "debug", "=", "debug", "\n", "\n", "self", ".", "grid_maker", "=", "molgrid", ".", "GridMaker", "(", "gaussian_radius_multiple", "=", "-", "1.5", ")", "\n", "self", ".", "c2grid", "=", "molgrid", ".", "Coords2Grid", "(", "self", ".", "grid_maker", ")", "\n", "\n", "# lazily initialize atom density kernel", "\n", "self", ".", "kernel", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.print": [[100, 103], ["atom_fitting.AtomFitter.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "print", "(", "self", ",", "*", "msg", ",", "level", "=", "1", ")", ":", "\n", "        ", "if", "self", ".", "verbose", ">=", "level", ":", "\n", "            ", "print", "(", "*", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.init_kernel": [[104, 175], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "atom_fitting.AtomFitter.grid_maker.set_resolution", "atom_fitting.AtomFitter.grid_maker.set_radii_type_indexed", "atom_grids.dimension_to_size", "atom_fitting.AtomFitter.grid_maker.set_dimension", "atom_fitting.AtomFitter.c2grid.forward", "radii.max().item", "atom_grids.size_to_dimension", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "atom_fitting.AtomFitter.kernel.to_dx", "atom_fitting.AtomFitter.grid_maker.get_dimension", "atom_fitting.weiner_invert_kernel", "atom_fitting.AtomFitter.kernel.norm().item", "atom_fitting.AtomFitter.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.dimension_to_size", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.size_to_dimension", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to_dx", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.weiner_invert_kernel", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "init_kernel", "(", "self", ",", "resolution", ",", "typer", ",", "deconv", "=", "False", ")", ":", "\n", "        ", "'''\n        Initialize an atomic density kernel that can\n        can be used to detect atoms in density grids.\n        The kernel has a different channel for each\n        element in the typer's element range.\n        '''", "\n", "# kernel is created by computing a molgrid from a", "\n", "# struct with one atom of each element at the center", "\n", "coords", "=", "torch", ".", "zeros", "(", "\n", "(", "typer", ".", "n_elem_types", ",", "3", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "self", ".", "device", "\n", ")", "\n", "types", "=", "torch", ".", "eye", "(", "\n", "typer", ".", "n_elem_types", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "self", ".", "device", "\n", ")", "\n", "radii", "=", "typer", ".", "elem_radii", "\n", "\n", "# now set the grid settings", "\n", "self", ".", "grid_maker", ".", "set_resolution", "(", "resolution", ")", "\n", "\n", "# this flag indicates that each atom has its own radius", "\n", "#   which may or may not be needed here...", "\n", "self", ".", "grid_maker", ".", "set_radii_type_indexed", "(", "False", ")", "\n", "\n", "# kernel must be large enough for atom with largest radius", "\n", "kernel_radius", "=", "1.5", "*", "radii", ".", "max", "(", ")", ".", "item", "(", ")", "\n", "kernel_size", "=", "atom_grids", ".", "dimension_to_size", "(", "\n", "2", "*", "kernel_radius", ",", "resolution", "\n", ")", "\n", "\n", "# kernel must also have odd spatial dimension", "\n", "#   so that convolution produces same size output grid", "\n", "if", "kernel_size", "%", "2", "==", "0", ":", "\n", "            ", "kernel_size", "+=", "1", "\n", "\n", "# but even if we don't need to change the kernel size,", "\n", "#   still use size_to_dimension to set dimension to a", "\n", "#   value that is a multiple of resolution, otherwise", "\n", "#   there are issues with grid centering", "\n", "", "self", ".", "grid_maker", ".", "set_dimension", "(", "\n", "atom_grids", ".", "size_to_dimension", "(", "kernel_size", ",", "resolution", ")", "\n", ")", "\n", "assert", "self", ".", "grid_maker", ".", "get_dimension", "(", ")", "%", "resolution", "==", "0", ",", "'bad kernel dimension'", "\n", "\n", "# create the atom density kernel", "\n", "self", ".", "c2grid", ".", "center", "=", "(", "0", ",", "0", ",", "0", ")", "\n", "self", ".", "kernel", "=", "self", ".", "c2grid", ".", "forward", "(", "coords", ",", "types", ",", "radii", ")", "\n", "\n", "if", "deconv", ":", "# invert the kernel", "\n", "            ", "self", ".", "kernel", "=", "torch", ".", "tensor", "(", "\n", "weiner_invert_kernel", "(", "self", ".", "kernel", ".", "cpu", "(", ")", ",", "noise_ratio", "=", "1", ")", ",", "\n", "dtype", "=", "self", ".", "kernel", ".", "dtype", ",", "\n", "device", "=", "self", ".", "device", ",", "\n", ")", "\n", "\n", "", "if", "self", ".", "output_kernel", ":", "# write out the kernel", "\n", "            ", "dx_prefix", "=", "'deconv_kernel'", "if", "deconv", "else", "'conv_kernel'", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "kernel_norm", "=", "self", ".", "kernel", ".", "norm", "(", ")", ".", "item", "(", ")", "\n", "print", "(", "\n", "'writing out {} (norm={})'", ".", "format", "(", "dx_prefix", ",", "kernel_norm", ")", "\n", ")", "\n", "", "self", ".", "kernel", ".", "to_dx", "(", "dx_prefix", ")", "\n", "self", ".", "output_kernel", "=", "False", "# only write once", "\n", "\n", "", "return", "self", ".", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.get_types_estimate": [[176, 188], ["atom_fitting.AtomFitter.kernel.sum", "grid.elem_values.sum", "atom_fitting.AtomFitter.init_kernel"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.init_kernel"], ["", "def", "get_types_estimate", "(", "self", ",", "grid", ")", ":", "\n", "        ", "'''\n        Since atom density is additive and non-negative, estimate\n        the atom type counts by dividing the total density in each\n        grid channel by the total density in each kernel channel.\n        '''", "\n", "if", "self", ".", "kernel", "is", "None", ":", "\n", "            ", "self", ".", "init_kernel", "(", "grid", ".", "resolution", ",", "grid", ".", "typer", ")", "\n", "\n", "", "kernel_sum", "=", "self", ".", "kernel", ".", "sum", "(", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "\n", "grid_sum", "=", "grid", ".", "elem_values", ".", "sum", "(", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "\n", "return", "grid_sum", "/", "kernel_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.convolve": [[189, 210], ["atom_fitting.AtomFitter.init_kernel", "torch.conv3d", "torch.conv3d", "elem_values.unsqueeze", "atom_fitting.AtomFitter.kernel.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.init_kernel"], ["", "def", "convolve", "(", "self", ",", "elem_values", ",", "resolution", ",", "typer", ")", ":", "\n", "        ", "'''\n        Compute a convolution between the provided\n        density grid and the atomic density kernel.\n\n        The output is normalized by the kernel norm\n        so that values above 0.5 indicate grid points\n        where placing an atom would decrease L2 loss.\n        '''", "\n", "if", "self", ".", "kernel", "is", "None", ":", "\n", "            ", "self", ".", "init_kernel", "(", "resolution", ",", "typer", ")", "\n", "\n", "# normalize convolved grid channels by kernel norm", "\n", "", "kernel_norm2", "=", "(", "self", ".", "kernel", "**", "2", ")", ".", "sum", "(", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ",", "keepdim", "=", "True", ")", "\n", "\n", "return", "F", ".", "conv3d", "(", "\n", "input", "=", "elem_values", ".", "unsqueeze", "(", "0", ")", ",", "# add batch dim", "\n", "weight", "=", "self", ".", "kernel", ".", "unsqueeze", "(", "1", ")", ",", "# add inputs/group dim", "\n", "padding", "=", "self", ".", "kernel", ".", "shape", "[", "-", "1", "]", "//", "2", ",", "\n", "groups", "=", "typer", ".", "n_elem_types", ",", "\n", ")", "[", "0", "]", "/", "kernel_norm2", "# index into batch", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_peak_value": [[211, 218], ["None"], "methods", ["None"], ["", "def", "apply_peak_value", "(", "self", ",", "grid_values", ")", ":", "\n", "        ", "'''\n        Reflect grid_values that are above peak_value,\n        so that the maximum value is peak_value and\n        values over peak_value start to decrease.\n        '''", "\n", "return", "self", ".", "peak_value", "-", "(", "self", ".", "peak_value", "-", "grid_values", ")", ".", "abs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.sort_grid_points": [[219, 238], ["torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "grid_values.flatten"], "methods", ["None"], ["", "def", "sort_grid_points", "(", "self", ",", "grid_values", ")", ":", "\n", "        ", "'''\n        Sort grid_values from highest to lowest,\n        and also return corresponding spatial and\n        channel indices of the sorted values.\n        '''", "\n", "n_c", ",", "n_x", ",", "n_y", ",", "n_z", "=", "grid_values", ".", "shape", "\n", "\n", "# get flattened grid values and index, sorted by value", "\n", "values", ",", "idx", "=", "torch", ".", "sort", "(", "grid_values", ".", "flatten", "(", ")", ",", "descending", "=", "True", ")", "\n", "\n", "# convert flattened grid index to channel and spatial index", "\n", "idx_z", ",", "idx", "=", "idx", "%", "n_z", ",", "idx", "//", "n_z", "\n", "idx_y", ",", "idx", "=", "idx", "%", "n_y", ",", "idx", "//", "n_y", "\n", "idx_x", ",", "idx", "=", "idx", "%", "n_x", ",", "idx", "//", "n_x", "\n", "idx_c", ",", "idx", "=", "idx", "%", "n_c", ",", "idx", "//", "n_c", "\n", "idx_xyz", "=", "torch", ".", "stack", "(", "(", "idx_x", ",", "idx_y", ",", "idx_z", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "values", ",", "idx_xyz", ",", "idx_c", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_threshold": [[239, 250], ["None"], "methods", ["None"], ["", "def", "apply_threshold", "(", "self", ",", "values", ",", "idx_xyz", ",", "idx_c", ")", ":", "\n", "        ", "'''\n        Return only the elements of the provided values\n        and corresponding spatial and channel indices\n        where the value is above threshold.\n        '''", "\n", "above_thresh", "=", "values", ">", "self", ".", "threshold", "\n", "values", "=", "values", "[", "above_thresh", "]", "\n", "idx_xyz", "=", "idx_xyz", "[", "above_thresh", "]", "\n", "idx_c", "=", "idx_c", "[", "above_thresh", "]", "\n", "return", "values", ",", "idx_xyz", ",", "idx_c", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_type_constraint": [[251, 269], ["None"], "methods", ["None"], ["", "def", "apply_type_constraint", "(", "self", ",", "values", ",", "idx_xyz", ",", "idx_c", ",", "type_counts", ")", ":", "\n", "        ", "'''\n        Return only the elements of the provided values\n        and corresponding spatial and channel indices\n        where type_counts of the channels is greater\n        than zero.\n        '''", "\n", "#TODO this does not constrain the atoms types correctly", "\n", "# when doing multi_atom fitting, because it only omits", "\n", "# atom types that have 0 atoms left- i.e. we could still", "\n", "# return 2 atoms of a type that only has 1 atom left.", "\n", "# Need to exclude all atoms of type t beyond rank n_t", "\n", "# where n_t is the number of atoms left of type t", "\n", "has_atoms_left", "=", "type_counts", "[", "idx_c", "]", ">", "0", "\n", "values", "=", "values", "[", "has_atoms_left", "]", "\n", "idx_xyz", "=", "idx_xyz", "[", "has_atoms_left", "]", "\n", "idx_c", "=", "idx_c", "[", "has_atoms_left", "]", "\n", "return", "values", ",", "idx_xyz", ",", "idx_c", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.suppress_non_max": [[270, 324], ["len", "torch.tril().any", "torch.tril().any", "torch.tril().any", "torch.tril().any", "coords[].unsqueeze", "idx_xyz[].unsqueeze", "idx_c[].unsqueeze", "range", "idx_c.unsqueeze", "idx_c.unsqueeze", "r[].unsqueeze", "r[].unsqueeze", "len", "len", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "coords.unsqueeze", "coords.unsqueeze", "coords[].unsqueeze", "idx_xyz[].unsqueeze", "idx_c[].unsqueeze", "coords[].unsqueeze"], "methods", ["None"], ["", "def", "suppress_non_max", "(", "\n", "self", ",", "values", ",", "coords", ",", "idx_xyz", ",", "idx_c", ",", "typer", ",", "matrix", "=", "None", "\n", ")", ":", "\n", "        ", "'''\n        Return the coords, spatial and channel indices\n        where there is no other coord with higher value\n        that is within a certain distance of the point\n        in the same channel. The distance is equal to\n        min_dist * (sum of the atom pair's radii), and\n        the method assumes that values/coords/indices \n        are all sorted by value.\n        '''", "\n", "if", "len", "(", "coords", ")", "<=", "1", ":", "# nothing to suppress", "\n", "            ", "return", "coords", ",", "idx_xyz", ",", "idx_c", "\n", "\n", "", "r", "=", "typer", ".", "elem_radii", "\n", "if", "matrix", "or", "(", "matrix", "is", "None", "and", "len", "(", "coords", ")", "<", "1000", ")", ":", "\n", "\n", "# use NxN matrix calculations", "\n", "            ", "same_type", "=", "(", "idx_c", ".", "unsqueeze", "(", "1", ")", "==", "idx_c", ".", "unsqueeze", "(", "0", ")", ")", "\n", "bond_radius", "=", "r", "[", "idx_c", "]", ".", "unsqueeze", "(", "1", ")", "+", "r", "[", "idx_c", "]", ".", "unsqueeze", "(", "0", ")", "\n", "min_dist2", "=", "(", "self", ".", "min_dist", "*", "bond_radius", ")", "**", "2", "\n", "dist2", "=", "(", "(", "coords", ".", "unsqueeze", "(", "1", ")", "-", "coords", ".", "unsqueeze", "(", "0", ")", ")", "**", "2", ")", ".", "sum", "(", "dim", "=", "2", ")", "\n", "\n", "# the lower triangular part of a matrix under diagonal -1", "\n", "#   gives those indices i,j such that i > j", "\n", "# since atoms are sorted by decreasing density value,", "\n", "#   i > j implies that atom i has lower value than atom j", "\n", "# we use this to check a condition on each atom", "\n", "#   only with respect to atoms of higher value ", "\n", "too_close", "=", "torch", ".", "tril", "(", "\n", "(", "dist2", "<", "min_dist2", ")", "&", "same_type", ",", "diagonal", "=", "-", "1", "\n", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "\n", "return", "(", "\n", "coords", "[", "~", "too_close", "]", ",", "idx_xyz", "[", "~", "too_close", "]", ",", "idx_c", "[", "~", "too_close", "]", "\n", ")", "\n", "\n", "", "else", ":", "# use a for-loop", "\n", "            ", "coords_max", "=", "coords", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "idx_xyz_max", "=", "idx_xyz", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "idx_c_max", "=", "idx_c", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "idx_c", ")", ")", ":", "\n", "                ", "same_type", "=", "(", "idx_c", "[", "i", "]", "==", "idx_c_max", ")", "\n", "bond_radius", "=", "r", "[", "idx_c", "[", "i", "]", "]", "+", "r", "[", "idx_c_max", "]", "\n", "min_dist2", "=", "(", "self", ".", "min_dist", "*", "bond_radius", ")", "**", "2", "\n", "dist2", "=", "(", "(", "coords", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "-", "coords_max", ")", "**", "2", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "not", "(", "(", "dist2", "<", "min_dist2", ")", "&", "same_type", ")", ".", "any", "(", ")", ":", "\n", "                    ", "coords_max", "=", "torch", ".", "cat", "(", "[", "coords_max", ",", "coords", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "]", ")", "\n", "idx_xyz_max", "=", "torch", ".", "cat", "(", "[", "idx_xyz_max", ",", "idx_xyz", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "]", ")", "\n", "idx_c_max", "=", "torch", ".", "cat", "(", "[", "idx_c_max", ",", "idx_c", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "]", ")", "\n", "\n", "", "", "return", "coords_max", ",", "idx_xyz_max", ",", "idx_c_max", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.detect_atoms": [[325, 393], ["atom_fitting.AtomFitter.sort_grid_points", "grid.get_coords", "torch.one_hot().to", "torch.one_hot().to", "atom_fitting.AtomFitter.convolve", "not_none", "atom_fitting.AtomFitter.apply_peak_value", "not_none", "atom_fitting.AtomFitter.apply_threshold", "atom_fitting.AtomFitter.apply_type_constraint", "not_none", "not_none", "atom_fitting.AtomFitter.suppress_non_max", "not_none", "torch.cat.extend", "torch.cat.extend", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "grid.get_coords.detach", "torch.cat.detach", "torch.cat.detach", "len", "torch.one_hot", "torch.one_hot", "atom_fitting.AtomFitter.detect_properties"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.sort_grid_points", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.get_coords", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.convolve", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_peak_value", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_threshold", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_type_constraint", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.suppress_non_max", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.detect_properties"], ["", "", "def", "detect_atoms", "(", "self", ",", "grid", ",", "type_counts", "=", "None", ")", ":", "\n", "        ", "'''\n        Detect a set of typed atoms in an AtomGrid by convolving\n        with a kernel, applying a threshold, and then returning\n        atom coordinates and type vectors ordered by grid value.\n        '''", "\n", "not_none", "=", "lambda", "x", ":", "x", "is", "not", "None", "\n", "\n", "# detect atoms in the element channels", "\n", "values", "=", "grid", ".", "elem_values", "\n", "\n", "# convolve grid with atomic density kernel", "\n", "if", "self", ".", "apply_conv", ":", "\n", "            ", "values", "=", "self", ".", "convolve", "(", "values", ",", "grid", ".", "resolution", ",", "grid", ".", "typer", ")", "\n", "\n", "# reflect grid values above peak value", "\n", "", "if", "not_none", "(", "self", ".", "peak_value", ")", "and", "self", ".", "peak_value", "<", "np", ".", "inf", ":", "\n", "            ", "values", "=", "self", ".", "apply_peak_value", "(", "values", ")", "\n", "\n", "# sort grid points by value", "\n", "", "values", ",", "idx_xyz", ",", "idx_c", "=", "self", ".", "sort_grid_points", "(", "values", ")", "\n", "\n", "# apply threshold to grid points and values", "\n", "if", "not_none", "(", "self", ".", "threshold", ")", "and", "self", ".", "threshold", ">", "-", "np", ".", "inf", ":", "\n", "            ", "values", ",", "idx_xyz", ",", "idx_c", "=", "self", ".", "apply_threshold", "(", "\n", "values", ",", "idx_xyz", ",", "idx_c", "\n", ")", "\n", "\n", "# exclude grid channels with no atoms left", "\n", "", "if", "self", ".", "constrain_types", ":", "\n", "            ", "values", ",", "idx_xyz", ",", "idx_c", "=", "self", ".", "apply_type_constraint", "(", "\n", "values", ",", "idx_xyz", ",", "idx_c", ",", "type_counts", "\n", ")", "\n", "\n", "# convert spatial index to atomic coordinates", "\n", "", "coords", "=", "grid", ".", "get_coords", "(", "idx_xyz", ")", "\n", "\n", "# suppress atoms too close to a higher-value atom of same type", "\n", "if", "(", "\n", "not_none", "(", "self", ".", "min_dist", ")", "and", "self", ".", "min_dist", ">", "0.0", "\n", "and", "not_none", "(", "self", ".", "n_atoms_detect", ")", "and", "self", ".", "n_atoms_detect", ">", "1", "\n", "and", "len", "(", "coords", ")", ">", "1", "\n", ")", ":", "\n", "            ", "coords", ",", "idx_xyz", ",", "idx_c", "=", "self", ".", "suppress_non_max", "(", "\n", "values", ",", "coords", ",", "idx_xyz", ",", "idx_c", ",", "grid", ".", "typer", "\n", ")", "\n", "\n", "# limit total number of detected atoms", "\n", "", "if", "not_none", "(", "self", ".", "n_atoms_detect", ")", "and", "self", ".", "n_atoms_detect", ">=", "0", ":", "\n", "            ", "coords", "=", "coords", "[", ":", "self", ".", "n_atoms_detect", "]", "\n", "idx_xyz", "=", "idx_xyz", "[", ":", "self", ".", "n_atoms_detect", "]", "\n", "idx_c", "=", "idx_c", "[", ":", "self", ".", "n_atoms_detect", "]", "\n", "\n", "# convert element channel index to one-hot type vector", "\n", "", "types", "=", "F", ".", "one_hot", "(", "idx_c", ",", "grid", ".", "n_elem_channels", ")", ".", "to", "(", "\n", "dtype", "=", "grid", ".", "dtype", ",", "device", "=", "self", ".", "device", "\n", ")", "\n", "\n", "if", "grid", ".", "typer", ".", "n_prop_types", ">", "0", ":", "# detect atom properties", "\n", "\n", "# accrue additional property vecs in types list", "\n", "            ", "types", "=", "[", "types", "]", "\n", "types", ".", "extend", "(", "self", ".", "detect_properties", "(", "grid", ",", "idx_xyz", ",", "idx_c", ")", ")", "\n", "\n", "# concat all property vectors into full type vector", "\n", "types", "=", "torch", ".", "cat", "(", "types", ",", "dim", "=", "1", ")", "\n", "\n", "", "return", "coords", ".", "detach", "(", ")", ",", "types", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.detect_properties": [[394, 452], ["idx_xyz.long().split", "torch.split", "torch.split", "torch.split", "torch.split", "len", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "[].sum", "idx_xyz.long", "atom_fitting.AtomFitter.init_kernel", "torch.conv3d", "torch.conv3d", "len", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.zeros_like.argmax", "torch.zeros_like.argmax", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "prop_values.unsqueeze", "atom_fitting.AtomFitter.kernel.unsqueeze", "len", "prop_values.permute"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.init_kernel"], ["", "def", "detect_properties", "(", "self", ",", "grid", ",", "idx_xyz", ",", "idx_c", ")", ":", "\n", "\n", "# detect atom properties in property channels", "\n", "        ", "prop_values", "=", "grid", ".", "prop_values", "\n", "\n", "# adjust spatial index so we can actually use it", "\n", "#   to index into grid and get property vectors", "\n", "idx", "=", "idx_xyz", ".", "long", "(", ")", ".", "split", "(", "1", ",", "dim", "=", "1", ")", "\n", "\n", "# convolve property channels with atom density kernel", "\n", "if", "self", ".", "apply_prop_conv", ":", "\n", "\n", "            ", "if", "self", ".", "kernel", "is", "None", ":", "\n", "                ", "self", ".", "init_kernel", "(", "grid", ".", "resolution", ",", "grid", ".", "typer", ")", "\n", "\n", "", "kernel_norm2", "=", "(", "\n", "self", ".", "kernel", "**", "2", "\n", ")", ".", "sum", "(", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ",", "keepdim", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "\n", "# apply each element kernel to each property channel", "\n", "#   by setting the properties as the batch dimension", "\n", "#   instead of the inputs dimension, and no groups", "\n", "prop_values", "=", "F", ".", "conv3d", "(", "\n", "input", "=", "prop_values", ".", "unsqueeze", "(", "1", ")", ",", "# add inputs dim", "\n", "weight", "=", "self", ".", "kernel", ".", "unsqueeze", "(", "1", ")", ",", "# add inputs/group dim", "\n", "padding", "=", "self", ".", "kernel", ".", "shape", "[", "-", "1", "]", "//", "2", ",", "\n", "# no groups", "\n", ")", "/", "kernel_norm2", "# normalize, not working?", "\n", "# prop_values[prop_channel, elem_channel, x, y, z]", "\n", "\n", "# need to include elem channel index now", "\n", "idx", "=", "(", "idx_c", ",", ")", "+", "idx", "\n", "\n", "# split into separate grids for each property", "\n", "#   and extend type vector with detected properties", "\n", "", "prop_ranges", "=", "[", "len", "(", "r", ")", "for", "r", "in", "grid", ".", "typer", ".", "prop_ranges", "[", "1", ":", "]", "]", "\n", "for", "prop_values", "in", "torch", ".", "split", "(", "prop_values", ",", "prop_ranges", ")", ":", "\n", "\n", "            ", "if", "len", "(", "idx_xyz", ")", "==", "0", ":", "# no atoms detected", "\n", "                ", "yield", "torch", ".", "zeros", "(", "0", ",", "len", "(", "prop_values", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "continue", "\n", "\n", "# rearrange so property channels are the last index", "\n", "#   and then use spatial index to get property vectors", "\n", "#   there's an extra dimension added for some reason", "\n", "", "dims", "=", "torch", ".", "roll", "(", "torch", ".", "arange", "(", "prop_values", ".", "ndim", ")", ",", "shifts", "=", "-", "1", ")", "\n", "assert", "dims", "[", "-", "1", "]", "==", "0", "\n", "prop_vecs", "=", "prop_values", ".", "permute", "(", "*", "dims", ")", "[", "idx", "]", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "if", "prop_vecs", ".", "shape", "[", "1", "]", ">", "1", ":", "# argmax -> one-hot", "\n", "                ", "prop_vals", "=", "prop_vecs", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "prop_vecs", "=", "torch", ".", "zeros_like", "(", "prop_vecs", ")", "\n", "prop_vecs", "[", ":", ",", "prop_vals", "]", "=", "1.0", "\n", "", "else", ":", "# boolean", "\n", "                ", "prop_vecs", "=", "(", "prop_vecs", ">", "0.5", ")", "\n", "\n", "", "yield", "prop_vecs", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.gd": [[453, 496], ["coords.clone().detach().to.clone().detach().to.clone().detach().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "atom_fitting.AtomFitter.grid_maker.set_radii_type_indexed", "atom_fitting.AtomFitter.grid_maker.set_dimension", "atom_fitting.AtomFitter.grid_maker.set_resolution", "tuple", "range", "len", "grid.center.cpu().numpy().astype", "torch.optim.Adam.zero_grad", "torch.optim.Adam.zero_grad", "atom_fitting.AtomFitter.c2grid", "values_diff.abs().sum.backward", "torch.optim.Adam.step", "torch.optim.Adam.step", "coords.clone().detach().to.clone().detach().to.detach", "atom_fitting.AtomFitter.detach", "values_diff.detach", "values_diff.abs().sum.detach", "coords.clone().detach().to.clone().detach().to.clone().detach", "values_diff.abs().sum", "elem_types.argmax", "grid.center.cpu().numpy", "coords.clone().detach().to.clone().detach().to.clone", "values_diff.abs", "grid.center.cpu"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["", "", "def", "gd", "(", "self", ",", "grid", ",", "coords", ",", "types", ",", "n_iters", ")", ":", "\n", "        ", "'''\n        Performing n_iters steps of gradient descent\n        on the provided atomic coordinates, minimizing\n        the L2 loss between the provided grid and the\n        grid produced by the fit coords and types.\n        '''", "\n", "coords", "=", "coords", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "elem_types", "=", "types", "[", ":", ",", ":", "grid", ".", "n_elem_channels", "]", "\n", "if", "len", "(", "coords", ")", ">", "0", ":", "\n", "            ", "radii", "=", "grid", ".", "typer", ".", "elem_radii", "[", "elem_types", ".", "argmax", "(", "dim", "=", "1", ")", "]", "\n", "", "else", ":", "\n", "            ", "radii", "=", "grid", ".", "typer", ".", "elem_radii", "[", ":", "0", "]", "\n", "", "coords", ".", "requires_grad", "=", "True", "\n", "\n", "optim", "=", "torch", ".", "optim", ".", "Adam", "(", "(", "coords", ",", ")", ",", "**", "self", ".", "gd_kwargs", ")", "\n", "\n", "self", ".", "grid_maker", ".", "set_radii_type_indexed", "(", "False", ")", "\n", "self", ".", "grid_maker", ".", "set_dimension", "(", "grid", ".", "dimension", ")", "\n", "self", ".", "grid_maker", ".", "set_resolution", "(", "grid", ".", "resolution", ")", "\n", "self", ".", "c2grid", ".", "center", "=", "tuple", "(", "grid", ".", "center", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_iters", "+", "1", ")", ":", "\n", "            ", "optim", ".", "zero_grad", "(", ")", "\n", "\n", "values_fit", "=", "self", ".", "c2grid", "(", "coords", ",", "types", ",", "radii", ")", "\n", "values_diff", "=", "grid", ".", "values", "-", "values_fit", "\n", "if", "self", ".", "fit_L1_loss", ":", "\n", "                ", "loss", "=", "values_diff", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "                ", "loss", "=", "(", "values_diff", "**", "2", ")", ".", "sum", "(", ")", "/", "2.0", "\n", "\n", "", "if", "i", "==", "n_iters", ":", "# or converged?", "\n", "                ", "break", "\n", "\n", "", "loss", ".", "backward", "(", ")", "\n", "optim", ".", "step", "(", ")", "\n", "\n", "", "return", "(", "\n", "coords", ".", "detach", "(", ")", ",", "\n", "values_fit", ".", "detach", "(", ")", ",", "\n", "values_diff", ".", "detach", "(", ")", ",", "\n", "loss", ".", "detach", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.expand_struct": [[498, 517], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "coords_next[].unsqueeze", "types_next[].unsqueeze"], "methods", ["None"], ["", "def", "expand_struct", "(", "self", ",", "coords", ",", "types", ",", "coords_next", ",", "types_next", ")", ":", "\n", "        ", "'''\n        TODO please document me!!!\n        '''", "\n", "if", "self", ".", "multi_atom", "and", "len", "(", "coords_next", ")", ">", "0", ":", "\n", "\n", "# expand to all next atoms simultaneously", "\n", "            ", "coords_new", "=", "torch", ".", "cat", "(", "[", "coords", ",", "coords_next", "]", ")", "\n", "types_new", "=", "torch", ".", "cat", "(", "[", "types", ",", "types_next", "]", ")", "\n", "\n", "yield", "coords_new", ",", "types_new", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "coords_next", ")", ")", ":", "\n", "\n", "# expand to each next atom individually", "\n", "            ", "coords_new", "=", "torch", ".", "cat", "(", "[", "coords", ",", "coords_next", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "]", ")", "\n", "types_new", "=", "torch", ".", "cat", "(", "[", "types", ",", "types_next", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "]", ")", "\n", "\n", "yield", "coords_new", ",", "types_new", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.fit_struct": [[518, 765], ["time.time", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "grid.to", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "atom_fitting.AtomFitter.print", "atom_fitting.AtomFitter.detect_atoms", "set", "torch.cuda.max_memory_allocated", "torch.cuda.max_memory_allocated", "torch.cuda.max_memory_allocated", "torch.cuda.max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "atom_fitting.AtomFitter.print", "atom_fitting.AtomFitter.gd", "values_diff.abs().sum", "atom_fitting.AtomFitter.print", "visited_structs.append", "iter", "grid.to.new_like", "torch.cuda.max_memory_allocated", "torch.cuda.max_memory_allocated", "torch.cuda.max_memory_allocated", "torch.cuda.max_memory_allocated", "type_counts.to.to.to", "atom_fitting.AtomFitter.get_types_estimate", "grid.values.abs().sum", "grid.values.abs().sum.item", "type_counts.to.to.abs().sum", "objective.insert", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "torch.cuda.reset_max_memory_allocated", "ms.append", "grid.values.abs().sum.item", "best_obj.insert", "atom_structs.AtomStruct", "visited_structs.append", "int", "atom_fitting.AtomFitter.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.detect_atoms", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.gd", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.new_like", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.get_types_estimate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "fit_struct", "(", "self", ",", "grid", ",", "type_counts", "=", "None", ")", ":", "\n", "        ", "'''\n        Fit an AtomStruct to an AtomGrid by performing\n        a beam search over sets of atom types and coords\n        with gradient descent at each step.\n        '''", "\n", "t_start", "=", "time", ".", "time", "(", ")", "\n", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "\n", "# get true grid and type counts on appropriate device", "\n", "grid_true", "=", "grid", ".", "to", "(", "self", ".", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "if", "type_counts", "is", "not", "None", ":", "\n", "            ", "type_counts", "=", "type_counts", ".", "to", "(", "self", ".", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "", "if", "self", ".", "estimate_types", ":", "# estimate atom type counts from grid density", "\n", "            ", "type_counts_est", "=", "self", ".", "get_types_estimate", "(", "grid_true", ")", "\n", "est_type_loss", "=", "(", "type_counts", "-", "type_counts_est", ")", ".", "abs", "(", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "type_counts", "=", "type_counts_est", "\n", "", "else", ":", "\n", "            ", "est_type_loss", "=", "np", ".", "nan", "\n", "\n", "# initialize empty struct", "\n", "", "coords", "=", "torch", ".", "zeros", "(", "\n", "(", "0", ",", "3", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "self", ".", "device", "\n", ")", "\n", "types", "=", "torch", ".", "zeros", "(", "\n", "(", "0", ",", "grid", ".", "n_channels", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "self", ".", "device", "\n", ")", "\n", "\n", "# compute initial search objective", "\n", "if", "self", ".", "fit_L1_loss", ":", "\n", "            ", "fit_loss", "=", "grid", ".", "values", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "fit_loss", "=", "(", "grid", ".", "values", "**", "2", ")", ".", "sum", "(", ")", "/", "2.0", "\n", "", "objective", "=", "[", "fit_loss", ".", "item", "(", ")", "]", "\n", "\n", "# to constrain types, order structs first by type diff, then fit loss", "\n", "if", "self", ".", "constrain_types", ":", "\n", "            ", "type_loss", "=", "type_counts", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "objective", ".", "insert", "(", "0", ",", "type_loss", ".", "item", "(", ")", ")", "\n", "\n", "# function for printing objective nicely", "\n", "", "fmt_obj", "=", "lambda", "obj", ":", "'[{}]'", ".", "format", "(", "\n", "', '", ".", "join", "(", "'{:.2f}'", ".", "format", "(", "v", ")", "for", "v", "in", "obj", ")", "\n", ")", "\n", "self", ".", "print", "(", "'Initial struct 0 (objective={}, n_atoms={})'", ".", "format", "(", "\n", "fmt_obj", "(", "objective", ")", ",", "len", "(", "coords", ")", "\n", ")", ")", "\n", "\n", "# detect initial atom locations and types", "\n", "coords_next", ",", "types_next", "=", "self", ".", "detect_atoms", "(", "grid_true", ",", "type_counts", ")", "\n", "\n", "# keep track of best structures so far", "\n", "struct_id", "=", "0", "\n", "best_structs", "=", "[", "\n", "(", "objective", ",", "struct_id", ",", "coords", ",", "types", ",", "coords_next", ",", "types_next", ")", "\n", "]", "\n", "found_new_best_struct", "=", "True", "\n", "\n", "# keep track of visited and expanded structures", "\n", "#   visit = perform gradient descent and compute loss", "\n", "#     if it's a current best struct, also detect atoms", "\n", "#   expand = visit structs derived from this one by", "\n", "#     adding the detected atoms to current stuct", "\n", "visited_structs", "=", "[", "\n", "(", "objective", ",", "struct_id", ",", "time", ".", "time", "(", ")", "-", "t_start", ",", "coords", ",", "types", ")", "\n", "]", "\n", "expanded_ids", "=", "set", "(", ")", "\n", "struct_count", "=", "1", "\n", "\n", "# track GPU memory usage throughout search", "\n", "mi", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "\n", "ms", "=", "[", "]", "\n", "\n", "# search until we can't find a better structure", "\n", "while", "found_new_best_struct", ":", "\n", "\n", "            ", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "found_new_best_struct", "=", "False", "\n", "new_best_structs", "=", "[", "]", "\n", "\n", "# try to expand each current-best structure", "\n", "for", "bs", "in", "best_structs", ":", "\n", "                ", "obj", ",", "struct_id", ",", "coords", ",", "types", ",", "coords_next", ",", "types_next", "=", "bs", "\n", "\n", "if", "struct_id", "in", "expanded_ids", ":", "\n", "                    ", "continue", "# don't expand again", "\n", "\n", "", "self", ".", "print", "(", "'Expand struct {} to {} detected atom(s)'", ".", "format", "(", "\n", "struct_id", ",", "len", "(", "coords_next", ")", "\n", ")", ")", "\n", "\n", "# expand structure to possible next atom(s)", "\n", "for", "coords_new", ",", "types_new", "in", "self", ".", "expand_struct", "(", "\n", "coords", ",", "types", ",", "coords_next", ",", "types_next", "\n", ")", ":", "\n", "\n", "# compute diff and loss after gradient descent", "\n", "                    ", "coords_new", ",", "values_fit", ",", "values_diff", ",", "fit_loss", "=", "self", ".", "gd", "(", "\n", "grid", ",", "coords_new", ",", "types_new", ",", "self", ".", "interm_gd_iters", "\n", ")", "\n", "\n", "# compute new search objective", "\n", "obj_new", "=", "[", "fit_loss", ".", "item", "(", ")", "]", "\n", "if", "self", ".", "constrain_types", ":", "\n", "                        ", "types_diff", "=", "types_true", "-", "types_new", ".", "sum", "(", "dim", "=", "0", ")", "\n", "type_loss", "=", "types_diff", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "objective_new", ".", "insert", "(", "0", ",", "type_loss", ".", "item", "(", ")", ")", "\n", "", "else", ":", "\n", "                        ", "types_diff", "=", "None", "\n", "\n", "", "self", ".", "print", "(", "\n", "'Found new struct (objective={}, n_atoms={})'", ".", "format", "(", "\n", "fmt_obj", "(", "obj_new", ")", ",", "len", "(", "coords_new", ")", "\n", ")", "\n", ")", "\n", "\n", "# check if new structure is one of the best yet", "\n", "if", "any", "(", "obj_new", "<", "s", "[", "0", "]", "for", "s", "in", "best_structs", ")", ":", "\n", "                        ", "found_new_best_struct", "=", "True", "\n", "\n", "# detect possible next atoms to expand the new struct", "\n", "coords_new_next", ",", "types_new_next", "=", "self", ".", "detect_atoms", "(", "\n", "grid_true", ".", "new_like", "(", "values", "=", "values_diff", ")", ",", "\n", "types_diff", ",", "\n", ")", "\n", "new_best_structs", ".", "append", "(", "(", "\n", "obj_new", ",", "\n", "struct_count", ",", "\n", "coords_new", ",", "\n", "types_new", ",", "\n", "coords_new_next", ",", "\n", "types_new_next", ",", "\n", ")", ")", "\n", "struct_count", "+=", "1", "\n", "\n", "n_atoms_added", "=", "len", "(", "coords_new", ")", "-", "len", "(", "coords", ")", "\n", "assert", "n_atoms_added", ">", "0", ",", "'no atoms added'", "\n", "\n", "if", "n_atoms_added", ">", "1", ":", "# skip single atom expand", "\n", "                            ", "break", "\n", "\n", "# regardless, store the visited struct", "\n", "", "", "visited_structs", ".", "append", "(", "(", "\n", "obj_new", ",", "\n", "struct_id", ",", "\n", "time", ".", "time", "(", ")", "-", "t_start", ",", "\n", "coords_new", ",", "\n", "types_new", "\n", ")", ")", "\n", "\n", "", "expanded_ids", ".", "add", "(", "struct_id", ")", "\n", "\n", "", "if", "found_new_best_struct", ":", "\n", "\n", "# determine new set of best structures", "\n", "                ", "best_structs", "=", "sorted", "(", "\n", "best_structs", "+", "new_best_structs", "\n", ")", "[", ":", "self", ".", "beam_size", "]", "\n", "best_objective", "=", "best_structs", "[", "0", "]", "[", "0", "]", "\n", "best_id", "=", "best_structs", "[", "0", "]", "[", "1", "]", "\n", "best_n_atoms", "=", "len", "(", "best_structs", "[", "0", "]", "[", "2", "]", ")", "\n", "\n", "self", ".", "print", "(", "'Best struct {} (objective={}, n_atoms={})'", ".", "format", "(", "\n", "best_id", ",", "fmt_obj", "(", "best_objective", ")", ",", "best_n_atoms", "\n", ")", ")", "\n", "\n", "if", "best_n_atoms", ">=", "50", ":", "# limit molecule size", "\n", "                    ", "found_new_best_struct", "=", "False", "\n", "\n", "", "", "ms", ".", "append", "(", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", ")", "\n", "\n", "", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "\n", "# done searching for atomic structures", "\n", "best_obj", ",", "best_id", ",", "coords_best", ",", "types_best", "=", "best_structs", "[", "0", "]", "[", ":", "4", "]", "\n", "\n", "self", ".", "print", "(", "'Finalize struct {} as struct {}'", ".", "format", "(", "\n", "best_id", ",", "struct_count", "\n", ")", ")", "\n", "\n", "# perform final gradient descent", "\n", "coords_best", ",", "values_fit", ",", "values_diff", ",", "fit_loss", "=", "self", ".", "gd", "(", "\n", "grid_true", ",", "coords_best", ",", "types_best", ",", "self", ".", "final_gd_iters", "\n", ")", "\n", "best_id", "=", "struct_count", "# count this as a new struct", "\n", "\n", "# compute the final L2 and L1 loss", "\n", "L2_loss", "=", "(", "values_diff", "**", "2", ")", ".", "sum", "(", ")", "/", "2", "\n", "L1_loss", "=", "values_diff", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "\n", "best_obj", "=", "[", "fit_loss", ".", "item", "(", ")", "]", "\n", "if", "self", ".", "constrain_types", ":", "\n", "            ", "type_loss", "=", "(", "\n", "type_counts", "-", "types_best", ".", "sum", "(", "dim", "=", "0", ")", "\n", ")", ".", "abs", "(", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "best_obj", ".", "insert", "(", "0", ",", "type_loss", ".", "item", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "type_loss", "=", "np", ".", "nan", "\n", "\n", "", "self", ".", "print", "(", "'Final struct {} (objective={}, n_atoms={})'", ".", "format", "(", "\n", "best_id", ",", "fmt_obj", "(", "best_obj", ")", ",", "len", "(", "coords_best", ")", "\n", ")", ")", "\n", "\n", "# make sure final struct is the last visited struct", "\n", "visited_structs", ".", "append", "(", "(", "\n", "best_obj", ",", "\n", "best_id", ",", "\n", "time", ".", "time", "(", ")", "-", "t_start", ",", "\n", "coords_best", ",", "\n", "types_best", "\n", ")", ")", "\n", "\n", "# finalize visited structs as AtomStructs", "\n", "iter_visited", "=", "iter", "(", "visited_structs", ")", "\n", "visited_structs", "=", "[", "]", "\n", "for", "objective", ",", "struct_id", ",", "fit_time", ",", "coords", ",", "types", "in", "iter_visited", ":", "\n", "\n", "            ", "struct", "=", "AtomStruct", "(", "\n", "coords", "=", "coords", ".", "detach", "(", ")", ",", "\n", "types", "=", "types", ".", "detach", "(", ")", ",", "\n", "typer", "=", "grid", ".", "typer", ",", "\n", "L2_loss", "=", "L2_loss", ",", "\n", "L1_loss", "=", "L1_loss", ",", "\n", "type_diff", "=", "type_loss", ",", "\n", "est_type_diff", "=", "est_type_loss", ",", "\n", "time", "=", "fit_time", ",", "\n", ")", "\n", "visited_structs", ".", "append", "(", "struct", ")", "\n", "\n", "# get the finalized best struct", "\n", "", "struct_best", "=", "visited_structs", "[", "-", "1", "]", "\n", "\n", "# get the fit atomic density grid", "\n", "grid_fit", "=", "grid_true", ".", "new_like", "(", "values", "=", "values_fit", ".", "detach", "(", ")", ")", "\n", "\n", "mf", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "MB", "=", "int", "(", "1024", "**", "2", ")", "\n", "print", "(", "'GPU'", ",", "mi", "//", "MB", ",", "[", "m", "//", "MB", "for", "m", "in", "ms", "]", ",", "mf", "//", "MB", ")", "\n", "\n", "", "return", "struct_best", ",", "grid_fit", ",", "visited_structs", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.fit_batch": [[766, 781], ["atom_grids.AtomGrid", "atom_fitting.AtomFitter.fit_struct", "fit_structs.append", "fit_grids.append", "values.detach"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.fit_struct"], ["", "def", "fit_batch", "(", "self", ",", "batch_values", ",", "center", ",", "resolution", ",", "typer", ")", ":", "\n", "\n", "        ", "fit_structs", ",", "fit_grids", "=", "[", "]", ",", "[", "]", "\n", "for", "values", "in", "batch_values", ":", "\n", "            ", "grid", "=", "AtomGrid", "(", "\n", "values", "=", "values", ".", "detach", "(", ")", ",", "\n", "center", "=", "center", ",", "\n", "resolution", "=", "resolution", ",", "\n", "typer", "=", "typer", "\n", ")", "\n", "fit_struct", ",", "fit_grid", ",", "_", "=", "self", ".", "fit_struct", "(", "grid", ")", "\n", "fit_structs", ".", "append", "(", "fit_struct", ")", "\n", "fit_grids", ".", "append", "(", "fit_grid", ")", "\n", "\n", "", "return", "fit_structs", ",", "fit_grids", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.DkoesAtomFitter.__init__": [[785, 791], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dkoes_make_mol", ",", "use_openbabel", ",", "iters", "=", "25", ",", "tol", "=", "0.01", ")", ":", "\n", "        ", "self", ".", "iters", "=", "iters", "\n", "self", ".", "tol", "=", "tol", "\n", "self", ".", "verbose", "=", "False", "\n", "self", ".", "dkoes_make_mol", "=", "dkoes_make_mol", "\n", "self", ".", "use_openbabel", "=", "use_openbabel", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.DkoesAtomFitter.fit": [[792, 823], ["atom_grids.AtomGrid", "dkoes_fitting.simple_atom_fit", "atom_fitting.DkoesAtomFitter.validify", "atom_grids.AtomGrid", "atom_fitting.remove_tensors", "atom_grids.AtomGrid.cpu().detach().numpy", "atom_grids.AtomGrid.cpu().detach", "atom_grids.AtomGrid.cpu"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.dkoes_fitting.simple_atom_fit", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.remove_tensors"], ["", "def", "fit", "(", "self", ",", "grid", ",", "types", ")", ":", "\n", "\n", "        ", "grid", "=", "AtomGrid", "(", "\n", "values", "=", "grid", ".", "values", ",", "\n", "channels", "=", "grid", ".", "channels", ",", "\n", "center", "=", "grid", ".", "center", ",", "\n", "resolution", "=", "grid", ".", "resolution", ",", "\n", ")", "\n", "\n", "struct", ",", "grid_pred", "=", "dkoes_fitting", ".", "simple_atom_fit", "(", "\n", "mgrid", "=", "grid", ",", "\n", "types", "=", "types", ",", "\n", "iters", "=", "self", ".", "iters", ",", "\n", "tol", "=", "self", ".", "tol", ",", "\n", "grm", "=", "1.0", "\n", ")", "\n", "\n", "struct", ".", "info", "[", "'visited_structs'", "]", "=", "[", "struct", "]", "\n", "self", ".", "validify", "(", "struct", ")", "\n", "\n", "grid_pred", "=", "AtomGrid", "(", "\n", "values", "=", "grid_pred", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "channels", "=", "grid", ".", "channels", ",", "\n", "center", "=", "grid", ".", "center", ",", "\n", "resolution", "=", "grid", ".", "resolution", ",", "\n", "visited_structs", "=", "[", "struct", "]", ",", "\n", "src_struct", "=", "struct", ",", "\n", ")", "\n", "\n", "return", "remove_tensors", "(", "grid_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.remove_tensors": [[825, 855], ["visited.add", "isinstance", "set", "id", "hasattr", "dct.items", "isinstance", "isinstance", "id", "isinstance", "enumerate", "v.cpu().detach().numpy", "atom_fitting.remove_tensors", "atom_fitting.remove_tensors", "v.cpu().detach", "v.cpu"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.remove_tensors", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.remove_tensors"], ["", "", "def", "remove_tensors", "(", "obj", ",", "visited", "=", "None", ")", ":", "\n", "    ", "'''\n    Recursively traverse an object converting pytorch tensors\n    to numpy arrays in-place.\n    '''", "\n", "visited", "=", "visited", "or", "set", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "obj", ",", "(", "AtomGrid", ",", "AtomStruct", ",", "list", ",", "dict", ")", ")", "or", "id", "(", "obj", ")", "in", "visited", ":", "\n", "#avoid traversing everything", "\n", "        ", "return", "obj", "\n", "\n", "", "visited", ".", "add", "(", "id", "(", "obj", ")", ")", "\n", "\n", "dct", "=", "None", "\n", "if", "isinstance", "(", "obj", ",", "dict", ")", ":", "\n", "        ", "dct", "=", "obj", "\n", "", "elif", "hasattr", "(", "obj", ",", "'__dict__'", ")", ":", "\n", "        ", "dct", "=", "obj", ".", "__dict__", "\n", "\n", "", "if", "dct", ":", "\n", "        ", "for", "k", ",", "v", "in", "dct", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "dct", "[", "k", "]", "=", "v", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "                ", "dct", "[", "k", "]", "=", "remove_tensors", "(", "v", ",", "visited", ")", "\n", "", "", "", "elif", "isinstance", "(", "obj", ",", "list", ")", ":", "\n", "        ", "for", "i", ",", "v", "in", "enumerate", "(", "obj", ")", ":", "\n", "            ", "obj", "[", "i", "]", "=", "remove_tensors", "(", "obj", "[", "i", "]", ",", "visited", ")", "\n", "\n", "", "", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot": [[857, 862], ["torch.zeros", "torch.zeros", "numpy.ndenumerate", "int"], "function", ["None"], ["", "def", "make_one_hot", "(", "x", ",", "n", ",", "dtype", "=", "None", ",", "device", "=", "None", ")", ":", "\n", "    ", "y", "=", "torch", ".", "zeros", "(", "x", ".", "shape", "+", "(", "n", ",", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "for", "idx", ",", "last_idx", "in", "np", ".", "ndenumerate", "(", "x", ")", ":", "\n", "        ", "y", "[", "idx", "+", "(", "int", "(", "last_idx", ")", ",", ")", "]", "=", "1", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.one_hot_to_index": [[864, 869], ["len", "torch.argmax", "torch.argmax", "torch.empty", "torch.empty"], "function", ["None"], ["", "def", "one_hot_to_index", "(", "x", ")", ":", "\n", "    ", "if", "len", "(", "x", ")", ">", "0", ":", "\n", "        ", "return", "torch", ".", "argmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "        ", "return", "torch", ".", "empty", "(", "(", "0", ",", ")", ",", "device", "=", "x", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.conv_grid": [[871, 876], ["numpy.fft.fftn", "numpy.fft.fftn", "numpy.real", "numpy.fft.ifftn"], "function", ["None"], ["", "", "def", "conv_grid", "(", "grid", ",", "kernel", ")", ":", "\n", "# convolution theorem: g * grid = F-1(F(g)F(grid))", "\n", "    ", "F_h", "=", "np", ".", "fft", ".", "fftn", "(", "kernel", ")", "\n", "F_grid", "=", "np", ".", "fft", ".", "fftn", "(", "grid", ")", "\n", "return", "np", ".", "real", "(", "np", ".", "fft", ".", "ifftn", "(", "F_grid", "*", "F_h", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.weiner_invert_kernel": [[878, 883], ["numpy.fft.fftn", "numpy.conj", "numpy.real", "numpy.fft.ifftn"], "function", ["None"], ["", "def", "weiner_invert_kernel", "(", "kernel", ",", "noise_ratio", "=", "0.0", ")", ":", "\n", "    ", "F_h", "=", "np", ".", "fft", ".", "fftn", "(", "kernel", ")", "\n", "conj_F_h", "=", "np", ".", "conj", "(", "F_h", ")", "\n", "F_g", "=", "conj_F_h", "/", "(", "F_h", "*", "conj_F_h", "+", "noise_ratio", ")", "\n", "return", "np", ".", "real", "(", "np", ".", "fft", ".", "ifftn", "(", "F_g", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.wiener_deconv_grid": [[885, 901], ["numpy.fft.fftn", "numpy.fft.fftn", "numpy.conj", "numpy.real", "numpy.fft.ifftn"], "function", ["None"], ["", "def", "wiener_deconv_grid", "(", "grid", ",", "kernel", ",", "noise_ratio", "=", "0.0", ")", ":", "\n", "    ", "'''\n    Applies a convolution to the input grid that approximates the inverse\n    of the operation that converts a set of atom positions to a grid of\n    atom density.\n    '''", "\n", "# we want a convolution g such that g * grid = a, where a is the atom positions", "\n", "# we assume that grid = h * a, so g is the inverse of h: g * (h * a) = a", "\n", "# take F() to be the Fourier transform, F-1() the inverse Fourier transform", "\n", "# convolution theorem: g * grid = F-1(F(g)F(grid))", "\n", "# Wiener deconvolution: F(g) = 1/F(h) |F(h)|^2 / (|F(h)|^2 + noise_ratio)", "\n", "F_h", "=", "np", ".", "fft", ".", "fftn", "(", "kernel", ")", "\n", "F_grid", "=", "np", ".", "fft", ".", "fftn", "(", "grid", ")", "\n", "conj_F_h", "=", "np", ".", "conj", "(", "F_h", ")", "\n", "F_g", "=", "conj_F_h", "/", "(", "F_h", "*", "conj_F_h", "+", "noise_ratio", ")", "\n", "return", "np", ".", "real", "(", "np", ".", "fft", ".", "ifftn", "(", "F_grid", "*", "F_g", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.wiener_deconv_grids": [[903, 916], ["numpy.zeros_like", "atom_fitting.get_grid_points", "enumerate", "numpy.stack", "get_atom_density().reshape", "numpy.roll", "atom_fitting.wiener_deconv_grid", "get_atom_density", "range"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.get_grid_points", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.wiener_deconv_grid"], ["", "def", "wiener_deconv_grids", "(", "grids", ",", "channels", ",", "resolution", ",", "radius_multiple", ",", "noise_ratio", "=", "0.0", ",", "radius_factor", "=", "1.0", ")", ":", "\n", "\n", "    ", "deconv_grids", "=", "np", ".", "zeros_like", "(", "grids", ")", "\n", "points", "=", "get_grid_points", "(", "grids", ".", "shape", "[", "1", ":", "]", ",", "0", ",", "resolution", ")", "\n", "\n", "for", "i", ",", "grid", "in", "enumerate", "(", "grids", ")", ":", "\n", "\n", "        ", "r", "=", "channels", "[", "i", "]", ".", "atomic_radius", "*", "radius_factor", "\n", "kernel", "=", "get_atom_density", "(", "resolution", "/", "2", ",", "r", ",", "points", ",", "radius_multiple", ")", ".", "reshape", "(", "grid", ".", "shape", ")", "\n", "kernel", "=", "np", ".", "roll", "(", "kernel", ",", "shift", "=", "[", "d", "//", "2", "for", "d", "in", "grid", ".", "shape", "]", ",", "axis", "=", "range", "(", "grid", ".", "ndim", ")", ")", "\n", "deconv_grids", "[", "i", ",", "...", "]", "=", "wiener_deconv_grid", "(", "grid", ",", "kernel", ",", "noise_ratio", ")", "\n", "\n", "", "return", "np", ".", "stack", "(", "deconv_grids", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.get_grid_points": [[918, 929], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "list", "numpy.ndindex"], "function", ["None"], ["", "def", "get_grid_points", "(", "shape", ",", "center", ",", "resolution", ")", ":", "\n", "    ", "'''\n    Return an array of points for a grid with\n    the given shape, center, and resolution.\n    '''", "\n", "shape", "=", "np", ".", "array", "(", "shape", ")", "\n", "center", "=", "np", ".", "array", "(", "center", ")", "\n", "resolution", "=", "np", ".", "array", "(", "resolution", ")", "\n", "origin", "=", "center", "-", "resolution", "*", "(", "shape", "-", "1", ")", "/", "2.0", "\n", "indices", "=", "np", ".", "array", "(", "list", "(", "np", ".", "ndindex", "(", "*", "shape", ")", ")", ")", "\n", "return", "origin", "+", "resolution", "*", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.grid_to_points_and_values": [[931, 938], ["atom_fitting.get_grid_points", "grid.flatten"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.get_grid_points"], ["", "def", "grid_to_points_and_values", "(", "grid", ",", "center", ",", "resolution", ")", ":", "\n", "    ", "'''\n    Convert a grid with a center and resolution to lists\n    of grid points and values at each point.\n    '''", "\n", "points", "=", "get_grid_points", "(", "grid", ".", "shape", ",", "center", ",", "resolution", ")", "\n", "return", "points", ",", "grid", ".", "flatten", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.__init__": [[34, 99], ["object.__init__", "print", "generating.MoleculeGenerator.init_data", "print", "liGAN.atom_fitting.AtomFitter", "print", "liGAN.bond_adding.BondAdder", "print", "generating.OutputWriter", "print", "generating.MoleculeGenerator.init_gen_model", "print", "grid_types.add", "grid_types.add", "grid_types.add", "print", "generating.MoleculeGenerator.init_prior_model", "grid_types.add", "grid_types.add"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_data", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_gen_model", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_prior_model"], ["def", "__init__", "(", "\n", "self", ",", "\n", "out_prefix", ",", "\n", "n_samples", ",", "\n", "fit_atoms", ",", "\n", "data_kws", "=", "{", "}", ",", "\n", "gen_model_kws", "=", "{", "}", ",", "\n", "prior_model_kws", "=", "{", "}", ",", "\n", "atom_fitting_kws", "=", "{", "}", ",", "\n", "bond_adding_kws", "=", "{", "}", ",", "\n", "output_kws", "=", "{", "}", ",", "\n", "device", "=", "'cuda'", ",", "\n", "verbose", "=", "False", ",", "\n", "debug", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "device", "=", "device", "\n", "\n", "print", "(", "'Loading data'", ")", "\n", "self", ".", "init_data", "(", "device", "=", "device", ",", "n_samples", "=", "n_samples", ",", "**", "data_kws", ")", "\n", "\n", "if", "self", ".", "gen_model_type", ":", "\n", "            ", "print", "(", "'Initializing generative model'", ")", "\n", "self", ".", "init_gen_model", "(", "\n", "device", "=", "device", ",", "n_samples", "=", "n_samples", ",", "**", "gen_model_kws", "\n", ")", "\n", "\n", "if", "self", ".", "gen_model_type", ".", "has_stage2", ":", "\n", "                ", "print", "(", "'Initializing prior model'", ")", "\n", "self", ".", "init_prior_model", "(", "device", "=", "device", ",", "**", "prior_model_kws", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "prior_model", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "'No generative model'", ")", "\n", "self", ".", "gen_model", "=", "None", "\n", "self", ".", "prior_model", "=", "None", "\n", "\n", "", "print", "(", "'Initializing atom fitter'", ")", "\n", "self", ".", "atom_fitter", "=", "liGAN", ".", "atom_fitting", ".", "AtomFitter", "(", "\n", "device", "=", "device", ",", "**", "atom_fitting_kws", "\n", ")", "\n", "print", "(", "'Initializing bond adder'", ")", "\n", "self", ".", "bond_adder", "=", "liGAN", ".", "bond_adding", ".", "BondAdder", "(", "\n", "debug", "=", "debug", ",", "**", "bond_adding_kws", "\n", ")", "\n", "\n", "# determine expected grid types", "\n", "grid_types", "=", "{", "'rec'", ",", "'lig'", "}", "\n", "if", "self", ".", "data", ".", "diff_cond_structs", "or", "self", ".", "data", ".", "diff_cond_transform", ":", "\n", "            ", "grid_types", ".", "add", "(", "'cond_rec'", ")", "\n", "grid_types", ".", "add", "(", "'cond_lig'", ")", "\n", "", "if", "self", ".", "gen_model", ":", "\n", "            ", "grid_types", ".", "add", "(", "'lig_gen'", ")", "\n", "if", "fit_atoms", ":", "\n", "                ", "grid_types", ".", "add", "(", "'lig_gen_fit'", ")", "\n", "", "", "elif", "fit_atoms", ":", "\n", "            ", "grid_types", ".", "add", "(", "'lig_fit'", ")", "\n", "\n", "", "print", "(", "'Initializing output writer'", ")", "\n", "self", ".", "out_writer", "=", "OutputWriter", "(", "\n", "out_prefix", "=", "out_prefix", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "grid_types", "=", "grid_types", ",", "\n", "verbose", "=", "verbose", ",", "\n", "**", "output_kws", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_data": [[101, 104], ["liGAN.data.AtomGridData"], "methods", ["None"], ["", "def", "init_data", "(", "self", ",", "device", ",", "n_samples", ",", "**", "data_kws", ")", ":", "\n", "        ", "self", ".", "data", "=", "liGAN", ".", "data", ".", "AtomGridData", "(", "\n", "device", "=", "device", ",", "n_samples", "=", "n_samples", ",", "**", "data_kws", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_gen_model": [[106, 129], ["generating.MoleculeGenerator.gen_model_type", "generating.MoleculeGenerator.gen_model.apply", "print", "torch.load", "torch.load.pop", "generating.MoleculeGenerator.gen_model.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "init_gen_model", "(", "\n", "self", ",", "\n", "device", ",", "\n", "caffe_init", "=", "False", ",", "\n", "state", "=", "None", ",", "\n", "**", "gen_model_kws", "\n", ")", ":", "\n", "        ", "self", ".", "gen_model", "=", "self", ".", "gen_model_type", "(", "\n", "n_channels_in", "=", "self", ".", "n_channels_in", ",", "\n", "n_channels_cond", "=", "self", ".", "n_channels_cond", ",", "\n", "n_channels_out", "=", "self", ".", "n_channels_out", ",", "\n", "grid_size", "=", "self", ".", "data", ".", "grid_size", ",", "\n", "device", "=", "device", ",", "\n", "**", "gen_model_kws", "\n", ")", "\n", "if", "caffe_init", ":", "\n", "            ", "self", ".", "gen_model", ".", "apply", "(", "liGAN", ".", "models", ".", "caffe_init_weights", ")", "\n", "\n", "", "if", "state", ":", "\n", "            ", "print", "(", "'Loading generative model state'", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "state", ")", "\n", "state_dict", ".", "pop", "(", "'log_recon_var'", ",", "None", ")", "\n", "self", ".", "gen_model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.init_prior_model": [[130, 150], ["liGAN.models.Stage2VAE().to", "generating.MoleculeGenerator.prior_model.apply", "print", "torch.load", "torch.load.pop", "generating.MoleculeGenerator.prior_model.load_state_dict", "liGAN.models.Stage2VAE"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "init_prior_model", "(", "\n", "self", ",", "\n", "device", ",", "\n", "caffe_init", "=", "False", ",", "\n", "state", "=", "None", ",", "\n", "**", "prior_model_kws", "\n", ")", ":", "\n", "        ", "self", ".", "prior_model", "=", "liGAN", ".", "models", ".", "Stage2VAE", "(", "\n", "n_input", "=", "self", ".", "gen_model", ".", "n_latent", ",", "\n", "**", "prior_model_kws", "\n", ")", ".", "to", "(", "device", ")", "\n", "\n", "if", "caffe_init", ":", "\n", "            ", "self", ".", "prior_model", ".", "apply", "(", "liGAN", ".", "models", ".", "caffe_init_weights", ")", "\n", "\n", "", "if", "state", ":", "\n", "            ", "print", "(", "'Loading prior model state'", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "state", ")", "\n", "state_dict", ".", "pop", "(", "'log_recon_var'", ",", "None", ")", "\n", "self", ".", "prior_model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.n_channels_in": [[151, 159], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "n_channels_in", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "gen_model_type", ".", "has_input_encoder", ":", "\n", "            ", "data", "=", "self", ".", "data", "\n", "if", "self", ".", "has_complex_input", ":", "\n", "                ", "return", "data", ".", "n_rec_channels", "+", "data", ".", "n_lig_channels", "\n", "", "else", ":", "\n", "                ", "return", "data", ".", "n_lig_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.n_channels_cond": [[160, 164], ["None"], "methods", ["None"], ["", "", "", "@", "property", "\n", "def", "n_channels_cond", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "gen_model_type", ".", "has_conditional_encoder", ":", "\n", "            ", "return", "self", ".", "data", ".", "n_rec_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.n_channels_out": [[165, 168], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "n_channels_out", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "n_lig_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.n_channels_disc": [[169, 177], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_channels_disc", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "has_disc_model", ":", "\n", "            ", "data", "=", "self", ".", "data", "\n", "if", "self", ".", "gen_model_type", ".", "has_conditional_encoder", ":", "\n", "                ", "return", "data", ".", "n_rec_channels", "+", "data", ".", "n_lig_channels", "\n", "", "else", ":", "\n", "                ", "return", "data", ".", "n_lig_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward": [[178, 252], ["print", "print", "print", "print", "data.split_channels", "data.split_channels", "data.forward", "generating.MoleculeGenerator.forward.try_detach"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.split_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.split_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "", "", "def", "forward", "(", "\n", "self", ",", "\n", "prior", ",", "\n", "stage2", ",", "\n", "interpolate", "=", "False", ",", "\n", "spherical", "=", "False", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "print", "(", "f'Calling generator forward'", ")", "\n", "print", "(", "f'  prior = {prior}'", ")", "\n", "print", "(", "f'  stage2 = {stage2}'", ")", "\n", "\n", "print", "(", "'Getting next batch of data'", ")", "\n", "data", "=", "self", ".", "data", "\n", "input_grids", ",", "cond_grids", ",", "input_structs", ",", "cond_structs", ",", "transforms", "=", "data", ".", "forward", "(", "interpolate", "=", "interpolate", ",", "spherical", "=", "spherical", ")", "[", ":", "5", "]", "\n", "input_rec_structs", ",", "input_lig_structs", "=", "input_structs", "\n", "cond_rec_structs", ",", "cond_lig_structs", "=", "cond_structs", "\n", "input_transforms", ",", "cond_transforms", "=", "transforms", "\n", "input_rec_grids", ",", "input_lig_grids", "=", "data", ".", "split_channels", "(", "input_grids", ")", "\n", "cond_rec_grids", ",", "cond_lig_grids", "=", "data", ".", "split_channels", "(", "cond_grids", ")", "\n", "\n", "posterior", "=", "not", "prior", "\n", "if", "posterior", ":", "\n", "            ", "if", "self", ".", "has_complex_input", ":", "\n", "                ", "gen_input_grids", "=", "torch", ".", "cat", "(", "\n", "[", "input_rec_grids", ",", "input_lig_grids", "]", ",", "dim", "=", "1", "\n", ")", "\n", "", "else", ":", "\n", "                ", "gen_input_grids", "=", "input_lig_grids", "\n", "", "", "else", ":", "\n", "            ", "gen_input_grids", "=", "None", "\n", "\n", "", "gen_cond_grids", "=", "cond_rec_grids", "\n", "\n", "if", "self", ".", "gen_model", ":", "\n", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "if", "stage2", ":", "# insert prior model", "\n", "                    ", "lig_gen_grids", ",", "_", ",", "_", ",", "_", ",", "latents", ",", "_", ",", "_", "=", "self", ".", "gen_model", ".", "forward2", "(", "\n", "prior_model", "=", "self", ".", "prior_model", ",", "\n", "inputs", "=", "gen_input_grids", ",", "\n", "conditions", "=", "gen_cond_grids", ",", "\n", "interpolate", "=", "interpolate", ",", "\n", "spherical", "=", "spherical", ",", "\n", "batch_size", "=", "self", ".", "data", ".", "batch_size", ",", "\n", "**", "kwargs", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "lig_gen_grids", ",", "latents", ",", "_", ",", "_", "=", "self", ".", "gen_model", "(", "\n", "inputs", "=", "gen_input_grids", ",", "\n", "conditions", "=", "gen_cond_grids", ",", "\n", "batch_size", "=", "self", ".", "data", ".", "batch_size", ",", "\n", "interpolate", "=", "interpolate", ",", "\n", "spherical", "=", "spherical", ",", "\n", "**", "kwargs", "\n", ")", "\n", "", "", "", "else", ":", "\n", "            ", "lig_gen_grids", ",", "latents", "=", "None", ",", "None", "\n", "\n", "", "def", "try_detach", "(", "x", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "return", "x", ".", "detach", "(", ")", "\n", "", "except", "AttributeError", ":", "\n", "                ", "return", "x", "\n", "\n", "", "", "input_grids", "=", "try_detach", "(", "input_rec_grids", ")", ",", "try_detach", "(", "input_lig_grids", ")", "\n", "cond_grids", "=", "try_detach", "(", "cond_rec_grids", ")", ",", "try_detach", "(", "cond_lig_grids", ")", "\n", "latents", ",", "lig_gen_grids", "=", "try_detach", "(", "latents", ")", ",", "try_detach", "(", "lig_gen_grids", ")", "\n", "return", "(", "\n", "input_grids", ",", "cond_grids", ",", "\n", "input_structs", ",", "cond_structs", ",", "\n", "latents", ",", "lig_gen_grids", ",", "transforms", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.generate": [[254, 573], ["print", "itertools.product", "range", "range", "print", "torch.as_tensor", "torch.as_tensor", "generating.MoleculeGenerator.forward", "tuple", "tuple", "print", "generating.read_rec_from_pdb_file", "generating.read_lig_from_sdf_file", "generating.read_rec_from_pdb_file", "generating.read_lig_from_sdf_file", "torch.cuda.reset_max_memory_allocated", "grid_type.startswith", "grid_type.endswith", "liGAN.atom_grids.AtomGrid", "print", "generating.MoleculeGenerator.out_writer.write", "input_transform.get_rotation_center", "cond_transform.get_rotation_center", "x.rsplit", "splitext", "splitext", "read_rec_from_pdb_file.get_pocket", "read_lig_from_sdf_file.uff_minimize", "print", "generating.MoleculeGenerator.bond_adder.make_mol", "splitext", "splitext", "read_rec_from_pdb_file.get_pocket", "read_lig_from_sdf_file.uff_minimize", "liGAN.atom_grids.AtomGrid.values.norm", "liGAN.atom_grids.AtomGrid.new_like", "print", "generating.MoleculeGenerator.atom_fitter.fit_struct", "generating.MoleculeGenerator.out_writer.write", "os.path.basename", "os.path.basename", "print", "read_lig_from_sdf_file.gnina_minimize", "print", "read_rec_from_pdb_file.get_pocket", "lig_add_mol.uff_minimize", "os.path.basename", "os.path.basename", "print", "read_lig_from_sdf_file.gnina_minimize", "torch.cuda.max_memory_allocated", "cond_transform.backward", "print", "generating.MoleculeGenerator.bond_adder.make_mol", "x.endswith", "print", "lig_add_mol.uff_minimize.gnina_minimize", "torch.cat", "print", "read_rec_from_pdb_file.get_pocket", "fit_add_mol.uff_minimize", "print", "read_rec_from_pdb_file.get_pocket", "fit_add_mol.uff_minimize", "print", "fit_add_mol.uff_minimize.gnina_minimize", "print", "fit_add_mol.uff_minimize.gnina_minimize", "atom_fitter.convolve"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.read_rec_from_pdb_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.read_lig_from_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.read_rec_from_pdb_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.read_lig_from_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.get_pocket", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.uff_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.get_pocket", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.uff_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.new_like", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.fit_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.gnina_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.get_pocket", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.uff_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.gnina_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.gnina_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.get_pocket", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.uff_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.get_pocket", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.uff_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.gnina_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.gnina_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.convolve"], ["", "def", "generate", "(", "\n", "self", ",", "\n", "n_examples", ",", "\n", "n_samples", ",", "\n", "prior", "=", "False", ",", "\n", "stage2", "=", "False", ",", "\n", "var_factor", "=", "1.0", ",", "\n", "post_factor", "=", "1.0", ",", "\n", "z_score", "=", "None", ",", "\n", "truncate", "=", "None", ",", "\n", "interpolate", "=", "False", ",", "\n", "spherical", "=", "False", ",", "\n", "fit_atoms", "=", "True", ",", "\n", "add_bonds", "=", "True", ",", "\n", "uff_minimize", "=", "True", ",", "\n", "gnina_minimize", "=", "True", ",", "\n", "fit_to_real", "=", "False", ",", "\n", "add_to_real", "=", "False", ",", "\n", "minimize_real", "=", "True", ",", "\n", "verbose", "=", "True", ",", "\n", ")", ":", "\n", "        ", "'''\n        Generate atomic density grids from generative\n        model for each example in data, fit atomic\n        structures, and add bonds to make molecules.\n        '''", "\n", "batch_size", "=", "self", ".", "data", ".", "batch_size", "\n", "\n", "print", "(", "'Starting to generate grids'", ")", "\n", "for", "example_idx", ",", "sample_idx", "in", "itertools", ".", "product", "(", "\n", "range", "(", "n_examples", ")", ",", "range", "(", "n_samples", ")", "\n", ")", ":", "\n", "# keep track of position in current batch", "\n", "            ", "full_idx", "=", "example_idx", "*", "n_samples", "+", "sample_idx", "\n", "batch_idx", "=", "full_idx", "%", "batch_size", "\n", "print", "(", "example_idx", ",", "sample_idx", ",", "full_idx", ",", "batch_idx", ")", "\n", "\n", "need_real_input_mol", "=", "(", "sample_idx", "==", "0", ")", "\n", "need_real_cond_mol", "=", "(", "sample_idx", "==", "0", "and", "self", ".", "data", ".", "diff_cond_structs", ")", "\n", "need_next_batch", "=", "(", "batch_idx", "==", "0", ")", "\n", "\n", "if", "need_next_batch", ":", "# forward next batch", "\n", "\n", "#if gnina_minimize: # copy to gpu", "\n", "#    self.gen_model.to('cuda')", "\n", "                ", "(", "\n", "input_grids", ",", "cond_grids", ",", "\n", "input_structs", ",", "cond_structs", ",", "\n", "latents", ",", "lig_gen_grids", ",", "transforms", "\n", ")", "=", "self", ".", "forward", "(", "\n", "prior", "=", "prior", ",", "\n", "stage2", "=", "stage2", ",", "\n", "var_factor", "=", "var_factor", ",", "\n", "post_factor", "=", "post_factor", ",", "\n", "z_score", "=", "z_score", ",", "\n", "truncate", "=", "truncate", ",", "\n", "interpolate", "=", "interpolate", ",", "\n", "spherical", "=", "spherical", ",", "\n", ")", "\n", "input_rec_grids", ",", "input_lig_grids", "=", "input_grids", "\n", "cond_rec_grids", ",", "cond_lig_grids", "=", "cond_grids", "\n", "input_rec_structs", ",", "input_lig_structs", "=", "input_structs", "\n", "cond_rec_structs", ",", "cond_lig_structs", "=", "cond_structs", "\n", "input_transforms", ",", "cond_transforms", "=", "transforms", "\n", "#if gnina_minimize: # copy to cpu", "\n", "#    self.gen_model.to('cpu')", "\n", "\n", "", "input_rec_struct", "=", "input_rec_structs", "[", "batch_idx", "]", "\n", "input_lig_struct", "=", "input_lig_structs", "[", "batch_idx", "]", "\n", "cond_rec_struct", "=", "cond_rec_structs", "[", "batch_idx", "]", "\n", "cond_lig_struct", "=", "cond_lig_structs", "[", "batch_idx", "]", "\n", "\n", "# in order to align gen structs with real structs,", "\n", "#   we need to apply the inverse of the transform", "\n", "#   that was used to create the density grid that", "\n", "#   is the reconstruction target (assume conditional)", "\n", "input_transform", "=", "input_transforms", "[", "batch_idx", "]", "\n", "cond_transform", "=", "cond_transforms", "[", "batch_idx", "]", "\n", "input_center", "=", "torch", ".", "as_tensor", "(", "tuple", "(", "\n", "input_transform", ".", "get_rotation_center", "(", ")", "\n", ")", ")", "\n", "cond_center", "=", "torch", ".", "as_tensor", "(", "tuple", "(", "\n", "cond_transform", ".", "get_rotation_center", "(", ")", "\n", ")", ")", "\n", "\n", "# only process real rec/lig once, since they're", "\n", "#   the same for all samples of a given ligand", "\n", "if", "need_real_input_mol", ":", "\n", "                ", "print", "(", "'Getting real input molecule from data root'", ")", "\n", "splitext", "=", "lambda", "x", ":", "x", ".", "rsplit", "(", "'.'", ",", "1", "+", "x", ".", "endswith", "(", "'.gz'", ")", ")", "\n", "\n", "input_rec_src_file", "=", "input_rec_struct", ".", "info", "[", "'src_file'", "]", "\n", "input_rec_mol", "=", "read_rec_from_pdb_file", "(", "input_rec_src_file", ")", "\n", "input_rec_name", "=", "splitext", "(", "os", ".", "path", ".", "basename", "(", "input_rec_src_file", ")", ")", "[", "0", "]", "\n", "\n", "input_lig_src_file", "=", "input_lig_struct", ".", "info", "[", "'src_file'", "]", "\n", "input_lig_mol", "=", "read_lig_from_sdf_file", "(", "input_lig_src_file", ")", "\n", "input_lig_name", "=", "splitext", "(", "os", ".", "path", ".", "basename", "(", "input_lig_src_file", ")", ")", "[", "0", "]", "\n", "\n", "if", "uff_minimize", ":", "\n", "# real molecules don't need UFF minimization,", "\n", "#   but we need their UFF metrics for reference", "\n", "                    ", "input_pkt_mol", "=", "input_rec_mol", ".", "get_pocket", "(", "lig_mol", "=", "input_lig_mol", ")", "\n", "input_lig_mol", ".", "info", "[", "'pkt_mol'", "]", "=", "input_pkt_mol", "\n", "input_uff_mol", "=", "input_lig_mol", ".", "uff_minimize", "(", "rec_mol", "=", "input_pkt_mol", ")", "\n", "input_lig_mol", ".", "info", "[", "'uff_mol'", "]", "=", "input_uff_mol", "\n", "\n", "if", "minimize_real", ":", "\n", "                        ", "print", "(", "'Minimizing real molecule with gnina'", ",", "flush", "=", "True", ")", "\n", "# NOTE that we are not using the UFF mol here", "\n", "input_lig_mol", ".", "info", "[", "'gni_mol'", "]", "=", "input_lig_mol", ".", "gnina_minimize", "(", "rec_mol", "=", "input_rec_mol", ")", "\n", "\n", "", "", "if", "add_to_real", ":", "# evaluate bond adding in isolation", "\n", "                    ", "print", "(", "'Adding bonds to real atoms'", ")", "\n", "lig_add_mol", ",", "lig_add_struct", ",", "_", "=", "self", ".", "bond_adder", ".", "make_mol", "(", "input_lig_struct", ")", "\n", "lig_add_mol", ".", "info", "[", "'type_struct'", "]", "=", "lig_add_struct", "\n", "lig_struct", ".", "info", "[", "'add_mol'", "]", "=", "lig_add_mol", "\n", "\n", "if", "uff_minimize", ":", "\n", "                        ", "print", "(", "'Minimizing molecule from real atoms with UFF'", ",", "\n", "end", "=", "''", ")", "# show number of tries inline", "\n", "lig_add_pkt_mol", "=", "input_rec_mol", ".", "get_pocket", "(", "lig_mol", "=", "lig_add_mol", ")", "\n", "lig_add_mol", ".", "info", "[", "'pkt_mol'", "]", "=", "lig_add_pkt_mol", "\n", "lig_add_uff_mol", "=", "lig_add_mol", ".", "uff_minimize", "(", "rec_mol", "=", "lig_add_pkt_mol", ")", "\n", "lig_add_mol", ".", "info", "[", "'uff_mol'", "]", "=", "lig_add_uff_mol", "\n", "\n", "if", "gnina_minimize", ":", "\n", "                            ", "print", "(", "'Minimizing molecule from real atoms with gnina'", ",", "flush", "=", "True", ")", "\n", "lig_add_mol", ".", "info", "[", "'gni_mol'", "]", "=", "lig_add_uff_mol", ".", "gnina_minimize", "(", "rec_mol", "=", "input_rec_mol", ")", "\n", "\n", "", "", "", "", "else", ":", "# check that the molecules are the same", "\n", "                ", "assert", "input_rec_struct", ".", "info", "[", "'src_file'", "]", "==", "input_rec_src_file", "\n", "assert", "input_lig_struct", ".", "info", "[", "'src_file'", "]", "==", "input_lig_src_file", "\n", "\n", "# if the conditional molecule is different,", "\n", "#   we need to process it separately from input", "\n", "", "if", "need_real_cond_mol", ":", "\n", "\n", "                ", "cond_rec_src_file", "=", "cond_rec_struct", ".", "info", "[", "'src_file'", "]", "\n", "cond_rec_mol", "=", "read_rec_from_pdb_file", "(", "cond_rec_src_file", ")", "\n", "cond_rec_name", "=", "splitext", "(", "os", ".", "path", ".", "basename", "(", "cond_rec_src_file", ")", ")", "[", "0", "]", "\n", "\n", "cond_lig_src_file", "=", "cond_lig_struct", ".", "info", "[", "'src_file'", "]", "\n", "cond_lig_mol", "=", "read_lig_from_sdf_file", "(", "cond_lig_src_file", ")", "\n", "cond_lig_name", "=", "splitext", "(", "os", ".", "path", ".", "basename", "(", "cond_lig_src_file", ")", ")", "[", "0", "]", "\n", "\n", "if", "uff_minimize", ":", "\n", "# real molecules don't need UFF minimization,", "\n", "#   but we need their UFF metrics for reference", "\n", "                    ", "cond_pkt_mol", "=", "cond_rec_mol", ".", "get_pocket", "(", "lig_mol", "=", "cond_lig_mol", ")", "\n", "cond_lig_mol", ".", "info", "[", "'pkt_mol'", "]", "=", "cond_pkt_mol", "\n", "cond_uff_mol", "=", "cond_lig_mol", ".", "uff_minimize", "(", "rec_mol", "=", "cond_pkt_mol", ")", "\n", "cond_lig_mol", ".", "info", "[", "'uff_mol'", "]", "=", "cond_uff_mol", "\n", "\n", "if", "minimize_real", ":", "\n", "                        ", "print", "(", "'Minimizing real molecule with gnina'", ",", "flush", "=", "True", ")", "\n", "# NOTE that we are not using the UFF mol here", "\n", "cond_lig_mol", ".", "info", "[", "'gni_mol'", "]", "=", "cond_lig_mol", ".", "gnina_minimize", "(", "rec_mol", "=", "cond_rec_mol", ")", "\n", "\n", "", "", "", "elif", "self", ".", "data", ".", "diff_cond_structs", ":", "\n", "                ", "assert", "cond_rec_struct", ".", "info", "[", "'src_file'", "]", "==", "cond_rec_src_file", "\n", "assert", "cond_lig_struct", ".", "info", "[", "'src_file'", "]", "==", "cond_lig_src_file", "\n", "", "else", ":", "\n", "                ", "cond_rec_name", "=", "input_rec_name", "\n", "cond_lig_name", "=", "input_lig_name", "\n", "\n", "# unique identifier for this data example", "\n", "", "example_info", "=", "(", "\n", "example_idx", ",", "\n", "input_rec_name", ",", "\n", "input_lig_name", ",", "\n", "cond_rec_name", ",", "\n", "cond_lig_name", ",", "\n", ")", "\n", "\n", "# done processing real mols/structs, so attach them", "\n", "input_rec_struct", ".", "info", "[", "'src_mol'", "]", "=", "input_rec_mol", "\n", "input_lig_struct", ".", "info", "[", "'src_mol'", "]", "=", "input_lig_mol", "\n", "if", "self", ".", "data", ".", "diff_cond_structs", ":", "\n", "                ", "cond_rec_struct", ".", "info", "[", "'src_mol'", "]", "=", "cond_rec_mol", "\n", "cond_lig_struct", ".", "info", "[", "'src_mol'", "]", "=", "cond_lig_mol", "\n", "\n", "# now process atomic density grids", "\n", "", "grid_types", "=", "[", "\n", "(", "'rec'", ",", "input_rec_grids", ")", ",", "\n", "(", "'lig'", ",", "input_lig_grids", ")", ",", "\n", "]", "\n", "if", "self", ".", "data", ".", "diff_cond_structs", "or", "self", ".", "data", ".", "diff_cond_transform", ":", "\n", "                ", "grid_types", "+=", "[", "\n", "(", "'cond_rec'", ",", "cond_rec_grids", ")", ",", "\n", "(", "'cond_lig'", ",", "cond_lig_grids", ")", "\n", "]", "\n", "", "if", "self", ".", "gen_model", ":", "\n", "                ", "grid_types", "+=", "[", "\n", "(", "'lig_gen'", ",", "lig_gen_grids", ")", "\n", "]", "\n", "\n", "", "for", "grid_type", ",", "grids", "in", "grid_types", ":", "\n", "                ", "torch", ".", "cuda", ".", "reset_max_memory_allocated", "(", ")", "\n", "\n", "is_cond_grid", "=", "grid_type", ".", "startswith", "(", "'cond'", ")", "\n", "is_lig_grid", "=", "(", "'lig'", "in", "grid_type", ")", "\n", "is_gen_grid", "=", "grid_type", ".", "endswith", "(", "'gen'", ")", "\n", "real_or_gen", "=", "'generated'", "if", "is_gen_grid", "else", "'real'", "\n", "\n", "if", "is_gen_grid", ":", "\n", "                    ", "grid_needs_fit", "=", "fit_atoms", "and", "is_lig_grid", "\n", "center", "=", "cond_center", "\n", "", "elif", "is_cond_grid", ":", "\n", "                    ", "grid_need_fit", "=", "False", "\n", "center", "=", "cond_center", "\n", "", "else", ":", "\n", "                    ", "grid_needs_fit", "=", "fit_to_real", "and", "is_lig_grid", "\n", "center", "=", "input_center", "\n", "\n", "", "if", "is_lig_grid", ":", "\n", "                    ", "atom_typer", "=", "self", ".", "data", ".", "lig_typer", "\n", "", "else", ":", "\n", "                    ", "atom_typer", "=", "self", ".", "data", ".", "rec_typer", "\n", "\n", "", "grid", "=", "liGAN", ".", "atom_grids", ".", "AtomGrid", "(", "\n", "values", "=", "grids", "[", "batch_idx", "]", ",", "\n", "typer", "=", "atom_typer", ",", "\n", "center", "=", "center", ",", "\n", "resolution", "=", "self", ".", "data", ".", "resolution", "\n", ")", "\n", "\n", "if", "grid_type", "==", "'rec'", ":", "\n", "                    ", "grid", ".", "info", "[", "'src_struct'", "]", "=", "input_rec_struct", "\n", "", "elif", "grid_type", "==", "'lig'", ":", "\n", "                    ", "grid", ".", "info", "[", "'src_struct'", "]", "=", "input_lig_struct", "\n", "", "elif", "grid_type", "==", "'cond_rec'", ":", "\n", "                    ", "grid", ".", "info", "[", "'src_struct'", "]", "=", "cond_rec_struct", "\n", "", "elif", "grid_type", "==", "'cond_lig'", ":", "\n", "                    ", "grid", ".", "info", "[", "'src_struct'", "]", "=", "cond_lig_struct", "\n", "", "elif", "grid_type", "==", "'lig_gen'", ":", "\n", "                    ", "grid", ".", "info", "[", "'src_latent'", "]", "=", "latents", "[", "batch_idx", "]", "\n", "\n", "# display progress", "\n", "", "index_str", "=", "f'[example_idx={example_idx} sample_idx={sample_idx} grid_type={grid_type}]'", "\n", "value_str", "=", "'norm={:.4f} gpu={:.4f}'", ".", "format", "(", "\n", "grid", ".", "values", ".", "norm", "(", ")", ",", "\n", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "/", "MB", ",", "\n", ")", "\n", "print", "(", "index_str", "+", "' '", "+", "value_str", ",", "flush", "=", "True", ")", "\n", "\n", "if", "is_lig_grid", "and", "self", ".", "out_writer", ".", "output_conv", ":", "\n", "                    ", "grid", ".", "info", "[", "'conv_grid'", "]", "=", "grid", ".", "new_like", "(", "\n", "values", "=", "torch", ".", "cat", "(", "[", "\n", "atom_fitter", ".", "convolve", "(", "\n", "grid", ".", "elem_values", ",", "grid", ".", "resolution", ",", "grid", ".", "typer", "\n", ")", ",", "\n", "grid", ".", "prop_values", "\n", "]", ",", "dim", "=", "0", ")", "\n", ")", "\n", "\n", "", "self", ".", "out_writer", ".", "write", "(", "example_info", ",", "sample_idx", ",", "grid_type", ",", "grid", ")", "\n", "\n", "if", "grid_needs_fit", ":", "# perform atom fitting", "\n", "\n", "                    ", "print", "(", "f'Fitting atoms to {real_or_gen} grid'", ")", "\n", "fit_struct", ",", "fit_grid", ",", "visited_structs", "=", "self", ".", "atom_fitter", ".", "fit_struct", "(", "grid", ",", "cond_lig_struct", ".", "type_counts", ")", "\n", "fit_struct", ".", "info", "[", "'visited_structs'", "]", "=", "visited_structs", "\n", "fit_grid", ".", "info", "[", "'src_struct'", "]", "=", "fit_struct", "\n", "\n", "if", "fit_struct", ".", "n_atoms", ">", "0", ":", "# inverse transform", "\n", "                        ", "cond_transform", ".", "backward", "(", "fit_struct", ".", "coords", ",", "fit_struct", ".", "coords", ")", "\n", "\n", "", "if", "add_bonds", ":", "# do bond adding", "\n", "                        ", "print", "(", "f'Adding bonds to atoms from {real_or_gen} grid'", ")", "\n", "fit_add_mol", ",", "fit_add_struct", ",", "visited_mols", "=", "self", ".", "bond_adder", ".", "make_mol", "(", "fit_struct", ")", "\n", "fit_add_mol", ".", "info", "[", "'type_struct'", "]", "=", "fit_add_struct", "\n", "fit_struct", ".", "info", "[", "'add_mol'", "]", "=", "fit_add_mol", "\n", "\n", "if", "uff_minimize", ":", "# do UFF minimization", "\n", "                            ", "print", "(", "f'Minimizing molecule from {real_or_gen} grid with UFF'", ",", "end", "=", "''", ")", "\n", "fit_pkt_mol", "=", "input_rec_mol", ".", "get_pocket", "(", "fit_add_mol", ")", "\n", "fit_add_mol", ".", "info", "[", "'pkt_mol'", "]", "=", "fit_pkt_mol", "\n", "fit_uff_mol", "=", "fit_add_mol", ".", "uff_minimize", "(", "rec_mol", "=", "fit_pkt_mol", ")", "\n", "fit_add_mol", ".", "info", "[", "'uff_mol'", "]", "=", "fit_uff_mol", "\n", "\n", "if", "gnina_minimize", ":", "# do gnina minimization", "\n", "                                ", "print", "(", "f'Minimizing molecule from {real_or_gen} grid with gnina'", ",", "flush", "=", "True", ")", "\n", "fit_add_mol", ".", "info", "[", "'gni_mol'", "]", "=", "fit_uff_mol", ".", "gnina_minimize", "(", "rec_mol", "=", "input_rec_mol", ")", "\n", "\n", "# minimize and score wrt conditional receptor too", "\n", "", "", "if", "self", ".", "data", ".", "diff_cond_structs", "and", "uff_minimize", ":", "\n", "                            ", "print", "(", "f'Minimizing molecule from {real_or_gen} grid with UFF wrt conditional receptor'", ",", "end", "=", "''", ")", "\n", "fit_pkt_mol", "=", "cond_rec_mol", ".", "get_pocket", "(", "fit_add_mol", ")", "\n", "fit_add_mol", ".", "info", "[", "'cond_pkt_mol'", "]", "=", "fit_pkt_mol", "\n", "fit_uff_mol", "=", "fit_add_mol", ".", "uff_minimize", "(", "rec_mol", "=", "fit_pkt_mol", ")", "\n", "fit_add_mol", ".", "info", "[", "'cond_uff_mol'", "]", "=", "fit_uff_mol", "\n", "\n", "if", "gnina_minimize", ":", "# do gnina minimization", "\n", "                                ", "print", "(", "f'Minimizing molecule from {real_or_gen} grid with gnina wrt conditional receptor'", ",", "flush", "=", "True", ")", "\n", "fit_add_mol", ".", "info", "[", "'cond_gni_mol'", "]", "=", "fit_uff_mol", ".", "gnina_minimize", "(", "rec_mol", "=", "cond_rec_mol", ")", "\n", "\n", "", "", "", "grid_type", "+=", "'_fit'", "\n", "self", ".", "out_writer", ".", "write", "(", "\n", "example_info", ",", "sample_idx", ",", "grid_type", ",", "fit_grid", "\n", ")", "\n", "\n", "", "", "", "return", "self", ".", "out_writer", ".", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.__init__": [[631, 703], ["os.path.split", "collections.defaultdict", "os.path.join", "pandas.DataFrame().set_index", "os.path.join", "dict", "pathlib.Path", "pathlib.Path.mkdir", "generating.OutputWriter.latent_dir.mkdir", "generating.OutputWriter.grid_dir.mkdir", "generating.OutputWriter.struct_dir.mkdir", "generating.OutputWriter.mol_dir.mkdir", "collections.defaultdict", "pandas.DataFrame"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "out_prefix", ",", "\n", "n_samples", ",", "\n", "grid_types", ",", "\n", "output_mols", "=", "True", ",", "\n", "output_structs", "=", "False", ",", "\n", "output_grids", "=", "False", ",", "\n", "output_latents", "=", "False", ",", "\n", "output_visited", "=", "False", ",", "\n", "output_conv", "=", "False", ",", "\n", "batch_metrics", "=", "False", ",", "\n", "verbose", "=", "False", "\n", ")", ":", "\n", "        ", "out_dir", ",", "out_prefix", "=", "os", ".", "path", ".", "split", "(", "out_prefix", ")", "\n", "self", ".", "out_prefix", "=", "out_prefix", "\n", "\n", "self", ".", "output_grids", "=", "output_grids", "\n", "self", ".", "output_structs", "=", "output_structs", "\n", "self", ".", "output_mols", "=", "output_mols", "\n", "self", ".", "output_latents", "=", "output_latents", "\n", "self", ".", "output_visited", "=", "output_visited", "\n", "self", ".", "output_conv", "=", "output_conv", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "self", ".", "grid_types", "=", "grid_types", "\n", "self", ".", "batch_metrics", "=", "batch_metrics", "\n", "\n", "# organize grids by (rec_name, lig_name), sample_idx, grid_type", "\n", "self", ".", "grids", "=", "defaultdict", "(", "lambda", ":", "defaultdict", "(", "dict", ")", ")", "\n", "\n", "# accumulate metrics in dataframe", "\n", "self", ".", "metric_file", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "f'{out_prefix}.gen_metrics'", ")", "\n", "columns", "=", "[", "\n", "'example_idx'", ",", "\n", "'input_rec_name'", ",", "\n", "'input_lig_name'", ",", "\n", "'cond_rec_name'", ",", "\n", "'cond_lig_name'", ",", "\n", "'sample_idx'", "\n", "]", "\n", "self", ".", "metrics", "=", "pd", ".", "DataFrame", "(", "columns", "=", "columns", ")", ".", "set_index", "(", "columns", ")", "\n", "\n", "# write a pymol script when finished", "\n", "self", ".", "pymol_file", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "f'{out_prefix}.pymol'", ")", "\n", "self", ".", "dx_prefixes", "=", "[", "]", "\n", "self", ".", "sdf_files", "=", "[", "]", "\n", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "# keep sdf files open so that all samples of a given", "\n", "#   struct or molecule can be written to one file", "\n", "self", ".", "open_files", "=", "dict", "(", ")", "\n", "\n", "# create directories for output files", "\n", "out_dir", "=", "Path", "(", "out_dir", ")", "\n", "out_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "if", "output_latents", ":", "\n", "            ", "self", ".", "latent_dir", "=", "out_dir", "/", "'latents'", "\n", "self", ".", "latent_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "", "if", "output_grids", ":", "\n", "            ", "self", ".", "grid_dir", "=", "out_dir", "/", "'grids'", "\n", "self", ".", "grid_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "", "if", "output_structs", ":", "\n", "            ", "self", ".", "struct_dir", "=", "out_dir", "/", "'structs'", "\n", "self", ".", "struct_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "", "if", "output_mols", ":", "\n", "            ", "self", ".", "mol_dir", "=", "out_dir", "/", "'molecules'", "\n", "self", ".", "mol_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print": [[704, 707], ["generating.OutputWriter.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "print", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.close_files": [[708, 717], ["list", "generating.OutputWriter.open_files.items", "out.close"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close"], ["", "", "def", "close_files", "(", "self", ")", ":", "\n", "        ", "'''\n        Close all open files that the output\n        writer currently has a reference to\n        and delete the references.\n        '''", "\n", "for", "f", ",", "out", "in", "list", "(", "self", ".", "open_files", ".", "items", "(", ")", ")", ":", "\n", "            ", "out", ".", "close", "(", ")", "\n", "del", "self", ".", "open_files", "[", "f", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf": [[718, 762], ["gzip.open", "generating.OutputWriter.print", "isinstance", "generating.OutputWriter.sdf_files.append", "out.close", "liGAN.molecules.write_rd_mols_to_sdf_file", "str", "generating.OutputWriter.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.close", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mols_to_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "write_sdf", "(", "self", ",", "sdf_file", ",", "mol", ",", "sample_idx", ",", "is_real", ")", ":", "\n", "        ", "'''\n        Append molecule or atom sturct to sdf_file.\n\n        NOTE this method assumes that samples will be\n        produced in sequential order (i.e. not async)\n        because it opens the file on first sample_idx\n        and closes it on the last one.\n        '''", "\n", "if", "sdf_file", "not", "in", "self", ".", "open_files", ":", "\n", "            ", "self", ".", "open_files", "[", "sdf_file", "]", "=", "gzip", ".", "open", "(", "sdf_file", ",", "'wt'", ")", "\n", "", "out", "=", "self", ".", "open_files", "[", "sdf_file", "]", "\n", "\n", "if", "sample_idx", "==", "0", "or", "not", "is_real", ":", "\n", "            ", "self", ".", "print", "(", "f'Writing {sdf_file} sample {sample_idx}'", ")", "\n", "\n", "if", "isinstance", "(", "mol", ",", "AtomStruct", ")", ":", "\n", "                ", "struct", "=", "mol", "\n", "if", "self", ".", "output_visited", "and", "'visited_structs'", "in", "struct", ".", "info", ":", "\n", "                    ", "visited_structs", "=", "struct", ".", "info", "[", "'visited_structs'", "]", "\n", "rd_mols", "=", "[", "s", ".", "to_rd_mol", "(", ")", "for", "s", "in", "visited_structs", "]", "\n", "", "else", ":", "\n", "                    ", "rd_mols", "=", "[", "struct", ".", "to_rd_mol", "(", ")", "]", "\n", "\n", "", "", "else", ":", "# molecule", "\n", "                ", "if", "self", ".", "output_visited", "and", "'visited_mols'", "in", "mol", ".", "info", ":", "\n", "                    ", "rd_mols", "=", "mol", ".", "info", "[", "'visited_mols'", "]", "\n", "", "else", ":", "\n", "                    ", "rd_mols", "=", "[", "mol", "]", "\n", "\n", "", "", "try", ":", "\n", "                ", "mols", ".", "write_rd_mols_to_sdf_file", "(", "\n", "out", ",", "rd_mols", ",", "str", "(", "sample_idx", ")", ",", "kekulize", "=", "False", "\n", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "print", "(", "sdf_file", ",", "sample_idx", ",", "is_real", ")", "\n", "raise", "\n", "\n", "", "", "if", "sample_idx", "==", "0", ":", "\n", "            ", "self", ".", "sdf_files", ".", "append", "(", "sdf_file", ")", "\n", "\n", "", "if", "sample_idx", "+", "1", "==", "self", ".", "n_samples", "or", "is_real", ":", "\n", "            ", "out", ".", "close", "(", ")", "\n", "del", "self", ".", "open_files", "[", "sdf_file", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_atom_types": [[763, 767], ["generating.OutputWriter.print", "generating.write_atom_types_to_file", "str"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.write_atom_types_to_file"], ["", "", "def", "write_atom_types", "(", "self", ",", "types_file", ",", "atom_types", ")", ":", "\n", "\n", "        ", "self", ".", "print", "(", "'Writing '", "+", "str", "(", "types_file", ")", ")", "\n", "write_atom_types_to_file", "(", "types_file", ",", "atom_types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_dx": [[768, 773], ["generating.OutputWriter.print", "grid.to_dx", "generating.OutputWriter.dx_prefixes.append"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to_dx"], ["", "def", "write_dx", "(", "self", ",", "dx_prefix", ",", "grid", ")", ":", "\n", "\n", "        ", "self", ".", "print", "(", "f'Writing {dx_prefix} .dx files'", ")", "\n", "grid", ".", "to_dx", "(", "dx_prefix", ")", "\n", "self", ".", "dx_prefixes", ".", "append", "(", "dx_prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_latent": [[774, 778], ["generating.OutputWriter.print", "generating.write_latent_vec_to_file", "str"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.write_latent_vec_to_file"], ["", "def", "write_latent", "(", "self", ",", "latent_file", ",", "latent_vec", ")", ":", "\n", "\n", "        ", "self", ".", "print", "(", "'Writing '", "+", "str", "(", "latent_file", ")", ")", "\n", "write_latent_vec_to_file", "(", "latent_file", ",", "latent_vec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write": [[779, 969], ["str", "grid_type.startswith", "grid_type.endswith", "grid_type.endswith", "generating.OutputWriter.write_dx", "generating.OutputWriter.write_latent", "all", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_atom_types", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_dx", "len", "generating.OutputWriter.print", "generating.OutputWriter.print", "generating.OutputWriter.metrics.to_csv", "generating.OutputWriter.print", "generating.write_pymol_script", "generating.OutputWriter.print", "set", "generating.OutputWriter.print", "generating.OutputWriter.print", "generating.OutputWriter.metrics.to_csv", "generating.OutputWriter.print", "generating.write_pymol_script", "generating.OutputWriter.print", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.write_sdf", "generating.OutputWriter.compute_metrics", "generating.OutputWriter.compute_metrics", "set", "generating.OutputWriter.close_files", "generating.OutputWriter.close_files"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_dx", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_latent", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_atom_types", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_dx", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.write_pymol_script", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.write_pymol_script", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_metrics", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.close_files", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.close_files"], ["", "def", "write", "(", "self", ",", "example_info", ",", "sample_idx", ",", "grid_type", ",", "grid", ")", ":", "\n", "        ", "'''\n        Write output files for grid and compute metrics in\n        data frame, if all necessary data is present.\n        '''", "\n", "out_prefix", "=", "self", ".", "out_prefix", "\n", "example_idx", ",", "input_rec_name", ",", "input_lig_name", ",", "cond_rec_name", ",", "cond_lig_name", "=", "example_info", "\n", "grid_prefix", "=", "f'{out_prefix}_{example_idx}_{grid_type}'", "\n", "i", "=", "str", "(", "sample_idx", ")", "\n", "\n", "assert", "grid_type", "in", "{", "\n", "'rec'", ",", "'lig'", ",", "'cond_rec'", ",", "'cond_lig'", ",", "\n", "'lig_gen'", ",", "'lig_fit'", ",", "'lig_gen_fit'", "\n", "}", "\n", "is_lig_grid", "=", "grid_type", ".", "startswith", "(", "'lig'", ")", "\n", "is_gen_grid", "=", "grid_type", ".", "endswith", "(", "'_gen'", ")", "\n", "is_fit_grid", "=", "grid_type", ".", "endswith", "(", "'_fit'", ")", "\n", "\n", "is_real_grid", "=", "not", "(", "is_gen_grid", "or", "is_fit_grid", ")", "\n", "is_first_real_grid", "=", "(", "is_real_grid", "and", "sample_idx", "==", "0", ")", "\n", "has_struct", "=", "(", "is_real_grid", "or", "is_fit_grid", ")", "\n", "has_conv_grid", "=", "not", "is_fit_grid", "# and is_lig_grid ?", "\n", "\n", "# write atomic structs and/or molecules", "\n", "if", "has_struct", ":", "\n", "\n", "# get struct that created this grid (via molgrid.GridMaker)", "\n", "#   note that depending on the grid_type, this can either be", "\n", "#   from atom fitting OR from typing a real molecule", "\n", "            ", "struct", "=", "grid", ".", "info", "[", "'src_struct'", "]", "\n", "\n", "# the real (source) molecule and atom types don't change", "\n", "#   between different samples, so only write them once", "\n", "\n", "# and we don't apply bond adding to the receptor struct,", "\n", "#   so only ligand structs have add_mol and uff_mol", "\n", "\n", "# write real molecule", "\n", "if", "self", ".", "output_mols", "and", "is_first_real_grid", ":", "\n", "\n", "                ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_src.sdf.gz'", ")", "\n", "src_mol", "=", "struct", ".", "info", "[", "'src_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "src_mol", ",", "sample_idx", ",", "is_real", "=", "True", ")", "\n", "\n", "if", "'pkt_mol'", "in", "src_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_src_pkt.sdf.gz'", ")", "\n", "pkt_mol", "=", "src_mol", ".", "info", "[", "'pkt_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "pkt_mol", ",", "sample_idx", ",", "is_real", "=", "True", ")", "\n", "\n", "", "if", "'uff_mol'", "in", "src_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_src_uff.sdf.gz'", ")", "\n", "uff_mol", "=", "src_mol", ".", "info", "[", "'uff_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "uff_mol", ",", "sample_idx", ",", "is_real", "=", "True", ")", "\n", "\n", "", "if", "'gni_mol'", "in", "src_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_src_gna.sdf.gz'", ")", "\n", "gni_mol", "=", "src_mol", ".", "info", "[", "'gni_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "gni_mol", ",", "sample_idx", ",", "is_real", "=", "True", ")", "\n", "\n", "# write typed atomic structure (real or fit)", "\n", "", "", "if", "self", ".", "output_structs", "and", "(", "is_first_real_grid", "or", "is_fit_grid", ")", ":", "\n", "\n", "                ", "sdf_file", "=", "self", ".", "struct_dir", "/", "(", "grid_prefix", "+", "'.sdf.gz'", ")", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "struct", ",", "sample_idx", ",", "is_real_grid", ")", "\n", "\n", "# write atom type channels", "\n", "types_base", "=", "grid_prefix", "+", "'_'", "+", "i", "+", "'.atom_types'", "\n", "types_file", "=", "self", ".", "struct_dir", "/", "types_base", "\n", "self", ".", "write_atom_types", "(", "types_file", ",", "struct", ".", "atom_types", ")", "\n", "\n", "# write bond-added molecule (real or fit ligand)", "\n", "", "if", "self", ".", "output_mols", "and", "'add_mol'", "in", "struct", ".", "info", ":", "\n", "                ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_add.sdf.gz'", ")", "\n", "add_mol", "=", "struct", ".", "info", "[", "'add_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "add_mol", ",", "sample_idx", ",", "is_real_grid", ")", "\n", "\n", "if", "'pkt_mol'", "in", "add_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_add_pkt.sdf.gz'", ")", "\n", "pkt_mol", "=", "add_mol", ".", "info", "[", "'pkt_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "pkt_mol", ",", "sample_idx", ",", "is_real_grid", ")", "\n", "\n", "", "if", "'uff_mol'", "in", "add_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_add_uff.sdf.gz'", ")", "\n", "uff_mol", "=", "add_mol", ".", "info", "[", "'uff_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "uff_mol", ",", "sample_idx", ",", "is_real_grid", ")", "\n", "\n", "", "if", "'gni_mol'", "in", "add_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_add_gna.sdf.gz'", ")", "\n", "gni_mol", "=", "add_mol", ".", "info", "[", "'gni_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "gni_mol", ",", "sample_idx", ",", "is_real_grid", ")", "\n", "\n", "", "if", "'cond_pkt_mol'", "in", "add_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_add_cond_pkt.sdf.gz'", ")", "\n", "pkt_mol", "=", "add_mol", ".", "info", "[", "'pkt_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "pkt_mol", ",", "sample_idx", ",", "is_real_grid", ")", "\n", "\n", "", "if", "'cond_uff_mol'", "in", "add_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_add_cond_uff.sdf.gz'", ")", "\n", "uff_mol", "=", "add_mol", ".", "info", "[", "'uff_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "uff_mol", ",", "sample_idx", ",", "is_real_grid", ")", "\n", "\n", "", "if", "'cond_gni_mol'", "in", "add_mol", ".", "info", ":", "\n", "                    ", "sdf_file", "=", "self", ".", "mol_dir", "/", "(", "grid_prefix", "+", "'_add_cond_gna.sdf.gz'", ")", "\n", "gni_mol", "=", "add_mol", ".", "info", "[", "'gni_mol'", "]", "\n", "self", ".", "write_sdf", "(", "sdf_file", ",", "gni_mol", ",", "sample_idx", ",", "is_real_grid", ")", "\n", "\n", "# write atomic density grids", "\n", "", "", "", "if", "self", ".", "output_grids", ":", "\n", "\n", "            ", "dx_prefix", "=", "self", ".", "grid_dir", "/", "(", "grid_prefix", "+", "'_'", "+", "i", ")", "\n", "self", ".", "write_dx", "(", "dx_prefix", ",", "grid", ")", "\n", "\n", "# write convolved grid", "\n", "if", "self", ".", "output_conv", "and", "'conv_grid'", "in", "grid", ".", "info", ":", "\n", "\n", "                ", "dx_prefix", "=", "self", ".", "grid_dir", "/", "(", "grid_prefix", "+", "'_conv_'", "+", "i", ")", "\n", "self", ".", "write_dx", "(", "dx_prefix", ",", "grid", ".", "info", "[", "'conv_grid'", "]", ")", "\n", "\n", "# write latent vectors", "\n", "", "", "if", "self", ".", "output_latents", "and", "is_gen_grid", ":", "\n", "\n", "            ", "latent_file", "=", "self", ".", "latent_dir", "/", "(", "grid_prefix", "+", "'_'", "+", "i", "+", "'.latent'", ")", "\n", "self", ".", "write_latent", "(", "latent_file", ",", "grid", ".", "info", "[", "'src_latent'", "]", ")", "\n", "\n", "# store grid until ready to compute output metrics", "\n", "#   if we're computing batch matrics, need all samples", "\n", "#   otherwise, just need all grids for this sample", "\n", "", "self", ".", "grids", "[", "example_info", "]", "[", "sample_idx", "]", "[", "grid_type", "]", "=", "grid", "\n", "lig_grids", "=", "self", ".", "grids", "[", "example_info", "]", "\n", "\n", "if", "self", ".", "batch_metrics", ":", "\n", "\n", "# store until grids for all samples are ready", "\n", "            ", "has_all_samples", "=", "(", "len", "(", "lig_grids", ")", "==", "self", ".", "n_samples", ")", "\n", "has_all_grids", "=", "all", "(", "\n", "set", "(", "lig_grids", "[", "i", "]", ")", ">=", "self", ".", "grid_types", "for", "i", "in", "lig_grids", "\n", ")", "\n", "\n", "# compute batch metrics", "\n", "if", "has_all_samples", "and", "has_all_grids", ":", "\n", "                ", "self", ".", "print", "(", "\n", "f'Computing metrics for all example {example_idx} samples'", "\n", ")", "\n", "try", ":", "\n", "                    ", "self", ".", "compute_metrics", "(", "example_info", ")", "\n", "", "except", ":", "\n", "                    ", "self", ".", "close_files", "(", ")", "\n", "raise", "\n", "\n", "", "self", ".", "print", "(", "'Writing '", "+", "self", ".", "metric_file", ")", "\n", "self", ".", "metrics", ".", "to_csv", "(", "self", ".", "metric_file", ",", "sep", "=", "' '", ")", "\n", "\n", "self", ".", "print", "(", "'Writing '", "+", "self", ".", "pymol_file", ")", "\n", "write_pymol_script", "(", "\n", "self", ".", "pymol_file", ",", "\n", "self", ".", "out_prefix", ",", "\n", "self", ".", "dx_prefixes", ",", "\n", "self", ".", "sdf_files", ",", "\n", ")", "\n", "self", ".", "print", "(", "'Freeing memory'", ")", "\n", "del", "self", ".", "grids", "[", "example_info", "]", "# free memory", "\n", "\n", "", "", "else", ":", "\n", "# only store until grids for this sample are ready", "\n", "            ", "has_all_grids", "=", "(", "\n", "set", "(", "lig_grids", "[", "sample_idx", "]", ")", ">=", "self", ".", "grid_types", "\n", ")", "\n", "# compute sample metrics", "\n", "if", "has_all_grids", ":", "\n", "                ", "self", ".", "print", "(", "\n", "f'Computing metrics for example {example_idx} sample {sample_idx}'", "\n", ")", "\n", "try", ":", "\n", "                    ", "self", ".", "compute_metrics", "(", "example_info", ",", "sample_idx", ")", "\n", "", "except", ":", "\n", "                    ", "self", ".", "close_files", "(", ")", "\n", "raise", "\n", "\n", "", "self", ".", "print", "(", "'Writing '", "+", "self", ".", "metric_file", ")", "\n", "self", ".", "metrics", ".", "to_csv", "(", "self", ".", "metric_file", ",", "sep", "=", "' '", ")", "\n", "\n", "self", ".", "print", "(", "'Writing '", "+", "self", ".", "pymol_file", ")", "\n", "write_pymol_script", "(", "\n", "self", ".", "pymol_file", ",", "\n", "self", ".", "out_prefix", ",", "\n", "self", ".", "dx_prefixes", ",", "\n", "self", ".", "sdf_files", ",", "\n", ")", "\n", "self", ".", "print", "(", "'Freeing memory'", ")", "\n", "del", "self", ".", "grids", "[", "example_info", "]", "[", "sample_idx", "]", "# free memory", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_metrics": [[970, 1202], ["generating.OutputWriter.print", "range", "generating.OutputWriter.compute_metrics.get_mean_type_counts"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "", "def", "compute_metrics", "(", "self", ",", "example_info", ",", "sample_idx", "=", "None", ")", ":", "\n", "        ", "'''\n        Compute metrics for density grids, typed atomic structures,\n        and molecules for a given ligand in metrics data frame.\n        '''", "\n", "has_rec", "=", "(", "'rec'", "in", "self", ".", "grid_types", ")", "\n", "has_cond_rec", "=", "(", "'cond_rec'", "in", "self", ".", "grid_types", ")", "\n", "has_lig_gen", "=", "(", "'lig_gen'", "in", "self", ".", "grid_types", ")", "\n", "has_lig_fit", "=", "(", "'lig_fit'", "in", "self", ".", "grid_types", ")", "\n", "has_lig_gen_fit", "=", "(", "'lig_gen_fit'", "in", "self", ".", "grid_types", ")", "\n", "\n", "if", "sample_idx", "is", "None", ":", "\n", "            ", "sample_idxs", "=", "range", "(", "self", ".", "n_samples", ")", "\n", "", "else", ":", "\n", "            ", "sample_idxs", "=", "[", "sample_idx", "]", "\n", "\n", "# TODO don't compute metrics twice w/ diff_cond_transform", "\n", "#   the only thing we really need is the lig l2 loss", "\n", "\n", "", "lig_grids", "=", "self", ".", "grids", "[", "example_info", "]", "\n", "\n", "if", "self", ".", "batch_metrics", ":", "# compute mean grids and type counts", "\n", "\n", "            ", "def", "get_mean_type_counts", "(", "struct_batch", ")", ":", "\n", "                ", "n", "=", "len", "(", "struct_batch", ")", "\n", "type_counts", "=", "sum", "(", "[", "s", ".", "type_counts", "for", "s", "in", "struct_batch", "]", ")", "/", "n", "\n", "elem_counts", "=", "sum", "(", "[", "s", ".", "elem_counts", "for", "s", "in", "struct_batch", "]", ")", "/", "n", "\n", "prop_counts", "=", "sum", "(", "[", "s", ".", "prop_counts", "for", "s", "in", "struct_batch", "]", ")", "/", "n", "\n", "return", "type_counts", ",", "elem_counts", ",", "prop_counts", "\n", "\n", "", "lig_grid_batch", "=", "[", "lig_grids", "[", "i", "]", "[", "'lig'", "]", ".", "values", "for", "i", "in", "sample_idxs", "]", "\n", "lig_grid_mean", "=", "sum", "(", "lig_grid_batch", ")", "/", "self", ".", "n_samples", "\n", "\n", "lig_struct_batch", "=", "[", "lig_grids", "[", "i", "]", "[", "'lig'", "]", ".", "info", "[", "'src_struct'", "]", "for", "i", "in", "sample_idxs", "]", "\n", "lig_mean_counts", "=", "get_mean_type_counts", "(", "lig_struct_batch", ")", "\n", "\n", "if", "has_cond_rec", ":", "\n", "                ", "cond_lig_grid_batch", "=", "[", "lig_grids", "[", "i", "]", "[", "'cond_lig'", "]", ".", "values", "for", "i", "in", "sample_idxs", "]", "\n", "cond_lig_grid_mean", "=", "sum", "(", "cond_lig_grid_batch", ")", "/", "self", ".", "n_samples", "\n", "\n", "cond_lig_struct_batch", "=", "[", "\n", "lig_grids", "[", "i", "]", "[", "'cond_lig'", "]", ".", "info", "[", "'src_struct'", "]", "for", "i", "in", "sample_idxs", "\n", "]", "\n", "cond_lig_mean_counts", "=", "get_mean_type_counts", "(", "cond_lig_struct_batch", ")", "\n", "\n", "", "if", "has_lig_fit", ":", "\n", "                ", "lig_fit_struct_batch", "=", "[", "lig_grids", "[", "i", "]", "[", "'lig_fit'", "]", ".", "info", "[", "'src_struct'", "]", "for", "i", "in", "sample_idxs", "]", "\n", "lig_fit_mean_counts", "=", "get_mean_type_counts", "(", "lig_fit_struct_batch", ")", "\n", "\n", "", "if", "has_lig_gen", ":", "\n", "                ", "lig_gen_grid_mean", "=", "sum", "(", "lig_grids", "[", "i", "]", "[", "'lig_gen'", "]", ".", "values", "for", "i", "in", "sample_idxs", ")", "/", "self", ".", "n_samples", "\n", "lig_latent_mean", "=", "sum", "(", "lig_grids", "[", "i", "]", "[", "'lig_gen'", "]", ".", "info", "[", "'src_latent'", "]", "for", "i", "in", "sample_idxs", ")", "/", "self", ".", "n_samples", "\n", "\n", "if", "has_lig_gen_fit", ":", "\n", "                    ", "lig_gen_fit_struct_batch", "=", "[", "lig_grids", "[", "i", "]", "[", "'lig_gen_fit'", "]", ".", "info", "[", "'src_struct'", "]", "for", "i", "in", "sample_idxs", "]", "\n", "lig_gen_fit_mean_counts", "=", "get_mean_type_counts", "(", "lig_gen_fit_struct_batch", ")", "\n", "", "", "", "else", ":", "\n", "            ", "lig_grid_mean", "=", "None", "\n", "cond_lig_grid_mean", "=", "None", "\n", "lig_mean_counts", "=", "None", "\n", "cond_lig_mean_counts", "=", "None", "\n", "lig_fit_mean_counts", "=", "None", "\n", "lig_gen_grid_mean", "=", "None", "\n", "lig_latent_mean", "=", "None", "\n", "lig_gen_fit_mean_counts", "=", "None", "\n", "\n", "", "for", "sample_idx", "in", "sample_idxs", ":", "\n", "            ", "idx", "=", "example_info", "+", "(", "sample_idx", ",", ")", "\n", "\n", "rec_grid", "=", "lig_grids", "[", "sample_idx", "]", "[", "'rec'", "]", "if", "has_rec", "else", "None", "\n", "lig_grid", "=", "lig_grids", "[", "sample_idx", "]", "[", "'lig'", "]", "\n", "self", ".", "compute_grid_metrics", "(", "idx", ",", "\n", "grid_type", "=", "'lig'", ",", "\n", "grid", "=", "lig_grid", ",", "\n", "mean_grid", "=", "lig_grid_mean", ",", "\n", "cond_grid", "=", "rec_grid", ",", "\n", ")", "\n", "\n", "lig_struct", "=", "lig_grid", ".", "info", "[", "'src_struct'", "]", "\n", "self", ".", "compute_struct_metrics", "(", "idx", ",", "\n", "struct_type", "=", "'lig'", ",", "\n", "struct", "=", "lig_struct", ",", "\n", "mean_counts", "=", "lig_mean_counts", ",", "\n", ")", "\n", "\n", "lig_mol", "=", "lig_struct", ".", "info", "[", "'src_mol'", "]", "\n", "self", ".", "compute_mol_metrics", "(", "idx", ",", "\n", "mol_type", "=", "'lig'", ",", "mol", "=", "lig_mol", "\n", ")", "\n", "\n", "if", "'add_mol'", "in", "lig_struct", ".", "info", ":", "\n", "\n", "                ", "lig_add_mol", "=", "lig_struct", ".", "info", "[", "'add_mol'", "]", "\n", "self", ".", "compute_mol_metrics", "(", "idx", ",", "\n", "mol_type", "=", "'lig_add'", ",", "mol", "=", "lig_add_mol", ",", "ref_mol", "=", "lig_mol", "\n", ")", "\n", "\n", "", "if", "has_cond_rec", ":", "\n", "                ", "cond_rec_grid", "=", "lig_grids", "[", "sample_idx", "]", "[", "'cond_rec'", "]", "\n", "cond_lig_grid", "=", "lig_grids", "[", "sample_idx", "]", "[", "'cond_lig'", "]", "\n", "self", ".", "compute_grid_metrics", "(", "idx", ",", "\n", "grid_type", "=", "'cond_lig'", ",", "\n", "grid", "=", "cond_lig_grid", ",", "\n", "mean_grid", "=", "cond_lig_grid_mean", ",", "\n", "cond_grid", "=", "cond_rec_grid", ",", "\n", ")", "\n", "\n", "cond_lig_struct", "=", "cond_lig_grid", ".", "info", "[", "'src_struct'", "]", "\n", "self", ".", "compute_struct_metrics", "(", "idx", ",", "\n", "struct_type", "=", "'cond_lig'", ",", "\n", "struct", "=", "cond_lig_struct", ",", "\n", "mean_counts", "=", "cond_lig_mean_counts", ",", "\n", ")", "\n", "\n", "cond_lig_mol", "=", "cond_lig_struct", ".", "info", "[", "'src_mol'", "]", "\n", "self", ".", "compute_mol_metrics", "(", "idx", ",", "\n", "mol_type", "=", "'lig'", ",", "mol", "=", "cond_lig_mol", "\n", ")", "\n", "\n", "", "if", "has_lig_gen", ":", "\n", "\n", "                ", "lig_gen_grid", "=", "lig_grids", "[", "sample_idx", "]", "[", "'lig_gen'", "]", "\n", "self", ".", "compute_grid_metrics", "(", "idx", ",", "\n", "grid_type", "=", "'lig_gen'", ",", "\n", "grid", "=", "lig_gen_grid", ",", "\n", "ref_grid", "=", "lig_grid", ",", "\n", "mean_grid", "=", "lig_gen_grid_mean", ",", "\n", "cond_grid", "=", "rec_grid", "\n", ")", "\n", "\n", "lig_latent", "=", "lig_gen_grid", ".", "info", "[", "'src_latent'", "]", "\n", "self", ".", "compute_latent_metrics", "(", "idx", ",", "\n", "latent_type", "=", "'lig'", ",", "\n", "latent", "=", "lig_latent", ",", "\n", "mean_latent", "=", "lig_latent_mean", "\n", ")", "\n", "\n", "if", "has_cond_rec", ":", "\n", "\n", "                    ", "self", ".", "compute_grid_metrics", "(", "idx", ",", "\n", "grid_type", "=", "'lig_gen_cond'", ",", "\n", "grid", "=", "lig_gen_grid", ",", "\n", "ref_grid", "=", "cond_lig_grid", ",", "\n", "cond_grid", "=", "cond_rec_grid", ",", "\n", "ref_only", "=", "True", "\n", ")", "\n", "\n", "", "", "if", "has_lig_fit", ":", "\n", "\n", "                ", "lig_fit_grid", "=", "lig_grids", "[", "sample_idx", "]", "[", "'lig_fit'", "]", "\n", "self", ".", "compute_grid_metrics", "(", "idx", ",", "\n", "grid_type", "=", "'lig_fit'", ",", "\n", "grid", "=", "lig_fit_grid", ",", "\n", "ref_grid", "=", "lig_grid", ",", "\n", "cond_grid", "=", "rec_grid", ",", "\n", ")", "\n", "\n", "lig_fit_struct", "=", "lig_fit_grid", ".", "info", "[", "'src_struct'", "]", "\n", "self", ".", "compute_struct_metrics", "(", "idx", ",", "\n", "struct_type", "=", "'lig_fit'", ",", "\n", "struct", "=", "lig_fit_struct", ",", "\n", "ref_struct", "=", "lig_struct", ",", "\n", "mean_counts", "=", "lig_fit_mean_counts", ",", "\n", ")", "\n", "\n", "lig_fit_add_mol", "=", "lig_fit_struct", ".", "info", "[", "'add_mol'", "]", "\n", "self", ".", "compute_mol_metrics", "(", "idx", ",", "\n", "mol_type", "=", "'lig_fit_add'", ",", "\n", "mol", "=", "lig_fit_add_mol", ",", "\n", "ref_mol", "=", "lig_mol", ",", "\n", ")", "\n", "\n", "lig_fit_add_struct", "=", "lig_fit_add_mol", ".", "info", "[", "'type_struct'", "]", "\n", "self", ".", "compute_struct_metrics", "(", "idx", ",", "\n", "struct_type", "=", "'lig_fit_add'", ",", "\n", "struct", "=", "lig_fit_add_struct", ",", "\n", "ref_struct", "=", "lig_fit_struct", ",", "\n", ")", "\n", "\n", "", "if", "has_lig_gen_fit", ":", "\n", "\n", "                ", "lig_gen_fit_grid", "=", "lig_grids", "[", "sample_idx", "]", "[", "'lig_gen_fit'", "]", "\n", "self", ".", "compute_grid_metrics", "(", "idx", ",", "\n", "grid_type", "=", "'lig_gen_fit'", ",", "\n", "grid", "=", "lig_gen_fit_grid", ",", "\n", "ref_grid", "=", "lig_gen_grid", ",", "\n", "cond_grid", "=", "rec_grid", ",", "\n", ")", "\n", "\n", "lig_gen_fit_struct", "=", "lig_gen_fit_grid", ".", "info", "[", "'src_struct'", "]", "\n", "self", ".", "compute_struct_metrics", "(", "idx", ",", "\n", "struct_type", "=", "'lig_gen_fit'", ",", "\n", "struct", "=", "lig_gen_fit_struct", ",", "\n", "ref_struct", "=", "lig_struct", ",", "\n", "mean_counts", "=", "lig_gen_fit_mean_counts", ",", "\n", ")", "\n", "\n", "lig_gen_fit_add_mol", "=", "lig_gen_fit_struct", ".", "info", "[", "'add_mol'", "]", "\n", "self", ".", "compute_mol_metrics", "(", "idx", ",", "\n", "mol_type", "=", "'lig_gen_fit_add'", ",", "\n", "mol", "=", "lig_gen_fit_add_mol", ",", "\n", "ref_mol", "=", "lig_mol", ",", "\n", ")", "\n", "\n", "lig_gen_fit_add_struct", "=", "lig_gen_fit_add_mol", ".", "info", "[", "'type_struct'", "]", "\n", "self", ".", "compute_struct_metrics", "(", "idx", ",", "\n", "struct_type", "=", "'lig_gen_fit_add'", ",", "\n", "struct", "=", "lig_gen_fit_add_struct", ",", "\n", "ref_struct", "=", "lig_gen_fit_struct", ",", "\n", ")", "\n", "\n", "if", "has_cond_rec", ":", "\n", "\n", "                    ", "self", ".", "compute_struct_metrics", "(", "idx", ",", "\n", "struct_type", "=", "'lig_gen_fit_cond'", ",", "\n", "struct", "=", "lig_gen_fit_struct", ",", "\n", "ref_struct", "=", "cond_lig_struct", ",", "\n", "ref_only", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "compute_mol_metrics", "(", "idx", ",", "\n", "mol_type", "=", "'lig_gen_fit_add_cond'", ",", "\n", "mol", "=", "lig_gen_fit_add_mol", ",", "\n", "ref_mol", "=", "cond_lig_mol", ",", "\n", "ref_only", "=", "True", ",", "\n", "use_cond_min", "=", "True", "\n", ")", "\n", "\n", "", "", "", "self", ".", "print", "(", "self", ".", "metrics", ".", "loc", "[", "example_info", "]", ".", "loc", "[", "sample_idxs", "]", ".", "transpose", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_grid_metrics": [[1203, 1263], ["grid.values.norm().item", "grid.elem_values.norm().item", "grid.prop_values.norm().item", "grid.values.norm", "grid.elem_values.norm", "grid.prop_values.norm", "cond_grid.values.sum", "grid.values.sum().clamp", "cond_grid.elem_values.sum", "grid.elem_values.sum().clamp", "cond_grid.prop_values.sum", "grid.prop_values.sum().clamp", "grid.values.sum", "grid.elem_values.sum", "grid.prop_values.sum"], "methods", ["None"], ["", "def", "compute_grid_metrics", "(", "\n", "self", ",", "\n", "idx", ",", "\n", "grid_type", ",", "\n", "grid", ",", "\n", "ref_grid", "=", "None", ",", "\n", "mean_grid", "=", "None", ",", "\n", "cond_grid", "=", "None", ",", "\n", "ref_only", "=", "False", ",", "\n", ")", ":", "\n", "        ", "m", "=", "self", ".", "metrics", "\n", "\n", "if", "not", "ref_only", ":", "\n", "\n", "# density magnitude", "\n", "            ", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_grid_norm'", "]", "=", "grid", ".", "values", ".", "norm", "(", ")", ".", "item", "(", ")", "\n", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_grid_elem_norm'", "]", "=", "grid", ".", "elem_values", ".", "norm", "(", ")", ".", "item", "(", ")", "\n", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_grid_prop_norm'", "]", "=", "grid", ".", "prop_values", ".", "norm", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "mean_grid", "is", "not", "None", ":", "\n", "\n", "# density variance", "\n", "# (divide by n_samples (+1) for sample (population) variance)", "\n", "                ", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_grid_variance'", "]", "=", "(", "\n", "(", "grid", ".", "values", "-", "mean_grid", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "if", "ref_grid", "is", "not", "None", ":", "\n", "\n", "# density L2 loss", "\n", "            ", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_L2_loss'", "]", "=", "(", "\n", "(", "ref_grid", ".", "values", "-", "grid", ".", "values", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "2", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_elem_L2_loss'", "]", "=", "(", "\n", "(", "ref_grid", ".", "elem_values", "-", "grid", ".", "elem_values", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "2", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_prop_L2_loss'", "]", "=", "(", "\n", "(", "ref_grid", ".", "prop_values", "-", "grid", ".", "prop_values", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "2", "\n", "\n", "", "if", "cond_grid", "is", "not", "None", ":", "\n", "\n", "# density product", "\n", "            ", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_rec_prod'", "]", "=", "(", "\n", "cond_grid", ".", "values", ".", "sum", "(", "dim", "=", "0", ")", "*", "\n", "grid", ".", "values", ".", "sum", "(", "dim", "=", "0", ")", ".", "clamp", "(", "0", ")", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_rec_elem_prod'", "]", "=", "(", "\n", "cond_grid", ".", "elem_values", ".", "sum", "(", "dim", "=", "0", ")", "*", "\n", "grid", ".", "elem_values", ".", "sum", "(", "dim", "=", "0", ")", ".", "clamp", "(", "0", ")", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "grid_type", "+", "'_rec_prop_prod'", "]", "=", "(", "\n", "cond_grid", ".", "prop_values", ".", "sum", "(", "dim", "=", "0", ")", "*", "\n", "grid", ".", "prop_values", ".", "sum", "(", "dim", "=", "0", ")", ".", "clamp", "(", "0", ")", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_latent_metrics": [[1266, 1284], ["latent.norm().item", "latent.norm"], "methods", ["None"], ["", "", "def", "compute_latent_metrics", "(", "\n", "self", ",", "idx", ",", "latent_type", ",", "latent", ",", "mean_latent", "=", "None", "\n", ")", ":", "\n", "        ", "m", "=", "self", ".", "metrics", "\n", "\n", "# latent vector magnitude", "\n", "m", ".", "loc", "[", "idx", ",", "latent_type", "+", "'_latent_norm'", "]", "=", "latent", ".", "norm", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "mean_latent", "is", "not", "None", ":", "\n", "\n", "# latent vector variance", "\n", "            ", "variance", "=", "(", "\n", "(", "latent", "-", "mean_latent", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "            ", "variance", "=", "np", ".", "nan", "\n", "\n", "", "m", ".", "loc", "[", "idx", ",", "latent_type", "+", "'_latent_variance'", "]", "=", "variance", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_struct_metrics": [[1285, 1363], ["liGAN.metrics.compute_struct_rmsd", "struct_type.endswith", "len", "struct.info.get"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_struct_rmsd", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "def", "compute_struct_metrics", "(", "\n", "self", ",", "\n", "idx", ",", "\n", "struct_type", ",", "\n", "struct", ",", "\n", "ref_struct", "=", "None", ",", "\n", "mean_counts", "=", "None", ",", "\n", "ref_only", "=", "False", ",", "\n", ")", ":", "\n", "        ", "m", "=", "self", ".", "metrics", "\n", "\n", "if", "not", "ref_only", ":", "\n", "\n", "            ", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_n_atoms'", "]", "=", "struct", ".", "n_atoms", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_radius'", "]", "=", "(", "\n", "struct", ".", "radius", "if", "struct", ".", "n_atoms", ">", "0", "else", "np", ".", "nan", "\n", ")", "\n", "\n", "if", "mean_counts", "is", "not", "None", ":", "\n", "\n", "                ", "mean_type_counts", ",", "mean_elem_counts", ",", "mean_prop_counts", "=", "mean_counts", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_type_variance'", "]", "=", "(", "\n", "(", "struct", ".", "type_counts", "-", "mean_type_counts", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_elem_variance'", "]", "=", "(", "\n", "(", "struct", ".", "elem_counts", "-", "mean_elem_counts", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_prop_variance'", "]", "=", "(", "\n", "(", "struct", ".", "prop_counts", "-", "mean_prop_counts", ")", "**", "2", "\n", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "", "if", "ref_struct", "is", "not", "None", ":", "\n", "\n", "# difference in num atoms", "\n", "            ", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_n_atoms_diff'", "]", "=", "(", "\n", "ref_struct", ".", "n_atoms", "-", "struct", ".", "n_atoms", "\n", ")", "\n", "\n", "# overall type count difference", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_type_diff'", "]", "=", "(", "\n", "ref_struct", ".", "type_counts", "-", "struct", ".", "type_counts", "\n", ")", ".", "norm", "(", "p", "=", "1", ")", ".", "item", "(", ")", "\n", "\n", "# element type count difference", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_elem_diff'", "]", "=", "(", "\n", "ref_struct", ".", "elem_counts", "-", "struct", ".", "elem_counts", "\n", ")", ".", "norm", "(", "p", "=", "1", ")", ".", "item", "(", ")", "\n", "\n", "# property type count difference", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_prop_diff'", "]", "=", "(", "\n", "ref_struct", ".", "prop_counts", "-", "struct", ".", "prop_counts", "\n", ")", ".", "norm", "(", "p", "=", "1", ")", ".", "item", "(", ")", "\n", "\n", "# minimum atom-only RMSD (ignores properties)", "\n", "rmsd", "=", "liGAN", ".", "metrics", ".", "compute_struct_rmsd", "(", "ref_struct", ",", "struct", ")", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_RMSD'", "]", "=", "rmsd", "\n", "\n", "", "if", "not", "ref_only", ":", "\n", "            ", "if", "struct_type", ".", "endswith", "(", "'_fit'", ")", ":", "\n", "\n", "# fit time and number of visited structures", "\n", "                ", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_time'", "]", "=", "struct", ".", "info", "[", "'time'", "]", "\n", "m", ".", "loc", "[", "idx", ",", "struct_type", "+", "'_n_visited'", "]", "=", "len", "(", "\n", "struct", ".", "info", "[", "'visited_structs'", "]", "\n", ")", "\n", "\n", "# accuracy of estimated type counts, whether or not", "\n", "# they were actually used to constrain atom fitting", "\n", "est_type", "=", "struct_type", "[", ":", "-", "4", "]", "+", "'_est'", "\n", "m", ".", "loc", "[", "idx", ",", "est_type", "+", "'_type_diff'", "]", "=", "struct", ".", "info", ".", "get", "(", "\n", "'est_type_diff'", ",", "np", ".", "nan", "\n", ")", "\n", "m", ".", "loc", "[", "idx", ",", "est_type", "+", "'_exact_types'", "]", "=", "(", "\n", "m", ".", "loc", "[", "idx", ",", "est_type", "+", "'_type_diff'", "]", "==", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.compute_mol_metrics": [[1365, 1493], ["mol.validate", "mol.to_smi", "gni_mol.info.get", "gni_mol.info.get", "gni_mol.info.get", "gni_mol.info.get", "liGAN.molecules.get_rd_mol_weight", "liGAN.molecules.get_rd_mol_logP", "liGAN.molecules.get_rd_mol_QED", "ref_mol.validate", "ref_mol.to_smi", "liGAN.molecules.get_rd_mol_SAS", "liGAN.molecules.get_rd_mol_NPS", "liGAN.molecules.get_ob_smi_similarity", "liGAN.molecules.get_rd_mol_similarity", "liGAN.molecules.get_rd_mol_similarity", "liGAN.molecules.get_rd_mol_similarity", "generating.OutputWriter.print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.validate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_smi", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.validate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_smi", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_NPS", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_ob_smi_similarity", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_similarity", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_similarity", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_similarity", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "", "def", "compute_mol_metrics", "(", "\n", "self", ",", "\n", "idx", ",", "\n", "mol_type", ",", "\n", "mol", ",", "\n", "ref_mol", "=", "None", ",", "\n", "ref_only", "=", "False", ",", "\n", "use_cond_min", "=", "False", ",", "\n", ")", ":", "\n", "        ", "m", "=", "self", ".", "metrics", "\n", "\n", "# check molecular validity", "\n", "valid", ",", "reason", "=", "mol", ".", "validate", "(", ")", "\n", "\n", "if", "not", "ref_only", ":", "\n", "            ", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_n_atoms'", "]", "=", "mol", ".", "n_atoms", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_n_frags'", "]", "=", "mol", ".", "n_frags", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_valid'", "]", "=", "valid", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_reason'", "]", "=", "reason", "\n", "\n", "# other molecular descriptors", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_MW'", "]", "=", "mols", ".", "get_rd_mol_weight", "(", "mol", ")", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_logP'", "]", "=", "mols", ".", "get_rd_mol_logP", "(", "mol", ")", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_QED'", "]", "=", "mols", ".", "get_rd_mol_QED", "(", "mol", ")", "\n", "if", "valid", ":", "\n", "                ", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_SAS'", "]", "=", "mols", ".", "get_rd_mol_SAS", "(", "mol", ")", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_NPS'", "]", "=", "mols", ".", "get_rd_mol_NPS", "(", "mol", ")", "\n", "", "else", ":", "\n", "                ", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_SAS'", "]", "=", "np", ".", "nan", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_NPS'", "]", "=", "np", ".", "nan", "\n", "\n", "# convert to SMILES string", "\n", "", "", "smi", "=", "mol", ".", "to_smi", "(", ")", "\n", "if", "not", "ref_only", ":", "\n", "            ", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_SMILES'", "]", "=", "smi", "\n", "\n", "", "if", "ref_mol", ":", "# compare to ref_mol", "\n", "\n", "# difference in num atoms", "\n", "            ", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_n_atoms_diff'", "]", "=", "(", "\n", "ref_mol", ".", "n_atoms", "-", "mol", ".", "n_atoms", "\n", ")", "\n", "\n", "ref_valid", ",", "ref_reason", "=", "ref_mol", ".", "validate", "(", ")", "\n", "\n", "# get reference SMILES strings", "\n", "ref_smi", "=", "ref_mol", ".", "to_smi", "(", ")", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_SMILES_match'", "]", "=", "(", "smi", "==", "ref_smi", ")", "\n", "\n", "if", "valid", "and", "ref_valid", ":", "# fingerprint similarity", "\n", "\n", "                ", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_ob_sim'", "]", "=", "mols", ".", "get_ob_smi_similarity", "(", "ref_smi", ",", "smi", ")", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_rdkit_sim'", "]", "=", "mols", ".", "get_rd_mol_similarity", "(", "ref_mol", ",", "mol", ",", "'rdkit'", ")", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_morgan_sim'", "]", "=", "mols", ".", "get_rd_mol_similarity", "(", "ref_mol", ",", "mol", ",", "'morgan'", ")", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_maccs_sim'", "]", "=", "mols", ".", "get_rd_mol_similarity", "(", "ref_mol", ",", "mol", ",", "'maccs'", ")", "\n", "", "else", ":", "\n", "                ", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_ob_sim'", "]", "=", "np", ".", "nan", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_rdkit_sim'", "]", "=", "np", ".", "nan", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_morgan_sim'", "]", "=", "np", ".", "nan", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_maccs_sim'", "]", "=", "np", ".", "nan", "\n", "\n", "", "", "if", "'uff_mol'", "not", "in", "mol", ".", "info", ":", "\n", "            ", "return", "\n", "\n", "# UFF energy minimization", "\n", "", "if", "use_cond_min", "and", "'cond_uff_mol'", "in", "mol", ".", "info", ":", "# handle diff_cond_transform with no diff_cond_structs", "\n", "            ", "uff_mol", "=", "mol", ".", "info", "[", "'cond_uff_mol'", "]", "\n", "", "else", ":", "\n", "            ", "uff_mol", "=", "mol", ".", "info", "[", "'uff_mol'", "]", "\n", "", "uff_init", "=", "uff_mol", ".", "info", "[", "'E_init'", "]", "\n", "uff_min", "=", "uff_mol", ".", "info", "[", "'E_min'", "]", "\n", "uff_rmsd", "=", "uff_mol", ".", "info", "[", "'min_rmsd'", "]", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_UFF_init'", "]", "=", "uff_init", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_UFF_min'", "]", "=", "uff_min", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_UFF_rmsd'", "]", "=", "uff_rmsd", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_UFF_error'", "]", "=", "uff_mol", ".", "info", "[", "'min_error'", "]", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_UFF_time'", "]", "=", "uff_mol", ".", "info", "[", "'min_time'", "]", "\n", "\n", "# compare energy to ref mol, before and after minimizing", "\n", "if", "ref_mol", ":", "\n", "            ", "ref_uff_mol", "=", "ref_mol", ".", "info", "[", "'uff_mol'", "]", "\n", "ref_uff_init", "=", "ref_uff_mol", ".", "info", "[", "'E_init'", "]", "\n", "ref_uff_min", "=", "ref_uff_mol", ".", "info", "[", "'E_min'", "]", "\n", "ref_uff_rmsd", "=", "ref_uff_mol", ".", "info", "[", "'min_rmsd'", "]", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_UFF_init_diff'", "]", "=", "uff_init", "-", "ref_uff_init", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_UFF_min_diff'", "]", "=", "uff_min", "-", "ref_uff_min", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_UFF_rmsd_diff'", "]", "=", "uff_rmsd", "-", "ref_uff_rmsd", "\n", "\n", "", "if", "'gni_mol'", "not", "in", "mol", ".", "info", ":", "\n", "            ", "return", "\n", "\n", "# gnina energy minimization", "\n", "", "if", "use_cond_min", "and", "'cond_gni_mol'", "in", "mol", ".", "info", ":", "\n", "            ", "gni_mol", "=", "mol", ".", "info", "[", "'cond_gni_mol'", "]", "\n", "", "else", ":", "\n", "            ", "gni_mol", "=", "mol", ".", "info", "[", "'gni_mol'", "]", "\n", "", "vina_aff", "=", "gni_mol", ".", "info", ".", "get", "(", "'minimizedAffinity'", ",", "np", ".", "nan", ")", "\n", "vina_rmsd", "=", "gni_mol", ".", "info", ".", "get", "(", "'minimizedRMSD'", ",", "np", ".", "nan", ")", "\n", "cnn_pose", "=", "gni_mol", ".", "info", ".", "get", "(", "'CNNscore'", ",", "np", ".", "nan", ")", "\n", "cnn_aff", "=", "gni_mol", ".", "info", ".", "get", "(", "'CNNaffinity'", ",", "np", ".", "nan", ")", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_vina_aff'", "]", "=", "vina_aff", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_vina_rmsd'", "]", "=", "vina_rmsd", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_cnn_pose'", "]", "=", "cnn_pose", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_cnn_aff'", "]", "=", "cnn_aff", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_gnina_error'", "]", "=", "gni_mol", ".", "info", "[", "'error'", "]", "\n", "\n", "# compare gnina metrics to ref mol", "\n", "if", "ref_mol", ":", "\n", "            ", "ref_gni_mol", "=", "ref_mol", ".", "info", "[", "'gni_mol'", "]", "\n", "try", ":", "\n", "                ", "ref_vina_aff", "=", "ref_gni_mol", ".", "info", "[", "'minimizedAffinity'", "]", "\n", "", "except", "KeyError", ":", "\n", "                ", "print", "(", "ref_gni_mol", ".", "info", ")", "\n", "raise", "\n", "", "ref_vina_rmsd", "=", "ref_gni_mol", ".", "info", "[", "'minimizedRMSD'", "]", "\n", "ref_cnn_pose", "=", "ref_gni_mol", ".", "info", "[", "'CNNscore'", "]", "\n", "ref_cnn_aff", "=", "ref_gni_mol", ".", "info", "[", "'CNNaffinity'", "]", "\n", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_vina_aff_diff'", "]", "=", "vina_aff", "-", "ref_vina_aff", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_vina_rmsd_diff'", "]", "=", "vina_rmsd", "-", "ref_vina_rmsd", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_cnn_pose_diff'", "]", "=", "cnn_pose", "-", "ref_cnn_pose", "\n", "m", ".", "loc", "[", "idx", ",", "mol_type", "+", "'_cnn_aff_diff'", "]", "=", "cnn_aff", "-", "ref_cnn_aff", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.read_rec_from_pdb_file": [[1495, 1503], ["liGAN.molecules.Molecule.from_pdb", "rdkit.Chem.SanitizeMol"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_pdb"], ["", "", "", "def", "read_rec_from_pdb_file", "(", "pdb_file", ")", ":", "\n", "\n", "    ", "rec_mol", "=", "mols", ".", "Molecule", ".", "from_pdb", "(", "pdb_file", ",", "sanitize", "=", "False", ")", "\n", "try", ":", "\n", "        ", "Chem", ".", "SanitizeMol", "(", "rec_mol", ")", "\n", "", "except", "Chem", ".", "MolSanitizeException", ":", "\n", "        ", "pass", "\n", "", "return", "rec_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.read_lig_from_sdf_file": [[1505, 1527], ["lig_mol.add_hs.AddHydrogens", "liGAN.molecules.Molecule.from_ob_mol", "liGAN.molecules.Molecule.from_sdf", "lig_mol.add_hs.sanitize", "lig_mol.add_hs.add_hs", "liGAN.molecules.read_ob_mols_from_file"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_sdf", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.sanitize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.add_hs", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["", "def", "read_lig_from_sdf_file", "(", "sdf_file", ",", "use_ob", "=", "True", ")", ":", "\n", "    ", "'''\n    Try to find the real molecule in data_root using the\n    source path in the data file, without file extension.\n    '''", "\n", "if", "use_ob", ":", "# read and add Hs with OpenBabel, then convert to RDkit", "\n", "        ", "lig_mol", "=", "mols", ".", "read_ob_mols_from_file", "(", "sdf_file", ",", "'sdf'", ")", "[", "0", "]", "\n", "lig_mol", ".", "AddHydrogens", "(", ")", "\n", "lig_mol", "=", "mols", ".", "Molecule", ".", "from_ob_mol", "(", "lig_mol", ")", "\n", "\n", "", "else", ":", "# read and add Hs with RDKit (need to sanitize before add Hs)", "\n", "        ", "lig_mol", "=", "mols", ".", "Molecule", ".", "from_sdf", "(", "sdf_file", ",", "sanitize", "=", "False", ",", "idx", "=", "0", ")", "\n", "\n", "", "try", ":", "# need to do this to get ring info, etc.", "\n", "        ", "lig_mol", ".", "sanitize", "(", ")", "\n", "", "except", "Chem", ".", "MolSanitizeException", ":", "\n", "        ", "pass", "\n", "\n", "", "if", "not", "use_ob", ":", "# add Hs with rdkit (after sanitize)", "\n", "        ", "lig_mol", "=", "lig_mol", ".", "add_hs", "(", ")", "\n", "\n", "", "return", "lig_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.write_atom_types_to_file": [[1529, 1532], ["open", "f.write", "str"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write"], ["", "def", "write_atom_types_to_file", "(", "types_file", ",", "atom_types", ")", ":", "\n", "    ", "with", "open", "(", "types_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "'\\n'", ".", "join", "(", "str", "(", "a", ")", "for", "a", "in", "atom_types", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.write_latent_vec_to_file": [[1534, 1539], ["open", "f.write", "str", "value.item"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write"], ["", "", "def", "write_latent_vec_to_file", "(", "latent_file", ",", "latent_vec", ")", ":", "\n", "\n", "    ", "with", "open", "(", "latent_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "for", "value", "in", "latent_vec", ":", "\n", "            ", "f", ".", "write", "(", "str", "(", "value", ".", "item", "(", ")", ")", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.write_pymol_script": [[1541, 1581], ["open", "f.write", "f.write", "f.write", "f.write", "f.write", "re.match", "re.match.group", "re.match", "re.match.group", "str", "print", "str", "print", "re.escape", "re.escape"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "", "def", "write_pymol_script", "(", "\n", "pymol_file", ",", "out_prefix", ",", "dx_prefixes", ",", "sdf_files", "\n", ")", ":", "\n", "    ", "'''\n    Write a pymol script that loads all .dx files with a given\n    prefix into a single group, then loads a set of sdf_files\n    and translates them to the origin, if centers are provided.\n    '''", "\n", "with", "open", "(", "pymol_file", ",", "'w'", ")", "as", "f", ":", "\n", "\n", "        ", "for", "dx_prefix", "in", "dx_prefixes", ":", "# load density grids", "\n", "            ", "try", ":", "\n", "                ", "m", "=", "re", ".", "match", "(", "\n", "'^grids/({}_.*)$'", ".", "format", "(", "re", ".", "escape", "(", "out_prefix", ")", ")", ",", "\n", "str", "(", "dx_prefix", ")", "\n", ")", "\n", "", "except", "AttributeError", ":", "\n", "                ", "print", "(", "dx_prefix", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "raise", "\n", "", "group_name", "=", "m", ".", "group", "(", "1", ")", "+", "'_grids'", "\n", "dx_pattern", "=", "'{}_*.dx'", ".", "format", "(", "dx_prefix", ")", "\n", "f", ".", "write", "(", "'load_group {}, {}\\n'", ".", "format", "(", "dx_pattern", ",", "group_name", ")", ")", "\n", "\n", "", "for", "sdf_file", "in", "sdf_files", ":", "# load structs/molecules", "\n", "            ", "try", ":", "\n", "                ", "m", "=", "re", ".", "match", "(", "\n", "r'^.*(molecules|structs)/({}_.*)\\.sdf(\\.gz)?$'", ".", "format", "(", "\n", "re", ".", "escape", "(", "out_prefix", ")", "\n", ")", ",", "\n", "str", "(", "sdf_file", ")", "\n", ")", "\n", "obj_name", "=", "m", ".", "group", "(", "2", ")", "\n", "", "except", "AttributeError", ":", "\n", "                ", "print", "(", "sdf_file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "raise", "\n", "", "f", ".", "write", "(", "'load {}, {}\\n'", ".", "format", "(", "sdf_file", ",", "obj_name", ")", ")", "\n", "\n", "", "f", ".", "write", "(", "'util.cbam *rec_src\\n'", ")", "\n", "f", ".", "write", "(", "'util.cbag *lig_src\\n'", ")", "\n", "f", ".", "write", "(", "'util.cbac *lig_gen_fit_add\\n'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.__init__": [[25, 40], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "min_bond_len", "=", "0.01", ",", "\n", "max_bond_len", "=", "4.0", ",", "\n", "max_bond_stretch", "=", "0.45", ",", "\n", "min_bond_angle", "=", "45", ",", "\n", "debug", "=", "False", ",", "\n", ")", ":", "\n", "        ", "self", ".", "min_bond_len", "=", "min_bond_len", "\n", "self", ".", "max_bond_len", "=", "max_bond_len", "\n", "\n", "self", ".", "max_bond_stretch", "=", "max_bond_stretch", "\n", "self", ".", "min_bond_angle", "=", "min_bond_angle", "\n", "\n", "self", ".", "debug", "=", "debug", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.disable_perception": [[41, 49], ["ob_mol.SetHybridizationPerceived", "ob_mol.SetAromaticPerceived"], "methods", ["None"], ["", "def", "disable_perception", "(", "self", ",", "ob_mol", ")", ":", "\n", "        ", "'''\n        Set flags that prevent openbabel perception\n        of hybridization and aromaticity from being\n        triggered when the properties are accessed.\n        '''", "\n", "ob_mol", ".", "SetHybridizationPerceived", "(", "True", ")", "\n", "ob_mol", ".", "SetAromaticPerceived", "(", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.set_hybridization": [[50, 72], ["ob_mol.SetHybridizationPerceived", "ob_mol.SetHybridizationPerceived", "ob_atom.GetHyb", "zip", "ob_atom.SetHyb"], "methods", ["None"], ["", "def", "set_hybridization", "(", "self", ",", "ob_mol", ",", "atoms", ",", "struct", ")", ":", "\n", "        ", "'''\n        Set hybridization of atoms in two passes.\n        First, perceive the hybridization state\n        using openbabel, then turn off perception.\n        Next, set all aromatic atoms to sp2.\n        '''", "\n", "# turn on perception", "\n", "ob_mol", ".", "SetHybridizationPerceived", "(", "False", ")", "\n", "\n", "# trigger perception", "\n", "for", "ob_atom", "in", "atoms", ":", "\n", "            ", "ob_atom", ".", "GetHyb", "(", ")", "\n", "\n", "# turn off perception", "\n", "", "ob_mol", ".", "SetHybridizationPerceived", "(", "True", ")", "\n", "\n", "# set all aromatic atoms to sp2", "\n", "if", "Atom", ".", "aromatic", "in", "struct", ".", "typer", ":", "\n", "            ", "for", "ob_atom", ",", "atom_type", "in", "zip", "(", "atoms", ",", "struct", ".", "atom_types", ")", ":", "\n", "                ", "if", "atom_type", ".", "aromatic", ":", "\n", "                    ", "ob_atom", ".", "SetHyb", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.set_aromaticity": [[73, 102], ["ob_mol.SetAromaticPerceived", "openbabel.openbabel.openbabel.OBMolBondIter", "ob_mol.SetAromaticPerceived", "zip", "bond.GetBeginAtom", "bond.GetEndAtom", "bond.IsInRing", "ob_atom.IsAromatic", "ob_atom.SetAromatic", "bond.SetAromatic", "bool", "bond.GetBeginAtom.IsAromatic", "bond.GetEndAtom.IsAromatic"], "methods", ["None"], ["", "", "", "", "def", "set_aromaticity", "(", "self", ",", "ob_mol", ",", "atoms", ",", "struct", ")", ":", "\n", "        ", "'''\n        Use openbabel to perceive aromaticity, or\n        set it based on atom types, if available.\n        Set bonds as aromatic iff they are between\n        aromatic atoms in a ring.\n        '''", "\n", "if", "Atom", ".", "aromatic", "not", "in", "struct", ".", "typer", ":", "\n", "\n", "# turn on perception", "\n", "            ", "ob_mol", ".", "SetAromaticPerceived", "(", "False", ")", "\n", "\n", "# trigger perception", "\n", "for", "ob_atom", "in", "atoms", ":", "\n", "                ", "ob_atom", ".", "IsAromatic", "(", ")", "\n", "\n", "", "", "else", ":", "# set aromaticity based on atom types", "\n", "            ", "for", "ob_atom", ",", "atom_type", "in", "zip", "(", "atoms", ",", "struct", ".", "atom_types", ")", ":", "\n", "                ", "ob_atom", ".", "SetAromatic", "(", "bool", "(", "atom_type", ".", "aromatic", ")", ")", "\n", "\n", "# turn off perception", "\n", "", "", "ob_mol", ".", "SetAromaticPerceived", "(", "True", ")", "\n", "\n", "# set bonds between aromatic ring atoms as aromatic", "\n", "for", "bond", "in", "ob", ".", "OBMolBondIter", "(", "ob_mol", ")", ":", "\n", "            ", "a1", "=", "bond", ".", "GetBeginAtom", "(", ")", "\n", "a2", "=", "bond", ".", "GetEndAtom", "(", ")", "\n", "if", "bond", ".", "IsInRing", "(", ")", ":", "\n", "                ", "bond", ".", "SetAromatic", "(", "a1", ".", "IsAromatic", "(", ")", "and", "a2", ".", "IsAromatic", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.set_formal_charges": [[103, 111], ["zip", "ob_atom.SetFormalCharge"], "methods", ["None"], ["", "", "", "def", "set_formal_charges", "(", "self", ",", "ob_mol", ",", "atoms", ",", "struct", ")", ":", "\n", "        ", "'''\n        Set formal charge on atoms based on their\n        atom type, if it is available.\n        '''", "\n", "if", "Atom", ".", "formal_charge", "in", "struct", ".", "typer", ":", "\n", "            ", "for", "ob_atom", ",", "atom_type", "in", "zip", "(", "atoms", ",", "struct", ".", "atom_types", ")", ":", "\n", "                ", "ob_atom", ".", "SetFormalCharge", "(", "atom_type", ".", "formal_charge", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.set_min_h_counts": [[112, 137], ["zip", "atom_types.Atom.h_count", "ob_atom.SetImplicitHCount"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.h_count"], ["", "", "", "def", "set_min_h_counts", "(", "self", ",", "ob_mol", ",", "atoms", ",", "struct", ")", ":", "\n", "        ", "'''\n        Set atoms to have at least the minimum number\n        of Hs required by their atom type. Does not\n        remove Hs, and any added Hs are implicit.\n        '''", "\n", "for", "ob_atom", ",", "atom_type", "in", "zip", "(", "atoms", ",", "struct", ".", "atom_types", ")", ":", "\n", "\n", "            ", "if", "struct", ".", "typer", ".", "explicit_h", ":", "\n", "# all Hs should already be explicit,", "\n", "#   though possibly not bonded yet", "\n", "                ", "continue", "\n", "\n", "# get current hydrogen count", "\n", "", "h_count", "=", "Atom", ".", "h_count", "(", "ob_atom", ")", "\n", "\n", "# get count required by atom type", "\n", "if", "Atom", ".", "h_count", "in", "struct", ".", "typer", ":", "\n", "                ", "min_h_count", "=", "atom_type", ".", "h_count", "\n", "\n", "", "elif", "Atom", ".", "h_donor", "in", "struct", ".", "typer", ":", "\n", "                ", "min_h_count", "=", "1", "if", "atom_type", ".", "h_donor", "else", "0", "\n", "\n", "", "if", "h_count", "<", "min_h_count", ":", "\n", "                ", "ob_atom", ".", "SetImplicitHCount", "(", "min_h_count", "-", "h_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.add_within_distance": [[138, 158], ["numpy.array", "scipy.spatial.distance.squareform", "enumerate", "scipy.spatial.distance.pdist", "enumerate", "a.GetX", "a.GetY", "a.GetZ", "ob_mol.AddBond", "atom_a.GetIdx", "atom_b.GetIdx"], "methods", ["None"], ["", "", "", "def", "add_within_distance", "(", "self", ",", "ob_mol", ",", "atoms", ",", "struct", ")", ":", "\n", "        ", "'''\n        Add bonds between every pair of atoms\n        that are within a certain distance.\n        '''", "\n", "# just do n^2 comparisons, worry about efficiency later", "\n", "coords", "=", "np", ".", "array", "(", "[", "(", "a", ".", "GetX", "(", ")", ",", "a", ".", "GetY", "(", ")", ",", "a", ".", "GetZ", "(", ")", ")", "for", "a", "in", "atoms", "]", ")", "\n", "dists", "=", "squareform", "(", "pdist", "(", "coords", ")", ")", "\n", "\n", "# for every pairs of atoms in ob_mol,", "\n", "for", "i", ",", "atom_a", "in", "enumerate", "(", "atoms", ")", ":", "\n", "            ", "for", "j", ",", "atom_b", "in", "enumerate", "(", "atoms", ")", ":", "\n", "                ", "if", "i", ">=", "j", ":", "# avoid redundant checks", "\n", "                    ", "continue", "\n", "\n", "# if they are within min and max bond length,", "\n", "", "if", "self", ".", "min_bond_len", "<", "dists", "[", "i", ",", "j", "]", "<", "self", ".", "max_bond_len", ":", "\n", "\n", "# add a single bond between the atoms", "\n", "                    ", "ob_mol", ".", "AddBond", "(", "atom_a", ".", "GetIdx", "(", ")", ",", "atom_b", ".", "GetIdx", "(", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.remove_bad_valences": [[159, 218], ["bond_adding.get_max_valences", "openbabel.openbabel.openbabel.OBMolBondIter", "bond_adding.sort_atoms_by_valence", "ob_mol.SetHybridizationPerceived", "bond.GetBeginAtom", "bond.GetEndAtom", "bond_adding.sort_bonds_by_stretch", "ob_mol.DeleteBond", "atom.GetExplicitValence", "openbabel.openbabel.openbabel.OBAtomBondIter", "max", "get_max_valences.get", "get_max_valences.get", "bond.GetBeginAtom", "bond.GetEndAtom", "bond.GetBondOrder", "bond.GetBeginAtom.GetIdx", "bond.GetEndAtom.GetIdx", "a1.GetExplicitValence", "get_max_valences.get", "a2.GetExplicitValence", "get_max_valences.get", "bond.SetBondOrder", "bond_adding.reachable", "atom.GetExplicitValence", "a1.GetIdx", "a2.GetIdx", "ob_mol.DeleteBond", "atom.GetIdx"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.get_max_valences", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.sort_atoms_by_valence", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.sort_bonds_by_stretch", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.reachable"], ["", "", "", "", "def", "remove_bad_valences", "(", "self", ",", "ob_mol", ",", "atoms", ",", "struct", ")", ":", "\n", "        ", "'''\n        Remove hypervalent bonds without fragmenting\n        the molecule, and prioritize stretched bonds.\n        Also remove bonds between halogens/hydrogens.\n        '''", "\n", "# get max valence of the atoms", "\n", "max_vals", "=", "get_max_valences", "(", "atoms", ")", "\n", "\n", "# remove any bonds between halogens or hydrogens", "\n", "for", "bond", "in", "ob", ".", "OBMolBondIter", "(", "ob_mol", ")", ":", "\n", "            ", "atom_a", "=", "bond", ".", "GetBeginAtom", "(", ")", "\n", "atom_b", "=", "bond", ".", "GetEndAtom", "(", ")", "\n", "if", "(", "\n", "max_vals", ".", "get", "(", "atom_a", ".", "GetIdx", "(", ")", ",", "1", ")", "==", "1", "and", "\n", "max_vals", ".", "get", "(", "atom_b", ".", "GetIdx", "(", ")", ",", "1", ")", "==", "1", "\n", ")", ":", "\n", "                ", "ob_mol", ".", "DeleteBond", "(", "bond", ")", "\n", "\n", "# remove bonds causing larger-than-permitted valences", "\n", "#   prioritize atoms with lowest max valence, since they", "\n", "#   place the hardest constraint on reachability (e.g O)", "\n", "\n", "", "", "atom_info", "=", "sort_atoms_by_valence", "(", "atoms", ",", "max_vals", ")", "\n", "for", "max_val", ",", "rem_val", ",", "atom", "in", "atom_info", ":", "\n", "\n", "            ", "if", "atom", ".", "GetExplicitValence", "(", ")", "<=", "max_val", ":", "\n", "                ", "continue", "\n", "# else, the atom could have an invalid valence", "\n", "#   so check whether we can modify a bond", "\n", "\n", "", "bond_info", "=", "sort_bonds_by_stretch", "(", "ob", ".", "OBAtomBondIter", "(", "atom", ")", ")", "\n", "for", "bond_stretch", ",", "bond_len", ",", "bond", "in", "bond_info", ":", "\n", "\n", "# do the atoms involved in this bond have bad valences?", "\n", "#   since we are modifying the valences in the loop, this", "\n", "#   could have changed since calling sort_atoms_by_valence", "\n", "\n", "                ", "a1", ",", "a2", "=", "bond", ".", "GetBeginAtom", "(", ")", ",", "bond", ".", "GetEndAtom", "(", ")", "\n", "max_val_diff", "=", "max", "(", "# by how much are the valences over?", "\n", "a1", ".", "GetExplicitValence", "(", ")", "-", "max_vals", ".", "get", "(", "a1", ".", "GetIdx", "(", ")", ",", "1", ")", ",", "\n", "a2", ".", "GetExplicitValence", "(", ")", "-", "max_vals", ".", "get", "(", "a2", ".", "GetIdx", "(", ")", ",", "1", ")", "\n", ")", "\n", "if", "max_val_diff", ">", "0", ":", "\n", "\n", "                    ", "bond_order", "=", "bond", ".", "GetBondOrder", "(", ")", "\n", "if", "bond_order", ">", "max_val_diff", ":", "# decrease bond order", "\n", "                        ", "bond", ".", "SetBondOrder", "(", "bond_order", "-", "max_val_diff", ")", "\n", "\n", "", "elif", "reachable", "(", "a1", ",", "a2", ")", ":", "# don't fragment the molecule", "\n", "                        ", "ob_mol", ".", "DeleteBond", "(", "bond", ")", "\n", "\n", "# if the current atom now has a permitted valence,", "\n", "# break and let other atoms choose next bonds to remove", "\n", "", "if", "atom", ".", "GetExplicitValence", "(", ")", "<=", "max_vals", "[", "atom", ".", "GetIdx", "(", ")", "]", ":", "\n", "                        ", "break", "\n", "\n", "# deleting bonds resets this flag", "\n", "", "", "", "", "ob_mol", ".", "SetHybridizationPerceived", "(", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.remove_bad_geometry": [[219, 246], ["bond_adding.sort_bonds_by_stretch", "ob_mol.SetHybridizationPerceived", "openbabel.openbabel.openbabel.OBMolBondIter", "bond.GetBeginAtom", "bond.GetEndAtom", "bond_adding.forms_small_angle", "bond_adding.forms_small_angle", "bond_adding.reachable", "ob_mol.DeleteBond"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.sort_bonds_by_stretch", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.forms_small_angle", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.forms_small_angle", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.reachable"], ["", "def", "remove_bad_geometry", "(", "self", ",", "ob_mol", ")", ":", "\n", "        ", "'''\n        Remove bonds with excessive stretch or angle strain\n        without fragmenting the molecule, and prioritizing\n        the most stretch bonds.\n        '''", "\n", "# eliminate geometrically poor bonds", "\n", "bond_info", "=", "sort_bonds_by_stretch", "(", "ob", ".", "OBMolBondIter", "(", "ob_mol", ")", ")", "\n", "for", "bond_stretch", ",", "bond_len", ",", "bond", "in", "bond_info", ":", "\n", "\n", "# can we remove this bond without disconnecting the molecule?", "\n", "            ", "atom1", "=", "bond", ".", "GetBeginAtom", "(", ")", "\n", "atom2", "=", "bond", ".", "GetEndAtom", "(", ")", "\n", "\n", "# as long as we aren't disconnecting, let's remove things", "\n", "#   that are excessively far away (0.45 from ConnectTheDots)", "\n", "# get bonds to be less than max allowed", "\n", "# also remove tight angles, as done in openbabel", "\n", "if", "(", "bond_stretch", ">", "self", ".", "max_bond_stretch", "\n", "or", "forms_small_angle", "(", "atom1", ",", "atom2", ",", "self", ".", "min_bond_angle", ")", "\n", "or", "forms_small_angle", "(", "atom2", ",", "atom1", ",", "self", ".", "min_bond_angle", ")", "\n", ")", ":", "\n", "                ", "if", "reachable", "(", "atom1", ",", "atom2", ")", ":", "# don't fragment the molecule", "\n", "                    ", "ob_mol", ".", "DeleteBond", "(", "bond", ")", "\n", "\n", "# deleting bonds resets this flag", "\n", "", "", "", "ob_mol", ".", "SetHybridizationPerceived", "(", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.fill_rem_valences": [[247, 320], ["bond_adding.get_max_valences", "zip", "bond_adding.get_max_valences", "bond_adding.sort_atoms_by_valence", "reversed", "get_max_valences.get", "bond_adding.sort_bonds_by_stretch", "reversed", "ob_atom.GetIdx", "atom_types.Atom.h_count", "atom.GetExplicitValence", "openbabel.openbabel.openbabel.OBAtomBondIter", "min", "ob_atom.GetImplicitHCount", "ob_atom.SetImplicitHCount", "ob_atom.GetExplicitValence", "ob_atom.GetImplicitHCount", "openbabel.openbabel.openbabel.OBAtomAssignTypicalImplicitHydrogens", "ob_atom.GetImplicitHCount", "ob_atom.SetImplicitHCount", "bond.GetBondOrder", "bond.GetBeginAtom", "bond.GetEndAtom", "bond.GetBondOrder", "bond.SetBondOrder", "get_max_valences.get", "a1.GetExplicitValence", "get_max_valences.get", "a2.GetExplicitValence", "min", "atom.GetExplicitValence", "a1.GetIdx", "a2.GetIdx", "atom.GetIdx"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.get_max_valences", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.get_max_valences", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.sort_atoms_by_valence", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.sort_bonds_by_stretch", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.Atom.h_count", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "def", "fill_rem_valences", "(", "self", ",", "ob_mol", ",", "atoms", ",", "struct", ")", ":", "\n", "        ", "'''\n        Fill empty valences with hydrogens up to the\n        amount expected by the atom type, or a typical\n        amount according to openbabel, and then fill\n        remaining empty valences with higher bond orders.\n        '''", "\n", "max_vals", "=", "get_max_valences", "(", "atoms", ")", "\n", "\n", "for", "ob_atom", ",", "atom_type", "in", "zip", "(", "atoms", ",", "struct", ".", "atom_types", ")", ":", "\n", "\n", "            ", "if", "struct", ".", "typer", ".", "explicit_h", ":", "\n", "# all Hs should already be present", "\n", "                ", "continue", "\n", "\n", "", "max_val", "=", "max_vals", ".", "get", "(", "ob_atom", ".", "GetIdx", "(", ")", ",", "1", ")", "\n", "\n", "if", "Atom", ".", "h_count", "in", "struct", ".", "typer", ":", "\n", "# this should have already been set", "\n", "#   by set_min_h_counts, but whatever", "\n", "                ", "h_count", "=", "Atom", ".", "h_count", "(", "ob_atom", ")", "\n", "if", "h_count", "<", "atom_type", ".", "h_count", ":", "\n", "                    ", "n", "=", "ob_atom", ".", "GetImplicitHCount", "(", ")", "\n", "ob_atom", ".", "SetImplicitHCount", "(", "n", "+", "atom_type", ".", "h_count", "-", "h_count", ")", "\n", "\n", "", "", "elif", "ob_atom", ".", "GetExplicitValence", "(", ")", "<", "max_val", ":", "\n", "# this uses explicit valence and formal charge,", "\n", "#   and only ever INCREASES hydrogens, since it", "\n", "#   never sets implicit H to a negative value", "\n", "# but it does overwrite the existing value, so", "\n", "#   we need to save it beforehand and then add", "\n", "                ", "n", "=", "ob_atom", ".", "GetImplicitHCount", "(", ")", "\n", "ob", ".", "OBAtomAssignTypicalImplicitHydrogens", "(", "ob_atom", ")", "\n", "n", "+=", "ob_atom", ".", "GetImplicitHCount", "(", ")", "\n", "ob_atom", ".", "SetImplicitHCount", "(", "n", ")", "\n", "\n", "# these have possibly changed", "\n", "", "", "max_vals", "=", "get_max_valences", "(", "atoms", ")", "\n", "\n", "# now increment bond orders to fill remaining valences", "\n", "atom_info", "=", "sort_atoms_by_valence", "(", "atoms", ",", "max_vals", ")", "\n", "for", "max_val", ",", "rem_val", ",", "atom", "in", "reversed", "(", "atom_info", ")", ":", "\n", "\n", "            ", "if", "atom", ".", "GetExplicitValence", "(", ")", ">=", "max_val", ":", "\n", "                ", "continue", "\n", "# else, the atom could have an empty valence", "\n", "#   so check whether we can augment a bond,", "\n", "#   prioritizing bonds that are too short", "\n", "\n", "", "bond_info", "=", "sort_bonds_by_stretch", "(", "ob", ".", "OBAtomBondIter", "(", "atom", ")", ")", "\n", "for", "bond_stretch", ",", "bond_len", ",", "bond", "in", "reversed", "(", "bond_info", ")", ":", "\n", "\n", "                ", "if", "bond", ".", "GetBondOrder", "(", ")", ">=", "3", ":", "\n", "                    ", "continue", "# don't go above triple", "\n", "\n", "# do the atoms involved in this bond have empty valences?", "\n", "#   since we are modifying the valences in the loop, this", "\n", "#   could have changed since calling sort_atoms_by_valence", "\n", "\n", "", "a1", ",", "a2", "=", "bond", ".", "GetBeginAtom", "(", ")", ",", "bond", ".", "GetEndAtom", "(", ")", "\n", "min_val_diff", "=", "min", "(", "# by how much are the valences under?", "\n", "max_vals", ".", "get", "(", "a1", ".", "GetIdx", "(", ")", ",", "1", ")", "-", "a1", ".", "GetExplicitValence", "(", ")", ",", "\n", "max_vals", ".", "get", "(", "a2", ".", "GetIdx", "(", ")", ",", "1", ")", "-", "a2", ".", "GetExplicitValence", "(", ")", "\n", ")", "\n", "if", "min_val_diff", ">", "0", ":", "# increase bond order", "\n", "\n", "                    ", "bond_order", "=", "bond", ".", "GetBondOrder", "(", ")", "# don't go above triple", "\n", "bond", ".", "SetBondOrder", "(", "min", "(", "bond_order", "+", "min_val_diff", ",", "3", ")", ")", "\n", "\n", "# if the current atom now has its preferred valence,", "\n", "#   break and let other atoms choose next bonds to augment", "\n", "if", "atom", ".", "GetExplicitValence", "(", ")", "==", "max_vals", "[", "atom", ".", "GetIdx", "(", ")", "]", ":", "\n", "                        ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_h_explicit": [[321, 337], ["ob_mol.SetHydrogensAdded", "ob_mol.AddHydrogens", "openbabel.openbabel.openbabel.OBMolAtomIter", "bond_adding.BondAdder.disable_perception", "a.GetAtomicNum", "a.SetHyb"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.disable_perception"], ["", "", "", "", "", "def", "make_h_explicit", "(", "self", ",", "ob_mol", ",", "atoms", ")", ":", "\n", "        ", "'''\n        Make implicit hydrogens into\n        explicit hydrogens and set\n        their hybridization state.\n        '''", "\n", "# hydrogens are not added if this flag is set", "\n", "ob_mol", ".", "SetHydrogensAdded", "(", "False", ")", "\n", "ob_mol", ".", "AddHydrogens", "(", ")", "\n", "\n", "for", "a", "in", "ob", ".", "OBMolAtomIter", "(", "ob_mol", ")", ":", "\n", "            ", "if", "a", ".", "GetAtomicNum", "(", ")", "==", "1", ":", "\n", "                ", "a", ".", "SetHyb", "(", "1", ")", "\n", "\n", "# AddHydrogens() resets some flags", "\n", "", "", "self", ".", "disable_perception", "(", "ob_mol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.add_bonds": [[338, 452], ["bond_adding.BondAdder.disable_perception", "bond_adding.BondAdder.add_bonds.visit_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.disable_perception"], ["", "def", "add_bonds", "(", "self", ",", "ob_mol", ",", "atoms", ",", "struct", ")", ":", "\n", "\n", "# track each step of bond adding", "\n", "        ", "visited_mols", "=", "[", "]", "\n", "\n", "def", "visit_mol", "(", "mol", ",", "msg", ")", ":", "\n", "            ", "mol", "=", "copy_ob_mol", "(", "mol", ")", "\n", "visited_mols", ".", "append", "(", "mol", ")", "\n", "if", "self", ".", "debug", ":", "\n", "                ", "bmap", "=", "{", "1", ":", "'-'", ",", "2", ":", "'='", ",", "3", ":", "'\u2261'", "}", "\n", "print", "(", "len", "(", "visited_mols", ")", ",", "msg", ")", "\n", "assert", "(", "\n", "mol", ".", "HasHybridizationPerceived", "(", ")", "and", "\n", "mol", ".", "HasAromaticPerceived", "(", ")", "\n", ")", ",", "'perception is on'", "\n", "return", "\n", "for", "a", "in", "ob", ".", "OBMolAtomIter", "(", "mol", ")", ":", "\n", "                    ", "print", "(", "'   '", ",", "(", "\n", "a", ".", "GetAtomicNum", "(", ")", ",", "\n", "a", ".", "IsAromatic", "(", ")", ",", "\n", "a", ".", "GetHyb", "(", ")", ",", "\n", "a", ".", "GetImplicitHCount", "(", ")", "\n", ")", ",", "end", "=", "' '", ")", "\n", "for", "b", "in", "ob", ".", "OBAtomBondIter", "(", "a", ")", ":", "\n", "                        ", "print", "(", "'({}{}{})'", ".", "format", "(", "\n", "b", ".", "GetBeginAtomIdx", "(", ")", ",", "\n", "bmap", "[", "b", ".", "GetBondOrder", "(", ")", "]", ",", "\n", "b", ".", "GetEndAtomIdx", "(", ")", "\n", ")", ",", "end", "=", "' '", ")", "\n", "", "print", "(", ")", "\n", "\n", "", "", "", "if", "len", "(", "atoms", ")", "==", "0", ":", "# nothing to do", "\n", "            ", "return", "ob_mol", ",", "visited_mols", "\n", "\n", "# by default, openbabel tries to perceive", "\n", "#   aromaticity and hybridization when you", "\n", "#   first access those properties, but it", "\n", "#   can be disabled by setting flags", "\n", "# here, we will prefer to use atom type info", "\n", "#   and only enable perception when needed", "\n", "", "self", ".", "disable_perception", "(", "ob_mol", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'initial struct'", ")", "\n", "\n", "# add all bonds between atom pairs within a distance range", "\n", "self", ".", "add_within_distance", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'add_within_distance'", ")", "\n", "\n", "# set minimum H counts to determine hyper valency", "\n", "#   but don't make them explicit yet to avoid issues", "\n", "#   with bond adding/removal (i.e. ignore bonds to H)", "\n", "self", ".", "set_min_h_counts", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'set_min_h_counts'", ")", "\n", "\n", "# set formal charge to correctly determine allowed valences", "\n", "self", ".", "set_formal_charges", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'set_formal_charges'", ")", "\n", "\n", "# remove bonds to atoms that are above their allowed valence", "\n", "#   with priority towards removing highly stretched bonds", "\n", "self", ".", "remove_bad_valences", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'remove_bad_valences'", ")", "\n", "\n", "# remove bonds with excessively distorted lengths/angles", "\n", "self", ".", "remove_bad_geometry", "(", "ob_mol", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'remove_bad_geometry'", ")", "\n", "\n", "# need to make_h_explicit() before PerceiveBondOrders()", "\n", "#   bc it fills remaining EXPLICIT valence with bonds", "\n", "# need to set_hybridization() before make_h_explicit()", "\n", "#   so that it generates the correct H coordinates", "\n", "\n", "self", ".", "set_hybridization", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'set_hybridization'", ")", "\n", "\n", "self", ".", "set_aromaticity", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'set_aromaticity'", ")", "\n", "\n", "self", ".", "make_h_explicit", "(", "ob_mol", ",", "atoms", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'make_h_explicit'", ")", "\n", "\n", "# hybridization and aromaticity are perceived in PBO()", "\n", "#   but the flags both are cleared at the end", "\n", "# so we have to disable perception again, and then", "\n", "#   re-apply previous methods", "\n", "ob_mol", ".", "PerceiveBondOrders", "(", ")", "\n", "self", ".", "disable_perception", "(", "ob_mol", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'perceive_bond_orders'", ")", "\n", "\n", "self", ".", "set_min_h_counts", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "# maybe removed by PBO?", "\n", "self", ".", "set_hybridization", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "self", ".", "set_aromaticity", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "self", ".", "make_h_explicit", "(", "ob_mol", ",", "atoms", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'recover_from_pbo'", ")", "\n", "\n", "# try to fix higher bond orders that cause bad valences", "\n", "#   if hybrid flag is not set, then can alter hybridization", "\n", "self", ".", "remove_bad_valences", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'remove_bad_valences'", ")", "\n", "\n", "# fill remaining valences with explicit Hs,", "\n", "#   up to the num expected by the atom types,", "\n", "#   and fill the rest with increased bond orders", "\n", "self", ".", "fill_rem_valences", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'fill_rem_valences'", ")", "\n", "\n", "self", ".", "make_h_explicit", "(", "ob_mol", ",", "atoms", ")", "\n", "visit_mol", "(", "ob_mol", ",", "'make_h_explicit'", ")", "\n", "\n", "# final cleanup for validity", "\n", "for", "a", "in", "ob", ".", "OBMolAtomIter", "(", "ob_mol", ")", ":", "\n", "            ", "if", "not", "a", ".", "IsInRing", "(", ")", ":", "\n", "                ", "a", ".", "SetAromatic", "(", "False", ")", "\n", "\n", "", "", "return", "ob_mol", ",", "visited_mols", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.post_process_rd_mol": [[453, 526], ["rdkit.Chem.GetPeriodicTable", "rdkit.Chem.AddHs.GetConformer().GetPositions", "rdkit.Chem.AddHs.GetBonds", "nonsingles.sort", "rdkit.Chem.AddHs.GetAtoms", "rdkit.Chem.AddHs", "rdkit.Chem.AddHs.GetConformer().GetPositions", "numpy.mean", "rdkit.Chem.AddHs.GetAtoms", "rdkit.Chem.AddHs.GetBonds", "bond.GetBeginAtom", "bond.GetEndAtom", "atom.GetIdx", "rdkit.Chem.SanitizeMol", "bond.GetBeginAtom", "bond.GetEndAtom", "bond.GetIsAromatic", "rdkit.Chem.AddHs.GetConformer", "bond.GetBeginAtomIdx", "bond.GetEndAtomIdx", "numpy.linalg.norm", "nonsingles.append", "bond.SetBondType", "atom.SetFormalCharge", "rdkit.Chem.AddHs.GetConformer", "numpy.all", "rdkit.Chem.AddHs.GetConformer().SetAtomPosition", "openbabel.openbabel.pybel.Molecule", "numpy.random.randint", "print", "openbabel.pybel.Molecule.write", "bond.GetBondType", "bond.GetBondType", "bond_adding.calc_valence", "rdkit.Chem.GetPeriodicTable.GetDefaultValence", "bond_adding.calc_valence", "rdkit.Chem.GetPeriodicTable.GetDefaultValence", "bond.GetBondType", "atom.GetAtomicNum", "atom.GetDegree", "numpy.all", "numpy.isfinite", "os.path.isdir", "os.mkdir", "pickle.dump", "bond.SetIsAromatic", "bond.GetBeginAtom.GetIsAromatic", "bond.GetEndAtom.GetIsAromatic", "bond.SetIsAromatic", "bond.GetBeginAtom.GetAtomicNum", "bond.GetEndAtom.GetAtomicNum", "numpy.isfinite", "rdkit.Chem.AddHs.GetConformer", "open", "bond.GetBeginAtom.GetIsAromatic", "bond.GetEndAtom.GetIsAromatic"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.calc_valence", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.calc_valence"], ["", "def", "post_process_rd_mol", "(", "self", ",", "rd_mol", ",", "struct", "=", "None", ")", ":", "\n", "        ", "'''\n        Convert OBMol to RDKit mol, fixing up issues.\n        '''", "\n", "pt", "=", "Chem", ".", "GetPeriodicTable", "(", ")", "\n", "# if double/triple bonds are connected to hypervalent atoms,", "\n", "#   decrement the order", "\n", "\n", "positions", "=", "rd_mol", ".", "GetConformer", "(", ")", ".", "GetPositions", "(", ")", "\n", "nonsingles", "=", "[", "]", "\n", "for", "bond", "in", "rd_mol", ".", "GetBonds", "(", ")", ":", "\n", "            ", "if", "bond", ".", "GetBondType", "(", ")", "==", "Chem", ".", "BondType", ".", "DOUBLE", "or", "bond", ".", "GetBondType", "(", ")", "==", "Chem", ".", "BondType", ".", "TRIPLE", ":", "\n", "                ", "i", "=", "bond", ".", "GetBeginAtomIdx", "(", ")", "\n", "j", "=", "bond", ".", "GetEndAtomIdx", "(", ")", "\n", "dist", "=", "np", ".", "linalg", ".", "norm", "(", "positions", "[", "i", "]", "-", "positions", "[", "j", "]", ")", "\n", "nonsingles", ".", "append", "(", "(", "dist", ",", "bond", ")", ")", "\n", "", "", "nonsingles", ".", "sort", "(", "reverse", "=", "True", ",", "key", "=", "lambda", "t", ":", "t", "[", "0", "]", ")", "\n", "\n", "for", "(", "d", ",", "bond", ")", "in", "nonsingles", ":", "\n", "            ", "a1", "=", "bond", ".", "GetBeginAtom", "(", ")", "\n", "a2", "=", "bond", ".", "GetEndAtom", "(", ")", "\n", "\n", "if", "calc_valence", "(", "a1", ")", ">", "pt", ".", "GetDefaultValence", "(", "a1", ".", "GetAtomicNum", "(", ")", ")", "or", "calc_valence", "(", "a2", ")", ">", "pt", ".", "GetDefaultValence", "(", "a2", ".", "GetAtomicNum", "(", ")", ")", ":", "\n", "                ", "btype", "=", "Chem", ".", "BondType", ".", "SINGLE", "\n", "if", "bond", ".", "GetBondType", "(", ")", "==", "Chem", ".", "BondType", ".", "TRIPLE", ":", "\n", "                    ", "btype", "=", "Chem", ".", "BondType", ".", "DOUBLE", "\n", "", "bond", ".", "SetBondType", "(", "btype", ")", "\n", "\n", "", "", "for", "atom", "in", "rd_mol", ".", "GetAtoms", "(", ")", ":", "\n", "#set nitrogens with 4 neighbors to have a charge", "\n", "            ", "if", "atom", ".", "GetAtomicNum", "(", ")", "==", "7", "and", "atom", ".", "GetDegree", "(", ")", "==", "4", ":", "\n", "                ", "atom", ".", "SetFormalCharge", "(", "1", ")", "\n", "\n", "", "", "rd_mol", "=", "Chem", ".", "AddHs", "(", "rd_mol", ",", "addCoords", "=", "True", ")", "\n", "\n", "positions", "=", "rd_mol", ".", "GetConformer", "(", ")", ".", "GetPositions", "(", ")", "\n", "center", "=", "np", ".", "mean", "(", "positions", "[", "np", ".", "all", "(", "np", ".", "isfinite", "(", "positions", ")", ",", "axis", "=", "1", ")", "]", ",", "axis", "=", "0", ")", "\n", "for", "atom", "in", "rd_mol", ".", "GetAtoms", "(", ")", ":", "\n", "            ", "i", "=", "atom", ".", "GetIdx", "(", ")", "\n", "pos", "=", "positions", "[", "i", "]", "\n", "if", "not", "np", ".", "all", "(", "np", ".", "isfinite", "(", "pos", ")", ")", ":", "\n", "#hydrogens on C fragment get set to nan (shouldn't, but they do)", "\n", "                ", "rd_mol", ".", "GetConformer", "(", ")", ".", "SetAtomPosition", "(", "i", ",", "center", ")", "\n", "\n", "", "", "try", ":", "\n", "            ", "Chem", ".", "SanitizeMol", "(", "rd_mol", ",", "Chem", ".", "SANITIZE_ALL", "^", "Chem", ".", "SANITIZE_KEKULIZE", ")", "\n", "", "except", ":", "# mtr22 - don't assume mols will pass this", "\n", "            ", "pass", "\n", "# dkoes - but we want to make failures as rare as possible and should debug them", "\n", "m", "=", "pybel", ".", "Molecule", "(", "ob_mol", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'badmols'", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "'badmols'", ")", "\n", "", "i", "=", "np", ".", "random", ".", "randint", "(", "1000000", ")", "\n", "outname", "=", "'badmols/badmol%d.sdf'", "%", "i", "\n", "print", "(", "\"WRITING\"", ",", "outname", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "m", ".", "write", "(", "'sdf'", ",", "outname", ",", "overwrite", "=", "True", ")", "\n", "if", "struct", ":", "\n", "                ", "pickle", ".", "dump", "(", "struct", ",", "open", "(", "'badmols/badmol%d.pkl'", "%", "i", ",", "'wb'", ")", ")", "\n", "\n", "#but at some point stop trying to enforce our aromaticity -", "\n", "#openbabel and rdkit have different aromaticity models so they", "\n", "#won't always agree.  Remove any aromatic bonds to non-aromatic atoms", "\n", "", "", "for", "bond", "in", "rd_mol", ".", "GetBonds", "(", ")", ":", "\n", "            ", "a1", "=", "bond", ".", "GetBeginAtom", "(", ")", "\n", "a2", "=", "bond", ".", "GetEndAtom", "(", ")", "\n", "if", "bond", ".", "GetIsAromatic", "(", ")", ":", "\n", "                ", "if", "not", "a1", ".", "GetIsAromatic", "(", ")", "or", "not", "a2", ".", "GetIsAromatic", "(", ")", ":", "\n", "                    ", "bond", ".", "SetIsAromatic", "(", "False", ")", "\n", "", "", "elif", "a1", ".", "GetIsAromatic", "(", ")", "and", "a2", ".", "GetIsAromatic", "(", ")", ":", "\n", "                ", "bond", ".", "SetIsAromatic", "(", "True", ")", "\n", "\n", "", "", "return", "rd_mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_mol": [[527, 552], ["struct.to_ob_mol", "bond_adding.BondAdder.add_bonds", "molecules.Molecule.from_ob_mol", "struct.typer.make_struct", "molecules.Molecule.from_ob_mol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.add_bonds", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_ob_mol"], ["", "def", "make_mol", "(", "self", ",", "struct", ",", "visited", "=", "True", ")", ":", "\n", "        ", "'''\n        Create a Molecule from an AtomStruct with added\n        bonds, trying to maintain the same atom types.\n        '''", "\n", "# convert struct to ob_mol with minimal processing", "\n", "ob_mol", ",", "atoms", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "\n", "# add bonds and hydrogens, maintaining atomic properties", "\n", "ob_mol", ",", "visited_mols", "=", "self", ".", "add_bonds", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "\n", "# convert ob_mol to rd_mol with minimal processing", "\n", "add_mol", "=", "Molecule", ".", "from_ob_mol", "(", "ob_mol", ")", "\n", "\n", "# convert output mol back to struct, to see if types match", "\n", "add_struct", "=", "struct", ".", "typer", ".", "make_struct", "(", "ob_mol", ")", "\n", "\n", "if", "visited", ":", "\n", "            ", "visited_mols", "=", "[", "\n", "Molecule", ".", "from_ob_mol", "(", "m", ")", "for", "m", "in", "visited_mols", "\n", "]", "+", "[", "add_mol", "]", "\n", "\n", "return", "add_mol", ",", "add_struct", ",", "visited_mols", "\n", "", "else", ":", "\n", "            ", "return", "add_mol", ",", "add_struct", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_batch": [[553, 562], ["bond_adding.BondAdder.make_mol", "add_mols.append", "add_structs.append"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_mol"], ["", "", "def", "make_batch", "(", "self", ",", "structs", ")", ":", "\n", "\n", "        ", "add_mols", ",", "add_structs", "=", "[", "]", ",", "[", "]", "\n", "for", "struct", "in", "structs", ":", "\n", "            ", "add_mol", ",", "add_struct", "=", "self", ".", "make_mol", "(", "struct", ",", "visited", "=", "False", ")", "\n", "add_mols", ".", "append", "(", "add_mol", ")", "\n", "add_structs", ".", "append", "(", "add_struct", ")", "\n", "\n", "", "return", "add_mols", ",", "add_structs", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.calc_valence": [[564, 574], ["rd_atom.GetBonds", "bond.GetBondTypeAsDouble"], "function", ["None"], ["", "", "def", "calc_valence", "(", "rd_atom", ")", ":", "\n", "    ", "'''\n    Can call GetExplicitValence before sanitize,\n    but need to know this to fix up the molecule\n    to prevent sanitization failures.\n    '''", "\n", "val", "=", "0", "\n", "for", "bond", "in", "rd_atom", ".", "GetBonds", "(", ")", ":", "\n", "        ", "val", "+=", "bond", ".", "GetBondTypeAsDouble", "(", ")", "\n", "", "return", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.compare_bonds": [[576, 588], ["b1.GetBeginAtomIdx", "b2.GetBeginAtomIdx", "b1.GetEndAtomIdx", "b2.GetEndAtomIdx", "b1.GetBeginAtomIdx", "b2.GetEndAtomIdx", "b1.GetEndAtomIdx", "b2.GetBeginAtomIdx"], "function", ["None"], ["", "def", "compare_bonds", "(", "b1", ",", "b2", ")", ":", "\n", "    ", "'''\n    Return whether two OB bonds have the\n    the same begin and end atom indices,\n    assuming they're in the same mol.\n    '''", "\n", "return", "(", "\n", "b1", ".", "GetBeginAtomIdx", "(", ")", "==", "b2", ".", "GetBeginAtomIdx", "(", ")", "and", "\n", "b1", ".", "GetEndAtomIdx", "(", ")", "==", "b2", ".", "GetEndAtomIdx", "(", ")", "\n", ")", "or", "(", "\n", "b1", ".", "GetBeginAtomIdx", "(", ")", "==", "b2", ".", "GetEndAtomIdx", "(", ")", "and", "\n", "b1", ".", "GetEndAtomIdx", "(", ")", "==", "b2", ".", "GetBeginAtomIdx", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.reachable_r": [[591, 607], ["openbabel.openbabel.OBAtomAtomIter", "curr_atom.GetBond", "nbr_atom.GetIdx", "visited_atoms.add", "bond_adding.compare_bonds", "bond_adding.reachable_r"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.compare_bonds", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.reachable_r"], ["", "def", "reachable_r", "(", "curr_atom", ",", "goal_atom", ",", "avoid_bond", ",", "visited_atoms", ")", ":", "\n", "    ", "'''\n    Recursive helper for determining whether\n    goal_atom is reachable from curr_atom\n    without using avoid_bond.\n    '''", "\n", "for", "nbr_atom", "in", "ob", ".", "OBAtomAtomIter", "(", "curr_atom", ")", ":", "\n", "        ", "curr_bond", "=", "curr_atom", ".", "GetBond", "(", "nbr_atom", ")", "\n", "nbr_atom_idx", "=", "nbr_atom", ".", "GetIdx", "(", ")", "\n", "if", "not", "compare_bonds", "(", "curr_bond", ",", "avoid_bond", ")", "and", "nbr_atom_idx", "not", "in", "visited_atoms", ":", "\n", "            ", "visited_atoms", ".", "add", "(", "nbr_atom_idx", ")", "\n", "if", "nbr_atom", "==", "goal_atom", ":", "\n", "                ", "return", "True", "\n", "", "elif", "reachable_r", "(", "nbr_atom", ",", "goal_atom", ",", "avoid_bond", ",", "visited_atoms", ")", ":", "\n", "                ", "return", "True", "\n", "", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.reachable": [[609, 627], ["atom_a.GetBond", "bond_adding.reachable_r", "atom_a.GetExplicitDegree", "atom_b.GetExplicitDegree", "atom_a.GetBond", "atom_a.GetIdx"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.reachable_r"], ["", "def", "reachable", "(", "atom_a", ",", "atom_b", ")", ":", "\n", "    ", "'''\n    Return whether atom_b is reachable from atom_a\n    without using the bond between them, i.e. whether\n    the bond can be removed without fragmenting the\n    molecule (because the bond is part of a ring).\n    '''", "\n", "assert", "atom_a", ".", "GetBond", "(", "atom_b", ")", ",", "'atoms must be bonded'", "\n", "\n", "if", "atom_a", ".", "GetExplicitDegree", "(", ")", "==", "1", "or", "atom_b", ".", "GetExplicitDegree", "(", ")", "==", "1", ":", "\n", "        ", "return", "False", "# this is the _only_ bond for one atom", "\n", "\n", "# otherwise do recursive traversal", "\n", "", "return", "reachable_r", "(", "\n", "curr_atom", "=", "atom_a", ",", "\n", "goal_atom", "=", "atom_b", ",", "\n", "avoid_bond", "=", "atom_a", ".", "GetBond", "(", "atom_b", ")", ",", "\n", "visited_atoms", "=", "{", "atom_a", ".", "GetIdx", "(", ")", "}", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.forms_small_angle": [[630, 642], ["openbabel.openbabel.OBAtomAtomIter", "atom_b.GetAngle"], "function", ["None"], ["", "def", "forms_small_angle", "(", "atom_a", ",", "atom_b", ",", "cutoff", "=", "45", ")", ":", "\n", "    ", "'''\n    Return whether bond between atom_a and atom_b\n    is part of a small angle with a neighbor of a\n    only.\n    '''", "\n", "for", "nbr", "in", "ob", ".", "OBAtomAtomIter", "(", "atom_a", ")", ":", "\n", "        ", "if", "nbr", "!=", "atom_b", ":", "\n", "            ", "degrees", "=", "atom_b", ".", "GetAngle", "(", "atom_a", ",", "nbr", ")", "\n", "if", "degrees", "<", "cutoff", ":", "\n", "                ", "return", "True", "\n", "", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.sort_bonds_by_stretch": [[644, 670], ["bond_info.sort", "bond.GetBeginAtom().GetAtomicNum", "bond.GetEndAtom().GetAtomicNum", "bond.GetLength", "bond_info.append", "openbabel.openbabel.GetCovalentRad", "openbabel.openbabel.GetCovalentRad", "numpy.abs", "bond.GetBeginAtom", "bond.GetEndAtom"], "function", ["None"], ["", "def", "sort_bonds_by_stretch", "(", "bonds", ",", "absolute", "=", "True", ")", ":", "\n", "    ", "'''\n    Return bonds sorted by their distance\n    from the optimal covalent bond length,\n    and their actual bond length, with the\n    most stretched and longest bonds first.\n    '''", "\n", "bond_info", "=", "[", "]", "\n", "for", "bond", "in", "bonds", ":", "\n", "\n", "# compute how far away from optimal we are", "\n", "        ", "atomic_num1", "=", "bond", ".", "GetBeginAtom", "(", ")", ".", "GetAtomicNum", "(", ")", "\n", "atomic_num2", "=", "bond", ".", "GetEndAtom", "(", ")", ".", "GetAtomicNum", "(", ")", "\n", "ideal_bond_len", "=", "(", "\n", "ob", ".", "GetCovalentRad", "(", "atomic_num1", ")", "+", "\n", "ob", ".", "GetCovalentRad", "(", "atomic_num2", ")", "\n", ")", "\n", "bond_len", "=", "bond", ".", "GetLength", "(", ")", "\n", "stretch", "=", "bond_len", "-", "ideal_bond_len", "\n", "if", "absolute", ":", "\n", "            ", "stretch", "=", "np", ".", "abs", "(", "stretch", ")", "\n", "", "bond_info", ".", "append", "(", "(", "stretch", ",", "bond_len", ",", "bond", ")", ")", "\n", "\n", "# sort bonds from most to least stretched", "\n", "", "bond_info", ".", "sort", "(", "reverse", "=", "True", ",", "key", "=", "lambda", "t", ":", "(", "t", "[", "0", "]", ",", "t", "[", "1", "]", ")", ")", "\n", "return", "bond_info", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.count_nbrs_of_elem": [[672, 678], ["openbabel.openbabel.OBAtomAtomIter", "nbr.GetAtomicNum"], "function", ["None"], ["", "def", "count_nbrs_of_elem", "(", "atom", ",", "atomic_num", ")", ":", "\n", "    ", "count", "=", "0", "\n", "for", "nbr", "in", "ob", ".", "OBAtomAtomIter", "(", "atom", ")", ":", "\n", "        ", "if", "nbr", ".", "GetAtomicNum", "(", ")", "==", "atomic_num", ":", "\n", "            ", "count", "+=", "1", "\n", "", "", "return", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.get_max_valences": [[680, 716], ["rdkit.Chem.GetPeriodicTable", "enumerate", "ob_atom.GetAtomicNum", "Chem.GetPeriodicTable.GetDefaultValence", "ob_atom.GetImplicitHCount", "ob_atom.GetFormalCharge", "bond_adding.count_nbrs_of_elem", "ob_atom.GetIdx", "bond_adding.count_nbrs_of_elem"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.count_nbrs_of_elem", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.count_nbrs_of_elem"], ["", "def", "get_max_valences", "(", "atoms", ")", ":", "\n", "\n", "# determine max allowed valences", "\n", "    ", "pt", "=", "Chem", ".", "GetPeriodicTable", "(", ")", "\n", "max_vals", "=", "{", "}", "\n", "for", "i", ",", "ob_atom", "in", "enumerate", "(", "atoms", ")", ":", "\n", "\n", "# set max valance to the smallest allowed by either openbabel", "\n", "# or rdkit, since we want the molecule to be valid for both", "\n", "# (rdkit is usually lower, mtr22- specifically for N, 3 vs 4)", "\n", "\n", "# mtr22- since we are assessing validity with rdkit,", "\n", "# we should try to use the rdkit valence model here", "\n", "# which allows multiple valences for certain elements", "\n", "# refer to rdkit.Chem.Atom.calcExplicitValence", "\n", "\n", "        ", "atomic_num", "=", "ob_atom", ".", "GetAtomicNum", "(", ")", "\n", "\n", "# get default valence of isoelectronic element", "\n", "iso_atomic_num", "=", "atomic_num", "-", "ob_atom", ".", "GetFormalCharge", "(", ")", "\n", "max_val", "=", "pt", ".", "GetDefaultValence", "(", "iso_atomic_num", ")", "\n", "\n", "# check for common functional groups", "\n", "if", "atomic_num", "==", "15", ":", "# phosphate", "\n", "            ", "if", "count_nbrs_of_elem", "(", "ob_atom", ",", "8", ")", ">=", "4", ":", "\n", "                ", "max_val", "=", "5", "\n", "\n", "", "", "elif", "atomic_num", "==", "16", ":", "# sulfone", "\n", "            ", "if", "count_nbrs_of_elem", "(", "ob_atom", ",", "8", ")", ">=", "2", ":", "\n", "                ", "max_val", "=", "6", "\n", "\n", "", "", "max_val", "-=", "ob_atom", ".", "GetImplicitHCount", "(", ")", "\n", "\n", "max_vals", "[", "ob_atom", ".", "GetIdx", "(", ")", "]", "=", "max_val", "\n", "\n", "", "return", "max_vals", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.sort_atoms_by_valence": [[718, 734], ["atom_info.sort", "atom_info.append", "atom.GetExplicitValence", "atom.GetIdx"], "function", ["None"], ["", "def", "sort_atoms_by_valence", "(", "atoms", ",", "max_vals", ")", ":", "\n", "    ", "'''\n    Return atoms sorted by their maximum\n    allowed valence and remaining valence,\n    with the most valence-constrained and\n    hyper-valent atoms sorted first.\n    '''", "\n", "atom_info", "=", "[", "]", "\n", "for", "atom", "in", "atoms", ":", "\n", "        ", "max_val", "=", "max_vals", "[", "atom", ".", "GetIdx", "(", ")", "]", "\n", "rem_val", "=", "max_val", "-", "atom", ".", "GetExplicitValence", "(", ")", "\n", "atom_info", ".", "append", "(", "(", "max_val", ",", "rem_val", ",", "atom", ")", ")", "\n", "\n", "# sort atoms from least to most remaining valence", "\n", "", "atom_info", ".", "sort", "(", "key", "=", "lambda", "t", ":", "(", "t", "[", "0", "]", ",", "t", "[", "1", "]", ")", ")", "\n", "return", "atom_info", "\n", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DReLU.conv": [[66, 75], ["pytest.fixture", "request.param"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "models", ".", "Conv3DReLU", ",", "models", ".", "TConv3DReLU", "]", ")", "\n", "def", "conv", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "(", "\n", "n_channels_in", "=", "n_rec_channels", ",", "\n", "n_channels_out", "=", "n_lig_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "batch_norm", "=", "2", ",", "\n", "spectral_norm", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DReLU.test_init": [[77, 79], ["len"], "methods", ["None"], ["", "def", "test_init", "(", "self", ",", "conv", ")", ":", "\n", "        ", "assert", "len", "(", "conv", ")", "==", "3", ",", "'different num modules'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DReLU.test_forward_cpu": [[80, 84], ["torch.zeros().cpu", "conv.to", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["", "def", "test_forward_cpu", "(", "self", ",", "conv", ")", ":", "\n", "        ", "x", "=", "torch", ".", "zeros", "(", "batch_size", ",", "n_rec_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", ")", ".", "cpu", "(", ")", "\n", "y", "=", "conv", ".", "to", "(", "'cpu'", ")", "(", "x", ")", "\n", "assert", "y", ".", "shape", "==", "(", "batch_size", ",", "n_lig_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", ")", ",", "'different output shape'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DReLU.test_forward_cuda": [[85, 89], ["torch.zeros().cuda", "conv.to", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["", "def", "test_forward_cuda", "(", "self", ",", "conv", ")", ":", "\n", "        ", "x", "=", "torch", ".", "zeros", "(", "batch_size", ",", "n_rec_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", ")", ".", "cuda", "(", ")", "\n", "y", "=", "conv", ".", "to", "(", "'cuda'", ")", "(", "x", ")", "\n", "assert", "y", ".", "shape", "==", "(", "batch_size", ",", "n_lig_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", ")", ",", "'different output shape'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type": [[93, 96], ["pytest.fixture"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "models", ".", "Conv3DBlock", ",", "models", ".", "TConv3DBlock", "]", ")", "\n", "def", "conv_type", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.block_type": [[97, 100], ["pytest.fixture"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "'c'", ",", "'r'", ",", "'d'", "]", ")", "\n", "def", "block_type", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.bn_factor": [[101, 104], ["pytest.fixture"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "1", ",", "2", ",", "4", "]", ")", "\n", "def", "bn_factor", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_block": [[105, 117], ["test_models.TestConv3DBlock.conv_type"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.conv_type"], ["", "@", "pytest", ".", "fixture", "\n", "def", "conv_block", "(", "self", ",", "conv_type", ",", "block_type", ",", "bn_factor", ")", ":", "\n", "        ", "return", "conv_type", "(", "\n", "n_convs", "=", "3", ",", "\n", "n_channels_in", "=", "n_rec_channels", ",", "\n", "n_channels_out", "=", "n_lig_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "batch_norm", "=", "0", ",", "\n", "spectral_norm", "=", "1", ",", "\n", "block_type", "=", "block_type", ",", "\n", "bottleneck_factor", "=", "bn_factor", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.test_init": [[119, 121], ["len"], "methods", ["None"], ["", "def", "test_init", "(", "self", ",", "conv_block", ")", ":", "\n", "        ", "assert", "len", "(", "conv_block", ")", "==", "3", ",", "'different num modules'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestConv3DBlock.test_forward_cuda": [[122, 128], ["torch.zeros().cuda", "print", "print", "conv_block.to", "liGAN.models.get_n_params", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.get_n_params"], ["", "def", "test_forward_cuda", "(", "self", ",", "conv_block", ")", ":", "\n", "        ", "x", "=", "torch", ".", "zeros", "(", "batch_size", ",", "n_rec_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", ")", ".", "cuda", "(", ")", "\n", "y", "=", "conv_block", ".", "to", "(", "'cuda'", ")", "(", "x", ")", "\n", "print", "(", "conv_block", ")", "\n", "print", "(", "get_n_params", "(", "conv_block", ")", ")", "\n", "assert", "y", ".", "shape", "==", "(", "batch_size", ",", "n_lig_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", ")", ",", "'different output shape'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.get_enc": [[132, 147], ["liGAN.models.GridEncoder().cuda", "liGAN.models.GridEncoder"], "methods", ["None"], ["    ", "def", "get_enc", "(", "self", ",", "n_output", ")", ":", "\n", "        ", "return", "models", ".", "GridEncoder", "(", "\n", "n_channels", "=", "n_lig_channels", ",", "\n", "grid_size", "=", "grid_size", ",", "\n", "n_filters", "=", "32", ",", "\n", "width_factor", "=", "2", ",", "\n", "n_levels", "=", "3", ",", "\n", "conv_per_level", "=", "4", ",", "\n", "kernel_size", "=", "3", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "batch_norm", "=", "2", ",", "\n", "spectral_norm", "=", "1", ",", "\n", "pool_type", "=", "'a'", ",", "\n", "pool_factor", "=", "2", ",", "\n", "n_output", "=", "n_output", ",", "\n", ")", ".", "cuda", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc0": [[149, 152], ["test_models.TestGridEncoder.get_enc"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.get_enc"], ["", "@", "pytest", ".", "fixture", "\n", "def", "enc0", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "get_enc", "(", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc1": [[153, 156], ["test_models.TestGridEncoder.get_enc"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.get_enc"], ["", "@", "pytest", ".", "fixture", "\n", "def", "enc1", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "get_enc", "(", "128", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc2": [[157, 160], ["test_models.TestGridEncoder.get_enc"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.get_enc"], ["", "@", "pytest", ".", "fixture", "\n", "def", "enc2", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "get_enc", "(", "[", "128", ",", "128", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.x": [[161, 165], ["torch.zeros().cuda", "torch.zeros"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "x", "(", "self", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "\n", "batch_size", ",", "n_lig_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", "\n", ")", ".", "cuda", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.test_enc1_init": [[167, 172], ["len", "len"], "methods", ["None"], ["", "def", "test_enc1_init", "(", "self", ",", "enc1", ")", ":", "\n", "        ", "assert", "len", "(", "enc1", ".", "grid_modules", ")", "==", "5", ",", "'different num grid modules'", "\n", "assert", "len", "(", "enc1", ".", "task_modules", ")", "==", "1", ",", "'different num task modules'", "\n", "assert", "enc1", ".", "n_channels", "==", "128", ",", "'different num grid channels'", "\n", "assert", "enc1", ".", "grid_size", "==", "grid_size", "//", "4", ",", "'different grid size'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.test_enc1_forward": [[173, 177], ["test_models.TestGridEncoder.enc1"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc1"], ["", "def", "test_enc1_forward", "(", "self", ",", "enc1", ",", "x", ")", ":", "\n", "        ", "y", ",", "_", "=", "enc1", "(", "x", ")", "\n", "assert", "y", ".", "shape", "==", "(", "10", ",", "128", ")", ",", "'different output shape'", "\n", "assert", "y", ".", "norm", "(", ")", ">", "0", ",", "'output norm is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.test_enc1_backward0": [[178, 184], ["test_models.TestGridEncoder.enc1"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc1"], ["", "def", "test_enc1_backward0", "(", "self", ",", "enc1", ",", "x", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "y", ",", "_", "=", "enc1", "(", "x", ")", "\n", "y", ".", "backward", "(", "torch", ".", "zeros_like", "(", "y", ")", ")", "\n", "assert", "x", ".", "grad", "is", "not", "None", ",", "'input has no gradient'", "\n", "assert", "x", ".", "grad", ".", "norm", "(", ")", "==", "0", ",", "'input gradient not zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.test_enc1_backward1": [[185, 191], ["test_models.TestGridEncoder.enc1"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc1"], ["", "def", "test_enc1_backward1", "(", "self", ",", "enc1", ",", "x", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "y", ",", "_", "=", "enc1", "(", "x", ")", "\n", "y", ".", "backward", "(", "torch", ".", "ones_like", "(", "y", ")", ")", "\n", "assert", "x", ".", "grad", "is", "not", "None", ",", "'input has no gradient'", "\n", "assert", "x", ".", "grad", ".", "norm", "(", ")", ">", "0", ",", "'input gradient is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.test_enc2_init": [[192, 197], ["len", "len"], "methods", ["None"], ["", "def", "test_enc2_init", "(", "self", ",", "enc2", ")", ":", "\n", "        ", "assert", "len", "(", "enc2", ".", "grid_modules", ")", "==", "5", ",", "'different num grid modules'", "\n", "assert", "len", "(", "enc2", ".", "task_modules", ")", "==", "2", ",", "'different num task modules'", "\n", "assert", "enc2", ".", "n_channels", "==", "128", ",", "'different num grid channels'", "\n", "assert", "enc2", ".", "grid_size", "==", "grid_size", "//", "4", ",", "'different grid size'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.test_enc2_forward": [[198, 203], ["test_models.TestGridEncoder.enc2"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc2"], ["", "def", "test_enc2_forward", "(", "self", ",", "enc2", ",", "x", ")", ":", "\n", "        ", "(", "y0", ",", "y1", ")", ",", "_", "=", "enc2", "(", "x", ")", "\n", "assert", "y0", ".", "shape", "==", "y1", ".", "shape", "==", "(", "10", ",", "128", ")", ",", "'different output shape'", "\n", "assert", "y0", ".", "norm", "(", ")", ">", "0", ",", "'output norm is zero'", "\n", "assert", "y1", ".", "norm", "(", ")", ">", "0", ",", "'output norm is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.test_enc2_backward0": [[204, 210], ["test_models.TestGridEncoder.enc2"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc2"], ["", "def", "test_enc2_backward0", "(", "self", ",", "enc2", ",", "x", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "(", "y0", ",", "y1", ")", ",", "_", "=", "enc2", "(", "x", ")", "\n", "(", "y0", "+", "y1", ")", ".", "backward", "(", "torch", ".", "zeros_like", "(", "y0", "+", "y1", ")", ")", "\n", "assert", "x", ".", "grad", "is", "not", "None", ",", "'input has no gradient'", "\n", "assert", "x", ".", "grad", ".", "norm", "(", ")", "==", "0", ",", "'input gradient not zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.test_enc2_backward1": [[211, 217], ["test_models.TestGridEncoder.enc2"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridEncoder.enc2"], ["", "def", "test_enc2_backward1", "(", "self", ",", "enc2", ",", "x", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "(", "y0", ",", "y1", ")", ",", "_", "=", "enc2", "(", "x", ")", "\n", "(", "y0", "+", "y1", ")", ".", "backward", "(", "torch", ".", "ones_like", "(", "y0", "+", "y1", ")", ")", "\n", "assert", "x", ".", "grad", "is", "not", "None", ",", "'input has no gradient'", "\n", "assert", "x", ".", "grad", ".", "norm", "(", ")", ">", "0", ",", "'input gradient is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.dec": [[221, 237], ["liGAN.models.GridDecoder().cuda", "liGAN.models.GridDecoder"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "\n", "def", "dec", "(", "self", ")", ":", "\n", "        ", "return", "models", ".", "GridDecoder", "(", "\n", "n_input", "=", "128", ",", "\n", "grid_size", "=", "grid_size", "//", "2", "**", "2", ",", "\n", "n_channels", "=", "32", "*", "2", "**", "2", ",", "\n", "width_factor", "=", "2", ",", "\n", "n_levels", "=", "3", ",", "\n", "tconv_per_level", "=", "4", ",", "\n", "kernel_size", "=", "3", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "batch_norm", "=", "2", ",", "\n", "spectral_norm", "=", "1", ",", "\n", "unpool_type", "=", "'n'", ",", "\n", "unpool_factor", "=", "2", ",", "\n", "n_channels_out", "=", "n_rec_channels", ",", "\n", ")", ".", "cuda", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.x": [[239, 242], ["torch.zeros().cuda", "torch.zeros"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "x", "(", "self", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "batch_size", ",", "128", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.test_init": [[243, 248], ["len", "len"], "methods", ["None"], ["", "def", "test_init", "(", "self", ",", "dec", ")", ":", "\n", "        ", "assert", "len", "(", "dec", ".", "fc_modules", ")", "==", "1", ",", "'different num fc modules'", "\n", "assert", "len", "(", "dec", ".", "grid_modules", ")", "==", "6", ",", "'different num grid modules'", "\n", "assert", "dec", ".", "n_channels", "==", "n_rec_channels", ",", "'different num grid channels'", "\n", "assert", "dec", ".", "grid_size", "==", "grid_size", ",", "'different grid size'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.test_forward": [[249, 255], ["test_models.TestGridDecoder.dec"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.dec"], ["", "def", "test_forward", "(", "self", ",", "dec", ",", "x", ")", ":", "\n", "        ", "y", "=", "dec", "(", "x", ")", "\n", "assert", "y", ".", "shape", "==", "(", "\n", "batch_size", ",", "n_rec_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", "\n", ")", ",", "'different output shape'", "\n", "assert", "y", ".", "norm", "(", ")", ">", "0", ",", "'output norm is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.test_backward0": [[256, 262], ["test_models.TestGridDecoder.dec"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.dec"], ["", "def", "test_backward0", "(", "self", ",", "dec", ",", "x", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "y", "=", "dec", "(", "x", ")", "\n", "y", ".", "backward", "(", "torch", ".", "zeros_like", "(", "y", ")", ")", "\n", "assert", "x", ".", "grad", "is", "not", "None", ",", "'input has not gradient'", "\n", "assert", "x", ".", "grad", ".", "norm", "(", ")", "==", "0", ",", "'input gradient not zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.test_backward1": [[263, 269], ["test_models.TestGridDecoder.dec"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridDecoder.dec"], ["", "def", "test_backward1", "(", "self", ",", "dec", ",", "x", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "y", "=", "dec", "(", "x", ")", "\n", "y", ".", "backward", "(", "torch", ".", "ones_like", "(", "y", ")", ")", "\n", "assert", "x", ".", "grad", "is", "not", "None", ",", "'input has not gradient'", "\n", "assert", "x", ".", "grad", ".", "norm", "(", ")", ">", "0", ",", "'input gradient is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.model_type": [[273, 276], ["pytest.fixture"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "AE", ",", "CE", ",", "VAE", ",", "CVAE", ",", "GAN", ",", "CGAN", ",", "VAE2", ",", "CVAE2", "]", ")", "\n", "def", "model_type", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.block_type": [[277, 280], ["pytest.fixture"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "'c'", "]", ")", "#, 'r', 'd'])", "\n", "def", "block_type", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.bn_factor": [[281, 284], ["pytest.fixture"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "0", "]", ")", "#, 2, 4])", "\n", "def", "bn_factor", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.init_conv_pool": [[285, 288], ["pytest.fixture"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "0", ",", "1", "]", ")", "\n", "def", "init_conv_pool", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.gen": [[289, 318], ["test_models.TestGridGenerator.model_type"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.model_type"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gen", "(", "self", ",", "model_type", ",", "init_conv_pool", ",", "block_type", ",", "bn_factor", ")", ":", "\n", "        ", "model", "=", "model_type", "(", "\n", "n_channels_in", "=", "n_lig_channels", "if", "model_type", ".", "has_input_encoder", "else", "None", ",", "\n", "n_channels_cond", "=", "n_rec_channels", "if", "model_type", ".", "has_conditional_encoder", "else", "None", ",", "\n", "n_channels_out", "=", "n_lig_channels", ",", "\n", "grid_size", "=", "grid_size", ",", "\n", "n_filters", "=", "32", ",", "\n", "width_factor", "=", "2", ",", "\n", "n_levels", "=", "4", "-", "bool", "(", "init_conv_pool", ")", ",", "\n", "conv_per_level", "=", "3", ",", "\n", "kernel_size", "=", "3", ",", "\n", "relu_leak", "=", "0.1", ",", "\n", "batch_norm", "=", "0", ",", "\n", "spectral_norm", "=", "1", ",", "\n", "pool_type", "=", "'a'", ",", "\n", "unpool_type", "=", "'n'", ",", "\n", "n_latent", "=", "128", ",", "\n", "skip_connect", "=", "model_type", ".", "has_conditional_encoder", ",", "\n", "init_conv_pool", "=", "init_conv_pool", ",", "\n", "block_type", "=", "block_type", ",", "\n", "bottleneck_factor", "=", "bn_factor", ",", "\n", "device", "=", "'cuda'", ",", "\n", "debug", "=", "True", ",", "\n", ")", "\n", "model", ".", "name", "=", "'{}_{}_{}_{}'", ".", "format", "(", "\n", "model_type", ".", "__name__", ",", "init_conv_pool", ",", "block_type", ",", "bn_factor", "\n", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.inputs": [[319, 323], ["torch.zeros().cuda", "torch.zeros"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "inputs", "(", "self", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "\n", "batch_size", ",", "n_lig_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", "\n", ")", ".", "cuda", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.conditions": [[325, 329], ["torch.zeros().cuda", "torch.zeros"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "conditions", "(", "self", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "\n", "batch_size", ",", "n_rec_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", "\n", ")", ".", "cuda", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.test_gen_init": [[331, 336], ["type", "n.endswith", "n.startswith"], "methods", ["None"], ["", "def", "test_gen_init", "(", "self", ",", "gen", ")", ":", "\n", "        ", "n", "=", "type", "(", "gen", ")", ".", "__name__", "\n", "assert", "gen", ".", "is_variational", "==", "(", "'VAE'", "in", "n", ")", "or", "n", ".", "endswith", "(", "'GAN'", ")", "\n", "assert", "gen", ".", "has_input_encoder", "==", "(", "'AE'", "in", "n", ")", "\n", "assert", "gen", ".", "has_conditional_encoder", "==", "n", ".", "startswith", "(", "'C'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.test_gen_forward_poster": [[337, 342], ["test_models.TestGridGenerator.gen"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.gen"], ["", "def", "test_gen_forward_poster", "(", "self", ",", "gen", ",", "inputs", ",", "conditions", ")", ":", "\n", "        ", "outputs", ",", "latents", ",", "means", ",", "log_stds", "=", "gen", "(", "inputs", ",", "conditions", ",", "batch_size", ")", "\n", "assert", "outputs", ".", "shape", "==", "(", "batch_size", ",", "n_lig_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", ")", ",", "'different output shape'", "\n", "assert", "latents", ".", "shape", "==", "(", "batch_size", ",", "gen", ".", "n_latent", ")", ",", "'different latent shape'", "\n", "assert", "outputs", ".", "norm", "(", ")", ">", "0", ",", "'output norm is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.test_gen_forward_prior": [[343, 348], ["test_models.TestGridGenerator.gen"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.gen"], ["", "def", "test_gen_forward_prior", "(", "self", ",", "gen", ",", "conditions", ")", ":", "\n", "        ", "outputs", ",", "latents", ",", "means", ",", "log_stds", "=", "gen", "(", "None", ",", "conditions", ",", "batch_size", ")", "\n", "assert", "outputs", ".", "shape", "==", "(", "batch_size", ",", "n_lig_channels", ",", "grid_size", ",", "grid_size", ",", "grid_size", ")", ",", "'different output shape'", "\n", "assert", "latents", ".", "shape", "==", "(", "batch_size", ",", "gen", ".", "n_latent", ")", ",", "'different latent shape'", "\n", "assert", "outputs", ".", "norm", "(", ")", ">", "0", ",", "'output norm is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.test_gen_backward_poster0": [[349, 373], ["test_models.TestGridGenerator.gen"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.gen"], ["", "def", "test_gen_backward_poster0", "(", "self", ",", "gen", ",", "inputs", ",", "conditions", ")", ":", "\n", "        ", "inputs", ".", "requires_grad", "=", "True", "\n", "conditions", ".", "requires_grad", "=", "True", "\n", "outputs", ",", "latents", ",", "means", ",", "log_stds", "=", "gen", "(", "inputs", ",", "conditions", ",", "batch_size", ")", "\n", "outputs", ".", "backward", "(", "torch", ".", "zeros_like", "(", "outputs", ")", ")", "\n", "\n", "assert", "param_grad_norm", "(", "gen", ")", "==", "0", ",", "'param gradient not zero'", "\n", "assert", "param_grad_norm", "(", "gen", ".", "decoder", ")", "==", "0", ",", "'decoder gradient is zero'", "\n", "\n", "if", "gen", ".", "has_input_encoder", ":", "\n", "            ", "assert", "param_grad_norm", "(", "gen", ".", "input_encoder", ")", "==", "0", ",", "'input encoder gradient is zero'", "\n", "assert", "inputs", ".", "grad", "is", "not", "None", ",", "'input has no gradient'", "\n", "assert", "inputs", ".", "grad", ".", "norm", "(", ")", "==", "0", ",", "'input gradient not zero'", "\n", "", "else", ":", "\n", "            ", "assert", "inputs", ".", "grad", "is", "None", ",", "'input has a gradient'", "\n", "\n", "", "if", "gen", ".", "has_conditional_encoder", ":", "\n", "            ", "assert", "param_grad_norm", "(", "gen", ".", "conditional_encoder", ")", "==", "0", ",", "'conditional encoder gradient is zero'", "\n", "assert", "conditions", ".", "grad", "is", "not", "None", ",", "'condition has no gradient'", "\n", "assert", "conditions", ".", "grad", ".", "norm", "(", ")", "==", "0", ",", "'condition gradient not zero'", "\n", "", "else", ":", "\n", "            ", "assert", "conditions", ".", "grad", "is", "None", ",", "'condition has a gradient'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.test_gen_backward_poster1": [[374, 398], ["test_models.TestGridGenerator.gen"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.gen"], ["", "", "def", "test_gen_backward_poster1", "(", "self", ",", "gen", ",", "inputs", ",", "conditions", ")", ":", "\n", "        ", "inputs", ".", "requires_grad", "=", "True", "\n", "conditions", ".", "requires_grad", "=", "True", "\n", "outputs", ",", "latents", ",", "means", ",", "log_stds", "=", "gen", "(", "inputs", ",", "conditions", ",", "batch_size", ")", "\n", "outputs", ".", "backward", "(", "torch", ".", "ones_like", "(", "outputs", ")", ")", "\n", "\n", "assert", "param_grad_norm", "(", "gen", ")", ">", "0", ",", "'param gradient is zero'", "\n", "assert", "param_grad_norm", "(", "gen", ".", "decoder", ")", ">", "0", ",", "'decoder gradient is zero'", "\n", "\n", "if", "gen", ".", "has_input_encoder", ":", "\n", "            ", "assert", "param_grad_norm", "(", "gen", ".", "input_encoder", ")", ">", "0", ",", "'input encoder gradient is zero'", "\n", "assert", "inputs", ".", "grad", "is", "not", "None", ",", "'input has no gradient'", "\n", "assert", "inputs", ".", "grad", ".", "norm", "(", ")", ">", "0", ",", "'input gradient is zero'", "\n", "", "else", ":", "\n", "            ", "assert", "inputs", ".", "grad", "is", "None", ",", "'input has a gradient'", "\n", "\n", "", "if", "gen", ".", "has_conditional_encoder", ":", "\n", "            ", "assert", "param_grad_norm", "(", "gen", ".", "conditional_encoder", ")", ">", "0", ",", "'conditional encoder gradient is zero'", "\n", "assert", "conditions", ".", "grad", "is", "not", "None", ",", "'condition has no gradient'", "\n", "assert", "conditions", ".", "grad", ".", "norm", "(", ")", ">", "0", ",", "'condition gradient is zero'", "\n", "", "else", ":", "\n", "            ", "assert", "conditions", ".", "grad", "is", "None", ",", "'condition has a gradient'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.test_gen_backward_prior0": [[399, 419], ["test_models.TestGridGenerator.gen"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.gen"], ["", "", "def", "test_gen_backward_prior0", "(", "self", ",", "gen", ",", "conditions", ")", ":", "\n", "        ", "conditions", ".", "requires_grad", "=", "True", "\n", "\n", "outputs", ",", "latents", ",", "means", ",", "log_stds", "=", "gen", "(", "None", ",", "conditions", ",", "batch_size", ")", "\n", "outputs", ".", "backward", "(", "torch", ".", "zeros_like", "(", "outputs", ")", ")", "\n", "\n", "assert", "param_grad_norm", "(", "gen", ")", "==", "0", ",", "'param gradient not zero'", "\n", "assert", "param_grad_norm", "(", "gen", ".", "decoder", ")", "==", "0", ",", "'decoder gradient not zero'", "\n", "\n", "if", "gen", ".", "has_input_encoder", ":", "\n", "            ", "assert", "param_grad_norm", "(", "gen", ".", "input_encoder", ")", "==", "0", ",", "'input encoder gradient not zero'", "\n", "\n", "", "if", "gen", ".", "has_conditional_encoder", ":", "\n", "            ", "assert", "param_grad_norm", "(", "gen", ".", "conditional_encoder", ")", "==", "0", ",", "'conditional encoder gradient not zero'", "\n", "assert", "conditions", ".", "grad", "is", "not", "None", ",", "'condition has no gradient'", "\n", "assert", "conditions", ".", "grad", ".", "norm", "(", ")", "==", "0", ",", "'condition gradient not zero'", "\n", "", "else", ":", "\n", "            ", "assert", "conditions", ".", "grad", "is", "None", ",", "'condition has a gradient'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.test_gen_backward_prior1": [[420, 440], ["test_models.TestGridGenerator.gen"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.gen"], ["", "", "def", "test_gen_backward_prior1", "(", "self", ",", "gen", ",", "conditions", ")", ":", "\n", "        ", "conditions", ".", "requires_grad", "=", "True", "\n", "\n", "outputs", ",", "latents", ",", "means", ",", "log_stds", "=", "gen", "(", "None", ",", "conditions", ",", "batch_size", ")", "\n", "outputs", ".", "backward", "(", "torch", ".", "ones_like", "(", "outputs", ")", ")", "\n", "\n", "assert", "param_grad_norm", "(", "gen", ")", ">", "0", ",", "'param gradient is zero'", "\n", "assert", "param_grad_norm", "(", "gen", ".", "decoder", ")", ">", "0", ",", "'decoder gradient is zero'", "\n", "\n", "if", "gen", ".", "has_input_encoder", ":", "\n", "            ", "assert", "param_grad_norm", "(", "gen", ".", "input_encoder", ")", "==", "0", ",", "'input encoder gradient not zero'", "\n", "\n", "", "if", "gen", ".", "has_conditional_encoder", ":", "\n", "            ", "assert", "param_grad_norm", "(", "gen", ".", "conditional_encoder", ")", ">", "0", ",", "'conditional encoder gradient is zero'", "\n", "assert", "conditions", ".", "grad", "is", "not", "None", ",", "'condition has no gradient'", "\n", "assert", "conditions", ".", "grad", ".", "norm", "(", ")", ">", "0", ",", "'condition gradient is zero'", "\n", "", "else", ":", "\n", "            ", "assert", "conditions", ".", "grad", "is", "None", ",", "'condition has a gradient'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.test_gen_benchmark": [[441, 464], ["time.time", "range", "liGAN.models.get_n_params", "time.time", "test_models.TestGridGenerator.gen"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.get_n_params", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestGridGenerator.gen"], ["", "", "def", "test_gen_benchmark", "(", "self", ",", "gen", ",", "inputs", ",", "conditions", ")", ":", "\n", "        ", "n_trials", "=", "10", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "for", "i", "in", "range", "(", "n_trials", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "debug_file", "=", "'tests/output/TEST_{}.model_debug'", ".", "format", "(", "gen", ".", "name", ")", "\n", "with", "open", "(", "debug_file", ",", "'w'", ")", "as", "f", ":", "\n", "                    ", "with", "redirect_stderr", "(", "f", ")", ":", "\n", "                        ", "generated", ",", "latents", ",", "means", ",", "log_stds", "=", "gen", "(", "\n", "inputs", ",", "conditions", ",", "batch_size", "\n", ")", "\n", "", "", "", "else", ":", "\n", "                ", "generated", ",", "latents", ",", "means", ",", "log_stds", "=", "gen", "(", "\n", "inputs", ",", "conditions", ",", "batch_size", "\n", ")", "\n", "\n", "", "", "t_delta", "=", "time", ".", "time", "(", ")", "-", "t0", "\n", "t_delta", "/=", "n_trials", "\n", "n_params", "=", "models", ".", "get_n_params", "(", "gen", ")", "\n", "assert", "t_delta", "<", "1", ",", "'{:.1f}M params\\t{:.2f}s / batch'", ".", "format", "(", "\n", "n_params", "/", "1e6", ",", "t_delta", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestStage2VAE.model": [[469, 480], ["pytest.fixture", "liGAN.models.Stage2VAE().to", "liGAN.models.Stage2VAE"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "\n", "(", "0", ",", "0", ")", ",", "(", "1", ",", "96", ")", ",", "(", "2", ",", "96", ")", "\n", "]", ")", "\n", "def", "model", "(", "self", ",", "request", ")", ":", "\n", "        ", "n_h_layers", ",", "n_h_units", "=", "request", ".", "param", "\n", "return", "models", ".", "Stage2VAE", "(", "\n", "n_input", "=", "128", ",", "\n", "n_h_layers", "=", "n_h_layers", ",", "\n", "n_h_units", "=", "n_h_units", ",", "\n", "n_latent", "=", "64", ",", "\n", ")", ".", "to", "(", "'cuda'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestStage2VAE.inputs": [[481, 484], ["torch.zeros"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "inputs", "(", "self", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "10", ",", "128", ",", "device", "=", "'cuda'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestStage2VAE.test_init": [[485, 487], ["None"], "methods", ["None"], ["", "def", "test_init", "(", "self", ",", "model", ")", ":", "\n", "        ", "assert", "model", ".", "n_latent", "==", "64", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestStage2VAE.test_forward_poster": [[488, 491], ["test_models.TestStage2VAE.model"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestStage2VAE.model"], ["", "def", "test_forward_poster", "(", "self", ",", "model", ",", "inputs", ")", ":", "\n", "        ", "outputs", ",", "_", ",", "_", ",", "_", "=", "model", "(", "inputs", "=", "inputs", ",", "batch_size", "=", "10", ")", "\n", "assert", "outputs", ".", "shape", "==", "inputs", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestStage2VAE.test_forward_prior": [[492, 495], ["test_models.TestStage2VAE.model"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.TestStage2VAE.model"], ["", "def", "test_forward_prior", "(", "self", ",", "model", ",", "inputs", ")", ":", "\n", "        ", "outputs", ",", "_", ",", "_", ",", "_", "=", "model", "(", "batch_size", "=", "10", ")", "\n", "assert", "outputs", ".", "shape", "==", "inputs", ".", "shape", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_models.test_interpolate": [[22, 62], ["range", "torch.zeros", "range", "torch.randn", "torch.arange", "torch.cat", "torch.cat", "liGAN.interpolation.slerp", "print"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.interpolation.slerp", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["def", "test_interpolate", "(", ")", ":", "\n", "\n", "    ", "n_examples", "=", "4", "\n", "n_samples", "=", "10", "\n", "batch_size", "=", "5", "\n", "n_latent", "=", "2", "\n", "\n", "# total # interpolation steps so far", "\n", "interp_step", "=", "0", "\n", "end_pts", "=", "torch", ".", "zeros", "(", "(", "1", ",", "n_latent", ")", ")", "+", "1e-6", "\n", "\n", "for", "example_idx", "in", "range", "(", "n_examples", ")", ":", "\n", "        ", "for", "sample_idx", "in", "range", "(", "n_samples", ")", ":", "\n", "            ", "full_idx", "=", "example_idx", "*", "n_samples", "+", "sample_idx", "\n", "batch_idx", "=", "full_idx", "%", "batch_size", "\n", "\n", "if", "batch_idx", "==", "0", ":", "# forward", "\n", "\n", "                ", "latents", "=", "torch", ".", "randn", "(", "(", "batch_size", ",", "1", ")", ")", "\n", "batch_idxs", "=", "torch", ".", "arange", "(", "batch_size", ")", "\n", "latents", "=", "(", "\n", "(", "full_idx", "+", "batch_idxs", ")", "%", "(", "n_samples", "*", "2", ")", "==", "0", "\n", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "1", ")", "\n", "latents", "=", "torch", ".", "cat", "(", "[", "latents", ",", "1", "-", "latents", "]", ",", "dim", "=", "1", ")", "\n", "\n", "is_endpt", "=", "(", "interp_step", "+", "batch_idxs", ")", "%", "n_samples", "==", "0", "\n", "end_pts", "=", "torch", ".", "cat", "(", "[", "end_pts", ",", "latents", "[", "is_endpt", "]", "]", ")", "\n", "\n", "start_idx", "=", "(", "interp_step", "+", "batch_idxs", ")", "//", "n_samples", "\n", "stop_idx", "=", "start_idx", "+", "1", "\n", "start_pts", "=", "end_pts", "[", "start_idx", "]", "\n", "stop_pts", "=", "end_pts", "[", "stop_idx", "]", "\n", "k_interp", "=", "(", "\n", "(", "interp_step", "+", "batch_idxs", ")", "%", "n_samples", "+", "1", "\n", ")", ".", "unsqueeze", "(", "1", ")", "/", "n_samples", "\n", "\n", "new_latents", "=", "interpolation", ".", "slerp", "(", "start_pts", ",", "stop_pts", ",", "k_interp", ")", "\n", "print", "(", "new_latents", ")", "\n", "\n", "interp_step", "+=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_structs.TestAtomStruct.typer": [[12, 17], ["liGAN.atom_types.AtomTyper.get_typer"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer"], ["    ", "@", "pytest", ".", "fixture", "\n", "def", "typer", "(", "self", ")", ":", "\n", "        ", "typer", "=", "AtomTyper", ".", "get_typer", "(", "prop_funcs", "=", "''", ",", "radius_func", "=", "1.0", ")", "\n", "typer", ".", "elem_range", "=", "[", "8", "]", "\n", "return", "typer", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_structs.TestAtomStruct.struct": [[18, 24], ["liGAN.atom_structs.AtomStruct", "torch.zeros", "torch.eye"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "struct", "(", "self", ",", "typer", ")", ":", "\n", "        ", "return", "AtomStruct", "(", "\n", "coords", "=", "torch", ".", "zeros", "(", "(", "typer", ".", "n_types", ",", "3", ")", ")", ",", "\n", "types", "=", "torch", ".", "eye", "(", "typer", ".", "n_types", ")", ",", "\n", "typer", "=", "typer", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_structs.TestAtomStruct.test_init": [[26, 32], ["None"], "methods", ["None"], ["", "def", "test_init", "(", "self", ",", "struct", ")", ":", "\n", "        ", "assert", "struct", ".", "atom_types", "==", "struct", ".", "atom_types", "\n", "assert", "struct", ".", "atom_types", "is", "struct", ".", "atom_types", "\n", "\n", "assert", "(", "struct", ".", "atomic_radii", "==", "struct", ".", "atomic_radii", ")", ".", "all", "(", ")", "\n", "assert", "struct", ".", "atomic_radii", "is", "struct", ".", "atomic_radii", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.loss_kws": [[12, 17], ["dict", "dict", "dict"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "\n", "def", "loss_kws", "(", "self", ")", ":", "\n", "        ", "return", "dict", "(", "\n", "types", "=", "dict", "(", "recon_loss", "=", "'2'", ",", "gan_loss", "=", "'w'", ")", ",", "\n", "weights", "=", "dict", "(", "recon_loss", "=", "1", ",", "gan_loss", "=", "10", ",", "steric_loss", "=", "-", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.loss_fn": [[19, 22], ["liGAN.loss_fns.LossFunction"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "loss_fn", "(", "self", ",", "loss_kws", ")", ":", "\n", "        ", "return", "LossFunction", "(", "device", "=", "'cpu'", ",", "**", "loss_kws", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_init": [[23, 28], ["None"], "methods", ["None"], ["", "def", "test_loss_init", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "assert", "loss_fn", ".", "kldiv_loss_wt", "==", "0.0", "\n", "assert", "loss_fn", ".", "recon_loss_wt", "==", "1.0", "\n", "assert", "loss_fn", ".", "gan_loss_wt", "==", "10.0", "\n", "assert", "loss_fn", ".", "steric_loss_wt", "==", "-", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_null": [[29, 33], ["test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_null", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "loss", ",", "losses", "=", "loss_fn", "(", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "0", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_recon0": [[34, 43], ["torch.zeros", "torch.zeros", "test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_recon0", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "lig_grids", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "lig_gen_grids", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "loss", ",", "losses", "=", "loss_fn", "(", "\n", "lig_grids", "=", "lig_grids", ",", "lig_gen_grids", "=", "lig_gen_grids", "\n", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "0", "\n", "print", "(", "losses", ")", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "0", ",", "recon_loss", "=", "0", ",", "recon_loss_wt", "=", "1", ",", "recon_log_var", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_recon1": [[44, 53], ["torch.zeros", "torch.ones", "test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_recon1", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "lig_grids", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "lig_gen_grids", "=", "torch", ".", "ones", "(", "10", ",", "10", ")", "\n", "loss", ",", "losses", "=", "loss_fn", "(", "\n", "lig_grids", "=", "lig_grids", ",", "lig_gen_grids", "=", "lig_gen_grids", "\n", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "5", "\n", "print", "(", "losses", ")", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "5", ",", "recon_loss", "=", "5", ",", "recon_loss_wt", "=", "1", ",", "recon_log_var", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_kldiv0": [[54, 62], ["torch.zeros", "torch.zeros", "test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_kldiv0", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "a", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "b", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "loss", ",", "losses", "=", "loss_fn", "(", "\n", "latent_means", "=", "a", ",", "latent_log_stds", "=", "b", "\n", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "0", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "0", ",", "kldiv_loss", "=", "0", ",", "kldiv_loss_wt", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_kldiv1": [[63, 71], ["torch.ones", "torch.zeros", "test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_kldiv1", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "a", "=", "torch", ".", "ones", "(", "10", ",", "10", ")", "\n", "b", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "loss", ",", "losses", "=", "loss_fn", "(", "\n", "latent_means", "=", "a", ",", "latent_log_stds", "=", "b", "\n", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "0", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "0", ",", "kldiv_loss", "=", "5", ",", "kldiv_loss_wt", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_gan0": [[72, 80], ["torch.zeros", "torch.zeros", "test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_gan0", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "a", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "b", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "loss", ",", "losses", "=", "loss_fn", "(", "\n", "disc_labels", "=", "a", ",", "disc_preds", "=", "b", "\n", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "0", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "0", ",", "gan_loss", "=", "0", ",", "gan_loss_wt", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_gan1": [[81, 90], ["torch.ones", "torch.ones", "test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_gan1", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "a", "=", "torch", ".", "ones", "(", "10", ",", "10", ")", "\n", "b", "=", "torch", ".", "ones", "(", "10", ",", "10", ")", "\n", "loss", ",", "losses", "=", "loss_fn", "(", "\n", "disc_labels", "=", "a", ",", "disc_preds", "=", "b", "\n", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "100", "\n", "print", "(", "losses", ")", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "100", ",", "gan_loss", "=", "10", ",", "gan_loss_wt", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_steric0": [[91, 99], ["torch.zeros", "torch.zeros", "test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_steric0", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "a", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "b", "=", "torch", ".", "zeros", "(", "10", ",", "10", ")", "\n", "loss", ",", "losses", "=", "loss_fn", "(", "\n", "rec_grids", "=", "a", ",", "rec_lig_grids", "=", "b", "\n", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "0", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "0", ",", "steric_loss", "=", "0", ",", "steric_loss_wt", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossFunction.test_loss_steric1": [[100, 108], ["torch.ones", "torch.ones", "test_loss_fns.TestLossFunction.loss_fn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn"], ["", "def", "test_loss_steric1", "(", "self", ",", "loss_fn", ")", ":", "\n", "        ", "a", "=", "torch", ".", "ones", "(", "10", ",", "10", ")", "\n", "b", "=", "torch", ".", "ones", "(", "10", ",", "10", ")", "\n", "loss", ",", "losses", "=", "loss_fn", "(", "\n", "rec_grids", "=", "a", ",", "rec_lig_grids", "=", "b", "\n", ")", "\n", "assert", "loss", ".", "item", "(", ")", "==", "-", "100", "\n", "assert", "losses", "==", "dict", "(", "loss", "=", "-", "100", ",", "steric_loss", "=", "100", ",", "steric_loss_wt", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossSchedule.iters": [[112, 115], ["range"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "\n", "def", "iters", "(", "self", ")", ":", "\n", "        ", "return", "range", "(", "1", ",", "1000001", ",", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_loss_fns.TestLossSchedule.test_schedule_0": [[116, 120], ["liGAN.loss_fns.get_loss_schedule"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.loss_fns.get_loss_schedule"], ["", "def", "test_schedule_0", "(", "self", ",", "iters", ")", ":", "\n", "\n", "        ", "f", "=", "liGAN", ".", "loss_fns", ".", "get_loss_schedule", "(", "\n", "start_wt", "=", "1", ",", "end_wt", "=", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_init": [[157, 183], ["solver_name.endswith", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "solver.named_parameters", "type", "type", "len", "name.endswith", "type", "type", "name.endswith", "params.detach().norm().cpu", "params.detach().norm", "params.detach"], "methods", ["None"], ["    ", "def", "test_solver_init", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "assert", "type", "(", "solver", ".", "gen_model", ")", "==", "type", "(", "solver", ")", ".", "gen_model_type", "\n", "assert", "solver", ".", "gen_iter", "==", "0", "\n", "\n", "solver_name", "=", "type", "(", "solver", ")", ".", "__name__", "\n", "assert", "solver", ".", "has_complex_input", "==", "(", "'CVAE'", "in", "solver_name", ")", "\n", "\n", "assert", "solver", ".", "has_disc_model", "==", "(", "'GAN'", "in", "solver_name", ")", "\n", "if", "solver_name", ".", "endswith", "(", "'GAN'", ")", ":", "\n", "            ", "assert", "type", "(", "solver", ".", "disc_model", ")", "==", "models", ".", "Discriminator", "\n", "assert", "solver", ".", "disc_iter", "==", "0", "\n", "\n", "", "assert", "isinstance", "(", "solver", ".", "train_data", ",", "liGAN", ".", "data", ".", "AtomGridData", ")", "\n", "assert", "isinstance", "(", "solver", ".", "test_data", ",", "liGAN", ".", "data", ".", "AtomGridData", ")", "\n", "assert", "isinstance", "(", "solver", ".", "loss_fn", ",", "liGAN", ".", "loss_fns", ".", "LossFunction", ")", "\n", "assert", "isinstance", "(", "solver", ".", "atom_fitter", ",", "liGAN", ".", "atom_fitting", ".", "AtomFitter", ")", "\n", "assert", "isinstance", "(", "solver", ".", "bond_adder", ",", "liGAN", ".", "bond_adding", ".", "BondAdder", ")", "\n", "assert", "isinstance", "(", "solver", ".", "metrics", ",", "pd", ".", "DataFrame", ")", "\n", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "0", "\n", "\n", "for", "name", ",", "params", "in", "solver", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "name", ".", "endswith", "(", "'weight'", ")", ":", "\n", "                ", "assert", "params", ".", "detach", "(", ")", ".", "norm", "(", ")", ".", "cpu", "(", ")", ">", "0", ",", "'weights are zero'", "\n", "", "elif", "name", ".", "endswith", "(", "'bias'", ")", ":", "\n", "                ", "pass", "# ok for bias to be zero", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_phases": [[186, 189], ["solver.get_gen_grid_phase", "range"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.get_gen_grid_phase"], ["", "", "", "def", "test_solver_gen_phases", "(", "self", ",", "solver", ")", ":", "\n", "        ", "phases", "=", "[", "solver", ".", "get_gen_grid_phase", "(", "i", ")", "for", "i", "in", "range", "(", "6", ")", "]", "\n", "assert", "phases", ",", "phases", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_phases": [[190, 194], ["solver.get_disc_grid_phase", "range"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.get_disc_grid_phase"], ["", "def", "test_solver_disc_phases", "(", "self", ",", "solver", ")", ":", "\n", "        ", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "phases", "=", "[", "solver", ".", "get_disc_grid_phase", "(", "i", ")", "for", "i", "in", "range", "(", "6", ")", "]", "\n", "assert", "phases", ",", "phases", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_forward_poster": [[197, 205], ["solver.gen_forward", "metrics.items", "print", "loss.item"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_gen_forward_poster", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_posterior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'poster'", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "assert", "loss", ".", "item", "(", ")", "!=", "0", ",", "'loss is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_forward_prior": [[206, 216], ["solver.gen_forward", "metrics.items", "print", "print", "loss.item"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_gen_forward_prior", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_prior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'prior'", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "print", "(", "solver", ".", "loss_fn", ".", "has_prior_loss", ")", "\n", "assert", "loss", ".", "item", "(", ")", "!=", "0", "or", "not", "solver", ".", "loss_fn", ".", "has_prior_loss", ",", "'loss is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_forward_poster2": [[217, 225], ["solver.gen_forward", "metrics.items", "print", "loss.item"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_gen_forward_poster2", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_prior_model", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'poster2'", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "assert", "loss", ".", "item", "(", ")", "!=", "0", ",", "'loss is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_forward_prior2": [[226, 236], ["solver.gen_forward", "metrics.items", "print", "print", "loss.item"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_gen_forward_prior2", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_prior_model", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'prior2'", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "print", "(", "solver", ".", "loss_fn", ".", "has_prior_loss", ")", "\n", "assert", "loss", ".", "item", "(", ")", "!=", "0", "or", "not", "solver", ".", "loss_fn", ".", "has_prior_loss", ",", "'loss is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_forward_real": [[237, 245], ["solver.disc_forward", "metrics.items", "print", "loss.item"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_disc_forward_real", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'real'", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "assert", "loss", ".", "item", "(", ")", "!=", "0", ",", "'loss is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_forward_poster": [[246, 254], ["solver.disc_forward", "metrics.items", "print", "loss.item"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_disc_forward_poster", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_disc_model", "and", "solver", ".", "has_posterior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'poster'", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "assert", "loss", ".", "item", "(", ")", "!=", "0", ",", "'loss is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_forward_prior": [[255, 263], ["solver.disc_forward", "metrics.items", "print", "loss.item"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_disc_forward_prior", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_disc_model", "and", "solver", ".", "has_prior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'prior'", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "assert", "loss", ".", "item", "(", ")", "!=", "0", ",", "'loss is zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_backward_poster": [[266, 288], ["solver.gen_forward", "solver.gen_backward", "solver.gen_backward.items", "test_training.check_solver_grad", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_solver_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_gen_backward_poster", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_posterior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'poster'", ")", "\n", "metrics", "=", "solver", ".", "gen_backward", "(", "loss", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "check_solver_grad", "(", "solver", ",", "True", ",", "True", ",", "True", ",", "True", ",", "True", ")", "\n", "\n", "if", "solver", ".", "learn_recon_var", ":", "\n", "                ", "assert", "(", "\n", "solver", ".", "gen_model", ".", "log_recon_var", ".", "grad", ".", "data", "**", "2", "\n", ")", ".", "sum", "(", ")", ">", "0", ",", "'no gen log_recon_var gradient'", "\n", "if", "solver", ".", "has_prior_model", ":", "\n", "                    ", "assert", "(", "\n", "solver", ".", "prior_model", ".", "log_recon_var", ".", "grad", ".", "data", "**", "2", "\n", ")", ".", "sum", "(", ")", ">", "0", ",", "'no prior log_recon_var gradient'", "\n", "", "", "else", ":", "\n", "                ", "assert", "solver", ".", "gen_model", ".", "log_recon_var", ".", "grad", "is", "None", "\n", "if", "solver", ".", "has_prior_model", ":", "\n", "                    ", "assert", "solver", ".", "prior_model", ".", "log_recon_var", ".", "grad", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_backward_prior": [[289, 298], ["solver.gen_forward", "solver.gen_backward", "solver.gen_backward.items", "test_training.check_solver_grad", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_solver_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "", "", "def", "test_solver_gen_backward_prior", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_prior_phase", "and", "solver", ".", "loss_fn", ".", "has_prior_loss", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'prior'", ")", "\n", "metrics", "=", "solver", ".", "gen_backward", "(", "loss", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "check_solver_grad", "(", "solver", ",", "True", ",", "True", ",", "False", ",", "True", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_backward_poster2": [[299, 308], ["solver.gen_forward", "solver.gen_backward", "solver.gen_backward.items", "test_training.check_solver_grad", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_solver_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_gen_backward_poster2", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_prior_model", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'poster2'", ")", "\n", "metrics", "=", "solver", ".", "gen_backward", "(", "loss", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "check_solver_grad", "(", "solver", ",", "True", ",", "True", ",", "True", ",", "True", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_backward_prior2": [[309, 318], ["solver.gen_forward", "solver.gen_backward", "solver.gen_backward.items", "test_training.check_solver_grad", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_solver_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_gen_backward_prior2", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_prior_model", "and", "solver", ".", "loss_fn", ".", "has_prior_loss", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'prior2'", ")", "\n", "metrics", "=", "solver", ".", "gen_backward", "(", "loss", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "check_solver_grad", "(", "solver", ",", "True", ",", "True", ",", "False", ",", "True", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_backward_real": [[319, 328], ["solver.disc_forward", "solver.gen_backward", "solver.gen_backward.items", "test_training.check_solver_grad", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_solver_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_disc_backward_real", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'real'", ")", "\n", "metrics", "=", "solver", ".", "gen_backward", "(", "loss", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "check_solver_grad", "(", "solver", ",", "True", ",", "False", ",", "False", ",", "False", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_backward_poster": [[329, 338], ["solver.disc_forward", "solver.gen_backward", "solver.gen_backward.items", "test_training.check_solver_grad", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_solver_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_disc_backward_poster", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_disc_model", "and", "solver", ".", "has_posterior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'poster'", ")", "\n", "metrics", "=", "solver", ".", "gen_backward", "(", "loss", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "check_solver_grad", "(", "solver", ",", "True", ",", "False", ",", "False", ",", "False", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_backward_prior": [[339, 348], ["solver.disc_forward", "solver.gen_backward", "solver.gen_backward.items", "test_training.check_solver_grad", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_backward", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_solver_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_solver_disc_backward_prior", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "if", "solver", ".", "has_disc_model", "and", "solver", ".", "has_prior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "loss", ",", "metrics", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'prior'", ")", "\n", "metrics", "=", "solver", ".", "gen_backward", "(", "loss", ")", "\n", "for", "k", ",", "v", "in", "metrics", ".", "items", "(", ")", ":", "\n", "                ", "print", "(", "k", ",", "v", ")", "\n", "", "check_solver_grad", "(", "solver", ",", "True", ",", "False", ",", "False", ",", "False", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_step_poster": [[351, 380], ["liGAN.set_random_seed", "solver.gen_step", "liGAN.set_random_seed", "solver.gen_forward", "solver.gen_model.log_recon_var.item", "solver.prior_model.log_recon_var.item"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward"], ["", "", "def", "test_solver_gen_step_poster", "(", "self", ",", "solver", ")", ":", "\n", "        ", "if", "solver", ".", "has_posterior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "\n", "if", "solver", ".", "learn_recon_var", ":", "\n", "                ", "gen_log_var0", "=", "solver", ".", "gen_model", ".", "log_recon_var", ".", "item", "(", ")", "\n", "if", "solver", ".", "has_prior_model", ":", "\n", "                    ", "prior_log_var0", "=", "solver", ".", "prior_model", ".", "log_recon_var", ".", "item", "(", ")", "\n", "\n", "", "", "metrics0", "=", "solver", ".", "gen_step", "(", "grid_type", "=", "'poster'", ")", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "_", ",", "metrics1", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'poster'", ")", "\n", "assert", "metrics1", "[", "'loss'", "]", "<", "metrics0", "[", "'loss'", "]", ",", "'loss did not decrease'", "\n", "\n", "if", "solver", ".", "has_prior_model", ":", "\n", "                ", "assert", "(", "\n", "metrics1", "[", "'recon2_loss'", "]", "+", "metrics1", "[", "'kldiv2_loss'", "]", "<", "metrics0", "[", "'recon2_loss'", "]", "+", "metrics0", "[", "'kldiv2_loss'", "]", "\n", ")", ",", "'prior model loss did not decrease'", "\n", "\n", "", "if", "solver", ".", "learn_recon_var", ":", "\n", "                ", "assert", "(", "\n", "solver", ".", "gen_model", ".", "log_recon_var", "!=", "gen_log_var0", "\n", ")", ",", "'gen log_recon_var did not change'", "\n", "if", "solver", ".", "has_prior_model", ":", "\n", "                    ", "assert", "(", "\n", "solver", ".", "prior_model", ".", "log_recon_var", "!=", "prior_log_var0", "\n", ")", ",", "'prior log_recon_var did not change'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_gen_step_prior": [[381, 389], ["liGAN.set_random_seed", "solver.gen_step", "liGAN.set_random_seed", "solver.gen_forward"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_forward"], ["", "", "", "", "def", "test_solver_gen_step_prior", "(", "self", ",", "solver", ")", ":", "\n", "        ", "if", "solver", ".", "has_prior_phase", "and", "solver", ".", "loss_fn", ".", "has_prior_loss", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "metrics0", "=", "solver", ".", "gen_step", "(", "grid_type", "=", "'prior'", ")", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "_", ",", "metrics1", "=", "solver", ".", "gen_forward", "(", "data", ",", "grid_type", "=", "'prior'", ")", "\n", "assert", "metrics1", "[", "'loss'", "]", "<", "metrics0", "[", "'loss'", "]", ",", "'loss did not decrease'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_step_real": [[390, 398], ["liGAN.set_random_seed", "solver.disc_step", "liGAN.set_random_seed", "solver.disc_forward"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward"], ["", "", "def", "test_solver_disc_step_real", "(", "self", ",", "solver", ")", ":", "\n", "        ", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "metrics0", "=", "solver", ".", "disc_step", "(", "grid_type", "=", "'real'", ")", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "_", ",", "metrics1", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'real'", ")", "\n", "assert", "metrics1", "[", "'loss'", "]", "<", "metrics0", "[", "'loss'", "]", ",", "'loss did not decrease'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_step_poster": [[399, 407], ["liGAN.set_random_seed", "solver.disc_step", "liGAN.set_random_seed", "solver.disc_forward"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward"], ["", "", "def", "test_solver_disc_step_poster", "(", "self", ",", "solver", ")", ":", "\n", "        ", "if", "solver", ".", "has_disc_model", "and", "solver", ".", "has_posterior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "metrics0", "=", "solver", ".", "disc_step", "(", "grid_type", "=", "'poster'", ")", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "_", ",", "metrics1", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'poster'", ")", "\n", "assert", "metrics1", "[", "'loss'", "]", "<", "metrics0", "[", "'loss'", "]", ",", "'loss did not decrease'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_disc_step_prior": [[408, 416], ["liGAN.set_random_seed", "solver.disc_step", "liGAN.set_random_seed", "solver.disc_forward"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.common.set_random_seed", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_forward"], ["", "", "def", "test_solver_disc_step_prior", "(", "self", ",", "solver", ")", ":", "\n", "        ", "if", "solver", ".", "has_disc_model", "and", "solver", ".", "has_prior_phase", ":", "\n", "            ", "data", "=", "solver", ".", "train_data", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "metrics0", "=", "solver", ".", "disc_step", "(", "grid_type", "=", "'prior'", ")", "\n", "liGAN", ".", "set_random_seed", "(", "0", ")", "\n", "_", ",", "metrics1", "=", "solver", ".", "disc_forward", "(", "data", ",", "grid_type", "=", "'prior'", ")", "\n", "assert", "metrics1", "[", "'loss'", "]", "<", "metrics0", "[", "'loss'", "]", ",", "'loss did not decrease'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_state": [[419, 460], ["test_training.param_norm", "solver.save_state", "test_training.param_norm", "solver.load_state", "test_training.param_norm", "numpy.isclose", "solver.gen_step", "int", "int", "abs", "solver.state_dict", "solver.disc_step", "solver.gen_step", "solver.disc_step"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.param_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.save_state", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.param_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.load_state", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.param_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.gen_step", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.disc_step"], ["", "", "def", "test_solver_state", "(", "self", ",", "solver", ")", ":", "\n", "\n", "        ", "assert", "solver", ".", "gen_iter", "==", "0", "\n", "assert", "solver", ".", "disc_iter", "==", "0", "\n", "assert", "solver", ".", "prior_iter", "==", "0", "\n", "init_norm", "=", "param_norm", "(", "solver", ")", "\n", "solver", ".", "save_state", "(", ")", "\n", "\n", "if", "solver", ".", "has_posterior_phase", ":", "\n", "            ", "solver", ".", "gen_step", "(", "grid_type", "=", "'poster'", ")", "\n", "if", "solver", ".", "has_disc_model", ":", "\n", "                ", "solver", ".", "disc_step", "(", "grid_type", "=", "'poster'", ")", "\n", "\n", "", "", "elif", "solver", ".", "has_prior_phase", ":", "\n", "            ", "solver", ".", "gen_step", "(", "grid_type", "=", "'prior'", ")", "\n", "if", "solver", ".", "has_disc_model", ":", "\n", "                ", "solver", ".", "disc_step", "(", "grid_type", "=", "'prior'", ")", "\n", "\n", "", "", "assert", "solver", ".", "gen_iter", "==", "1", "\n", "assert", "solver", ".", "disc_iter", "==", "int", "(", "solver", ".", "has_disc_model", ")", "\n", "assert", "solver", ".", "prior_iter", "==", "int", "(", "solver", ".", "has_prior_model", ")", "\n", "\n", "norm", "=", "param_norm", "(", "solver", ")", "\n", "norm_diff", "=", "(", "norm", "-", "init_norm", ")", "\n", "assert", "abs", "(", "norm_diff", ")", ">", "1e-4", ",", "'same params after update ({:.4f})'", ".", "format", "(", "norm_diff", ")", "\n", "\n", "solver", ".", "load_state", "(", "cont_iter", "=", "0", ")", "\n", "assert", "solver", ".", "gen_iter", "==", "0", "\n", "assert", "solver", ".", "disc_iter", "==", "0", "\n", "assert", "solver", ".", "prior_iter", "==", "0", "\n", "norm", "=", "param_norm", "(", "solver", ")", "\n", "norm_diff", "=", "(", "norm", "-", "init_norm", ")", "\n", "assert", "isclose", "(", "norm", ",", "init_norm", ")", ",", "'different params after load ({:.2f})'", ".", "format", "(", "norm_diff", ")", "\n", "\n", "if", "solver", ".", "learn_recon_var", ":", "\n", "            ", "state_dict", "=", "solver", ".", "state_dict", "(", ")", "\n", "assert", "'gen_model.log_recon_var'", "in", "state_dict", "\n", "if", "solver", ".", "has_prior_model", ":", "\n", "                ", "assert", "'prior_model.log_recon_var'", "in", "state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_test_disc": [[463, 469], ["len", "solver.test_model", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_model"], ["", "", "", "def", "test_solver_test_disc", "(", "self", ",", "solver", ")", ":", "\n", "        ", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "0", "\n", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "solver", ".", "test_model", "(", "n_batches", "=", "10", ",", "model_type", "=", "'disc'", ",", "fit_atoms", "=", "False", ")", "\n", "assert", "solver", ".", "disc_iter", "==", "0", "\n", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_test_gen": [[470, 475], ["solver.test_model", "len", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_model"], ["", "", "def", "test_solver_test_gen", "(", "self", ",", "solver", ")", ":", "\n", "        ", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "0", "\n", "solver", ".", "test_model", "(", "n_batches", "=", "10", ",", "model_type", "=", "'gen'", ",", "fit_atoms", "=", "False", ")", "\n", "assert", "solver", ".", "gen_iter", "==", "0", "\n", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_test_gen_fit": [[476, 485], ["solver.test_model", "print", "len", "len", "solver.metrics.transpose"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_model", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_solver_test_gen_fit", "(", "self", ",", "solver", ")", ":", "\n", "        ", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "0", "\n", "solver", ".", "test_model", "(", "n_batches", "=", "1", ",", "model_type", "=", "'gen'", ",", "fit_atoms", "=", "True", ")", "\n", "assert", "solver", ".", "gen_iter", "==", "0", "\n", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "1", "\n", "print", "(", "solver", ".", "metrics", ".", "transpose", "(", ")", ")", "\n", "assert", "'lig_gen_fit_n_atoms'", "in", "solver", ".", "metrics", ".", "columns", "\n", "if", "solver", ".", "has_posterior_phase", ":", "\n", "            ", "assert", "'lig_gen_fit_type_diff'", "in", "solver", ".", "metrics", ".", "columns", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_test_models": [[486, 492], ["solver.test_models", "len", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.test_models"], ["", "", "def", "test_solver_test_models", "(", "self", ",", "solver", ")", ":", "\n", "        ", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "0", "\n", "solver", ".", "test_models", "(", "n_batches", "=", "10", ",", "fit_atoms", "=", "False", ")", "\n", "assert", "solver", ".", "gen_iter", "==", "0", "\n", "assert", "solver", ".", "disc_iter", "==", "0", "\n", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "10", "+", "solver", ".", "has_disc_model", "*", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_train_gen": [[495, 498], ["solver.train_model", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_model"], ["", "def", "test_solver_train_gen", "(", "self", ",", "solver", ")", ":", "\n", "        ", "solver", ".", "train_model", "(", "n_iters", "=", "10", ",", "model_type", "=", "'gen'", ")", "\n", "assert", "solver", ".", "gen_iter", "==", "len", "(", "solver", ".", "metrics", ")", "==", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_train_disc": [[499, 503], ["solver.train_model", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_model"], ["", "def", "test_solver_train_disc", "(", "self", ",", "solver", ")", ":", "\n", "        ", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "solver", ".", "train_model", "(", "n_iters", "=", "10", ",", "model_type", "=", "'disc'", ")", "\n", "assert", "solver", ".", "disc_iter", "==", "len", "(", "solver", ".", "metrics", ")", "==", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_train_models": [[504, 513], ["solver.train_models", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_models"], ["", "", "def", "test_solver_train_models", "(", "self", ",", "solver", ")", ":", "\n", "        ", "solver", ".", "train_models", "(", "update", "=", "True", ")", "\n", "assert", "not", "solver", ".", "balance", "\n", "assert", "solver", ".", "gen_iter", "==", "solver", ".", "n_gen_train_iters", "\n", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "assert", "solver", ".", "disc_iter", "==", "solver", ".", "n_disc_train_iters", "\n", "", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "(", "\n", "solver", ".", "n_gen_train_iters", "+", "\n", "(", "solver", ".", "n_disc_train_iters", "if", "solver", ".", "has_disc_model", "else", "0", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_train_models_noup": [[515, 525], ["solver.train_models", "print", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_models", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_solver_train_models_noup", "(", "self", ",", "solver", ")", ":", "\n", "        ", "solver", ".", "train_models", "(", "update", "=", "False", ")", "\n", "assert", "not", "solver", ".", "balance", "\n", "assert", "solver", ".", "gen_iter", "==", "0", "\n", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "assert", "solver", ".", "disc_iter", "==", "0", "\n", "", "print", "(", "solver", ".", "metrics", ")", "\n", "assert", "len", "(", "solver", ".", "metrics", ")", "==", "(", "\n", "solver", ".", "n_gen_train_iters", "+", "\n", "(", "solver", ".", "n_disc_train_iters", "if", "solver", ".", "has_disc_model", "else", "0", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.TestGenerativeSolver.test_solver_train_and_test": [[527, 572], ["time.time", "solver.train_and_test", "print", "solver.metrics.reset_index", "os.path.isfile", "os.path.isfile", "os.path.isfile", "[].mean", "[].mean", "int", "time.time", "len", "len", "os.path.isfile", "os.path.isfile"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.training.GenerativeSolver.train_and_test", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_solver_train_and_test", "(", "self", ",", "solver", ",", "train_params", ")", ":", "\n", "\n", "        ", "max_iter", "=", "train_params", "[", "'max_iter'", "]", "\n", "test_interval", "=", "train_params", "[", "'test_interval'", "]", "\n", "n_test_batches", "=", "train_params", "[", "'n_test_batches'", "]", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "solver", ".", "train_and_test", "(", "**", "train_params", ")", "\n", "t_delta", "=", "time", ".", "time", "(", ")", "-", "t0", "\n", "\n", "print", "(", "solver", ".", "metrics", ")", "\n", "assert", "solver", ".", "gen_iter", "==", "max_iter", "\n", "\n", "m", "=", "solver", ".", "metrics", ".", "reset_index", "(", ")", "\n", "n_train_rows", "=", "(", "max_iter", "+", "1", ")", "*", "(", "\n", "solver", ".", "n_gen_train_iters", "+", "(", "\n", "solver", ".", "n_disc_train_iters", "if", "solver", ".", "has_disc_model", "else", "0", "\n", ")", "\n", ")", "\n", "n_test_rows", "=", "(", "max_iter", "//", "test_interval", "+", "1", ")", "*", "(", "\n", "n_test_batches", "+", "(", "n_test_batches", "if", "solver", ".", "has_disc_model", "else", "0", ")", "\n", ")", "\n", "assert", "len", "(", "m", "[", "m", "[", "'data_phase'", "]", "==", "'train'", "]", ")", "==", "n_train_rows", ",", "'unexpected num trains'", "\n", "assert", "len", "(", "m", "[", "m", "[", "'data_phase'", "]", "==", "'test'", "]", ")", "==", "n_test_rows", ",", "'unexpected num tests'", "\n", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "solver", ".", "metrics_file", ")", ",", "solver", ".", "metrics_file", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "solver", ".", "gen_model_state_file", ")", ",", "solver", ".", "gen_model_state_file", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "solver", ".", "gen_solver_state_file", ")", ",", "solver", ".", "gen_solver_state_file", "\n", "if", "solver", ".", "has_disc_model", ":", "\n", "            ", "assert", "os", ".", "path", ".", "isfile", "(", "solver", ".", "disc_model_state_file", ")", ",", "solver", ".", "disc_model_state_file", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "solver", ".", "disc_solver_state_file", ")", ",", "solver", ".", "disc_solver_state_file", "\n", "\n", "", "loss_i", "=", "m", "[", "m", "[", "'iteration'", "]", "==", "0", "]", "[", "'loss'", "]", ".", "mean", "(", ")", "\n", "loss_f", "=", "m", "[", "m", "[", "'iteration'", "]", "==", "max_iter", "]", "[", "'loss'", "]", ".", "mean", "(", ")", "\n", "assert", "loss_f", "<", "loss_i", ",", "'loss did not decrease'", "\n", "\n", "t_per_iter", "=", "t_delta", "/", "max_iter", "\n", "iters_per_day", "=", "(", "24", "*", "60", "*", "60", ")", "/", "t_per_iter", "\n", "k_iters_per_day", "=", "int", "(", "iters_per_day", "//", "1000", ")", "\n", "assert", "k_iters_per_day", ">=", "100", ",", "'too slow ({:d}k iters/day)'", ".", "format", "(", "\n", "k_iters_per_day", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.param_norm": [[15, 23], ["model.parameters", "test_training.solver", "test_training.solver", "test_training.solver"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver"], ["def", "param_norm", "(", "model", ")", ":", "\n", "    ", "'''\n    Compute the L2 norm of model parameters.\n    '''", "\n", "norm2", "=", "0", "\n", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "norm2", "+=", "(", "p", ".", "data", "**", "2", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "return", "norm2", "**", "(", "1", "/", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.train_params": [[25, 34], ["dict"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "train_params", "(", ")", ":", "\n", "    ", "return", "dict", "(", "\n", "max_iter", "=", "10", ",", "\n", "test_interval", "=", "10", ",", "\n", "n_test_batches", "=", "1", ",", "\n", "fit_interval", "=", "0", ",", "\n", "norm_interval", "=", "10", ",", "\n", "save_interval", "=", "10", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver": [[37, 112], ["pytest.fixture", "getattr", "getattr.", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "\n", "#'CVAE', 'CVAE2',", "\n", "'AE'", ",", "'CE'", ",", "'VAE'", ",", "'CVAE'", ",", "'GAN'", ",", "'CGAN'", ",", "\n", "'VAEGAN'", ",", "'CVAEGAN'", ",", "'VAE2'", ",", "'CVAE2'", "\n", "]", ")", "\n", "def", "solver", "(", "request", ")", ":", "\n", "    ", "solver_type", "=", "getattr", "(", "liGAN", ".", "training", ",", "request", ".", "param", "+", "'Solver'", ")", "\n", "return", "solver_type", "(", "\n", "data_kws", "=", "dict", "(", "\n", "train_file", "=", "'data/it2_tt_0_lowrmsd_valid_mols_head1.types'", ",", "\n", "test_file", "=", "'data/it2_tt_0_lowrmsd_valid_mols_head1.types'", ",", "\n", "data_root", "=", "'data/crossdock2020'", ",", "\n", "batch_size", "=", "1", ",", "\n", "rec_typer", "=", "'oadc-1.0'", ",", "\n", "lig_typer", "=", "'oadc-1.0'", ",", "\n", "resolution", "=", "1.0", ",", "\n", "grid_size", "=", "16", ",", "\n", "shuffle", "=", "False", ",", "\n", "random_rotation", "=", "True", ",", "\n", "random_translation", "=", "0", ",", "\n", "diff_cond_transform", "=", "True", ",", "\n", "cache_structs", "=", "False", ",", "\n", ")", ",", "\n", "gen_model_kws", "=", "dict", "(", "\n", "n_filters", "=", "8", ",", "\n", "n_levels", "=", "4", ",", "\n", "conv_per_level", "=", "1", ",", "\n", "spectral_norm", "=", "1", ",", "\n", "n_latent", "=", "128", ",", "\n", "init_conv_pool", "=", "False", ",", "\n", "skip_connect", "=", "solver_type", ".", "gen_model_type", ".", "has_conditional_encoder", ",", "\n", ")", ",", "\n", "disc_model_kws", "=", "dict", "(", "\n", "n_filters", "=", "8", ",", "\n", "n_levels", "=", "4", ",", "\n", "conv_per_level", "=", "1", ",", "\n", "spectral_norm", "=", "1", ",", "\n", "n_output", "=", "1", ",", "\n", ")", ",", "\n", "prior_model_kws", "=", "dict", "(", "\n", "n_h_layers", "=", "1", ",", "\n", "n_h_units", "=", "96", ",", "\n", "n_latent", "=", "64", ",", "\n", ")", ",", "\n", "loss_fn_kws", "=", "dict", "(", "\n", "types", "=", "dict", "(", "recon_loss", "=", "'2'", ",", "gan_loss", "=", "'w'", ")", ",", "\n", "weights", "=", "dict", "(", "\n", "kldiv_loss", "=", "1.0", ",", "\n", "recon_loss", "=", "1.0", ",", "\n", "gan_loss", "=", "1.0", "*", "solver_type", ".", "has_disc_model", ",", "\n", "steric_loss", "=", "1.0", "*", "solver_type", ".", "gen_model_type", ".", "has_conditional_encoder", ",", "\n", "kldiv2_loss", "=", "1.0", "*", "solver_type", ".", "has_prior_model", ",", "\n", "recon2_loss", "=", "1.0", "*", "solver_type", ".", "has_prior_model", ",", "\n", ")", ",", "\n", "learn_recon_var", "=", "True", ",", "\n", ")", ",", "\n", "gen_optim_kws", "=", "dict", "(", "\n", "type", "=", "'RMSprop'", ",", "\n", "lr", "=", "1e-5", ",", "\n", "n_train_iters", "=", "1", ",", "\n", ")", ",", "\n", "disc_optim_kws", "=", "dict", "(", "\n", "type", "=", "'RMSprop'", ",", "\n", "lr", "=", "5e-5", ",", "\n", "n_train_iters", "=", "2", ",", "\n", ")", ",", "\n", "prior_optim_kws", "=", "dict", "(", "\n", "type", "=", "'RMSprop'", ",", "\n", "lr", "=", "1e-5", ",", "\n", ")", ",", "\n", "atom_fitting_kws", "=", "dict", "(", ")", ",", "\n", "bond_adding_kws", "=", "dict", "(", ")", ",", "\n", "out_prefix", "=", "'tests/output/TEST_'", "+", "request", ".", "param", ",", "\n", "device", "=", "'cuda'", ",", "\n", "debug", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_grad": [[115, 120], ["liGAN.models.compute_grad_norm", "liGAN.models.compute_grad_norm"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.compute_grad_norm", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.models.compute_grad_norm"], ["", "def", "check_grad", "(", "model", ",", "expect_grad", ",", "name", ")", ":", "\n", "    ", "if", "expect_grad", ":", "\n", "        ", "assert", "param_grad_norm", "(", "model", ")", ">", "0", ",", "name", "+", "' grad is zero'", "\n", "", "else", ":", "\n", "        ", "assert", "param_grad_norm", "(", "model", ")", "==", "0", ",", "name", "+", "' grad not zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_solver_grad": [[122, 151], ["test_training.check_grad", "test_training.check_grad", "test_training.check_grad", "test_training.check_grad", "test_training.check_grad", "test_training.solver", "test_training.solver", "test_training.solver", "test_training.solver", "test_training.solver", "test_training.solver", "test_training.solver"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.check_grad", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_training.solver"], ["", "", "def", "check_solver_grad", "(", "\n", "solver", ",", "\n", "expect_disc_grad", ",", "\n", "expect_dec_grad", ",", "\n", "expect_inp_enc_grad", ",", "\n", "expect_cond_enc_grad", ",", "\n", "expect_prior_grad", ",", "\n", ")", ":", "\n", "    ", "if", "solver", ".", "has_disc_model", ":", "\n", "        ", "check_grad", "(", "solver", ".", "disc_model", ",", "expect_disc_grad", ",", "'disc'", ")", "\n", "\n", "", "check_grad", "(", "solver", ".", "gen_model", ".", "decoder", ",", "expect_dec_grad", ",", "'decoder'", ")", "\n", "\n", "if", "solver", ".", "gen_model", ".", "has_input_encoder", ":", "\n", "        ", "check_grad", "(", "\n", "solver", ".", "gen_model", ".", "input_encoder", ",", "\n", "expect_inp_enc_grad", ",", "\n", "name", "=", "'input encoder'", "\n", ")", "\n", "\n", "", "if", "solver", ".", "gen_model", ".", "has_conditional_encoder", ":", "\n", "        ", "check_grad", "(", "\n", "solver", ".", "gen_model", ".", "conditional_encoder", ",", "\n", "expect_cond_enc_grad", ",", "\n", "name", "=", "'cond encoder'", "\n", ")", "\n", "\n", "", "if", "solver", ".", "has_prior_model", ":", "\n", "        ", "check_grad", "(", "solver", ".", "prior_model", ",", "expect_prior_grad", ",", "'prior'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.prop_funcs": [[48, 51], ["pytest.fixture"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "'oad'", ",", "'oadc'", ",", "'on'", ",", "'oh'", "]", ")", "\n", "def", "prop_funcs", "(", "self", ",", "request", ")", ":", "\n", "        ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.typer": [[52, 55], ["liGAN.atom_types.AtomTyper.get_typer"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer"], ["", "@", "pytest", ".", "fixture", "\n", "def", "typer", "(", "self", ",", "prop_funcs", ")", ":", "\n", "        ", "return", "AtomTyper", ".", "get_typer", "(", "prop_funcs", ",", "radius_func", "=", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.rec_typer": [[56, 60], ["liGAN.atom_types.AtomTyper.get_typer"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer"], ["", "@", "pytest", ".", "fixture", "\n", "def", "rec_typer", "(", "self", ",", "prop_funcs", ")", ":", "\n", "        ", "return", "AtomTyper", ".", "get_typer", "(", "\n", "prop_funcs", ",", "radius_func", "=", "1.0", ",", "rec", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.mol": [[62, 69], ["pytest.fixture", "mol.AddHydrogens", "liGAN.read_ob_mols_from_file", "os.path.splitext", "os.path.basename"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "test_sdf_files", ")", "\n", "def", "mol", "(", "self", ",", "request", ")", ":", "\n", "        ", "sdf_file", "=", "request", ".", "param", "\n", "mol", "=", "mols", ".", "read_ob_mols_from_file", "(", "sdf_file", ",", "'sdf'", ")", "[", "0", "]", "\n", "mol", ".", "AddHydrogens", "(", ")", "# this is needed to determine donor/acceptor", "\n", "mol", ".", "name", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "sdf_file", ")", ")", "[", "0", "]", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.test_typer_defaults": [[70, 73], ["None"], "methods", ["None"], ["", "def", "test_typer_defaults", "(", "self", ")", ":", "\n", "        ", "assert", "AtomTyper", ".", "rec_elem_range", "==", "[", "6", ",", "7", ",", "8", ",", "11", ",", "12", ",", "15", ",", "16", ",", "17", ",", "19", ",", "20", ",", "30", "]", "\n", "assert", "AtomTyper", ".", "lig_elem_range", "==", "[", "5", ",", "6", ",", "7", ",", "8", ",", "9", ",", "15", ",", "16", ",", "17", ",", "35", ",", "53", ",", "26", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.test_typer_init": [[74, 82], ["len", "len", "len"], "methods", ["None"], ["", "def", "test_typer_init", "(", "self", ",", "typer", ")", ":", "\n", "        ", "assert", "len", "(", "typer", ".", "prop_funcs", ")", ">", "1", "\n", "assert", "len", "(", "typer", ".", "prop_funcs", ")", "==", "len", "(", "typer", ".", "prop_ranges", ")", "\n", "assert", "typer", ".", "prop_funcs", "[", "0", "]", "==", "Atom", ".", "atomic_num", "\n", "assert", "typer", ".", "explicit_h", "==", "(", "1", "in", "typer", ".", "elem_range", ")", "\n", "assert", "typer", ".", "elem_range", "[", "typer", ".", "explicit_h", ":", "]", "==", "typer", ".", "lig_elem_range", "\n", "for", "f", "in", "typer", ".", "prop_funcs", ":", "\n", "            ", "assert", "typer", ".", "prop_funcs", "[", "typer", ".", "prop_idx", "[", "f", "]", "]", "==", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.test_rec_typer_init": [[83, 85], ["None"], "methods", ["None"], ["", "", "def", "test_rec_typer_init", "(", "self", ",", "rec_typer", ")", ":", "\n", "        ", "assert", "rec_typer", ".", "elem_range", "[", "rec_typer", ".", "explicit_h", ":", "]", "==", "rec_typer", ".", "rec_elem_range", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.test_typer_names": [[86, 88], ["print", "list", "typer.get_type_names"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_names"], ["", "def", "test_typer_names", "(", "self", ",", "typer", ")", ":", "\n", "        ", "print", "(", "list", "(", "typer", ".", "get_type_names", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.test_typer_type_vec": [[89, 104], ["enumerate", "liGAN.atom_types.ob.OBMolAtomIter", "torch.as_tensor", "zip", "typer.get_type_vector", "torch.as_tensor.bool().any", "f", "len", "print", "torch.as_tensor.bool", "bool", "prop_vec.argmax().item", "prop_vec.argmax"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_vector", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_typer_type_vec", "(", "self", ",", "typer", ",", "mol", ")", ":", "\n", "        ", "for", "i", ",", "atom", "in", "enumerate", "(", "ob", ".", "OBMolAtomIter", "(", "mol", ")", ")", ":", "\n", "            ", "type_vec", "=", "torch", ".", "as_tensor", "(", "typer", ".", "get_type_vector", "(", "atom", ")", ")", "\n", "if", "not", "type_vec", ".", "bool", "(", ")", ".", "any", "(", ")", ":", "\n", "                ", "continue", "\n", "", "for", "f", ",", "r", "in", "zip", "(", "typer", ".", "prop_funcs", ",", "typer", ".", "prop_ranges", ")", ":", "\n", "                ", "prop_vec", "=", "type_vec", "[", "typer", ".", "type_vec_idx", "[", "f", "]", "]", "\n", "value", "=", "f", "(", "atom", ")", "\n", "if", "len", "(", "r", ")", ">", "1", ":", "# one-hot vector", "\n", "                    ", "if", "value", "not", "in", "r", ":", "\n", "                        ", "value", "=", "r", "[", "-", "1", "]", "\n", "", "assert", "r", "[", "prop_vec", ".", "argmax", "(", ")", ".", "item", "(", ")", "]", "==", "value", "\n", "", "else", ":", "# binary", "\n", "                    ", "print", "(", "f", ",", "r", ",", "prop_vec", ",", "value", ")", "\n", "assert", "bool", "(", "prop_vec", ">", "0.5", ")", "==", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.test_typer_atom_type": [[105, 121], ["enumerate", "liGAN.atom_types.ob.OBMolAtomIter", "torch.as_tensor", "typer.get_atom_type", "typer.get_type_vector", "torch.as_tensor.bool().any", "torch.as_tensor.bool", "getattr", "f"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_atom_type", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_type_vector"], ["", "", "", "", "def", "test_typer_atom_type", "(", "self", ",", "typer", ",", "mol", ")", ":", "\n", "        ", "for", "i", ",", "atom", "in", "enumerate", "(", "ob", ".", "OBMolAtomIter", "(", "mol", ")", ")", ":", "\n", "            ", "type_vec", "=", "torch", ".", "as_tensor", "(", "typer", ".", "get_type_vector", "(", "atom", ")", ")", "\n", "if", "not", "type_vec", ".", "bool", "(", ")", ".", "any", "(", ")", ":", "\n", "                ", "continue", "\n", "", "atom_type", "=", "typer", ".", "get_atom_type", "(", "type_vec", ")", "\n", "for", "f", "in", "[", "\n", "Atom", ".", "atomic_num", ",", "\n", "Atom", ".", "aromatic", ",", "\n", "Atom", ".", "h_acceptor", ",", "\n", "Atom", ".", "h_donor", ",", "\n", "Atom", ".", "h_count", ",", "\n", "Atom", ".", "formal_charge", ",", "\n", "]", ":", "\n", "                ", "if", "f", "in", "typer", ":", "\n", "                    ", "assert", "getattr", "(", "atom_type", ",", "f", ".", "__name__", ")", "==", "f", "(", "atom", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.TestAtomTyper.test_typer_coord_set": [[122, 132], ["typer.make_struct", "molgrid.CoordinateSet", "liGAN.atom_structs.AtomStruct.from_coord_set"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_coord_set"], ["", "", "", "", "def", "test_typer_coord_set", "(", "self", ",", "typer", ",", "mol", ")", ":", "\n", "        ", "struct1", "=", "typer", ".", "make_struct", "(", "mol", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "coord_set", "=", "molgrid", ".", "CoordinateSet", "(", "mol", ",", "typer", ")", "\n", "struct2", "=", "AtomStruct", ".", "from_coord_set", "(", "coord_set", ",", "typer", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "assert", "(", "struct1", ".", "coords", "==", "struct2", ".", "coords", ")", ".", "all", "(", ")", ",", "'different coords'", "\n", "assert", "(", "struct1", ".", "types", "==", "struct2", ".", "types", ")", ".", "all", "(", ")", ",", "'different types'", "\n", "assert", "struct1", ".", "typer", "==", "struct2", ".", "typer", ",", "'different typers'", "\n", "assert", "struct1", ".", "atom_types", "==", "struct2", ".", "atom_types", ",", "'different atom types'", "\n", "assert", "(", "struct1", ".", "atomic_radii", "==", "struct2", ".", "atomic_radii", ")", ".", "all", "(", ")", ",", "'different atomic radii'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_types.test_make_one_hot": [[24, 44], ["pytest.raises", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot", "liGAN.atom_types.make_one_hot"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.make_one_hot"], ["def", "test_make_one_hot", "(", ")", ":", "\n", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "assert", "make_one_hot", "(", "0", ",", "[", "]", ")", "==", "[", "]", "\n", "\n", "# binary type", "\n", "", "assert", "make_one_hot", "(", "0", ",", "[", "0", "]", ")", "==", "[", "1", "]", "\n", "assert", "make_one_hot", "(", "0", ",", "[", "1", "]", ")", "==", "[", "0", "]", "\n", "assert", "make_one_hot", "(", "1", ",", "[", "0", "]", ")", "==", "[", "0", "]", "\n", "assert", "make_one_hot", "(", "1", ",", "[", "1", "]", ")", "==", "[", "1", "]", "\n", "assert", "make_one_hot", "(", "2", ",", "[", "0", "]", ")", "==", "[", "0", "]", "\n", "assert", "make_one_hot", "(", "2", ",", "[", "1", "]", ")", "==", "[", "0", "]", "\n", "\n", "# argmax type, with dummy value", "\n", "assert", "make_one_hot", "(", "0", ",", "[", "0", ",", "1", "]", ")", "==", "[", "1", ",", "0", "]", "\n", "assert", "make_one_hot", "(", "1", ",", "[", "0", ",", "1", "]", ")", "==", "[", "0", ",", "1", "]", "\n", "assert", "make_one_hot", "(", "2", ",", "[", "0", ",", "1", "]", ")", "==", "[", "0", ",", "1", "]", "\n", "assert", "make_one_hot", "(", "0", ",", "[", "0", ",", "2", "]", ")", "==", "[", "1", ",", "0", "]", "\n", "assert", "make_one_hot", "(", "1", ",", "[", "0", ",", "2", "]", ")", "==", "[", "0", ",", "1", "]", "\n", "assert", "make_one_hot", "(", "2", ",", "[", "0", ",", "2", "]", ")", "==", "[", "0", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.water": [[11, 16], ["mol.AddHydrogens", "liGAN.molecules.read_ob_mols_from_file"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["    ", "@", "pytest", ".", "fixture", "\n", "def", "water", "(", "self", ")", ":", "\n", "        ", "mol", "=", "mols", ".", "read_ob_mols_from_file", "(", "'tests/input/O_2_0_0.sdf'", ",", "'sdf'", ")", "[", "0", "]", "\n", "mol", ".", "AddHydrogens", "(", ")", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.ammonia": [[17, 22], ["mol.AddHydrogens", "liGAN.molecules.read_ob_mols_from_file"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["", "@", "pytest", ".", "fixture", "\n", "def", "ammonia", "(", "self", ")", ":", "\n", "        ", "mol", "=", "mols", ".", "read_ob_mols_from_file", "(", "'tests/input/N_2_0_0.sdf'", ",", "'sdf'", ")", "[", "0", "]", "\n", "mol", ".", "AddHydrogens", "(", ")", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.methane": [[23, 28], ["mol.AddHydrogens", "liGAN.molecules.read_ob_mols_from_file"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["", "@", "pytest", ".", "fixture", "\n", "def", "methane", "(", "self", ")", ":", "\n", "        ", "mol", "=", "mols", ".", "read_ob_mols_from_file", "(", "'tests/input/C_2_0_0.sdf'", ",", "'sdf'", ")", "[", "0", "]", "\n", "mol", ".", "AddHydrogens", "(", ")", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.benzene": [[29, 34], ["mol.AddHydrogens", "liGAN.molecules.read_ob_mols_from_file"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["", "@", "pytest", ".", "fixture", "\n", "def", "benzene", "(", "self", ")", ":", "\n", "        ", "mol", "=", "mols", ".", "read_ob_mols_from_file", "(", "'tests/input/benzene.sdf'", ",", "'sdf'", ")", "[", "0", "]", "\n", "mol", ".", "AddHydrogens", "(", ")", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.test_water_imp_hs": [[35, 80], ["water.DeleteHydrogens", "list", "water.AddHydrogens", "water.HasHydrogensAdded", "water.SetHydrogensAdded", "water.AddHydrogens", "water.HasNonZeroCoords", "water.NumAtoms", "water.HasHydrogensAdded", "liGAN.molecules.ob.OBMolAtomIter", "atom.SetImplicitHCount", "water.NumAtoms", "atom.SetImplicitHCount", "water.NumAtoms", "atom.GetImplicitHCount", "atom.GetExplicitValence", "atom.GetTotalValence", "atom.GetExplicitDegree", "atom.GetHvyDegree", "atom.GetTotalDegree", "liGAN.molecules.ob.GetMaxBonds", "atom.GetImplicitHCount", "atom.GetExplicitValence", "atom.GetTotalValence", "atom.GetExplicitDegree", "atom.GetHvyDegree", "atom.GetTotalDegree", "liGAN.molecules.ob.GetMaxBonds", "atom.GetImplicitHCount", "atom.GetExplicitValence", "atom.GetTotalValence", "atom.GetExplicitDegree", "atom.GetHvyDegree", "atom.GetTotalDegree", "liGAN.molecules.ob.GetMaxBonds", "atom.GetAtomicNum", "atom.GetAtomicNum", "atom.GetAtomicNum"], "methods", ["None"], ["", "def", "test_water_imp_hs", "(", "self", ",", "water", ")", ":", "\n", "\n", "        ", "water", ".", "DeleteHydrogens", "(", ")", "\n", "assert", "water", ".", "NumAtoms", "(", ")", "==", "1", "\n", "assert", "not", "water", ".", "HasHydrogensAdded", "(", ")", "\n", "atoms", "=", "list", "(", "ob", ".", "OBMolAtomIter", "(", "water", ")", ")", "\n", "\n", "for", "atom", "in", "atoms", ":", "\n", "            ", "assert", "atom", ".", "GetImplicitHCount", "(", ")", "==", "2", "\n", "assert", "atom", ".", "GetExplicitValence", "(", ")", "==", "0", "\n", "assert", "atom", ".", "GetTotalValence", "(", ")", "==", "2", "\n", "assert", "atom", ".", "GetExplicitDegree", "(", ")", "==", "0", "\n", "assert", "atom", ".", "GetHvyDegree", "(", ")", "==", "0", "\n", "assert", "atom", ".", "GetTotalDegree", "(", ")", "==", "2", "\n", "assert", "ob", ".", "GetMaxBonds", "(", "atom", ".", "GetAtomicNum", "(", ")", ")", "==", "2", "\n", "atom", ".", "SetImplicitHCount", "(", "1", ")", "\n", "\n", "", "water", ".", "AddHydrogens", "(", ")", "\n", "assert", "water", ".", "NumAtoms", "(", ")", "==", "2", "\n", "assert", "water", ".", "HasHydrogensAdded", "(", ")", "\n", "\n", "for", "atom", "in", "atoms", ":", "\n", "            ", "assert", "atom", ".", "GetImplicitHCount", "(", ")", "==", "0", "\n", "assert", "atom", ".", "GetExplicitValence", "(", ")", "==", "1", "\n", "assert", "atom", ".", "GetTotalValence", "(", ")", "==", "1", "\n", "assert", "atom", ".", "GetExplicitDegree", "(", ")", "==", "1", "\n", "assert", "atom", ".", "GetHvyDegree", "(", ")", "==", "0", "\n", "assert", "atom", ".", "GetTotalDegree", "(", ")", "==", "1", "\n", "assert", "ob", ".", "GetMaxBonds", "(", "atom", ".", "GetAtomicNum", "(", ")", ")", "==", "2", "\n", "atom", ".", "SetImplicitHCount", "(", "1", ")", "\n", "\n", "", "water", ".", "SetHydrogensAdded", "(", "False", ")", "\n", "water", ".", "AddHydrogens", "(", ")", "\n", "assert", "water", ".", "NumAtoms", "(", ")", "==", "3", "\n", "\n", "for", "atom", "in", "atoms", ":", "\n", "            ", "assert", "atom", ".", "GetImplicitHCount", "(", ")", "==", "0", "\n", "assert", "atom", ".", "GetExplicitValence", "(", ")", "==", "2", "\n", "assert", "atom", ".", "GetTotalValence", "(", ")", "==", "2", "\n", "assert", "atom", ".", "GetExplicitDegree", "(", ")", "==", "2", "\n", "assert", "atom", ".", "GetHvyDegree", "(", ")", "==", "0", "\n", "assert", "atom", ".", "GetTotalDegree", "(", ")", "==", "2", "\n", "assert", "ob", ".", "GetMaxBonds", "(", "atom", ".", "GetAtomicNum", "(", ")", ")", "==", "2", "\n", "\n", "", "assert", "water", ".", "HasNonZeroCoords", "(", ")", ",", "'all zero coords'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.test_benzene_imp_hs": [[81, 99], ["benzene.DeleteHydrogens", "list", "benzene.AddHydrogens", "benzene.HasNonZeroCoords", "liGAN.molecules.ob.OBMolAtomIter", "atom.GetImplicitHCount", "atom.GetExplicitValence", "atom.GetTotalValence", "liGAN.molecules.ob.GetMaxBonds", "atom.GetImplicitHCount", "atom.GetExplicitValence", "atom.GetTotalValence", "liGAN.molecules.ob.GetMaxBonds", "atom.GetAtomicNum", "atom.GetAtomicNum"], "methods", ["None"], ["", "def", "test_benzene_imp_hs", "(", "self", ",", "benzene", ")", ":", "\n", "\n", "        ", "benzene", ".", "DeleteHydrogens", "(", ")", "\n", "atoms", "=", "list", "(", "ob", ".", "OBMolAtomIter", "(", "benzene", ")", ")", "\n", "for", "atom", "in", "atoms", ":", "\n", "            ", "assert", "atom", ".", "GetImplicitHCount", "(", ")", "==", "1", "\n", "assert", "atom", ".", "GetExplicitValence", "(", ")", "==", "3", "\n", "assert", "atom", ".", "GetTotalValence", "(", ")", "==", "4", "\n", "assert", "ob", ".", "GetMaxBonds", "(", "atom", ".", "GetAtomicNum", "(", ")", ")", "==", "4", "\n", "\n", "", "benzene", ".", "AddHydrogens", "(", ")", "\n", "for", "atom", "in", "atoms", ":", "\n", "            ", "assert", "atom", ".", "GetImplicitHCount", "(", ")", "==", "0", "\n", "assert", "atom", ".", "GetExplicitValence", "(", ")", "==", "4", "\n", "assert", "atom", ".", "GetTotalValence", "(", ")", "==", "4", "\n", "assert", "ob", ".", "GetMaxBonds", "(", "atom", ".", "GetAtomicNum", "(", ")", ")", "==", "4", "\n", "\n", "", "assert", "benzene", ".", "HasNonZeroCoords", "(", ")", ",", "'all zero coords'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.test_water_to_smi": [[100, 103], ["liGAN.molecules.ob_mol_to_smi().rstrip", "liGAN.molecules.ob_mol_to_smi"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_smi"], ["", "def", "test_water_to_smi", "(", "self", ",", "water", ")", ":", "\n", "        ", "smi", "=", "mols", ".", "ob_mol_to_smi", "(", "water", ",", "'cnh'", ")", ".", "rstrip", "(", ")", "\n", "assert", "smi", "==", "'[H]O[H]'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.test_ammonia_to_smi": [[104, 107], ["liGAN.molecules.ob_mol_to_smi().rstrip", "liGAN.molecules.ob_mol_to_smi"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_smi"], ["", "def", "test_ammonia_to_smi", "(", "self", ",", "ammonia", ")", ":", "\n", "        ", "smi", "=", "mols", ".", "ob_mol_to_smi", "(", "ammonia", ",", "'cnh'", ")", ".", "rstrip", "(", ")", "\n", "assert", "smi", "==", "'[H]N([H])[H]'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.test_methane_to_smi": [[108, 111], ["liGAN.molecules.ob_mol_to_smi().rstrip", "liGAN.molecules.ob_mol_to_smi"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_smi"], ["", "def", "test_methane_to_smi", "(", "self", ",", "methane", ")", ":", "\n", "        ", "smi", "=", "mols", ".", "ob_mol_to_smi", "(", "methane", ",", "'cnh'", ")", ".", "rstrip", "(", ")", "\n", "assert", "smi", "==", "'[H]C([H])([H])[H]'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_molecules.TestOBMol.test_benzene_to_smi": [[112, 115], ["liGAN.molecules.ob_mol_to_smi().rstrip", "liGAN.molecules.ob_mol_to_smi"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_smi"], ["", "def", "test_benzene_to_smi", "(", "self", ",", "benzene", ")", ":", "\n", "        ", "smi", "=", "mols", ".", "ob_mol_to_smi", "(", "benzene", ",", "'cnh'", ")", ".", "rstrip", "(", ")", "\n", "assert", "smi", "==", "'[H]c1c([H])c([H])c(c(c1[H])[H])[H]'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.data": [[16, 39], ["pytest.fixture", "liGAN.data.AtomGridData"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "\n", "'data/test_pockets/AROK_MYCTU_1_176_0/fixed_input_1zyu_A_rec_mutants.types'", ",", "\n", "'data/test_pockets/AROK_MYCTU_1_176_0/fixed_cond_1zyu_A_rec_mutants.types'", "\n", "]", ")", "\n", "def", "data", "(", "self", ",", "request", ")", ":", "\n", "        ", "data_file", "=", "request", ".", "param", "\n", "diff_cond_transform", "=", "False", "\n", "diff_cond_structs", "=", "True", "\n", "return", "AtomGridData", "(", "\n", "data_file", "=", "data_file", ",", "\n", "data_root", "=", "'data/crossdock2020'", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "rec_typer", "=", "'oadc-1.0'", ",", "\n", "lig_typer", "=", "'oadc-1.0'", ",", "\n", "resolution", "=", "0.5", ",", "\n", "dimension", "=", "23.5", ",", "\n", "shuffle", "=", "True", ",", "\n", "random_rotation", "=", "True", ",", "\n", "random_translation", "=", "True", ",", "\n", "diff_cond_transform", "=", "diff_cond_transform", ",", "\n", "diff_cond_structs", "=", "diff_cond_structs", ",", "\n", "cache_structs", "=", "True", ",", "\n", "debug", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.data2": [[41, 54], ["liGAN.data.AtomGridData"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "data2", "(", "self", ")", ":", "\n", "        ", "return", "AtomGridData", "(", "\n", "data_file", "=", "'data/two_atoms.types'", ",", "\n", "data_root", "=", "'tests/input'", ",", "\n", "batch_size", "=", "2", ",", "\n", "rec_typer", "=", "'oadc-1.0'", ",", "\n", "lig_typer", "=", "'oadc-1.0'", ",", "\n", "resolution", "=", "0.5", ",", "\n", "dimension", "=", "23.5", ",", "\n", "shuffle", "=", "False", ",", "\n", "debug", "=", "False", ",", "\n", "diff_cond_transform", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_init": [[56, 62], ["len"], "methods", ["None"], ["", "def", "test_data_init", "(", "self", ",", "data", ")", ":", "\n", "        ", "assert", "data", ".", "n_rec_channels", "==", "(", "data", ".", "rec_typer", ".", "n_types", "if", "data", ".", "rec_typer", "else", "0", ")", "\n", "assert", "data", ".", "n_lig_channels", "==", "data", ".", "lig_typer", ".", "n_types", "\n", "assert", "data", ".", "ex_provider", "\n", "assert", "data", ".", "grid_maker", "\n", "assert", "len", "(", "data", ")", "==", "25", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_find_real_mol": [[63, 72], ["data.ex_provider.next_batch", "data.find_real_mol", "data.find_real_mol", "os.path.isfile", "os.path.isfile"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.find_real_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.find_real_mol"], ["", "def", "test_data_find_real_mol", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "\n", "for", "ex", "in", "data", ".", "ex_provider", ".", "next_batch", "(", "16", ")", ":", "\n", "            ", "rec_src", "=", "ex", ".", "coord_sets", "[", "0", "]", ".", "src", "\n", "lig_src", "=", "ex", ".", "coord_sets", "[", "1", "]", ".", "src", "\n", "rec_file", ",", "rec_name", ",", "rec_idx", "=", "data", ".", "find_real_mol", "(", "rec_src", ",", "'.pdb'", ")", "\n", "lig_file", ",", "lig_name", ",", "lig_idx", "=", "data", ".", "find_real_mol", "(", "lig_src", ",", "'.sdf'", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "rec_file", ")", ",", "rec_file", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "lig_file", ")", ",", "lig_file", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_forward": [[73, 109], ["data.forward", "len", "len", "len", "len", "numpy.isclose", "numpy.isclose", "input_grids.norm().cpu", "cond_grids.norm().cpu", "input_grids.norm", "cond_grids.norm"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "", "def", "test_data_forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "input_grids", ",", "cond_grids", ",", "input_structs", ",", "cond_structs", ",", "transforms", ",", "labels", "=", "data", ".", "forward", "(", ")", "\n", "input_rec_structs", ",", "input_lig_structs", "=", "input_structs", "\n", "cond_rec_structs", ",", "cond_lig_structs", "=", "cond_structs", "\n", "input_transforms", ",", "cond_transforms", "=", "transforms", "\n", "\n", "assert", "input_grids", ".", "shape", "==", "(", "batch_size", ",", "data", ".", "n_channels", ")", "+", "(", "data", ".", "grid_size", ",", ")", "*", "3", "\n", "assert", "cond_grids", ".", "shape", "==", "(", "batch_size", ",", "data", ".", "n_channels", ")", "+", "(", "data", ".", "grid_size", ",", ")", "*", "3", "\n", "\n", "assert", "len", "(", "input_rec_structs", ")", "==", "batch_size", "\n", "assert", "len", "(", "input_lig_structs", ")", "==", "batch_size", "\n", "assert", "len", "(", "cond_rec_structs", ")", "==", "batch_size", "\n", "assert", "len", "(", "cond_lig_structs", ")", "==", "batch_size", "\n", "assert", "labels", ".", "shape", "==", "(", "batch_size", ",", ")", "\n", "\n", "assert", "not", "isclose", "(", "0", ",", "input_grids", ".", "norm", "(", ")", ".", "cpu", "(", ")", ")", "\n", "assert", "not", "isclose", "(", "0", ",", "cond_grids", ".", "norm", "(", ")", ".", "cpu", "(", ")", ")", "\n", "\n", "if", "data", ".", "diff_cond_structs", ":", "\n", "            ", "assert", "cond_rec_structs", "!=", "input_rec_structs", "\n", "assert", "cond_lig_structs", "!=", "input_lig_structs", "\n", "", "else", ":", "\n", "            ", "assert", "cond_rec_structs", "==", "input_rec_structs", "\n", "assert", "cond_lig_structs", "==", "input_lig_structs", "\n", "\n", "", "if", "data", ".", "diff_cond_transform", ":", "\n", "            ", "assert", "cond_transforms", "!=", "input_transforms", "\n", "", "else", ":", "\n", "            ", "assert", "cond_transforms", "==", "input_transforms", "\n", "\n", "", "if", "data", ".", "diff_cond_structs", "or", "data", ".", "diff_cond_transform", ":", "\n", "            ", "assert", "(", "cond_grids", "!=", "input_grids", ")", ".", "any", "(", ")", "\n", "", "else", ":", "\n", "            ", "assert", "(", "cond_grids", "==", "input_grids", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_split": [[110, 117], ["data.forward", "data.split_channels"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.data.AtomGridData.split_channels"], ["", "", "def", "test_data_split", "(", "self", ",", "data", ")", ":", "\n", "        ", "input_grids", ",", "cond_grids", ",", "_", ",", "_", ",", "_", ",", "_", "=", "data", ".", "forward", "(", ")", "\n", "rec_grids", ",", "lig_grids", "=", "data", ".", "split_channels", "(", "input_grids", ")", "\n", "assert", "rec_grids", ".", "shape", "==", "(", "batch_size", ",", "data", ".", "n_lig_channels", ")", "+", "(", "data", ".", "grid_size", ",", ")", "*", "3", "\n", "assert", "lig_grids", ".", "shape", "==", "(", "batch_size", ",", "data", ".", "n_rec_channels", ")", "+", "(", "data", ".", "grid_size", ",", ")", "*", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_no_transform": [[118, 132], ["range", "data2.forward", "input_grids.norm"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "test_data_no_transform", "(", "self", ",", "data2", ")", ":", "\n", "        ", "data2", ".", "random_rotation", "=", "False", "\n", "data2", ".", "random_translation", "=", "0.0", "\n", "n_trials", "=", "100", "\n", "\n", "diff", "=", "0.0", "\n", "for", "i", "in", "range", "(", "n_trials", ")", ":", "\n", "            ", "input_grids", ",", "cond_grids", "=", "data2", ".", "forward", "(", ")", "[", ":", "2", "]", "\n", "assert", "input_grids", ".", "norm", "(", ")", ">", "0", ",", "'initial grids are empty'", "\n", "diff", "+=", "(", "input_grids", "[", "0", "]", "-", "input_grids", "[", "1", "]", ")", ".", "abs", "(", ")", ".", "max", "(", ")", "\n", "\n", "", "diff", "/=", "n_trials", "\n", "assert", "diff", "<", "0.1", ",", "'no-transform grids are different ({:.2f})'", ".", "format", "(", "diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_rand_rotate": [[133, 147], ["range", "data2.forward", "input_grids.norm"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "test_data_rand_rotate", "(", "self", ",", "data2", ")", ":", "\n", "        ", "data2", ".", "random_rotation", "=", "True", "\n", "data2", ".", "random_translation", "=", "0.0", "\n", "n_trials", "=", "100", "\n", "\n", "diff", "=", "0.0", "\n", "for", "i", "in", "range", "(", "n_trials", ")", ":", "\n", "            ", "input_grids", ",", "cond_grids", "=", "data2", ".", "forward", "(", ")", "[", ":", "2", "]", "\n", "assert", "input_grids", ".", "norm", "(", ")", ">", "0", ",", "'rotated grids are empty'", "\n", "diff", "+=", "(", "input_grids", "[", "0", "]", "-", "input_grids", "[", "1", "]", ")", ".", "abs", "(", ")", ".", "max", "(", ")", "\n", "\n", "", "diff", "/=", "n_trials", "\n", "assert", "diff", ">", "0.5", ",", "'rotated grids are the same ({:.2f})'", ".", "format", "(", "diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_rand_translate": [[148, 162], ["range", "data2.forward", "input_grids.norm"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "test_data_rand_translate", "(", "self", ",", "data2", ")", ":", "\n", "        ", "data2", ".", "random_rotation", "=", "False", "\n", "data2", ".", "random_translation", "=", "2.0", "\n", "n_trials", "=", "100", "\n", "\n", "diff", "=", "0.0", "\n", "for", "i", "in", "range", "(", "n_trials", ")", ":", "\n", "            ", "input_grids", ",", "cond_grids", "=", "data2", ".", "forward", "(", ")", "[", ":", "2", "]", "\n", "assert", "input_grids", ".", "norm", "(", ")", ">", "0", ",", "'translated grids are empty'", "\n", "diff", "+=", "(", "input_grids", "[", "0", "]", "-", "input_grids", "[", "1", "]", ")", ".", "abs", "(", ")", ".", "max", "(", ")", "\n", "\n", "", "diff", "/=", "n_trials", "\n", "assert", "diff", ">", "0.5", ",", "'translated grids are the same ({:.2f})'", ".", "format", "(", "diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_diff_cond_transform": [[163, 179], ["range", "data2.forward", "input_grids.norm", "cond_grids.norm"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "test_data_diff_cond_transform", "(", "self", ",", "data2", ")", ":", "\n", "        ", "data2", ".", "random_rotation", "=", "True", "\n", "data2", ".", "random_translation", "=", "2.0", "\n", "n_trials", "=", "100", "\n", "\n", "diff", "=", "0.0", "\n", "for", "i", "in", "range", "(", "n_trials", ")", ":", "\n", "            ", "input_grids", ",", "cond_grids", "=", "data2", ".", "forward", "(", ")", "[", ":", "2", "]", "\n", "assert", "input_grids", ".", "norm", "(", ")", ">", "0", ",", "'input grids are empty'", "\n", "assert", "cond_grids", ".", "norm", "(", ")", ">", "0", ",", "'conditional grids are empty'", "\n", "diff", "+=", "(", "input_grids", "[", "0", "]", "-", "cond_grids", "[", "0", "]", ")", ".", "abs", "(", ")", ".", "max", "(", ")", "\n", "diff", "+=", "(", "input_grids", "[", "1", "]", "-", "cond_grids", "[", "1", "]", ")", ".", "abs", "(", ")", ".", "max", "(", ")", "\n", "\n", "", "diff", "/=", "(", "2", "*", "n_trials", ")", "\n", "assert", "diff", ">", "0.5", ",", "'input and conditional grids are the same ({:.2f})'", ".", "format", "(", "diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_consecutive": [[180, 197], ["range", "data2.forward", "input_grids.norm"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "test_data_consecutive", "(", "self", ",", "data2", ")", ":", "\n", "        ", "data2", ".", "random_rotation", "=", "True", "\n", "data2", ".", "random_translation", "=", "2.0", "\n", "n_trials", "=", "100", "\n", "\n", "diff", "=", "0.0", "\n", "for", "i", "in", "range", "(", "n_trials", ")", ":", "\n", "            ", "input_grids", "=", "data2", ".", "forward", "(", ")", "[", "0", "]", "\n", "assert", "input_grids", ".", "norm", "(", ")", ">", "0", ",", "'input grids are empty'", "\n", "if", "i", ">", "0", ":", "\n", "                ", "diff", "+=", "(", "input_grids", "[", "0", "]", "-", "last_input_grids", "[", "0", "]", ")", ".", "abs", "(", ")", ".", "max", "(", ")", "\n", "diff", "+=", "(", "input_grids", "[", "1", "]", "-", "last_input_grids", "[", "1", "]", ")", ".", "abs", "(", ")", ".", "max", "(", ")", "\n", "", "last_input_grids", "=", "input_grids", "\n", "\n", "", "diff", "/=", "(", "2", "*", "(", "n_trials", "-", "1", ")", ")", "\n", "assert", "diff", ">", "0.5", ",", "'consecutive input grids are the same ({:.2f})'", ".", "format", "(", "diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestAtomGridData.test_data_benchmark": [[198, 208], ["time.time", "range", "data.forward", "time.time"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "test_data_benchmark", "(", "self", ",", "data", ")", ":", "\n", "        ", "n_trials", "=", "100", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "for", "i", "in", "range", "(", "n_trials", ")", ":", "\n", "            ", "data", ".", "forward", "(", ")", "\n", "\n", "", "t_delta", "=", "time", ".", "time", "(", ")", "-", "t0", "\n", "t_delta", "/=", "n_trials", "\n", "assert", "t_delta", "<", "1", ",", "'too slow ({:.2f}s / batch)'", ".", "format", "(", "t_delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestMolDataset.data": [[212, 246], ["pytest.fixture", "liGAN.atom_types.AtomTyper.get_typer", "liGAN.atom_types.AtomTyper.get_typer", "liGAN.data.MolDataset", "liGAN.data.molgrid.ExampleProvider", "liGAN.data.molgrid.ExampleProvider.populate"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "False", ",", "True", "]", ")", "\n", "def", "data", "(", "self", ",", "request", ")", ":", "\n", "        ", "use_dataset", "=", "request", ".", "param", "\n", "\n", "data_root", "=", "os", ".", "environ", "[", "'CROSSDOCK_ROOT'", "]", "\n", "data_file", "=", "'data/it2_tt_0_lowrmsd_valid_mols_test0_100.types'", "\n", "\n", "lig_typer", "=", "AtomTyper", ".", "get_typer", "(", "'oadc'", ",", "1.0", ",", "rec", "=", "False", ")", "\n", "rec_typer", "=", "AtomTyper", ".", "get_typer", "(", "'oadc'", ",", "1.0", ",", "rec", "=", "True", ")", "\n", "\n", "if", "use_dataset", ":", "\n", "            ", "data", "=", "MolDataset", "(", "\n", "rec_typer", ",", "lig_typer", ",", "\n", "data_root", "=", "data_root", ",", "\n", "data_file", "=", "data_file", ",", "\n", "verbose", "=", "True", ",", "\n", ")", "\n", "#data = torch.utils.data.DataLoader(", "\n", "#    data, batch_size=batch_size, collate_fn=list, num_workers=0", "\n", "#)", "\n", "#data.rec_typer = rec_typer", "\n", "#data.lig_typer = lig_typer", "\n", "return", "data", "\n", "", "else", ":", "\n", "            ", "data", "=", "molgrid", ".", "ExampleProvider", "(", "\n", "rec_typer", ",", "lig_typer", ",", "\n", "data_root", "=", "data_root", ",", "\n", "cache_structs", "=", "True", ",", "\n", ")", "\n", "data", ".", "root_dir", "=", "data_root", "\n", "data", ".", "populate", "(", "data_file", ")", "\n", "data", ".", "rec_typer", "=", "rec_typer", "\n", "data", ".", "lig_typer", "=", "lig_typer", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_data.TestMolDataset.test_benchmark": [[247, 287], ["time.time", "isinstance", "data.size", "isinstance", "time.time", "data.next_batch", "len", "len", "liGAN.atom_structs.AtomStruct.from_coord_set", "liGAN.atom_structs.AtomStruct.from_coord_set", "data.rec_typer.make_struct", "data.lig_typer.make_struct", "print", "rec_mol.GetTitle", "lig_mol.GetTitle", "data.rec_typer.make_struct", "data.lig_typer.make_struct", "print", "rec_mol.GetTitle", "lig_mol.GetTitle"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.size", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_coord_set", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_structs.AtomStruct.from_coord_set", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "test_benchmark", "(", "self", ",", "data", ")", ":", "\n", "\n", "        ", "t_start", "=", "time", ".", "time", "(", ")", "\n", "if", "isinstance", "(", "data", ",", "molgrid", ".", "ExampleProvider", ")", ":", "\n", "            ", "n_rows", "=", "data", ".", "size", "(", ")", "\n", "i", "=", "0", "\n", "while", "i", "<", "n_rows", ":", "\n", "                ", "examples", "=", "data", ".", "next_batch", "(", "batch_size", ")", "\n", "for", "ex", "in", "examples", ":", "\n", "                    ", "rec_coord_set", ",", "lig_coord_set", "=", "ex", ".", "coord_sets", "\n", "rec_struct", "=", "AtomStruct", ".", "from_coord_set", "(", "\n", "rec_coord_set", ",", "data", ".", "rec_typer", ",", "data", ".", "root_dir", "\n", ")", "\n", "lig_struct", "=", "AtomStruct", ".", "from_coord_set", "(", "\n", "lig_coord_set", ",", "data", ".", "lig_typer", ",", "data", ".", "root_dir", "\n", ")", "\n", "", "i", "+=", "batch_size", "\n", "\n", "", "", "elif", "isinstance", "(", "data", ",", "MolDataset", ")", ":", "\n", "            ", "n_rows", "=", "len", "(", "data", ")", "\n", "for", "rec_mol", ",", "lig_mol", "in", "data", ":", "\n", "                ", "rec_struct", "=", "data", ".", "rec_typer", ".", "make_struct", "(", "rec_mol", ")", "\n", "lig_struct", "=", "data", ".", "lig_typer", ".", "make_struct", "(", "lig_mol", ")", "\n", "print", "(", "rec_mol", ".", "GetTitle", "(", ")", ",", "'\\t'", ",", "lig_mol", ".", "GetTitle", "(", ")", ")", "\n", "\n", "", "", "else", ":", "# data loader", "\n", "            ", "n_rows", "=", "len", "(", "data", ")", "\n", "i", "=", "0", "\n", "for", "batch", "in", "data", ":", "\n", "                ", "for", "rec_mol", ",", "lig_mol", "in", "batch", ":", "\n", "                    ", "rec_struct", "=", "data", ".", "rec_typer", ".", "make_struct", "(", "rec_mol", ")", "\n", "lig_struct", "=", "data", ".", "lig_typer", ".", "make_struct", "(", "lig_mol", ")", "\n", "print", "(", "rec_mol", ".", "GetTitle", "(", ")", ",", "'\\t'", ",", "lig_mol", ".", "GetTitle", "(", ")", ")", "\n", "", "i", "+=", "batch_size", "\n", "if", "i", ">", "n_rows", ":", "\n", "                    ", "break", "\n", "\n", "", "", "", "t_delta", "=", "time", ".", "time", "(", ")", "-", "t_start", "\n", "t_delta", "/=", "n_rows", "\n", "assert", "t_delta", "<", "0.05", ",", "'too slow ({:.4f}s / row)'", ".", "format", "(", "t_delta", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.typer": [[97, 122], ["pytest.fixture", "request.param.split", "liGAN.atom_types.AtomTyper.get_typer"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "\n", "#'-c',     '-v',", "\n", "#'oad-c',  'oad-v',", "\n", "#'oadc-c', 'oadc-v',", "\n", "#'on-c',   'on-v',", "\n", "#'oh-c', # different num atoms (missing Hs on all tests)", "\n", "#'oh-v', # different property counts (not all carbons aromatic, or aromatic Hs if using convolution)", "\n", "#'oadc-0.50',", "\n", "'oadc-1.00'", ",", "\n", "#'oadc-1.50',", "\n", "#'on-0.50',", "\n", "'on-1.00'", ",", "\n", "#'on-1.50',", "\n", "#'oh-0.50',", "\n", "'oh-1.00'", ",", "\n", "#'oh-1.50',", "\n", "]", ")", "\n", "def", "typer", "(", "self", ",", "request", ")", ":", "\n", "        ", "prop_funcs", ",", "radius_func", "=", "request", ".", "param", ".", "split", "(", "'-'", ")", "\n", "typer", "=", "AtomTyper", ".", "get_typer", "(", "\n", "prop_funcs", "=", "prop_funcs", ",", "\n", "radius_func", "=", "radius_func", ",", "\n", ")", "\n", "typer", ".", "name", "=", "request", ".", "param", "\n", "return", "typer", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.gridder": [[123, 133], ["molgrid.Coords2Grid", "molgrid.GridMaker", "liGAN.atom_grids.size_to_dimension"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.size_to_dimension"], ["", "@", "pytest", ".", "fixture", "\n", "def", "gridder", "(", "self", ")", ":", "\n", "        ", "resolution", "=", "0.5", "\n", "return", "Coords2Grid", "(", "GridMaker", "(", "\n", "resolution", "=", "resolution", ",", "\n", "dimension", "=", "size_to_dimension", "(", "\n", "size", "=", "32", ",", "\n", "resolution", "=", "resolution", "\n", ")", ",", "\n", "gaussian_radius_multiple", "=", "-", "1.5", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.fitter": [[135, 150], ["liGAN.atom_fitting.AtomFitter", "dict"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "fitter", "(", "self", ")", ":", "\n", "        ", "return", "AtomFitter", "(", "\n", "multi_atom", "=", "False", ",", "\n", "n_atoms_detect", "=", "1", ",", "\n", "apply_conv", "=", "False", ",", "\n", "threshold", "=", "0.1", ",", "\n", "peak_value", "=", "1.5", ",", "\n", "min_dist", "=", "0", ",", "\n", "apply_prop_conv", "=", "False", ",", "\n", "interm_gd_iters", "=", "10", ",", "\n", "final_gd_iters", "=", "100", ",", "\n", "gd_kwargs", "=", "dict", "(", "lr", "=", "0.1", ")", ",", "\n", "verbose", "=", "True", ",", "\n", "device", "=", "'cuda'", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.mol": [[152, 159], ["pytest.fixture", "liGAN.molecules.read_ob_mols_from_file", "mol.AddHydrogens", "os.path.splitext", "os.path.basename"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "test_sdf_files", ")", "\n", "def", "mol", "(", "self", ",", "request", ")", ":", "\n", "        ", "sdf_file", "=", "request", ".", "param", "\n", "mol", ",", "atoms", "=", "mols", ".", "read_ob_mols_from_file", "(", "sdf_file", ",", "'sdf'", ")", "\n", "mol", ".", "AddHydrogens", "(", ")", "# this is needed to determine donor/acceptor", "\n", "mol", ".", "name", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "sdf_file", ")", ")", "[", "0", "]", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.struct": [[160, 167], ["typer.make_struct"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct"], ["", "@", "pytest", ".", "fixture", "\n", "def", "struct", "(", "self", ",", "mol", ",", "typer", ")", ":", "\n", "        ", "return", "typer", ".", "make_struct", "(", "\n", "mol", ",", "\n", "name", "=", "'{}_{}'", ".", "format", "(", "mol", ".", "name", ",", "typer", ".", "name", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "'cuda'", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.grid": [[169, 188], ["tuple", "gridder.gmaker.set_dimension", "liGAN.atom_grids.AtomGrid", "liGAN.atom_grids.round_dimension", "float", "gridder.gmaker.get_resolution", "gridder.forward", "gridder.gmaker.get_resolution"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.round_dimension", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "@", "pytest", ".", "fixture", "\n", "def", "grid", "(", "self", ",", "struct", ",", "gridder", ")", ":", "\n", "\n", "# set the grid settings based on the size/location of structure", "\n", "        ", "gridder", ".", "center", "=", "tuple", "(", "float", "(", "v", ")", "for", "v", "in", "struct", ".", "center", ")", "\n", "gridder", ".", "gmaker", ".", "set_dimension", "(", "round_dimension", "(", "\n", "2", "*", "(", "struct", ".", "radius", "+", "2", ")", ",", "gridder", ".", "gmaker", ".", "get_resolution", "(", ")", "\n", ")", ")", "\n", "\n", "return", "AtomGrid", "(", "\n", "values", "=", "gridder", ".", "forward", "(", "\n", "coords", "=", "struct", ".", "coords", ",", "\n", "types", "=", "struct", ".", "types", ",", "\n", "radii", "=", "struct", ".", "atomic_radii", ",", "\n", ")", ",", "\n", "center", "=", "struct", ".", "center", ",", "\n", "resolution", "=", "gridder", ".", "gmaker", ".", "get_resolution", "(", ")", ",", "\n", "typer", "=", "struct", ".", "typer", ",", "\n", "src_struct", "=", "struct", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_init": [[190, 192], ["None"], "methods", ["None"], ["", "def", "test_init", "(", "self", ",", "fitter", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_gridder1": [[193, 198], ["grid.values.norm", "grid.values[].sum"], "methods", ["None"], ["", "def", "test_gridder1", "(", "self", ",", "grid", ")", ":", "\n", "        ", "assert", "grid", ".", "values", ".", "norm", "(", ")", ">", "0", ",", "'empty grid'", "\n", "for", "type_vec", "in", "grid", ".", "info", "[", "'src_struct'", "]", ".", "types", ":", "\n", "            ", "assert", "(", "grid", ".", "values", "[", "type_vec", ">", "0", "]", ".", "sum", "(", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", ">", "0", ")", ".", "all", "(", ")", ",", "'empty grid channel'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_gridder2": [[199, 213], ["fitter.grid_maker.set_dimension", "fitter.grid_maker.set_resolution", "tuple", "fitter.c2grid.forward", "float"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "", "def", "test_gridder2", "(", "self", ",", "struct", ",", "grid", ",", "fitter", ")", ":", "\n", "# NOTE if dimensions are slightly different, even if it's", "\n", "#   less than resolution so that the grid shapes are same,", "\n", "#   the grid values will be different due to centering", "\n", "        ", "fitter", ".", "grid_maker", ".", "set_dimension", "(", "grid", ".", "dimension", ")", "\n", "fitter", ".", "grid_maker", ".", "set_resolution", "(", "grid", ".", "resolution", ")", "\n", "fitter", ".", "c2grid", ".", "center", "=", "tuple", "(", "float", "(", "v", ")", "for", "v", "in", "struct", ".", "center", ")", "\n", "values", "=", "fitter", ".", "c2grid", ".", "forward", "(", "\n", "coords", "=", "struct", ".", "coords", ",", "\n", "types", "=", "struct", ".", "types", ",", "\n", "radii", "=", "struct", ".", "atomic_radii", "\n", ")", "\n", "assert", "values", ".", "shape", "==", "grid", ".", "values", ".", "shape", ",", "'different grid shapes'", "\n", "assert", "(", "values", "==", "grid", ".", "values", ")", ".", "all", "(", ")", ",", "'different grid values'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_init_kernel": [[214, 227], ["fitter.init_kernel", "fitter.init_kernel.norm", "fitter.init_kernel.flip", "fitter.init_kernel.flip", "fitter.init_kernel.flip"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.init_kernel"], ["", "def", "test_init_kernel", "(", "self", ",", "typer", ",", "fitter", ")", ":", "\n", "        ", "assert", "fitter", ".", "kernel", "is", "None", ",", "'kernel already initialized'", "\n", "kernel", "=", "fitter", ".", "init_kernel", "(", "resolution", "=", "0.5", ",", "typer", "=", "typer", ")", "\n", "assert", "kernel", ".", "shape", "[", "0", "]", "==", "typer", ".", "n_elem_types", ",", "'wrong num channels'", "\n", "assert", "kernel", ".", "shape", "[", "1", "]", "%", "2", "==", "1", ",", "'kernel size is even'", "\n", "assert", "kernel", ".", "norm", "(", ")", ">", "0", ",", "'empty kernel'", "\n", "assert", "(", "(", "kernel", "**", "2", ")", ".", "sum", "(", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", ">", "0", ")", ".", "all", "(", ")", ",", "'empty kernel channel'", "\n", "\n", "m", "=", "kernel", ".", "shape", "[", "1", "]", "//", "2", "# midpoint index", "\n", "assert", "(", "kernel", "[", ":", ",", "m", ",", "m", ",", "m", "]", "==", "1.0", ")", ".", "all", "(", ")", ",", "'kernel not centered'", "\n", "assert", "(", "kernel", "==", "kernel", ".", "flip", "(", "dims", "=", "(", "1", ",", ")", ")", ")", ".", "all", "(", ")", ",", "'kernel not symmetric'", "\n", "assert", "(", "kernel", "==", "kernel", ".", "flip", "(", "dims", "=", "(", "2", ",", ")", ")", ")", ".", "all", "(", ")", ",", "'kernel not symmetric'", "\n", "assert", "(", "kernel", "==", "kernel", ".", "flip", "(", "dims", "=", "(", "3", ",", ")", ")", ")", ".", "all", "(", ")", ",", "'kernel not symmetric'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_convolve": [[228, 244], ["fitter.convolve"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.convolve"], ["", "def", "test_convolve", "(", "self", ",", "fitter", ",", "grid", ")", ":", "\n", "        ", "grid_values", "=", "grid", ".", "elem_values", "\n", "conv_values", "=", "fitter", ".", "convolve", "(", "\n", "grid_values", ",", "grid", ".", "resolution", ",", "grid", ".", "typer", "\n", ")", "\n", "#kern_grid = make_grid(grid, fitter.kernel)", "\n", "#conv_grid = make_grid(grid, conv_values)", "\n", "#mol = grid.info['src_struct'].info['src_mol']", "\n", "#write_pymol([], grid, mol, kern_grid=kern_grid, conv_grid=conv_grid)", "\n", "\n", "dims", "=", "(", "1", ",", "2", ",", "3", ")", "# compute channel norms", "\n", "grid_norm2", "=", "(", "grid_values", "**", "2", ")", ".", "sum", "(", "dim", "=", "dims", ")", "**", "0.5", "\n", "conv_norm2", "=", "(", "conv_values", "**", "2", ")", ".", "sum", "(", "dim", "=", "dims", ")", "**", "0.5", "\n", "kern_norm2", "=", "(", "fitter", ".", "kernel", "**", "2", ")", ".", "sum", "(", "dim", "=", "dims", ")", "**", "0.5", "\n", "assert", "(", "conv_norm2", ">=", "grid_norm2", ")", ".", "all", "(", ")", ",", "'channel norm decreased'", "\n", "assert", "(", "conv_values", ">", "0.5", ")", ".", "any", "(", ")", ",", "'failed to detect atoms'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_apply_peak_value": [[245, 248], ["fitter.apply_peak_value"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_peak_value"], ["", "def", "test_apply_peak_value", "(", "self", ",", "fitter", ",", "grid", ")", ":", "\n", "        ", "peak_values", "=", "fitter", ".", "apply_peak_value", "(", "grid", ".", "elem_values", ")", "\n", "assert", "(", "peak_values", "<=", "fitter", ".", "peak_value", ")", ".", "all", "(", ")", ",", "'values above peak'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_sort_grid_points": [[249, 255], ["fitter.sort_grid_points"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.sort_grid_points"], ["", "def", "test_sort_grid_points", "(", "self", ",", "fitter", ",", "grid", ")", ":", "\n", "        ", "values", ",", "idx_xyz", ",", "idx_c", "=", "fitter", ".", "sort_grid_points", "(", "grid", ".", "elem_values", ")", "\n", "idx_x", ",", "idx_y", ",", "idx_z", "=", "idx_xyz", "[", ":", ",", "0", "]", ",", "idx_xyz", "[", ":", ",", "1", "]", ",", "idx_xyz", "[", ":", ",", "2", "]", "\n", "assert", "(", "values", "[", ":", "-", "1", "]", ">=", "values", "[", "1", ":", "]", ")", ".", "all", "(", ")", ",", "'values not sorted'", "\n", "assert", "(", "grid", ".", "elem_values", "[", "idx_c", ",", "idx_x", ",", "idx_y", ",", "idx_z", "]", "==", "values", ")", ".", "all", "(", ")", ",", "'values not unsorted'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_apply_threshold": [[256, 260], ["fitter.sort_grid_points", "fitter.apply_threshold"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.sort_grid_points", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_threshold"], ["", "def", "test_apply_threshold", "(", "self", ",", "fitter", ",", "grid", ")", ":", "\n", "        ", "values", ",", "idx_xyz", ",", "idx_c", "=", "fitter", ".", "sort_grid_points", "(", "grid", ".", "elem_values", ")", "\n", "values", ",", "idx_xyz", ",", "idx_c", "=", "fitter", ".", "apply_threshold", "(", "values", ",", "idx_xyz", ",", "idx_c", ")", "\n", "assert", "(", "values", ">", "fitter", ".", "threshold", ")", ".", "all", "(", ")", ",", "'values below threshold'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_suppress_non_max": [[261, 279], ["fitter.sort_grid_points", "fitter.apply_threshold", "grid.get_coords", "fitter.suppress_non_max", "fitter.suppress_non_max", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.sort_grid_points", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.apply_threshold", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.get_coords", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.suppress_non_max", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.suppress_non_max"], ["", "def", "test_suppress_non_max", "(", "self", ",", "fitter", ",", "grid", ")", ":", "\n", "        ", "values", ",", "idx_xyz", ",", "idx_c", "=", "fitter", ".", "sort_grid_points", "(", "grid", ".", "elem_values", ")", "\n", "values", ",", "idx_xyz", ",", "idx_c", "=", "fitter", ".", "apply_threshold", "(", "values", ",", "idx_xyz", ",", "idx_c", ")", "\n", "coords", "=", "grid", ".", "get_coords", "(", "idx_xyz", ")", "\n", "coords_mat", ",", "idx_xyz_mat", ",", "idx_c_mat", "=", "fitter", ".", "suppress_non_max", "(", "\n", "values", ",", "coords", ",", "idx_xyz", ",", "idx_c", ",", "grid", ".", "typer", ",", "matrix", "=", "True", "\n", ")", "\n", "coords_for", ",", "idx_xyz_for", ",", "idx_c_for", "=", "fitter", ".", "suppress_non_max", "(", "\n", "values", ",", "coords", ",", "idx_xyz", ",", "idx_c", ",", "grid", ".", "typer", ",", "matrix", "=", "False", "\n", ")", "\n", "assert", "len", "(", "coords_mat", ")", "==", "len", "(", "idx_c_mat", ")", "\n", "assert", "len", "(", "coords_for", ")", "==", "len", "(", "idx_c_for", ")", "\n", "assert", "len", "(", "coords_mat", ")", "==", "len", "(", "coords_for", ")", "\n", "assert", "len", "(", "coords_mat", ")", "<=", "len", "(", "coords", ")", "\n", "assert", "coords_mat", ".", "shape", "[", "1", "]", "==", "3", "\n", "assert", "coords_for", ".", "shape", "[", "1", "]", "==", "3", "\n", "assert", "(", "coords_mat", "==", "coords_for", ")", ".", "all", "(", ")", "\n", "assert", "(", "idx_c_mat", "==", "idx_c_for", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_detect_atoms": [[280, 293], ["fitter.detect_atoms", "liGAN.atom_structs.AtomStruct"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.detect_atoms"], ["", "def", "test_detect_atoms", "(", "self", ",", "fitter", ",", "grid", ")", ":", "\n", "        ", "fitter", ".", "n_atoms_detect", "=", "None", "\n", "coords", ",", "types", "=", "fitter", ".", "detect_atoms", "(", "grid", ")", "\n", "struct", "=", "AtomStruct", "(", "\n", "coords", ",", "types", ",", "grid", ".", "typer", ",", "\n", "src_mol", "=", "grid", ".", "info", "[", "'src_struct'", "]", ".", "info", "[", "'src_mol'", "]", "\n", ")", "\n", "#write_pymol([struct], grid, struct)", "\n", "if", "fitter", ".", "n_atoms_detect", "is", "not", "None", ":", "\n", "            ", "assert", "coords", ".", "shape", "==", "(", "fitter", ".", "n_atoms_detect", ",", "3", ")", "\n", "assert", "types", ".", "shape", "==", "(", "fitter", ".", "n_atoms_detect", ",", "grid", ".", "n_channels", ")", "\n", "", "assert", "coords", ".", "dtype", "==", "types", ".", "dtype", "==", "grid", ".", "dtype", "\n", "assert", "coords", ".", "device", "==", "types", ".", "device", "==", "grid", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.TestAtomFitter.test_fit_struct": [[294, 329], ["fitter.fit_struct", "all", "zip", "liGAN.metrics.compute_struct_rmsd", "sorted", "sorted", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_fitting.AtomFitter.fit_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.metrics.compute_struct_rmsd", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_fit_struct", "(", "self", ",", "fitter", ",", "grid", ")", ":", "\n", "\n", "        ", "struct", "=", "grid", ".", "info", "[", "'src_struct'", "]", "\n", "fit_struct", ",", "fit_grid", ",", "visited_structs", "=", "fitter", ".", "fit_struct", "(", "grid", ")", "\n", "\n", "#write_pymol(visited_structs, grid, struct, fit_grid=fit_grid)", "\n", "\n", "assert", "fit_struct", "==", "visited_structs", "[", "-", "1", "]", ",", "'final struct is not last visited'", "\n", "\n", "loss", "=", "fit_struct", ".", "info", "[", "'L2_loss'", "]", "\n", "assert", "all", "(", "loss", "<=", "s", ".", "info", "[", "'L2_loss'", "]", "for", "s", "in", "visited_structs", ")", ",", "'final struct loss is not best'", "\n", "\n", "n_atoms_diff", "=", "(", "struct", ".", "n_atoms", "-", "fit_struct", ".", "n_atoms", ")", "\n", "elem_diff", "=", "(", "struct", ".", "elem_counts", "-", "fit_struct", ".", "elem_counts", ")", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "prop_diff", "=", "(", "struct", ".", "prop_counts", "-", "fit_struct", ".", "prop_counts", ")", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "\n", "assert", "n_atoms_diff", "==", "0", ",", "'different num atoms ({})'", ".", "format", "(", "n_atoms_diff", ")", "\n", "\n", "for", "t1", ",", "t2", "in", "zip", "(", "\n", "sorted", "(", "struct", ".", "atom_types", ")", ",", "\n", "sorted", "(", "fit_struct", ".", "atom_types", ")", "\n", ")", ":", "\n", "            ", "print", "(", "t1", ",", "'\\t'", ",", "t2", ")", "\n", "\n", "", "assert", "elem_diff", "==", "0", ",", "'different element counts ({})'", ".", "format", "(", "elem_diff", ")", "\n", "\n", "rmsd", "=", "compute_struct_rmsd", "(", "struct", ",", "fit_struct", ",", "catch_exc", "=", "False", ")", "\n", "assert", "rmsd", "<", "0.5", ",", "'RMSD too high ({:.2f})'", ".", "format", "(", "rmsd", ")", "\n", "\n", "assert", "prop_diff", "==", "0", ",", "'different property counts ({})'", ".", "format", "(", "prop_diff", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.write_pymol": [[26, 66], ["open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "test_atom_fitting.write_structs", "test_atom_fitting.write_grid", "test_atom_fitting.write_grid", "test_atom_fitting.write_grid", "test_atom_fitting.write_grid"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.write_structs", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.write_grid", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.write_grid", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.write_grid", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.write_grid"], ["def", "write_pymol", "(", "\n", "visited_structs", ",", "grid", ",", "in_struct", ",", "\n", "fit_grid", "=", "None", ",", "\n", "kern_grid", "=", "None", ",", "\n", "conv_grid", "=", "None", "\n", ")", ":", "\n", "    ", "mol_name", "=", "in_struct", ".", "info", "[", "'name'", "]", "\n", "pymol_file", "=", "'tests/output/TEST_'", "+", "mol_name", "+", "'_fit.pymol'", "\n", "with", "open", "(", "pymol_file", ",", "'w'", ")", "as", "f", ":", "\n", "\n", "        ", "if", "visited_structs", ":", "\n", "            ", "f", ".", "write", "(", "'load {}\\n'", ".", "format", "(", "\n", "write_structs", "(", "\n", "visited_structs", ",", "in_struct", ".", "info", "[", "'src_mol'", "]", ",", "mol_name", "\n", ")", "\n", ")", ")", "\n", "\n", "", "f", ".", "write", "(", "'load_group {}, {}\\n'", ".", "format", "(", "\n", "*", "write_grid", "(", "grid", ",", "mol_name", ",", "'lig'", ")", "\n", ")", ")", "\n", "\n", "if", "fit_grid", "is", "not", "None", ":", "\n", "            ", "f", ".", "write", "(", "'load_group {}, {}\\n'", ".", "format", "(", "\n", "*", "write_grid", "(", "fit_grid", ",", "mol_name", ",", "'lig_fit'", ")", "\n", ")", ")", "\n", "\n", "", "if", "kern_grid", "is", "not", "None", ":", "\n", "            ", "f", ".", "write", "(", "'load_group {}, {}\\n'", ".", "format", "(", "\n", "*", "write_grid", "(", "kern_grid", ",", "mol_name", ",", "'lig_kern'", ")", "\n", ")", ")", "\n", "\n", "", "if", "conv_grid", "is", "not", "None", ":", "\n", "            ", "f", ".", "write", "(", "'load_group {}, {}\\n'", ".", "format", "(", "\n", "*", "write_grid", "(", "conv_grid", ",", "mol_name", ",", "'lig_conv'", ")", "\n", ")", ")", "\n", "\n", "", "f", ".", "write", "(", "'show_as nb_spheres\\n'", ")", "\n", "f", ".", "write", "(", "'show sticks\\n'", ")", "\n", "f", ".", "write", "(", "'util.cbam\\n'", ")", "\n", "f", ".", "write", "(", "'set_atom_level 0.5, job_name=TEST'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.write_grid": [[68, 72], ["grid.to_dx"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to_dx"], ["", "", "def", "write_grid", "(", "grid", ",", "mol_name", ",", "grid_type", ")", ":", "\n", "    ", "dx_prefix", "=", "'tests/output/TEST_{}_{}_0'", ".", "format", "(", "mol_name", ",", "grid_type", ")", "\n", "dx_files", "=", "grid", ".", "to_dx", "(", "dx_prefix", ")", "\n", "return", "dx_prefix", "+", "'*.dx'", ",", "dx_prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.make_grid": [[74, 79], ["torch.zeros", "grid.new_like", "torch.cat"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.new_like"], ["", "def", "make_grid", "(", "grid", ",", "elem_values", ")", ":", "\n", "    ", "nc", ",", "sz", "=", "grid", ".", "n_prop_channels", ",", "elem_values", ".", "shape", "[", "1", "]", "\n", "prop_values", "=", "torch", ".", "zeros", "(", "nc", ",", "sz", ",", "sz", ",", "sz", ",", "device", "=", "elem_values", ".", "device", ")", "\n", "return", "grid", ".", "new_like", "(", "\n", "values", "=", "torch", ".", "cat", "(", "[", "elem_values", ",", "prop_values", "]", ",", "dim", "=", "0", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.write_structs": [[82, 88], ["liGAN.molecules.write_ob_mols_to_sdf_file", "m.to_ob_mol"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_ob_mols_to_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol"], ["", "def", "write_structs", "(", "visited_structs", ",", "in_mol", ",", "mol_name", ")", ":", "\n", "    ", "visited_mols", "=", "[", "m", ".", "to_ob_mol", "(", ")", "[", "0", "]", "for", "m", "in", "visited_structs", "]", "\n", "write_mols", "=", "visited_mols", "+", "[", "in_mol", "]", "\n", "mol_file", "=", "'tests/output/TEST_{}_fit.sdf'", ".", "format", "(", "mol_name", ")", "\n", "mols", ".", "write_ob_mols_to_sdf_file", "(", "mol_file", ",", "write_mols", ")", "\n", "return", "mol_file", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_fitting.idx": [[90, 93], ["pytest.fixture", "range"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "range", "(", "10", ")", ")", "\n", "def", "idx", "(", "request", ")", ":", "\n", "    ", "return", "request", ".", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.train.loss_fn": [[40, 42], ["None"], "function", ["None"], ["", "except", "FileExistsError", ":", "\n", "                ", "pass", "\n", "", "config", "[", "'out_prefix'", "]", "=", "'wandb_output/'", "+", "wandb", ".", "run", ".", "id", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.typer": [[13, 19], ["liGAN.atom_types.AtomTyper"], "methods", ["None"], ["    ", "@", "pytest", ".", "fixture", "\n", "def", "typer", "(", "self", ")", ":", "\n", "        ", "return", "AtomTyper", "(", "\n", "prop_funcs", "=", "[", "Atom", ".", "atomic_num", "]", ",", "\n", "prop_ranges", "=", "[", "[", "8", "]", "]", ",", "\n", "radius_func", "=", "lambda", "x", ":", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.grid": [[21, 28], ["liGAN.atom_grids.AtomGrid", "numpy.random.randn", "numpy.zeros"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "grid", "(", "self", ",", "typer", ")", ":", "\n", "        ", "return", "AtomGrid", "(", "\n", "values", "=", "np", ".", "random", ".", "randn", "(", "1", ",", "5", ",", "5", ",", "5", ")", ",", "\n", "center", "=", "np", ".", "zeros", "(", "3", ")", ",", "\n", "resolution", "=", "1.0", ",", "\n", "typer", "=", "typer", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.test_init": [[30, 33], ["None"], "methods", ["None"], ["", "def", "test_init", "(", "self", ",", "grid", ")", ":", "\n", "        ", "assert", "grid", ".", "n_channels", "==", "1", ",", "'incorrect num channels'", "\n", "assert", "grid", ".", "size", "==", "5", ",", "'incorrect grid size'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.test_dimension": [[34, 36], ["None"], "methods", ["None"], ["", "def", "test_dimension", "(", "self", ",", "grid", ")", ":", "\n", "        ", "assert", "grid", ".", "dimension", "==", "4.0", ",", "'incorrect grid dimension'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.test_new_like": [[37, 45], ["grid.new_like", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.new_like"], ["", "def", "test_new_like", "(", "self", ",", "grid", ")", ":", "\n", "        ", "new_grid", "=", "grid", ".", "new_like", "(", "\n", "values", "=", "np", ".", "random", ".", "randn", "(", "1", ",", "5", ",", "5", ",", "5", ")", "\n", ")", "\n", "assert", "new_grid", ".", "values", "is", "not", "grid", ".", "values", ",", "'same grid values'", "\n", "assert", "new_grid", ".", "center", "is", "grid", ".", "center", ",", "'different center'", "\n", "assert", "new_grid", ".", "resolution", "is", "grid", ".", "resolution", ",", "'different resolution'", "\n", "assert", "new_grid", ".", "typer", "is", "grid", ".", "typer", ",", "'different atom typer'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.test_to_dx": [[46, 51], ["grid.to_dx", "print"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to_dx", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_to_dx", "(", "self", ",", "grid", ")", ":", "\n", "        ", "dx_files", "=", "grid", ".", "to_dx", "(", "'tests/output/TEST'", ")", "\n", "print", "(", "dx_files", ")", "\n", "assert", "dx_files", "==", "[", "'tests/output/TEST_atomic_num=8.dx'", "]", ",", "'incorrect file names'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.test_from_dx": [[52, 56], ["liGAN.atom_grids.AtomGrid.from_dx"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.from_dx"], ["", "def", "test_from_dx", "(", "self", ",", "typer", ")", ":", "\n", "        ", "grid", "=", "AtomGrid", ".", "from_dx", "(", "'tests/output/TEST'", ",", "typer", ")", "\n", "assert", "grid", ".", "n_channels", "==", "1", ",", "'incorrect num channels'", "\n", "assert", "grid", ".", "size", "==", "5", ",", "'incorrect grid size'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.test_to_and_from_dx": [[57, 64], ["grid.to_dx", "liGAN.atom_grids.AtomGrid.from_dx", "print", "print", "print", "numpy.allclose"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.to_dx", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.from_dx", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_to_and_from_dx", "(", "self", ",", "grid", ")", ":", "\n", "        ", "dx_files", "=", "grid", ".", "to_dx", "(", "'tests/output/TEST'", ")", "\n", "new_grid", "=", "AtomGrid", ".", "from_dx", "(", "'tests/output/TEST'", ",", "grid", ".", "typer", ")", "\n", "print", "(", "grid", ".", "values", ")", "\n", "print", "(", ")", "\n", "print", "(", "new_grid", ".", "values", ")", "\n", "assert", "allclose", "(", "new_grid", ".", "values", ",", "grid", ".", "values", ")", ",", "'different values'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.test_get_coords": [[65, 71], ["torch.arange", "liGAN.atom_grids.unravel_index", "grid.get_coords", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.unravel_index", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_grids.AtomGrid.get_coords"], ["", "def", "test_get_coords", "(", "self", ",", "grid", ")", ":", "\n", "        ", "idx", "=", "torch", ".", "arange", "(", "grid", ".", "size", "**", "3", ")", "\n", "idx_xyz", "=", "unravel_index", "(", "idx", ",", "grid", ".", "shape", "[", "1", ":", "]", ")", "\n", "assert", "len", "(", "idx_xyz", ".", "shape", ")", "==", "2", "\n", "assert", "idx_xyz", ".", "shape", "[", "1", "]", "==", "3", "\n", "coords", "=", "grid", ".", "get_coords", "(", "idx_xyz", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_atom_grids.TestAtomGrid.test_prop_values": [[72, 77], ["torch.cat", "list"], "methods", ["None"], ["", "def", "test_prop_values", "(", "self", ",", "grid", ")", ":", "\n", "        ", "out_values", "=", "torch", ".", "cat", "(", "\n", "[", "grid", ".", "elem_values", "]", "+", "list", "(", "grid", ".", "prop_values", ")", ",", "dim", "=", "0", "\n", ")", "\n", "assert", "(", "out_values", "==", "grid", ".", "values", ")", ".", "all", "(", ")", ",", "'different values'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.typer": [[338, 343], ["pytest.fixture", "liGAN.atom_types.AtomTyper.get_typer"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.get_typer"], ["    ", "@", "pytest", ".", "fixture", "(", "params", "=", "test_typer_fns", ")", "\n", "def", "typer", "(", "self", ",", "request", ")", ":", "\n", "        ", "prop_funcs", "=", "request", ".", "param", "\n", "radius_func", "=", "lambda", "x", ":", "1", "\n", "return", "AtomTyper", ".", "get_typer", "(", "prop_funcs", ",", "radius_func", ",", "device", "=", "'cpu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.adder": [[344, 347], ["liGAN.bond_adding.BondAdder"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "adder", "(", "self", ")", ":", "\n", "        ", "return", "BondAdder", "(", "debug", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.in_mol": [[348, 355], ["pytest.fixture", "mol.AddHydrogens", "liGAN.read_ob_mols_from_file", "os.path.splitext", "os.path.basename"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "test_sdf_files", ")", "\n", "def", "in_mol", "(", "self", ",", "request", ")", ":", "\n", "        ", "sdf_file", "=", "request", ".", "param", "\n", "mol", "=", "mols", ".", "read_ob_mols_from_file", "(", "sdf_file", ",", "'sdf'", ")", "[", "0", "]", "\n", "mol", ".", "AddHydrogens", "(", ")", "# this is needed to determine donor/acceptor", "\n", "mol", ".", "name", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "sdf_file", ")", ")", "[", "0", "]", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_init": [[356, 358], ["None"], "methods", ["None"], ["", "def", "test_init", "(", "self", ",", "adder", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_make_ob_mol": [[359, 366], ["typer.make_struct", "typer.make_struct.to_ob_mol", "test_bond_adding.iter_atom_pairs", "o.GetAtomicNum", "i.GetAtomicNum", "o.GetVector", "i.GetVector"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs"], ["", "def", "test_make_ob_mol", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "out_mol", ",", "_", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "\n", "for", "i", ",", "o", "in", "iter_atom_pairs", "(", "in_mol", ",", "out_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "            ", "assert", "o", ".", "GetAtomicNum", "(", ")", "==", "i", ".", "GetAtomicNum", "(", ")", ",", "'different elements'", "\n", "assert", "o", ".", "GetVector", "(", ")", "==", "i", ".", "GetVector", "(", ")", ",", "'different coordinates'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_add_within_distance": [[367, 383], ["typer.make_struct", "typer.make_struct.to_ob_mol", "adder.add_within_distance", "test_bond_adding.iter_atom_pairs", "test_bond_adding.iter_atom_pairs", "bool", "bool", "in_mol.GetBond", "out_mol.GetBond", "liGAN.molecules.ob.GetSymbol", "liGAN.molecules.ob.GetSymbol", "a_i.GetAtomicNum", "b_i.GetAtomicNum"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.add_within_distance", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs"], ["", "", "def", "test_add_within_distance", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "out_mol", ",", "atoms", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "adder", ".", "add_within_distance", "(", "out_mol", ",", "atoms", ",", "struct", ")", "\n", "\n", "for", "a_i", ",", "a_o", "in", "iter_atom_pairs", "(", "in_mol", ",", "out_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "            ", "for", "b_i", ",", "b_o", "in", "iter_atom_pairs", "(", "in_mol", ",", "out_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "\n", "                ", "in_bonded", "=", "bool", "(", "in_mol", ".", "GetBond", "(", "a_i", ",", "b_i", ")", ")", "\n", "out_bonded", "=", "bool", "(", "out_mol", ".", "GetBond", "(", "a_o", ",", "b_o", ")", ")", "\n", "bond_str", "=", "'{}-{}'", ".", "format", "(", "\n", "ob", ".", "GetSymbol", "(", "a_i", ".", "GetAtomicNum", "(", ")", ")", ",", "\n", "ob", ".", "GetSymbol", "(", "b_i", ".", "GetAtomicNum", "(", ")", ")", "\n", ")", "\n", "if", "in_bonded", ":", "# all input bonds should be present in output", "\n", "                    ", "assert", "out_bonded", ",", "'missing '", "+", "bond_str", "+", "' bond'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_set_min_h_counts": [[384, 398], ["typer.make_struct", "typer.make_struct.to_ob_mol", "adder.add_within_distance", "adder.set_min_h_counts", "test_bond_adding.iter_atom_pairs", "o.GetImplicitHCount", "o.GetImplicitHCount", "i.IsHbondDonor"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.add_within_distance", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.set_min_h_counts", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs"], ["", "", "", "", "def", "test_set_min_h_counts", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "out_mol", ",", "atoms", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "adder", ".", "add_within_distance", "(", "out_mol", ",", "atoms", ",", "struct", ")", "\n", "adder", ".", "set_min_h_counts", "(", "out_mol", ",", "atoms", ",", "struct", ")", "\n", "\n", "for", "i", ",", "o", "in", "iter_atom_pairs", "(", "in_mol", ",", "out_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "# all H donors should have at least one hydrogen", "\n", "            ", "if", "typer", ".", "explicit_h", ":", "\n", "                ", "assert", "o", ".", "GetImplicitHCount", "(", ")", "==", "0", ",", "'explicit H donor has implicit H(s)'", "\n", "", "else", ":", "\n", "                ", "assert", "o", ".", "GetImplicitHCount", "(", ")", ">=", "i", ".", "IsHbondDonor", "(", ")", ",", "'implicit H donor has no implicit H(s)'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_set_formal_charges": [[399, 407], ["typer.make_struct", "typer.make_struct.to_ob_mol", "adder.disable_perception", "adder.set_formal_charges", "test_bond_adding.iter_atom_pairs", "o.GetFormalCharge", "i.GetFormalCharge"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.disable_perception", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.set_formal_charges", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs"], ["", "", "", "def", "test_set_formal_charges", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "ob_mol", ",", "atoms", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "adder", ".", "disable_perception", "(", "ob_mol", ")", "\n", "adder", ".", "set_formal_charges", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "for", "i", ",", "o", "in", "iter_atom_pairs", "(", "in_mol", ",", "ob_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "            ", "assert", "o", ".", "GetFormalCharge", "(", ")", "==", "i", ".", "GetFormalCharge", "(", ")", ",", "'incorrect formal charge'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_remove_bad_valences": [[408, 417], ["typer.make_struct", "typer.make_struct.to_ob_mol", "adder.add_within_distance", "adder.remove_bad_valences", "liGAN.bond_adding.get_max_valences", "test_bond_adding.iter_atoms", "o.GetExplicitValence", "liGAN.bond_adding.get_max_valences.get", "o.GetIdx"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.add_within_distance", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.remove_bad_valences", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.get_max_valences", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atoms", "home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "", "def", "test_remove_bad_valences", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "ob_mol", ",", "atoms", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "adder", ".", "add_within_distance", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "adder", ".", "remove_bad_valences", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "max_vals", "=", "get_max_valences", "(", "atoms", ")", "\n", "for", "o", "in", "iter_atoms", "(", "ob_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "            ", "assert", "o", ".", "GetExplicitValence", "(", ")", "<=", "max_vals", ".", "get", "(", "o", ".", "GetIdx", "(", ")", ",", "1", ")", ",", "'invalid valence'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_remove_bad_geometry": [[418, 423], ["typer.make_struct", "typer.make_struct.to_ob_mol", "adder.add_within_distance", "adder.remove_bad_geometry"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.add_within_distance", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.remove_bad_geometry"], ["", "", "def", "test_remove_bad_geometry", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "ob_mol", ",", "atoms", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "adder", ".", "add_within_distance", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "adder", ".", "remove_bad_geometry", "(", "ob_mol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_set_aromaticity": [[424, 431], ["typer.make_struct", "typer.make_struct.to_ob_mol", "adder.disable_perception", "adder.set_aromaticity", "test_bond_adding.iter_atom_pairs", "o.IsAromatic", "i.IsAromatic"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.disable_perception", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.set_aromaticity", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs"], ["", "def", "test_set_aromaticity", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "ob_mol", ",", "atoms", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "adder", ".", "disable_perception", "(", "ob_mol", ")", "\n", "adder", ".", "set_aromaticity", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "for", "i", ",", "o", "in", "iter_atom_pairs", "(", "in_mol", ",", "ob_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "            ", "assert", "o", ".", "IsAromatic", "(", ")", "==", "i", ".", "IsAromatic", "(", ")", ",", "'different aromaticity'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_add_bonds": [[432, 469], ["typer.make_struct", "typer.make_struct.to_ob_mol", "adder.add_bonds", "typer.make_struct", "test_bond_adding.write_ob_pymol", "zip", "test_bond_adding.iter_atom_pairs", "in_mol.NumAtoms", "ob_mol.NumAtoms", "print", "test_bond_adding.iter_atom_pairs", "in_mol.GetBond", "ob_mol.GetBond", "liGAN.molecules.ob.GetSymbol", "liGAN.molecules.ob.GetSymbol", "bool", "bool", "in_mol.GetBond.IsAromatic", "in_a.GetAtomicNum", "in_b.GetAtomicNum", "ob_mol.GetBond.IsAromatic", "in_mol.GetBond.GetBondOrder", "ob_mol.GetBond.GetBondOrder"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.add_bonds", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_ob_pymol", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs"], ["", "", "def", "test_add_bonds", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "ob_mol", ",", "atoms", "=", "struct", ".", "to_ob_mol", "(", ")", "\n", "ob_mol", ",", "visited_mols", "=", "adder", ".", "add_bonds", "(", "ob_mol", ",", "atoms", ",", "struct", ")", "\n", "add_struct", "=", "typer", ".", "make_struct", "(", "ob_mol", ")", "\n", "\n", "write_ob_pymol", "(", "visited_mols", ",", "in_mol", ")", "\n", "for", "t1", ",", "t2", "in", "zip", "(", "struct", ".", "atom_types", ",", "add_struct", ".", "atom_types", ")", ":", "\n", "            ", "print", "(", "t1", ",", "'\\t'", ",", "t2", ")", "\n", "\n", "# check bonds between atoms in typed structure", "\n", "", "for", "in_a", ",", "out_a", "in", "iter_atom_pairs", "(", "in_mol", ",", "ob_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "            ", "for", "in_b", ",", "out_b", "in", "iter_atom_pairs", "(", "in_mol", ",", "ob_mol", ",", "typer", ".", "explicit_h", ")", ":", "\n", "\n", "                ", "in_bond", "=", "in_mol", ".", "GetBond", "(", "in_a", ",", "in_b", ")", "\n", "out_bond", "=", "ob_mol", ".", "GetBond", "(", "out_a", ",", "out_b", ")", "\n", "bstr", "=", "'{}-{}'", ".", "format", "(", "\n", "ob", ".", "GetSymbol", "(", "in_a", ".", "GetAtomicNum", "(", ")", ")", ",", "\n", "ob", ".", "GetSymbol", "(", "in_b", ".", "GetAtomicNum", "(", ")", ")", "\n", ")", "\n", "assert", "(", "\n", "bool", "(", "out_bond", ")", "==", "bool", "(", "in_bond", ")", "\n", ")", ",", "'different {} bond presence'", ".", "format", "(", "bstr", ")", "\n", "if", "in_bond", "and", "out_bond", ":", "\n", "                    ", "if", "in_bond", ".", "IsAromatic", "(", ")", ":", "# allow diff kekule structures", "\n", "                        ", "assert", "out_bond", ".", "IsAromatic", "(", ")", ",", "'different {} bond aromaticity'", ".", "format", "(", "bstr", ")", "\n", "", "else", ":", "# mols should have same bond orders", "\n", "                        ", "assert", "(", "\n", "in_bond", ".", "GetBondOrder", "(", ")", "==", "out_bond", ".", "GetBondOrder", "(", ")", "\n", ")", ",", "'different {} bond orders'", ".", "format", "(", "bstr", ")", "\n", "\n", "# check whether correct num hydrogens were added", "\n", "", "", "", "", "n_in", "=", "in_mol", ".", "NumAtoms", "(", ")", "\n", "n_out", "=", "ob_mol", ".", "NumAtoms", "(", ")", "\n", "assert", "n_out", "==", "n_in", ",", "'different num atoms ({} vs {})'", ".", "format", "(", "\n", "n_out", ",", "n_in", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_convert_mol": [[471, 479], ["liGAN.molecules.Molecule.from_ob_mol", "liGAN.molecules.Molecule.from_ob_mol.to_ob_mol", "liGAN.ob_mol_to_smi", "liGAN.ob_mol_to_smi", "liGAN.get_ob_smi_similarity"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_smi", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_mol_to_smi", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_ob_smi_similarity"], ["", "def", "test_convert_mol", "(", "self", ",", "in_mol", ")", ":", "\n", "        ", "rd_mol", "=", "Molecule", ".", "from_ob_mol", "(", "in_mol", ")", "\n", "out_mol", "=", "rd_mol", ".", "to_ob_mol", "(", ")", "\n", "in_smi", "=", "mols", ".", "ob_mol_to_smi", "(", "in_mol", ")", "\n", "out_smi", "=", "mols", ".", "ob_mol_to_smi", "(", "out_mol", ")", "\n", "ob_sim", "=", "mols", ".", "get_ob_smi_similarity", "(", "out_smi", ",", "in_smi", ")", "\n", "assert", "out_smi", "==", "in_smi", ",", "'different SMILES strings ({:.3f})'", ".", "format", "(", "ob_sim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_make_mol": [[480, 519], ["typer.make_struct", "adder.make_mol", "liGAN.molecules.Molecule.from_ob_mol", "zip", "out_mol.validate", "liGAN.molecules.Molecule.from_ob_mol.validate", "print", "test_bond_adding.write_rd_pymol", "liGAN.molecules.Molecule.from_ob_mol.to_smi", "out_mol.to_smi", "liGAN.get_rd_mol_similarity", "liGAN.get_ob_smi_similarity", "out_mol.aligned_rmsd", "print", "len"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.validate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.validate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_rd_pymol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_smi", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.to_smi", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_rd_mol_similarity", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.get_ob_smi_similarity", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.aligned_rmsd", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_make_mol", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "out_mol", ",", "add_struct", ",", "visited_mols", "=", "adder", ".", "make_mol", "(", "struct", ")", "\n", "in_mol", "=", "Molecule", ".", "from_ob_mol", "(", "in_mol", ")", "\n", "\n", "n_atoms_diff", "=", "(", "in_mol", ".", "n_atoms", "-", "out_mol", ".", "n_atoms", ")", "\n", "elem_diff", "=", "(", "struct", ".", "elem_counts", "-", "add_struct", ".", "elem_counts", ")", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "prop_diff", "=", "(", "struct", ".", "prop_counts", "-", "add_struct", ".", "prop_counts", ")", ".", "abs", "(", ")", ".", "sum", "(", ")", "\n", "\n", "assert", "n_atoms_diff", "==", "0", ",", "'different num atoms ({})'", ".", "format", "(", "n_atoms_diff", ")", "\n", "\n", "for", "t1", ",", "t2", "in", "zip", "(", "struct", ".", "atom_types", ",", "add_struct", ".", "atom_types", ")", ":", "\n", "            ", "print", "(", "t1", ",", "'\\t'", ",", "t2", ")", "\n", "\n", "", "assert", "elem_diff", "==", "0", ",", "'different element counts ({})'", ".", "format", "(", "elem_diff", ")", "\n", "\n", "assert", "prop_diff", "==", "0", ",", "'different property counts ({})'", ".", "format", "(", "prop_diff", ")", "\n", "\n", "out_valid", ",", "out_reason", "=", "out_mol", ".", "validate", "(", ")", "\n", "assert", "out_valid", ",", "'out_mol '", "+", "out_reason", "\n", "\n", "in_valid", ",", "in_reason", "=", "in_mol", ".", "validate", "(", ")", "\n", "assert", "in_valid", ",", "'in_mol '", "+", "in_reason", "\n", "\n", "print", "(", "len", "(", "visited_mols", ")", ")", "\n", "write_rd_pymol", "(", "visited_mols", ",", "in_mol", ")", "\n", "\n", "in_smi", "=", "in_mol", ".", "to_smi", "(", ")", "\n", "out_smi", "=", "out_mol", ".", "to_smi", "(", ")", "\n", "rd_sim", "=", "mols", ".", "get_rd_mol_similarity", "(", "out_mol", ",", "in_mol", ",", "'rdkit'", ")", "\n", "ob_sim", "=", "mols", ".", "get_ob_smi_similarity", "(", "out_smi", ",", "in_smi", ")", "\n", "assert", "out_smi", "==", "in_smi", ",", "'different SMILES strings ({:.3f} {:.3f})'", ".", "format", "(", "ob_sim", ",", "rd_sim", ")", "\n", "\n", "rmsd", "=", "out_mol", ".", "aligned_rmsd", "(", "in_mol", ")", "\n", "assert", "rmsd", "<", "1.0", ",", "'RMSD too high ({})'", ".", "format", "(", "rmsd", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.TestBondAdding.test_uff_minimize": [[520, 529], ["typer.make_struct", "adder.make_mol", "out_mol.validate", "out_mol.uff_minimize", "liGAN.molecules.Molecule.from_ob_mol", "liGAN.molecules.Molecule.from_ob_mol.validate", "liGAN.molecules.Molecule.from_ob_mol.uff_minimize", "test_bond_adding.write_rd_pymol"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.AtomTyper.make_struct", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.BondAdder.make_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.validate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.uff_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.validate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.uff_minimize", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_rd_pymol"], ["", "def", "test_uff_minimize", "(", "self", ",", "adder", ",", "typer", ",", "in_mol", ")", ":", "\n", "        ", "struct", "=", "typer", ".", "make_struct", "(", "in_mol", ")", "\n", "out_mol", ",", "add_struct", ",", "visited_mols", "=", "adder", ".", "make_mol", "(", "struct", ")", "\n", "out_mol", ".", "validate", "(", ")", "\n", "out_mol_min", "=", "out_mol", ".", "uff_minimize", "(", ")", "\n", "in_mol", "=", "Molecule", ".", "from_ob_mol", "(", "in_mol", ")", "\n", "in_mol", ".", "validate", "(", ")", "\n", "in_mol_min", "=", "in_mol", ".", "uff_minimize", "(", ")", "\n", "write_rd_pymol", "(", "visited_mols", "+", "[", "out_mol_min", ",", "in_mol_min", "]", ",", "in_mol", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atoms": [[28, 37], ["liGAN.molecules.ob.OBMolAtomIter", "atom.GetAtomicNum"], "function", ["None"], ["def", "iter_atoms", "(", "ob_mol", ",", "explicit_h", "=", "True", ")", ":", "\n", "    ", "'''\n    Iterate over atoms in ob_mol,\n    optionally omitting hydrogens.\n    '''", "\n", "for", "atom", "in", "ob", ".", "OBMolAtomIter", "(", "ob_mol", ")", ":", "\n", "        ", "if", "not", "explicit_h", "and", "atom", ".", "GetAtomicNum", "(", ")", "==", "1", ":", "\n", "            ", "continue", "\n", "", "yield", "atom", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atom_pairs": [[39, 58], ["zip", "in_mol.NumHvyAtoms", "out_mol.NumHvyAtoms", "in_mol.NumAtoms", "out_mol.NumAtoms", "test_bond_adding.iter_atoms", "test_bond_adding.iter_atoms"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atoms", "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.iter_atoms"], ["", "", "def", "iter_atom_pairs", "(", "in_mol", ",", "out_mol", ",", "explicit_h", "=", "False", ")", ":", "\n", "    ", "'''\n    Iterate over pairs of atoms in in_mol and\n    out_mol, optionally omitting hydrogens.\n    '''", "\n", "if", "not", "explicit_h", ":", "\n", "        ", "n_in", "=", "in_mol", ".", "NumHvyAtoms", "(", ")", "\n", "n_out", "=", "out_mol", ".", "NumHvyAtoms", "(", ")", "\n", "assert", "n_out", "==", "n_in", ",", "'different num heavy atoms ({} vs {})'", ".", "format", "(", "n_out", ",", "n_in", ")", "\n", "", "else", ":", "\n", "        ", "n_in", "=", "in_mol", ".", "NumAtoms", "(", ")", "\n", "n_out", "=", "out_mol", ".", "NumAtoms", "(", ")", "\n", "assert", "n_out", "==", "n_in", ",", "'different num atoms ({} vs {})'", ".", "format", "(", "n_out", ",", "n_in", ")", "\n", "\n", "", "return", "zip", "(", "\n", "iter_atoms", "(", "in_mol", ",", "explicit_h", ")", ",", "\n", "iter_atoms", "(", "out_mol", ",", "explicit_h", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_ob_pymol": [[61, 63], ["test_bond_adding.write_pymol"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_pymol"], ["", "def", "write_ob_pymol", "(", "visited_mols", ",", "in_mol", ")", ":", "\n", "    ", "write_pymol", "(", "visited_mols", ",", "in_mol", ",", "mol_type", "=", "'ob'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_rd_pymol": [[65, 67], ["test_bond_adding.write_pymol"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_pymol"], ["", "def", "write_rd_pymol", "(", "visited_mols", ",", "in_mol", ")", ":", "\n", "    ", "write_pymol", "(", "visited_mols", ",", "in_mol", ",", "mol_type", "=", "'rd'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_pymol": [[69, 97], ["open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "write_mols", "write", "write", "write", "write", "write", "write"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.write"], ["", "def", "write_pymol", "(", "visited_mols", ",", "in_mol", ",", "mol_type", ")", ":", "\n", "    ", "if", "mol_type", "==", "'ob'", ":", "\n", "        ", "mol_name", "=", "in_mol", ".", "name", "\n", "write_mols", "=", "write_ob_mols", "\n", "", "else", ":", "\n", "        ", "mol_name", "=", "in_mol", ".", "info", "[", "'ob_mol'", "]", ".", "name", "\n", "write_mols", "=", "write_rd_mols", "\n", "", "pymol_file", "=", "f'tests/output/TEST_{mol_type}_{mol_name}.pymol'", "\n", "with", "open", "(", "pymol_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "write", "=", "lambda", "mode", ":", "write_mols", "(", "\n", "mol_name", ",", "visited_mols", "+", "[", "in_mol", "]", ",", "mode", "\n", ")", "\n", "f", ".", "write", "(", "'load {}\\n'", ".", "format", "(", "write", "(", "None", ")", ")", ")", "\n", "f", ".", "write", "(", "'load {}\\n'", ".", "format", "(", "write", "(", "'o'", ")", ")", ")", "\n", "f", ".", "write", "(", "'load {}\\n'", ".", "format", "(", "write", "(", "'e'", ")", ")", ")", "\n", "f", ".", "write", "(", "'load {}\\n'", ".", "format", "(", "write", "(", "'n'", ")", ")", ")", "\n", "f", ".", "write", "(", "'load {}\\n'", ".", "format", "(", "write", "(", "'a'", ")", ")", ")", "\n", "f", ".", "write", "(", "'load {}\\n'", ".", "format", "(", "write", "(", "'d'", ")", ")", ")", "\n", "f", ".", "write", "(", "'show_as nb_spheres\\n'", ")", "\n", "f", ".", "write", "(", "'show sticks\\n'", ")", "\n", "f", ".", "write", "(", "'util.cbam\\n'", ")", "\n", "f", ".", "write", "(", "'color white, (name H)\\n'", ")", "\n", "f", ".", "write", "(", "'color red, (name Md)\\n'", ")", "\n", "f", ".", "write", "(", "'color orange, (name No)\\n'", ")", "\n", "f", ".", "write", "(", "'color yellow, (name Lr)\\n'", ")", "\n", "f", ".", "write", "(", "'color green, (name Rf)\\n'", ")", "\n", "f", ".", "write", "(", "'color blue, (name Db)\\n'", ")", "\n", "f", ".", "write", "(", "'color magenta, (name Sg)\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_rd_mols": [[99, 141], ["liGAN.write_rd_mols_to_sdf_file", "liGAN.Molecule", "m.GetAtoms", "m.GetBonds", "a.SetAtomicNum", "b.GetIsAromatic", "a.SetAtomicNum", "b.SetBondType", "b.SetBondType", "a.SetAtomicNum", "a.GetIsAromatic", "a.SetAtomicNum", "a.GetHybridization", "a.SetAtomicNum", "a.GetNumExplicitHs", "ValueError"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_rd_mols_to_sdf_file"], ["", "", "def", "write_rd_mols", "(", "mol_name", ",", "rd_mols", ",", "mode", "=", "None", ")", ":", "\n", "\n", "# color molecule by atomic properties by setting", "\n", "#  the element based on the property value", "\n", "    ", "value_map", "=", "{", "0", ":", "1", ",", "1", ":", "101", ",", "2", ":", "102", ",", "3", ":", "103", ",", "4", ":", "104", ",", "5", ":", "105", ",", "6", ":", "106", "}", "\n", "\n", "write_mols", "=", "[", "mols", ".", "Molecule", "(", "m", ")", "for", "m", "in", "rd_mols", "]", "\n", "\n", "for", "m", "in", "write_mols", ":", "\n", "        ", "for", "a", "in", "m", ".", "GetAtoms", "(", ")", ":", "\n", "\n", "            ", "if", "mode", "==", "'o'", ":", "# aromaticity", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "a", ".", "GetIsAromatic", "(", ")", "]", ")", "\n", "\n", "", "elif", "mode", "==", "'e'", ":", "# hybridization", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "a", ".", "GetHybridization", "(", ")", "]", ")", "\n", "\n", "", "elif", "mode", "==", "'n'", ":", "# implicit H count", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "a", ".", "GetNumExplicitHs", "(", ")", "]", ")", "\n", "\n", "", "elif", "mode", "==", "'a'", ":", "# hydrogen acceptor", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "False", "]", ")", "\n", "\n", "", "elif", "mode", "==", "'d'", ":", "# hydrogen donor", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "False", "]", ")", "\n", "\n", "", "elif", "mode", "is", "not", "None", ":", "\n", "                ", "raise", "ValueError", "(", "mode", ")", "\n", "\n", "", "", "if", "mode", "==", "'o'", ":", "# aromatic bonds", "\n", "            ", "for", "b", "in", "m", ".", "GetBonds", "(", ")", ":", "\n", "                ", "if", "b", ".", "GetIsAromatic", "(", ")", ":", "\n", "                    ", "b", ".", "SetBondType", "(", "mols", ".", "Chem", ".", "BondType", ".", "DOUBLE", ")", "\n", "", "else", ":", "\n", "                    ", "b", ".", "SetBondType", "(", "mols", ".", "Chem", ".", "BondType", ".", "SINGLE", ")", "\n", "\n", "", "", "", "", "if", "mode", ":", "\n", "        ", "mol_name", "+=", "'_'", "+", "mode", "\n", "\n", "", "mol_file", "=", "'tests/output/TEST_rd_{}.sdf'", ".", "format", "(", "mol_name", ")", "\n", "mols", ".", "write_rd_mols_to_sdf_file", "(", "mol_file", ",", "write_mols", ")", "\n", "return", "mol_file", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.write_ob_mols": [[143, 181], ["liGAN.write_ob_mols_to_sdf_file", "liGAN.copy_ob_mol", "liGAN.molecules.ob.OBMolAtomIter", "liGAN.molecules.ob.OBMolBondIter", "a.SetAtomicNum", "b.SetBondOrder", "a.SetAtomicNum", "a.SetAtomicNum", "b.IsAromatic", "a.IsAromatic", "a.SetAtomicNum", "liGAN.ob_hyb_to_rd_hyb", "a.SetAtomicNum", "a.GetImplicitHCount", "ValueError", "a.IsHbondAcceptor", "a.IsHbondDonor"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_ob_mols_to_sdf_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.copy_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.ob_hyb_to_rd_hyb"], ["", "def", "write_ob_mols", "(", "mol_name", ",", "ob_mols", ",", "mode", "=", "None", ")", ":", "\n", "\n", "# color molecule by atomic properties by setting", "\n", "#  the element based on the property value", "\n", "    ", "value_map", "=", "{", "0", ":", "1", ",", "1", ":", "101", ",", "2", ":", "102", ",", "3", ":", "103", ",", "4", ":", "104", ",", "5", ":", "105", ",", "6", ":", "106", "}", "\n", "\n", "write_mols", "=", "[", "mols", ".", "copy_ob_mol", "(", "m", ")", "for", "m", "in", "ob_mols", "]", "\n", "\n", "for", "m", "in", "write_mols", ":", "\n", "        ", "for", "a", "in", "ob", ".", "OBMolAtomIter", "(", "m", ")", ":", "\n", "\n", "            ", "if", "mode", "==", "'o'", ":", "# aromaticity", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "a", ".", "IsAromatic", "(", ")", "]", ")", "\n", "\n", "", "elif", "mode", "==", "'e'", ":", "# hybridization", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "mols", ".", "ob_hyb_to_rd_hyb", "(", "a", ")", "]", ")", "\n", "\n", "", "elif", "mode", "==", "'n'", ":", "# implicit H count", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "a", ".", "GetImplicitHCount", "(", ")", "]", ")", "\n", "\n", "", "elif", "mode", "==", "'a'", ":", "# hydrogen acceptor", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "a", ".", "IsHbondAcceptor", "(", ")", "]", ")", "\n", "\n", "", "elif", "mode", "==", "'d'", ":", "# hydrogen donor", "\n", "                ", "a", ".", "SetAtomicNum", "(", "value_map", "[", "a", ".", "IsHbondDonor", "(", ")", "]", ")", "\n", "\n", "", "elif", "mode", "is", "not", "None", ":", "\n", "                ", "raise", "ValueError", "(", "mode", ")", "\n", "\n", "", "", "if", "mode", "==", "'o'", ":", "# aromatic bonds", "\n", "            ", "for", "b", "in", "ob", ".", "OBMolBondIter", "(", "m", ")", ":", "\n", "                ", "b", ".", "SetBondOrder", "(", "1", "+", "b", ".", "IsAromatic", "(", ")", ")", "\n", "", "", "", "if", "mode", ":", "\n", "        ", "mol_name", "+=", "'_'", "+", "mode", "\n", "\n", "", "mol_file", "=", "f'tests/output/TEST_ob_{mol_name}.sdf'", "\n", "mols", ".", "write_ob_mols_to_sdf_file", "(", "mol_file", ",", "write_mols", ")", "\n", "return", "mol_file", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.test_add_bond": [[183, 216], ["liGAN.molecules.ob.OBMol", "ob.OBMol.NumAtoms", "ob.OBMol.NumBonds", "ob.OBMol.NewAtom", "ob.OBMol.NewAtom", "ob.OBMol.NumAtoms", "ob.OBMol.NumBonds", "mol.NewAtom.GetIdx", "mol.NewAtom.GetIdx", "ob.OBMol.AddBond", "liGAN.bond_adding.compare_bonds", "liGAN.bond_adding.compare_bonds", "ob.OBMol.NumAtoms", "ob.OBMol.NumBonds", "ob.OBMol.NumAtoms", "ob.OBMol.NumBonds", "mol.NewAtom.GetIdx", "mol.NewAtom.GetIdx", "ob.OBMol.GetAtom", "ob.OBMol.GetAtom", "ob.OBMol.GetBond", "ob.OBMol.GetBond", "ob.OBMol.GetBond", "ob.OBMol.GetBond", "ob.OBMol.AddBond", "ob.OBMol.AddBond", "ob.OBMol.GetBond", "ob.OBMol.GetBond", "ob.OBMol.GetBond", "ob.OBMol.GetBond"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.compare_bonds", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.compare_bonds"], ["", "def", "test_add_bond", "(", ")", ":", "\n", "    ", "'''\n    Test basic OBMol bond adding methods.\n    '''", "\n", "# create an empty molecule", "\n", "mol", "=", "ob", ".", "OBMol", "(", ")", "\n", "assert", "mol", ".", "NumAtoms", "(", ")", "==", "0", ",", "mol", ".", "NumAtoms", "(", ")", "\n", "assert", "mol", ".", "NumBonds", "(", ")", "==", "0", ",", "mol", ".", "NumBonds", "(", ")", "\n", "\n", "# add two atoms to the molecule", "\n", "a", "=", "mol", ".", "NewAtom", "(", ")", "\n", "b", "=", "mol", ".", "NewAtom", "(", ")", "\n", "assert", "mol", ".", "NumAtoms", "(", ")", "==", "2", ",", "mol", ".", "NumAtoms", "(", ")", "\n", "assert", "mol", ".", "NumBonds", "(", ")", "==", "0", ",", "mol", ".", "NumBonds", "(", ")", "\n", "\n", "# OB uses 1-based atom indexing", "\n", "assert", "a", ".", "GetIdx", "(", ")", "==", "1", ",", "a", ".", "GetIdx", "(", ")", "\n", "assert", "b", ".", "GetIdx", "(", ")", "==", "2", ",", "b", ".", "GetIdx", "(", ")", "\n", "assert", "mol", ".", "GetAtom", "(", "1", ")", "==", "a", "\n", "assert", "mol", ".", "GetAtom", "(", "2", ")", "==", "b", "\n", "\n", "# add a bond between the atoms", "\n", "assert", "mol", ".", "AddBond", "(", "1", ",", "2", ",", "1", ",", "0", ")", "\n", "assert", "mol", ".", "GetBond", "(", "1", ",", "2", ")", "and", "mol", ".", "GetBond", "(", "2", ",", "1", ")", "\n", "assert", "mol", ".", "GetBond", "(", "a", ",", "b", ")", "and", "mol", ".", "GetBond", "(", "b", ",", "a", ")", "\n", "\n", "# try adding the same bond again", "\n", "assert", "not", "mol", ".", "AddBond", "(", "1", ",", "2", ",", "1", ",", "0", ")", "\n", "assert", "not", "mol", ".", "AddBond", "(", "2", ",", "1", ",", "1", ",", "0", ")", "\n", "\n", "# check that bond comparison holds", "\n", "assert", "compare_bonds", "(", "mol", ".", "GetBond", "(", "1", ",", "2", ")", ",", "mol", ".", "GetBond", "(", "2", ",", "1", ")", ")", "\n", "assert", "compare_bonds", "(", "mol", ".", "GetBond", "(", "a", ",", "b", ")", ",", "mol", ".", "GetBond", "(", "b", ",", "a", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.dense": [[218, 247], ["pytest.fixture", "liGAN.make_ob_mol", "liGAN.write_ob_mols_to_sdf_file", "numpy.random.choice", "numpy.eye", "numpy.random.normal", "numpy.ones", "liGAN.atom_types.AtomTyper"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.make_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.write_ob_mols_to_sdf_file"], ["", "@", "pytest", ".", "fixture", "(", "params", "=", "[", "10", ",", "50", "]", ")", "\n", "def", "dense", "(", "request", ")", ":", "\n", "    ", "'''\n    An OBMol where every pair of atoms\n    is bonded with some probability.\n    '''", "\n", "n_atoms", "=", "request", ".", "param", "\n", "\n", "p", "=", "0.9", "\n", "bonds", "=", "np", ".", "random", ".", "choice", "(", "\n", "[", "0", ",", "1", "]", ",", "size", "=", "(", "n_atoms", ",", "n_atoms", ")", ",", "p", "=", "[", "1", "-", "p", ",", "p", "]", "\n", ")", "*", "(", "1", "-", "np", ".", "eye", "(", "n_atoms", ")", ")", "\n", "\n", "mol", ",", "atoms", "=", "mols", ".", "make_ob_mol", "(", "\n", "coords", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "10", ",", "(", "n_atoms", ",", "3", ")", ")", ",", "\n", "types", "=", "np", ".", "ones", "(", "(", "n_atoms", ",", "1", ")", ")", ",", "\n", "bonds", "=", "bonds", ",", "\n", "typer", "=", "AtomTyper", "(", "\n", "prop_funcs", "=", "[", "Atom", ".", "atomic_num", "]", ",", "\n", "prop_ranges", "=", "[", "[", "6", "]", "]", ",", "\n", "radius_func", "=", "Atom", ".", "cov_radius", ",", "\n", "explicit_h", "=", "False", ",", "\n", "device", "=", "'cpu'", "\n", ")", "\n", ")", "\n", "mols", ".", "write_ob_mols_to_sdf_file", "(", "\n", "'tests/output/TEST_dense_{}.sdf'", ".", "format", "(", "n_atoms", ")", ",", "[", "mol", "]", "\n", ")", "\n", "return", "mol", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.test_highly_fused_rings": [[249, 252], ["liGAN.Molecule.from_ob_mol", "liGAN.read_ob_mols_from_file"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.Molecule.from_ob_mol", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.molecules.read_ob_mols_from_file"], ["", "def", "test_highly_fused_rings", "(", ")", ":", "\n", "    ", "ob_mol", "=", "mols", ".", "read_ob_mols_from_file", "(", "'tests/input/buckyball.sdf'", ",", "'sdf'", ")", "[", "0", "]", "\n", "mols", ".", "Molecule", ".", "from_ob_mol", "(", "ob_mol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.test_reachable_basic": [[254, 314], ["liGAN.molecules.ob.OBMol", "test_bond_adding.test_reachable_basic.new_atom"], "function", ["None"], ["", "def", "test_reachable_basic", "(", ")", ":", "\n", "    ", "'''\n    D--E\n    | /\n    |/\\\n    F  A--B\n       | /\n       |/\n       C\n    '''", "\n", "mol", "=", "ob", ".", "OBMol", "(", ")", "\n", "\n", "def", "new_atom", "(", "x", ",", "y", ",", "z", ")", ":", "\n", "# caution: i is the *id*, not the idx", "\n", "        ", "atom", "=", "mol", ".", "NewAtom", "(", "mol", ".", "NumAtoms", "(", ")", ")", "\n", "atom", ".", "SetAtomicNum", "(", "6", ")", "\n", "atom", ".", "SetVector", "(", "x", ",", "y", ",", "z", ")", "\n", "return", "atom", "\n", "\n", "", "def", "add_bond", "(", "a1", ",", "a2", ")", ":", "\n", "        ", "mol", ".", "AddBond", "(", "a1", ".", "GetIdx", "(", ")", ",", "a2", ".", "GetIdx", "(", ")", ",", "1", ",", "0", ")", "\n", "\n", "", "a", "=", "new_atom", "(", "0", ",", "0", ",", "0", ")", "\n", "b", "=", "new_atom", "(", "1", ",", "0", ",", "0", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "# not bonded", "\n", "        ", "reachable", "(", "a", ",", "b", ")", "or", "reachable", "(", "b", ",", "a", ")", "\n", "\n", "", "add_bond", "(", "a", ",", "b", ")", "\n", "assert", "not", "reachable", "(", "a", ",", "b", ")", "and", "not", "reachable", "(", "b", ",", "a", ")", "\n", "\n", "c", "=", "new_atom", "(", "0", ",", "2", ",", "0", ")", "\n", "add_bond", "(", "b", ",", "c", ")", "\n", "assert", "not", "reachable", "(", "b", ",", "c", ")", "and", "not", "reachable", "(", "c", ",", "b", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "reachable", "(", "a", ",", "c", ")", "or", "reachable", "(", "c", ",", "a", ")", "\n", "\n", "", "add_bond", "(", "a", ",", "c", ")", "# cycle formed", "\n", "assert", "reachable", "(", "a", ",", "b", ")", "and", "reachable", "(", "b", ",", "a", ")", "\n", "assert", "reachable", "(", "b", ",", "c", ")", "and", "reachable", "(", "c", ",", "b", ")", "\n", "assert", "reachable", "(", "a", ",", "c", ")", "and", "reachable", "(", "c", ",", "a", ")", "\n", "\n", "d", "=", "new_atom", "(", "0", ",", "0", ",", "3", ")", "\n", "add_bond", "(", "a", ",", "d", ")", "# add unreachable group", "\n", "assert", "not", "reachable", "(", "a", ",", "d", ")", "and", "not", "reachable", "(", "d", ",", "a", ")", "\n", "\n", "e", "=", "new_atom", "(", "1", ",", "0", ",", "3", ")", "\n", "f", "=", "new_atom", "(", "0", ",", "2", ",", "3", ")", "\n", "add_bond", "(", "d", ",", "e", ")", "\n", "add_bond", "(", "d", ",", "f", ")", "\n", "add_bond", "(", "f", ",", "e", ")", "# form new cycle", "\n", "assert", "reachable", "(", "d", ",", "e", ")", "and", "reachable", "(", "e", ",", "d", ")", "\n", "assert", "reachable", "(", "d", ",", "f", ")", "and", "reachable", "(", "f", ",", "d", ")", "\n", "assert", "reachable", "(", "f", ",", "e", ")", "and", "reachable", "(", "e", ",", "f", ")", "\n", "\n", "#a.SetAtomicNum(8)", "\n", "#a.GetBond(d).SetBondOrder(2)", "\n", "#mols.write_ob_mols_to_sdf_file('tests/output/TEST_reachable.sdf', [mol])", "\n", "\n", "# atoms connecting the two cycles should be unreachable", "\n", "assert", "not", "reachable", "(", "a", ",", "d", ")", "and", "not", "reachable", "(", "d", ",", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_bond_adding.test_reachable_recursion": [[316, 334], ["f", "dense.GetAtom", "dense.GetAtom", "dense.GetBond", "liGAN.bond_adding.reachable", "pytest.raises", "f", "dense.NumAtoms", "f"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.bond_adding.reachable"], ["", "def", "test_reachable_recursion", "(", "dense", ")", ":", "\n", "    ", "'''\n    Test the recursive function that decides\n    if two atoms are reachable without using\n    the bond between them.\n    '''", "\n", "f", "=", "lambda", "n", ":", "f", "(", "n", "-", "1", ")", "if", "n", ">", "0", "else", "True", "\n", "assert", "f", "(", "100", ")", "\n", "with", "pytest", ".", "raises", "(", "RecursionError", ")", ":", "\n", "        ", "f", "(", "1000", ")", "\n", "\n", "# the first and last atoms should take a", "\n", "#   a pathologically long time to reach", "\n", "", "atom_a", "=", "dense", ".", "GetAtom", "(", "1", ")", "\n", "atom_b", "=", "dense", ".", "GetAtom", "(", "dense", ".", "NumAtoms", "(", ")", ")", "\n", "assert", "atom_a", "and", "atom_b", ",", "(", "atom_a", ",", "atom_b", ")", "\n", "assert", "dense", ".", "GetBond", "(", "atom_a", ",", "atom_b", ")", ",", "'not bonded'", "\n", "assert", "reachable", "(", "atom_a", ",", "atom_b", ")", ",", "'not reachable'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_generating.TestGenerator.test_generator_init": [[68, 82], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "type", "type", "len", "type"], "methods", ["None"], ["    ", "def", "test_generator_init", "(", "self", ",", "generator", ")", ":", "\n", "\n", "        ", "assert", "type", "(", "generator", ".", "gen_model", ")", "==", "type", "(", "generator", ")", ".", "gen_model_type", "\n", "generator_name", "=", "type", "(", "generator", ")", ".", "__name__", "\n", "assert", "generator", ".", "has_complex_input", "==", "(", "'CVAE'", "in", "generator_name", ")", "\n", "\n", "assert", "isinstance", "(", "generator", ".", "data", ",", "liGAN", ".", "data", ".", "AtomGridData", ")", "\n", "assert", "isinstance", "(", "generator", ".", "atom_fitter", ",", "liGAN", ".", "atom_fitting", ".", "AtomFitter", ")", "\n", "assert", "isinstance", "(", "generator", ".", "bond_adder", ",", "liGAN", ".", "bond_adding", ".", "BondAdder", ")", "\n", "assert", "isinstance", "(", "generator", ".", "out_writer", ",", "liGAN", ".", "generating", ".", "OutputWriter", ")", "\n", "assert", "isinstance", "(", "generator", ".", "out_writer", ".", "metrics", ",", "pd", ".", "DataFrame", ")", "\n", "assert", "len", "(", "generator", ".", "out_writer", ".", "metrics", ")", "==", "0", "\n", "if", "generator", ".", "data", ".", "diff_cond_structs", "or", "generator", ".", "data", ".", "diff_cond_transform", ":", "\n", "            ", "assert", "generator", ".", "out_writer", ".", "grid_types", ">", "{", "'cond_rec'", ",", "'cond_lig'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_generating.TestGenerator.test_gen_forward": [[85, 114], ["generator.forward", "input_rec_grids.norm", "input_lig_grids.norm", "cond_rec_grids.norm", "cond_lig_grids.norm", "latents.norm", "lig_gen_grids.norm"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "", "def", "test_gen_forward", "(", "self", ",", "generator", ")", ":", "\n", "        ", "(", "\n", "input_grids", ",", "cond_grids", ",", "input_structs", ",", "cond_structs", ",", "\n", "latents", ",", "lig_gen_grids", ",", "transforms", "\n", ")", "=", "generator", ".", "forward", "(", "prior", "=", "False", ",", "stage2", "=", "False", ")", "\n", "input_rec_grids", ",", "input_lig_grids", "=", "input_grids", "\n", "cond_rec_grids", ",", "cond_lig_grids", "=", "cond_grids", "\n", "input_rec_structs", ",", "input_lig_structs", "=", "input_structs", "\n", "cond_rec_structs", ",", "cond_lig_structs", "=", "cond_structs", "\n", "input_transforms", ",", "cond_transforms", "=", "transforms", "\n", "\n", "if", "generator", ".", "data", ".", "diff_cond_structs", ":", "\n", "            ", "assert", "cond_rec_structs", "!=", "input_rec_structs", "\n", "assert", "cond_lig_structs", "!=", "input_lig_structs", "\n", "", "else", ":", "\n", "            ", "assert", "cond_rec_structs", "==", "input_rec_structs", "\n", "assert", "cond_lig_structs", "==", "input_lig_structs", "\n", "\n", "", "if", "generator", ".", "data", ".", "diff_cond_transform", ":", "\n", "            ", "assert", "cond_transforms", "!=", "input_transforms", "\n", "", "else", ":", "\n", "            ", "assert", "cond_transforms", "==", "input_transforms", "\n", "\n", "", "assert", "input_rec_grids", ".", "norm", "(", ")", ">", "0", ",", "'input rec grids are zero'", "\n", "assert", "input_lig_grids", ".", "norm", "(", ")", ">", "0", ",", "'input lig grids are zero'", "\n", "assert", "cond_rec_grids", ".", "norm", "(", ")", ">", "0", ",", "'cond rec grids are zero'", "\n", "assert", "cond_lig_grids", ".", "norm", "(", ")", ">", "0", ",", "'cond lig grids are zero'", "\n", "assert", "latents", ".", "norm", "(", ")", ">", "0", ",", "'latent vecs are zero'", "\n", "assert", "lig_gen_grids", ".", "norm", "(", ")", ">", "0", ",", "'lig gen grids are zero'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_generating.TestGenerator.test_gen_forward2": [[115, 146], ["generator.forward", "generator.forward"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.forward"], ["", "def", "test_gen_forward2", "(", "self", ",", "generator", ")", ":", "\n", "        ", "input_grids", ",", "cond_grids", ",", "input_structs", ",", "cond_structs", ",", "_", ",", "_", ",", "_", "=", "generator", ".", "forward", "(", "prior", "=", "False", ",", "stage2", "=", "False", ")", "\n", "input_rec_grids0", ",", "input_lig_grids0", "=", "input_grids", "\n", "cond_rec_grids0", ",", "cond_lig_grids0", "=", "cond_grids", "\n", "input_rec_structs0", ",", "input_lig_structs0", "=", "input_structs", "\n", "cond_rec_structs0", ",", "cond_lig_structs0", "=", "cond_structs", "\n", "\n", "input_grids", ",", "cond_grids", ",", "input_structs", ",", "cond_structs", ",", "_", ",", "_", ",", "_", "=", "generator", ".", "forward", "(", "prior", "=", "False", ",", "stage2", "=", "False", ")", "\n", "input_rec_grids1", ",", "input_lig_grids1", "=", "input_grids", "\n", "cond_rec_grids1", ",", "cond_lig_grids1", "=", "cond_grids", "\n", "input_rec_structs1", ",", "input_lig_structs1", "=", "input_structs", "\n", "cond_rec_structs1", ",", "cond_lig_structs1", "=", "cond_structs", "\n", "\n", "assert", "input_rec_structs1", "!=", "input_rec_structs0", ",", "'input rec structs are the same'", "\n", "assert", "input_lig_structs1", "!=", "input_lig_structs0", ",", "'input lig structs are the same'", "\n", "assert", "cond_rec_structs1", "!=", "cond_rec_structs0", ",", "'cond rec structs are the same'", "\n", "assert", "cond_lig_structs1", "!=", "cond_lig_structs0", ",", "'cond lig structs are the same'", "\n", "assert", "(", "input_rec_grids1", "!=", "input_rec_grids0", ")", ".", "any", "(", ")", ",", "'input rec grids are the same'", "\n", "assert", "(", "input_lig_grids1", "!=", "input_lig_grids0", ")", ".", "any", "(", ")", ",", "'input lig grids are the same'", "\n", "assert", "(", "cond_rec_grids1", "!=", "cond_rec_grids0", ")", ".", "any", "(", ")", ",", "'cond rec grids are the same'", "\n", "assert", "(", "cond_lig_grids1", "!=", "cond_lig_grids0", ")", ".", "any", "(", ")", ",", "'cond lig grids are the same'", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_generating.TestGenerator.test_generate": [[147, 158], ["generator.generate", "print", "m.reset_index().set_index.reset_index().set_index.reset_index().set_index", "print", "len", "print", "m.reset_index().set_index.reset_index().set_index.reset_index"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.MoleculeGenerator.generate", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "test_generate", "(", "self", ",", "generator", ")", ":", "\n", "        ", "m", "=", "generator", ".", "generate", "(", "n_examples", "=", "1", ",", "n_samples", "=", "5", ")", "\n", "print", "(", "generator", ".", "out_writer", ".", "grid_types", ")", "\n", "assert", "len", "(", "m", ")", ">", "0", ",", "'empty metrics'", "\n", "m", "=", "m", ".", "reset_index", "(", ")", ".", "set_index", "(", "[", "'example_idx'", ",", "'sample_idx'", "]", ")", "\n", "print", "(", "m", ")", "\n", "if", "generator", ".", "data", ".", "diff_cond_structs", ":", "\n", "            ", "rec_prod", "=", "m", "[", "'lig_gen_rec_prod'", "]", "\n", "cond_rec_prod", "=", "m", "[", "'lig_gen_cond_rec_prod'", "]", "\n", "print", "(", "(", "cond_rec_prod", "-", "rec_prod", ")", ".", "describe", "(", ")", ")", "\n", "assert", "False", ",", "'OK'", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mattragoza_liGAN.tests.test_generating.generator": [[14, 62], ["pytest.fixture", "getattr", "getattr.", "dict", "dict", "dict", "dict", "dict", "dict"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", "params", "=", "[", "\n", "'data/test_pockets/AROK_MYCTU_1_176_0/fixed_input_1zyu_A_rec_mutants.types'", ",", "\n", "'data/test_pockets/AROK_MYCTU_1_176_0/fixed_cond_1zyu_A_rec_mutants.types'", ",", "\n", "#'data/test_pockets/AROK_MYCTU_1_176_0/fixed_input_no_rec_mutants.types',", "\n", "#'data/test_pockets/AROK_MYCTU_1_176_0/fixed_cond_no_rec_mutants.types',", "\n", "]", ")", "\n", "def", "generator", "(", "request", ")", ":", "\n", "    ", "data_file", "=", "request", ".", "param", "\n", "generator_name", ",", "diff_cond_transform", ",", "diff_cond_structs", "=", "'CVAE'", ",", "0", ",", "1", "\n", "generator_type", "=", "getattr", "(", "liGAN", ".", "generating", ",", "generator_name", "+", "'Generator'", ")", "\n", "return", "generator_type", "(", "\n", "data_kws", "=", "dict", "(", "\n", "data_file", "=", "data_file", ",", "\n", "data_root", "=", "'data/crossdock2020'", ",", "\n", "batch_size", "=", "1", ",", "\n", "rec_typer", "=", "'oadc-1.0'", ",", "\n", "lig_typer", "=", "'oadc-1.0'", ",", "\n", "resolution", "=", "1.0", ",", "\n", "grid_size", "=", "16", ",", "\n", "shuffle", "=", "False", ",", "\n", "random_rotation", "=", "True", ",", "\n", "random_translation", "=", "0", ",", "\n", "diff_cond_transform", "=", "diff_cond_transform", ",", "\n", "diff_cond_structs", "=", "diff_cond_structs", ",", "\n", "cache_structs", "=", "False", ",", "\n", ")", ",", "\n", "gen_model_kws", "=", "dict", "(", "\n", "n_filters", "=", "8", ",", "\n", "n_levels", "=", "4", ",", "\n", "conv_per_level", "=", "1", ",", "\n", "spectral_norm", "=", "1", ",", "\n", "n_latent", "=", "128", ",", "\n", "init_conv_pool", "=", "False", ",", "\n", "skip_connect", "=", "generator_type", ".", "gen_model_type", ".", "has_conditional_encoder", ",", "\n", ")", ",", "\n", "prior_model_kws", "=", "dict", "(", "\n", "n_h_layers", "=", "1", ",", "\n", "n_h_units", "=", "96", ",", "\n", "n_latent", "=", "64", ",", "\n", ")", ",", "\n", "atom_fitting_kws", "=", "dict", "(", ")", ",", "\n", "bond_adding_kws", "=", "dict", "(", ")", ",", "\n", "output_kws", "=", "dict", "(", "batch_metrics", "=", "False", ")", ",", "\n", "n_samples", "=", "5", ",", "\n", "fit_atoms", "=", "True", ",", "\n", "out_prefix", "=", "f'tests/output/TEST_{generator_name}'", ",", "\n", "device", "=", "'cuda'", ",", "\n", "debug", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.get_common_prefix": [[11, 15], ["enumerate", "zip", "len", "set"], "function", ["None"], ["def", "get_common_prefix", "(", "strs", ")", ":", "\n", "    ", "for", "i", ",", "chars", "in", "enumerate", "(", "zip", "(", "*", "strs", ")", ")", ":", "\n", "        ", "if", "len", "(", "set", "(", "chars", ")", ")", ">", "1", ":", "\n", "            ", "return", "strs", "[", "0", "]", "[", ":", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.get_color": [[17, 34], ["atom_types.get_rgb", "grid_type.endswith"], "function", ["None"], ["", "", "", "def", "get_color", "(", "grid_type", ",", "atomic_num", ")", ":", "\n", "    ", "'''\n    Color atomic density isosurfaces by\n    element, using different colors for\n    carbon depending on the grid_type.\n    '''", "\n", "if", "atomic_num", "==", "6", ":", "\n", "        ", "if", "grid_type", "==", "'rec'", ":", "\n", "            ", "return", "[", "0.8", ",", "0.8", ",", "0.8", "]", "# gray", "\n", "", "elif", "grid_type", "==", "'lig_gen'", ":", "\n", "            ", "return", "[", "1.0", ",", "0.0", ",", "1.0", "]", "# magenta", "\n", "", "elif", "grid_type", ".", "endswith", "(", "'fit'", ")", ":", "\n", "            ", "return", "[", "0.0", ",", "1.0", ",", "0.0", "]", "# green", "\n", "", "else", ":", "\n", "            ", "return", "[", "0.0", ",", "1.0", ",", "1.0", "]", "# cyan", "\n", "", "", "else", ":", "\n", "        ", "return", "atom_types", ".", "get_rgb", "(", "atomic_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.as_bool": [[36, 43], ["bool"], "function", ["None"], ["", "", "def", "as_bool", "(", "s", ")", ":", "\n", "    ", "if", "s", "in", "{", "'True'", ",", "'true'", ",", "'T'", ",", "'t'", ",", "'1'", "}", ":", "\n", "        ", "return", "True", "\n", "", "elif", "s", "in", "{", "'False'", ",", "'false'", ",", "'F'", ",", "'f'", ",", "'0'", "}", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "return", "bool", "(", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.set_atom_level": [[45, 177], ["pymol_util.as_bool", "pymol_util.as_bool", "channels_by_name.keys", "pymol.cmd.get_names", "re.compile", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "enumerate", "collections.OrderedDict.items", "print", "atom_types.get_channels_from_file", "atom_types.get_channels_from_file", "re.match", "os.path.basename", "re.compile.match", "surface_format.format", "pymol.cmd.isosurface", "pymol.cmd.color", "print", "pymol.cmd.group", "atom_types.get_default_rec_channels", "atom_types.get_default_lig_channels", "pymol.cmd.set_color", "fnmatch.fnmatch", "grids.append", "os.getcwd", "grid_re.match.group", "grid_re.match.group", "int", "grid_re.match.group", "grouped_surfaces[].append", "grouped_lig_names[].append", "pymol_util.get_color", "grid_re.match.group", "print", "print", "grid_re.match.groupdict", "len", "len"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.as_bool", "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.as_bool", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_from_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_channels_from_file", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_default_rec_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.atom_types.get_default_lig_channels", "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.get_color", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "", "def", "set_atom_level", "(", "\n", "level", ",", "\n", "selection", "=", "'*'", ",", "\n", "state", "=", "None", ",", "\n", "rec_map", "=", "None", ",", "\n", "lig_map", "=", "None", ",", "\n", "interp", "=", "False", ",", "\n", "job_name", "=", "None", ",", "\n", "array_job", "=", "False", ",", "\n", ")", ":", "\n", "    ", "interp", "=", "as_bool", "(", "interp", ")", "\n", "array_job", "=", "as_bool", "(", "array_job", ")", "\n", "\n", "# get atom type channel info and set custom colors", "\n", "try", ":", "\n", "        ", "rec_channels", "=", "atom_types", ".", "get_channels_from_file", "(", "rec_map", ")", "\n", "", "except", ":", "\n", "        ", "rec_channels", "=", "atom_types", ".", "get_default_rec_channels", "(", ")", "\n", "", "try", ":", "\n", "        ", "lig_channels", "=", "atom_types", ".", "get_channels_from_file", "(", "lig_map", ")", "\n", "", "except", ":", "\n", "        ", "lig_channels", "=", "atom_types", ".", "get_default_lig_channels", "(", ")", "\n", "\n", "", "channels", "=", "rec_channels", "+", "lig_channels", "\n", "channels_by_name", "=", "{", "ch", ".", "name", ":", "ch", "for", "ch", "in", "channels", "}", "\n", "channel_names", "=", "channels_by_name", ".", "keys", "(", ")", "\n", "\n", "for", "ch", "in", "channels", ":", "\n", "        ", "for", "grid_type", "in", "[", "'rec'", ",", "'lig'", ",", "'lig_gen'", ",", "'lig_fit'", ",", "'lig_gen_fit'", "]", ":", "\n", "            ", "color_name", "=", "grid_type", "+", "'_'", "+", "ch", ".", "name", "\n", "cmd", ".", "set_color", "(", "color_name", "+", "'$'", ",", "get_color", "(", "grid_type", ",", "ch", ".", "atomic_num", ")", ")", "\n", "\n", "# We sort grids based on two different criteria before creating surfaces", "\n", "# for each grid. The first criteria determines what STATE to put the", "\n", "# surface in, the second determines what GROUP to put it in.", "\n", "\n", "# We expect grid names to store info in the following basic format:", "\n", "#   {job_name}_{lig_name}_{grid_type}_{sample_idx}_{channel_name}", "\n", "\n", "# By default,", "\n", "#   group=(job_name, lig_name, grid_type)", "\n", "#   state=(sample_idx,)", "\n", "\n", "# With interp=True,", "\n", "#   group=(job_name, grid_type)", "\n", "#   state=(lig_name, sample_idx)", "\n", "\n", "# get list of selected grid objects", "\n", "", "", "grids", "=", "[", "]", "\n", "for", "obj", "in", "cmd", ".", "get_names", "(", "'objects'", ")", ":", "\n", "        ", "m", "=", "re", ".", "match", "(", "r'^(.*)(\\.dx|_grid)$'", ",", "obj", ")", "\n", "if", "m", "and", "fnmatch", ".", "fnmatch", "(", "obj", ",", "selection", ")", ":", "\n", "            ", "grids", ".", "append", "(", "obj", ")", "\n", "\n", "# try to infer the job_name from working directory", "\n", "", "", "if", "job_name", "is", "None", ":", "\n", "        ", "job_name", "=", "os", ".", "path", ".", "basename", "(", "os", ".", "getcwd", "(", ")", ")", "\n", "\n", "# create a regex for parsing grid names", "\n", "", "grid_re_fields", "=", "[", "r'(?P<job_name>{})'", ".", "format", "(", "job_name", ")", "]", "\n", "\n", "if", "array_job", ":", "\n", "        ", "grid_re_fields", "+=", "[", "r'(?P<array_idx>\\d+)'", "]", "\n", "\n", "", "grid_re_fields", "+=", "[", "\n", "r'(?P<lig_name>.+)'", ",", "\n", "r'(?P<grid_type>rec|lig(_gen)?(_conv|_fit)?)'", ",", "\n", "r'(?P<sample_idx>\\d+)'", ",", "\n", "r'(?P<channel_name>{})'", ".", "format", "(", "'|'", ".", "join", "(", "channel_names", ")", ")", ",", "\n", "]", "\n", "grid_re", "=", "re", ".", "compile", "(", "'^'", "+", "'_'", ".", "join", "(", "grid_re_fields", ")", "+", "r'(\\.dx|_grid)$'", ")", "\n", "\n", "# assign grids to groups and states", "\n", "grouped_surfaces", "=", "OrderedDict", "(", ")", "\n", "grouped_lig_names", "=", "OrderedDict", "(", ")", "\n", "state_counter", "=", "OrderedDict", "(", ")", "\n", "\n", "for", "i", ",", "grid", "in", "enumerate", "(", "grids", ")", ":", "\n", "\n", "        ", "m", "=", "grid_re", ".", "match", "(", "grid", ")", "\n", "try", ":", "\n", "            ", "lig_name", "=", "m", ".", "group", "(", "'lig_name'", ")", "\n", "grid_type", "=", "m", ".", "group", "(", "'grid_type'", ")", "\n", "sample_idx", "=", "int", "(", "m", ".", "group", "(", "'sample_idx'", ")", ")", "\n", "channel_name", "=", "m", ".", "group", "(", "'channel_name'", ")", "\n", "", "except", ":", "\n", "            ", "print", "(", "grid_re", ")", "\n", "print", "(", "grid", ")", "\n", "raise", "\n", "\n", "", "if", "interp", ":", "\n", "            ", "group_criteria", "=", "(", "job_name", ",", "grid_type", ")", "\n", "state_criteria", "=", "(", "lig_name", ",", "sample_idx", ")", "\n", "surface_format", "=", "'{job_name}_{grid_type}_{channel_name}_surface'", "\n", "", "else", ":", "\n", "            ", "group_criteria", "=", "(", "job_name", ",", "lig_name", ",", "grid_type", ")", "\n", "state_criteria", "=", "sample_idx", "\n", "surface_format", "=", "'{job_name}_{lig_name}_{grid_type}_{channel_name}_surface'", "\n", "\n", "", "surface", "=", "surface_format", ".", "format", "(", "**", "m", ".", "groupdict", "(", ")", ")", "\n", "\n", "if", "state_criteria", "not", "in", "state_counter", ":", "\n", "            ", "state_counter", "[", "state_criteria", "]", "=", "len", "(", "state_counter", ")", "+", "1", "\n", "", "s", "=", "state_counter", "[", "state_criteria", "]", "\n", "\n", "if", "group_criteria", "not", "in", "grouped_surfaces", ":", "\n", "            ", "grouped_surfaces", "[", "group_criteria", "]", "=", "[", "]", "\n", "grouped_lig_names", "[", "group_criteria", "]", "=", "[", "]", "\n", "\n", "", "if", "surface", "not", "in", "grouped_surfaces", "[", "group_criteria", "]", ":", "\n", "            ", "grouped_surfaces", "[", "group_criteria", "]", ".", "append", "(", "surface", ")", "\n", "\n", "", "if", "lig_name", "not", "in", "grouped_lig_names", "[", "group_criteria", "]", ":", "\n", "            ", "grouped_lig_names", "[", "group_criteria", "]", ".", "append", "(", "lig_name", ")", "\n", "\n", "", "channel", "=", "channels_by_name", "[", "channel_name", "]", "\n", "cmd", ".", "isosurface", "(", "surface", ",", "grid", ",", "level", "=", "level", ",", "state", "=", "s", ")", "\n", "cmd", ".", "color", "(", "grid_type", "+", "'_'", "+", "channel", ".", "name", "+", "'$'", ",", "surface", ")", "\n", "print", "(", "'[{}/{}] {}'", ".", "format", "(", "i", "+", "1", ",", "len", "(", "grids", ")", ",", "surface", ",", "group_criteria", ",", "s", ")", ")", "\n", "\n", "", "for", "group_criteria", ",", "surfaces", "in", "grouped_surfaces", ".", "items", "(", ")", ":", "\n", "        ", "if", "interp", ":", "\n", "            ", "job_name", ",", "grid_type", "=", "group_criteria", "\n", "lig_names", "=", "grouped_lig_names", "[", "group_criteria", "]", "\n", "surface_group", "=", "'_'", ".", "join", "(", "\n", "(", "job_name", ",", "'_to_'", ".", "join", "(", "lig_names", ")", ",", "grid_type", ")", "\n", ")", "+", "'_surfaces'", "\n", "", "else", ":", "\n", "            ", "surface_group", "=", "'_'", ".", "join", "(", "group_criteria", ")", "+", "'_surfaces'", "\n", "", "cmd", ".", "group", "(", "surface_group", ",", "' '", ".", "join", "(", "surfaces", ")", ")", "\n", "\n", "", "print", "(", "'Done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.join_structs": [[179, 260], ["re.compile", "collections.OrderedDict", "collections.OrderedDict", "pymol.cmd.get_names", "collections.OrderedDict.items", "print", "os.path.basename", "re.compile.match", "struct_re.match.group", "struct_re.match.group", "int", "print", "pymol.cmd.join_states", "os.getcwd", "fnmatch.fnmatch", "struct_re.match.group", "lig_names_to_join[].append", "lig_names_to_join[].index", "structs_to_join[].append", "pymol.cmd.delete", "sorted"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "join_structs", "(", "\n", "selection", "=", "'*'", ",", "\n", "job_name", "=", "None", ",", "\n", "array_job", "=", "False", ",", "\n", "interp", "=", "False", ",", "\n", "delete", "=", "False", ",", "\n", ")", ":", "\n", "    ", "'''\n    join_structs selection=*, job_name=None, array_job=False, interp=False, delete=False\n    '''", "\n", "# try to infer the job_name from working directory", "\n", "if", "job_name", "is", "None", ":", "\n", "        ", "job_name", "=", "os", ".", "path", ".", "basename", "(", "os", ".", "getcwd", "(", ")", ")", "\n", "\n", "# create regex to parse struct names", "\n", "", "struct_re_fields", "=", "[", "r'(?P<job_name>{})'", ".", "format", "(", "job_name", ")", "]", "\n", "\n", "if", "array_job", ":", "\n", "        ", "struct_re_fields", "+=", "[", "r'(?P<array_idx>\\d+)'", "]", "\n", "\n", "", "struct_re_fields", "+=", "[", "\n", "r'(?P<lig_name>.+)'", ",", "\n", "r'(?P<struct_type>lig(_gen)?(_fit)?(_add|_src)?(_uff)?)'", ",", "\n", "r'(?P<sample_idx>\\d+)'", ",", "\n", "]", "\n", "\n", "struct_pat", "=", "'^'", "+", "'_'", ".", "join", "(", "struct_re_fields", ")", "+", "'$'", "\n", "struct_re", "=", "re", ".", "compile", "(", "struct_pat", ")", "\n", "\n", "# keep track of which structs to join and their lig_names", "\n", "structs_to_join", "=", "OrderedDict", "(", ")", "\n", "lig_names_to_join", "=", "OrderedDict", "(", ")", "\n", "\n", "for", "obj", "in", "cmd", ".", "get_names", "(", "'objects'", ")", ":", "\n", "\n", "        ", "if", "not", "fnmatch", ".", "fnmatch", "(", "obj", ",", "selection", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "m", "=", "struct_re", ".", "match", "(", "obj", ")", "\n", "if", "not", "m", ":", "\n", "            ", "continue", "\n", "", "struct", "=", "obj", "\n", "\n", "lig_name", "=", "m", ".", "group", "(", "'lig_name'", ")", "\n", "struct_type", "=", "m", ".", "group", "(", "'struct_type'", ")", "\n", "sample_idx", "=", "int", "(", "m", ".", "group", "(", "'sample_idx'", ")", ")", "\n", "\n", "if", "interp", ":", "# join different lig_names", "\n", "            ", "join_criteria", "=", "(", "job_name", ",", "struct_type", ")", "\n", "", "else", ":", "\n", "            ", "join_criteria", "=", "(", "job_name", ",", "lig_name", ",", "struct_type", ")", "\n", "\n", "", "if", "join_criteria", "not", "in", "structs_to_join", ":", "\n", "            ", "structs_to_join", "[", "join_criteria", "]", "=", "[", "]", "\n", "lig_names_to_join", "[", "join_criteria", "]", "=", "[", "]", "\n", "\n", "", "if", "lig_name", "not", "in", "lig_names_to_join", "[", "join_criteria", "]", ":", "\n", "            ", "lig_names_to_join", "[", "join_criteria", "]", ".", "append", "(", "lig_name", ")", "\n", "\n", "", "if", "struct", "not", "in", "structs_to_join", "[", "join_criteria", "]", ":", "\n", "            ", "lig_idx", "=", "lig_names_to_join", "[", "join_criteria", "]", ".", "index", "(", "lig_name", ")", "\n", "structs_to_join", "[", "join_criteria", "]", ".", "append", "(", "\n", "(", "lig_idx", ",", "sample_idx", ",", "struct", ")", "\n", ")", "\n", "\n", "", "", "for", "join_criteria", ",", "structs", "in", "structs_to_join", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "join_criteria", ")", "\n", "structs", "=", "[", "struct", "for", "_", ",", "_", ",", "struct", "in", "sorted", "(", "structs", ")", "]", "\n", "lig_names", "=", "lig_names_to_join", "[", "join_criteria", "]", "\n", "if", "interp", ":", "\n", "            ", "job_name", ",", "struct_type", "=", "join_criteria", "\n", "", "else", ":", "\n", "            ", "job_name", ",", "lig_name", ",", "struct_type", "=", "join_criteria", "\n", "", "joined_struct", "=", "'_'", ".", "join", "(", "\n", "(", "job_name", ",", "'_to_'", ".", "join", "(", "lig_names", ")", ",", "struct_type", ")", "\n", ")", "\n", "cmd", ".", "join_states", "(", "joined_struct", ",", "' '", ".", "join", "(", "structs", ")", ",", "0", ")", "\n", "if", "delete", ":", "\n", "            ", "cmd", ".", "delete", "(", "' '", ".", "join", "(", "structs", ")", ")", "\n", "\n", "", "", "print", "(", "'Done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.draw_interp": [[262, 322], ["pymol.cmd.get_names", "os.path.basename", "re.compile", "print", "re.match", "re.match", "os.getcwd", "re.compile.match", "interp_re.match.group", "os.path.join", "os.makedirs", "pymol.cmd.disable", "pymol.cmd.enable", "pymol.cmd.enable", "pymol.cmd.set", "pymol.cmd.mpng", "pymol.cmd.enable", "pymol.cmd.set", "pymol.cmd.mpng", "pymol.cmd.disable", "pymol.cmd.mpng", "structs.append", "fnmatch.fnmatch", "interp_prefixes.append", "os.path.join", "os.path.join", "os.path.join", "interp_re.match.group"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "draw_interp", "(", "out_dir", ",", "selection", "=", "'*'", ",", "width", "=", "1000", ",", "height", "=", "1000", ",", "antialias", "=", "2", ",", "dpi", "=", "-", "1", ")", ":", "\n", "\n", "    ", "structs", "=", "[", "]", "\n", "interp_prefixes", "=", "[", "]", "\n", "for", "obj", "in", "cmd", ".", "get_names", "(", "'objects'", ")", ":", "\n", "        ", "m", "=", "re", ".", "match", "(", "r'^.*lig(_gen)?(_fit)?(_add)?$'", ",", "obj", ")", "\n", "if", "m", ":", "\n", "            ", "structs", ".", "append", "(", "obj", ")", "\n", "", "m", "=", "re", ".", "match", "(", "r'^(.*_lig_gen)_surfaces$'", ",", "obj", ")", "\n", "if", "m", "and", "fnmatch", ".", "fnmatch", "(", "obj", ",", "selection", ")", ":", "\n", "            ", "interp_prefixes", ".", "append", "(", "m", ".", "group", "(", "1", ")", ")", "\n", "\n", "# try to infer the job_name from working directory", "\n", "", "", "job_name", "=", "os", ".", "path", ".", "basename", "(", "os", ".", "getcwd", "(", ")", ")", "\n", "\n", "# once we have a job_name, we can correctly parse the prefixes", "\n", "interp_re", "=", "re", ".", "compile", "(", "\n", "'^'", "+", "'_'", ".", "join", "(", "[", "\n", "r'(?P<job_name>{})'", ".", "format", "(", "job_name", ")", ",", "\n", "r'(?P<array_idx>\\d+)'", ",", "\n", "r'(?P<interp_name>(.+)_to_(.+))'", ",", "\n", "r'(?P<grid_type>lig(_gen)?(_fit)?)'", "\n", "]", ")", "+", "'$'", "\n", ")", "\n", "\n", "for", "interp_prefix", "in", "interp_prefixes", ":", "\n", "\n", "        ", "m", "=", "interp_re", ".", "match", "(", "interp_prefix", ")", "\n", "if", "not", "m", ":", "\n", "            ", "continue", "\n", "\n", "", "interp_name", "=", "m", ".", "group", "(", "'interp_name'", ")", "\n", "interp_dir", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "job_name", ",", "interp_name", ")", "\n", "os", ".", "makedirs", "(", "interp_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "density", "=", "interp_prefix", "+", "'_surfaces'", "\n", "struct", "=", "interp_prefix", "+", "'_fit_add'", "\n", "\n", "# hide everything except the grouped surface objects,", "\n", "# since their visibility is controlled by the group object", "\n", "cmd", ".", "disable", "(", "'all'", ")", "\n", "cmd", ".", "enable", "(", "'*_surface'", ")", "\n", "\n", "# density only", "\n", "cmd", ".", "enable", "(", "density", ")", "\n", "cmd", ".", "set", "(", "'transparency'", ",", "0.2", ",", "density", ")", "\n", "im_prefix", "=", "os", ".", "path", ".", "join", "(", "interp_dir", ",", "interp_prefix", ")", "+", "'_density_'", "\n", "cmd", ".", "mpng", "(", "im_prefix", ",", "first", "=", "0", ",", "last", "=", "0", ",", "mode", "=", "1", ",", "width", "=", "width", ",", "height", "=", "height", ")", "\n", "\n", "# density and struct", "\n", "cmd", ".", "enable", "(", "struct", ")", "\n", "cmd", ".", "set", "(", "'transparency'", ",", "0.5", ",", "density", ")", "\n", "im_prefix", "=", "os", ".", "path", ".", "join", "(", "interp_dir", ",", "interp_prefix", ")", "+", "'_both_'", "\n", "cmd", ".", "mpng", "(", "im_prefix", ",", "first", "=", "0", ",", "last", "=", "0", ",", "mode", "=", "1", ",", "width", "=", "width", ",", "height", "=", "height", ")", "\n", "\n", "cmd", ".", "disable", "(", "density", ")", "\n", "im_prefix", "=", "os", ".", "path", ".", "join", "(", "interp_dir", ",", "interp_prefix", ")", "+", "'_struct_'", "\n", "cmd", ".", "mpng", "(", "im_prefix", ",", "first", "=", "0", ",", "last", "=", "0", ",", "mode", "=", "1", ",", "width", "=", "width", ",", "height", "=", "height", ")", "\n", "\n", "", "print", "(", "'Done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.load_group": [[323, 331], ["glob.glob", "os.path.basename", "pymol.cmd.load", "group_objs.append", "pymol.cmd.group"], "function", ["None"], ["", "def", "load_group", "(", "pattern", ",", "name", ")", ":", "\n", "    ", "group_objs", "=", "[", "]", "\n", "for", "file", "in", "glob", ".", "glob", "(", "pattern", ")", ":", "\n", "        ", "obj", "=", "os", ".", "path", ".", "basename", "(", "file", ")", "\n", "cmd", ".", "load", "(", "file", ",", "obj", ")", "\n", "group_objs", ".", "append", "(", "obj", ")", "\n", "", "if", "group_objs", ":", "\n", "        ", "cmd", ".", "group", "(", "name", ",", "' '", ".", "join", "(", "group_objs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.my_rotate": [[333, 337], ["range", "int", "pymol.cmd.create", "pymol.cmd.rotate", "int", "float"], "function", ["None"], ["", "", "def", "my_rotate", "(", "name", ",", "axis", ",", "angle", ",", "states", ",", "**", "kwargs", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "int", "(", "states", ")", ")", ":", "\n", "        ", "cmd", ".", "create", "(", "name", ",", "name", ",", "1", ",", "i", "+", "1", ")", "\n", "cmd", ".", "rotate", "(", "axis", ",", "float", "(", "angle", ")", "*", "i", "/", "int", "(", "states", ")", ",", "name", ",", "state", "=", "i", "+", "1", ",", "camera", "=", "0", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.mutate": [[339, 349], ["pymol.cmd.wizard", "pymol.cmd.do", "pymol.cmd.get_wizard().set_mode", "pymol.cmd.get_wizard().do_select", "pymol.cmd.frame", "pymol.cmd.get_wizard().apply", "pymol.cmd.set_wizard", "pymol.cmd.refresh", "mode.upper", "str", "pymol.cmd.get_wizard", "pymol.cmd.get_wizard", "pymol.cmd.get_wizard"], "function", ["None"], ["", "", "def", "mutate", "(", "protein", ",", "resi", ",", "mode", "=", "'ALA'", ",", "chain", "=", "'A'", ")", ":", "\n", "    ", "cmd", ".", "wizard", "(", "'mutagenesis'", ")", "\n", "cmd", ".", "do", "(", "\"refresh_wizard\"", ")", "\n", "cmd", ".", "get_wizard", "(", ")", ".", "set_mode", "(", "mode", ".", "upper", "(", ")", ")", "\n", "selection", "=", "f'/{protein}//{chain}/{resi}'", "\n", "cmd", ".", "get_wizard", "(", ")", ".", "do_select", "(", "selection", ")", "\n", "cmd", ".", "frame", "(", "str", "(", "1", ")", ")", "\n", "cmd", ".", "get_wizard", "(", ")", ".", "apply", "(", ")", "\n", "cmd", ".", "set_wizard", "(", "'done'", ")", "\n", "cmd", ".", "refresh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.my_mutate": [[351, 403], ["dict", "pymol.cmd.iterate", "sorted", "pymol.cmd.copy", "pymol.cmd.save", "pymol.cmd.zoom", "print", "str", "pymol.cmd.copy", "pymol_util.mutate", "pymol.cmd.save", "set", "pymol.cmd.copy", "pymol_util.mutate", "pymol.cmd.save", "pymol_util.mutate"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print", "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.mutate", "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.mutate", "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.pymol_util.mutate"], ["", "def", "my_mutate", "(", "rec_name", ",", "lig_name", ",", "dist", ")", ":", "\n", "\n", "# select residues in rec_name within dist of lig_name", "\n", "#   and show them as lines, the rest as cartoon", "\n", "    ", "rec_pocket", "=", "f'byres {rec_name} within {dist} of {lig_name}'", "\n", "\n", "# get the names and indices of the pocket residues", "\n", "space", "=", "dict", "(", "residues", "=", "set", "(", ")", ")", "\n", "cmd", ".", "iterate", "(", "rec_pocket", ",", "'residues.add((resv, resn))'", ",", "space", "=", "space", ")", "\n", "residues", "=", "sorted", "(", "space", "[", "'residues'", "]", ")", "\n", "res_idxs", "=", "[", "str", "(", "i", ")", "for", "i", ",", "n", "in", "residues", "]", "\n", "res_idxs", "=", "'(resi '", "+", "'+'", ".", "join", "(", "res_idxs", ")", "+", "')'", "\n", "\n", "# create a mapping from charged residues to", "\n", "#   oppositely charged residues of similar size", "\n", "charge_map", "=", "{", "\n", "'ARG'", ":", "'GLU'", ",", "\n", "'HIS'", ":", "'ASP'", ",", "\n", "'LYS'", ":", "'GLU'", ",", "\n", "'ASP'", ":", "'LYS'", ",", "\n", "'GLU'", ":", "'LYS'", ",", "\n", "}", "\n", "\n", "# mutate each pocket residue individually", "\n", "for", "res_idx", ",", "res_name", "in", "residues", ":", "\n", "\n", "# make a mutant with the residue as alanine", "\n", "        ", "mut_name", "=", "f'{rec_name}_mut_{res_idx}_{res_name}_ALA'", "\n", "cmd", ".", "copy", "(", "mut_name", ",", "rec_name", ")", "\n", "mutate", "(", "mut_name", ",", "res_idx", ",", "'ALA'", ")", "\n", "cmd", ".", "save", "(", "mut_name", "+", "'.pdb'", ",", "mut_name", ")", "\n", "\n", "if", "res_name", "in", "charge_map", ":", "\n", "\n", "# make another mutant with the charge flipped", "\n", "            ", "inv_name", "=", "charge_map", "[", "res_name", "]", "\n", "mut_name", "=", "f'{rec_name}_mut_{res_idx}_{res_name}_{inv_name}'", "\n", "cmd", ".", "copy", "(", "mut_name", ",", "rec_name", ")", "\n", "mutate", "(", "mut_name", ",", "res_idx", ",", "inv_name", ")", "\n", "cmd", ".", "save", "(", "mut_name", "+", "'.pdb'", ",", "mut_name", ")", "\n", "\n", "# create one final mutant with ALL charges flipped", "\n", "", "", "mut_name", "=", "f'{rec_name}_mut_all_charges'", "\n", "cmd", ".", "copy", "(", "mut_name", ",", "rec_name", ")", "\n", "for", "res_idx", ",", "res_name", "in", "residues", ":", "\n", "        ", "if", "res_name", "in", "charge_map", ":", "\n", "            ", "inv_name", "=", "charge_map", "[", "res_name", "]", "\n", "mutate", "(", "mut_name", ",", "res_idx", ",", "inv_name", ")", "\n", "\n", "", "", "cmd", ".", "save", "(", "mut_name", "+", "'.pdb'", ",", "mut_name", ")", "\n", "cmd", ".", "zoom", "(", "rec_pocket", ")", "\n", "print", "(", "res_idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.LevelVar.__init__": [[52, 56], ["Tkinter.Variable.__init__", "isoslider.LevelVar.trace"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "self", ",", "master", ",", "name", ",", "level", ")", ":", "\n", "        ", "Tkinter", ".", "Variable", ".", "__init__", "(", "self", ",", "master", ",", "value", "=", "level", ")", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "trace", "(", "'w'", ",", "self", ".", "callback", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.LevelVar.callback": [[57, 59], ["pymol.cmd.isolevel", "isoslider.LevelVar.get"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "def", "callback", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "cmd", ".", "isolevel", "(", "self", ".", "name", ",", "self", ".", "get", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.LevelVar.increment": [[60, 62], ["isoslider.LevelVar.set", "round", "float", "isoslider.LevelVar.get"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "def", "increment", "(", "self", ",", "event", "=", "None", ",", "delta", "=", "DELTA", ")", ":", "\n", "        ", "self", ".", "set", "(", "round", "(", "float", "(", "self", ".", "get", "(", ")", ")", "+", "delta", ",", "DIGITS", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.LevelVar.decrement": [[63, 65], ["isoslider.LevelVar.increment"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.increment"], ["", "def", "decrement", "(", "self", ",", "event", "=", "None", ")", ":", "\n", "        ", "self", ".", "increment", "(", "None", ",", "-", "DELTA", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.LevelVar.bindscrollwheel": [[66, 69], ["element.bind", "element.bind"], "methods", ["None"], ["", "def", "bindscrollwheel", "(", "self", ",", "element", ")", ":", "\n", "        ", "element", ".", "bind", "(", "'<Button-4>'", ",", "self", ".", "increment", ")", "\n", "element", ".", "bind", "(", "'<Button-5>'", ",", "self", ".", "decrement", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__": [[77, 81], ["Tkinter.Variable.__init__", "isoslider.GroupLevelVar.trace"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.__init__"], ["def", "__init__", "(", "self", ",", "master", ",", "names", ",", "level", ")", ":", "\n", "        ", "Tkinter", ".", "Variable", ".", "__init__", "(", "self", ",", "master", ",", "value", "=", "level", ")", "\n", "self", ".", "names", "=", "names", "\n", "self", ".", "trace", "(", "'w'", ",", "self", ".", "callback", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.callback": [[82, 85], ["pymol.cmd.isolevel", "isoslider.GroupLevelVar.get"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "def", "callback", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "for", "name", "in", "self", ".", "names", ":", "\n", "            ", "cmd", ".", "isolevel", "(", "name", ",", "self", ".", "get", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.increment": [[86, 88], ["isoslider.GroupLevelVar.set", "round", "float", "isoslider.GroupLevelVar.get"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.scripts.interrupt.NamedPipe.get"], ["", "", "def", "increment", "(", "self", ",", "event", "=", "None", ",", "delta", "=", "DELTA", ")", ":", "\n", "        ", "self", ".", "set", "(", "round", "(", "float", "(", "self", ".", "get", "(", ")", ")", "+", "delta", ",", "DIGITS", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.decrement": [[89, 91], ["isoslider.GroupLevelVar.increment"], "methods", ["home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.increment"], ["", "def", "decrement", "(", "self", ",", "event", "=", "None", ")", ":", "\n", "        ", "self", ".", "increment", "(", "None", ",", "-", "DELTA", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.GroupLevelVar.bindscrollwheel": [[92, 95], ["element.bind", "element.bind"], "methods", ["None"], ["", "def", "bindscrollwheel", "(", "self", ",", "element", ")", ":", "\n", "        ", "element", ".", "bind", "(", "'<Button-4>'", ",", "self", ".", "increment", ")", "\n", "element", ".", "bind", "(", "'<Button-5>'", ",", "self", ".", "decrement", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.__init_plugin__": [[25, 27], ["pymol.plugins.addmenuitem"], "function", ["None"], ["def", "__init_plugin__", "(", "self", "=", "None", ")", ":", "\n", "    ", "plugins", ".", "addmenuitem", "(", "'Isocontour Slider'", ",", "isoslider", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.get_isoobjects": [[29, 44], ["pymol.cmd.get_names", "int", "int", "pymol.cmd.get_type", "pymol.cmd.isolevel", "r.append", "print"], "function", ["home.repos.pwc.inspect_result.mattragoza_liGAN.liGAN.generating.OutputWriter.print"], ["", "def", "get_isoobjects", "(", "state", "=", "1", ",", "quiet", "=", "1", ")", ":", "\n", "    ", "'''\n    Get a list of (name, isolevel) tuples for all isomesh and isosurface\n    objects.\n    '''", "\n", "state", ",", "quiet", "=", "int", "(", "state", ")", ",", "int", "(", "quiet", ")", "\n", "r", "=", "[", "]", "\n", "for", "name", "in", "cmd", ".", "get_names", "(", ")", ":", "\n", "        ", "t", "=", "cmd", ".", "get_type", "(", "name", ")", "\n", "if", "t", "in", "(", "'object:mesh'", ",", "'object:surface'", ")", ":", "\n", "            ", "level", "=", "cmd", ".", "isolevel", "(", "name", ",", "0", ",", "state", ",", "1", ")", "\n", "if", "not", "quiet", ":", "\n", "                ", "print", "(", "'%-20s %5.2f'", "%", "(", "name", ",", "level", ")", ")", "\n", "", "r", ".", "append", "(", "(", "name", ",", "level", ")", ")", "\n", "", "", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.mattragoza_liGAN.pymol.isoslider.isoslider": [[97, 162], ["float", "float", "Tkinter.Toplevel", "Tkinter.Frame", "Tkinter.Frame.pack", "Tkinter.DoubleVar", "isoslider.isoslider.fillmaster"], "function", ["None"], ["", "", "def", "isoslider", "(", "mm_min", "=", "0.0", ",", "mm_max", "=", "1.0", ")", ":", "\n", "    ", "'''\n    DESCRIPTION\n\n    Opens a dialog with isolevel sliders for all isomesh and isosurface\n    objects in PyMOL.\n    '''", "\n", "mm_min", "=", "float", "(", "mm_min", ")", "\n", "mm_max", "=", "float", "(", "mm_max", ")", "\n", "top", "=", "Tkinter", ".", "Toplevel", "(", "plugins", ".", "get_tk_root", "(", ")", ")", "\n", "master", "=", "Tkinter", ".", "Frame", "(", "top", ",", "padx", "=", "5", ",", "pady", "=", "5", ")", "\n", "master", ".", "pack", "(", "fill", "=", "\"both\"", ",", "expand", "=", "1", ")", "\n", "mmvar", "=", "Tkinter", ".", "DoubleVar", "(", "top", ",", "value", "=", "mm_min", ")", "\n", "\n", "def", "fillmaster", "(", ")", ":", "\n", "        ", "ffmt", "=", "'{:.'", "+", "str", "(", "DIGITS", ")", "+", "'f}'", "\n", "for", "child", "in", "list", "(", "master", ".", "children", ".", "values", "(", ")", ")", ":", "\n", "            ", "child", ".", "destroy", "(", ")", "\n", "\n", "", "mm", "=", "mmvar", ".", "get", "(", ")", "\n", "mmf", "=", "Tkinter", ".", "Frame", "(", "master", ")", "\n", "Tkinter", ".", "Label", "(", "mmf", ",", "text", "=", "ffmt", ".", "format", "(", "mm_min", ")", ")", ".", "grid", "(", "row", "=", "0", ",", "column", "=", "0", ",", "sticky", "=", "'w'", ")", "\n", "Tkinter", ".", "Label", "(", "mmf", ",", "text", "=", "ffmt", ".", "format", "(", "(", "mm_max", "+", "mm_min", ")", "/", "2", ")", ")", ".", "grid", "(", "row", "=", "0", ",", "column", "=", "1", ")", "\n", "Tkinter", ".", "Label", "(", "mmf", ",", "text", "=", "ffmt", ".", "format", "(", "mm_max", ")", ")", ".", "grid", "(", "row", "=", "0", ",", "column", "=", "2", ",", "sticky", "=", "'e'", ")", "\n", "mmf", ".", "grid", "(", "row", "=", "0", ",", "column", "=", "1", ",", "sticky", "=", "'ew'", ")", "\n", "mmf", ".", "columnconfigure", "(", "1", ",", "weight", "=", "1", ")", "\n", "\n", "names", "=", "[", "]", "\n", "for", "i", ",", "(", "name", ",", "level", ")", "in", "enumerate", "(", "get_isoobjects", "(", ")", ",", "1", ")", ":", "\n", "            ", "names", ".", "append", "(", "name", ")", "\n", "continue", "\n", "\n", "v", "=", "LevelVar", "(", "master", ",", "name", ",", "ffmt", ".", "format", "(", "level", ")", ")", "\n", "Tkinter", ".", "Label", "(", "master", ",", "text", "=", "name", ")", ".", "grid", "(", "row", "=", "i", "+", "2", ",", "column", "=", "0", ",", "sticky", "=", "\"w\"", ")", "\n", "e", "=", "Tkinter", ".", "Scale", "(", "master", ",", "orient", "=", "Tkinter", ".", "HORIZONTAL", ",", "\n", "from_", "=", "mm_min", ",", "to", "=", "mm_max", ",", "resolution", "=", "DELTA", ",", "\n", "showvalue", "=", "0", ",", "variable", "=", "v", ")", "\n", "e", ".", "grid", "(", "row", "=", "i", "+", "2", ",", "column", "=", "1", ",", "sticky", "=", "\"ew\"", ")", "\n", "v", ".", "bindscrollwheel", "(", "e", ")", "\n", "e", "=", "Tkinter", ".", "Entry", "(", "master", ",", "textvariable", "=", "v", ",", "width", "=", "6", ")", "\n", "e", ".", "grid", "(", "row", "=", "i", "+", "2", ",", "column", "=", "2", ",", "sticky", "=", "\"e\"", ")", "\n", "v", ".", "bindscrollwheel", "(", "e", ")", "\n", "master", ".", "columnconfigure", "(", "1", ",", "weight", "=", "1", ")", "\n", "\n", "", "v", "=", "GroupLevelVar", "(", "master", ",", "names", ",", "ffmt", ".", "format", "(", "mm_min", ")", ")", "\n", "Tkinter", ".", "Label", "(", "master", ",", "text", "=", "'all'", ")", ".", "grid", "(", "row", "=", "1", ",", "column", "=", "0", ",", "sticky", "=", "\"w\"", ")", "\n", "e", "=", "Tkinter", ".", "Scale", "(", "master", ",", "orient", "=", "Tkinter", ".", "HORIZONTAL", ",", "\n", "from_", "=", "mm_min", ",", "to", "=", "mm_max", ",", "resolution", "=", "DELTA", ",", "\n", "showvalue", "=", "0", ",", "variable", "=", "v", ")", "\n", "e", ".", "grid", "(", "row", "=", "1", ",", "column", "=", "1", ",", "sticky", "=", "\"ew\"", ")", "\n", "v", ".", "bindscrollwheel", "(", "e", ")", "\n", "e", "=", "Tkinter", ".", "Entry", "(", "master", ",", "textvariable", "=", "v", ",", "width", "=", "6", ")", "\n", "e", ".", "grid", "(", "row", "=", "1", ",", "column", "=", "2", ",", "sticky", "=", "\"e\"", ")", "\n", "v", ".", "bindscrollwheel", "(", "e", ")", "\n", "master", ".", "columnconfigure", "(", "1", ",", "weight", "=", "1", ")", "\n", "\n", "", "fillmaster", "(", ")", "\n", "\n", "bottom", "=", "Tkinter", ".", "Frame", "(", "top", ",", "padx", "=", "5", ")", "\n", "Tkinter", ".", "Label", "(", "bottom", ",", "text", "=", "\"+/-\"", ")", ".", "pack", "(", "side", "=", "Tkinter", ".", "LEFT", ")", "\n", "mmentry", "=", "Tkinter", ".", "Entry", "(", "bottom", ",", "textvariable", "=", "mmvar", ",", "width", "=", "6", ")", "\n", "mmentry", ".", "pack", "(", "side", "=", "Tkinter", ".", "LEFT", ")", "\n", "refresh", "=", "Tkinter", ".", "Button", "(", "bottom", ",", "text", "=", "\"Refresh\"", ",", "command", "=", "fillmaster", ")", "\n", "refresh", ".", "pack", "(", "side", "=", "Tkinter", ".", "LEFT", ")", "\n", "bottom", ".", "pack", "(", "side", "=", "Tkinter", ".", "BOTTOM", ",", "fill", "=", "\"x\"", ",", "expand", "=", "1", ")", "\n", "\n"]]}