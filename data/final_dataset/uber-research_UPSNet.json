{"home.repos.pwc.inspect_result.uber-research_UPSNet.utils.colormap.colormap": [[34, 122], ["numpy.array().astype", "np.array().astype.reshape", "numpy.array"], "function", ["None"], ["def", "colormap", "(", "rgb", "=", "False", ")", ":", "\n", "    ", "color_list", "=", "np", ".", "array", "(", "\n", "[", "\n", "0.000", ",", "0.447", ",", "0.741", ",", "\n", "0.850", ",", "0.325", ",", "0.098", ",", "\n", "0.929", ",", "0.694", ",", "0.125", ",", "\n", "0.494", ",", "0.184", ",", "0.556", ",", "\n", "0.466", ",", "0.674", ",", "0.188", ",", "\n", "0.301", ",", "0.745", ",", "0.933", ",", "\n", "0.635", ",", "0.078", ",", "0.184", ",", "\n", "0.300", ",", "0.300", ",", "0.300", ",", "\n", "0.600", ",", "0.600", ",", "0.600", ",", "\n", "1.000", ",", "0.000", ",", "0.000", ",", "\n", "1.000", ",", "0.500", ",", "0.000", ",", "\n", "0.749", ",", "0.749", ",", "0.000", ",", "\n", "0.000", ",", "1.000", ",", "0.000", ",", "\n", "0.000", ",", "0.000", ",", "1.000", ",", "\n", "0.667", ",", "0.000", ",", "1.000", ",", "\n", "0.333", ",", "0.333", ",", "0.000", ",", "\n", "0.333", ",", "0.667", ",", "0.000", ",", "\n", "0.333", ",", "1.000", ",", "0.000", ",", "\n", "0.667", ",", "0.333", ",", "0.000", ",", "\n", "0.667", ",", "0.667", ",", "0.000", ",", "\n", "0.667", ",", "1.000", ",", "0.000", ",", "\n", "1.000", ",", "0.333", ",", "0.000", ",", "\n", "1.000", ",", "0.667", ",", "0.000", ",", "\n", "1.000", ",", "1.000", ",", "0.000", ",", "\n", "0.000", ",", "0.333", ",", "0.500", ",", "\n", "0.000", ",", "0.667", ",", "0.500", ",", "\n", "0.000", ",", "1.000", ",", "0.500", ",", "\n", "0.333", ",", "0.000", ",", "0.500", ",", "\n", "0.333", ",", "0.333", ",", "0.500", ",", "\n", "0.333", ",", "0.667", ",", "0.500", ",", "\n", "0.333", ",", "1.000", ",", "0.500", ",", "\n", "0.667", ",", "0.000", ",", "0.500", ",", "\n", "0.667", ",", "0.333", ",", "0.500", ",", "\n", "0.667", ",", "0.667", ",", "0.500", ",", "\n", "0.667", ",", "1.000", ",", "0.500", ",", "\n", "1.000", ",", "0.000", ",", "0.500", ",", "\n", "1.000", ",", "0.333", ",", "0.500", ",", "\n", "1.000", ",", "0.667", ",", "0.500", ",", "\n", "1.000", ",", "1.000", ",", "0.500", ",", "\n", "0.000", ",", "0.333", ",", "1.000", ",", "\n", "0.000", ",", "0.667", ",", "1.000", ",", "\n", "0.000", ",", "1.000", ",", "1.000", ",", "\n", "0.333", ",", "0.000", ",", "1.000", ",", "\n", "0.333", ",", "0.333", ",", "1.000", ",", "\n", "0.333", ",", "0.667", ",", "1.000", ",", "\n", "0.333", ",", "1.000", ",", "1.000", ",", "\n", "0.667", ",", "0.000", ",", "1.000", ",", "\n", "0.667", ",", "0.333", ",", "1.000", ",", "\n", "0.667", ",", "0.667", ",", "1.000", ",", "\n", "0.667", ",", "1.000", ",", "1.000", ",", "\n", "1.000", ",", "0.000", ",", "1.000", ",", "\n", "1.000", ",", "0.333", ",", "1.000", ",", "\n", "1.000", ",", "0.667", ",", "1.000", ",", "\n", "0.167", ",", "0.000", ",", "0.000", ",", "\n", "0.333", ",", "0.000", ",", "0.000", ",", "\n", "0.500", ",", "0.000", ",", "0.000", ",", "\n", "0.667", ",", "0.000", ",", "0.000", ",", "\n", "0.833", ",", "0.000", ",", "0.000", ",", "\n", "1.000", ",", "0.000", ",", "0.000", ",", "\n", "0.000", ",", "0.167", ",", "0.000", ",", "\n", "0.000", ",", "0.333", ",", "0.000", ",", "\n", "0.000", ",", "0.500", ",", "0.000", ",", "\n", "0.000", ",", "0.667", ",", "0.000", ",", "\n", "0.000", ",", "0.833", ",", "0.000", ",", "\n", "0.000", ",", "1.000", ",", "0.000", ",", "\n", "0.000", ",", "0.000", ",", "0.167", ",", "\n", "0.000", ",", "0.000", ",", "0.333", ",", "\n", "0.000", ",", "0.000", ",", "0.500", ",", "\n", "0.000", ",", "0.000", ",", "0.667", ",", "\n", "0.000", ",", "0.000", ",", "0.833", ",", "\n", "0.000", ",", "0.000", ",", "1.000", ",", "\n", "0.000", ",", "0.000", ",", "0.000", ",", "\n", "0.143", ",", "0.143", ",", "0.143", ",", "\n", "0.286", ",", "0.286", ",", "0.286", ",", "\n", "0.429", ",", "0.429", ",", "0.429", ",", "\n", "0.571", ",", "0.571", ",", "0.571", ",", "\n", "0.714", ",", "0.714", ",", "0.714", ",", "\n", "0.857", ",", "0.857", ",", "0.857", ",", "\n", "1.000", ",", "1.000", ",", "1.000", "\n", "]", "\n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "color_list", "=", "color_list", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "*", "255", "\n", "if", "not", "rgb", ":", "\n", "        ", "color_list", "=", "color_list", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "", "return", "color_list", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.logging.create_logger": [[20, 48], ["os.path.exists", "os.path.join", "os.path.join", "logging.basicConfig", "logging.getLogger", "logging.getLogger.setLevel", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "os.path.exists", "os.makedirs", "os.path.basename().split", "os.path.exists", "os.makedirs", "os.path.exists", "os.makedirs", "time.strftime", "logging.Formatter", "image_set.split", "os.path.join", "os.path.basename"], "function", ["None"], ["def", "create_logger", "(", "root_output_path", ",", "cfg", ",", "image_set", ")", ":", "\n", "# set up logger", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "root_output_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "root_output_path", ")", "\n", "", "assert", "os", ".", "path", ".", "exists", "(", "root_output_path", ")", ",", "'{} does not exist'", ".", "format", "(", "root_output_path", ")", "\n", "\n", "cfg_name", "=", "os", ".", "path", ".", "basename", "(", "cfg", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "config_output_path", "=", "os", ".", "path", ".", "join", "(", "root_output_path", ",", "'{}'", ".", "format", "(", "cfg_name", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "config_output_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "config_output_path", ")", "\n", "\n", "", "image_sets", "=", "[", "iset", "for", "iset", "in", "image_set", ".", "split", "(", "'+'", ")", "]", "\n", "final_output_path", "=", "os", ".", "path", ".", "join", "(", "config_output_path", ",", "'{}'", ".", "format", "(", "'_'", ".", "join", "(", "image_sets", ")", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "final_output_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "final_output_path", ")", "\n", "\n", "", "log_file", "=", "'{}_{}.log'", ".", "format", "(", "cfg_name", ",", "time", ".", "strftime", "(", "'%Y-%m-%d-%H-%M'", ")", ")", "\n", "head", "=", "'%(asctime)-15s | %(filename)-10s | line %(lineno)-3d: %(message)s'", "\n", "logging", ".", "basicConfig", "(", "filename", "=", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "log_file", ")", ",", "format", "=", "head", ")", "\n", "global", "logger", "\n", "logger", "=", "logging", ".", "getLogger", "(", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "console", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "console", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "console", ".", "setFormatter", "(", "logging", ".", "Formatter", "(", "head", ")", ")", "\n", "logger", ".", "addHandler", "(", "console", ")", "\n", "\n", "return", "logger", ",", "final_output_path", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.__init__": [[19, 21], ["timer.Timer.reset"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.tic": [[22, 26], ["time.time"], "methods", ["None"], ["", "def", "tic", "(", "self", ")", ":", "\n", "# using time.time instead of time.clock because time time.clock", "\n", "# does not normalize for multithreading", "\n", "        ", "self", ".", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.toc": [[27, 36], ["time.time"], "methods", ["None"], ["", "def", "toc", "(", "self", ",", "average", "=", "True", ")", ":", "\n", "        ", "self", ".", "diff", "=", "time", ".", "time", "(", ")", "-", "self", ".", "start_time", "\n", "self", ".", "total_time", "+=", "self", ".", "diff", "\n", "self", ".", "calls", "+=", "1", "\n", "self", ".", "average_time", "=", "self", ".", "total_time", "/", "self", ".", "calls", "\n", "if", "average", ":", "\n", "            ", "return", "self", ".", "average_time", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "diff", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.reset": [[37, 43], ["None"], "methods", ["None"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "total_time", "=", "0.", "\n", "self", ".", "calls", "=", "0", "\n", "self", ".", "start_time", "=", "0.", "\n", "self", ".", "diff", "=", "0.", "\n", "self", ".", "average_time", "=", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.timeit": [[45, 58], ["time.time", "method", "time.time", "kw.get", "int", "print", "method.__name__.upper"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get"], ["", "", "def", "timeit", "(", "method", ")", ":", "\n", "    ", "def", "timed", "(", "*", "args", ",", "**", "kw", ")", ":", "\n", "        ", "ts", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "method", "(", "*", "args", ",", "**", "kw", ")", "\n", "te", "=", "time", ".", "time", "(", ")", "\n", "if", "'log_time'", "in", "kw", ":", "\n", "            ", "name", "=", "kw", ".", "get", "(", "'log_name'", ",", "method", ".", "__name__", ".", "upper", "(", ")", ")", "\n", "kw", "[", "'log_time'", "]", "[", "name", "]", "=", "int", "(", "(", "te", "-", "ts", ")", "*", "1000", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'%r  %2.2f ms'", "%", "(", "method", ".", "__name__", ",", "(", "te", "-", "ts", ")", "*", "1000", ")", ")", "\n", "", "return", "result", "\n", "", "return", "timed", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.__init__": [[80, 102], ["torch.nn.modules.Module.__init__", "data_parallel._check_balance", "torch.cuda.is_available", "list", "len", "data_parallel.DataParallel.module.cuda", "range", "torch.cuda.device_count"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel._check_balance"], ["def", "__init__", "(", "self", ",", "module", ",", "device_ids", "=", "None", ",", "output_device", "=", "None", ",", "dim", "=", "0", ",", "gather_output", "=", "True", ")", ":", "\n", "        ", "super", "(", "DataParallel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "module", "=", "module", "\n", "self", ".", "device_ids", "=", "[", "]", "\n", "return", "\n", "\n", "", "if", "device_ids", "is", "None", ":", "\n", "            ", "device_ids", "=", "list", "(", "range", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ")", "\n", "", "if", "output_device", "is", "None", ":", "\n", "            ", "output_device", "=", "device_ids", "[", "0", "]", "\n", "", "self", ".", "dim", "=", "dim", "\n", "self", ".", "module", "=", "module", "\n", "self", ".", "device_ids", "=", "device_ids", "\n", "self", ".", "output_device", "=", "output_device", "\n", "\n", "_check_balance", "(", "self", ".", "device_ids", ")", "\n", "\n", "if", "len", "(", "self", ".", "device_ids", ")", "==", "1", ":", "\n", "            ", "self", ".", "module", ".", "cuda", "(", "device_ids", "[", "0", "]", ")", "\n", "", "self", ".", "gather_output", "=", "gather_output", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.forward": [[103, 117], ["data_parallel.DataParallel.replicate", "data_parallel.DataParallel.parallel_apply", "data_parallel.DataParallel.module", "len", "data_parallel.DataParallel.module", "data_parallel.DataParallel.gather", "range", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.replicate", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.parallel_apply", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.gather"], ["", "def", "forward", "(", "self", ",", "*", "inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "self", ".", "device_ids", ":", "\n", "            ", "return", "self", ".", "module", "(", "*", "inputs", ",", "**", "kwargs", ")", "\n", "# inputs, kwargs = self.scatter(inputs, kwargs, self.device_ids)", "\n", "", "assert", "kwargs", "==", "{", "}", ",", "'not implemented'", "\n", "kwargs", "=", "[", "{", "}", "for", "_", "in", "range", "(", "len", "(", "inputs", ")", ")", "]", "\n", "if", "len", "(", "self", ".", "device_ids", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "module", "(", "*", "inputs", "[", "0", "]", ",", "**", "kwargs", "[", "0", "]", ")", "\n", "", "replicas", "=", "self", ".", "replicate", "(", "self", ".", "module", ",", "self", ".", "device_ids", "[", ":", "len", "(", "inputs", ")", "]", ")", "\n", "outputs", "=", "self", ".", "parallel_apply", "(", "replicas", ",", "inputs", ",", "kwargs", ")", "\n", "if", "self", ".", "gather_output", "or", "len", "(", "self", ".", "device_ids", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "gather", "(", "outputs", ",", "self", ".", "output_device", ")", "\n", "", "else", ":", "\n", "            ", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.replicate": [[118, 120], ["torch.nn.parallel.replicate.replicate"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.replicate"], ["", "", "def", "replicate", "(", "self", ",", "module", ",", "device_ids", ")", ":", "\n", "        ", "return", "replicate", "(", "module", ",", "device_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.scatter": [[121, 123], ["torch.nn.parallel.scatter_gather.scatter_kwargs"], "methods", ["None"], ["", "def", "scatter", "(", "self", ",", "inputs", ",", "kwargs", ",", "device_ids", ")", ":", "\n", "        ", "return", "scatter_kwargs", "(", "inputs", ",", "kwargs", ",", "device_ids", ",", "dim", "=", "self", ".", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.parallel_apply": [[124, 126], ["torch.nn.parallel.parallel_apply.parallel_apply", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.parallel_apply"], ["", "def", "parallel_apply", "(", "self", ",", "replicas", ",", "inputs", ",", "kwargs", ")", ":", "\n", "        ", "return", "parallel_apply", "(", "replicas", ",", "inputs", ",", "kwargs", ",", "self", ".", "device_ids", "[", ":", "len", "(", "replicas", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.gather": [[127, 129], ["torch.nn.parallel.scatter_gather.gather"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.gather"], ["", "def", "gather", "(", "self", ",", "outputs", ",", "output_device", ")", ":", "\n", "        ", "return", "gather", "(", "outputs", ",", "output_device", ",", "dim", "=", "self", ".", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel._check_balance": [[23, 45], ["data_parallel._check_balance.warn_imbalance"], "function", ["None"], ["def", "_check_balance", "(", "device_ids", ")", ":", "\n", "    ", "imbalance_warn", "=", "\"\"\"\n    There is an imbalance between your GPUs. You may want to exclude GPU {} which\n    has less than 75% of the memory or cores of GPU {}. You can do so by setting\n    the device_ids argument to DataParallel, or by setting the CUDA_VISIBLE_DEVICES\n    environment variable.\"\"\"", "\n", "\n", "dev_props", "=", "[", "torch", ".", "cuda", ".", "get_device_properties", "(", "i", ")", "for", "i", "in", "device_ids", "]", "\n", "\n", "def", "warn_imbalance", "(", "get_prop", ")", ":", "\n", "        ", "values", "=", "[", "get_prop", "(", "props", ")", "for", "props", "in", "dev_props", "]", "\n", "min_pos", ",", "min_val", "=", "min", "(", "enumerate", "(", "values", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "\n", "max_pos", ",", "max_val", "=", "max", "(", "enumerate", "(", "values", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "\n", "if", "min_val", "/", "max_val", "<", "0.75", ":", "\n", "            ", "warnings", ".", "warn", "(", "imbalance_warn", ".", "format", "(", "device_ids", "[", "min_pos", "]", ",", "device_ids", "[", "max_pos", "]", ")", ")", "\n", "return", "True", "\n", "", "return", "False", "\n", "\n", "", "if", "warn_imbalance", "(", "lambda", "props", ":", "props", ".", "total_memory", ")", ":", "\n", "        ", "return", "\n", "", "if", "warn_imbalance", "(", "lambda", "props", ":", "props", ".", "multi_processor_count", ")", ":", "\n", "        ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.__init__": [[40, 47], ["str", "metric.EvalMetric.reset"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.reset"], ["def", "__init__", "(", "self", ",", "name", ",", "output_names", "=", "None", ",", "\n", "label_names", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "name", "=", "str", "(", "name", ")", "\n", "self", ".", "output_names", "=", "output_names", "\n", "self", ".", "label_names", "=", "label_names", "\n", "self", ".", "_kwargs", "=", "kwargs", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.__str__": [[48, 50], ["dict", "metric.EvalMetric.get_name_value"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get_name_value"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}\"", ".", "format", "(", "dict", "(", "self", ".", "get_name_value", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get_config": [[51, 62], ["metric.EvalMetric._kwargs.copy", "metric.EvalMetric.update"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "\"\"\"Save configurations of metric. Can be recreated\n        from configs with metric.create(**config)\n        \"\"\"", "\n", "config", "=", "self", ".", "_kwargs", ".", "copy", "(", ")", "\n", "config", ".", "update", "(", "{", "\n", "'metric'", ":", "self", ".", "__class__", ".", "__name__", ",", "\n", "'name'", ":", "self", ".", "name", ",", "\n", "'output_names'", ":", "self", ".", "output_names", ",", "\n", "'label_names'", ":", "self", ".", "label_names", "}", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.update": [[86, 98], ["NotImplementedError"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "preds", ",", "labels", ",", "loss", ")", ":", "\n", "        ", "\"\"\"Updates the internal evaluation result.\n\n        Parameters\n        ----------\n        labels : list of `NDArray`\n            The labels of the data.\n\n        preds : list of `NDArray`\n            Predicted values.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.reset": [[99, 103], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Resets the internal evaluation result to initial state.\"\"\"", "\n", "self", ".", "num_inst", "=", "0", "\n", "self", ".", "sum_metric", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get": [[104, 118], ["float"], "methods", ["None"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "\"\"\"Gets the current evaluation result.\n\n        Returns\n        -------\n        names : list of str\n           Name of the metrics.\n        values : list of float\n           Value of the evaluations.\n        \"\"\"", "\n", "if", "self", ".", "num_inst", "==", "0", ":", "\n", "            ", "return", "(", "self", ".", "name", ",", "float", "(", "'nan'", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "(", "self", ".", "name", ",", "self", ".", "sum_metric", "/", "self", ".", "num_inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get_name_value": [[119, 133], ["metric.EvalMetric.get", "list", "isinstance", "isinstance", "zip"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get"], ["", "", "def", "get_name_value", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns zipped name and value pairs.\n\n        Returns\n        -------\n        list of tuples\n            A (name, value) tuple list.\n        \"\"\"", "\n", "name", ",", "value", "=", "self", ".", "get", "(", ")", "\n", "if", "not", "isinstance", "(", "name", ",", "list", ")", ":", "\n", "            ", "name", "=", "[", "name", "]", "\n", "", "if", "not", "isinstance", "(", "value", ",", "list", ")", ":", "\n", "            ", "value", "=", "[", "value", "]", "\n", "", "return", "list", "(", "zip", "(", "name", ",", "value", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.AvgMetric.__init__": [[135, 139], ["metric.EvalMetric.__init__", "metric.AvgMetric.reset"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.reset"], ["    ", "def", "__init__", "(", "self", ",", "scale", "=", "1", ",", "name", "=", "\"AverageScalar\"", ")", ":", "\n", "        ", "super", "(", "AvgMetric", ",", "self", ")", ".", "__init__", "(", "name", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.AvgMetric.update": [[140, 143], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "predict", ",", "target", ",", "loss", ")", ":", "\n", "        ", "self", ".", "sum_metric", "+=", "loss", "/", "self", ".", "scale", "\n", "self", ".", "num_inst", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.AvgMetric.reset": [[144, 147], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "sum_metric", "=", "0", "\n", "self", ".", "num_inst", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.AccWithIgnoreMetric.__init__": [[149, 153], ["metric.EvalMetric.__init__", "metric.AccWithIgnoreMetric.reset"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.reset"], ["    ", "def", "__init__", "(", "self", ",", "ignore_label", "=", "255", ",", "name", "=", "\"AccWithIgnore\"", ")", ":", "\n", "        ", "super", "(", "AccWithIgnoreMetric", ",", "self", ")", ".", "__init__", "(", "name", ")", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.AccWithIgnoreMetric.update": [[154, 162], ["predict.data.max", "predict_label.int.int.int", "target.data.int.data.int.data.int", "predict.dim", "target.data.int.data.int.dim", "len", "predict_label.int.int.view", "predict_label.int.int.view", "target.data.int.data.int.view", "target.data.int.data.int.view"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "predict", ",", "target", ",", "loss", ")", ":", "\n", "        ", "assert", "predict", ".", "dim", "(", ")", "==", "4", "\n", "assert", "target", ".", "dim", "(", ")", "==", "3", "\n", "_", ",", "predict_label", "=", "predict", ".", "data", ".", "max", "(", "dim", "=", "1", ")", "\n", "predict_label", "=", "predict_label", ".", "int", "(", ")", "\n", "target", "=", "target", ".", "data", ".", "int", "(", ")", "\n", "self", ".", "sum_metric", "+=", "(", "predict_label", ".", "view", "(", "-", "1", ")", "==", "target", ".", "view", "(", "-", "1", ")", ")", ".", "sum", "(", ")", "\n", "self", ".", "num_inst", "+=", "len", "(", "predict_label", ".", "view", "(", "-", "1", ")", ")", "-", "(", "target", ".", "view", "(", "-", "1", ")", "==", "self", ".", "ignore_label", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.AccWithIgnoreMetric.reset": [[163, 166], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "sum_metric", "=", "0", "\n", "self", ".", "num_inst", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.__init__": [[168, 172], ["metric.EvalMetric.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "label_num", ",", "ignore_label", "=", "255", ",", "name", "=", "\"IoU\"", ")", ":", "\n", "        ", "self", ".", "label_num", "=", "label_num", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "super", "(", "IoUMetric", ",", "self", ")", ".", "__init__", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.reset": [[173, 176], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_tp", "=", "[", "0.0", "]", "*", "self", ".", "label_num", "\n", "self", ".", "_denom", "=", "[", "0.0", "]", "*", "self", ".", "label_num", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update": [[177, 204], ["predict.data.max", "predict_label.int.int.int", "target.data.int.data.int.data.int", "range", "predict.dim", "target.data.int.data.int.dim", "len", "target.data.int.data.int.size", "range", "predict_label.int.int.size", "pred_label.view", "label.view", "label.view"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "predict", ",", "target", ",", "loss", ")", ":", "\n", "        ", "assert", "predict", ".", "dim", "(", ")", "==", "4", "\n", "assert", "target", ".", "dim", "(", ")", "==", "3", "\n", "_", ",", "predict_label", "=", "predict", ".", "data", ".", "max", "(", "dim", "=", "1", ")", "\n", "predict_label", "=", "predict_label", ".", "int", "(", ")", "\n", "target", "=", "target", ".", "data", ".", "int", "(", ")", "\n", "assert", "len", "(", "predict_label", ".", "size", "(", ")", ")", "==", "3", "\n", "\n", "for", "i", "in", "range", "(", "target", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "label", "=", "target", "[", "i", ",", ":", ",", ":", "]", "\n", "pred_label", "=", "predict_label", "[", "i", ",", ":", ",", ":", "]", "\n", "\n", "iou", "=", "0", "\n", "eps", "=", "1e-6", "\n", "# skip_label_num = 0", "\n", "for", "j", "in", "range", "(", "self", ".", "label_num", ")", ":", "\n", "                ", "pred_cur", "=", "(", "pred_label", ".", "view", "(", "-", "1", ")", "==", "j", ")", "\n", "gt_cur", "=", "(", "label", ".", "view", "(", "-", "1", ")", "==", "j", ")", "\n", "tp", "=", "(", "pred_cur", "&", "gt_cur", ")", ".", "sum", "(", ")", "\n", "denom", "=", "(", "pred_cur", "|", "gt_cur", ")", ".", "sum", "(", ")", "-", "(", "pred_cur", "&", "(", "label", ".", "view", "(", "-", "1", ")", "==", "self", ".", "ignore_label", ")", ")", ".", "sum", "(", ")", "\n", "assert", "tp", "<=", "denom", "\n", "self", ".", "_tp", "[", "j", "]", "+=", "tp", "\n", "self", ".", "_denom", "[", "j", "]", "+=", "denom", "\n", "iou", "+=", "self", ".", "_tp", "[", "j", "]", "/", "(", "self", ".", "_denom", "[", "j", "]", "+", "eps", ")", "\n", "", "iou", "/=", "self", ".", "label_num", "\n", "self", ".", "sum_metric", "=", "iou", "\n", "self", ".", "num_inst", "=", "1", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.callback.Speedometer.__init__": [[17, 23], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "batch_size", ",", "frequent", "=", "50", ")", ":", "\n", "        ", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "frequent", "=", "frequent", "\n", "self", ".", "init", "=", "False", "\n", "self", ".", "tic", "=", "0", "\n", "self", ".", "last_count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.callback.Speedometer.__call__": [[24, 45], ["time.time", "logging.info", "time.time", "time.time", "metric.get"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get"], ["", "def", "__call__", "(", "self", ",", "count", ",", "metrics", ")", ":", "\n", "        ", "\"\"\"Callback to Show speed.\"\"\"", "\n", "if", "self", ".", "last_count", ">", "count", ":", "\n", "            ", "self", ".", "init", "=", "False", "\n", "", "self", ".", "last_count", "=", "count", "\n", "\n", "if", "self", ".", "init", ":", "\n", "            ", "if", "count", "%", "self", ".", "frequent", "==", "0", ":", "\n", "                ", "speed", "=", "self", ".", "frequent", "*", "self", ".", "batch_size", "/", "(", "time", ".", "time", "(", ")", "-", "self", ".", "tic", ")", "\n", "if", "metrics", "is", "not", "None", ":", "\n", "                    ", "s", "=", "\"Batch [%d]\\tSpeed: %.2f samples/sec\\tTrain-\"", "%", "(", "count", ",", "speed", ")", "\n", "for", "metric", "in", "metrics", ":", "\n", "                        ", "s", "+=", "\"%s=%f,\\t\"", "%", "(", "metric", ".", "get", "(", ")", ")", "\n", "", "", "else", ":", "\n", "                    ", "s", "=", "\"Batch [%d]\\tSpeed: %.2f samples/sec\"", "%", "(", "count", ",", "speed", ")", "\n", "\n", "", "logging", ".", "info", "(", "s", ")", "\n", "self", ".", "tic", "=", "time", ".", "time", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "init", "=", "True", "\n", "self", ".", "tic", "=", "time", ".", "time", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.SGD.__init__": [[54, 64], ["dict", "torch.optim.optimizer.Optimizer.__init__", "lib.utils.logging.logger.info", "ValueError"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["def", "__init__", "(", "self", ",", "params", ",", "lr", "=", "required", ",", "momentum", "=", "0", ",", "dampening", "=", "0", ",", "\n", "weight_decay", "=", "0", ",", "nesterov", "=", "False", ")", ":", "\n", "        ", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "momentum", "=", "momentum", ",", "dampening", "=", "dampening", ",", "\n", "weight_decay", "=", "weight_decay", ",", "nesterov", "=", "nesterov", ")", "\n", "if", "logger", ":", "\n", "            ", "logger", ".", "info", "(", "defaults", ")", "\n", "", "if", "nesterov", "and", "(", "momentum", "<=", "0", "or", "dampening", "!=", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Nesterov momentum requires a momentum and zero dampening\"", ")", "\n", "", "assert", "dampening", "==", "0", ",", "\"not implemented\"", "\n", "super", "(", "SGD", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.SGD.__setstate__": [[65, 69], ["super().__setstate__", "group.setdefault"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.SGD.__setstate__"], ["", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "super", "(", "SGD", ",", "self", ")", ".", "__setstate__", "(", "state", ")", "\n", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "group", ".", "setdefault", "(", "'nesterov'", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.SGD.step": [[70, 107], ["closure", "p.data.add_", "d_p.add.add.add_", "p.data.new().resize_as_().zero_", "p.data.new().resize_as_().zero_.mul_().add_", "p.data.new().resize_as_().zero_.mul_().add_", "d_p.add.add.add", "p.data.new().resize_as_", "p.data.new().resize_as_().zero_.mul_", "p.data.new().resize_as_().zero_.mul_", "p.data.new"], "methods", ["None"], ["", "", "def", "step", "(", "self", ",", "lr", ",", "closure", "=", "None", ")", ":", "\n", "        ", "\"\"\"Performs a single optimization step.\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        \"\"\"", "\n", "loss", "=", "None", "\n", "if", "closure", "is", "not", "None", ":", "\n", "            ", "loss", "=", "closure", "(", ")", "\n", "\n", "", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "weight_decay", "=", "group", "[", "'weight_decay'", "]", "\n", "momentum", "=", "group", "[", "'momentum'", "]", "\n", "nesterov", "=", "group", "[", "'nesterov'", "]", "\n", "\n", "for", "p", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "d_p", "=", "p", ".", "grad", ".", "data", "\n", "if", "weight_decay", "!=", "0", ":", "\n", "                    ", "d_p", ".", "add_", "(", "weight_decay", ",", "p", ".", "data", ")", "\n", "", "if", "momentum", "!=", "0", ":", "\n", "                    ", "param_state", "=", "self", ".", "state", "[", "p", "]", "\n", "if", "'momentum_buffer'", "not", "in", "param_state", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "=", "p", ".", "data", ".", "new", "(", ")", ".", "resize_as_", "(", "p", ".", "data", ")", ".", "zero_", "(", ")", "\n", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "group", "[", "'lr'", "]", "*", "lr", ",", "d_p", ")", "\n", "", "else", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "\n", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "group", "[", "'lr'", "]", "*", "lr", ",", "d_p", ")", "\n", "", "if", "nesterov", ":", "\n", "                        ", "d_p", "=", "d_p", ".", "add", "(", "momentum", ",", "buf", ")", "\n", "", "else", ":", "\n", "                        ", "d_p", "=", "buf", "\n", "\n", "", "", "p", ".", "data", ".", "add_", "(", "-", "1", ",", "d_p", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.Adam.__init__": [[128, 133], ["dict", "torch.optim.optimizer.Optimizer.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["def", "__init__", "(", "self", ",", "params", ",", "lr", "=", "1e-3", ",", "betas", "=", "(", "0.9", ",", "0.999", ")", ",", "eps", "=", "1e-8", ",", "\n", "weight_decay", "=", "0", ")", ":", "\n", "        ", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "betas", "=", "betas", ",", "eps", "=", "eps", ",", "\n", "weight_decay", "=", "weight_decay", ")", "\n", "super", "(", "Adam", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.Adam.step": [[134, 181], ["closure", "exp_avg.mul_().add_", "exp_avg_sq.mul_().addcmul_", "exp_avg_sq.sqrt().add_", "p.data.addcdiv_", "len", "grad.add.add.new().resize_as_().zero_", "grad.add.add.new().resize_as_().zero_", "grad.add.add.add", "exp_avg.mul_", "exp_avg_sq.mul_", "exp_avg_sq.sqrt", "math.sqrt", "grad.add.add.new().resize_as_", "grad.add.add.new().resize_as_", "grad.add.add.new", "grad.add.add.new"], "methods", ["None"], ["", "def", "step", "(", "self", ",", "lr", ",", "closure", "=", "None", ")", ":", "\n", "        ", "\"\"\"Performs a single optimization step.\n\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        \"\"\"", "\n", "loss", "=", "None", "\n", "if", "closure", "is", "not", "None", ":", "\n", "            ", "loss", "=", "closure", "(", ")", "\n", "\n", "", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "for", "p", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "grad", "=", "p", ".", "grad", ".", "data", "\n", "state", "=", "self", ".", "state", "[", "p", "]", "\n", "\n", "# State initialization", "\n", "if", "len", "(", "state", ")", "==", "0", ":", "\n", "                    ", "state", "[", "'step'", "]", "=", "0", "\n", "# Exponential moving average of gradient values", "\n", "state", "[", "'exp_avg'", "]", "=", "grad", ".", "new", "(", ")", ".", "resize_as_", "(", "grad", ")", ".", "zero_", "(", ")", "\n", "# Exponential moving average of squared gradient values", "\n", "state", "[", "'exp_avg_sq'", "]", "=", "grad", ".", "new", "(", ")", ".", "resize_as_", "(", "grad", ")", ".", "zero_", "(", ")", "\n", "\n", "", "exp_avg", ",", "exp_avg_sq", "=", "state", "[", "'exp_avg'", "]", ",", "state", "[", "'exp_avg_sq'", "]", "\n", "beta1", ",", "beta2", "=", "group", "[", "'betas'", "]", "\n", "\n", "state", "[", "'step'", "]", "+=", "1", "\n", "\n", "if", "group", "[", "'weight_decay'", "]", "!=", "0", ":", "\n", "                    ", "grad", "=", "grad", ".", "add", "(", "group", "[", "'weight_decay'", "]", ",", "p", ".", "data", ")", "\n", "\n", "# Decay the first and second moment running average coefficient", "\n", "", "exp_avg", ".", "mul_", "(", "beta1", ")", ".", "add_", "(", "1", "-", "beta1", ",", "grad", ")", "\n", "exp_avg_sq", ".", "mul_", "(", "beta2", ")", ".", "addcmul_", "(", "1", "-", "beta2", ",", "grad", ",", "grad", ")", "\n", "\n", "denom", "=", "exp_avg_sq", ".", "sqrt", "(", ")", ".", "add_", "(", "group", "[", "'eps'", "]", ")", "\n", "\n", "bias_correction1", "=", "1", "-", "beta1", "**", "state", "[", "'step'", "]", "\n", "bias_correction2", "=", "1", "-", "beta2", "**", "state", "[", "'step'", "]", "\n", "step_size", "=", "lr", "*", "group", "[", "'lr'", "]", "*", "math", ".", "sqrt", "(", "bias_correction2", ")", "/", "bias_correction1", "\n", "\n", "p", ".", "data", ".", "addcdiv_", "(", "-", "step_size", ",", "exp_avg", ",", "denom", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.clip_grad": [[183, 199], ["list", "filter", "p.grad.data.clamp_"], "function", ["None"], ["", "", "def", "clip_grad", "(", "parameters", ",", "clip_val", ")", ":", "\n", "    ", "r\"\"\"Clips gradient norm of an iterable of parameters.\n    The norm is computed over all gradients together, as if they were\n    concatenated into a single vector. Gradients are modified in-place.\n    Arguments:\n        parameters (Iterable[Variable]): an iterable of Variables that will have\n            gradients normalized\n        max_norm (float or int): max norm of the gradients\n        norm_type (float or int): type of the used p-norm. Can be ``'inf'`` for\n            infinity norm.\n    Returns:\n        Total norm of the parameters (viewed as a single vector).\n    \"\"\"", "\n", "parameters", "=", "list", "(", "filter", "(", "lambda", "p", ":", "p", ".", "grad", "is", "not", "None", ",", "parameters", ")", ")", "\n", "for", "p", "in", "parameters", ":", "\n", "        ", "p", ".", "grad", ".", "data", ".", "clamp_", "(", "-", "clip_val", ",", "clip_val", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_test.im_detect": [[55, 92], ["range", "len", "len", "scores_all.append", "pred_boxes_all.append", "cls_inds_all.append", "v.data.cpu().numpy", "pred_masks_all.append", "pred_ssegs_all.append", "pred_panos_all.append", "pred_pano_cls_inds_all.append", "output.items", "v.data.cpu"], "function", ["None"], ["def", "im_detect", "(", "output_all", ",", "data", ",", "im_infos", ")", ":", "\n", "\n", "    ", "scores_all", "=", "[", "]", "\n", "pred_boxes_all", "=", "[", "]", "\n", "pred_masks_all", "=", "[", "]", "\n", "pred_ssegs_all", "=", "[", "]", "\n", "pred_panos_all", "=", "[", "]", "\n", "pred_pano_cls_inds_all", "=", "[", "]", "\n", "cls_inds_all", "=", "[", "]", "\n", "\n", "if", "len", "(", "data", ")", "==", "1", ":", "\n", "        ", "output_all", "=", "[", "output_all", "]", "\n", "\n", "", "output_all", "=", "[", "{", "k", ":", "v", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "k", ",", "v", "in", "output", ".", "items", "(", ")", "}", "for", "output", "in", "output_all", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "data", ")", ")", ":", "\n", "        ", "im_info", "=", "im_infos", "[", "i", "]", "\n", "scores_all", ".", "append", "(", "output_all", "[", "i", "]", "[", "'cls_probs'", "]", ")", "\n", "pred_boxes_all", ".", "append", "(", "output_all", "[", "i", "]", "[", "'pred_boxes'", "]", "[", ":", ",", "1", ":", "]", "/", "im_info", "[", "2", "]", ")", "\n", "cls_inds_all", ".", "append", "(", "output_all", "[", "i", "]", "[", "'cls_inds'", "]", ")", "\n", "\n", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "            ", "pred_masks_all", ".", "append", "(", "output_all", "[", "i", "]", "[", "'mask_probs'", "]", ")", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "            ", "pred_ssegs_all", ".", "append", "(", "output_all", "[", "i", "]", "[", "'fcn_outputs'", "]", ")", "\n", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "            ", "pred_panos_all", ".", "append", "(", "output_all", "[", "i", "]", "[", "'panoptic_outputs'", "]", ")", "\n", "pred_pano_cls_inds_all", ".", "append", "(", "output_all", "[", "i", "]", "[", "'panoptic_cls_inds'", "]", ")", "\n", "\n", "", "", "return", "{", "\n", "'scores'", ":", "scores_all", ",", "\n", "'boxes'", ":", "pred_boxes_all", ",", "\n", "'masks'", ":", "pred_masks_all", ",", "\n", "'ssegs'", ":", "pred_ssegs_all", ",", "\n", "'panos'", ":", "pred_panos_all", ",", "\n", "'cls_inds'", ":", "cls_inds_all", ",", "\n", "'pano_cls_inds'", ":", "pred_pano_cls_inds_all", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_test.im_post": [[95, 153], ["upsnet.bbox.bbox_transform.expand_boxes", "ref_boxes.astype.astype", "numpy.zeros", "range", "numpy.hstack", "range", "boxes_all[].append", "masks_all[].append", "range", "numpy.maximum", "numpy.maximum", "cv2.resize", "numpy.array", "numpy.zeros", "max", "min", "max", "min", "rle[].decode", "segms.append", "pycocotools.mask.encode", "scores.reshape", "numpy.array"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.expand_boxes"], ["", "def", "im_post", "(", "boxes_all", ",", "masks_all", ",", "scores", ",", "pred_boxes", ",", "pred_masks", ",", "cls_inds", ",", "num_classes", ",", "im_info", ")", ":", "\n", "\n", "    ", "cls_segms", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "mask_ind", "=", "0", "\n", "\n", "M", "=", "config", ".", "network", ".", "mask_size", "\n", "\n", "scale", "=", "(", "M", "+", "2.0", ")", "/", "M", "\n", "\n", "\n", "ref_boxes", "=", "expand_boxes", "(", "pred_boxes", ",", "scale", ")", "\n", "ref_boxes", "=", "ref_boxes", ".", "astype", "(", "np", ".", "int32", ")", "\n", "padded_mask", "=", "np", ".", "zeros", "(", "(", "M", "+", "2", ",", "M", "+", "2", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "for", "idx", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "        ", "segms", "=", "[", "]", "\n", "cls_boxes", "=", "np", ".", "hstack", "(", "[", "pred_boxes", "[", "idx", "==", "cls_inds", ",", ":", "]", ",", "scores", ".", "reshape", "(", "-", "1", ",", "1", ")", "[", "idx", "==", "cls_inds", "]", "]", ")", "\n", "cls_pred_masks", "=", "pred_masks", "[", "idx", "==", "cls_inds", "]", "\n", "cls_ref_boxes", "=", "ref_boxes", "[", "idx", "==", "cls_inds", "]", "\n", "for", "_", "in", "range", "(", "cls_boxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "\n", "            ", "if", "pred_masks", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "                ", "padded_mask", "[", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", "=", "cls_pred_masks", "[", "_", ",", "idx", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "                ", "padded_mask", "[", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", "=", "cls_pred_masks", "[", "_", ",", "0", ",", ":", ",", ":", "]", "\n", "", "ref_box", "=", "cls_ref_boxes", "[", "_", ",", ":", "]", "\n", "\n", "w", "=", "ref_box", "[", "2", "]", "-", "ref_box", "[", "0", "]", "+", "1", "\n", "h", "=", "ref_box", "[", "3", "]", "-", "ref_box", "[", "1", "]", "+", "1", "\n", "w", "=", "np", ".", "maximum", "(", "w", ",", "1", ")", "\n", "h", "=", "np", ".", "maximum", "(", "h", ",", "1", ")", "\n", "\n", "mask", "=", "cv2", ".", "resize", "(", "padded_mask", ",", "(", "w", ",", "h", ")", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ">", "0.5", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "im_mask", "=", "np", ".", "zeros", "(", "(", "im_info", "[", "0", "]", ",", "im_info", "[", "1", "]", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "x_0", "=", "max", "(", "ref_box", "[", "0", "]", ",", "0", ")", "\n", "x_1", "=", "min", "(", "ref_box", "[", "2", "]", "+", "1", ",", "im_info", "[", "1", "]", ")", "\n", "y_0", "=", "max", "(", "ref_box", "[", "1", "]", ",", "0", ")", "\n", "y_1", "=", "min", "(", "ref_box", "[", "3", "]", "+", "1", ",", "im_info", "[", "0", "]", ")", "\n", "\n", "im_mask", "[", "y_0", ":", "y_1", ",", "x_0", ":", "x_1", "]", "=", "mask", "[", "\n", "(", "y_0", "-", "ref_box", "[", "1", "]", ")", ":", "(", "y_1", "-", "ref_box", "[", "1", "]", ")", ",", "\n", "(", "x_0", "-", "ref_box", "[", "0", "]", ")", ":", "(", "x_1", "-", "ref_box", "[", "0", "]", ")", "\n", "]", "\n", "\n", "# Get RLE encoding used by the COCO evaluation API", "\n", "rle", "=", "mask_encode", "(", "\n", "np", ".", "array", "(", "im_mask", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "order", "=", "'F'", ")", "\n", ")", "[", "0", "]", "\n", "rle", "[", "'counts'", "]", "=", "rle", "[", "'counts'", "]", ".", "decode", "(", ")", "\n", "segms", ".", "append", "(", "rle", ")", "\n", "\n", "mask_ind", "+=", "1", "\n", "\n", "", "cls_segms", "[", "idx", "]", "=", "segms", "\n", "boxes_all", "[", "idx", "]", ".", "append", "(", "cls_boxes", ")", "\n", "masks_all", "[", "idx", "]", ".", "append", "(", "segms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_test.upsnet_test": [[155, 311], ["pprint.pprint", "logger.info", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "DataParallel().to.parameters", "lib.utils.data_parallel.DataParallel().to", "DataParallel().to.eval", "torch.utils.data.DataLoader.__iter__", "lib.utils.timer.Timer", "lib.utils.timer.Timer", "lib.utils.timer.Timer", "range", "os.makedirs", "int", "eval", "pickle.load", "sys.exit", "DataParallel().to.load_state_dict", "DataParallel().to.load_state_dict", "len", "lib.utils.timer.Timer.tic", "lib.utils.timer.Timer.toc", "lib.utils.timer.Timer.tic", "zip", "lib.utils.timer.Timer.toc", "logging.info", "os.path.join", "open", "pickle.dump", "test_dataset.vis_all_mask", "test_dataset.evaluate_boxes", "pprint.pformat", "upsnet.config.config.config.gpus.split", "upsnet.config.config.config.dataset.test_image_set.split", "open", "test_dataset.vis_all_mask", "test_dataset.evaluate_boxes", "test_dataset.evaluate_masks", "test_dataset.evaluate_ssegs", "logging.info", "test_dataset.evaluate_panoptic", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "lib.utils.data_parallel.DataParallel", "range", "batch.append", "labels.append", "lib.utils.timer.Timer.tic", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "DataParallel().to.", "torch.cuda.synchronize", "torch.cuda.synchronize", "torch.cuda.synchronize", "torch.cuda.synchronize", "upsnet_end2end_test.im_detect", "upsnet_end2end_test.im_post", "enumerate", "enumerate", "all_panos.extend", "all_pano_cls_inds.extend", "os.path.join", "os.path.join", "os.path.join", "test_dataset.evaluate_masks", "logging.info", "test_dataset.evaluate_panoptic", "test_dataset.evaluate_ssegs", "eval", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "test_dataset.get_unified_pan_result", "os.path.join", "os.path.join", "range", "test_loader.__iter__.next", "data.copy.items", "lib.utils.timer.Timer.toc", "numpy.round().astype", "all_ssegs.append", "zip", "panos.append", "pano_cls_inds.append", "len", "len", "len", "len", "os.path.join", "test_dataset.get_unified_pan_result", "os.path.join", "os.path.join", "os.path.join", "data.copy.copy", "data.copy.items", "sseg.squeeze().astype", "cv2.resize", "pano.squeeze().astype", "cv2.resize", "len", "os.path.join", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "v.pin_memory().to", "numpy.round", "upsnet.config.config.config.dataset.image_set.split", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "v.pin_memory().to", "sseg.squeeze", "int", "int", "pano.squeeze", "int", "int", "os.path.basename().split", "str", "v.pin_memory", "v.pin_memory", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.load_state_dict", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.load_state_dict", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.toc", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.toc", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.vis_all_mask", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.vis_all_mask", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_masks", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.evaluate_ssegs", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_panoptic", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_test.im_detect", "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_test.im_post", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_masks", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_panoptic", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.evaluate_ssegs", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_unified_pan_result", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.toc", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_unified_pan_result"], ["", "", "def", "upsnet_test", "(", ")", ":", "\n", "\n", "    ", "pprint", ".", "pprint", "(", "config", ")", "\n", "logger", ".", "info", "(", "'test config:{}\\n'", ".", "format", "(", "pprint", ".", "pformat", "(", "config", ")", ")", ")", "\n", "\n", "# create models", "\n", "gpus", "=", "[", "int", "(", "_", ")", "for", "_", "in", "config", ".", "gpus", ".", "split", "(", "','", ")", "]", "\n", "test_model", "=", "eval", "(", "config", ".", "symbol", ")", "(", ")", ".", "cuda", "(", "device", "=", "gpus", "[", "0", "]", ")", "\n", "\n", "# create data loader", "\n", "test_dataset", "=", "eval", "(", "config", ".", "dataset", ".", "dataset", ")", "(", "image_sets", "=", "config", ".", "dataset", ".", "test_image_set", ".", "split", "(", "'+'", ")", ",", "flip", "=", "False", ",", "\n", "result_path", "=", "final_output_path", ",", "phase", "=", "'test'", ")", "\n", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "test_dataset", ",", "batch_size", "=", "config", ".", "test", ".", "batch_size", ",", "shuffle", "=", "False", ",", "\n", "num_workers", "=", "0", ",", "drop_last", "=", "False", ",", "pin_memory", "=", "False", ",", "collate_fn", "=", "test_dataset", ".", "collate", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "results", "=", "pickle", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ",", "'results_list.pkl'", ")", ",", "'rb'", ")", ")", "\n", "if", "config", ".", "test", ".", "vis_mask", ":", "\n", "            ", "test_dataset", ".", "vis_all_mask", "(", "results", "[", "'all_boxes'", "]", ",", "results", "[", "'all_masks'", "]", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ",", "'vis'", ")", ")", "\n", "", "if", "config", ".", "network", ".", "has_rcnn", ":", "\n", "            ", "test_dataset", ".", "evaluate_boxes", "(", "results", "[", "'all_boxes'", "]", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ")", ")", "\n", "", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "            ", "test_dataset", ".", "evaluate_masks", "(", "results", "[", "'all_boxes'", "]", ",", "results", "[", "'all_masks'", "]", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ")", ")", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "            ", "test_dataset", ".", "evaluate_ssegs", "(", "results", "[", "'all_ssegs'", "]", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ",", "'ssegs'", ")", ")", "\n", "# logging.info('combined pano result:')", "\n", "# test_dataset.evaluate_panoptic(test_dataset.get_combined_pan_result(results['all_ssegs'], results['all_boxes'], results['all_masks'], stuff_area_limit=config.test.panoptic_stuff_area_limit), os.path.join(final_output_path, 'results', 'pans_combined'))", "\n", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "            ", "logging", ".", "info", "(", "'unified pano result:'", ")", "\n", "test_dataset", ".", "evaluate_panoptic", "(", "test_dataset", ".", "get_unified_pan_result", "(", "results", "[", "'all_ssegs'", "]", ",", "results", "[", "'all_panos'", "]", ",", "results", "[", "'all_pano_cls_inds'", "]", ",", "stuff_area_limit", "=", "config", ".", "test", ".", "panoptic_stuff_area_limit", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ",", "'pans_unified'", ")", ")", "\n", "", "sys", ".", "exit", "(", ")", "\n", "\n", "# preparing", "\n", "", "curr_iter", "=", "config", ".", "test", ".", "test_iteration", "\n", "if", "args", ".", "weight_path", "==", "''", ":", "\n", "        ", "test_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "join", "(", "config", ".", "output_path", ",", "os", ".", "path", ".", "basename", "(", "args", ".", "cfg", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", ",", "\n", "'_'", ".", "join", "(", "config", ".", "dataset", ".", "image_set", ".", "split", "(", "'+'", ")", ")", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.pth'", ")", ")", ")", ",", "resume", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "test_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "args", ".", "weight_path", ")", ",", "resume", "=", "True", ")", "\n", "\n", "\n", "", "for", "p", "in", "test_model", ".", "parameters", "(", ")", ":", "\n", "        ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "test_model", "=", "DataParallel", "(", "test_model", ",", "device_ids", "=", "gpus", ",", "gather_output", "=", "False", ")", ".", "to", "(", "gpus", "[", "0", "]", ")", "\n", "\n", "# start training", "\n", "test_model", ".", "eval", "(", ")", "\n", "\n", "i_iter", "=", "0", "\n", "idx", "=", "0", "\n", "test_iter", "=", "test_loader", ".", "__iter__", "(", ")", "\n", "all_boxes", "=", "[", "[", "]", "for", "_", "in", "range", "(", "test_dataset", ".", "num_classes", ")", "]", "\n", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "        ", "all_masks", "=", "[", "[", "]", "for", "_", "in", "range", "(", "test_dataset", ".", "num_classes", ")", "]", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "        ", "all_ssegs", "=", "[", "]", "\n", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "        ", "all_panos", "=", "[", "]", "\n", "all_pano_cls_inds", "=", "[", "]", "\n", "panos", "=", "[", "]", "\n", "\n", "\n", "", "data_timer", "=", "Timer", "(", ")", "\n", "net_timer", "=", "Timer", "(", ")", "\n", "post_timer", "=", "Timer", "(", ")", "\n", "\n", "while", "i_iter", "<", "len", "(", "test_loader", ")", ":", "\n", "        ", "data_timer", ".", "tic", "(", ")", "\n", "batch", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "for", "gpu_id", "in", "gpus", ":", "\n", "            ", "try", ":", "\n", "                ", "data", ",", "label", ",", "_", "=", "test_iter", ".", "next", "(", ")", "\n", "if", "label", "is", "not", "None", ":", "\n", "                    ", "data", "[", "'roidb'", "]", "=", "label", "[", "'roidb'", "]", "\n", "", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", ":", "\n", "                    ", "data", "[", "k", "]", "=", "v", ".", "pin_memory", "(", ")", ".", "to", "(", "gpu_id", ",", "non_blocking", "=", "True", ")", "if", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", "\n", "", "", "except", "StopIteration", ":", "\n", "                ", "data", "=", "data", ".", "copy", "(", ")", "\n", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", ":", "\n", "                    ", "data", "[", "k", "]", "=", "v", ".", "pin_memory", "(", ")", ".", "to", "(", "gpu_id", ",", "non_blocking", "=", "True", ")", "if", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", "\n", "", "", "batch", ".", "append", "(", "(", "data", ",", "None", ")", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "i_iter", "+=", "1", "\n", "\n", "", "im_infos", "=", "[", "_", "[", "0", "]", "[", "'im_info'", "]", "[", "0", "]", "for", "_", "in", "batch", "]", "\n", "\n", "data_time", "=", "data_timer", ".", "toc", "(", ")", "\n", "if", "i_iter", ">", "10", ":", "\n", "            ", "net_timer", ".", "tic", "(", ")", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "output", "=", "test_model", "(", "*", "batch", ")", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "if", "i_iter", ">", "10", ":", "\n", "                ", "net_time", "=", "net_timer", ".", "toc", "(", ")", "\n", "", "else", ":", "\n", "                ", "net_time", "=", "0", "\n", "", "output", "=", "im_detect", "(", "output", ",", "batch", ",", "im_infos", ")", "\n", "", "post_timer", ".", "tic", "(", ")", "\n", "for", "score", ",", "box", ",", "mask", ",", "cls_idx", ",", "im_info", "in", "zip", "(", "output", "[", "'scores'", "]", ",", "output", "[", "'boxes'", "]", ",", "output", "[", "'masks'", "]", ",", "output", "[", "'cls_inds'", "]", ",", "im_infos", ")", ":", "\n", "            ", "im_post", "(", "all_boxes", ",", "all_masks", ",", "score", ",", "box", ",", "mask", ",", "cls_idx", ",", "test_dataset", ".", "num_classes", ",", "np", ".", "round", "(", "im_info", "[", ":", "2", "]", "/", "im_info", "[", "2", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "idx", "+=", "1", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "            ", "for", "i", ",", "sseg", "in", "enumerate", "(", "output", "[", "'ssegs'", "]", ")", ":", "\n", "                ", "sseg", "=", "sseg", ".", "squeeze", "(", "0", ")", ".", "astype", "(", "'uint8'", ")", "[", ":", "int", "(", "im_infos", "[", "i", "]", "[", "0", "]", ")", ",", ":", "int", "(", "im_infos", "[", "i", "]", "[", "1", "]", ")", "]", "\n", "all_ssegs", ".", "append", "(", "cv2", ".", "resize", "(", "sseg", ",", "None", ",", "None", ",", "fx", "=", "1", "/", "im_infos", "[", "i", "]", "[", "2", "]", ",", "fy", "=", "1", "/", "im_infos", "[", "i", "]", "[", "2", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", ")", "\n", "", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "            ", "pano_cls_inds", "=", "[", "]", "\n", "for", "i", ",", "(", "pano", ",", "cls_ind", ")", "in", "enumerate", "(", "zip", "(", "output", "[", "'panos'", "]", ",", "output", "[", "'pano_cls_inds'", "]", ")", ")", ":", "\n", "                ", "pano", "=", "pano", ".", "squeeze", "(", "0", ")", ".", "astype", "(", "'uint8'", ")", "[", ":", "int", "(", "im_infos", "[", "i", "]", "[", "0", "]", ")", ",", ":", "int", "(", "im_infos", "[", "i", "]", "[", "1", "]", ")", "]", "\n", "panos", ".", "append", "(", "cv2", ".", "resize", "(", "pano", ",", "None", ",", "None", ",", "fx", "=", "1", "/", "im_infos", "[", "i", "]", "[", "2", "]", ",", "fy", "=", "1", "/", "im_infos", "[", "i", "]", "[", "2", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", ")", "\n", "pano_cls_inds", ".", "append", "(", "cls_ind", ")", "\n", "\n", "", "all_panos", ".", "extend", "(", "panos", ")", "\n", "panos", "=", "[", "]", "\n", "all_pano_cls_inds", ".", "extend", "(", "pano_cls_inds", ")", "\n", "", "post_time", "=", "post_timer", ".", "toc", "(", ")", "\n", "s", "=", "'Batch %d/%d, data_time:%.3f, net_time:%.3f, post_time:%.3f'", "%", "(", "idx", ",", "len", "(", "test_dataset", ")", ",", "data_time", ",", "net_time", ",", "post_time", ")", "\n", "logging", ".", "info", "(", "s", ")", "\n", "\n", "", "results", "=", "[", "]", "\n", "\n", "# trim redundant predictions", "\n", "for", "i", "in", "range", "(", "1", ",", "test_dataset", ".", "num_classes", ")", ":", "\n", "        ", "all_boxes", "[", "i", "]", "=", "all_boxes", "[", "i", "]", "[", ":", "len", "(", "test_loader", ")", "]", "\n", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "            ", "all_masks", "[", "i", "]", "=", "all_masks", "[", "i", "]", "[", ":", "len", "(", "test_loader", ")", "]", "\n", "", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "        ", "all_ssegs", "=", "all_ssegs", "[", ":", "len", "(", "test_loader", ")", "]", "\n", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "        ", "all_panos", "=", "all_panos", "[", ":", "len", "(", "test_loader", ")", "]", "\n", "\n", "", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ")", ",", "exist_ok", "=", "True", ")", "\n", "\n", "results", "=", "{", "'all_boxes'", ":", "all_boxes", ",", "\n", "'all_masks'", ":", "all_masks", "if", "config", ".", "network", ".", "has_mask_head", "else", "None", ",", "\n", "'all_ssegs'", ":", "all_ssegs", "if", "config", ".", "network", ".", "has_fcn_head", "else", "None", ",", "\n", "'all_panos'", ":", "all_panos", "if", "config", ".", "network", ".", "has_panoptic_head", "else", "None", ",", "\n", "'all_pano_cls_inds'", ":", "all_pano_cls_inds", "if", "config", ".", "network", ".", "has_panoptic_head", "else", "None", ",", "\n", "}", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ",", "'results_list.pkl'", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "pickle", ".", "dump", "(", "results", ",", "f", ",", "protocol", "=", "2", ")", "\n", "\n", "", "if", "config", ".", "test", ".", "vis_mask", ":", "\n", "        ", "test_dataset", ".", "vis_all_mask", "(", "all_boxes", ",", "all_masks", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ",", "'vis'", ")", ")", "\n", "", "else", ":", "\n", "        ", "test_dataset", ".", "evaluate_boxes", "(", "all_boxes", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ")", ")", "\n", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "            ", "test_dataset", ".", "evaluate_masks", "(", "all_boxes", ",", "all_masks", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ")", ")", "\n", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "            ", "logging", ".", "info", "(", "'unified pano result:'", ")", "\n", "test_dataset", ".", "evaluate_panoptic", "(", "test_dataset", ".", "get_unified_pan_result", "(", "all_ssegs", ",", "all_panos", ",", "all_pano_cls_inds", ",", "stuff_area_limit", "=", "config", ".", "test", ".", "panoptic_stuff_area_limit", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ",", "'pans_unified'", ")", ")", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "            ", "test_dataset", ".", "evaluate_ssegs", "(", "all_ssegs", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "'results'", ",", "'ssegs'", ")", ")", "\n", "# logging.info('combined pano result:')", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.lr_poly": [[76, 82], ["min", "float", "float", "upsnet.config.config.config.train.lr", "upsnet.config.config.config.train.max_iteration", "upsnet.config.config.config.train.warmup_iteration"], "function", ["None"], ["def", "lr_poly", "(", "base_lr", ",", "iter", ",", "max_iter", ",", "warmup_iter", "=", "0", ")", ":", "\n", "    ", "power", "=", "0.9", "\n", "if", "iter", "<", "warmup_iter", ":", "\n", "        ", "alpha", "=", "iter", "/", "warmup_iter", "\n", "return", "min", "(", "base_lr", "*", "(", "1", "/", "10.0", "*", "(", "1", "-", "alpha", ")", "+", "alpha", ")", ",", "base_lr", "*", "(", "(", "1", "-", "float", "(", "iter", ")", "/", "max_iter", ")", "**", "(", "power", ")", ")", ")", "\n", "", "return", "base_lr", "*", "(", "(", "1", "-", "float", "(", "iter", ")", "/", "max_iter", ")", "**", "(", "power", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.get_step_index": [[84, 89], ["enumerate", "len"], "function", ["None"], ["", "def", "get_step_index", "(", "iter", ",", "decay_iters", ")", ":", "\n", "    ", "for", "idx", ",", "decay_iter", "in", "enumerate", "(", "decay_iters", ")", ":", "\n", "        ", "if", "iter", "<", "decay_iter", ":", "\n", "            ", "return", "idx", "\n", "", "", "return", "len", "(", "decay_iters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.lr_factor": [[91, 96], ["upsnet_end2end_train.get_step_index", "upsnet.config.config.config.train.lr", "upsnet.config.config.config.train.decay_iteration", "upsnet.config.config.config.train.warmup_iteration"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.get_step_index"], ["", "def", "lr_factor", "(", "base_lr", ",", "iter", ",", "decay_iter", ",", "warmup_iter", "=", "0", ")", ":", "\n", "    ", "if", "iter", "<", "warmup_iter", ":", "\n", "        ", "alpha", "=", "iter", "/", "warmup_iter", "\n", "return", "base_lr", "*", "(", "1", "/", "10.0", "*", "(", "1", "-", "alpha", ")", "+", "alpha", ")", "\n", "", "return", "base_lr", "*", "(", "0.1", "**", "get_step_index", "(", "iter", ",", "decay_iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.adjust_learning_rate": [[98, 104], ["upsnet_end2end_train.lr_factor", "upsnet_end2end_train.lr_poly", "upsnet.config.config.config", "upsnet.config.config.config"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.lr_factor", "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.lr_poly"], ["", "def", "adjust_learning_rate", "(", "optimizer", ",", "iter", ",", "config", ")", ":", "\n", "    ", "assert", "config", ".", "train", ".", "lr_schedule", "in", "[", "'step'", ",", "'poly'", "]", "\n", "if", "config", ".", "train", ".", "lr_schedule", "==", "'step'", ":", "\n", "        ", "return", "lr_factor", "(", "config", ".", "train", ".", "lr", ",", "iter", ",", "config", ".", "train", ".", "decay_iteration", ",", "config", ".", "train", ".", "warmup_iteration", ")", "\n", "", "if", "config", ".", "train", ".", "lr_schedule", "==", "'poly'", ":", "\n", "        ", "return", "lr_poly", "(", "config", ".", "train", ".", "lr", ",", "iter", ",", "config", ".", "train", ".", "max_iteration", ",", "config", ".", "train", ".", "warmup_iteration", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.upsnet_train": [[105, 401], ["DataParallel().to.get_params_lr", "lib.nn.optimizer.SGD", "hvd.DistributedOptimizer.zero_grad", "DataParallel().to.eval", "logger.info", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "hvd.size", "len", "len", "hvd.DistributedOptimizer", "eval", "eval", "torch.DistributedSampler", "torch.DistributedSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "lib.utils.callback.Speedometer", "metrics.extend", "metrics_name.extend", "metrics.extend", "metrics_name.extend", "metrics.extend", "metrics_name.extend", "metrics.extend", "metrics_name.extend", "metrics.extend", "metrics_name.extend", "DataParallel().to.load_state_dict", "hvd.DistributedOptimizer.load_state_dict", "lib.utils.data_parallel.DataParallel().to", "logger.info", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "int", "upsnet.config.config.config.gpus.split", "upsnet.config.config.config.dataset.image_set.split", "upsnet.config.config.config.dataset.test_image_set.split", "metrics.extend", "metrics_name.extend", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "hvd.broadcast_parameters", "DataParallel().to.load_state_dict", "hvd.broadcast_parameters", "distributed.DistributedSampler.set_epoch", "enumerate", "torch.utils.data.DataLoader.__iter__", "metric.reset", "DataParallel().to.eval", "DataParallel().to.state_dict", "os.path.join", "hvd.DistributedOptimizer.state_dict", "os.path.join", "logger.info", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "pprint.pformat", "eval", "DataParallel().to.named_parameters", "hvd.size", "hvd.rank", "hvd.size", "hvd.rank", "lib.utils.metric.AvgMetric", "lib.utils.metric.AvgMetric", "lib.utils.metric.AvgMetric", "lib.utils.metric.AvgMetric", "lib.utils.metric.AvgMetric", "lib.utils.metric.AvgMetric", "lib.utils.metric.AvgMetric", "lib.utils.metric.AvgMetric", "lib.utils.metric.AvgMetric", "os.path.join", "os.path.join", "DataParallel().to.state_dict", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "DataParallel().to.state_dict", "lib.utils.data_parallel.DataParallel", "DataParallel().to.train", "data.items", "label.items", "upsnet_end2end_train.adjust_learning_rate", "hvd.DistributedOptimizer.zero_grad", "DataParallel().to.", "hvd.allreduce().item.backward", "hvd.DistributedOptimizer.step", "losses.append", "hvd.synchronize().item", "enumerate", "len", "upsnet_end2end_train.adjust_learning_rate", "hvd.DistributedOptimizer.zero_grad", "hvd.allreduce().item.backward", "hvd.DistributedOptimizer.step", "losses.append", "enumerate", "enumerate", "torch.utils.data.DataLoader.__iter__", "metric.get", "logger.info", "DataParallel().to.module.state_dict", "os.path.join", "hvd.DistributedOptimizer.state_dict", "os.path.join", "lib.utils.metric.AvgMetric", "DataParallel().to.freeze_backbone", "DataParallel().to.resnet_backbone.eval", "allreduce_async", "losses.append", "writer.add_scalar", "zip", "hvd.synchronize().item", "[].keys", "train_loader.__iter__.next", "data.items", "label.items", "batch.append", "DataParallel().to.", "DataParallel().to.", "hvd.allreduce().item.item", "losses.append", "writer.add_scalar", "zip", "[].keys", "train_loader.__iter__.next", "data.items", "label.items", "zip", "len", "zip", "writer.add_scalar", "metric.reset", "v.cuda", "v.cuda", "output[].mean", "output[].mean", "allreduce_async", "hvd.synchronize", "writer.add_scalar", "metric.update", "logger.info", "logger.info", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "output[].mean", "output[].mean", "output[].mean", "output[].mean().item", "writer.add_scalar", "metric.update", "logger.info", "[].div_", "logger.info", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "DataParallel().to.", "hvd.allreduce().item", "len", "val_loader.__iter__.next", "data.items", "label.items", "batch.append", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "losses.append", "val_loader.__iter__.next", "len", "str", "str", "str", "str", "int", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "output[].mean", "output[].mean", "output[].mean", "output[].mean", "output[].mean", "output[].mean", "hvd.synchronize", "[].div_", "callback", "DataParallel().to.state_dict", "os.path.join", "hvd.DistributedOptimizer.state_dict", "os.path.join", "v.pin_memory().to", "v.pin_memory().to", "output[].mean", "output[].mean", "output[].mean", "output[].mean", "callback", "DataParallel().to.module.state_dict", "os.path.join", "hvd.DistributedOptimizer.state_dict", "os.path.join", "v.cuda", "v.cuda", "metric.update", "DataParallel().to.", "DataParallel().to.", "hvd.synchronize().item", "metric.update", "str", "str", "upsnet.config.config.config.gpus.split", "hvd.DistributedOptimizer.state_dict", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "output[].mean", "hvd.DistributedOptimizer.state_dict", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "hvd.allreduce", "v.pin_memory().to", "v.pin_memory().to", "allreduce_async", "output[].mean().item", "output[].mean", "hvd.DistributedOptimizer.state_dict", "v.pin_memory", "v.pin_memory", "output[].mean", "output[].mean", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "output[].mean", "hvd.synchronize", "str", "str", "str", "str", "v.pin_memory", "v.pin_memory", "output[].mean", "hvd.DistributedOptimizer.state_dict", "hvd.DistributedOptimizer.state_dict"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.get_params_lr", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.load_state_dict", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.load_state_dict", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.load_state_dict", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.reset", "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.adjust_learning_rate", "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.proposal_target.ProposalTargetFunction.backward", "home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.Adam.step", "home.repos.pwc.inspect_result.uber-research_UPSNet.upsnet.upsnet_end2end_train.adjust_learning_rate", "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.proposal_target.ProposalTargetFunction.backward", "home.repos.pwc.inspect_result.uber-research_UPSNet.nn.optimizer.Adam.step", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.freeze_backbone", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.reset", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update"], ["", "", "def", "upsnet_train", "(", ")", ":", "\n", "\n", "    ", "if", "is_master", ":", "\n", "        ", "logger", ".", "info", "(", "'training config:{}\\n'", ".", "format", "(", "pprint", ".", "pformat", "(", "config", ")", ")", ")", "\n", "", "gpus", "=", "[", "torch", ".", "device", "(", "'cuda'", ",", "int", "(", "_", ")", ")", "for", "_", "in", "config", ".", "gpus", ".", "split", "(", "','", ")", "]", "\n", "num_replica", "=", "hvd", ".", "size", "(", ")", "if", "config", ".", "train", ".", "use_horovod", "else", "len", "(", "gpus", ")", "\n", "num_gpus", "=", "1", "if", "config", ".", "train", ".", "use_horovod", "else", "len", "(", "gpus", ")", "\n", "\n", "# create models", "\n", "train_model", "=", "eval", "(", "config", ".", "symbol", ")", "(", ")", ".", "cuda", "(", ")", "\n", "\n", "# create optimizer", "\n", "params_lr", "=", "train_model", ".", "get_params_lr", "(", ")", "\n", "# we use custom optimizer and pass lr=1 to support different lr for different weights", "\n", "optimizer", "=", "SGD", "(", "params_lr", ",", "lr", "=", "1", ",", "momentum", "=", "config", ".", "train", ".", "momentum", ",", "weight_decay", "=", "config", ".", "train", ".", "wd", ")", "\n", "if", "config", ".", "train", ".", "use_horovod", ":", "\n", "        ", "optimizer", "=", "hvd", ".", "DistributedOptimizer", "(", "optimizer", ",", "named_parameters", "=", "train_model", ".", "named_parameters", "(", ")", ")", "\n", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# create data loader", "\n", "train_dataset", "=", "eval", "(", "config", ".", "dataset", ".", "dataset", ")", "(", "image_sets", "=", "config", ".", "dataset", ".", "image_set", ".", "split", "(", "'+'", ")", ",", "flip", "=", "config", ".", "train", ".", "flip", ",", "result_path", "=", "final_output_path", ")", "\n", "val_dataset", "=", "eval", "(", "config", ".", "dataset", ".", "dataset", ")", "(", "image_sets", "=", "config", ".", "dataset", ".", "test_image_set", ".", "split", "(", "'+'", ")", ",", "flip", "=", "False", ",", "result_path", "=", "final_output_path", ",", "phase", "=", "'val'", ")", "\n", "if", "config", ".", "train", ".", "use_horovod", ":", "\n", "        ", "train_sampler", "=", "distributed", ".", "DistributedSampler", "(", "train_dataset", ",", "num_replicas", "=", "hvd", ".", "size", "(", ")", ",", "rank", "=", "hvd", ".", "rank", "(", ")", ")", "\n", "val_sampler", "=", "distributed", ".", "DistributedSampler", "(", "val_dataset", ",", "num_replicas", "=", "hvd", ".", "size", "(", ")", ",", "rank", "=", "hvd", ".", "rank", "(", ")", ")", "\n", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "train_dataset", ",", "batch_size", "=", "config", ".", "train", ".", "batch_size", ",", "sampler", "=", "train_sampler", ",", "num_workers", "=", "num_gpus", "*", "4", ",", "drop_last", "=", "False", ",", "collate_fn", "=", "train_dataset", ".", "collate", ")", "\n", "val_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "val_dataset", ",", "batch_size", "=", "config", ".", "train", ".", "batch_size", ",", "sampler", "=", "val_sampler", ",", "num_workers", "=", "num_gpus", "*", "4", ",", "drop_last", "=", "False", ",", "collate_fn", "=", "val_dataset", ".", "collate", ")", "\n", "", "else", ":", "\n", "        ", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "train_dataset", ",", "batch_size", "=", "config", ".", "train", ".", "batch_size", ",", "shuffle", "=", "config", ".", "train", ".", "shuffle", ",", "num_workers", "=", "num_gpus", "*", "4", "if", "not", "config", ".", "debug_mode", "else", "num_gpus", "*", "4", ",", "drop_last", "=", "False", ",", "collate_fn", "=", "train_dataset", ".", "collate", ")", "\n", "val_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "val_dataset", ",", "batch_size", "=", "config", ".", "train", ".", "batch_size", ",", "shuffle", "=", "False", ",", "num_workers", "=", "num_gpus", "*", "4", "if", "not", "config", ".", "debug_mode", "else", "num_gpus", "*", "4", ",", "drop_last", "=", "False", ",", "collate_fn", "=", "val_dataset", ".", "collate", ")", "\n", "\n", "# preparing", "\n", "", "curr_iter", "=", "config", ".", "train", ".", "begin_iteration", "\n", "batch_end_callback", "=", "[", "Speedometer", "(", "num_replica", "*", "config", ".", "train", ".", "batch_size", ",", "config", ".", "train", ".", "display_iter", ")", "]", "\n", "metrics", "=", "[", "]", "\n", "metrics_name", "=", "[", "]", "\n", "if", "config", ".", "network", ".", "has_rpn", ":", "\n", "        ", "metrics", ".", "extend", "(", "[", "AvgMetric", "(", "name", "=", "'rpn_cls_loss'", ")", ",", "AvgMetric", "(", "name", "=", "'rpn_bbox_loss'", ")", ",", "]", ")", "\n", "metrics_name", ".", "extend", "(", "[", "'rpn_cls_loss'", ",", "'rpn_bbox_loss'", "]", ")", "\n", "", "if", "config", ".", "network", ".", "has_rcnn", ":", "\n", "        ", "metrics", ".", "extend", "(", "[", "AvgMetric", "(", "name", "=", "'rcnn_accuracy'", ")", ",", "AvgMetric", "(", "name", "=", "'cls_loss'", ")", ",", "AvgMetric", "(", "name", "=", "'bbox_loss'", ")", ",", "]", ")", "\n", "metrics_name", ".", "extend", "(", "[", "'rcnn_accuracy'", ",", "'cls_loss'", ",", "'bbox_loss'", "]", ")", "\n", "", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "        ", "metrics", ".", "extend", "(", "[", "AvgMetric", "(", "name", "=", "'mask_loss'", ")", ",", "]", ")", "\n", "metrics_name", ".", "extend", "(", "[", "'mask_loss'", "]", ")", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "        ", "metrics", ".", "extend", "(", "[", "AvgMetric", "(", "name", "=", "'fcn_loss'", ")", ",", "]", ")", "\n", "metrics_name", ".", "extend", "(", "[", "'fcn_loss'", "]", ")", "\n", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "            ", "metrics", ".", "extend", "(", "[", "AvgMetric", "(", "name", "=", "'fcn_roi_loss'", ")", ",", "]", ")", "\n", "metrics_name", ".", "extend", "(", "[", "'fcn_roi_loss'", "]", ")", "\n", "", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "        ", "metrics", ".", "extend", "(", "[", "AvgMetric", "(", "name", "=", "'panoptic_accuracy'", ")", ",", "AvgMetric", "(", "name", "=", "'panoptic_loss'", ")", ",", "]", ")", "\n", "metrics_name", ".", "extend", "(", "[", "'panoptic_accuracy'", ",", "'panoptic_loss'", "]", ")", "\n", "\n", "", "if", "config", ".", "train", ".", "resume", ":", "\n", "        ", "train_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.pth'", ")", ")", ",", "resume", "=", "True", ")", "\n", "optimizer", ".", "load_state_dict", "(", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.state.pth'", ")", ")", ")", "\n", "if", "config", ".", "train", ".", "use_horovod", ":", "\n", "            ", "hvd", ".", "broadcast_parameters", "(", "train_model", ".", "state_dict", "(", ")", ",", "root_rank", "=", "0", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "is_master", ":", "\n", "            ", "train_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "config", ".", "network", ".", "pretrained", ")", ")", "\n", "\n", "", "if", "config", ".", "train", ".", "use_horovod", ":", "\n", "            ", "hvd", ".", "broadcast_parameters", "(", "train_model", ".", "state_dict", "(", ")", ",", "root_rank", "=", "0", ")", "\n", "\n", "", "", "if", "not", "config", ".", "train", ".", "use_horovod", ":", "\n", "        ", "train_model", "=", "DataParallel", "(", "train_model", ",", "device_ids", "=", "[", "int", "(", "_", ")", "for", "_", "in", "config", ".", "gpus", ".", "split", "(", "','", ")", "]", ")", ".", "to", "(", "gpus", "[", "0", "]", ")", "\n", "\n", "", "if", "is_master", ":", "\n", "        ", "batch_end_callback", "[", "0", "]", "(", "0", ",", "0", ")", "\n", "\n", "", "train_model", ".", "eval", "(", ")", "\n", "\n", "# start training", "\n", "while", "curr_iter", "<", "config", ".", "train", ".", "max_iteration", ":", "\n", "        ", "if", "config", ".", "train", ".", "use_horovod", ":", "\n", "            ", "train_sampler", ".", "set_epoch", "(", "curr_iter", ")", "\n", "\n", "if", "config", ".", "network", ".", "use_syncbn", ":", "\n", "                ", "train_model", ".", "train", "(", ")", "\n", "if", "config", ".", "network", ".", "backbone_freeze_at", ">", "0", ":", "\n", "                    ", "train_model", ".", "freeze_backbone", "(", "config", ".", "network", ".", "backbone_freeze_at", ")", "\n", "", "if", "config", ".", "network", ".", "backbone_fix_bn", ":", "\n", "                    ", "train_model", ".", "resnet_backbone", ".", "eval", "(", ")", "\n", "\n", "\n", "", "", "for", "inner_iter", ",", "batch", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "                ", "data", ",", "label", ",", "_", "=", "batch", "\n", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", ":", "\n", "                    ", "data", "[", "k", "]", "=", "v", "if", "not", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", ".", "cuda", "(", ")", "\n", "", "for", "k", ",", "v", "in", "label", ".", "items", "(", ")", ":", "\n", "                    ", "label", "[", "k", "]", "=", "v", "if", "not", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", ".", "cuda", "(", ")", "\n", "\n", "", "lr", "=", "adjust_learning_rate", "(", "optimizer", ",", "curr_iter", ",", "config", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "train_model", "(", "data", ",", "label", ")", "\n", "loss", "=", "0", "\n", "if", "config", ".", "network", ".", "has_rpn", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'rpn_cls_loss'", "]", ".", "mean", "(", ")", "+", "output", "[", "'rpn_bbox_loss'", "]", ".", "mean", "(", ")", "\n", "", "if", "config", ".", "network", ".", "has_rcnn", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'cls_loss'", "]", ".", "mean", "(", ")", "+", "output", "[", "'bbox_loss'", "]", ".", "mean", "(", ")", "*", "config", ".", "train", ".", "bbox_loss_weight", "\n", "", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'mask_loss'", "]", ".", "mean", "(", ")", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'fcn_loss'", "]", ".", "mean", "(", ")", "*", "config", ".", "train", ".", "fcn_loss_weight", "\n", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "                        ", "loss", "=", "loss", "+", "output", "[", "'fcn_roi_loss'", "]", ".", "mean", "(", ")", "*", "config", ".", "train", ".", "fcn_loss_weight", "*", "0.2", "\n", "", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'panoptic_loss'", "]", ".", "mean", "(", ")", "*", "config", ".", "train", ".", "panoptic_loss_weight", "\n", "", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", "lr", ")", "\n", "\n", "losses", "=", "[", "]", "\n", "losses", ".", "append", "(", "allreduce_async", "(", "loss", ",", "name", "=", "'train_total_loss'", ")", ")", "\n", "for", "l", "in", "metrics_name", ":", "\n", "                    ", "losses", ".", "append", "(", "allreduce_async", "(", "output", "[", "l", "]", ".", "mean", "(", ")", ",", "name", "=", "l", ")", ")", "\n", "\n", "", "loss", "=", "hvd", ".", "synchronize", "(", "losses", "[", "0", "]", ")", ".", "item", "(", ")", "\n", "if", "is_master", ":", "\n", "                    ", "writer", ".", "add_scalar", "(", "'train_total_loss'", ",", "loss", ",", "curr_iter", ")", "\n", "", "for", "i", ",", "(", "metric", ",", "l", ")", "in", "enumerate", "(", "zip", "(", "metrics", ",", "metrics_name", ")", ")", ":", "\n", "                    ", "loss", "=", "hvd", ".", "synchronize", "(", "losses", "[", "i", "+", "1", "]", ")", ".", "item", "(", ")", "\n", "if", "is_master", ":", "\n", "                        ", "writer", ".", "add_scalar", "(", "'train_'", "+", "l", ",", "loss", ",", "curr_iter", ")", "\n", "metric", ".", "update", "(", "_", ",", "_", ",", "loss", ")", "\n", "", "", "curr_iter", "+=", "1", "\n", "\n", "\n", "if", "curr_iter", "in", "config", ".", "train", ".", "decay_iteration", ":", "\n", "                    ", "if", "is_master", ":", "\n", "                        ", "logger", ".", "info", "(", "'decay momentum buffer'", ")", "\n", "", "for", "k", "in", "optimizer", ".", "state_dict", "(", ")", "[", "'state'", "]", ".", "keys", "(", ")", ":", "\n", "                        ", "if", "'momentum_buffer'", "in", "optimizer", ".", "state_dict", "(", ")", "[", "'state'", "]", "[", "k", "]", ":", "\n", "                            ", "optimizer", ".", "state_dict", "(", ")", "[", "'state'", "]", "[", "k", "]", "[", "'momentum_buffer'", "]", ".", "div_", "(", "10", ")", "\n", "\n", "", "", "", "if", "is_master", ":", "\n", "                    ", "if", "curr_iter", "%", "config", ".", "train", ".", "display_iter", "==", "0", ":", "\n", "                        ", "for", "callback", "in", "batch_end_callback", ":", "\n", "                            ", "callback", "(", "curr_iter", ",", "metrics", ")", "\n", "\n", "", "", "if", "curr_iter", "%", "config", ".", "train", ".", "snapshot_step", "==", "0", ":", "\n", "                        ", "logger", ".", "info", "(", "'taking snapshot ...'", ")", "\n", "torch", ".", "save", "(", "train_model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.pth'", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.state.pth'", ")", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "inner_iter", "=", "0", "\n", "train_iterator", "=", "train_loader", ".", "__iter__", "(", ")", "\n", "while", "inner_iter", "+", "num_gpus", "<=", "len", "(", "train_loader", ")", ":", "\n", "                ", "batch", "=", "[", "]", "\n", "for", "gpu_id", "in", "gpus", ":", "\n", "                    ", "data", ",", "label", ",", "_", "=", "train_iterator", ".", "next", "(", ")", "\n", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", ":", "\n", "                        ", "data", "[", "k", "]", "=", "v", "if", "not", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", ".", "pin_memory", "(", ")", ".", "to", "(", "gpu_id", ",", "non_blocking", "=", "True", ")", "\n", "", "for", "k", ",", "v", "in", "label", ".", "items", "(", ")", ":", "\n", "                        ", "label", "[", "k", "]", "=", "v", "if", "not", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", ".", "pin_memory", "(", ")", ".", "to", "(", "gpu_id", ",", "non_blocking", "=", "True", ")", "\n", "", "batch", ".", "append", "(", "(", "data", ",", "label", ")", ")", "\n", "inner_iter", "+=", "1", "\n", "", "lr", "=", "adjust_learning_rate", "(", "optimizer", ",", "curr_iter", ",", "config", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "if", "config", ".", "train", ".", "use_horovod", ":", "\n", "                    ", "output", "=", "train_model", "(", "data", ",", "label", ")", "\n", "", "else", ":", "\n", "                    ", "output", "=", "train_model", "(", "*", "batch", ")", "\n", "\n", "", "loss", "=", "0", "\n", "if", "config", ".", "network", ".", "has_rpn", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'rpn_cls_loss'", "]", ".", "mean", "(", ")", "+", "output", "[", "'rpn_bbox_loss'", "]", ".", "mean", "(", ")", "\n", "", "if", "config", ".", "network", ".", "has_rcnn", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'cls_loss'", "]", ".", "mean", "(", ")", "+", "output", "[", "'bbox_loss'", "]", ".", "mean", "(", ")", "\n", "", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'mask_loss'", "]", ".", "mean", "(", ")", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'fcn_loss'", "]", ".", "mean", "(", ")", "*", "config", ".", "train", ".", "fcn_loss_weight", "\n", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "                        ", "loss", "=", "loss", "+", "output", "[", "'fcn_roi_loss'", "]", ".", "mean", "(", ")", "*", "config", ".", "train", ".", "fcn_loss_weight", "*", "0.2", "\n", "", "", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "                    ", "loss", "=", "loss", "+", "output", "[", "'panoptic_loss'", "]", ".", "mean", "(", ")", "*", "config", ".", "train", ".", "panoptic_loss_weight", "\n", "", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", "lr", ")", "\n", "\n", "losses", "=", "[", "]", "\n", "losses", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "for", "l", "in", "metrics_name", ":", "\n", "                    ", "losses", ".", "append", "(", "output", "[", "l", "]", ".", "mean", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "loss", "=", "losses", "[", "0", "]", "\n", "if", "is_master", ":", "\n", "                    ", "writer", ".", "add_scalar", "(", "'train_total_loss'", ",", "loss", ",", "curr_iter", ")", "\n", "", "for", "i", ",", "(", "metric", ",", "l", ")", "in", "enumerate", "(", "zip", "(", "metrics", ",", "metrics_name", ")", ")", ":", "\n", "                    ", "loss", "=", "losses", "[", "i", "+", "1", "]", "\n", "if", "is_master", ":", "\n", "                        ", "writer", ".", "add_scalar", "(", "'train_'", "+", "l", ",", "loss", ",", "curr_iter", ")", "\n", "metric", ".", "update", "(", "_", ",", "_", ",", "loss", ")", "\n", "", "", "curr_iter", "+=", "1", "\n", "\n", "if", "curr_iter", "in", "config", ".", "train", ".", "decay_iteration", ":", "\n", "                    ", "if", "is_master", ":", "\n", "                        ", "logger", ".", "info", "(", "'decay momentum buffer'", ")", "\n", "", "for", "k", "in", "optimizer", ".", "state_dict", "(", ")", "[", "'state'", "]", ".", "keys", "(", ")", ":", "\n", "                        ", "optimizer", ".", "state_dict", "(", ")", "[", "'state'", "]", "[", "k", "]", "[", "'momentum_buffer'", "]", ".", "div_", "(", "10", ")", "\n", "\n", "", "", "if", "is_master", ":", "\n", "                    ", "if", "curr_iter", "%", "config", ".", "train", ".", "display_iter", "==", "0", ":", "\n", "                        ", "for", "callback", "in", "batch_end_callback", ":", "\n", "                            ", "callback", "(", "curr_iter", ",", "metrics", ")", "\n", "\n", "\n", "", "", "if", "curr_iter", "%", "config", ".", "train", ".", "snapshot_step", "==", "0", ":", "\n", "                        ", "logger", ".", "info", "(", "'taking snapshot ...'", ")", "\n", "torch", ".", "save", "(", "train_model", ".", "module", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.pth'", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.state.pth'", ")", ")", "\n", "\n", "", "", "", "while", "True", ":", "\n", "                ", "try", ":", "\n", "                    ", "train_iterator", ".", "next", "(", ")", "\n", "", "except", ":", "\n", "                    ", "break", "\n", "\n", "", "", "", "for", "metric", "in", "metrics", ":", "\n", "            ", "metric", ".", "reset", "(", ")", "\n", "\n", "", "if", "config", ".", "train", ".", "eval_data", ":", "\n", "            ", "train_model", ".", "eval", "(", ")", "\n", "\n", "if", "config", ".", "train", ".", "use_horovod", ":", "\n", "                ", "for", "inner_iter", ",", "batch", "in", "enumerate", "(", "val_loader", ")", ":", "\n", "                    ", "data", ",", "label", ",", "_", "=", "batch", "\n", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", ":", "\n", "                        ", "data", "[", "k", "]", "=", "v", "if", "not", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", ".", "cuda", "(", "non_blocking", "=", "True", ")", "\n", "", "for", "k", ",", "v", "in", "label", ".", "items", "(", ")", ":", "\n", "                        ", "label", "[", "k", "]", "=", "v", "if", "not", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", ".", "cuda", "(", "non_blocking", "=", "True", ")", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "output", "=", "train_model", "(", "data", ",", "label", ")", "\n", "\n", "", "for", "metric", ",", "l", "in", "zip", "(", "metrics", ",", "metrics_name", ")", ":", "\n", "                        ", "loss", "=", "hvd", ".", "allreduce", "(", "output", "[", "l", "]", ".", "mean", "(", ")", ")", ".", "item", "(", ")", "\n", "if", "is_master", ":", "\n", "                            ", "metric", ".", "update", "(", "_", ",", "_", ",", "loss", ")", "\n", "\n", "", "", "", "", "else", ":", "\n", "                ", "inner_iter", "=", "0", "\n", "val_iterator", "=", "val_loader", ".", "__iter__", "(", ")", "\n", "while", "inner_iter", "+", "len", "(", "gpus", ")", "<=", "len", "(", "val_loader", ")", ":", "\n", "                    ", "batch", "=", "[", "]", "\n", "for", "gpu_id", "in", "gpus", ":", "\n", "                        ", "data", ",", "label", ",", "_", "=", "val_iterator", ".", "next", "(", ")", "\n", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", ":", "\n", "                            ", "data", "[", "k", "]", "=", "v", "if", "not", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", ".", "pin_memory", "(", ")", ".", "to", "(", "gpu_id", ",", "non_blocking", "=", "True", ")", "\n", "", "for", "k", ",", "v", "in", "label", ".", "items", "(", ")", ":", "\n", "                            ", "label", "[", "k", "]", "=", "v", "if", "not", "torch", ".", "is_tensor", "(", "v", ")", "else", "v", ".", "pin_memory", "(", ")", ".", "to", "(", "gpu_id", ",", "non_blocking", "=", "True", ")", "\n", "", "batch", ".", "append", "(", "(", "data", ",", "label", ")", ")", "\n", "inner_iter", "+=", "1", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "if", "config", ".", "train", ".", "use_horovod", ":", "\n", "                            ", "output", "=", "train_model", "(", "data", ",", "label", ")", "\n", "", "else", ":", "\n", "                            ", "output", "=", "train_model", "(", "*", "batch", ")", "\n", "\n", "", "", "losses", "=", "[", "]", "\n", "for", "l", "in", "metrics_name", ":", "\n", "                        ", "losses", ".", "append", "(", "allreduce_async", "(", "output", "[", "l", "]", ".", "mean", "(", ")", ",", "name", "=", "l", ")", "if", "config", ".", "train", ".", "use_horovod", "else", "output", "[", "l", "]", ".", "mean", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "for", "metric", ",", "loss", "in", "zip", "(", "metrics", ",", "losses", ")", ":", "\n", "                        ", "loss", "=", "hvd", ".", "synchronize", "(", "loss", ")", ".", "item", "(", ")", "if", "config", ".", "train", ".", "use_horovod", "else", "loss", "\n", "if", "is_master", ":", "\n", "                            ", "metric", ".", "update", "(", "_", ",", "_", ",", "loss", ")", "\n", "\n", "", "", "", "while", "True", ":", "\n", "                    ", "try", ":", "\n", "                        ", "val_iterator", ".", "next", "(", ")", "\n", "", "except", "Exception", ":", "\n", "                        ", "break", "\n", "\n", "", "", "", "s", "=", "'Batch [%d]\\t Epoch[%d]\\t'", "%", "(", "curr_iter", ",", "curr_iter", "//", "len", "(", "train_loader", ")", ")", "\n", "\n", "for", "metric", "in", "metrics", ":", "\n", "                ", "m", ",", "v", "=", "metric", ".", "get", "(", ")", "\n", "s", "+=", "'Val-%s=%f,\\t'", "%", "(", "m", ",", "v", ")", "\n", "if", "is_master", ":", "\n", "                    ", "writer", ".", "add_scalar", "(", "'val_'", "+", "m", ",", "v", ",", "curr_iter", ")", "\n", "metric", ".", "reset", "(", ")", "\n", "", "", "if", "is_master", ":", "\n", "                ", "logger", ".", "info", "(", "s", ")", "\n", "\n", "", "", "", "if", "is_master", "and", "config", ".", "train", ".", "use_horovod", ":", "\n", "        ", "logger", ".", "info", "(", "'taking snapshot ...'", ")", "\n", "torch", ".", "save", "(", "train_model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.pth'", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.state.pth'", ")", ")", "\n", "", "elif", "not", "config", ".", "train", ".", "use_horovod", ":", "\n", "        ", "logger", ".", "info", "(", "'taking snapshot ...'", ")", "\n", "torch", ".", "save", "(", "train_model", ".", "module", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.pth'", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "final_output_path", ",", "config", ".", "model_prefix", "+", "str", "(", "curr_iter", ")", "+", "'.state.pth'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.setup.custom_build_ext.build_extensions": [[114, 117], ["setup.customize_compiler_for_nvcc", "Cython.Distutils.build_ext.build_extensions"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.setup.customize_compiler_for_nvcc", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.setup.custom_build_ext.build_extensions"], ["    ", "def", "build_extensions", "(", "self", ")", ":", "\n", "        ", "customize_compiler_for_nvcc", "(", "self", ".", "compiler", ")", "\n", "build_ext", ".", "build_extensions", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.setup.find_in_path": [[22, 31], ["path.split", "os.path.join", "os.path.exists", "os.path.abspath"], "function", ["None"], ["def", "find_in_path", "(", "name", ",", "path", ")", ":", "\n", "    ", "\"Find a file in a search path\"", "\n", "# Adapted fom", "\n", "# http://code.activestate.com/recipes/52224-find-a-file-given-a-search-path/", "\n", "for", "dir", "in", "path", ".", "split", "(", "os", ".", "pathsep", ")", ":", "\n", "        ", "binpath", "=", "pjoin", "(", "dir", ",", "name", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "binpath", ")", ":", "\n", "            ", "return", "os", ".", "path", ".", "abspath", "(", "binpath", ")", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.setup.locate_cuda": [[33, 64], ["cudaconfig.items", "os.path.join", "os.path.join", "setup.find_in_path", "os.path.dirname", "os.path.join", "os.path.join", "EnvironmentError", "os.path.dirname", "os.path.exists", "EnvironmentError"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.nms.setup.find_in_path"], ["", "def", "locate_cuda", "(", ")", ":", "\n", "    ", "\"\"\"Locate the CUDA environment on the system\n\n    Returns a dict with keys 'home', 'nvcc', 'include', and 'lib64'\n    and values giving the absolute path to each directory.\n\n    Starts by looking for the CUDAHOME env variable. If not found, everything\n    is based on finding 'nvcc' in the PATH.\n    \"\"\"", "\n", "\n", "# first check if the CUDAHOME env variable is in use", "\n", "if", "'CUDAHOME'", "in", "os", ".", "environ", ":", "\n", "        ", "home", "=", "os", ".", "environ", "[", "'CUDAHOME'", "]", "\n", "nvcc", "=", "pjoin", "(", "home", ",", "'bin'", ",", "'nvcc'", ")", "\n", "", "else", ":", "\n", "# otherwise, search the PATH for NVCC", "\n", "        ", "default_path", "=", "pjoin", "(", "os", ".", "sep", ",", "'usr'", ",", "'local'", ",", "'cuda'", ",", "'bin'", ")", "\n", "nvcc", "=", "find_in_path", "(", "'nvcc'", ",", "os", ".", "environ", "[", "'PATH'", "]", "+", "os", ".", "pathsep", "+", "default_path", ")", "\n", "if", "nvcc", "is", "None", ":", "\n", "            ", "raise", "EnvironmentError", "(", "'The nvcc binary could not be '", "\n", "'located in your $PATH. Either add it to your path, or set $CUDAHOME'", ")", "\n", "", "home", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "nvcc", ")", ")", "\n", "\n", "", "cudaconfig", "=", "{", "'home'", ":", "home", ",", "'nvcc'", ":", "nvcc", ",", "\n", "'include'", ":", "pjoin", "(", "home", ",", "'include'", ")", ",", "\n", "'lib64'", ":", "pjoin", "(", "home", ",", "'lib64'", ")", "}", "\n", "for", "k", ",", "v", "in", "cudaconfig", ".", "items", "(", ")", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "v", ")", ":", "\n", "            ", "raise", "EnvironmentError", "(", "'The CUDA %s path could not be located in %s'", "%", "(", "k", ",", "v", ")", ")", "\n", "\n", "", "", "return", "cudaconfig", "\n", "", "CUDA", "=", "locate_cuda", "(", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.setup.customize_compiler_for_nvcc": [[74, 110], ["setup..src_extensions.append", "setup..set_executable", "os.path.splitext"], "function", ["None"], ["", "def", "customize_compiler_for_nvcc", "(", "self", ")", ":", "\n", "    ", "\"\"\"inject deep into distutils to customize how the dispatch\n    to gcc/nvcc works.\n\n    If you subclass UnixCCompiler, it's not trivial to get your subclass\n    injected in, and still have the right customizations (i.e.\n    distutils.sysconfig.customize_compiler) run on it. So instead of going\n    the OO route, I have this. Note, it's kindof like a wierd functional\n    subclassing going on.\"\"\"", "\n", "\n", "# tell the compiler it can processes .cu", "\n", "self", ".", "src_extensions", ".", "append", "(", "'.cu'", ")", "\n", "\n", "# save references to the default compiler_so and _comple methods", "\n", "default_compiler_so", "=", "self", ".", "compiler_so", "\n", "super", "=", "self", ".", "_compile", "\n", "\n", "# now redefine the _compile method. This gets executed for each", "\n", "# object but distutils doesn't have the ability to change compilers", "\n", "# based on source extension: we add it.", "\n", "def", "_compile", "(", "obj", ",", "src", ",", "ext", ",", "cc_args", ",", "extra_postargs", ",", "pp_opts", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "splitext", "(", "src", ")", "[", "1", "]", "==", "'.cu'", ":", "\n", "# use the cuda for .cu files", "\n", "            ", "self", ".", "set_executable", "(", "'compiler_so'", ",", "CUDA", "[", "'nvcc'", "]", ")", "\n", "# use only a subset of the extra_postargs, which are 1-1 translated", "\n", "# from the extra_compile_args in the Extension class", "\n", "postargs", "=", "extra_postargs", "[", "'nvcc'", "]", "\n", "", "else", ":", "\n", "            ", "postargs", "=", "extra_postargs", "[", "'gcc'", "]", "\n", "\n", "", "super", "(", "obj", ",", "src", ",", "ext", ",", "cc_args", ",", "postargs", ",", "pp_opts", ")", "\n", "# reset the default compiler_so, which we might have changed for cuda", "\n", "self", ".", "compiler_so", "=", "default_compiler_so", "\n", "\n", "# inject our redefined _compile method into the class", "\n", "", "self", ".", "_compile", "=", "_compile", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.generate_anchors": [[50, 61], ["generate_anchors._generate_anchors", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._generate_anchors"], ["def", "generate_anchors", "(", "\n", "stride", "=", "16", ",", "sizes", "=", "(", "32", ",", "64", ",", "128", ",", "256", ",", "512", ")", ",", "aspect_ratios", "=", "(", "0.5", ",", "1", ",", "2", ")", "\n", ")", ":", "\n", "    ", "\"\"\"Generates a matrix of anchor boxes in (x1, y1, x2, y2) format. Anchors\n    are centered on stride / 2, have (approximate) sqrt areas of the specified\n    sizes, and aspect ratios as given.\n    \"\"\"", "\n", "return", "_generate_anchors", "(", "\n", "stride", ",", "\n", "np", ".", "array", "(", "sizes", ",", "dtype", "=", "np", ".", "float", ")", "/", "stride", ",", "\n", "np", ".", "array", "(", "aspect_ratios", ",", "dtype", "=", "np", ".", "float", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._generate_anchors": [[65, 77], ["generate_anchors._ratio_enum", "numpy.vstack", "numpy.arange", "numpy.array", "generate_anchors._scale_enum", "range"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._ratio_enum", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._scale_enum"], ["", "def", "_generate_anchors", "(", "base_size", "=", "16", ",", "scales", "=", "2", "**", "np", ".", "arange", "(", "3", ",", "6", ")", ",", "\n", "ratios", "=", "[", "0.5", ",", "1", ",", "2", "]", ")", ":", "\n", "    ", "\"\"\"\n    Generate anchor (reference) windows by enumerating aspect ratios X\n    scales wrt a reference (0, 0, 15, 15) window.\n    \"\"\"", "\n", "\n", "base_anchor", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "base_size", ",", "base_size", "]", ")", "-", "1", "\n", "ratio_anchors", "=", "_ratio_enum", "(", "base_anchor", ",", "ratios", ")", "\n", "anchors", "=", "np", ".", "vstack", "(", "[", "_scale_enum", "(", "ratio_anchors", "[", "i", ",", ":", "]", ",", "scales", ")", "\n", "for", "i", "in", "range", "(", "ratio_anchors", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.get_field_of_anchors": [[79, 131], ["generate_anchors.generate_anchors", "int", "numpy.meshgrid", "shift_x.ravel.ravel", "shift_y.ravel.ravel", "numpy.vstack().transpose", "field_of_anchors.reshape.reshape", "FieldOfAnchors", "hasattr", "str", "numpy.ceil", "numpy.ceil", "numpy.arange", "generate_anchors.reshape", "np.vstack().transpose.reshape().transpose", "str", "str", "numpy.vstack", "field_of_anchors.reshape.astype", "float", "float", "np.vstack().transpose.reshape"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.generate_anchors"], ["", "def", "get_field_of_anchors", "(", "\n", "stride", ",", "anchor_sizes", ",", "anchor_aspect_ratios", ",", "octave", "=", "None", ",", "aspect", "=", "None", "\n", ")", ":", "\n", "    ", "global", "_threadlocal_foa", "\n", "if", "not", "hasattr", "(", "_threadlocal_foa", ",", "'cache'", ")", ":", "\n", "        ", "_threadlocal_foa", ".", "cache", "=", "{", "}", "\n", "\n", "", "cache_key", "=", "str", "(", "stride", ")", "+", "str", "(", "anchor_sizes", ")", "+", "str", "(", "anchor_aspect_ratios", ")", "\n", "if", "cache_key", "in", "_threadlocal_foa", ".", "cache", ":", "\n", "        ", "return", "_threadlocal_foa", ".", "cache", "[", "cache_key", "]", "\n", "\n", "# Anchors at a single feature cell", "\n", "", "cell_anchors", "=", "generate_anchors", "(", "\n", "stride", "=", "stride", ",", "sizes", "=", "anchor_sizes", ",", "aspect_ratios", "=", "anchor_aspect_ratios", "\n", ")", "\n", "num_cell_anchors", "=", "cell_anchors", ".", "shape", "[", "0", "]", "\n", "\n", "# Generate canonical proposals from shifted anchors", "\n", "# Enumerate all shifted positions on the (H, W) grid", "\n", "fpn_max_size", "=", "config", ".", "network", ".", "rcnn_feat_stride", "*", "np", ".", "ceil", "(", "\n", "config", ".", "train", ".", "max_size", "/", "float", "(", "config", ".", "network", ".", "rcnn_feat_stride", ")", "\n", ")", "\n", "field_size", "=", "int", "(", "np", ".", "ceil", "(", "fpn_max_size", "/", "float", "(", "stride", ")", ")", ")", "\n", "shifts", "=", "np", ".", "arange", "(", "0", ",", "field_size", ")", "*", "stride", "\n", "shift_x", ",", "shift_y", "=", "np", ".", "meshgrid", "(", "shifts", ",", "shifts", ")", "\n", "shift_x", "=", "shift_x", ".", "ravel", "(", ")", "\n", "shift_y", "=", "shift_y", ".", "ravel", "(", ")", "\n", "shifts", "=", "np", ".", "vstack", "(", "(", "shift_x", ",", "shift_y", ",", "shift_x", ",", "shift_y", ")", ")", ".", "transpose", "(", ")", "\n", "\n", "# Broacast anchors over shifts to enumerate all anchors at all positions", "\n", "# in the (H, W) grid:", "\n", "#   - add A cell anchors of shape (1, A, 4) to", "\n", "#   - K shifts of shape (K, 1, 4) to get", "\n", "#   - all shifted anchors of shape (K, A, 4)", "\n", "#   - reshape to (K*A, 4) shifted anchors", "\n", "A", "=", "num_cell_anchors", "\n", "K", "=", "shifts", ".", "shape", "[", "0", "]", "\n", "field_of_anchors", "=", "(", "\n", "cell_anchors", ".", "reshape", "(", "(", "1", ",", "A", ",", "4", ")", ")", "+", "\n", "shifts", ".", "reshape", "(", "(", "1", ",", "K", ",", "4", ")", ")", ".", "transpose", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", ")", "\n", "field_of_anchors", "=", "field_of_anchors", ".", "reshape", "(", "(", "K", "*", "A", ",", "4", ")", ")", "\n", "foa", "=", "FieldOfAnchors", "(", "\n", "field_of_anchors", "=", "field_of_anchors", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "num_cell_anchors", "=", "num_cell_anchors", ",", "\n", "stride", "=", "stride", ",", "\n", "field_size", "=", "field_size", ",", "\n", "octave", "=", "octave", ",", "\n", "aspect", "=", "aspect", "\n", ")", "\n", "_threadlocal_foa", ".", "cache", "[", "cache_key", "]", "=", "foa", "\n", "return", "foa", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.unmap": [[133, 148], ["len", "len", "numpy.empty", "np.empty.fill", "numpy.empty", "np.empty.fill"], "function", ["None"], ["", "def", "unmap", "(", "data", ",", "count", ",", "inds", ",", "fill", "=", "0", ")", ":", "\n", "    ", "\"\"\"Unmap a subset of item (data) back to the original set of items (of\n    size count)\"\"\"", "\n", "if", "count", "==", "len", "(", "inds", ")", ":", "\n", "        ", "return", "data", "\n", "\n", "", "if", "len", "(", "data", ".", "shape", ")", "==", "1", ":", "\n", "        ", "ret", "=", "np", ".", "empty", "(", "(", "count", ",", ")", ",", "dtype", "=", "data", ".", "dtype", ")", "\n", "ret", ".", "fill", "(", "fill", ")", "\n", "ret", "[", "inds", "]", "=", "data", "\n", "", "else", ":", "\n", "        ", "ret", "=", "np", ".", "empty", "(", "(", "count", ",", ")", "+", "data", ".", "shape", "[", "1", ":", "]", ",", "dtype", "=", "data", ".", "dtype", ")", "\n", "ret", ".", "fill", "(", "fill", ")", "\n", "ret", "[", "inds", ",", ":", "]", "=", "data", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.compute_targets": [[150, 154], ["upsnet.bbox.bbox_transform.bbox_transform_inv().astype", "upsnet.bbox.bbox_transform.bbox_transform_inv"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_transform_inv"], ["", "def", "compute_targets", "(", "ex_rois", ",", "gt_rois", ",", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", ":", "\n", "    ", "\"\"\"Compute bounding-box regression targets for an image.\"\"\"", "\n", "return", "bbox_transform_inv", "(", "ex_rois", ",", "gt_rois", ",", "weights", ")", ".", "astype", "(", "\n", "np", ".", "float32", ",", "copy", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._whctrs": [[156, 166], ["None"], "function", ["None"], ["", "def", "_whctrs", "(", "anchor", ")", ":", "\n", "    ", "\"\"\"\n    Return width, height, x center, and y center for an anchor (window).\n    \"\"\"", "\n", "\n", "w", "=", "anchor", "[", "2", "]", "-", "anchor", "[", "0", "]", "+", "1", "\n", "h", "=", "anchor", "[", "3", "]", "-", "anchor", "[", "1", "]", "+", "1", "\n", "x_ctr", "=", "anchor", "[", "0", "]", "+", "0.5", "*", "(", "w", "-", "1", ")", "\n", "y_ctr", "=", "anchor", "[", "1", "]", "+", "0.5", "*", "(", "h", "-", "1", ")", "\n", "return", "w", ",", "h", ",", "x_ctr", ",", "y_ctr", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._mkanchors": [[168, 181], ["numpy.hstack"], "function", ["None"], ["", "def", "_mkanchors", "(", "ws", ",", "hs", ",", "x_ctr", ",", "y_ctr", ")", ":", "\n", "    ", "\"\"\"\n    Given a vector of widths (ws) and heights (hs) around a center\n    (x_ctr, y_ctr), output a set of anchors (windows).\n    \"\"\"", "\n", "\n", "ws", "=", "ws", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "hs", "=", "hs", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "anchors", "=", "np", ".", "hstack", "(", "(", "x_ctr", "-", "0.5", "*", "(", "ws", "-", "1", ")", ",", "\n", "y_ctr", "-", "0.5", "*", "(", "hs", "-", "1", ")", ",", "\n", "x_ctr", "+", "0.5", "*", "(", "ws", "-", "1", ")", ",", "\n", "y_ctr", "+", "0.5", "*", "(", "hs", "-", "1", ")", ")", ")", "\n", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._ratio_enum": [[183, 195], ["generate_anchors._whctrs", "numpy.round", "numpy.round", "generate_anchors._mkanchors", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._whctrs", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._mkanchors"], ["", "def", "_ratio_enum", "(", "anchor", ",", "ratios", ")", ":", "\n", "    ", "\"\"\"\n    Enumerate a set of anchors for each aspect ratio wrt an anchor.\n    \"\"\"", "\n", "\n", "w", ",", "h", ",", "x_ctr", ",", "y_ctr", "=", "_whctrs", "(", "anchor", ")", "\n", "size", "=", "w", "*", "h", "\n", "size_ratios", "=", "size", "/", "ratios", "\n", "ws", "=", "np", ".", "round", "(", "np", ".", "sqrt", "(", "size_ratios", ")", ")", "\n", "hs", "=", "np", ".", "round", "(", "ws", "*", "ratios", ")", "\n", "anchors", "=", "_mkanchors", "(", "ws", ",", "hs", ",", "x_ctr", ",", "y_ctr", ")", "\n", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._scale_enum": [[197, 207], ["generate_anchors._whctrs", "generate_anchors._mkanchors"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._whctrs", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors._mkanchors"], ["", "def", "_scale_enum", "(", "anchor", ",", "scales", ")", ":", "\n", "    ", "\"\"\"\n    Enumerate a set of anchors for each scale wrt an anchor.\n    \"\"\"", "\n", "\n", "w", ",", "h", ",", "x_ctr", ",", "y_ctr", "=", "_whctrs", "(", "anchor", ")", "\n", "ws", "=", "w", "*", "scales", "\n", "hs", "=", "h", "*", "scales", "\n", "anchors", "=", "_mkanchors", "(", "ws", ",", "hs", ",", "x_ctr", ",", "y_ctr", ")", "\n", "return", "anchors", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor.assign_anchor": [[41, 168], ["numpy.array", "generate_anchors.generate_anchors", "numpy.meshgrid", "numpy.vstack().transpose", "all_anchors.reshape.reshape", "int", "numpy.empty", "labels.reshape.fill", "int", "numpy.zeros", "numpy.zeros", "numpy.array", "assign_anchor.assign_anchor._unmap"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.generate_anchors"], ["def", "assign_anchor", "(", "feat_shape", ",", "gt_boxes", ",", "im_info", ",", "feat_stride", "=", "16", ",", "\n", "scales", "=", "(", "8", ",", "16", ",", "32", ")", ",", "ratios", "=", "(", "0.5", ",", "1", ",", "2", ")", ",", "allowed_border", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    assign ground truth boxes to anchor positions\n    :param feat_shape: infer output shape\n    :param gt_boxes: assign ground truth\n    :param im_info: filter out anchors overlapped with edges\n    :param feat_stride: anchor position step\n    :param scales: used to generate anchors, affects num_anchors (per location)\n    :param ratios: aspect ratios of generated anchors\n    :param allowed_border: filter out anchors with edge overlap > allowed_border\n    :return: dict of label\n    'label': of shape (batch_size, 1) <- (batch_size, num_anchors, feat_height, feat_width)\n    'bbox_target': of shape (batch_size, num_anchors * 4, feat_height, feat_width)\n    'bbox_inside_weight': *todo* mark the assigned anchors\n    'bbox_outside_weight': used to normalize the bbox_loss, all weights sums to RPN_POSITIVE_WEIGHT\n    \"\"\"", "\n", "def", "_unmap", "(", "data", ",", "count", ",", "inds", ",", "fill", "=", "0", ")", ":", "\n", "        ", "\"\"\"\" unmap a subset inds of data into original data of size count \"\"\"", "\n", "if", "len", "(", "data", ".", "shape", ")", "==", "1", ":", "\n", "            ", "ret", "=", "np", ".", "empty", "(", "(", "count", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "ret", ".", "fill", "(", "fill", ")", "\n", "ret", "[", "inds", "]", "=", "data", "\n", "", "else", ":", "\n", "            ", "ret", "=", "np", ".", "empty", "(", "(", "count", ",", ")", "+", "data", ".", "shape", "[", "1", ":", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "ret", ".", "fill", "(", "fill", ")", "\n", "ret", "[", "inds", ",", ":", "]", "=", "data", "\n", "", "return", "ret", "\n", "\n", "", "DEBUG", "=", "False", "\n", "im_info", "=", "im_info", "[", "0", "]", "\n", "scales", "=", "np", ".", "array", "(", "scales", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "base_anchors", "=", "generate_anchors", "(", "base_size", "=", "feat_stride", ",", "ratios", "=", "list", "(", "ratios", ")", ",", "scales", "=", "scales", ")", "\n", "num_anchors", "=", "base_anchors", ".", "shape", "[", "0", "]", "\n", "feat_height", ",", "feat_width", "=", "feat_shape", "[", "-", "2", ":", "]", "\n", "\n", "# 1. generate proposals from bbox deltas and shifted anchors", "\n", "shift_x", "=", "np", ".", "arange", "(", "0", ",", "feat_width", ")", "*", "feat_stride", "\n", "shift_y", "=", "np", ".", "arange", "(", "0", ",", "feat_height", ")", "*", "feat_stride", "\n", "shift_x", ",", "shift_y", "=", "np", ".", "meshgrid", "(", "shift_x", ",", "shift_y", ")", "\n", "shifts", "=", "np", ".", "vstack", "(", "(", "shift_x", ".", "ravel", "(", ")", ",", "shift_y", ".", "ravel", "(", ")", ",", "shift_x", ".", "ravel", "(", ")", ",", "shift_y", ".", "ravel", "(", ")", ")", ")", ".", "transpose", "(", ")", "\n", "# add A anchors (1, A, 4) to", "\n", "# cell K shifts (K, 1, 4) to get", "\n", "# shift anchors (K, A, 4)", "\n", "# reshape to (K*A, 4) shifted anchors", "\n", "A", "=", "num_anchors", "\n", "K", "=", "shifts", ".", "shape", "[", "0", "]", "\n", "all_anchors", "=", "base_anchors", ".", "reshape", "(", "(", "1", ",", "A", ",", "4", ")", ")", "+", "shifts", ".", "reshape", "(", "(", "1", ",", "K", ",", "4", ")", ")", ".", "transpose", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "all_anchors", "=", "all_anchors", ".", "reshape", "(", "(", "K", "*", "A", ",", "4", ")", ")", "\n", "total_anchors", "=", "int", "(", "K", "*", "A", ")", "\n", "\n", "# only keep anchors inside the image", "\n", "inds_inside", "=", "np", ".", "where", "(", "(", "all_anchors", "[", ":", ",", "0", "]", ">=", "-", "allowed_border", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "1", "]", ">=", "-", "allowed_border", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "2", "]", "<", "im_info", "[", "1", "]", "+", "allowed_border", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "3", "]", "<", "im_info", "[", "0", "]", "+", "allowed_border", ")", ")", "[", "0", "]", "\n", "\n", "# keep only inside anchors", "\n", "anchors", "=", "all_anchors", "[", "inds_inside", ",", ":", "]", "\n", "\n", "# label: 1 is positive, 0 is negative, -1 is dont care", "\n", "labels", "=", "np", ".", "empty", "(", "(", "len", "(", "inds_inside", ")", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "labels", ".", "fill", "(", "-", "1", ")", "\n", "\n", "if", "gt_boxes", ".", "size", ">", "0", ":", "\n", "# overlap between the anchors and the gt boxes", "\n", "# overlaps (ex, gt)", "\n", "        ", "overlaps", "=", "bbox_overlaps", "(", "anchors", ".", "astype", "(", "np", ".", "float", ")", ",", "gt_boxes", ".", "astype", "(", "np", ".", "float", ")", ")", "\n", "argmax_overlaps", "=", "overlaps", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "max_overlaps", "=", "overlaps", "[", "np", ".", "arange", "(", "len", "(", "inds_inside", ")", ")", ",", "argmax_overlaps", "]", "\n", "gt_argmax_overlaps", "=", "overlaps", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "gt_max_overlaps", "=", "overlaps", "[", "gt_argmax_overlaps", ",", "np", ".", "arange", "(", "overlaps", ".", "shape", "[", "1", "]", ")", "]", "\n", "gt_argmax_overlaps", "=", "np", ".", "where", "(", "overlaps", "==", "gt_max_overlaps", ")", "[", "0", "]", "\n", "\n", "if", "not", "config", ".", "train", ".", "rpn_clobber_positives", ":", "\n", "# assign bg labels first so that positive labels can clobber them", "\n", "            ", "labels", "[", "max_overlaps", "<", "config", ".", "train", ".", "rpn_negative_overlap", "]", "=", "0", "\n", "\n", "# fg label: for each gt, anchor with highest overlap", "\n", "", "labels", "[", "gt_argmax_overlaps", "]", "=", "1", "\n", "\n", "# fg label: above threshold IoU", "\n", "labels", "[", "max_overlaps", ">=", "config", ".", "train", ".", "rpn_positive_overlap", "]", "=", "1", "\n", "\n", "if", "config", ".", "train", ".", "rpn_clobber_positives", ":", "\n", "# assign bg labels last so that negative labels can clobber positives", "\n", "            ", "labels", "[", "max_overlaps", "<", "config", ".", "train", ".", "rpn_negative_overlap", "]", "=", "0", "\n", "", "", "else", ":", "\n", "        ", "labels", "[", ":", "]", "=", "0", "\n", "\n", "# subsample positive labels if we have too many", "\n", "", "num_fg", "=", "int", "(", "config", ".", "train", ".", "rpn_fg_fraction", "*", "config", ".", "train", ".", "rpn_batch_size", ")", "\n", "fg_inds", "=", "np", ".", "where", "(", "labels", "==", "1", ")", "[", "0", "]", "\n", "if", "len", "(", "fg_inds", ")", ">", "num_fg", ":", "\n", "        ", "disable_inds", "=", "npr", ".", "choice", "(", "fg_inds", ",", "size", "=", "(", "len", "(", "fg_inds", ")", "-", "num_fg", ")", ",", "replace", "=", "False", ")", "\n", "# if DEBUG:", "\n", "#     disable_inds = fg_inds[:(len(fg_inds) - num_fg)]", "\n", "labels", "[", "disable_inds", "]", "=", "-", "1", "\n", "\n", "# subsample negative labels if we have too many", "\n", "", "num_bg", "=", "config", ".", "train", ".", "rpn_batch_size", "-", "np", ".", "sum", "(", "labels", "==", "1", ")", "\n", "bg_inds", "=", "np", ".", "where", "(", "labels", "==", "0", ")", "[", "0", "]", "\n", "if", "len", "(", "bg_inds", ")", ">", "num_bg", ":", "\n", "        ", "disable_inds", "=", "npr", ".", "choice", "(", "bg_inds", ",", "size", "=", "(", "len", "(", "bg_inds", ")", "-", "num_bg", ")", ",", "replace", "=", "False", ")", "\n", "labels", "[", "disable_inds", "]", "=", "-", "1", "\n", "\n", "", "bbox_targets", "=", "np", ".", "zeros", "(", "(", "len", "(", "inds_inside", ")", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "gt_boxes", ".", "size", ">", "0", ":", "\n", "        ", "bbox_targets", "[", ":", "]", "=", "bbox_transform", "(", "anchors", ",", "gt_boxes", "[", "argmax_overlaps", ",", ":", "4", "]", ")", "\n", "\n", "", "bbox_weights", "=", "np", ".", "zeros", "(", "(", "len", "(", "inds_inside", ")", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "bbox_weights", "[", "labels", "==", "1", ",", ":", "]", "=", "np", ".", "array", "(", "config", ".", "train", ".", "rpn_bbox_weights", ")", "\n", "\n", "# map up to original set of anchors", "\n", "labels", "=", "_unmap", "(", "labels", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "-", "1", ")", "\n", "bbox_targets", "=", "_unmap", "(", "bbox_targets", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "0", ")", "\n", "bbox_weights", "=", "_unmap", "(", "bbox_weights", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "0", ")", "\n", "\n", "labels", "=", "labels", ".", "reshape", "(", "(", "1", ",", "feat_height", ",", "feat_width", ",", "A", ")", ")", ".", "transpose", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "labels", "=", "labels", ".", "reshape", "(", "(", "1", ",", "A", "*", "feat_height", "*", "feat_width", ")", ")", "\n", "bbox_targets", "=", "bbox_targets", ".", "reshape", "(", "(", "1", ",", "feat_height", ",", "feat_width", ",", "A", "*", "4", ")", ")", ".", "transpose", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "bbox_weights", "=", "bbox_weights", ".", "reshape", "(", "(", "1", ",", "feat_height", ",", "feat_width", ",", "A", "*", "4", ")", ")", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "2", ")", ")", "\n", "\n", "label", "=", "{", "'label'", ":", "labels", ",", "\n", "'bbox_target'", ":", "bbox_targets", ",", "\n", "'bbox_weight'", ":", "bbox_weights", "}", "\n", "return", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor.assign_pyramid_anchor": [[170, 367], ["numpy.array", "range", "numpy.concatenate", "range", "numpy.concatenate", "sum", "numpy.empty", "_unmap.fill", "int", "numpy.zeros", "numpy.zeros", "numpy.array", "assign_anchor.assign_anchor._unmap"], "function", ["None"], ["", "def", "assign_pyramid_anchor", "(", "gt_boxes", ",", "im_info", ",", "feat_strides", "=", "(", "64", ",", "32", ",", "16", ",", "8", ",", "4", ")", ",", "\n", "scales", "=", "(", "8", ",", ")", ",", "ratios", "=", "(", "0.5", ",", "1", ",", "2", ")", ",", "allowed_border", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    assign ground truth boxes to anchor positions\n    :param feat_shape: infer output shape\n    :param gt_boxes: assign ground truth\n    :param im_info: filter out anchors overlapped with edges\n    :param feat_stride: anchor position step\n    :param scales: used to generate anchors, affects num_anchors (per location)\n    :param ratios: aspect ratios of generated anchors\n    :param allowed_border: filter out anchors with edge overlap > allowed_border\n    :return: tuple\n    labels: of shape (batch_size, 1) <- (batch_size, num_anchors, feat_height, feat_width)\n    bbox_targets: of shape (batch_size, num_anchors * 4, feat_height, feat_width)\n    bbox_weights: mark the assigned anchors\n    \"\"\"", "\n", "def", "_unmap", "(", "data", ",", "count", ",", "inds", ",", "fill", "=", "0", ")", ":", "\n", "        ", "\"\"\"\" unmap a subset inds of data into original data of size count \"\"\"", "\n", "if", "len", "(", "data", ".", "shape", ")", "==", "1", ":", "\n", "            ", "ret", "=", "np", ".", "empty", "(", "(", "count", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "ret", ".", "fill", "(", "fill", ")", "\n", "ret", "[", "inds", "]", "=", "data", "\n", "", "else", ":", "\n", "            ", "ret", "=", "np", ".", "empty", "(", "(", "count", ",", ")", "+", "data", ".", "shape", "[", "1", ":", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "ret", ".", "fill", "(", "fill", ")", "\n", "ret", "[", "inds", ",", ":", "]", "=", "data", "\n", "", "return", "ret", "\n", "\n", "", "DEBUG", "=", "False", "\n", "im_info", "=", "im_info", "[", "0", "]", "\n", "# clean up boxes", "\n", "nonneg", "=", "np", ".", "where", "(", "gt_boxes", "[", ":", ",", "4", "]", "!=", "-", "1", ")", "[", "0", "]", "\n", "gt_boxes", "=", "gt_boxes", "[", "nonneg", "]", "\n", "scales", "=", "np", ".", "array", "(", "scales", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "anchors_list", "=", "[", "]", "\n", "anchors_num_list", "=", "[", "]", "\n", "inds_inside_list", "=", "[", "]", "\n", "feat_infos", "=", "[", "]", "\n", "A_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "feat_strides", ")", ")", ":", "\n", "        ", "base_anchors", "=", "generate_anchors", "(", "base_size", "=", "feat_strides", "[", "i", "]", ",", "ratios", "=", "list", "(", "ratios", ")", ",", "scales", "=", "scales", ")", "\n", "num_anchors", "=", "base_anchors", ".", "shape", "[", "0", "]", "\n", "# feat_height, feat_width = feat_shape[i][-2:]", "\n", "feat_height", ",", "feat_width", ",", "s", "=", "im_info", "[", "0", "]", ",", "im_info", "[", "1", "]", ",", "feat_strides", "[", "i", "]", "\n", "s", "=", "s", "//", "4", "\n", "feat_height", ",", "feat_width", "=", "int", "(", "np", ".", "ceil", "(", "feat_height", "/", "2", ")", ")", "//", "2", ",", "int", "(", "np", ".", "ceil", "(", "feat_width", "/", "2", ")", ")", "//", "2", ",", "\n", "while", "s", ">", "1", ":", "\n", "            ", "feat_height", ",", "feat_width", "=", "int", "(", "np", ".", "ceil", "(", "feat_height", "/", "2", ")", ")", ",", "int", "(", "np", ".", "ceil", "(", "feat_width", "/", "2", ")", ")", "\n", "s", "=", "s", "//", "2", "\n", "", "feat_stride", "=", "feat_strides", "[", "i", "]", "\n", "feat_infos", ".", "append", "(", "[", "feat_height", ",", "feat_width", "]", ")", "\n", "\n", "A", "=", "num_anchors", "\n", "A_list", ".", "append", "(", "A", ")", "\n", "K", "=", "feat_height", "*", "feat_width", "\n", "\n", "# shift_x = np.arange(0, feat_width) * feat_stride", "\n", "# shift_y = np.arange(0, feat_height) * feat_stride", "\n", "# shift_x, shift_y = np.meshgrid(shift_x, shift_y)", "\n", "# shifts = np.vstack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel())).transpose()", "\n", "# all_anchors = base_anchors.reshape((1, A, 4)) + shifts.reshape((1, K, 4)).transpose((1, 0, 2))", "\n", "all_anchors", "=", "anchors_cython", "(", "feat_height", ",", "feat_width", ",", "feat_stride", ",", "base_anchors", ")", "\n", "all_anchors", "=", "all_anchors", ".", "reshape", "(", "(", "K", "*", "A", ",", "4", ")", ")", "\n", "\n", "total_anchors", "=", "int", "(", "K", "*", "A", ")", "\n", "anchors_num_list", ".", "append", "(", "total_anchors", ")", "\n", "# only keep anchors inside the image", "\n", "inds_inside", "=", "np", ".", "where", "(", "(", "all_anchors", "[", ":", ",", "0", "]", ">=", "-", "allowed_border", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "1", "]", ">=", "-", "allowed_border", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "2", "]", "<", "im_info", "[", "1", "]", "+", "allowed_border", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "3", "]", "<", "im_info", "[", "0", "]", "+", "allowed_border", ")", ")", "[", "0", "]", "\n", "if", "DEBUG", ":", "\n", "            ", "print", "(", "'total_anchors'", ",", "total_anchors", ")", "\n", "print", "(", "'inds_inside'", ",", "len", "(", "inds_inside", ")", ")", "\n", "\n", "# keep only inside anchors", "\n", "", "anchors", "=", "all_anchors", "[", "inds_inside", ",", ":", "]", "\n", "\n", "anchors_list", ".", "append", "(", "anchors", ")", "\n", "inds_inside_list", ".", "append", "(", "inds_inside", ")", "\n", "\n", "# Concat anchors from each level", "\n", "", "anchors", "=", "np", ".", "concatenate", "(", "anchors_list", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "inds_inside_list", ")", ")", ":", "\n", "        ", "inds_inside_list", "[", "i", "]", "=", "inds_inside_list", "[", "i", "]", "+", "sum", "(", "anchors_num_list", "[", ":", "i", "]", ")", "\n", "", "inds_inside", "=", "np", ".", "concatenate", "(", "inds_inside_list", ")", "\n", "total_anchors", "=", "sum", "(", "anchors_num_list", ")", "\n", "\n", "# label: 1 is positive, 0 is negative, -1 is dont care", "\n", "labels", "=", "np", ".", "empty", "(", "(", "len", "(", "inds_inside", ")", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "labels", ".", "fill", "(", "-", "1", ")", "\n", "\n", "if", "gt_boxes", ".", "size", ">", "0", ":", "\n", "# overlap between the anchors and the gt boxes", "\n", "# overlaps (ex, gt)", "\n", "        ", "overlaps", "=", "bbox_overlaps", "(", "anchors", ".", "astype", "(", "np", ".", "float", ")", ",", "gt_boxes", ".", "astype", "(", "np", ".", "float", ")", ")", "\n", "argmax_overlaps", "=", "overlaps", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "max_overlaps", "=", "overlaps", "[", "np", ".", "arange", "(", "len", "(", "inds_inside", ")", ")", ",", "argmax_overlaps", "]", "\n", "gt_argmax_overlaps", "=", "overlaps", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "gt_max_overlaps", "=", "overlaps", "[", "gt_argmax_overlaps", ",", "np", ".", "arange", "(", "overlaps", ".", "shape", "[", "1", "]", ")", "]", "\n", "gt_argmax_overlaps", "=", "np", ".", "where", "(", "overlaps", "==", "gt_max_overlaps", ")", "[", "0", "]", "\n", "\n", "if", "not", "config", ".", "train", ".", "rpn_clobber_positives", ":", "\n", "# assign bg labels first so that positive labels can clobber them", "\n", "            ", "labels", "[", "max_overlaps", "<", "config", ".", "train", ".", "rpn_negative_overlap", "]", "=", "0", "\n", "\n", "# fg label: for each gt, anchor with highest overlap", "\n", "", "labels", "[", "gt_argmax_overlaps", "]", "=", "1", "\n", "\n", "# fg label: above threshold IoU", "\n", "labels", "[", "max_overlaps", ">=", "config", ".", "train", ".", "rpn_positive_overlap", "]", "=", "1", "\n", "\n", "if", "config", ".", "train", ".", "rpn_clobber_positives", ":", "\n", "# assign bg labels last so that negative labels can clobber positives", "\n", "            ", "labels", "[", "max_overlaps", "<", "config", ".", "train", ".", "rpn_negative_overlap", "]", "=", "0", "\n", "", "", "else", ":", "\n", "        ", "labels", "[", ":", "]", "=", "0", "\n", "\n", "# subsample positive labels if we have too many", "\n", "", "num_fg", "=", "int", "(", "config", ".", "train", ".", "rpn_fg_fraction", "*", "config", ".", "train", ".", "rpn_batch_size", ")", "\n", "fg_inds", "=", "np", ".", "where", "(", "labels", "==", "1", ")", "[", "0", "]", "\n", "if", "len", "(", "fg_inds", ")", ">", "num_fg", ":", "\n", "        ", "disable_inds", "=", "npr", ".", "choice", "(", "fg_inds", ",", "size", "=", "(", "len", "(", "fg_inds", ")", "-", "num_fg", ")", ",", "replace", "=", "False", ")", "\n", "if", "DEBUG", ":", "\n", "            ", "disable_inds", "=", "fg_inds", "[", ":", "(", "len", "(", "fg_inds", ")", "-", "num_fg", ")", "]", "\n", "", "labels", "[", "disable_inds", "]", "=", "-", "1", "\n", "\n", "# subsample negative labels if we have too many", "\n", "", "num_bg", "=", "config", ".", "train", ".", "rpn_batch_size", "-", "np", ".", "sum", "(", "labels", "==", "1", ")", "\n", "bg_inds", "=", "np", ".", "where", "(", "labels", "==", "0", ")", "[", "0", "]", "\n", "if", "len", "(", "bg_inds", ")", ">", "num_bg", ":", "\n", "        ", "disable_inds", "=", "npr", ".", "choice", "(", "bg_inds", ",", "size", "=", "(", "len", "(", "bg_inds", ")", "-", "num_bg", ")", ",", "replace", "=", "False", ")", "\n", "if", "DEBUG", ":", "\n", "            ", "disable_inds", "=", "bg_inds", "[", ":", "(", "len", "(", "bg_inds", ")", "-", "num_bg", ")", "]", "\n", "", "labels", "[", "disable_inds", "]", "=", "-", "1", "\n", "\n", "", "bbox_targets", "=", "np", ".", "zeros", "(", "(", "len", "(", "inds_inside", ")", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "gt_boxes", ".", "size", ">", "0", ":", "\n", "        ", "bbox_targets", "[", ":", "]", "=", "bbox_transform", "(", "anchors", ",", "gt_boxes", "[", "argmax_overlaps", ",", ":", "4", "]", ")", "\n", "\n", "", "bbox_weights", "=", "np", ".", "zeros", "(", "(", "len", "(", "inds_inside", ")", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "bbox_weights", "[", "labels", "==", "1", ",", ":", "]", "=", "np", ".", "array", "(", "config", ".", "train", ".", "rpn_bbox_weights", ")", "\n", "\n", "if", "DEBUG", ":", "\n", "        ", "_sums", "=", "bbox_targets", "[", "labels", "==", "1", ",", ":", "]", ".", "sum", "(", "axis", "=", "0", ")", "\n", "_squared_sums", "=", "(", "bbox_targets", "[", "labels", "==", "1", ",", ":", "]", "**", "2", ")", ".", "sum", "(", "axis", "=", "0", ")", "\n", "_counts", "=", "np", ".", "sum", "(", "labels", "==", "1", ")", "\n", "means", "=", "_sums", "/", "(", "_counts", "+", "1e-14", ")", "\n", "stds", "=", "np", ".", "sqrt", "(", "_squared_sums", "/", "_counts", "-", "means", "**", "2", ")", "\n", "print", "(", "'means'", ",", "means", ")", "\n", "print", "(", "'stdevs'", ",", "stds", ")", "\n", "# map up to original set of anchors", "\n", "", "labels", "=", "_unmap", "(", "labels", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "-", "1", ")", "\n", "bbox_targets", "=", "_unmap", "(", "bbox_targets", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "0", ")", "\n", "bbox_weights", "=", "_unmap", "(", "bbox_weights", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "0", ")", "\n", "\n", "if", "DEBUG", ":", "\n", "        ", "if", "gt_boxes", ".", "size", ">", "0", ":", "\n", "            ", "print", "(", "'rpn: max max_overlaps'", ",", "np", ".", "max", "(", "max_overlaps", ")", ")", "\n", "", "print", "(", "'rpn: num_positives'", ",", "np", ".", "sum", "(", "labels", "==", "1", ")", ")", "\n", "print", "(", "'rpn: num_negatives'", ",", "np", ".", "sum", "(", "labels", "==", "0", ")", ")", "\n", "_fg_sum", "=", "np", ".", "sum", "(", "labels", "==", "1", ")", "\n", "_bg_sum", "=", "np", ".", "sum", "(", "labels", "==", "0", ")", "\n", "_count", "=", "1", "\n", "print", "(", "'rpn: num_positive avg'", ",", "_fg_sum", "/", "_count", ")", "\n", "print", "(", "'rpn: num_negative avg'", ",", "_bg_sum", "/", "_count", ")", "\n", "\n", "# resahpe", "\n", "", "label_list", "=", "list", "(", ")", "\n", "bbox_target_list", "=", "list", "(", ")", "\n", "bbox_weight_list", "=", "list", "(", ")", "\n", "anchors_num_range", "=", "[", "0", "]", "+", "anchors_num_list", "\n", "for", "i", "in", "range", "(", "len", "(", "feat_strides", ")", ")", ":", "\n", "        ", "feat_height", ",", "feat_width", "=", "feat_infos", "[", "i", "]", "\n", "A", "=", "A_list", "[", "i", "]", "\n", "label", "=", "labels", "[", "sum", "(", "anchors_num_range", "[", ":", "i", "+", "1", "]", ")", ":", "sum", "(", "anchors_num_range", "[", ":", "i", "+", "1", "]", ")", "+", "anchors_num_range", "[", "i", "+", "1", "]", "]", "\n", "bbox_target", "=", "bbox_targets", "[", "sum", "(", "anchors_num_range", "[", ":", "i", "+", "1", "]", ")", ":", "sum", "(", "anchors_num_range", "[", ":", "i", "+", "1", "]", ")", "+", "anchors_num_range", "[", "i", "+", "1", "]", "]", "\n", "bbox_weight", "=", "bbox_weights", "[", "sum", "(", "anchors_num_range", "[", ":", "i", "+", "1", "]", ")", ":", "sum", "(", "anchors_num_range", "[", ":", "i", "+", "1", "]", ")", "+", "anchors_num_range", "[", "i", "+", "1", "]", "]", "\n", "\n", "label", "=", "label", ".", "reshape", "(", "(", "1", ",", "feat_height", ",", "feat_width", ",", "A", ")", ")", ".", "transpose", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "label", "=", "label", ".", "reshape", "(", "(", "1", ",", "A", "*", "feat_height", "*", "feat_width", ")", ")", "\n", "bbox_target", "=", "bbox_target", ".", "reshape", "(", "(", "1", ",", "feat_height", "*", "feat_width", ",", "A", "*", "4", ")", ")", ".", "transpose", "(", "0", ",", "2", ",", "1", ")", "\n", "bbox_weight", "=", "bbox_weight", ".", "reshape", "(", "(", "1", ",", "feat_height", "*", "feat_width", ",", "A", "*", "4", ")", ")", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "\n", "label_list", ".", "append", "(", "label", ")", "\n", "bbox_target_list", ".", "append", "(", "bbox_target", ")", "\n", "bbox_weight_list", ".", "append", "(", "bbox_weight", ")", "\n", "\n", "", "label_concat", "=", "np", ".", "concatenate", "(", "label_list", ",", "axis", "=", "1", ")", "\n", "bbox_target_concat", "=", "np", ".", "concatenate", "(", "bbox_target_list", ",", "axis", "=", "2", ")", "\n", "bbox_weight_concat", "=", "np", ".", "concatenate", "(", "bbox_weight_list", ",", "axis", "=", "2", ")", "\n", "\n", "label", "=", "{", "'label'", ":", "label_concat", ",", "\n", "'bbox_target'", ":", "bbox_target_concat", ",", "\n", "'bbox_weight'", ":", "bbox_weight_concat", "}", "\n", "return", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor.add_rpn_blobs": [[370, 446], ["enumerate", "blobs.items", "enumerate", "numpy.concatenate", "upsnet.rpn.generate_anchors.get_field_of_anchors", "numpy.round", "numpy.round", "numpy.zeros", "numpy.array", "blobs[].append", "upsnet.rpn.generate_anchors.get_field_of_anchors", "foas.append", "numpy.where", "numpy.where", "assign_anchor._get_rpn_blobs", "enumerate", "assign_anchor._get_rpn_blobs", "_get_rpn_blobs.items", "isinstance", "numpy.concatenate", "range", "numpy.array", "len", "rpn_blobs[].items", "blobs[].append", "len", "len", "blobs[].append", "str"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.get_field_of_anchors", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.get_field_of_anchors", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor._get_rpn_blobs", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor._get_rpn_blobs"], ["", "def", "add_rpn_blobs", "(", "blobs", ",", "im_scales", ",", "roidb", ")", ":", "\n", "    ", "\"\"\"Add blobs needed training RPN-only and end-to-end Faster R-CNN models.\"\"\"", "\n", "if", "config", ".", "network", ".", "has_fpn", ":", "\n", "# RPN applied to many feature levels, as in the FPN paper", "\n", "        ", "foas", "=", "[", "]", "\n", "for", "field_stride", "in", "config", ".", "network", ".", "rpn_feat_stride", ":", "\n", "            ", "anchor_sizes", "=", "(", "config", ".", "network", ".", "anchor_scales", "[", "0", "]", "*", "field_stride", ",", ")", "\n", "anchor_aspect_ratios", "=", "config", ".", "network", ".", "anchor_ratios", "\n", "foa", "=", "get_field_of_anchors", "(", "\n", "field_stride", ",", "anchor_sizes", ",", "anchor_aspect_ratios", "\n", ")", "\n", "foas", ".", "append", "(", "foa", ")", "\n", "", "all_anchors", "=", "np", ".", "concatenate", "(", "[", "f", ".", "field_of_anchors", "for", "f", "in", "foas", "]", ")", "\n", "", "else", ":", "\n", "        ", "foa", "=", "get_field_of_anchors", "(", "\n", "config", ".", "network", ".", "rpn_feat_stride", ",", "np", ".", "array", "(", "config", ".", "network", ".", "anchor_scales", ")", "*", "config", ".", "network", ".", "rpn_feat_stride", ",", "config", ".", "network", ".", "anchor_ratios", "\n", ")", "\n", "all_anchors", "=", "foa", ".", "field_of_anchors", "\n", "\n", "", "for", "im_i", ",", "entry", "in", "enumerate", "(", "roidb", ")", ":", "\n", "        ", "scale", "=", "im_scales", "[", "im_i", "]", "\n", "im_height", "=", "np", ".", "round", "(", "entry", "[", "'height'", "]", "*", "scale", ")", "\n", "im_width", "=", "np", ".", "round", "(", "entry", "[", "'width'", "]", "*", "scale", ")", "\n", "gt_inds", "=", "np", ".", "where", "(", "\n", "(", "entry", "[", "'gt_classes'", "]", ">", "0", ")", "&", "(", "entry", "[", "'is_crowd'", "]", "==", "0", ")", "\n", ")", "[", "0", "]", "\n", "crowd_gt_inds", "=", "np", ".", "where", "(", "\n", "(", "entry", "[", "'gt_classes'", "]", ">", "0", ")", "&", "(", "entry", "[", "'is_crowd'", "]", "==", "1", ")", "\n", ")", "[", "0", "]", "\n", "gt_rois", "=", "entry", "[", "'boxes'", "]", "[", "gt_inds", ",", ":", "]", "*", "scale", "\n", "crowd_gt_rois", "=", "entry", "[", "'boxes'", "]", "[", "crowd_gt_inds", ",", ":", "]", "*", "scale", "\n", "# TODO(rbg): gt_boxes is poorly named;", "\n", "# should be something like 'gt_rois_info'", "\n", "gt_boxes", "=", "np", ".", "zeros", "(", "(", "len", "(", "gt_inds", ")", ",", "6", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_boxes", "[", ":", ",", "0", "]", "=", "im_i", "# batch inds", "\n", "gt_boxes", "[", ":", ",", "1", ":", "5", "]", "=", "gt_rois", "\n", "gt_boxes", "[", ":", ",", "5", "]", "=", "entry", "[", "'gt_classes'", "]", "[", "gt_inds", "]", "\n", "im_info", "=", "np", ".", "array", "(", "[", "[", "im_height", ",", "im_width", ",", "scale", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "blobs", "[", "'im_info'", "]", ".", "append", "(", "im_info", ")", "\n", "\n", "# Add RPN targets", "\n", "if", "config", ".", "network", ".", "has_fpn", ":", "\n", "# RPN applied to many feature levels, as in the FPN paper", "\n", "            ", "rpn_blobs", "=", "_get_rpn_blobs", "(", "\n", "im_height", ",", "im_width", ",", "foas", ",", "all_anchors", ",", "gt_rois", ")", "\n", "for", "i", ",", "lvl", "in", "enumerate", "(", "config", ".", "network", ".", "rpn_feat_stride", ")", ":", "\n", "                ", "for", "k", ",", "v", "in", "rpn_blobs", "[", "i", "]", ".", "items", "(", ")", ":", "\n", "                    ", "blobs", "[", "k", "+", "'_fpn'", "+", "str", "(", "lvl", ")", "]", ".", "append", "(", "v", ")", "\n", "", "", "", "else", ":", "\n", "# Classical RPN, applied to a single feature level", "\n", "            ", "rpn_blobs", "=", "_get_rpn_blobs", "(", "\n", "im_height", ",", "im_width", ",", "[", "foa", "]", ",", "all_anchors", ",", "gt_rois", ")", "\n", "for", "k", ",", "v", "in", "rpn_blobs", ".", "items", "(", ")", ":", "\n", "                ", "blobs", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "\n", "", "", "", "for", "k", ",", "v", "in", "blobs", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "list", ")", "and", "len", "(", "v", ")", ">", "0", ":", "\n", "            ", "blobs", "[", "k", "]", "=", "np", ".", "concatenate", "(", "v", ")", "\n", "\n", "# valid_keys = [", "\n", "#     'has_visible_keypoints', 'boxes', 'segms', 'seg_areas', 'gt_classes',", "\n", "#     'gt_overlaps', 'is_crowd', 'box_to_gt_ind_map', 'gt_keypoints'", "\n", "# ]", "\n", "", "", "valid_keys", "=", "[", "\n", "'boxes'", ",", "'segms'", ",", "'seg_areas'", ",", "'gt_classes'", ",", "\n", "'gt_overlaps'", ",", "'is_crowd'", ",", "'box_to_gt_ind_map'", "\n", "]", "\n", "minimal_roidb", "=", "[", "{", "}", "for", "_", "in", "range", "(", "len", "(", "roidb", ")", ")", "]", "\n", "for", "i", ",", "e", "in", "enumerate", "(", "roidb", ")", ":", "\n", "        ", "for", "k", "in", "valid_keys", ":", "\n", "            ", "if", "k", "in", "e", ":", "\n", "                ", "minimal_roidb", "[", "i", "]", "[", "k", "]", "=", "e", "[", "k", "]", "\n", "", "", "", "blobs", "[", "'roidb'", "]", "=", "minimal_roidb", "\n", "\n", "# Always return valid=True, since RPN minibatches are valid by design", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor._get_rpn_blobs": [[447, 596], ["len", "numpy.empty", "upsnet.rpn.generate_anchors.unmap.fill", "int", "numpy.zeros", "upsnet.rpn.generate_anchors.compute_targets", "numpy.zeros", "numpy.zeros", "numpy.sum", "upsnet.rpn.generate_anchors.unmap", "upsnet.rpn.generate_anchors.unmap", "upsnet.rpn.generate_anchors.unmap", "upsnet.rpn.generate_anchors.unmap", "numpy.arange", "len", "upsnet.bbox.bbox_transform.bbox_overlaps", "upsnet.bbox.bbox_transform.bbox_overlaps.argmax", "upsnet.bbox.bbox_transform.bbox_overlaps.argmax", "numpy.where", "len", "numpy.random.choice", "numpy.where", "numpy.sum", "numpy.where", "len", "numpy.where", "_labels.reshape().transpose.reshape().transpose", "_bbox_targets.reshape().transpose.reshape().transpose", "_bbox_inside_weights.reshape().transpose.reshape().transpose", "_bbox_outside_weights.reshape().transpose.reshape().transpose", "blobs_out.append", "numpy.where", "numpy.where", "dict", "len", "numpy.random.choice", "_labels.reshape().transpose.reshape", "_bbox_targets.reshape().transpose.reshape", "_bbox_inside_weights.reshape().transpose.reshape", "_bbox_outside_weights.reshape().transpose.reshape", "numpy.arange", "numpy.arange", "len", "len"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.compute_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.unmap", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.unmap", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.unmap", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.unmap", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps"], ["", "def", "_get_rpn_blobs", "(", "im_height", ",", "im_width", ",", "foas", ",", "all_anchors", ",", "gt_boxes", ")", ":", "\n", "    ", "total_anchors", "=", "all_anchors", ".", "shape", "[", "0", "]", "\n", "straddle_thresh", "=", "config", ".", "train", ".", "rpn_straddle_thresh", "\n", "\n", "if", "straddle_thresh", ">=", "0", ":", "\n", "# Only keep anchors inside the image by a margin of straddle_thresh", "\n", "# Set TRAIN.RPN_STRADDLE_THRESH to -1 (or a large value) to keep all", "\n", "# anchors", "\n", "        ", "inds_inside", "=", "np", ".", "where", "(", "\n", "(", "all_anchors", "[", ":", ",", "0", "]", ">=", "-", "straddle_thresh", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "1", "]", ">=", "-", "straddle_thresh", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "2", "]", "<", "im_width", "+", "straddle_thresh", ")", "&", "\n", "(", "all_anchors", "[", ":", ",", "3", "]", "<", "im_height", "+", "straddle_thresh", ")", "\n", ")", "[", "0", "]", "\n", "# keep only inside anchors", "\n", "anchors", "=", "all_anchors", "[", "inds_inside", ",", ":", "]", "\n", "", "else", ":", "\n", "        ", "inds_inside", "=", "np", ".", "arange", "(", "all_anchors", ".", "shape", "[", "0", "]", ")", "\n", "anchors", "=", "all_anchors", "\n", "", "num_inside", "=", "len", "(", "inds_inside", ")", "\n", "\n", "# Compute anchor labels:", "\n", "# label=1 is positive, 0 is negative, -1 is don't care (ignore)", "\n", "labels", "=", "np", ".", "empty", "(", "(", "num_inside", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "labels", ".", "fill", "(", "-", "1", ")", "\n", "if", "len", "(", "gt_boxes", ")", ">", "0", ":", "\n", "# Compute overlaps between the anchors and the gt boxes overlaps", "\n", "        ", "anchor_by_gt_overlap", "=", "bbox_overlaps", "(", "anchors", ",", "gt_boxes", ")", "\n", "# Map from anchor to gt box that has highest overlap", "\n", "anchor_to_gt_argmax", "=", "anchor_by_gt_overlap", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "# For each anchor, amount of overlap with most overlapping gt box", "\n", "anchor_to_gt_max", "=", "anchor_by_gt_overlap", "[", "np", ".", "arange", "(", "num_inside", ")", ",", "\n", "anchor_to_gt_argmax", "]", "\n", "\n", "# Map from gt box to an anchor that has highest overlap", "\n", "gt_to_anchor_argmax", "=", "anchor_by_gt_overlap", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "# For each gt box, amount of overlap with most overlapping anchor", "\n", "gt_to_anchor_max", "=", "anchor_by_gt_overlap", "[", "\n", "gt_to_anchor_argmax", ",", "\n", "np", ".", "arange", "(", "anchor_by_gt_overlap", ".", "shape", "[", "1", "]", ")", "\n", "]", "\n", "# Find all anchors that share the max overlap amount", "\n", "# (this includes many ties)", "\n", "anchors_with_max_overlap", "=", "np", ".", "where", "(", "\n", "anchor_by_gt_overlap", "==", "gt_to_anchor_max", "\n", ")", "[", "0", "]", "\n", "\n", "# Fg label: for each gt use anchors with highest overlap", "\n", "# (including ties)", "\n", "labels", "[", "anchors_with_max_overlap", "]", "=", "1", "\n", "# Fg label: above threshold IOU", "\n", "labels", "[", "anchor_to_gt_max", ">=", "config", ".", "train", ".", "rpn_positive_overlap", "]", "=", "1", "\n", "\n", "\n", "# subsample positive labels if we have too many", "\n", "", "num_fg", "=", "int", "(", "config", ".", "train", ".", "rpn_fg_fraction", "*", "config", ".", "train", ".", "rpn_batch_size", ")", "\n", "fg_inds", "=", "np", ".", "where", "(", "labels", "==", "1", ")", "[", "0", "]", "\n", "if", "len", "(", "fg_inds", ")", ">", "num_fg", ":", "\n", "        ", "disable_inds", "=", "np", ".", "random", ".", "choice", "(", "\n", "fg_inds", ",", "size", "=", "(", "len", "(", "fg_inds", ")", "-", "num_fg", ")", ",", "replace", "=", "False", "\n", ")", "\n", "# print('assign_anchor debug use first 128 fg')", "\n", "# labels[fg_inds[-(len(fg_inds) - num_fg):]] = -1", "\n", "labels", "[", "disable_inds", "]", "=", "-", "1", "\n", "", "fg_inds", "=", "np", ".", "where", "(", "labels", "==", "1", ")", "[", "0", "]", "\n", "\n", "# subsample negative labels if we have too many", "\n", "# (samples with replacement, but since the set of bg inds is large most", "\n", "# samples will not have repeats)", "\n", "num_bg", "=", "config", ".", "train", ".", "rpn_batch_size", "-", "np", ".", "sum", "(", "labels", "==", "1", ")", "\n", "bg_inds", "=", "np", ".", "where", "(", "anchor_to_gt_max", "<", "config", ".", "train", ".", "rpn_negative_overlap", ")", "[", "0", "]", "\n", "if", "len", "(", "bg_inds", ")", ">", "num_bg", ":", "\n", "# enable_inds = bg_inds[np.random.randint(len(bg_inds), size=num_bg)]", "\n", "        ", "enable_inds", "=", "bg_inds", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "bg_inds", ")", ",", "num_bg", ",", "replace", "=", "False", ")", "]", "\n", "# print('assign_anchor debug use first 128 bg')", "\n", "# labels[bg_inds[:num_bg]] = 0", "\n", "labels", "[", "enable_inds", "]", "=", "0", "\n", "", "bg_inds", "=", "np", ".", "where", "(", "labels", "==", "0", ")", "[", "0", "]", "\n", "\n", "bbox_targets", "=", "np", ".", "zeros", "(", "(", "num_inside", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "bbox_targets", "[", "fg_inds", ",", ":", "]", "=", "compute_targets", "(", "\n", "anchors", "[", "fg_inds", ",", ":", "]", ",", "gt_boxes", "[", "anchor_to_gt_argmax", "[", "fg_inds", "]", ",", ":", "]", "\n", ")", "\n", "\n", "# Bbox regression loss has the form:", "\n", "#   loss(x) = weight_outside * L(weight_inside * x)", "\n", "# Inside weights allow us to set zero loss on an element-wise basis", "\n", "# Bbox regression is only trained on positive examples so we set their", "\n", "# weights to 1.0 (or otherwise if config is different) and 0 otherwise", "\n", "bbox_inside_weights", "=", "np", ".", "zeros", "(", "(", "num_inside", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "bbox_inside_weights", "[", "labels", "==", "1", ",", ":", "]", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", "\n", "\n", "# The bbox regression loss only averages by the number of images in the", "\n", "# mini-batch, whereas we need to average by the total number of example", "\n", "# anchors selected", "\n", "# Outside weights are used to scale each element-wise loss so the final", "\n", "# average over the mini-batch is correct", "\n", "bbox_outside_weights", "=", "np", ".", "zeros", "(", "(", "num_inside", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# uniform weighting of examples (given non-uniform sampling)", "\n", "num_examples", "=", "np", ".", "sum", "(", "labels", ">=", "0", ")", "\n", "bbox_outside_weights", "[", "labels", "==", "1", ",", ":", "]", "=", "1.0", "/", "num_examples", "\n", "bbox_outside_weights", "[", "labels", "==", "0", ",", ":", "]", "=", "1.0", "/", "num_examples", "\n", "\n", "# Map up to original set of anchors", "\n", "labels", "=", "unmap", "(", "labels", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "-", "1", ")", "\n", "bbox_targets", "=", "unmap", "(", "\n", "bbox_targets", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "0", "\n", ")", "\n", "bbox_inside_weights", "=", "unmap", "(", "\n", "bbox_inside_weights", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "0", "\n", ")", "\n", "bbox_outside_weights", "=", "unmap", "(", "\n", "bbox_outside_weights", ",", "total_anchors", ",", "inds_inside", ",", "fill", "=", "0", "\n", ")", "\n", "\n", "# Split the generated labels, etc. into labels per each field of anchors", "\n", "blobs_out", "=", "[", "]", "\n", "start_idx", "=", "0", "\n", "for", "foa", "in", "foas", ":", "\n", "        ", "H", "=", "foa", ".", "field_size", "\n", "W", "=", "foa", ".", "field_size", "\n", "A", "=", "foa", ".", "num_cell_anchors", "\n", "end_idx", "=", "start_idx", "+", "H", "*", "W", "*", "A", "\n", "_labels", "=", "labels", "[", "start_idx", ":", "end_idx", "]", "\n", "_bbox_targets", "=", "bbox_targets", "[", "start_idx", ":", "end_idx", ",", ":", "]", "\n", "_bbox_inside_weights", "=", "bbox_inside_weights", "[", "start_idx", ":", "end_idx", ",", ":", "]", "\n", "_bbox_outside_weights", "=", "bbox_outside_weights", "[", "start_idx", ":", "end_idx", ",", ":", "]", "\n", "start_idx", "=", "end_idx", "\n", "\n", "# labels output with shape (1, A, height, width)", "\n", "_labels", "=", "_labels", ".", "reshape", "(", "(", "1", ",", "H", ",", "W", ",", "A", ")", ")", ".", "transpose", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "# bbox_targets output with shape (1, 4 * A, height, width)", "\n", "_bbox_targets", "=", "_bbox_targets", ".", "reshape", "(", "\n", "(", "1", ",", "H", ",", "W", ",", "A", "*", "4", ")", ")", ".", "transpose", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "# bbox_inside_weights output with shape (1, 4 * A, height, width)", "\n", "_bbox_inside_weights", "=", "_bbox_inside_weights", ".", "reshape", "(", "\n", "(", "1", ",", "H", ",", "W", ",", "A", "*", "4", ")", ")", ".", "transpose", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "# bbox_outside_weights output with shape (1, 4 * A, height, width)", "\n", "_bbox_outside_weights", "=", "_bbox_outside_weights", ".", "reshape", "(", "\n", "(", "1", ",", "H", ",", "W", ",", "A", "*", "4", ")", ")", ".", "transpose", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "blobs_out", ".", "append", "(", "\n", "dict", "(", "\n", "rpn_labels_int32_wide", "=", "_labels", ",", "\n", "rpn_bbox_targets_wide", "=", "_bbox_targets", ",", "\n", "rpn_bbox_inside_weights_wide", "=", "_bbox_inside_weights", ",", "\n", "rpn_bbox_outside_weights_wide", "=", "_bbox_outside_weights", "\n", ")", "\n", ")", "\n", "", "return", "blobs_out", "[", "0", "]", "if", "len", "(", "blobs_out", ")", "==", "1", "else", "blobs_out", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.operators.build_deform_conv._create_module_dir": [[24, 39], ["fullname.rpartition", "os.path.join", "itertools.accumulate", "functools.reduce", "os.makedirs", "fullname.split", "os.path.join", "open().close", "fullname.split", "open"], "function", ["None"], ["def", "_create_module_dir", "(", "base_path", ",", "fullname", ")", ":", "\n", "    ", "module", ",", "_", ",", "name", "=", "fullname", ".", "rpartition", "(", "'.'", ")", "\n", "if", "not", "module", ":", "\n", "        ", "target_dir", "=", "name", "\n", "", "else", ":", "\n", "        ", "target_dir", "=", "reduce", "(", "os", ".", "path", ".", "join", ",", "fullname", ".", "split", "(", "'.'", ")", ")", "\n", "", "target_dir", "=", "os", ".", "path", ".", "join", "(", "base_path", ",", "target_dir", ")", "\n", "try", ":", "\n", "        ", "os", ".", "makedirs", "(", "target_dir", ")", "\n", "", "except", "os", ".", "error", ":", "\n", "        ", "pass", "\n", "", "for", "dirname", "in", "accumulate", "(", "fullname", ".", "split", "(", "'.'", ")", ",", "os", ".", "path", ".", "join", ")", ":", "\n", "        ", "init_file", "=", "os", ".", "path", ".", "join", "(", "base_path", ",", "dirname", ",", "'__init__.py'", ")", "\n", "open", "(", "init_file", ",", "'a'", ")", ".", "close", "(", ")", "# Create file if it doesn't exist yet", "\n", "", "return", "name", ",", "target_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.operators.build_mod_deform_conv._create_module_dir": [[24, 39], ["fullname.rpartition", "os.path.join", "itertools.accumulate", "functools.reduce", "os.makedirs", "fullname.split", "os.path.join", "open().close", "fullname.split", "open"], "function", ["None"], ["def", "_create_module_dir", "(", "base_path", ",", "fullname", ")", ":", "\n", "    ", "module", ",", "_", ",", "name", "=", "fullname", ".", "rpartition", "(", "'.'", ")", "\n", "if", "not", "module", ":", "\n", "        ", "target_dir", "=", "name", "\n", "", "else", ":", "\n", "        ", "target_dir", "=", "reduce", "(", "os", ".", "path", ".", "join", ",", "fullname", ".", "split", "(", "'.'", ")", ")", "\n", "", "target_dir", "=", "os", ".", "path", ".", "join", "(", "base_path", ",", "target_dir", ")", "\n", "try", ":", "\n", "        ", "os", ".", "makedirs", "(", "target_dir", ")", "\n", "", "except", "os", ".", "error", ":", "\n", "        ", "pass", "\n", "", "for", "dirname", "in", "accumulate", "(", "fullname", ".", "split", "(", "'.'", ")", ",", "os", ".", "path", ".", "join", ")", ":", "\n", "        ", "init_file", "=", "os", ".", "path", ".", "join", "(", "base_path", ",", "dirname", ",", "'__init__.py'", ")", "\n", "open", "(", "init_file", ",", "'a'", ")", ".", "close", "(", ")", "# Create file if it doesn't exist yet", "\n", "", "return", "name", ",", "target_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.operators.build_roialign._create_module_dir": [[24, 39], ["fullname.rpartition", "os.path.join", "itertools.accumulate", "functools.reduce", "os.makedirs", "fullname.split", "os.path.join", "open().close", "fullname.split", "open"], "function", ["None"], ["def", "_create_module_dir", "(", "base_path", ",", "fullname", ")", ":", "\n", "    ", "module", ",", "_", ",", "name", "=", "fullname", ".", "rpartition", "(", "'.'", ")", "\n", "if", "not", "module", ":", "\n", "        ", "target_dir", "=", "name", "\n", "", "else", ":", "\n", "        ", "target_dir", "=", "reduce", "(", "os", ".", "path", ".", "join", ",", "fullname", ".", "split", "(", "'.'", ")", ")", "\n", "", "target_dir", "=", "os", ".", "path", ".", "join", "(", "base_path", ",", "target_dir", ")", "\n", "try", ":", "\n", "        ", "os", ".", "makedirs", "(", "target_dir", ")", "\n", "", "except", "os", ".", "error", ":", "\n", "        ", "pass", "\n", "", "for", "dirname", "in", "accumulate", "(", "fullname", ".", "split", "(", "'.'", ")", ",", "os", ".", "path", ".", "join", ")", ":", "\n", "        ", "init_file", "=", "os", ".", "path", ".", "join", "(", "base_path", ",", "dirname", ",", "'__init__.py'", ")", "\n", "open", "(", "init_file", ",", "'a'", ")", ".", "close", "(", ")", "# Create file if it doesn't exist yet", "\n", "", "return", "name", ",", "target_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.proposal_mask_target.ProposalMaskTargetFunction.__init__": [[25, 33], ["torch.autograd.Function.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_classes", ",", "batch_images", ",", "batch_rois", ",", "fg_fraction", ",", "mask_size", ",", "binary_thresh", ")", ":", "\n", "        ", "super", "(", "ProposalMaskTargetFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "batch_images", "=", "batch_images", "\n", "self", ".", "batch_rois", "=", "batch_rois", "\n", "self", ".", "fg_fraction", "=", "fg_fraction", "\n", "self", ".", "mask_size", "=", "mask_size", "\n", "self", ".", "binary_thresh", "=", "binary_thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.proposal_mask_target.ProposalMaskTargetFunction.forward": [[34, 64], ["torch.device", "rois.cpu().numpy", "gt_boxes.cpu().numpy.cpu().numpy.cpu().numpy", "gt_masks.cpu().numpy.cpu().numpy.cpu().numpy", "numpy.zeros", "numpy.vstack", "numpy.all", "upsnet.bbox.sample_rois.sample_rois", "rois.get_device", "numpy.round().astype", "torch.Tensor().pin_memory().to", "torch.Tensor().pin_memory().to", "torch.Tensor().pin_memory().to", "torch.Tensor().pin_memory().to", "torch.Tensor().pin_memory().to", "torch.Tensor().pin_memory().to", "rois.cpu", "gt_boxes.cpu().numpy.cpu().numpy.cpu", "gt_masks.cpu().numpy.cpu().numpy.cpu", "numpy.hstack", "numpy.round", "torch.Tensor().pin_memory", "torch.Tensor().pin_memory", "torch.Tensor().pin_memory", "torch.Tensor().pin_memory", "torch.Tensor().pin_memory", "torch.Tensor().pin_memory", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois.sample_rois"], ["", "def", "forward", "(", "self", ",", "rois", ",", "gt_boxes", ",", "gt_masks", ")", ":", "\n", "\n", "        ", "context", "=", "torch", ".", "device", "(", "'cuda'", ",", "rois", ".", "get_device", "(", ")", ")", "\n", "\n", "assert", "self", ".", "batch_rois", "==", "-", "1", "or", "self", ".", "batch_rois", "%", "self", ".", "batch_images", "==", "0", ",", "'batchimages {} must devide batch_rois {}'", ".", "format", "(", "self", ".", "batch_images", ",", "self", ".", "batch_rois", ")", "\n", "all_rois", "=", "rois", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "gt_masks", "=", "gt_masks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "self", ".", "batch_rois", "==", "-", "1", ":", "\n", "            ", "rois_per_image", "=", "all_rois", ".", "shape", "[", "0", "]", "+", "gt_boxes", ".", "shape", "[", "0", "]", "\n", "fg_rois_per_image", "=", "rois_per_image", "\n", "", "else", ":", "\n", "            ", "rois_per_image", "=", "self", ".", "batch_rois", "//", "self", ".", "batch_images", "\n", "fg_rois_per_image", "=", "np", ".", "round", "(", "self", ".", "fg_fraction", "*", "rois_per_image", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# Include ground-truth boxes in the set of candidate rois", "\n", "", "zeros", "=", "np", ".", "zeros", "(", "(", "gt_boxes", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "gt_boxes", ".", "dtype", ")", "\n", "all_rois", "=", "np", ".", "vstack", "(", "(", "all_rois", ",", "np", ".", "hstack", "(", "(", "zeros", ",", "gt_boxes", "[", ":", ",", ":", "-", "1", "]", ")", ")", ")", ")", "\n", "# Sanity check: single batch only", "\n", "assert", "np", ".", "all", "(", "all_rois", "[", ":", ",", "0", "]", "==", "0", ")", ",", "'Only single item batches are supported'", "\n", "\n", "rois", ",", "labels", ",", "bbox_targets", ",", "bbox_weights", ",", "mask_targets", ",", "mask_weights", "=", "sample_rois", "(", "all_rois", ",", "fg_rois_per_image", ",", "rois_per_image", ",", "self", ".", "num_classes", ",", "gt_boxes", "=", "gt_boxes", ",", "\n", "gt_masks", "=", "gt_masks", ",", "mask_size", "=", "self", ".", "mask_size", ",", "binary_thresh", "=", "self", ".", "binary_thresh", ")", "\n", "\n", "return", "torch", ".", "Tensor", "(", "rois", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "Tensor", "(", "labels", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "int64", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "Tensor", "(", "bbox_targets", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "Tensor", "(", "bbox_weights", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "Tensor", "(", "mask_targets", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "Tensor", "(", "mask_weights", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.proposal_mask_target.ProposalMaskTargetFunction.backward": [[65, 67], ["None"], "methods", ["None"], ["", "def", "backward", "(", "self", ",", "grad_output", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.roialign.RoIAlignFunction.__init__": [[22, 29], ["torch.autograd.Function.__init__", "int", "int", "float"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "pooled_height", ",", "pooled_width", ",", "spatial_scale", ",", "sampling_ratio", "=", "2", ")", ":", "\n", "        ", "super", "(", "RoIAlignFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pooled_width", "=", "int", "(", "pooled_width", ")", "\n", "self", ".", "pooled_height", "=", "int", "(", "pooled_height", ")", "\n", "self", ".", "spatial_scale", "=", "float", "(", "spatial_scale", ")", "\n", "self", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "self", ".", "feature_size", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.roialign.RoIAlignFunction.forward": [[30, 44], ["features.new().resize_().zero_", "_ext.roi_align.roi_align_cuda.roi_align_forward", "features.size", "Exception", "features.new().resize_", "features.new"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ",", "rois", ")", ":", "\n", "        ", "batch_size", ",", "num_channels", ",", "data_height", ",", "data_width", "=", "features", ".", "shape", "\n", "num_rois", "=", "rois", ".", "shape", "[", "0", "]", "\n", "\n", "if", "not", "features", ".", "is_cuda", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "\n", "", "output", "=", "features", ".", "new", "(", ")", ".", "resize_", "(", "num_rois", ",", "num_channels", ",", "self", ".", "pooled_height", ",", "self", ".", "pooled_width", ")", ".", "zero_", "(", ")", "\n", "\n", "roi_align_cuda", ".", "roi_align_forward", "(", "self", ".", "pooled_height", ",", "self", ".", "pooled_width", ",", "self", ".", "sampling_ratio", ",", "self", ".", "spatial_scale", ",", "\n", "features", ",", "rois", ",", "output", ")", "\n", "self", ".", "feature_size", "=", "features", ".", "size", "(", ")", "\n", "self", ".", "rois", "=", "rois", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.roialign.RoIAlignFunction.backward": [[45, 55], ["grad_output.new().resize_().zero_", "_ext.roi_align.roi_align_cuda.roi_align_backward", "grad_output.new().resize_", "grad_output.new"], "methods", ["None"], ["", "def", "backward", "(", "self", ",", "grad_output", ")", ":", "\n", "        ", "assert", "(", "self", ".", "feature_size", "is", "not", "None", "and", "grad_output", ".", "is_cuda", ")", "\n", "\n", "batch_size", ",", "num_channels", ",", "data_height", ",", "data_width", "=", "self", ".", "feature_size", "\n", "\n", "grad_input", "=", "grad_output", ".", "new", "(", ")", ".", "resize_", "(", "batch_size", ",", "num_channels", ",", "data_height", ",", "data_width", ")", ".", "zero_", "(", ")", "\n", "roi_align_cuda", ".", "roi_align_backward", "(", "self", ".", "pooled_height", ",", "self", ".", "pooled_width", ",", "self", ".", "sampling_ratio", ",", "self", ".", "spatial_scale", ",", "\n", "grad_output", ",", "self", ".", "rois", ",", "grad_input", ")", "\n", "\n", "return", "grad_input", ",", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.mod_deform_conv.ModDeformConvFunction.forward": [[24, 60], ["tuple", "tuple", "tuple", "mod_deform_conv.ModDeformConvFunction.shape_setup", "data.new().resize_().zero_", "data.new().resize_().zero_", "range", "ctx.save_for_backward", "data.size", "offset.size", "mask.size", "Exception", "_ext.mod_deform_conv.mod_deform_conv_cuda.mod_deform_im2col", "torch.mm().view", "bias.view().expand_as", "data.new().resize_", "data.new().resize_", "data[].contiguous", "offset[].contiguous", "mask[].contiguous", "tuple", "int", "data.new().resize_().zero_.size", "torch.mm", "bias.view", "data.new", "data.new", "weight.view", "data.new().resize_().zero_.view", "numpy.prod", "int", "int", "numpy.prod", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.functions.deform_conv.DeformConvFunction.shape_setup"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "data", ",", "offset", ",", "mask", ",", "weight", ",", "bias", ",", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", ",", "\n", "padding", ",", "dilation", ",", "groups", ",", "deformable_groups", ")", ":", "\n", "        ", "if", "weight", ".", "requires_grad", "or", "data", ".", "requires_grad", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "data", ",", "offset", ",", "mask", ",", "weight", ",", "bias", ")", "\n", "", "ctx", ".", "in_channels", "=", "in_channels", "\n", "ctx", ".", "out_channels", "=", "out_channels", "\n", "ctx", ".", "kernel_size", "=", "kernel_size", "\n", "ctx", ".", "stride", "=", "stride", "\n", "ctx", ".", "padding", "=", "padding", "\n", "ctx", ".", "dilation", "=", "dilation", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "data_shape", "=", "tuple", "(", "data", ".", "size", "(", ")", ")", "\n", "ctx", ".", "offset_shape", "=", "tuple", "(", "offset", ".", "size", "(", ")", ")", "\n", "ctx", ".", "mask_shape", "=", "tuple", "(", "mask", ".", "size", "(", ")", ")", "\n", "if", "not", "data", ".", "is_cuda", "or", "not", "offset", ".", "is_cuda", "or", "not", "mask", ".", "is_cuda", "or", "not", "weight", ".", "is_cuda", "or", "(", "bias", "is", "not", "None", "and", "not", "bias", ".", "is_cuda", ")", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "\n", "", "assert", "data", ".", "is_contiguous", "and", "offset", ".", "is_contiguous", "and", "mask", ".", "is_contiguous", "\n", "\n", "ModDeformConvFunction", ".", "shape_setup", "(", "ctx", ")", "\n", "col_buffer", "=", "data", ".", "new", "(", ")", ".", "resize_", "(", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", ".", "zero_", "(", ")", "\n", "output", "=", "data", ".", "new", "(", ")", ".", "resize_", "(", "ctx", ".", "output_shape", "[", "0", "]", ",", "ctx", ".", "output_shape", "[", "1", "]", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", ".", "zero_", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "ctx", ".", "data_shape", "[", "0", "]", ")", ":", "\n", "            ", "mod_deform_conv_cuda", ".", "mod_deform_im2col", "(", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", ",", "mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "deformable_groups", ",", "col_buffer", ")", "\n", "output", "[", "i", ",", ":", ",", ":", ",", ":", "]", "=", "torch", ".", "mm", "(", "weight", ".", "view", "(", "-", "1", ",", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ")", ",", "\n", "col_buffer", ".", "view", "(", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ",", "-", "1", ")", ")", ".", "view", "(", "ctx", ".", "output_shape", "[", "1", "]", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", "\n", "", "if", "bias", "is", "not", "None", ":", "\n", "            ", "output", "+=", "bias", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "output", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.mod_deform_conv.ModDeformConvFunction.backward": [[61, 98], ["data.new().resize_as_().zero_", "offset.new().resize_as_().zero_", "mask.new().resize_as_().zero_", "weight.new().resize_as_().zero_", "range", "Exception", "torch.mm().view", "_ext.mod_deform_conv.mod_deform_conv_cuda.mod_deform_col2im_coord", "_ext.mod_deform_conv.mod_deform_conv_cuda.mod_deform_col2im", "_ext.mod_deform_conv.mod_deform_conv_cuda.mod_deform_im2col", "torch.mm().view_as", "grad_output.data.sum().sum().sum().squeeze", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "data.new().resize_as_", "offset.new().resize_as_", "mask.new().resize_as_", "weight.new().resize_as_", "tuple", "tuple", "tuple", "torch.autograd.Variable", "torch.mm", "grad_output.size", "grad_output.size", "torch.mm().view.size", "torch.mm().view.size", "torch.mm().view.size", "torch.mm", "grad_output.data.sum().sum().sum", "data.new", "offset.new", "mask.new", "weight.new", "weight.view().t", "grad_output.data[].view", "grad_output.data[].view", "torch.mm().view.view().t", "grad_output.size", "grad_output.data.sum().sum", "weight.view", "torch.mm().view.view", "int", "torch.mm().view.size", "grad_output.data.sum", "numpy.prod"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "data", ",", "offset", ",", "mask", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "", "grad_data", "=", "data", ".", "new", "(", ")", ".", "resize_as_", "(", "data", ")", ".", "zero_", "(", ")", "\n", "grad_offset", "=", "offset", ".", "new", "(", ")", ".", "resize_as_", "(", "offset", ")", ".", "zero_", "(", ")", "\n", "grad_mask", "=", "mask", ".", "new", "(", ")", ".", "resize_as_", "(", "mask", ")", ".", "zero_", "(", ")", "\n", "grad_weight", "=", "weight", ".", "new", "(", ")", ".", "resize_as_", "(", "weight", ")", ".", "zero_", "(", ")", "\n", "\n", "\n", "for", "i", "in", "range", "(", "ctx", ".", "data_shape", "[", "0", "]", ")", ":", "\n", "            ", "col_buffer", "=", "torch", ".", "mm", "(", "weight", ".", "view", "(", "-", "1", ",", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ")", ".", "t", "(", ")", ",", "\n", "grad_output", ".", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "view", "(", "ctx", ".", "out_channels", ",", "-", "1", ")", ")", ".", "view", "(", "(", "-", "1", ",", "grad_output", ".", "size", "(", "2", ")", ",", "grad_output", ".", "size", "(", "3", ")", ")", ")", "\n", "\n", "mod_deform_conv_cuda", ".", "mod_deform_col2im_coord", "(", "col_buffer", ",", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "deformable_groups", ",", "grad_offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "grad_mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "mod_deform_conv_cuda", ".", "mod_deform_col2im", "(", "col_buffer", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "deformable_groups", ",", "grad_data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "mod_deform_conv_cuda", ".", "mod_deform_im2col", "(", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "deformable_groups", ",", "col_buffer", ")", "\n", "\n", "grad_weight", "+=", "torch", ".", "mm", "(", "grad_output", ".", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "view", "(", "grad_output", ".", "size", "(", "1", ")", ",", "-", "1", ")", ",", "\n", "col_buffer", ".", "view", "(", "col_buffer", ".", "size", "(", "0", ")", ",", "-", "1", ")", ".", "t", "(", ")", ")", ".", "view_as", "(", "grad_weight", ")", "\n", "\n", "", "if", "bias", "is", "not", "None", ":", "\n", "            ", "grad_bias", "=", "grad_output", ".", "data", ".", "sum", "(", "dim", "=", "0", ",", "keepdim", "=", "True", ")", ".", "sum", "(", "dim", "=", "2", ",", "keepdim", "=", "True", ")", ".", "sum", "(", "dim", "=", "3", ",", "keepdim", "=", "True", ")", ".", "squeeze", "(", ")", "\n", "", "else", ":", "\n", "            ", "grad_bias", "=", "None", "\n", "", "return", "Variable", "(", "grad_data", ")", ",", "Variable", "(", "grad_offset", ")", ",", "Variable", "(", "grad_mask", ")", ",", "Variable", "(", "grad_weight", ")", ",", "Variable", "(", "grad_bias", ")", "if", "grad_bias", "is", "not", "None", "else", "bias", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.mod_deform_conv.ModDeformConvFunction.shape_setup": [[99, 110], ["numpy.prod", "numpy.prod", "numpy.prod"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "shape_setup", "(", "ctx", ")", ":", "\n", "        ", "ctx", ".", "kernel_dim", "=", "ctx", ".", "in_channels", "/", "ctx", ".", "groups", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", "\n", "\n", "ctx", ".", "output_shape", "=", "(", "ctx", ".", "data_shape", "[", "0", "]", ",", "ctx", ".", "out_channels", ",", "\n", "(", "ctx", ".", "data_shape", "[", "2", "]", "+", "2", "*", "ctx", ".", "padding", "[", "0", "]", "-", "ctx", ".", "dilation", "[", "0", "]", "*", "(", "ctx", ".", "kernel_size", "[", "0", "]", "-", "1", ")", "-", "1", ")", "//", "ctx", ".", "stride", "[", "0", "]", "+", "1", ",", "\n", "(", "ctx", ".", "data_shape", "[", "3", "]", "+", "2", "*", "ctx", ".", "padding", "[", "1", "]", "-", "ctx", ".", "dilation", "[", "1", "]", "*", "(", "ctx", ".", "kernel_size", "[", "1", "]", "-", "1", ")", "-", "1", ")", "//", "ctx", ".", "stride", "[", "1", "]", "+", "1", ")", "\n", "\n", "ctx", ".", "input_dim", "=", "np", ".", "prod", "(", "ctx", ".", "data_shape", "[", "1", ":", "]", ")", "\n", "ctx", ".", "input_offset_dim", "=", "np", ".", "prod", "(", "ctx", ".", "offset_shape", "[", "1", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.deform_conv.DeformConvFunction.forward": [[25, 58], ["tuple", "tuple", "deform_conv.DeformConvFunction.shape_setup", "data.new().resize_().zero_", "data.new().resize_().zero_", "range", "ctx.save_for_backward", "data.size", "offset.size", "Exception", "_ext.deform_conv.deform_conv_cuda.deform_im2col", "torch.mm().view", "bias.view().expand_as", "data.new().resize_", "data.new().resize_", "tuple", "int", "data.new().resize_().zero_.size", "torch.mm", "bias.view", "data.new", "data.new", "weight.view", "data.new().resize_().zero_.view", "bias.size", "numpy.prod", "int", "int", "numpy.prod", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.functions.deform_conv.DeformConvFunction.shape_setup"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "data", ",", "offset", ",", "weight", ",", "bias", ",", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", ",", "\n", "padding", ",", "dilation", ",", "groups", ",", "deformable_groups", ")", ":", "\n", "        ", "if", "weight", ".", "requires_grad", "or", "data", ".", "requires_grad", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "data", ",", "offset", ",", "weight", ",", "bias", ")", "\n", "", "ctx", ".", "in_channels", "=", "in_channels", "\n", "ctx", ".", "out_channels", "=", "out_channels", "\n", "ctx", ".", "kernel_size", "=", "kernel_size", "\n", "ctx", ".", "stride", "=", "stride", "\n", "ctx", ".", "padding", "=", "padding", "\n", "ctx", ".", "dilation", "=", "dilation", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "data_shape", "=", "tuple", "(", "data", ".", "size", "(", ")", ")", "\n", "ctx", ".", "offset_shape", "=", "tuple", "(", "offset", ".", "size", "(", ")", ")", "\n", "if", "not", "data", ".", "is_cuda", "or", "not", "offset", ".", "is_cuda", "or", "not", "weight", ".", "is_cuda", "or", "(", "bias", "is", "not", "None", "and", "not", "bias", ".", "is_cuda", ")", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "\n", "", "DeformConvFunction", ".", "shape_setup", "(", "ctx", ")", "\n", "col_buffer", "=", "data", ".", "new", "(", ")", ".", "resize_", "(", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", ".", "zero_", "(", ")", "\n", "output", "=", "data", ".", "new", "(", ")", ".", "resize_", "(", "ctx", ".", "output_shape", "[", "0", "]", ",", "ctx", ".", "output_shape", "[", "1", "]", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", ".", "zero_", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "ctx", ".", "data_shape", "[", "0", "]", ")", ":", "\n", "            ", "deform_conv_cuda", ".", "deform_im2col", "(", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "1", ",", "ctx", ".", "deformable_groups", ",", "col_buffer", ")", "\n", "output", "[", "i", ",", ":", ",", ":", ",", ":", "]", "=", "torch", ".", "mm", "(", "weight", ".", "view", "(", "-", "1", ",", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ")", ",", "\n", "col_buffer", ".", "view", "(", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ",", "-", "1", ")", ")", ".", "view", "(", "ctx", ".", "output_shape", "[", "1", "]", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", "\n", "", "if", "bias", "is", "not", "None", ":", "\n", "            ", "output", "+=", "bias", ".", "view", "(", "1", ",", "bias", ".", "size", "(", "0", ")", ",", "1", ",", "1", ")", ".", "expand_as", "(", "output", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.deform_conv.DeformConvFunction.backward": [[59, 95], ["data.new().resize_as_().zero_", "offset.new().resize_as_().zero_", "weight.new().resize_as_().zero_", "range", "Exception", "torch.mm().view", "_ext.deform_conv.deform_conv_cuda.deform_col2im_coord", "_ext.deform_conv.deform_conv_cuda.deform_col2im", "_ext.deform_conv.deform_conv_cuda.deform_im2col", "torch.mm().view_as", "grad_output.data.sum().sum().sum().squeeze", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "data.new().resize_as_", "offset.new().resize_as_", "weight.new().resize_as_", "tuple", "tuple", "tuple", "torch.autograd.Variable", "torch.mm", "grad_output.size", "grad_output.size", "torch.mm().view.size", "torch.mm().view.size", "torch.mm().view.size", "torch.mm", "grad_output.data.sum().sum().sum", "data.new", "offset.new", "weight.new", "weight.view().t", "grad_output.data[].view", "grad_output.data[].view", "torch.mm().view.view().t", "grad_output.size", "grad_output.data.sum().sum", "weight.view", "torch.mm().view.view", "int", "torch.mm().view.size", "grad_output.data.sum", "numpy.prod"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "data", ",", "offset", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "", "grad_data", "=", "data", ".", "new", "(", ")", ".", "resize_as_", "(", "data", ")", ".", "zero_", "(", ")", "\n", "grad_offset", "=", "offset", ".", "new", "(", ")", ".", "resize_as_", "(", "offset", ")", ".", "zero_", "(", ")", "\n", "grad_weight", "=", "weight", ".", "new", "(", ")", ".", "resize_as_", "(", "weight", ")", ".", "zero_", "(", ")", "\n", "\n", "\n", "for", "i", "in", "range", "(", "ctx", ".", "data_shape", "[", "0", "]", ")", ":", "\n", "            ", "col_buffer", "=", "torch", ".", "mm", "(", "weight", ".", "view", "(", "-", "1", ",", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ")", ".", "t", "(", ")", ",", "\n", "grad_output", ".", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "view", "(", "ctx", ".", "out_channels", ",", "-", "1", ")", ")", ".", "view", "(", "(", "-", "1", ",", "grad_output", ".", "size", "(", "2", ")", ",", "grad_output", ".", "size", "(", "3", ")", ")", ")", "\n", "\n", "deform_conv_cuda", ".", "deform_col2im_coord", "(", "col_buffer", ",", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "1", ",", "ctx", ".", "deformable_groups", ",", "grad_offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "deform_conv_cuda", ".", "deform_col2im", "(", "col_buffer", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "1", ",", "ctx", ".", "deformable_groups", ",", "grad_data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "deform_conv_cuda", ".", "deform_im2col", "(", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "1", ",", "ctx", ".", "deformable_groups", ",", "col_buffer", ")", "\n", "\n", "grad_weight", "+=", "torch", ".", "mm", "(", "grad_output", ".", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "view", "(", "grad_output", ".", "size", "(", "1", ")", ",", "-", "1", ")", ",", "\n", "col_buffer", ".", "view", "(", "col_buffer", ".", "size", "(", "0", ")", ",", "-", "1", ")", ".", "t", "(", ")", ")", ".", "view_as", "(", "grad_weight", ")", "\n", "\n", "", "if", "bias", "is", "not", "None", ":", "\n", "            ", "grad_bias", "=", "grad_output", ".", "data", ".", "sum", "(", "dim", "=", "0", ",", "keepdim", "=", "True", ")", ".", "sum", "(", "dim", "=", "2", ",", "keepdim", "=", "True", ")", ".", "sum", "(", "dim", "=", "3", ",", "keepdim", "=", "True", ")", ".", "squeeze", "(", ")", "\n", "", "else", ":", "\n", "            ", "grad_bias", "=", "None", "\n", "", "return", "Variable", "(", "grad_data", ")", ",", "Variable", "(", "grad_offset", ")", ",", "Variable", "(", "grad_weight", ")", ",", "Variable", "(", "grad_bias", ")", "if", "grad_bias", "is", "not", "None", "else", "bias", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.deform_conv.DeformConvFunction.shape_setup": [[96, 107], ["numpy.prod", "numpy.prod", "numpy.prod"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "shape_setup", "(", "ctx", ")", ":", "\n", "        ", "ctx", ".", "kernel_dim", "=", "ctx", ".", "in_channels", "/", "ctx", ".", "groups", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", "\n", "\n", "ctx", ".", "output_shape", "=", "(", "ctx", ".", "data_shape", "[", "0", "]", ",", "ctx", ".", "out_channels", ",", "\n", "(", "ctx", ".", "data_shape", "[", "2", "]", "+", "2", "*", "ctx", ".", "padding", "[", "0", "]", "-", "ctx", ".", "dilation", "[", "0", "]", "*", "(", "ctx", ".", "kernel_size", "[", "0", "]", "-", "1", ")", "-", "1", ")", "//", "ctx", ".", "stride", "[", "0", "]", "+", "1", ",", "\n", "(", "ctx", ".", "data_shape", "[", "3", "]", "+", "2", "*", "ctx", ".", "padding", "[", "1", "]", "-", "ctx", ".", "dilation", "[", "1", "]", "*", "(", "ctx", ".", "kernel_size", "[", "1", "]", "-", "1", ")", "-", "1", ")", "//", "ctx", ".", "stride", "[", "1", "]", "+", "1", ")", "\n", "\n", "ctx", ".", "input_dim", "=", "np", ".", "prod", "(", "ctx", ".", "data_shape", "[", "1", ":", "]", ")", "\n", "ctx", ".", "input_offset_dim", "=", "np", ".", "prod", "(", "ctx", ".", "offset_shape", "[", "1", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.pyramid_proposal.PyramidProposalFunction.__init__": [[26, 40], ["torch.autograd.Function.__init__", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "feat_stride", ",", "scales", ",", "ratios", ",", "rpn_pre_nms_top_n", ",", "rpn_post_nms_top_n", ",", "threshold", ",", "rpn_min_size", ",", "individual_proposals", "=", "False", ",", "batch_idx", "=", "0", ",", "use_softnms", "=", "False", ",", "crowd_gt_roi", "=", "None", ")", ":", "\n", "        ", "super", "(", "PyramidProposalFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "feat_stride", "=", "feat_stride", "\n", "self", ".", "scales", "=", "np", ".", "array", "(", "scales", ")", "\n", "self", ".", "ratios", "=", "np", ".", "array", "(", "ratios", ")", "\n", "self", ".", "num_anchors", "=", "3", "\n", "self", ".", "rpn_pre_nms_top_n", "=", "rpn_pre_nms_top_n", "\n", "self", ".", "rpn_post_nms_top_n", "=", "rpn_post_nms_top_n", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "rpn_min_size", "=", "rpn_min_size", "\n", "self", ".", "individual_proposals", "=", "individual_proposals", "\n", "self", ".", "batch_idx", "=", "batch_idx", "\n", "self", ".", "use_softnms", "=", "use_softnms", "\n", "self", ".", "crowd_gt_roi", "=", "crowd_gt_roi", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.pyramid_proposal.PyramidProposalFunction.forward": [[41, 223], ["cls_prob_p2.get_device", "torch.device", "im_info.numpy.numpy.numpy", "range", "numpy.vstack", "numpy.vstack", "numpy.hstack", "upsnet.nms.nms.gpu_nms_wrapper", "soft_nms_wrapper", "ValueError", "len", "int", "upsnet.rpn.generate_anchors.generate_anchors", "cls_probs[].cpu().numpy", "bbox_preds[].cpu().numpy", "numpy.meshgrid", "numpy.vstack().transpose", "anchors.reshape.reshape.reshape", "bbox_deltas.transpose().reshape.transpose().reshape.transpose().reshape", "scores.squeeze.squeeze.transpose().reshape", "upsnet.bbox.bbox_transform.bbox_transform", "upsnet.bbox.bbox_transform.clip_boxes", "pyramid_proposal.PyramidProposalFunction._filter_boxes", "proposal_list.append", "score_list.append", "scores.squeeze.squeeze.squeeze", "numpy.ones", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "numpy.arange", "numpy.arange", "upsnet.rpn.generate_anchors.generate_anchors.reshape", "numpy.vstack().transpose.reshape().transpose", "upsnet.bbox.bbox_transform.bbox_overlaps", "upsnet.bbox.bbox_transform.bbox_overlaps.max", "scores.squeeze.squeeze.ravel().argsort", "nms", "numpy.hstack().astype", "nms", "upsnet.bbox.bbox_transform.clip_boxes.astype", "cls_probs[].cpu", "bbox_preds[].cpu", "numpy.vstack", "bbox_deltas.transpose().reshape.transpose().reshape.transpose", "scores.squeeze.squeeze.transpose", "numpy.argsort", "numpy.argsort", "numpy.where", "nms", "nms", "numpy.hstack().astype", "len", "numpy.random.choice", "numpy.hstack", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "numpy.vstack().transpose.reshape", "len", "numpy.argpartition", "numpy.hstack().astype", "numpy.hstack().astype", "scores.squeeze.squeeze.ravel", "numpy.hstack", "shift_x.ravel", "shift_y.ravel", "shift_x.ravel", "shift_y.ravel", "scores.squeeze.squeeze.squeeze", "scores[].squeeze", "numpy.hstack", "numpy.argsort", "torch.tensor", "torch.tensor", "scores.squeeze.squeeze.squeeze", "numpy.hstack", "numpy.argsort", "numpy.hstack", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.nms.nms.gpu_nms_wrapper", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.generate_anchors.generate_anchors", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_transform", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.pyramid_proposal.PyramidProposalFunction._filter_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps"], ["", "def", "forward", "(", "self", ",", "cls_prob_p2", ",", "cls_prob_p3", ",", "cls_prob_p4", ",", "cls_prob_p5", ",", "cls_prob_p6", ",", "\n", "bbox_pred_p2", ",", "bbox_pred_p3", ",", "bbox_pred_p4", ",", "bbox_pred_p5", ",", "bbox_pred_p6", ",", "im_info", ")", ":", "\n", "        ", "device_id", "=", "cls_prob_p2", ".", "get_device", "(", ")", "\n", "nms", "=", "gpu_nms_wrapper", "(", "self", ".", "threshold", ",", "device_id", "=", "device_id", ")", "if", "not", "self", ".", "use_softnms", "else", "soft_nms_wrapper", "(", "self", ".", "threshold", ")", "\n", "context", "=", "torch", ".", "device", "(", "'cuda'", ",", "device_id", ")", "\n", "\n", "batch_size", "=", "cls_prob_p2", ".", "shape", "[", "0", "]", "\n", "if", "batch_size", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Sorry, multiple images each device is not implemented\"", ")", "\n", "\n", "# for each (H, W) location i", "\n", "#   generate A anchor boxes centered on cell i", "\n", "#   apply predicted bbox deltas at cell i to each of the A anchors", "\n", "# clip predicted boxes to image", "\n", "# remove predicted boxes with either height or width < threshold", "\n", "# sort all (proposal, score) pairs by score from highest to lowest", "\n", "# take top pre_nms_topN proposals before NMS", "\n", "# apply NMS with threshold 0.7 to remaining proposals", "\n", "# take after_nms_topN proposals after NMS", "\n", "# return the top proposals (-> RoIs top, scores top)", "\n", "\n", "", "cls_probs", "=", "[", "cls_prob_p2", ",", "cls_prob_p3", ",", "cls_prob_p4", ",", "cls_prob_p5", ",", "cls_prob_p6", "]", "\n", "bbox_preds", "=", "[", "bbox_pred_p2", ",", "bbox_pred_p3", ",", "bbox_pred_p4", ",", "bbox_pred_p5", ",", "bbox_pred_p6", "]", "\n", "\n", "pre_nms_topN", "=", "self", ".", "rpn_pre_nms_top_n", "\n", "post_nms_topN", "=", "self", ".", "rpn_post_nms_top_n", "\n", "min_size", "=", "self", ".", "rpn_min_size", "\n", "\n", "proposal_list", "=", "[", "]", "\n", "score_list", "=", "[", "]", "\n", "im_info", "=", "im_info", ".", "numpy", "(", ")", "\n", "\n", "for", "s", "in", "range", "(", "len", "(", "self", ".", "feat_stride", ")", ")", ":", "\n", "            ", "stride", "=", "int", "(", "self", ".", "feat_stride", "[", "s", "]", ")", "\n", "sub_anchors", "=", "generate_anchors", "(", "stride", "=", "stride", ",", "sizes", "=", "self", ".", "scales", "*", "stride", ",", "aspect_ratios", "=", "self", ".", "ratios", ")", "\n", "scores", "=", "cls_probs", "[", "s", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bbox_deltas", "=", "bbox_preds", "[", "s", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# 1. Generate proposals from bbox_deltas and shifted anchors", "\n", "# use real image size instead of padded feature map sizes", "\n", "height", ",", "width", "=", "scores", ".", "shape", "[", "-", "2", ":", "]", "\n", "\n", "# Enumerate all shifts", "\n", "shift_x", "=", "np", ".", "arange", "(", "0", ",", "width", ")", "*", "stride", "\n", "shift_y", "=", "np", ".", "arange", "(", "0", ",", "height", ")", "*", "stride", "\n", "shift_x", ",", "shift_y", "=", "np", ".", "meshgrid", "(", "shift_x", ",", "shift_y", ")", "\n", "shifts", "=", "np", ".", "vstack", "(", "(", "shift_x", ".", "ravel", "(", ")", ",", "shift_y", ".", "ravel", "(", ")", ",", "shift_x", ".", "ravel", "(", ")", ",", "shift_y", ".", "ravel", "(", ")", ")", ")", ".", "transpose", "(", ")", "\n", "\n", "# Enumerate all shifted anchors:", "\n", "#", "\n", "# add A anchors (1, A, 4) to", "\n", "# cell K shifts (K, 1, 4) to get", "\n", "# shift anchors (K, A, 4)", "\n", "# reshape to (K*A, 4) shifted anchors", "\n", "A", "=", "self", ".", "num_anchors", "\n", "K", "=", "shifts", ".", "shape", "[", "0", "]", "\n", "anchors", "=", "sub_anchors", ".", "reshape", "(", "(", "1", ",", "A", ",", "4", ")", ")", "+", "shifts", ".", "reshape", "(", "(", "1", ",", "K", ",", "4", ")", ")", ".", "transpose", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "anchors", "=", "anchors", ".", "reshape", "(", "(", "K", "*", "A", ",", "4", ")", ")", "\n", "# print(np.linalg.norm(anchors))", "\n", "\n", "# Transpose and reshape predicted bbox transformations to get them", "\n", "# into the same order as the anchors:", "\n", "#", "\n", "# bbox deltas will be (1, 4 * A, H, W) format", "\n", "# transpose to (1, H, W, 4 * A)", "\n", "# reshape to (1 * H * W * A, 4) where rows are ordered by (h, w, a)", "\n", "# in slowest to fastest order", "\n", "# bbox_deltas = self._clip_pad(bbox_deltas, (height, width))", "\n", "bbox_deltas", "=", "bbox_deltas", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "\n", "\n", "# Same story for the scores:", "\n", "#", "\n", "# scores are (1, A, H, W) format", "\n", "# transpose to (1, H, W, A)", "\n", "# reshape to (1 * H * W * A, 1) where rows are ordered by (h, w, a)", "\n", "# scores = self._clip_pad(scores, (height, width))", "\n", "scores", "=", "scores", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "if", "self", ".", "individual_proposals", ":", "\n", "# 4. sort all (proposal, score) pairs by score from highest to lowest", "\n", "# 5. take top pre_nms_topN (e.g. 6000)", "\n", "                ", "if", "pre_nms_topN", "<=", "0", "or", "pre_nms_topN", ">=", "len", "(", "scores", ")", ":", "\n", "                    ", "order", "=", "np", ".", "argsort", "(", "-", "scores", ".", "squeeze", "(", ")", ")", "\n", "", "else", ":", "\n", "# Avoid sorting possibly large arrays; First partition to get top K", "\n", "# unsorted and then sort just those (~20x faster for 200k scores)", "\n", "                    ", "inds", "=", "np", ".", "argpartition", "(", "\n", "-", "scores", ".", "squeeze", "(", ")", ",", "pre_nms_topN", "\n", ")", "[", ":", "pre_nms_topN", "]", "\n", "order", "=", "np", ".", "argsort", "(", "-", "scores", "[", "inds", "]", ".", "squeeze", "(", ")", ")", "\n", "order", "=", "inds", "[", "order", "]", "\n", "# order = np.argsort(-scores.squeeze())", "\n", "", "bbox_deltas", "=", "bbox_deltas", "[", "order", ",", ":", "]", "\n", "anchors", "=", "anchors", "[", "order", ",", ":", "]", "\n", "scores", "=", "scores", "[", "order", "]", "\n", "\n", "# Convert anchors into proposals via bbox transformations", "\n", "", "proposals", "=", "bbox_pred", "(", "anchors", ",", "bbox_deltas", ")", "\n", "\n", "# 2. clip predicted boxes to image", "\n", "proposals", "=", "clip_boxes", "(", "proposals", ",", "im_info", "[", ":", "2", "]", ")", "\n", "\n", "# 3. remove predicted boxes with either height or width < threshold", "\n", "# (NOTE: convert min_size to input image scale stored in im_info[2])", "\n", "keep", "=", "self", ".", "_filter_boxes", "(", "proposals", ",", "min_size", "*", "im_info", "[", "2", "]", ")", "\n", "proposals", "=", "proposals", "[", "keep", ",", ":", "]", "\n", "scores", "=", "scores", "[", "keep", "]", "\n", "\n", "if", "self", ".", "crowd_gt_roi", "is", "not", "None", ":", "\n", "                ", "proposal_by_gt_overlap", "=", "bbox_overlaps", "(", "proposals", ",", "self", ".", "crowd_gt_roi", "*", "im_info", "[", "2", "]", ")", "\n", "proposal_by_gt_overlap_max", "=", "proposal_by_gt_overlap", ".", "max", "(", "axis", "=", "1", ")", "\n", "keep", "=", "np", ".", "where", "(", "proposal_by_gt_overlap_max", "<", "0.5", ")", "[", "0", "]", "\n", "proposals", "=", "proposals", "[", "keep", ",", ":", "]", "\n", "scores", "=", "scores", "[", "keep", "]", "\n", "\n", "", "if", "self", ".", "individual_proposals", ":", "\n", "# 6. apply nms (e.g. threshold = 0.7)", "\n", "# 7. take after_nms_topN (e.g. 300)", "\n", "# 8. return the top proposals (-> RoIs top)", "\n", "                ", "if", "self", ".", "use_softnms", ":", "\n", "                    ", "det", ",", "keep", "=", "nms", "(", "np", ".", "hstack", "(", "(", "proposals", ",", "scores", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "det", "=", "det", "[", "keep", "]", "\n", "det", "=", "det", "[", "np", ".", "argsort", "(", "det", "[", ":", ",", "4", "]", ")", "[", ":", ":", "-", "1", "]", "]", "\n", "if", "post_nms_topN", ">", "0", ":", "\n", "                        ", "det", "=", "det", "[", ":", "post_nms_topN", "]", "\n", "", "proposals", "=", "det", "[", ":", ",", ":", "4", "]", "\n", "scores", "=", "det", "[", ":", ",", "4", "]", "\n", "", "else", ":", "\n", "                    ", "keep", "=", "nms", "(", "np", ".", "hstack", "(", "(", "proposals", ",", "scores", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "if", "post_nms_topN", ">", "0", ":", "\n", "                        ", "keep", "=", "keep", "[", ":", "post_nms_topN", "]", "\n", "", "proposals", "=", "proposals", "[", "keep", ",", ":", "]", "\n", "scores", "=", "scores", "[", "keep", "]", "\n", "\n", "", "", "proposal_list", ".", "append", "(", "proposals", ")", "\n", "score_list", ".", "append", "(", "scores", ")", "\n", "\n", "", "proposals", "=", "np", ".", "vstack", "(", "proposal_list", ")", "\n", "scores", "=", "np", ".", "vstack", "(", "score_list", ")", "\n", "\n", "\n", "if", "not", "self", ".", "individual_proposals", ":", "\n", "# 4. sort all (proposal, score) pairs by score from highest to lowest", "\n", "# 5. take top pre_nms_topN (e.g. 6000)", "\n", "            ", "order", "=", "scores", ".", "ravel", "(", ")", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "if", "pre_nms_topN", ">", "0", ":", "\n", "                ", "order", "=", "order", "[", ":", "pre_nms_topN", "]", "\n", "", "proposals", "=", "proposals", "[", "order", ",", ":", "]", "\n", "scores", "=", "scores", "[", "order", "]", "\n", "\n", "# 6. apply nms (e.g. threshold = 0.7)", "\n", "# 7. take after_nms_topN (e.g. 300)", "\n", "# 8. return the top proposals (-> RoIs top)", "\n", "\n", "if", "self", ".", "use_softnms", ":", "\n", "                ", "det", ",", "keep", "=", "nms", "(", "np", ".", "hstack", "(", "(", "proposals", ",", "scores", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "det", "=", "det", "[", "keep", "]", "\n", "det", "=", "det", "[", "np", ".", "argsort", "(", "det", "[", ":", ",", "4", "]", ")", "[", ":", ":", "-", "1", "]", "]", "\n", "if", "post_nms_topN", ">", "0", ":", "\n", "                    ", "det", "=", "det", "[", ":", "post_nms_topN", "]", "\n", "", "proposals", "=", "det", "[", ":", ",", ":", "4", "]", "\n", "scores", "=", "det", "[", ":", ",", "4", "]", "\n", "", "else", ":", "\n", "                ", "det", "=", "np", ".", "hstack", "(", "(", "proposals", ",", "scores", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "keep", "=", "nms", "(", "det", ")", "\n", "if", "post_nms_topN", ">", "0", ":", "\n", "                    ", "keep", "=", "keep", "[", ":", "post_nms_topN", "]", "\n", "# pad to ensure output size remains unchanged", "\n", "", "if", "len", "(", "keep", ")", "<", "post_nms_topN", ":", "\n", "                    ", "pad", "=", "np", ".", "random", ".", "choice", "(", "keep", ",", "size", "=", "post_nms_topN", "-", "len", "(", "keep", ")", ")", "\n", "keep", "=", "np", ".", "hstack", "(", "(", "keep", ",", "pad", ")", ")", "\n", "", "proposals", "=", "proposals", "[", "keep", ",", ":", "]", "\n", "scores", "=", "scores", "[", "keep", "]", "\n", "", "", "else", ":", "\n", "            ", "scores", "=", "scores", ".", "squeeze", "(", ")", "\n", "\n", "# Output rois array", "\n", "# Our RPN implementation only supports a single input image, so all", "\n", "# batch inds are 0", "\n", "", "batch_inds", "=", "np", ".", "ones", "(", "(", "proposals", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "*", "self", ".", "batch_idx", "\n", "blob", "=", "np", ".", "hstack", "(", "(", "batch_inds", ",", "proposals", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", ")", ")", "\n", "return", "torch", ".", "tensor", "(", "blob", ",", "requires_grad", "=", "False", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "tensor", "(", "scores", ",", "requires_grad", "=", "False", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.pyramid_proposal.PyramidProposalFunction._filter_boxes": [[224, 231], ["numpy.where"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_filter_boxes", "(", "boxes", ",", "min_size", ")", ":", "\n", "        ", "\"\"\" Remove all boxes with any side smaller than min_size \"\"\"", "\n", "ws", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "+", "1", "\n", "hs", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "+", "1", "\n", "keep", "=", "np", ".", "where", "(", "(", "ws", ">=", "min_size", ")", "&", "(", "hs", ">=", "min_size", ")", ")", "[", "0", "]", "\n", "return", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.pyramid_proposal.PyramidProposalFunction._clip_pad": [[232, 247], ["tensor[].copy"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_clip_pad", "(", "tensor", ",", "pad_shape", ")", ":", "\n", "        ", "\"\"\"\n        Clip boxes of the pad area.\n        :param tensor: [n, c, H, W]\n        :param pad_shape: [h, w]\n        :return: [n, c, h, w]\n        \"\"\"", "\n", "H", ",", "W", "=", "tensor", ".", "shape", "[", "2", ":", "]", "\n", "h", ",", "w", "=", "pad_shape", "\n", "\n", "if", "h", "<", "H", "or", "w", "<", "W", ":", "\n", "            ", "tensor", "=", "tensor", "[", ":", ",", ":", ",", ":", "h", ",", ":", "w", "]", ".", "copy", "(", ")", "\n", "\n", "", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.pyramid_proposal.PyramidProposalFunction.backward": [[248, 250], ["None"], "methods", ["None"], ["", "def", "backward", "(", "self", ",", "grad_output", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.proposal_target.ProposalTargetFunction.__init__": [[24, 30], ["torch.autograd.Function.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_classes", ",", "batch_images", ",", "batch_rois", ",", "fg_fraction", ")", ":", "\n", "        ", "super", "(", "ProposalTargetFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "batch_images", "=", "batch_images", "\n", "self", ".", "batch_rois", "=", "batch_rois", "\n", "self", ".", "fg_fraction", "=", "fg_fraction", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.proposal_target.ProposalTargetFunction.forward": [[31, 55], ["rois.cpu().numpy", "gt_boxes.cpu().numpy.cpu().numpy.cpu().numpy", "numpy.zeros", "numpy.vstack", "numpy.all", "upsnet.bbox.sample_rois.sample_rois", "numpy.round().astype", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "rois.cpu", "gt_boxes.cpu().numpy.cpu().numpy.cpu", "numpy.hstack", "numpy.round"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois.sample_rois"], ["", "def", "forward", "(", "self", ",", "rois", ",", "gt_boxes", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "batch_rois", "==", "-", "1", "or", "self", ".", "batch_rois", "%", "self", ".", "batch_images", "==", "0", ",", "'batchimages {} must devide batch_rois {}'", ".", "format", "(", "self", ".", "batch_images", ",", "self", ".", "batch_rois", ")", "\n", "all_rois", "=", "rois", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "self", ".", "batch_rois", "==", "-", "1", ":", "\n", "            ", "rois_per_image", "=", "all_rois", ".", "shape", "[", "0", "]", "+", "gt_boxes", ".", "shape", "[", "0", "]", "\n", "fg_rois_per_image", "=", "rois_per_image", "\n", "", "else", ":", "\n", "            ", "rois_per_image", "=", "self", ".", "batch_rois", "//", "self", ".", "batch_images", "\n", "fg_rois_per_image", "=", "np", ".", "round", "(", "self", ".", "fg_fraction", "*", "rois_per_image", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# Include ground-truth boxes in the set of candidate rois", "\n", "", "zeros", "=", "np", ".", "zeros", "(", "(", "gt_boxes", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "gt_boxes", ".", "dtype", ")", "\n", "all_rois", "=", "np", ".", "vstack", "(", "(", "all_rois", ",", "np", ".", "hstack", "(", "(", "zeros", ",", "gt_boxes", "[", ":", ",", ":", "-", "1", "]", ")", ")", ")", ")", "\n", "# Sanity check: single batch only", "\n", "assert", "np", ".", "all", "(", "all_rois", "[", ":", ",", "0", "]", "==", "0", ")", ",", "'Only single item batches are supported'", "\n", "\n", "rois", ",", "labels", ",", "bbox_targets", ",", "bbox_weights", "=", "sample_rois", "(", "all_rois", ",", "fg_rois_per_image", ",", "rois_per_image", ",", "self", ".", "num_classes", ",", "gt_boxes", "=", "gt_boxes", ")", "\n", "\n", "return", "torch", ".", "FloatTensor", "(", "rois", ")", ",", "torch", ".", "FloatTensor", "(", "labels", ")", ",", "torch", ".", "FloatTensor", "(", "bbox_targets", ")", ",", "torch", ".", "FloatTensor", "(", "bbox_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.functions.proposal_target.ProposalTargetFunction.backward": [[56, 58], ["None"], "methods", ["None"], ["", "def", "backward", "(", "self", ",", "grad_output", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.deformable_roi_pooling.__init__._import_symbols": [[6, 14], ["dir", "getattr", "callable", "__all__.append", "torch.utils.ffi._wrap_function"], "function", ["None"], []], "home.repos.pwc.inspect_result.uber-research_UPSNet.roi_pooling.__init__._import_symbols": [[6, 14], ["dir", "getattr", "callable", "__all__.append", "torch.utils.ffi._wrap_function"], "function", ["None"], []], "home.repos.pwc.inspect_result.uber-research_UPSNet.segment_reduction.__init__._import_symbols": [[6, 14], ["dir", "getattr", "callable", "__all__.append", "torch.utils.ffi._wrap_function"], "function", ["None"], []], "home.repos.pwc.inspect_result.uber-research_UPSNet.deformable_convolution.__init__._import_symbols": [[6, 14], ["dir", "getattr", "callable", "__all__.append", "torch.utils.ffi._wrap_function"], "function", ["None"], []], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.view.View.__init__": [[21, 24], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "shape", ")", ":", "\n", "        ", "super", "(", "View", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.view.View.forward": [[25, 27], ["input.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "input", ".", "view", "(", "*", "self", ".", "shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.proposal_mask_target.ProposalMaskTarget.__init__": [[28, 36], ["torch.nn.modules.module.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["self", ".", "batch_images", "=", "batch_images", "\n", "self", ".", "batch_rois", "=", "batch_rois", "\n", "self", ".", "fg_fraction", "=", "fg_fraction", "\n", "self", ".", "mask_size", "=", "mask_size", "\n", "self", ".", "binary_thresh", "=", "binary_thresh", "\n", "\n", "", "def", "forward", "(", "self", ",", "rois", ",", "gt_boxes", ",", "gt_masks", ")", ":", "\n", "\n", "        ", "context", "=", "torch", ".", "device", "(", "'cuda'", ",", "rois", ".", "get_device", "(", ")", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.proposal_mask_target.ProposalMaskTarget.forward": [[37, 62], ["torch.device", "rois.data.cpu().numpy", "upsnet.dataset.json_dataset.add_proposals", "collections.defaultdict", "enumerate", "rois.get_device", "upsnet.bbox.sample_rois.sample_rois", "upsnet.bbox.sample_rois.sample_rois.items", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "rois.data.cpu", "blobs[].append", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory().to", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "torch.tensor().pin_memory", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.add_proposals", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois.sample_rois"], ["\n", "assert", "self", ".", "batch_rois", "==", "-", "1", "or", "self", ".", "batch_rois", "%", "self", ".", "batch_images", "==", "0", ",", "'batchimages {} must devide batch_rois {}'", ".", "format", "(", "self", ".", "batch_images", ",", "self", ".", "batch_rois", ")", "\n", "all_rois", "=", "rois", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "gt_boxes", "=", "gt_boxes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "gt_masks", "=", "gt_masks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "self", ".", "batch_rois", "==", "-", "1", ":", "\n", "            ", "rois_per_image", "=", "all_rois", ".", "shape", "[", "0", "]", "+", "gt_boxes", ".", "shape", "[", "0", "]", "\n", "fg_rois_per_image", "=", "rois_per_image", "\n", "", "else", ":", "\n", "            ", "rois_per_image", "=", "self", ".", "batch_rois", "//", "self", ".", "batch_images", "\n", "fg_rois_per_image", "=", "np", ".", "round", "(", "self", ".", "fg_fraction", "*", "rois_per_image", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# Include ground-truth boxes in the set of candidate rois", "\n", "", "zeros", "=", "np", ".", "zeros", "(", "(", "gt_boxes", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "gt_boxes", ".", "dtype", ")", "\n", "all_rois", "=", "np", ".", "vstack", "(", "(", "all_rois", ",", "np", ".", "hstack", "(", "(", "zeros", ",", "gt_boxes", "[", ":", ",", ":", "-", "1", "]", ")", ")", ")", ")", "\n", "# Sanity check: single batch only", "\n", "assert", "np", ".", "all", "(", "all_rois", "[", ":", ",", "0", "]", "==", "0", ")", ",", "'Only single item batches are supported'", "\n", "\n", "rois", ",", "labels", ",", "bbox_targets", ",", "bbox_weights", ",", "mask_targets", ",", "mask_weights", "=", "sample_rois", "(", "all_rois", ",", "fg_rois_per_image", ",", "rois_per_image", ",", "self", ".", "num_classes", ",", "gt_boxes", "=", "gt_boxes", ",", "\n", "gt_masks", "=", "gt_masks", ",", "mask_size", "=", "self", ".", "mask_size", ",", "binary_thresh", "=", "self", ".", "binary_thresh", ")", "\n", "\n", "return", "torch", ".", "Tensor", "(", "rois", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "Tensor", "(", "labels", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "int64", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "Tensor", "(", "bbox_targets", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "Tensor", "(", "bbox_weights", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "dtype", "=", "torch", ".", "float32", ",", "non_blocking", "=", "True", ")", ","]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.roialign.RoIAlign.__init__": [[21, 27], ["torch.nn.modules.module.Module.__init__", "int", "int", "float"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["class", "RoIAlignFunction", "(", "Function", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "pooled_height", ",", "pooled_width", ",", "spatial_scale", ",", "sampling_ratio", "=", "2", ")", ":", "\n", "        ", "super", "(", "RoIAlignFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pooled_width", "=", "int", "(", "pooled_width", ")", "\n", "self", ".", "pooled_height", "=", "int", "(", "pooled_height", ")", "\n", "self", ".", "spatial_scale", "=", "float", "(", "spatial_scale", ")", "\n", "self", ".", "sampling_ratio", "=", "sampling_ratio", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.roialign.RoIAlign.forward": [[28, 30], ["functions.roialign.RoIAlignFunction"], "methods", ["None"], ["self", ".", "feature_size", "=", "None", "\n", "\n", "", "def", "forward", "(", "self", ",", "features", ",", "rois", ")", ":", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.fpn_roi_pooling.FPNRoIPool.__init__": [[24, 31], ["torch.nn.modules.module.Module.__init__", "int", "int"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "pooled_height", ",", "pooled_width", ",", "spatial_scale", ")", ":", "\n", "        ", "super", "(", "FPNRoIPool", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "pooled_width", "=", "int", "(", "pooled_width", ")", "\n", "self", ".", "pooled_height", "=", "int", "(", "pooled_height", ")", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "roi_pooling", "=", "RoIPoolFunction", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.fpn_roi_pooling.FPNRoIPool.forward": [[32, 62], ["rois.data.cpu().numpy.data.cpu().numpy.data.cpu().numpy", "numpy.clip", "range", "torch.autograd.Variable().cuda", "range", "torch.cat", "torch.index_select", "numpy.floor", "feat[].get_device", "len", "torch.autograd.Variable().cuda", "torch.index_select.append", "rois.data.cpu().numpy.data.cpu().numpy.data.cpu", "numpy.where", "len", "rois_fpn.append", "feat_no.append", "rois_fpn.append", "feat_no.append", "torch.autograd.Variable", "feat[].get_device", "numpy.log2", "numpy.zeros", "torch.LongTensor", "torch.autograd.Variable", "fpn_roi_pooling.FPNRoIPool.roi_pooling", "torch.FloatTensor", "numpy.sqrt", "numpy.argsort", "numpy.hstack"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feat", ",", "rois", ")", ":", "\n", "\n", "        ", "rois", "=", "rois", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "w", "=", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", "+", "1", "\n", "h", "=", "rois", "[", ":", ",", "4", "]", "-", "rois", "[", ":", ",", "2", "]", "+", "1", "\n", "feat_id", "=", "np", ".", "clip", "(", "np", ".", "floor", "(", "2", "+", "np", ".", "log2", "(", "np", ".", "sqrt", "(", "w", "*", "h", ")", "/", "224", ")", ")", ",", "0", ",", "3", ")", "\n", "feat_no", "=", "[", "]", "\n", "rois_fpn", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "feat_idx", "=", "np", ".", "where", "(", "feat_id", "==", "i", ")", "[", "0", "]", "\n", "if", "len", "(", "feat_idx", ")", "==", "0", ":", "\n", "                ", "rois_fpn", ".", "append", "(", "np", ".", "zeros", "(", "(", "1", ",", "5", ")", ")", ")", "\n", "feat_no", ".", "append", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "                ", "rois_fpn", ".", "append", "(", "rois", "[", "feat_idx", "]", ")", "\n", "feat_no", ".", "append", "(", "feat_idx", ")", "\n", "\n", "", "", "rois_index", "=", "Variable", "(", "torch", ".", "LongTensor", "(", "np", ".", "argsort", "(", "np", ".", "hstack", "(", "feat_no", ")", ")", "[", "-", "rois", ".", "shape", "[", "0", "]", ":", "]", ")", ",", "requires_grad", "=", "False", ")", ".", "cuda", "(", "feat", "[", "0", "]", ".", "get_device", "(", ")", ")", "\n", "\n", "\n", "pool_feat", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "spatial_scale", ")", ")", ":", "\n", "            ", "rois_fpn", "[", "i", "]", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "rois_fpn", "[", "i", "]", ")", ",", "requires_grad", "=", "False", ")", ".", "cuda", "(", "feat", "[", "i", "]", ".", "get_device", "(", ")", ")", "\n", "pool_feat", ".", "append", "(", "\n", "self", ".", "roi_pooling", "(", "self", ".", "pooled_height", ",", "self", ".", "pooled_width", ",", "self", ".", "spatial_scale", "[", "i", "]", ")", "(", "feat", "[", "i", "]", ",", "rois_fpn", "[", "i", "]", ")", ")", "\n", "\n", "", "pool_feat", "=", "torch", ".", "cat", "(", "pool_feat", ",", "dim", "=", "0", ")", "\n", "pool_feat", "=", "torch", ".", "index_select", "(", "pool_feat", ",", "0", ",", "rois_index", ")", "\n", "return", "pool_feat", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mod_deform_conv.ModDeformConv.__init__": [[26, 50], ["torch.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "mod_deform_conv.ModDeformConv.reset_parameters", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "mod_deform_conv.ModDeformConv.register_parameter", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.deform_conv.DeformConv.reset_parameters"], ["padding", ",", "dilation", ",", "groups", ",", "deformable_groups", ")", ":", "\n", "        ", "if", "weight", ".", "requires_grad", "or", "data", ".", "requires_grad", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "data", ",", "offset", ",", "mask", ",", "weight", ",", "bias", ")", "\n", "", "ctx", ".", "in_channels", "=", "in_channels", "\n", "ctx", ".", "out_channels", "=", "out_channels", "\n", "ctx", ".", "kernel_size", "=", "kernel_size", "\n", "ctx", ".", "stride", "=", "stride", "\n", "ctx", ".", "padding", "=", "padding", "\n", "ctx", ".", "dilation", "=", "dilation", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "data_shape", "=", "tuple", "(", "data", ".", "size", "(", ")", ")", "\n", "ctx", ".", "offset_shape", "=", "tuple", "(", "offset", ".", "size", "(", ")", ")", "\n", "ctx", ".", "mask_shape", "=", "tuple", "(", "mask", ".", "size", "(", ")", ")", "\n", "if", "not", "data", ".", "is_cuda", "or", "not", "offset", ".", "is_cuda", "or", "not", "mask", ".", "is_cuda", "or", "not", "weight", ".", "is_cuda", "or", "(", "bias", "is", "not", "None", "and", "not", "bias", ".", "is_cuda", ")", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "\n", "", "assert", "data", ".", "is_contiguous", "and", "offset", ".", "is_contiguous", "and", "mask", ".", "is_contiguous", "\n", "\n", "ModDeformConvFunction", ".", "shape_setup", "(", "ctx", ")", "\n", "col_buffer", "=", "data", ".", "new", "(", ")", ".", "resize_", "(", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", ".", "zero_", "(", ")", "\n", "output", "=", "data", ".", "new", "(", ")", ".", "resize_", "(", "ctx", ".", "output_shape", "[", "0", "]", ",", "ctx", ".", "output_shape", "[", "1", "]", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", ".", "zero_", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "ctx", ".", "data_shape", "[", "0", "]", ")", ":", "\n", "            ", "mod_deform_conv_cuda", ".", "mod_deform_im2col", "(", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", ",", "mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", ",", "ctx", ".", "data_shape", ",", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mod_deform_conv.ModDeformConv.reset_parameters": [[51, 59], ["mod_deform_conv.ModDeformConv.weight.data.uniform_", "math.sqrt", "mod_deform_conv.ModDeformConv.bias.data.uniform_"], "methods", ["None"], ["tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "deformable_groups", ",", "col_buffer", ")", "\n", "output", "[", "i", ",", ":", ",", ":", ",", ":", "]", "=", "torch", ".", "mm", "(", "weight", ".", "view", "(", "-", "1", ",", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ")", ",", "\n", "col_buffer", ".", "view", "(", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ",", "-", "1", ")", ")", ".", "view", "(", "ctx", ".", "output_shape", "[", "1", "]", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", "\n", "", "if", "bias", "is", "not", "None", ":", "\n", "            ", "output", "+=", "bias", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "output", ")", "\n", "", "return", "output", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mod_deform_conv.ModDeformConv.forward": [[60, 68], ["torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "deeplab.operators.functions.mod_deform_conv.ModDeformConvFunction.apply", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["\n", "", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "data", ",", "offset", ",", "mask", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "", "grad_data", "=", "data", ".", "new", "(", ")", ".", "resize_as_", "(", "data", ")", ".", "zero_", "(", ")", "\n", "grad_offset", "=", "offset", ".", "new", "(", ")", ".", "resize_as_", "(", "offset", ")", ".", "zero_", "(", ")", "\n", "grad_mask", "=", "mask", ".", "new", "(", ")", ".", "resize_as_", "(", "mask", ")", ".", "zero_", "(", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mod_deform_conv.ModDeformConvWithOffsetMask.__init__": [[72, 79], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "mod_deform_conv.ModDeformConvWithOffsetMask.conv_offset_mask.weight.data.zero_", "mod_deform_conv.ModDeformConvWithOffsetMask.conv_offset_mask.bias.data.zero_", "mod_deform_conv.ModDeformConv"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["for", "i", "in", "range", "(", "ctx", ".", "data_shape", "[", "0", "]", ")", ":", "\n", "            ", "col_buffer", "=", "torch", ".", "mm", "(", "weight", ".", "view", "(", "-", "1", ",", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ")", ".", "t", "(", ")", ",", "\n", "grad_output", ".", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "view", "(", "ctx", ".", "out_channels", ",", "-", "1", ")", ")", ".", "view", "(", "(", "-", "1", ",", "grad_output", ".", "size", "(", "2", ")", ",", "grad_output", ".", "size", "(", "3", ")", ")", ")", "\n", "\n", "mod_deform_conv_cuda", ".", "mod_deform_col2im_coord", "(", "col_buffer", ",", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "deformable_groups", ",", "grad_offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "grad_mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mod_deform_conv.ModDeformConvWithOffsetMask.forward": [[80, 82], ["mod_deform_conv.ModDeformConvWithOffsetMask.conv", "mod_deform_conv.ModDeformConvWithOffsetMask.conv_offset_mask"], "methods", ["None"], ["\n", "mod_deform_conv_cuda", ".", "mod_deform_col2im", "(", "col_buffer", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "mask", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_roi.MaskROI.__init__": [[25, 35], ["torch.nn.modules.module.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "clip_boxes", ",", "bbox_class_agnostic", ",", "top_n", ",", "num_classes", ",", "nms_thresh", "=", "None", ",", "class_agnostic", "=", "False", ",", "score_thresh", "=", "None", ")", ":", "\n", "        ", "super", "(", "MaskROI", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "clip_boxes", "=", "clip_boxes", "\n", "self", ".", "bbox_class_agnostic", "=", "bbox_class_agnostic", "\n", "self", ".", "top_n", "=", "top_n", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "if", "nms_thresh", "is", "not", "None", "else", "config", ".", "test", ".", "nms_thresh", "\n", "self", ".", "class_agnostic", "=", "class_agnostic", "\n", "self", ".", "nms_classes", "=", "num_classes", "if", "not", "class_agnostic", "else", "2", "\n", "self", ".", "score_thresh", "=", "score_thresh", "if", "score_thresh", "is", "not", "None", "else", "config", ".", "test", ".", "score_thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_roi.MaskROI.forward": [[36, 147], ["bottom_rois.cpu().detach().numpy.cpu().detach().numpy.get_device", "upsnet.nms.nms.gpu_nms_wrapper", "bottom_rois.cpu().detach().numpy.cpu().detach().numpy.cpu().detach().numpy", "bbox_delta.cpu().detach().numpy.cpu().detach().numpy.cpu().detach().numpy", "torch.cat.cpu", "torch.cat.detach().numpy", "upsnet.bbox.bbox_transform.bbox_transform", "range", "numpy.vstack", "numpy.zeros", "numpy.hstack", "cls_score.cpu", "cls_label.view().expand().contiguous().view.view().expand().contiguous().view.cpu", "upsnet.bbox.bbox_transform.clip_boxes", "cls_prob_np[].reshape", "numpy.hstack", "cls_prob[].contiguous().view", "torch.cat", "[].reshape", "numpy.hstack", "numpy.array().T[].reshape", "numpy.vstack().tolist", "numpy.hstack().astype", "numpy.hstack", "numpy.hstack", "torch.cat().to", "numpy.ones", "numpy.zeros", "numpy.zeros", "torch.cat().to", "bottom_rois.cpu().detach().numpy.cpu().detach().numpy.cpu().detach", "bbox_delta.cpu().detach().numpy.cpu().detach().numpy.cpu().detach", "torch.cat.detach", "range", "cls_label.view().expand().contiguous().view.view().expand().contiguous().view.view().expand().contiguous().view", "range", "range", "numpy.where", "upsnet.nms.nms.gpu_nms_wrapper.", "[].numpy", "len", "range", "torch.from_numpy().float().pin_memory().to", "torch.from_numpy().long().pin_memory().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().long().to", "torch.from_numpy().float().pin_memory().to", "torch.from_numpy().long().pin_memory().to", "range", "numpy.zeros_like", "cls_prob[].contiguous", "torch.zeros_like", "numpy.zeros_like", "numpy.vstack", "range", "range", "numpy.hstack", "len", "torch.from_numpy().long", "numpy.array", "numpy.sort", "range", "torch.cat", "torch.cat", "bottom_rois.cpu().detach().numpy.cpu().detach().numpy.cpu", "bbox_delta.cpu().detach().numpy.cpu().detach().numpy.cpu", "numpy.hstack.reshape", "cls_label.view().expand().contiguous().view.view().expand().contiguous().view.view().expand().contiguous", "range", "numpy.where", "torch.from_numpy().float().pin_memory", "torch.from_numpy().long().pin_memory", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().long", "torch.from_numpy().float().pin_memory", "torch.from_numpy().long().pin_memory", "numpy.array", "numpy.zeros_like", "torch.from_numpy().long", "torch.from_numpy", "torch.from_numpy", "cls_label.view().expand().contiguous().view.view().expand().contiguous().view.view().expand", "numpy.array", "numpy.array", "torch.from_numpy", "torch.from_numpy().float", "torch.from_numpy().long", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().float", "torch.from_numpy().long", "torch.from_numpy", "numpy.array", "cls_label.view().expand().contiguous().view.view().expand().contiguous().view.view", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.nms.nms.gpu_nms_wrapper", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_transform", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_boxes"], ["", "def", "forward", "(", "self", ",", "bottom_rois", ",", "bbox_delta", ",", "cls_prob", ",", "im_info", ",", "nms", "=", "True", ",", "cls_score", "=", "None", ",", "cls_label", "=", "None", ")", ":", "\n", "\n", "        ", "context", "=", "bottom_rois", ".", "get_device", "(", ")", "\n", "nms", "=", "gpu_nms_wrapper", "(", "self", ".", "nms_thresh", ",", "device_id", "=", "context", ")", "\n", "\n", "\n", "bottom_rois", "=", "bottom_rois", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "bbox_delta", "=", "bbox_delta", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "cls_prob", "=", "cls_prob", ".", "cpu", "(", ")", "\n", "cls_prob_np", "=", "cls_prob", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "if", "cls_score", "is", "not", "None", ":", "\n", "            ", "cls_prob", "=", "cls_score", ".", "cpu", "(", ")", "\n", "", "if", "cls_label", "is", "not", "None", ":", "\n", "            ", "cls_label", "=", "cls_label", ".", "cpu", "(", ")", "\n", "\n", "", "proposal", "=", "bbox_pred", "(", "bottom_rois", "[", ":", ",", "1", ":", "]", ",", "bbox_delta", ",", "config", ".", "network", ".", "bbox_reg_weights", ")", "\n", "\n", "if", "self", ".", "clip_boxes", ":", "\n", "            ", "proposal", "=", "clip_boxes", "(", "proposal", ",", "im_info", "[", "0", ",", ":", "2", "]", ")", "\n", "\n", "", "cls_idx", "=", "[", "[", "_", "for", "__", "in", "range", "(", "proposal", ".", "shape", "[", "0", "]", ")", "]", "for", "_", "in", "range", "(", "self", ".", "num_classes", ")", "]", "\n", "\n", "\n", "if", "self", ".", "class_agnostic", ":", "\n", "            ", "cls_prob_np", "=", "cls_prob_np", "[", ":", ",", "1", ":", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "# n x 1 -> n x 2", "\n", "cls_prob_np", "=", "np", ".", "hstack", "(", "(", "np", ".", "zeros_like", "(", "cls_prob_np", ")", ",", "cls_prob_np", ")", ")", "\n", "cls_prob", "=", "cls_prob", "[", ":", ",", "1", ":", "]", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "# n x 1 -> n x 2", "\n", "cls_prob", "=", "torch", ".", "cat", "(", "[", "torch", ".", "zeros_like", "(", "cls_prob", ")", ",", "cls_prob", "]", ",", "dim", "=", "1", ")", "\n", "\n", "proposal", "=", "proposal", ".", "reshape", "(", "(", "proposal", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "4", ")", ")", "[", ":", ",", "1", ":", ",", ":", "]", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "\n", "# n x 4 -> n x 8", "\n", "proposal", "=", "np", ".", "hstack", "(", "(", "np", ".", "zeros_like", "(", "proposal", ")", ",", "proposal", ")", ")", "\n", "\n", "cls_idx", "=", "np", ".", "array", "(", "cls_idx", ")", ".", "T", "[", ":", ",", "1", ":", "]", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "# 1 x n -> 2 x n", "\n", "cls_idx", "=", "np", ".", "vstack", "(", "(", "np", ".", "zeros_like", "(", "cls_idx", ")", ",", "cls_idx", ")", ")", ".", "tolist", "(", ")", "\n", "\n", "if", "cls_label", "is", "not", "None", ":", "\n", "                ", "cls_label", "=", "cls_label", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand", "(", "-", "1", ",", "self", ".", "num_classes", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "", "", "cls_boxes", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "nms_classes", ")", "]", "\n", "scores_th", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "nms_classes", ")", "]", "\n", "if", "cls_score", "is", "not", "None", ":", "\n", "            ", "feat_th", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "nms_classes", ")", "]", "\n", "", "if", "cls_label", "is", "not", "None", ":", "\n", "            ", "cls_label_th", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "nms_classes", ")", "]", "\n", "# Apply threshold on detection probabilities and apply NMS", "\n", "# Skip j = 0, because it's the background class", "\n", "\n", "", "for", "j", "in", "range", "(", "1", ",", "self", ".", "nms_classes", ")", ":", "\n", "            ", "inds", "=", "np", ".", "where", "(", "cls_prob_np", "[", ":", ",", "j", "]", ">", "self", ".", "score_thresh", ")", "[", "0", "]", "\n", "scores_j", "=", "cls_prob_np", "[", "inds", ",", "j", "]", "\n", "boxes_j", "=", "proposal", "[", "inds", ",", "j", "*", "4", ":", "(", "j", "+", "1", ")", "*", "4", "]", "\n", "dets_j", "=", "np", ".", "hstack", "(", "(", "boxes_j", ",", "scores_j", "[", ":", ",", "np", ".", "newaxis", "]", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# nms", "\n", "keep", "=", "[", "]", "if", "len", "(", "dets_j", ")", "==", "0", "else", "nms", "(", "dets_j", ")", "\n", "nms_dets", "=", "dets_j", "[", "keep", ",", ":", "]", "\n", "scores_th", "[", "j", "]", "=", "cls_prob", "[", "torch", ".", "from_numpy", "(", "inds", ")", ".", "long", "(", ")", ",", "j", "]", "[", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "keep", ")", ")", ".", "long", "(", ")", "]", "\n", "\n", "# Refine the post-NMS boxes using bounding-box voting", "\n", "cls_boxes", "[", "j", "]", "=", "nms_dets", "\n", "cls_idx", "[", "j", "]", "=", "np", ".", "array", "(", "cls_idx", "[", "j", "]", ")", "[", "inds", "]", "[", "keep", "]", "\n", "if", "cls_label", "is", "not", "None", ":", "\n", "                ", "cls_label_th", "[", "j", "]", "=", "cls_label", "[", "inds", "]", "[", "keep", "]", ".", "numpy", "(", ")", "\n", "\n", "# Limit to max_per_image detections **over all classes**", "\n", "", "", "if", "config", ".", "test", ".", "max_det", ">", "0", ":", "\n", "            ", "image_scores", "=", "np", ".", "hstack", "(", "\n", "[", "cls_boxes", "[", "j", "]", "[", ":", ",", "-", "1", "]", "for", "j", "in", "range", "(", "1", ",", "self", ".", "nms_classes", ")", "]", "\n", ")", "\n", "\n", "if", "len", "(", "image_scores", ")", ">", "config", ".", "test", ".", "max_det", ":", "\n", "                ", "image_thresh", "=", "np", ".", "sort", "(", "image_scores", ")", "[", "-", "config", ".", "test", ".", "max_det", "]", "\n", "for", "j", "in", "range", "(", "1", ",", "self", ".", "nms_classes", ")", ":", "\n", "                    ", "keep", "=", "np", ".", "where", "(", "cls_boxes", "[", "j", "]", "[", ":", ",", "-", "1", "]", ">=", "image_thresh", ")", "[", "0", "]", "\n", "cls_boxes", "[", "j", "]", "=", "cls_boxes", "[", "j", "]", "[", "keep", ",", ":", "]", "\n", "scores_th", "[", "j", "]", "=", "scores_th", "[", "j", "]", "[", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "keep", ")", ")", "]", "\n", "cls_idx", "[", "j", "]", "=", "cls_idx", "[", "j", "]", "[", "keep", "]", "\n", "if", "cls_score", "is", "not", "None", ":", "\n", "                        ", "feat_th", "[", "j", "]", "=", "feat_th", "[", "j", "]", "[", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "keep", ")", ")", "]", "\n", "", "if", "cls_label", "is", "not", "None", ":", "\n", "                        ", "cls_label_th", "[", "j", "]", "=", "cls_label_th", "[", "j", "]", "[", "keep", "]", "\n", "\n", "", "", "", "", "im_results", "=", "np", ".", "vstack", "(", "[", "cls_boxes", "[", "j", "]", "for", "j", "in", "range", "(", "1", ",", "self", ".", "nms_classes", ")", "]", ")", "\n", "boxes", "=", "np", ".", "zeros", "(", "im_results", ".", "shape", ")", "\n", "boxes", "[", ":", ",", "1", ":", "]", "=", "im_results", "[", ":", ",", ":", "-", "1", "]", "\n", "scores", "=", "im_results", "[", ":", ",", "-", "1", "]", "\n", "cls_idx", "=", "np", ".", "hstack", "(", "(", "cls_idx", "[", "1", ":", "]", ")", ")", "\n", "if", "cls_label", "is", "not", "None", ":", "\n", "            ", "cls_label", "=", "np", ".", "hstack", "(", "(", "cls_label_th", "[", "1", ":", "]", ")", ")", "\n", "scores_th", "=", "torch", ".", "cat", "(", "scores_th", "[", "1", ":", "]", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", "\n", "return", "scores_th", ",", "torch", ".", "from_numpy", "(", "boxes", ")", ".", "float", "(", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "from_numpy", "(", "cls_idx", ")", ".", "long", "(", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", ",", "cls_label", "\n", "\n", "", "if", "scores", ".", "size", "==", "0", ":", "\n", "            ", "scores", "=", "np", ".", "ones", "(", "(", "1", ",", ")", ")", "\n", "boxes", "=", "np", ".", "zeros", "(", "(", "1", ",", "5", ")", ")", "\n", "cls_idx", "=", "np", ".", "zeros", "(", "(", "1", ",", ")", ")", "\n", "return", "torch", ".", "from_numpy", "(", "scores", ")", ".", "float", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "from_numpy", "(", "boxes", ")", ".", "float", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "from_numpy", "(", "cls_idx", ")", ".", "long", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "scores_th", "=", "torch", ".", "cat", "(", "scores_th", "[", "1", ":", "]", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", "\n", "return", "scores_th", ",", "torch", ".", "from_numpy", "(", "boxes", ")", ".", "float", "(", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", ",", "torch", ".", "from_numpy", "(", "cls_idx", ")", ".", "long", "(", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_roi.MaskROI.bbox_transform": [[148, 203], ["torch.zeros_like", "torch.max.view", "torch.max.transpose", "center_x.view", "center_y.view", "bbox_width.view", "dw.exp", "bbox_height.view", "dh.exp", "torch.from_numpy().to", "im_wh.repeat().unsqueeze.repeat().unsqueeze.repeat().unsqueeze", "torch.min", "torch.max", "bbox_width.view", "bbox_height.view", "torch.zeros_like", "torch.from_numpy", "im_wh.repeat().unsqueeze.repeat().unsqueeze.repeat"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "bbox_transform", "(", "bbox", ",", "bbox_delta", ",", "im_info", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\n        :param bbox: [num_boxes, 4]\n        :param bbox_delta: [num_boxes, (4 * num_reg_classes - 1)]\n        :param im_info: [1, 3] -> [[height, width, scale]]\n        :return: transformed_bbox: [num_boxes, 4, num_reg_classes]\n        \"\"\"", "\n", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "bbox", "[", ":", ",", "0", "]", ",", "bbox", "[", ":", ",", "1", "]", ",", "bbox", "[", ":", ",", "2", "]", ",", "bbox", "[", ":", ",", "3", "]", "\n", "\n", "bbox_width", "=", "xmax", "-", "xmin", "+", "1.0", "\n", "bbox_height", "=", "ymax", "-", "ymin", "+", "1.0", "\n", "center_x", "=", "xmin", "+", "0.5", "*", "bbox_width", "\n", "center_y", "=", "ymin", "+", "0.5", "*", "bbox_height", "\n", "\n", "dx", ",", "dy", ",", "dw", ",", "dh", "=", "bbox_delta", "[", ":", ",", "0", ":", ":", "4", "]", ",", "bbox_delta", "[", ":", ",", "1", ":", ":", "4", "]", ",", "bbox_delta", "[", ":", ",", "2", ":", ":", "4", "]", ",", "bbox_delta", "[", ":", ",", "3", ":", ":", "4", "]", "\n", "\n", "dx", "=", "dx", "/", "config", ".", "network", ".", "bbox_reg_weights", "[", "0", "]", "\n", "dy", "=", "dy", "/", "config", ".", "network", ".", "bbox_reg_weights", "[", "1", "]", "\n", "dw", "=", "dw", "/", "config", ".", "network", ".", "bbox_reg_weights", "[", "2", "]", "\n", "dh", "=", "dh", "/", "config", ".", "network", ".", "bbox_reg_weights", "[", "3", "]", "\n", "\n", "transformed_center_x", "=", "center_x", ".", "view", "(", "-", "1", ",", "1", ")", "+", "bbox_width", ".", "view", "(", "-", "1", ",", "1", ")", "*", "dx", "\n", "transformed_center_y", "=", "center_y", ".", "view", "(", "-", "1", ",", "1", ")", "+", "bbox_height", ".", "view", "(", "-", "1", ",", "1", ")", "*", "dy", "\n", "transformed_width", "=", "bbox_width", ".", "view", "(", "-", "1", ",", "1", ")", "*", "dw", ".", "exp", "(", ")", "\n", "transformed_height", "=", "bbox_height", ".", "view", "(", "-", "1", ",", "1", ")", "*", "dh", ".", "exp", "(", ")", "\n", "\n", "w_offset", "=", "0.5", "*", "transformed_width", "\n", "h_offset", "=", "0.5", "*", "transformed_height", "\n", "transformed_xmin", "=", "transformed_center_x", "-", "w_offset", "\n", "transformed_ymin", "=", "transformed_center_y", "-", "h_offset", "\n", "transformed_xmax", "=", "transformed_center_x", "+", "w_offset", "-", "1", "\n", "transformed_ymax", "=", "transformed_center_y", "+", "h_offset", "-", "1", "\n", "\n", "# transformed_bbox = torch.cat([transformed_xmin, transformed_ymin, transformed_xmax, transformed_ymax], dim=1)", "\n", "transformed_bbox", "=", "torch", ".", "zeros_like", "(", "bbox_delta", ")", "\n", "transformed_bbox", "[", ":", ",", "0", ":", ":", "4", "]", "=", "transformed_xmin", "\n", "transformed_bbox", "[", ":", ",", "1", ":", ":", "4", "]", "=", "transformed_ymin", "\n", "transformed_bbox", "[", ":", ",", "2", ":", ":", "4", "]", "=", "transformed_xmax", "\n", "transformed_bbox", "[", ":", ",", "3", ":", ":", "4", "]", "=", "transformed_ymax", "\n", "# [num_boxes, num_reg_classes - 1, 4]", "\n", "transformed_bbox", "=", "transformed_bbox", ".", "view", "(", "(", "transformed_bbox", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "4", ")", ")", "\n", "\n", "\n", "if", "im_info", "is", "not", "None", ":", "\n", "# [1, 2]", "\n", "            ", "im_wh", "=", "torch", ".", "from_numpy", "(", "im_info", "[", "0", ",", "[", "1", ",", "0", "]", "]", "-", "1.0", ")", ".", "to", "(", "transformed_bbox", ".", "device", ",", "non_blocking", "=", "True", ")", "\n", "# [1, 1, 4]", "\n", "im_wh", "=", "im_wh", ".", "repeat", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "0", ")", "\n", "transformed_bbox", "=", "torch", ".", "min", "(", "transformed_bbox", ",", "im_wh", ")", "\n", "transformed_bbox", "=", "torch", ".", "max", "(", "transformed_bbox", ",", "torch", ".", "zeros_like", "(", "transformed_bbox", ")", ")", "\n", "\n", "", "return", "transformed_bbox", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.deform_conv.DeformConv.__init__": [[27, 51], ["torch.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "deform_conv.DeformConv.reset_parameters", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "deform_conv.DeformConv.register_parameter", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.deform_conv.DeformConv.reset_parameters"], ["padding", ",", "dilation", ",", "groups", ",", "deformable_groups", ")", ":", "\n", "        ", "if", "weight", ".", "requires_grad", "or", "data", ".", "requires_grad", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "data", ",", "offset", ",", "weight", ",", "bias", ")", "\n", "", "ctx", ".", "in_channels", "=", "in_channels", "\n", "ctx", ".", "out_channels", "=", "out_channels", "\n", "ctx", ".", "kernel_size", "=", "kernel_size", "\n", "ctx", ".", "stride", "=", "stride", "\n", "ctx", ".", "padding", "=", "padding", "\n", "ctx", ".", "dilation", "=", "dilation", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "data_shape", "=", "tuple", "(", "data", ".", "size", "(", ")", ")", "\n", "ctx", ".", "offset_shape", "=", "tuple", "(", "offset", ".", "size", "(", ")", ")", "\n", "if", "not", "data", ".", "is_cuda", "or", "not", "offset", ".", "is_cuda", "or", "not", "weight", ".", "is_cuda", "or", "(", "bias", "is", "not", "None", "and", "not", "bias", ".", "is_cuda", ")", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "\n", "", "DeformConvFunction", ".", "shape_setup", "(", "ctx", ")", "\n", "col_buffer", "=", "data", ".", "new", "(", ")", ".", "resize_", "(", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", ".", "zero_", "(", ")", "\n", "output", "=", "data", ".", "new", "(", ")", ".", "resize_", "(", "ctx", ".", "output_shape", "[", "0", "]", ",", "ctx", ".", "output_shape", "[", "1", "]", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", ".", "zero_", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "ctx", ".", "data_shape", "[", "0", "]", ")", ":", "\n", "            ", "deform_conv_cuda", ".", "deform_im2col", "(", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "1", ",", "ctx", ".", "deformable_groups", ",", "col_buffer", ")", "\n", "output", "[", "i", ",", ":", ",", ":", ",", ":", "]", "="]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.deform_conv.DeformConv.reset_parameters": [[52, 60], ["deform_conv.DeformConv.weight.data.uniform_", "math.sqrt", "deform_conv.DeformConv.bias.data.uniform_"], "methods", ["None"], ["torch", ".", "mm", "(", "weight", ".", "view", "(", "-", "1", ",", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ")", ",", "\n", "col_buffer", ".", "view", "(", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ",", "-", "1", ")", ")", ".", "view", "(", "ctx", ".", "output_shape", "[", "1", "]", ",", "ctx", ".", "output_shape", "[", "2", "]", ",", "ctx", ".", "output_shape", "[", "3", "]", ")", "\n", "", "if", "bias", "is", "not", "None", ":", "\n", "            ", "output", "+=", "bias", ".", "view", "(", "1", ",", "bias", ".", "size", "(", "0", ")", ",", "1", ",", "1", ")", ".", "expand_as", "(", "output", ")", "\n", "", "return", "output", "\n", "\n", "", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.deform_conv.DeformConv.forward": [[61, 65], ["upsnet.operators.functions.deform_conv.DeformConvFunction.apply"], "methods", ["None"], ["        ", "data", ",", "offset", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "Exception", "(", "'not implemented'", ")", "\n", "", "grad_data", "=", "data", ".", "new", "(", ")", ".", "resize_as_", "(", "data", ")", ".", "zero_", "(", ")", "\n", "grad_offset", "=", "offset", ".", "new", "(", ")", ".", "resize_as_", "(", "offset", ")", ".", "zero_", "(", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.deform_conv.DeformConvWithOffset.__init__": [[69, 76], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "deform_conv.DeformConvWithOffset.conv_offset.weight.data.zero_", "deform_conv.DeformConvWithOffset.conv_offset.bias.data.zero_", "deform_conv.DeformConv"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["for", "i", "in", "range", "(", "ctx", ".", "data_shape", "[", "0", "]", ")", ":", "\n", "            ", "col_buffer", "=", "torch", ".", "mm", "(", "weight", ".", "view", "(", "-", "1", ",", "int", "(", "ctx", ".", "in_channels", "*", "np", ".", "prod", "(", "ctx", ".", "kernel_size", ")", ")", ")", ".", "t", "(", ")", ",", "\n", "grad_output", ".", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ".", "view", "(", "ctx", ".", "out_channels", ",", "-", "1", ")", ")", ".", "view", "(", "(", "-", "1", ",", "grad_output", ".", "size", "(", "2", ")", ",", "grad_output", ".", "size", "(", "3", ")", ")", ")", "\n", "\n", "deform_conv_cuda", ".", "deform_col2im_coord", "(", "col_buffer", ",", "data", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n", "1", ",", "ctx", ".", "deformable_groups", ",", "grad_offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.deform_conv.DeformConvWithOffset.forward": [[77, 79], ["deform_conv.DeformConvWithOffset.conv", "deform_conv.DeformConvWithOffset.conv_offset"], "methods", ["None"], ["\n", "deform_conv_cuda", ".", "deform_col2im", "(", "col_buffer", ",", "offset", "[", "i", ",", ":", ",", ":", ",", ":", "]", ",", "ctx", ".", "data_shape", ",", "\n", "tuple", "(", "col_buffer", ".", "size", "(", ")", ")", ",", "ctx", ".", "kernel_size", ",", "ctx", ".", "padding", ",", "ctx", ".", "stride", ",", "ctx", ".", "dilation", ",", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_removal.MaskRemoval.__init__": [[25, 28], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "fraction_threshold", "=", "0.3", ")", ":", "\n", "        ", "super", "(", "MaskRemoval", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fraction_threshold", "=", "fraction_threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_removal.MaskRemoval.forward": [[29, 94], ["mask_rois.detach().cpu().numpy.detach().cpu().numpy.new_zeros", "mask_rois.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "cls_prob.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "mask_logit_gpu.detach().cpu().numpy", "cls_idx.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "numpy.zeros", "mask_rois.detach().cpu().numpy.detach().cpu().numpy.astype", "range", "mask_rois.detach().cpu().numpy.detach().cpu().numpy.size", "numpy.argsort", "mask_logit_gpu.new_zeros", "ref_boxes[].astype", "max", "max", "cv2.resize", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "numpy.array", "max", "min", "max", "min", "crop_mask.sum", "keep_inds.append", "len", "mask_logit_gpu.new_zeros", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "mask_rois.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "cls_prob.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "mask_logit_gpu.detach().cpu", "cls_idx.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "len", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "mask_logit[].squeeze", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "torch.from_numpy().pin_memory().to", "numpy.max", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "len", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "mask_rois.detach().cpu().numpy.detach().cpu().numpy.detach", "cls_prob.detach().cpu().numpy.detach().cpu().numpy.detach", "mask_logit_gpu.detach", "cls_idx.detach().cpu().numpy.detach().cpu().numpy.detach", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "numpy.logical_and().sum", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "torch.from_numpy().pin_memory", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.logical_and", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "mask_rois", ",", "cls_prob", ",", "mask_prob", ",", "cls_idx", ",", "im_shape", ")", ":", "\n", "        ", "\"\"\"\n\n        :param mask_rois: [n x 4]\n        :param cls_prob: [n x 1]\n        :param mask_prob: [n x 28 x 28]\n        :param im_shape: [2] (h x w)\n        :return:\n        \"\"\"", "\n", "mask_logit_gpu", "=", "mask_prob", "\n", "mask_energy", "=", "mask_rois", ".", "new_zeros", "(", "1", ",", "mask_rois", ".", "size", "(", "0", ")", ",", "im_shape", "[", "0", "]", ",", "im_shape", "[", "1", "]", ")", "\n", "frame_id", "=", "0", "\n", "\n", "context", "=", "mask_rois", ".", "device", "\n", "mask_rois", "=", "mask_rois", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "cls_prob", "=", "cls_prob", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mask_logit", "=", "mask_logit_gpu", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "cls_idx", "=", "cls_idx", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "mask_image", "=", "np", ".", "zeros", "(", "(", "np", ".", "max", "(", "cls_idx", ")", ",", ")", "+", "im_shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "sorted_inds", "=", "np", ".", "argsort", "(", "cls_prob", ")", "[", ":", ":", "-", "1", "]", "\n", "mask_rois", "=", "mask_rois", "[", "sorted_inds", "]", "\n", "cls_prob", "=", "cls_prob", "[", "sorted_inds", "]", "\n", "mask_logit", "=", "mask_logit", "[", "sorted_inds", "]", "\n", "cls_idx", "=", "cls_idx", "[", "sorted_inds", "]", "-", "1", "\n", "if", "len", "(", "cls_idx", ")", "==", "1", "and", "cls_idx", "[", "0", "]", "==", "-", "1", ":", "\n", "            ", "mask_energy", "=", "mask_logit_gpu", ".", "new_zeros", "(", "1", ",", "1", ",", "im_shape", "[", "0", "]", ",", "im_shape", "[", "1", "]", ")", "\n", "return", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", ",", "mask_energy", "\n", "\n", "", "keep_inds", "=", "[", "]", "\n", "ref_boxes", "=", "mask_rois", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "for", "i", "in", "range", "(", "sorted_inds", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "ref_box", "=", "ref_boxes", "[", "i", ",", ":", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "w", "=", "ref_box", "[", "2", "]", "-", "ref_box", "[", "0", "]", "+", "1", "\n", "h", "=", "ref_box", "[", "3", "]", "-", "ref_box", "[", "1", "]", "+", "1", "\n", "w", "=", "max", "(", "w", ",", "1", ")", "\n", "h", "=", "max", "(", "h", ",", "1", ")", "\n", "logit", "=", "cv2", ".", "resize", "(", "mask_logit", "[", "i", "]", ".", "squeeze", "(", ")", ",", "(", "w", ",", "h", ")", ")", "\n", "logit_tensor", "=", "torch", ".", "from_numpy", "(", "logit", ")", ".", "cuda", "(", ")", "\n", "mask", "=", "np", ".", "array", "(", "logit", ">", "0", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "x_0", "=", "max", "(", "ref_box", "[", "0", "]", ",", "0", ")", "\n", "x_1", "=", "min", "(", "ref_box", "[", "2", "]", "+", "1", ",", "im_shape", "[", "1", "]", ")", "\n", "y_0", "=", "max", "(", "ref_box", "[", "1", "]", ",", "0", ")", "\n", "y_1", "=", "min", "(", "ref_box", "[", "3", "]", "+", "1", ",", "im_shape", "[", "0", "]", ")", "\n", "\n", "crop_mask", "=", "mask", "[", "(", "y_0", "-", "ref_box", "[", "1", "]", ")", ":", "(", "y_1", "-", "ref_box", "[", "1", "]", ")", ",", "\n", "(", "x_0", "-", "ref_box", "[", "0", "]", ")", ":", "(", "x_1", "-", "ref_box", "[", "0", "]", ")", "]", "\n", "mask_sum", "=", "crop_mask", ".", "sum", "(", ")", "\n", "\n", "mask_image_crop", "=", "mask_image", "[", "cls_idx", "[", "i", "]", "]", "[", "y_0", ":", "y_1", ",", "x_0", ":", "x_1", "]", "\n", "if", "mask_sum", "==", "0", "or", "(", "np", ".", "logical_and", "(", "mask_image_crop", ">=", "1", ",", "crop_mask", "==", "1", ")", ".", "sum", "(", ")", "/", "mask_sum", ">", "self", ".", "fraction_threshold", ")", ":", "\n", "                ", "continue", "\n", "", "keep_inds", ".", "append", "(", "sorted_inds", "[", "i", "]", ")", "\n", "mask_image", "[", "cls_idx", "[", "i", "]", "]", "[", "y_0", ":", "y_1", ",", "x_0", ":", "x_1", "]", "+=", "crop_mask", "\n", "mask_energy", "[", "0", ",", "frame_id", ",", "y_0", ":", "y_1", ",", "x_0", ":", "x_1", "]", "=", "logit_tensor", "[", "(", "y_0", "-", "ref_box", "[", "1", "]", ")", ":", "(", "y_1", "-", "ref_box", "[", "1", "]", ")", ",", "(", "x_0", "-", "ref_box", "[", "0", "]", ")", ":", "(", "x_1", "-", "ref_box", "[", "0", "]", ")", "]", "\n", "frame_id", "+=", "1", "\n", "\n", "", "mask_energy", "=", "mask_energy", "[", ":", ",", ":", "len", "(", "keep_inds", ")", "]", "\n", "if", "len", "(", "keep_inds", ")", "==", "0", ":", "\n", "            ", "mask_energy", "=", "mask_logit_gpu", ".", "new_zeros", "(", "1", ",", "1", ",", "im_shape", "[", "0", "]", ",", "im_shape", "[", "1", "]", ")", "\n", "return", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", ",", "mask_energy", "\n", "", "return", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "keep_inds", ")", ")", ".", "pin_memory", "(", ")", ".", "to", "(", "context", ",", "non_blocking", "=", "True", ")", ",", "mask_energy", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_matching.MaskMatching.__init__": [[30, 36], ["torch.Module.__init__", "len", "dict", "zip", "range", "range"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_seg_classes", ",", "enable_void", ",", "class_mapping", "=", "None", ")", ":", "\n", "        ", "super", "(", "MaskMatching", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "class_mapping", "=", "dict", "(", "zip", "(", "range", "(", "1", ",", "config", ".", "dataset", ".", "num_classes", ")", ",", "range", "(", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", "+", "1", ",", "num_seg_classes", ")", ")", ")", "if", "class_mapping", "is", "None", "else", "class_mapping", "\n", "self", ".", "num_seg_classes", "=", "num_seg_classes", "\n", "self", ".", "num_inst_classes", "=", "len", "(", "self", ".", "class_mapping", ")", "\n", "self", ".", "enable_void", "=", "enable_void", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_matching.MaskMatching.forward": [[37, 59], ["torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "range", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "gt_segs", ",", "gt_masks", ",", "keep_inds", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param gt_segs: [1 x h x w]\n        :param gt_masks: [num_gt_boxes x h x w]\n        :param keep_inds: [num_kept_boxes x 1]\n        :return: matched_gt: [1 x h x w]\n        \"\"\"", "\n", "\n", "matched_gt", "=", "torch", ".", "ones_like", "(", "gt_segs", ")", "*", "-", "1", "\n", "matched_gt", "=", "torch", ".", "where", "(", "gt_segs", "<=", "config", ".", "dataset", ".", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", ",", "gt_segs", ",", "matched_gt", ")", "\n", "matched_gt", "=", "torch", ".", "where", "(", "gt_segs", ">=", "255", ",", "gt_segs", ",", "matched_gt", ")", "\n", "if", "keep_inds", "is", "not", "None", ":", "\n", "            ", "gt_masks", "=", "gt_masks", "[", "keep_inds", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "gt_masks", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "matched_gt", "[", "(", "gt_masks", "[", "[", "i", "]", ",", ":", ",", ":", "]", "!=", "0", ")", "&", "(", "gt_masks", "[", "[", "i", "]", ",", ":", ",", ":", "]", "!=", "255", ")", "]", "=", "i", "+", "self", ".", "num_seg_classes", "-", "self", ".", "num_inst_classes", "\n", "", "if", "keep_inds", "is", "not", "None", ":", "\n", "            ", "matched_gt", "[", "matched_gt", "==", "-", "1", "]", "=", "self", ".", "num_seg_classes", "-", "self", ".", "num_inst_classes", "+", "gt_masks", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "matched_gt", "[", "matched_gt", "==", "-", "1", "]", "=", "255", "\n", "\n", "", "return", "matched_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_matching.PanopticGTGenerate.__init__": [[63, 69], ["torch.Module.__init__", "len", "dict", "zip", "range", "range"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_seg_classes", ",", "enable_void", ",", "class_mapping", "=", "None", ")", ":", "\n", "        ", "super", "(", "PanopticGTGenerate", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "class_mapping", "=", "dict", "(", "zip", "(", "range", "(", "1", ",", "config", ".", "dataset", ".", "num_classes", ")", ",", "range", "(", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", "+", "1", ",", "num_seg_classes", ")", ")", ")", "if", "class_mapping", "is", "None", "else", "class_mapping", "\n", "self", ".", "num_seg_classes", "=", "num_seg_classes", "\n", "self", ".", "num_inst_classes", "=", "len", "(", "self", ".", "class_mapping", ")", "\n", "self", ".", "enable_void", "=", "enable_void", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.mask_matching.PanopticGTGenerate.forward": [[70, 126], ["numpy.hstack.data.cpu().numpy", "bbox_pred.data.cpu().numpy.data.cpu().numpy.data.cpu().numpy", "cls_score.data.cpu().numpy.data.cpu().numpy.data.cpu().numpy", "numpy.argmax", "label.data.cpu().numpy.data.cpu().numpy.data.cpu().numpy", "gt_rois.cpu().numpy.cpu().numpy.cpu().numpy", "upsnet.bbox.bbox_transform.bbox_overlaps", "numpy.argmax", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "numpy.ones", "range", "numpy.hstack", "numpy.cumsum", "range", "numpy.ones", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "print", "print", "print", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "numpy.hstack.data.cpu", "bbox_pred.data.cpu().numpy.data.cpu().numpy.data.cpu", "cls_score.data.cpu().numpy.data.cpu().numpy.data.cpu", "label.data.cpu().numpy.data.cpu().numpy.data.cpu", "gt_rois.cpu().numpy.cpu().numpy.cpu", "numpy.zeros", "numpy.round", "int", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps"], ["", "def", "forward", "(", "self", ",", "rois", ",", "bbox_pred", ",", "cls_score", ",", "label", ",", "gt_rois", ",", "cls_idx", ",", "seg_gt", ",", "mask_gt", ",", "im_shape", ")", ":", "\n", "\n", "        ", "rois", "=", "rois", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bbox_pred", "=", "bbox_pred", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "cls_score", "=", "cls_score", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "cls_pred", "=", "np", ".", "argmax", "(", "cls_score", ",", "axis", "=", "1", ")", "\n", "label", "=", "label", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "gt_rois", "=", "gt_rois", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "rois", "=", "rois", "[", ":", ",", "1", ":", "]", "\n", "\n", "bbox_overlap", "=", "bbox_overlaps", "(", "rois", ",", "gt_rois", "[", ":", ",", "1", ":", "]", ")", "# #rois x #gt_rois", "\n", "max_bbox_overlap", "=", "np", ".", "argmax", "(", "bbox_overlap", ",", "axis", "=", "1", ")", "\n", "max_overlap", "=", "np", ".", "ones", "(", "(", "gt_rois", ".", "shape", "[", "0", "]", ")", ",", "dtype", "=", "np", ".", "int32", ")", "*", "-", "1", "\n", "\n", "matched_gt", "=", "torch", ".", "ones_like", "(", "seg_gt", ")", "*", "-", "1", "\n", "matched_gt", "=", "torch", ".", "where", "(", "seg_gt", "<=", "config", ".", "dataset", ".", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", ",", "seg_gt", ",", "matched_gt", ")", "\n", "matched_gt", "=", "torch", ".", "where", "(", "seg_gt", ">=", "255", ",", "seg_gt", ",", "matched_gt", ")", "\n", "\n", "keep", "=", "np", ".", "ones", "(", "(", "rois", ".", "shape", "[", "0", "]", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "for", "i", "in", "range", "(", "rois", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "bbox_overlap", "[", "i", ",", "max_bbox_overlap", "[", "i", "]", "]", ">", "0.5", ":", "\n", "                ", "if", "max_overlap", "[", "max_bbox_overlap", "[", "i", "]", "]", "==", "-", "1", ":", "\n", "                    ", "max_overlap", "[", "max_bbox_overlap", "[", "i", "]", "]", "=", "i", "\n", "", "elif", "bbox_overlap", "[", "max_overlap", "[", "max_bbox_overlap", "[", "i", "]", "]", ",", "max_bbox_overlap", "[", "i", "]", "]", ">", "bbox_overlap", "[", "i", ",", "max_bbox_overlap", "[", "i", "]", "]", ":", "\n", "                    ", "keep", "[", "i", "]", "=", "0", "\n", "", "else", ":", "\n", "                    ", "keep", "[", "max_overlap", "[", "max_bbox_overlap", "[", "i", "]", "]", "]", "=", "0", "\n", "max_overlap", "[", "max_bbox_overlap", "[", "i", "]", "]", "=", "i", "\n", "", "", "elif", "cls_pred", "[", "i", "]", "==", "0", "and", "label", "[", "i", "]", "==", "0", ":", "\n", "                ", "keep", "[", "i", "]", "=", "0", "\n", "\n", "", "", "rois", "=", "rois", "[", "keep", "!=", "0", "]", "\n", "rois", "=", "np", ".", "hstack", "(", "(", "np", ".", "zeros", "(", "(", "rois", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "rois", ")", ")", "\n", "label", "=", "label", "[", "keep", "!=", "0", "]", "\n", "\n", "keep", "=", "np", ".", "cumsum", "(", "keep", ")", "\n", "if", "keep", "[", "-", "1", "]", "==", "0", ":", "\n", "            ", "print", "(", "max_overlap", ")", "\n", "print", "(", "max_bbox_overlap", ")", "\n", "print", "(", "cls_pred", ")", "\n", "assert", "keep", "[", "-", "1", "]", "!=", "0", "\n", "\n", "", "for", "i", "in", "range", "(", "max_overlap", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "max_overlap", "[", "i", "]", "!=", "-", "1", ":", "\n", "                ", "roi", "=", "np", ".", "round", "(", "rois", "[", "keep", "[", "max_overlap", "[", "i", "]", "]", "-", "1", "]", "/", "4", ")", "\n", "mask_gt_i", "=", "mask_gt", "[", "[", "i", "]", "]", "\n", "matched_gt", "[", "mask_gt_i", "!=", "0", "]", "=", "int", "(", "keep", "[", "max_overlap", "[", "i", "]", "]", "-", "1", "+", "self", ".", "num_seg_classes", "-", "self", ".", "num_inst_classes", ")", "\n", "\n", "", "", "if", "config", ".", "train", ".", "panoptic_box_keep_fraction", "<", "1", ":", "\n", "            ", "matched_gt", "[", "matched_gt", "==", "-", "1", "]", "=", "self", ".", "num_seg_classes", "-", "self", ".", "num_inst_classes", "+", "rois", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "matched_gt", "[", "matched_gt", "==", "-", "1", "]", "=", "255", "\n", "\n", "", "return", "torch", ".", "from_numpy", "(", "rois", ")", ".", "to", "(", "matched_gt", ".", "device", ")", ",", "torch", ".", "from_numpy", "(", "label", ")", ".", "to", "(", "matched_gt", ".", "device", ")", ",", "matched_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.pyramid_proposal.PyramidProposal.__init__": [[24, 35], ["torch.nn.modules.module.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["class", "PyramidProposalFunction", "(", "Function", ")", ":", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "feat_stride", ",", "scales", ",", "ratios", ",", "rpn_pre_nms_top_n", ",", "rpn_post_nms_top_n", ",", "threshold", ",", "rpn_min_size", ",", "individual_proposals", "=", "False", ",", "batch_idx", "=", "0", ",", "use_softnms", "=", "False", ",", "crowd_gt_roi", "=", "None", ")", ":", "\n", "        ", "super", "(", "PyramidProposalFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "feat_stride", "=", "feat_stride", "\n", "self", ".", "scales", "=", "np", ".", "array", "(", "scales", ")", "\n", "self", ".", "ratios", "=", "np", ".", "array", "(", "ratios", ")", "\n", "self", ".", "num_anchors", "=", "3", "\n", "self", ".", "rpn_pre_nms_top_n", "=", "rpn_pre_nms_top_n", "\n", "self", ".", "rpn_post_nms_top_n", "=", "rpn_post_nms_top_n", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "rpn_min_size", "=", "rpn_min_size", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.pyramid_proposal.PyramidProposal.forward": [[36, 68], ["range", "torch.sort", "pickle.loads", "functions.pyramid_proposal.PyramidProposalFunction", "functions.pyramid_proposal.PyramidProposalFunction.", "rois.append", "scores.append", "torch.cat", "torch.cat", "pickle.loads.astype().tobytes", "torch.from_numpy", "pickle.loads.astype", "numpy.where"], "methods", ["None"], ["self", ".", "individual_proposals", "=", "individual_proposals", "\n", "self", ".", "batch_idx", "=", "batch_idx", "\n", "self", ".", "use_softnms", "=", "use_softnms", "\n", "self", ".", "crowd_gt_roi", "=", "crowd_gt_roi", "\n", "\n", "", "def", "forward", "(", "self", ",", "cls_prob_p2", ",", "cls_prob_p3", ",", "cls_prob_p4", ",", "cls_prob_p5", ",", "cls_prob_p6", ",", "\n", "bbox_pred_p2", ",", "bbox_pred_p3", ",", "bbox_pred_p4", ",", "bbox_pred_p5", ",", "bbox_pred_p6", ",", "im_info", ")", ":", "\n", "        ", "device_id", "=", "cls_prob_p2", ".", "get_device", "(", ")", "\n", "nms", "=", "gpu_nms_wrapper", "(", "self", ".", "threshold", ",", "device_id", "=", "device_id", ")", "if", "not", "self", ".", "use_softnms", "else", "soft_nms_wrapper", "(", "self", ".", "threshold", ")", "\n", "context", "=", "torch", ".", "device", "(", "'cuda'", ",", "device_id", ")", "\n", "\n", "batch_size", "=", "cls_prob_p2", ".", "shape", "[", "0", "]", "\n", "if", "batch_size", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Sorry, multiple images each device is not implemented\"", ")", "\n", "\n", "# for each (H, W) location i", "\n", "#   generate A anchor boxes centered on cell i", "\n", "#   apply predicted bbox deltas at cell i to each of the A anchors", "\n", "# clip predicted boxes to image", "\n", "# remove predicted boxes with either height or width < threshold", "\n", "# sort all (proposal, score) pairs by score from highest to lowest", "\n", "# take top pre_nms_topN proposals before NMS", "\n", "# apply NMS with threshold 0.7 to remaining proposals", "\n", "# take after_nms_topN proposals after NMS", "\n", "# return the top proposals (-> RoIs top, scores top)", "\n", "\n", "", "cls_probs", "=", "[", "cls_prob_p2", ",", "cls_prob_p3", ",", "cls_prob_p4", ",", "cls_prob_p5", ",", "cls_prob_p6", "]", "\n", "bbox_preds", "=", "[", "bbox_pred_p2", ",", "bbox_pred_p3", ",", "bbox_pred_p4", ",", "bbox_pred_p5", ",", "bbox_pred_p6", "]", "\n", "\n", "pre_nms_topN", "=", "self", ".", "rpn_pre_nms_top_n", "\n", "post_nms_topN", "=", "self", ".", "rpn_post_nms_top_n", "\n", "min_size", "=", "self", ".", "rpn_min_size", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.proposal_target.ProposalTarget.__init__": [[20, 23], ["torch.nn.modules.module.Module.__init__", "functions.proposal_target.ProposalTargetFunction"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["\n", "\n", "class", "ProposalTargetFunction", "(", "Function", ")", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.proposal_target.ProposalTarget.forward": [[24, 26], ["proposal_target.ProposalTarget.proposal_target_function"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "num_classes", ",", "batch_images", ",", "batch_rois", ",", "fg_fraction", ")", ":", "\n", "        ", "super", "(", "ProposalTargetFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.unary_logits.MaskTerm.__init__": [[27, 32], ["torch.Module.__init__", "dict", "zip", "range", "range"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_seg_classes", ",", "box_scale", "=", "1", "/", "4.0", ",", "class_mapping", "=", "None", ")", ":", "\n", "        ", "super", "(", "MaskTerm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "class_mapping", "=", "dict", "(", "zip", "(", "range", "(", "1", ",", "config", ".", "dataset", ".", "num_classes", ")", ",", "range", "(", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", "+", "1", ",", "num_seg_classes", ")", ")", ")", "if", "class_mapping", "is", "None", "else", "class_mapping", "\n", "self", ".", "num_seg_classes", "=", "num_seg_classes", "\n", "self", ".", "box_scale", "=", "box_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.unary_logits.MaskTerm.forward": [[33, 67], ["cls_indices.cpu().numpy.cpu().numpy.cpu().numpy", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "boxes[].long", "max", "max", "torch.upsample", "torch.upsample", "torch.upsample", "max", "min", "max", "min", "cls_indices.cpu().numpy.cpu().numpy.cpu", "masks[].view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "masks", ",", "boxes", ",", "cls_indices", ",", "seg_score", ")", ":", "\n", "        ", "\"\"\"\n\n        :param masks: [num_boxes x c x 28 x 28]\n        :param boxes: [num_boxes x 5]\n        :param cls_indices: [num_boxes x 1]\n        :param seg_score: [1 x num_seg_classes x h x w]\n        :return: mask_energy: [1 x num_boxes x h x w]\n        \"\"\"", "\n", "\n", "assert", "seg_score", ".", "shape", "[", "0", "]", "==", "1", ",", "\"only support batch size = 1\"", "\n", "cls_indices", "=", "cls_indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# remove first dim which indicate batch id", "\n", "boxes", "=", "boxes", "[", ":", ",", "1", ":", "]", "*", "self", ".", "box_scale", "\n", "im_shape", "=", "seg_score", ".", "shape", "[", "2", ":", "]", "\n", "\n", "# [n x num_boxes x h x w]", "\n", "mask_energy", "=", "torch", ".", "zeros", "(", "(", "seg_score", ".", "shape", "[", "0", "]", ",", "masks", ".", "shape", "[", "0", "]", ",", "seg_score", ".", "shape", "[", "2", "]", ",", "seg_score", ".", "shape", "[", "3", "]", ")", ",", "device", "=", "seg_score", ".", "device", ")", "\n", "\n", "for", "i", "in", "range", "(", "cls_indices", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "ref_box", "=", "boxes", "[", "i", ",", ":", "]", ".", "long", "(", ")", "\n", "w", "=", "ref_box", "[", "2", "]", "-", "ref_box", "[", "0", "]", "+", "1", "\n", "h", "=", "ref_box", "[", "3", "]", "-", "ref_box", "[", "1", "]", "+", "1", "\n", "w", "=", "max", "(", "w", ",", "1", ")", "\n", "h", "=", "max", "(", "h", ",", "1", ")", "\n", "mask", "=", "F", ".", "upsample", "(", "masks", "[", "i", ",", "0", ",", ":", ",", ":", "]", ".", "view", "(", "1", ",", "1", ",", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ",", "size", "=", "(", "h", ",", "w", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "x_0", "=", "max", "(", "ref_box", "[", "0", "]", ",", "0", ")", "\n", "x_1", "=", "min", "(", "ref_box", "[", "2", "]", "+", "1", ",", "im_shape", "[", "1", "]", ")", "\n", "y_0", "=", "max", "(", "ref_box", "[", "1", "]", ",", "0", ")", "\n", "y_1", "=", "min", "(", "ref_box", "[", "3", "]", "+", "1", ",", "im_shape", "[", "0", "]", ")", "\n", "mask_energy", "[", "0", ",", "i", ",", "y_0", ":", "y_1", ",", "x_0", ":", "x_1", "]", "=", "mask", "[", "0", ",", "0", ",", "(", "y_0", "-", "ref_box", "[", "1", "]", ")", ":", "(", "y_1", "-", "ref_box", "[", "1", "]", ")", ",", "(", "x_0", "-", "ref_box", "[", "0", "]", ")", ":", "(", "x_1", "-", "ref_box", "[", "0", "]", ")", "]", "\n", "", "return", "mask_energy", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.unary_logits.SegTerm.__init__": [[71, 77], ["torch.Module.__init__", "len", "dict", "zip", "range", "range"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_seg_classes", ",", "box_scale", "=", "1", "/", "4.0", ",", "class_mapping", "=", "None", ",", "thresh", "=", "0.3", ")", ":", "\n", "        ", "super", "(", "SegTerm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "class_mapping", "=", "dict", "(", "zip", "(", "range", "(", "1", ",", "config", ".", "dataset", ".", "num_classes", ")", ",", "range", "(", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", "+", "1", ",", "num_seg_classes", ")", ")", ")", "if", "class_mapping", "is", "None", "else", "class_mapping", "\n", "self", ".", "num_seg_classes", "=", "num_seg_classes", "\n", "self", ".", "num_inst_classes", "=", "len", "(", "self", ".", "class_mapping", ")", "\n", "self", ".", "box_scale", "=", "box_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.unary_logits.SegTerm.forward": [[78, 106], ["cls_indices.cpu().numpy.cpu().numpy.cpu().numpy", "boxes.cpu().numpy.cpu().numpy.cpu().numpy", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "cls_indices.cpu().numpy.cpu().numpy.cpu", "boxes.cpu().numpy.cpu().numpy.cpu", "int", "int", "int", "int", "torch.ones_like().view", "torch.ones_like().view", "torch.ones_like().view", "torch.ones_like().view", "torch.ones_like().view", "torch.ones_like().view", "torch.ones_like().view", "torch.ones_like().view", "torch.ones_like().view", "[].round", "[].round", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "cls_indices", ",", "seg_score", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        :param cls_indices: [num_boxes x 1]\n        :param seg_score: [1 x num_seg_classes x h x w]\n        :return: seg_energy: [1 x (num_seg_classes - num_inst_classes + num_boxes) x h x w]\n        \"\"\"", "\n", "\n", "assert", "seg_score", ".", "shape", "[", "0", "]", "==", "1", ",", "\"only support batch size = 1\"", "\n", "cls_indices", "=", "cls_indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "seg_energy", "=", "seg_score", "[", "[", "0", "]", ",", ":", "-", "self", ".", "num_inst_classes", ",", ":", ",", ":", "]", "\n", "\n", "boxes", "=", "boxes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "boxes", "=", "boxes", "[", ":", ",", "1", ":", "]", "*", "self", ".", "box_scale", "\n", "\n", "if", "cls_indices", ".", "size", "==", "0", ":", "\n", "            ", "return", "seg_energy", ",", "torch", ".", "ones_like", "(", "seg_energy", "[", "[", "0", "]", ",", "[", "0", "]", ",", ":", ",", ":", "]", ")", ".", "view", "(", "1", ",", "1", ",", "seg_energy", ".", "shape", "[", "2", "]", ",", "seg_energy", ".", "shape", "[", "3", "]", ")", "*", "-", "10", "\n", "", "else", ":", "\n", "            ", "seg_inst_energy", "=", "torch", ".", "zeros", "(", "(", "seg_score", ".", "shape", "[", "0", "]", ",", "cls_indices", ".", "shape", "[", "0", "]", ",", "seg_score", ".", "shape", "[", "2", "]", ",", "seg_score", ".", "shape", "[", "3", "]", ")", ",", "device", "=", "seg_score", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "cls_indices", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "if", "cls_indices", "[", "i", "]", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "y0", "=", "int", "(", "boxes", "[", "i", "]", "[", "1", "]", ")", "\n", "y1", "=", "int", "(", "boxes", "[", "i", "]", "[", "3", "]", ".", "round", "(", ")", "+", "1", ")", "\n", "x0", "=", "int", "(", "boxes", "[", "i", "]", "[", "0", "]", ")", "\n", "x1", "=", "int", "(", "boxes", "[", "i", "]", "[", "2", "]", ".", "round", "(", ")", "+", "1", ")", "\n", "seg_inst_energy", "[", "0", ",", "i", ",", "y0", ":", "y1", ",", "x0", ":", "x1", "]", "=", "seg_score", "[", "0", ",", "self", ".", "class_mapping", "[", "cls_indices", "[", "i", "]", "]", ",", "y0", ":", "y1", ",", "x0", ":", "x1", "]", "\n", "\n", "", "return", "seg_energy", ",", "seg_inst_energy", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.fpn_roi_align.FPNRoIAlign.__init__": [[23, 31], ["torch.nn.modules.module.Module.__init__", "int", "int"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "pooled_height", ",", "pooled_width", ",", "spatial_scale", ",", "with_expand", "=", "False", ")", ":", "\n", "        ", "super", "(", "FPNRoIAlign", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "pooled_width", "=", "int", "(", "pooled_width", ")", "\n", "self", ".", "pooled_height", "=", "int", "(", "pooled_height", ")", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "with_expand", "=", "with_expand", "\n", "self", ".", "roi_pooling", "=", "RoIAlignFunction", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.modules.fpn_roi_align.FPNRoIAlign.forward": [[32, 63], ["torch.device", "rois.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "numpy.clip", "range", "torch.tensor().to", "range", "torch.cat", "torch.index_select", "feat[].get_device", "numpy.floor", "len", "torch.tensor().to", "torch.index_select.append", "rois.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "numpy.where", "len", "rois_fpn.append", "feat_no.append", "rois_fpn.append", "feat_no.append", "torch.tensor", "numpy.log2", "numpy.zeros", "torch.tensor", "fpn_roi_align.FPNRoIAlign.roi_pooling", "rois.detach().cpu().numpy.detach().cpu().numpy.detach", "numpy.argsort", "numpy.hstack", "numpy.sqrt"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feat", ",", "rois", ")", ":", "\n", "\n", "        ", "context", "=", "torch", ".", "device", "(", "'cuda'", ",", "feat", "[", "0", "]", ".", "get_device", "(", ")", ")", "\n", "rois", "=", "rois", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "w", "=", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", "+", "1", "\n", "h", "=", "rois", "[", ":", ",", "4", "]", "-", "rois", "[", ":", ",", "2", "]", "+", "1", "\n", "feat_id", "=", "np", ".", "clip", "(", "np", ".", "floor", "(", "2", "+", "np", ".", "log2", "(", "np", ".", "sqrt", "(", "w", "*", "h", ")", "/", "224", "+", "1e-6", ")", ")", ",", "0", ",", "3", ")", "\n", "feat_no", "=", "[", "]", "\n", "rois_fpn", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "feat_idx", "=", "np", ".", "where", "(", "feat_id", "==", "i", ")", "[", "0", "]", "\n", "if", "len", "(", "feat_idx", ")", "==", "0", ":", "\n", "                ", "rois_fpn", ".", "append", "(", "np", ".", "zeros", "(", "(", "1", ",", "5", ")", ")", ")", "\n", "feat_no", ".", "append", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "                ", "rois_fpn", ".", "append", "(", "rois", "[", "feat_idx", "]", ")", "\n", "feat_no", ".", "append", "(", "feat_idx", ")", "\n", "\n", "", "", "rois_index", "=", "torch", ".", "tensor", "(", "np", ".", "argsort", "(", "np", ".", "hstack", "(", "feat_no", ")", ")", "[", "-", "rois", ".", "shape", "[", "0", "]", ":", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "requires_grad", "=", "False", ")", ".", "to", "(", "context", ")", "\n", "\n", "\n", "pool_feat", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "spatial_scale", ")", ")", ":", "\n", "            ", "rois_fpn", "[", "i", "]", "=", "torch", ".", "tensor", "(", "rois_fpn", "[", "i", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "requires_grad", "=", "False", ")", ".", "to", "(", "context", ")", "\n", "pool_feat", ".", "append", "(", "\n", "self", ".", "roi_pooling", "(", "self", ".", "pooled_height", ",", "self", ".", "pooled_width", ",", "self", ".", "spatial_scale", "[", "i", "]", ")", "(", "feat", "[", "i", "]", ",", "rois_fpn", "[", "i", "]", ")", ")", "\n", "\n", "", "pool_feat", "=", "torch", ".", "cat", "(", "pool_feat", ",", "dim", "=", "0", ")", "\n", "pool_feat", "=", "torch", ".", "index_select", "(", "pool_feat", ",", "0", ",", "rois_index", ")", "\n", "return", "pool_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.nms.py_nms_wrapper": [[26, 30], ["nms.py_nms"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.nms.nms.py_nms"], ["def", "py_nms_wrapper", "(", "thresh", ")", ":", "\n", "    ", "def", "_nms", "(", "dets", ")", ":", "\n", "        ", "return", "py_nms", "(", "dets", ",", "thresh", ")", "\n", "", "return", "_nms", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.nms.py_soft_nms_wrapper": [[31, 35], ["py_soft_nms"], "function", ["None"], ["", "def", "py_soft_nms_wrapper", "(", "thresh", ")", ":", "\n", "    ", "def", "_nms", "(", "dets", ")", ":", "\n", "        ", "return", "py_soft_nms", "(", "dets", ",", "thresh", ")", "\n", "", "return", "_nms", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.nms.cpu_nms_wrapper": [[37, 41], ["cpu_nms.cpu_nms"], "function", ["None"], ["", "def", "cpu_nms_wrapper", "(", "thresh", ")", ":", "\n", "    ", "def", "_nms", "(", "dets", ")", ":", "\n", "        ", "return", "cpu_nms", "(", "dets", ",", "thresh", ")", "\n", "", "return", "_nms", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.nms.gpu_nms_wrapper": [[43, 47], ["gpu_nms.gpu_nms"], "function", ["None"], ["", "def", "gpu_nms_wrapper", "(", "thresh", ",", "device_id", ")", ":", "\n", "    ", "def", "_nms", "(", "dets", ")", ":", "\n", "        ", "return", "gpu_nms", "(", "dets", ",", "thresh", ",", "device_id", ")", "\n", "", "return", "_nms", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.nms.py_nms": [[48, 86], ["scores.argsort", "keep.append", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.where"], "function", ["None"], ["", "def", "py_nms", "(", "dets", ",", "thresh", ")", ":", "\n", "    ", "\"\"\"\n    greedily select boxes with high confidence and overlap with current maximum <= thresh\n    rule out overlap >= thresh\n    :param dets: [[x1, y1, x2, y2 score]]\n    :param thresh: retain overlap < thresh\n    :return: indexes to keep\n    \"\"\"", "\n", "if", "dets", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "[", "]", "\n", "\n", "", "x1", "=", "dets", "[", ":", ",", "0", "]", "\n", "y1", "=", "dets", "[", ":", ",", "1", "]", "\n", "x2", "=", "dets", "[", ":", ",", "2", "]", "\n", "y2", "=", "dets", "[", ":", ",", "3", "]", "\n", "scores", "=", "dets", "[", ":", ",", "4", "]", "\n", "\n", "areas", "=", "(", "x2", "-", "x1", "+", "1", ")", "*", "(", "y2", "-", "y1", "+", "1", ")", "\n", "order", "=", "scores", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "keep", "=", "[", "]", "\n", "while", "order", ".", "size", ">", "0", ":", "\n", "        ", "i", "=", "order", "[", "0", "]", "\n", "keep", ".", "append", "(", "i", ")", "\n", "xx1", "=", "np", ".", "maximum", "(", "x1", "[", "i", "]", ",", "x1", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "yy1", "=", "np", ".", "maximum", "(", "y1", "[", "i", "]", ",", "y1", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "xx2", "=", "np", ".", "minimum", "(", "x2", "[", "i", "]", ",", "x2", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "yy2", "=", "np", ".", "minimum", "(", "y2", "[", "i", "]", ",", "y2", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "\n", "w", "=", "np", ".", "maximum", "(", "0.0", ",", "xx2", "-", "xx1", "+", "1", ")", "\n", "h", "=", "np", ".", "maximum", "(", "0.0", ",", "yy2", "-", "yy1", "+", "1", ")", "\n", "inter", "=", "w", "*", "h", "\n", "ovr", "=", "inter", "/", "(", "areas", "[", "i", "]", "+", "areas", "[", "order", "[", "1", ":", "]", "]", "-", "inter", ")", "\n", "\n", "inds", "=", "np", ".", "where", "(", "ovr", "<=", "thresh", ")", "[", "0", "]", "\n", "order", "=", "order", "[", "inds", "+", "1", "]", "\n", "\n", "", "return", "keep", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.py_cpu_nms.py_cpu_nms": [[16, 45], ["scores.argsort", "keep.append", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.where"], "function", ["None"], ["def", "py_cpu_nms", "(", "dets", ",", "thresh", ")", ":", "\n", "    ", "\"\"\"Pure Python NMS baseline.\"\"\"", "\n", "x1", "=", "dets", "[", ":", ",", "0", "]", "\n", "y1", "=", "dets", "[", ":", ",", "1", "]", "\n", "x2", "=", "dets", "[", ":", ",", "2", "]", "\n", "y2", "=", "dets", "[", ":", ",", "3", "]", "\n", "scores", "=", "dets", "[", ":", ",", "4", "]", "\n", "\n", "areas", "=", "(", "x2", "-", "x1", "+", "1", ")", "*", "(", "y2", "-", "y1", "+", "1", ")", "\n", "order", "=", "scores", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "keep", "=", "[", "]", "\n", "while", "order", ".", "size", ">", "0", ":", "\n", "        ", "i", "=", "order", "[", "0", "]", "\n", "keep", ".", "append", "(", "i", ")", "\n", "xx1", "=", "np", ".", "maximum", "(", "x1", "[", "i", "]", ",", "x1", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "yy1", "=", "np", ".", "maximum", "(", "y1", "[", "i", "]", ",", "y1", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "xx2", "=", "np", ".", "minimum", "(", "x2", "[", "i", "]", ",", "x2", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "yy2", "=", "np", ".", "minimum", "(", "y2", "[", "i", "]", ",", "y2", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "\n", "w", "=", "np", ".", "maximum", "(", "0.0", ",", "xx2", "-", "xx1", "+", "1", ")", "\n", "h", "=", "np", ".", "maximum", "(", "0.0", ",", "yy2", "-", "yy1", "+", "1", ")", "\n", "inter", "=", "w", "*", "h", "\n", "ovr", "=", "inter", "/", "(", "areas", "[", "i", "]", "+", "areas", "[", "order", "[", "1", ":", "]", "]", "-", "inter", ")", "\n", "\n", "inds", "=", "np", ".", "where", "(", "ovr", "<=", "thresh", ")", "[", "0", "]", "\n", "order", "=", "order", "[", "inds", "+", "1", "]", "\n", "\n", "", "return", "keep", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.setup.custom_build_ext.build_extensions": [[111, 114], ["setup.customize_compiler_for_nvcc", "Cython.Distutils.build_ext.build_extensions"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.setup.customize_compiler_for_nvcc", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.setup.custom_build_ext.build_extensions"], ["\n", "# run the customize_compiler", "\n", "", "class", "custom_build_ext", "(", "build_ext", ")", ":", "\n", "    ", "def", "build_extensions", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.setup.find_in_path": [[22, 31], ["path.split", "os.path.join", "os.path.exists", "os.path.abspath"], "function", ["None"], ["def", "find_in_path", "(", "name", ",", "path", ")", ":", "\n", "    ", "\"Find a file in a search path\"", "\n", "# Adapted fom", "\n", "# http://code.activestate.com/recipes/52224-find-a-file-given-a-search-path/", "\n", "for", "dir", "in", "path", ".", "split", "(", "os", ".", "pathsep", ")", ":", "\n", "        ", "binpath", "=", "pjoin", "(", "dir", ",", "name", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "binpath", ")", ":", "\n", "            ", "return", "os", ".", "path", ".", "abspath", "(", "binpath", ")", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.setup.locate_cuda": [[33, 62], ["cudaconfig.items", "os.path.join", "os.path.join", "setup.find_in_path", "os.path.dirname", "os.path.join", "os.path.join", "EnvironmentError", "os.path.dirname", "os.path.exists", "EnvironmentError"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.nms.setup.find_in_path"], ["", "def", "locate_cuda", "(", ")", ":", "\n", "    ", "\"\"\"Locate the CUDA environment on the system\n\n    Returns a dict with keys 'home', 'nvcc', 'include', and 'lib64'\n    and values giving the absolute path to each directory.\n\n    Starts by looking for the CUDAHOME env variable. If not found, everything\n    is based on finding 'nvcc' in the PATH.\n    \"\"\"", "\n", "\n", "# first check if the CUDAHOME env variable is in use", "\n", "if", "'CUDAHOME'", "in", "os", ".", "environ", ":", "\n", "        ", "home", "=", "os", ".", "environ", "[", "'CUDAHOME'", "]", "\n", "nvcc", "=", "pjoin", "(", "home", ",", "'bin'", ",", "'nvcc'", ")", "\n", "", "else", ":", "\n", "# otherwise, search the PATH for NVCC", "\n", "        ", "default_path", "=", "pjoin", "(", "os", ".", "sep", ",", "'usr'", ",", "'local'", ",", "'cuda'", ",", "'bin'", ")", "\n", "nvcc", "=", "find_in_path", "(", "'nvcc'", ",", "os", ".", "environ", "[", "'PATH'", "]", "+", "os", ".", "pathsep", "+", "default_path", ")", "\n", "if", "nvcc", "is", "None", ":", "\n", "            ", "raise", "EnvironmentError", "(", "'The nvcc binary could not be '", "\n", "'located in your $PATH. Either add it to your path, or set $CUDAHOME'", ")", "\n", "", "home", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "nvcc", ")", ")", "\n", "\n", "", "cudaconfig", "=", "{", "'home'", ":", "home", ",", "'nvcc'", ":", "nvcc", ",", "\n", "'include'", ":", "pjoin", "(", "home", ",", "'include'", ")", ",", "\n", "'lib64'", ":", "pjoin", "(", "home", ",", "'lib64'", ")", "}", "\n", "for", "k", ",", "v", "in", "cudaconfig", ".", "items", "(", ")", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "v", ")", ":", "\n", "            ", "raise", "EnvironmentError", "(", "'The CUDA %s path could not be located in %s'", "%", "(", "k", ",", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.nms.setup.customize_compiler_for_nvcc": [[72, 107], ["setup..src_extensions.append", "setup..set_executable", "os.path.splitext"], "function", ["None"], ["\n", "\n", "", "def", "customize_compiler_for_nvcc", "(", "self", ")", ":", "\n", "    ", "\"\"\"inject deep into distutils to customize how the dispatch\n    to gcc/nvcc works.\n\n    If you subclass UnixCCompiler, it's not trivial to get your subclass\n    injected in, and still have the right customizations (i.e.\n    distutils.sysconfig.customize_compiler) run on it. So instead of going\n    the OO route, I have this. Note, it's kindof like a wierd functional\n    subclassing going on.\"\"\"", "\n", "\n", "# tell the compiler it can processes .cu", "\n", "self", ".", "src_extensions", ".", "append", "(", "'.cu'", ")", "\n", "\n", "# save references to the default compiler_so and _comple methods", "\n", "default_compiler_so", "=", "self", ".", "compiler_so", "\n", "super", "=", "self", ".", "_compile", "\n", "\n", "# now redefine the _compile method. This gets executed for each", "\n", "# object but distutils doesn't have the ability to change compilers", "\n", "# based on source extension: we add it.", "\n", "def", "_compile", "(", "obj", ",", "src", ",", "ext", ",", "cc_args", ",", "extra_postargs", ",", "pp_opts", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "splitext", "(", "src", ")", "[", "1", "]", "==", "'.cu'", ":", "\n", "# use the cuda for .cu files", "\n", "            ", "self", ".", "set_executable", "(", "'compiler_so'", ",", "CUDA", "[", "'nvcc'", "]", ")", "\n", "# use only a subset of the extra_postargs, which are 1-1 translated", "\n", "# from the extra_compile_args in the Extension class", "\n", "postargs", "=", "extra_postargs", "[", "'nvcc'", "]", "\n", "", "else", ":", "\n", "            ", "postargs", "=", "extra_postargs", "[", "'gcc'", "]", "\n", "\n", "", "super", "(", "obj", ",", "src", ",", "ext", ",", "cc_args", ",", "postargs", ",", "pp_opts", ")", "\n", "# reset the default compiler_so, which we might have changed for cuda", "\n", "self", ".", "compiler_so", "=", "default_compiler_so", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.coco.coco.__init__": [[43, 120], ["upsnet.dataset.base_dataset.BaseDataset.__init__", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "zip", "upsnet.dataset.json_dataset.filter_for_training", "upsnet.dataset.json_dataset.add_bbox_regression_targets", "upsnet.dataset.json_dataset.JsonDataset", "coco.coco.dataset.get_roidb", "len", "len", "upsnet.dataset.json_dataset.JsonDataset", "upsnet.dataset.json_dataset.JsonDataset.get_roidb", "roidbs.append", "upsnet.dataset.json_dataset.filter_for_training.extend", "len", "upsnet.dataset.json_dataset.extend_with_flipped_entries", "upsnet.dataset.json_dataset.filter_for_training", "upsnet.dataset.json_dataset.add_bbox_regression_targets", "upsnet.dataset.json_dataset.extend_with_flipped_entries", "os.path.join", "lib.utils.logging.logger.info", "os.path.join", "lib.utils.logging.logger.info"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.filter_for_training", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.add_bbox_regression_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.get_roidb", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.get_roidb", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.extend_with_flipped_entries", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.filter_for_training", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.add_bbox_regression_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.extend_with_flipped_entries"], ["    ", "def", "__init__", "(", "self", ",", "image_sets", ",", "flip", "=", "False", ",", "proposal_files", "=", "None", ",", "phase", "=", "'train'", ",", "result_path", "=", "''", ")", ":", "\n", "\n", "        ", "super", "(", "coco", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "image_dirs", "=", "{", "\n", "'train2014'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'coco_train2014'", ")", ",", "\n", "'val2014'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'coco_val2014'", ")", ",", "\n", "'minival2014'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'coco_val2014'", ")", ",", "\n", "'valminusminival2014'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'coco_val2014'", ")", ",", "\n", "'test2015'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'coco_test2015'", ")", ",", "\n", "'test-dev2015'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'coco_test2015'", ")", ",", "\n", "'train2017'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ",", "'train2017'", ")", ",", "\n", "'val2017'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ",", "'val2017'", ")", ",", "\n", "'test-dev2017'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ",", "'test2017'", ")", ",", "\n", "}", "\n", "\n", "anno_files", "=", "{", "\n", "'train2014'", ":", "'instances_train2014.json'", ",", "\n", "'val2014'", ":", "'instances_val2014.json'", ",", "\n", "'minival2014'", ":", "'instances_minival2014.json'", ",", "\n", "'valminusminival2014'", ":", "'instances_valminusminival2014.json'", ",", "\n", "'test2015'", ":", "'image_info_test2015.json'", ",", "\n", "'test-dev2015'", ":", "'image_info_test-dev2015.json'", ",", "\n", "'train2017'", ":", "'instances_train2017.json'", ",", "\n", "'val2017'", ":", "'instances_val2017.json'", ",", "\n", "'test-dev2017'", ":", "'image_info_test-dev2017.json'", ",", "\n", "}", "\n", "\n", "if", "image_sets", "[", "0", "]", "==", "'test-dev2017'", ":", "\n", "            ", "self", ".", "panoptic_json_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "'image_info_test-dev2017.json'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "panoptic_json_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "'panoptic_val2017_stff.json'", ")", "\n", "self", ".", "panoptic_gt_folder", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "'panoptic_val2017'", ")", "\n", "\n", "", "if", "proposal_files", "is", "None", ":", "\n", "            ", "proposal_files", "=", "[", "None", "]", "*", "len", "(", "image_sets", ")", "\n", "\n", "", "if", "phase", "==", "'train'", "and", "len", "(", "image_sets", ")", ">", "1", ":", "\n", "# combine multiple datasets", "\n", "            ", "roidbs", "=", "[", "]", "\n", "for", "image_set", ",", "proposal_file", "in", "zip", "(", "image_sets", ",", "proposal_files", ")", ":", "\n", "                ", "dataset", "=", "JsonDataset", "(", "'coco_'", "+", "image_set", ",", "\n", "image_dir", "=", "image_dirs", "[", "image_set", "]", ",", "\n", "anno_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "anno_files", "[", "image_set", "]", ")", ")", "\n", "roidb", "=", "dataset", ".", "get_roidb", "(", "gt", "=", "True", ",", "proposal_file", "=", "proposal_file", ",", "crowd_filter_thresh", "=", "config", ".", "train", ".", "crowd_filter_thresh", ")", "\n", "if", "flip", ":", "\n", "                    ", "if", "logger", ":", "\n", "                        ", "logger", ".", "info", "(", "'Appending horizontally-flipped training examples...'", ")", "\n", "", "extend_with_flipped_entries", "(", "roidb", ",", "dataset", ")", "\n", "", "roidbs", ".", "append", "(", "roidb", ")", "\n", "", "roidb", "=", "roidbs", "[", "0", "]", "\n", "for", "r", "in", "roidbs", "[", "1", ":", "]", ":", "\n", "                ", "roidb", ".", "extend", "(", "r", ")", "\n", "", "roidb", "=", "filter_for_training", "(", "roidb", ")", "\n", "add_bbox_regression_targets", "(", "roidb", ")", "\n", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "image_sets", ")", "==", "1", "\n", "self", ".", "dataset", "=", "JsonDataset", "(", "'coco_'", "+", "image_sets", "[", "0", "]", ",", "\n", "image_dir", "=", "image_dirs", "[", "image_sets", "[", "0", "]", "]", ",", "\n", "anno_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "\n", "anno_files", "[", "image_sets", "[", "0", "]", "]", ")", ")", "\n", "roidb", "=", "self", ".", "dataset", ".", "get_roidb", "(", "gt", "=", "True", ",", "proposal_file", "=", "proposal_files", "[", "0", "]", ",", "\n", "crowd_filter_thresh", "=", "config", ".", "train", ".", "crowd_filter_thresh", "if", "phase", "!=", "'test'", "else", "0", ")", "\n", "if", "flip", ":", "\n", "                ", "if", "logger", ":", "\n", "                    ", "logger", ".", "info", "(", "'Appending horizontally-flipped training examples...'", ")", "\n", "", "extend_with_flipped_entries", "(", "roidb", ",", "self", ".", "dataset", ")", "\n", "", "if", "phase", "!=", "'test'", ":", "\n", "                ", "roidb", "=", "filter_for_training", "(", "roidb", ")", "\n", "add_bbox_regression_targets", "(", "roidb", ")", "\n", "\n", "", "", "self", ".", "roidb", "=", "roidb", "\n", "self", ".", "phase", "=", "phase", "\n", "self", ".", "flip", "=", "flip", "\n", "self", ".", "result_path", "=", "result_path", "\n", "self", ".", "num_classes", "=", "81", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.coco.coco.__len__": [[121, 123], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "roidb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.coco.coco.__getitem__": [[124, 192], ["collections.defaultdict", "coco.coco.get_image_blob", "upsnet.rpn.assign_anchor.add_rpn_blobs", "numpy.array", "cv2.resize", "label.update", "label.update", "label.update", "range", "label.update", "numpy.array", "PIL.Image.open", "numpy.fliplr", "len", "numpy.around().astype", "label.update", "range", "[].replace().replace().replace().replace", "numpy.zeros", "PIL.Image.new", "range", "cv2.resize", "len", "cv2.resize", "blob[].astype", "type", "type", "len", "PIL.ImageDraw.Draw().polygon", "numpy.array", "type", "cv2.resize", "pycocotools.decode", "cv2.resize", "numpy.around", "numpy.zeros", "[].replace().replace().replace", "len", "int", "int", "tuple", "type", "type", "len", "numpy.where", "numpy.round", "numpy.round", "PIL.ImageDraw.Draw", "pycocotools.decode", "len", "[].replace().replace", "pycocotools.frPyObjects", "[].replace"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_image_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor.add_rpn_blobs", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "blob", "=", "defaultdict", "(", "list", ")", "\n", "im_blob", ",", "im_scales", "=", "self", ".", "get_image_blob", "(", "[", "self", ".", "roidb", "[", "index", "]", "]", ")", "\n", "if", "config", ".", "network", ".", "has_rpn", ":", "\n", "            ", "if", "self", ".", "phase", "!=", "'test'", ":", "\n", "                ", "add_rpn_blobs", "(", "blob", ",", "im_scales", ",", "[", "self", ".", "roidb", "[", "index", "]", "]", ")", "\n", "data", "=", "{", "'data'", ":", "im_blob", ",", "\n", "'im_info'", ":", "blob", "[", "'im_info'", "]", "}", "\n", "label", "=", "{", "'roidb'", ":", "blob", "[", "'roidb'", "]", "[", "0", "]", "}", "\n", "for", "stride", "in", "config", ".", "network", ".", "rpn_feat_stride", ":", "\n", "                    ", "label", ".", "update", "(", "{", "\n", "'rpn_labels_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "'rpn_labels_int32_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ".", "astype", "(", "\n", "np", ".", "int64", ")", ",", "\n", "'rpn_bbox_targets_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "'rpn_bbox_targets_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ",", "\n", "'rpn_bbox_inside_weights_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "\n", "'rpn_bbox_inside_weights_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ",", "\n", "'rpn_bbox_outside_weights_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "\n", "'rpn_bbox_outside_weights_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", "\n", "}", ")", "\n", "", "", "else", ":", "\n", "                ", "data", "=", "{", "'data'", ":", "im_blob", ",", "\n", "'im_info'", ":", "np", ".", "array", "(", "[", "[", "im_blob", ".", "shape", "[", "-", "2", "]", ",", "\n", "im_blob", ".", "shape", "[", "-", "1", "]", ",", "\n", "im_scales", "[", "0", "]", "]", "]", ",", "np", ".", "float32", ")", "}", "\n", "label", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "            ", "if", "self", ".", "phase", "!=", "'test'", ":", "\n", "                ", "seg_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "self", ".", "roidb", "[", "index", "]", "[", "'image'", "]", ".", "replace", "(", "'images'", ",", "'annotations'", ")", ".", "replace", "(", "'train2017'", ",", "'panoptic_train2017_semantic_trainid_stff'", ")", ".", "replace", "(", "'val2017'", ",", "'panoptic_val2017_semantic_trainid_stff'", ")", ".", "replace", "(", "'jpg'", ",", "'png'", ")", ")", ")", "\n", "if", "self", ".", "roidb", "[", "index", "]", "[", "'flipped'", "]", ":", "\n", "                    ", "seg_gt", "=", "np", ".", "fliplr", "(", "seg_gt", ")", "\n", "", "seg_gt", "=", "cv2", ".", "resize", "(", "seg_gt", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "label", ".", "update", "(", "{", "'seg_gt'", ":", "seg_gt", "}", ")", "\n", "label", ".", "update", "(", "{", "'gt_classes'", ":", "label", "[", "'roidb'", "]", "[", "'gt_classes'", "]", "[", "label", "[", "'roidb'", "]", "[", "'is_crowd'", "]", "==", "0", "]", "}", ")", "\n", "label", ".", "update", "(", "{", "'mask_gt'", ":", "np", ".", "zeros", "(", "(", "len", "(", "label", "[", "'gt_classes'", "]", ")", ",", "im_blob", ".", "shape", "[", "-", "2", "]", ",", "im_blob", ".", "shape", "[", "-", "1", "]", ")", ")", "}", ")", "\n", "idx", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "label", "[", "'roidb'", "]", "[", "'gt_classes'", "]", ")", ")", ":", "\n", "                    ", "if", "label", "[", "'roidb'", "]", "[", "'is_crowd'", "]", "[", "i", "]", "!=", "0", ":", "\n", "                        ", "continue", "\n", "", "if", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "is", "list", "and", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "0", "]", ")", "is", "list", ":", "\n", "                        ", "img", "=", "Image", ".", "new", "(", "'L'", ",", "(", "int", "(", "np", ".", "round", "(", "im_blob", ".", "shape", "[", "-", "1", "]", "/", "im_scales", "[", "0", "]", ")", ")", ",", "int", "(", "np", ".", "round", "(", "im_blob", ".", "shape", "[", "-", "2", "]", "/", "im_scales", "[", "0", "]", ")", ")", ")", ",", "0", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", ")", ":", "\n", "                            ", "ImageDraw", ".", "Draw", "(", "img", ")", ".", "polygon", "(", "tuple", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "j", "]", ")", ",", "outline", "=", "1", ",", "fill", "=", "1", ")", "\n", "", "label", "[", "'mask_gt'", "]", "[", "idx", "]", "=", "cv2", ".", "resize", "(", "np", ".", "array", "(", "img", ")", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "else", ":", "\n", "                        ", "assert", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "is", "dict", "or", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "0", "]", ")", "is", "dict", "\n", "if", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "is", "dict", ":", "\n", "                            ", "label", "[", "'mask_gt'", "]", "[", "idx", "]", "=", "cv2", ".", "resize", "(", "mask_util", ".", "decode", "(", "mask_util", ".", "frPyObjects", "(", "[", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "]", ",", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "'size'", "]", "[", "0", "]", ",", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "'size'", "]", "[", "1", "]", ")", ")", "[", ":", ",", ":", ",", "0", "]", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "else", ":", "\n", "                            ", "assert", "len", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "==", "1", "\n", "output", "=", "mask_util", ".", "decode", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "\n", "label", "[", "'mask_gt'", "]", "[", "idx", "]", "=", "cv2", ".", "resize", "(", "output", "[", ":", ",", ":", ",", "0", "]", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "", "idx", "+=", "1", "\n", "", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "                    ", "gt_boxes", "=", "label", "[", "'roidb'", "]", "[", "'boxes'", "]", "[", "np", ".", "where", "(", "(", "label", "[", "'roidb'", "]", "[", "'gt_classes'", "]", ">", "0", ")", "&", "(", "label", "[", "'roidb'", "]", "[", "'is_crowd'", "]", "==", "0", ")", ")", "[", "0", "]", "]", "\n", "gt_boxes", "=", "np", ".", "around", "(", "gt_boxes", "*", "im_scales", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "label", ".", "update", "(", "{", "'seg_roi_gt'", ":", "np", ".", "zeros", "(", "(", "len", "(", "gt_boxes", ")", ",", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ",", "dtype", "=", "np", ".", "int64", ")", "}", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "gt_boxes", ")", ")", ":", "\n", "                        ", "if", "gt_boxes", "[", "i", "]", "[", "3", "]", "==", "gt_boxes", "[", "i", "]", "[", "1", "]", ":", "\n", "                            ", "gt_boxes", "[", "i", "]", "[", "3", "]", "+=", "1", "\n", "", "if", "gt_boxes", "[", "i", "]", "[", "2", "]", "==", "gt_boxes", "[", "i", "]", "[", "0", "]", ":", "\n", "                            ", "gt_boxes", "[", "i", "]", "[", "2", "]", "+=", "1", "\n", "", "label", "[", "'seg_roi_gt'", "]", "[", "i", "]", "=", "cv2", ".", "resize", "(", "seg_gt", "[", "gt_boxes", "[", "i", "]", "[", "1", "]", ":", "gt_boxes", "[", "i", "]", "[", "3", "]", ",", "gt_boxes", "[", "i", "]", "[", "0", "]", ":", "gt_boxes", "[", "i", "]", "[", "2", "]", "]", ",", "(", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "", "", "else", ":", "\n", "                ", "pass", "\n", "\n", "", "", "return", "data", ",", "label", ",", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.coco.coco.evaluate_masks": [[194, 223], ["os.path.join", "enumerate", "coco.coco.dataset.COCO.loadRes", "pycocotools.cocoeval.COCOeval", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "coco.coco.log_detection_eval_metrics", "results.extend", "lib.utils.logging.logger.info", "open", "json.dump", "str", "os.path.join", "len", "coco.coco.segms_results_one_category", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.log_detection_eval_metrics", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.segms_results_one_category"], ["", "def", "evaluate_masks", "(", "\n", "self", ",", "\n", "all_boxes", ",", "\n", "all_segms", ",", "\n", "output_dir", ",", "\n", ")", ":", "\n", "        ", "res_file", "=", "os", ".", "path", ".", "join", "(", "\n", "output_dir", ",", "'segmentations_'", "+", "self", ".", "dataset", ".", "name", "+", "'_results.json'", "\n", ")", "\n", "results", "=", "[", "]", "\n", "for", "cls_ind", ",", "cls", "in", "enumerate", "(", "self", ".", "dataset", ".", "classes", ")", ":", "\n", "            ", "if", "cls", "==", "'__background__'", ":", "\n", "                ", "continue", "\n", "", "if", "cls_ind", ">=", "len", "(", "all_boxes", ")", ":", "\n", "                ", "break", "\n", "", "cat_id", "=", "self", ".", "dataset", ".", "category_to_id_map", "[", "cls", "]", "\n", "results", ".", "extend", "(", "self", ".", "segms_results_one_category", "(", "all_boxes", "[", "cls_ind", "]", ",", "all_segms", "[", "cls_ind", "]", ",", "cat_id", ")", ")", "\n", "", "if", "logger", ":", "\n", "            ", "logger", ".", "info", "(", "\n", "'Writing segmentation results json to: {}'", ".", "format", "(", "\n", "os", ".", "path", ".", "abspath", "(", "res_file", ")", ")", ")", "\n", "", "with", "open", "(", "res_file", ",", "'w'", ")", "as", "fid", ":", "\n", "            ", "json", ".", "dump", "(", "results", ",", "fid", ")", "\n", "", "coco_dt", "=", "self", ".", "dataset", ".", "COCO", ".", "loadRes", "(", "str", "(", "res_file", ")", ")", "\n", "coco_eval", "=", "COCOeval", "(", "self", ".", "dataset", ".", "COCO", ",", "coco_dt", ",", "'segm'", ")", "\n", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "self", ".", "log_detection_eval_metrics", "(", "coco_eval", ",", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'detection_results.txt'", ")", ")", "\n", "return", "coco_eval", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.coco.coco.evaluate_ssegs": [[225, 273], ["coco.coco.write_segmentation_result", "numpy.zeros", "enumerate", "re.sub.sum", "re.sub.sum", "numpy.diag", "IU_array.mean", "lib.utils.logging.logger.info", "coco.coco.evaluate_ssegs.convert_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.write_segmentation_result"], ["", "def", "evaluate_ssegs", "(", "self", ",", "pred_segmentations", ",", "res_file_folder", ")", ":", "\n", "        ", "self", ".", "write_segmentation_result", "(", "pred_segmentations", ",", "res_file_folder", ")", "\n", "\n", "confusion_matrix", "=", "np", ".", "zeros", "(", "(", "config", ".", "dataset", ".", "num_seg_classes", ",", "config", ".", "dataset", ".", "num_seg_classes", ")", ")", "\n", "for", "i", ",", "roidb", "in", "enumerate", "(", "self", ".", "roidb", ")", ":", "\n", "\n", "            ", "seg_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "self", ".", "roidb", "[", "i", "]", "[", "'image'", "]", ".", "replace", "(", "'images'", ",", "'annotations'", ")", ".", "replace", "(", "'train2017'", ",", "'panoptic_train2017_semantic_trainid_stff'", ")", ".", "replace", "(", "'val2017'", ",", "'panoptic_val2017_semantic_trainid_stff'", ")", ".", "replace", "(", "'jpg'", ",", "'png'", ")", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "seg_pathes", "=", "os", ".", "path", ".", "split", "(", "roidb", "[", "'image'", "]", ")", "\n", "res_image_name", "=", "seg_pathes", "[", "-", "1", "]", "\n", "res_save_path", "=", "os", ".", "path", ".", "join", "(", "res_file_folder", ",", "res_image_name", "+", "'.png'", ")", "\n", "\n", "seg_pred", "=", "Image", ".", "open", "(", "res_save_path", ")", "\n", "\n", "seg_pred", "=", "np", ".", "array", "(", "seg_pred", ".", "resize", "(", "(", "seg_gt", ".", "shape", "[", "1", "]", ",", "seg_gt", ".", "shape", "[", "0", "]", ")", ",", "Image", ".", "NEAREST", ")", ")", "\n", "ignore_index", "=", "seg_gt", "!=", "255", "\n", "seg_gt", "=", "seg_gt", "[", "ignore_index", "]", "\n", "seg_pred", "=", "seg_pred", "[", "ignore_index", "]", "\n", "\n", "confusion_matrix", "+=", "self", ".", "get_confusion_matrix", "(", "seg_gt", ",", "seg_pred", ",", "config", ".", "dataset", ".", "num_seg_classes", ")", "\n", "\n", "", "pos", "=", "confusion_matrix", ".", "sum", "(", "1", ")", "\n", "res", "=", "confusion_matrix", ".", "sum", "(", "0", ")", "\n", "tp", "=", "np", ".", "diag", "(", "confusion_matrix", ")", "\n", "\n", "IU_array", "=", "(", "tp", "/", "np", ".", "maximum", "(", "1.0", ",", "pos", "+", "res", "-", "tp", ")", ")", "\n", "mean_IU", "=", "IU_array", ".", "mean", "(", ")", "\n", "\n", "evaluation_results", "=", "{", "'meanIU'", ":", "mean_IU", ",", "'IU_array'", ":", "IU_array", ",", "'confusion_matrix'", ":", "confusion_matrix", "}", "\n", "\n", "def", "convert_confusion_matrix", "(", "confusion_matrix", ")", ":", "\n", "            ", "cls_sum", "=", "confusion_matrix", ".", "sum", "(", "axis", "=", "1", ")", "\n", "confusion_matrix", "=", "confusion_matrix", "/", "cls_sum", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "return", "confusion_matrix", "\n", "\n", "", "logger", ".", "info", "(", "'evaluate segmentation:'", ")", "\n", "meanIU", "=", "evaluation_results", "[", "'meanIU'", "]", "\n", "IU_array", "=", "evaluation_results", "[", "'IU_array'", "]", "\n", "confusion_matrix", "=", "convert_confusion_matrix", "(", "evaluation_results", "[", "'confusion_matrix'", "]", ")", "\n", "logger", ".", "info", "(", "'IU_array:'", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "IU_array", ")", ")", ":", "\n", "            ", "logger", ".", "info", "(", "'%.5f'", "%", "IU_array", "[", "i", "]", ")", "\n", "", "logger", ".", "info", "(", "'meanIU:%.5f'", "%", "meanIU", ")", "\n", "np", ".", "set_printoptions", "(", "precision", "=", "3", ",", "suppress", "=", "True", ",", "linewidth", "=", "200", ")", "\n", "import", "re", "\n", "confusion_matrix", "=", "re", ".", "sub", "(", "'[\\[\\]]'", ",", "''", ",", "np", ".", "array2string", "(", "confusion_matrix", ",", "separator", "=", "'\\t'", ")", ")", "\n", "logger", ".", "info", "(", "'confusion_matrix:'", ")", "\n", "logger", ".", "info", "(", "confusion_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.coco.coco.write_segmentation_result": [[275, 294], ["enumerate", "os.path.exists", "os.mkdir", "os.path.split", "os.path.join", "numpy.uint8", "PIL.Image.fromarray", "PIL.Image.fromarray.save", "numpy.squeeze", "numpy.copy"], "methods", ["None"], ["", "def", "write_segmentation_result", "(", "self", ",", "segmentation_results", ",", "res_file_folder", ")", ":", "\n", "        ", "\"\"\"\n        Write the segmentation result to result_file_folder\n        :param segmentation_results: the prediction result\n        :param result_file_folder: the saving folder\n        :return: [None]\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "res_file_folder", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "res_file_folder", ")", "\n", "\n", "", "for", "i", ",", "roidb", "in", "enumerate", "(", "self", ".", "roidb", ")", ":", "\n", "\n", "            ", "seg_pathes", "=", "os", ".", "path", ".", "split", "(", "roidb", "[", "'image'", "]", ")", "\n", "res_image_name", "=", "seg_pathes", "[", "-", "1", "]", "\n", "res_save_path", "=", "os", ".", "path", ".", "join", "(", "res_file_folder", ",", "res_image_name", "+", "'.png'", ")", "\n", "\n", "segmentation_result", "=", "np", ".", "uint8", "(", "np", ".", "squeeze", "(", "np", ".", "copy", "(", "segmentation_results", "[", "i", "]", ")", ")", ")", "\n", "segmentation_result", "=", "Image", ".", "fromarray", "(", "segmentation_result", ")", "\n", "segmentation_result", ".", "save", "(", "res_save_path", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.__init__": [[61, 85], ["pycocotools.coco.COCO", "lib.utils.timer.Timer", "json_dataset.JsonDataset.COCO.getCatIds", "dict", "len", "lib.utils.logging.logger.info", "zip", "json_dataset.JsonDataset.COCO.loadCats", "enumerate", "json_dataset.JsonDataset.json_category_id_to_contiguous_id.items", "json_dataset.JsonDataset.COCO.getCatIds"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ",", "image_dir", ",", "anno_file", ")", ":", "\n", "        ", "if", "logger", ":", "\n", "            ", "logger", ".", "info", "(", "'Creating: {}'", ".", "format", "(", "name", ")", ")", "\n", "", "self", ".", "name", "=", "name", "\n", "self", ".", "image_directory", "=", "image_dir", "\n", "self", ".", "image_prefix", "=", "''", "\n", "self", ".", "COCO", "=", "COCO", "(", "anno_file", ")", "\n", "self", ".", "debug_timer", "=", "Timer", "(", ")", "\n", "# Set up dataset classes", "\n", "category_ids", "=", "self", ".", "COCO", ".", "getCatIds", "(", ")", "\n", "categories", "=", "[", "c", "[", "'name'", "]", "for", "c", "in", "self", ".", "COCO", ".", "loadCats", "(", "category_ids", ")", "]", "\n", "self", ".", "category_to_id_map", "=", "dict", "(", "zip", "(", "categories", ",", "category_ids", ")", ")", "\n", "self", ".", "classes", "=", "[", "'__background__'", "]", "+", "categories", "\n", "self", ".", "num_classes", "=", "len", "(", "self", ".", "classes", ")", "\n", "self", ".", "json_category_id_to_contiguous_id", "=", "{", "\n", "v", ":", "i", "+", "1", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "COCO", ".", "getCatIds", "(", ")", ")", "\n", "}", "\n", "self", ".", "contiguous_category_id_to_json_id", "=", "{", "\n", "v", ":", "k", "\n", "for", "k", ",", "v", "in", "self", ".", "json_category_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "# self._init_keypoints()", "\n", "self", ".", "keypoints", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.get_roidb": [[86, 132], ["json_dataset.JsonDataset.COCO.getImgIds", "json_dataset.JsonDataset.sort", "copy.deepcopy", "json_dataset._add_class_assignments", "json_dataset.JsonDataset.COCO.loadImgs", "json_dataset.JsonDataset._prep_roidb_entry", "json_dataset.JsonDataset.debug_timer.tic", "json_dataset.JsonDataset.debug_timer.tic", "json_dataset.JsonDataset._add_proposals_from_file", "json_dataset.JsonDataset._add_gt_annotations", "lib.utils.logging.logger.debug", "lib.utils.logging.logger.debug", "json_dataset.JsonDataset.debug_timer.toc", "json_dataset.JsonDataset.debug_timer.toc"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._add_class_assignments", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._prep_roidb_entry", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._add_proposals_from_file", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._add_gt_annotations", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.toc", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.timer.Timer.toc"], ["", "def", "get_roidb", "(", "\n", "self", ",", "\n", "gt", "=", "False", ",", "\n", "proposal_file", "=", "None", ",", "\n", "min_proposal_size", "=", "2", ",", "\n", "proposal_limit", "=", "-", "1", ",", "\n", "crowd_filter_thresh", "=", "0", "\n", ")", ":", "\n", "        ", "\"\"\"Return an roidb corresponding to the json dataset. Optionally:\n           - include ground truth boxes in the roidb\n           - add proposals specified in a proposals file\n           - filter proposals based on a minimum side length\n           - filter proposals that intersect with crowd regions\n        \"\"\"", "\n", "assert", "gt", "is", "True", "or", "crowd_filter_thresh", "==", "0", ",", "'Crowd filter threshold must be 0 if ground-truth annotations '", "'are not included.'", "\n", "image_ids", "=", "self", ".", "COCO", ".", "getImgIds", "(", ")", "\n", "image_ids", ".", "sort", "(", ")", "\n", "roidb", "=", "copy", ".", "deepcopy", "(", "self", ".", "COCO", ".", "loadImgs", "(", "image_ids", ")", ")", "\n", "for", "entry", "in", "roidb", ":", "\n", "            ", "self", ".", "_prep_roidb_entry", "(", "entry", ")", "\n", "", "if", "gt", ":", "\n", "# Include ground-truth object annotations", "\n", "            ", "self", ".", "debug_timer", ".", "tic", "(", ")", "\n", "for", "entry", "in", "roidb", ":", "\n", "                ", "self", ".", "_add_gt_annotations", "(", "entry", ")", "\n", "", "if", "logger", ":", "\n", "                ", "logger", ".", "debug", "(", "\n", "'_add_gt_annotations took {:.3f}s'", ".", "\n", "format", "(", "self", ".", "debug_timer", ".", "toc", "(", "average", "=", "False", ")", ")", "\n", ")", "\n", "", "", "if", "proposal_file", "is", "not", "None", ":", "\n", "# Include proposals from a file", "\n", "            ", "self", ".", "debug_timer", ".", "tic", "(", ")", "\n", "self", ".", "_add_proposals_from_file", "(", "\n", "roidb", ",", "proposal_file", ",", "min_proposal_size", ",", "proposal_limit", ",", "\n", "crowd_filter_thresh", "\n", ")", "\n", "if", "logger", ":", "\n", "                ", "logger", ".", "debug", "(", "\n", "'_add_proposals_from_file took {:.3f}s'", ".", "\n", "format", "(", "self", ".", "debug_timer", ".", "toc", "(", "average", "=", "False", ")", ")", "\n", ")", "\n", "", "", "_add_class_assignments", "(", "roidb", ")", "\n", "return", "roidb", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._prep_roidb_entry": [[133, 163], ["os.path.join", "numpy.empty", "numpy.empty", "numpy.empty", "scipy.sparse.csr_matrix", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty"], "methods", ["None"], ["", "def", "_prep_roidb_entry", "(", "self", ",", "entry", ")", ":", "\n", "        ", "\"\"\"Adds empty metadata fields to an roidb entry.\"\"\"", "\n", "# Reference back to the parent dataset", "\n", "entry", "[", "'dataset'", "]", "=", "self", "\n", "# Make file_name an abs path", "\n", "entry", "[", "'image'", "]", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "image_directory", ",", "self", ".", "image_prefix", "+", "entry", "[", "'file_name'", "]", "\n", ")", "\n", "entry", "[", "'flipped'", "]", "=", "False", "\n", "entry", "[", "'has_visible_keypoints'", "]", "=", "False", "\n", "# Empty placeholders", "\n", "entry", "[", "'boxes'", "]", "=", "np", ".", "empty", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "entry", "[", "'segms'", "]", "=", "[", "]", "\n", "entry", "[", "'gt_classes'", "]", "=", "np", ".", "empty", "(", "(", "0", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "entry", "[", "'seg_areas'", "]", "=", "np", ".", "empty", "(", "(", "0", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "entry", "[", "'gt_overlaps'", "]", "=", "scipy", ".", "sparse", ".", "csr_matrix", "(", "\n", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "num_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", ")", "\n", "entry", "[", "'is_crowd'", "]", "=", "np", ".", "empty", "(", "(", "0", ",", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "# 'box_to_gt_ind_map': Shape is (#rois). Maps from each roi to the index", "\n", "# in the list of rois that satisfy np.where(entry['gt_classes'] > 0)", "\n", "entry", "[", "'box_to_gt_ind_map'", "]", "=", "np", ".", "empty", "(", "(", "0", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "if", "self", ".", "keypoints", "is", "not", "None", ":", "\n", "            ", "entry", "[", "'gt_keypoints'", "]", "=", "np", ".", "empty", "(", "\n", "(", "0", ",", "3", ",", "self", ".", "num_keypoints", ")", ",", "dtype", "=", "np", ".", "int32", "\n", ")", "\n", "# Remove unwanted fields that come from the json file (if they exist)", "\n", "", "for", "k", "in", "[", "'date_captured'", ",", "'url'", ",", "'license'", "]", ":", "\n", "            ", "if", "k", "in", "entry", ":", "\n", "                ", "del", "entry", "[", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._add_gt_annotations": [[164, 252], ["json_dataset.JsonDataset.COCO.getAnnIds", "json_dataset.JsonDataset.COCO.loadAnns", "len", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.append", "entry[].extend", "numpy.append", "numpy.append", "numpy.append", "scipy.sparse.csr_matrix", "numpy.append", "numpy.append", "isinstance", "upsnet.xywh_to_xyxy", "upsnet.xywh_to_xyxy", "upsnet.clip_xyxy_to_image", "upsnet.clip_xyxy_to_image", "numpy.zeros", "entry[].toarray", "numpy.append", "valid_objs.append", "valid_segms.append", "json_dataset.JsonDataset._get_gt_keypoints", "numpy.sum", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.xywh_to_xyxy", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.xywh_to_xyxy", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_xyxy_to_image", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_xyxy_to_image", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._get_gt_keypoints"], ["", "", "", "def", "_add_gt_annotations", "(", "self", ",", "entry", ")", ":", "\n", "        ", "\"\"\"Add ground truth annotation metadata to an roidb entry.\"\"\"", "\n", "ann_ids", "=", "self", ".", "COCO", ".", "getAnnIds", "(", "imgIds", "=", "entry", "[", "'id'", "]", ",", "iscrowd", "=", "None", ")", "\n", "objs", "=", "self", ".", "COCO", ".", "loadAnns", "(", "ann_ids", ")", "\n", "# Sanitize bboxes -- some are invalid", "\n", "valid_objs", "=", "[", "]", "\n", "valid_segms", "=", "[", "]", "\n", "width", "=", "entry", "[", "'width'", "]", "\n", "height", "=", "entry", "[", "'height'", "]", "\n", "for", "obj", "in", "objs", ":", "\n", "# crowd regions are RLE encoded and stored as dicts", "\n", "            ", "if", "isinstance", "(", "obj", "[", "'segmentation'", "]", ",", "list", ")", ":", "\n", "# Valid polygons have >= 3 points, so require >= 6 coordinates", "\n", "                ", "obj", "[", "'segmentation'", "]", "=", "[", "\n", "p", "for", "p", "in", "obj", "[", "'segmentation'", "]", "if", "len", "(", "p", ")", ">=", "6", "\n", "]", "\n", "# if obj['area'] < cfg.TRAIN.GT_MIN_AREA:", "\n", "", "if", "obj", "[", "'area'", "]", "<", "config", ".", "train", ".", "gt_min_area", ":", "\n", "                ", "continue", "\n", "", "if", "'ignore'", "in", "obj", "and", "obj", "[", "'ignore'", "]", "==", "1", ":", "\n", "                ", "continue", "\n", "# Convert form (x1, y1, w, h) to (x1, y1, x2, y2)", "\n", "", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "box_utils", ".", "xywh_to_xyxy", "(", "obj", "[", "'bbox'", "]", ")", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "box_utils", ".", "clip_xyxy_to_image", "(", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", ",", "height", ",", "width", "\n", ")", "\n", "# Require non-zero seg area and more than 1x1 box size", "\n", "if", "obj", "[", "'area'", "]", ">", "0", "and", "x2", ">", "x1", "and", "y2", ">", "y1", ":", "\n", "                ", "obj", "[", "'clean_bbox'", "]", "=", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", "\n", "valid_objs", ".", "append", "(", "obj", ")", "\n", "valid_segms", ".", "append", "(", "obj", "[", "'segmentation'", "]", ")", "\n", "", "", "num_valid_objs", "=", "len", "(", "valid_objs", ")", "\n", "\n", "boxes", "=", "np", ".", "zeros", "(", "(", "num_valid_objs", ",", "4", ")", ",", "dtype", "=", "entry", "[", "'boxes'", "]", ".", "dtype", ")", "\n", "gt_classes", "=", "np", ".", "zeros", "(", "(", "num_valid_objs", ",", ")", ",", "dtype", "=", "entry", "[", "'gt_classes'", "]", ".", "dtype", ")", "\n", "gt_overlaps", "=", "np", ".", "zeros", "(", "\n", "(", "num_valid_objs", ",", "self", ".", "num_classes", ")", ",", "\n", "dtype", "=", "entry", "[", "'gt_overlaps'", "]", ".", "dtype", "\n", ")", "\n", "seg_areas", "=", "np", ".", "zeros", "(", "(", "num_valid_objs", ",", ")", ",", "dtype", "=", "entry", "[", "'seg_areas'", "]", ".", "dtype", ")", "\n", "is_crowd", "=", "np", ".", "zeros", "(", "(", "num_valid_objs", ",", ")", ",", "dtype", "=", "entry", "[", "'is_crowd'", "]", ".", "dtype", ")", "\n", "box_to_gt_ind_map", "=", "np", ".", "zeros", "(", "\n", "(", "num_valid_objs", ",", ")", ",", "dtype", "=", "entry", "[", "'box_to_gt_ind_map'", "]", ".", "dtype", "\n", ")", "\n", "if", "self", ".", "keypoints", "is", "not", "None", ":", "\n", "            ", "gt_keypoints", "=", "np", ".", "zeros", "(", "\n", "(", "num_valid_objs", ",", "3", ",", "self", ".", "num_keypoints", ")", ",", "\n", "dtype", "=", "entry", "[", "'gt_keypoints'", "]", ".", "dtype", "\n", ")", "\n", "\n", "", "im_has_visible_keypoints", "=", "False", "\n", "for", "ix", ",", "obj", "in", "enumerate", "(", "valid_objs", ")", ":", "\n", "            ", "cls", "=", "self", ".", "json_category_id_to_contiguous_id", "[", "obj", "[", "'category_id'", "]", "]", "\n", "boxes", "[", "ix", ",", ":", "]", "=", "obj", "[", "'clean_bbox'", "]", "\n", "gt_classes", "[", "ix", "]", "=", "cls", "\n", "seg_areas", "[", "ix", "]", "=", "obj", "[", "'area'", "]", "\n", "is_crowd", "[", "ix", "]", "=", "obj", "[", "'iscrowd'", "]", "\n", "box_to_gt_ind_map", "[", "ix", "]", "=", "ix", "\n", "if", "self", ".", "keypoints", "is", "not", "None", ":", "\n", "                ", "gt_keypoints", "[", "ix", ",", ":", ",", ":", "]", "=", "self", ".", "_get_gt_keypoints", "(", "obj", ")", "\n", "if", "np", ".", "sum", "(", "gt_keypoints", "[", "ix", ",", "2", ",", ":", "]", ")", ">", "0", ":", "\n", "                    ", "im_has_visible_keypoints", "=", "True", "\n", "", "", "if", "obj", "[", "'iscrowd'", "]", ":", "\n", "# Set overlap to -1 for all classes for crowd objects", "\n", "# so they will be excluded during training", "\n", "                ", "gt_overlaps", "[", "ix", ",", ":", "]", "=", "-", "1.0", "\n", "", "else", ":", "\n", "                ", "gt_overlaps", "[", "ix", ",", "cls", "]", "=", "1.0", "\n", "", "", "entry", "[", "'boxes'", "]", "=", "np", ".", "append", "(", "entry", "[", "'boxes'", "]", ",", "boxes", ",", "axis", "=", "0", ")", "\n", "entry", "[", "'segms'", "]", ".", "extend", "(", "valid_segms", ")", "\n", "# To match the original implementation:", "\n", "# entry['boxes'] = np.append(", "\n", "#     entry['boxes'], boxes.astype(np.int).astype(np.float), axis=0)", "\n", "entry", "[", "'gt_classes'", "]", "=", "np", ".", "append", "(", "entry", "[", "'gt_classes'", "]", ",", "gt_classes", ")", "\n", "entry", "[", "'seg_areas'", "]", "=", "np", ".", "append", "(", "entry", "[", "'seg_areas'", "]", ",", "seg_areas", ")", "\n", "entry", "[", "'gt_overlaps'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'gt_overlaps'", "]", ".", "toarray", "(", ")", ",", "gt_overlaps", ",", "axis", "=", "0", "\n", ")", "\n", "entry", "[", "'gt_overlaps'", "]", "=", "scipy", ".", "sparse", ".", "csr_matrix", "(", "entry", "[", "'gt_overlaps'", "]", ")", "\n", "entry", "[", "'is_crowd'", "]", "=", "np", ".", "append", "(", "entry", "[", "'is_crowd'", "]", ",", "is_crowd", ")", "\n", "entry", "[", "'box_to_gt_ind_map'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'box_to_gt_ind_map'", "]", ",", "box_to_gt_ind_map", "\n", ")", "\n", "if", "self", ".", "keypoints", "is", "not", "None", ":", "\n", "            ", "entry", "[", "'gt_keypoints'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'gt_keypoints'", "]", ",", "gt_keypoints", ",", "axis", "=", "0", "\n", ")", "\n", "entry", "[", "'has_visible_keypoints'", "]", "=", "im_has_visible_keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._add_proposals_from_file": [[253, 285], ["json_dataset._sort_proposals", "enumerate", "json_dataset._merge_proposal_boxes_into_roidb", "lib.utils.logging.logger.info", "open", "pickle.load", "upsnet.clip_boxes_to_image", "upsnet.clip_boxes_to_image", "upsnet.unique_boxes", "upsnet.unique_boxes", "upsnet.filter_boxes", "upsnet.filter_boxes", "box_list.append", "json_dataset._filter_crowd_proposals", "lib.utils.logging.logger.info", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._sort_proposals", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._merge_proposal_boxes_into_roidb", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_boxes_to_image", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_boxes_to_image", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.unique_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.unique_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.filter_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.filter_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._filter_crowd_proposals"], ["", "", "def", "_add_proposals_from_file", "(", "\n", "self", ",", "roidb", ",", "proposal_file", ",", "min_proposal_size", ",", "top_k", ",", "crowd_thresh", "\n", ")", ":", "\n", "        ", "\"\"\"Add proposals from a proposals file to an roidb.\"\"\"", "\n", "if", "logger", ":", "\n", "            ", "logger", ".", "info", "(", "'Loading proposals from: {}'", ".", "format", "(", "proposal_file", ")", ")", "\n", "", "with", "open", "(", "proposal_file", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "proposals", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "id_field", "=", "'indexes'", "if", "'indexes'", "in", "proposals", "else", "'ids'", "# compat fix", "\n", "_sort_proposals", "(", "proposals", ",", "id_field", ")", "\n", "box_list", "=", "[", "]", "\n", "for", "i", ",", "entry", "in", "enumerate", "(", "roidb", ")", ":", "\n", "            ", "if", "i", "%", "2500", "==", "0", ":", "\n", "                ", "if", "logger", ":", "\n", "                    ", "logger", ".", "info", "(", "' {:d}/{:d}'", ".", "format", "(", "i", "+", "1", ",", "len", "(", "roidb", ")", ")", ")", "\n", "", "", "boxes", "=", "proposals", "[", "'boxes'", "]", "[", "i", "]", "\n", "# Sanity check that these boxes are for the correct image id", "\n", "assert", "entry", "[", "'id'", "]", "==", "proposals", "[", "id_field", "]", "[", "i", "]", "\n", "# Remove duplicate boxes and very small boxes and then take top k", "\n", "boxes", "=", "box_utils", ".", "clip_boxes_to_image", "(", "\n", "boxes", ",", "entry", "[", "'height'", "]", ",", "entry", "[", "'width'", "]", "\n", ")", "\n", "keep", "=", "box_utils", ".", "unique_boxes", "(", "boxes", ")", "\n", "boxes", "=", "boxes", "[", "keep", ",", ":", "]", "\n", "keep", "=", "box_utils", ".", "filter_boxes", "(", "boxes", ",", "min_proposal_size", ")", "\n", "boxes", "=", "boxes", "[", "keep", ",", ":", "]", "\n", "if", "top_k", ">", "0", ":", "\n", "                ", "boxes", "=", "boxes", "[", ":", "top_k", ",", ":", "]", "\n", "", "box_list", ".", "append", "(", "boxes", ")", "\n", "", "_merge_proposal_boxes_into_roidb", "(", "roidb", ",", "box_list", ")", "\n", "if", "crowd_thresh", ">", "0", ":", "\n", "            ", "_filter_crowd_proposals", "(", "roidb", ",", "crowd_thresh", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._init_keypoints": [[286, 314], ["json_dataset.JsonDataset.COCO.loadCats", "dict", "len", "zip", "range", "len"], "methods", ["None"], ["", "", "def", "_init_keypoints", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize COCO keypoint information.\"\"\"", "\n", "self", ".", "keypoints", "=", "None", "\n", "self", ".", "keypoint_flip_map", "=", "None", "\n", "self", ".", "keypoints_to_id_map", "=", "None", "\n", "self", ".", "num_keypoints", "=", "0", "\n", "# Thus far only the 'person' category has keypoints", "\n", "if", "'person'", "in", "self", ".", "category_to_id_map", ":", "\n", "            ", "cat_info", "=", "self", ".", "COCO", ".", "loadCats", "(", "[", "self", ".", "category_to_id_map", "[", "'person'", "]", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "\n", "\n", "# Check if the annotations contain keypoint data or not", "\n", "", "if", "'keypoints'", "in", "cat_info", "[", "0", "]", ":", "\n", "            ", "keypoints", "=", "cat_info", "[", "0", "]", "[", "'keypoints'", "]", "\n", "self", ".", "keypoints_to_id_map", "=", "dict", "(", "\n", "zip", "(", "keypoints", ",", "range", "(", "len", "(", "keypoints", ")", ")", ")", ")", "\n", "self", ".", "keypoints", "=", "keypoints", "\n", "self", ".", "num_keypoints", "=", "len", "(", "keypoints", ")", "\n", "self", ".", "keypoint_flip_map", "=", "{", "\n", "'left_eye'", ":", "'right_eye'", ",", "\n", "'left_ear'", ":", "'right_ear'", ",", "\n", "'left_shoulder'", ":", "'right_shoulder'", ",", "\n", "'left_elbow'", ":", "'right_elbow'", ",", "\n", "'left_wrist'", ":", "'right_wrist'", ",", "\n", "'left_hip'", ":", "'right_hip'", ",", "\n", "'left_knee'", ":", "'right_knee'", ",", "\n", "'left_ankle'", ":", "'right_ankle'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset._get_gt_keypoints": [[315, 333], ["numpy.array", "numpy.ones", "range", "len"], "methods", ["None"], ["", "", "def", "_get_gt_keypoints", "(", "self", ",", "obj", ")", ":", "\n", "        ", "\"\"\"Return ground truth keypoints.\"\"\"", "\n", "if", "'keypoints'", "not", "in", "obj", ":", "\n", "            ", "return", "None", "\n", "", "kp", "=", "np", ".", "array", "(", "obj", "[", "'keypoints'", "]", ")", "\n", "x", "=", "kp", "[", "0", ":", ":", "3", "]", "# 0-indexed x coordinates", "\n", "y", "=", "kp", "[", "1", ":", ":", "3", "]", "# 0-indexed y coordinates", "\n", "# 0: not labeled; 1: labeled, not inside mask;", "\n", "# 2: labeled and inside mask", "\n", "v", "=", "kp", "[", "2", ":", ":", "3", "]", "\n", "num_keypoints", "=", "len", "(", "obj", "[", "'keypoints'", "]", ")", "/", "3", "\n", "assert", "num_keypoints", "==", "self", ".", "num_keypoints", "\n", "gt_kps", "=", "np", ".", "ones", "(", "(", "3", ",", "self", ".", "num_keypoints", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_keypoints", ")", ":", "\n", "            ", "gt_kps", "[", "0", ",", "i", "]", "=", "x", "[", "i", "]", "\n", "gt_kps", "[", "1", ",", "i", "]", "=", "y", "[", "i", "]", "\n", "gt_kps", "[", "2", ",", "i", "]", "=", "v", "[", "i", "]", "\n", "", "return", "gt_kps", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.add_proposals": [[335, 349], ["range", "json_dataset._merge_proposal_boxes_into_roidb", "json_dataset._add_class_assignments", "len", "box_list.append", "json_dataset._filter_crowd_proposals", "numpy.where"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._merge_proposal_boxes_into_roidb", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._add_class_assignments", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._filter_crowd_proposals"], ["", "", "def", "add_proposals", "(", "roidb", ",", "rois", ",", "scales", ",", "crowd_thresh", ")", ":", "\n", "    ", "\"\"\"Add proposal boxes (rois) to an roidb that has ground-truth annotations\n    but no proposals. If the proposals are not at the original image scale,\n    specify the scale factor that separate them in scales.\n    \"\"\"", "\n", "box_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "roidb", ")", ")", ":", "\n", "        ", "inv_im_scale", "=", "1.", "/", "scales", "[", "i", "]", "\n", "idx", "=", "np", ".", "where", "(", "rois", "[", ":", ",", "0", "]", "==", "i", ")", "[", "0", "]", "\n", "box_list", ".", "append", "(", "rois", "[", "idx", ",", "1", ":", "]", "*", "inv_im_scale", ")", "\n", "", "_merge_proposal_boxes_into_roidb", "(", "roidb", ",", "box_list", ")", "\n", "if", "crowd_thresh", ">", "0", ":", "\n", "        ", "_filter_crowd_proposals", "(", "roidb", ",", "crowd_thresh", ")", "\n", "", "_add_class_assignments", "(", "roidb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.extend_with_flipped_entries": [[351, 383], ["roidb.extend", "entry[].copy", "boxes[].copy", "boxes[].copy", "entry.items", "upsnet.flip_segms", "flipped_roidb.append"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.flip_segms"], ["", "def", "extend_with_flipped_entries", "(", "roidb", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"Flip each entry in the given roidb and return a new roidb that is the\n    concatenation of the original roidb and the flipped entries.\n    \"Flipping\" an entry means that that image and associated metadata (e.g.,\n    ground truth boxes and object proposals) are horizontally flipped.\n    \"\"\"", "\n", "flipped_roidb", "=", "[", "]", "\n", "for", "entry", "in", "roidb", ":", "\n", "        ", "width", "=", "entry", "[", "'width'", "]", "\n", "boxes", "=", "entry", "[", "'boxes'", "]", ".", "copy", "(", ")", "\n", "oldx1", "=", "boxes", "[", ":", ",", "0", "]", ".", "copy", "(", ")", "\n", "oldx2", "=", "boxes", "[", ":", ",", "2", "]", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", "0", "]", "=", "width", "-", "oldx2", "-", "1", "\n", "boxes", "[", ":", ",", "2", "]", "=", "width", "-", "oldx1", "-", "1", "\n", "assert", "(", "boxes", "[", ":", ",", "2", "]", ">=", "boxes", "[", ":", ",", "0", "]", ")", ".", "all", "(", ")", "\n", "flipped_entry", "=", "{", "}", "\n", "dont_copy", "=", "(", "'boxes'", ",", "'segms'", ",", "'gt_keypoints'", ",", "'flipped'", ")", "\n", "for", "k", ",", "v", "in", "entry", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "not", "in", "dont_copy", ":", "\n", "                ", "flipped_entry", "[", "k", "]", "=", "v", "\n", "", "", "flipped_entry", "[", "'boxes'", "]", "=", "boxes", "\n", "flipped_entry", "[", "'segms'", "]", "=", "segm_utils", ".", "flip_segms", "(", "\n", "entry", "[", "'segms'", "]", ",", "entry", "[", "'height'", "]", ",", "entry", "[", "'width'", "]", "\n", ")", "\n", "# if dataset.keypoints is not None:", "\n", "#     flipped_entry['gt_keypoints'] = keypoint_utils.flip_keypoints(", "\n", "#         dataset.keypoints, dataset.keypoint_flip_map,", "\n", "#         entry['gt_keypoints'], entry['width']", "\n", "#     )", "\n", "flipped_entry", "[", "'flipped'", "]", "=", "True", "\n", "flipped_roidb", ".", "append", "(", "flipped_entry", ")", "\n", "", "roidb", ".", "extend", "(", "flipped_roidb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.filter_for_training": [[385, 412], ["len", "len", "lib.utils.logging.logger.info", "numpy.where", "numpy.where", "json_dataset.filter_for_training.is_valid"], "function", ["None"], ["", "def", "filter_for_training", "(", "roidb", ")", ":", "\n", "    ", "\"\"\"Remove roidb entries that have no usable RoIs based on config settings.\n    \"\"\"", "\n", "def", "is_valid", "(", "entry", ")", ":", "\n", "# Valid images have:", "\n", "#   (1) At least one foreground RoI OR", "\n", "#   (2) At least one background RoI", "\n", "        ", "overlaps", "=", "entry", "[", "'max_overlaps'", "]", "\n", "# find boxes with sufficient overlap", "\n", "fg_inds", "=", "np", ".", "where", "(", "overlaps", ">=", "config", ".", "train", ".", "fg_thresh", ")", "[", "0", "]", "\n", "# Select background RoIs as those within [BG_THRESH_LO, BG_THRESH_HI)", "\n", "bg_inds", "=", "np", ".", "where", "(", "(", "overlaps", "<", "config", ".", "train", ".", "bg_thresh_hi", ")", "&", "\n", "(", "overlaps", ">=", "config", ".", "train", ".", "bg_thresh_lo", ")", ")", "[", "0", "]", "\n", "# image is only valid if such boxes exist", "\n", "valid", "=", "len", "(", "fg_inds", ")", ">", "0", "or", "len", "(", "bg_inds", ")", ">", "0", "\n", "# if cfg.MODEL.KEYPOINTS_ON:", "\n", "#     # If we're training for keypoints, exclude images with no keypoints", "\n", "#     valid = valid and entry['has_visible_keypoints']", "\n", "return", "valid", "\n", "\n", "", "num", "=", "len", "(", "roidb", ")", "\n", "filtered_roidb", "=", "[", "entry", "for", "entry", "in", "roidb", "if", "is_valid", "(", "entry", ")", "]", "\n", "num_after", "=", "len", "(", "filtered_roidb", ")", "\n", "if", "logger", ":", "\n", "        ", "logger", ".", "info", "(", "'Filtered {} roidb entries: {} -> {}'", ".", "\n", "format", "(", "num", "-", "num_after", ",", "num", ",", "num_after", ")", ")", "\n", "", "return", "filtered_roidb", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.add_bbox_regression_targets": [[414, 418], ["json_dataset._compute_targets"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois._compute_targets"], ["", "def", "add_bbox_regression_targets", "(", "roidb", ")", ":", "\n", "    ", "\"\"\"Add information needed to train bounding-box regressors.\"\"\"", "\n", "for", "entry", "in", "roidb", ":", "\n", "        ", "entry", "[", "'bbox_targets'", "]", "=", "_compute_targets", "(", "entry", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._compute_targets": [[420, 452], ["numpy.zeros", "upsnet.bbox_overlaps", "box_utils.bbox_overlaps.argmax", "upsnet.bbox_transform_inv", "numpy.where", "len", "numpy.where", "rois[].astype", "rois[].astype"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_transform_inv"], ["", "", "def", "_compute_targets", "(", "entry", ")", ":", "\n", "    ", "\"\"\"Compute bounding-box regression targets for an image.\"\"\"", "\n", "# Indices of ground-truth ROIs", "\n", "rois", "=", "entry", "[", "'boxes'", "]", "\n", "overlaps", "=", "entry", "[", "'max_overlaps'", "]", "\n", "labels", "=", "entry", "[", "'max_classes'", "]", "\n", "gt_inds", "=", "np", ".", "where", "(", "(", "entry", "[", "'gt_classes'", "]", ">", "0", ")", "&", "(", "entry", "[", "'is_crowd'", "]", "==", "0", ")", ")", "[", "0", "]", "\n", "# Targets has format (class, tx, ty, tw, th)", "\n", "targets", "=", "np", ".", "zeros", "(", "(", "rois", ".", "shape", "[", "0", "]", ",", "5", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "len", "(", "gt_inds", ")", "==", "0", ":", "\n", "# Bail if the image has no ground-truth ROIs", "\n", "        ", "return", "targets", "\n", "\n", "# Indices of examples for which we try to make predictions", "\n", "", "ex_inds", "=", "np", ".", "where", "(", "overlaps", ">=", "config", ".", "train", ".", "bbox_thresh", ")", "[", "0", "]", "\n", "\n", "# Get IoU overlap between each ex ROI and gt ROI", "\n", "ex_gt_overlaps", "=", "box_utils", ".", "bbox_overlaps", "(", "\n", "rois", "[", "ex_inds", ",", ":", "]", ".", "astype", "(", "dtype", "=", "np", ".", "float32", ",", "copy", "=", "False", ")", ",", "\n", "rois", "[", "gt_inds", ",", ":", "]", ".", "astype", "(", "dtype", "=", "np", ".", "float32", ",", "copy", "=", "False", ")", ")", "\n", "\n", "# Find which gt ROI each ex ROI has max overlap with:", "\n", "# this will be the ex ROI's gt target", "\n", "gt_assignment", "=", "ex_gt_overlaps", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "gt_rois", "=", "rois", "[", "gt_inds", "[", "gt_assignment", "]", ",", ":", "]", "\n", "ex_rois", "=", "rois", "[", "ex_inds", ",", ":", "]", "\n", "# Use class \"1\" for all boxes if using class_agnostic_bbox_reg", "\n", "targets", "[", "ex_inds", ",", "0", "]", "=", "(", "\n", "1", "if", "config", ".", "network", ".", "cls_agnostic_bbox_reg", "else", "labels", "[", "ex_inds", "]", ")", "\n", "targets", "[", "ex_inds", ",", "1", ":", "]", "=", "box_utils", ".", "bbox_transform_inv", "(", "\n", "ex_rois", ",", "gt_rois", ",", "config", ".", "network", ".", "bbox_reg_weights", ")", "\n", "return", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._merge_proposal_boxes_into_roidb": [[454, 514], ["enumerate", "len", "len", "numpy.zeros", "numpy.append", "numpy.append", "numpy.append", "numpy.append", "scipy.sparse.csr_matrix", "numpy.append", "numpy.append", "numpy.ones", "numpy.where", "len", "upsnet.bbox_overlaps", "box_utils.bbox_overlaps.argmax", "box_utils.bbox_overlaps.max", "boxes.astype", "numpy.zeros", "numpy.zeros", "entry[].toarray", "numpy.zeros", "box_to_gt_ind_map.astype", "boxes.astype", "gt_boxes.astype", "numpy.where"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps"], ["", "def", "_merge_proposal_boxes_into_roidb", "(", "roidb", ",", "box_list", ")", ":", "\n", "    ", "\"\"\"Add proposal boxes to each roidb entry.\"\"\"", "\n", "assert", "len", "(", "box_list", ")", "==", "len", "(", "roidb", ")", "\n", "for", "i", ",", "entry", "in", "enumerate", "(", "roidb", ")", ":", "\n", "        ", "boxes", "=", "box_list", "[", "i", "]", "\n", "num_boxes", "=", "boxes", ".", "shape", "[", "0", "]", "\n", "gt_overlaps", "=", "np", ".", "zeros", "(", "\n", "(", "num_boxes", ",", "entry", "[", "'gt_overlaps'", "]", ".", "shape", "[", "1", "]", ")", ",", "\n", "dtype", "=", "entry", "[", "'gt_overlaps'", "]", ".", "dtype", "\n", ")", "\n", "box_to_gt_ind_map", "=", "-", "np", ".", "ones", "(", "\n", "(", "num_boxes", ",", ")", ",", "dtype", "=", "entry", "[", "'box_to_gt_ind_map'", "]", ".", "dtype", "\n", ")", "\n", "\n", "# Note: unlike in other places, here we intentionally include all gt", "\n", "# rois, even ones marked as crowd. Boxes that overlap with crowds will", "\n", "# be filtered out later (see: _filter_crowd_proposals).", "\n", "gt_inds", "=", "np", ".", "where", "(", "entry", "[", "'gt_classes'", "]", ">", "0", ")", "[", "0", "]", "\n", "if", "len", "(", "gt_inds", ")", ">", "0", ":", "\n", "            ", "gt_boxes", "=", "entry", "[", "'boxes'", "]", "[", "gt_inds", ",", ":", "]", "\n", "gt_classes", "=", "entry", "[", "'gt_classes'", "]", "[", "gt_inds", "]", "\n", "proposal_to_gt_overlaps", "=", "box_utils", ".", "bbox_overlaps", "(", "\n", "boxes", ".", "astype", "(", "dtype", "=", "np", ".", "float32", ",", "copy", "=", "False", ")", ",", "\n", "gt_boxes", ".", "astype", "(", "dtype", "=", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", ")", "\n", "# Gt box that overlaps each input box the most", "\n", "# (ties are broken arbitrarily by class order)", "\n", "argmaxes", "=", "proposal_to_gt_overlaps", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "# Amount of that overlap", "\n", "maxes", "=", "proposal_to_gt_overlaps", ".", "max", "(", "axis", "=", "1", ")", "\n", "# Those boxes with non-zero overlap with gt boxes", "\n", "I", "=", "np", ".", "where", "(", "maxes", ">", "0", ")", "[", "0", "]", "\n", "# Record max overlaps with the class of the appropriate gt box", "\n", "gt_overlaps", "[", "I", ",", "gt_classes", "[", "argmaxes", "[", "I", "]", "]", "]", "=", "maxes", "[", "I", "]", "\n", "box_to_gt_ind_map", "[", "I", "]", "=", "gt_inds", "[", "argmaxes", "[", "I", "]", "]", "\n", "", "entry", "[", "'boxes'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'boxes'", "]", ",", "\n", "boxes", ".", "astype", "(", "entry", "[", "'boxes'", "]", ".", "dtype", ",", "copy", "=", "False", ")", ",", "\n", "axis", "=", "0", "\n", ")", "\n", "entry", "[", "'gt_classes'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'gt_classes'", "]", ",", "\n", "np", ".", "zeros", "(", "(", "num_boxes", ",", ")", ",", "dtype", "=", "entry", "[", "'gt_classes'", "]", ".", "dtype", ")", "\n", ")", "\n", "entry", "[", "'seg_areas'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'seg_areas'", "]", ",", "\n", "np", ".", "zeros", "(", "(", "num_boxes", ",", ")", ",", "dtype", "=", "entry", "[", "'seg_areas'", "]", ".", "dtype", ")", "\n", ")", "\n", "entry", "[", "'gt_overlaps'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'gt_overlaps'", "]", ".", "toarray", "(", ")", ",", "gt_overlaps", ",", "axis", "=", "0", "\n", ")", "\n", "entry", "[", "'gt_overlaps'", "]", "=", "scipy", ".", "sparse", ".", "csr_matrix", "(", "entry", "[", "'gt_overlaps'", "]", ")", "\n", "entry", "[", "'is_crowd'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'is_crowd'", "]", ",", "\n", "np", ".", "zeros", "(", "(", "num_boxes", ",", ")", ",", "dtype", "=", "entry", "[", "'is_crowd'", "]", ".", "dtype", ")", "\n", ")", "\n", "entry", "[", "'box_to_gt_ind_map'", "]", "=", "np", ".", "append", "(", "\n", "entry", "[", "'box_to_gt_ind_map'", "]", ",", "\n", "box_to_gt_ind_map", ".", "astype", "(", "\n", "entry", "[", "'box_to_gt_ind_map'", "]", ".", "dtype", ",", "copy", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._filter_crowd_proposals": [[518, 536], ["entry[].toarray", "upsnet.xyxy_to_xywh", "upsnet.xyxy_to_xywh", "pycocotools.mask.iou", "scipy.sparse.csr_matrix", "numpy.where", "numpy.where", "len", "numpy.where", "len", "len", "int", "COCOmask.iou.max"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.xyxy_to_xywh", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.xyxy_to_xywh"], ["", "", "def", "_filter_crowd_proposals", "(", "roidb", ",", "crowd_thresh", ")", ":", "\n", "    ", "\"\"\"Finds proposals that are inside crowd regions and marks them as\n    overlap = -1 with each ground-truth rois, which means they will be excluded\n    from training.\n    \"\"\"", "\n", "for", "entry", "in", "roidb", ":", "\n", "        ", "gt_overlaps", "=", "entry", "[", "'gt_overlaps'", "]", ".", "toarray", "(", ")", "\n", "crowd_inds", "=", "np", ".", "where", "(", "entry", "[", "'is_crowd'", "]", "==", "1", ")", "[", "0", "]", "\n", "non_gt_inds", "=", "np", ".", "where", "(", "entry", "[", "'gt_classes'", "]", "==", "0", ")", "[", "0", "]", "\n", "if", "len", "(", "crowd_inds", ")", "==", "0", "or", "len", "(", "non_gt_inds", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "crowd_boxes", "=", "box_utils", ".", "xyxy_to_xywh", "(", "entry", "[", "'boxes'", "]", "[", "crowd_inds", ",", ":", "]", ")", "\n", "non_gt_boxes", "=", "box_utils", ".", "xyxy_to_xywh", "(", "entry", "[", "'boxes'", "]", "[", "non_gt_inds", ",", ":", "]", ")", "\n", "iscrowd_flags", "=", "[", "int", "(", "True", ")", "]", "*", "len", "(", "crowd_inds", ")", "\n", "ious", "=", "COCOmask", ".", "iou", "(", "non_gt_boxes", ",", "crowd_boxes", ",", "iscrowd_flags", ")", "\n", "bad_inds", "=", "np", ".", "where", "(", "ious", ".", "max", "(", "axis", "=", "1", ")", ">", "crowd_thresh", ")", "[", "0", "]", "\n", "gt_overlaps", "[", "non_gt_inds", "[", "bad_inds", "]", ",", ":", "]", "=", "-", "1", "\n", "entry", "[", "'gt_overlaps'", "]", "=", "scipy", ".", "sparse", ".", "csr_matrix", "(", "gt_overlaps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._add_class_assignments": [[538, 557], ["entry[].toarray", "entry[].toarray.max", "entry[].toarray.argmax", "all", "all", "numpy.where", "numpy.where"], "function", ["None"], ["", "", "def", "_add_class_assignments", "(", "roidb", ")", ":", "\n", "    ", "\"\"\"Compute object category assignment for each box associated with each\n    roidb entry.\n    \"\"\"", "\n", "for", "entry", "in", "roidb", ":", "\n", "        ", "gt_overlaps", "=", "entry", "[", "'gt_overlaps'", "]", ".", "toarray", "(", ")", "\n", "# max overlap with gt over classes (columns)", "\n", "max_overlaps", "=", "gt_overlaps", ".", "max", "(", "axis", "=", "1", ")", "\n", "# gt class that had the max overlap", "\n", "max_classes", "=", "gt_overlaps", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "entry", "[", "'max_classes'", "]", "=", "max_classes", "\n", "entry", "[", "'max_overlaps'", "]", "=", "max_overlaps", "\n", "# sanity checks", "\n", "# if max overlap is 0, the class must be background (class 0)", "\n", "zero_inds", "=", "np", ".", "where", "(", "max_overlaps", "==", "0", ")", "[", "0", "]", "\n", "assert", "all", "(", "max_classes", "[", "zero_inds", "]", "==", "0", ")", "\n", "# if max overlap > 0, the class must be a fg class (not class 0)", "\n", "nonzero_inds", "=", "np", ".", "where", "(", "max_overlaps", ">", "0", ")", "[", "0", "]", "\n", "assert", "all", "(", "max_classes", "[", "nonzero_inds", "]", "!=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset._sort_proposals": [[559, 565], ["numpy.argsort"], "function", ["None"], ["", "", "def", "_sort_proposals", "(", "proposals", ",", "id_field", ")", ":", "\n", "    ", "\"\"\"Sort proposals by the specified id field.\"\"\"", "\n", "order", "=", "np", ".", "argsort", "(", "proposals", "[", "id_field", "]", ")", "\n", "fields_to_sort", "=", "[", "'boxes'", ",", "id_field", ",", "'scores'", "]", "\n", "for", "k", "in", "fields_to_sort", ":", "\n", "        ", "proposals", "[", "k", "]", "=", "[", "proposals", "[", "k", "]", "[", "i", "]", "for", "i", "in", "order", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.__init__": [[35, 46], ["print"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ")", ":", "\n", "        ", "self", ".", "_name", "=", "name", "\n", "self", ".", "_num_classes", "=", "0", "\n", "self", ".", "_classes", "=", "[", "]", "\n", "self", ".", "_image_index", "=", "[", "]", "\n", "self", ".", "_obj_proposer", "=", "'selective_search'", "\n", "self", ".", "_roidb", "=", "None", "\n", "print", "(", "self", ".", "default_roidb", ")", "\n", "self", ".", "_roidb_handler", "=", "self", ".", "default_roidb", "\n", "# Use this dict for storing dataset specific config options", "\n", "self", ".", "config", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.name": [[47, 50], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_name", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.num_classes": [[51, 54], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_classes", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.classes": [[55, 58], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "classes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.image_index": [[59, 62], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "image_index", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_image_index", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.roidb_handler": [[67, 70], ["None"], "methods", ["None"], ["", "@", "roidb_handler", ".", "setter", "\n", "def", "roidb_handler", "(", "self", ",", "val", ")", ":", "\n", "        ", "self", ".", "_roidb_handler", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.set_proposal_method": [[71, 74], ["eval"], "methods", ["None"], ["", "def", "set_proposal_method", "(", "self", ",", "method", ")", ":", "\n", "        ", "method", "=", "eval", "(", "'self.'", "+", "method", "+", "'_roidb'", ")", "\n", "self", ".", "roidb_handler", "=", "method", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.roidb": [[75, 86], ["imdb.imdb.roidb_handler"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.roidb_handler"], ["", "@", "property", "\n", "def", "roidb", "(", "self", ")", ":", "\n", "# A roidb is a list of dictionaries, each with the following keys:", "\n", "#   boxes", "\n", "#   gt_overlaps", "\n", "#   gt_classes", "\n", "#   flipped", "\n", "        ", "if", "self", ".", "_roidb", "is", "not", "None", ":", "\n", "            ", "return", "self", ".", "_roidb", "\n", "", "self", ".", "_roidb", "=", "self", ".", "roidb_handler", "(", ")", "\n", "return", "self", ".", "_roidb", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.cache_path": [[87, 93], ["os.abspath", "os.abspath", "os.join", "os.join", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs"], "methods", ["None"], ["", "@", "property", "\n", "def", "cache_path", "(", "self", ")", ":", "\n", "        ", "cache_path", "=", "osp", ".", "abspath", "(", "osp", ".", "join", "(", "config", ".", "DATA_DIR", ",", "'cache'", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "cache_path", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "cache_path", ")", "\n", "", "return", "cache_path", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.num_images": [[94, 97], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_images", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "image_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.image_path_at": [[98, 100], ["None"], "methods", ["None"], ["", "def", "image_path_at", "(", "self", ",", "i", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.default_roidb": [[101, 103], ["None"], "methods", ["None"], ["", "def", "default_roidb", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.evaluate_detections": [[104, 113], ["None"], "methods", ["None"], ["", "def", "evaluate_detections", "(", "self", ",", "detections", ")", ":", "\n", "        ", "\"\"\"\n        all_boxes is a list of length number-of-classes.\n        Each list element is a list of length number-of-images.\n        Each of those list elements is either an empty list []\n        or a numpy array of detection.\n        all_boxes[class][image] = [] or np.array of shape #dets x 5\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb._get_widths": [[115, 118], ["range", "PIL.Image.open", "imdb.imdb.image_path_at"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.image_path_at"], ["", "def", "_get_widths", "(", "self", ")", ":", "\n", "        ", "return", "[", "PIL", ".", "Image", ".", "open", "(", "self", ".", "image_path_at", "(", "i", ")", ")", ".", "size", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_images", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.append_flipped_images": [[119, 146], ["imdb.imdb._get_widths", "range", "[].copy", "boxes[].copy", "boxes[].copy", "imdb.imdb.roidb.append", "[].copy", "[].copy", "dontcare_areas[].copy", "dontcare_areas[].copy"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb._get_widths"], ["", "def", "append_flipped_images", "(", "self", ")", ":", "\n", "        ", "num_images", "=", "self", ".", "num_images", "\n", "widths", "=", "self", ".", "_get_widths", "(", ")", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "boxes", "=", "self", ".", "roidb", "[", "i", "]", "[", "'boxes'", "]", ".", "copy", "(", ")", "\n", "oldx1", "=", "boxes", "[", ":", ",", "0", "]", ".", "copy", "(", ")", "\n", "oldx2", "=", "boxes", "[", ":", ",", "2", "]", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", "0", "]", "=", "widths", "[", "i", "]", "-", "oldx2", "-", "1", "\n", "boxes", "[", ":", ",", "2", "]", "=", "widths", "[", "i", "]", "-", "oldx1", "-", "1", "\n", "assert", "(", "boxes", "[", ":", ",", "2", "]", ">=", "boxes", "[", ":", ",", "0", "]", ")", ".", "all", "(", ")", "\n", "entry", "=", "{", "'boxes'", ":", "boxes", ",", "\n", "'gt_overlaps'", ":", "self", ".", "roidb", "[", "i", "]", "[", "'gt_overlaps'", "]", ",", "\n", "'gt_classes'", ":", "self", ".", "roidb", "[", "i", "]", "[", "'gt_classes'", "]", ",", "\n", "'flipped'", ":", "True", "}", "\n", "\n", "if", "'gt_ishard'", "in", "self", ".", "roidb", "[", "i", "]", "and", "'dontcare_areas'", "in", "self", ".", "roidb", "[", "i", "]", ":", "\n", "                ", "entry", "[", "'gt_ishard'", "]", "=", "self", ".", "roidb", "[", "i", "]", "[", "'gt_ishard'", "]", ".", "copy", "(", ")", "\n", "dontcare_areas", "=", "self", ".", "roidb", "[", "i", "]", "[", "'dontcare_areas'", "]", ".", "copy", "(", ")", "\n", "oldx1", "=", "dontcare_areas", "[", ":", ",", "0", "]", ".", "copy", "(", ")", "\n", "oldx2", "=", "dontcare_areas", "[", ":", ",", "2", "]", ".", "copy", "(", ")", "\n", "dontcare_areas", "[", ":", ",", "0", "]", "=", "widths", "[", "i", "]", "-", "oldx2", "-", "1", "\n", "dontcare_areas", "[", ":", ",", "2", "]", "=", "widths", "[", "i", "]", "-", "oldx1", "-", "1", "\n", "entry", "[", "'dontcare_areas'", "]", "=", "dontcare_areas", "\n", "\n", "", "self", ".", "roidb", ".", "append", "(", "entry", ")", "\n", "\n", "", "self", ".", "_image_index", "=", "self", ".", "_image_index", "*", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.evaluate_recall": [[147, 235], ["areas.has_key", "numpy.zeros", "range", "numpy.sort", "numpy.zeros_like", "enumerate", "numpy.zeros_like.mean", "[].toarray().max", "len", "bbox.bbox.bbox_overlaps", "numpy.zeros", "range", "numpy.hstack", "numpy.arange", "numpy.where", "numpy.where", "boxes.astype", "gt_boxes.astype", "bbox.bbox.bbox_overlaps.argmax", "bbox.bbox.bbox_overlaps.max", "bbox.bbox.bbox_overlaps.max.argmax", "bbox.bbox.bbox_overlaps.max.max", "float", "[].toarray", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps"], ["", "def", "evaluate_recall", "(", "self", ",", "candidate_boxes", "=", "None", ",", "thresholds", "=", "None", ",", "\n", "area", "=", "'all'", ",", "limit", "=", "None", ")", ":", "\n", "        ", "\"\"\"Evaluate detection proposal recall metrics.\n        Returns:\n            results: dictionary of results with keys\n                'ar': average recall\n                'recalls': vector recalls at each IoU overlap threshold\n                'thresholds': vector of IoU overlap thresholds\n                'gt_overlaps': vector of all ground-truth overlaps\n        \"\"\"", "\n", "# Record max overlap value for each gt box", "\n", "# Return vector of overlap values", "\n", "areas", "=", "{", "'all'", ":", "0", ",", "'small'", ":", "1", ",", "'medium'", ":", "2", ",", "'large'", ":", "3", ",", "\n", "'96-128'", ":", "4", ",", "'128-256'", ":", "5", ",", "'256-512'", ":", "6", ",", "'512-inf'", ":", "7", "}", "\n", "area_ranges", "=", "[", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "# all", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "# small", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "# medium", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "# large", "\n", "[", "96", "**", "2", ",", "128", "**", "2", "]", ",", "# 96-128", "\n", "[", "128", "**", "2", ",", "256", "**", "2", "]", ",", "# 128-256", "\n", "[", "256", "**", "2", ",", "512", "**", "2", "]", ",", "# 256-512", "\n", "[", "512", "**", "2", ",", "1e5", "**", "2", "]", ",", "# 512-inf", "\n", "]", "\n", "assert", "areas", ".", "has_key", "(", "area", ")", ",", "'unknown area range: {}'", ".", "format", "(", "area", ")", "\n", "area_range", "=", "area_ranges", "[", "areas", "[", "area", "]", "]", "\n", "gt_overlaps", "=", "np", ".", "zeros", "(", "0", ")", "\n", "num_pos", "=", "0", "\n", "for", "i", "in", "range", "(", "self", ".", "num_images", ")", ":", "\n", "# Checking for max_overlaps == 1 avoids including crowd annotations", "\n", "# (...pretty hacking :/)", "\n", "            ", "max_gt_overlaps", "=", "self", ".", "roidb", "[", "i", "]", "[", "'gt_overlaps'", "]", ".", "toarray", "(", ")", ".", "max", "(", "axis", "=", "1", ")", "\n", "gt_inds", "=", "np", ".", "where", "(", "(", "self", ".", "roidb", "[", "i", "]", "[", "'gt_classes'", "]", ">", "0", ")", "&", "\n", "(", "max_gt_overlaps", "==", "1", ")", ")", "[", "0", "]", "\n", "gt_boxes", "=", "self", ".", "roidb", "[", "i", "]", "[", "'boxes'", "]", "[", "gt_inds", ",", ":", "]", "\n", "gt_areas", "=", "self", ".", "roidb", "[", "i", "]", "[", "'seg_areas'", "]", "[", "gt_inds", "]", "\n", "valid_gt_inds", "=", "np", ".", "where", "(", "(", "gt_areas", ">=", "area_range", "[", "0", "]", ")", "&", "\n", "(", "gt_areas", "<=", "area_range", "[", "1", "]", ")", ")", "[", "0", "]", "\n", "gt_boxes", "=", "gt_boxes", "[", "valid_gt_inds", ",", ":", "]", "\n", "num_pos", "+=", "len", "(", "valid_gt_inds", ")", "\n", "\n", "if", "candidate_boxes", "is", "None", ":", "\n", "# If candidate_boxes is not supplied, the default is to use the", "\n", "# non-ground-truth boxes from this roidb", "\n", "                ", "non_gt_inds", "=", "np", ".", "where", "(", "self", ".", "roidb", "[", "i", "]", "[", "'gt_classes'", "]", "==", "0", ")", "[", "0", "]", "\n", "boxes", "=", "self", ".", "roidb", "[", "i", "]", "[", "'boxes'", "]", "[", "non_gt_inds", ",", ":", "]", "\n", "", "else", ":", "\n", "                ", "boxes", "=", "candidate_boxes", "[", "i", "]", "\n", "", "if", "boxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "if", "limit", "is", "not", "None", "and", "boxes", ".", "shape", "[", "0", "]", ">", "limit", ":", "\n", "                ", "boxes", "=", "boxes", "[", ":", "limit", ",", ":", "]", "\n", "\n", "", "overlaps", "=", "bbox_overlaps", "(", "boxes", ".", "astype", "(", "np", ".", "float", ")", ",", "\n", "gt_boxes", ".", "astype", "(", "np", ".", "float", ")", ")", "\n", "\n", "_gt_overlaps", "=", "np", ".", "zeros", "(", "(", "gt_boxes", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "j", "in", "range", "(", "gt_boxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "# find which proposal box maximally covers each gt box", "\n", "                ", "argmax_overlaps", "=", "overlaps", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "# and get the iou amount of coverage for each gt box", "\n", "max_overlaps", "=", "overlaps", ".", "max", "(", "axis", "=", "0", ")", "\n", "# find which gt box is 'best' covered (i.e. 'best' = most iou)", "\n", "gt_ind", "=", "max_overlaps", ".", "argmax", "(", ")", "\n", "gt_ovr", "=", "max_overlaps", ".", "max", "(", ")", "\n", "assert", "(", "gt_ovr", ">=", "0", ")", "\n", "# find the proposal box that covers the best covered gt box", "\n", "box_ind", "=", "argmax_overlaps", "[", "gt_ind", "]", "\n", "# record the iou coverage of this gt box", "\n", "_gt_overlaps", "[", "j", "]", "=", "overlaps", "[", "box_ind", ",", "gt_ind", "]", "\n", "assert", "(", "_gt_overlaps", "[", "j", "]", "==", "gt_ovr", ")", "\n", "# mark the proposal box and the gt box as used", "\n", "overlaps", "[", "box_ind", ",", ":", "]", "=", "-", "1", "\n", "overlaps", "[", ":", ",", "gt_ind", "]", "=", "-", "1", "\n", "# append recorded iou coverage level", "\n", "", "gt_overlaps", "=", "np", ".", "hstack", "(", "(", "gt_overlaps", ",", "_gt_overlaps", ")", ")", "\n", "\n", "", "gt_overlaps", "=", "np", ".", "sort", "(", "gt_overlaps", ")", "\n", "if", "thresholds", "is", "None", ":", "\n", "            ", "step", "=", "0.05", "\n", "thresholds", "=", "np", ".", "arange", "(", "0.5", ",", "0.95", "+", "1e-5", ",", "step", ")", "\n", "", "recalls", "=", "np", ".", "zeros_like", "(", "thresholds", ")", "\n", "# compute recall for each iou threshold", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "            ", "recalls", "[", "i", "]", "=", "(", "gt_overlaps", ">=", "t", ")", ".", "sum", "(", ")", "/", "float", "(", "num_pos", ")", "\n", "# ar = 2 * np.trapz(recalls, thresholds)", "\n", "", "ar", "=", "recalls", ".", "mean", "(", ")", "\n", "return", "{", "'ar'", ":", "ar", ",", "'recalls'", ":", "recalls", ",", "'thresholds'", ":", "thresholds", ",", "\n", "'gt_overlaps'", ":", "gt_overlaps", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.create_roidb_from_box_list": [[236, 264], ["range", "len", "numpy.zeros", "scipy.sparse.csr_matrix", "roidb.append", "bbox.bbox.bbox_overlaps", "bbox.bbox.bbox_overlaps.argmax", "bbox.bbox.bbox_overlaps.max", "boxes.astype", "gt_boxes.astype", "numpy.where", "numpy.zeros", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps"], ["", "def", "create_roidb_from_box_list", "(", "self", ",", "box_list", ",", "gt_roidb", ")", ":", "\n", "        ", "assert", "len", "(", "box_list", ")", "==", "self", ".", "num_images", ",", "'Number of boxes must match number of ground-truth images'", "\n", "roidb", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_images", ")", ":", "\n", "            ", "boxes", "=", "box_list", "[", "i", "]", "\n", "num_boxes", "=", "boxes", ".", "shape", "[", "0", "]", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "num_boxes", ",", "self", ".", "num_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "if", "gt_roidb", "is", "not", "None", "and", "gt_roidb", "[", "i", "]", "[", "'boxes'", "]", ".", "size", ">", "0", ":", "\n", "                ", "gt_boxes", "=", "gt_roidb", "[", "i", "]", "[", "'boxes'", "]", "\n", "gt_classes", "=", "gt_roidb", "[", "i", "]", "[", "'gt_classes'", "]", "\n", "gt_overlaps", "=", "bbox_overlaps", "(", "boxes", ".", "astype", "(", "np", ".", "float", ")", ",", "\n", "gt_boxes", ".", "astype", "(", "np", ".", "float", ")", ")", "\n", "argmaxes", "=", "gt_overlaps", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "maxes", "=", "gt_overlaps", ".", "max", "(", "axis", "=", "1", ")", "\n", "I", "=", "np", ".", "where", "(", "maxes", ">", "0", ")", "[", "0", "]", "\n", "overlaps", "[", "I", ",", "gt_classes", "[", "argmaxes", "[", "I", "]", "]", "]", "=", "maxes", "[", "I", "]", "\n", "\n", "", "overlaps", "=", "scipy", ".", "sparse", ".", "csr_matrix", "(", "overlaps", ")", "\n", "roidb", ".", "append", "(", "{", "\n", "'boxes'", ":", "boxes", ",", "\n", "'gt_classes'", ":", "np", ".", "zeros", "(", "(", "num_boxes", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", ",", "\n", "'gt_overlaps'", ":", "overlaps", ",", "\n", "'flipped'", ":", "False", ",", "\n", "'seg_areas'", ":", "np", ".", "zeros", "(", "(", "num_boxes", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "}", ")", "\n", "", "return", "roidb", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.merge_roidbs": [[265, 277], ["range", "len", "len", "len", "numpy.vstack", "numpy.hstack", "scipy.sparse.vstack", "numpy.hstack"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "merge_roidbs", "(", "a", ",", "b", ")", ":", "\n", "        ", "assert", "len", "(", "a", ")", "==", "len", "(", "b", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "a", ")", ")", ":", "\n", "            ", "a", "[", "i", "]", "[", "'boxes'", "]", "=", "np", ".", "vstack", "(", "(", "a", "[", "i", "]", "[", "'boxes'", "]", ",", "b", "[", "i", "]", "[", "'boxes'", "]", ")", ")", "\n", "a", "[", "i", "]", "[", "'gt_classes'", "]", "=", "np", ".", "hstack", "(", "(", "a", "[", "i", "]", "[", "'gt_classes'", "]", ",", "\n", "b", "[", "i", "]", "[", "'gt_classes'", "]", ")", ")", "\n", "a", "[", "i", "]", "[", "'gt_overlaps'", "]", "=", "scipy", ".", "sparse", ".", "vstack", "(", "[", "a", "[", "i", "]", "[", "'gt_overlaps'", "]", ",", "\n", "b", "[", "i", "]", "[", "'gt_overlaps'", "]", "]", ")", "\n", "a", "[", "i", "]", "[", "'seg_areas'", "]", "=", "np", ".", "hstack", "(", "(", "a", "[", "i", "]", "[", "'seg_areas'", "]", ",", "\n", "b", "[", "i", "]", "[", "'seg_areas'", "]", ")", ")", "\n", "", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.imdb.imdb.competition_mode": [[278, 281], ["None"], "methods", ["None"], ["", "def", "competition_mode", "(", "self", ",", "on", ")", ":", "\n", "        ", "\"\"\"Turn competition mode on or off.\"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.__init__": [[41, 116], ["upsnet.dataset.base_dataset.BaseDataset.__init__", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "zip", "upsnet.dataset.json_dataset.filter_for_training", "upsnet.dataset.json_dataset.add_bbox_regression_targets", "upsnet.dataset.json_dataset.JsonDataset", "cityscapes.Cityscapes.dataset.get_roidb", "len", "_.strip", "len", "len", "upsnet.dataset.json_dataset.JsonDataset", "upsnet.dataset.json_dataset.JsonDataset.get_roidb", "roidbs.append", "upsnet.dataset.json_dataset.filter_for_training.extend", "len", "upsnet.dataset.json_dataset.extend_with_flipped_entries", "upsnet.dataset.json_dataset.filter_for_training", "upsnet.dataset.json_dataset.add_bbox_regression_targets", "open().readlines", "upsnet.dataset.json_dataset.extend_with_flipped_entries", "os.path.join", "lib.utils.logging.logger.info", "os.path.join", "lib.utils.logging.logger.info", "open"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.filter_for_training", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.add_bbox_regression_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.get_roidb", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.get_roidb", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.extend_with_flipped_entries", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.filter_for_training", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.add_bbox_regression_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.extend_with_flipped_entries"], ["    ", "def", "__init__", "(", "self", ",", "image_sets", ",", "flip", "=", "False", ",", "proposal_files", "=", "None", ",", "phase", "=", "'train'", ",", "result_path", "=", "''", ")", ":", "\n", "\n", "        ", "super", "(", "Cityscapes", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "image_dirs", "=", "{", "\n", "'train'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ")", ",", "\n", "'val'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ")", ",", "\n", "'test'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ")", ",", "\n", "'train_extra'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ")", ",", "\n", "'debug'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ")", ",", "\n", "}", "\n", "\n", "self", ".", "anno_files", "=", "{", "\n", "'train'", ":", "'instancesonly_gtFine_train.json'", ",", "\n", "'val'", ":", "'instancesonly_gtFine_val.json'", ",", "\n", "'test'", ":", "'image_info_test.json'", ",", "\n", "'train_extra'", ":", "'instancesonly_gtCoarse_train_extra.json'", ",", "\n", "'debug'", ":", "'instancesonly_gtFine_debug.json'", ",", "\n", "}", "\n", "\n", "self", ".", "panoptic_json_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "'cityscapes_fine_val.json'", ")", "\n", "self", ".", "panoptic_gt_folder", "=", "'data/cityscapes/panoptic'", "\n", "\n", "self", ".", "flip", "=", "flip", "\n", "self", ".", "result_path", "=", "result_path", "\n", "self", ".", "num_classes", "=", "9", "\n", "self", ".", "phase", "=", "phase", "\n", "self", ".", "image_sets", "=", "image_sets", "\n", "\n", "if", "image_sets", "[", "0", "]", "==", "'demoVideo'", ":", "\n", "            ", "assert", "len", "(", "image_sets", ")", "==", "1", "\n", "assert", "phase", "==", "'test'", "\n", "im_path", "=", "[", "_", ".", "strip", "(", ")", "for", "_", "in", "open", "(", "'data/cityscapes/split/demoVideo_img.txt'", ",", "'r'", ")", ".", "readlines", "(", ")", "]", "\n", "self", ".", "roidb", "=", "[", "{", "'image'", ":", "_", ",", "'flipped'", ":", "False", "}", "for", "_", "in", "im_path", "]", "\n", "return", "\n", "\n", "", "if", "proposal_files", "is", "None", ":", "\n", "            ", "proposal_files", "=", "[", "None", "]", "*", "len", "(", "image_sets", ")", "\n", "\n", "", "if", "phase", "==", "'train'", "and", "len", "(", "image_sets", ")", ">", "1", ":", "\n", "# combine multiple datasets", "\n", "            ", "roidbs", "=", "[", "]", "\n", "for", "image_set", ",", "proposal_file", "in", "zip", "(", "image_sets", ",", "proposal_files", ")", ":", "\n", "                ", "dataset", "=", "JsonDataset", "(", "'cityscapes_'", "+", "image_set", ",", "\n", "image_dir", "=", "self", ".", "image_dirs", "[", "image_set", "]", ",", "\n", "anno_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "self", ".", "anno_files", "[", "image_set", "]", ")", ")", "\n", "roidb", "=", "dataset", ".", "get_roidb", "(", "gt", "=", "True", ",", "proposal_file", "=", "proposal_file", ",", "crowd_filter_thresh", "=", "config", ".", "train", ".", "crowd_filter_thresh", ")", "\n", "if", "flip", ":", "\n", "                    ", "if", "logger", ":", "\n", "                        ", "logger", ".", "info", "(", "'Appending horizontally-flipped training examples...'", ")", "\n", "", "extend_with_flipped_entries", "(", "roidb", ",", "dataset", ")", "\n", "", "roidbs", ".", "append", "(", "roidb", ")", "\n", "", "roidb", "=", "roidbs", "[", "0", "]", "\n", "for", "r", "in", "roidbs", "[", "1", ":", "]", ":", "\n", "                ", "roidb", ".", "extend", "(", "r", ")", "\n", "", "roidb", "=", "filter_for_training", "(", "roidb", ")", "\n", "add_bbox_regression_targets", "(", "roidb", ")", "\n", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "image_sets", ")", "==", "1", "\n", "self", ".", "dataset", "=", "JsonDataset", "(", "'cityscapes_'", "+", "image_sets", "[", "0", "]", ",", "\n", "image_dir", "=", "self", ".", "image_dirs", "[", "image_sets", "[", "0", "]", "]", ",", "\n", "anno_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "\n", "self", ".", "anno_files", "[", "image_sets", "[", "0", "]", "]", ")", ")", "\n", "roidb", "=", "self", ".", "dataset", ".", "get_roidb", "(", "gt", "=", "True", ",", "proposal_file", "=", "proposal_files", "[", "0", "]", ",", "\n", "crowd_filter_thresh", "=", "config", ".", "train", ".", "crowd_filter_thresh", "if", "phase", "!=", "'test'", "else", "0", ")", "\n", "if", "flip", ":", "\n", "                ", "if", "logger", ":", "\n", "                    ", "logger", ".", "info", "(", "'Appending horizontally-flipped training examples...'", ")", "\n", "", "extend_with_flipped_entries", "(", "roidb", ",", "self", ".", "dataset", ")", "\n", "", "if", "phase", "!=", "'test'", ":", "\n", "                ", "roidb", "=", "filter_for_training", "(", "roidb", ")", "\n", "add_bbox_regression_targets", "(", "roidb", ")", "\n", "\n", "", "", "self", ".", "roidb", "=", "roidb", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.__getitem__": [[117, 194], ["collections.defaultdict", "cityscapes.Cityscapes.get_image_blob", "upsnet.rpn.assign_anchor.add_rpn_blobs", "upsnet.bbox.sample_rois.sample_rois", "numpy.array", "cv2.resize", "label.update", "label.update", "label.update", "range", "label.update", "numpy.array", "numpy.array", "frcn_blob[].astype", "frcn_blob[].astype", "frcn_blob[].astype", "frcn_blob[].astype", "frcn_blob[].astype", "frcn_blob[].astype", "frcn_blob[].astype", "numpy.hstack().astype", "numpy.array", "PIL.Image.open", "numpy.fliplr", "len", "PIL.Image.new", "range", "cv2.resize", "numpy.around().astype", "label.update", "range", "[].replace().replace", "numpy.zeros", "len", "PIL.ImageDraw.Draw().polygon", "numpy.array", "len", "cv2.resize", "blob[].astype", "numpy.hstack", "int", "int", "tuple", "numpy.around", "numpy.zeros", "[].replace", "len", "PIL.ImageDraw.Draw", "numpy.where", "numpy.zeros", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_image_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor.add_rpn_blobs", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois.sample_rois", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "blob", "=", "defaultdict", "(", "list", ")", "\n", "im_blob", ",", "im_scales", "=", "self", ".", "get_image_blob", "(", "[", "self", ".", "roidb", "[", "index", "]", "]", ")", "\n", "if", "config", ".", "network", ".", "has_rpn", ":", "\n", "            ", "if", "self", ".", "phase", "!=", "'test'", ":", "\n", "                ", "add_rpn_blobs", "(", "blob", ",", "im_scales", ",", "[", "self", ".", "roidb", "[", "index", "]", "]", ")", "\n", "data", "=", "{", "'data'", ":", "im_blob", ",", "\n", "'im_info'", ":", "blob", "[", "'im_info'", "]", "}", "\n", "label", "=", "{", "'roidb'", ":", "blob", "[", "'roidb'", "]", "[", "0", "]", "}", "\n", "for", "stride", "in", "config", ".", "network", ".", "rpn_feat_stride", ":", "\n", "                    ", "label", ".", "update", "(", "{", "\n", "'rpn_labels_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "'rpn_labels_int32_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ".", "astype", "(", "\n", "np", ".", "int64", ")", ",", "\n", "'rpn_bbox_targets_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "'rpn_bbox_targets_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ",", "\n", "'rpn_bbox_inside_weights_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "\n", "'rpn_bbox_inside_weights_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ",", "\n", "'rpn_bbox_outside_weights_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "\n", "'rpn_bbox_outside_weights_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", "\n", "}", ")", "\n", "", "", "else", ":", "\n", "                ", "data", "=", "{", "'data'", ":", "im_blob", ",", "\n", "'im_info'", ":", "np", ".", "array", "(", "[", "[", "im_blob", ".", "shape", "[", "-", "2", "]", ",", "\n", "im_blob", ".", "shape", "[", "-", "1", "]", ",", "\n", "im_scales", "[", "0", "]", "]", "]", ",", "np", ".", "float32", ")", ",", "\n", "}", "\n", "label", "=", "{", "'roidb'", ":", "self", ".", "roidb", "[", "index", "]", "}", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "phase", "!=", "'test'", ":", "\n", "                ", "frcn_blob", "=", "sample_rois", "(", "self", ".", "roidb", "[", "index", "]", ",", "im_scales", ",", "0", ")", "\n", "\n", "data", "=", "{", "'data'", ":", "im_blob", ",", "\n", "'im_info'", ":", "np", ".", "array", "(", "[", "[", "im_blob", ".", "shape", "[", "-", "2", "]", ",", "\n", "im_blob", ".", "shape", "[", "-", "1", "]", ",", "\n", "im_scales", "[", "0", "]", "]", "]", ",", "np", ".", "float32", ")", "}", "\n", "label", "=", "{", "'rois'", ":", "frcn_blob", "[", "'rois'", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "'cls_label'", ":", "frcn_blob", "[", "'labels_int32'", "]", ".", "astype", "(", "np", ".", "int64", ")", ",", "\n", "'bbox_target'", ":", "frcn_blob", "[", "'bbox_targets'", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "'bbox_inside_weight'", ":", "frcn_blob", "[", "'bbox_inside_weights'", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "'bbox_outside_weight'", ":", "frcn_blob", "[", "'bbox_outside_weights'", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "'mask_rois'", ":", "frcn_blob", "[", "'mask_rois'", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "'mask_target'", ":", "frcn_blob", "[", "'mask_int32'", "]", ".", "astype", "(", "np", ".", "float32", ")", "}", "\n", "", "else", ":", "\n", "                ", "data", "=", "{", "'data'", ":", "im_blob", ",", "\n", "'rois'", ":", "np", ".", "hstack", "(", "(", "np", ".", "zeros", "(", "(", "self", ".", "roidb", "[", "index", "]", "[", "'boxes'", "]", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "self", ".", "roidb", "[", "index", "]", "[", "'boxes'", "]", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "'im_info'", ":", "np", ".", "array", "(", "[", "[", "im_blob", ".", "shape", "[", "-", "2", "]", ",", "\n", "im_blob", ".", "shape", "[", "-", "1", "]", ",", "\n", "im_scales", "[", "0", "]", "]", "]", ",", "np", ".", "float32", ")", ",", "\n", "'id'", ":", "self", ".", "roidb", "[", "index", "]", "[", "'id'", "]", "}", "\n", "label", "=", "None", "\n", "", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "            ", "if", "self", ".", "phase", "!=", "'test'", ":", "\n", "                ", "seg_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "self", ".", "roidb", "[", "index", "]", "[", "'image'", "]", ".", "replace", "(", "'images'", ",", "'labels'", ")", ".", "replace", "(", "'leftImg8bit.png'", ",", "'gtFine_labelTrainIds.png'", ")", ")", ")", "\n", "if", "self", ".", "roidb", "[", "index", "]", "[", "'flipped'", "]", ":", "\n", "                    ", "seg_gt", "=", "np", ".", "fliplr", "(", "seg_gt", ")", "\n", "", "seg_gt", "=", "cv2", ".", "resize", "(", "seg_gt", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "label", ".", "update", "(", "{", "'seg_gt'", ":", "seg_gt", "}", ")", "\n", "label", ".", "update", "(", "{", "'gt_classes'", ":", "label", "[", "'roidb'", "]", "[", "'gt_classes'", "]", "}", ")", "\n", "label", ".", "update", "(", "{", "'mask_gt'", ":", "np", ".", "zeros", "(", "(", "len", "(", "label", "[", "'gt_classes'", "]", ")", ",", "im_blob", ".", "shape", "[", "-", "2", "]", ",", "im_blob", ".", "shape", "[", "-", "1", "]", ")", ")", "}", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "label", "[", "'gt_classes'", "]", ")", ")", ":", "\n", "                    ", "img", "=", "Image", ".", "new", "(", "'L'", ",", "(", "int", "(", "im_blob", ".", "shape", "[", "-", "1", "]", "/", "im_scales", "[", "0", "]", ")", ",", "int", "(", "im_blob", ".", "shape", "[", "-", "2", "]", "/", "im_scales", "[", "0", "]", ")", ")", ",", "0", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", ")", ":", "\n", "                        ", "ImageDraw", ".", "Draw", "(", "img", ")", ".", "polygon", "(", "tuple", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "j", "]", ")", ",", "outline", "=", "1", ",", "fill", "=", "1", ")", "\n", "", "label", "[", "'mask_gt'", "]", "[", "i", "]", "=", "cv2", ".", "resize", "(", "np", ".", "array", "(", "img", ")", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "                    ", "gt_boxes", "=", "label", "[", "'roidb'", "]", "[", "'boxes'", "]", "[", "np", ".", "where", "(", "label", "[", "'roidb'", "]", "[", "'gt_classes'", "]", ">", "0", ")", "[", "0", "]", "]", "\n", "gt_boxes", "=", "np", ".", "around", "(", "gt_boxes", "*", "im_scales", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "label", ".", "update", "(", "{", "'seg_roi_gt'", ":", "np", ".", "zeros", "(", "(", "len", "(", "gt_boxes", ")", ",", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ",", "dtype", "=", "np", ".", "int64", ")", "}", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "gt_boxes", ")", ")", ":", "\n", "                        ", "if", "gt_boxes", "[", "i", "]", "[", "3", "]", "==", "gt_boxes", "[", "i", "]", "[", "1", "]", ":", "\n", "                            ", "gt_boxes", "[", "i", "]", "[", "3", "]", "+=", "1", "\n", "", "if", "gt_boxes", "[", "i", "]", "[", "2", "]", "==", "gt_boxes", "[", "i", "]", "[", "0", "]", ":", "\n", "                            ", "gt_boxes", "[", "i", "]", "[", "2", "]", "+=", "1", "\n", "", "label", "[", "'seg_roi_gt'", "]", "[", "i", "]", "=", "cv2", ".", "resize", "(", "seg_gt", "[", "gt_boxes", "[", "i", "]", "[", "1", "]", ":", "gt_boxes", "[", "i", "]", "[", "3", "]", ",", "gt_boxes", "[", "i", "]", "[", "0", "]", ":", "gt_boxes", "[", "i", "]", "[", "2", "]", "]", ",", "(", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "", "", "else", ":", "\n", "                ", "pass", "\n", "\n", "", "", "return", "data", ",", "label", ",", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.get_image_blob": [[195, 235], ["len", "range", "numpy.random.randint", "numpy.random.randint", "cv2.imread", "im_scales.append", "processed_ims.append", "len", "cityscapes.Cityscapes.prep_im_for_blob", "cityscapes.Cityscapes.prep_im_for_blob", "im[].transpose", "len", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.prep_im_for_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.prep_im_for_blob"], ["", "def", "get_image_blob", "(", "self", ",", "roidb", ")", ":", "\n", "        ", "\"\"\"Builds an input blob from the images in the roidb at the specified\n        scales.\n        \"\"\"", "\n", "num_images", "=", "len", "(", "roidb", ")", "\n", "# Sample random scales to use for each image in this batch", "\n", "if", "self", ".", "phase", "==", "'train'", ":", "\n", "            ", "scale_inds", "=", "np", ".", "random", ".", "randint", "(", "\n", "0", ",", "high", "=", "len", "(", "config", ".", "train", ".", "scales", ")", ",", "size", "=", "num_images", "\n", ")", "\n", "", "else", ":", "\n", "            ", "scale_inds", "=", "np", ".", "random", ".", "randint", "(", "\n", "0", ",", "high", "=", "len", "(", "config", ".", "test", ".", "scales", ")", ",", "size", "=", "num_images", "\n", ")", "\n", "", "processed_ims", "=", "[", "]", "\n", "im_scales", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "im", "=", "cv2", ".", "imread", "(", "roidb", "[", "i", "]", "[", "'image'", "]", ")", "\n", "assert", "im", "is", "not", "None", ",", "'Failed to read image \\'{}\\''", ".", "format", "(", "roidb", "[", "i", "]", "[", "'image'", "]", ")", "\n", "if", "roidb", "[", "i", "]", "[", "'flipped'", "]", ":", "\n", "                ", "im", "=", "im", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "if", "self", ".", "phase", "==", "'train'", ":", "\n", "                ", "target_size", "=", "config", ".", "train", ".", "scales", "[", "scale_inds", "[", "i", "]", "]", "\n", "im", ",", "im_scale", "=", "self", ".", "prep_im_for_blob", "(", "\n", "im", ",", "config", ".", "network", ".", "pixel_means", ",", "[", "target_size", "]", ",", "config", ".", "train", ".", "max_size", "\n", ")", "\n", "", "else", ":", "\n", "                ", "target_size", "=", "config", ".", "test", ".", "scales", "[", "scale_inds", "[", "i", "]", "]", "\n", "im", ",", "im_scale", "=", "self", ".", "prep_im_for_blob", "(", "\n", "im", ",", "config", ".", "network", ".", "pixel_means", ",", "[", "target_size", "]", ",", "config", ".", "test", ".", "max_size", "\n", ")", "\n", "", "im_scales", ".", "append", "(", "im_scale", "[", "0", "]", ")", "\n", "processed_ims", ".", "append", "(", "im", "[", "0", "]", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "# Create a blob to hold the input images", "\n", "", "assert", "len", "(", "processed_ims", ")", "==", "1", "\n", "blob", "=", "processed_ims", "[", "0", "]", "\n", "\n", "return", "blob", ",", "im_scales", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.vis_all_mask": [[236, 346], ["matplotlib.use", "range", "os.makedirs", "len", "numpy.array", "plt.figure", "plt.figure.set_size_inches", "plt.Axes", "plt.Axes.axis", "plt.figure.add_axes", "plt.Axes.imshow", "enumerate", "plt.close", "PIL.Image.open", "pycocotools.decode", "range", "plt.show", "plt.figure.savefig", "plt.Axes.add_patch", "plt.Axes.text", "cv2.findContours", "os.path.join", "plt.Rectangle", "mask.copy", "plt.Axes.add_patch", "dict", "Polygon", "c.reshape", "[].split"], "methods", ["None"], ["", "def", "vis_all_mask", "(", "self", ",", "all_boxes", ",", "all_masks", ",", "save_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        visualize all detections in one image\n        :param im_array: [b=1 c h w] in rgb\n        :param detections: [ numpy.ndarray([[x1 y1 x2 y2 score]]) for j in classes ]\n        :param class_names: list of names in imdb\n        :param scale: visualize the scaled image\n        :return:\n        \"\"\"", "\n", "import", "matplotlib", "\n", "matplotlib", ".", "use", "(", "'Agg'", ")", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "from", "matplotlib", ".", "patches", "import", "Polygon", "\n", "import", "random", "\n", "import", "cv2", "\n", "palette", "=", "{", "\n", "'person'", ":", "(", "220", ",", "20", ",", "60", ")", ",", "\n", "'rider'", ":", "(", "255", ",", "0", ",", "0", ")", ",", "\n", "'car'", ":", "(", "0", ",", "0", ",", "142", ")", ",", "\n", "'truck'", ":", "(", "0", ",", "0", ",", "70", ")", ",", "\n", "'bus'", ":", "(", "0", ",", "60", ",", "100", ")", ",", "\n", "'train'", ":", "(", "0", ",", "80", ",", "100", ")", ",", "\n", "'motorcycle'", ":", "(", "0", ",", "0", ",", "230", ")", ",", "\n", "'bicycle'", ":", "(", "119", ",", "11", ",", "32", ")", ",", "\n", "#", "\n", "'road'", ":", "(", "128", ",", "64", ",", "128", ")", ",", "\n", "'sidewalk'", ":", "(", "244", ",", "35", ",", "232", ")", ",", "\n", "'building'", ":", "(", "70", ",", "70", ",", "70", ")", ",", "\n", "'wall'", ":", "(", "102", ",", "102", ",", "156", ")", ",", "\n", "'fence'", ":", "(", "190", ",", "153", ",", "153", ")", ",", "\n", "'pole'", ":", "(", "153", ",", "153", ",", "153", ")", ",", "\n", "'sky'", ":", "(", "70", ",", "130", ",", "180", ")", ",", "\n", "'traffic light'", ":", "(", "250", ",", "170", ",", "30", ")", ",", "\n", "'traffic sign'", ":", "(", "220", ",", "220", ",", "0", ")", ",", "\n", "'vegetation'", ":", "(", "107", ",", "142", ",", "35", ")", ",", "\n", "'terrain'", ":", "(", "152", ",", "251", ",", "152", ")", "\n", "}", "\n", "name2id", "=", "{", "\n", "'road'", ":", "0", ",", "\n", "'sidewalk'", ":", "1", ",", "\n", "'building'", ":", "2", ",", "\n", "'wall'", ":", "3", ",", "\n", "'fence'", ":", "4", ",", "\n", "'pole'", ":", "5", ",", "\n", "'traffic light'", ":", "6", ",", "\n", "'traffic sign'", ":", "7", ",", "\n", "'vegetation'", ":", "8", ",", "\n", "'terrain'", ":", "9", ",", "\n", "'sky'", ":", "10", "\n", "}", "\n", "\n", "self", ".", "classes", "=", "[", "\n", "'__background__'", ",", "\n", "'person'", ",", "\n", "'rider'", ",", "\n", "'car'", ",", "\n", "'truck'", ",", "\n", "'bus'", ",", "\n", "'train'", ",", "\n", "'motorcycle'", ",", "\n", "'bicycle'", ",", "\n", "]", "\n", "\n", "if", "save_path", "is", "not", "None", ":", "\n", "            ", "os", ".", "makedirs", "(", "save_path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "roidb", ")", ")", ":", "\n", "\n", "            ", "im", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "self", ".", "roidb", "[", "i", "]", "[", "'image'", "]", ")", ")", "\n", "fig", "=", "plt", ".", "figure", "(", "frameon", "=", "False", ")", "\n", "\n", "fig", ".", "set_size_inches", "(", "im", ".", "shape", "[", "1", "]", "/", "200", ",", "im", ".", "shape", "[", "0", "]", "/", "200", ")", "\n", "ax", "=", "plt", ".", "Axes", "(", "fig", ",", "[", "0.", ",", "0.", ",", "1.", ",", "1.", "]", ")", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "fig", ".", "add_axes", "(", "ax", ")", "\n", "ax", ".", "imshow", "(", "im", ")", "\n", "for", "j", ",", "name", "in", "enumerate", "(", "self", ".", "classes", ")", ":", "\n", "                ", "if", "name", "==", "'__background__'", ":", "\n", "                    ", "continue", "\n", "", "boxes", "=", "all_boxes", "[", "j", "]", "[", "i", "]", "\n", "segms", "=", "all_masks", "[", "j", "]", "[", "i", "]", "\n", "if", "segms", "==", "[", "]", ":", "\n", "                    ", "continue", "\n", "", "masks", "=", "mask_util", ".", "decode", "(", "segms", ")", "\n", "for", "k", "in", "range", "(", "boxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "score", "=", "boxes", "[", "k", ",", "-", "1", "]", "\n", "mask", "=", "masks", "[", ":", ",", ":", ",", "k", "]", "\n", "if", "score", "<", "0.5", ":", "\n", "                        ", "continue", "\n", "", "bbox", "=", "boxes", "[", "k", ",", ":", "]", "\n", "ax", ".", "add_patch", "(", "\n", "plt", ".", "Rectangle", "(", "(", "bbox", "[", "0", "]", ",", "bbox", "[", "1", "]", ")", ",", "bbox", "[", "2", "]", "-", "bbox", "[", "0", "]", ",", "bbox", "[", "3", "]", "-", "bbox", "[", "1", "]", ",", "\n", "fill", "=", "False", ",", "edgecolor", "=", "'g'", ",", "linewidth", "=", "1", ",", "alpha", "=", "0.5", ")", "\n", ")", "\n", "ax", ".", "text", "(", "bbox", "[", "0", "]", ",", "bbox", "[", "1", "]", "-", "2", ",", "name", "+", "'{:0.2f}'", ".", "format", "(", "score", ")", ".", "lstrip", "(", "'0'", ")", ",", "fontsize", "=", "5", ",", "family", "=", "'serif'", ",", "\n", "bbox", "=", "dict", "(", "facecolor", "=", "'g'", ",", "alpha", "=", "0.4", ",", "pad", "=", "0", ",", "edgecolor", "=", "'none'", ")", ",", "color", "=", "'white'", ")", "\n", "_", ",", "contour", ",", "hier", "=", "cv2", ".", "findContours", "(", "mask", ".", "copy", "(", ")", ",", "cv2", ".", "RETR_CCOMP", ",", "cv2", ".", "CHAIN_APPROX_NONE", ")", "\n", "color", "=", "(", "palette", "[", "name", "]", "[", "0", "]", "/", "255", ",", "palette", "[", "name", "]", "[", "1", "]", "/", "255", ",", "palette", "[", "name", "]", "[", "2", "]", "/", "255", ")", "\n", "for", "c", "in", "contour", ":", "\n", "                        ", "ax", ".", "add_patch", "(", "\n", "Polygon", "(", "\n", "c", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", ",", "\n", "fill", "=", "True", ",", "facecolor", "=", "color", ",", "edgecolor", "=", "'w'", ",", "linewidth", "=", "0.8", ",", "alpha", "=", "0.5", "\n", ")", "\n", ")", "\n", "", "", "", "if", "save_path", "is", "None", ":", "\n", "                ", "plt", ".", "show", "(", ")", "\n", "", "else", ":", "\n", "                ", "fig", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "'{}.png'", ".", "format", "(", "self", ".", "roidb", "[", "i", "]", "[", "'image'", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "[", ":", "-", "16", "]", ")", ")", ",", "dpi", "=", "200", ")", "\n", "", "plt", ".", "close", "(", "'all'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.evaluate_masks": [[347, 398], ["os.path.join", "os.path.join", "os.path.join", "sys.path.insert", "sys.path.insert", "cityscapes.Cityscapes.dataset.get_roidb", "enumerate", "cityscapes_eval.main", "os.path.dirname", "os.path.join", "os.path.join", "os.path.join", "os.makedirs", "os.path.abspath", "os.path.abspath", "os.path.splitext", "os.path.join", "open", "range", "os.path.dirname", "os.path.dirname", "os.path.basename", "len", "pycocotools.decode", "range", "os.path.join", "fid_txt.write", "os.makedirs", "cv2.imwrite", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.get_roidb"], ["", "", "def", "evaluate_masks", "(", "\n", "self", ",", "\n", "all_boxes", ",", "\n", "all_segms", ",", "\n", "output_dir", ",", "\n", ")", ":", "\n", "        ", "res_file", "=", "os", ".", "path", ".", "join", "(", "\n", "output_dir", ",", "'segmentations_'", "+", "self", ".", "dataset", ".", "name", "+", "'_results'", ")", "\n", "res_file", "+=", "'.json'", "\n", "\n", "os", ".", "environ", "[", "'CITYSCAPES_DATASET'", "]", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "'../../data/cityscapes'", ")", "\n", "os", ".", "environ", "[", "'CITYSCAPES_RESULTS'", "]", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'inst_seg'", ")", "\n", "sys", ".", "path", ".", "insert", "(", "0", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ",", "'..'", ",", "'..'", ",", "'lib'", ",", "'dataset_devkit'", ",", "'cityscapesScripts'", ")", ")", "\n", "sys", ".", "path", ".", "insert", "(", "0", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ",", "'..'", ",", "'..'", ",", "'lib'", ",", "'dataset_devkit'", ",", "'cityscapesScripts'", ",", "'cityscapesscripts'", ",", "'evaluation'", ")", ")", "\n", "\n", "# Load the Cityscapes eval script *after* setting the required env vars,", "\n", "# since the script reads their values into global variables (at load time).", "\n", "import", "cityscapesscripts", ".", "evaluation", ".", "evalInstanceLevelSemanticLabeling", "as", "cityscapes_eval", "\n", "sys", ".", "argv", "=", "[", "]", "\n", "\n", "roidb", "=", "self", ".", "dataset", ".", "get_roidb", "(", ")", "\n", "for", "i", ",", "entry", "in", "enumerate", "(", "roidb", ")", ":", "\n", "            ", "im_name", "=", "entry", "[", "'image'", "]", "\n", "\n", "basename", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "im_name", ")", ")", "[", "0", "]", "\n", "txtname", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'inst_seg'", ",", "basename", "+", "'pred.txt'", ")", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'inst_seg'", ")", ",", "exist_ok", "=", "True", ")", "\n", "with", "open", "(", "txtname", ",", "'w'", ")", "as", "fid_txt", ":", "\n", "                ", "for", "j", "in", "range", "(", "1", ",", "len", "(", "all_segms", ")", ")", ":", "\n", "                    ", "clss", "=", "self", ".", "dataset", ".", "classes", "[", "j", "]", "\n", "clss_id", "=", "cityscapes_eval", ".", "name2label", "[", "clss", "]", ".", "id", "\n", "segms", "=", "all_segms", "[", "j", "]", "[", "i", "]", "\n", "boxes", "=", "all_boxes", "[", "j", "]", "[", "i", "]", "\n", "if", "segms", "==", "[", "]", ":", "\n", "                        ", "continue", "\n", "", "masks", "=", "mask_util", ".", "decode", "(", "segms", ")", "\n", "\n", "for", "k", "in", "range", "(", "boxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                        ", "score", "=", "boxes", "[", "k", ",", "-", "1", "]", "\n", "mask", "=", "masks", "[", ":", ",", ":", ",", "k", "]", "\n", "pngname", "=", "os", ".", "path", ".", "join", "(", "\n", "'seg_results'", ",", "basename", ",", "\n", "basename", "+", "'_'", "+", "clss", "+", "'_{}.png'", ".", "format", "(", "k", ")", ")", "\n", "# write txt", "\n", "fid_txt", ".", "write", "(", "'{} {} {}\\n'", ".", "format", "(", "pngname", ",", "clss_id", ",", "score", ")", ")", "\n", "# save mask", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'inst_seg'", ",", "'seg_results'", ",", "basename", ")", ",", "exist_ok", "=", "True", ")", "\n", "cv2", ".", "imwrite", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'inst_seg'", ",", "pngname", ")", ",", "mask", "*", "255", ")", "\n", "", "", "", "", "cityscapes_eval", ".", "main", "(", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.get_pallete": [[399, 443], ["numpy.zeros().astype", "numpy.zeros().astype", "range", "pallete.reshape.reshape.reshape", "len", "numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "get_pallete", "(", "self", ")", ":", "\n", "\n", "        ", "pallete_raw", "=", "np", ".", "zeros", "(", "(", "256", ",", "3", ")", ")", ".", "astype", "(", "'uint8'", ")", "\n", "pallete", "=", "np", ".", "zeros", "(", "(", "256", ",", "3", ")", ")", ".", "astype", "(", "'uint8'", ")", "\n", "\n", "pallete_raw", "[", "5", ",", ":", "]", "=", "[", "111", ",", "74", ",", "0", "]", "\n", "pallete_raw", "[", "6", ",", ":", "]", "=", "[", "81", ",", "0", ",", "81", "]", "\n", "pallete_raw", "[", "7", ",", ":", "]", "=", "[", "128", ",", "64", ",", "128", "]", "\n", "pallete_raw", "[", "8", ",", ":", "]", "=", "[", "244", ",", "35", ",", "232", "]", "\n", "pallete_raw", "[", "9", ",", ":", "]", "=", "[", "250", ",", "170", ",", "160", "]", "\n", "pallete_raw", "[", "10", ",", ":", "]", "=", "[", "230", ",", "150", ",", "140", "]", "\n", "pallete_raw", "[", "11", ",", ":", "]", "=", "[", "70", ",", "70", ",", "70", "]", "\n", "pallete_raw", "[", "12", ",", ":", "]", "=", "[", "102", ",", "102", ",", "156", "]", "\n", "pallete_raw", "[", "13", ",", ":", "]", "=", "[", "190", ",", "153", ",", "153", "]", "\n", "pallete_raw", "[", "14", ",", ":", "]", "=", "[", "180", ",", "165", ",", "180", "]", "\n", "pallete_raw", "[", "15", ",", ":", "]", "=", "[", "150", ",", "100", ",", "100", "]", "\n", "pallete_raw", "[", "16", ",", ":", "]", "=", "[", "150", ",", "120", ",", "90", "]", "\n", "pallete_raw", "[", "17", ",", ":", "]", "=", "[", "153", ",", "153", ",", "153", "]", "\n", "pallete_raw", "[", "18", ",", ":", "]", "=", "[", "153", ",", "153", ",", "153", "]", "\n", "pallete_raw", "[", "19", ",", ":", "]", "=", "[", "250", ",", "170", ",", "30", "]", "\n", "pallete_raw", "[", "20", ",", ":", "]", "=", "[", "220", ",", "220", ",", "0", "]", "\n", "pallete_raw", "[", "21", ",", ":", "]", "=", "[", "107", ",", "142", ",", "35", "]", "\n", "pallete_raw", "[", "22", ",", ":", "]", "=", "[", "152", ",", "251", ",", "152", "]", "\n", "pallete_raw", "[", "23", ",", ":", "]", "=", "[", "70", ",", "130", ",", "180", "]", "\n", "pallete_raw", "[", "24", ",", ":", "]", "=", "[", "220", ",", "20", ",", "60", "]", "\n", "pallete_raw", "[", "25", ",", ":", "]", "=", "[", "255", ",", "0", ",", "0", "]", "\n", "pallete_raw", "[", "26", ",", ":", "]", "=", "[", "0", ",", "0", ",", "142", "]", "\n", "pallete_raw", "[", "27", ",", ":", "]", "=", "[", "0", ",", "0", ",", "70", "]", "\n", "pallete_raw", "[", "28", ",", ":", "]", "=", "[", "0", ",", "60", ",", "100", "]", "\n", "pallete_raw", "[", "29", ",", ":", "]", "=", "[", "0", ",", "0", ",", "90", "]", "\n", "pallete_raw", "[", "30", ",", ":", "]", "=", "[", "0", ",", "0", ",", "110", "]", "\n", "pallete_raw", "[", "31", ",", ":", "]", "=", "[", "0", ",", "80", ",", "100", "]", "\n", "pallete_raw", "[", "32", ",", ":", "]", "=", "[", "0", ",", "0", ",", "230", "]", "\n", "pallete_raw", "[", "33", ",", ":", "]", "=", "[", "119", ",", "11", ",", "32", "]", "\n", "\n", "train2regular", "=", "[", "7", ",", "8", ",", "11", ",", "12", ",", "13", ",", "17", ",", "19", ",", "20", ",", "21", ",", "22", ",", "23", ",", "24", ",", "25", ",", "26", ",", "27", ",", "28", ",", "31", ",", "32", ",", "33", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "train2regular", ")", ")", ":", "\n", "            ", "pallete", "[", "i", ",", ":", "]", "=", "pallete_raw", "[", "train2regular", "[", "i", "]", ",", ":", "]", "\n", "\n", "", "pallete", "=", "pallete", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# return pallete_raw", "\n", "return", "pallete", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.evaluate_ssegs": [[445, 493], ["cityscapes.Cityscapes.write_segmentation_result", "numpy.zeros", "enumerate", "re.sub.sum", "re.sub.sum", "numpy.diag", "IU_array.mean", "lib.utils.logging.logger.info", "cityscapes.Cityscapes.evaluate_ssegs.convert_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.write_segmentation_result"], ["", "def", "evaluate_ssegs", "(", "self", ",", "pred_segmentations", ",", "res_file_folder", ")", ":", "\n", "        ", "self", ".", "write_segmentation_result", "(", "pred_segmentations", ",", "res_file_folder", ")", "\n", "\n", "confusion_matrix", "=", "np", ".", "zeros", "(", "(", "config", ".", "dataset", ".", "num_seg_classes", ",", "config", ".", "dataset", ".", "num_seg_classes", ")", ")", "\n", "for", "i", ",", "roidb", "in", "enumerate", "(", "self", ".", "roidb", ")", ":", "\n", "\n", "            ", "seg_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "roidb", "[", "'image'", "]", ".", "replace", "(", "'images'", ",", "'labels'", ")", ".", "replace", "(", "'leftImg8bit.png'", ",", "'gtFine_labelTrainIds.png'", ")", ")", ")", ".", "astype", "(", "'float32'", ")", "\n", "\n", "seg_pathes", "=", "os", ".", "path", ".", "split", "(", "roidb", "[", "'image'", "]", ".", "replace", "(", "'images'", ",", "'labels'", ")", ".", "replace", "(", "'leftImg8bit.png'", ",", "'gtFine_labelTrainIds.png'", ")", ")", "\n", "res_image_name", "=", "seg_pathes", "[", "-", "1", "]", "[", ":", "-", "len", "(", "'_gtFine_labelTrainIds.png'", ")", "]", "\n", "res_save_path", "=", "os", ".", "path", ".", "join", "(", "res_file_folder", ",", "res_image_name", "+", "'.png'", ")", "\n", "\n", "seg_pred", "=", "Image", ".", "open", "(", "res_save_path", ")", "\n", "\n", "seg_pred", "=", "np", ".", "array", "(", "seg_pred", ".", "resize", "(", "(", "seg_gt", ".", "shape", "[", "1", "]", ",", "seg_gt", ".", "shape", "[", "0", "]", ")", ",", "Image", ".", "NEAREST", ")", ")", "\n", "ignore_index", "=", "seg_gt", "!=", "255", "\n", "seg_gt", "=", "seg_gt", "[", "ignore_index", "]", "\n", "seg_pred", "=", "seg_pred", "[", "ignore_index", "]", "\n", "\n", "confusion_matrix", "+=", "self", ".", "get_confusion_matrix", "(", "seg_gt", ",", "seg_pred", ",", "config", ".", "dataset", ".", "num_seg_classes", ")", "\n", "\n", "", "pos", "=", "confusion_matrix", ".", "sum", "(", "1", ")", "\n", "res", "=", "confusion_matrix", ".", "sum", "(", "0", ")", "\n", "tp", "=", "np", ".", "diag", "(", "confusion_matrix", ")", "\n", "\n", "IU_array", "=", "(", "tp", "/", "np", ".", "maximum", "(", "1.0", ",", "pos", "+", "res", "-", "tp", ")", ")", "\n", "mean_IU", "=", "IU_array", ".", "mean", "(", ")", "\n", "\n", "evaluation_results", "=", "{", "'meanIU'", ":", "mean_IU", ",", "'IU_array'", ":", "IU_array", ",", "'confusion_matrix'", ":", "confusion_matrix", "}", "\n", "\n", "def", "convert_confusion_matrix", "(", "confusion_matrix", ")", ":", "\n", "            ", "cls_sum", "=", "confusion_matrix", ".", "sum", "(", "axis", "=", "1", ")", "\n", "confusion_matrix", "=", "confusion_matrix", "/", "cls_sum", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "return", "confusion_matrix", "\n", "\n", "", "logger", ".", "info", "(", "'evaluate segmentation:'", ")", "\n", "meanIU", "=", "evaluation_results", "[", "'meanIU'", "]", "\n", "IU_array", "=", "evaluation_results", "[", "'IU_array'", "]", "\n", "confusion_matrix", "=", "convert_confusion_matrix", "(", "evaluation_results", "[", "'confusion_matrix'", "]", ")", "\n", "logger", ".", "info", "(", "'IU_array:'", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "IU_array", ")", ")", ":", "\n", "            ", "logger", ".", "info", "(", "'%.5f'", "%", "IU_array", "[", "i", "]", ")", "\n", "", "logger", ".", "info", "(", "'meanIU:%.5f'", "%", "meanIU", ")", "\n", "np", ".", "set_printoptions", "(", "precision", "=", "3", ",", "suppress", "=", "True", ",", "linewidth", "=", "200", ")", "\n", "import", "re", "\n", "confusion_matrix", "=", "re", ".", "sub", "(", "'[\\[\\]]'", ",", "''", ",", "np", ".", "array2string", "(", "confusion_matrix", ",", "separator", "=", "'\\t'", ")", ")", "\n", "logger", ".", "info", "(", "'confusion_matrix:'", ")", "\n", "logger", ".", "info", "(", "confusion_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.write_segmentation_result": [[494, 515], ["cityscapes.Cityscapes.get_pallete", "enumerate", "os.path.exists", "os.mkdir", "os.path.split", "os.path.join", "numpy.uint8", "PIL.Image.fromarray", "PIL.Image.fromarray.putpalette", "PIL.Image.fromarray.save", "numpy.squeeze", "numpy.copy", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.cityscapes.Cityscapes.get_pallete"], ["", "def", "write_segmentation_result", "(", "self", ",", "segmentation_results", ",", "res_file_folder", ")", ":", "\n", "        ", "\"\"\"\n        Write the segmentation result to result_file_folder\n        :param segmentation_results: the prediction result\n        :param result_file_folder: the saving folder\n        :return: [None]\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "res_file_folder", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "res_file_folder", ")", "\n", "\n", "", "pallete", "=", "self", ".", "get_pallete", "(", ")", "\n", "for", "i", ",", "roidb", "in", "enumerate", "(", "self", ".", "roidb", ")", ":", "\n", "\n", "            ", "seg_pathes", "=", "os", ".", "path", ".", "split", "(", "roidb", "[", "'image'", "]", ")", "\n", "res_image_name", "=", "seg_pathes", "[", "-", "1", "]", "[", ":", "-", "len", "(", "'_leftImg8bit.png'", ")", "]", "\n", "res_save_path", "=", "os", ".", "path", ".", "join", "(", "res_file_folder", ",", "res_image_name", "+", "'.png'", ")", "\n", "\n", "segmentation_result", "=", "np", ".", "uint8", "(", "np", ".", "squeeze", "(", "np", ".", "copy", "(", "segmentation_results", "[", "i", "]", ")", ")", ")", "\n", "segmentation_result", "=", "Image", ".", "fromarray", "(", "segmentation_result", ")", "\n", "segmentation_result", ".", "putpalette", "(", "pallete", ")", "\n", "segmentation_result", ".", "save", "(", "res_save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.__init__": [[43, 104], ["upsnet.dataset.base_dataset.BaseDataset.__init__", "os.path.join", "os.path.join", "zip", "upsnet.dataset.json_dataset.filter_for_training", "upsnet.dataset.json_dataset.add_bbox_regression_targets", "upsnet.dataset.json_dataset.JsonDataset", "ade20k.ade20k.dataset.get_roidb", "len", "len", "upsnet.dataset.json_dataset.JsonDataset", "upsnet.dataset.json_dataset.JsonDataset.get_roidb", "roidbs.append", "upsnet.dataset.json_dataset.filter_for_training.extend", "len", "upsnet.dataset.json_dataset.extend_with_flipped_entries", "upsnet.dataset.json_dataset.filter_for_training", "upsnet.dataset.json_dataset.add_bbox_regression_targets", "upsnet.dataset.json_dataset.extend_with_flipped_entries", "os.path.join", "lib.utils.logging.logger.info", "os.path.join", "lib.utils.logging.logger.info"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.filter_for_training", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.add_bbox_regression_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.get_roidb", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.JsonDataset.get_roidb", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.extend_with_flipped_entries", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.filter_for_training", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.add_bbox_regression_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.json_dataset.extend_with_flipped_entries"], ["    ", "def", "__init__", "(", "self", ",", "image_sets", ",", "flip", "=", "False", ",", "proposal_files", "=", "None", ",", "phase", "=", "'train'", ",", "result_path", "=", "''", ")", ":", "\n", "\n", "        ", "super", "(", "ade20k", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "image_dirs", "=", "{", "\n", "'train'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ",", "'training'", ")", ",", "\n", "'val'", ":", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'images'", ",", "'validation'", ")", ",", "\n", "}", "\n", "\n", "anno_files", "=", "{", "\n", "'train'", ":", "'instances_training_gts.json'", ",", "\n", "'val'", ":", "'instances_validation_gts.json'", ",", "\n", "}", "\n", "\n", "# self.panoptic_json_file = os.path.join(config.dataset.dataset_path, 'annotations', 'panoptic_val2017_stff.json')", "\n", "# self.panoptic_gt_folder = os.path.join(config.dataset.dataset_path, 'annotations', 'panoptic_val2017')", "\n", "\n", "\n", "if", "proposal_files", "is", "None", ":", "\n", "            ", "proposal_files", "=", "[", "None", "]", "*", "len", "(", "image_sets", ")", "\n", "\n", "", "if", "phase", "==", "'train'", "and", "len", "(", "image_sets", ")", ">", "1", ":", "\n", "# combine multiple datasets", "\n", "            ", "roidbs", "=", "[", "]", "\n", "for", "image_set", ",", "proposal_file", "in", "zip", "(", "image_sets", ",", "proposal_files", ")", ":", "\n", "                ", "dataset", "=", "JsonDataset", "(", "'coco_'", "+", "image_set", ",", "\n", "image_dir", "=", "image_dirs", "[", "image_set", "]", ",", "\n", "anno_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "anno_files", "[", "image_set", "]", ")", ")", "\n", "roidb", "=", "dataset", ".", "get_roidb", "(", "gt", "=", "True", ",", "proposal_file", "=", "proposal_file", ",", "crowd_filter_thresh", "=", "config", ".", "train", ".", "crowd_filter_thresh", ")", "\n", "if", "flip", ":", "\n", "                    ", "if", "logger", ":", "\n", "                        ", "logger", ".", "info", "(", "'Appending horizontally-flipped training examples...'", ")", "\n", "", "extend_with_flipped_entries", "(", "roidb", ",", "dataset", ")", "\n", "", "roidbs", ".", "append", "(", "roidb", ")", "\n", "", "roidb", "=", "roidbs", "[", "0", "]", "\n", "for", "r", "in", "roidbs", "[", "1", ":", "]", ":", "\n", "                ", "roidb", ".", "extend", "(", "r", ")", "\n", "", "roidb", "=", "filter_for_training", "(", "roidb", ")", "\n", "add_bbox_regression_targets", "(", "roidb", ")", "\n", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "image_sets", ")", "==", "1", "\n", "self", ".", "dataset", "=", "JsonDataset", "(", "'ade20k_'", "+", "image_sets", "[", "0", "]", ",", "\n", "image_dir", "=", "image_dirs", "[", "image_sets", "[", "0", "]", "]", ",", "\n", "anno_file", "=", "os", ".", "path", ".", "join", "(", "config", ".", "dataset", ".", "dataset_path", ",", "'annotations'", ",", "\n", "anno_files", "[", "image_sets", "[", "0", "]", "]", ")", ")", "\n", "roidb", "=", "self", ".", "dataset", ".", "get_roidb", "(", "gt", "=", "phase", "!=", "'test'", ",", "proposal_file", "=", "proposal_files", "[", "0", "]", ",", "\n", "crowd_filter_thresh", "=", "config", ".", "train", ".", "crowd_filter_thresh", "if", "phase", "!=", "'test'", "else", "0", ")", "\n", "if", "flip", ":", "\n", "                ", "if", "logger", ":", "\n", "                    ", "logger", ".", "info", "(", "'Appending horizontally-flipped training examples...'", ")", "\n", "", "extend_with_flipped_entries", "(", "roidb", ",", "self", ".", "dataset", ")", "\n", "", "if", "phase", "!=", "'test'", ":", "\n", "                ", "roidb", "=", "filter_for_training", "(", "roidb", ")", "\n", "add_bbox_regression_targets", "(", "roidb", ")", "\n", "\n", "", "", "self", ".", "roidb", "=", "roidb", "\n", "self", ".", "phase", "=", "phase", "\n", "self", ".", "flip", "=", "flip", "\n", "self", ".", "result_path", "=", "result_path", "\n", "self", ".", "num_classes", "=", "101", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.__len__": [[107, 109], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "roidb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.__getitem__": [[110, 189], ["collections.defaultdict", "ade20k.ade20k.get_image_blob", "data.update", "upsnet.rpn.assign_anchor.add_rpn_blobs", "numpy.array", "cv2.resize", "label.update", "label.update", "label.update", "range", "numpy.array", "cv2.resize", "label.update", "ade20k.ade20k.build_crf_graph", "label.update", "numpy.array", "PIL.Image.open", "numpy.fliplr", "len", "numpy.around().astype", "label.update", "range", "PIL.Image.open", "numpy.fliplr", "[].replace", "numpy.zeros", "PIL.Image.new", "range", "cv2.resize", "len", "cv2.resize", "[].replace", "blob[].astype", "type", "type", "len", "PIL.ImageDraw.Draw().polygon", "numpy.array", "type", "cv2.resize", "pycocotools.decode", "cv2.resize", "numpy.around", "numpy.zeros", "len", "int", "int", "tuple", "type", "type", "len", "numpy.where", "numpy.round", "numpy.round", "PIL.ImageDraw.Draw", "pycocotools.decode", "len", "pycocotools.frPyObjects"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_image_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.rpn.assign_anchor.add_rpn_blobs", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "# index = (index + 2000) % len(self.roidb)", "\n", "        ", "blob", "=", "defaultdict", "(", "list", ")", "\n", "im_blob", ",", "im_scales", "=", "self", ".", "get_image_blob", "(", "[", "self", ".", "roidb", "[", "index", "]", "]", ")", "\n", "if", "config", ".", "network", ".", "has_rpn", ":", "\n", "            ", "if", "self", ".", "phase", "!=", "'test'", ":", "\n", "                ", "add_rpn_blobs", "(", "blob", ",", "im_scales", ",", "[", "self", ".", "roidb", "[", "index", "]", "]", ")", "\n", "data", "=", "{", "'data'", ":", "im_blob", ",", "\n", "'im_info'", ":", "blob", "[", "'im_info'", "]", "}", "\n", "label", "=", "{", "'roidb'", ":", "blob", "[", "'roidb'", "]", "[", "0", "]", "}", "\n", "for", "stride", "in", "config", ".", "network", ".", "rpn_feat_stride", ":", "\n", "                    ", "label", ".", "update", "(", "{", "\n", "'rpn_labels_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "'rpn_labels_int32_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ".", "astype", "(", "\n", "np", ".", "int64", ")", ",", "\n", "'rpn_bbox_targets_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "'rpn_bbox_targets_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ",", "\n", "'rpn_bbox_inside_weights_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "\n", "'rpn_bbox_inside_weights_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", ",", "\n", "'rpn_bbox_outside_weights_fpn{}'", ".", "format", "(", "stride", ")", ":", "blob", "[", "\n", "'rpn_bbox_outside_weights_wide_fpn{}'", ".", "format", "(", "stride", ")", "]", "\n", "}", ")", "\n", "", "", "else", ":", "\n", "                ", "data", "=", "{", "'data'", ":", "im_blob", ",", "\n", "'im_info'", ":", "np", ".", "array", "(", "[", "[", "im_blob", ".", "shape", "[", "-", "2", "]", ",", "\n", "im_blob", ".", "shape", "[", "-", "1", "]", ",", "\n", "im_scales", "[", "0", "]", "]", "]", ",", "np", ".", "float32", ")", "}", "\n", "label", "=", "{", "'roidb'", ":", "self", ".", "roidb", "[", "index", "]", "}", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "if", "config", ".", "network", ".", "has_fcn_head", ":", "\n", "            ", "if", "self", ".", "phase", "!=", "'test'", ":", "\n", "                ", "seg_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "self", ".", "roidb", "[", "index", "]", "[", "'image'", "]", ".", "replace", "(", "'images'", ",", "'annotations'", ")", ")", ")", "\n", "if", "self", ".", "roidb", "[", "index", "]", "[", "'flipped'", "]", ":", "\n", "                    ", "seg_gt", "=", "np", ".", "fliplr", "(", "seg_gt", ")", "\n", "", "seg_gt", "=", "cv2", ".", "resize", "(", "seg_gt", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "label", ".", "update", "(", "{", "'seg_gt'", ":", "seg_gt", "}", ")", "\n", "# label.update({'seg_gt_4x': cv2.resize(seg_gt, (im_blob.shape[-1] // 4, im_blob.shape[-2] // 4), interpolation=cv2.INTER_NEAREST)})", "\n", "label", ".", "update", "(", "{", "'gt_classes'", ":", "label", "[", "'roidb'", "]", "[", "'gt_classes'", "]", "}", ")", "\n", "label", ".", "update", "(", "{", "'mask_gt'", ":", "np", ".", "zeros", "(", "(", "len", "(", "label", "[", "'gt_classes'", "]", ")", ",", "im_blob", ".", "shape", "[", "-", "2", "]", ",", "im_blob", ".", "shape", "[", "-", "1", "]", ")", ")", "}", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "label", "[", "'gt_classes'", "]", ")", ")", ":", "\n", "                    ", "if", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "is", "list", "and", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "0", "]", ")", "is", "list", ":", "\n", "                        ", "img", "=", "Image", ".", "new", "(", "'L'", ",", "(", "int", "(", "np", ".", "round", "(", "im_blob", ".", "shape", "[", "-", "1", "]", "/", "im_scales", "[", "0", "]", ")", ")", ",", "int", "(", "np", ".", "round", "(", "im_blob", ".", "shape", "[", "-", "2", "]", "/", "im_scales", "[", "0", "]", ")", ")", ")", ",", "0", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", ")", ":", "\n", "                            ", "ImageDraw", ".", "Draw", "(", "img", ")", ".", "polygon", "(", "tuple", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "j", "]", ")", ",", "outline", "=", "1", ",", "fill", "=", "1", ")", "\n", "# try:", "\n", "#     ImageDraw.Draw(img).polygon(tuple(label['roidb']['segms'][i][j]), outline=1, fill=1)", "\n", "# except:", "\n", "#     print(label['roidb']['segms'][i], j)", "\n", "#     import pdb; pdb.set_trace()", "\n", "#     sys.exit()", "\n", "", "label", "[", "'mask_gt'", "]", "[", "i", "]", "=", "cv2", ".", "resize", "(", "np", ".", "array", "(", "img", ")", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "else", ":", "\n", "                        ", "assert", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "is", "dict", "or", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "0", "]", ")", "is", "dict", "\n", "if", "type", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "is", "dict", ":", "\n", "                            ", "label", "[", "'mask_gt'", "]", "[", "i", "]", "=", "cv2", ".", "resize", "(", "mask_util", ".", "decode", "(", "mask_util", ".", "frPyObjects", "(", "[", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "]", ",", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "'size'", "]", "[", "0", "]", ",", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", "[", "'size'", "]", "[", "1", "]", ")", ")", "[", ":", ",", ":", ",", "0", "]", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "else", ":", "\n", "                            ", "assert", "len", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "==", "1", "\n", "output", "=", "mask_util", ".", "decode", "(", "label", "[", "'roidb'", "]", "[", "'segms'", "]", "[", "i", "]", ")", "\n", "label", "[", "'mask_gt'", "]", "[", "i", "]", "=", "cv2", ".", "resize", "(", "output", "[", ":", ",", ":", ",", "0", "]", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "", "", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "                    ", "gt_boxes", "=", "label", "[", "'roidb'", "]", "[", "'boxes'", "]", "[", "np", ".", "where", "(", "label", "[", "'roidb'", "]", "[", "'gt_classes'", "]", ">", "0", ")", "[", "0", "]", "]", "\n", "gt_boxes", "=", "np", ".", "around", "(", "gt_boxes", "*", "im_scales", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "label", ".", "update", "(", "{", "'seg_roi_gt'", ":", "np", ".", "zeros", "(", "(", "len", "(", "gt_boxes", ")", ",", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ",", "dtype", "=", "np", ".", "int64", ")", "}", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "gt_boxes", ")", ")", ":", "\n", "                        ", "if", "gt_boxes", "[", "i", "]", "[", "3", "]", "==", "gt_boxes", "[", "i", "]", "[", "1", "]", ":", "\n", "                            ", "gt_boxes", "[", "i", "]", "[", "3", "]", "+=", "1", "\n", "", "if", "gt_boxes", "[", "i", "]", "[", "2", "]", "==", "gt_boxes", "[", "i", "]", "[", "0", "]", ":", "\n", "                            ", "gt_boxes", "[", "i", "]", "[", "2", "]", "+=", "1", "\n", "", "label", "[", "'seg_roi_gt'", "]", "[", "i", "]", "=", "cv2", ".", "resize", "(", "seg_gt", "[", "gt_boxes", "[", "i", "]", "[", "1", "]", ":", "gt_boxes", "[", "i", "]", "[", "3", "]", ",", "gt_boxes", "[", "i", "]", "[", "0", "]", ":", "gt_boxes", "[", "i", "]", "[", "2", "]", "]", ",", "(", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "", "", "else", ":", "\n", "                ", "seg_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "self", ".", "roidb", "[", "index", "]", "[", "'image'", "]", ".", "replace", "(", "'images'", ",", "'annotations'", ")", ")", ")", "\n", "if", "self", ".", "roidb", "[", "index", "]", "[", "'flipped'", "]", ":", "\n", "                    ", "seg_gt", "=", "np", ".", "fliplr", "(", "seg_gt", ")", "\n", "", "seg_gt", "=", "cv2", ".", "resize", "(", "seg_gt", ",", "None", ",", "None", ",", "fx", "=", "im_scales", "[", "0", "]", ",", "fy", "=", "im_scales", "[", "0", "]", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "label", ".", "update", "(", "{", "'seg_gt'", ":", "seg_gt", "}", ")", "\n", "\n", "", "", "if", "config", ".", "network", ".", "has_crf", ":", "\n", "            ", "data", ".", "update", "(", "self", ".", "build_crf_graph", "(", "im_blob", ")", ")", "\n", "\n", "", "return", "data", ",", "label", ",", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.evaluate_masks": [[191, 226], ["os.path.join", "enumerate", "ade20k.ade20k.dataset.COCO.loadRes", "pycocotools.cocoeval.COCOeval", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "ade20k.ade20k.log_detection_eval_metrics", "results.extend", "lib.utils.logging.logger.info", "open", "json.dump", "str", "os.path.join", "len", "ade20k.ade20k.segms_results_one_category", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.log_detection_eval_metrics", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.segms_results_one_category"], ["", "def", "evaluate_masks", "(", "\n", "self", ",", "\n", "all_boxes", ",", "\n", "all_segms", ",", "\n", "output_dir", ",", "\n", ")", ":", "\n", "        ", "res_file", "=", "os", ".", "path", ".", "join", "(", "\n", "output_dir", ",", "'segmentations_'", "+", "self", ".", "dataset", ".", "name", "+", "'_results.json'", "\n", ")", "\n", "results", "=", "[", "]", "\n", "for", "cls_ind", ",", "cls", "in", "enumerate", "(", "self", ".", "dataset", ".", "classes", ")", ":", "\n", "            ", "if", "cls", "==", "'__background__'", ":", "\n", "                ", "continue", "\n", "", "if", "cls_ind", ">=", "len", "(", "all_boxes", ")", ":", "\n", "                ", "break", "\n", "", "cat_id", "=", "self", ".", "dataset", ".", "category_to_id_map", "[", "cls", "]", "\n", "results", ".", "extend", "(", "self", ".", "segms_results_one_category", "(", "all_boxes", "[", "cls_ind", "]", ",", "all_segms", "[", "cls_ind", "]", ",", "cat_id", ")", ")", "\n", "", "if", "logger", ":", "\n", "            ", "logger", ".", "info", "(", "\n", "'Writing segmentation results json to: {}'", ".", "format", "(", "\n", "os", ".", "path", ".", "abspath", "(", "res_file", ")", ")", ")", "\n", "", "with", "open", "(", "res_file", ",", "'w'", ")", "as", "fid", ":", "\n", "            ", "json", ".", "dump", "(", "results", ",", "fid", ")", "\n", "", "coco_dt", "=", "self", ".", "dataset", ".", "COCO", ".", "loadRes", "(", "str", "(", "res_file", ")", ")", "\n", "coco_eval", "=", "COCOeval", "(", "self", ".", "dataset", ".", "COCO", ",", "coco_dt", ",", "'segm'", ")", "\n", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "self", ".", "log_detection_eval_metrics", "(", "coco_eval", ",", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'detection_results.txt'", ")", ")", "\n", "# eval_file = os.path.join(output_dir, 'segmentation_results.pkl')", "\n", "# pickle.dump(coco_eval, open(eval_file, 'wb'), pickle.HIGHEST_PROTOCOL)", "\n", "# if logger:", "\n", "# logger.info('Wrote json eval results to: {}'.format(eval_file))", "\n", "# Optionally cleanup results json file", "\n", "# os.remove(res_file)", "\n", "return", "coco_eval", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.evaluate_ssegs": [[228, 276], ["ade20k.ade20k.write_segmentation_result", "numpy.zeros", "enumerate", "re.sub.sum", "re.sub.sum", "numpy.diag", "IU_array.mean", "lib.utils.logging.logger.info", "ade20k.ade20k.evaluate_ssegs.convert_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.write_segmentation_result"], ["", "def", "evaluate_ssegs", "(", "self", ",", "pred_segmentations", ",", "res_file_folder", ")", ":", "\n", "        ", "self", ".", "write_segmentation_result", "(", "pred_segmentations", ",", "res_file_folder", ")", "\n", "\n", "confusion_matrix", "=", "np", ".", "zeros", "(", "(", "config", ".", "dataset", ".", "num_seg_classes", ",", "config", ".", "dataset", ".", "num_seg_classes", ")", ")", "\n", "for", "i", ",", "roidb", "in", "enumerate", "(", "self", ".", "roidb", ")", ":", "\n", "\n", "            ", "seg_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "self", ".", "roidb", "[", "i", "]", "[", "'image'", "]", ".", "replace", "(", "'images'", ",", "'annotations'", ")", ".", "replace", "(", "'train2017'", ",", "'panoptic_train2017_semantic_trainid_stff'", ")", ".", "replace", "(", "'val2017'", ",", "'panoptic_val2017_semantic_trainid_stff'", ")", ".", "replace", "(", "'jpg'", ",", "'png'", ")", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "seg_pathes", "=", "os", ".", "path", ".", "split", "(", "roidb", "[", "'image'", "]", ")", "\n", "res_image_name", "=", "seg_pathes", "[", "-", "1", "]", "\n", "res_save_path", "=", "os", ".", "path", ".", "join", "(", "res_file_folder", ",", "res_image_name", "+", "'.png'", ")", "\n", "\n", "seg_pred", "=", "Image", ".", "open", "(", "res_save_path", ")", "\n", "\n", "seg_pred", "=", "np", ".", "array", "(", "seg_pred", ".", "resize", "(", "(", "seg_gt", ".", "shape", "[", "1", "]", ",", "seg_gt", ".", "shape", "[", "0", "]", ")", ",", "Image", ".", "NEAREST", ")", ")", "\n", "ignore_index", "=", "seg_gt", "!=", "255", "\n", "seg_gt", "=", "seg_gt", "[", "ignore_index", "]", "\n", "seg_pred", "=", "seg_pred", "[", "ignore_index", "]", "\n", "\n", "confusion_matrix", "+=", "self", ".", "get_confusion_matrix", "(", "seg_gt", ",", "seg_pred", ",", "config", ".", "dataset", ".", "num_seg_classes", ")", "\n", "\n", "", "pos", "=", "confusion_matrix", ".", "sum", "(", "1", ")", "\n", "res", "=", "confusion_matrix", ".", "sum", "(", "0", ")", "\n", "tp", "=", "np", ".", "diag", "(", "confusion_matrix", ")", "\n", "\n", "IU_array", "=", "(", "tp", "/", "np", ".", "maximum", "(", "1.0", ",", "pos", "+", "res", "-", "tp", ")", ")", "\n", "mean_IU", "=", "IU_array", ".", "mean", "(", ")", "\n", "\n", "evaluation_results", "=", "{", "'meanIU'", ":", "mean_IU", ",", "'IU_array'", ":", "IU_array", ",", "'confusion_matrix'", ":", "confusion_matrix", "}", "\n", "\n", "def", "convert_confusion_matrix", "(", "confusion_matrix", ")", ":", "\n", "            ", "cls_sum", "=", "confusion_matrix", ".", "sum", "(", "axis", "=", "1", ")", "\n", "confusion_matrix", "=", "confusion_matrix", "/", "cls_sum", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "return", "confusion_matrix", "\n", "\n", "", "logger", ".", "info", "(", "'evaluate segmentation:'", ")", "\n", "meanIU", "=", "evaluation_results", "[", "'meanIU'", "]", "\n", "IU_array", "=", "evaluation_results", "[", "'IU_array'", "]", "\n", "confusion_matrix", "=", "convert_confusion_matrix", "(", "evaluation_results", "[", "'confusion_matrix'", "]", ")", "\n", "logger", ".", "info", "(", "'IU_array:'", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "IU_array", ")", ")", ":", "\n", "            ", "logger", ".", "info", "(", "'%.5f'", "%", "IU_array", "[", "i", "]", ")", "\n", "", "logger", ".", "info", "(", "'meanIU:%.5f'", "%", "meanIU", ")", "\n", "np", ".", "set_printoptions", "(", "precision", "=", "3", ",", "suppress", "=", "True", ",", "linewidth", "=", "200", ")", "\n", "import", "re", "\n", "confusion_matrix", "=", "re", ".", "sub", "(", "'[\\[\\]]'", ",", "''", ",", "np", ".", "array2string", "(", "confusion_matrix", ",", "separator", "=", "'\\t'", ")", ")", "\n", "logger", ".", "info", "(", "'confusion_matrix:'", ")", "\n", "logger", ".", "info", "(", "confusion_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.ade20k.ade20k.write_segmentation_result": [[278, 299], ["enumerate", "os.path.exists", "os.mkdir", "os.path.split", "os.path.join", "numpy.uint8", "PIL.Image.fromarray", "PIL.Image.fromarray.save", "numpy.squeeze", "numpy.copy"], "methods", ["None"], ["", "def", "write_segmentation_result", "(", "self", ",", "segmentation_results", ",", "res_file_folder", ")", ":", "\n", "        ", "\"\"\"\n        Write the segmentation result to result_file_folder\n        :param segmentation_results: the prediction result\n        :param result_file_folder: the saving folder\n        :return: [None]\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "res_file_folder", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "res_file_folder", ")", "\n", "\n", "# pallete = self.get_pallete()", "\n", "", "for", "i", ",", "roidb", "in", "enumerate", "(", "self", ".", "roidb", ")", ":", "\n", "\n", "            ", "seg_pathes", "=", "os", ".", "path", ".", "split", "(", "roidb", "[", "'image'", "]", ")", "\n", "res_image_name", "=", "seg_pathes", "[", "-", "1", "]", "\n", "res_save_path", "=", "os", ".", "path", ".", "join", "(", "res_file_folder", ",", "res_image_name", "+", "'.png'", ")", "\n", "\n", "segmentation_result", "=", "np", ".", "uint8", "(", "np", ".", "squeeze", "(", "np", ".", "copy", "(", "segmentation_results", "[", "i", "]", ")", ")", ")", "\n", "segmentation_result", "=", "Image", ".", "fromarray", "(", "segmentation_result", ")", "\n", "# segmentation_result.putpalette(pallete)", "\n", "segmentation_result", ".", "save", "(", "res_save_path", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.PQStatCat.__init__": [[47, 52], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "iou", "=", "0.0", "\n", "self", ".", "tp", "=", "0", "\n", "self", ".", "fp", "=", "0", "\n", "self", ".", "fn", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.PQStatCat.__iadd__": [[53, 59], ["None"], "methods", ["None"], ["", "def", "__iadd__", "(", "self", ",", "pq_stat_cat", ")", ":", "\n", "        ", "self", ".", "iou", "+=", "pq_stat_cat", ".", "iou", "\n", "self", ".", "tp", "+=", "pq_stat_cat", ".", "tp", "\n", "self", ".", "fp", "+=", "pq_stat_cat", ".", "fp", "\n", "self", ".", "fn", "+=", "pq_stat_cat", ".", "fn", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.PQStat.__init__": [[62, 64], ["collections.defaultdict"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "pq_per_cat", "=", "defaultdict", "(", "PQStatCat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.PQStat.__getitem__": [[65, 67], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "return", "self", ".", "pq_per_cat", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.PQStat.__iadd__": [[68, 72], ["pq_stat.pq_per_cat.items"], "methods", ["None"], ["", "def", "__iadd__", "(", "self", ",", "pq_stat", ")", ":", "\n", "        ", "for", "label", ",", "pq_stat_cat", "in", "pq_stat", ".", "pq_per_cat", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "pq_per_cat", "[", "label", "]", "+=", "pq_stat_cat", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.PQStat.pq_average": [[73, 98], ["categories.items"], "methods", ["None"], ["", "def", "pq_average", "(", "self", ",", "categories", ",", "isthing", ")", ":", "\n", "        ", "pq", ",", "sq", ",", "rq", ",", "n", "=", "0", ",", "0", ",", "0", ",", "0", "\n", "per_class_results", "=", "{", "}", "\n", "for", "label", ",", "label_info", "in", "categories", ".", "items", "(", ")", ":", "\n", "            ", "if", "isthing", "is", "not", "None", ":", "\n", "                ", "cat_isthing", "=", "label_info", "[", "'isthing'", "]", "==", "1", "\n", "if", "isthing", "!=", "cat_isthing", ":", "\n", "                    ", "continue", "\n", "", "", "iou", "=", "self", ".", "pq_per_cat", "[", "label", "]", ".", "iou", "\n", "tp", "=", "self", ".", "pq_per_cat", "[", "label", "]", ".", "tp", "\n", "fp", "=", "self", ".", "pq_per_cat", "[", "label", "]", ".", "fp", "\n", "fn", "=", "self", ".", "pq_per_cat", "[", "label", "]", ".", "fn", "\n", "if", "tp", "+", "fp", "+", "fn", "==", "0", ":", "\n", "                ", "per_class_results", "[", "label", "]", "=", "{", "'pq'", ":", "0.0", ",", "'sq'", ":", "0.0", ",", "'rq'", ":", "0.0", "}", "\n", "continue", "\n", "", "n", "+=", "1", "\n", "pq_class", "=", "iou", "/", "(", "tp", "+", "0.5", "*", "fp", "+", "0.5", "*", "fn", ")", "\n", "sq_class", "=", "iou", "/", "tp", "if", "tp", "!=", "0", "else", "0", "\n", "rq_class", "=", "tp", "/", "(", "tp", "+", "0.5", "*", "fp", "+", "0.5", "*", "fn", ")", "\n", "per_class_results", "[", "label", "]", "=", "{", "'pq'", ":", "pq_class", ",", "'sq'", ":", "sq_class", ",", "'rq'", ":", "rq_class", ",", "'iou'", ":", "iou", ",", "'tp'", ":", "tp", ",", "'fp'", ":", "fp", ",", "'fn'", ":", "fn", "}", "\n", "pq", "+=", "pq_class", "\n", "sq", "+=", "sq_class", "\n", "rq", "+=", "rq_class", "\n", "\n", "", "return", "{", "'pq'", ":", "pq", "/", "n", ",", "'sq'", ":", "sq", "/", "n", ",", "'rq'", ":", "rq", "/", "n", ",", "'n'", ":", "n", "}", ",", "per_class_results", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.__init__": [[102, 109], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "flip", "=", "None", "\n", "self", ".", "roidb", "=", "None", "\n", "self", ".", "phase", "=", "None", "\n", "self", ".", "num_classes", "=", "None", "\n", "self", ".", "result_path", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.__len__": [[110, 112], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "roidb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_image_blob": [[113, 142], ["len", "numpy.random.randint", "range", "cv2.imread", "base_dataset.BaseDataset.prep_im_for_blob", "im_scales.append", "processed_ims.append", "len", "len", "im[].transpose"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.prep_im_for_blob"], ["", "def", "get_image_blob", "(", "self", ",", "roidb", ")", ":", "\n", "        ", "\"\"\"Builds an input blob from the images in the roidb at the specified\n        scales.\n        \"\"\"", "\n", "num_images", "=", "len", "(", "roidb", ")", "\n", "# Sample random scales to use for each image in this batch", "\n", "scale_inds", "=", "np", ".", "random", ".", "randint", "(", "\n", "0", ",", "high", "=", "len", "(", "config", ".", "train", ".", "scales", ")", ",", "size", "=", "num_images", "\n", ")", "\n", "processed_ims", "=", "[", "]", "\n", "im_scales", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "im", "=", "cv2", ".", "imread", "(", "roidb", "[", "i", "]", "[", "'image'", "]", ")", "\n", "assert", "im", "is", "not", "None", ",", "'Failed to read image \\'{}\\''", ".", "format", "(", "roidb", "[", "i", "]", "[", "'image'", "]", ")", "\n", "if", "roidb", "[", "i", "]", "[", "'flipped'", "]", ":", "\n", "                ", "im", "=", "im", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "target_size", "=", "config", ".", "train", ".", "scales", "[", "scale_inds", "[", "i", "]", "]", "\n", "im", ",", "im_scale", "=", "self", ".", "prep_im_for_blob", "(", "\n", "im", ",", "config", ".", "network", ".", "pixel_means", ",", "[", "target_size", "]", ",", "config", ".", "train", ".", "max_size", "\n", ")", "\n", "im_scales", ".", "append", "(", "im_scale", "[", "0", "]", ")", "\n", "processed_ims", ".", "append", "(", "im", "[", "0", "]", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "# Create a blob to hold the input images", "\n", "", "assert", "len", "(", "processed_ims", ")", "==", "1", "\n", "blob", "=", "processed_ims", "[", "0", "]", "\n", "\n", "return", "blob", ",", "im_scales", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.prep_im_for_blob": [[143, 174], ["cv2.resize.astype", "numpy.min", "numpy.max", "pixel_means.reshape", "numpy.array", "numpy.array", "cv2.resize", "ims.append", "im_scales.append", "float", "float", "numpy.round", "float", "float"], "methods", ["None"], ["", "def", "prep_im_for_blob", "(", "self", ",", "im", ",", "pixel_means", ",", "target_sizes", ",", "max_size", ")", ":", "\n", "        ", "\"\"\"Prepare an image for use as a network input blob. Specially:\n          - Subtract per-channel pixel mean\n          - Convert to float32\n          - Rescale to each of the specified target size (capped at max_size)\n        Returns a list of transformed images, one for each target size. Also returns\n        the scale factors that were used to compute each returned image.\n        \"\"\"", "\n", "im", "=", "im", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "if", "config", ".", "network", ".", "use_caffe_model", ":", "\n", "            ", "im", "-=", "pixel_means", ".", "reshape", "(", "(", "1", ",", "1", ",", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "im", "/=", "255.0", "\n", "im", "-=", "np", ".", "array", "(", "[", "[", "[", "0.485", ",", "0.456", ",", "0.406", "]", "]", "]", ")", "\n", "im", "/=", "np", ".", "array", "(", "[", "[", "[", "0.229", ",", "0.224", ",", "0.225", "]", "]", "]", ")", "\n", "", "im_shape", "=", "im", ".", "shape", "\n", "im_size_min", "=", "np", ".", "min", "(", "im_shape", "[", "0", ":", "2", "]", ")", "\n", "im_size_max", "=", "np", ".", "max", "(", "im_shape", "[", "0", ":", "2", "]", ")", "\n", "\n", "ims", "=", "[", "]", "\n", "im_scales", "=", "[", "]", "\n", "for", "target_size", "in", "target_sizes", ":", "\n", "            ", "im_scale", "=", "float", "(", "target_size", ")", "/", "float", "(", "im_size_min", ")", "\n", "# Prevent the biggest axis from being more than max_size", "\n", "if", "np", ".", "round", "(", "im_scale", "*", "im_size_max", ")", ">", "max_size", ":", "\n", "                ", "im_scale", "=", "float", "(", "max_size", ")", "/", "float", "(", "im_size_max", ")", "\n", "", "im", "=", "cv2", ".", "resize", "(", "im", ",", "None", ",", "None", ",", "fx", "=", "im_scale", ",", "fy", "=", "im_scale", ",", "\n", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "ims", ".", "append", "(", "im", ")", "\n", "im_scales", ".", "append", "(", "im_scale", ")", "\n", "", "return", "ims", ",", "im_scales", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_all": [[176, 180], ["base_dataset.BaseDataset.evaluate_boxes", "base_dataset.BaseDataset.evaluate_masks"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_masks"], ["", "def", "evaluate_all", "(", "self", ",", "all_boxes", ",", "all_segms", ",", "output_dir", ")", ":", "\n", "        ", "all_results", "=", "self", ".", "evaluate_boxes", "(", "all_boxes", ",", "output_dir", ")", "\n", "self", ".", "evaluate_masks", "(", "all_boxes", ",", "all_segms", ",", "output_dir", ")", "\n", "return", "all_results", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_boxes": [[181, 205], ["os.path.join", "enumerate", "base_dataset.BaseDataset.dataset.COCO.loadRes", "pycocotools.cocoeval.COCOeval", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "base_dataset.BaseDataset.log_detection_eval_metrics", "results.extend", "lib.utils.logging.logger.info", "open", "json.dump", "str", "os.path.join", "len", "base_dataset.BaseDataset.bbox_results_one_category", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.log_detection_eval_metrics", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.bbox_results_one_category"], ["", "def", "evaluate_boxes", "(", "self", ",", "all_boxes", ",", "output_dir", ")", ":", "\n", "        ", "res_file", "=", "os", ".", "path", ".", "join", "(", "\n", "output_dir", ",", "'bbox_'", "+", "self", ".", "dataset", ".", "name", "+", "'_results.json'", "\n", ")", "\n", "results", "=", "[", "]", "\n", "for", "cls_ind", ",", "cls", "in", "enumerate", "(", "self", ".", "dataset", ".", "classes", ")", ":", "\n", "            ", "if", "cls", "==", "'__background__'", ":", "\n", "                ", "continue", "\n", "", "if", "cls_ind", ">=", "len", "(", "all_boxes", ")", ":", "\n", "                ", "break", "\n", "", "cat_id", "=", "self", ".", "dataset", ".", "category_to_id_map", "[", "cls", "]", "\n", "results", ".", "extend", "(", "self", ".", "bbox_results_one_category", "(", "all_boxes", "[", "cls_ind", "]", ",", "cat_id", ")", ")", "\n", "", "if", "logger", ":", "\n", "            ", "logger", ".", "info", "(", "'Writing bbox results json to: {}'", ".", "format", "(", "os", ".", "path", ".", "abspath", "(", "res_file", ")", ")", ")", "\n", "", "with", "open", "(", "res_file", ",", "'w'", ")", "as", "fid", ":", "\n", "            ", "json", ".", "dump", "(", "results", ",", "fid", ")", "\n", "\n", "", "coco_dt", "=", "self", ".", "dataset", ".", "COCO", ".", "loadRes", "(", "str", "(", "res_file", ")", ")", "\n", "coco_eval", "=", "COCOeval", "(", "self", ".", "dataset", ".", "COCO", ",", "coco_dt", ",", "'bbox'", ")", "\n", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "self", ".", "log_detection_eval_metrics", "(", "coco_eval", ",", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'detection_results.txt'", ")", ")", "\n", "\n", "return", "coco_eval", ".", "stats", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_masks": [[206, 208], ["None"], "methods", ["None"], ["", "def", "evaluate_masks", "(", "self", ",", "all_boxes", ",", "all_segms", ",", "output_dir", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_panoptic": [[209, 331], ["sys.path.insert", "base_dataset.BaseDataset.evaluate_panoptic.get_gt"], "methods", ["None"], ["", "def", "evaluate_panoptic", "(", "self", ",", "pred_pans_2ch", ",", "output_dir", ")", ":", "\n", "\n", "        ", "sys", ".", "path", ".", "insert", "(", "0", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ",", "'..'", ",", "'..'", ",", "'lib'", ",", "'dataset_devkit'", ")", ")", "\n", "\n", "from", "panopticapi", ".", "utils", "import", "IdGenerator", "\n", "\n", "def", "get_gt", "(", "pan_gt_json_file", "=", "None", ",", "pan_gt_folder", "=", "None", ")", ":", "\n", "            ", "if", "pan_gt_json_file", "is", "None", ":", "\n", "                ", "pan_gt_json_file", "=", "self", ".", "panoptic_json_file", "\n", "", "if", "pan_gt_folder", "is", "None", ":", "\n", "                ", "pan_gt_folder", "=", "self", ".", "panoptic_gt_folder", "\n", "", "with", "open", "(", "pan_gt_json_file", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "pan_gt_json", "=", "json", ".", "load", "(", "f", ")", "\n", "", "files", "=", "[", "item", "[", "'file_name'", "]", "for", "item", "in", "pan_gt_json", "[", "'images'", "]", "]", "\n", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "files_split", "=", "np", ".", "array_split", "(", "files", ",", "cpu_num", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "files_set", "in", "enumerate", "(", "files_split", ")", ":", "\n", "                ", "p", "=", "workers", ".", "apply_async", "(", "BaseDataset", ".", "_load_image_single_core", ",", "(", "proc_id", ",", "files_set", ",", "pan_gt_folder", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "workers", ".", "close", "(", ")", "\n", "workers", ".", "join", "(", ")", "\n", "pan_gt_all", "=", "[", "]", "\n", "for", "p", "in", "processes", ":", "\n", "                ", "pan_gt_all", ".", "extend", "(", "p", ".", "get", "(", ")", ")", "\n", "\n", "", "categories", "=", "pan_gt_json", "[", "'categories'", "]", "\n", "categories", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "categories", "}", "\n", "color_gererator", "=", "IdGenerator", "(", "categories", ")", "\n", "\n", "return", "pan_gt_all", ",", "pan_gt_json", ",", "categories", ",", "color_gererator", "\n", "\n", "", "def", "get_pred", "(", "pan_2ch_all", ",", "color_gererator", ",", "cpu_num", "=", "None", ")", ":", "\n", "            ", "if", "cpu_num", "is", "None", ":", "\n", "                ", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "", "pan_2ch_split", "=", "np", ".", "array_split", "(", "pan_2ch_all", ",", "cpu_num", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "pan_2ch_set", "in", "enumerate", "(", "pan_2ch_split", ")", ":", "\n", "                ", "p", "=", "workers", ".", "apply_async", "(", "BaseDataset", ".", "_converter_2ch_single_core", ",", "(", "proc_id", ",", "pan_2ch_set", ",", "color_gererator", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "workers", ".", "close", "(", ")", "\n", "workers", ".", "join", "(", ")", "\n", "annotations", ",", "pan_all", "=", "[", "]", ",", "[", "]", "\n", "for", "p", "in", "processes", ":", "\n", "                ", "p", "=", "p", ".", "get", "(", ")", "\n", "annotations", ".", "extend", "(", "p", "[", "0", "]", ")", "\n", "pan_all", ".", "extend", "(", "p", "[", "1", "]", ")", "\n", "", "pan_json", "=", "{", "'annotations'", ":", "annotations", "}", "\n", "return", "pan_all", ",", "pan_json", "\n", "\n", "", "def", "save_image", "(", "images", ",", "save_folder", ",", "gt_json", ",", "colors", "=", "None", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "save_folder", ",", "exist_ok", "=", "True", ")", "\n", "names", "=", "[", "os", ".", "path", ".", "join", "(", "save_folder", ",", "item", "[", "'file_name'", "]", ".", "replace", "(", "'_leftImg8bit'", ",", "''", ")", ".", "replace", "(", "'jpg'", ",", "'png'", ")", ".", "replace", "(", "'jpeg'", ",", "'png'", ")", ")", "for", "item", "in", "gt_json", "[", "'images'", "]", "]", "\n", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "images_split", "=", "np", ".", "array_split", "(", "images", ",", "cpu_num", ")", "\n", "names_split", "=", "np", ".", "array_split", "(", "names", ",", "cpu_num", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "for", "proc_id", ",", "(", "images_set", ",", "names_set", ")", "in", "enumerate", "(", "zip", "(", "images_split", ",", "names_split", ")", ")", ":", "\n", "                ", "workers", ".", "apply_async", "(", "BaseDataset", ".", "_save_image_single_core", ",", "(", "proc_id", ",", "images_set", ",", "names_set", ",", "colors", ")", ")", "\n", "", "workers", ".", "close", "(", ")", "\n", "workers", ".", "join", "(", ")", "\n", "\n", "", "def", "pq_compute", "(", "gt_jsons", ",", "pred_jsons", ",", "gt_pans", ",", "pred_pans", ",", "categories", ")", ":", "\n", "            ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "# from json and from numpy", "\n", "gt_image_jsons", "=", "gt_jsons", "[", "'images'", "]", "\n", "gt_jsons", ",", "pred_jsons", "=", "gt_jsons", "[", "'annotations'", "]", ",", "pred_jsons", "[", "'annotations'", "]", "\n", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "gt_jsons_split", ",", "pred_jsons_split", "=", "np", ".", "array_split", "(", "gt_jsons", ",", "cpu_num", ")", ",", "np", ".", "array_split", "(", "pred_jsons", ",", "cpu_num", ")", "\n", "gt_pans_split", ",", "pred_pans_split", "=", "np", ".", "array_split", "(", "gt_pans", ",", "cpu_num", ")", ",", "np", ".", "array_split", "(", "pred_pans", ",", "cpu_num", ")", "\n", "gt_image_jsons_split", "=", "np", ".", "array_split", "(", "gt_image_jsons", ",", "cpu_num", ")", "\n", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "(", "gt_jsons_set", ",", "pred_jsons_set", ",", "gt_pans_set", ",", "pred_pans_set", ",", "gt_image_jsons_set", ")", "in", "enumerate", "(", "zip", "(", "gt_jsons_split", ",", "pred_jsons_split", ",", "gt_pans_split", ",", "pred_pans_split", ",", "gt_image_jsons_split", ")", ")", ":", "\n", "                ", "p", "=", "workers", ".", "apply_async", "(", "BaseDataset", ".", "_pq_compute_single_core", ",", "(", "proc_id", ",", "gt_jsons_set", ",", "pred_jsons_set", ",", "gt_pans_set", ",", "pred_pans_set", ",", "gt_image_jsons_set", ",", "categories", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "workers", ".", "close", "(", ")", "\n", "workers", ".", "join", "(", ")", "\n", "pq_stat", "=", "PQStat", "(", ")", "\n", "for", "p", "in", "processes", ":", "\n", "                ", "pq_stat", "+=", "p", ".", "get", "(", ")", "\n", "", "metrics", "=", "[", "(", "\"All\"", ",", "None", ")", ",", "(", "\"Things\"", ",", "True", ")", ",", "(", "\"Stuff\"", ",", "False", ")", "]", "\n", "results", "=", "{", "}", "\n", "for", "name", ",", "isthing", "in", "metrics", ":", "\n", "                ", "results", "[", "name", "]", ",", "per_class_results", "=", "pq_stat", ".", "pq_average", "(", "categories", ",", "isthing", "=", "isthing", ")", "\n", "if", "name", "==", "'All'", ":", "\n", "                    ", "results", "[", "'per_class'", "]", "=", "per_class_results", "\n", "\n", "", "", "if", "logger", ":", "\n", "                ", "logger", ".", "info", "(", "\"{:10s}| {:>5s}  {:>5s}  {:>5s} {:>5s}\"", ".", "format", "(", "\"\"", ",", "\"PQ\"", ",", "\"SQ\"", ",", "\"RQ\"", ",", "\"N\"", ")", ")", "\n", "logger", ".", "info", "(", "\"-\"", "*", "(", "10", "+", "7", "*", "4", ")", ")", "\n", "for", "name", ",", "_isthing", "in", "metrics", ":", "\n", "                    ", "logger", ".", "info", "(", "\"{:10s}| {:5.1f}  {:5.1f}  {:5.1f} {:5d}\"", ".", "format", "(", "name", ",", "100", "*", "results", "[", "name", "]", "[", "'pq'", "]", ",", "100", "*", "results", "[", "name", "]", "[", "'sq'", "]", ",", "100", "*", "results", "[", "name", "]", "[", "'rq'", "]", ",", "results", "[", "name", "]", "[", "'n'", "]", ")", ")", "\n", "\n", "", "logger", ".", "info", "(", "\"{:4s}| {:>5s} {:>5s} {:>5s} {:>6s} {:>7s} {:>7s} {:>7s}\"", ".", "format", "(", "\"IDX\"", ",", "\"PQ\"", ",", "\"SQ\"", ",", "\"RQ\"", ",", "\"IoU\"", ",", "\"TP\"", ",", "\"FP\"", ",", "\"FN\"", ")", ")", "\n", "for", "idx", ",", "result", "in", "results", "[", "'per_class'", "]", ".", "items", "(", ")", ":", "\n", "                    ", "logger", ".", "info", "(", "\"{:4d} | {:5.1f} {:5.1f} {:5.1f} {:6.1f} {:7d} {:7d} {:7d}\"", ".", "format", "(", "idx", ",", "100", "*", "result", "[", "'pq'", "]", ",", "100", "*", "result", "[", "'sq'", "]", ",", "100", "*", "result", "[", "'rq'", "]", ",", "result", "[", "'iou'", "]", ",", "result", "[", "'tp'", "]", ",", "\n", "result", "[", "'fp'", "]", ",", "result", "[", "'fn'", "]", ")", ")", "\n", "\n", "", "", "t_delta", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"Time elapsed: {:0.2f} seconds\"", ".", "format", "(", "t_delta", ")", ")", "\n", "return", "results", "\n", "\n", "\n", "# if eval for test-dev, since there is no gt we simply retrieve image names from image_info json files", "\n", "# with open(self.panoptic_json_file, 'r') as f:", "\n", "#     gt_json = json.load(f)", "\n", "#     gt_json['images'] = sorted(gt_json['images'], key=lambda x: x['id'])", "\n", "# other wise:", "\n", "", "gt_pans", ",", "gt_json", ",", "categories", ",", "color_gererator", "=", "get_gt", "(", ")", "\n", "\n", "pred_pans", ",", "pred_json", "=", "get_pred", "(", "pred_pans_2ch", ",", "color_gererator", ")", "\n", "save_image", "(", "pred_pans_2ch", ",", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'pan_2ch'", ")", ",", "gt_json", ")", "\n", "save_image", "(", "pred_pans", ",", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'pan'", ")", ",", "gt_json", ")", "\n", "json", ".", "dump", "(", "gt_json", ",", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'gt.json'", ")", ",", "'w'", ")", ")", "\n", "json", ".", "dump", "(", "pred_json", ",", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'pred.json'", ")", ",", "'w'", ")", ")", "\n", "results", "=", "pq_compute", "(", "gt_json", ",", "pred_json", ",", "gt_pans", ",", "pred_pans", ",", "categories", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_unified_pan_result": [[332, 372], ["zip", "pan.copy", "pan.copy", "numpy.unique", "enumerate", "numpy.unique", "range", "numpy.zeros", "pred_pans_2ch.append", "numpy.unique", "area.sum", "numpy.argmax", "numpy.max", "numpy.sum", "numpy.argmax", "numpy.argmax"], "methods", ["None"], ["", "def", "get_unified_pan_result", "(", "self", ",", "segs", ",", "pans", ",", "cls_inds", ",", "stuff_area_limit", "=", "4", "*", "64", "*", "64", ")", ":", "\n", "        ", "pred_pans_2ch", "=", "[", "]", "\n", "\n", "for", "(", "seg", ",", "pan", ",", "cls_ind", ")", "in", "zip", "(", "segs", ",", "pans", ",", "cls_inds", ")", ":", "\n", "            ", "pan_seg", "=", "pan", ".", "copy", "(", ")", "\n", "pan_ins", "=", "pan", ".", "copy", "(", ")", "\n", "id_last_stuff", "=", "config", ".", "dataset", ".", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", "\n", "ids", "=", "np", ".", "unique", "(", "pan", ")", "\n", "ids_ins", "=", "ids", "[", "ids", ">", "id_last_stuff", "]", "\n", "pan_ins", "[", "pan_ins", "<=", "id_last_stuff", "]", "=", "0", "\n", "for", "idx", ",", "id", "in", "enumerate", "(", "ids_ins", ")", ":", "\n", "                ", "region", "=", "(", "pan_ins", "==", "id", ")", "\n", "if", "id", "==", "255", ":", "\n", "                    ", "pan_seg", "[", "region", "]", "=", "255", "\n", "pan_ins", "[", "region", "]", "=", "0", "\n", "continue", "\n", "", "cls", ",", "cnt", "=", "np", ".", "unique", "(", "seg", "[", "region", "]", ",", "return_counts", "=", "True", ")", "\n", "if", "cls", "[", "np", ".", "argmax", "(", "cnt", ")", "]", "==", "cls_ind", "[", "id", "-", "id_last_stuff", "-", "1", "]", "+", "id_last_stuff", ":", "\n", "                    ", "pan_seg", "[", "region", "]", "=", "cls_ind", "[", "id", "-", "id_last_stuff", "-", "1", "]", "+", "id_last_stuff", "\n", "pan_ins", "[", "region", "]", "=", "idx", "+", "1", "\n", "", "else", ":", "\n", "                    ", "if", "np", ".", "max", "(", "cnt", ")", "/", "np", ".", "sum", "(", "cnt", ")", ">=", "0.5", "and", "cls", "[", "np", ".", "argmax", "(", "cnt", ")", "]", "<=", "id_last_stuff", ":", "\n", "                        ", "pan_seg", "[", "region", "]", "=", "cls", "[", "np", ".", "argmax", "(", "cnt", ")", "]", "\n", "pan_ins", "[", "region", "]", "=", "0", "\n", "", "else", ":", "\n", "                        ", "pan_seg", "[", "region", "]", "=", "cls_ind", "[", "id", "-", "id_last_stuff", "-", "1", "]", "+", "id_last_stuff", "\n", "pan_ins", "[", "region", "]", "=", "idx", "+", "1", "\n", "\n", "", "", "", "idx_sem", "=", "np", ".", "unique", "(", "pan_seg", ")", "\n", "for", "i", "in", "range", "(", "idx_sem", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "if", "idx_sem", "[", "i", "]", "<=", "id_last_stuff", ":", "\n", "                    ", "area", "=", "pan_seg", "==", "idx_sem", "[", "i", "]", "\n", "if", "(", "area", ")", ".", "sum", "(", ")", "<", "stuff_area_limit", ":", "\n", "                        ", "pan_seg", "[", "area", "]", "=", "255", "\n", "\n", "", "", "", "pan_2ch", "=", "np", ".", "zeros", "(", "(", "pan", ".", "shape", "[", "0", "]", ",", "pan", ".", "shape", "[", "1", "]", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "pan_2ch", "[", ":", ",", ":", ",", "0", "]", "=", "pan_seg", "\n", "pan_2ch", "[", ":", ",", ":", ",", "1", "]", "=", "pan_ins", "\n", "pred_pans_2ch", ".", "append", "(", "pan_2ch", ")", "\n", "", "return", "pred_pans_2ch", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_combined_pan_result": [[373, 404], ["range", "torch.cpu_count", "torch.cpu_count", "torch.cpu_count", "numpy.array_split", "numpy.array_split", "numpy.array_split", "numpy.array_split", "torch.Pool", "torch.Pool", "torch.Pool", "enumerate", "torch.Pool.close", "torch.Pool.join", "len", "numpy.vstack", "numpy.array", "numpy.hstack", "boxes_all.append", "masks_all.append", "cls_idxs_all.append", "zip", "torch.Pool.apply_async", "processes.append", "pan_2ch_all.extend", "list", "numpy.argsort", "multiprocessing.Pool.apply_async.get", "itertools.chain", "numpy.array().astype", "range", "range", "len", "numpy.array", "len", "range", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get"], ["", "def", "get_combined_pan_result", "(", "self", ",", "segs", ",", "boxes", ",", "masks", ",", "score_threshold", "=", "0.6", ",", "fraction_threshold", "=", "0.7", ",", "stuff_area_limit", "=", "4", "*", "64", "*", "64", ")", ":", "\n", "# suppose ins masks are already sorted in descending order by scores", "\n", "        ", "boxes_all", ",", "masks_all", ",", "cls_idxs_all", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "boxes_all", "=", "[", "]", "\n", "import", "itertools", "\n", "import", "time", "\n", "for", "i", "in", "range", "(", "len", "(", "segs", ")", ")", ":", "\n", "            ", "boxes_i", "=", "np", ".", "vstack", "(", "[", "boxes", "[", "j", "]", "[", "i", "]", "for", "j", "in", "range", "(", "1", ",", "len", "(", "boxes", ")", ")", "]", ")", "\n", "masks_i", "=", "np", ".", "array", "(", "list", "(", "itertools", ".", "chain", "(", "*", "[", "masks", "[", "j", "]", "[", "i", "]", "for", "j", "in", "range", "(", "1", ",", "len", "(", "masks", ")", ")", "]", ")", ")", ")", "\n", "cls_idxs_i", "=", "np", ".", "hstack", "(", "[", "np", ".", "array", "(", "[", "j", "for", "_", "in", "boxes", "[", "j", "]", "[", "i", "]", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "for", "j", "in", "range", "(", "1", ",", "len", "(", "boxes", ")", ")", "]", ")", "\n", "sorted_idxs", "=", "np", ".", "argsort", "(", "boxes_i", "[", ":", ",", "4", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "boxes_all", ".", "append", "(", "boxes_i", "[", "sorted_idxs", "]", ")", "\n", "masks_all", ".", "append", "(", "masks_i", "[", "sorted_idxs", "]", ")", "\n", "cls_idxs_all", ".", "append", "(", "cls_idxs_i", "[", "sorted_idxs", "]", ")", "\n", "\n", "", "cpu_num", "=", "multiprocessing", ".", "cpu_count", "(", ")", "\n", "boxes_split", "=", "np", ".", "array_split", "(", "boxes_all", ",", "cpu_num", ")", "\n", "cls_idxs_split", "=", "np", ".", "array_split", "(", "cls_idxs_all", ",", "cpu_num", ")", "\n", "masks_split", "=", "np", ".", "array_split", "(", "masks_all", ",", "cpu_num", ")", "\n", "segs_split", "=", "np", ".", "array_split", "(", "segs", ",", "cpu_num", ")", "\n", "workers", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "cpu_num", ")", "\n", "processes", "=", "[", "]", "\n", "for", "proc_id", ",", "(", "boxes_set", ",", "cls_idxs_set", ",", "masks_set", ",", "sems_set", ")", "in", "enumerate", "(", "zip", "(", "boxes_split", ",", "cls_idxs_split", ",", "masks_split", ",", "segs_split", ")", ")", ":", "\n", "            ", "p", "=", "workers", ".", "apply_async", "(", "BaseDataset", ".", "_merge_pred_single_core", ",", "(", "proc_id", ",", "boxes_set", ",", "cls_idxs_set", ",", "masks_set", ",", "sems_set", ",", "score_threshold", ",", "fraction_threshold", ",", "stuff_area_limit", ")", ")", "\n", "processes", ".", "append", "(", "p", ")", "\n", "", "workers", ".", "close", "(", ")", "\n", "workers", ".", "join", "(", ")", "\n", "pan_2ch_all", "=", "[", "]", "\n", "for", "p", "in", "processes", ":", "\n", "            ", "pan_2ch_all", ".", "extend", "(", "p", ".", "get", "(", ")", ")", "\n", "", "return", "pan_2ch_all", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset._merge_pred_single_core": [[405, 450], ["range", "len", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.unique", "range", "numpy.zeros", "sem.copy", "numpy.zeros.copy", "pan_2ch_all.append", "len", "mask_decode", "mask_decode.astype().sum", "area.sum", "ins_remain.astype().sum", "mask_decode.astype().sum", "mask_decode.astype", "ins_remain.astype", "mask_decode.astype"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_merge_pred_single_core", "(", "proc_id", ",", "boxes_set", ",", "cls_idxs_set", ",", "masks_set", ",", "sems_set", ",", "score_threshold", ",", "fraction_threshold", ",", "stuff_area_limit", ")", ":", "\n", "        ", "from", "pycocotools", ".", "mask", "import", "decode", "as", "mask_decode", "\n", "pan_2ch_all", "=", "[", "]", "\n", "id_last_stuff", "=", "config", ".", "dataset", ".", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", "\n", "\n", "for", "idx_outer", "in", "range", "(", "len", "(", "boxes_set", ")", ")", ":", "\n", "            ", "boxes", ",", "scores", ",", "cls_idxs", ",", "masks", "=", "boxes_set", "[", "idx_outer", "]", "[", ":", ",", ":", "4", "]", ",", "boxes_set", "[", "idx_outer", "]", "[", ":", ",", "4", "]", ",", "cls_idxs_set", "[", "idx_outer", "]", ",", "masks_set", "[", "idx_outer", "]", "\n", "sem", "=", "sems_set", "[", "idx_outer", "]", "\n", "h", ",", "w", "=", "sem", ".", "shape", "\n", "ins_mask", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "ins_sem", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "idx_ins_array", "=", "np", ".", "zeros", "(", "config", ".", "dataset", ".", "num_classes", "-", "1", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "for", "idx_inner", "in", "range", "(", "len", "(", "scores", ")", ")", ":", "\n", "                ", "score", ",", "cls_idx", ",", "mask", "=", "scores", "[", "idx_inner", "]", ",", "cls_idxs", "[", "idx_inner", "]", ",", "masks", "[", "idx_inner", "]", "\n", "if", "score", "<", "score_threshold", ":", "\n", "                    ", "continue", "\n", "", "mask", "=", "mask_decode", "(", "masks", "[", "idx_inner", "]", ")", "\n", "ins_remain", "=", "(", "mask", "==", "1", ")", "&", "(", "ins_mask", "==", "0", ")", "\n", "if", "(", "mask", ".", "astype", "(", "np", ".", "float32", ")", ".", "sum", "(", ")", "==", "0", ")", "or", "(", "ins_remain", ".", "astype", "(", "np", ".", "float32", ")", ".", "sum", "(", ")", "/", "mask", ".", "astype", "(", "np", ".", "float32", ")", ".", "sum", "(", ")", "<", "fraction_threshold", ")", ":", "\n", "                    ", "continue", "\n", "", "idx_ins_array", "[", "cls_idx", "-", "1", "]", "+=", "1", "\n", "ins_mask", "[", "ins_remain", "]", "=", "idx_ins_array", "[", "cls_idx", "-", "1", "]", "\n", "ins_sem", "[", "ins_remain", "]", "=", "cls_idx", "\n", "\n", "", "idx_sem", "=", "np", ".", "unique", "(", "sem", ")", "\n", "for", "i", "in", "range", "(", "idx_sem", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "if", "idx_sem", "[", "i", "]", "<=", "id_last_stuff", ":", "\n", "                    ", "area", "=", "sem", "==", "idx_sem", "[", "i", "]", "\n", "if", "(", "area", ")", ".", "sum", "(", ")", "<", "stuff_area_limit", ":", "\n", "                        ", "sem", "[", "area", "]", "=", "255", "\n", "\n", "# merge sem and ins, leave conflict region as 255", "\n", "", "", "", "pan_2ch", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "pan_2ch_c0", "=", "sem", ".", "copy", "(", ")", "\n", "pan_2ch_c1", "=", "ins_mask", ".", "copy", "(", ")", "\n", "conflict", "=", "(", "sem", ">", "id_last_stuff", ")", "&", "(", "ins_mask", "==", "0", ")", "# sem treat as thing while ins treat as stuff", "\n", "pan_2ch_c0", "[", "conflict", "]", "=", "255", "\n", "insistence", "=", "(", "ins_mask", "!=", "0", ")", "# change sem region to ins thing region", "\n", "pan_2ch_c0", "[", "insistence", "]", "=", "ins_sem", "[", "insistence", "]", "+", "id_last_stuff", "\n", "pan_2ch", "[", ":", ",", ":", ",", "0", "]", "=", "pan_2ch_c0", "\n", "pan_2ch", "[", ":", ",", ":", ",", "1", "]", "=", "pan_2ch_c1", "\n", "pan_2ch_all", ".", "append", "(", "pan_2ch", ")", "\n", "\n", "", "return", "pan_2ch_all", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset._load_image_single_core": [[451, 461], ["enumerate", "numpy.array", "images.append", "PIL.Image.open", "os.path.join"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_load_image_single_core", "(", "proc_id", ",", "files_set", ",", "folder", ")", ":", "\n", "        ", "images", "=", "[", "]", "\n", "for", "working_idx", ",", "file", "in", "enumerate", "(", "files_set", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "image", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "os", ".", "path", ".", "join", "(", "folder", ",", "file", ")", ")", ")", "\n", "images", ".", "append", "(", "image", ")", "\n", "", "except", "Exception", ":", "\n", "                ", "pass", "\n", "", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset._converter_2ch_single_core": [[462, 512], ["sys.path.insert", "range", "os.path.join", "len", "numpy.uint32", "numpy.zeros", "numpy.unique", "annotations.append", "pan_all.append", "os.path.abspath", "numpy.where", "index[].min", "index[].min", "segm_info.append", "PIL.Image.fromarray", "PIL.ImageDraw.Draw", "numpy.array", "os.path.dirname", "color_gererator.get_color", "index[].max", "index[].max", "sem.item", "int", "mask.sum().item", "cv2.findContours", "rgb2id", "index[].min.item", "index[].min.item", "width.item", "height.item", "mask.copy", "c.reshape().tolist.reshape().tolist.reshape().tolist", "PIL.ImageDraw.Draw.line", "mask.sum", "len", "print", "c.reshape().tolist.reshape().tolist.reshape"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_converter_2ch_single_core", "(", "proc_id", ",", "pan_2ch_set", ",", "color_gererator", ")", ":", "\n", "        ", "sys", ".", "path", ".", "insert", "(", "0", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ",", "'..'", ",", "'..'", ",", "'lib'", ",", "'dataset_devkit'", ")", ")", "\n", "from", "panopticapi", ".", "utils", "import", "rgb2id", "\n", "OFFSET", "=", "1000", "\n", "VOID", "=", "255", "\n", "annotations", ",", "pan_all", "=", "[", "]", ",", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "pan_2ch_set", ")", ")", ":", "\n", "            ", "pan_2ch", "=", "np", ".", "uint32", "(", "pan_2ch_set", "[", "idx", "]", ")", "\n", "pan", "=", "OFFSET", "*", "pan_2ch", "[", ":", ",", ":", ",", "0", "]", "+", "pan_2ch", "[", ":", ",", ":", ",", "1", "]", "\n", "pan_format", "=", "np", ".", "zeros", "(", "(", "pan_2ch", ".", "shape", "[", "0", "]", ",", "pan_2ch", ".", "shape", "[", "1", "]", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "l", "=", "np", ".", "unique", "(", "pan", ")", "\n", "segm_info", "=", "[", "]", "\n", "for", "el", "in", "l", ":", "\n", "                ", "sem", "=", "el", "//", "OFFSET", "\n", "if", "sem", "==", "VOID", ":", "\n", "                    ", "continue", "\n", "", "mask", "=", "pan", "==", "el", "\n", "if", "vis_panoptic", ":", "\n", "                    ", "color", "=", "color_gererator", ".", "categories", "[", "sem", "]", "[", "'color'", "]", "\n", "", "else", ":", "\n", "                    ", "color", "=", "color_gererator", ".", "get_color", "(", "sem", ")", "\n", "", "pan_format", "[", "mask", "]", "=", "color", "\n", "index", "=", "np", ".", "where", "(", "mask", ")", "\n", "x", "=", "index", "[", "1", "]", ".", "min", "(", ")", "\n", "y", "=", "index", "[", "0", "]", ".", "min", "(", ")", "\n", "width", "=", "index", "[", "1", "]", ".", "max", "(", ")", "-", "x", "\n", "height", "=", "index", "[", "0", "]", ".", "max", "(", ")", "-", "y", "\n", "segm_info", ".", "append", "(", "{", "\"category_id\"", ":", "sem", ".", "item", "(", ")", ",", "\"iscrowd\"", ":", "0", ",", "\"id\"", ":", "int", "(", "rgb2id", "(", "color", ")", ")", ",", "\"bbox\"", ":", "[", "x", ".", "item", "(", ")", ",", "y", ".", "item", "(", ")", ",", "width", ".", "item", "(", ")", ",", "height", ".", "item", "(", ")", "]", ",", "\"area\"", ":", "mask", ".", "sum", "(", ")", ".", "item", "(", ")", "}", ")", "\n", "", "annotations", ".", "append", "(", "{", "\"segments_info\"", ":", "segm_info", "}", ")", "\n", "if", "vis_panoptic", ":", "\n", "                ", "pan_format", "=", "Image", ".", "fromarray", "(", "pan_format", ")", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "pan_format", ")", "\n", "for", "el", "in", "l", ":", "\n", "                    ", "sem", "=", "el", "//", "OFFSET", "\n", "if", "sem", "==", "VOID", ":", "\n", "                        ", "continue", "\n", "", "if", "color_gererator", ".", "categories", "[", "sem", "]", "[", "'isthing'", "]", "and", "el", "%", "OFFSET", "!=", "0", ":", "\n", "                        ", "mask", "=", "(", "(", "pan", "==", "el", ")", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "_", ",", "contour", ",", "_", "=", "cv2", ".", "findContours", "(", "mask", ".", "copy", "(", ")", ",", "cv2", ".", "RETR_EXTERNAL", ",", "cv2", ".", "CHAIN_APPROX_NONE", ")", "\n", "for", "c", "in", "contour", ":", "\n", "                            ", "c", "=", "c", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", "\n", "if", "len", "(", "c", ")", "<", "4", ":", "\n", "                                ", "print", "(", "'warning: invalid contour'", ")", "\n", "continue", "\n", "", "draw", ".", "line", "(", "c", ",", "fill", "=", "'white'", ",", "width", "=", "2", ")", "\n", "", "", "", "pan_format", "=", "np", ".", "array", "(", "pan_format", ")", "\n", "", "pan_all", ".", "append", "(", "pan_format", ")", "\n", "", "return", "annotations", ",", "pan_all", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset._pq_compute_single_core": [[513, 609], ["base_dataset.PQStat", "enumerate", "zip", "set", "numpy.unique", "zip", "numpy.unique", "zip", "set", "set", "gt_pred_map.items", "gt_segms.items", "pred_segms.items", "numpy.uint32", "numpy.uint32", "set.remove", "len", "KeyError", "pan_pred.astype", "gt_pred_map.get", "KeyError", "KeyError", "pan_gt.astype", "gt_pred_map.get", "set.add", "set.add", "gt_pred_map.get", "list"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.EvalMetric.get"], ["", "@", "staticmethod", "\n", "def", "_pq_compute_single_core", "(", "proc_id", ",", "gt_jsons_set", ",", "pred_jsons_set", ",", "gt_pans_set", ",", "pred_pans_set", ",", "gt_image_jsons_set", ",", "categories", ")", ":", "\n", "        ", "OFFSET", "=", "256", "*", "256", "*", "256", "\n", "VOID", "=", "0", "\n", "pq_stat", "=", "PQStat", "(", ")", "\n", "for", "idx", ",", "(", "gt_json", ",", "pred_json", ",", "gt_pan", ",", "pred_pan", ",", "gt_image_json", ")", "in", "enumerate", "(", "zip", "(", "gt_jsons_set", ",", "pred_jsons_set", ",", "gt_pans_set", ",", "pred_pans_set", ",", "gt_image_jsons_set", ")", ")", ":", "\n", "# if idx % 100 == 0:", "\n", "#     logger.info('Compute pq -> Core: {}, {} from {} images processed'.format(proc_id, idx, len(gt_jsons_set)))", "\n", "            ", "gt_pan", ",", "pred_pan", "=", "np", ".", "uint32", "(", "gt_pan", ")", ",", "np", ".", "uint32", "(", "pred_pan", ")", "\n", "pan_gt", "=", "gt_pan", "[", ":", ",", ":", ",", "0", "]", "+", "gt_pan", "[", ":", ",", ":", ",", "1", "]", "*", "256", "+", "gt_pan", "[", ":", ",", ":", ",", "2", "]", "*", "256", "*", "256", "\n", "pan_pred", "=", "pred_pan", "[", ":", ",", ":", ",", "0", "]", "+", "pred_pan", "[", ":", ",", ":", ",", "1", "]", "*", "256", "+", "pred_pan", "[", ":", ",", ":", ",", "2", "]", "*", "256", "*", "256", "\n", "\n", "gt_segms", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "gt_json", "[", "'segments_info'", "]", "}", "\n", "pred_segms", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "pred_json", "[", "'segments_info'", "]", "}", "\n", "\n", "# predicted segments area calculation + prediction sanity checks", "\n", "pred_labels_set", "=", "set", "(", "el", "[", "'id'", "]", "for", "el", "in", "pred_json", "[", "'segments_info'", "]", ")", "\n", "labels", ",", "labels_cnt", "=", "np", ".", "unique", "(", "pan_pred", ",", "return_counts", "=", "True", ")", "\n", "for", "label", ",", "label_cnt", "in", "zip", "(", "labels", ",", "labels_cnt", ")", ":", "\n", "                ", "if", "label", "not", "in", "pred_segms", ":", "\n", "                    ", "if", "label", "==", "VOID", ":", "\n", "                        ", "continue", "\n", "", "raise", "KeyError", "(", "'In the image with ID {} segment with ID {} is presented in PNG and not presented in JSON.'", ".", "format", "(", "gt_ann", "[", "'image_id'", "]", ",", "label", ")", ")", "\n", "", "pred_segms", "[", "label", "]", "[", "'area'", "]", "=", "label_cnt", "\n", "pred_labels_set", ".", "remove", "(", "label", ")", "\n", "if", "pred_segms", "[", "label", "]", "[", "'category_id'", "]", "not", "in", "categories", ":", "\n", "                    ", "raise", "KeyError", "(", "'In the image with ID {} segment with ID {} has unknown category_id {}.'", ".", "format", "(", "gt_ann", "[", "'image_id'", "]", ",", "label", ",", "pred_segms", "[", "label", "]", "[", "'category_id'", "]", ")", ")", "\n", "", "", "if", "len", "(", "pred_labels_set", ")", "!=", "0", ":", "\n", "                ", "raise", "KeyError", "(", "\n", "'In the image with ID {} the following segment IDs {} are presented in JSON and not presented in PNG.'", ".", "format", "(", "gt_ann", "[", "'image_id'", "]", ",", "list", "(", "pred_labels_set", ")", ")", ")", "\n", "\n", "# confusion matrix calculation", "\n", "", "pan_gt_pred", "=", "pan_gt", ".", "astype", "(", "np", ".", "uint64", ")", "*", "OFFSET", "+", "pan_pred", ".", "astype", "(", "np", ".", "uint64", ")", "\n", "gt_pred_map", "=", "{", "}", "\n", "labels", ",", "labels_cnt", "=", "np", ".", "unique", "(", "pan_gt_pred", ",", "return_counts", "=", "True", ")", "\n", "for", "label", ",", "intersection", "in", "zip", "(", "labels", ",", "labels_cnt", ")", ":", "\n", "                ", "gt_id", "=", "label", "//", "OFFSET", "\n", "pred_id", "=", "label", "%", "OFFSET", "\n", "gt_pred_map", "[", "(", "gt_id", ",", "pred_id", ")", "]", "=", "intersection", "\n", "\n", "# count all matched pairs", "\n", "", "gt_matched", "=", "set", "(", ")", "\n", "pred_matched", "=", "set", "(", ")", "\n", "tp", "=", "0", "\n", "fp", "=", "0", "\n", "fn", "=", "0", "\n", "\n", "for", "label_tuple", ",", "intersection", "in", "gt_pred_map", ".", "items", "(", ")", ":", "\n", "                ", "gt_label", ",", "pred_label", "=", "label_tuple", "\n", "if", "gt_label", "not", "in", "gt_segms", ":", "\n", "                    ", "continue", "\n", "", "if", "pred_label", "not", "in", "pred_segms", ":", "\n", "                    ", "continue", "\n", "", "if", "gt_segms", "[", "gt_label", "]", "[", "'iscrowd'", "]", "==", "1", ":", "\n", "                    ", "continue", "\n", "", "if", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "!=", "pred_segms", "[", "pred_label", "]", "[", "'category_id'", "]", ":", "\n", "                    ", "continue", "\n", "\n", "", "union", "=", "pred_segms", "[", "pred_label", "]", "[", "'area'", "]", "+", "gt_segms", "[", "gt_label", "]", "[", "'area'", "]", "-", "intersection", "-", "gt_pred_map", ".", "get", "(", "\n", "(", "VOID", ",", "pred_label", ")", ",", "0", ")", "\n", "iou", "=", "intersection", "/", "union", "\n", "if", "iou", ">", "0.5", ":", "\n", "                    ", "pq_stat", "[", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "]", ".", "tp", "+=", "1", "\n", "pq_stat", "[", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "]", ".", "iou", "+=", "iou", "\n", "gt_matched", ".", "add", "(", "gt_label", ")", "\n", "pred_matched", ".", "add", "(", "pred_label", ")", "\n", "tp", "+=", "1", "\n", "\n", "# count false positives", "\n", "", "", "crowd_labels_dict", "=", "{", "}", "\n", "for", "gt_label", ",", "gt_info", "in", "gt_segms", ".", "items", "(", ")", ":", "\n", "                ", "if", "gt_label", "in", "gt_matched", ":", "\n", "                    ", "continue", "\n", "# crowd segments are ignored", "\n", "", "if", "gt_info", "[", "'iscrowd'", "]", "==", "1", ":", "\n", "                    ", "crowd_labels_dict", "[", "gt_info", "[", "'category_id'", "]", "]", "=", "gt_label", "\n", "continue", "\n", "", "pq_stat", "[", "gt_info", "[", "'category_id'", "]", "]", ".", "fn", "+=", "1", "\n", "fn", "+=", "1", "\n", "\n", "# count false positives", "\n", "", "for", "pred_label", ",", "pred_info", "in", "pred_segms", ".", "items", "(", ")", ":", "\n", "                ", "if", "pred_label", "in", "pred_matched", ":", "\n", "                    ", "continue", "\n", "# intersection of the segment with VOID", "\n", "", "intersection", "=", "gt_pred_map", ".", "get", "(", "(", "VOID", ",", "pred_label", ")", ",", "0", ")", "\n", "# plus intersection with corresponding CROWD region if it exists", "\n", "if", "pred_info", "[", "'category_id'", "]", "in", "crowd_labels_dict", ":", "\n", "                    ", "intersection", "+=", "gt_pred_map", ".", "get", "(", "(", "crowd_labels_dict", "[", "pred_info", "[", "'category_id'", "]", "]", ",", "pred_label", ")", ",", "0", ")", "\n", "# predicted segment is ignored if more than half of the segment correspond to VOID and CROWD regions", "\n", "", "if", "intersection", "/", "pred_info", "[", "'area'", "]", ">", "0.5", ":", "\n", "                    ", "continue", "\n", "", "pq_stat", "[", "pred_info", "[", "'category_id'", "]", "]", ".", "fp", "+=", "1", "\n", "fp", "+=", "1", "\n", "# logger.info('Compute pq -> Core: {}, all {} images processed'.format(proc_id, len(gt_jsons_set)))", "\n", "", "", "return", "pq_stat", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset._save_image_single_core": [[610, 625], ["enumerate", "PIL.Image.fromarray().convert", "PIL.Image.fromarray().convert.putpalette", "zip", "os.makedirs", "PIL.Image.fromarray.save", "base_dataset.BaseDataset._save_image_single_core.colorize"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_save_image_single_core", "(", "proc_id", ",", "images_set", ",", "names_set", ",", "colors", "=", "None", ")", ":", "\n", "        ", "def", "colorize", "(", "gray", ",", "palette", ")", ":", "\n", "# gray: numpy array of the label and 1*3N size list palette", "\n", "            ", "color", "=", "Image", ".", "fromarray", "(", "gray", ".", "astype", "(", "np", ".", "uint8", ")", ")", ".", "convert", "(", "'P'", ")", "\n", "color", ".", "putpalette", "(", "palette", ")", "\n", "return", "color", "\n", "\n", "", "for", "working_idx", ",", "(", "image", ",", "name", ")", "in", "enumerate", "(", "zip", "(", "images_set", ",", "names_set", ")", ")", ":", "\n", "            ", "if", "colors", "is", "not", "None", ":", "\n", "                ", "image", "=", "colorize", "(", "image", ",", "colors", ")", "\n", "", "else", ":", "\n", "                ", "image", "=", "Image", ".", "fromarray", "(", "image", ")", "\n", "", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "name", ")", ",", "exist_ok", "=", "True", ")", "\n", "image", ".", "save", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.bbox_results_one_category": [[626, 648], ["base_dataset.BaseDataset.dataset.COCO.getImgIds", "base_dataset.BaseDataset.sort", "enumerate", "len", "len", "dets.astype.astype.astype", "upsnet.bbox.bbox_transform.xyxy_to_xywh", "results.extend", "isinstance", "len", "range"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.xyxy_to_xywh"], ["", "", "def", "bbox_results_one_category", "(", "self", ",", "boxes", ",", "cat_id", ")", ":", "\n", "        ", "results", "=", "[", "]", "\n", "image_ids", "=", "self", ".", "dataset", ".", "COCO", ".", "getImgIds", "(", ")", "\n", "image_ids", ".", "sort", "(", ")", "\n", "assert", "len", "(", "boxes", ")", "==", "len", "(", "image_ids", ")", "\n", "for", "i", ",", "image_id", "in", "enumerate", "(", "image_ids", ")", ":", "\n", "            ", "dets", "=", "boxes", "[", "i", "]", "\n", "if", "isinstance", "(", "dets", ",", "list", ")", "and", "len", "(", "dets", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "dets", "=", "dets", ".", "astype", "(", "np", ".", "float", ")", "\n", "scores", "=", "dets", "[", ":", ",", "-", "1", "]", "\n", "xywh_dets", "=", "bbox_transform", ".", "xyxy_to_xywh", "(", "dets", "[", ":", ",", "0", ":", "4", "]", ")", "\n", "xs", "=", "xywh_dets", "[", ":", ",", "0", "]", "\n", "ys", "=", "xywh_dets", "[", ":", ",", "1", "]", "\n", "ws", "=", "xywh_dets", "[", ":", ",", "2", "]", "\n", "hs", "=", "xywh_dets", "[", ":", ",", "3", "]", "\n", "results", ".", "extend", "(", "\n", "[", "{", "'image_id'", ":", "image_id", ",", "\n", "'category_id'", ":", "cat_id", ",", "\n", "'bbox'", ":", "[", "xs", "[", "k", "]", ",", "ys", "[", "k", "]", ",", "ws", "[", "k", "]", ",", "hs", "[", "k", "]", "]", ",", "\n", "'score'", ":", "scores", "[", "k", "]", "}", "for", "k", "in", "range", "(", "dets", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.segms_results_one_category": [[649, 673], ["base_dataset.BaseDataset.dataset.COCO.getImgIds", "base_dataset.BaseDataset.sort", "enumerate", "len", "len", "len", "len", "dets.astype.astype.astype", "results.extend", "isinstance", "len", "range"], "methods", ["None"], ["", "def", "segms_results_one_category", "(", "self", ",", "boxes", ",", "segms", ",", "cat_id", ")", ":", "\n", "        ", "results", "=", "[", "]", "\n", "image_ids", "=", "self", ".", "dataset", ".", "COCO", ".", "getImgIds", "(", ")", "\n", "image_ids", ".", "sort", "(", ")", "\n", "assert", "len", "(", "boxes", ")", "==", "len", "(", "image_ids", ")", "\n", "assert", "len", "(", "segms", ")", "==", "len", "(", "image_ids", ")", "\n", "for", "i", ",", "image_id", "in", "enumerate", "(", "image_ids", ")", ":", "\n", "            ", "dets", "=", "boxes", "[", "i", "]", "\n", "rles", "=", "segms", "[", "i", "]", "\n", "\n", "if", "isinstance", "(", "dets", ",", "list", ")", "and", "len", "(", "dets", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "dets", "=", "dets", ".", "astype", "(", "np", ".", "float", ")", "\n", "scores", "=", "dets", "[", ":", ",", "-", "1", "]", "\n", "\n", "results", ".", "extend", "(", "\n", "[", "{", "'image_id'", ":", "image_id", ",", "\n", "'category_id'", ":", "cat_id", ",", "\n", "'segmentation'", ":", "rles", "[", "k", "]", ",", "\n", "'score'", ":", "scores", "[", "k", "]", "}", "\n", "for", "k", "in", "range", "(", "dets", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.log_detection_eval_metrics": [[674, 722], ["tee", "coco_eval.summarize", "numpy.isclose", "open", "base_dataset.BaseDataset.log_detection_eval_metrics._get_thr_ind"], "methods", ["None"], ["", "def", "log_detection_eval_metrics", "(", "self", ",", "coco_eval", ",", "log_file", ")", ":", "\n", "\n", "        ", "def", "_get_thr_ind", "(", "coco_eval", ",", "thr", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "(", "coco_eval", ".", "params", ".", "iouThrs", ">", "thr", "-", "1e-5", ")", "&", "\n", "(", "coco_eval", ".", "params", ".", "iouThrs", "<", "thr", "+", "1e-5", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "iou_thr", "=", "coco_eval", ".", "params", ".", "iouThrs", "[", "ind", "]", "\n", "assert", "np", ".", "isclose", "(", "iou_thr", ",", "thr", ")", "\n", "return", "ind", "\n", "\n", "", "class", "tee", ":", "\n", "            ", "def", "__init__", "(", "self", ",", "*", "files", ")", ":", "\n", "                ", "self", ".", "files", "=", "files", "\n", "\n", "", "def", "write", "(", "self", ",", "obj", ")", ":", "\n", "                ", "for", "f", "in", "self", ".", "files", ":", "\n", "                    ", "f", ".", "write", "(", "obj", ")", "\n", "\n", "", "", "", "stdout", "=", "sys", ".", "stdout", "\n", "sys", ".", "stdout", "=", "tee", "(", "sys", ".", "stdout", ",", "open", "(", "log_file", ",", "'w'", ")", ")", "\n", "\n", "IoU_lo_thresh", "=", "0.5", "\n", "for", "IoU_hi_thresh", "in", "[", "0.95", ",", "0.5", "]", ":", "\n", "            ", "ind_lo", "=", "_get_thr_ind", "(", "coco_eval", ",", "IoU_lo_thresh", ")", "\n", "ind_hi", "=", "_get_thr_ind", "(", "coco_eval", ",", "IoU_hi_thresh", ")", "\n", "# precision has dims (iou, recall, cls, area range, max dets)", "\n", "# area range index 0: all area ranges", "\n", "# max dets index 2: 100 per image", "\n", "precision", "=", "coco_eval", ".", "eval", "[", "'precision'", "]", "[", "ind_lo", ":", "(", "ind_hi", "+", "1", ")", ",", ":", ",", ":", ",", "0", ",", "2", "]", "\n", "ap_default", "=", "np", ".", "mean", "(", "precision", "[", "precision", ">", "-", "1", "]", ")", "\n", "if", "logger", ":", "\n", "                ", "logger", ".", "info", "(", "\n", "'~~~~ Mean and per-category AP @ IoU=[{:.2f},{:.2f}] ~~~~'", ".", "format", "(", "\n", "IoU_lo_thresh", ",", "IoU_hi_thresh", ")", ")", "\n", "", "for", "cls_ind", ",", "cls", "in", "enumerate", "(", "self", ".", "dataset", ".", "classes", ")", ":", "\n", "                ", "if", "cls", "==", "'__background__'", ":", "\n", "                    ", "continue", "\n", "# minus 1 because of __background__", "\n", "", "precision", "=", "coco_eval", ".", "eval", "[", "'precision'", "]", "[", "ind_lo", ":", "(", "ind_hi", "+", "1", ")", ",", ":", ",", "cls_ind", "-", "1", ",", "0", ",", "2", "]", "\n", "ap", "=", "np", ".", "mean", "(", "precision", "[", "precision", ">", "-", "1", "]", ")", "\n", "if", "logger", ":", "\n", "                    ", "logger", ".", "info", "(", "'{:.3f}'", ".", "format", "(", "ap", ")", ")", "\n", "", "", "if", "logger", ":", "\n", "                ", "logger", ".", "info", "(", "'{:.3f}'", ".", "format", "(", "ap_default", ")", ")", "\n", "", "", "if", "logger", ":", "\n", "            ", "logger", ".", "info", "(", "'~~~~ Summary metrics ~~~~'", ")", "\n", "", "coco_eval", ".", "summarize", "(", ")", "\n", "\n", "sys", ".", "stdout", "=", "stdout", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.evaluate_box_proposals": [[723, 805], ["numpy.zeros", "numpy.sort", "numpy.zeros_like", "enumerate", "numpy.zeros_like.mean", "len", "upsnet.bbox.bbox_transform.bbox_overlaps", "numpy.zeros", "range", "numpy.hstack", "numpy.arange", "numpy.where", "numpy.where", "numpy.where", "boxes.astype", "gt_boxes.astype", "min", "upsnet.bbox.bbox_transform.bbox_overlaps.argmax", "upsnet.bbox.bbox_transform.bbox_overlaps.max", "bbox_transform.bbox_overlaps.max.argmax", "bbox_transform.bbox_overlaps.max.max", "float"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps"], ["", "def", "evaluate_box_proposals", "(", "\n", "self", ",", "roidb", ",", "thresholds", "=", "None", ",", "area", "=", "'all'", ",", "limit", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"Evaluate detection proposal recall metrics. This function is a much\n        faster alternative to the official COCO API recall evaluation code. However,\n        it produces slightly different results.\n        \"\"\"", "\n", "# Record max overlap value for each gt box", "\n", "# Return vector of overlap values", "\n", "areas", "=", "{", "\n", "'all'", ":", "0", ",", "\n", "'small'", ":", "1", ",", "\n", "'medium'", ":", "2", ",", "\n", "'large'", ":", "3", ",", "\n", "'96-128'", ":", "4", ",", "\n", "'128-256'", ":", "5", ",", "\n", "'256-512'", ":", "6", ",", "\n", "'512-inf'", ":", "7", "}", "\n", "area_ranges", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "# all", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "# small", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "# medium", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "# large", "\n", "[", "96", "**", "2", ",", "128", "**", "2", "]", ",", "# 96-128", "\n", "[", "128", "**", "2", ",", "256", "**", "2", "]", ",", "# 128-256", "\n", "[", "256", "**", "2", ",", "512", "**", "2", "]", ",", "# 256-512", "\n", "[", "512", "**", "2", ",", "1e5", "**", "2", "]", "]", "# 512-inf", "\n", "assert", "area", "in", "areas", ",", "'Unknown area range: {}'", ".", "format", "(", "area", ")", "\n", "area_range", "=", "area_ranges", "[", "areas", "[", "area", "]", "]", "\n", "gt_overlaps", "=", "np", ".", "zeros", "(", "0", ")", "\n", "num_pos", "=", "0", "\n", "for", "entry", "in", "roidb", ":", "\n", "            ", "gt_inds", "=", "np", ".", "where", "(", "\n", "(", "entry", "[", "'gt_classes'", "]", ">", "0", ")", "&", "(", "entry", "[", "'is_crowd'", "]", "==", "0", ")", ")", "[", "0", "]", "\n", "gt_boxes", "=", "entry", "[", "'boxes'", "]", "[", "gt_inds", ",", ":", "]", "\n", "gt_areas", "=", "entry", "[", "'seg_areas'", "]", "[", "gt_inds", "]", "\n", "valid_gt_inds", "=", "np", ".", "where", "(", "\n", "(", "gt_areas", ">=", "area_range", "[", "0", "]", ")", "&", "(", "gt_areas", "<=", "area_range", "[", "1", "]", ")", ")", "[", "0", "]", "\n", "gt_boxes", "=", "gt_boxes", "[", "valid_gt_inds", ",", ":", "]", "\n", "num_pos", "+=", "len", "(", "valid_gt_inds", ")", "\n", "non_gt_inds", "=", "np", ".", "where", "(", "entry", "[", "'gt_classes'", "]", "==", "0", ")", "[", "0", "]", "\n", "boxes", "=", "entry", "[", "'boxes'", "]", "[", "non_gt_inds", ",", ":", "]", "\n", "if", "boxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "if", "limit", "is", "not", "None", "and", "boxes", ".", "shape", "[", "0", "]", ">", "limit", ":", "\n", "                ", "boxes", "=", "boxes", "[", ":", "limit", ",", ":", "]", "\n", "", "overlaps", "=", "bbox_transform", ".", "bbox_overlaps", "(", "\n", "boxes", ".", "astype", "(", "dtype", "=", "np", ".", "float32", ",", "copy", "=", "False", ")", ",", "\n", "gt_boxes", ".", "astype", "(", "dtype", "=", "np", ".", "float32", ",", "copy", "=", "False", ")", ")", "\n", "_gt_overlaps", "=", "np", ".", "zeros", "(", "(", "gt_boxes", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "j", "in", "range", "(", "min", "(", "boxes", ".", "shape", "[", "0", "]", ",", "gt_boxes", ".", "shape", "[", "0", "]", ")", ")", ":", "\n", "# find which proposal box maximally covers each gt box", "\n", "                ", "argmax_overlaps", "=", "overlaps", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "# and get the iou amount of coverage for each gt box", "\n", "max_overlaps", "=", "overlaps", ".", "max", "(", "axis", "=", "0", ")", "\n", "# find which gt box is 'best' covered (i.e. 'best' = most iou)", "\n", "gt_ind", "=", "max_overlaps", ".", "argmax", "(", ")", "\n", "gt_ovr", "=", "max_overlaps", ".", "max", "(", ")", "\n", "assert", "gt_ovr", ">=", "0", "\n", "# find the proposal box that covers the best covered gt box", "\n", "box_ind", "=", "argmax_overlaps", "[", "gt_ind", "]", "\n", "# record the iou coverage of this gt box", "\n", "_gt_overlaps", "[", "j", "]", "=", "overlaps", "[", "box_ind", ",", "gt_ind", "]", "\n", "assert", "_gt_overlaps", "[", "j", "]", "==", "gt_ovr", "\n", "# mark the proposal box and the gt box as used", "\n", "overlaps", "[", "box_ind", ",", ":", "]", "=", "-", "1", "\n", "overlaps", "[", ":", ",", "gt_ind", "]", "=", "-", "1", "\n", "# append recorded iou coverage level", "\n", "", "gt_overlaps", "=", "np", ".", "hstack", "(", "(", "gt_overlaps", ",", "_gt_overlaps", ")", ")", "\n", "\n", "", "gt_overlaps", "=", "np", ".", "sort", "(", "gt_overlaps", ")", "\n", "if", "thresholds", "is", "None", ":", "\n", "            ", "step", "=", "0.05", "\n", "thresholds", "=", "np", ".", "arange", "(", "0.5", ",", "0.95", "+", "1e-5", ",", "step", ")", "\n", "", "recalls", "=", "np", ".", "zeros_like", "(", "thresholds", ")", "\n", "# compute recall for each iou threshold", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "            ", "recalls", "[", "i", "]", "=", "(", "gt_overlaps", ">=", "t", ")", ".", "sum", "(", ")", "/", "float", "(", "num_pos", ")", "\n", "# ar = 2 * np.trapz(recalls, thresholds)", "\n", "", "ar", "=", "recalls", ".", "mean", "(", ")", "\n", "return", "{", "'ar'", ":", "ar", ",", "'recalls'", ":", "recalls", ",", "'thresholds'", ":", "thresholds", ",", "\n", "'gt_overlaps'", ":", "gt_overlaps", ",", "'num_pos'", ":", "num_pos", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.get_confusion_matrix": [[806, 825], ["numpy.bincount", "numpy.zeros", "range", "range", "len"], "methods", ["None"], ["", "def", "get_confusion_matrix", "(", "self", ",", "gt_label", ",", "pred_label", ",", "class_num", ")", ":", "\n", "        ", "\"\"\"\n        Calcute the confusion matrix by given label and pred\n        :param gt_label: the ground truth label\n        :param pred_label: the pred label\n        :param class_num: the nunber of class\n        :return: the confusion matrix\n        \"\"\"", "\n", "index", "=", "(", "gt_label", "*", "class_num", "+", "pred_label", ")", ".", "astype", "(", "'int32'", ")", "\n", "label_count", "=", "np", ".", "bincount", "(", "index", ")", "\n", "confusion_matrix", "=", "np", ".", "zeros", "(", "(", "class_num", ",", "class_num", ")", ")", "\n", "\n", "for", "i_label", "in", "range", "(", "class_num", ")", ":", "\n", "            ", "for", "i_pred_label", "in", "range", "(", "class_num", ")", ":", "\n", "                ", "cur_index", "=", "i_label", "*", "class_num", "+", "i_pred_label", "\n", "if", "cur_index", "<", "len", "(", "label_count", ")", ":", "\n", "                    ", "confusion_matrix", "[", "i_label", ",", "i_pred_label", "]", "=", "label_count", "[", "cur_index", "]", "\n", "\n", "", "", "", "return", "confusion_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.vis_all_mask": [[826, 897], ["matplotlib.use", "range", "os.makedirs", "colormap", "len", "numpy.array", "plt.figure", "plt.figure.set_size_inches", "plt.Axes", "plt.Axes.axis", "plt.figure.add_axes", "plt.Axes.imshow", "enumerate", "plt.close", "PIL.Image.open", "pycocotools.decode", "range", "plt.show", "plt.figure.savefig", "plt.Axes.add_patch", "plt.Axes.text", "range", "cv2.findContours", "os.path.join", "plt.Rectangle", "mask.copy", "plt.Axes.add_patch", "dict", "Polygon", "c.reshape", "[].split", "len"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.colormap.colormap"], ["", "def", "vis_all_mask", "(", "self", ",", "all_boxes", ",", "all_masks", ",", "save_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        visualize all detections in one image\n        :param im_array: [b=1 c h w] in rgb\n        :param detections: [ numpy.ndarray([[x1 y1 x2 y2 score]]) for j in classes ]\n        :param class_names: list of names in imdb\n        :param scale: visualize the scaled image\n        :return:\n        \"\"\"", "\n", "import", "matplotlib", "\n", "matplotlib", ".", "use", "(", "'Agg'", ")", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "from", "matplotlib", ".", "patches", "import", "Polygon", "\n", "import", "random", "\n", "import", "cv2", "\n", "from", "lib", ".", "utils", ".", "colormap", "import", "colormap", "\n", "\n", "if", "save_path", "is", "not", "None", ":", "\n", "            ", "os", ".", "makedirs", "(", "save_path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "color_list", "=", "colormap", "(", "rgb", "=", "True", ")", "/", "255", "\n", "mask_color_id", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "roidb", ")", ")", ":", "\n", "            ", "im", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "self", ".", "roidb", "[", "i", "]", "[", "'image'", "]", ")", ")", "\n", "fig", "=", "plt", ".", "figure", "(", "frameon", "=", "False", ")", "\n", "\n", "fig", ".", "set_size_inches", "(", "im", ".", "shape", "[", "1", "]", "/", "200", ",", "im", ".", "shape", "[", "0", "]", "/", "200", ")", "\n", "ax", "=", "plt", ".", "Axes", "(", "fig", ",", "[", "0.", ",", "0.", ",", "1.", ",", "1.", "]", ")", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "fig", ".", "add_axes", "(", "ax", ")", "\n", "ax", ".", "imshow", "(", "im", ")", "\n", "for", "j", ",", "name", "in", "enumerate", "(", "self", ".", "dataset", ".", "classes", ")", ":", "\n", "                ", "if", "name", "==", "'__background__'", ":", "\n", "                    ", "continue", "\n", "", "boxes", "=", "all_boxes", "[", "j", "]", "[", "i", "]", "\n", "segms", "=", "all_masks", "[", "j", "]", "[", "i", "]", "\n", "if", "segms", "==", "[", "]", ":", "\n", "                    ", "continue", "\n", "", "masks", "=", "mask_util", ".", "decode", "(", "segms", ")", "\n", "for", "k", "in", "range", "(", "boxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "score", "=", "boxes", "[", "k", ",", "-", "1", "]", "\n", "mask", "=", "masks", "[", ":", ",", ":", ",", "k", "]", "\n", "if", "score", "<", "0.5", ":", "\n", "                        ", "continue", "\n", "", "bbox", "=", "boxes", "[", "k", ",", ":", "]", "\n", "ax", ".", "add_patch", "(", "\n", "plt", ".", "Rectangle", "(", "(", "bbox", "[", "0", "]", ",", "bbox", "[", "1", "]", ")", ",", "bbox", "[", "2", "]", "-", "bbox", "[", "0", "]", ",", "bbox", "[", "3", "]", "-", "bbox", "[", "1", "]", ",", "\n", "fill", "=", "False", ",", "edgecolor", "=", "'g'", ",", "linewidth", "=", "1", ",", "alpha", "=", "0.5", ")", "\n", ")", "\n", "ax", ".", "text", "(", "bbox", "[", "0", "]", ",", "bbox", "[", "1", "]", "-", "2", ",", "name", "+", "'{:0.2f}'", ".", "format", "(", "score", ")", ".", "lstrip", "(", "'0'", ")", ",", "fontsize", "=", "5", ",", "family", "=", "'serif'", ",", "\n", "bbox", "=", "dict", "(", "facecolor", "=", "'g'", ",", "alpha", "=", "0.4", ",", "pad", "=", "0", ",", "edgecolor", "=", "'none'", ")", ",", "color", "=", "'white'", ")", "\n", "color_mask", "=", "color_list", "[", "mask_color_id", "%", "len", "(", "color_list", ")", ",", "0", ":", "3", "]", "\n", "mask_color_id", "+=", "1", "\n", "w_ratio", "=", ".4", "\n", "for", "c", "in", "range", "(", "3", ")", ":", "\n", "                        ", "color_mask", "[", "c", "]", "=", "color_mask", "[", "c", "]", "*", "(", "1", "-", "w_ratio", ")", "+", "w_ratio", "\n", "\n", "", "_", ",", "contour", ",", "hier", "=", "cv2", ".", "findContours", "(", "mask", ".", "copy", "(", ")", ",", "cv2", ".", "RETR_CCOMP", ",", "cv2", ".", "CHAIN_APPROX_NONE", ")", "\n", "for", "c", "in", "contour", ":", "\n", "                        ", "ax", ".", "add_patch", "(", "\n", "Polygon", "(", "\n", "c", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", ",", "\n", "fill", "=", "True", ",", "facecolor", "=", "color_mask", ",", "edgecolor", "=", "'w'", ",", "linewidth", "=", "0.8", ",", "alpha", "=", "0.5", "\n", ")", "\n", ")", "\n", "", "", "", "if", "save_path", "is", "None", ":", "\n", "                ", "plt", ".", "show", "(", ")", "\n", "", "else", ":", "\n", "                ", "fig", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "'{}.png'", ".", "format", "(", "self", ".", "roidb", "[", "i", "]", "[", "'image'", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ")", ")", ",", "dpi", "=", "200", ")", "\n", "", "plt", ".", "close", "(", "'all'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.im_list_to_blob": [[898, 924], ["numpy.array().max", "len", "numpy.zeros", "range", "float", "int", "int", "numpy.array", "int", "int", "cv2.resize().transpose", "numpy.ceil", "numpy.ceil", "cv2.resize", "ims[].transpose"], "methods", ["None"], ["", "", "def", "im_list_to_blob", "(", "self", ",", "ims", ",", "scale", "=", "1", ")", ":", "\n", "        ", "\"\"\"Convert a list of images into a network input. Assumes images were\n        prepared using prep_im_for_blob or equivalent: i.e.\n          - BGR channel order\n          - pixel means subtracted\n          - resized to the desired input size\n          - float32 numpy ndarray format\n        Output is a 4D HCHW tensor of the images concatenated along axis 0 with\n        shape.\n        \"\"\"", "\n", "max_shape", "=", "np", ".", "array", "(", "[", "im", ".", "shape", "for", "im", "in", "ims", "]", ")", ".", "max", "(", "axis", "=", "0", ")", "\n", "# Pad the image so they can be divisible by a stride", "\n", "if", "config", ".", "network", ".", "has_fpn", ":", "\n", "            ", "stride", "=", "float", "(", "config", ".", "network", ".", "rpn_feat_stride", "[", "-", "2", "]", ")", "\n", "max_shape", "[", "1", "]", "=", "int", "(", "np", ".", "ceil", "(", "max_shape", "[", "1", "]", "/", "stride", ")", "*", "stride", ")", "\n", "max_shape", "[", "2", "]", "=", "int", "(", "np", ".", "ceil", "(", "max_shape", "[", "2", "]", "/", "stride", ")", "*", "stride", ")", "\n", "\n", "", "num_images", "=", "len", "(", "ims", ")", "\n", "blob", "=", "np", ".", "zeros", "(", "(", "num_images", ",", "3", ",", "int", "(", "max_shape", "[", "1", "]", "*", "scale", ")", ",", "int", "(", "max_shape", "[", "2", "]", "*", "scale", ")", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "im", "=", "ims", "[", "i", "]", "if", "scale", "==", "1", "else", "cv2", ".", "resize", "(", "ims", "[", "i", "]", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", ",", "None", ",", "None", ",", "fx", "=", "scale", ",", "fy", "=", "scale", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "blob", "[", "i", ",", ":", ",", "0", ":", "im", ".", "shape", "[", "1", "]", ",", "0", ":", "im", ".", "shape", "[", "2", "]", "]", "=", "im", "\n", "# Move channels (axis 3) to axis 1", "\n", "# Axis order will become: (batch elem, channel, height, width)", "\n", "", "return", "blob", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.gt_list_to_blob": [[925, 951], ["numpy.array().max", "range", "float", "int", "int", "numpy.ones", "numpy.array", "cv2.resize", "numpy.ceil", "numpy.ceil", "int", "int"], "methods", ["None"], ["", "def", "gt_list_to_blob", "(", "self", ",", "ims", ",", "scale", "=", "1", ")", ":", "\n", "        ", "\"\"\"Convert a list of images into a network input. Assumes images were\n        prepared using prep_im_for_blob or equivalent: i.e.\n          - resized to the desired input size\n          - int64 numpy ndarray format\n        Output is a 4D HCHW tensor of the images concatenated along axis 0 with\n        shape.\n        \"\"\"", "\n", "max_shape", "=", "np", ".", "array", "(", "[", "im", ".", "shape", "for", "im", "in", "ims", "]", ")", ".", "max", "(", "axis", "=", "0", ")", "\n", "# Pad the image so they can be divisible by a stride", "\n", "if", "config", ".", "network", ".", "has_fpn", ":", "\n", "            ", "stride", "=", "float", "(", "config", ".", "network", ".", "rpn_feat_stride", "[", "-", "2", "]", ")", "\n", "max_shape", "[", "1", "]", "=", "int", "(", "np", ".", "ceil", "(", "max_shape", "[", "1", "]", "/", "stride", ")", "*", "stride", ")", "\n", "max_shape", "[", "2", "]", "=", "int", "(", "np", ".", "ceil", "(", "max_shape", "[", "2", "]", "/", "stride", ")", "*", "stride", ")", "\n", "\n", "", "num_images", "=", "ims", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "blob", "=", "np", ".", "ones", "(", "(", "num_images", ",", "int", "(", "max_shape", "[", "1", "]", "*", "scale", ")", ",", "int", "(", "max_shape", "[", "2", "]", "*", "scale", ")", ")", ",", "\n", "dtype", "=", "np", ".", "int64", ")", "*", "255", "\n", "im", "=", "ims", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "new_im", "=", "im", "[", "i", "]", "if", "scale", "==", "1", "else", "cv2", ".", "resize", "(", "im", "[", "i", "]", ",", "None", ",", "None", ",", "fx", "=", "scale", ",", "fy", "=", "scale", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "blob", "[", "i", ",", "0", ":", "new_im", ".", "shape", "[", "0", "]", ",", "0", ":", "new_im", ".", "shape", "[", "1", "]", "]", "=", "new_im", "\n", "# Move channels (axis 3) to axis 1", "\n", "# Axis order will become: (batch elem, channel, height, width)", "\n", "\n", "", "return", "blob", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.collate": [[952, 989], ["isinstance", "zip", "isinstance", "base_dataset.BaseDataset.collate", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "isinstance", "blob.update", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "blob.update", "blob.update", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "blob.update", "blob.update", "b.unsqueeze", "base_dataset.BaseDataset.im_list_to_blob", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "len", "blob.update", "base_dataset.BaseDataset.im_list_to_blob", "base_dataset.BaseDataset.gt_list_to_blob", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "blob.update", "base_dataset.BaseDataset.gt_list_to_blob", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "blob.update", "base_dataset.BaseDataset.gt_list_to_blob", "numpy.vstack", "len", "blob.update", "blob.update", "blob.update", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.collate", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.im_list_to_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.im_list_to_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.gt_list_to_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.gt_list_to_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.dataset.base_dataset.BaseDataset.gt_list_to_blob", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update"], ["", "def", "collate", "(", "self", ",", "batch", ")", ":", "\n", "        ", "if", "isinstance", "(", "batch", "[", "0", "]", ",", "Sequence", ")", ":", "\n", "            ", "transposed", "=", "zip", "(", "*", "batch", ")", "\n", "return", "[", "self", ".", "collate", "(", "samples", ")", "for", "samples", "in", "transposed", "]", "\n", "", "elif", "isinstance", "(", "batch", "[", "0", "]", ",", "int", ")", ":", "\n", "            ", "return", "torch", ".", "LongTensor", "(", "batch", ")", "\n", "", "elif", "isinstance", "(", "batch", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "torch", ".", "cat", "(", "[", "b", ".", "unsqueeze", "(", "0", ")", "for", "b", "in", "batch", "]", ",", "0", ")", "\n", "", "elif", "batch", "[", "0", "]", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "blob", "=", "{", "}", "\n", "for", "key", "in", "batch", "[", "0", "]", ":", "\n", "            ", "if", "key", "==", "'data'", ":", "\n", "                ", "blob", ".", "update", "(", "{", "'data'", ":", "torch", ".", "from_numpy", "(", "self", ".", "im_list_to_blob", "(", "[", "b", "[", "'data'", "]", "for", "b", "in", "batch", "]", ")", ")", "}", ")", "\n", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "                    ", "blob", ".", "update", "(", "{", "'data_4x'", ":", "torch", ".", "from_numpy", "(", "self", ".", "im_list_to_blob", "(", "[", "b", "[", "'data'", "]", "for", "b", "in", "batch", "]", ",", "scale", "=", "1", "/", "4.", ")", ")", "}", ")", "\n", "", "", "elif", "key", "==", "'seg_gt'", ":", "\n", "                ", "blob", ".", "update", "(", "{", "'seg_gt'", ":", "torch", ".", "from_numpy", "(", "self", ".", "gt_list_to_blob", "(", "[", "b", "[", "'seg_gt'", "]", "[", "np", ".", "newaxis", ",", "...", "]", "for", "b", "in", "batch", "]", ")", ")", "}", ")", "\n", "if", "config", ".", "network", ".", "has_panoptic_head", ":", "\n", "                    ", "blob", ".", "update", "(", "{", "'seg_gt_4x'", ":", "torch", ".", "from_numpy", "(", "self", ".", "gt_list_to_blob", "(", "[", "b", "[", "'seg_gt'", "]", "[", "np", ".", "newaxis", ",", "...", "]", "for", "b", "in", "batch", "]", ",", "scale", "=", "1", "/", "4.", ")", ")", "}", ")", "\n", "", "", "elif", "key", "==", "'seg_roi_gt'", ":", "\n", "                ", "assert", "(", "len", "(", "batch", ")", "==", "1", ")", "\n", "blob", ".", "update", "(", "{", "'seg_roi_gt'", ":", "torch", ".", "from_numpy", "(", "batch", "[", "0", "]", "[", "'seg_roi_gt'", "]", ")", "}", ")", "\n", "", "elif", "key", "==", "'mask_gt'", ":", "\n", "                ", "blob", ".", "update", "(", "{", "'mask_gt'", ":", "torch", ".", "from_numpy", "(", "self", ".", "gt_list_to_blob", "(", "[", "b", "[", "'mask_gt'", "]", "for", "b", "in", "batch", "]", ",", "scale", "=", "1.", "/", "4", ")", ")", "}", ")", "\n", "", "elif", "key", "==", "'im_info'", ":", "\n", "                ", "blob", ".", "update", "(", "{", "'im_info'", ":", "np", ".", "vstack", "(", "[", "b", "[", "'im_info'", "]", "for", "b", "in", "batch", "]", ")", "}", ")", "\n", "", "elif", "key", "==", "'roidb'", ":", "\n", "                ", "assert", "len", "(", "batch", ")", "==", "1", "\n", "blob", ".", "update", "(", "{", "'roidb'", ":", "batch", "[", "0", "]", "[", "'roidb'", "]", "}", ")", "\n", "", "elif", "key", "==", "'id'", ":", "\n", "                ", "blob", ".", "update", "(", "{", "key", ":", "torch", ".", "cat", "(", "[", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "[", "b", "[", "key", "]", "]", ")", ")", "for", "b", "in", "batch", "]", ",", "0", ")", "}", ")", "\n", "", "elif", "key", "==", "'incidence_mat'", "or", "key", "==", "'msg_adj'", ":", "\n", "                ", "blob", ".", "update", "(", "{", "key", ":", "batch", "[", "0", "]", "[", "key", "]", "}", ")", "\n", "", "else", ":", "\n", "                ", "blob", ".", "update", "(", "{", "key", ":", "torch", ".", "cat", "(", "[", "torch", ".", "from_numpy", "(", "b", "[", "key", "]", ")", "for", "b", "in", "batch", "]", ",", "0", ")", "}", ")", "\n", "", "", "return", "blob", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.config.config.update_config": [[177, 199], ["open", "easydict.EasyDict", "easydict.EasyDict.items", "yaml.load", "isinstance", "v.items", "numpy.array", "numpy.array"], "function", ["None"], ["def", "update_config", "(", "config_file", ")", ":", "\n", "    ", "exp_config", "=", "None", "\n", "with", "open", "(", "config_file", ")", "as", "f", ":", "\n", "        ", "exp_config", "=", "edict", "(", "yaml", ".", "load", "(", "f", ")", ")", "\n", "for", "k", ",", "v", "in", "exp_config", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "in", "config", ":", "\n", "                ", "if", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "                    ", "if", "k", "==", "'train'", ":", "\n", "                        ", "if", "'bbox_weights'", "in", "v", ":", "\n", "                            ", "v", "[", "'bbox_weights'", "]", "=", "np", ".", "array", "(", "v", "[", "'bbox_weights'", "]", ")", "\n", "", "", "elif", "k", "==", "'network'", ":", "\n", "                        ", "if", "'pixel_means'", "in", "v", ":", "\n", "                            ", "v", "[", "'pixel_means'", "]", "=", "np", ".", "array", "(", "v", "[", "'pixel_means'", "]", ")", "\n", "", "", "for", "vk", ",", "vv", "in", "v", ".", "items", "(", ")", ":", "\n", "                        ", "config", "[", "k", "]", "[", "vk", "]", "=", "vv", "\n", "", "", "else", ":", "\n", "                    ", "config", "[", "k", "]", "=", "v", "\n", "", "", "else", ":", "\n", "                ", "config", "[", "k", "]", "=", "v", "\n", "", "", "", "if", "config", ".", "debug_mode", ":", "\n", "        ", "config", ".", "train", ".", "use_horovod", "=", "False", "\n", "config", ".", "gpus", "=", "'0'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.config.parse_args.parse_args": [[19, 33], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_known_args", "config.update_config", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.config.config.update_config", "home.repos.pwc.inspect_result.uber-research_UPSNet.config.parse_args.parse_args"], ["def", "parse_args", "(", "description", "=", "''", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "description", ")", "\n", "# general", "\n", "parser", ".", "add_argument", "(", "'--cfg'", ",", "help", "=", "'experiment configure file name'", ",", "required", "=", "True", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_only'", ",", "help", "=", "'if only eval existing results'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--weight_path'", ",", "help", "=", "'manually specify model weights'", ",", "type", "=", "str", ",", "default", "=", "''", ")", "\n", "\n", "args", ",", "rest", "=", "parser", ".", "parse_known_args", "(", ")", "\n", "# update config", "\n", "update_config", "(", "args", ".", "cfg", ")", "\n", "\n", "# training", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskBranch.__init__": [[36, 66], ["torch.Module.__init__", "upsnet.operators.modules.fpn_roi_align.FPNRoIAlign", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "rcnn.MaskBranch.initialize", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "conv", "norm", "torch.ReLU", "torch.ReLU", "torch.ReLU", "conv", "norm", "torch.ReLU", "torch.ReLU", "torch.ReLU", "conv", "norm", "torch.ReLU", "torch.ReLU", "torch.ReLU", "conv", "norm", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "conv", "torch.ReLU", "torch.ReLU", "torch.ReLU", "conv", "torch.ReLU", "torch.ReLU", "torch.ReLU", "conv", "torch.ReLU", "torch.ReLU", "torch.ReLU", "conv", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.initialize"], ["    ", "def", "__init__", "(", "self", ",", "num_classes", ",", "dim_in", "=", "256", ",", "dim_hidden", "=", "256", ",", "with_norm", "=", "'none'", ")", ":", "\n", "        ", "super", "(", "MaskBranch", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "roi_pooling", "=", "FPNRoIAlign", "(", "config", ".", "network", ".", "mask_size", "//", "2", ",", "config", ".", "network", ".", "mask_size", "//", "2", ",", "\n", "[", "1.0", "/", "4", ",", "1.0", "/", "8", ",", "1.0", "/", "16", ",", "1.0", "/", "32", "]", ")", "\n", "conv", "=", "nn", ".", "Conv2d", "\n", "\n", "assert", "with_norm", "in", "[", "'batch_norm'", ",", "'group_norm'", ",", "'none'", "]", "\n", "\n", "if", "with_norm", "==", "'batch_norm'", ":", "\n", "            ", "norm", "=", "BatchNorm2d", "\n", "", "elif", "with_norm", "==", "'group_norm'", ":", "\n", "            ", "def", "group_norm", "(", "num_channels", ")", ":", "\n", "                ", "return", "nn", ".", "GroupNorm", "(", "32", ",", "num_channels", ")", "\n", "", "norm", "=", "group_norm", "\n", "\n", "", "if", "with_norm", "!=", "'none'", ":", "\n", "            ", "self", ".", "mask_conv1", "=", "nn", ".", "Sequential", "(", "*", "[", "conv", "(", "dim_in", ",", "dim_hidden", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "dim_hidden", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "mask_conv2", "=", "nn", ".", "Sequential", "(", "*", "[", "conv", "(", "dim_hidden", ",", "dim_hidden", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "dim_hidden", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "mask_conv3", "=", "nn", ".", "Sequential", "(", "*", "[", "conv", "(", "dim_hidden", ",", "dim_hidden", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "dim_hidden", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "mask_conv4", "=", "nn", ".", "Sequential", "(", "*", "[", "conv", "(", "dim_hidden", ",", "dim_hidden", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "dim_hidden", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "mask_deconv1", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "ConvTranspose2d", "(", "dim_hidden", ",", "dim_hidden", ",", "2", ",", "2", ",", "0", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "mask_conv1", "=", "nn", ".", "Sequential", "(", "*", "[", "conv", "(", "dim_in", ",", "dim_hidden", ",", "3", ",", "1", ",", "1", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "mask_conv2", "=", "nn", ".", "Sequential", "(", "*", "[", "conv", "(", "dim_hidden", ",", "dim_hidden", ",", "3", ",", "1", ",", "1", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "mask_conv3", "=", "nn", ".", "Sequential", "(", "*", "[", "conv", "(", "dim_hidden", ",", "dim_hidden", ",", "3", ",", "1", ",", "1", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "mask_conv4", "=", "nn", ".", "Sequential", "(", "*", "[", "conv", "(", "dim_hidden", ",", "dim_hidden", ",", "3", ",", "1", ",", "1", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "mask_deconv1", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "ConvTranspose2d", "(", "dim_hidden", ",", "dim_hidden", ",", "2", ",", "2", ",", "0", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "\n", "", "self", ".", "mask_score", "=", "nn", ".", "Conv2d", "(", "dim_hidden", ",", "num_classes", ",", "1", ")", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskBranch.initialize": [[67, 77], ["rcnn.MaskBranch.modules", "isinstance", "isinstance", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.normal_", "torch.init.normal_", "torch.init.normal_", "m.bias.data.zero_", "m.bias.data.zero_"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ".", "data", ",", "mode", "=", "'fan_in'", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "nn", ".", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "0", ",", "0.01", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskBranch.forward": [[79, 88], ["rcnn.MaskBranch.roi_pooling", "rcnn.MaskBranch.mask_conv1", "rcnn.MaskBranch.mask_conv2", "rcnn.MaskBranch.mask_conv3", "rcnn.MaskBranch.mask_conv4", "rcnn.MaskBranch.mask_deconv1", "rcnn.MaskBranch.mask_score"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "feat", ",", "rois", ")", ":", "\n", "        ", "pool_feat", "=", "self", ".", "roi_pooling", "(", "feat", ",", "rois", ")", "\n", "mask_conv1", "=", "self", ".", "mask_conv1", "(", "pool_feat", ")", "\n", "mask_conv2", "=", "self", ".", "mask_conv2", "(", "mask_conv1", ")", "\n", "mask_conv3", "=", "self", ".", "mask_conv3", "(", "mask_conv2", ")", "\n", "mask_conv4", "=", "self", ".", "mask_conv4", "(", "mask_conv3", ")", "\n", "mask_deconv1", "=", "self", ".", "mask_deconv1", "(", "mask_conv4", ")", "\n", "mask_score", "=", "self", ".", "mask_score", "(", "mask_deconv1", ")", "\n", "return", "mask_score", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.RCNN.__init__": [[91, 116], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "rcnn.RCNN.initialize", "upsnet.operators.modules.fpn_roi_align.FPNRoIAlign", "upsnet.operators.modules.roialign.RoIAlign", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.Linear", "torch.Linear", "torch.Linear", "upsnet.operators.modules.view.View", "norm", "upsnet.operators.modules.view.View", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.initialize"], ["    ", "def", "__init__", "(", "self", ",", "num_classes", ",", "num_reg_classes", ",", "pool_size", "=", "7", ",", "dim_in", "=", "256", ",", "dim_hidden", "=", "1024", ",", "with_fpn_pooling", "=", "True", ",", "with_dpooling", "=", "False", ",", "with_adaptive_pooling", "=", "False", ",", "with_heavier_head", "=", "False", ",", "with_norm", "=", "'none'", ")", ":", "\n", "        ", "super", "(", "RCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_fpn_pooling", "=", "with_fpn_pooling", "\n", "if", "self", ".", "with_fpn_pooling", ":", "\n", "            ", "self", ".", "roi_pooling", "=", "FPNRoIAlign", "(", "pool_size", ",", "pool_size", ",", "[", "1.0", "/", "4", ",", "1.0", "/", "8", ",", "1.0", "/", "16", ",", "1.0", "/", "32", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "roi_pooling", "=", "RoIAlign", "(", "pool_size", ",", "pool_size", ",", "[", "1.0", "/", "16", "]", ")", "\n", "\n", "", "assert", "with_norm", "in", "[", "'batch_norm'", ",", "'group_norm'", ",", "'none'", "]", "\n", "if", "with_norm", "==", "'batch_norm'", ":", "\n", "            ", "norm", "=", "BatchNorm2d", "\n", "", "elif", "with_norm", "==", "'group_norm'", ":", "\n", "            ", "def", "group_norm", "(", "num_channels", ")", ":", "\n", "                ", "return", "nn", ".", "GroupNorm", "(", "32", ",", "num_channels", ")", "\n", "", "norm", "=", "group_norm", "\n", "\n", "", "if", "with_norm", "!=", "'none'", ":", "\n", "            ", "self", ".", "fc6", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Linear", "(", "(", "pool_size", "**", "2", ")", "*", "dim_in", ",", "dim_hidden", ")", ",", "View", "(", "-", "1", ",", "dim_hidden", ",", "1", ",", "1", ")", ",", "norm", "(", "dim_hidden", ")", ",", "View", "(", "-", "1", ",", "dim_hidden", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "fc7", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Linear", "(", "dim_hidden", ",", "dim_hidden", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fc6", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Linear", "(", "(", "pool_size", "**", "2", ")", "*", "dim_in", ",", "dim_hidden", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "self", ".", "fc7", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Linear", "(", "dim_hidden", ",", "dim_hidden", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "", "self", ".", "cls_score", "=", "nn", ".", "Linear", "(", "dim_hidden", ",", "num_classes", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Linear", "(", "dim_hidden", ",", "num_reg_classes", "*", "4", ")", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.RCNN.initialize": [[117, 131], ["rcnn.RCNN.modules", "torch.init.normal_", "torch.init.normal_", "torch.init.normal_", "rcnn.RCNN.cls_score.bias.data.fill_", "torch.init.normal_", "torch.init.normal_", "torch.init.normal_", "rcnn.RCNN.bbox_pred.bias.data.fill_", "isinstance", "torch.init.kaiming_uniform_", "torch.init.kaiming_uniform_", "torch.init.kaiming_uniform_", "isinstance", "m.bias.data.fill_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "m.bias.data.fill_"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ".", "data", ",", "a", "=", "1", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ".", "data", ",", "mode", "=", "'fan_out'", ")", "\n", "", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "cls_score", ".", "weight", ".", "data", ",", "0", ",", "0.01", ")", "\n", "self", ".", "cls_score", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "bbox_pred", ".", "weight", ".", "data", ",", "0", ",", "0.001", ")", "\n", "self", ".", "bbox_pred", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.RCNN.forward": [[132, 146], ["rcnn.RCNN.roi_pooling", "rcnn.RCNN.view", "rcnn.RCNN.fc6", "rcnn.RCNN.fc7", "rcnn.RCNN.cls_score", "rcnn.RCNN.bbox_pred", "rcnn.RCNN.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feat", ",", "rois", ")", ":", "\n", "        ", "pool_feat", "=", "self", ".", "roi_pooling", "(", "feat", ",", "rois", ")", "\n", "\n", "rcnn_feat", "=", "pool_feat", ".", "view", "(", "pool_feat", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "fc6", "=", "self", ".", "fc6", "(", "rcnn_feat", ")", "\n", "fc7", "=", "self", ".", "fc7", "(", "fc6", ")", "\n", "fc_feat", "=", "fc7", "\n", "\n", "cls_score", "=", "self", ".", "cls_score", "(", "fc_feat", ")", "\n", "bbox_pred", "=", "self", ".", "bbox_pred", "(", "fc_feat", ")", "\n", "return", "{", "\n", "'cls_score'", ":", "cls_score", ",", "\n", "'bbox_pred'", ":", "bbox_pred", ",", "\n", "'fc_feat'", ":", "fc_feat", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.RCNNLoss.__init__": [[149, 153], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SmoothL1Loss", "torch.SmoothL1Loss", "torch.SmoothL1Loss"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "RCNNLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cls_loss", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "-", "1", ")", "\n", "self", ".", "bbox_loss", "=", "nn", ".", "SmoothL1Loss", "(", "reduction", "=", "'sum'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.RCNNLoss.forward": [[154, 158], ["rcnn.RCNNLoss.cls_loss", "rcnn.RCNNLoss.bbox_loss"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "cls_score", ",", "bbox_pred", ",", "cls_label", ",", "bbox_target", ",", "bbox_weight", ")", ":", "\n", "        ", "cls_loss", "=", "self", ".", "cls_loss", "(", "cls_score", ",", "cls_label", ")", "\n", "bbox_loss", "=", "self", ".", "bbox_loss", "(", "bbox_pred", "*", "bbox_weight", ",", "bbox_target", "*", "bbox_weight", ")", "\n", "return", "cls_loss", ",", "bbox_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskRCNNLoss.__init__": [[160, 164], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "super", "(", "MaskRCNNLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cls_loss", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "-", "1", ")", "\n", "self", ".", "bbox_loss", "=", "self", ".", "smooth_l1_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskRCNNLoss.rcnn_accuracy": [[165, 172], ["torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "correct.float", "total.float", "cls_label.view", "cls_pred.view"], "methods", ["None"], ["", "def", "rcnn_accuracy", "(", "self", ",", "cls_score", ",", "cls_label", ")", ":", "\n", "        ", "_", ",", "cls_pred", "=", "torch", ".", "max", "(", "cls_score", ".", "data", ",", "1", ",", "keepdim", "=", "True", ")", "\n", "ignore", "=", "(", "cls_label", "==", "-", "1", ")", ".", "long", "(", ")", ".", "sum", "(", ")", "\n", "correct", "=", "(", "cls_pred", ".", "view", "(", "-", "1", ")", "==", "cls_label", ".", "data", ")", ".", "long", "(", ")", ".", "sum", "(", ")", "-", "ignore", "\n", "total", "=", "(", "cls_label", ".", "view", "(", "-", "1", ")", ".", "shape", "[", "0", "]", ")", "-", "ignore", "\n", "\n", "return", "correct", ".", "float", "(", ")", "/", "total", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskRCNNLoss.mask_loss": [[173, 178], ["loss.sum", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "def", "mask_loss", "(", "self", ",", "input", ",", "target", ",", "weight", ")", ":", "\n", "        ", "binary_input", "=", "(", "input", ">=", "0", ")", ".", "float", "(", ")", "\n", "loss", "=", "-", "input", "*", "(", "target", "-", "binary_input", ")", "+", "torch", ".", "log", "(", "1", "+", "torch", ".", "exp", "(", "input", "-", "2", "*", "input", "*", "binary_input", ")", ")", "\n", "loss", "=", "loss", "*", "weight", "\n", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskRCNNLoss.smooth_l1_loss": [[179, 188], ["torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "loss_box.sum", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["None"], ["", "def", "smooth_l1_loss", "(", "self", ",", "bbox_pred", ",", "bbox_targets", ",", "bbox_inside_weights", ",", "bbox_outside_weights", ",", "sigma", "=", "1.0", ")", ":", "\n", "        ", "sigma_2", "=", "sigma", "**", "2", "\n", "box_diff", "=", "bbox_pred", "-", "bbox_targets", "\n", "in_box_diff", "=", "bbox_inside_weights", "*", "box_diff", "\n", "abs_in_box_diff", "=", "torch", ".", "abs", "(", "in_box_diff", ")", "\n", "smoothL1_sign", "=", "(", "abs_in_box_diff", "<", "1.", "/", "sigma_2", ")", ".", "detach", "(", ")", ".", "float", "(", ")", "\n", "loss_box", "=", "(", "torch", ".", "pow", "(", "in_box_diff", ",", "2", ")", "*", "(", "sigma_2", "/", "2.", ")", "*", "smoothL1_sign", "\n", "+", "(", "abs_in_box_diff", "-", "(", "0.5", "/", "sigma_2", ")", ")", "*", "(", "1.", "-", "smoothL1_sign", ")", ")", "*", "bbox_outside_weights", "\n", "return", "loss_box", ".", "sum", "(", ")", "/", "loss_box", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskRCNNLoss.forward": [[189, 198], ["rcnn.MaskRCNNLoss.cls_loss", "rcnn.MaskRCNNLoss.bbox_loss", "rcnn.MaskRCNNLoss.rcnn_accuracy", "mask_target.view.view.view", "cls_score.detach", "rcnn.MaskRCNNLoss.mask_loss", "mask_weight.float", "mask_weight.float().sum", "mask_weight.float"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskRCNNLoss.rcnn_accuracy", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rcnn.MaskRCNNLoss.mask_loss"], ["", "def", "forward", "(", "self", ",", "cls_score", ",", "bbox_pred", ",", "mask_score", ",", "cls_label", ",", "bbox_target", ",", "bbox_inside_weight", ",", "bbox_outside_weight", ",", "mask_target", ")", ":", "\n", "        ", "cls_loss", "=", "self", ".", "cls_loss", "(", "cls_score", ",", "cls_label", ")", "\n", "bbox_loss", "=", "self", ".", "bbox_loss", "(", "bbox_pred", ",", "bbox_target", ",", "bbox_inside_weight", ",", "bbox_outside_weight", ")", "\n", "rcnn_acc", "=", "self", ".", "rcnn_accuracy", "(", "cls_score", ".", "detach", "(", ")", ",", "cls_label", ")", "\n", "mask_target", "=", "mask_target", ".", "view", "(", "mask_target", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", "\n", "mask_weight", "=", "mask_target", "!=", "-", "1", "\n", "mask_loss", "=", "self", ".", "mask_loss", "(", "mask_score", ",", "mask_target", ",", "mask_weight", ".", "float", "(", ")", ")", "/", "(", "mask_weight", ".", "float", "(", ")", ".", "sum", "(", ")", "+", "1e-10", ")", "\n", "\n", "return", "cls_loss", ",", "bbox_loss", ",", "mask_loss", ",", "rcnn_acc", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rpn.RPN.__init__": [[27, 44], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "rpn.RPN.initialize", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "norm", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.initialize"], ["    ", "def", "__init__", "(", "self", ",", "num_anchors", "=", "15", ",", "input_dim", "=", "256", ",", "with_norm", "=", "'none'", ")", ":", "\n", "        ", "super", "(", "RPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_anchors", "=", "num_anchors", "\n", "if", "with_norm", "==", "'batch_norm'", ":", "\n", "            ", "norm", "=", "BatchNorm2d", "\n", "", "elif", "with_norm", "==", "'group_norm'", ":", "\n", "            ", "def", "group_norm", "(", "num_channels", ")", ":", "\n", "                ", "return", "nn", ".", "GroupNorm", "(", "32", ",", "num_channels", ")", "\n", "", "norm", "=", "group_norm", "\n", "\n", "", "if", "with_norm", "!=", "'none'", ":", "\n", "            ", "self", ".", "conv_proposal", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "input_dim", ",", "input_dim", ",", "3", ",", "padding", "=", "1", ")", ",", "norm", "(", "input_dim", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv_proposal", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "input_dim", ",", "input_dim", ",", "3", ",", "padding", "=", "1", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", ")", "\n", "", "self", ".", "cls_score", "=", "nn", ".", "Conv2d", "(", "input_dim", ",", "self", ".", "num_anchors", ",", "1", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "input_dim", ",", "self", ".", "num_anchors", "*", "4", ",", "1", ")", "\n", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rpn.RPN.initialize": [[45, 51], ["isinstance", "torch.init.normal_", "torch.init.normal_", "torch.init.normal_", "m.bias.data.zero_"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "[", "self", ".", "conv_proposal", "[", "0", "]", ",", "self", ".", "cls_score", ",", "self", ".", "bbox_pred", "]", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "0", ",", "0.01", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rpn.RPN.forward": [[52, 58], ["rpn.RPN.conv_proposal", "rpn.RPN.cls_score", "rpn.RPN.bbox_pred", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv_proposal", "(", "data", ")", "\n", "cls_score", "=", "self", ".", "cls_score", "(", "x", ")", "\n", "bbox_pred", "=", "self", ".", "bbox_pred", "(", "x", ")", "\n", "cls_prob", "=", "F", ".", "sigmoid", "(", "cls_score", ")", "\n", "return", "cls_score", ",", "bbox_pred", ",", "cls_prob", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rpn.RPNLoss.__init__": [[62, 68], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "rpn_batch_size", ",", "with_fpn", "=", "True", ")", ":", "\n", "        ", "super", "(", "RPNLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "rpn_cls_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "\n", "self", ".", "rpn_bbox_loss", "=", "self", ".", "smooth_l1_loss", "\n", "self", ".", "rpn_batch_size", "=", "rpn_batch_size", "\n", "self", ".", "with_fpn", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rpn.RPNLoss.smooth_l1_loss": [[69, 78], ["torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "loss_box.sum", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["None"], ["", "def", "smooth_l1_loss", "(", "self", ",", "bbox_pred", ",", "bbox_targets", ",", "bbox_inside_weights", ",", "bbox_outside_weights", ",", "sigma", "=", "3.0", ")", ":", "\n", "        ", "sigma_2", "=", "sigma", "**", "2", "\n", "box_diff", "=", "bbox_pred", "-", "bbox_targets", "\n", "in_box_diff", "=", "bbox_inside_weights", "*", "box_diff", "\n", "abs_in_box_diff", "=", "torch", ".", "abs", "(", "in_box_diff", ")", "\n", "smoothL1_sign", "=", "(", "abs_in_box_diff", "<", "1.", "/", "sigma_2", ")", ".", "detach", "(", ")", ".", "type", "(", "bbox_pred", ".", "dtype", ")", "\n", "loss_box", "=", "(", "torch", ".", "pow", "(", "in_box_diff", ",", "2", ")", "*", "(", "sigma_2", "/", "2.", ")", "*", "smoothL1_sign", "\n", "+", "(", "abs_in_box_diff", "-", "(", "0.5", "/", "sigma_2", ")", ")", "*", "(", "1.", "-", "smoothL1_sign", ")", ")", "*", "bbox_outside_weights", "\n", "return", "loss_box", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.rpn.RPNLoss.forward": [[79, 102], ["zip", "rpn_cls_loss.append", "rpn_bbox_loss.append", "functools.reduce", "functools.reduce", "rpn.RPNLoss.rpn_cls_loss", "rpn.RPNLoss.rpn_bbox_loss", "rpn_labels.type", "bbox_targets.type", "bbox_inside_weights.type", "bbox_outside_weights.tyep", "rpn.RPNLoss.rpn_cls_loss", "rpn.RPNLoss.rpn_bbox_loss", "cls_score.size", "cls_score.size", "bbox_pred.size", "bbox_pred.size", "bbox_pred.size", "bbox_pred.size", "bbox_pred.size", "bbox_pred.size", "cls_score.size", "cls_score.size", "bbox_pred.size", "bbox_pred.size", "bbox_pred.size", "bbox_pred.size", "bbox_pred.size", "bbox_pred.size", "rpn_labels.type", "bbox_targets.type", "bbox_inside_weights.type", "bbox_outside_weights.type"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "rpn_cls_score", ",", "rpn_bbox_pred", ",", "label", ")", ":", "\n", "\n", "        ", "if", "self", ".", "with_fpn", ":", "\n", "            ", "rpn_cls_loss", ",", "rpn_bbox_loss", "=", "[", "]", ",", "[", "]", "\n", "for", "cls_score", ",", "bbox_pred", ",", "stride", "in", "zip", "(", "rpn_cls_score", ",", "rpn_bbox_pred", ",", "[", "4", ",", "8", ",", "16", ",", "32", ",", "64", "]", ")", ":", "\n", "                ", "rpn_labels", "=", "label", "[", "'rpn_labels_fpn{}'", ".", "format", "(", "stride", ")", "]", "[", ":", ",", ":", ",", ":", "cls_score", ".", "size", "(", "2", ")", ",", ":", "cls_score", ".", "size", "(", "3", ")", "]", "\n", "bbox_targets", "=", "label", "[", "'rpn_bbox_targets_fpn{}'", ".", "format", "(", "stride", ")", "]", "[", ":", ",", ":", ",", ":", "bbox_pred", ".", "size", "(", "2", ")", ",", ":", "bbox_pred", ".", "size", "(", "3", ")", "]", "\n", "bbox_inside_weights", "=", "label", "[", "'rpn_bbox_inside_weights_fpn{}'", ".", "format", "(", "stride", ")", "]", "[", ":", ",", ":", ",", ":", "bbox_pred", ".", "size", "(", "2", ")", ",", ":", "bbox_pred", ".", "size", "(", "3", ")", "]", "\n", "bbox_outside_weights", "=", "label", "[", "'rpn_bbox_outside_weights_fpn{}'", ".", "format", "(", "stride", ")", "]", "[", ":", ",", ":", ",", ":", "bbox_pred", ".", "size", "(", "2", ")", ",", ":", "bbox_pred", ".", "size", "(", "3", ")", "]", "\n", "\n", "rpn_cls_loss", ".", "append", "(", "self", ".", "rpn_cls_loss", "(", "cls_score", ",", "rpn_labels", ".", "type", "(", "cls_score", ".", "dtype", ")", ",", "(", "rpn_labels", "!=", "-", "1", ")", ".", "type", "(", "cls_score", ".", "dtype", ")", ",", "reduction", "=", "'sum'", ")", "/", "self", ".", "rpn_batch_size", ")", "\n", "rpn_bbox_loss", ".", "append", "(", "self", ".", "rpn_bbox_loss", "(", "bbox_pred", ",", "bbox_targets", ".", "type", "(", "bbox_pred", ".", "dtype", ")", ",", "bbox_inside_weights", ".", "type", "(", "bbox_pred", ".", "dtype", ")", ",", "bbox_outside_weights", ".", "type", "(", "bbox_pred", ".", "dtype", ")", ")", "/", "bbox_pred", ".", "shape", "[", "0", "]", ")", "\n", "", "rpn_cls_loss_sum", ",", "rpn_bbox_loss_sum", "=", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ",", "rpn_cls_loss", ")", ",", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ",", "rpn_bbox_loss", ")", "\n", "return", "rpn_cls_loss_sum", ",", "rpn_bbox_loss_sum", "\n", "\n", "", "else", ":", "\n", "            ", "rpn_labels", "=", "label", "[", "'rpn_labels'", "]", "[", ":", ",", ":", ",", ":", "cls_score", ".", "size", "(", "2", ")", ",", ":", "cls_score", ".", "size", "(", "3", ")", "]", "\n", "bbox_targets", "=", "label", "[", "'rpn_bbox_targets'", "]", "[", ":", ",", ":", ",", ":", "bbox_pred", ".", "size", "(", "2", ")", ",", ":", "bbox_pred", ".", "size", "(", "3", ")", "]", "\n", "bbox_inside_weights", "=", "label", "[", "'rpn_bbox_inside_weights'", "]", "[", ":", ",", ":", ",", ":", "bbox_pred", ".", "size", "(", "2", ")", ",", ":", "bbox_pred", ".", "size", "(", "3", ")", "]", "\n", "bbox_outside_weights", "=", "label", "[", "'rpn_bbox_outside_weights'", "]", "[", ":", ",", ":", ",", ":", "bbox_pred", ".", "size", "(", "2", ")", ",", ":", "bbox_pred", ".", "size", "(", "3", ")", "]", "\n", "rpn_cls_loss", "=", "self", ".", "rpn_cls_loss", "(", "rpn_cls_score", ",", "rpn_labels", ".", "type", "(", "rpn_cls_score", ".", "dtype", ")", ",", "(", "rpn_labels", "!=", "-", "1", ")", ".", "type", "(", "rpn_cls_score", ".", "dtype", ")", ",", "reduction", "=", "'sum'", ")", "/", "self", ".", "rpn_batch_size", "\n", "rpn_bbox_loss", "=", "self", ".", "rpn_bbox_loss", "(", "rpn_bbox_pred", ",", "bbox_targets", ".", "type", "(", "rpn_bbox_pred", ".", "dtype", ")", ",", "bbox_inside_weights", ".", "type", "(", "rpn_bbox_pred", ".", "dtype", ")", ",", "bbox_outside_weights", ".", "tyep", "(", "rpn_bbox_pred", ".", "dtype", ")", ")", "/", "rpn_bbox_pred", ".", "shape", "[", "0", "]", "\n", "return", "rpn_cls_loss", ",", "rpn_bbox_loss", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fpn.FPN.__init__": [[27, 70], ["torch.Module.__init__", "fpn.FPN.initialize", "torch.interpolate", "torch.interpolate", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.GroupNorm", "torch.GroupNorm", "torch.Conv2d", "torch.Conv2d", "norm", "torch.Conv2d", "torch.Conv2d", "norm", "torch.Conv2d", "torch.Conv2d", "norm", "torch.Conv2d", "torch.Conv2d", "norm", "torch.Conv2d", "torch.Conv2d", "norm", "torch.Conv2d", "torch.Conv2d", "norm", "torch.Conv2d", "torch.Conv2d", "norm", "torch.Conv2d", "torch.Conv2d", "norm"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.initialize"], ["    ", "def", "__init__", "(", "self", ",", "feature_dim", ",", "with_extra_level", "=", "True", ",", "with_bottom_up_path_aggregation", "=", "False", ",", "with_norm", "=", "'none'", ",", "upsample_method", "=", "'nearest'", ")", ":", "\n", "        ", "super", "(", "FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "feature_dim", "=", "feature_dim", "\n", "self", ".", "with_bottom_up_path_aggregation", "=", "with_bottom_up_path_aggregation", "\n", "assert", "upsample_method", "in", "[", "'nearest'", ",", "'bilinear'", "]", "\n", "\n", "def", "interpolate", "(", "input", ")", ":", "\n", "            ", "return", "F", ".", "interpolate", "(", "input", ",", "scale_factor", "=", "2", ",", "mode", "=", "upsample_method", ",", "align_corners", "=", "False", "if", "upsample_method", "==", "'bilinear'", "else", "None", ")", "\n", "", "self", ".", "fpn_upsample", "=", "interpolate", "\n", "\n", "assert", "with_norm", "in", "[", "'group_norm'", ",", "'batch_norm'", ",", "'none'", "]", "\n", "if", "with_extra_level", ":", "\n", "            ", "self", ".", "fpn_p6", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "1", ",", "stride", "=", "2", ")", "\n", "", "if", "config", ".", "network", ".", "fpn_with_gap", ":", "\n", "            ", "self", ".", "fpn_gap", "=", "nn", ".", "Linear", "(", "2048", ",", "feature_dim", ")", "\n", "\n", "", "if", "with_norm", "==", "'batch_norm'", ":", "\n", "            ", "norm", "=", "BatchNorm2d", "\n", "", "elif", "with_norm", "==", "'group_norm'", ":", "\n", "            ", "def", "group_norm", "(", "num_channels", ")", ":", "\n", "                ", "return", "nn", ".", "GroupNorm", "(", "32", ",", "num_channels", ")", "\n", "", "norm", "=", "group_norm", "\n", "\n", "", "if", "with_norm", "!=", "'none'", ":", "\n", "            ", "self", ".", "fpn_p5_1x1", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "2048", ",", "feature_dim", ",", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "feature_dim", ")", "]", ")", "\n", "self", ".", "fpn_p4_1x1", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "1024", ",", "feature_dim", ",", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "feature_dim", ")", "]", ")", "\n", "self", ".", "fpn_p3_1x1", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "512", ",", "feature_dim", ",", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "feature_dim", ")", "]", ")", "\n", "self", ".", "fpn_p2_1x1", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "256", ",", "feature_dim", ",", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "feature_dim", ")", "]", ")", "\n", "self", ".", "fpn_p5", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "feature_dim", ",", "feature_dim", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "feature_dim", ")", "]", ")", "\n", "self", ".", "fpn_p4", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "feature_dim", ",", "feature_dim", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "feature_dim", ")", "]", ")", "\n", "self", ".", "fpn_p3", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "feature_dim", ",", "feature_dim", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "feature_dim", ")", "]", ")", "\n", "self", ".", "fpn_p2", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Conv2d", "(", "feature_dim", ",", "feature_dim", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "norm", "(", "feature_dim", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fpn_p5_1x1", "=", "nn", ".", "Conv2d", "(", "2048", ",", "feature_dim", ",", "1", ")", "\n", "self", ".", "fpn_p4_1x1", "=", "nn", ".", "Conv2d", "(", "1024", ",", "feature_dim", ",", "1", ")", "\n", "self", ".", "fpn_p3_1x1", "=", "nn", ".", "Conv2d", "(", "512", ",", "feature_dim", ",", "1", ")", "\n", "self", ".", "fpn_p2_1x1", "=", "nn", ".", "Conv2d", "(", "256", ",", "feature_dim", ",", "1", ")", "\n", "self", ".", "fpn_p5", "=", "nn", ".", "Conv2d", "(", "feature_dim", ",", "feature_dim", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "fpn_p4", "=", "nn", ".", "Conv2d", "(", "feature_dim", ",", "feature_dim", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "fpn_p3", "=", "nn", ".", "Conv2d", "(", "feature_dim", ",", "feature_dim", ",", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "fpn_p2", "=", "nn", ".", "Conv2d", "(", "feature_dim", ",", "feature_dim", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n", "", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fpn.FPN.initialize": [[71, 77], ["fpn.FPN.modules", "isinstance", "torch.init.kaiming_uniform_", "torch.init.kaiming_uniform_", "m.bias.data.zero_"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ".", "data", ",", "a", "=", "1", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fpn.FPN.forward": [[78, 105], ["fpn.FPN.fpn_p5_1x1", "fpn.FPN.fpn_p4_1x1", "fpn.FPN.fpn_p3_1x1", "fpn.FPN.fpn_p2_1x1", "fpn.FPN.fpn_upsample", "fpn.FPN.fpn_upsample", "fpn.FPN.fpn_upsample", "fpn.FPN.fpn_p5", "fpn.FPN.fpn_p4", "fpn.FPN.fpn_p3", "fpn.FPN.fpn_p2", "hasattr", "fpn.FPN.fpn_gap().view", "fpn.FPN.fpn_p6", "fpn.FPN.fpn_gap", "torch.adaptive_avg_pool2d().squeeze", "torch.adaptive_avg_pool2d().squeeze", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "res2", ",", "res3", ",", "res4", ",", "res5", ")", ":", "\n", "        ", "fpn_p5_1x1", "=", "self", ".", "fpn_p5_1x1", "(", "res5", ")", "\n", "fpn_p4_1x1", "=", "self", ".", "fpn_p4_1x1", "(", "res4", ")", "\n", "fpn_p3_1x1", "=", "self", ".", "fpn_p3_1x1", "(", "res3", ")", "\n", "fpn_p2_1x1", "=", "self", ".", "fpn_p2_1x1", "(", "res2", ")", "\n", "\n", "if", "config", ".", "network", ".", "fpn_with_gap", ":", "\n", "            ", "fpn_gap", "=", "self", ".", "fpn_gap", "(", "F", ".", "adaptive_avg_pool2d", "(", "res5", ",", "(", "1", ",", "1", ")", ")", ".", "squeeze", "(", ")", ")", ".", "view", "(", "-", "1", ",", "self", ".", "feature_dim", ",", "1", ",", "1", ")", "\n", "fpn_p5_1x1", "=", "fpn_p5_1x1", "+", "fpn_gap", "\n", "\n", "", "fpn_p5_upsample", "=", "self", ".", "fpn_upsample", "(", "fpn_p5_1x1", ")", "\n", "fpn_p4_plus", "=", "fpn_p5_upsample", "+", "fpn_p4_1x1", "\n", "fpn_p4_upsample", "=", "self", ".", "fpn_upsample", "(", "fpn_p4_plus", ")", "\n", "fpn_p3_plus", "=", "fpn_p4_upsample", "+", "fpn_p3_1x1", "\n", "fpn_p3_upsample", "=", "self", ".", "fpn_upsample", "(", "fpn_p3_plus", ")", "\n", "fpn_p2_plus", "=", "fpn_p3_upsample", "+", "fpn_p2_1x1", "\n", "\n", "fpn_p5", "=", "self", ".", "fpn_p5", "(", "fpn_p5_1x1", ")", "\n", "fpn_p4", "=", "self", ".", "fpn_p4", "(", "fpn_p4_plus", ")", "\n", "fpn_p3", "=", "self", ".", "fpn_p3", "(", "fpn_p3_plus", ")", "\n", "fpn_p2", "=", "self", ".", "fpn_p2", "(", "fpn_p2_plus", ")", "\n", "\n", "if", "hasattr", "(", "self", ",", "'fpn_p6'", ")", ":", "\n", "            ", "fpn_p6", "=", "self", ".", "fpn_p6", "(", "fpn_p5", ")", "\n", "return", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", ",", "fpn_p6", "\n", "", "else", ":", "\n", "            ", "return", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.__init__": [[40, 84], ["upsnet.models.resnet.resnet_rcnn.__init__", "upsnet.models.resnet.ResNetBackbone", "upsnet.models.fpn.FPN", "upsnet.models.rpn.RPN", "upsnet.models.rcnn.RCNN", "upsnet.models.rcnn.MaskBranch", "upsnet.operators.modules.mask_roi.MaskROI", "upsnet.operators.modules.mask_roi.MaskROI", "upsnet.operators.modules.mask_removal.MaskRemoval", "upsnet.operators.modules.unary_logits.SegTerm", "upsnet.operators.modules.unary_logits.MaskTerm", "upsnet.operators.modules.mask_matching.MaskMatching", "upsnet.models.rpn.RPNLoss", "upsnet.models.rcnn.MaskRCNNLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "resnet_upsnet.resnet_upsnet.initialize", "eval", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.initialize"], ["    ", "def", "__init__", "(", "self", ",", "backbone_depth", ")", ":", "\n", "        ", "super", "(", "resnet_upsnet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_classes", "=", "config", ".", "dataset", ".", "num_classes", "\n", "self", ".", "num_seg_classes", "=", "config", ".", "dataset", ".", "num_seg_classes", "\n", "self", ".", "num_reg_classes", "=", "(", "2", "if", "config", ".", "network", ".", "cls_agnostic_bbox_reg", "else", "config", ".", "dataset", ".", "num_classes", ")", "\n", "\n", "# backbone net", "\n", "self", ".", "resnet_backbone", "=", "ResNetBackbone", "(", "backbone_depth", ")", "\n", "# FPN, RPN, Instance Head and Semantic Head", "\n", "self", ".", "fpn", "=", "FPN", "(", "feature_dim", "=", "config", ".", "network", ".", "fpn_feature_dim", ",", "with_norm", "=", "config", ".", "network", ".", "fpn_with_norm", ",", "\n", "upsample_method", "=", "config", ".", "network", ".", "fpn_upsample_method", ")", "\n", "self", ".", "rpn", "=", "RPN", "(", "num_anchors", "=", "config", ".", "network", ".", "num_anchors", ",", "input_dim", "=", "config", ".", "network", ".", "fpn_feature_dim", ")", "\n", "self", ".", "rcnn", "=", "RCNN", "(", "self", ".", "num_classes", ",", "self", ".", "num_reg_classes", ",", "dim_in", "=", "config", ".", "network", ".", "fpn_feature_dim", ",", "\n", "with_norm", "=", "config", ".", "network", ".", "rcnn_with_norm", ")", "\n", "self", ".", "mask_branch", "=", "MaskBranch", "(", "self", ".", "num_classes", ",", "dim_in", "=", "config", ".", "network", ".", "fpn_feature_dim", ",", "\n", "with_norm", "=", "config", ".", "network", ".", "rcnn_with_norm", ")", "\n", "self", ".", "fcn_head", "=", "eval", "(", "config", ".", "network", ".", "fcn_head", ")", "(", "config", ".", "network", ".", "fpn_feature_dim", ",", "self", ".", "num_seg_classes", ",", "\n", "num_layers", "=", "config", ".", "network", ".", "fcn_num_layers", ",", "\n", "with_norm", "=", "config", ".", "network", ".", "fcn_with_norm", ",", "upsample_rate", "=", "4", ",", "\n", "with_roi_loss", "=", "config", ".", "train", ".", "fcn_with_roi_loss", ")", "\n", "self", ".", "mask_roi", "=", "MaskROI", "(", "clip_boxes", "=", "True", ",", "bbox_class_agnostic", "=", "False", ",", "top_n", "=", "config", ".", "test", ".", "max_det", ",", "\n", "num_classes", "=", "self", ".", "num_classes", ",", "score_thresh", "=", "config", ".", "test", ".", "score_thresh", ")", "\n", "\n", "# Panoptic Head", "\n", "# param for training", "\n", "self", ".", "box_keep_fraction", "=", "config", ".", "train", ".", "panoptic_box_keep_fraction", "\n", "self", ".", "enable_void", "=", "config", ".", "train", ".", "panoptic_box_keep_fraction", "<", "1", "\n", "\n", "self", ".", "mask_roi_panoptic", "=", "MaskROI", "(", "clip_boxes", "=", "True", ",", "bbox_class_agnostic", "=", "False", ",", "top_n", "=", "config", ".", "test", ".", "max_det", ",", "\n", "num_classes", "=", "self", ".", "num_classes", ",", "nms_thresh", "=", "0.5", ",", "class_agnostic", "=", "True", ",", "score_thresh", "=", "config", ".", "test", ".", "panoptic_score_thresh", ")", "\n", "self", ".", "mask_removal", "=", "MaskRemoval", "(", "fraction_threshold", "=", "0.3", ")", "\n", "self", ".", "seg_term", "=", "SegTerm", "(", "config", ".", "dataset", ".", "num_seg_classes", ")", "\n", "self", ".", "mask_term", "=", "MaskTerm", "(", "config", ".", "dataset", ".", "num_seg_classes", ",", "box_scale", "=", "1", "/", "4.0", ")", "\n", "self", ".", "mask_matching", "=", "MaskMatching", "(", "config", ".", "dataset", ".", "num_seg_classes", ",", "enable_void", "=", "self", ".", "enable_void", ")", "\n", "\n", "# # Loss layer", "\n", "self", ".", "rpn_loss", "=", "RPNLoss", "(", "config", ".", "train", ".", "rpn_batch_size", "*", "config", ".", "train", ".", "batch_size", ")", "\n", "self", ".", "mask_rcnn_loss", "=", "MaskRCNNLoss", "(", "config", ".", "train", ".", "batch_rois", "*", "config", ".", "train", ".", "batch_size", ")", "\n", "self", ".", "fcn_loss", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "255", ")", "\n", "self", ".", "panoptic_loss", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "255", ",", "reduce", "=", "False", ")", "\n", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "            ", "self", ".", "fcn_roi_loss", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "255", ",", "reduce", "=", "False", ")", "\n", "", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.initialize": [[85, 87], ["None"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.forward": [[88, 249], ["resnet_upsnet.resnet_upsnet.resnet_backbone", "resnet_upsnet.resnet_upsnet.fpn", "resnet_upsnet.resnet_upsnet.rpn", "rpn_cls_score.append", "rpn_cls_prob.append", "rpn_bbox_pred.append", "upsnet.operators.modules.pyramid_proposal.PyramidProposal", "upsnet.operators.modules.proposal_mask_target.ProposalMaskTarget", "resnet_upsnet.resnet_upsnet.pyramid_proposal", "resnet_upsnet.resnet_upsnet.proposal_target", "upsnet.operators.modules.pyramid_proposal.PyramidProposal", "resnet_upsnet.resnet_upsnet.pyramid_proposal", "resnet_upsnet.resnet_upsnet.get_gt_rois", "fcn_rois.to.to.to", "resnet_upsnet.resnet_upsnet.fcn_head", "resnet_upsnet.resnet_upsnet.fcn_head", "resnet_upsnet.resnet_upsnet.rpn_loss", "resnet_upsnet.resnet_upsnet.fcn_loss", "resnet_upsnet.resnet_upsnet.rcnn", "resnet_upsnet.resnet_upsnet.mask_branch", "resnet_upsnet.resnet_upsnet.mask_rcnn_loss", "resnet_upsnet.resnet_upsnet.get_gt_rois", "resnet_upsnet.resnet_upsnet.mask_branch", "mask_score.gather.gather.gather", "resnet_upsnet.resnet_upsnet.seg_term", "resnet_upsnet.resnet_upsnet.mask_term", "resnet_upsnet.resnet_upsnet.calc_panoptic_acc", "resnet_upsnet.resnet_upsnet.panoptic_loss", "panoptic_loss.mean.mean.mean", "resnet_upsnet.resnet_upsnet.rcnn", "torch.softmax", "torch.softmax", "torch.softmax", "resnet_upsnet.resnet_upsnet.mask_roi", "resnet_upsnet.resnet_upsnet.mask_branch", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "resnet_upsnet.resnet_upsnet.mask_roi_panoptic", "resnet_upsnet.resnet_upsnet.mask_branch", "mask_score.gather.gather.gather", "resnet_upsnet.resnet_upsnet.mask_removal", "resnet_upsnet.resnet_upsnet.seg_term", "results.update", "results.update", "resnet_upsnet.resnet_upsnet.fcn_roi_loss", "fcn_roi_loss.mean.mean.mean", "numpy.random.choice", "gt_rois.to", "cls_idx.to", "cls_idx.view().expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "rpn_cls_loss.unsqueeze", "rpn_bbox_loss.unsqueeze", "cls_loss.unsqueeze", "bbox_loss.unsqueeze", "mask_loss.unsqueeze", "resnet_upsnet.resnet_upsnet.unsqueeze", "panoptic_loss.mean.mean.unsqueeze", "rcnn_acc.unsqueeze", "resnet_upsnet.resnet_upsnet.unsqueeze", "output.update", "cls_idx.view().expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "max", "resnet_upsnet.resnet_upsnet.mask_matching", "resnet_upsnet.resnet_upsnet.mask_matching", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "int", "cls_idx.view", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "cls_idx.view", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.softmax", "torch.softmax", "torch.softmax"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.get_gt_rois", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.get_gt_rois", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.gather", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.calc_panoptic_acc", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.data_parallel.DataParallel.gather", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update"], ["", "def", "forward", "(", "self", ",", "data", ",", "label", "=", "None", ")", ":", "\n", "\n", "        ", "res2", ",", "res3", ",", "res4", ",", "res5", "=", "self", ".", "resnet_backbone", "(", "data", "[", "'data'", "]", ")", "\n", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", ",", "fpn_p6", "=", "self", ".", "fpn", "(", "res2", ",", "res3", ",", "res4", ",", "res5", ")", "\n", "\n", "rpn_cls_score", ",", "rpn_cls_prob", ",", "rpn_bbox_pred", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "feat", "in", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", ",", "fpn_p6", "]", ":", "\n", "            ", "rpn_cls_score_p", ",", "rpn_bbox_pred_p", ",", "rpn_cls_prob_p", "=", "self", ".", "rpn", "(", "feat", ")", "\n", "rpn_cls_score", ".", "append", "(", "rpn_cls_score_p", ")", "\n", "rpn_cls_prob", ".", "append", "(", "rpn_cls_prob_p", ")", "\n", "rpn_bbox_pred", ".", "append", "(", "rpn_bbox_pred_p", ")", "\n", "\n", "", "if", "label", "is", "not", "None", ":", "\n", "            ", "self", ".", "pyramid_proposal", "=", "PyramidProposal", "(", "feat_stride", "=", "config", ".", "network", ".", "rpn_feat_stride", ",", "scales", "=", "config", ".", "network", ".", "anchor_scales", ",", "\n", "ratios", "=", "config", ".", "network", ".", "anchor_ratios", ",", "rpn_pre_nms_top_n", "=", "config", ".", "train", ".", "rpn_pre_nms_top_n", ",", "\n", "rpn_post_nms_top_n", "=", "config", ".", "train", ".", "rpn_post_nms_top_n", ",", "threshold", "=", "config", ".", "train", ".", "rpn_nms_thresh", ",", "\n", "rpn_min_size", "=", "config", ".", "train", ".", "rpn_min_size", ",", "individual_proposals", "=", "config", ".", "train", ".", "rpn_individual_proposals", ")", "\n", "self", ".", "proposal_target", "=", "ProposalMaskTarget", "(", "num_classes", "=", "self", ".", "num_reg_classes", ",", "\n", "batch_images", "=", "config", ".", "train", ".", "batch_size", ",", "batch_rois", "=", "config", ".", "train", ".", "batch_rois", ",", "\n", "fg_fraction", "=", "config", ".", "train", ".", "fg_fraction", ",", "mask_size", "=", "config", ".", "network", ".", "mask_size", ",", "\n", "binary_thresh", "=", "config", ".", "network", ".", "binary_thresh", ")", "\n", "rois", ",", "_", "=", "self", ".", "pyramid_proposal", "(", "rpn_cls_prob", ",", "rpn_bbox_pred", ",", "data", "[", "'im_info'", "]", ")", "\n", "rois", ",", "cls_label", ",", "bbox_target", ",", "bbox_inside_weight", ",", "bbox_outside_weight", ",", "mask_rois", ",", "mask_target", ",", "roi_has_mask", ",", "nongt_inds", "=", "self", ".", "proposal_target", "(", "rois", ",", "label", "[", "'roidb'", "]", ",", "data", "[", "'im_info'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "pyramid_proposal", "=", "PyramidProposal", "(", "feat_stride", "=", "config", ".", "network", ".", "rpn_feat_stride", ",", "scales", "=", "config", ".", "network", ".", "anchor_scales", ",", "\n", "ratios", "=", "config", ".", "network", ".", "anchor_ratios", ",", "rpn_pre_nms_top_n", "=", "config", ".", "test", ".", "rpn_pre_nms_top_n", ",", "\n", "rpn_post_nms_top_n", "=", "config", ".", "test", ".", "rpn_post_nms_top_n", ",", "threshold", "=", "config", ".", "test", ".", "rpn_nms_thresh", ",", "\n", "rpn_min_size", "=", "config", ".", "test", ".", "rpn_min_size", ",", "individual_proposals", "=", "config", ".", "train", ".", "rpn_individual_proposals", ")", "\n", "rois", ",", "_", "=", "self", ".", "pyramid_proposal", "(", "rpn_cls_prob", ",", "rpn_bbox_pred", ",", "data", "[", "'im_info'", "]", ")", "\n", "\n", "", "if", "label", "is", "not", "None", "and", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "            ", "fcn_rois", ",", "_", "=", "self", ".", "get_gt_rois", "(", "label", "[", "'roidb'", "]", ",", "data", "[", "'im_info'", "]", ")", "\n", "fcn_rois", "=", "fcn_rois", ".", "to", "(", "rois", ".", "device", ")", "\n", "fcn_output", "=", "self", ".", "fcn_head", "(", "*", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", ",", "fcn_rois", "]", ")", "\n", "", "else", ":", "\n", "            ", "fcn_output", "=", "self", ".", "fcn_head", "(", "*", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "]", ")", "\n", "\n", "", "if", "label", "is", "not", "None", ":", "\n", "\n", "# RPN loss", "\n", "            ", "rpn_cls_loss", ",", "rpn_bbox_loss", "=", "self", ".", "rpn_loss", "(", "rpn_cls_score", ",", "rpn_bbox_pred", ",", "label", ")", "\n", "\n", "# Semantic head loss", "\n", "fcn_loss", "=", "self", ".", "fcn_loss", "(", "fcn_output", "[", "'fcn_output'", "]", ",", "label", "[", "'seg_gt'", "]", ")", "\n", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "                ", "fcn_roi_loss", "=", "self", ".", "fcn_roi_loss", "(", "fcn_output", "[", "'fcn_roi_score'", "]", ",", "label", "[", "'seg_roi_gt'", "]", ")", "\n", "fcn_roi_loss", "=", "fcn_roi_loss", ".", "mean", "(", ")", "\n", "\n", "# Instance head loss", "\n", "", "rcnn_output", "=", "self", ".", "rcnn", "(", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "]", ",", "rois", ")", "\n", "cls_score", ",", "bbox_pred", "=", "rcnn_output", "[", "'cls_score'", "]", ",", "rcnn_output", "[", "'bbox_pred'", "]", "\n", "mask_score", "=", "self", ".", "mask_branch", "(", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "]", ",", "mask_rois", ")", "\n", "cls_loss", ",", "bbox_loss", ",", "mask_loss", ",", "rcnn_acc", "=", "self", ".", "mask_rcnn_loss", "(", "cls_score", ",", "bbox_pred", ",", "mask_score", ",", "\n", "cls_label", ",", "bbox_target", ",", "bbox_inside_weight", ",", "bbox_outside_weight", ",", "mask_target", ")", "\n", "\n", "# Panoptic head", "\n", "\n", "# extract gt rois for panoptic head", "\n", "gt_rois", ",", "cls_idx", "=", "self", ".", "get_gt_rois", "(", "label", "[", "'roidb'", "]", ",", "data", "[", "'im_info'", "]", ")", "\n", "if", "self", ".", "enable_void", ":", "\n", "                ", "keep_inds", "=", "np", ".", "random", ".", "choice", "(", "gt_rois", ".", "shape", "[", "0", "]", ",", "max", "(", "int", "(", "gt_rois", ".", "shape", "[", "0", "]", "*", "self", ".", "box_keep_fraction", ")", ",", "1", ")", ",", "replace", "=", "False", ")", "\n", "gt_rois", "=", "gt_rois", "[", "keep_inds", "]", "\n", "cls_idx", "=", "cls_idx", "[", "keep_inds", "]", "\n", "", "gt_rois", ",", "cls_idx", "=", "gt_rois", ".", "to", "(", "rois", ".", "device", ")", ",", "cls_idx", ".", "to", "(", "rois", ".", "device", ")", "\n", "\n", "# Calc mask logits with gt rois", "\n", "mask_score", "=", "self", ".", "mask_branch", "(", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "]", ",", "gt_rois", ")", "\n", "mask_score", "=", "mask_score", ".", "gather", "(", "1", ",", "cls_idx", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ")", "\n", "\n", "# Calc panoptic logits", "\n", "seg_logits", ",", "seg_inst_logits", "=", "self", ".", "seg_term", "(", "cls_idx", ",", "fcn_output", "[", "'fcn_score'", "]", ",", "gt_rois", ")", "\n", "mask_logits", "=", "self", ".", "mask_term", "(", "mask_score", ",", "gt_rois", ",", "cls_idx", ",", "fcn_output", "[", "'fcn_score'", "]", ")", "\n", "\n", "if", "self", ".", "enable_void", ":", "\n", "                ", "void_logits", "=", "torch", ".", "max", "(", "fcn_output", "[", "'fcn_score'", "]", "[", ":", ",", "(", "config", ".", "dataset", ".", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", "+", "1", ")", ":", ",", "...", "]", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "-", "torch", ".", "max", "(", "seg_inst_logits", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "inst_logits", "=", "seg_inst_logits", "+", "mask_logits", "\n", "panoptic_logits", "=", "torch", ".", "cat", "(", "[", "seg_logits", ",", "inst_logits", ",", "void_logits", "]", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "panoptic_logits", "=", "torch", ".", "cat", "(", "[", "seg_logits", ",", "(", "seg_inst_logits", "+", "mask_logits", ")", "]", ",", "dim", "=", "1", ")", "\n", "\n", "# generate gt for panoptic head ", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "if", "self", ".", "enable_void", ":", "\n", "                    ", "panoptic_gt", "=", "self", ".", "mask_matching", "(", "label", "[", "'seg_gt_4x'", "]", ",", "label", "[", "'mask_gt'", "]", ",", "keep_inds", "=", "keep_inds", ")", "\n", "", "else", ":", "\n", "                    ", "panoptic_gt", "=", "self", ".", "mask_matching", "(", "label", "[", "'seg_gt_4x'", "]", ",", "label", "[", "'mask_gt'", "]", ")", "\n", "\n", "# Panoptic head loss", "\n", "", "", "panoptic_acc", "=", "self", ".", "calc_panoptic_acc", "(", "panoptic_logits", ",", "panoptic_gt", ")", "\n", "panoptic_loss", "=", "self", ".", "panoptic_loss", "(", "panoptic_logits", ",", "panoptic_gt", ")", "\n", "panoptic_loss", "=", "panoptic_loss", ".", "mean", "(", ")", "\n", "\n", "output", "=", "{", "\n", "'rpn_cls_loss'", ":", "rpn_cls_loss", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'rpn_bbox_loss'", ":", "rpn_bbox_loss", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'cls_loss'", ":", "cls_loss", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'bbox_loss'", ":", "bbox_loss", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'mask_loss'", ":", "mask_loss", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'fcn_loss'", ":", "fcn_loss", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'panoptic_loss'", ":", "panoptic_loss", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'rcnn_accuracy'", ":", "rcnn_acc", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'panoptic_accuracy'", ":", "panoptic_acc", ".", "unsqueeze", "(", "0", ")", ",", "\n", "}", "\n", "if", "config", ".", "train", ".", "fcn_with_roi_loss", ":", "\n", "                ", "output", ".", "update", "(", "{", "'fcn_roi_loss'", ":", "fcn_roi_loss", "}", ")", "\n", "\n", "", "return", "output", "\n", "\n", "", "else", ":", "\n", "\n", "\n", "            ", "rcnn_output", "=", "self", ".", "rcnn", "(", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "]", ",", "rois", ")", "\n", "cls_score", ",", "bbox_pred", "=", "rcnn_output", "[", "'cls_score'", "]", ",", "rcnn_output", "[", "'bbox_pred'", "]", "\n", "cls_prob", "=", "F", ".", "softmax", "(", "cls_score", ",", "dim", "=", "1", ")", "\n", "\n", "cls_prob_all", ",", "mask_rois", ",", "cls_idx", "=", "self", ".", "mask_roi", "(", "rois", ",", "bbox_pred", ",", "cls_prob", ",", "data", "[", "'im_info'", "]", ")", "\n", "mask_score", "=", "self", ".", "mask_branch", "(", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "]", ",", "mask_rois", ")", "\n", "mask_prob", "=", "torch", ".", "sigmoid", "(", "mask_score", ")", "\n", "\n", "# get mask rcnn output (optional)", "\n", "results", "=", "{", "\n", "'cls_probs'", ":", "cls_prob_all", ",", "\n", "'pred_boxes'", ":", "mask_rois", ",", "\n", "'mask_probs'", ":", "mask_prob", ",", "\n", "'fcn_outputs'", ":", "torch", ".", "max", "(", "fcn_output", "[", "'fcn_output'", "]", ",", "dim", "=", "1", ")", "[", "1", "]", ",", "\n", "'cls_inds'", ":", "cls_idx", "\n", "}", "\n", "\n", "# get mask_logits", "\n", "cls_prob", ",", "mask_rois", ",", "cls_idx", "=", "self", ".", "mask_roi_panoptic", "(", "rois", ",", "bbox_pred", ",", "cls_prob", ",", "data", "[", "'im_info'", "]", ")", "\n", "mask_score", "=", "self", ".", "mask_branch", "(", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "]", ",", "mask_rois", ")", "\n", "mask_score", "=", "mask_score", ".", "gather", "(", "1", ",", "cls_idx", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ")", ")", "\n", "\n", "# get panoptic logits", "\n", "keep_inds", ",", "mask_logits", "=", "self", ".", "mask_removal", "(", "mask_rois", "[", ":", ",", "1", ":", "]", ",", "cls_prob", ",", "mask_score", ",", "cls_idx", ",", "fcn_output", "[", "'fcn_output'", "]", ".", "shape", "[", "2", ":", "]", ")", "\n", "mask_rois", "=", "mask_rois", "[", "keep_inds", "]", "\n", "cls_idx", "=", "cls_idx", "[", "keep_inds", "]", "\n", "cls_prob", "=", "cls_prob", "[", "keep_inds", "]", "\n", "seg_logits", ",", "seg_inst_logits", "=", "self", ".", "seg_term", "(", "cls_idx", ",", "fcn_output", "[", "'fcn_output'", "]", ",", "mask_rois", "*", "4.0", ")", "\n", "\n", "results", ".", "update", "(", "{", "\n", "'panoptic_cls_inds'", ":", "cls_idx", ",", "\n", "'panoptic_cls_probs'", ":", "cls_prob", "\n", "}", ")", "\n", "\n", "if", "self", ".", "enable_void", ":", "\n", "                ", "void_logits", "=", "torch", ".", "max", "(", "fcn_output", "[", "'fcn_output'", "]", "[", ":", ",", "(", "config", ".", "dataset", ".", "num_seg_classes", "-", "config", ".", "dataset", ".", "num_classes", "+", "1", ")", ":", ",", "...", "]", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "-", "torch", ".", "max", "(", "seg_inst_logits", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "\n", "inst_logits", "=", "(", "seg_inst_logits", "+", "mask_logits", ")", "\n", "panoptic_logits", "=", "torch", ".", "cat", "(", "[", "seg_logits", ",", "inst_logits", ",", "void_logits", "]", ",", "dim", "=", "1", ")", "\n", "void_id", "=", "panoptic_logits", ".", "shape", "[", "1", "]", "-", "1", "\n", "panoptic_output", "=", "torch", ".", "max", "(", "panoptic_logits", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "panoptic_output", "[", "panoptic_output", "==", "void_id", "]", "=", "255", "\n", "", "else", ":", "\n", "                ", "panoptic_logits", "=", "torch", ".", "cat", "(", "[", "seg_logits", ",", "(", "seg_inst_logits", "+", "mask_logits", ")", "]", ",", "dim", "=", "1", ")", "\n", "panoptic_output", "=", "torch", ".", "max", "(", "F", ".", "softmax", "(", "panoptic_logits", ",", "dim", "=", "1", ")", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "\n", "", "results", ".", "update", "(", "{", "\n", "'panoptic_outputs'", ":", "panoptic_output", ",", "\n", "}", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.calc_panoptic_acc": [[250, 258], ["torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "correct.float", "total.float", "gt.view", "output_cls.view", "gt.data.view"], "methods", ["None"], ["", "", "def", "calc_panoptic_acc", "(", "self", ",", "panoptic_logits", ",", "gt", ")", ":", "\n", "        ", "_", ",", "output_cls", "=", "torch", ".", "max", "(", "panoptic_logits", ".", "data", ",", "1", ",", "keepdim", "=", "True", ")", "\n", "ignore", "=", "(", "gt", "==", "255", ")", ".", "long", "(", ")", ".", "sum", "(", ")", "\n", "correct", "=", "(", "output_cls", ".", "view", "(", "-", "1", ")", "==", "gt", ".", "data", ".", "view", "(", "-", "1", ")", ")", ".", "long", "(", ")", ".", "sum", "(", ")", "\n", "total", "=", "(", "gt", ".", "view", "(", "-", "1", ")", ".", "shape", "[", "0", "]", ")", "-", "ignore", "\n", "assert", "total", "!=", "0", "\n", "panoptic_acc", "=", "correct", ".", "float", "(", ")", "/", "total", ".", "float", "(", ")", "\n", "return", "panoptic_acc", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.get_params_lr": [[260, 286], ["resnet_upsnet.resnet_upsnet.named_modules", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "ret.append", "isinstance", "gn_params.append", "gn_params.append", "gn_params_name.append", "gn_params_name.append", "isinstance", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params", "upsnet.models.resnet.get_params"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params"], ["", "def", "get_params_lr", "(", "self", ")", ":", "\n", "        ", "ret", "=", "[", "]", "\n", "gn_params", "=", "[", "]", "\n", "gn_params_name", "=", "[", "]", "\n", "for", "n", ",", "m", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "GroupNorm", ")", "or", "(", "config", ".", "train", ".", "use_horovod", "and", "config", ".", "network", ".", "use_syncbn", "and", "isinstance", "(", "m", ",", "BatchNorm2d", ")", ")", ":", "\n", "                ", "gn_params", ".", "append", "(", "m", ".", "weight", ")", "\n", "gn_params", ".", "append", "(", "m", ".", "bias", ")", "\n", "gn_params_name", ".", "append", "(", "n", "+", "'.weight'", ")", "\n", "gn_params_name", ".", "append", "(", "n", "+", "'.bias'", ")", "\n", "\n", "", "", "ret", ".", "append", "(", "{", "'params'", ":", "gn_params", ",", "'lr'", ":", "1", ",", "'weight_decay'", ":", "0", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'resnet_backbone.res3'", ",", "'resnet_backbone.res4'", ",", "'resnet_backbone.res5'", "]", ",", "[", "'weight'", "]", ")", "]", ",", "'lr'", ":", "1", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'resnet_backbone.res3'", ",", "'resnet_backbone.res4'", ",", "'resnet_backbone.res5'", "]", ",", "[", "'bias'", "]", ")", "]", ",", "'lr'", ":", "2", ",", "'weight_decay'", ":", "0", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'fpn'", "]", ",", "[", "'weight'", "]", ",", "exclude", "=", "gn_params_name", ")", "]", ",", "'lr'", ":", "1", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'fpn'", "]", ",", "[", "'bias'", "]", ",", "exclude", "=", "gn_params_name", ")", "]", ",", "'lr'", ":", "2", ",", "'weight_decay'", ":", "0", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'rcnn'", "]", ",", "[", "'weight'", "]", ",", "exclude", "=", "gn_params_name", ")", "]", ",", "'lr'", ":", "1", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'rcnn'", "]", ",", "[", "'bias'", "]", ",", "exclude", "=", "gn_params_name", ")", "]", ",", "'lr'", ":", "2", ",", "'weight_decay'", ":", "0", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'mask_branch'", "]", ",", "[", "'weight'", "]", ",", "exclude", "=", "gn_params_name", ")", "]", ",", "'lr'", ":", "1", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'mask_branch'", "]", ",", "[", "'bias'", "]", ",", "exclude", "=", "gn_params_name", ")", "]", ",", "'lr'", ":", "2", ",", "'weight_decay'", ":", "0", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'rpn'", "]", ",", "[", "'weight'", "]", ")", "]", ",", "'lr'", ":", "1", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'rpn'", "]", ",", "[", "'bias'", "]", ")", "]", ",", "'lr'", ":", "2", ",", "'weight_decay'", ":", "0", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'fcn_head'", "]", ",", "[", "'weight'", "]", ",", "exclude", "=", "gn_params_name", ")", "]", ",", "'lr'", ":", "1", "}", ")", "\n", "ret", ".", "append", "(", "{", "'params'", ":", "[", "_", "for", "_", "in", "get_params", "(", "self", ",", "[", "'fcn_head'", "]", ",", "[", "'bias'", "]", ",", "exclude", "=", "gn_params_name", ")", "]", ",", "'lr'", ":", "2", ",", "'weight_decay'", ":", "0", "}", ")", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_upsnet.get_gt_rois": [[287, 292], ["numpy.where", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "numpy.hstack", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.zeros"], "methods", ["None"], ["", "def", "get_gt_rois", "(", "self", ",", "roidb", ",", "im_info", ")", ":", "\n", "        ", "gt_inds", "=", "np", ".", "where", "(", "(", "roidb", "[", "'gt_classes'", "]", ">", "0", ")", "&", "(", "roidb", "[", "'is_crowd'", "]", "==", "0", ")", ")", "[", "0", "]", "\n", "rois", "=", "roidb", "[", "'boxes'", "]", "[", "gt_inds", "]", "*", "im_info", "[", "0", ",", "2", "]", "\n", "cls_idx", "=", "roidb", "[", "'gt_classes'", "]", "[", "gt_inds", "]", "\n", "return", "torch", ".", "from_numpy", "(", "np", ".", "hstack", "(", "(", "np", ".", "zeros", "(", "(", "rois", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "rois", ")", ")", ")", ",", "torch", ".", "from_numpy", "(", "cls_idx", ")", ".", "long", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_101_upsnet": [[293, 295], ["resnet_upsnet.resnet_upsnet"], "function", ["None"], ["", "", "def", "resnet_101_upsnet", "(", ")", ":", "\n", "    ", "return", "resnet_upsnet", "(", "[", "3", ",", "4", ",", "23", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet_upsnet.resnet_50_upsnet": [[296, 298], ["resnet_upsnet.resnet_upsnet"], "function", ["None"], ["", "def", "resnet_50_upsnet", "(", ")", ":", "\n", "    ", "return", "resnet_upsnet", "(", "[", "3", ",", "4", ",", "6", ",", "3", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNSubNet.__init__": [[31, 59], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "fcn.FCNSubNet.initialize", "conv.append", "fcn.FCNSubNet.conv.append", "conv.append", "conv.append", "conv.append", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "upsnet.operators.modules.deform_conv.DeformConvWithOffset", "upsnet.operators.modules.deform_conv.DeformConvWithOffset", "norm"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.initialize"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "num_layers", ",", "deformable_group", "=", "1", ",", "dilation", "=", "1", ",", "with_norm", "=", "'none'", ")", ":", "\n", "        ", "super", "(", "FCNSubNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "with_norm", "in", "[", "'none'", ",", "'batch_norm'", ",", "'group_norm'", "]", "\n", "assert", "num_layers", ">=", "2", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "if", "with_norm", "==", "'batch_norm'", ":", "\n", "            ", "norm", "=", "BatchNorm2d", "\n", "", "elif", "with_norm", "==", "'group_norm'", ":", "\n", "            ", "def", "group_norm", "(", "in_channel", ")", ":", "\n", "                ", "return", "nn", ".", "GroupNorm", "(", "32", ",", "in_channel", ")", "\n", "", "norm", "=", "group_norm", "\n", "", "else", ":", "\n", "            ", "norm", "=", "None", "\n", "", "self", ".", "conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "num_layers", ")", ":", "\n", "            ", "conv", "=", "[", "]", "\n", "if", "i", "==", "num_layers", "-", "2", ":", "\n", "                ", "conv", ".", "append", "(", "DeformConvWithOffset", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ")", ")", "\n", "in_channels", "=", "out_channels", "\n", "", "else", ":", "\n", "                ", "conv", ".", "append", "(", "DeformConvWithOffset", "(", "in_channels", ",", "in_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ")", ")", "\n", "", "if", "with_norm", "!=", "'none'", ":", "\n", "                ", "conv", ".", "append", "(", "norm", "(", "in_channels", ")", ")", "\n", "", "conv", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "self", ".", "conv", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "conv", ")", ")", "\n", "\n", "", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNSubNet.initialize": [[60, 69], ["fcn.FCNSubNet.modules", "isinstance", "m.weight.data.fill_", "m.bias.data.fill_", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "m.bias.data.fill_"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "0", ")", "\n", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "DeformConv", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ".", "data", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNSubNet.forward": [[70, 74], ["range"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "x", "=", "self", ".", "conv", "[", "i", "]", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.__init__": [[78, 87], ["torch.Module.__init__", "fcn.FCNSubNet", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "fcn.FCNHead.initialize", "upsnet.operators.modules.roialign.RoIAlign"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.initialize"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "num_classes", ",", "num_layers", ",", "with_norm", "=", "'none'", ",", "with_roi_loss", "=", "False", ",", "upsample_rate", "=", "4", ")", ":", "\n", "        ", "super", "(", "FCNHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fcn_subnet", "=", "FCNSubNet", "(", "in_channels", ",", "128", ",", "num_layers", ",", "with_norm", "=", "with_norm", ")", "\n", "self", ".", "upsample_rate", "=", "upsample_rate", "\n", "\n", "self", ".", "score", "=", "nn", ".", "Conv2d", "(", "512", ",", "num_classes", ",", "1", ")", "\n", "if", "with_roi_loss", ":", "\n", "            ", "self", ".", "roipool", "=", "RoIAlign", "(", "config", ".", "network", ".", "mask_size", ",", "config", ".", "network", ".", "mask_size", ",", "1", "/", "4.0", ")", "\n", "", "self", ".", "initialize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.forward": [[88, 109], ["fcn.FCNHead.fcn_subnet", "fcn.FCNHead.fcn_subnet", "fcn.FCNHead.fcn_subnet", "fcn.FCNHead.fcn_subnet", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "fcn.FCNHead.score", "torch.interpolate", "torch.interpolate", "torch.interpolate", "ret.update", "fcn.FCNHead.roipool", "fcn.FCNHead.score", "ret.update"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update", "home.repos.pwc.inspect_result.uber-research_UPSNet.utils.metric.IoUMetric.update"], ["", "def", "forward", "(", "self", ",", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", ",", "roi", "=", "None", ")", ":", "\n", "        ", "fpn_p2", "=", "self", ".", "fcn_subnet", "(", "fpn_p2", ")", "\n", "fpn_p3", "=", "self", ".", "fcn_subnet", "(", "fpn_p3", ")", "\n", "fpn_p4", "=", "self", ".", "fcn_subnet", "(", "fpn_p4", ")", "\n", "fpn_p5", "=", "self", ".", "fcn_subnet", "(", "fpn_p5", ")", "\n", "\n", "fpn_p3", "=", "F", ".", "interpolate", "(", "fpn_p3", ",", "None", ",", "2", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "fpn_p4", "=", "F", ".", "interpolate", "(", "fpn_p4", ",", "None", ",", "4", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "fpn_p5", "=", "F", ".", "interpolate", "(", "fpn_p5", ",", "None", ",", "8", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "feat", "=", "torch", ".", "cat", "(", "[", "fpn_p2", ",", "fpn_p3", ",", "fpn_p4", ",", "fpn_p5", "]", ",", "dim", "=", "1", ")", "\n", "score", "=", "self", ".", "score", "(", "feat", ")", "\n", "ret", "=", "{", "'fcn_score'", ":", "score", ",", "'fcn_feat'", ":", "feat", "}", "\n", "if", "self", ".", "upsample_rate", "!=", "1", ":", "\n", "            ", "output", "=", "F", ".", "interpolate", "(", "score", ",", "None", ",", "self", ".", "upsample_rate", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "ret", ".", "update", "(", "{", "'fcn_output'", ":", "output", "}", ")", "\n", "", "if", "roi", "is", "not", "None", ":", "\n", "            ", "roi_feat", "=", "self", ".", "roipool", "(", "feat", ",", "roi", ")", "\n", "roi_score", "=", "self", ".", "score", "(", "roi_feat", ")", "\n", "ret", ".", "update", "(", "{", "'fcn_roi_score'", ":", "roi_score", "}", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.FCNHead.initialize": [[111, 114], ["torch.init.normal_", "torch.init.normal_", "torch.init.normal_", "fcn.FCNHead.score.bias.data.zero_"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "nn", ".", "init", ".", "normal_", "(", "self", ".", "score", ".", "weight", ".", "data", ",", "0", ",", "0.01", ")", "\n", "self", ".", "score", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.CrossEntropyLoss2d.__init__": [[118, 122], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "size_average", "=", "True", ",", "ignore_label", "=", "255", ")", ":", "\n", "        ", "super", "(", "CrossEntropyLoss2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "size_average", "=", "size_average", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.fcn.CrossEntropyLoss2d.forward": [[123, 141], ["predict.size", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "predict.dim", "target.dim", "predict.size", "target.size", "predict.size", "target.size", "predict.size", "target.size", "predict.size", "target.size", "predict.size", "target.size", "predict.size", "target.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "predict", ",", "target", ",", "weight", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n            Args:\n                predict:(n, c, h, w)\n                target:(n, h, w)\n                weight (Tensor, optional): a manual rescaling weight given to each class.\n                                           If given, has to be a Tensor of size \"nclasses\"\n        \"\"\"", "\n", "assert", "not", "target", ".", "requires_grad", "\n", "assert", "predict", ".", "dim", "(", ")", "==", "4", "\n", "assert", "target", ".", "dim", "(", ")", "==", "3", "\n", "assert", "predict", ".", "size", "(", "0", ")", "==", "target", ".", "size", "(", "0", ")", ",", "\"{0} vs {1} \"", ".", "format", "(", "predict", ".", "size", "(", "0", ")", ",", "target", ".", "size", "(", "0", ")", ")", "\n", "assert", "predict", ".", "size", "(", "2", ")", "==", "target", ".", "size", "(", "1", ")", ",", "\"{0} vs {1} \"", ".", "format", "(", "predict", ".", "size", "(", "2", ")", ",", "target", ".", "size", "(", "1", ")", ")", "\n", "assert", "predict", ".", "size", "(", "3", ")", "==", "target", ".", "size", "(", "2", ")", ",", "\"{0} vs {1} \"", ".", "format", "(", "predict", ".", "size", "(", "3", ")", ",", "target", ".", "size", "(", "2", ")", ")", "\n", "n", ",", "c", ",", "h", ",", "w", "=", "predict", ".", "size", "(", ")", "\n", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "predict", ",", "target", ",", "weight", "=", "weight", ",", "size_average", "=", "self", ".", "size_average", ",", "ignore_index", "=", "self", ".", "ignore_label", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.Bottleneck.__init__": [[56, 79], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "resnet.Bottleneck.bn1.eval", "resnet.Bottleneck.bn2.eval", "resnet.Bottleneck.bn3.eval", "resnet.Bottleneck.bn1.parameters", "resnet.Bottleneck.bn2.parameters", "resnet.Bottleneck.bn3.parameters"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "dilation", "=", "1", ",", "downsample", "=", "None", ",", "fix_bn", "=", "True", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "\n", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "4", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "if", "fix_bn", ":", "\n", "            ", "self", ".", "bn1", ".", "eval", "(", ")", "\n", "self", ".", "bn2", ".", "eval", "(", ")", "\n", "self", ".", "bn3", ".", "eval", "(", ")", "\n", "for", "i", "in", "self", ".", "bn1", ".", "parameters", "(", ")", ":", "\n", "                ", "i", ".", "requires_grad", "=", "False", "\n", "", "for", "i", "in", "self", ".", "bn2", ".", "parameters", "(", ")", ":", "\n", "                ", "i", ".", "requires_grad", "=", "False", "\n", "", "for", "i", "in", "self", ".", "bn3", ".", "parameters", "(", ")", ":", "\n", "                ", "i", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.Bottleneck.forward": [[80, 101], ["resnet.Bottleneck.conv1", "resnet.Bottleneck.bn1", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv2", "resnet.Bottleneck.bn2", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv3", "resnet.Bottleneck.bn3", "resnet.Bottleneck.relu", "resnet.Bottleneck.downsample"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.DCNBottleneck.__init__": [[105, 131], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "resnet.DCNBottleneck.conv2_offset.weight.data.zero_", "resnet.DCNBottleneck.conv2_offset.bias.data.zero_", "upsnet.operators.modules.deform_conv.DeformConv", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "resnet.DCNBottleneck.bn1.eval", "resnet.DCNBottleneck.bn2.eval", "resnet.DCNBottleneck.bn3.eval", "resnet.DCNBottleneck.bn1.parameters", "resnet.DCNBottleneck.bn2.parameters", "resnet.DCNBottleneck.bn3.parameters"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "dilation", "=", "1", ",", "downsample", "=", "None", ",", "fix_bn", "=", "True", ",", "deformable_group", "=", "1", ")", ":", "\n", "        ", "super", "(", "DCNBottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "conv2_offset", "=", "nn", ".", "Conv2d", "(", "planes", ",", "18", "*", "deformable_group", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "dilation", "=", "1", ")", "\n", "self", ".", "conv2_offset", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv2_offset", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv2", "=", "DeformConv", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "\n", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "4", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "if", "fix_bn", ":", "\n", "            ", "self", ".", "bn1", ".", "eval", "(", ")", "\n", "self", ".", "bn2", ".", "eval", "(", ")", "\n", "self", ".", "bn3", ".", "eval", "(", ")", "\n", "for", "i", "in", "self", ".", "bn1", ".", "parameters", "(", ")", ":", "\n", "                ", "i", ".", "requires_grad", "=", "False", "\n", "", "for", "i", "in", "self", ".", "bn2", ".", "parameters", "(", ")", ":", "\n", "                ", "i", ".", "requires_grad", "=", "False", "\n", "", "for", "i", "in", "self", ".", "bn3", ".", "parameters", "(", ")", ":", "\n", "                ", "i", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.DCNBottleneck.forward": [[132, 154], ["resnet.DCNBottleneck.conv1", "resnet.DCNBottleneck.bn1", "resnet.DCNBottleneck.relu", "resnet.DCNBottleneck.conv2_offset", "resnet.DCNBottleneck.conv2", "resnet.DCNBottleneck.bn2", "resnet.DCNBottleneck.relu", "resnet.DCNBottleneck.conv3", "resnet.DCNBottleneck.bn3", "resnet.DCNBottleneck.relu", "resnet.DCNBottleneck.downsample"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "offset", "=", "self", ".", "conv2_offset", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ",", "offset", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.conv1.__init__": [[156, 169], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "resnet.conv1.eval", "resnet.conv1.parameters"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "requires_grad", "=", "False", ")", ":", "\n", "        ", "super", "(", "conv1", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inplanes", "=", "64", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "if", "not", "requires_grad", ":", "\n", "            ", "self", ".", "eval", "(", ")", "\n", "for", "i", "in", "self", ".", "parameters", "(", ")", ":", "\n", "                ", "i", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.conv1.forward": [[170, 176], ["resnet.conv1.conv1", "resnet.conv1.bn1", "resnet.conv1.relu", "resnet.conv1.maxpool"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.res_block.__init__": [[178, 204], ["torch.Module.__init__", "layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "layers.append", "layers.append", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "downsample[].eval", "downsample[].parameters", "block", "resnet.DCNBottleneck", "block"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "planes", ",", "blocks", ",", "block", "=", "Bottleneck", ",", "stride", "=", "1", ",", "dilation", "=", "1", ",", "fix_bn", "=", "True", ",", "with_dpyramid", "=", "False", ")", ":", "\n", "        ", "super", "(", "res_block", ",", "self", ")", ".", "__init__", "(", ")", "\n", "downsample", "=", "None", "\n", "self", ".", "inplanes", "=", "planes", "*", "2", "if", "planes", "!=", "64", "else", "planes", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "if", "fix_bn", ":", "\n", "                ", "downsample", "[", "1", "]", ".", "eval", "(", ")", "\n", "for", "i", "in", "downsample", "[", "1", "]", ".", "parameters", "(", ")", ":", "\n", "                    ", "i", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "dilation", ",", "downsample", ",", "fix_bn", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", "-", "1", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "dilation", "=", "dilation", ",", "fix_bn", "=", "fix_bn", ")", ")", "\n", "", "if", "with_dpyramid", ":", "\n", "            ", "layers", ".", "append", "(", "DCNBottleneck", "(", "self", ".", "inplanes", ",", "planes", ",", "dilation", "=", "dilation", ",", "fix_bn", "=", "fix_bn", ")", ")", "\n", "", "else", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "dilation", "=", "dilation", ",", "fix_bn", "=", "fix_bn", ")", ")", "\n", "", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.res_block.forward": [[205, 208], ["resnet.res_block.layers"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "layers", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.name_mapping": [[211, 220], ["name.replace().replace().replace().replace", "name.startswith", "name.startswith", "name.replace().replace().replace", "name.startswith", "len", "name.replace().replace", "name.replace"], "methods", ["None"], ["    ", "def", "name_mapping", "(", "self", ",", "name", ",", "resume", "=", "False", ")", ":", "\n", "        ", "if", "resume", ":", "\n", "            ", "return", "name", "if", "not", "name", ".", "startswith", "(", "'module.'", ")", "else", "name", "[", "len", "(", "'module.'", ")", ":", "]", "\n", "", "if", "name", ".", "startswith", "(", "'conv1'", ")", "or", "name", ".", "startswith", "(", "'bn1'", ")", ":", "\n", "            ", "return", "'resnet_backbone.conv1.'", "+", "name", "\n", "", "return", "name", ".", "replace", "(", "'layer1'", ",", "'resnet_backbone.res2.layers'", ")", ".", "replace", "(", "'layer2'", ",", "'resnet_backbone.res3.layers'", ")", ".", "replace", "(", "'layer3'", ",", "'resnet_backbone.res4.layers'", ")", ".", "replace", "(", "'layer4'", ",", "'resnet_backbone.res5.layers'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.load_state_dict": [[221, 300], ["resnet.resnet_rcnn.state_dict", "state_dict.items", "resnet.resnet_rcnn.name_mapping", "isinstance", "set", "set", "len", "warnings.warn", "state_dict[].mean().item", "state_dict[].std().item", "state_dict[].view", "range", "weight_blobs.reshape.reshape.reshape", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "state_dict[].mean().item", "state_dict[].std().item", "range", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "warnings.warn", "own_state[].copy_", "warnings.warn", "resnet.resnet_rcnn.keys", "resnet.resnet_rcnn.name_mapping", "state_dict[].mean", "state_dict[].std", "list", "state_dict[].mean", "state_dict[].std", "own_state[].size", "param.size", "state_dict.keys", "list", "numpy.random.randn", "numpy.random.randn", "list", "list"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.name_mapping", "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.name_mapping"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ",", "resume", "=", "False", ")", ":", "\n", "        ", "own_state", "=", "self", ".", "state_dict", "(", ")", "\n", "\n", "if", "'rcnn.cls_score.weight'", "in", "state_dict", "and", "own_state", "[", "'rcnn.cls_score.weight'", "]", ".", "shape", "[", "0", "]", "==", "9", "and", "state_dict", "[", "'rcnn.cls_score.weight'", "]", ".", "shape", "[", "0", "]", "==", "81", ":", "\n", "            ", "cls_map", "=", "{", "\n", "0", ":", "0", ",", "# background", "\n", "1", ":", "1", ",", "# person", "\n", "2", ":", "-", "1", ",", "# rider, ignore", "\n", "3", ":", "3", ",", "# car", "\n", "4", ":", "8", ",", "# truck", "\n", "5", ":", "6", ",", "# bus", "\n", "6", ":", "7", ",", "# train", "\n", "7", ":", "4", ",", "# motorcycle", "\n", "8", ":", "2", ",", "# bicycle", "\n", "}", "\n", "for", "weight_name", "in", "[", "'rcnn.cls_score.weight'", ",", "'rcnn.cls_score.bias'", ",", "'rcnn.bbox_pred.weight'", ",", "'rcnn.bbox_pred.bias'", ",", "'mask_branch.mask_score.weight'", ",", "'mask_branch.mask_score.bias'", "]", ":", "\n", "                ", "mean", "=", "state_dict", "[", "weight_name", "]", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "std", "=", "state_dict", "[", "weight_name", "]", ".", "std", "(", ")", ".", "item", "(", ")", "\n", "state_dict", "[", "weight_name", "]", "=", "state_dict", "[", "weight_name", "]", ".", "view", "(", "*", "(", "[", "81", ",", "-", "1", "]", "+", "list", "(", "state_dict", "[", "weight_name", "]", ".", "shape", "[", "1", ":", "]", ")", ")", ")", "\n", "weight_blobs", "=", "(", "(", "np", ".", "random", ".", "randn", "(", "*", "(", "[", "9", "]", "+", "list", "(", "state_dict", "[", "weight_name", "]", ".", "shape", "[", "1", ":", "]", ")", ")", ")", ")", "*", "std", "+", "mean", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "for", "i", "in", "range", "(", "9", ")", ":", "\n", "                    ", "cls", "=", "cls_map", "[", "i", "]", "\n", "if", "cls", ">=", "0", ":", "\n", "                        ", "weight_blobs", "[", "i", "]", "=", "state_dict", "[", "weight_name", "]", "[", "cls", "]", "\n", "", "", "weight_blobs", "=", "weight_blobs", ".", "reshape", "(", "[", "-", "1", "]", "+", "list", "(", "state_dict", "[", "weight_name", "]", ".", "shape", "[", "2", ":", "]", ")", ")", "\n", "state_dict", "[", "weight_name", "]", "=", "torch", ".", "from_numpy", "(", "weight_blobs", ")", "\n", "\n", "", "", "if", "'fcn_head.score.weight'", "in", "own_state", "and", "'fcn_head.score.weight'", "in", "state_dict", "and", "own_state", "[", "'fcn_head.score.weight'", "]", ".", "shape", "[", "0", "]", "==", "19", "and", "state_dict", "[", "'fcn_head.score.weight'", "]", ".", "shape", "[", "0", "]", "==", "133", ":", "\n", "            ", "cls_map", "=", "{", "\n", "0", ":", "20", ",", "# road", "\n", "1", ":", "43", ",", "# sidewalk (pavement-merged -> sidewalk)", "\n", "2", ":", "49", ",", "# building", "\n", "3", ":", "51", ",", "# wall", "\n", "4", ":", "37", ",", "# fence", "\n", "5", ":", "-", "1", ",", "# pole", "\n", "6", ":", "62", ",", "# traffic light", "\n", "7", ":", "-", "1", ",", "# traffic sign", "\n", "8", ":", "36", ",", "# vegetation (tree-merged -> vegetation)", "\n", "9", ":", "-", "1", ",", "# terrain", "\n", "10", ":", "39", ",", "# sky", "\n", "11", ":", "53", ",", "# person", "\n", "12", ":", "-", "1", ",", "# rider", "\n", "13", ":", "55", ",", "# car", "\n", "14", ":", "60", ",", "# truck", "\n", "15", ":", "58", ",", "# bus", "\n", "16", ":", "59", ",", "# train", "\n", "17", ":", "56", ",", "# motorcycle", "\n", "18", ":", "54", ",", "# bicycle", "\n", "}", "\n", "for", "weight_name", "in", "[", "'fcn_head.score.weight'", ",", "'fcn_head.score.bias'", "]", ":", "\n", "                ", "mean", "=", "state_dict", "[", "weight_name", "]", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "std", "=", "state_dict", "[", "weight_name", "]", ".", "std", "(", ")", ".", "item", "(", ")", "\n", "weight_blobs", "=", "(", "(", "np", ".", "random", ".", "randn", "(", "*", "(", "[", "19", "]", "+", "list", "(", "state_dict", "[", "weight_name", "]", ".", "shape", "[", "1", ":", "]", ")", ")", ")", ")", "*", "std", "+", "mean", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "for", "i", "in", "range", "(", "19", ")", ":", "\n", "                    ", "cls", "=", "cls_map", "[", "i", "]", "\n", "if", "cls", ">=", "0", ":", "\n", "                        ", "weight_blobs", "[", "i", "]", "=", "state_dict", "[", "weight_name", "]", "[", "cls", "]", "\n", "", "", "state_dict", "[", "weight_name", "]", "=", "torch", ".", "from_numpy", "(", "weight_blobs", ")", "\n", "\n", "", "", "for", "name", ",", "param", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "            ", "name", "=", "self", ".", "name_mapping", "(", "name", ",", "resume", ")", "\n", "if", "name", "not", "in", "own_state", ":", "\n", "                ", "warnings", ".", "warn", "(", "'unexpected key \"{}\" in state_dict'", ".", "format", "(", "name", ")", ")", "\n", "continue", "\n", "", "if", "isinstance", "(", "param", ",", "Parameter", ")", ":", "\n", "# backwards compatibility for serialized parameters", "\n", "                ", "param", "=", "param", ".", "data", "\n", "", "if", "own_state", "[", "name", "]", ".", "shape", "==", "param", ".", "shape", ":", "\n", "                ", "own_state", "[", "name", "]", ".", "copy_", "(", "param", ")", "\n", "", "else", ":", "\n", "                ", "warnings", ".", "warn", "(", "'While copying the parameter named {}, whose dimensions in the models are'", "\n", "' {} and whose dimensions in the checkpoint are {}, ...'", ".", "format", "(", "\n", "name", ",", "own_state", "[", "name", "]", ".", "size", "(", ")", ",", "param", ".", "size", "(", ")", ")", ")", "\n", "\n", "", "", "missing", "=", "set", "(", "own_state", ".", "keys", "(", ")", ")", "-", "set", "(", "[", "self", ".", "name_mapping", "(", "_", ",", "resume", ")", "for", "_", "in", "state_dict", ".", "keys", "(", ")", "]", ")", "\n", "if", "len", "(", "missing", ")", ">", "0", ":", "\n", "            ", "warnings", ".", "warn", "(", "'missing keys in state_dict: \"{}\"'", ".", "format", "(", "missing", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.get_params_lr": [[301, 303], ["NotImplementedError"], "methods", ["None"], ["", "", "def", "get_params_lr", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.resnet_rcnn.freeze_backbone": [[304, 313], ["resnet.resnet_rcnn.resnet_backbone.conv1.parameters", "resnet.resnet_rcnn.resnet_backbone.conv1.eval", "range", "eval().parameters", "eval().eval", "eval", "eval"], "methods", ["None"], ["", "def", "freeze_backbone", "(", "self", ",", "freeze_at", ")", ":", "\n", "        ", "assert", "freeze_at", ">", "0", "\n", "for", "p", "in", "self", ".", "resnet_backbone", ".", "conv1", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "", "self", ".", "resnet_backbone", ".", "conv1", ".", "eval", "(", ")", "\n", "for", "i", "in", "range", "(", "2", ",", "freeze_at", "+", "1", ")", ":", "\n", "            ", "for", "p", "in", "eval", "(", "'self.resnet_backbone.res{}'", ".", "format", "(", "i", ")", ")", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "", "eval", "(", "'self.resnet_backbone.res{}'", ".", "format", "(", "i", ")", ")", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__": [[316, 346], ["torch.Module.__init__", "resnet.conv1", "resnet.res_block", "resnet.res_block", "resnet.res_block", "resnet.res_block", "resnet.ResNetBackbone.conv1.parameters", "resnet.ResNetBackbone.conv1.eval", "range", "eval().parameters", "eval().eval", "eval", "eval"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.__init__"], ["    ", "def", "__init__", "(", "self", ",", "blocks", ")", ":", "\n", "        ", "super", "(", "ResNetBackbone", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "fix_bn", "=", "config", ".", "network", ".", "backbone_fix_bn", "\n", "self", ".", "with_dilation", "=", "config", ".", "network", ".", "backbone_with_dilation", "\n", "self", ".", "with_dpyramid", "=", "config", ".", "network", ".", "backbone_with_dpyramid", "\n", "self", ".", "with_dconv", "=", "config", ".", "network", ".", "backbone_with_dconv", "\n", "self", ".", "freeze_at", "=", "config", ".", "network", ".", "backbone_freeze_at", "\n", "\n", "\n", "self", ".", "conv1", "=", "conv1", "(", "requires_grad", "=", "False", ")", "\n", "self", ".", "res2", "=", "res_block", "(", "64", ",", "blocks", "[", "0", "]", ",", "fix_bn", "=", "self", ".", "fix_bn", ")", "\n", "self", ".", "res3", "=", "res_block", "(", "128", ",", "blocks", "[", "1", "]", ",", "block", "=", "DCNBottleneck", "if", "self", ".", "with_dconv", "<=", "3", "else", "Bottleneck", ",", "\n", "stride", "=", "2", ",", "fix_bn", "=", "self", ".", "fix_bn", ",", "with_dpyramid", "=", "self", ".", "with_dpyramid", ")", "\n", "self", ".", "res4", "=", "res_block", "(", "256", ",", "blocks", "[", "2", "]", ",", "block", "=", "DCNBottleneck", "if", "self", ".", "with_dconv", "<=", "4", "else", "Bottleneck", ",", "\n", "stride", "=", "2", ",", "fix_bn", "=", "self", ".", "fix_bn", ",", "with_dpyramid", "=", "self", ".", "with_dpyramid", ")", "\n", "if", "self", ".", "with_dilation", ":", "\n", "            ", "res5_stride", ",", "res5_dilation", "=", "1", ",", "2", "\n", "", "else", ":", "\n", "            ", "res5_stride", ",", "res5_dilation", "=", "2", ",", "1", "\n", "", "self", ".", "res5", "=", "res_block", "(", "512", ",", "blocks", "[", "3", "]", ",", "block", "=", "DCNBottleneck", "if", "self", ".", "with_dconv", "<=", "5", "else", "Bottleneck", ",", "\n", "stride", "=", "res5_stride", ",", "dilation", "=", "res5_dilation", ",", "fix_bn", "=", "self", ".", "fix_bn", ")", "\n", "if", "self", ".", "freeze_at", ">", "0", ":", "\n", "            ", "for", "p", "in", "self", ".", "conv1", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "", "self", ".", "conv1", ".", "eval", "(", ")", "\n", "for", "i", "in", "range", "(", "2", ",", "self", ".", "freeze_at", "+", "1", ")", ":", "\n", "                ", "for", "p", "in", "eval", "(", "'self.res{}'", ".", "format", "(", "i", ")", ")", ".", "parameters", "(", ")", ":", "\n", "                    ", "p", ".", "requires_grad", "=", "False", "\n", "", "eval", "(", "'self.res{}'", ".", "format", "(", "i", ")", ")", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.ResNetBackbone.forward": [[347, 357], ["resnet.ResNetBackbone.conv1().detach", "resnet.ResNetBackbone.conv1", "resnet.ResNetBackbone.res2().detach", "resnet.ResNetBackbone.res2", "resnet.ResNetBackbone.res3().detach", "resnet.ResNetBackbone.res3", "resnet.ResNetBackbone.res4().detach", "resnet.ResNetBackbone.res4", "resnet.ResNetBackbone.res5().detach", "resnet.ResNetBackbone.res5", "resnet.ResNetBackbone.conv1", "resnet.ResNetBackbone.res2", "resnet.ResNetBackbone.res3", "resnet.ResNetBackbone.res4", "resnet.ResNetBackbone.res5"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\n", "        ", "conv1", "=", "self", ".", "conv1", "(", "x", ")", ".", "detach", "(", ")", "if", "self", ".", "freeze_at", "==", "1", "else", "self", ".", "conv1", "(", "x", ")", "\n", "res2", "=", "self", ".", "res2", "(", "conv1", ")", ".", "detach", "(", ")", "if", "self", ".", "freeze_at", "==", "2", "else", "self", ".", "res2", "(", "conv1", ")", "\n", "\n", "res3", "=", "self", ".", "res3", "(", "res2", ")", ".", "detach", "(", ")", "if", "self", ".", "freeze_at", "==", "3", "else", "self", ".", "res3", "(", "res2", ")", "\n", "res4", "=", "self", ".", "res4", "(", "res3", ")", ".", "detach", "(", ")", "if", "self", ".", "freeze_at", "==", "4", "else", "self", ".", "res4", "(", "res3", ")", "\n", "res5", "=", "self", ".", "res5", "(", "res4", ")", ".", "detach", "(", ")", "if", "self", ".", "freeze_at", "==", "5", "else", "self", ".", "res5", "(", "res4", ")", "\n", "\n", "return", "res2", ",", "res3", ",", "res4", ",", "res5", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.models.resnet.get_params": [[31, 52], ["model.named_modules", "module.named_parameters", "type", "type", "[].startswith", "n.endswith", "n.split"], "function", ["None"], ["", "def", "get_params", "(", "model", ",", "prefixs", ",", "suffixes", ",", "exclude", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    This generator returns all the parameters of the net except for\n    the last classification layer. Note that for each batchnorm layer,\n    requires_grad is set to False in deeplab_resnet.py, therefore this function does not return\n    any batchnorm parameter\n    \"\"\"", "\n", "for", "name", ",", "module", "in", "model", ".", "named_modules", "(", ")", ":", "\n", "        ", "for", "prefix", "in", "prefixs", ":", "\n", "            ", "if", "name", "==", "prefix", ":", "\n", "                ", "for", "n", ",", "p", "in", "module", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "n", "=", "'.'", ".", "join", "(", "[", "name", ",", "n", "]", ")", "\n", "if", "type", "(", "exclude", ")", "==", "list", "and", "n", "in", "exclude", ":", "\n", "                        ", "continue", "\n", "", "if", "type", "(", "exclude", ")", "==", "str", "and", "exclude", "in", "n", ":", "\n", "                        ", "continue", "\n", "\n", "", "for", "suffix", "in", "suffixes", ":", "\n", "                        ", "if", "(", "n", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", ".", "startswith", "(", "suffix", ")", "or", "n", ".", "endswith", "(", "suffix", ")", ")", "and", "p", ".", "requires_grad", ":", "\n", "                            ", "yield", "p", "\n", "", "", "", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.get_gt_masks": [[31, 37], ["numpy.zeros", "range", "cv2.resize", "gt_masks[].astype"], "function", ["None"], ["def", "get_gt_masks", "(", "gt_masks", ",", "size", ")", ":", "\n", "    ", "num_mask", "=", "gt_masks", ".", "shape", "[", "0", "]", "\n", "processed_masks", "=", "np", ".", "zeros", "(", "(", "num_mask", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "num_mask", ")", ":", "\n", "        ", "processed_masks", "[", "i", ",", ":", ",", ":", "]", "=", "cv2", ".", "resize", "(", "gt_masks", "[", "i", "]", ".", "astype", "(", "'float32'", ")", ",", "(", "size", "[", "1", "]", ",", "size", "[", "0", "]", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "", "return", "processed_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.mask_overlap": [[40, 71], ["max", "max", "min", "min", "numpy.logical_and().sum", "float", "float", "numpy.logical_and", "mask1.sum", "mask2.sum"], "function", ["None"], ["", "def", "mask_overlap", "(", "box1", ",", "box2", ",", "mask1", ",", "mask2", ")", ":", "\n", "    ", "\"\"\"\n    This function calculate region IOU when masks are\n    inside different boxes\n    Returns:\n        intersection over unions of this two masks\n    \"\"\"", "\n", "x1", "=", "max", "(", "box1", "[", "0", "]", ",", "box2", "[", "0", "]", ")", "\n", "y1", "=", "max", "(", "box1", "[", "1", "]", ",", "box2", "[", "1", "]", ")", "\n", "x2", "=", "min", "(", "box1", "[", "2", "]", ",", "box2", "[", "2", "]", ")", "\n", "y2", "=", "min", "(", "box1", "[", "3", "]", ",", "box2", "[", "3", "]", ")", "\n", "if", "x1", ">", "x2", "or", "y1", ">", "y2", ":", "\n", "        ", "return", "0", "\n", "", "w", "=", "x2", "-", "x1", "+", "1", "\n", "h", "=", "y2", "-", "y1", "+", "1", "\n", "# get masks in the intersection part", "\n", "start_ya", "=", "y1", "-", "box1", "[", "1", "]", "\n", "start_xa", "=", "x1", "-", "box1", "[", "0", "]", "\n", "inter_maska", "=", "mask1", "[", "start_ya", ":", "start_ya", "+", "h", ",", "start_xa", ":", "start_xa", "+", "w", "]", "\n", "\n", "start_yb", "=", "y1", "-", "box2", "[", "1", "]", "\n", "start_xb", "=", "x1", "-", "box2", "[", "0", "]", "\n", "inter_maskb", "=", "mask2", "[", "start_yb", ":", "start_yb", "+", "h", ",", "start_xb", ":", "start_xb", "+", "w", "]", "\n", "\n", "assert", "inter_maska", ".", "shape", "==", "inter_maskb", ".", "shape", "\n", "\n", "inter", "=", "np", ".", "logical_and", "(", "inter_maskb", ",", "inter_maska", ")", ".", "sum", "(", ")", "\n", "union", "=", "mask1", ".", "sum", "(", ")", "+", "mask2", ".", "sum", "(", ")", "-", "inter", "\n", "if", "union", "<", "1.0", ":", "\n", "        ", "return", "0", "\n", "", "return", "float", "(", "inter", ")", "/", "float", "(", "union", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.intersect_box_mask": [[73, 100], ["max", "max", "min", "min", "numpy.zeros", "numpy.zeros"], "function", ["None"], ["", "def", "intersect_box_mask", "(", "ex_box", ",", "gt_box", ",", "gt_mask", ")", ":", "\n", "    ", "\"\"\"\n    This function calculate the intersection part of a external box\n    and gt_box, mask it according to gt_mask\n    Args:\n        ex_box: external ROIS\n        gt_box: ground truth boxes\n        gt_mask: ground truth masks, not been resized yet\n    Returns:\n        regression_target: logical numpy array\n    \"\"\"", "\n", "x1", "=", "max", "(", "ex_box", "[", "0", "]", ",", "gt_box", "[", "0", "]", ")", "\n", "y1", "=", "max", "(", "ex_box", "[", "1", "]", ",", "gt_box", "[", "1", "]", ")", "\n", "x2", "=", "min", "(", "ex_box", "[", "2", "]", ",", "gt_box", "[", "2", "]", ")", "\n", "y2", "=", "min", "(", "ex_box", "[", "3", "]", ",", "gt_box", "[", "3", "]", ")", "\n", "if", "x1", ">", "x2", "or", "y1", ">", "y2", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "21", ",", "21", ")", ",", "dtype", "=", "bool", ")", "\n", "", "w", "=", "x2", "-", "x1", "+", "1", "\n", "h", "=", "y2", "-", "y1", "+", "1", "\n", "ex_starty", "=", "y1", "-", "ex_box", "[", "1", "]", "\n", "ex_startx", "=", "x1", "-", "ex_box", "[", "0", "]", "\n", "\n", "inter_maskb", "=", "gt_mask", "[", "y1", ":", "y2", "+", "1", ",", "x1", ":", "x2", "+", "1", "]", "\n", "regression_target", "=", "np", ".", "zeros", "(", "(", "ex_box", "[", "3", "]", "-", "ex_box", "[", "1", "]", "+", "1", ",", "ex_box", "[", "2", "]", "-", "ex_box", "[", "0", "]", "+", "1", ")", ")", "\n", "regression_target", "[", "ex_starty", ":", "ex_starty", "+", "h", ",", "ex_startx", ":", "ex_startx", "+", "w", "]", "=", "inter_maskb", "\n", "\n", "return", "regression_target", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.mask_aggregation": [[102, 135], ["numpy.zeros", "range", "numpy.where", "numpy.array", "len", "numpy.round().astype", "numpy.ceil().astype", "numpy.ceil().astype", "numpy.min", "numpy.min", "numpy.max", "numpy.max", "len", "len", "len", "numpy.round", "numpy.ceil", "numpy.ceil"], "function", ["None"], ["", "def", "mask_aggregation", "(", "boxes", ",", "masks", ",", "mask_weights", ",", "im_width", ",", "im_height", ",", "binary_thresh", "=", "0.4", ")", ":", "\n", "    ", "\"\"\"\n    This function implements mask voting mechanism to give finer mask\n    n is the candidate boxes (masks) number\n    Args:\n        masks: All masks need to be aggregated (n x sz x sz)\n        mask_weights: class score associated with each mask (n x 1)\n        boxes: tight box enclose each mask (n x 4)\n        im_width, im_height: image information\n    \"\"\"", "\n", "assert", "boxes", ".", "shape", "[", "0", "]", "==", "len", "(", "masks", ")", "and", "boxes", ".", "shape", "[", "0", "]", "==", "mask_weights", ".", "shape", "[", "0", "]", "\n", "im_mask", "=", "np", ".", "zeros", "(", "(", "im_height", ",", "im_width", ")", ")", "\n", "for", "mask_ind", "in", "range", "(", "len", "(", "masks", ")", ")", ":", "\n", "        ", "box", "=", "np", ".", "round", "(", "boxes", "[", "mask_ind", "]", ")", ".", "astype", "(", "int", ")", "\n", "mask", "=", "(", "masks", "[", "mask_ind", "]", ">=", "binary_thresh", ")", ".", "astype", "(", "float", ")", "\n", "\n", "mask_weight", "=", "mask_weights", "[", "mask_ind", "]", "\n", "im_mask", "[", "box", "[", "1", "]", ":", "box", "[", "3", "]", "+", "1", ",", "box", "[", "0", "]", ":", "box", "[", "2", "]", "+", "1", "]", "+=", "mask", "*", "mask_weight", "\n", "", "[", "r", ",", "c", "]", "=", "np", ".", "where", "(", "im_mask", ">=", "binary_thresh", ")", "\n", "if", "len", "(", "r", ")", "==", "0", "or", "len", "(", "c", ")", "==", "0", ":", "\n", "        ", "min_y", "=", "np", ".", "ceil", "(", "im_height", "/", "2", ")", ".", "astype", "(", "int", ")", "\n", "min_x", "=", "np", ".", "ceil", "(", "im_width", "/", "2", ")", ".", "astype", "(", "int", ")", "\n", "max_y", "=", "min_y", "\n", "max_x", "=", "min_x", "\n", "", "else", ":", "\n", "        ", "min_y", "=", "np", ".", "min", "(", "r", ")", "\n", "min_x", "=", "np", ".", "min", "(", "c", ")", "\n", "max_y", "=", "np", ".", "max", "(", "r", ")", "\n", "max_x", "=", "np", ".", "max", "(", "c", ")", "\n", "\n", "", "clipped_mask", "=", "im_mask", "[", "min_y", ":", "max_y", "+", "1", ",", "min_x", ":", "max_x", "+", "1", "]", "\n", "clipped_box", "=", "np", ".", "array", "(", "(", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "return", "clipped_mask", ",", "clipped_box", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.flip_segms": [[137, 164], ["numpy.array", "np.array.tolist", "pycocotools.decode", "pycocotools.encode", "pycocotools.frPyObjects", "numpy.array", "type", "flipped_segms.append", "flipped_segms.append", "numpy.array", "type", "type", "mask_transform.flip_segms._flip_rle"], "function", ["None"], ["", "def", "flip_segms", "(", "segms", ",", "height", ",", "width", ")", ":", "\n", "    ", "\"\"\"Left/right flip each mask in a list of masks.\"\"\"", "\n", "def", "_flip_poly", "(", "poly", ",", "width", ")", ":", "\n", "        ", "flipped_poly", "=", "np", ".", "array", "(", "poly", ")", "\n", "flipped_poly", "[", "0", ":", ":", "2", "]", "=", "width", "-", "np", ".", "array", "(", "poly", "[", "0", ":", ":", "2", "]", ")", "-", "1", "\n", "return", "flipped_poly", ".", "tolist", "(", ")", "\n", "\n", "", "def", "_flip_rle", "(", "rle", ",", "height", ",", "width", ")", ":", "\n", "        ", "if", "'counts'", "in", "rle", "and", "type", "(", "rle", "[", "'counts'", "]", ")", "==", "list", ":", "\n", "# Magic RLE format handling painfully discovered by looking at the", "\n", "# COCO API showAnns function.", "\n", "            ", "rle", "=", "mask_util", ".", "frPyObjects", "(", "[", "rle", "]", ",", "height", ",", "width", ")", "\n", "", "mask", "=", "mask_util", ".", "decode", "(", "rle", ")", "\n", "mask", "=", "mask", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "rle", "=", "mask_util", ".", "encode", "(", "np", ".", "array", "(", "mask", ",", "order", "=", "'F'", ",", "dtype", "=", "np", ".", "uint8", ")", ")", "\n", "return", "rle", "\n", "\n", "", "flipped_segms", "=", "[", "]", "\n", "for", "segm", "in", "segms", ":", "\n", "        ", "if", "type", "(", "segm", ")", "==", "list", ":", "\n", "# Polygon format", "\n", "            ", "flipped_segms", ".", "append", "(", "[", "_flip_poly", "(", "poly", ",", "width", ")", "for", "poly", "in", "segm", "]", ")", "\n", "", "else", ":", "\n", "# RLE format", "\n", "            ", "assert", "type", "(", "segm", ")", "==", "dict", "\n", "flipped_segms", ".", "append", "(", "_flip_rle", "(", "segm", ",", "height", ",", "width", ")", ")", "\n", "", "", "return", "flipped_segms", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.polys_to_mask": [[166, 178], ["pycocotools.frPyObjects", "numpy.array", "numpy.sum", "numpy.array", "pycocotools.decode"], "function", ["None"], ["", "def", "polys_to_mask", "(", "polygons", ",", "height", ",", "width", ")", ":", "\n", "    ", "\"\"\"Convert from the COCO polygon segmentation format to a binary mask\n    encoded as a 2D array of data type numpy.float32. The polygon segmentation\n    is understood to be enclosed inside a height x width image. The resulting\n    mask is therefore of shape (height, width).\n    \"\"\"", "\n", "rle", "=", "mask_util", ".", "frPyObjects", "(", "polygons", ",", "height", ",", "width", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask_util", ".", "decode", "(", "rle", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# Flatten in case polygons was a list", "\n", "mask", "=", "np", ".", "sum", "(", "mask", ",", "axis", "=", "2", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ">", "0", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.mask_to_bbox": [[180, 193], ["numpy.array", "numpy.where", "numpy.where", "len", "len", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "def", "mask_to_bbox", "(", "mask", ")", ":", "\n", "    ", "\"\"\"Compute the tight bounding box of a binary mask.\"\"\"", "\n", "xs", "=", "np", ".", "where", "(", "np", ".", "sum", "(", "mask", ",", "axis", "=", "0", ")", ">", "0", ")", "[", "0", "]", "\n", "ys", "=", "np", ".", "where", "(", "np", ".", "sum", "(", "mask", ",", "axis", "=", "1", ")", ">", "0", ")", "[", "0", "]", "\n", "\n", "if", "len", "(", "xs", ")", "==", "0", "or", "len", "(", "ys", ")", "==", "0", ":", "\n", "        ", "return", "None", "\n", "\n", "", "x0", "=", "xs", "[", "0", "]", "\n", "x1", "=", "xs", "[", "-", "1", "]", "\n", "y0", "=", "ys", "[", "0", "]", "\n", "y1", "=", "ys", "[", "-", "1", "]", "\n", "return", "np", ".", "array", "(", "(", "x0", ",", "y0", ",", "x1", ",", "y1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.polys_to_mask_wrt_box": [[195, 220], ["numpy.maximum", "numpy.maximum", "pycocotools.frPyObjects", "numpy.array", "numpy.sum", "numpy.array", "numpy.array", "polygons_norm.append", "pycocotools.decode"], "function", ["None"], ["", "def", "polys_to_mask_wrt_box", "(", "polygons", ",", "box", ",", "M", ")", ":", "\n", "    ", "\"\"\"Convert from the COCO polygon segmentation format to a binary mask\n    encoded as a 2D array of data type numpy.float32. The polygon segmentation\n    is understood to be enclosed in the given box and rasterized to an M x M\n    mask. The resulting mask is therefore of shape (M, M).\n    \"\"\"", "\n", "w", "=", "box", "[", "2", "]", "-", "box", "[", "0", "]", "\n", "h", "=", "box", "[", "3", "]", "-", "box", "[", "1", "]", "\n", "\n", "w", "=", "np", ".", "maximum", "(", "w", ",", "1", ")", "\n", "h", "=", "np", ".", "maximum", "(", "h", ",", "1", ")", "\n", "\n", "polygons_norm", "=", "[", "]", "\n", "for", "poly", "in", "polygons", ":", "\n", "        ", "p", "=", "np", ".", "array", "(", "poly", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "p", "[", "0", ":", ":", "2", "]", "=", "(", "p", "[", "0", ":", ":", "2", "]", "-", "box", "[", "0", "]", ")", "*", "M", "/", "w", "\n", "p", "[", "1", ":", ":", "2", "]", "=", "(", "p", "[", "1", ":", ":", "2", "]", "-", "box", "[", "1", "]", ")", "*", "M", "/", "h", "\n", "polygons_norm", ".", "append", "(", "p", ")", "\n", "\n", "", "rle", "=", "mask_util", ".", "frPyObjects", "(", "polygons_norm", ",", "M", ",", "M", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask_util", ".", "decode", "(", "rle", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# Flatten in case polygons was a list", "\n", "mask", "=", "np", ".", "sum", "(", "mask", ",", "axis", "=", "2", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ">", "0", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.polys_to_boxes": [[222, 234], ["numpy.zeros", "range", "len", "min", "max", "min", "max", "len", "min", "max", "min", "max", "numpy.np.float32"], "function", ["None"], ["", "def", "polys_to_boxes", "(", "polys", ")", ":", "\n", "    ", "\"\"\"Convert a list of polygons into an array of tight bounding boxes.\"\"\"", "\n", "boxes_from_polys", "=", "np", ".", "zeros", "(", "(", "len", "(", "polys", ")", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "polys", ")", ")", ":", "\n", "        ", "poly", "=", "polys", "[", "i", "]", "\n", "x0", "=", "min", "(", "min", "(", "p", "[", ":", ":", "2", "]", ")", "for", "p", "in", "poly", ")", "\n", "x1", "=", "max", "(", "max", "(", "p", "[", ":", ":", "2", "]", ")", "for", "p", "in", "poly", ")", "\n", "y0", "=", "min", "(", "min", "(", "p", "[", "1", ":", ":", "2", "]", ")", "for", "p", "in", "poly", ")", "\n", "y1", "=", "max", "(", "max", "(", "p", "[", "1", ":", ":", "2", "]", ")", "for", "p", "in", "poly", ")", "\n", "boxes_from_polys", "[", "i", ",", ":", "]", "=", "[", "x0", ",", "y0", ",", "x1", ",", "y1", "]", "\n", "\n", "", "return", "boxes_from_polys", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.add_mask_rcnn_blobs": [[235, 300], ["mask_transform.polys_to_boxes", "blobs[].copy", "mask_transform._expand_to_class_specific_mask_targets", "numpy.hstack", "numpy.where", "numpy.where", "numpy.zeros", "upsnet.bbox.bbox_transform.bbox_overlaps", "numpy.argmax", "range", "sampled_boxes[].reshape", "numpy.zeros", "numpy.ones", "sampled_boxes[].reshape.astype", "polys_to_boxes.astype", "mask_transform.polys_to_mask_wrt_box", "numpy.array", "numpy.reshape", "numpy.where", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.polys_to_boxes", "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform._expand_to_class_specific_mask_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps", "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.polys_to_mask_wrt_box"], ["", "def", "add_mask_rcnn_blobs", "(", "blobs", ",", "sampled_boxes", ",", "roidb", ",", "im_scale", ",", "batch_idx", ")", ":", "\n", "    ", "\"\"\"Add Mask R-CNN specific blobs to the input blob dictionary.\"\"\"", "\n", "# Prepare the mask targets by associating one gt mask to each training roi", "\n", "# that has a fg (non-bg) class label.", "\n", "M", "=", "config", ".", "network", ".", "mask_size", "\n", "polys_gt_inds", "=", "np", ".", "where", "(", "\n", "(", "roidb", "[", "'gt_classes'", "]", ">", "0", ")", "&", "(", "roidb", "[", "'is_crowd'", "]", "==", "0", ")", "\n", ")", "[", "0", "]", "\n", "polys_gt", "=", "[", "roidb", "[", "'segms'", "]", "[", "i", "]", "for", "i", "in", "polys_gt_inds", "]", "\n", "boxes_from_polys", "=", "polys_to_boxes", "(", "polys_gt", ")", "\n", "fg_inds", "=", "np", ".", "where", "(", "blobs", "[", "'labels_int32'", "]", ">", "0", ")", "[", "0", "]", "\n", "roi_has_mask", "=", "blobs", "[", "'labels_int32'", "]", ".", "copy", "(", ")", "\n", "roi_has_mask", "[", "roi_has_mask", ">", "0", "]", "=", "1", "\n", "\n", "if", "fg_inds", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "# Class labels for the foreground rois", "\n", "        ", "mask_class_labels", "=", "blobs", "[", "'labels_int32'", "]", "[", "fg_inds", "]", "\n", "masks", "=", "np", ".", "zeros", "(", "(", "fg_inds", ".", "shape", "[", "0", "]", ",", "M", "**", "2", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "# Find overlap between all foreground rois and the bounding boxes", "\n", "# enclosing each segmentation", "\n", "rois_fg", "=", "sampled_boxes", "[", "fg_inds", "]", "\n", "overlaps_bbfg_bbpolys", "=", "bbox_overlaps", "(", "\n", "rois_fg", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", ",", "\n", "boxes_from_polys", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", ")", "\n", "# Map from each fg rois to the index of the mask with highest overlap", "\n", "# (measured by bbox overlap)", "\n", "fg_polys_inds", "=", "np", ".", "argmax", "(", "overlaps_bbfg_bbpolys", ",", "axis", "=", "1", ")", "\n", "\n", "# add fg targets", "\n", "for", "i", "in", "range", "(", "rois_fg", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "fg_polys_ind", "=", "fg_polys_inds", "[", "i", "]", "\n", "poly_gt", "=", "polys_gt", "[", "fg_polys_ind", "]", "\n", "roi_fg", "=", "rois_fg", "[", "i", "]", "\n", "# Rasterize the portion of the polygon mask within the given fg roi", "\n", "# to an M x M binary image", "\n", "mask", "=", "polys_to_mask_wrt_box", "(", "poly_gt", ",", "roi_fg", ",", "M", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ">", "0", ",", "dtype", "=", "np", ".", "int32", ")", "# Ensure it's binary", "\n", "masks", "[", "i", ",", ":", "]", "=", "np", ".", "reshape", "(", "mask", ",", "M", "**", "2", ")", "\n", "", "", "else", ":", "# If there are no fg masks (it does happen)", "\n", "# The network cannot handle empty blobs, so we must provide a mask", "\n", "# We simply take the first bg roi, given it an all -1's mask (ignore", "\n", "# label), and label it with class zero (bg).", "\n", "        ", "bg_inds", "=", "np", ".", "where", "(", "blobs", "[", "'labels_int32'", "]", "==", "0", ")", "[", "0", "]", "\n", "# rois_fg is actually one background roi, but that's ok because ...", "\n", "rois_fg", "=", "sampled_boxes", "[", "bg_inds", "[", "0", "]", "]", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "# We give it an -1's blob (ignore label)", "\n", "masks", "=", "-", "np", ".", "ones", "(", "(", "1", ",", "M", "**", "2", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "# We label it with class = 0 (background)", "\n", "mask_class_labels", "=", "np", ".", "zeros", "(", "(", "1", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# Mark that the first roi has a mask", "\n", "roi_has_mask", "[", "0", "]", "=", "1", "\n", "\n", "", "masks", "=", "_expand_to_class_specific_mask_targets", "(", "masks", ",", "mask_class_labels", ")", "\n", "\n", "# Scale rois_fg and format as (batch_idx, x1, y1, x2, y2)", "\n", "rois_fg", "*=", "im_scale", "\n", "repeated_batch_idx", "=", "batch_idx", "*", "np", ".", "ones", "(", "(", "rois_fg", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "rois_fg", "=", "np", ".", "hstack", "(", "(", "repeated_batch_idx", ",", "rois_fg", ")", ")", "\n", "\n", "# Update blobs dict with Mask R-CNN blobs", "\n", "blobs", "[", "'mask_rois'", "]", "=", "rois_fg", "\n", "blobs", "[", "'roi_has_mask_int32'", "]", "=", "roi_has_mask", "\n", "blobs", "[", "'mask_int32'", "]", "=", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform._expand_to_class_specific_mask_targets": [[302, 324], ["range", "numpy.ones", "int"], "function", ["None"], ["", "def", "_expand_to_class_specific_mask_targets", "(", "masks", ",", "mask_class_labels", ")", ":", "\n", "    ", "\"\"\"Expand masks from shape (#masks, M ** 2) to (#masks, #classes * M ** 2)\n    to encode class specific mask targets.\n    \"\"\"", "\n", "assert", "masks", ".", "shape", "[", "0", "]", "==", "mask_class_labels", ".", "shape", "[", "0", "]", "\n", "M", "=", "config", ".", "network", ".", "mask_size", "\n", "\n", "# Target values of -1 are \"don't care\" / ignore labels", "\n", "mask_targets", "=", "-", "np", ".", "ones", "(", "\n", "(", "masks", ".", "shape", "[", "0", "]", ",", "config", ".", "dataset", ".", "num_classes", "*", "M", "**", "2", ")", ",", "dtype", "=", "np", ".", "int32", "\n", ")", "\n", "\n", "for", "i", "in", "range", "(", "masks", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "cls", "=", "int", "(", "mask_class_labels", "[", "i", "]", ")", "\n", "start", "=", "M", "**", "2", "*", "cls", "\n", "end", "=", "start", "+", "M", "**", "2", "\n", "# Ignore background instance", "\n", "# (only happens when there is no fg samples in an image)", "\n", "if", "cls", ">", "0", ":", "\n", "            ", "mask_targets", "[", "i", ",", "start", ":", "end", "]", "=", "masks", "[", "i", ",", ":", "]", "\n", "\n", "", "", "return", "mask_targets", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois.compute_assign_targets": [[22, 33], ["numpy.sqrt", "numpy.zeros", "enumerate", "numpy.shape", "numpy.logical_and"], "function", ["None"], ["def", "compute_assign_targets", "(", "rois", ",", "threshold", "=", "[", "[", "np", ".", "inf", ",", "448", "]", ",", "[", "448", ",", "224", "]", ",", "[", "224", ",", "112", "]", ",", "[", "112", ",", "0", "]", "]", ")", ":", "\n", "    ", "rois_area", "=", "np", ".", "sqrt", "(", "(", "rois", "[", ":", ",", "2", "]", "-", "rois", "[", ":", ",", "0", "]", "+", "1", ")", "*", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", "+", "1", ")", ")", "\n", "num_rois", "=", "np", ".", "shape", "(", "rois", ")", "[", "0", "]", "\n", "assign_levels", "=", "np", ".", "zeros", "(", "num_rois", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", ",", "stride", "in", "enumerate", "(", "config", ".", "network", ".", "rcnn_feat_stride", ")", ":", "\n", "        ", "thd", "=", "threshold", "[", "i", "]", "\n", "idx", "=", "np", ".", "logical_and", "(", "thd", "[", "1", "]", "<=", "rois_area", ",", "rois_area", "<", "thd", "[", "0", "]", ")", "\n", "assign_levels", "[", "idx", "]", "=", "stride", "\n", "\n", "", "assert", "0", "not", "in", "assign_levels", ",", "\"All rois should assign to specify levels.\"", "\n", "return", "assign_levels", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois.compute_mask_and_label": [[35, 49], ["numpy.zeros", "numpy.zeros", "range", "numpy.zeros", "cv2.resize", "int", "int", "int", "int", "int", "int"], "function", ["None"], ["", "def", "compute_mask_and_label", "(", "rois", ",", "labels", ",", "gt_masks", ",", "gt_assignment", ",", "num_classes", ",", "mask_size", ")", ":", "\n", "    ", "n_rois", "=", "rois", ".", "shape", "[", "0", "]", "\n", "mask_targets", "=", "np", ".", "zeros", "(", "(", "n_rois", ",", "num_classes", ",", "mask_size", ",", "mask_size", ")", ")", "\n", "mask_weights", "=", "np", ".", "zeros", "(", "(", "n_rois", ",", "num_classes", ",", "1", ",", "1", ")", ")", "\n", "for", "n", "in", "range", "(", "n_rois", ")", ":", "\n", "        ", "target", "=", "gt_masks", "[", "gt_assignment", "[", "n", "]", ",", "int", "(", "rois", "[", "n", ",", "2", "]", ")", ":", "int", "(", "rois", "[", "n", ",", "4", "]", ")", ",", "int", "(", "rois", "[", "n", ",", "1", "]", ")", ":", "int", "(", "rois", "[", "n", ",", "3", "]", ")", "]", "\n", "if", "labels", "[", "n", "]", "==", "0", "or", "target", ".", "size", "==", "0", ":", "\n", "            ", "continue", "\n", "", "mask", "=", "np", ".", "zeros", "(", "target", ".", "shape", ")", "\n", "mask", "[", "target", "==", "1", "]", "=", "1", "\n", "mask", "=", "cv2", ".", "resize", "(", "mask", ",", "(", "mask_size", ",", "mask_size", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "mask_targets", "[", "n", ",", "int", "(", "labels", "[", "n", "]", ")", ",", "...", "]", "=", "mask", "\n", "mask_weights", "[", "n", ",", "int", "(", "labels", "[", "n", "]", ")", ",", "...", "]", "=", "1", "\n", "", "return", "mask_targets", ",", "mask_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois.sample_rois": [[51, 138], ["int", "int", "numpy.minimum", "numpy.minimum", "numpy.append", "numpy.array", "numpy.hstack", "dict", "numpy.round", "numpy.where", "numpy.choice", "numpy.where", "numpy.choice", "sample_rois._compute_targets", "sample_rois._expand_bbox_targets", "sample_rois._expand_bbox_targets", "numpy.ones", "numpy.where", "upsnet.mask.mask_transform.add_mask_rcnn_blobs", "numpy.where", "sampled_labels.astype"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois._compute_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois._expand_bbox_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois._expand_bbox_targets", "home.repos.pwc.inspect_result.uber-research_UPSNet.mask.mask_transform.add_mask_rcnn_blobs"], ["", "def", "sample_rois", "(", "roidb", ",", "im_scale", ",", "batch_idx", ")", ":", "\n", "    ", "\"\"\"Generate a random sample of RoIs comprising foreground and background\n    examples.\n    \"\"\"", "\n", "rois_per_image", "=", "int", "(", "config", ".", "train", ".", "batch_rois", ")", "\n", "fg_rois_per_image", "=", "int", "(", "np", ".", "round", "(", "config", ".", "train", ".", "fg_fraction", "*", "rois_per_image", ")", ")", "\n", "max_overlaps", "=", "roidb", "[", "'max_overlaps'", "]", "\n", "\n", "# Select foreground RoIs as those with >= FG_THRESH overlap", "\n", "fg_inds", "=", "np", ".", "where", "(", "max_overlaps", ">=", "config", ".", "train", ".", "fg_thresh", ")", "[", "0", "]", "\n", "# Guard against the case when an image has fewer than fg_rois_per_image", "\n", "# foreground RoIs", "\n", "fg_rois_per_this_image", "=", "np", ".", "minimum", "(", "fg_rois_per_image", ",", "fg_inds", ".", "size", ")", "\n", "# Sample foreground regions without replacement", "\n", "if", "fg_inds", ".", "size", ">", "0", ":", "\n", "# print('sample rois use first 128 fg')", "\n", "# fg_inds = fg_inds[:fg_rois_per_this_image]", "\n", "        ", "fg_inds", "=", "npr", ".", "choice", "(", "\n", "fg_inds", ",", "size", "=", "fg_rois_per_this_image", ",", "replace", "=", "False", "\n", ")", "\n", "\n", "# Select background RoIs as those within [BG_THRESH_LO, BG_THRESH_HI)", "\n", "", "bg_inds", "=", "np", ".", "where", "(", "\n", "(", "max_overlaps", "<", "config", ".", "train", ".", "bg_thresh_hi", ")", "&", "\n", "(", "max_overlaps", ">=", "config", ".", "train", ".", "bg_thresh_lo", ")", "\n", ")", "[", "0", "]", "\n", "# Compute number of background RoIs to take from this image (guarding", "\n", "# against there being fewer than desired)", "\n", "bg_rois_per_this_image", "=", "rois_per_image", "-", "fg_rois_per_this_image", "\n", "bg_rois_per_this_image", "=", "np", ".", "minimum", "(", "bg_rois_per_this_image", ",", "bg_inds", ".", "size", ")", "\n", "# Sample foreground regions without replacement", "\n", "if", "bg_inds", ".", "size", ">", "0", ":", "\n", "# print('sample rois use first 384 bg')", "\n", "# bg_inds = bg_inds[:bg_rois_per_this_image]", "\n", "        ", "bg_inds", "=", "npr", ".", "choice", "(", "\n", "bg_inds", ",", "size", "=", "bg_rois_per_this_image", ",", "replace", "=", "False", "\n", ")", "\n", "\n", "# The indices that we're selecting (both fg and bg)", "\n", "", "keep_inds", "=", "np", ".", "append", "(", "fg_inds", ",", "bg_inds", ")", "\n", "# print(keep_inds.shape)", "\n", "# Label is the class each RoI has max overlap with", "\n", "sampled_labels", "=", "roidb", "[", "'max_classes'", "]", "[", "keep_inds", "]", "\n", "sampled_labels", "[", "fg_rois_per_this_image", ":", "]", "=", "0", "# Label bg RoIs with class 0", "\n", "sampled_boxes", "=", "roidb", "[", "'boxes'", "]", "[", "keep_inds", "]", "\n", "\n", "if", "'bbox_targets'", "not", "in", "roidb", ":", "\n", "        ", "gt_inds", "=", "np", ".", "where", "(", "roidb", "[", "'gt_classes'", "]", ">", "0", ")", "[", "0", "]", "\n", "gt_boxes", "=", "roidb", "[", "'boxes'", "]", "[", "gt_inds", ",", ":", "]", "\n", "gt_assignments", "=", "gt_inds", "[", "roidb", "[", "'box_to_gt_ind_map'", "]", "[", "keep_inds", "]", "]", "\n", "bbox_targets", "=", "_compute_targets", "(", "\n", "sampled_boxes", ",", "gt_boxes", "[", "gt_assignments", ",", ":", "]", ",", "sampled_labels", "\n", ")", "\n", "bbox_targets", ",", "bbox_inside_weights", "=", "_expand_bbox_targets", "(", "bbox_targets", ")", "\n", "", "else", ":", "\n", "        ", "bbox_targets", ",", "bbox_inside_weights", "=", "_expand_bbox_targets", "(", "\n", "roidb", "[", "'bbox_targets'", "]", "[", "keep_inds", ",", ":", "]", "\n", ")", "\n", "\n", "", "bbox_outside_weights", "=", "np", ".", "array", "(", "\n", "bbox_inside_weights", ">", "0", ",", "dtype", "=", "bbox_inside_weights", ".", "dtype", "\n", ")", "\n", "\n", "# Scale rois and format as (batch_idx, x1, y1, x2, y2)", "\n", "sampled_rois", "=", "sampled_boxes", "*", "im_scale", "\n", "repeated_batch_idx", "=", "batch_idx", "*", "np", ".", "ones", "(", "(", "sampled_rois", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "np", ".", "float32", ")", "\n", "sampled_rois", "=", "np", ".", "hstack", "(", "(", "repeated_batch_idx", ",", "sampled_rois", ")", ")", "\n", "\n", "nongt_inds", "=", "np", ".", "where", "(", "roidb", "[", "'gt_classes'", "]", "[", "keep_inds", "]", "==", "0", ")", "[", "0", "]", "\n", "\n", "# Base Fast R-CNN blobs", "\n", "blob_dict", "=", "dict", "(", "\n", "labels_int32", "=", "sampled_labels", ".", "astype", "(", "np", ".", "int32", ",", "copy", "=", "False", ")", ",", "\n", "rois", "=", "sampled_rois", ",", "\n", "bbox_targets", "=", "bbox_targets", ",", "\n", "bbox_inside_weights", "=", "bbox_inside_weights", ",", "\n", "bbox_outside_weights", "=", "bbox_outside_weights", ",", "\n", "nongt_inds", "=", "nongt_inds", "\n", ")", "\n", "\n", "# Optionally add Mask R-CNN blobs", "\n", "if", "config", ".", "network", ".", "has_mask_head", ":", "\n", "        ", "add_mask_rcnn_blobs", "(", "\n", "blob_dict", ",", "sampled_boxes", ",", "roidb", ",", "im_scale", ",", "batch_idx", "\n", ")", "\n", "\n", "", "return", "blob_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois._compute_targets": [[139, 151], ["upsnet.bbox.bbox_transform.bbox_transform_inv", "numpy.hstack().astype", "numpy.hstack"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_transform_inv"], ["", "def", "_compute_targets", "(", "ex_rois", ",", "gt_rois", ",", "labels", ")", ":", "\n", "    ", "\"\"\"Compute bounding-box regression targets for an image.\"\"\"", "\n", "\n", "assert", "ex_rois", ".", "shape", "[", "0", "]", "==", "gt_rois", ".", "shape", "[", "0", "]", "\n", "assert", "ex_rois", ".", "shape", "[", "1", "]", "==", "4", "\n", "assert", "gt_rois", ".", "shape", "[", "1", "]", "==", "4", "\n", "\n", "targets", "=", "bbox_transform_inv", "(", "\n", "ex_rois", ",", "gt_rois", ",", "config", ".", "network", ".", "bbox_reg_weights", "\n", ")", "\n", "return", "np", ".", "hstack", "(", "(", "labels", "[", ":", ",", "np", ".", "newaxis", "]", ",", "targets", ")", ")", ".", "astype", "(", "\n", "np", ".", "float32", ",", "copy", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.sample_rois._expand_bbox_targets": [[154, 177], ["numpy.zeros", "numpy.zeros", "numpy.where", "int"], "function", ["None"], ["", "def", "_expand_bbox_targets", "(", "bbox_target_data", ")", ":", "\n", "    ", "\"\"\"Bounding-box regression targets are stored in a compact form in the\n    roidb.\n    This function expands those targets into the 4-of-4*K representation used\n    by the network (i.e. only one class has non-zero targets). The loss weights\n    are similarly expanded.\n    Returns:\n        bbox_target_data (ndarray): N x 4K blob of regression targets\n        bbox_inside_weights (ndarray): N x 4K blob of loss weights\n    \"\"\"", "\n", "num_bbox_reg_classes", "=", "2", "if", "config", ".", "network", ".", "cls_agnostic_bbox_reg", "else", "config", ".", "dataset", ".", "num_classes", "\n", "\n", "clss", "=", "bbox_target_data", "[", ":", ",", "0", "]", "\n", "bbox_targets", "=", "np", ".", "zeros", "(", "(", "clss", ".", "size", ",", "4", "*", "num_bbox_reg_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "bbox_inside_weights", "=", "np", ".", "zeros", "(", "bbox_targets", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "inds", "=", "np", ".", "where", "(", "clss", ">", "0", ")", "[", "0", "]", "\n", "for", "ind", "in", "inds", ":", "\n", "        ", "cls", "=", "int", "(", "clss", "[", "ind", "]", ")", "\n", "start", "=", "4", "*", "cls", "\n", "end", "=", "start", "+", "4", "\n", "bbox_targets", "[", "ind", ",", "start", ":", "end", "]", "=", "bbox_target_data", "[", "ind", ",", "1", ":", "]", "\n", "bbox_inside_weights", "[", "ind", ",", "start", ":", "end", "]", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", "\n", "", "return", "bbox_targets", ",", "bbox_inside_weights", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.setup.custom_build_ext.build_extensions": [[68, 71], ["setup.customize_compiler_for_nvcc", "Cython.Distutils.build_ext.build_extensions"], "methods", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.setup.customize_compiler_for_nvcc", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.setup.custom_build_ext.build_extensions"], ["try", ":", "\n", "    ", "numpy_include", "=", "np", ".", "get_include", "(", ")", "\n", "", "except", "AttributeError", ":", "\n", "    ", "numpy_include", "=", "np", ".", "get_numpy_include", "(", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.setup.customize_compiler_for_nvcc": [[29, 64], ["setup..src_extensions.append", "setup..set_executable", "os.path.splitext"], "function", ["None"], ["            ", "return", "os", ".", "path", ".", "abspath", "(", "binpath", ")", "\n", "", "", "return", "None", "\n", "\n", "\n", "", "def", "locate_cuda", "(", ")", ":", "\n", "    ", "\"\"\"Locate the CUDA environment on the system\n\n    Returns a dict with keys 'home', 'nvcc', 'include', and 'lib64'\n    and values giving the absolute path to each directory.\n\n    Starts by looking for the CUDAHOME env variable. If not found, everything\n    is based on finding 'nvcc' in the PATH.\n    \"\"\"", "\n", "\n", "# first check if the CUDAHOME env variable is in use", "\n", "if", "'CUDAHOME'", "in", "os", ".", "environ", ":", "\n", "        ", "home", "=", "os", ".", "environ", "[", "'CUDAHOME'", "]", "\n", "nvcc", "=", "pjoin", "(", "home", ",", "'bin'", ",", "'nvcc'", ")", "\n", "", "else", ":", "\n", "# otherwise, search the PATH for NVCC", "\n", "        ", "default_path", "=", "pjoin", "(", "os", ".", "sep", ",", "'usr'", ",", "'local'", ",", "'cuda'", ",", "'bin'", ")", "\n", "nvcc", "=", "find_in_path", "(", "'nvcc'", ",", "os", ".", "environ", "[", "'PATH'", "]", "+", "os", ".", "pathsep", "+", "default_path", ")", "\n", "if", "nvcc", "is", "None", ":", "\n", "            ", "raise", "EnvironmentError", "(", "'The nvcc binary could not be '", "\n", "'located in your $PATH. Either add it to your path, or set $CUDAHOME'", ")", "\n", "", "home", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "nvcc", ")", ")", "\n", "\n", "", "cudaconfig", "=", "{", "'home'", ":", "home", ",", "'nvcc'", ":", "nvcc", ",", "\n", "'include'", ":", "pjoin", "(", "home", ",", "'include'", ")", ",", "\n", "'lib64'", ":", "pjoin", "(", "home", ",", "'lib64'", ")", "}", "\n", "for", "k", ",", "v", "in", "cudaconfig", ".", "items", "(", ")", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "v", ")", ":", "\n", "            ", "raise", "EnvironmentError", "(", "'The CUDA %s path could not be located in %s'", "%", "(", "k", ",", "v", ")", ")", "\n", "\n", "", "", "return", "cudaconfig", "\n", "", "CUDA", "=", "locate_cuda", "(", ")", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps": [[18, 20], ["bbox.bbox_overlaps"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps"], ["def", "bbox_overlaps", "(", "boxes", ",", "query_boxes", ")", ":", "\n", "    ", "return", "bbox_overlaps_cython", "(", "boxes", ",", "query_boxes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps_py": [[22, 43], ["numpy.zeros", "range", "range", "min", "max", "float", "min", "max"], "function", ["None"], ["", "def", "bbox_overlaps_py", "(", "boxes", ",", "query_boxes", ")", ":", "\n", "    ", "\"\"\"\n    determine overlaps between boxes and query_boxes\n    :param boxes: n * 4 bounding boxes\n    :param query_boxes: k * 4 bounding boxes\n    :return: overlaps: n * k overlaps\n    \"\"\"", "\n", "n_", "=", "boxes", ".", "shape", "[", "0", "]", "\n", "k_", "=", "query_boxes", ".", "shape", "[", "0", "]", "\n", "overlaps", "=", "np", ".", "zeros", "(", "(", "n_", ",", "k_", ")", ",", "dtype", "=", "np", ".", "float", ")", "\n", "for", "k", "in", "range", "(", "k_", ")", ":", "\n", "        ", "query_box_area", "=", "(", "query_boxes", "[", "k", ",", "2", "]", "-", "query_boxes", "[", "k", ",", "0", "]", "+", "1", ")", "*", "(", "query_boxes", "[", "k", ",", "3", "]", "-", "query_boxes", "[", "k", ",", "1", "]", "+", "1", ")", "\n", "for", "n", "in", "range", "(", "n_", ")", ":", "\n", "            ", "iw", "=", "min", "(", "boxes", "[", "n", ",", "2", "]", ",", "query_boxes", "[", "k", ",", "2", "]", ")", "-", "max", "(", "boxes", "[", "n", ",", "0", "]", ",", "query_boxes", "[", "k", ",", "0", "]", ")", "+", "1", "\n", "if", "iw", ">", "0", ":", "\n", "                ", "ih", "=", "min", "(", "boxes", "[", "n", ",", "3", "]", ",", "query_boxes", "[", "k", ",", "3", "]", ")", "-", "max", "(", "boxes", "[", "n", ",", "1", "]", ",", "query_boxes", "[", "k", ",", "1", "]", ")", "+", "1", "\n", "if", "ih", ">", "0", ":", "\n", "                    ", "box_area", "=", "(", "boxes", "[", "n", ",", "2", "]", "-", "boxes", "[", "n", ",", "0", "]", "+", "1", ")", "*", "(", "boxes", "[", "n", ",", "3", "]", "-", "boxes", "[", "n", ",", "1", "]", "+", "1", ")", "\n", "all_area", "=", "float", "(", "box_area", "+", "query_box_area", "-", "iw", "*", "ih", ")", "\n", "overlaps", "[", "n", ",", "k", "]", "=", "iw", "*", "ih", "/", "all_area", "\n", "", "", "", "", "return", "overlaps", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_boxes": [[45, 61], ["numpy.maximum", "numpy.maximum", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.minimum", "numpy.minimum"], "function", ["None"], ["", "def", "clip_boxes", "(", "boxes", ",", "im_shape", ")", ":", "\n", "    ", "\"\"\"\n    Clip boxes to image boundaries.\n    :param boxes: [N, 4* num_classes]\n    :param im_shape: tuple of 2\n    :return: [N, 4* num_classes]\n    \"\"\"", "\n", "# x1 >= 0", "\n", "boxes", "[", ":", ",", "0", ":", ":", "4", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "0", ":", ":", "4", "]", ",", "im_shape", "[", "1", "]", "-", "1", ")", ",", "0", ")", "\n", "# y1 >= 0", "\n", "boxes", "[", ":", ",", "1", ":", ":", "4", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "1", ":", ":", "4", "]", ",", "im_shape", "[", "0", "]", "-", "1", ")", ",", "0", ")", "\n", "# x2 < im_shape[1]", "\n", "boxes", "[", ":", ",", "2", ":", ":", "4", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "2", ":", ":", "4", "]", ",", "im_shape", "[", "1", "]", "-", "1", ")", ",", "0", ")", "\n", "# y2 < im_shape[0]", "\n", "boxes", "[", ":", ",", "3", ":", ":", "4", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "3", ":", ":", "4", "]", ",", "im_shape", "[", "0", "]", "-", "1", ")", ",", "0", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_boxes_to_image": [[62, 67], ["numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["", "def", "clip_boxes_to_image", "(", "boxes", ",", "height", ",", "width", ")", ":", "\n", "    ", "\"\"\"Clip an array of boxes to an image with the given height and width.\"\"\"", "\n", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "=", "np", ".", "minimum", "(", "width", "-", "1.", ",", "np", ".", "maximum", "(", "0.", ",", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", ")", ")", "\n", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "=", "np", ".", "minimum", "(", "height", "-", "1.", ",", "np", ".", "maximum", "(", "0.", ",", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", ")", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_xyxy_to_image": [[69, 76], ["numpy.minimum", "numpy.minimum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["", "def", "clip_xyxy_to_image", "(", "x1", ",", "y1", ",", "x2", ",", "y2", ",", "height", ",", "width", ")", ":", "\n", "    ", "\"\"\"Clip coordinates to an image with the given height and width.\"\"\"", "\n", "x1", "=", "np", ".", "minimum", "(", "width", "-", "1.", ",", "np", ".", "maximum", "(", "0.", ",", "x1", ")", ")", "\n", "y1", "=", "np", ".", "minimum", "(", "height", "-", "1.", ",", "np", ".", "maximum", "(", "0.", ",", "y1", ")", ")", "\n", "x2", "=", "np", ".", "minimum", "(", "width", "-", "1.", ",", "np", ".", "maximum", "(", "0.", ",", "x2", ")", ")", "\n", "y2", "=", "np", ".", "minimum", "(", "height", "-", "1.", ",", "np", ".", "maximum", "(", "0.", ",", "y2", ")", ")", "\n", "return", "x1", ",", "y1", ",", "x2", ",", "y2", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.clip_tiled_boxes": [[78, 94], ["numpy.maximum", "numpy.maximum", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.minimum", "numpy.minimum"], "function", ["None"], ["", "def", "clip_tiled_boxes", "(", "boxes", ",", "im_shape", ")", ":", "\n", "    ", "\"\"\"Clip boxes to image boundaries. im_shape is [height, width] and boxes\n    has shape (N, 4 * num_tiled_boxes).\"\"\"", "\n", "assert", "boxes", ".", "shape", "[", "1", "]", "%", "4", "==", "0", ",", "'boxes.shape[1] is {:d}, but must be divisible by 4.'", ".", "format", "(", "\n", "boxes", ".", "shape", "[", "1", "]", "\n", ")", "\n", "# x1 >= 0", "\n", "boxes", "[", ":", ",", "0", ":", ":", "4", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "0", ":", ":", "4", "]", ",", "im_shape", "[", "1", "]", "-", "1", ")", ",", "0", ")", "\n", "# y1 >= 0", "\n", "boxes", "[", ":", ",", "1", ":", ":", "4", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "1", ":", ":", "4", "]", ",", "im_shape", "[", "0", "]", "-", "1", ")", ",", "0", ")", "\n", "# x2 < im_shape[1]", "\n", "boxes", "[", ":", ",", "2", ":", ":", "4", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "2", ":", ":", "4", "]", ",", "im_shape", "[", "1", "]", "-", "1", ")", ",", "0", ")", "\n", "# y2 < im_shape[0]", "\n", "boxes", "[", ":", ",", "3", ":", ":", "4", "]", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "boxes", "[", ":", ",", "3", ":", ":", "4", "]", ",", "im_shape", "[", "0", "]", "-", "1", ")", ",", "0", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.unique_boxes": [[95, 101], ["numpy.array", "numpy.round().dot", "numpy.unique", "numpy.sort", "numpy.round"], "function", ["None"], ["", "def", "unique_boxes", "(", "boxes", ",", "scale", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"Return indices of unique boxes.\"\"\"", "\n", "v", "=", "np", ".", "array", "(", "[", "1", ",", "1e3", ",", "1e6", ",", "1e9", "]", ")", "\n", "hashes", "=", "np", ".", "round", "(", "boxes", "*", "scale", ")", ".", "dot", "(", "v", ")", "\n", "_", ",", "index", "=", "np", ".", "unique", "(", "hashes", ",", "return_index", "=", "True", ")", "\n", "return", "np", ".", "sort", "(", "index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.filter_boxes": [[102, 113], ["numpy.where"], "function", ["None"], ["", "def", "filter_boxes", "(", "boxes", ",", "min_size", ")", ":", "\n", "    ", "\"\"\"\n    filter small boxes.\n    :param boxes: [N, 4* num_classes]\n    :param min_size:\n    :return: keep:\n    \"\"\"", "\n", "ws", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "+", "1", "\n", "hs", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "+", "1", "\n", "keep", "=", "np", ".", "where", "(", "(", "ws", ">=", "min_size", ")", "&", "(", "hs", ">=", "min_size", ")", ")", "[", "0", "]", "\n", "return", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.nonlinear_transform": [[114, 141], ["numpy.log", "numpy.log", "numpy.vstack().transpose", "numpy.vstack"], "function", ["None"], ["", "def", "nonlinear_transform", "(", "ex_rois", ",", "gt_rois", ")", ":", "\n", "    ", "\"\"\"\n    compute bounding box regression targets from ex_rois to gt_rois\n    :param ex_rois: [N, 4]\n    :param gt_rois: [N, 4]\n    :return: [N, 4]\n    \"\"\"", "\n", "assert", "ex_rois", ".", "shape", "[", "0", "]", "==", "gt_rois", ".", "shape", "[", "0", "]", ",", "'inconsistent rois number'", "\n", "\n", "ex_widths", "=", "ex_rois", "[", ":", ",", "2", "]", "-", "ex_rois", "[", ":", ",", "0", "]", "+", "1.0", "\n", "ex_heights", "=", "ex_rois", "[", ":", ",", "3", "]", "-", "ex_rois", "[", ":", ",", "1", "]", "+", "1.0", "\n", "ex_ctr_x", "=", "ex_rois", "[", ":", ",", "0", "]", "+", "0.5", "*", "(", "ex_widths", "-", "1.0", ")", "\n", "ex_ctr_y", "=", "ex_rois", "[", ":", ",", "1", "]", "+", "0.5", "*", "(", "ex_heights", "-", "1.0", ")", "\n", "\n", "gt_widths", "=", "gt_rois", "[", ":", ",", "2", "]", "-", "gt_rois", "[", ":", ",", "0", "]", "+", "1.0", "\n", "gt_heights", "=", "gt_rois", "[", ":", ",", "3", "]", "-", "gt_rois", "[", ":", ",", "1", "]", "+", "1.0", "\n", "gt_ctr_x", "=", "gt_rois", "[", ":", ",", "0", "]", "+", "0.5", "*", "(", "gt_widths", "-", "1.0", ")", "\n", "gt_ctr_y", "=", "gt_rois", "[", ":", ",", "1", "]", "+", "0.5", "*", "(", "gt_heights", "-", "1.0", ")", "\n", "\n", "targets_dx", "=", "(", "gt_ctr_x", "-", "ex_ctr_x", ")", "/", "(", "ex_widths", "+", "1e-14", ")", "\n", "targets_dy", "=", "(", "gt_ctr_y", "-", "ex_ctr_y", ")", "/", "(", "ex_heights", "+", "1e-14", ")", "\n", "targets_dw", "=", "np", ".", "log", "(", "gt_widths", "/", "ex_widths", ")", "\n", "targets_dh", "=", "np", ".", "log", "(", "gt_heights", "/", "ex_heights", ")", "\n", "\n", "targets", "=", "np", ".", "vstack", "(", "\n", "(", "targets_dx", ",", "targets_dy", ",", "targets_dw", ",", "targets_dh", ")", ")", ".", "transpose", "(", ")", "\n", "return", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.nonlinear_pred": [[143, 181], ["boxes.astype.astype", "numpy.zeros", "numpy.zeros", "numpy.exp", "numpy.exp"], "function", ["None"], ["", "def", "nonlinear_pred", "(", "boxes", ",", "box_deltas", ")", ":", "\n", "    ", "\"\"\"\n    Transform the set of class-agnostic boxes into class-specific boxes\n    by applying the predicted offsets (box_deltas)\n    :param boxes: !important [N 4]\n    :param box_deltas: [N, 4 * num_classes]\n    :return: [N 4 * num_classes]\n    \"\"\"", "\n", "if", "boxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "0", ",", "box_deltas", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "boxes", "=", "boxes", ".", "astype", "(", "np", ".", "float", ",", "copy", "=", "False", ")", "\n", "widths", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "+", "1.0", "\n", "heights", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "+", "1.0", "\n", "ctr_x", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "(", "widths", "-", "1.0", ")", "\n", "ctr_y", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "(", "heights", "-", "1.0", ")", "\n", "\n", "dx", "=", "box_deltas", "[", ":", ",", "0", ":", ":", "4", "]", "\n", "dy", "=", "box_deltas", "[", ":", ",", "1", ":", ":", "4", "]", "\n", "dw", "=", "box_deltas", "[", ":", ",", "2", ":", ":", "4", "]", "\n", "dh", "=", "box_deltas", "[", ":", ",", "3", ":", ":", "4", "]", "\n", "\n", "pred_ctr_x", "=", "dx", "*", "widths", "[", ":", ",", "np", ".", "newaxis", "]", "+", "ctr_x", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "pred_ctr_y", "=", "dy", "*", "heights", "[", ":", ",", "np", ".", "newaxis", "]", "+", "ctr_y", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "pred_w", "=", "np", ".", "exp", "(", "dw", ")", "*", "widths", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "pred_h", "=", "np", ".", "exp", "(", "dh", ")", "*", "heights", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "pred_boxes", "=", "np", ".", "zeros", "(", "box_deltas", ".", "shape", ")", "\n", "# x1", "\n", "pred_boxes", "[", ":", ",", "0", ":", ":", "4", "]", "=", "pred_ctr_x", "-", "0.5", "*", "(", "pred_w", "-", "1.0", ")", "\n", "# y1", "\n", "pred_boxes", "[", ":", ",", "1", ":", ":", "4", "]", "=", "pred_ctr_y", "-", "0.5", "*", "(", "pred_h", "-", "1.0", ")", "\n", "# x2", "\n", "pred_boxes", "[", ":", ",", "2", ":", ":", "4", "]", "=", "pred_ctr_x", "+", "0.5", "*", "(", "pred_w", "-", "1.0", ")", "\n", "# y2", "\n", "pred_boxes", "[", ":", ",", "3", ":", ":", "4", "]", "=", "pred_ctr_y", "+", "0.5", "*", "(", "pred_h", "-", "1.0", ")", "\n", "\n", "return", "pred_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.iou_transform": [[183, 187], ["None"], "function", ["None"], ["", "def", "iou_transform", "(", "ex_rois", ",", "gt_rois", ")", ":", "\n", "    ", "\"\"\" return bbox targets, IoU loss uses gt_rois as gt \"\"\"", "\n", "assert", "ex_rois", ".", "shape", "[", "0", "]", "==", "gt_rois", ".", "shape", "[", "0", "]", ",", "'inconsistent rois number'", "\n", "return", "gt_rois", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.iou_pred": [[189, 222], ["boxes.astype.astype", "numpy.zeros", "numpy.zeros"], "function", ["None"], ["", "def", "iou_pred", "(", "boxes", ",", "box_deltas", ")", ":", "\n", "    ", "\"\"\"\n    Transform the set of class-agnostic boxes into class-specific boxes\n    by applying the predicted offsets (box_deltas)\n    :param boxes: !important [N 4]\n    :param box_deltas: [N, 4 * num_classes]\n    :return: [N 4 * num_classes]\n    \"\"\"", "\n", "if", "boxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "0", ",", "box_deltas", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "", "boxes", "=", "boxes", ".", "astype", "(", "np", ".", "float", ",", "copy", "=", "False", ")", "\n", "x1", "=", "boxes", "[", ":", ",", "0", "]", "\n", "y1", "=", "boxes", "[", ":", ",", "1", "]", "\n", "x2", "=", "boxes", "[", ":", ",", "2", "]", "\n", "y2", "=", "boxes", "[", ":", ",", "3", "]", "\n", "\n", "dx1", "=", "box_deltas", "[", ":", ",", "0", ":", ":", "4", "]", "\n", "dy1", "=", "box_deltas", "[", ":", ",", "1", ":", ":", "4", "]", "\n", "dx2", "=", "box_deltas", "[", ":", ",", "2", ":", ":", "4", "]", "\n", "dy2", "=", "box_deltas", "[", ":", ",", "3", ":", ":", "4", "]", "\n", "\n", "pred_boxes", "=", "np", ".", "zeros", "(", "box_deltas", ".", "shape", ")", "\n", "# x1", "\n", "pred_boxes", "[", ":", ",", "0", ":", ":", "4", "]", "=", "dx1", "+", "x1", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "# y1", "\n", "pred_boxes", "[", ":", ",", "1", ":", ":", "4", "]", "=", "dy1", "+", "y1", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "# x2", "\n", "pred_boxes", "[", ":", ",", "2", ":", ":", "4", "]", "=", "dx2", "+", "x2", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "# y2", "\n", "pred_boxes", "[", ":", ",", "3", ":", ":", "4", "]", "=", "dy2", "+", "y2", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "return", "pred_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.xywh_to_xyxy": [[224, 240], ["isinstance", "isinstance", "len", "numpy.maximum", "numpy.maximum", "numpy.hstack", "TypeError", "numpy.maximum"], "function", ["None"], ["", "def", "xywh_to_xyxy", "(", "xywh", ")", ":", "\n", "    ", "\"\"\"Convert [x1 y1 w h] box format to [x1 y1 x2 y2] format.\"\"\"", "\n", "if", "isinstance", "(", "xywh", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "# Single box given as a list of coordinates", "\n", "        ", "assert", "len", "(", "xywh", ")", "==", "4", "\n", "x1", ",", "y1", "=", "xywh", "[", "0", "]", ",", "xywh", "[", "1", "]", "\n", "x2", "=", "x1", "+", "np", ".", "maximum", "(", "0.", ",", "xywh", "[", "2", "]", "-", "1.", ")", "\n", "y2", "=", "y1", "+", "np", ".", "maximum", "(", "0.", ",", "xywh", "[", "3", "]", "-", "1.", ")", "\n", "return", "(", "x1", ",", "y1", ",", "x2", ",", "y2", ")", "\n", "", "elif", "isinstance", "(", "xywh", ",", "np", ".", "ndarray", ")", ":", "\n", "# Multiple boxes given as a 2D ndarray", "\n", "        ", "return", "np", ".", "hstack", "(", "\n", "(", "xywh", "[", ":", ",", "0", ":", "2", "]", ",", "xywh", "[", ":", ",", "0", ":", "2", "]", "+", "np", ".", "maximum", "(", "0", ",", "xywh", "[", ":", ",", "2", ":", "4", "]", "-", "1", ")", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'Argument xywh must be a list, tuple, or numpy array.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.xyxy_to_xywh": [[241, 255], ["isinstance", "isinstance", "len", "numpy.hstack", "TypeError"], "function", ["None"], ["", "", "def", "xyxy_to_xywh", "(", "xyxy", ")", ":", "\n", "    ", "\"\"\"Convert [x1 y1 x2 y2] box format to [x1 y1 w h] format.\"\"\"", "\n", "if", "isinstance", "(", "xyxy", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "# Single box given as a list of coordinates", "\n", "        ", "assert", "len", "(", "xyxy", ")", "==", "4", "\n", "x1", ",", "y1", "=", "xyxy", "[", "0", "]", ",", "xyxy", "[", "1", "]", "\n", "w", "=", "xyxy", "[", "2", "]", "-", "x1", "+", "1", "\n", "h", "=", "xyxy", "[", "3", "]", "-", "y1", "+", "1", "\n", "return", "(", "x1", ",", "y1", ",", "w", ",", "h", ")", "\n", "", "elif", "isinstance", "(", "xyxy", ",", "np", ".", "ndarray", ")", ":", "\n", "# Multiple boxes given as a 2D ndarray", "\n", "        ", "return", "np", ".", "hstack", "(", "(", "xyxy", "[", ":", ",", "0", ":", "2", "]", ",", "xyxy", "[", ":", ",", "2", ":", "4", "]", "-", "xyxy", "[", ":", ",", "0", ":", "2", "]", "+", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'Argument xyxy must be a list, tuple, or numpy array.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.flip_boxes": [[256, 262], ["boxes.copy"], "function", ["None"], ["", "", "def", "flip_boxes", "(", "boxes", ",", "im_width", ")", ":", "\n", "    ", "\"\"\"Flip boxes horizontally.\"\"\"", "\n", "boxes_flipped", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes_flipped", "[", ":", ",", "0", ":", ":", "4", "]", "=", "im_width", "-", "boxes", "[", ":", ",", "2", ":", ":", "4", "]", "-", "1", "\n", "boxes_flipped", "[", ":", ",", "2", ":", ":", "4", "]", "=", "im_width", "-", "boxes", "[", ":", ",", "0", ":", ":", "4", "]", "-", "1", "\n", "return", "boxes_flipped", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.aspect_ratio": [[263, 269], ["boxes.copy"], "function", ["None"], ["", "def", "aspect_ratio", "(", "boxes", ",", "aspect_ratio", ")", ":", "\n", "    ", "\"\"\"Perform width-relative aspect ratio transformation.\"\"\"", "\n", "boxes_ar", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes_ar", "[", ":", ",", "0", ":", ":", "4", "]", "=", "aspect_ratio", "*", "boxes", "[", ":", ",", "0", ":", ":", "4", "]", "\n", "boxes_ar", "[", ":", ",", "2", ":", ":", "4", "]", "=", "aspect_ratio", "*", "boxes", "[", ":", ",", "2", ":", ":", "4", "]", "\n", "return", "boxes_ar", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.soft_nms": [[271, 289], ["cython_nms.soft_nms", "numpy.ascontiguousarray", "numpy.float32", "numpy.float32", "numpy.float32", "numpy.uint8"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.soft_nms"], ["", "def", "soft_nms", "(", "\n", "dets", ",", "sigma", "=", "0.5", ",", "overlap_thresh", "=", "0.3", ",", "score_thresh", "=", "0.001", ",", "method", "=", "'linear'", "\n", ")", ":", "\n", "    ", "\"\"\"Apply the soft NMS algorithm from https://arxiv.org/abs/1704.04503.\"\"\"", "\n", "if", "dets", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "dets", ",", "[", "]", "\n", "\n", "", "methods", "=", "{", "'hard'", ":", "0", ",", "'linear'", ":", "1", ",", "'gaussian'", ":", "2", "}", "\n", "assert", "method", "in", "methods", ",", "'Unknown soft_nms method: {}'", ".", "format", "(", "method", ")", "\n", "\n", "dets", ",", "keep", "=", "cython_nms", ".", "soft_nms", "(", "\n", "np", ".", "ascontiguousarray", "(", "dets", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "np", ".", "float32", "(", "sigma", ")", ",", "\n", "np", ".", "float32", "(", "overlap_thresh", ")", ",", "\n", "np", ".", "float32", "(", "score_thresh", ")", ",", "\n", "np", ".", "uint8", "(", "methods", "[", "method", "]", ")", "\n", ")", "\n", "return", "dets", ",", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_transform": [[290, 331], ["boxes.astype.astype", "numpy.minimum", "numpy.minimum", "numpy.zeros", "numpy.zeros", "numpy.log", "numpy.log", "numpy.exp", "numpy.exp"], "function", ["None"], ["", "def", "bbox_transform", "(", "boxes", ",", "deltas", ",", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", ":", "\n", "    ", "\"\"\"Forward transform that maps proposal boxes to predicted ground-truth\n    boxes using bounding-box regression deltas. See bbox_transform_inv for a\n    description of the weights argument.\n    \"\"\"", "\n", "if", "boxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "0", ",", "deltas", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "deltas", ".", "dtype", ")", "\n", "\n", "", "boxes", "=", "boxes", ".", "astype", "(", "deltas", ".", "dtype", ",", "copy", "=", "False", ")", "\n", "\n", "widths", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "+", "1.0", "\n", "heights", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "+", "1.0", "\n", "ctr_x", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "widths", "\n", "ctr_y", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "heights", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", "=", "weights", "\n", "dx", "=", "deltas", "[", ":", ",", "0", ":", ":", "4", "]", "/", "wx", "\n", "dy", "=", "deltas", "[", ":", ",", "1", ":", ":", "4", "]", "/", "wy", "\n", "dw", "=", "deltas", "[", ":", ",", "2", ":", ":", "4", "]", "/", "ww", "\n", "dh", "=", "deltas", "[", ":", ",", "3", ":", ":", "4", "]", "/", "wh", "\n", "\n", "# Prevent sending too large values into np.exp()", "\n", "dw", "=", "np", ".", "minimum", "(", "dw", ",", "np", ".", "log", "(", "1000.", "/", "16.", ")", ")", "\n", "dh", "=", "np", ".", "minimum", "(", "dh", ",", "np", ".", "log", "(", "1000.", "/", "16.", ")", ")", "\n", "\n", "pred_ctr_x", "=", "dx", "*", "widths", "[", ":", ",", "np", ".", "newaxis", "]", "+", "ctr_x", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "pred_ctr_y", "=", "dy", "*", "heights", "[", ":", ",", "np", ".", "newaxis", "]", "+", "ctr_y", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "pred_w", "=", "np", ".", "exp", "(", "dw", ")", "*", "widths", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "pred_h", "=", "np", ".", "exp", "(", "dh", ")", "*", "heights", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "pred_boxes", "=", "np", ".", "zeros", "(", "deltas", ".", "shape", ",", "dtype", "=", "deltas", ".", "dtype", ")", "\n", "# x1", "\n", "pred_boxes", "[", ":", ",", "0", ":", ":", "4", "]", "=", "pred_ctr_x", "-", "0.5", "*", "pred_w", "\n", "# y1", "\n", "pred_boxes", "[", ":", ",", "1", ":", ":", "4", "]", "=", "pred_ctr_y", "-", "0.5", "*", "pred_h", "\n", "# x2 (note: \"- 1\" is correct; don't be fooled by the asymmetry)", "\n", "pred_boxes", "[", ":", ",", "2", ":", ":", "4", "]", "=", "pred_ctr_x", "+", "0.5", "*", "pred_w", "-", "1", "\n", "# y2 (note: \"- 1\" is correct; don't be fooled by the asymmetry)", "\n", "pred_boxes", "[", ":", ",", "3", ":", ":", "4", "]", "=", "pred_ctr_y", "+", "0.5", "*", "pred_h", "-", "1", "\n", "\n", "return", "pred_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_transform_inv": [[332, 364], ["numpy.vstack().transpose", "numpy.log", "numpy.log", "numpy.vstack"], "function", ["None"], ["", "def", "bbox_transform_inv", "(", "boxes", ",", "gt_boxes", ",", "weights", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ")", ":", "\n", "    ", "\"\"\"Inverse transform that computes target bounding-box regression deltas\n    given proposal boxes and ground-truth boxes. The weights argument should be\n    a 4-tuple of multiplicative weights that are applied to the regression\n    target.\n\n    In older versions of this code (and in py-faster-rcnn), the weights were set\n    such that the regression deltas would have unit standard deviation on the\n    training dataset. Presently, rather than computing these statistics exactly,\n    we use a fixed set of weights (10., 10., 5., 5.) by default. These are\n    approximately the weights one would get from COCO using the previous unit\n    stdev heuristic.\n    \"\"\"", "\n", "ex_widths", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "+", "1.0", "\n", "ex_heights", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "+", "1.0", "\n", "ex_ctr_x", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "ex_widths", "\n", "ex_ctr_y", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "ex_heights", "\n", "\n", "gt_widths", "=", "gt_boxes", "[", ":", ",", "2", "]", "-", "gt_boxes", "[", ":", ",", "0", "]", "+", "1.0", "\n", "gt_heights", "=", "gt_boxes", "[", ":", ",", "3", "]", "-", "gt_boxes", "[", ":", ",", "1", "]", "+", "1.0", "\n", "gt_ctr_x", "=", "gt_boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "gt_widths", "\n", "gt_ctr_y", "=", "gt_boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "gt_heights", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", "=", "weights", "\n", "targets_dx", "=", "wx", "*", "(", "gt_ctr_x", "-", "ex_ctr_x", ")", "/", "ex_widths", "\n", "targets_dy", "=", "wy", "*", "(", "gt_ctr_y", "-", "ex_ctr_y", ")", "/", "ex_heights", "\n", "targets_dw", "=", "ww", "*", "np", ".", "log", "(", "gt_widths", "/", "ex_widths", ")", "\n", "targets_dh", "=", "wh", "*", "np", ".", "log", "(", "gt_heights", "/", "ex_heights", ")", "\n", "\n", "targets", "=", "np", ".", "vstack", "(", "(", "targets_dx", ",", "targets_dy", ",", "targets_dw", ",", "\n", "targets_dh", ")", ")", ".", "transpose", "(", ")", "\n", "return", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.expand_boxes": [[365, 382], ["numpy.zeros"], "function", ["None"], ["", "def", "expand_boxes", "(", "boxes", ",", "scale", ")", ":", "\n", "    ", "\"\"\"Expand an array of boxes by a given scale.\"\"\"", "\n", "w_half", "=", "(", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "*", ".5", "\n", "h_half", "=", "(", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", ")", "*", ".5", "\n", "x_c", "=", "(", "boxes", "[", ":", ",", "2", "]", "+", "boxes", "[", ":", ",", "0", "]", ")", "*", ".5", "\n", "y_c", "=", "(", "boxes", "[", ":", ",", "3", "]", "+", "boxes", "[", ":", ",", "1", "]", ")", "*", ".5", "\n", "\n", "w_half", "*=", "scale", "\n", "h_half", "*=", "scale", "\n", "\n", "boxes_exp", "=", "np", ".", "zeros", "(", "boxes", ".", "shape", ")", "\n", "boxes_exp", "[", ":", ",", "0", "]", "=", "x_c", "-", "w_half", "\n", "boxes_exp", "[", ":", ",", "2", "]", "=", "x_c", "+", "w_half", "\n", "boxes_exp", "[", ":", ",", "1", "]", "=", "y_c", "-", "h_half", "\n", "boxes_exp", "[", ":", ",", "3", "]", "=", "y_c", "+", "h_half", "\n", "\n", "return", "boxes_exp", "\n", "", ""]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.compute_bbox_regression_targets": [[28, 63], ["rois.astype.astype", "bbox_transform.bbox_overlaps", "bbox_transform.bbox_overlaps.argmax", "numpy.zeros", "bbox_transform.bbox_transform", "len", "len", "print", "numpy.where", "len", "print", "numpy.where", "upsnet.config.config.config"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_transform"], ["def", "compute_bbox_regression_targets", "(", "rois", ",", "overlaps", ",", "labels", ")", ":", "\n", "    ", "\"\"\"\n    given rois, overlaps, gt labels, compute bounding box regression targets\n    :param rois: roidb[i]['boxes'] k * 4\n    :param overlaps: roidb[i]['max_overlaps'] k * 1\n    :param labels: roidb[i]['max_classes'] k * 1\n    :return: targets[i][class, dx, dy, dw, dh] k * 5\n    \"\"\"", "\n", "# Ensure ROIs are floats", "\n", "rois", "=", "rois", ".", "astype", "(", "np", ".", "float", ",", "copy", "=", "False", ")", "\n", "\n", "# Sanity check", "\n", "if", "len", "(", "rois", ")", "!=", "len", "(", "overlaps", ")", ":", "\n", "        ", "print", "(", "'bbox regression: this should not happen'", ")", "\n", "\n", "# Indices of ground-truth ROIs", "\n", "", "gt_inds", "=", "np", ".", "where", "(", "overlaps", "==", "1", ")", "[", "0", "]", "\n", "if", "len", "(", "gt_inds", ")", "==", "0", ":", "\n", "        ", "print", "(", "'something wrong : zero ground truth rois'", ")", "\n", "# Indices of examples for which we try to make predictions", "\n", "", "ex_inds", "=", "np", ".", "where", "(", "overlaps", ">=", "config", ".", "train", ".", "bbox_regression_thresh", ")", "[", "0", "]", "\n", "\n", "# Get IoU overlap between each ex ROI and gt ROI", "\n", "ex_gt_overlaps", "=", "bbox_overlaps", "(", "rois", "[", "ex_inds", ",", ":", "]", ",", "rois", "[", "gt_inds", ",", ":", "]", ")", "\n", "\n", "# Find which gt ROI each ex ROI has max overlap with:", "\n", "# this will be the ex ROI's gt target", "\n", "gt_assignment", "=", "ex_gt_overlaps", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "gt_rois", "=", "rois", "[", "gt_inds", "[", "gt_assignment", "]", ",", ":", "]", "\n", "ex_rois", "=", "rois", "[", "ex_inds", ",", ":", "]", "\n", "\n", "targets", "=", "np", ".", "zeros", "(", "(", "rois", ".", "shape", "[", "0", "]", ",", "5", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "targets", "[", "ex_inds", ",", "0", "]", "=", "labels", "[", "ex_inds", "]", "\n", "targets", "[", "ex_inds", ",", "1", ":", "]", "=", "bbox_transform", "(", "ex_rois", ",", "gt_rois", ")", "\n", "return", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.compute_mask_and_label": [[64, 108], ["numpy.zeros", "numpy.zeros", "range", "numpy.unique", "numpy.zeros", "numpy.where", "cv2.resize", "math.floor", "numpy.where", "numpy.min", "numpy.min", "numpy.max", "numpy.max", "max", "max", "min", "min", "int", "int", "int", "int", "int", "int", "int", "int"], "function", ["None"], ["", "def", "compute_mask_and_label", "(", "ex_rois", ",", "ex_labels", ",", "ins_seg", ",", "class_id", ")", ":", "\n", "# assert os.path.exists(seg_gt), 'Path does not exist: {}'.format(seg_gt)", "\n", "# im = Image.open(seg_gt)", "\n", "# pixel = list(im.getdata())", "\n", "# pixel = np.array(pixel).reshape([im.size[1], im.size[0]])", "\n", "    ", "rois", "=", "ex_rois", "\n", "n_rois", "=", "ex_rois", ".", "shape", "[", "0", "]", "\n", "label", "=", "ex_labels", "\n", "mask_target", "=", "np", ".", "zeros", "(", "(", "n_rois", ",", "28", ",", "28", ")", ",", "dtype", "=", "np", ".", "int8", ")", "\n", "mask_label", "=", "np", ".", "zeros", "(", "(", "n_rois", ")", ",", "dtype", "=", "np", ".", "int8", ")", "\n", "for", "n", "in", "range", "(", "n_rois", ")", ":", "\n", "        ", "target", "=", "ins_seg", "[", "int", "(", "rois", "[", "n", ",", "1", "]", ")", ":", "int", "(", "rois", "[", "n", ",", "3", "]", ")", ",", "int", "(", "rois", "[", "n", ",", "0", "]", ")", ":", "int", "(", "rois", "[", "n", ",", "2", "]", ")", "]", "\n", "ids", "=", "np", ".", "unique", "(", "target", ")", "\n", "ins_id", "=", "0", "\n", "max_count", "=", "0", "\n", "for", "id", "in", "ids", ":", "\n", "            ", "if", "math", ".", "floor", "(", "id", "/", "1000", ")", "==", "class_id", "[", "int", "(", "label", "[", "int", "(", "n", ")", "]", ")", "]", ":", "\n", "                ", "px", "=", "np", ".", "where", "(", "ins_seg", "==", "int", "(", "id", ")", ")", "\n", "x_min", "=", "np", ".", "min", "(", "px", "[", "1", "]", ")", "\n", "y_min", "=", "np", ".", "min", "(", "px", "[", "0", "]", ")", "\n", "x_max", "=", "np", ".", "max", "(", "px", "[", "1", "]", ")", "\n", "y_max", "=", "np", ".", "max", "(", "px", "[", "0", "]", ")", "\n", "x1", "=", "max", "(", "rois", "[", "n", ",", "0", "]", ",", "x_min", ")", "\n", "y1", "=", "max", "(", "rois", "[", "n", ",", "1", "]", ",", "y_min", ")", "\n", "x2", "=", "min", "(", "rois", "[", "n", ",", "2", "]", ",", "x_max", ")", "\n", "y2", "=", "min", "(", "rois", "[", "n", ",", "3", "]", ",", "y_max", ")", "\n", "iou", "=", "(", "x2", "-", "x1", ")", "*", "(", "y2", "-", "y1", ")", "\n", "iou", "=", "iou", "/", "(", "(", "rois", "[", "n", ",", "2", "]", "-", "rois", "[", "n", ",", "0", "]", ")", "*", "(", "rois", "[", "n", ",", "3", "]", "-", "rois", "[", "n", ",", "1", "]", ")", "\n", "+", "(", "x_max", "-", "x_min", ")", "*", "(", "y_max", "-", "y_min", ")", "-", "iou", ")", "\n", "if", "iou", ">", "max_count", ":", "\n", "                    ", "ins_id", "=", "id", "\n", "max_count", "=", "iou", "\n", "\n", "", "", "", "if", "max_count", "==", "0", ":", "\n", "            ", "continue", "\n", "# print max_count", "\n", "", "mask", "=", "np", ".", "zeros", "(", "target", ".", "shape", ")", "\n", "idx", "=", "np", ".", "where", "(", "target", "==", "ins_id", ")", "\n", "mask", "[", "idx", "]", "=", "1", "\n", "mask", "=", "cv2", ".", "resize", "(", "mask", ",", "(", "28", ",", "28", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "\n", "mask_target", "[", "n", "]", "=", "mask", "\n", "mask_label", "[", "n", "]", "=", "label", "[", "int", "(", "n", ")", "]", "\n", "", "return", "mask_target", ",", "mask_label", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.compute_bbox_mask_targets_and_label": [[109, 143], ["rois.astype.astype", "bbox_transform.bbox_overlaps", "bbox_transform.bbox_overlaps.argmax", "bbox_regression.compute_mask_and_label", "len", "len", "print", "numpy.where", "len", "print", "numpy.where"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_transform.bbox_overlaps", "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.compute_mask_and_label"], ["", "def", "compute_bbox_mask_targets_and_label", "(", "rois", ",", "overlaps", ",", "labels", ",", "seg", ",", "class_id", ")", ":", "\n", "    ", "\"\"\"\n    given rois, overlaps, gt labels, seg, compute bounding box mask targets\n    :param rois: roidb[i]['boxes'] k * 4\n    :param overlaps: roidb[i]['max_overlaps'] k * 1\n    :param labels: roidb[i]['max_classes'] k * 1\n    :return: targets[i][class, dx, dy, dw, dh] k * 5\n    \"\"\"", "\n", "# Ensure ROIs are floats", "\n", "rois", "=", "rois", ".", "astype", "(", "np", ".", "float", ",", "copy", "=", "False", ")", "\n", "\n", "# Sanity check", "\n", "if", "len", "(", "rois", ")", "!=", "len", "(", "overlaps", ")", ":", "\n", "        ", "print", "(", "'bbox regression: this should not happen'", ")", "\n", "\n", "# Indices of ground-truth ROIs", "\n", "", "gt_inds", "=", "np", ".", "where", "(", "overlaps", "==", "1", ")", "[", "0", "]", "\n", "if", "len", "(", "gt_inds", ")", "==", "0", ":", "\n", "        ", "print", "(", "'something wrong : zero ground truth rois'", ")", "\n", "# Indices of examples for which we try to make predictions", "\n", "", "ex_inds", "=", "np", ".", "where", "(", "overlaps", ">=", "config", ".", "train", ".", "bbox_regression_thresh", ")", "[", "0", "]", "\n", "\n", "# Get IoU overlap between each ex ROI and gt ROI", "\n", "ex_gt_overlaps", "=", "bbox_overlaps", "(", "rois", "[", "ex_inds", ",", ":", "]", ",", "rois", "[", "gt_inds", ",", ":", "]", ")", "\n", "\n", "\n", "# Find which gt ROI each ex ROI has max overlap with:", "\n", "# this will be the ex ROI's gt target", "\n", "gt_assignment", "=", "ex_gt_overlaps", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "gt_rois", "=", "rois", "[", "gt_inds", "[", "gt_assignment", "]", ",", ":", "]", "\n", "ex_rois", "=", "rois", "[", "ex_inds", ",", ":", "]", "\n", "\n", "mask_targets", ",", "mask_label", "=", "compute_mask_and_label", "(", "ex_rois", ",", "labels", "[", "ex_inds", "]", ",", "seg", ",", "class_id", ")", "\n", "return", "mask_targets", ",", "mask_label", ",", "ex_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.add_bbox_regression_targets": [[145, 203], ["print", "len", "range", "print", "print", "print", "print", "print", "print", "range", "len", "bbox_regression.compute_bbox_regression_targets", "numpy.tile", "numpy.tile", "numpy.zeros", "numpy.zeros", "range", "numpy.sqrt", "means[].mean", "stds[].mean", "range", "np.tile.ravel", "np.sqrt.ravel", "numpy.array", "numpy.array", "numpy.zeros", "range", "numpy.where", "targets[].sum", "numpy.where", "numpy.where", "numpy.where"], "function", ["home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.compute_bbox_regression_targets"], ["", "def", "add_bbox_regression_targets", "(", "roidb", ")", ":", "\n", "    ", "\"\"\"\n    given roidb, add ['bbox_targets'] and normalize bounding box regression targets\n    :param roidb: roidb to be processed. must have gone through imdb.prepare_roidb\n    :return: means, std variances of targets\n    \"\"\"", "\n", "print", "(", "'add bounding box regression targets'", ")", "\n", "assert", "len", "(", "roidb", ")", ">", "0", "\n", "assert", "'max_classes'", "in", "roidb", "[", "0", "]", "\n", "\n", "num_images", "=", "len", "(", "roidb", ")", "\n", "num_classes", "=", "2", "if", "config", ".", "network", ".", "class_agnostic", "else", "roidb", "[", "0", "]", "[", "'gt_overlaps'", "]", ".", "shape", "[", "1", "]", "\n", "\n", "for", "im_i", "in", "range", "(", "num_images", ")", ":", "\n", "        ", "rois", "=", "roidb", "[", "im_i", "]", "[", "'boxes'", "]", "\n", "max_overlaps", "=", "roidb", "[", "im_i", "]", "[", "'max_overlaps'", "]", "\n", "max_classes", "=", "roidb", "[", "im_i", "]", "[", "'max_classes'", "]", "\n", "roidb", "[", "im_i", "]", "[", "'bbox_targets'", "]", "=", "compute_bbox_regression_targets", "(", "rois", ",", "max_overlaps", ",", "max_classes", ",", "config", ")", "\n", "\n", "", "if", "config", ".", "train", ".", "bbox_normalization_precomputed", ":", "\n", "# use fixed / precomputed means and stds instead of empirical values", "\n", "        ", "means", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "config", ".", "train", ".", "bbox_means", ")", ",", "(", "num_classes", ",", "1", ")", ")", "\n", "stds", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "config", ".", "train", ".", "bbox_stds", ")", ",", "(", "num_classes", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "# compute mean, std values", "\n", "        ", "class_counts", "=", "np", ".", "zeros", "(", "(", "num_classes", ",", "1", ")", ")", "+", "1e-14", "\n", "sums", "=", "np", ".", "zeros", "(", "(", "num_classes", ",", "4", ")", ")", "\n", "squared_sums", "=", "np", ".", "zeros", "(", "(", "num_classes", ",", "4", ")", ")", "\n", "for", "im_i", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "targets", "=", "roidb", "[", "im_i", "]", "[", "'bbox_targets'", "]", "\n", "for", "cls", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "                ", "cls_indexes", "=", "np", ".", "where", "(", "targets", "[", ":", ",", "0", "]", ">", "0", ")", "[", "0", "]", "if", "config", ".", "network", ".", "class_agnostic", "else", "np", ".", "where", "(", "targets", "[", ":", ",", "0", "]", "==", "cls", ")", "[", "0", "]", "\n", "if", "cls_indexes", ".", "size", ">", "0", ":", "\n", "                    ", "class_counts", "[", "cls", "]", "+=", "cls_indexes", ".", "size", "\n", "sums", "[", "cls", ",", ":", "]", "+=", "targets", "[", "cls_indexes", ",", "1", ":", "]", ".", "sum", "(", "axis", "=", "0", ")", "\n", "squared_sums", "[", "cls", ",", ":", "]", "+=", "(", "targets", "[", "cls_indexes", ",", "1", ":", "]", "**", "2", ")", ".", "sum", "(", "axis", "=", "0", ")", "\n", "\n", "", "", "", "means", "=", "sums", "/", "class_counts", "\n", "# var(x) = E(x^2) - E(x)^2", "\n", "stds", "=", "np", ".", "sqrt", "(", "squared_sums", "/", "class_counts", "-", "means", "**", "2", ")", "\n", "\n", "", "print", "(", "'bbox target means:'", ")", "\n", "print", "(", "means", ")", "\n", "print", "(", "means", "[", "1", ":", ",", ":", "]", ".", "mean", "(", "axis", "=", "0", ")", ")", "# ignore bg class", "\n", "print", "(", "'bbox target stdevs:'", ")", "\n", "print", "(", "stds", ")", "\n", "print", "(", "stds", "[", "1", ":", ",", ":", "]", ".", "mean", "(", "axis", "=", "0", ")", ")", "# ignore bg class", "\n", "\n", "\n", "# normalized targets", "\n", "for", "im_i", "in", "range", "(", "num_images", ")", ":", "\n", "        ", "targets", "=", "roidb", "[", "im_i", "]", "[", "'bbox_targets'", "]", "\n", "for", "cls", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "            ", "cls_indexes", "=", "np", ".", "where", "(", "targets", "[", ":", ",", "0", "]", ">", "0", ")", "if", "config", ".", "network", ".", "class_agnostic", "else", "np", ".", "where", "(", "targets", "[", ":", ",", "0", "]", "==", "cls", ")", "[", "0", "]", "\n", "roidb", "[", "im_i", "]", "[", "'bbox_targets'", "]", "[", "cls_indexes", ",", "1", ":", "]", "-=", "means", "[", "cls", ",", ":", "]", "\n", "roidb", "[", "im_i", "]", "[", "'bbox_targets'", "]", "[", "cls_indexes", ",", "1", ":", "]", "/=", "stds", "[", "cls", ",", ":", "]", "\n", "\n", "", "", "return", "means", ".", "ravel", "(", ")", ",", "stds", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uber-research_UPSNet.bbox.bbox_regression.expand_bbox_regression_targets": [[205, 226], ["numpy.zeros", "numpy.zeros", "numpy.where", "int", "int"], "function", ["None"], ["", "def", "expand_bbox_regression_targets", "(", "bbox_targets_data", ",", "num_classes", ")", ":", "\n", "    ", "\"\"\"\n    expand from 5 to 4 * num_classes; only the right class has non-zero bbox regression targets\n    :param bbox_targets_data: [k * 5]\n    :param num_classes: number of classes\n    :return: bbox target processed [k * 4 num_classes]\n    bbox_weights ! only foreground boxes have bbox regression computation!\n    \"\"\"", "\n", "classes", "=", "bbox_targets_data", "[", ":", ",", "0", "]", "\n", "if", "config", ".", "network", ".", "class_agnostic", ":", "\n", "        ", "num_classes", "=", "2", "\n", "", "bbox_targets", "=", "np", ".", "zeros", "(", "(", "classes", ".", "size", ",", "4", "*", "num_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "bbox_weights", "=", "np", ".", "zeros", "(", "bbox_targets", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "indexes", "=", "np", ".", "where", "(", "classes", ">", "0", ")", "[", "0", "]", "\n", "for", "index", "in", "indexes", ":", "\n", "        ", "cls", "=", "classes", "[", "index", "]", "\n", "start", "=", "int", "(", "4", "*", "1", "if", "cls", ">", "0", "else", "0", ")", "if", "config", ".", "network", ".", "class_agnostic", "else", "int", "(", "4", "*", "cls", ")", "\n", "end", "=", "start", "+", "4", "\n", "bbox_targets", "[", "index", ",", "start", ":", "end", "]", "=", "bbox_targets_data", "[", "index", ",", "1", ":", "]", "\n", "bbox_weights", "[", "index", ",", "start", ":", "end", "]", "=", "config", ".", "train", ".", "bbox_weights", "\n", "", "return", "bbox_targets", ",", "bbox_weights", "\n", "\n"]]}