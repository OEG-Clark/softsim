{"home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DGENodeGenerator.__init__": [[23, 45], ["numpy.random.default_rng", "stellargraph.mapper.DirectedGraphSAGENodeGenerator.__init__", "utils.sample_relatives", "sgmods.HONGraphSAGENodeGenerator", "range"], "methods", ["home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DirectedBreadthFirstNeighboursSparse.__init__", "home.repos.pwc.inspect_result.sjkrieg_dge.None.utils.sample_relatives"], ["    ", "def", "__init__", "(", "self", ",", "\n", "G", ",", "\n", "n_learners", ",", "\n", "batch_size", ",", "\n", "in_samples", ",", "\n", "out_samples", ",", "\n", "seed", "=", "None", ",", "\n", "name", "=", "None", ",", "\n", "weighted", "=", "False", ",", "\n", "n2fam", "=", "None", ",", "\n", "N_k1", "=", "None", "\n", ")", ":", "\n", "\n", "        ", "self", ".", "rng", "=", "np", ".", "random", ".", "default_rng", "(", "seed", ")", "\n", "super", "(", ")", ".", "__init__", "(", "G", ",", "batch_size", ",", "in_samples", ",", "out_samples", ",", "seed", ",", "name", ",", "weighted", ")", "\n", "\n", "self", ".", "n_learners", "=", "n_learners", "\n", "self", ".", "n2fam", "=", "n2fam", "\n", "\n", "# stuff to override", "\n", "self", ".", "relative_samples", "=", "sample_relatives", "(", "N_k1", ",", "self", ".", "n_learners", ",", "self", ".", "n2fam", ",", "self", ".", "rng", ")", "\n", "self", ".", "generators", "=", "[", "HONGraphSAGENodeGenerator", "(", "G", ",", "batch_size", ",", "in_samples", ",", "out_samples", ",", "seed", "=", "seed", ",", "weighted", "=", "weighted", ")", "for", "_", "in", "range", "(", "self", ".", "n_learners", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DGENodeGenerator.sample_features": [[46, 48], ["gen.sample_features", "enumerate"], "methods", ["home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DGENodeGenerator.sample_features"], ["", "def", "sample_features", "(", "self", ",", "head_nodes", ",", "batch_num", ")", ":", "\n", "        ", "return", "[", "gen", ".", "sample_features", "(", "self", ".", "relative_samples", "[", "i", "]", "[", "head_nodes", "]", ",", "batch_num", ")", "for", "i", ",", "gen", "in", "enumerate", "(", "self", ".", "generators", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.HONGraphSAGENodeGenerator.__init__": [[52, 65], ["stellargraph.mapper.DirectedGraphSAGENodeGenerator.__init__", "sgmods.DirectedBreadthFirstNeighboursSparse"], "methods", ["home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DirectedBreadthFirstNeighboursSparse.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "G", ",", "\n", "batch_size", ",", "\n", "in_samples", ",", "\n", "out_samples", ",", "\n", "seed", "=", "None", ",", "\n", "name", "=", "None", ",", "\n", "weighted", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "G", ",", "batch_size", ",", "in_samples", ",", "out_samples", ",", "seed", ",", "name", ",", "weighted", ")", "\n", "\n", "self", ".", "sampler", "=", "DirectedBreadthFirstNeighboursSparse", "(", "\n", "G", ",", "graph_schema", "=", "self", ".", "schema", ",", "seed", "=", "seed", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.StellarGraphMod.node_features": [[133, 136], ["sgmods.extract_element_features_mod"], "methods", ["home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.extract_element_features_mod"], ["    ", "def", "node_features", "(", "self", ",", "nodes", "=", "None", ",", "node_type", "=", "None", ",", "use_ilocs", "=", "False", ")", ":", "\n", "        ", "return", "extract_element_features_mod", "(", "\n", "self", ".", "_nodes", ",", "self", ".", "unique_node_type", ",", "\"node\"", ",", "nodes", ",", "node_type", ",", "use_ilocs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DirectedGraphSAGEMod._node_model": [[140, 160], ["sgmods.DirectedGraphSAGEMod.", "tensorflow.keras.layers.Input"], "methods", ["None"], ["    ", "def", "_node_model", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Builds a GraphSAGE model for node prediction\n\n        Returns:\n            tuple: (x_inp, x_out) where ``x_inp`` is a list of Keras input tensors\n            for the specified GraphSAGE model and ``x_out`` is the Keras tensor\n            for the GraphSAGE model output.\n\n        \"\"\"", "\n", "# Create tensor inputs for neighbourhood sampling", "\n", "x_inp", "=", "[", "\n", "Input", "(", "shape", "=", "(", "s", ",", "self", ".", "input_feature_size", ")", ",", "dtype", "=", "tf", ".", "float16", ")", "for", "s", "in", "self", ".", "neighbourhood_sizes", "\n", "]", "\n", "\n", "# Output from GraphSAGE model", "\n", "x_out", "=", "self", "(", "x_inp", ")", "\n", "\n", "# Returns inputs and outputs", "\n", "return", "x_inp", ",", "x_out", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.SparseSampler.__init__": [[162, 171], ["numpy.reshape", "numpy.random.default_rng", "sgmods.SparseSampler.__repopulate__", "p.sum", "p.sum"], "methods", ["home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.SparseSampler.__repopulate__"], ["    ", "def", "__init__", "(", "self", ",", "n", ",", "p", ",", "s", "=", "2", "**", "10", ")", ":", "\n", "        ", "self", ".", "n", "=", "np", ".", "reshape", "(", "n", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "if", "p", ".", "sum", "(", ")", "!=", "1.0", ":", "\n", "            ", "self", ".", "p", "=", "p", "/", "p", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "p", "=", "p", "\n", "", "self", ".", "size", "=", "s", "\n", "self", ".", "rng", "=", "np", ".", "random", ".", "default_rng", "(", "7", ")", "\n", "self", ".", "__repopulate__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.SparseSampler.__len__": [[173, 175], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "q", ")", "-", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.SparseSampler.__iter__": [[176, 178], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.SparseSampler.__repopulate__": [[179, 182], ["sgmods.SparseSampler.rng.choice"], "methods", ["None"], ["", "def", "__repopulate__", "(", "self", ")", ":", "\n", "        ", "self", ".", "q", "=", "self", ".", "rng", ".", "choice", "(", "self", ".", "n", ",", "size", "=", "self", ".", "size", ",", "p", "=", "self", ".", "p", ",", "replace", "=", "True", ")", "\n", "self", ".", "i", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.SparseSampler.__next__": [[183, 191], ["sgmods.SparseSampler.__repopulate__", "sgmods.SparseSampler.__next__"], "methods", ["home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.SparseSampler.__repopulate__", "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.SparseSampler.__next__"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "# this will skip index 0 but oh well", "\n", "        ", "self", ".", "i", "+=", "1", "\n", "try", ":", "\n", "            ", "return", "self", ".", "q", "[", "self", ".", "i", "]", "\n", "", "except", "IndexError", ":", "\n", "            ", "self", ".", "__repopulate__", "(", ")", "\n", "return", "self", ".", "__next__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DirectedBreadthFirstNeighboursSparse.__init__": [[194, 198], ["stellargraph.data.explorer.DirectedBreadthFirstNeighbours.__init__", "collections.defaultdict"], "methods", ["home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DirectedBreadthFirstNeighboursSparse.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# indexed by node to SparseSampler class", "\n", "self", ".", "sparse_samplers", "=", "defaultdict", "(", "dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.DirectedBreadthFirstNeighboursSparse._sample_neighbours_untyped": [[200, 237], ["numpy.full", "neigh_func", "len", "numpy.array", "stellargraph.data.explorer.naive_weighted_choices", "py_and_np_rs[].choices", "next", "sgmods.SparseSampler", "next", "numpy.array", "range", "len"], "methods", ["None"], ["", "def", "_sample_neighbours_untyped", "(", "\n", "self", ",", "neigh_func", ",", "py_and_np_rs", ",", "cur_node", ",", "size", ",", "weighted", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Sample ``size`` neighbours of ``cur_node`` without checking node types or edge types, optionally\n        using edge weights.\n        \"\"\"", "\n", "if", "cur_node", "!=", "-", "1", ":", "\n", "            ", "neighbours", "=", "neigh_func", "(", "\n", "cur_node", ",", "use_ilocs", "=", "True", ",", "include_edge_weight", "=", "weighted", "\n", ")", "\n", "\n", "if", "weighted", ":", "\n", "                ", "neighbours", ",", "weights", "=", "neighbours", "\n", "", "", "else", ":", "\n", "            ", "neighbours", "=", "[", "]", "\n", "\n", "", "if", "len", "(", "neighbours", ")", ">", "0", ":", "\n", "            ", "if", "weighted", ":", "\n", "# sample following the edge weights", "\n", "                ", "if", "size", ">", "1", ":", "\n", "                    ", "idx", "=", "sg", ".", "data", ".", "explorer", ".", "naive_weighted_choices", "(", "py_and_np_rs", "[", "1", "]", ",", "weights", ",", "size", "=", "size", ")", "\n", "", "else", ":", "\n", "                    ", "try", ":", "\n", "                        ", "idx", "=", "next", "(", "self", ".", "sparse_samplers", "[", "neigh_func", ".", "__name__", "]", "[", "cur_node", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "                        ", "self", ".", "sparse_samplers", "[", "neigh_func", ".", "__name__", "]", "[", "cur_node", "]", "=", "SparseSampler", "(", "np", ".", "array", "(", "range", "(", "len", "(", "neighbours", ")", ")", ")", ",", "weights", ")", "\n", "idx", "=", "next", "(", "self", ".", "sparse_samplers", "[", "neigh_func", ".", "__name__", "]", "[", "cur_node", "]", ")", "\n", "", "", "if", "idx", "is", "not", "None", ":", "\n", "                    ", "return", "neighbours", "[", "idx", "]", "\n", "", "", "else", ":", "\n", "# uniform sample; for small-to-moderate `size`s (< 100 is typical for GraphSAGE), random", "\n", "# has less overhead than np.random", "\n", "                ", "return", "np", ".", "array", "(", "py_and_np_rs", "[", "0", "]", ".", "choices", "(", "neighbours", ",", "k", "=", "size", ")", ")", "\n", "\n", "# no neighbours (e.g. isolated node, cur_node == -1 or all weights 0), so propagate the -1 sentinel", "\n", "", "", "return", "np", ".", "full", "(", "size", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.GINAggregator.group_aggregate": [[250, 268], ["tensorflow.keras.backend.dot", "tensorflow.keras.backend.sum"], "methods", ["None"], ["def", "group_aggregate", "(", "self", ",", "x_group", ",", "group_idx", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Mean aggregator for tensors over the neighbourhood for each group.\n\n        Args:\n            x_group (tf.Tensor): : The input tensor representing the sampled neighbour nodes.\n            group_idx (int, optional): Group index.\n\n        Returns:\n            :class:`tensorflow.Tensor`: A tensor aggregation of the input nodes features.\n        \"\"\"", "\n", "# The first group is assumed to be the self-tensor and we do not aggregate over it", "\n", "if", "group_idx", "==", "0", ":", "\n", "            ", "x_agg", "=", "x_group", "\n", "", "else", ":", "\n", "            ", "x_agg", "=", "K", ".", "sum", "(", "x_group", ",", "axis", "=", "2", ")", "\n", "\n", "", "return", "K", ".", "dot", "(", "x_agg", ",", "self", ".", "w_group", "[", "group_idx", "]", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.sgmods.extract_element_features_mod": [[68, 130], ["numpy.asarray", "element_data.ids.is_valid", "element_data.ids.is_valid.all", "element_data.features", "numpy.zeros", "element_data.features_of_type", "len", "np.asarray.astype", "element_data.features", "element_data.ids.require_valid", "unique", "element_data.ids.to_iloc", "unique", "len", "numpy.unique", "element_data.type_of_iloc", "len", "ValueError", "len", "ValueError"], "function", ["None"], ["", "", "def", "extract_element_features_mod", "(", "element_data", ",", "unique", ",", "name", ",", "ids", ",", "type", ",", "use_ilocs", ")", ":", "\n", "    ", "if", "ids", "is", "None", ":", "\n", "        ", "if", "type", "is", "None", ":", "\n", "            ", "type", "=", "unique", "(", "\n", "f\"{name}_type: in a non-homogeneous graph, expected a {name} type and/or '{name}s' to be passed; found neither '{name}_type' nor '{name}s', and the graph has {name} types: %(found)s\"", "\n", ")", "\n", "\n", "", "return", "element_data", ".", "features_of_type", "(", "type", ")", "\n", "\n", "", "ids", "=", "np", ".", "asarray", "(", "ids", ")", "\n", "\n", "if", "len", "(", "ids", ")", "==", "0", ":", "\n", "# empty lists are cast to a default array type of float64 -", "\n", "# must manually specify integer type if empty, in which case we can pretend we received ilocs", "\n", "        ", "ilocs", "=", "ids", ".", "astype", "(", "dtype", "=", "np", ".", "float16", ")", "\n", "use_ilocs", "=", "True", "\n", "", "elif", "use_ilocs", ":", "\n", "        ", "ilocs", "=", "ids", "\n", "", "else", ":", "\n", "        ", "ilocs", "=", "element_data", ".", "ids", ".", "to_iloc", "(", "ids", ")", "\n", "\n", "", "valid", "=", "element_data", ".", "ids", ".", "is_valid", "(", "ilocs", ")", "\n", "all_valid", "=", "valid", ".", "all", "(", ")", "\n", "valid_ilocs", "=", "ilocs", "if", "all_valid", "else", "ilocs", "[", "valid", "]", "\n", "\n", "if", "type", "is", "None", ":", "\n", "        ", "try", ":", "\n", "# no inference required in a homogeneous-node graph", "\n", "            ", "type", "=", "unique", "(", ")", "\n", "", "except", "ValueError", ":", "\n", "# infer the type based on the valid nodes", "\n", "            ", "types", "=", "np", ".", "unique", "(", "element_data", ".", "type_of_iloc", "(", "valid_ilocs", ")", ")", "\n", "\n", "if", "len", "(", "types", ")", "==", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"must have at least one node for inference, if `{name}_type` is not specified\"", "\n", ")", "\n", "", "if", "len", "(", "types", ")", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "f\"all {name}s must have the same type\"", ")", "\n", "\n", "", "type", "=", "types", "[", "0", "]", "\n", "\n", "", "", "if", "all_valid", ":", "\n", "        ", "return", "element_data", ".", "features", "(", "type", ",", "valid_ilocs", ")", "\n", "\n", "# If there's some invalid values, they get replaced by zeros; this is designed to allow", "\n", "# models that build fixed-size structures (e.g. GraphSAGE) based on neighbours to fill out", "\n", "# missing neighbours with zeros automatically, using None as a sentinel.", "\n", "\n", "# FIXME: None as a sentinel forces nodes to have dtype=object even with integer IDs, could", "\n", "# instead use an impossible integer (e.g. 2**64 - 1)", "\n", "\n", "# everything that's not the sentinel should be valid", "\n", "", "if", "not", "use_ilocs", ":", "\n", "        ", "non_nones", "=", "ids", "!=", "None", "\n", "element_data", ".", "ids", ".", "require_valid", "(", "ids", "[", "non_nones", "]", ",", "ilocs", "[", "non_nones", "]", ")", "\n", "\n", "", "sampled", "=", "element_data", ".", "features", "(", "type", ",", "valid_ilocs", ")", "\n", "features", "=", "np", ".", "zeros", "(", "(", "len", "(", "ids", ")", ",", "sampled", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "sampled", ".", "dtype", ")", "\n", "features", "[", "valid", "]", "=", "sampled", "\n", "\n", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.utils.load_graph": [[8, 47], ["pandas.read_csv", "pandas.Series", "N.map.loc[].to_numpy", "N.map.to_dict", "N.map.map", "print", "print", "sklearn.preprocessing.OneHotEncoder().fit", "OneHotEncoder().fit.transform", "N.map.map", "set", "pandas.Series().map().to_numpy", "sorted", "pd.Series().map().to_numpy.reshape", "N.map.map().astype().to_numpy().reshape", "[].sum().reset_index().rename", "n_curr[].map().map", "n_curr[].map", "n_curr[].map", "E[].map", "pandas.Series", "sorted", "N.to_dict.items", "sklearn.preprocessing.OneHotEncoder", "len", "len", "[].transform().fillna", "[].sum().reset_index().rename.groupby", "pandas.concat", "pd.concat.apply().to_dict", "pandas.Series().map", "pandas.concat().sort_values().unique", "N.map.map().astype().to_numpy", "[].sum().reset_index", "n_curr[].map", "len", "n_curr[].unique", "str().split", "[].transform", "groups[].apply", "groups[].apply", "pd.concat.apply", "pandas.Series", "pandas.concat().sort_values", "N.map.str.contains", "x.split", "N.map.map().astype", "[].sum", "str().split", "str", "x.div", "pandas.concat", "N.map.map", "[].sum().reset_index().rename.groupby", "x.sum", "pd.read_csv.groupby", "str", "str().split", "str"], "function", ["None"], ["def", "load_graph", "(", "inf_name", ")", ":", "\n", "    ", "E", "=", "pd", ".", "read_csv", "(", "inf_name", ",", "delimiter", "=", "' '", ",", "names", "=", "[", "'source'", ",", "'target'", ",", "'weight'", "]", ",", "dtype", "=", "{", "'source'", ":", "str", ",", "'target'", ":", "str", "}", ")", "\n", "N", "=", "pd", ".", "Series", "(", "sorted", "(", "sorted", "(", "pd", ".", "concat", "(", "[", "E", "[", "'source'", "]", ",", "E", "[", "'target'", "]", "]", ")", ".", "sort_values", "(", ")", ".", "unique", "(", ")", ")", ",", "key", "=", "lambda", "x", ":", "1", "if", "'|'", "in", "x", "else", "0", ")", ")", "\n", "N_k1", "=", "N", ".", "loc", "[", "~", "N", ".", "str", ".", "contains", "(", "'\\|'", ")", "]", ".", "to_numpy", "(", ")", "# need to escape pipe char", "\n", "\n", "id2n", "=", "N", ".", "to_dict", "(", ")", "# ids to node labels", "\n", "n2id", "=", "{", "n", ":", "i", "for", "i", ",", "n", "in", "id2n", ".", "items", "(", ")", "}", "# node labels to ids", "\n", "n2bases", "=", "N", ".", "map", "(", "lambda", "x", ":", "n2id", "[", "x", ".", "split", "(", "'|'", ")", "[", "0", "]", "]", ")", "\n", "print", "(", "'done!'", ")", "\n", "\n", "print", "(", "'encoding nodes and features...'", ",", "end", "=", "''", ")", "\n", "# if G1 is not a first-order graph need this to encode features", "\n", "feature_encoder", "=", "OneHotEncoder", "(", "sparse", "=", "True", ",", "dtype", "=", "dtype", ",", "handle_unknown", "=", "'ignore'", ")", ".", "fit", "(", "N_k1", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "X", "=", "feature_encoder", ".", "transform", "(", "N", ".", "map", "(", "lambda", "x", ":", "str", "(", "x", ")", ".", "split", "(", "'|'", ")", "[", "0", "]", ")", ".", "astype", "(", "str", ")", ".", "to_numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "# generating node families (Omega_u^k)", "\n", "for", "ntype", "in", "[", "'source'", "]", ":", "\n", "        ", "n_curr", "=", "E", ".", "groupby", "(", "ntype", ")", "[", "'weight'", "]", ".", "sum", "(", ")", ".", "reset_index", "(", ")", ".", "rename", "(", "columns", "=", "{", "'weight'", ":", "'deg'", ".", "format", "(", "ntype", ")", "}", ")", "\n", "n_curr", "[", "'base'", "]", "=", "n_curr", "[", "ntype", "]", ".", "map", "(", "lambda", "x", ":", "str", "(", "x", ")", ".", "split", "(", "'|'", ")", "[", "0", "]", ")", ".", "map", "(", "n2id", ")", "\n", "n_curr", "[", "'order'", "]", "=", "n_curr", "[", "ntype", "]", ".", "map", "(", "lambda", "x", ":", "len", "(", "str", "(", "x", ")", ".", "split", "(", "'|'", ")", ")", ")", "\n", "n_curr", "[", "ntype", "]", "=", "n_curr", "[", "ntype", "]", ".", "map", "(", "n2id", ")", "\n", "if", "len", "(", "n_curr", "[", "'base'", "]", ".", "unique", "(", ")", ")", "<", "len", "(", "n_curr", ")", ":", "\n", "# normalize sampling probabilities by degree", "\n", "            ", "n_curr", "[", "'prob'", "]", "=", "n_curr", ".", "groupby", "(", "'base'", ")", "[", "'deg'", "]", ".", "transform", "(", "lambda", "x", ":", "x", ".", "div", "(", "x", ".", "sum", "(", ")", ")", ")", ".", "fillna", "(", "1", ")", "\n", "groups", "=", "n_curr", ".", "groupby", "(", "'base'", ")", "\n", "T", "=", "pd", ".", "concat", "(", "[", "groups", "[", "ntype", "]", ".", "apply", "(", "list", ")", ",", "groups", "[", "'prob'", "]", ".", "apply", "(", "list", ")", "]", ",", "axis", "=", "1", ")", "\n", "probs", "=", "T", ".", "apply", "(", "list", ",", "axis", "=", "1", ")", ".", "to_dict", "(", ")", "\n", "", "else", ":", "\n", "            ", "probs", "=", "{", "}", "\n", "", "", "n2famo", "=", "probs", "\n", "\n", "# map nodes and edges to ids", "\n", "N", "=", "N", ".", "map", "(", "n2id", ")", "\n", "for", "u", "in", "[", "'source'", ",", "'target'", "]", ":", "\n", "        ", "E", "[", "u", "]", "=", "E", "[", "u", "]", ".", "map", "(", "n2id", ")", "\n", "", "N_k1_names", "=", "set", "(", "pd", ".", "Series", "(", "N_k1", ")", ")", "\n", "N_k1", "=", "pd", ".", "Series", "(", "N_k1", ")", ".", "map", "(", "n2id", ")", ".", "to_numpy", "(", ")", "\n", "\n", "return", "N", ",", "E", ",", "X", ",", "N_k1", ",", "N_k1_names", ",", "n2famo", ",", "n2id", ",", "id2n", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.utils.load_labels": [[48, 57], ["pd.DataFrame.index.astype().map", "len", "pandas.read_csv", "pd.DataFrame.unique", "pandas.DataFrame", "pd.DataFrame.index.astype().isin", "pd.DataFrame.index.astype", "sklearn.preprocessing.OneHotEncoder().fit_transform", "pd.DataFrame.to_numpy().reshape", "pd.DataFrame.index.astype", "sklearn.preprocessing.OneHotEncoder", "pd.DataFrame.to_numpy"], "function", ["None"], ["", "def", "load_labels", "(", "inf_labels", ",", "N_k1_names", ",", "n2id", ")", ":", "\n", "    ", "y", "=", "pd", ".", "read_csv", "(", "inf_labels", ",", "index_col", "=", "0", ")", "[", "'Label'", "]", "\n", "y", "=", "y", ".", "loc", "[", "y", ".", "index", ".", "astype", "(", "str", ")", ".", "isin", "(", "N_k1_names", ")", "]", "# only keep labels that have nodes in the graph", "\n", "y", ".", "index", "=", "y", ".", "index", ".", "astype", "(", "str", ")", ".", "map", "(", "n2id", ")", "\n", "\n", "n_classes", "=", "len", "(", "y", ".", "unique", "(", ")", ")", "\n", "if", "n_classes", ">", "2", ":", "\n", "        ", "y", "=", "pd", ".", "DataFrame", "(", "OneHotEncoder", "(", "sparse", "=", "False", ")", ".", "fit_transform", "(", "y", ".", "to_numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "index", "=", "y", ".", "index", ")", "\n", "", "return", "y", ",", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.sjkrieg_dge.None.utils.sample_relatives": [[58, 60], ["numpy.array().transpose", "numpy.array", "rng.choice", "numpy.array", "type"], "function", ["None"], ["", "def", "sample_relatives", "(", "idx", ",", "ell", ",", "n2fam", ",", "rng", ")", ":", "\n", "    ", "return", "np", ".", "array", "(", "[", "rng", ".", "choice", "(", "n2fam", "[", "cur_node", "]", "[", "0", "]", ",", "size", "=", "ell", ",", "p", "=", "n2fam", "[", "cur_node", "]", "[", "1", "]", ",", "replace", "=", "True", ")", "if", "cur_node", "in", "n2fam", "else", "np", ".", "array", "(", "[", "cur_node", "]", "*", "ell", ",", "dtype", "=", "type", "(", "cur_node", ")", ")", "for", "cur_node", "in", "idx", "]", ")", ".", "transpose", "(", ")", "\n", "", ""]]}