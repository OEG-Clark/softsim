{"home.repos.pwc.inspect_result.snucml_largelossmatters.None.models.GlobalAvgPool2d.__init__": [[9, 11], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.ds_multilabel.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "GlobalAvgPool2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.models.GlobalAvgPool2d.forward": [[12, 14], ["torch.adaptive_avg_pool2d().squeeze().squeeze", "torch.adaptive_avg_pool2d().squeeze().squeeze", "torch.adaptive_avg_pool2d().squeeze().squeeze", "torch.adaptive_avg_pool2d().squeeze", "torch.adaptive_avg_pool2d().squeeze", "torch.adaptive_avg_pool2d().squeeze", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feature_map", ")", ":", "\n", "        ", "return", "F", ".", "adaptive_avg_pool2d", "(", "feature_map", ",", "1", ")", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.models.ImageClassifier.__init__": [[16, 36], ["super().__init__", "torchvision.models.resnet50", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "models.GlobalAvgPool2d", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Sequential.parameters", "torch.nn.Sequential.parameters", "torch.nn.Sequential.parameters", "torch.nn.Sequential.parameters", "torch.nn.Sequential.parameters", "torch.nn.Sequential.parameters", "list", "torch.nn.Sequential.children", "torch.nn.Sequential.children", "torch.nn.Sequential.children"], "methods", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.ds_multilabel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "P", ")", ":", "\n", "        ", "super", "(", "ImageClassifier", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "arch", "=", "P", "[", "'arch'", "]", "\n", "feature_extractor", "=", "torchvision", ".", "models", ".", "resnet50", "(", "pretrained", "=", "P", "[", "'use_pretrained'", "]", ")", "\n", "feature_extractor", "=", "torch", ".", "nn", ".", "Sequential", "(", "*", "list", "(", "feature_extractor", ".", "children", "(", ")", ")", "[", ":", "-", "2", "]", ")", "\n", "\n", "\n", "if", "P", "[", "'freeze_feature_extractor'", "]", ":", "\n", "            ", "for", "param", "in", "feature_extractor", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "", "", "else", ":", "\n", "            ", "for", "param", "in", "feature_extractor", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "True", "\n", "", "", "self", ".", "feature_extractor", "=", "feature_extractor", "\n", "\n", "self", ".", "avgpool", "=", "GlobalAvgPool2d", "(", ")", "\n", "\n", "linear_classifier", "=", "torch", ".", "nn", ".", "Linear", "(", "P", "[", "'feat_dim'", "]", ",", "P", "[", "'num_classes'", "]", ",", "bias", "=", "True", ")", "\n", "self", ".", "linear_classifier", "=", "linear_classifier", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.models.ImageClassifier.unfreeze_feature_extractor": [[37, 40], ["models.ImageClassifier.feature_extractor.parameters"], "methods", ["None"], ["", "def", "unfreeze_feature_extractor", "(", "self", ")", ":", "\n", "        ", "for", "param", "in", "self", ".", "feature_extractor", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.models.ImageClassifier.get_cam": [[41, 45], ["models.ImageClassifier.feature_extractor", "torch.conv2d", "torch.conv2d", "torch.conv2d", "models.ImageClassifier.linear_classifier.weight.unsqueeze().unsqueeze", "models.ImageClassifier.linear_classifier.weight.unsqueeze"], "methods", ["None"], ["", "", "def", "get_cam", "(", "self", ",", "x", ")", ":", "\n", "        ", "feats", "=", "self", ".", "feature_extractor", "(", "x", ")", "\n", "CAM", "=", "F", ".", "conv2d", "(", "feats", ",", "self", ".", "linear_classifier", ".", "weight", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", "\n", "return", "CAM", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.models.ImageClassifier.foward_linearinit": [[46, 49], ["models.ImageClassifier.linear_classifier"], "methods", ["None"], ["", "def", "foward_linearinit", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "linear_classifier", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.models.ImageClassifier.forward": [[50, 57], ["models.ImageClassifier.feature_extractor", "models.ImageClassifier.avgpool", "models.ImageClassifier.linear_classifier"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\n", "        ", "feats", "=", "self", ".", "feature_extractor", "(", "x", ")", "\n", "pooled_feats", "=", "self", ".", "avgpool", "(", "feats", ")", "\n", "logits", "=", "self", ".", "linear_classifier", "(", "pooled_feats", ")", "\n", "\n", "return", "logits", "\n", "", "", ""]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.config.str2bool": [[26, 33], ["v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "    ", "if", "v", ".", "lower", "(", ")", "in", "(", "'yes'", ",", "'true'", ",", "'t'", ",", "'y'", ",", "'1'", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'no'", ",", "'false'", ",", "'f'", ",", "'n'", ",", "'0'", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'Boolean value expected.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.config.set_dir": [[35, 40], ["os.path.join", "os.path.exists", "os.makedirs"], "function", ["None"], ["", "", "def", "set_dir", "(", "runs_dir", ",", "exp_name", ")", ":", "\n", "    ", "runs_dir", "=", "ospj", "(", "runs_dir", ",", "exp_name", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "runs_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "runs_dir", ")", "\n", "", "return", "runs_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.config.set_follow_up_configs": [[43, 65], ["config.set_dir"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.config.set_dir"], ["", "def", "set_follow_up_configs", "(", "args", ")", ":", "\n", "    ", "args", ".", "feat_dim", "=", "_LOOKUP", "[", "'feat_dim'", "]", "[", "args", ".", "arch", "]", "\n", "args", ".", "num_classes", "=", "_LOOKUP", "[", "'num_classes'", "]", "[", "args", ".", "dataset", "]", "\n", "args", ".", "save_path", "=", "set_dir", "(", "args", ".", "save_path", ",", "args", ".", "exp_name", ")", "\n", "\n", "if", "args", ".", "mod_scheme", "==", "'LL-R'", ":", "\n", "        ", "args", ".", "llr_rel", "=", "1", "\n", "args", ".", "llr_rel_mod", "=", "0", "\n", "args", ".", "perm_mod", "=", "0", "\n", "", "elif", "args", ".", "mod_scheme", "==", "'LL-Ct'", ":", "\n", "        ", "args", ".", "llr_rel", "=", "1", "\n", "args", ".", "llr_rel_mod", "=", "1", "\n", "args", ".", "perm_mod", "=", "0", "\n", "", "elif", "args", ".", "mod_scheme", "==", "'LL-Cp'", ":", "\n", "        ", "args", ".", "llr_rel", "=", "1", "\n", "args", ".", "llr_rel_mod", "=", "1", "\n", "args", ".", "perm_mod", "=", "1", "\n", "\n", "", "if", "args", ".", "delta_rel", "!=", "0", ":", "\n", "        ", "args", ".", "delta_rel", "/=", "100", "\n", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.config.get_configs": [[67, 112], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "config.set_follow_up_configs", "munch.Munch", "vars"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.config.set_follow_up_configs"], ["", "def", "get_configs", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--ss_seed'", ",", "type", "=", "int", ",", "default", "=", "999", ",", "\n", "help", "=", "'seed fo subsampling'", ")", "\n", "parser", ".", "add_argument", "(", "'--ss_frac_train'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "'fraction of training set to subsample'", ")", "\n", "parser", ".", "add_argument", "(", "'--ss_frac_val'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "'fraction of val set to subsample'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_feats'", ",", "type", "=", "str2bool", ",", "nargs", "=", "'?'", ",", "\n", "const", "=", "True", ",", "default", "=", "False", ",", "\n", "help", "=", "'False if end-to-end training, True if linear training'", ")", "\n", "parser", ".", "add_argument", "(", "'--val_frac'", ",", "type", "=", "float", ",", "default", "=", "0.2", ")", "\n", "parser", ".", "add_argument", "(", "'--split_seed'", ",", "type", "=", "int", ",", "default", "=", "1200", ")", "\n", "parser", ".", "add_argument", "(", "'--train_set_variant'", ",", "type", "=", "str", ",", "default", "=", "'observed'", ",", "\n", "choices", "=", "_TRAIN_SET_VARIANT", ")", "\n", "parser", ".", "add_argument", "(", "'--val_set_variant'", ",", "type", "=", "str", ",", "default", "=", "'clean'", ")", "\n", "parser", ".", "add_argument", "(", "'--arch'", ",", "type", "=", "str", ",", "default", "=", "'resnet50'", ")", "\n", "parser", ".", "add_argument", "(", "'--freeze_feature_extractor'", ",", "type", "=", "str2bool", ",", "nargs", "=", "'?'", ",", "\n", "const", "=", "True", ",", "default", "=", "False", ")", "\n", "parser", ".", "add_argument", "(", "'--use_pretrained'", ",", "type", "=", "str2bool", ",", "nargs", "=", "'?'", ",", "\n", "const", "=", "True", ",", "default", "=", "True", ")", "\n", "\n", "\n", "parser", ".", "add_argument", "(", "'--save_path'", ",", "type", "=", "str", ",", "default", "=", "'./results'", ")", "\n", "parser", ".", "add_argument", "(", "'--exp_name'", ",", "type", "=", "str", ",", "default", "=", "'exp_default'", ")", "\n", "parser", ".", "add_argument", "(", "'--dataset'", ",", "type", "=", "str", ",", "default", "=", "'coco'", ",", "\n", "choices", "=", "_DATASET", ")", "\n", "parser", ".", "add_argument", "(", "'--num_workers'", ",", "type", "=", "int", ",", "default", "=", "4", ")", "\n", "parser", ".", "add_argument", "(", "'--gpu_num'", ",", "type", "=", "str", ",", "default", "=", "'0'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_epochs'", ",", "type", "=", "int", ",", "default", "=", "10", ")", "\n", "parser", ".", "add_argument", "(", "'--optimizer'", ",", "type", "=", "str", ",", "default", "=", "'adam'", ",", "\n", "choices", "=", "_OPTIMIZER", ")", "\n", "parser", ".", "add_argument", "(", "'--bsize'", ",", "type", "=", "int", ",", "default", "=", "16", ")", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "type", "=", "float", ",", "default", "=", "1e-5", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_mult'", ",", "type", "=", "float", ",", "default", "=", "10", ")", "\n", "parser", ".", "add_argument", "(", "'--mod_scheme'", ",", "type", "=", "str", ",", "default", "=", "'LL-R'", ",", "\n", "choices", "=", "_SCHEMES", ")", "\n", "parser", ".", "add_argument", "(", "'--delta_rel'", ",", "type", "=", "float", ",", "default", "=", "0", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "args", "=", "set_follow_up_configs", "(", "args", ")", "\n", "args", "=", "mch", "(", "**", "vars", "(", "args", ")", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.main.main": [[6, 12], ["config.get_configs", "print", "print", "train.run_train"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.config.get_configs", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.train.run_train"], ["def", "main", "(", ")", ":", "\n", "    ", "P", "=", "get_configs", "(", ")", "\n", "print", "(", "P", ",", "'\\n'", ")", "\n", "os", ".", "environ", "[", "'CUDA_VISIBLE_DEVICES'", "]", "=", "P", "[", "'gpu_num'", "]", "\n", "print", "(", "'###### Train start ######'", ")", "\n", "run_train", "(", "P", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.check_inputs": [[4, 16], ["numpy.shape", "numpy.shape", "type", "type", "len", "numpy.max", "numpy.min", "numpy.max", "numpy.min", "numpy.unique"], "function", ["None"], ["def", "check_inputs", "(", "targs", ",", "preds", ")", ":", "\n", "\n", "    ", "'''\n    Helper function for input validation.\n    '''", "\n", "\n", "assert", "(", "np", ".", "shape", "(", "preds", ")", "==", "np", ".", "shape", "(", "targs", ")", ")", "\n", "assert", "type", "(", "preds", ")", "is", "np", ".", "ndarray", "\n", "assert", "type", "(", "targs", ")", "is", "np", ".", "ndarray", "\n", "assert", "(", "np", ".", "max", "(", "preds", ")", "<=", "1.0", ")", "and", "(", "np", ".", "min", "(", "preds", ")", ">=", "0.0", ")", "\n", "assert", "(", "np", ".", "max", "(", "targs", ")", "<=", "1.0", ")", "and", "(", "np", ".", "min", "(", "targs", ")", ">=", "0.0", ")", "\n", "assert", "(", "len", "(", "np", ".", "unique", "(", "targs", ")", ")", "<=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.compute_avg_precision": [[17, 36], ["metrics.check_inputs", "numpy.all", "sklearn.metrics.average_precision_score"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.check_inputs"], ["", "def", "compute_avg_precision", "(", "targs", ",", "preds", ")", ":", "\n", "\n", "    ", "'''\n    Compute average precision.\n    \n    Parameters\n    targs: Binary targets.\n    preds: Predicted probability scores.\n    '''", "\n", "\n", "check_inputs", "(", "targs", ",", "preds", ")", "\n", "\n", "if", "np", ".", "all", "(", "targs", "==", "0", ")", ":", "\n", "# If a class has zero true positives, we define average precision to be zero.", "\n", "        ", "metric_value", "=", "0.0", "\n", "", "else", ":", "\n", "        ", "metric_value", "=", "average_precision_score", "(", "targs", ",", "preds", ")", "\n", "\n", "", "return", "metric_value", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.compute_precision_at_k": [[37, 59], ["metrics.check_inputs", "numpy.flatnonzero", "len", "float", "numpy.argsort", "len", "numpy.intersect1d"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.check_inputs"], ["", "def", "compute_precision_at_k", "(", "targs", ",", "preds", ",", "k", ")", ":", "\n", "\n", "    ", "'''\n    Compute precision@k. \n    \n    Parameters\n    targs: Binary targets.\n    preds: Predicted probability scores.\n    k: Number of predictions to consider.\n    '''", "\n", "\n", "check_inputs", "(", "targs", ",", "preds", ")", "\n", "\n", "classes_rel", "=", "np", ".", "flatnonzero", "(", "targs", "==", "1", ")", "\n", "if", "len", "(", "classes_rel", ")", "==", "0", ":", "\n", "        ", "return", "0.0", "\n", "\n", "", "top_k_pred", "=", "np", ".", "argsort", "(", "preds", ")", "[", ":", ":", "-", "1", "]", "[", ":", "k", "]", "\n", "\n", "metric_value", "=", "float", "(", "len", "(", "np", ".", "intersect1d", "(", "top_k_pred", ",", "classes_rel", ")", ")", ")", "/", "k", "\n", "\n", "return", "metric_value", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.compute_recall_at_k": [[60, 82], ["metrics.check_inputs", "numpy.flatnonzero", "len", "float", "len", "numpy.argsort", "len", "numpy.intersect1d"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.check_inputs"], ["", "def", "compute_recall_at_k", "(", "targs", ",", "preds", ",", "k", ")", ":", "\n", "\n", "    ", "'''\n    Compute recall@k. \n    \n    Parameters\n    targs: Binary targets.\n    preds: Predicted probability scores.\n    k: Number of predictions to consider.\n    '''", "\n", "\n", "check_inputs", "(", "targs", ",", "preds", ")", "\n", "\n", "classes_rel", "=", "np", ".", "flatnonzero", "(", "targs", "==", "1", ")", "\n", "if", "len", "(", "classes_rel", ")", "==", "0", ":", "\n", "        ", "return", "0.0", "\n", "\n", "", "top_k_pred", "=", "np", ".", "argsort", "(", "preds", ")", "[", ":", ":", "-", "1", "]", "[", ":", "k", "]", "\n", "\n", "metric_value", "=", "float", "(", "len", "(", "np", ".", "intersect1d", "(", "top_k_pred", ",", "classes_rel", ")", ")", ")", "/", "len", "(", "classes_rel", ")", "\n", "\n", "return", "metric_value", "\n", "", ""]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.__init__": [[12, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "params", ")", ":", "\n", "\n", "        ", "self", ".", "params", "=", "params", "\n", "\n", "# epoch-level objects:", "\n", "self", ".", "best_stop_metric", "=", "-", "np", ".", "Inf", "\n", "self", ".", "best_epoch", "=", "-", "1", "\n", "self", ".", "running_loss", "=", "0.0", "\n", "self", ".", "num_examples", "=", "0", "\n", "\n", "# batch-level objects:", "\n", "self", ".", "temp_preds", "=", "[", "]", "\n", "self", ".", "temp_true", "=", "[", "]", "# true labels", "\n", "self", ".", "temp_obs", "=", "[", "]", "# observed labels", "\n", "self", ".", "temp_indices", "=", "[", "]", "# indices for each example", "\n", "self", ".", "temp_batch_loss", "=", "[", "]", "\n", "self", ".", "temp_batch_reg", "=", "[", "]", "\n", "\n", "# output objects: ", "\n", "self", ".", "logs", "=", "{", "}", "\n", "self", ".", "logs", "[", "'metrics'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'best_preds'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'gt'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'obs'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'targ'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'idx'", "]", "=", "{", "}", "\n", "for", "field", "in", "self", ".", "logs", ":", "\n", "            ", "for", "phase", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "                ", "self", ".", "logs", "[", "field", "]", "[", "phase", "]", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.compute_phase_metrics": [[42, 69], ["instrumentation.compute_metrics", "instrumentation.compute_metrics", "numpy.mean", "float", "numpy.mean", "numpy.sum", "numpy.mean", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.compute_metrics", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.compute_metrics"], ["", "", "", "def", "compute_phase_metrics", "(", "self", ",", "phase", ",", "epoch", ",", "labels_est", ")", ":", "\n", "\n", "        ", "'''\n        Compute and store end-of-phase metrics. \n        '''", "\n", "\n", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "=", "{", "}", "\n", "\n", "# compute metrics w.r.t. clean ground truth labels:", "\n", "metrics_clean", "=", "compute_metrics", "(", "self", ".", "temp_preds", ",", "self", ".", "temp_true", ")", "\n", "for", "k", "in", "metrics_clean", ":", "\n", "            ", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "k", "+", "'_clean'", "]", "=", "metrics_clean", "[", "k", "]", "\n", "\n", "# compute metrics w.r.t. observed labels:", "\n", "", "metrics_observed", "=", "compute_metrics", "(", "self", ".", "temp_preds", ",", "self", ".", "temp_obs", ")", "\n", "for", "k", "in", "metrics_observed", ":", "\n", "            ", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "k", "+", "'_observed'", "]", "=", "metrics_observed", "[", "k", "]", "\n", "\n", "", "if", "phase", "==", "'train'", ":", "\n", "            ", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "'loss'", "]", "=", "self", ".", "running_loss", "/", "self", ".", "num_examples", "\n", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "'est_labels_k_hat'", "]", "=", "float", "(", "np", ".", "mean", "(", "np", ".", "sum", "(", "labels_est", ",", "axis", "=", "1", ")", ")", ")", "\n", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "'avg_batch_reg'", "]", "=", "np", ".", "mean", "(", "self", ".", "temp_batch_reg", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "'loss'", "]", "=", "-", "999", "\n", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "'est_labels_k_hat'", "]", "=", "-", "999", "\n", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "'avg_batch_reg'", "]", "=", "-", "999", "\n", "", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "'preds_k_hat'", "]", "=", "np", ".", "mean", "(", "np", ".", "sum", "(", "self", ".", "temp_preds", ",", "axis", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.get_stop_metric": [[70, 78], ["None"], "methods", ["None"], ["", "def", "get_stop_metric", "(", "self", ",", "phase", ",", "epoch", ",", "variant", ")", ":", "\n", "\n", "        ", "'''\n        Query the stop metric.\n        '''", "\n", "\n", "assert", "variant", "in", "[", "'clean'", ",", "'observed'", "]", "\n", "return", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "self", ".", "params", "[", "'stop_metric'", "]", "+", "'_'", "+", "variant", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.update_phase_data": [[79, 94], ["range", "instrumentation.train_logger.temp_batch_loss.append", "instrumentation.train_logger.temp_batch_reg.append", "float", "len", "instrumentation.train_logger.temp_preds.append", "instrumentation.train_logger.temp_true.append", "instrumentation.train_logger.temp_obs.append", "instrumentation.train_logger.temp_indices.append", "float", "float", "[].tolist", "[].tolist", "[].tolist", "int", "batch[].size"], "methods", ["None"], ["", "def", "update_phase_data", "(", "self", ",", "batch", ")", ":", "\n", "\n", "        ", "'''\n        Store data from a batch for later use in computing metrics. \n        '''", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "batch", "[", "'idx'", "]", ")", ")", ":", "\n", "            ", "self", ".", "temp_preds", ".", "append", "(", "batch", "[", "'preds_np'", "]", "[", "i", ",", ":", "]", ".", "tolist", "(", ")", ")", "\n", "self", ".", "temp_true", ".", "append", "(", "batch", "[", "'label_vec_true'", "]", "[", "i", ",", ":", "]", ".", "tolist", "(", ")", ")", "\n", "self", ".", "temp_obs", ".", "append", "(", "batch", "[", "'label_vec_obs'", "]", "[", "i", ",", ":", "]", ".", "tolist", "(", ")", ")", "\n", "self", ".", "temp_indices", ".", "append", "(", "int", "(", "batch", "[", "'idx'", "]", "[", "i", "]", ")", ")", "\n", "self", ".", "num_examples", "+=", "1", "\n", "", "self", ".", "temp_batch_loss", ".", "append", "(", "float", "(", "batch", "[", "'loss_np'", "]", ")", ")", "\n", "self", ".", "temp_batch_reg", ".", "append", "(", "float", "(", "batch", "[", "'reg_loss_np'", "]", ")", ")", "\n", "self", ".", "running_loss", "+=", "float", "(", "batch", "[", "'loss_np'", "]", "*", "batch", "[", "'image'", "]", ".", "size", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.reset_phase_data": [[95, 108], ["None"], "methods", ["None"], ["", "def", "reset_phase_data", "(", "self", ")", ":", "\n", "\n", "        ", "'''\n        Reset for a new phase. \n        '''", "\n", "\n", "self", ".", "temp_preds", "=", "[", "]", "\n", "self", ".", "temp_true", "=", "[", "]", "\n", "self", ".", "temp_obs", "=", "[", "]", "\n", "self", ".", "temp_indices", "=", "[", "]", "\n", "self", ".", "temp_batch_reg", "=", "[", "]", "\n", "self", ".", "running_loss", "=", "0.0", "\n", "self", ".", "num_examples", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.update_best_results": [[109, 137], ["instrumentation.train_logger.get_stop_metric"], "methods", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.get_stop_metric"], ["", "def", "update_best_results", "(", "self", ",", "phase", ",", "epoch", ",", "variant", ")", ":", "\n", "\n", "        ", "'''\n        Update the current best epoch info if applicable.\n        '''", "\n", "\n", "if", "phase", "==", "'train'", ":", "\n", "            ", "return", "False", "\n", "", "elif", "phase", "==", "'val'", ":", "\n", "            ", "assert", "variant", "in", "[", "'clean'", ",", "'observed'", "]", "\n", "cur_stop_metric", "=", "self", ".", "get_stop_metric", "(", "phase", ",", "epoch", ",", "variant", ")", "\n", "if", "cur_stop_metric", ">", "self", ".", "best_stop_metric", ":", "\n", "                ", "self", ".", "best_stop_metric", "=", "cur_stop_metric", "\n", "self", ".", "best_epoch", "=", "epoch", "\n", "self", ".", "logs", "[", "'best_preds'", "]", "[", "phase", "]", "=", "self", ".", "temp_preds", "\n", "self", ".", "logs", "[", "'gt'", "]", "[", "phase", "]", "=", "self", ".", "temp_true", "\n", "self", ".", "logs", "[", "'obs'", "]", "[", "phase", "]", "=", "self", ".", "temp_obs", "\n", "self", ".", "logs", "[", "'idx'", "]", "[", "phase", "]", "=", "self", ".", "temp_indices", "\n", "return", "True", "# new best found", "\n", "", "else", ":", "\n", "                ", "return", "False", "# new best not found", "\n", "", "", "elif", "phase", "==", "'test'", ":", "\n", "            ", "if", "epoch", "==", "self", ".", "best_epoch", ":", "\n", "                ", "self", ".", "logs", "[", "'best_preds'", "]", "[", "phase", "]", "=", "self", ".", "temp_preds", "\n", "self", ".", "logs", "[", "'gt'", "]", "[", "phase", "]", "=", "self", ".", "temp_true", "\n", "self", ".", "logs", "[", "'obs'", "]", "[", "phase", "]", "=", "self", ".", "temp_obs", "\n", "self", ".", "logs", "[", "'idx'", "]", "[", "phase", "]", "=", "self", ".", "temp_indices", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.get_logs": [[138, 145], ["copy.deepcopy"], "methods", ["None"], ["", "", "def", "get_logs", "(", "self", ")", ":", "\n", "\n", "        ", "'''\n        Return a copy of all log data.\n        '''", "\n", "\n", "return", "copy", ".", "deepcopy", "(", "self", ".", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.report": [[146, 157], ["print", "instrumentation.train_logger.get_stop_metric", "instrumentation.train_logger.get_stop_metric"], "methods", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.get_stop_metric", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.train_logger.get_stop_metric"], ["", "def", "report", "(", "self", ",", "t_i", ",", "t_f", ",", "phase", ",", "epoch", ")", ":", "\n", "        ", "report", "=", "'[{}] time: {:.2f} min, loss: {:.3f}, {}: {:.2f}, {}: {:.2f}'", ".", "format", "(", "\n", "phase", ",", "\n", "(", "t_f", "-", "t_i", ")", "/", "60.0", ",", "\n", "self", ".", "logs", "[", "'metrics'", "]", "[", "phase", "]", "[", "epoch", "]", "[", "'loss'", "]", ",", "\n", "self", ".", "params", "[", "'stop_metric'", "]", "+", "'_clean'", ",", "\n", "self", ".", "get_stop_metric", "(", "phase", ",", "epoch", ",", "'clean'", ")", ",", "\n", "self", ".", "params", "[", "'stop_metric'", "]", "+", "'_observed'", ",", "\n", "self", ".", "get_stop_metric", "(", "phase", ",", "epoch", ",", "'observed'", ")", ",", "\n", ")", "\n", "print", "(", "report", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.compute_metrics": [[159, 185], ["numpy.shape", "numpy.array", "numpy.array", "numpy.array", "range", "average_precision_list.append", "float", "metrics.compute_avg_precision", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.compute_avg_precision"], ["", "", "def", "compute_metrics", "(", "y_pred", ",", "y_true", ")", ":", "\n", "\n", "    ", "'''\n    Given predictions and labels, compute a few metrics.\n    '''", "\n", "\n", "num_examples", ",", "num_classes", "=", "np", ".", "shape", "(", "y_true", ")", "\n", "\n", "results", "=", "{", "}", "\n", "average_precision_list", "=", "[", "]", "\n", "y_pred", "=", "np", ".", "array", "(", "y_pred", ")", "\n", "y_true", "=", "np", ".", "array", "(", "y_true", ")", "\n", "y_true", "=", "np", ".", "array", "(", "y_true", "==", "1", ",", "dtype", "=", "np", ".", "float32", ")", "# convert from -1 / 1 format to 0 / 1 format", "\n", "for", "j", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "average_precision_list", ".", "append", "(", "metrics", ".", "compute_avg_precision", "(", "y_true", "[", ":", ",", "j", "]", ",", "y_pred", "[", ":", ",", "j", "]", ")", ")", "\n", "\n", "", "results", "[", "'map'", "]", "=", "100.0", "*", "float", "(", "np", ".", "mean", "(", "average_precision_list", ")", ")", "\n", "''''\n    for k in [1, 3, 5]:\n        rec_at_k = np.array([metrics.compute_recall_at_k(y_true[i, :], y_pred[i, :], k) for i in range(num_examples)])\n        prec_at_k = np.array([metrics.compute_precision_at_k(y_true[i, :], y_pred[i, :], k) for i in range(num_examples)])\n        results['rec_at_{}'.format(k)] = np.mean(rec_at_k)\n        results['prec_at_{}'.format(k)] = np.mean(prec_at_k)\n        results['top_{}'.format(k)] = np.mean(prec_at_k > 0)\n    '''", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.compute_metrics_openimages": [[186, 215], ["numpy.shape", "range", "average_precision_list.append", "float", "numpy.where", "len", "metrics.compute_avg_precision", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.compute_avg_precision"], ["", "def", "compute_metrics_openimages", "(", "y_pred", ",", "y_true", ")", ":", "\n", "\n", "    ", "'''\n    Given predictions and labels, compute a few metrics.\n    '''", "\n", "\n", "num_examples", ",", "num_classes", "=", "np", ".", "shape", "(", "y_true", ")", "\n", "\n", "results", "=", "{", "}", "\n", "average_precision_list", "=", "[", "]", "\n", "# y_pred = np.array(y_pred)", "\n", "# y_true = np.array(y_true)", "\n", "# y_true = np.array(y_true == 1, dtype=np.float32) # convert from -1 / 1 format to 0 / 1 format", "\n", "for", "j", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "observed_idxs", "=", "np", ".", "where", "(", "y_true", "[", ":", ",", "j", "]", "!=", "-", "1", ")", "[", "0", "]", "\n", "if", "len", "(", "observed_idxs", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "average_precision_list", ".", "append", "(", "metrics", ".", "compute_avg_precision", "(", "y_true", "[", "observed_idxs", ",", "j", "]", ",", "y_pred", "[", "observed_idxs", ",", "j", "]", ")", ")", "\n", "\n", "", "results", "[", "'map'", "]", "=", "100.0", "*", "float", "(", "np", ".", "mean", "(", "average_precision_list", ")", ")", "\n", "''''\n    for k in [1, 3, 5]:\n        rec_at_k = np.array([metrics.compute_recall_at_k(y_true[i, :], y_pred[i, :], k) for i in range(num_examples)])\n        prec_at_k = np.array([metrics.compute_precision_at_k(y_true[i, :], y_pred[i, :], k) for i in range(num_examples)])\n        results['rec_at_{}'.format(k)] = np.mean(rec_at_k)\n        results['prec_at_{}'.format(k)] = np.mean(prec_at_k)\n        results['top_{}'.format(k)] = np.mean(prec_at_k > 0)\n    '''", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.compute_aps_openimages": [[216, 236], ["numpy.shape", "range", "numpy.array", "average_precision_list.append", "numpy.where", "len", "metrics.compute_avg_precision"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.metrics.compute_avg_precision"], ["", "def", "compute_aps_openimages", "(", "y_pred", ",", "y_true", ")", ":", "\n", "\n", "    ", "'''\n    Given predictions and labels, compute a few metrics.\n    '''", "\n", "\n", "num_examples", ",", "num_classes", "=", "np", ".", "shape", "(", "y_true", ")", "\n", "\n", "results", "=", "{", "}", "\n", "average_precision_list", "=", "[", "]", "\n", "# y_pred = np.array(y_pred)", "\n", "# y_true = np.array(y_true)", "\n", "# y_true = np.array(y_true == 1, dtype=np.float32) # convert from -1 / 1 format to 0 / 1 format", "\n", "for", "j", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "observed_idxs", "=", "np", ".", "where", "(", "y_true", "[", ":", ",", "j", "]", "!=", "-", "1", ")", "[", "0", "]", "\n", "if", "len", "(", "observed_idxs", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "average_precision_list", ".", "append", "(", "metrics", ".", "compute_avg_precision", "(", "y_true", "[", "observed_idxs", ",", "j", "]", ",", "y_pred", "[", "observed_idxs", ",", "j", "]", ")", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "average_precision_list", ")", "", "", ""]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.train.run_train": [[12, 152], ["datasets.get_data", "models.ImageClassifier", "models.ImageClassifier.to", "range", "torch.load", "models.ImageClassifier.load_state_dict", "models.ImageClassifier.eval", "numpy.zeros", "numpy.zeros", "instrumentation.compute_metrics", "print", "print", "torch.utils.data.DataLoader", "torch.optim.Adam", "torch.cuda.is_available", "print", "torch.set_grad_enabled", "tqdm.tqdm", "list", "list", "torch.optim.SGD", "print", "os.path.join", "torch.save", "len", "len", "batch[].to", "batch[].to", "batch[].clone().numpy", "torch.optim.SGD.zero_grad", "models.ImageClassifier.", "torch.sigmoid", "torch.sigmoid.cpu().numpy", "models.ImageClassifier.feature_extractor.parameters", "models.ImageClassifier.linear_classifier.parameters", "models.ImageClassifier.train", "models.ImageClassifier.eval", "numpy.zeros", "numpy.zeros", "torch.set_grad_enabled", "tqdm.tqdm", "instrumentation.compute_metrics", "print", "torch.unsqueeze.dim", "torch.unsqueeze", "batch[].to", "batch[].to", "batch[].clone().numpy", "torch.optim.SGD.zero_grad", "models.ImageClassifier.", "torch.sigmoid", "models.ImageClassifier.state_dict", "batch[].clone", "torch.sigmoid.cpu", "len", "len", "torch.unsqueeze.dim", "torch.unsqueeze", "losses.compute_batch_loss", "loss_tensor.backward", "torch.optim.SGD.step", "torch.sigmoid.cpu().numpy", "batch[].clone", "torch.sigmoid.cpu", "correction_idx[].cpu", "correction_idx[].cpu"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_data", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.compute_metrics", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.instrumentation.compute_metrics", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.losses.compute_batch_loss"], ["def", "run_train", "(", "P", ")", ":", "\n", "\n", "    ", "dataset", "=", "datasets", ".", "get_data", "(", "P", ")", "\n", "dataloader", "=", "{", "}", "\n", "for", "phase", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "        ", "dataloader", "[", "phase", "]", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", "[", "phase", "]", ",", "\n", "batch_size", "=", "P", "[", "'bsize'", "]", ",", "\n", "shuffle", "=", "phase", "==", "'train'", ",", "\n", "sampler", "=", "None", ",", "\n", "num_workers", "=", "P", "[", "'num_workers'", "]", ",", "\n", "drop_last", "=", "False", ",", "\n", "pin_memory", "=", "True", "\n", ")", "\n", "\n", "\n", "", "model", "=", "models", ".", "ImageClassifier", "(", "P", ")", "\n", "\n", "feature_extractor_params", "=", "[", "param", "for", "param", "in", "list", "(", "model", ".", "feature_extractor", ".", "parameters", "(", ")", ")", "if", "param", ".", "requires_grad", "]", "\n", "linear_classifier_params", "=", "[", "param", "for", "param", "in", "list", "(", "model", ".", "linear_classifier", ".", "parameters", "(", ")", ")", "if", "param", ".", "requires_grad", "]", "\n", "opt_params", "=", "[", "\n", "{", "'params'", ":", "feature_extractor_params", ",", "'lr'", ":", "P", "[", "'lr'", "]", "}", ",", "\n", "{", "'params'", ":", "linear_classifier_params", ",", "'lr'", ":", "P", "[", "'lr_mult'", "]", "*", "P", "[", "'lr'", "]", "}", "\n", "]", "\n", "\n", "if", "P", "[", "'optimizer'", "]", "==", "'adam'", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "opt_params", ",", "lr", "=", "P", "[", "'lr'", "]", ")", "\n", "", "elif", "P", "[", "'optimizer'", "]", "==", "'sgd'", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "opt_params", ",", "lr", "=", "P", "[", "'lr'", "]", ",", "momentum", "=", "0.9", ",", "weight_decay", "=", "0.001", ")", "\n", "\n", "# training loop", "\n", "", "device", "=", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", "\n", "model", ".", "to", "(", "device", ")", "\n", "\n", "bestmap_val", "=", "0", "\n", "bestmap_test", "=", "0", "\n", "\n", "for", "epoch", "in", "range", "(", "1", ",", "P", "[", "'num_epochs'", "]", "+", "1", ")", ":", "\n", "        ", "for", "phase", "in", "[", "'train'", ",", "'val'", "]", ":", "\n", "            ", "if", "phase", "==", "'train'", ":", "\n", "                ", "model", ".", "train", "(", ")", "\n", "", "else", ":", "\n", "                ", "model", ".", "eval", "(", ")", "\n", "y_pred", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", "[", "phase", "]", ")", ",", "P", "[", "'num_classes'", "]", ")", ")", "\n", "y_true", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", "[", "phase", "]", ")", ",", "P", "[", "'num_classes'", "]", ")", ")", "\n", "batch_stack", "=", "0", "\n", "\n", "\n", "", "with", "torch", ".", "set_grad_enabled", "(", "phase", "==", "'train'", ")", ":", "\n", "                ", "for", "batch", "in", "tqdm", "(", "dataloader", "[", "phase", "]", ")", ":", "\n", "# Move data to GPU", "\n", "                    ", "image", "=", "batch", "[", "'image'", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "label_vec_obs", "=", "batch", "[", "'label_vec_obs'", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "label_vec_true", "=", "batch", "[", "'label_vec_true'", "]", ".", "clone", "(", ")", ".", "numpy", "(", ")", "\n", "idx", "=", "batch", "[", "'idx'", "]", "\n", "\n", "# Forward pass", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "logits", "=", "model", "(", "image", ")", "\n", "\n", "if", "logits", ".", "dim", "(", ")", "==", "1", ":", "\n", "                        ", "logits", "=", "torch", ".", "unsqueeze", "(", "logits", ",", "0", ")", "\n", "", "preds", "=", "torch", ".", "sigmoid", "(", "logits", ")", "\n", "\n", "if", "phase", "==", "'train'", ":", "\n", "                        ", "loss_tensor", ",", "correction_idx", "=", "losses", ".", "compute_batch_loss", "(", "logits", ",", "label_vec_obs", ",", "P", ")", "\n", "loss_tensor", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "correction_idx", "is", "not", "None", ":", "\n", "                            ", "if", "P", "[", "'perm_mod'", "]", ":", "# permanent correction", "\n", "                                ", "dataset", "[", "phase", "]", ".", "label_matrix_obs", "[", "idx", "[", "correction_idx", "[", "0", "]", ".", "cpu", "(", ")", "]", ",", "correction_idx", "[", "1", "]", ".", "cpu", "(", ")", "]", "=", "1.0", "\n", "\n", "", "", "", "else", ":", "\n", "                        ", "preds_np", "=", "preds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "this_batch_size", "=", "preds_np", ".", "shape", "[", "0", "]", "\n", "y_pred", "[", "batch_stack", ":", "batch_stack", "+", "this_batch_size", "]", "=", "preds_np", "\n", "y_true", "[", "batch_stack", ":", "batch_stack", "+", "this_batch_size", "]", "=", "label_vec_true", "\n", "batch_stack", "+=", "this_batch_size", "\n", "\n", "", "", "", "if", "phase", "!=", "'train'", ":", "\n", "                ", "metrics", "=", "compute_metrics", "(", "y_pred", ",", "y_true", ")", "\n", "del", "y_pred", "\n", "del", "y_true", "\n", "map_val", "=", "metrics", "[", "'map'", "]", "\n", "\n", "", "", "P", "[", "'llr_rel'", "]", "-=", "P", "[", "'delta_rel'", "]", "\n", "\n", "print", "(", "f\"Epoch {epoch} : val mAP {map_val:.3f}\"", ")", "\n", "if", "bestmap_val", "<", "map_val", ":", "\n", "            ", "bestmap_val", "=", "map_val", "\n", "bestmap_epoch", "=", "epoch", "\n", "\n", "print", "(", "f'Saving model weight for best val mAP {bestmap_val:.3f}'", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "P", "[", "'save_path'", "]", ",", "'bestmodel.pt'", ")", "\n", "torch", ".", "save", "(", "(", "model", ".", "state_dict", "(", ")", ",", "P", ")", ",", "path", ")", "\n", "\n", "", "elif", "bestmap_val", "-", "map_val", ">", "3", ":", "\n", "            ", "print", "(", "'Early stopped.'", ")", "\n", "break", "\n", "\n", "# Test phase", "\n", "\n", "", "", "model_state", ",", "_", "=", "torch", ".", "load", "(", "path", ")", "\n", "model", ".", "load_state_dict", "(", "model_state", ")", "\n", "\n", "phase", "=", "'test'", "\n", "model", ".", "eval", "(", ")", "\n", "y_pred", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", "[", "phase", "]", ")", ",", "P", "[", "'num_classes'", "]", ")", ")", "\n", "y_true", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", "[", "phase", "]", ")", ",", "P", "[", "'num_classes'", "]", ")", ")", "\n", "batch_stack", "=", "0", "\n", "with", "torch", ".", "set_grad_enabled", "(", "phase", "==", "'train'", ")", ":", "\n", "        ", "for", "batch", "in", "tqdm", "(", "dataloader", "[", "phase", "]", ")", ":", "\n", "# Move data to GPU", "\n", "            ", "image", "=", "batch", "[", "'image'", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "label_vec_obs", "=", "batch", "[", "'label_vec_obs'", "]", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "label_vec_true", "=", "batch", "[", "'label_vec_true'", "]", ".", "clone", "(", ")", ".", "numpy", "(", ")", "\n", "idx", "=", "batch", "[", "'idx'", "]", "\n", "\n", "# Forward pass", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "logits", "=", "model", "(", "image", ")", "\n", "\n", "if", "logits", ".", "dim", "(", ")", "==", "1", ":", "\n", "                ", "logits", "=", "torch", ".", "unsqueeze", "(", "logits", ",", "0", ")", "\n", "", "preds", "=", "torch", ".", "sigmoid", "(", "logits", ")", "\n", "\n", "preds_np", "=", "preds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "this_batch_size", "=", "preds_np", ".", "shape", "[", "0", "]", "\n", "y_pred", "[", "batch_stack", ":", "batch_stack", "+", "this_batch_size", "]", "=", "preds_np", "\n", "y_true", "[", "batch_stack", ":", "batch_stack", "+", "this_batch_size", "]", "=", "label_vec_true", "\n", "batch_stack", "+=", "this_batch_size", "\n", "\n", "", "", "metrics", "=", "compute_metrics", "(", "y_pred", ",", "y_true", ")", "\n", "map_test", "=", "metrics", "[", "'map'", "]", "\n", "\n", "print", "(", "'Training procedure completed!'", ")", "\n", "print", "(", "f'Test mAP : {map_test:.3f} when trained until epoch {bestmap_epoch}'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.losses.loss_an": [[13, 20], ["torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.min", "torch.min", "torch.logical_not().float", "torch.logical_not().float", "torch.logical_not", "torch.logical_not"], "function", ["None"], ["def", "loss_an", "(", "logits", ",", "observed_labels", ",", "P", ")", ":", "\n", "\n", "    ", "assert", "torch", ".", "min", "(", "observed_labels", ")", ">=", "0", "\n", "# compute loss:", "\n", "loss_mtx", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "logits", ",", "observed_labels", ",", "reduction", "=", "'none'", ")", "\n", "corrected_loss_mtx", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "logits", ",", "torch", ".", "logical_not", "(", "observed_labels", ")", ".", "float", "(", ")", ",", "reduction", "=", "'none'", ")", "\n", "return", "loss_mtx", ",", "corrected_loss_mtx", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.losses.compute_batch_loss": [[26, 68], ["int", "int", "losses.loss_an", "preds.dim", "preds.size", "preds.size", "torch.ones_like", "torch.ones_like", "label_vec.clip", "math.ceil", "unobserved_mask.bool", "torch.topk", "torch.topk", "torch.where", "torch.where", "math.ceil", "unobserved_loss.flatten", "torch.where", "torch.where"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.losses.loss_an"], ["def", "compute_batch_loss", "(", "preds", ",", "label_vec", ",", "P", ")", ":", "# \"preds\" are actually logits (not sigmoid activated !)", "\n", "\n", "    ", "assert", "preds", ".", "dim", "(", ")", "==", "2", "\n", "\n", "batch_size", "=", "int", "(", "preds", ".", "size", "(", "0", ")", ")", "\n", "num_classes", "=", "int", "(", "preds", ".", "size", "(", "1", ")", ")", "\n", "\n", "loss_denom_mtx", "=", "(", "num_classes", "*", "batch_size", ")", "*", "torch", ".", "ones_like", "(", "preds", ")", "\n", "\n", "unobserved_mask", "=", "(", "label_vec", "==", "0", ")", "\n", "\n", "# compute loss for each image and class:", "\n", "loss_mtx", ",", "corrected_loss_mtx", "=", "loss_an", "(", "preds", ",", "label_vec", ".", "clip", "(", "0", ")", ",", "P", ")", "\n", "\n", "correction_idx", "=", "None", "\n", "\n", "if", "P", "[", "'llr_rel'", "]", ":", "\n", "        ", "unobserved_loss", "=", "unobserved_mask", ".", "bool", "(", ")", "*", "loss_mtx", "\n", "k", "=", "math", ".", "ceil", "(", "batch_size", "*", "num_classes", "*", "(", "1", "-", "P", "[", "'llr_rel'", "]", ")", ")", "\n", "if", "k", "!=", "0", ":", "# which means Epoch is not 1", "\n", "            ", "if", "P", "[", "'perm_mod'", "]", ":", "\n", "                ", "k", "=", "math", ".", "ceil", "(", "batch_size", "*", "num_classes", "*", "P", "[", "'delta_rel'", "]", ")", "\n", "", "topk", "=", "torch", ".", "topk", "(", "unobserved_loss", ".", "flatten", "(", ")", ",", "k", ")", "\n", "topk_lossvalue", "=", "topk", ".", "values", "[", "-", "1", "]", "\n", "loss_mask", "=", "(", "unobserved_loss", "<", "topk_lossvalue", ")", ".", "float", "(", ")", "\n", "correction_idx", "=", "torch", ".", "where", "(", "unobserved_loss", ">", "topk_lossvalue", ")", "\n", "masked_loss_mtx", "=", "loss_mtx", "*", "loss_mask", "\n", "if", "P", "[", "'llr_rel_mod'", "]", ":", "\n", "                ", "final_loss_mtx", "=", "torch", ".", "where", "(", "unobserved_loss", "<", "topk_lossvalue", ",", "loss_mtx", ",", "corrected_loss_mtx", ")", "\n", "", "else", ":", "\n", "                ", "final_loss_mtx", "=", "masked_loss_mtx", "\n", "\n", "", "", "else", ":", "\n", "            ", "final_loss_mtx", "=", "loss_mtx", "\n", "\n", "\n", "", "", "else", ":", "\n", "        ", "final_loss_mtx", "=", "loss_mtx", "\n", "\n", "", "main_loss", "=", "(", "final_loss_mtx", "/", "loss_denom_mtx", ")", ".", "sum", "(", ")", "\n", "\n", "return", "main_loss", ",", "correction_idx", "", "", ""]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.multilabel.__init__": [[147, 207], ["datasets.get_metadata", "datasets.load_data", "datasets.generate_split", "numpy.random.RandomState", "copy.deepcopy", "datasets.ds_multilabel", "datasets.ds_multilabel", "datasets.ds_multilabel", "len", "numpy.random.RandomState", "len", "int", "len", "len", "len", "numpy.round", "numpy.sort", "numpy.random.RandomState.permutation"], "methods", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_metadata", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.load_data", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.generate_split"], ["    ", "def", "__init__", "(", "self", ",", "P", ",", "tx", ")", ":", "\n", "\n", "# get dataset metadata:", "\n", "        ", "meta", "=", "get_metadata", "(", "P", "[", "'dataset'", "]", ")", "\n", "self", ".", "base_path", "=", "meta", "[", "'path_to_dataset'", "]", "\n", "\n", "# load data:", "\n", "source_data", "=", "load_data", "(", "self", ".", "base_path", ",", "P", ")", "\n", "\n", "# generate indices to split official train set into train and val:", "\n", "split_idx", "=", "{", "}", "\n", "(", "split_idx", "[", "'train'", "]", ",", "split_idx", "[", "'val'", "]", ")", "=", "generate_split", "(", "\n", "len", "(", "source_data", "[", "'train'", "]", "[", "'images'", "]", ")", ",", "\n", "P", "[", "'val_frac'", "]", ",", "\n", "np", ".", "random", ".", "RandomState", "(", "P", "[", "'split_seed'", "]", ")", "\n", ")", "\n", "\n", "# subsample split indices: # commenting this out makes the val set map be low?", "\n", "ss_rng", "=", "np", ".", "random", ".", "RandomState", "(", "P", "[", "'ss_seed'", "]", ")", "\n", "temp_train_idx", "=", "copy", ".", "deepcopy", "(", "split_idx", "[", "'train'", "]", ")", "\n", "for", "phase", "in", "[", "'train'", ",", "'val'", "]", ":", "\n", "            ", "num_initial", "=", "len", "(", "split_idx", "[", "phase", "]", ")", "\n", "num_final", "=", "int", "(", "np", ".", "round", "(", "P", "[", "'ss_frac_{}'", ".", "format", "(", "phase", ")", "]", "*", "num_initial", ")", ")", "\n", "split_idx", "[", "phase", "]", "=", "split_idx", "[", "phase", "]", "[", "np", ".", "sort", "(", "ss_rng", ".", "permutation", "(", "num_initial", ")", "[", ":", "num_final", "]", ")", "]", "\n", "\n", "# define train set:", "\n", "", "self", ".", "train", "=", "ds_multilabel", "(", "\n", "P", "[", "'dataset'", "]", ",", "\n", "source_data", "[", "'train'", "]", "[", "'images'", "]", "[", "split_idx", "[", "'train'", "]", "]", ",", "\n", "source_data", "[", "'train'", "]", "[", "'labels'", "]", "[", "split_idx", "[", "'train'", "]", ",", ":", "]", ",", "\n", "source_data", "[", "'train'", "]", "[", "'labels_obs'", "]", "[", "split_idx", "[", "'train'", "]", ",", ":", "]", ",", "\n", "source_data", "[", "'train'", "]", "[", "'feats'", "]", "[", "split_idx", "[", "'train'", "]", ",", ":", "]", "if", "P", "[", "'use_feats'", "]", "else", "[", "]", ",", "\n", "tx", "[", "'train'", "]", ",", "\n", "P", "[", "'use_feats'", "]", "\n", ")", "\n", "\n", "# define val set:", "\n", "self", ".", "val", "=", "ds_multilabel", "(", "\n", "P", "[", "'dataset'", "]", ",", "\n", "source_data", "[", "'train'", "]", "[", "'images'", "]", "[", "split_idx", "[", "'val'", "]", "]", ",", "\n", "source_data", "[", "'train'", "]", "[", "'labels'", "]", "[", "split_idx", "[", "'val'", "]", ",", ":", "]", ",", "\n", "source_data", "[", "'train'", "]", "[", "'labels_obs'", "]", "[", "split_idx", "[", "'val'", "]", ",", ":", "]", ",", "\n", "source_data", "[", "'train'", "]", "[", "'feats'", "]", "[", "split_idx", "[", "'val'", "]", ",", ":", "]", "if", "P", "[", "'use_feats'", "]", "else", "[", "]", ",", "\n", "tx", "[", "'val'", "]", ",", "\n", "P", "[", "'use_feats'", "]", "\n", ")", "\n", "\n", "# define test set:", "\n", "self", ".", "test", "=", "ds_multilabel", "(", "\n", "P", "[", "'dataset'", "]", ",", "\n", "source_data", "[", "'val'", "]", "[", "'images'", "]", ",", "\n", "source_data", "[", "'val'", "]", "[", "'labels'", "]", ",", "\n", "source_data", "[", "'val'", "]", "[", "'labels_obs'", "]", ",", "\n", "source_data", "[", "'val'", "]", "[", "'feats'", "]", ",", "\n", "tx", "[", "'test'", "]", ",", "\n", "P", "[", "'use_feats'", "]", "\n", ")", "\n", "\n", "# define dict of dataset lengths: ", "\n", "self", ".", "lengths", "=", "{", "'train'", ":", "len", "(", "self", ".", "train", ")", ",", "'val'", ":", "len", "(", "self", ".", "val", ")", ",", "'test'", ":", "len", "(", "self", ".", "test", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.multilabel.get_datasets": [[208, 210], ["None"], "methods", ["None"], ["", "def", "get_datasets", "(", "self", ")", ":", "\n", "        ", "return", "{", "'train'", ":", "self", ".", "train", ",", "'val'", ":", "self", ".", "val", ",", "'test'", ":", "self", ".", "test", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.ds_multilabel.__init__": [[213, 224], ["datasets.get_metadata"], "methods", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_metadata"], ["    ", "def", "__init__", "(", "self", ",", "dataset_name", ",", "image_ids", ",", "label_matrix", ",", "label_matrix_obs", ",", "feats", ",", "tx", ",", "use_feats", ")", ":", "\n", "        ", "meta", "=", "get_metadata", "(", "dataset_name", ")", "\n", "self", ".", "num_classes", "=", "meta", "[", "'num_classes'", "]", "\n", "self", ".", "path_to_images", "=", "meta", "[", "'path_to_images'", "]", "\n", "\n", "self", ".", "image_ids", "=", "image_ids", "\n", "self", ".", "label_matrix", "=", "label_matrix", "\n", "self", ".", "label_matrix_obs", "=", "label_matrix_obs", "\n", "self", ".", "feats", "=", "feats", "\n", "self", ".", "tx", "=", "tx", "\n", "self", ".", "use_feats", "=", "use_feats", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.ds_multilabel.__len__": [[225, 227], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "image_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.ds_multilabel.__getitem__": [[228, 247], ["torch.FloatTensor", "os.path.join", "torch.FloatTensor", "torch.FloatTensor", "numpy.copy", "PIL.Image.open", "datasets.ds_multilabel.tx", "numpy.copy", "numpy.copy", "I_raw.convert"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "use_feats", ":", "\n", "# Set I to be a feature vector:", "\n", "            ", "I", "=", "torch", ".", "FloatTensor", "(", "np", ".", "copy", "(", "self", ".", "feats", "[", "idx", ",", ":", "]", ")", ")", "\n", "", "else", ":", "\n", "# Set I to be an image: ", "\n", "            ", "image_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "path_to_images", ",", "self", ".", "image_ids", "[", "idx", "]", ")", "\n", "with", "Image", ".", "open", "(", "image_path", ")", "as", "I_raw", ":", "\n", "                ", "I", "=", "self", ".", "tx", "(", "I_raw", ".", "convert", "(", "'RGB'", ")", ")", "\n", "\n", "", "", "out", "=", "{", "\n", "'image'", ":", "I", ",", "\n", "'label_vec_obs'", ":", "torch", ".", "FloatTensor", "(", "np", ".", "copy", "(", "self", ".", "label_matrix_obs", "[", "idx", ",", ":", "]", ")", ")", ",", "\n", "'label_vec_true'", ":", "torch", ".", "FloatTensor", "(", "np", ".", "copy", "(", "self", ".", "label_matrix", "[", "idx", ",", ":", "]", ")", ")", ",", "\n", "'idx'", ":", "idx", ",", "\n", "# 'image_path': image_path # added for CAM visualization purpose", "\n", "}", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_metadata": [[10, 38], ["NotImplementedError"], "function", ["None"], ["def", "get_metadata", "(", "dataset_name", ")", ":", "\n", "    ", "if", "dataset_name", "==", "'pascal'", ":", "\n", "        ", "meta", "=", "{", "\n", "'num_classes'", ":", "20", ",", "\n", "'path_to_dataset'", ":", "'data/pascal'", ",", "\n", "'path_to_images'", ":", "'data/pascal/VOCdevkit/VOC2012/JPEGImages'", "\n", "}", "\n", "", "elif", "dataset_name", "==", "'coco'", ":", "\n", "        ", "meta", "=", "{", "\n", "'num_classes'", ":", "80", ",", "\n", "'path_to_dataset'", ":", "'data/coco'", ",", "\n", "'path_to_images'", ":", "'data/coco'", "\n", "}", "\n", "", "elif", "dataset_name", "==", "'nuswide'", ":", "\n", "        ", "meta", "=", "{", "\n", "'num_classes'", ":", "81", ",", "\n", "'path_to_dataset'", ":", "'data/nuswide'", ",", "\n", "'path_to_images'", ":", "'data/nuswide/Flickr'", "\n", "}", "\n", "", "elif", "dataset_name", "==", "'cub'", ":", "\n", "        ", "meta", "=", "{", "\n", "'num_classes'", ":", "312", ",", "\n", "'path_to_dataset'", ":", "'data/cub'", ",", "\n", "'path_to_images'", ":", "'data/cub/CUB_200_2011/images'", "\n", "}", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Metadata dictionary not implemented.'", ")", "\n", "", "return", "meta", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_imagenet_stats": [[39, 48], ["None"], "function", ["None"], ["", "def", "get_imagenet_stats", "(", ")", ":", "\n", "    ", "'''\n    Returns standard ImageNet statistics. \n    '''", "\n", "\n", "imagenet_mean", "=", "[", "0.485", ",", "0.456", ",", "0.406", "]", "\n", "imagenet_std", "=", "[", "0.229", ",", "0.224", ",", "0.225", "]", "\n", "\n", "return", "(", "imagenet_mean", ",", "imagenet_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_transforms": [[49, 74], ["datasets.get_imagenet_stats", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Resize", "torchvision.transforms.RandomHorizontalFlip", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.Resize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.Resize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_imagenet_stats"], ["", "def", "get_transforms", "(", ")", ":", "\n", "    ", "'''\n    Returns image transforms.\n    '''", "\n", "\n", "(", "imagenet_mean", ",", "imagenet_std", ")", "=", "get_imagenet_stats", "(", ")", "\n", "tx", "=", "{", "}", "\n", "tx", "[", "'train'", "]", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "Resize", "(", "(", "448", ",", "448", ")", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", "0.5", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "mean", "=", "imagenet_mean", ",", "std", "=", "imagenet_std", ")", "\n", "]", ")", "\n", "tx", "[", "'val'", "]", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "Resize", "(", "(", "448", ",", "448", ")", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "mean", "=", "imagenet_mean", ",", "std", "=", "imagenet_std", ")", "\n", "]", ")", "\n", "tx", "[", "'test'", "]", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "Resize", "(", "(", "448", ",", "448", ")", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "mean", "=", "imagenet_mean", ",", "std", "=", "imagenet_std", ")", "\n", "]", ")", "\n", "\n", "return", "tx", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.generate_split": [[75, 93], ["int", "rng.permutation", "numpy.sort", "numpy.sort", "numpy.round"], "function", ["None"], ["", "def", "generate_split", "(", "num_ex", ",", "frac", ",", "rng", ")", ":", "\n", "    ", "'''\n    Computes indices for a randomized split of num_ex objects into two parts,\n    so we return two index vectors: idx_1 and idx_2. Note that idx_1 has length\n    (1.0 - frac)*num_ex and idx_2 has length frac*num_ex. Sorted index sets are \n    returned because this function is for splitting, not shuffling. \n    '''", "\n", "\n", "# compute size of each split:", "\n", "n_2", "=", "int", "(", "np", ".", "round", "(", "frac", "*", "num_ex", ")", ")", "\n", "n_1", "=", "num_ex", "-", "n_2", "\n", "\n", "# assign indices to splits:", "\n", "idx_rand", "=", "rng", ".", "permutation", "(", "num_ex", ")", "\n", "idx_1", "=", "np", ".", "sort", "(", "idx_rand", "[", ":", "n_1", "]", ")", "\n", "idx_2", "=", "np", ".", "sort", "(", "idx_rand", "[", "-", "n_2", ":", "]", ")", "\n", "\n", "return", "(", "idx_1", ",", "idx_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_data": [[94, 134], ["datasets.get_transforms", "copy.deepcopy", "multilabel().get_datasets", "print", "copy.deepcopy", "print", "print", "copy.deepcopy", "print", "multilabel().get_datasets", "datasets.multilabel", "multilabel().get_datasets", "datasets.multilabel", "multilabel().get_datasets", "ValueError", "datasets.multilabel", "datasets.multilabel"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_transforms", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.multilabel.get_datasets", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.multilabel.get_datasets", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.multilabel.get_datasets", "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.multilabel.get_datasets"], ["", "def", "get_data", "(", "P", ")", ":", "\n", "    ", "'''\n    Given a parameter dictionary P, initialize and return the specified dataset. \n    '''", "\n", "\n", "# define transforms:", "\n", "tx", "=", "get_transforms", "(", ")", "\n", "\n", "# select and return the right dataset:", "\n", "if", "P", "[", "'dataset'", "]", "==", "'coco'", ":", "\n", "        ", "ds", "=", "multilabel", "(", "P", ",", "tx", ")", ".", "get_datasets", "(", ")", "\n", "", "elif", "P", "[", "'dataset'", "]", "==", "'pascal'", ":", "\n", "        ", "ds", "=", "multilabel", "(", "P", ",", "tx", ")", ".", "get_datasets", "(", ")", "\n", "", "elif", "P", "[", "'dataset'", "]", "==", "'nuswide'", ":", "\n", "        ", "ds", "=", "multilabel", "(", "P", ",", "tx", ")", ".", "get_datasets", "(", ")", "\n", "", "elif", "P", "[", "'dataset'", "]", "==", "'cub'", ":", "\n", "        ", "ds", "=", "multilabel", "(", "P", ",", "tx", ")", ".", "get_datasets", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown dataset.'", ")", "\n", "\n", "# Optionally overwrite the observed training labels with clean labels:", "\n", "# assert P['train_set_variant'] in ['clean', 'observed']", "\n", "", "if", "P", "[", "'train_set_variant'", "]", "==", "'clean'", ":", "\n", "        ", "print", "(", "'Using clean labels for training.'", ")", "\n", "ds", "[", "'train'", "]", ".", "label_matrix_obs", "=", "copy", ".", "deepcopy", "(", "ds", "[", "'train'", "]", ".", "label_matrix", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "'Using single positive labels for training.'", ")", "\n", "\n", "# Optionally overwrite the observed val labels with clean labels:", "\n", "", "assert", "P", "[", "'val_set_variant'", "]", "in", "[", "'clean'", ",", "'observed'", "]", "\n", "if", "P", "[", "'val_set_variant'", "]", "==", "'clean'", ":", "\n", "        ", "print", "(", "'Using clean labels for validation.'", ")", "\n", "ds", "[", "'val'", "]", ".", "label_matrix_obs", "=", "copy", ".", "deepcopy", "(", "ds", "[", "'val'", "]", ".", "label_matrix", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "'Using single positive labels for validation.'", ")", "\n", "\n", "# We always use a clean test set:", "\n", "", "ds", "[", "'test'", "]", ".", "label_matrix_obs", "=", "copy", ".", "deepcopy", "(", "ds", "[", "'test'", "]", ".", "label_matrix", ")", "\n", "\n", "return", "ds", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.load_data": [[135, 144], ["numpy.load", "numpy.load", "numpy.load", "os.path.join", "os.path.join", "os.path.join", "numpy.load"], "function", ["None"], ["", "def", "load_data", "(", "base_path", ",", "P", ")", ":", "\n", "    ", "data", "=", "{", "}", "\n", "for", "phase", "in", "[", "'train'", ",", "'val'", "]", ":", "\n", "        ", "data", "[", "phase", "]", "=", "{", "}", "\n", "data", "[", "phase", "]", "[", "'labels'", "]", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "base_path", ",", "'formatted_{}_labels.npy'", ".", "format", "(", "phase", ")", ")", ")", "\n", "data", "[", "phase", "]", "[", "'labels_obs'", "]", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "base_path", ",", "'formatted_{}_labels_obs.npy'", ".", "format", "(", "phase", ")", ")", ")", "\n", "data", "[", "phase", "]", "[", "'images'", "]", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "base_path", ",", "'formatted_{}_images.npy'", ".", "format", "(", "phase", ")", ")", ")", "\n", "data", "[", "phase", "]", "[", "'feats'", "]", "=", "np", ".", "load", "(", "P", "[", "'{}_feats_file'", ".", "format", "(", "phase", ")", "]", ")", "if", "P", "[", "'use_feats'", "]", "else", "[", "]", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.parse_categories": [[248, 255], ["range", "len", "category_list.append"], "function", ["None"], ["", "", "def", "parse_categories", "(", "categories", ")", ":", "\n", "    ", "category_list", "=", "[", "]", "\n", "id_to_index", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "categories", ")", ")", ":", "\n", "        ", "category_list", ".", "append", "(", "categories", "[", "i", "]", "[", "'name'", "]", ")", "\n", "id_to_index", "[", "categories", "[", "i", "]", "[", "'id'", "]", "]", "=", "i", "\n", "", "return", "(", "category_list", ",", "id_to_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.None.datasets.get_category_list": [[256, 299], ["datasets.parse_categories", "open", "json.load", "os.path.join"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.preproc.format_coco.parse_categories"], ["", "def", "get_category_list", "(", "P", ")", ":", "\n", "    ", "if", "P", "[", "'dataset'", "]", "==", "'pascal'", ":", "\n", "        ", "catName_to_catID", "=", "{", "\n", "'aeroplane'", ":", "0", ",", "\n", "'bicycle'", ":", "1", ",", "\n", "'bird'", ":", "2", ",", "\n", "'boat'", ":", "3", ",", "\n", "'bottle'", ":", "4", ",", "\n", "'bus'", ":", "5", ",", "\n", "'car'", ":", "6", ",", "\n", "'cat'", ":", "7", ",", "\n", "'chair'", ":", "8", ",", "\n", "'cow'", ":", "9", ",", "\n", "'diningtable'", ":", "10", ",", "\n", "'dog'", ":", "11", ",", "\n", "'horse'", ":", "12", ",", "\n", "'motorbike'", ":", "13", ",", "\n", "'person'", ":", "14", ",", "\n", "'pottedplant'", ":", "15", ",", "\n", "'sheep'", ":", "16", ",", "\n", "'sofa'", ":", "17", ",", "\n", "'train'", ":", "18", ",", "\n", "'tvmonitor'", ":", "19", "\n", "}", "\n", "return", "{", "catName_to_catID", "[", "k", "]", ":", "k", "for", "k", "in", "catName_to_catID", "}", "\n", "\n", "", "elif", "P", "[", "'dataset'", "]", "==", "'coco'", ":", "\n", "        ", "load_path", "=", "'data/coco'", "\n", "meta", "=", "{", "}", "\n", "meta", "[", "'category_id_to_index'", "]", "=", "{", "}", "\n", "meta", "[", "'category_list'", "]", "=", "[", "]", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "load_path", ",", "'annotations'", ",", "'instances_train2014.json'", ")", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "D", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "(", "meta", "[", "'category_list'", "]", ",", "meta", "[", "'category_id_to_index'", "]", ")", "=", "parse_categories", "(", "D", "[", "'categories'", "]", ")", "\n", "return", "meta", "[", "'category_list'", "]", "\n", "\n", "", "elif", "P", "[", "'dataset'", "]", "==", "'nuswide'", ":", "\n", "        ", "pass", "# TODO", "\n", "\n", "", "elif", "P", "[", "'dataset'", "]", "==", "'cub'", ":", "\n", "        ", "pass", "# TODO", "", "", "", ""]], "home.repos.pwc.inspect_result.snucml_largelossmatters.preproc.generate_observed_labels.get_random_label_indices": [[12, 32], ["rng.shuffle", "numpy.nonzero"], "function", ["None"], ["def", "get_random_label_indices", "(", "label_vec", ",", "label_value", ",", "num_sel", ",", "rng", ")", ":", "\n", "    ", "'''\n    Given a 1D numpy array label_vec, return num_sel indices chosen at random\n    from all indices where label_vec equals label_value.\n    Note that all relevant indices are returned if fewer than num_sel are found.\n    '''", "\n", "\n", "# find all indices where label_vec is equal to label_value:", "\n", "idx_all", "=", "np", ".", "nonzero", "(", "label_vec", "==", "label_value", ")", "[", "0", "]", "\n", "\n", "# shuffle those indices:", "\n", "rng", ".", "shuffle", "(", "idx_all", ")", "\n", "\n", "# return (up to) the first num_sel indices:", "\n", "if", "num_sel", "==", "-", "1", ":", "\n", "        ", "idx_sel", "=", "idx_all", "\n", "", "else", ":", "\n", "        ", "idx_sel", "=", "idx_all", "[", ":", "num_sel", "]", "\n", "\n", "", "return", "idx_sel", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.preproc.generate_observed_labels.observe_uniform": [[33, 63], ["numpy.unique", "numpy.shape", "numpy.zeros_like", "range", "type", "len", "len", "generate_observed_labels.get_random_label_indices", "generate_observed_labels.get_random_label_indices", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.snucml_largelossmatters.preproc.generate_observed_labels.get_random_label_indices", "home.repos.pwc.inspect_result.snucml_largelossmatters.preproc.generate_observed_labels.get_random_label_indices"], ["", "def", "observe_uniform", "(", "label_matrix", ",", "num_pos", ",", "num_neg", ",", "rng", ")", ":", "\n", "    ", "'''\n    label_matrix: binary (-1/+1) label matrix with shape num_items x num_classes\n    num_pos: number of positive labels to observe for each item\n    num_neg: number of negative labes to observe for each item\n    rng: random number generator to use\n    '''", "\n", "\n", "# check the observation parameters:", "\n", "assert", "(", "num_pos", "==", "-", "1", ")", "or", "(", "num_pos", ">=", "0", ")", "\n", "assert", "(", "num_neg", "==", "-", "1", ")", "or", "(", "num_neg", ">=", "0", ")", "\n", "\n", "# check that label_matrix is a binary numpy array:", "\n", "assert", "type", "(", "label_matrix", ")", "is", "np", ".", "ndarray", "\n", "label_values", "=", "np", ".", "unique", "(", "label_matrix", ")", "\n", "assert", "len", "(", "label_values", ")", "==", "2", "\n", "assert", "-", "1", "in", "label_values", "\n", "assert", "1", "in", "label_values", "\n", "assert", "len", "(", "np", ".", "unique", "(", "label_matrix", ")", ")", "==", "2", "\n", "\n", "# apply uniform observation process:", "\n", "num_items", ",", "num_classes", "=", "np", ".", "shape", "(", "label_matrix", ")", "\n", "label_matrix_obs", "=", "np", ".", "zeros_like", "(", "label_matrix", ")", "\n", "for", "i", "in", "range", "(", "num_items", ")", ":", "\n", "        ", "idx_pos", "=", "get_random_label_indices", "(", "label_matrix", "[", "i", ",", ":", "]", ",", "1.0", ",", "num_pos", ",", "rng", ")", "\n", "label_matrix_obs", "[", "i", ",", "idx_pos", "]", "=", "1.0", "\n", "idx_neg", "=", "get_random_label_indices", "(", "label_matrix", "[", "i", ",", ":", "]", ",", "-", "1.0", ",", "num_neg", ",", "rng", ")", "\n", "label_matrix_obs", "[", "i", ",", "idx_neg", "]", "=", "-", "1.0", "\n", "\n", "", "return", "label_matrix_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.snucml_largelossmatters.preproc.format_coco.parse_categories": [[11, 18], ["range", "len", "category_list.append"], "function", ["None"], ["def", "parse_categories", "(", "categories", ")", ":", "\n", "    ", "category_list", "=", "[", "]", "\n", "id_to_index", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "categories", ")", ")", ":", "\n", "        ", "category_list", ".", "append", "(", "categories", "[", "i", "]", "[", "'name'", "]", ")", "\n", "id_to_index", "[", "categories", "[", "i", "]", "[", "'id'", "]", "]", "=", "i", "\n", "", "return", "(", "category_list", ",", "id_to_index", ")", "\n", "\n"]]}