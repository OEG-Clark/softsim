{"home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__init__": [[9, 61], ["numpy.zeros", "numpy.asarray", "numpy.zeros", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "n_param", ",", "window_mvg_average", "=", "50", ",", "window_drift_detect", "=", "50", ",", "beta", "=", "0.0001", ",", "base_model", "=", "'probit'", ",", "\n", "init_mu", "=", "0", ",", "init_sigma", "=", "1", ",", "epochs", "=", "10", ",", "lr_mu", "=", "0.01", ",", "lr_sigma", "=", "0.01", ")", ":", "\n", "        ", "\"\"\"\n        ERICS: Effective and Robust Identification of Concept Shift\n\n        please cite:\n        [1] ERICS Paper (Todo)\n\n        [2] Haug, Johannes, et al. \"Leveraging Model Inherent Variable Importance for Stable Online Feature Selection.\"\n        Proceedings of the 26th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining. 2020.\n\n        :param n_param: (int) Total no. of parameters (corresponds to no. of features for probit model)\n        :param window_mvg_average: (int) Window Size for computation of moving average\n        :param window_drift_detect: (int) Window Size for Drift Detection\n        :param beta: (float) Update rate for the alpha-threshold\n        :param base_model: (str) Name of the base predictive model (whose parameters we investigate)\n        :param init_mu: (int) Initialize mean of parameter distributions (according to [2])\n        :param init_sigma: (int) Initialize variance of parameter distributions (according to [2])\n        :param epochs: (int) Number of epochs for optimization of parameter distributions (according to [2])\n        :param lr_mu: (float) Learning rate for the gradient update of the mean (according to [2])\n        :param lr_sigma: (float) Learning rate for the gradient update of the variance (according to [2])\n        \"\"\"", "\n", "# User-set ERICS-hyperparameters", "\n", "self", ".", "n_param", "=", "n_param", "\n", "self", ".", "M", "=", "window_mvg_average", "\n", "self", ".", "W", "=", "window_drift_detect", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "base_model", "=", "base_model", "\n", "\n", "# Default hyperparameters", "\n", "self", ".", "time_step", "=", "0", "# Current Time Step", "\n", "self", ".", "time_since_last_global_drift", "=", "0", "# Time steps since last global drift detection", "\n", "self", ".", "time_since_last_partial_drift", "=", "np", ".", "zeros", "(", "n_param", ")", "# Time steps since last partial drift detection", "\n", "self", ".", "global_drifts", "=", "[", "]", "# Time steps of all global drifts", "\n", "self", ".", "partial_drifts", "=", "[", "]", "# (time step, param.idx)-tuples of all partial drifts", "\n", "self", ".", "alpha", "=", "None", "# Adaptive threshold for global concept drift detection", "\n", "self", ".", "partial_alpha", "=", "np", ".", "asarray", "(", "[", "None", "]", "*", "self", ".", "n_param", ")", "# Adaptive threshold for partial concept drift detection", "\n", "self", ".", "mu_w", "=", "np", ".", "ones", "(", "(", "self", ".", "M", ",", "self", ".", "n_param", ")", ")", "*", "init_mu", "# Parameter Mean in window", "\n", "self", ".", "sigma_w", "=", "np", ".", "ones", "(", "(", "self", ".", "M", ",", "self", ".", "n_param", ")", ")", "*", "init_sigma", "# Parameter Variance in window", "\n", "self", ".", "param_sum", "=", "np", ".", "zeros", "(", "(", "self", ".", "M", "-", "1", ",", "self", ".", "n_param", ")", ")", "# Sum-expression for computation of moving average (see Eq. (8) in [1])", "\n", "self", ".", "global_info_ma", "=", "[", "]", "# Global moving average", "\n", "self", ".", "partial_info_ma", "=", "[", "]", "# Partial moving average", "\n", "\n", "# Parameters of FIRES (Probit) model according to [2]", "\n", "if", "self", ".", "base_model", "==", "'probit'", ":", "\n", "            ", "self", ".", "fires_mu", "=", "np", ".", "ones", "(", "self", ".", "n_param", ")", "*", "init_mu", "\n", "self", ".", "fires_sigma", "=", "np", ".", "ones", "(", "self", ".", "n_param", ")", "*", "init_sigma", "\n", "self", ".", "fires_epochs", "=", "epochs", "\n", "self", ".", "fires_lr_mu", "=", "lr_mu", "\n", "self", ".", "fires_lr_sigma", "=", "lr_sigma", "\n", "self", ".", "fires_labels", "=", "[", "]", "# Unique labels (fires requires binary labels)", "\n", "self", ".", "fires_encode_labels", "=", "True", "# Indicator for warning message (auto-encoded labels)", "\n", "\n"]], "home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.check_drift": [[67, 106], ["range", "time.time", "erics.ERICS.__update_param_sum", "erics.ERICS.__compute_moving_average", "erics.ERICS.__detect_drift", "erics.ERICS.__update_probit", "NotImplementedError", "time.time"], "methods", ["home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__update_param_sum", "home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__compute_moving_average", "home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__detect_drift", "home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__update_probit"], ["", "", "def", "check_drift", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        Process data batch and check for concept drift\n\n        :param x: (np.ndarray) Batch of observations\n        :param y: (np.ndarray) Batch of labels\n        :return: indicator global drift, indicator partial drift, computation time in sec.\n        :rtype bool, bool, float\n        \"\"\"", "\n", "# Update alpha (Eq. 7 in [1])", "\n", "if", "self", ".", "alpha", "is", "not", "None", ":", "\n", "            ", "self", ".", "alpha", "-=", "(", "self", ".", "alpha", "*", "self", ".", "beta", "*", "self", ".", "time_since_last_global_drift", ")", "\n", "", "for", "k", "in", "range", "(", "self", ".", "n_param", ")", ":", "# partial alpha", "\n", "            ", "if", "self", ".", "partial_alpha", "[", "k", "]", "is", "not", "None", ":", "\n", "                ", "self", ".", "partial_alpha", "[", "k", "]", "-=", "(", "self", ".", "partial_alpha", "[", "k", "]", "*", "self", ".", "beta", "*", "self", ".", "time_since_last_partial_drift", "[", "k", "]", ")", "\n", "\n", "# Update time since drift", "\n", "", "", "self", ".", "time_since_last_global_drift", "+=", "1", "\n", "self", ".", "time_since_last_partial_drift", "+=", "1", "\n", "\n", "# Update Parameter distribution", "\n", "if", "self", ".", "base_model", "==", "'probit'", ":", "\n", "            ", "self", ".", "__update_probit", "(", "x", ",", "y", ")", "# Probit model", "\n", "# ### ADD YOUR OWN MODEL HERE #######################################", "\n", "# elif(self.base_model == 'your_model':", "\n", "#   self.__update_your_model(x,y)", "\n", "#####################################################################", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'The base model {} has not been implemented.'", ".", "format", "(", "self", ".", "base_model", ")", ")", "\n", "\n", "", "start", "=", "time", ".", "time", "(", ")", "# Start time drift detection", "\n", "self", ".", "__update_param_sum", "(", ")", "# Update the sum expression for observations in a shifting window", "\n", "self", ".", "__compute_moving_average", "(", ")", "# Compute moving average in specified window", "\n", "g_drift", ",", "p_drift", "=", "self", ".", "__detect_drift", "(", ")", "# Detect concept drift", "\n", "\n", "# Update time step", "\n", "self", ".", "time_step", "+=", "1", "\n", "\n", "return", "g_drift", ",", "p_drift", ",", "time", ".", "time", "(", ")", "-", "start", "\n", "\n"]], "home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__update_param_sum": [[107, 134], ["numpy.concatenate", "numpy.concatenate", "range", "copy.copy().reshape", "copy.copy().reshape", "NotImplementedError", "copy.copy", "copy.copy"], "methods", ["None"], ["", "def", "__update_param_sum", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Retrieve current parameter distribution and compute sum expression according to Eq. (8) in the ERICS paper [1]\n        \"\"\"", "\n", "# Retrieve current distribution parameters", "\n", "if", "self", ".", "base_model", "==", "'probit'", ":", "\n", "            ", "new_mu", "=", "copy", ".", "copy", "(", "self", ".", "fires_mu", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "new_sigma", "=", "copy", ".", "copy", "(", "self", ".", "fires_sigma", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "# ### ADD YOUR OWN MODEL HERE #######################################", "\n", "# elif(self.base_model == 'your_model':", "\n", "#   new_mu = your_model.mu", "\n", "#   new_sigma = your_model.sigma", "\n", "#####################################################################", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'The base model {} has not been implemented.'", ".", "format", "(", "self", ".", "base_model", ")", ")", "\n", "\n", "# Drop oldest entry from window", "\n", "", "self", ".", "mu_w", "=", "self", ".", "mu_w", "[", "1", ":", ",", ":", "]", "\n", "self", ".", "sigma_w", "=", "self", ".", "sigma_w", "[", "1", ":", ",", ":", "]", "\n", "\n", "# Add new entry to window", "\n", "self", ".", "mu_w", "=", "np", ".", "concatenate", "(", "(", "self", ".", "mu_w", ",", "new_mu", ")", ")", "\n", "self", ".", "sigma_w", "=", "np", ".", "concatenate", "(", "(", "self", ".", "sigma_w", ",", "new_sigma", ")", ")", "\n", "\n", "# Compute parameter sum expression", "\n", "for", "t", "in", "range", "(", "self", ".", "M", "-", "1", ")", ":", "\n", "            ", "self", ".", "param_sum", "[", "t", ",", ":", "]", "=", "(", "self", ".", "sigma_w", "[", "t", "+", "1", ",", ":", "]", "**", "2", "+", "(", "self", ".", "mu_w", "[", "t", ",", ":", "]", "-", "self", ".", "mu_w", "[", "t", "+", "1", ",", ":", "]", ")", "**", "2", ")", "/", "self", ".", "sigma_w", "[", "t", ",", ":", "]", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__compute_moving_average": [[135, 151], ["numpy.zeros", "numpy.zeros", "range", "erics.ERICS.global_info_ma.append", "erics.ERICS.partial_info_ma.append", "numpy.sum", "numpy.sum", "numpy.abs", "numpy.abs"], "methods", ["None"], ["", "", "def", "__compute_moving_average", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute the moving average (according to Eq. (8) in the ERICS paper [1])\n        \"\"\"", "\n", "partial_ma", "=", "np", ".", "zeros", "(", "self", ".", "n_param", ")", "\n", "global_score", "=", "np", ".", "zeros", "(", "self", ".", "M", "-", "1", ")", "\n", "\n", "for", "k", "in", "range", "(", "self", ".", "n_param", ")", ":", "\n", "            ", "partial_score", "=", "self", ".", "param_sum", "[", ":", ",", "k", "]", "-", "1", "\n", "global_score", "+=", "partial_score", "\n", "partial_ma", "[", "k", "]", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "partial_score", ")", ")", "/", "(", "2", "*", "self", ".", "M", ")", "# Add partial mov. avg. for parameter k", "\n", "\n", "", "global_ma", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "global_score", ")", ")", "/", "(", "2", "*", "self", ".", "M", ")", "\n", "\n", "self", ".", "global_info_ma", ".", "append", "(", "global_ma", ")", "\n", "self", ".", "partial_info_ma", ".", "append", "(", "partial_ma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__detect_drift": [[152, 209], ["numpy.argwhere", "warnings.warn", "len", "len", "copy.copy", "copy.copy", "range", "numpy.abs", "numpy.isnan().flatten", "numpy.abs", "erics.ERICS.global_drifts.append", "erics.ERICS.partial_drifts.append", "numpy.isnan", "k.item", "erics.ERICS.partial_alpha.astype"], "methods", ["None"], ["", "def", "__detect_drift", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Detect global and partial concept drift using the adaptive alpha-threshold\n\n        :return: global drift indicator, partial drift indicator\n        :rtype: bool, bool\n        \"\"\"", "\n", "global_window_delta", "=", "None", "\n", "partial_window_delta", "=", "None", "\n", "\n", "# Compute delta in sliding window W (according to Eq. (5) in the ERICS paper [1])", "\n", "if", "self", ".", "W", "<", "2", ":", "\n", "            ", "self", ".", "W", "=", "2", "\n", "warn", "(", "'Sliding window for concept drift detection was automatically set to 2 observations.'", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "global_info_ma", ")", "<", "self", ".", "W", ":", "\n", "            ", "oldest_entry", "=", "len", "(", "self", ".", "global_info_ma", ")", "\n", "", "else", ":", "\n", "            ", "oldest_entry", "=", "self", ".", "W", "\n", "\n", "", "if", "oldest_entry", "==", "1", ":", "# In case of only one observation", "\n", "            ", "global_window_delta", "=", "copy", ".", "copy", "(", "self", ".", "global_info_ma", "[", "-", "1", "]", ")", "\n", "partial_window_delta", "=", "copy", ".", "copy", "(", "self", ".", "partial_info_ma", "[", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "for", "t", "in", "range", "(", "oldest_entry", ",", "1", ",", "-", "1", ")", ":", "\n", "                ", "if", "t", "==", "oldest_entry", ":", "\n", "                    ", "global_window_delta", "=", "self", ".", "global_info_ma", "[", "-", "t", "+", "1", "]", "-", "self", ".", "global_info_ma", "[", "-", "t", "]", "# newer - older", "\n", "partial_window_delta", "=", "self", ".", "partial_info_ma", "[", "-", "t", "+", "1", "]", "-", "self", ".", "partial_info_ma", "[", "-", "t", "]", "\n", "", "else", ":", "\n", "                    ", "global_window_delta", "+=", "(", "self", ".", "global_info_ma", "[", "-", "t", "+", "1", "]", "-", "self", ".", "global_info_ma", "[", "-", "t", "]", ")", "\n", "partial_window_delta", "+=", "(", "self", ".", "partial_info_ma", "[", "-", "t", "+", "1", "]", "-", "self", ".", "partial_info_ma", "[", "-", "t", "]", ")", "\n", "\n", "# (Re-) Initialize alpha if it is None (at time step 0 or if a drift was detected)", "\n", "", "", "", "if", "self", ".", "alpha", "is", "None", ":", "\n", "            ", "self", ".", "alpha", "=", "np", ".", "abs", "(", "global_window_delta", ")", "# according to Eq. (6) in [1] -> abs() is only required at t=0, to make sure that alpha > 0", "\n", "", "if", "None", "in", "self", ".", "partial_alpha", ":", "\n", "            ", "unspecified", "=", "np", ".", "isnan", "(", "self", ".", "partial_alpha", ".", "astype", "(", "float", ")", ")", ".", "flatten", "(", ")", "\n", "self", ".", "partial_alpha", "[", "unspecified", "]", "=", "np", ".", "abs", "(", "partial_window_delta", "[", "unspecified", "]", ")", "\n", "\n", "# Global Drift Detection", "\n", "", "g_drift", "=", "False", "\n", "if", "global_window_delta", ">", "self", ".", "alpha", ":", "\n", "            ", "g_drift", "=", "True", "\n", "self", ".", "global_drifts", ".", "append", "(", "self", ".", "time_step", ")", "\n", "self", ".", "time_since_last_global_drift", "=", "0", "\n", "self", ".", "alpha", "=", "None", "\n", "\n", "# Partial Drift Detection", "\n", "", "p_drift", "=", "False", "\n", "partial_drift_bool", "=", "partial_window_delta", ">", "self", ".", "partial_alpha", "\n", "for", "k", "in", "np", ".", "argwhere", "(", "partial_drift_bool", ")", ":", "\n", "            ", "p_drift", "=", "True", "\n", "self", ".", "partial_drifts", ".", "append", "(", "(", "self", ".", "time_step", ",", "k", ".", "item", "(", ")", ")", ")", "\n", "self", ".", "time_since_last_partial_drift", "[", "k", "]", "=", "0", "\n", "self", ".", "partial_alpha", "[", "k", "]", "=", "None", "\n", "\n", "", "return", "g_drift", ",", "p_drift", "\n", "\n"]], "home.repos.pwc.inspect_result.haugjo_erics.None.erics.ERICS.__update_probit": [[213, 266], ["numpy.unique", "range", "tuple", "numpy.random.permutation", "set", "erics.ERICS.fires_labels.append", "warnings.warn", "len", "len", "numpy.dot", "numpy.sqrt", "scipy.stats.norm.cdf", "len", "ValueError", "scipy.stats.norm.pdf", "scipy.stats.norm.pdf", "numpy.mean", "numpy.mean", "TypeError", "numpy.dot"], "methods", ["None"], ["", "def", "__update_probit", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        Update parameters of the Probit model\n\n        According to [2], as implemented here https://github.com/haugjo/fires\n        We have slightly adjusted the original code to fit our use case.\n\n        :param x: (np.ndarray) Batch of observations (numeric values only, consider normalizing data for better results)\n        :param y: (np.ndarray) Batch of labels: type binary, i.e. {-1,1} (bool, int or str will be encoded accordingly)\n        \"\"\"", "\n", "# Encode labels", "\n", "for", "y_val", "in", "np", ".", "unique", "(", "y", ")", ":", "# Add newly observed unique labels", "\n", "            ", "if", "y_val", "not", "in", "set", "(", "self", ".", "fires_labels", ")", ":", "\n", "                ", "self", ".", "fires_labels", ".", "append", "(", "y_val", ")", "\n", "\n", "", "", "if", "tuple", "(", "self", ".", "fires_labels", ")", "!=", "(", "-", "1", ",", "1", ")", ":", "# Check if labels are encoded correctly", "\n", "            ", "if", "self", ".", "fires_encode_labels", ":", "\n", "                ", "warn", "(", "'FIRES WARNING: The target variable will automatically be encoded as {-1, 1}.'", ")", "\n", "self", ".", "fires_encode_labels", "=", "False", "# set indicator to false", "\n", "\n", "", "if", "len", "(", "self", ".", "fires_labels", ")", "<", "2", ":", "\n", "                ", "y", "[", "y", "==", "self", ".", "fires_labels", "[", "0", "]", "]", "=", "-", "1", "\n", "", "elif", "len", "(", "self", ".", "fires_labels", ")", "==", "2", ":", "\n", "                ", "y", "[", "y", "==", "self", ".", "fires_labels", "[", "0", "]", "]", "=", "-", "1", "\n", "y", "[", "y", "==", "self", ".", "fires_labels", "[", "1", "]", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'The target variable y must be binary.'", ")", "\n", "\n", "", "", "for", "epoch", "in", "range", "(", "self", ".", "fires_epochs", ")", ":", "\n", "# Shuffle the observations", "\n", "            ", "random_idx", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "y", ")", ")", "\n", "x", "=", "x", "[", "random_idx", "]", "\n", "y", "=", "y", "[", "random_idx", "]", "\n", "\n", "# Iterative update of mu and sigma", "\n", "try", ":", "\n", "# Helper functions", "\n", "                ", "dot_mu_x", "=", "np", ".", "dot", "(", "x", ",", "self", ".", "fires_mu", ")", "\n", "rho", "=", "np", ".", "sqrt", "(", "1", "+", "np", ".", "dot", "(", "x", "**", "2", ",", "self", ".", "fires_sigma", "**", "2", ")", ")", "\n", "\n", "# Gradients", "\n", "nabla_mu", "=", "norm", ".", "pdf", "(", "y", "/", "rho", "*", "dot_mu_x", ")", "*", "(", "y", "/", "rho", "*", "x", ".", "T", ")", "\n", "nabla_sigma", "=", "norm", ".", "pdf", "(", "y", "/", "rho", "*", "dot_mu_x", ")", "*", "(", "\n", "-", "y", "/", "(", "2", "*", "rho", "**", "3", ")", "*", "2", "*", "(", "x", "**", "2", "*", "self", ".", "fires_sigma", ")", ".", "T", "*", "dot_mu_x", ")", "\n", "\n", "# Marginal Likelihood", "\n", "marginal", "=", "norm", ".", "cdf", "(", "y", "/", "rho", "*", "dot_mu_x", ")", "\n", "\n", "# Update parameters", "\n", "self", ".", "fires_mu", "+=", "self", ".", "fires_lr_mu", "*", "np", ".", "mean", "(", "nabla_mu", "/", "marginal", ",", "axis", "=", "1", ")", "\n", "self", ".", "fires_sigma", "+=", "self", ".", "fires_lr_sigma", "*", "np", ".", "mean", "(", "nabla_sigma", "/", "marginal", ",", "axis", "=", "1", ")", "\n", "", "except", "TypeError", "as", "e", ":", "\n", "                ", "raise", "TypeError", "(", "'All features must be a numeric data type.'", ")", "from", "e", "\n", "\n"]]}