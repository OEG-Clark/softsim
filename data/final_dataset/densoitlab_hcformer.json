{"home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.Trainer.build_evaluator": [[60, 141], ["detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "evaluator_list.append", "detectron2.evaluation.LVISEvaluator", "len", "NotImplementedError", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.COCOEvaluator", "evaluator_list.append", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.SemSegEvaluator", "hcformer.InstanceSegEvaluator", "detectron2.evaluation.SemSegEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "torch.cuda.device_count", "detectron2.get_rank", "evaluator_list.append", "evaluator_list.append", "hcformer.InstanceSegEvaluator", "len", "detectron2.evaluation.COCOPanopticEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.evaluation.CityscapesSemSegEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.evaluation.CityscapesInstanceEvaluator"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create evaluator(s) for a given dataset.\n        This uses the special metadata \"evaluator_type\" associated with each\n        builtin dataset. For your own dataset, you can simply create an\n        evaluator manually in your script and do not have to worry about the\n        hacky if-else logic here.\n        \"\"\"", "\n", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluator_list", "=", "[", "]", "\n", "evaluator_type", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "evaluator_type", "\n", "# semantic segmentation", "\n", "if", "evaluator_type", "in", "[", "\"sem_seg\"", ",", "\"ade20k_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "\n", "SemSegEvaluator", "(", "\n", "dataset_name", ",", "\n", "distributed", "=", "True", ",", "\n", "output_dir", "=", "output_folder", ",", "\n", ")", "\n", ")", "\n", "# instance segmentation", "\n", "", "if", "evaluator_type", "==", "\"coco\"", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOEvaluator", "(", "dataset_name", ",", "output_dir", "=", "output_folder", ")", ")", "\n", "# panoptic segmentation", "\n", "", "if", "evaluator_type", "in", "[", "\n", "\"coco_panoptic_seg\"", ",", "\n", "\"ade20k_panoptic_seg\"", ",", "\n", "\"cityscapes_panoptic_seg\"", ",", "\n", "\"mapillary_vistas_panoptic_seg\"", ",", "\n", "]", ":", "\n", "            ", "if", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "PANOPTIC_ON", ":", "\n", "                ", "evaluator_list", ".", "append", "(", "COCOPanopticEvaluator", "(", "dataset_name", ",", "output_folder", ")", ")", "\n", "# COCO", "\n", "", "", "if", "evaluator_type", "==", "\"coco_panoptic_seg\"", "and", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "INSTANCE_ON", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOEvaluator", "(", "dataset_name", ",", "output_dir", "=", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"coco_panoptic_seg\"", "and", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "SEMANTIC_ON", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "SemSegEvaluator", "(", "dataset_name", ",", "distributed", "=", "True", ",", "output_dir", "=", "output_folder", ")", ")", "\n", "# Mapillary Vistas", "\n", "", "if", "evaluator_type", "==", "\"mapillary_vistas_panoptic_seg\"", "and", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "INSTANCE_ON", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "InstanceSegEvaluator", "(", "dataset_name", ",", "output_dir", "=", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"mapillary_vistas_panoptic_seg\"", "and", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "SEMANTIC_ON", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "SemSegEvaluator", "(", "dataset_name", ",", "distributed", "=", "True", ",", "output_dir", "=", "output_folder", ")", ")", "\n", "# Cityscapes", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_instance\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesInstanceEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_sem_seg\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesSemSegEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_panoptic_seg\"", ":", "\n", "            ", "if", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "SEMANTIC_ON", ":", "\n", "                ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "evaluator_list", ".", "append", "(", "CityscapesSemSegEvaluator", "(", "dataset_name", ")", ")", "\n", "", "if", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "INSTANCE_ON", ":", "\n", "                ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "evaluator_list", ".", "append", "(", "CityscapesInstanceEvaluator", "(", "dataset_name", ")", ")", "\n", "# ADE20K", "\n", "", "", "if", "evaluator_type", "==", "\"ade20k_panoptic_seg\"", "and", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "INSTANCE_ON", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "InstanceSegEvaluator", "(", "dataset_name", ",", "output_dir", "=", "output_folder", ")", ")", "\n", "# LVIS", "\n", "", "if", "evaluator_type", "==", "\"lvis\"", ":", "\n", "            ", "return", "LVISEvaluator", "(", "dataset_name", ",", "output_dir", "=", "output_folder", ")", "\n", "", "if", "len", "(", "evaluator_list", ")", "==", "0", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"no Evaluator for the dataset {} with the type {}\"", ".", "format", "(", "\n", "dataset_name", ",", "evaluator_type", "\n", ")", "\n", ")", "\n", "", "elif", "len", "(", "evaluator_list", ")", "==", "1", ":", "\n", "            ", "return", "evaluator_list", "[", "0", "]", "\n", "", "return", "DatasetEvaluators", "(", "evaluator_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.Trainer.build_train_loader": [[142, 167], ["hcformer.MaskFormerSemanticDatasetMapper", "detectron2.data.build_detection_train_loader", "hcformer.MaskFormerPanopticDatasetMapper", "detectron2.data.build_detection_train_loader", "hcformer.MaskFormerInstanceDatasetMapper", "detectron2.data.build_detection_train_loader", "hcformer.COCOInstanceNewBaselineDatasetMapper", "detectron2.data.build_detection_train_loader", "hcformer.COCOPanopticNewBaselineDatasetMapper", "detectron2.data.build_detection_train_loader", "detectron2.data.build_detection_train_loader"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "build_train_loader", "(", "cls", ",", "cfg", ")", ":", "\n", "# Semantic segmentation dataset mapper", "\n", "        ", "if", "cfg", ".", "INPUT", ".", "DATASET_MAPPER_NAME", "==", "\"mask_former_semantic\"", ":", "\n", "            ", "mapper", "=", "MaskFormerSemanticDatasetMapper", "(", "cfg", ",", "True", ")", "\n", "return", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "mapper", ")", "\n", "# Panoptic segmentation dataset mapper", "\n", "", "elif", "cfg", ".", "INPUT", ".", "DATASET_MAPPER_NAME", "==", "\"mask_former_panoptic\"", ":", "\n", "            ", "mapper", "=", "MaskFormerPanopticDatasetMapper", "(", "cfg", ",", "True", ")", "\n", "return", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "mapper", ")", "\n", "# Instance segmentation dataset mapper", "\n", "", "elif", "cfg", ".", "INPUT", ".", "DATASET_MAPPER_NAME", "==", "\"mask_former_instance\"", ":", "\n", "            ", "mapper", "=", "MaskFormerInstanceDatasetMapper", "(", "cfg", ",", "True", ")", "\n", "return", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "mapper", ")", "\n", "# coco instance segmentation lsj new baseline", "\n", "", "elif", "cfg", ".", "INPUT", ".", "DATASET_MAPPER_NAME", "==", "\"coco_instance_lsj\"", ":", "\n", "            ", "mapper", "=", "COCOInstanceNewBaselineDatasetMapper", "(", "cfg", ",", "True", ")", "\n", "return", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "mapper", ")", "\n", "# coco panoptic segmentation lsj new baseline", "\n", "", "elif", "cfg", ".", "INPUT", ".", "DATASET_MAPPER_NAME", "==", "\"coco_panoptic_lsj\"", ":", "\n", "            ", "mapper", "=", "COCOPanopticNewBaselineDatasetMapper", "(", "cfg", ",", "True", ")", "\n", "return", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "mapper", ")", "\n", "", "else", ":", "\n", "            ", "mapper", "=", "None", "\n", "return", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "mapper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.Trainer.build_lr_scheduler": [[168, 175], ["detectron2.projects.deeplab.build_lr_scheduler"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.Trainer.build_lr_scheduler"], ["", "", "@", "classmethod", "\n", "def", "build_lr_scheduler", "(", "cls", ",", "cfg", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"\n        It now calls :func:`detectron2.solver.build_lr_scheduler`.\n        Overwrite it if you'd like a different scheduler.\n        \"\"\"", "\n", "return", "build_lr_scheduler", "(", "cfg", ",", "optimizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.Trainer.build_optimizer": [[176, 256], ["set", "model.named_modules", "module.named_parameters", "detectron2.solver.build.maybe_add_gradient_clipping", "memo.add", "copy.copy", "isinstance", "isinstance", "params.append", "train_net.Trainer.build_optimizer.maybe_add_full_model_gradient_clipping"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "build_optimizer", "(", "cls", ",", "cfg", ",", "model", ")", ":", "\n", "        ", "weight_decay_norm", "=", "cfg", ".", "SOLVER", ".", "WEIGHT_DECAY_NORM", "\n", "weight_decay_embed", "=", "cfg", ".", "SOLVER", ".", "WEIGHT_DECAY_EMBED", "\n", "\n", "defaults", "=", "{", "}", "\n", "defaults", "[", "\"lr\"", "]", "=", "cfg", ".", "SOLVER", ".", "BASE_LR", "\n", "defaults", "[", "\"weight_decay\"", "]", "=", "cfg", ".", "SOLVER", ".", "WEIGHT_DECAY", "\n", "\n", "norm_module_types", "=", "(", "\n", "torch", ".", "nn", ".", "BatchNorm1d", ",", "\n", "torch", ".", "nn", ".", "BatchNorm2d", ",", "\n", "torch", ".", "nn", ".", "BatchNorm3d", ",", "\n", "torch", ".", "nn", ".", "SyncBatchNorm", ",", "\n", "# NaiveSyncBatchNorm inherits from BatchNorm2d", "\n", "torch", ".", "nn", ".", "GroupNorm", ",", "\n", "torch", ".", "nn", ".", "InstanceNorm1d", ",", "\n", "torch", ".", "nn", ".", "InstanceNorm2d", ",", "\n", "torch", ".", "nn", ".", "InstanceNorm3d", ",", "\n", "torch", ".", "nn", ".", "LayerNorm", ",", "\n", "torch", ".", "nn", ".", "LocalResponseNorm", ",", "\n", ")", "\n", "\n", "params", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "[", "]", "\n", "memo", ":", "Set", "[", "torch", ".", "nn", ".", "parameter", ".", "Parameter", "]", "=", "set", "(", ")", "\n", "for", "module_name", ",", "module", "in", "model", ".", "named_modules", "(", ")", ":", "\n", "            ", "for", "module_param_name", ",", "value", "in", "module", ".", "named_parameters", "(", "recurse", "=", "False", ")", ":", "\n", "                ", "if", "not", "value", ".", "requires_grad", ":", "\n", "                    ", "continue", "\n", "# Avoid duplicating parameters", "\n", "", "if", "value", "in", "memo", ":", "\n", "                    ", "continue", "\n", "", "memo", ".", "add", "(", "value", ")", "\n", "\n", "hyperparams", "=", "copy", ".", "copy", "(", "defaults", ")", "\n", "if", "\"backbone\"", "in", "module_name", ":", "\n", "                    ", "hyperparams", "[", "\"lr\"", "]", "=", "hyperparams", "[", "\"lr\"", "]", "*", "cfg", ".", "SOLVER", ".", "BACKBONE_MULTIPLIER", "\n", "", "if", "(", "\n", "\"relative_position_bias_table\"", "in", "module_param_name", "\n", "or", "\"absolute_pos_embed\"", "in", "module_param_name", "\n", ")", ":", "\n", "                    ", "print", "(", "module_param_name", ")", "\n", "hyperparams", "[", "\"weight_decay\"", "]", "=", "0.0", "\n", "", "if", "isinstance", "(", "module", ",", "norm_module_types", ")", ":", "\n", "                    ", "hyperparams", "[", "\"weight_decay\"", "]", "=", "weight_decay_norm", "\n", "", "if", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "Embedding", ")", ":", "\n", "                    ", "hyperparams", "[", "\"weight_decay\"", "]", "=", "weight_decay_embed", "\n", "", "params", ".", "append", "(", "{", "\"params\"", ":", "[", "value", "]", ",", "**", "hyperparams", "}", ")", "\n", "\n", "", "", "def", "maybe_add_full_model_gradient_clipping", "(", "optim", ")", ":", "\n", "# detectron2 doesn't have full model gradient clipping now", "\n", "            ", "clip_norm_val", "=", "cfg", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "CLIP_VALUE", "\n", "enable", "=", "(", "\n", "cfg", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "ENABLED", "\n", "and", "cfg", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "CLIP_TYPE", "==", "\"full_model\"", "\n", "and", "clip_norm_val", ">", "0.0", "\n", ")", "\n", "\n", "class", "FullModelGradientClippingOptimizer", "(", "optim", ")", ":", "\n", "                ", "def", "step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "                    ", "all_params", "=", "itertools", ".", "chain", "(", "*", "[", "x", "[", "\"params\"", "]", "for", "x", "in", "self", ".", "param_groups", "]", ")", "\n", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "all_params", ",", "clip_norm_val", ")", "\n", "super", "(", ")", ".", "step", "(", "closure", "=", "closure", ")", "\n", "\n", "", "", "return", "FullModelGradientClippingOptimizer", "if", "enable", "else", "optim", "\n", "\n", "", "optimizer_type", "=", "cfg", ".", "SOLVER", ".", "OPTIMIZER", "\n", "if", "optimizer_type", "==", "\"SGD\"", ":", "\n", "            ", "optimizer", "=", "maybe_add_full_model_gradient_clipping", "(", "torch", ".", "optim", ".", "SGD", ")", "(", "\n", "params", ",", "cfg", ".", "SOLVER", ".", "BASE_LR", ",", "momentum", "=", "cfg", ".", "SOLVER", ".", "MOMENTUM", "\n", ")", "\n", "", "elif", "optimizer_type", "==", "\"ADAMW\"", ":", "\n", "            ", "optimizer", "=", "maybe_add_full_model_gradient_clipping", "(", "torch", ".", "optim", ".", "AdamW", ")", "(", "\n", "params", ",", "cfg", ".", "SOLVER", ".", "BASE_LR", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f\"no optimizer type {optimizer_type}\"", ")", "\n", "", "if", "not", "cfg", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "CLIP_TYPE", "==", "\"full_model\"", ":", "\n", "            ", "optimizer", "=", "maybe_add_gradient_clipping", "(", "cfg", ",", "optimizer", ")", "\n", "", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.Trainer.test_with_TTA": [[257, 272], ["logging.getLogger", "logging.getLogger.info", "hcformer.SemanticSegmentorWithTTA", "cls.test", "collections.OrderedDict", "cls.build_evaluator", "os.path.join", "collections.OrderedDict.items"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.Trainer.build_evaluator"], ["", "@", "classmethod", "\n", "def", "test_with_TTA", "(", "cls", ",", "cfg", ",", "model", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"detectron2.trainer\"", ")", "\n", "# In the end of training, run an evaluation with TTA.", "\n", "logger", ".", "info", "(", "\"Running inference with test-time augmentation ...\"", ")", "\n", "model", "=", "SemanticSegmentorWithTTA", "(", "cfg", ",", "model", ")", "\n", "evaluators", "=", "[", "\n", "cls", ".", "build_evaluator", "(", "\n", "cfg", ",", "name", ",", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference_TTA\"", ")", "\n", ")", "\n", "for", "name", "in", "cfg", ".", "DATASETS", ".", "TEST", "\n", "]", "\n", "res", "=", "cls", ".", "test", "(", "cfg", ",", "model", ",", "evaluators", ")", "\n", "res", "=", "OrderedDict", "(", "{", "k", "+", "\"_TTA\"", ":", "v", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "}", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.setup": [[274, 290], ["detectron2.config.get_cfg", "detectron2.projects.deeplab.add_deeplab_config", "hcformer.add_maskformer2_config", "hcformer.add_hcformer_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup", "detectron2.utils.logger.setup_logger", "detectron2.get_rank"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.config.add_maskformer2_config", "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.config.add_hcformer_config"], ["", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "# for poly lr schedule", "\n", "add_deeplab_config", "(", "cfg", ")", "\n", "add_maskformer2_config", "(", "cfg", ")", "\n", "add_hcformer_config", "(", "cfg", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "# Setup logger for \"mask_former\" module", "\n", "setup_logger", "(", "output", "=", "cfg", ".", "OUTPUT_DIR", ",", "distributed_rank", "=", "comm", ".", "get_rank", "(", ")", ",", "name", "=", "\"mask2former\"", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.main": [[292, 310], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.is_main_process", "Trainer.test.update", "detectron2.evaluation.verify_results", "detectron2.checkpoint.DetectionCheckpointer", "train_net.Trainer.test_with_TTA"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.tools.analyze_model.setup", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer.train", "home.repos.pwc.inspect_result.densoitlab_hcformer.None.train_net.Trainer.test_with_TTA"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", "\n", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "if", "cfg", ".", "TEST", ".", "AUG", ".", "ENABLED", ":", "\n", "            ", "res", ".", "update", "(", "Trainer", ".", "test_with_TTA", "(", "cfg", ",", "model", ")", ")", "\n", "", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "verify_results", "(", "cfg", ",", "res", ")", "\n", "", "return", "res", "\n", "\n", "", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "return", "trainer", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.prepare_ade20k_sem_seg.convert": [[12, 17], ["numpy.asarray", "PIL.Image.fromarray().save", "PIL.Image.open", "PIL.Image.fromarray"], "function", ["None"], ["def", "convert", "(", "input", ",", "output", ")", ":", "\n", "    ", "img", "=", "np", ".", "asarray", "(", "Image", ".", "open", "(", "input", ")", ")", "\n", "assert", "img", ".", "dtype", "==", "np", ".", "uint8", "\n", "img", "=", "img", "-", "1", "# 0 (ignore) becomes 255. others are shifted by 1", "\n", "Image", ".", "fromarray", "(", "img", ")", ".", "save", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.prepare_coco_semantic_annos_from_panoptic_annos._process_panoptic_to_semantic": [[18, 27], ["numpy.asarray", "panopticapi.utils.rgb2id", "PIL.Image.fromarray().save", "PIL.Image.open", "numpy.zeros_like", "PIL.Image.fromarray"], "function", ["None"], ["def", "_process_panoptic_to_semantic", "(", "input_panoptic", ",", "output_semantic", ",", "segments", ",", "id_map", ")", ":", "\n", "    ", "panoptic", "=", "np", ".", "asarray", "(", "Image", ".", "open", "(", "input_panoptic", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "panoptic", "=", "rgb2id", "(", "panoptic", ")", "\n", "output", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "+", "255", "\n", "for", "seg", "in", "segments", ":", "\n", "        ", "cat_id", "=", "seg", "[", "\"category_id\"", "]", "\n", "new_cat_id", "=", "id_map", "[", "cat_id", "]", "\n", "output", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "new_cat_id", "\n", "", "Image", ".", "fromarray", "(", "output", ")", ".", "save", "(", "output_semantic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.prepare_coco_semantic_annos_from_panoptic_annos.separate_coco_semantic_from_panoptic": [[29, 74], ["os.makedirs", "enumerate", "print", "multiprocessing.Pool", "print", "time.time", "mp.Pool.starmap", "print", "len", "open", "json.load", "functools.partial", "prepare_coco_semantic_annos_from_panoptic_annos.separate_coco_semantic_from_panoptic.iter_annotations"], "function", ["None"], ["", "def", "separate_coco_semantic_from_panoptic", "(", "panoptic_json", ",", "panoptic_root", ",", "sem_seg_root", ",", "categories", ")", ":", "\n", "    ", "\"\"\"\n    Create semantic segmentation annotations from panoptic segmentation\n    annotations, to be used by PanopticFPN.\n    It maps all thing categories to class 0, and maps all unlabeled pixels to class 255.\n    It maps all stuff categories to contiguous ids starting from 1.\n    Args:\n        panoptic_json (str): path to the panoptic json file, in COCO's format.\n        panoptic_root (str): a directory with panoptic annotation files, in COCO's format.\n        sem_seg_root (str): a directory to output semantic annotation files\n        categories (list[dict]): category metadata. Each dict needs to have:\n            \"id\": corresponds to the \"category_id\" in the json annotations\n            \"isthing\": 0 or 1\n    \"\"\"", "\n", "os", ".", "makedirs", "(", "sem_seg_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "id_map", "=", "{", "}", "# map from category id to id in the output semantic annotation", "\n", "assert", "len", "(", "categories", ")", "<=", "254", "\n", "for", "i", ",", "k", "in", "enumerate", "(", "categories", ")", ":", "\n", "        ", "id_map", "[", "k", "[", "\"id\"", "]", "]", "=", "i", "\n", "# what is id = 0?", "\n", "# id_map[0] = 255", "\n", "", "print", "(", "id_map", ")", "\n", "\n", "with", "open", "(", "panoptic_json", ")", "as", "f", ":", "\n", "        ", "obj", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "pool", "=", "mp", ".", "Pool", "(", "processes", "=", "max", "(", "mp", ".", "cpu_count", "(", ")", "//", "2", ",", "4", ")", ")", "\n", "\n", "def", "iter_annotations", "(", ")", ":", "\n", "        ", "for", "anno", "in", "obj", "[", "\"annotations\"", "]", ":", "\n", "            ", "file_name", "=", "anno", "[", "\"file_name\"", "]", "\n", "segments", "=", "anno", "[", "\"segments_info\"", "]", "\n", "input", "=", "os", ".", "path", ".", "join", "(", "panoptic_root", ",", "file_name", ")", "\n", "output", "=", "os", ".", "path", ".", "join", "(", "sem_seg_root", ",", "file_name", ")", "\n", "yield", "input", ",", "output", ",", "segments", "\n", "\n", "", "", "print", "(", "\"Start writing to {} ...\"", ".", "format", "(", "sem_seg_root", ")", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "pool", ".", "starmap", "(", "\n", "functools", ".", "partial", "(", "_process_panoptic_to_semantic", ",", "id_map", "=", "id_map", ")", ",", "\n", "iter_annotations", "(", ")", ",", "\n", "chunksize", "=", "100", ",", "\n", ")", "\n", "print", "(", "\"Finished. time: {:.2f}s\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.register_coco_panoptic_annos_semseg.get_metadata": [[31, 73], ["enumerate"], "function", ["None"], ["def", "get_metadata", "(", ")", ":", "\n", "    ", "meta", "=", "{", "}", "\n", "# The following metadata maps contiguous id from [0, #thing categories +", "\n", "# #stuff categories) to their names and colors. We have to replica of the", "\n", "# same name and color under \"thing_*\" and \"stuff_*\" because the current", "\n", "# visualization function in D2 handles thing and class classes differently", "\n", "# due to some heuristic used in Panoptic FPN. We keep the same naming to", "\n", "# enable reusing existing visualization functions.", "\n", "thing_classes", "=", "[", "k", "[", "\"name\"", "]", "for", "k", "in", "COCO_CATEGORIES", "if", "k", "[", "\"isthing\"", "]", "==", "1", "]", "\n", "thing_colors", "=", "[", "k", "[", "\"color\"", "]", "for", "k", "in", "COCO_CATEGORIES", "if", "k", "[", "\"isthing\"", "]", "==", "1", "]", "\n", "stuff_classes", "=", "[", "k", "[", "\"name\"", "]", "for", "k", "in", "COCO_CATEGORIES", "]", "\n", "stuff_colors", "=", "[", "k", "[", "\"color\"", "]", "for", "k", "in", "COCO_CATEGORIES", "]", "\n", "\n", "meta", "[", "\"thing_classes\"", "]", "=", "thing_classes", "\n", "meta", "[", "\"thing_colors\"", "]", "=", "thing_colors", "\n", "meta", "[", "\"stuff_classes\"", "]", "=", "stuff_classes", "\n", "meta", "[", "\"stuff_colors\"", "]", "=", "stuff_colors", "\n", "\n", "# Convert category id for training:", "\n", "#   category id: like semantic segmentation, it is the class id for each", "\n", "#   pixel. Since there are some classes not used in evaluation, the category", "\n", "#   id is not always contiguous and thus we have two set of category ids:", "\n", "#       - original category id: category id in the original dataset, mainly", "\n", "#           used for evaluation.", "\n", "#       - contiguous category id: [0, #classes), in order to train the linear", "\n", "#           softmax classifier.", "\n", "thing_dataset_id_to_contiguous_id", "=", "{", "}", "\n", "stuff_dataset_id_to_contiguous_id", "=", "{", "}", "\n", "\n", "for", "i", ",", "cat", "in", "enumerate", "(", "COCO_CATEGORIES", ")", ":", "\n", "        ", "if", "cat", "[", "\"isthing\"", "]", ":", "\n", "            ", "thing_dataset_id_to_contiguous_id", "[", "cat", "[", "\"id\"", "]", "]", "=", "i", "\n", "# else:", "\n", "#     stuff_dataset_id_to_contiguous_id[cat[\"id\"]] = i", "\n", "\n", "# in order to use sem_seg evaluator", "\n", "", "stuff_dataset_id_to_contiguous_id", "[", "cat", "[", "\"id\"", "]", "]", "=", "i", "\n", "\n", "", "meta", "[", "\"thing_dataset_id_to_contiguous_id\"", "]", "=", "thing_dataset_id_to_contiguous_id", "\n", "meta", "[", "\"stuff_dataset_id_to_contiguous_id\"", "]", "=", "stuff_dataset_id_to_contiguous_id", "\n", "\n", "return", "meta", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.register_coco_panoptic_annos_semseg.load_coco_panoptic_json": [[75, 127], ["len", "detectron2.utils.file_io.PathManager.isfile", "detectron2.utils.file_io.PathManager.isfile", "detectron2.utils.file_io.PathManager.isfile", "detectron2.utils.file_io.PathManager.open", "json.load", "int", "os.path.join", "os.path.join", "os.path.join", "ret.append", "register_coco_panoptic_annos_semseg.load_coco_panoptic_json._convert_category_id"], "function", ["None"], ["", "def", "load_coco_panoptic_json", "(", "json_file", ",", "image_dir", ",", "gt_dir", ",", "semseg_dir", ",", "meta", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        image_dir (str): path to the raw dataset. e.g., \"~/coco/train2017\".\n        gt_dir (str): path to the raw annotations. e.g., \"~/coco/panoptic_train2017\".\n        json_file (str): path to the json file. e.g., \"~/coco/annotations/panoptic_train2017.json\".\n    Returns:\n        list[dict]: a list of dicts in Detectron2 standard format. (See\n        `Using Custom Datasets </tutorials/datasets.html>`_ )\n    \"\"\"", "\n", "\n", "def", "_convert_category_id", "(", "segment_info", ",", "meta", ")", ":", "\n", "        ", "if", "segment_info", "[", "\"category_id\"", "]", "in", "meta", "[", "\"thing_dataset_id_to_contiguous_id\"", "]", ":", "\n", "            ", "segment_info", "[", "\"category_id\"", "]", "=", "meta", "[", "\"thing_dataset_id_to_contiguous_id\"", "]", "[", "\n", "segment_info", "[", "\"category_id\"", "]", "\n", "]", "\n", "segment_info", "[", "\"isthing\"", "]", "=", "True", "\n", "", "else", ":", "\n", "            ", "segment_info", "[", "\"category_id\"", "]", "=", "meta", "[", "\"stuff_dataset_id_to_contiguous_id\"", "]", "[", "\n", "segment_info", "[", "\"category_id\"", "]", "\n", "]", "\n", "segment_info", "[", "\"isthing\"", "]", "=", "False", "\n", "", "return", "segment_info", "\n", "\n", "", "with", "PathManager", ".", "open", "(", "json_file", ")", "as", "f", ":", "\n", "        ", "json_info", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "ret", "=", "[", "]", "\n", "for", "ann", "in", "json_info", "[", "\"annotations\"", "]", ":", "\n", "        ", "image_id", "=", "int", "(", "ann", "[", "\"image_id\"", "]", ")", "\n", "# TODO: currently we assume image and label has the same filename but", "\n", "# different extension, and images have extension \".jpg\" for COCO. Need", "\n", "# to make image extension a user-provided argument if we extend this", "\n", "# function to support other COCO-like datasets.", "\n", "image_file", "=", "os", ".", "path", ".", "join", "(", "image_dir", ",", "os", ".", "path", ".", "splitext", "(", "ann", "[", "\"file_name\"", "]", ")", "[", "0", "]", "+", "\".jpg\"", ")", "\n", "label_file", "=", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "ann", "[", "\"file_name\"", "]", ")", "\n", "sem_label_file", "=", "os", ".", "path", ".", "join", "(", "semseg_dir", ",", "ann", "[", "\"file_name\"", "]", ")", "\n", "segments_info", "=", "[", "_convert_category_id", "(", "x", ",", "meta", ")", "for", "x", "in", "ann", "[", "\"segments_info\"", "]", "]", "\n", "ret", ".", "append", "(", "\n", "{", "\n", "\"file_name\"", ":", "image_file", ",", "\n", "\"image_id\"", ":", "image_id", ",", "\n", "\"pan_seg_file_name\"", ":", "label_file", ",", "\n", "\"sem_seg_file_name\"", ":", "sem_label_file", ",", "\n", "\"segments_info\"", ":", "segments_info", ",", "\n", "}", "\n", ")", "\n", "", "assert", "len", "(", "ret", ")", ",", "f\"No images found in {image_dir}!\"", "\n", "assert", "PathManager", ".", "isfile", "(", "ret", "[", "0", "]", "[", "\"file_name\"", "]", ")", ",", "ret", "[", "0", "]", "[", "\"file_name\"", "]", "\n", "assert", "PathManager", ".", "isfile", "(", "ret", "[", "0", "]", "[", "\"pan_seg_file_name\"", "]", ")", ",", "ret", "[", "0", "]", "[", "\"pan_seg_file_name\"", "]", "\n", "assert", "PathManager", ".", "isfile", "(", "ret", "[", "0", "]", "[", "\"sem_seg_file_name\"", "]", ")", ",", "ret", "[", "0", "]", "[", "\"sem_seg_file_name\"", "]", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.register_coco_panoptic_annos_semseg.register_coco_panoptic_annos_sem_seg": [[129, 157], ["delattr", "delattr", "detectron2.data.MetadataCatalog.get().set", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "register_coco_panoptic_annos_semseg.load_coco_panoptic_json", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.register_coco_panoptic_annos_semseg.load_coco_panoptic_json", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["", "def", "register_coco_panoptic_annos_sem_seg", "(", "\n", "name", ",", "metadata", ",", "image_root", ",", "panoptic_root", ",", "panoptic_json", ",", "sem_seg_root", ",", "instances_json", "\n", ")", ":", "\n", "    ", "panoptic_name", "=", "name", "\n", "delattr", "(", "MetadataCatalog", ".", "get", "(", "panoptic_name", ")", ",", "\"thing_classes\"", ")", "\n", "delattr", "(", "MetadataCatalog", ".", "get", "(", "panoptic_name", ")", ",", "\"thing_colors\"", ")", "\n", "MetadataCatalog", ".", "get", "(", "panoptic_name", ")", ".", "set", "(", "\n", "thing_classes", "=", "metadata", "[", "\"thing_classes\"", "]", ",", "\n", "thing_colors", "=", "metadata", "[", "\"thing_colors\"", "]", ",", "\n", "# thing_dataset_id_to_contiguous_id=metadata[\"thing_dataset_id_to_contiguous_id\"],", "\n", ")", "\n", "\n", "# the name is \"coco_2017_train_panoptic_with_sem_seg\" and \"coco_2017_val_panoptic_with_sem_seg\"", "\n", "semantic_name", "=", "name", "+", "\"_with_sem_seg\"", "\n", "DatasetCatalog", ".", "register", "(", "\n", "semantic_name", ",", "\n", "lambda", ":", "load_coco_panoptic_json", "(", "panoptic_json", ",", "image_root", ",", "panoptic_root", ",", "sem_seg_root", ",", "metadata", ")", ",", "\n", ")", "\n", "MetadataCatalog", ".", "get", "(", "semantic_name", ")", ".", "set", "(", "\n", "sem_seg_root", "=", "sem_seg_root", ",", "\n", "panoptic_root", "=", "panoptic_root", ",", "\n", "image_root", "=", "image_root", ",", "\n", "panoptic_json", "=", "panoptic_json", ",", "\n", "json_file", "=", "instances_json", ",", "\n", "evaluator_type", "=", "\"coco_panoptic_seg\"", ",", "\n", "ignore_label", "=", "255", ",", "\n", "label_divisor", "=", "1000", ",", "\n", "**", "metadata", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.register_coco_panoptic_annos_semseg.register_all_coco_panoptic_annos_sem_seg": [[160, 177], ["_PREDEFINED_SPLITS_COCO_PANOPTIC.items", "detectron2.data.MetadataCatalog.get", "register_coco_panoptic_annos_semseg.register_coco_panoptic_annos_sem_seg", "register_coco_panoptic_annos_semseg.get_metadata", "os.path.join", "os.path.join", "os.path.join", "len"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.register_coco_panoptic_annos_semseg.register_coco_panoptic_annos_sem_seg", "home.repos.pwc.inspect_result.densoitlab_hcformer.datasets.register_coco_panoptic_annos_semseg.get_metadata"], ["", "def", "register_all_coco_panoptic_annos_sem_seg", "(", "root", ")", ":", "\n", "    ", "for", "(", "\n", "prefix", ",", "\n", "(", "panoptic_root", ",", "panoptic_json", ",", "semantic_root", ")", ",", "\n", ")", "in", "_PREDEFINED_SPLITS_COCO_PANOPTIC", ".", "items", "(", ")", ":", "\n", "        ", "prefix_instances", "=", "prefix", "[", ":", "-", "len", "(", "\"_panoptic\"", ")", "]", "\n", "instances_meta", "=", "MetadataCatalog", ".", "get", "(", "prefix_instances", ")", "\n", "image_root", ",", "instances_json", "=", "instances_meta", ".", "image_root", ",", "instances_meta", ".", "json_file", "\n", "\n", "register_coco_panoptic_annos_sem_seg", "(", "\n", "prefix", ",", "\n", "get_metadata", "(", ")", ",", "\n", "image_root", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "panoptic_root", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "panoptic_json", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "semantic_root", ")", ",", "\n", "instances_json", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.demo.setup_cfg": [[37, 47], ["detectron2.config.get_cfg", "detectron2.projects.deeplab.add_deeplab_config", "hcformer.add_maskformer2_config", "hcformer.add_hcformer_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.config.add_maskformer2_config", "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.config.add_hcformer_config"], ["def", "setup_cfg", "(", "args", ")", ":", "\n", "# load config from file and command-line arguments", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "add_deeplab_config", "(", "cfg", ")", "\n", "add_maskformer2_config", "(", "cfg", ")", "\n", "add_hcformer_config", "(", "cfg", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.demo.get_parser": [[49, 84], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"maskformer2 demo for builtin configs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config-file\"", ",", "\n", "default", "=", "\"configs/coco/panoptic-segmentation/maskformer2_R50_bs16_50ep.yaml\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "help", "=", "\"path to config file\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--webcam\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Take inputs from webcam.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--video-input\"", ",", "help", "=", "\"Path to video file.\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--input\"", ",", "\n", "nargs", "=", "\"+\"", ",", "\n", "help", "=", "\"A list of space separated input images; \"", "\n", "\"or a single glob pattern such as 'directory/*.jpg'\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "help", "=", "\"A file or directory to save output visualizations. \"", "\n", "\"If not given, will show output in an OpenCV window.\"", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--confidence-threshold\"", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "\"Minimum score for instance predictions to be shown\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line 'KEY VALUE' pairs\"", ",", "\n", "default", "=", "[", "]", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.demo.test_opencv_video_format": [[86, 101], ["tempfile.TemporaryDirectory", "os.path.join", "cv2.VideoWriter", "cv2.VideoWriter.release", "os.path.isfile", "cv2.VideoWriter.write", "cv2.VideoWriter_fourcc", "float", "numpy.zeros", "range"], "function", ["None"], ["", "def", "test_opencv_video_format", "(", "codec", ",", "file_ext", ")", ":", "\n", "    ", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"video_format_test\"", ")", "as", "dir", ":", "\n", "        ", "filename", "=", "os", ".", "path", ".", "join", "(", "dir", ",", "\"test_file\"", "+", "file_ext", ")", "\n", "writer", "=", "cv2", ".", "VideoWriter", "(", "\n", "filename", "=", "filename", ",", "\n", "fourcc", "=", "cv2", ".", "VideoWriter_fourcc", "(", "*", "codec", ")", ",", "\n", "fps", "=", "float", "(", "30", ")", ",", "\n", "frameSize", "=", "(", "10", ",", "10", ")", ",", "\n", "isColor", "=", "True", ",", "\n", ")", "\n", "[", "writer", ".", "write", "(", "np", ".", "zeros", "(", "(", "10", ",", "10", ",", "3", ")", ",", "np", ".", "uint8", ")", ")", "for", "_", "in", "range", "(", "30", ")", "]", "\n", "writer", ".", "release", "(", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "filename", ")", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.VisualizationDemo.__init__": [[22, 46], ["detectron2.data.MetadataCatalog.get", "torch.device", "predictor.VisualizationDemo.metadata.set", "torch.cuda.device_count", "predictor.AsyncPredictor", "detectron2.engine.defaults.DefaultPredictor", "len"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.device"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "instance_mode", "=", "ColorMode", ".", "SEGMENTATION", ",", "parallel", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            instance_mode (ColorMode):\n            parallel (bool): whether to run the model in different processes from visualization.\n                Useful since the visualization logic can be slow.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "MetadataCatalog", ".", "get", "(", "\n", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", "if", "len", "(", "cfg", ".", "DATASETS", ".", "TEST", ")", "else", "\"__unused\"", "\n", ")", "\n", "if", "'cityscapes'", "in", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ":", "\n", "# stuff_classes = [k.name for k in labels if k.trainId != 255]", "\n", "            ", "stuff_colors", "=", "[", "k", ".", "color", "for", "k", "in", "labels", "if", "k", ".", "trainId", "!=", "255", "]", "\n", "self", ".", "metadata", "=", "self", ".", "metadata", ".", "set", "(", "stuff_colors", "=", "stuff_colors", ")", "\n", "", "self", ".", "cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "instance_mode", "=", "instance_mode", "\n", "\n", "self", ".", "parallel", "=", "parallel", "\n", "if", "parallel", ":", "\n", "            ", "num_gpu", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "self", ".", "predictor", "=", "AsyncPredictor", "(", "cfg", ",", "num_gpus", "=", "num_gpu", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "predictor", "=", "DefaultPredictor", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.VisualizationDemo.run_on_image": [[47, 76], ["predictor.VisualizationDemo.predictor", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_panoptic_seg_predictions", "panoptic_seg.to", "detectron2.utils.visualizer.Visualizer.draw_sem_seg", "predictions[].to", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "predictions[].argmax().to", "predictions[].argmax"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to"], ["", "", "def", "run_on_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image (np.ndarray): an image of shape (H, W, C) (in BGR order).\n                This is the format used by OpenCV.\n        Returns:\n            predictions (dict): the output of the model.\n            vis_output (VisImage): the visualized image output.\n        \"\"\"", "\n", "vis_output", "=", "None", "\n", "predictions", "=", "self", ".", "predictor", "(", "image", ")", "\n", "# Convert image from OpenCV BGR format to Matplotlib RGB format.", "\n", "image", "=", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "visualizer", "=", "Visualizer", "(", "image", ",", "self", ".", "metadata", ",", "instance_mode", "=", "self", ".", "instance_mode", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "            ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_output", "=", "visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_output", "=", "visualizer", ".", "draw_sem_seg", "(", "\n", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "", "if", "\"instances\"", "in", "predictions", ":", "\n", "                ", "instances", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_output", "=", "visualizer", ".", "draw_instance_predictions", "(", "predictions", "=", "instances", ")", "\n", "\n", "", "", "return", "predictions", ",", "vis_output", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.VisualizationDemo._frame_from_video": [[77, 84], ["video.isOpened", "video.read"], "methods", ["None"], ["", "def", "_frame_from_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "while", "video", ".", "isOpened", "(", ")", ":", "\n", "            ", "success", ",", "frame", "=", "video", ".", "read", "(", ")", "\n", "if", "success", ":", "\n", "                ", "yield", "frame", "\n", "", "else", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.VisualizationDemo.run_on_video": [[85, 137], ["detectron2.utils.video_visualizer.VideoVisualizer", "predictor.VisualizationDemo._frame_from_video", "cv2.cvtColor", "cv2.cvtColor", "collections.deque", "enumerate", "len", "detectron2.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "detectron2.utils.video_visualizer.VideoVisualizer.draw_sem_seg.get_image", "collections.deque.append", "predictor.VisualizationDemo.predictor.put", "collections.deque.popleft", "predictor.VisualizationDemo.predictor.get", "panoptic_seg.to", "predictions[].to", "detectron2.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "collections.deque.popleft", "predictor.VisualizationDemo.predictor.get", "predictor.VisualizationDemo.run_on_video.process_predictions"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.VisualizationDemo._frame_from_video", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["", "", "", "def", "run_on_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "\"\"\"\n        Visualizes predictions on frames of the input video.\n        Args:\n            video (cv2.VideoCapture): a :class:`VideoCapture` object, whose source can be\n                either a webcam or a video file.\n        Yields:\n            ndarray: BGR visualizations of each video frame.\n        \"\"\"", "\n", "video_visualizer", "=", "VideoVisualizer", "(", "self", ".", "metadata", ",", "self", ".", "instance_mode", ")", "\n", "\n", "def", "process_predictions", "(", "frame", ",", "predictions", ")", ":", "\n", "            ", "frame", "=", "cv2", ".", "cvtColor", "(", "frame", ",", "cv2", ".", "COLOR_BGR2RGB", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "                ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "frame", ",", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "elif", "\"instances\"", "in", "predictions", ":", "\n", "                ", "predictions", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_instance_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "elif", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_frame", "=", "video_visualizer", ".", "draw_sem_seg", "(", "\n", "frame", ",", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "\n", "# Converts Matplotlib RGB format to OpenCV BGR format", "\n", "", "vis_frame", "=", "cv2", ".", "cvtColor", "(", "vis_frame", ".", "get_image", "(", ")", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "return", "vis_frame", "\n", "\n", "", "frame_gen", "=", "self", ".", "_frame_from_video", "(", "video", ")", "\n", "if", "self", ".", "parallel", ":", "\n", "            ", "buffer_size", "=", "self", ".", "predictor", ".", "default_buffer_size", "\n", "\n", "frame_data", "=", "deque", "(", ")", "\n", "\n", "for", "cnt", ",", "frame", "in", "enumerate", "(", "frame_gen", ")", ":", "\n", "                ", "frame_data", ".", "append", "(", "frame", ")", "\n", "self", ".", "predictor", ".", "put", "(", "frame", ")", "\n", "\n", "if", "cnt", ">=", "buffer_size", ":", "\n", "                    ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "\n", "", "", "while", "len", "(", "frame_data", ")", ":", "\n", "                ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "frame", "in", "frame_gen", ":", "\n", "                ", "yield", "process_predictions", "(", "frame", ",", "self", ".", "predictor", "(", "frame", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.__init__": [[167, 193], ["max", "multiprocessing.Queue", "multiprocessing.Queue", "range", "atexit.register", "max", "cfg.clone.clone.clone", "cfg.clone.clone.defrost", "predictor.AsyncPredictor.procs.append", "p.start", "AsyncPredictor._PredictWorker"], "methods", ["None"], ["", "", "", "def", "__init__", "(", "self", ",", "cfg", ",", "num_gpus", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            num_gpus (int): if 0, will run on CPU\n        \"\"\"", "\n", "num_workers", "=", "max", "(", "num_gpus", ",", "1", ")", "\n", "self", ".", "task_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "result_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "procs", "=", "[", "]", "\n", "for", "gpuid", "in", "range", "(", "max", "(", "num_gpus", ",", "1", ")", ")", ":", "\n", "            ", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cuda:{}\"", ".", "format", "(", "gpuid", ")", "if", "num_gpus", ">", "0", "else", "\"cpu\"", "\n", "self", ".", "procs", ".", "append", "(", "\n", "AsyncPredictor", ".", "_PredictWorker", "(", "cfg", ",", "self", ".", "task_queue", ",", "self", ".", "result_queue", ")", "\n", ")", "\n", "\n", "", "self", ".", "put_idx", "=", "0", "\n", "self", ".", "get_idx", "=", "0", "\n", "self", ".", "result_rank", "=", "[", "]", "\n", "self", ".", "result_data", "=", "[", "]", "\n", "\n", "for", "p", "in", "self", ".", "procs", ":", "\n", "            ", "p", ".", "start", "(", ")", "\n", "", "atexit", ".", "register", "(", "self", ".", "shutdown", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.put": [[194, 197], ["predictor.AsyncPredictor.task_queue.put"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.put"], ["", "def", "put", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put_idx", "+=", "1", "\n", "self", ".", "task_queue", ".", "put", "(", "(", "self", ".", "put_idx", ",", "image", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get": [[198, 213], ["len", "predictor.AsyncPredictor.result_queue.get", "bisect.bisect", "predictor.AsyncPredictor.result_rank.insert", "predictor.AsyncPredictor.result_data.insert"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "self", ".", "get_idx", "+=", "1", "# the index needed for this request", "\n", "if", "len", "(", "self", ".", "result_rank", ")", "and", "self", ".", "result_rank", "[", "0", "]", "==", "self", ".", "get_idx", ":", "\n", "            ", "res", "=", "self", ".", "result_data", "[", "0", "]", "\n", "del", "self", ".", "result_data", "[", "0", "]", ",", "self", ".", "result_rank", "[", "0", "]", "\n", "return", "res", "\n", "\n", "", "while", "True", ":", "\n", "# make sure the results are returned in the correct order", "\n", "            ", "idx", ",", "res", "=", "self", ".", "result_queue", ".", "get", "(", ")", "\n", "if", "idx", "==", "self", ".", "get_idx", ":", "\n", "                ", "return", "res", "\n", "", "insert", "=", "bisect", ".", "bisect", "(", "self", ".", "result_rank", ",", "idx", ")", "\n", "self", ".", "result_rank", ".", "insert", "(", "insert", ",", "idx", ")", "\n", "self", ".", "result_data", ".", "insert", "(", "insert", ",", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.__len__": [[214, 216], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "put_idx", "-", "self", ".", "get_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.__call__": [[217, 220], ["predictor.AsyncPredictor.put", "predictor.AsyncPredictor.get"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["", "def", "__call__", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put", "(", "image", ")", "\n", "return", "self", ".", "get", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.shutdown": [[221, 224], ["predictor.AsyncPredictor.task_queue.put", "AsyncPredictor._StopToken"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.put"], ["", "def", "shutdown", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "self", ".", "procs", ":", "\n", "            ", "self", ".", "task_queue", ".", "put", "(", "AsyncPredictor", ".", "_StopToken", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.default_buffer_size": [[225, 228], ["len"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "default_buffer_size", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "procs", ")", "*", "5", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.evaluate_coco_boundary_ap.main": [[18, 46], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "boundary_iou.coco_instance_api.coco.COCO", "json.load", "boundary_iou.coco_instance_api.coco.COCO.loadRes", "boundary_iou.coco_instance_api.cocoeval.COCOeval", "boundary_iou.coco_instance_api.cocoeval.COCOeval.evaluate", "boundary_iou.coco_instance_api.cocoeval.COCOeval.accumulate", "boundary_iou.coco_instance_api.cocoeval.COCOeval.summarize", "open", "c.pop"], "function", ["None"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"--gt-json-file\"", ",", "default", "=", "\"\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--dt-json-file\"", ",", "default", "=", "\"\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--iou-type\"", ",", "default", "=", "\"boundary\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--dilation-ratio\"", ",", "default", "=", "\"0.020\"", ",", "type", "=", "float", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "print", "(", "args", ")", "\n", "\n", "annFile", "=", "args", ".", "gt_json_file", "\n", "resFile", "=", "args", ".", "dt_json_file", "\n", "dilation_ratio", "=", "args", ".", "dilation_ratio", "\n", "if", "args", ".", "iou_type", "==", "\"boundary\"", ":", "\n", "        ", "get_boundary", "=", "True", "\n", "", "else", ":", "\n", "        ", "get_boundary", "=", "False", "\n", "", "cocoGt", "=", "COCO", "(", "annFile", ",", "get_boundary", "=", "get_boundary", ",", "dilation_ratio", "=", "dilation_ratio", ")", "\n", "\n", "# remove box predictions", "\n", "resFile", "=", "json", ".", "load", "(", "open", "(", "resFile", ")", ")", "\n", "for", "c", "in", "resFile", ":", "\n", "        ", "c", ".", "pop", "(", "\"bbox\"", ",", "None", ")", "\n", "\n", "", "cocoDt", "=", "cocoGt", ".", "loadRes", "(", "resFile", ")", "\n", "cocoEval", "=", "COCOeval", "(", "cocoGt", ",", "cocoDt", ",", "iouType", "=", "args", ".", "iou_type", ",", "dilation_ratio", "=", "dilation_ratio", ")", "\n", "cocoEval", ".", "evaluate", "(", ")", "\n", "cocoEval", ".", "accumulate", "(", ")", "\n", "cocoEval", ".", "summarize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.evaluate_pq_for_semantic_segmentation.default_argument_parser": [[21, 38], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "default_argument_parser", "(", ")", ":", "\n", "    ", "\"\"\"\n    Creates a parser with some common arguments used by analysis tools.\n    Returns:\n        argparse.ArgumentParser:\n    \"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Evaluate PQ metric for semantic segmentation.\"", ")", "\n", "# NOTE: currently does not support Cityscapes, you need to convert", "\n", "# Cityscapes prediction format to Detectron2 prediction format.", "\n", "parser", ".", "add_argument", "(", "\n", "\"--dataset-name\"", ",", "\n", "default", "=", "\"ade20k_sem_seg_val\"", ",", "\n", "choices", "=", "[", "\"ade20k_sem_seg_val\"", ",", "\"coco_2017_test_stuff_10k_sem_seg\"", ",", "\"ade20k_full_sem_seg_val\"", "]", ",", "\n", "help", "=", "\"dataset name you want to evaluate\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--json-file\"", ",", "default", "=", "\"\"", ",", "help", "=", "\"path to detection json file\"", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.evaluate_pq_for_semantic_segmentation.pq_compute_single_image": [[41, 137], ["panopticapi.evaluation.PQStat", "numpy.unique", "zip", "numpy.unique", "set", "numpy.unique", "zip", "numpy.unique", "zip", "set", "set", "gt_pred_map.items", "gt_segms.items", "pred_segms.items", "gt_ann[].append", "pred_ann[].append", "set.remove", "len", "KeyError", "pan_pred.astype", "gt_pred_map.get", "KeyError", "KeyError", "pan_gt.astype", "gt_pred_map.get", "set.add", "set.add", "gt_pred_map.get", "list"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["", "def", "pq_compute_single_image", "(", "segm_gt", ",", "segm_dt", ",", "categories", ",", "ignore_label", ")", ":", "\n", "    ", "pq_stat", "=", "PQStat", "(", ")", "\n", "VOID", "=", "ignore_label", "\n", "OFFSET", "=", "256", "*", "256", "*", "256", "\n", "\n", "pan_gt", "=", "segm_gt", "\n", "pan_pred", "=", "segm_dt", "\n", "\n", "gt_ann", "=", "{", "'segments_info'", ":", "[", "]", "}", "\n", "labels", ",", "labels_cnt", "=", "np", ".", "unique", "(", "segm_gt", ",", "return_counts", "=", "True", ")", "\n", "for", "cat_id", ",", "cnt", "in", "zip", "(", "labels", ",", "labels_cnt", ")", ":", "\n", "        ", "if", "cat_id", "==", "VOID", ":", "\n", "            ", "continue", "\n", "", "gt_ann", "[", "'segments_info'", "]", ".", "append", "(", "\n", "{", "\"id\"", ":", "cat_id", ",", "\"category_id\"", ":", "cat_id", ",", "\"area\"", ":", "cnt", ",", "\"iscrowd\"", ":", "0", "}", "\n", ")", "\n", "\n", "", "pred_ann", "=", "{", "'segments_info'", ":", "[", "]", "}", "\n", "for", "cat_id", "in", "np", ".", "unique", "(", "segm_dt", ")", ":", "\n", "        ", "pred_ann", "[", "'segments_info'", "]", ".", "append", "(", "{", "\"id\"", ":", "cat_id", ",", "\"category_id\"", ":", "cat_id", "}", ")", "\n", "\n", "", "gt_segms", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "gt_ann", "[", "'segments_info'", "]", "}", "\n", "pred_segms", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "pred_ann", "[", "'segments_info'", "]", "}", "\n", "\n", "# predicted segments area calculation + prediction sanity checks", "\n", "pred_labels_set", "=", "set", "(", "el", "[", "'id'", "]", "for", "el", "in", "pred_ann", "[", "'segments_info'", "]", ")", "\n", "labels", ",", "labels_cnt", "=", "np", ".", "unique", "(", "pan_pred", ",", "return_counts", "=", "True", ")", "\n", "for", "label", ",", "label_cnt", "in", "zip", "(", "labels", ",", "labels_cnt", ")", ":", "\n", "        ", "if", "label", "not", "in", "pred_segms", ":", "\n", "            ", "if", "label", "==", "VOID", ":", "\n", "                ", "continue", "\n", "", "raise", "KeyError", "(", "'In the image with ID {} segment with ID {} is presented in PNG and not presented in JSON.'", ".", "format", "(", "image_id", ",", "label", ")", ")", "\n", "", "pred_segms", "[", "label", "]", "[", "'area'", "]", "=", "label_cnt", "\n", "pred_labels_set", ".", "remove", "(", "label", ")", "\n", "if", "pred_segms", "[", "label", "]", "[", "'category_id'", "]", "not", "in", "categories", ":", "\n", "            ", "raise", "KeyError", "(", "'In the image with ID {} segment with ID {} has unknown category_id {}.'", ".", "format", "(", "image_id", ",", "label", ",", "pred_segms", "[", "label", "]", "[", "'category_id'", "]", ")", ")", "\n", "", "", "if", "len", "(", "pred_labels_set", ")", "!=", "0", ":", "\n", "        ", "raise", "KeyError", "(", "'In the image with ID {} the following segment IDs {} are presented in JSON and not presented in PNG.'", ".", "format", "(", "image_id", ",", "list", "(", "pred_labels_set", ")", ")", ")", "\n", "\n", "# confusion matrix calculation", "\n", "", "pan_gt_pred", "=", "pan_gt", ".", "astype", "(", "np", ".", "uint64", ")", "*", "OFFSET", "+", "pan_pred", ".", "astype", "(", "np", ".", "uint64", ")", "\n", "gt_pred_map", "=", "{", "}", "\n", "labels", ",", "labels_cnt", "=", "np", ".", "unique", "(", "pan_gt_pred", ",", "return_counts", "=", "True", ")", "\n", "for", "label", ",", "intersection", "in", "zip", "(", "labels", ",", "labels_cnt", ")", ":", "\n", "        ", "gt_id", "=", "label", "//", "OFFSET", "\n", "pred_id", "=", "label", "%", "OFFSET", "\n", "gt_pred_map", "[", "(", "gt_id", ",", "pred_id", ")", "]", "=", "intersection", "\n", "\n", "# count all matched pairs", "\n", "", "gt_matched", "=", "set", "(", ")", "\n", "pred_matched", "=", "set", "(", ")", "\n", "for", "label_tuple", ",", "intersection", "in", "gt_pred_map", ".", "items", "(", ")", ":", "\n", "        ", "gt_label", ",", "pred_label", "=", "label_tuple", "\n", "if", "gt_label", "not", "in", "gt_segms", ":", "\n", "            ", "continue", "\n", "", "if", "pred_label", "not", "in", "pred_segms", ":", "\n", "            ", "continue", "\n", "", "if", "gt_segms", "[", "gt_label", "]", "[", "'iscrowd'", "]", "==", "1", ":", "\n", "            ", "continue", "\n", "", "if", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "!=", "pred_segms", "[", "pred_label", "]", "[", "'category_id'", "]", ":", "\n", "            ", "continue", "\n", "\n", "", "union", "=", "pred_segms", "[", "pred_label", "]", "[", "'area'", "]", "+", "gt_segms", "[", "gt_label", "]", "[", "'area'", "]", "-", "intersection", "-", "gt_pred_map", ".", "get", "(", "(", "VOID", ",", "pred_label", ")", ",", "0", ")", "\n", "iou", "=", "intersection", "/", "union", "\n", "if", "iou", ">", "0.5", ":", "\n", "            ", "pq_stat", "[", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "]", ".", "tp", "+=", "1", "\n", "pq_stat", "[", "gt_segms", "[", "gt_label", "]", "[", "'category_id'", "]", "]", ".", "iou", "+=", "iou", "\n", "gt_matched", ".", "add", "(", "gt_label", ")", "\n", "pred_matched", ".", "add", "(", "pred_label", ")", "\n", "\n", "# count false positives", "\n", "", "", "crowd_labels_dict", "=", "{", "}", "\n", "for", "gt_label", ",", "gt_info", "in", "gt_segms", ".", "items", "(", ")", ":", "\n", "        ", "if", "gt_label", "in", "gt_matched", ":", "\n", "            ", "continue", "\n", "# crowd segments are ignored", "\n", "", "if", "gt_info", "[", "'iscrowd'", "]", "==", "1", ":", "\n", "            ", "crowd_labels_dict", "[", "gt_info", "[", "'category_id'", "]", "]", "=", "gt_label", "\n", "continue", "\n", "", "pq_stat", "[", "gt_info", "[", "'category_id'", "]", "]", ".", "fn", "+=", "1", "\n", "\n", "# count false positives", "\n", "", "for", "pred_label", ",", "pred_info", "in", "pred_segms", ".", "items", "(", ")", ":", "\n", "        ", "if", "pred_label", "in", "pred_matched", ":", "\n", "            ", "continue", "\n", "# intersection of the segment with VOID", "\n", "", "intersection", "=", "gt_pred_map", ".", "get", "(", "(", "VOID", ",", "pred_label", ")", ",", "0", ")", "\n", "# plus intersection with corresponding CROWD region if it exists", "\n", "if", "pred_info", "[", "'category_id'", "]", "in", "crowd_labels_dict", ":", "\n", "            ", "intersection", "+=", "gt_pred_map", ".", "get", "(", "(", "crowd_labels_dict", "[", "pred_info", "[", "'category_id'", "]", "]", ",", "pred_label", ")", ",", "0", ")", "\n", "# predicted segment is ignored if more than half of the segment correspond to VOID and CROWD regions", "\n", "", "if", "intersection", "/", "pred_info", "[", "'area'", "]", ">", "0.5", ":", "\n", "            ", "continue", "\n", "", "pq_stat", "[", "pred_info", "[", "'category_id'", "]", "]", ".", "fp", "+=", "1", "\n", "\n", "", "return", "pq_stat", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.evaluate_pq_for_semantic_segmentation.main": [[139, 242], ["evaluate_pq_for_semantic_segmentation.default_argument_parser", "default_argument_parser.parse_args", "os.getenv", "collections.defaultdict", "list", "detectron2.data.MetadataCatalog.get", "len", "numpy.zeros", "range", "panopticapi.evaluation.PQStat", "tqdm.tqdm", "print", "print", "numpy.full", "numpy.full", "[].astype", "numpy.sum().astype", "numpy.sum().astype", "print", "print", "open", "json.load", "imgToAnns[].append", "collections.defaultdict.keys", "numpy.zeros_like", "read_image().copy().astype.copy", "np.zeros_like.copy", "numpy.bincount().reshape", "evaluate_pq_for_semantic_segmentation.pq_compute_single_image", "panopticapi.evaluation.PQStat.pq_average", "print", "numpy.sum", "numpy.sum", "os.path.basename().split", "os.path.join", "detectron2.data.detection_utils.read_image().copy().astype", "hasattr", "pycocotools.mask.decode", "numpy.sum", "numpy.sum", "os.path.join", "detectron2.data.detection_utils.read_image().copy().astype", "numpy.bincount", "np.zeros.diagonal", "os.path.basename", "detectron2.data.detection_utils.read_image().copy", "os.path.join", "detectron2.data.detection_utils.read_image().copy().astype", "ValueError", "detectron2.data.detection_utils.read_image().copy", "segm_gt.copy.reshape", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.read_image().copy", "segm_dt.copy.reshape", "os.path.join", "detectron2.data.detection_utils.read_image", "os.path.join", "detectron2.data.detection_utils.read_image", "os.path.join"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.tools.evaluate_pq_for_semantic_segmentation.default_argument_parser", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.evaluate_pq_for_semantic_segmentation.pq_compute_single_image", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.decode"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "default_argument_parser", "(", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "_root", "=", "os", ".", "getenv", "(", "\"DETECTRON2_DATASETS\"", ",", "\"datasets\"", ")", "\n", "json_file", "=", "args", ".", "json_file", "\n", "\n", "with", "open", "(", "json_file", ")", "as", "f", ":", "\n", "        ", "predictions", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "imgToAnns", "=", "defaultdict", "(", "list", ")", "\n", "for", "pred", "in", "predictions", ":", "\n", "        ", "image_id", "=", "os", ".", "path", ".", "basename", "(", "pred", "[", "\"file_name\"", "]", ")", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "imgToAnns", "[", "image_id", "]", ".", "append", "(", "\n", "{", "\"category_id\"", ":", "pred", "[", "\"category_id\"", "]", ",", "\"segmentation\"", ":", "pred", "[", "\"segmentation\"", "]", "}", "\n", ")", "\n", "\n", "", "image_ids", "=", "list", "(", "imgToAnns", ".", "keys", "(", ")", ")", "\n", "\n", "meta", "=", "MetadataCatalog", ".", "get", "(", "args", ".", "dataset_name", ")", "\n", "class_names", "=", "meta", ".", "stuff_classes", "\n", "num_classes", "=", "len", "(", "meta", ".", "stuff_classes", ")", "\n", "ignore_label", "=", "meta", ".", "ignore_label", "\n", "conf_matrix", "=", "np", ".", "zeros", "(", "(", "num_classes", "+", "1", ",", "num_classes", "+", "1", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "categories", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "categories", "[", "i", "]", "=", "{", "\"id\"", ":", "i", ",", "\"name\"", ":", "class_names", "[", "i", "]", ",", "\"isthing\"", ":", "0", "}", "\n", "\n", "", "pq_stat", "=", "PQStat", "(", ")", "\n", "\n", "for", "image_id", "in", "tqdm", "(", "image_ids", ")", ":", "\n", "        ", "if", "args", ".", "dataset_name", "==", "\"ade20k_sem_seg_val\"", ":", "\n", "            ", "gt_dir", "=", "os", ".", "path", ".", "join", "(", "_root", ",", "\"ADEChallengeData2016\"", ",", "\"annotations_detectron2\"", ",", "\"validation\"", ")", "\n", "segm_gt", "=", "read_image", "(", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "image_id", "+", "\".png\"", ")", ")", ".", "copy", "(", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "", "elif", "args", ".", "dataset_name", "==", "\"coco_2017_test_stuff_10k_sem_seg\"", ":", "\n", "            ", "gt_dir", "=", "os", ".", "path", ".", "join", "(", "_root", ",", "\"coco\"", ",", "\"coco_stuff_10k\"", ",", "\"annotations_detectron2\"", ",", "\"test\"", ")", "\n", "segm_gt", "=", "read_image", "(", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "image_id", "+", "\".png\"", ")", ")", ".", "copy", "(", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "", "elif", "args", ".", "dataset_name", "==", "\"ade20k_full_sem_seg_val\"", ":", "\n", "            ", "gt_dir", "=", "os", ".", "path", ".", "join", "(", "_root", ",", "\"ADE20K_2021_17_01\"", ",", "\"annotations_detectron2\"", ",", "\"validation\"", ")", "\n", "segm_gt", "=", "read_image", "(", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "image_id", "+", "\".tif\"", ")", ")", ".", "copy", "(", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Unsupported dataset {args.dataset_name}\"", ")", "\n", "\n", "# get predictions", "\n", "", "segm_dt", "=", "np", ".", "zeros_like", "(", "segm_gt", ")", "\n", "anns", "=", "imgToAnns", "[", "image_id", "]", "\n", "for", "ann", "in", "anns", ":", "\n", "# map back category_id", "\n", "            ", "if", "hasattr", "(", "meta", ",", "\"stuff_dataset_id_to_contiguous_id\"", ")", ":", "\n", "                ", "if", "ann", "[", "\"category_id\"", "]", "in", "meta", ".", "stuff_dataset_id_to_contiguous_id", ":", "\n", "                    ", "category_id", "=", "meta", ".", "stuff_dataset_id_to_contiguous_id", "[", "ann", "[", "\"category_id\"", "]", "]", "\n", "", "", "else", ":", "\n", "                ", "category_id", "=", "ann", "[", "\"category_id\"", "]", "\n", "", "mask", "=", "maskUtils", ".", "decode", "(", "ann", "[", "\"segmentation\"", "]", ")", "\n", "segm_dt", "[", "mask", ">", "0", "]", "=", "category_id", "\n", "\n", "# miou", "\n", "", "gt", "=", "segm_gt", ".", "copy", "(", ")", "\n", "pred", "=", "segm_dt", ".", "copy", "(", ")", "\n", "gt", "[", "gt", "==", "ignore_label", "]", "=", "num_classes", "\n", "conf_matrix", "+=", "np", ".", "bincount", "(", "\n", "(", "num_classes", "+", "1", ")", "*", "pred", ".", "reshape", "(", "-", "1", ")", "+", "gt", ".", "reshape", "(", "-", "1", ")", ",", "\n", "minlength", "=", "conf_matrix", ".", "size", ",", "\n", ")", ".", "reshape", "(", "conf_matrix", ".", "shape", ")", "\n", "\n", "# pq", "\n", "pq_stat_single", "=", "pq_compute_single_image", "(", "segm_gt", ",", "segm_dt", ",", "categories", ",", "meta", ".", "ignore_label", ")", "\n", "pq_stat", "+=", "pq_stat_single", "\n", "\n", "", "metrics", "=", "[", "(", "\"All\"", ",", "None", ")", ",", "(", "\"Stuff\"", ",", "False", ")", "]", "\n", "results", "=", "{", "}", "\n", "for", "name", ",", "isthing", "in", "metrics", ":", "\n", "        ", "results", "[", "name", "]", ",", "per_class_results", "=", "pq_stat", ".", "pq_average", "(", "categories", ",", "isthing", "=", "isthing", ")", "\n", "if", "name", "==", "'All'", ":", "\n", "            ", "results", "[", "'per_class'", "]", "=", "per_class_results", "\n", "", "", "print", "(", "\"{:10s}| {:>5s}  {:>5s}  {:>5s} {:>5s}\"", ".", "format", "(", "\"\"", ",", "\"PQ\"", ",", "\"SQ\"", ",", "\"RQ\"", ",", "\"N\"", ")", ")", "\n", "print", "(", "\"-\"", "*", "(", "10", "+", "7", "*", "4", ")", ")", "\n", "\n", "for", "name", ",", "_isthing", "in", "metrics", ":", "\n", "        ", "print", "(", "\"{:10s}| {:5.1f}  {:5.1f}  {:5.1f} {:5d}\"", ".", "format", "(", "\n", "name", ",", "\n", "100", "*", "results", "[", "name", "]", "[", "'pq'", "]", ",", "\n", "100", "*", "results", "[", "name", "]", "[", "'sq'", "]", ",", "\n", "100", "*", "results", "[", "name", "]", "[", "'rq'", "]", ",", "\n", "results", "[", "name", "]", "[", "'n'", "]", ")", "\n", ")", "\n", "\n", "# calculate miou", "\n", "", "acc", "=", "np", ".", "full", "(", "num_classes", ",", "np", ".", "nan", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "iou", "=", "np", ".", "full", "(", "num_classes", ",", "np", ".", "nan", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "tp", "=", "conf_matrix", ".", "diagonal", "(", ")", "[", ":", "-", "1", "]", ".", "astype", "(", "np", ".", "float64", ")", "\n", "pos_gt", "=", "np", ".", "sum", "(", "conf_matrix", "[", ":", "-", "1", ",", ":", "-", "1", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "pos_pred", "=", "np", ".", "sum", "(", "conf_matrix", "[", ":", "-", "1", ",", ":", "-", "1", "]", ",", "axis", "=", "1", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "acc_valid", "=", "pos_gt", ">", "0", "\n", "acc", "[", "acc_valid", "]", "=", "tp", "[", "acc_valid", "]", "/", "pos_gt", "[", "acc_valid", "]", "\n", "iou_valid", "=", "(", "pos_gt", "+", "pos_pred", ")", ">", "0", "\n", "union", "=", "pos_gt", "+", "pos_pred", "-", "tp", "\n", "iou", "[", "acc_valid", "]", "=", "tp", "[", "acc_valid", "]", "/", "union", "[", "acc_valid", "]", "\n", "miou", "=", "np", ".", "sum", "(", "iou", "[", "acc_valid", "]", ")", "/", "np", ".", "sum", "(", "iou_valid", ")", "\n", "\n", "print", "(", "\"\"", ")", "\n", "print", "(", "f\"mIoU: {miou}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.analyze_model.setup": [[44, 60], ["args.config_file.endswith", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger", "detectron2.config.get_cfg", "detectron2.projects.deeplab.add_deeplab_config", "hcformer.add_maskformer2_config", "hcformer.add_hcformer_config", "LazyConfig.apply_overrides.merge_from_file", "LazyConfig.apply_overrides.merge_from_list", "LazyConfig.apply_overrides.freeze", "detectron2.config.LazyConfig.load", "detectron2.config.LazyConfig.apply_overrides"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.config.add_maskformer2_config", "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.config.add_hcformer_config"], ["def", "setup", "(", "args", ")", ":", "\n", "    ", "if", "args", ".", "config_file", ".", "endswith", "(", "\".yaml\"", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "add_deeplab_config", "(", "cfg", ")", "\n", "add_maskformer2_config", "(", "cfg", ")", "\n", "add_hcformer_config", "(", "cfg", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "", "else", ":", "\n", "        ", "cfg", "=", "LazyConfig", ".", "load", "(", "args", ".", "config_file", ")", "\n", "cfg", "=", "LazyConfig", ".", "apply_overrides", "(", "cfg", ",", "args", ".", "opts", ")", "\n", "", "setup_logger", "(", "name", "=", "\"fvcore\"", ")", "\n", "setup_logger", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.analyze_model.do_flop": [[62, 93], ["isinstance", "detectron2.config.instantiate.eval", "collections.Counter", "zip", "logger.info", "logger.info", "logger.info", "detectron2.data.build_detection_test_loader", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "detectron2.config.instantiate", "detectron2.config.instantiate", "detectron2.config.instantiate.to", "detectron2.checkpoint.DetectionCheckpointer().load", "tqdm.trange", "detectron2.utils.analysis.FlopCountAnalysis", "detectron2.utils.analysis.FlopCountAnalysis.by_operator", "total_flops.append", "isinstance", "torch.zeros", "torch.zeros", "detectron2.utils.analysis.FlopCountAnalysis.unsupported_ops_warnings().uncalled_modules_warnings", "detectron2.utils.analysis.FlopCountAnalysis.total", "fvcore.nn.flop_count_table", "str", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.checkpoint.DetectionCheckpointer", "numpy.mean", "numpy.std", "detectron2.utils.analysis.FlopCountAnalysis.unsupported_ops_warnings", "collections.Counter.items"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to"], ["", "def", "do_flop", "(", "cfg", ")", ":", "\n", "    ", "if", "isinstance", "(", "cfg", ",", "CfgNode", ")", ":", "\n", "        ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "", "else", ":", "\n", "        ", "data_loader", "=", "instantiate", "(", "cfg", ".", "dataloader", ".", "test", ")", "\n", "model", "=", "instantiate", "(", "cfg", ".", "model", ")", "\n", "model", ".", "to", "(", "cfg", ".", "train", ".", "device", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "train", ".", "init_checkpoint", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "\n", "counts", "=", "Counter", "(", ")", "\n", "total_flops", "=", "[", "]", "\n", "for", "idx", ",", "data", "in", "zip", "(", "tqdm", ".", "trange", "(", "args", ".", "num_inputs", ")", ",", "data_loader", ")", ":", "# noqa", "\n", "        ", "if", "args", ".", "use_fixed_input_size", "and", "isinstance", "(", "cfg", ",", "CfgNode", ")", ":", "\n", "            ", "crop_size", "=", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", "[", "0", "]", "\n", "data", "[", "0", "]", "[", "\"image\"", "]", "=", "torch", ".", "zeros", "(", "(", "3", ",", "crop_size", ",", "crop_size", ")", ")", "\n", "", "flops", "=", "FlopCountAnalysis", "(", "model", ",", "data", ")", "\n", "if", "idx", ">", "0", ":", "\n", "            ", "flops", ".", "unsupported_ops_warnings", "(", "False", ")", ".", "uncalled_modules_warnings", "(", "False", ")", "\n", "", "counts", "+=", "flops", ".", "by_operator", "(", ")", "\n", "total_flops", ".", "append", "(", "flops", ".", "total", "(", ")", ")", "\n", "\n", "", "logger", ".", "info", "(", "\"Flops table computed from only one input sample:\\n\"", "+", "flop_count_table", "(", "flops", ")", ")", "\n", "logger", ".", "info", "(", "\n", "\"Average GFlops for each type of operators:\\n\"", "\n", "+", "str", "(", "[", "(", "k", ",", "v", "/", "(", "idx", "+", "1", ")", "/", "1e9", ")", "for", "k", ",", "v", "in", "counts", ".", "items", "(", ")", "]", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total GFlops: {:.1f}\u00b1{:.1f}\"", ".", "format", "(", "np", ".", "mean", "(", "total_flops", ")", "/", "1e9", ",", "np", ".", "std", "(", "total_flops", ")", "/", "1e9", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.analyze_model.do_activation": [[96, 121], ["isinstance", "detectron2.config.instantiate.eval", "collections.Counter", "zip", "logger.info", "logger.info", "detectron2.data.build_detection_test_loader", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "detectron2.config.instantiate", "detectron2.config.instantiate", "detectron2.config.instantiate.to", "detectron2.checkpoint.DetectionCheckpointer().load", "tqdm.trange", "detectron2.utils.analysis.activation_count_operators", "total_activations.append", "sum", "str", "numpy.mean", "numpy.std", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.utils.analysis.activation_count_operators.values", "collections.Counter.items"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to"], ["", "def", "do_activation", "(", "cfg", ")", ":", "\n", "    ", "if", "isinstance", "(", "cfg", ",", "CfgNode", ")", ":", "\n", "        ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "", "else", ":", "\n", "        ", "data_loader", "=", "instantiate", "(", "cfg", ".", "dataloader", ".", "test", ")", "\n", "model", "=", "instantiate", "(", "cfg", ".", "model", ")", "\n", "model", ".", "to", "(", "cfg", ".", "train", ".", "device", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "train", ".", "init_checkpoint", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "\n", "counts", "=", "Counter", "(", ")", "\n", "total_activations", "=", "[", "]", "\n", "for", "idx", ",", "data", "in", "zip", "(", "tqdm", ".", "trange", "(", "args", ".", "num_inputs", ")", ",", "data_loader", ")", ":", "# noqa", "\n", "        ", "count", "=", "activation_count_operators", "(", "model", ",", "data", ")", "\n", "counts", "+=", "count", "\n", "total_activations", ".", "append", "(", "sum", "(", "count", ".", "values", "(", ")", ")", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"(Million) Activations for Each Type of Operators:\\n\"", "\n", "+", "str", "(", "[", "(", "k", ",", "v", "/", "idx", ")", "for", "k", ",", "v", "in", "counts", ".", "items", "(", ")", "]", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total (Million) Activations: {}\u00b1{}\"", ".", "format", "(", "\n", "np", ".", "mean", "(", "total_activations", ")", ",", "np", ".", "std", "(", "total_activations", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.analyze_model.do_parameter": [[125, 131], ["isinstance", "logger.info", "detectron2.modeling.build_model", "detectron2.config.instantiate", "detectron2.utils.analysis.parameter_count_table"], "function", ["None"], ["", "def", "do_parameter", "(", "cfg", ")", ":", "\n", "    ", "if", "isinstance", "(", "cfg", ",", "CfgNode", ")", ":", "\n", "        ", "model", "=", "build_model", "(", "cfg", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "instantiate", "(", "cfg", ".", "model", ")", "\n", "", "logger", ".", "info", "(", "\"Parameter Count:\\n\"", "+", "parameter_count_table", "(", "model", ",", "max_depth", "=", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.analyze_model.do_structure": [[133, 139], ["isinstance", "logger.info", "detectron2.modeling.build_model", "detectron2.config.instantiate", "str"], "function", ["None"], ["", "def", "do_structure", "(", "cfg", ")", ":", "\n", "    ", "if", "isinstance", "(", "cfg", ",", "CfgNode", ")", ":", "\n", "        ", "model", "=", "build_model", "(", "cfg", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "instantiate", "(", "cfg", ".", "model", ")", "\n", "", "logger", ".", "info", "(", "\"Model Structure:\\n\"", "+", "str", "(", "model", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.tools.analyze_model.do_clustering": [[141, 256], ["torch.no_grad", "torch.no_grad", "numpy.random.randint", "isinstance", "detectron2.config.instantiate.eval", "os.makedirs", "zip", "torch.unfold().reshape", "torch.unfold().reshape", "candidate_clusters.permute().reshape.permute().reshape", "A.permute().reshape.permute().reshape", "torch.bmm().reshape().permute().contiguous", "torch.bmm().reshape().permute().contiguous", "torch.fold", "numpy.unique", "A.permute().reshape.argmax", "torch.zeros_like().scatter_", "torch.zeros_like().scatter_", "range", "cluster_based_upsampling.to().long().numpy", "rgb[].reshape", "numpy.asarray().astype", "numpy.zeros_like", "numpy.unique", "detectron2.data.build_detection_test_loader", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "detectron2.config.instantiate", "detectron2.config.instantiate", "detectron2.config.instantiate.to", "detectron2.checkpoint.DetectionCheckpointer().load", "tqdm.trange", "ImageList.from_tensors", "hasattr", "analyze_model.do_clustering.clst2img"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "do_clustering", "(", "cfg", ")", ":", "\n", "    ", "from", "detectron2", ".", "structures", "import", "ImageList", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "from", "skimage", ".", "segmentation", "import", "mark_boundaries", "\n", "import", "scipy", ".", "stats", "\n", "\n", "rgb", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "255", ",", "(", "2048", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "def", "cluster_based_upsampling", "(", "x", ",", "A", ")", ":", "\n", "        ", "batch_size", ",", "_", ",", "height", ",", "width", "=", "A", ".", "shape", "\n", "n_channels", "=", "x", ".", "shape", "[", "1", "]", "\n", "# get 9 candidate clusters and corresponding assignments", "\n", "candidate_clusters", "=", "F", ".", "unfold", "(", "x", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ".", "reshape", "(", "batch_size", ",", "n_channels", ",", "9", ",", "-", "1", ")", "\n", "A", "=", "F", ".", "unfold", "(", "A", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", ".", "reshape", "(", "batch_size", ",", "9", ",", "4", ",", "-", "1", ")", "\n", "# linear decoding", "\n", "candidate_clusters", "=", "candidate_clusters", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "n_channels", ",", "9", ")", "\n", "A", "=", "A", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "9", ",", "4", ")", "\n", "decoded_features", "=", "torch", ".", "bmm", "(", "candidate_clusters", ",", "A", ")", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "n_channels", "*", "4", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "decoded_features", "=", "F", ".", "fold", "(", "decoded_features", ",", "(", "height", ",", "width", ")", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "return", "decoded_features", "\n", "\n", "", "def", "vis_undersegmentation_error", "(", "clusters", ",", "gt_masks", ",", "img", ",", "ignore_index", "=", "0", ")", ":", "\n", "        ", "c_idx", "=", "np", ".", "unique", "(", "clusters", ")", "\n", "valid_mask", "=", "gt_masks", "!=", "ignore_index", "\n", "for", "i", "in", "c_idx", ":", "\n", "            ", "elem", "=", "clusters", "==", "i", "\n", "gt_clst", "=", "gt_masks", "[", "elem", "]", "\n", "gt_clst", "=", "gt_clst", "[", "gt_clst", "!=", "ignore_index", "]", "\n", "mode", "=", "scipy", ".", "stats", ".", "mode", "(", "gt_clst", ")", ".", "mode", "\n", "err_idx", "=", "np", ".", "logical_and", "(", "np", ".", "logical_and", "(", "gt_masks", "!=", "mode", ",", "elem", ")", ",", "valid_mask", ")", "\n", "img", "[", "err_idx", ",", ":", "]", "=", "(", "255", ",", "0", ",", "0", ")", "\n", "", "return", "img", "\n", "\n", "", "def", "soft2hard", "(", "A", ")", ":", "\n", "        ", "idx", "=", "A", ".", "argmax", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "return", "torch", ".", "zeros_like", "(", "A", ")", ".", "scatter_", "(", "1", ",", "idx", ",", "torch", ".", "ones_like", "(", "idx", ")", ".", "float", "(", ")", ")", "\n", "\n", "", "def", "clst2img", "(", "assigns", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "assigns", ")", ")", ":", "\n", "            ", "h", ",", "w", "=", "assigns", "[", "i", "]", ".", "shape", "[", "-", "2", ":", "]", "\n", "idx", "=", "torch", ".", "arange", "(", "h", "//", "2", "*", "w", "//", "2", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", ".", "reshape", "(", "1", ",", "1", ",", "h", "//", "2", ",", "w", "//", "2", ")", "\n", "for", "a", "in", "assigns", "[", "i", ":", "]", ":", "\n", "                ", "idx", "=", "cluster_based_upsampling", "(", "idx", ",", "a", ")", "\n", "", "outputs", ".", "append", "(", "idx", ")", "\n", "", "return", "outputs", "\n", "\n", "", "def", "idx2rgb", "(", "idx", ",", "rgb", ")", ":", "\n", "        ", "idx", "=", "idx", ".", "to", "(", "'cpu'", ")", ".", "long", "(", ")", ".", "numpy", "(", ")", "\n", "h", ",", "w", "=", "idx", ".", "shape", "[", "-", "2", ":", "]", "\n", "return", "rgb", "[", "idx", ".", "ravel", "(", ")", "%", "2048", ",", ":", "]", ".", "reshape", "(", "h", ",", "w", ",", "3", ")", "\n", "\n", "", "def", "get_pan_gt", "(", "path", ")", ":", "\n", "        ", "img", "=", "np", ".", "asarray", "(", "Image", ".", "open", "(", "path", ")", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "id", "=", "img", "[", ":", ",", ":", ",", "0", "]", "+", "256", "*", "img", "[", ":", ",", ":", ",", "1", "]", "+", "256", "**", "2", "*", "img", "[", ":", ",", ":", ",", "2", "]", "\n", "msk", "=", "np", ".", "zeros_like", "(", "id", ")", "\n", "for", "i", "in", "np", ".", "unique", "(", "id", ")", ":", "\n", "            ", "msk", "[", "id", "==", "i", "]", "=", "i", "\n", "", "return", "msk", "\n", "\n", "", "if", "isinstance", "(", "cfg", ",", "CfgNode", ")", ":", "\n", "        ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "", "else", ":", "\n", "        ", "data_loader", "=", "instantiate", "(", "cfg", ".", "dataloader", ".", "test", ")", "\n", "model", "=", "instantiate", "(", "cfg", ".", "model", ")", "\n", "model", ".", "to", "(", "cfg", ".", "train", ".", "device", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "train", ".", "init_checkpoint", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "\n", "os", ".", "makedirs", "(", "cfg", ".", "OUTPUT_DIR", ",", "exist_ok", "=", "True", ")", "\n", "\n", "for", "idx", ",", "data", "in", "zip", "(", "tqdm", ".", "trange", "(", "args", ".", "num_inputs", ")", ",", "data_loader", ")", ":", "# noqa", "\n", "        ", "if", "args", ".", "use_fixed_input_size", "and", "isinstance", "(", "cfg", ",", "CfgNode", ")", ":", "\n", "            ", "crop_size", "=", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", "[", "0", "]", "\n", "data", "[", "0", "]", "[", "\"image\"", "]", "=", "torch", ".", "zeros", "(", "(", "3", ",", "crop_size", ",", "crop_size", ")", ")", "\n", "# preprocess", "\n", "", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "model", ".", "device", ")", "for", "x", "in", "data", "]", "\n", "images", "=", "[", "(", "x", "-", "model", ".", "pixel_mean", ")", "/", "model", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "model", ".", "size_divisibility", ")", "\n", "if", "hasattr", "(", "data", "[", "0", "]", ",", "'image_id'", ")", ":", "\n", "            ", "image_id", "=", "str", "(", "data", "[", "0", "]", "[", "'image_id'", "]", ")", ".", "zfill", "(", "12", ")", "\n", "", "else", ":", "\n", "            ", "image_id", "=", "str", "(", "idx", ")", ".", "zfill", "(", "4", ")", "\n", "# forward", "\n", "", "assign", "=", "model", ".", "backbone", "(", "images", ".", "tensor", ")", "[", "'assign'", "]", "\n", "hard_assign", "=", "[", "soft2hard", "(", "a", ")", "for", "a", "in", "assign", "]", "\n", "clusters", "=", "clst2img", "(", "hard_assign", ",", "model", ".", "device", ")", "\n", "pred", "=", "model", "(", "data", ")", "[", "0", "]", "\n", "# visualize", "\n", "h", ",", "w", "=", "pred", "[", "'sem_seg'", "]", ".", "shape", "[", "-", "2", ":", "]", "\n", "np_img", "=", "data", "[", "0", "]", "[", "'image'", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "contiguous", "(", ")", ".", "numpy", "(", ")", "\n", "np_img", "=", "cv2", ".", "resize", "(", "np_img", ",", "(", "w", ",", "h", ")", ",", "interpolation", "=", "cv2", ".", "INTER_CUBIC", ")", "\n", "if", "'pan_seg_file_name'", "in", "data", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "            ", "gt_id", "=", "get_pan_gt", "(", "data", "[", "0", "]", "[", "'pan_seg_file_name'", "]", ")", "\n", "gt_id", "=", "cv2", ".", "resize", "(", "gt_id", ",", "(", "w", ",", "h", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "ignore", "=", "0", "\n", "", "elif", "'sem_seg'", "in", "data", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "            ", "gt_id", "=", "data", "[", "0", "]", "[", "'sem_seg'", "]", ".", "numpy", "(", ")", "\n", "gt_id", "=", "cv2", ".", "resize", "(", "gt_id", ",", "(", "w", ",", "h", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "ignore", "=", "255", "\n", "", "else", ":", "\n", "            ", "gt_id", "=", "None", "\n", "", "for", "i", ",", "(", "c", ",", "a", ")", "in", "enumerate", "(", "zip", "(", "clusters", ",", "hard_assign", ")", ")", ":", "\n", "            ", "plt", ".", "imsave", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "f'{image_id}-{i}.png'", ")", ",", "idx2rgb", "(", "c", ",", "rgb", ")", ")", "\n", "c", "=", "F", ".", "interpolate", "(", "c", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "'nearest'", ")", "\n", "np_c", "=", "c", ".", "to", "(", "'cpu'", ")", ".", "long", "(", ")", ".", "numpy", "(", ")", "[", "0", ",", "0", "]", "\n", "b_img", "=", "mark_boundaries", "(", "np_img", ",", "np_c", ")", "\n", "plt", ".", "imsave", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "f'bound-{image_id}-{i}.png'", ")", ",", "b_img", ")", "\n", "if", "gt_id", "is", "not", "None", ":", "\n", "                ", "seg_err", "=", "vis_undersegmentation_error", "(", "np_c", ",", "gt_id", ",", "np_img", ".", "copy", "(", ")", ",", "ignore", ")", "\n", "plt", ".", "imsave", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "f'err-{image_id}-{i}.png'", ")", ",", "seg_err", ")", "\n", "", "", "torch", ".", "save", "(", "data", "[", "0", "]", ",", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "f'{image_id}-meta.pth'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.config.add_maskformer2_config": [[10, 119], ["detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["def", "add_maskformer2_config", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Add config for MASK_FORMER.\n    \"\"\"", "\n", "# NOTE: configs from original maskformer", "\n", "# data config", "\n", "# select the dataset mapper", "\n", "cfg", ".", "INPUT", ".", "DATASET_MAPPER_NAME", "=", "\"mask_former_semantic\"", "\n", "# Color augmentation", "\n", "cfg", ".", "INPUT", ".", "COLOR_AUG_SSD", "=", "False", "\n", "# We retry random cropping until no single category in semantic segmentation GT occupies more", "\n", "# than `SINGLE_CATEGORY_MAX_AREA` part of the crop.", "\n", "cfg", ".", "INPUT", ".", "CROP", ".", "SINGLE_CATEGORY_MAX_AREA", "=", "1.0", "\n", "# Pad image and segmentation GT in dataset mapper.", "\n", "cfg", ".", "INPUT", ".", "SIZE_DIVISIBILITY", "=", "-", "1", "\n", "\n", "# solver config", "\n", "# weight decay on embedding", "\n", "cfg", ".", "SOLVER", ".", "WEIGHT_DECAY_EMBED", "=", "0.0", "\n", "# optimizer", "\n", "cfg", ".", "SOLVER", ".", "OPTIMIZER", "=", "\"ADAMW\"", "\n", "cfg", ".", "SOLVER", ".", "BACKBONE_MULTIPLIER", "=", "0.1", "\n", "\n", "# mask_former model config", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", "=", "CN", "(", ")", "\n", "\n", "# loss", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DEEP_SUPERVISION", "=", "True", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NO_OBJECT_WEIGHT", "=", "0.1", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "CLASS_WEIGHT", "=", "1.0", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DICE_WEIGHT", "=", "1.0", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "MASK_WEIGHT", "=", "20.0", "\n", "\n", "# transformer config", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NHEADS", "=", "8", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DROPOUT", "=", "0.1", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DIM_FEEDFORWARD", "=", "2048", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "ENC_LAYERS", "=", "0", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DEC_LAYERS", "=", "6", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "PRE_NORM", "=", "False", "\n", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "HIDDEN_DIM", "=", "256", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NUM_OBJECT_QUERIES", "=", "100", "\n", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TRANSFORMER_IN_FEATURE", "=", "\"res5\"", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "ENFORCE_INPUT_PROJ", "=", "False", "\n", "\n", "# mask_former inference config", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", "=", "CN", "(", ")", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "SEMANTIC_ON", "=", "True", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "INSTANCE_ON", "=", "False", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "PANOPTIC_ON", "=", "False", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "OBJECT_MASK_THRESHOLD", "=", "0.0", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "OVERLAP_THRESHOLD", "=", "0.0", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "SEM_SEG_POSTPROCESSING_BEFORE_INFERENCE", "=", "False", "\n", "\n", "# Sometimes `backbone.size_divisibility` is set to 0 for some backbone (e.g. ResNet)", "\n", "# you can use this config to override", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "SIZE_DIVISIBILITY", "=", "32", "\n", "\n", "# pixel decoder config", "\n", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "MASK_DIM", "=", "256", "\n", "# adding transformer in pixel decoder", "\n", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "TRANSFORMER_ENC_LAYERS", "=", "0", "\n", "# pixel decoder", "\n", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "PIXEL_DECODER_NAME", "=", "\"BasePixelDecoder\"", "\n", "\n", "# swin transformer backbone", "\n", "cfg", ".", "MODEL", ".", "SWIN", "=", "CN", "(", ")", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "PRETRAIN_IMG_SIZE", "=", "224", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "PATCH_SIZE", "=", "4", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "EMBED_DIM", "=", "96", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "DEPTHS", "=", "[", "2", ",", "2", ",", "6", ",", "2", "]", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "NUM_HEADS", "=", "[", "3", ",", "6", ",", "12", ",", "24", "]", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "WINDOW_SIZE", "=", "7", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "MLP_RATIO", "=", "4.0", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "QKV_BIAS", "=", "True", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "QK_SCALE", "=", "None", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "DROP_RATE", "=", "0.0", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "ATTN_DROP_RATE", "=", "0.0", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "DROP_PATH_RATE", "=", "0.3", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "APE", "=", "False", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "PATCH_NORM", "=", "True", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "OUT_FEATURES", "=", "[", "\"res2\"", ",", "\"res3\"", ",", "\"res4\"", ",", "\"res5\"", "]", "\n", "cfg", ".", "MODEL", ".", "SWIN", ".", "USE_CHECKPOINT", "=", "False", "\n", "\n", "# NOTE: maskformer2 extra configs", "\n", "# transformer module", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TRANSFORMER_DECODER_NAME", "=", "\"MultiScaleMaskedTransformerDecoder\"", "\n", "\n", "# LSJ aug", "\n", "cfg", ".", "INPUT", ".", "IMAGE_SIZE", "=", "1024", "\n", "cfg", ".", "INPUT", ".", "MIN_SCALE", "=", "0.1", "\n", "cfg", ".", "INPUT", ".", "MAX_SCALE", "=", "2.0", "\n", "\n", "# MSDeformAttn encoder configs", "\n", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "DEFORMABLE_TRANSFORMER_ENCODER_IN_FEATURES", "=", "[", "\"res3\"", ",", "\"res4\"", ",", "\"res5\"", "]", "\n", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "DEFORMABLE_TRANSFORMER_ENCODER_N_POINTS", "=", "4", "\n", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "DEFORMABLE_TRANSFORMER_ENCODER_N_HEADS", "=", "8", "\n", "\n", "# point loss configs", "\n", "# Number of points sampled during training for a mask point head.", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TRAIN_NUM_POINTS", "=", "112", "*", "112", "\n", "# Oversampling parameter for PointRend point sampling during training. Parameter `k` in the", "\n", "# original paper.", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "OVERSAMPLE_RATIO", "=", "3.0", "\n", "# Importance sampling parameter for PointRend point sampling during training. Parametr `beta` in", "\n", "# the original paper.", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "IMPORTANCE_SAMPLE_RATIO", "=", "0.75", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.config.add_hcformer_config": [[121, 135], ["detectron2.config.CfgNode"], "function", ["None"], ["", "def", "add_hcformer_config", "(", "cfg", ")", ":", "\n", "# hc parameters", "\n", "    ", "cfg", ".", "MODEL", ".", "HC", "=", "CN", "(", ")", "\n", "# hierarchical level [0,3]", "\n", "cfg", ".", "MODEL", ".", "HC", ".", "LEVEL", "=", "3", "\n", "# initial value of the scale parameter in the clustering module", "\n", "cfg", ".", "MODEL", ".", "HC", ".", "TEMPERATURE", "=", "0.1", "\n", "# embedding dimension of 1x1Conv in the clustering module", "\n", "cfg", ".", "MODEL", ".", "HC", ".", "EMB_DIM", "=", "128", "\n", "# loss weight for l1 regularization term", "\n", "cfg", ".", "MODEL", ".", "HC", ".", "L1_WEIGHT", "=", "0.1", "\n", "# backbone parameters", "\n", "cfg", ".", "MODEL", ".", "RESNETS", ".", "AUX", "=", "'none'", "# none or transformer", "\n", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DOWNSAMPLING", "=", "'deform'", "# deform or conv", "\n", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.test_time_augmentation.SemanticSegmentorWithTTA.__init__": [[27, 48], ["torch.nn.Module.__init__", "isinstance", "cfg.clone", "detectron2.modeling.DatasetMapperTTA"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "model", ",", "tta_mapper", "=", "None", ",", "batch_size", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            model (SemanticSegmentor): a SemanticSegmentor to apply TTA on.\n            tta_mapper (callable): takes a dataset dict and returns a list of\n                augmented versions of the dataset dict. Defaults to\n                `DatasetMapperTTA(cfg)`.\n            batch_size (int): batch the augmented images into this batch size for inference.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "model", ",", "DistributedDataParallel", ")", ":", "\n", "            ", "model", "=", "model", ".", "module", "\n", "", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "\n", "if", "tta_mapper", "is", "None", ":", "\n", "            ", "tta_mapper", "=", "DatasetMapperTTA", "(", "cfg", ")", "\n", "", "self", ".", "tta_mapper", "=", "tta_mapper", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.test_time_augmentation.SemanticSegmentorWithTTA.__call__": [[49, 70], ["copy.copy", "test_time_augmentation.SemanticSegmentorWithTTA._inference_one_image", "processed_results.append", "detectron2.data.detection_utils.read_image", "torch.from_numpy", "test_time_augmentation.SemanticSegmentorWithTTA.__call__._maybe_read_image"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.test_time_augmentation.SemanticSegmentorWithTTA._inference_one_image"], ["", "def", "__call__", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Same input/output format as :meth:`SemanticSegmentor.forward`\n        \"\"\"", "\n", "\n", "def", "_maybe_read_image", "(", "dataset_dict", ")", ":", "\n", "            ", "ret", "=", "copy", ".", "copy", "(", "dataset_dict", ")", "\n", "if", "\"image\"", "not", "in", "ret", ":", "\n", "                ", "image", "=", "read_image", "(", "ret", ".", "pop", "(", "\"file_name\"", ")", ",", "self", ".", "model", ".", "input_format", ")", "\n", "image", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "# CHW", "\n", "ret", "[", "\"image\"", "]", "=", "image", "\n", "", "if", "\"height\"", "not", "in", "ret", "and", "\"width\"", "not", "in", "ret", ":", "\n", "                ", "ret", "[", "\"height\"", "]", "=", "image", ".", "shape", "[", "1", "]", "\n", "ret", "[", "\"width\"", "]", "=", "image", ".", "shape", "[", "2", "]", "\n", "", "return", "ret", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "x", "in", "batched_inputs", ":", "\n", "            ", "result", "=", "self", ".", "_inference_one_image", "(", "_maybe_read_image", "(", "x", ")", ")", "\n", "processed_results", ".", "append", "(", "result", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.test_time_augmentation.SemanticSegmentorWithTTA._inference_one_image": [[71, 99], ["test_time_augmentation.SemanticSegmentorWithTTA._get_augmented_inputs", "zip", "torch.no_grad", "any", "any", "[].pop().flip", "[].pop", "[].pop().flip", "[].pop", "isinstance", "isinstance", "[].pop", "[].pop", "test_time_augmentation.SemanticSegmentorWithTTA.model", "test_time_augmentation.SemanticSegmentorWithTTA.model", "test_time_augmentation.SemanticSegmentorWithTTA.model", "test_time_augmentation.SemanticSegmentorWithTTA.model"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.test_time_augmentation.SemanticSegmentorWithTTA._get_augmented_inputs"], ["", "def", "_inference_one_image", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (dict): one dataset dict with \"image\" field being a CHW tensor\n        Returns:\n            dict: one output dict\n        \"\"\"", "\n", "orig_shape", "=", "(", "input", "[", "\"height\"", "]", ",", "input", "[", "\"width\"", "]", ")", "\n", "augmented_inputs", ",", "tfms", "=", "self", ".", "_get_augmented_inputs", "(", "input", ")", "\n", "\n", "final_predictions", "=", "None", "\n", "count_predictions", "=", "0", "\n", "for", "input", ",", "tfm", "in", "zip", "(", "augmented_inputs", ",", "tfms", ")", ":", "\n", "            ", "count_predictions", "+=", "1", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "if", "final_predictions", "is", "None", ":", "\n", "                    ", "if", "any", "(", "isinstance", "(", "t", ",", "HFlipTransform", ")", "for", "t", "in", "tfm", ".", "transforms", ")", ":", "\n", "                        ", "final_predictions", "=", "self", ".", "model", "(", "[", "input", "]", ")", "[", "0", "]", ".", "pop", "(", "\"sem_seg\"", ")", ".", "flip", "(", "dims", "=", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                        ", "final_predictions", "=", "self", ".", "model", "(", "[", "input", "]", ")", "[", "0", "]", ".", "pop", "(", "\"sem_seg\"", ")", "\n", "", "", "else", ":", "\n", "                    ", "if", "any", "(", "isinstance", "(", "t", ",", "HFlipTransform", ")", "for", "t", "in", "tfm", ".", "transforms", ")", ":", "\n", "                        ", "final_predictions", "+=", "self", ".", "model", "(", "[", "input", "]", ")", "[", "0", "]", ".", "pop", "(", "\"sem_seg\"", ")", ".", "flip", "(", "dims", "=", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                        ", "final_predictions", "+=", "self", ".", "model", "(", "[", "input", "]", ")", "[", "0", "]", ".", "pop", "(", "\"sem_seg\"", ")", "\n", "\n", "", "", "", "", "final_predictions", "=", "final_predictions", "/", "count_predictions", "\n", "return", "{", "\"sem_seg\"", ":", "final_predictions", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.test_time_augmentation.SemanticSegmentorWithTTA._get_augmented_inputs": [[100, 104], ["test_time_augmentation.SemanticSegmentorWithTTA.tta_mapper", "x.pop"], "methods", ["None"], ["", "def", "_get_augmented_inputs", "(", "self", ",", "input", ")", ":", "\n", "        ", "augmented_inputs", "=", "self", ".", "tta_mapper", "(", "input", ")", "\n", "tfms", "=", "[", "x", ".", "pop", "(", "\"transforms\"", ")", "for", "x", "in", "augmented_inputs", "]", "\n", "return", "augmented_inputs", ",", "tfms", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.__init__": [[32, 101], ["torch.nn.Module.__init__", "hcformer_model.HCFormer.register_buffer", "hcformer_model.HCFormer.register_buffer", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "backbone", ":", "Backbone", ",", "\n", "sem_seg_head", ":", "nn", ".", "Module", ",", "\n", "criterion", ":", "nn", ".", "Module", ",", "\n", "num_queries", ":", "int", ",", "\n", "object_mask_threshold", ":", "float", ",", "\n", "overlap_threshold", ":", "float", ",", "\n", "metadata", ",", "\n", "size_divisibility", ":", "int", ",", "\n", "sem_seg_postprocess_before_inference", ":", "bool", ",", "\n", "pixel_mean", ":", "Tuple", "[", "float", "]", ",", "\n", "pixel_std", ":", "Tuple", "[", "float", "]", ",", "\n", "# inference", "\n", "semantic_on", ":", "bool", ",", "\n", "panoptic_on", ":", "bool", ",", "\n", "instance_on", ":", "bool", ",", "\n", "test_topk_per_image", ":", "int", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            backbone: a backbone module, must follow detectron2's backbone interface\n            sem_seg_head: a module that predicts semantic segmentation from backbone features\n            criterion: a module that defines the loss\n            num_queries: int, number of queries\n            object_mask_threshold: float, threshold to filter query based on classification score\n                for panoptic segmentation inference\n            overlap_threshold: overlap threshold used in general inference for panoptic segmentation\n            metadata: dataset meta, get `thing` and `stuff` category names for panoptic\n                segmentation inference\n            size_divisibility: Some backbones require the input height and width to be divisible by a\n                specific integer. We can use this to override such requirement.\n            sem_seg_postprocess_before_inference: whether to resize the prediction back\n                to original input size before semantic segmentation inference or after.\n                For high-resolution dataset like Mapillary, resizing predictions before\n                inference will cause OOM error.\n            pixel_mean, pixel_std: list or tuple with #channels element, representing\n                the per-channel mean and std to be used to normalize the input image\n            semantic_on: bool, whether to output semantic segmentation prediction\n            instance_on: bool, whether to output instance segmentation prediction\n            panoptic_on: bool, whether to output panoptic segmentation prediction\n            test_topk_per_image: int, instance segmentation parameter, keep topk instances per image\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "backbone", "\n", "self", ".", "sem_seg_head", "=", "sem_seg_head", "\n", "self", ".", "criterion", "=", "criterion", "\n", "self", ".", "num_queries", "=", "num_queries", "\n", "self", ".", "overlap_threshold", "=", "overlap_threshold", "\n", "self", ".", "object_mask_threshold", "=", "object_mask_threshold", "\n", "self", ".", "metadata", "=", "metadata", "\n", "if", "size_divisibility", "<", "0", ":", "\n", "# use backbone size_divisibility if not set", "\n", "            ", "size_divisibility", "=", "self", ".", "backbone", ".", "size_divisibility", "\n", "", "self", ".", "size_divisibility", "=", "size_divisibility", "\n", "self", ".", "sem_seg_postprocess_before_inference", "=", "sem_seg_postprocess_before_inference", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "pixel_mean", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ",", "False", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "pixel_std", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ",", "False", ")", "\n", "\n", "# additional args", "\n", "self", ".", "semantic_on", "=", "semantic_on", "\n", "self", ".", "instance_on", "=", "instance_on", "\n", "self", ".", "panoptic_on", "=", "panoptic_on", "\n", "self", ".", "test_topk_per_image", "=", "test_topk_per_image", "\n", "\n", "if", "not", "self", ".", "semantic_on", ":", "\n", "            ", "assert", "self", ".", "sem_seg_postprocess_before_inference", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.from_config": [[102, 168], ["detectron2.modeling.build_backbone", "detectron2.modeling.build_sem_seg_head", "modeling.matcher.HungarianMatcher", "modeling.criterion.SetCriterion", "detectron2.modeling.build_backbone.output_shape", "range", "weight_dict.update", "detectron2.data.MetadataCatalog.get", "aux_weight_dict.update", "weight_dict.items"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.HCSwinTransformer.output_shape", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", "\n", "\n", "# Loss parameters:", "\n", "deep_supervision", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DEEP_SUPERVISION", "\n", "no_object_weight", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NO_OBJECT_WEIGHT", "\n", "\n", "# loss weights", "\n", "class_weight", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "CLASS_WEIGHT", "\n", "dice_weight", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DICE_WEIGHT", "\n", "mask_weight", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "MASK_WEIGHT", "\n", "l1_weight", "=", "cfg", ".", "MODEL", ".", "HC", ".", "L1_WEIGHT", "\n", "\n", "# building criterion", "\n", "matcher", "=", "HungarianMatcher", "(", "\n", "cost_class", "=", "class_weight", ",", "\n", "cost_mask", "=", "mask_weight", ",", "\n", "cost_dice", "=", "dice_weight", ",", "\n", "num_points", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TRAIN_NUM_POINTS", ",", "\n", ")", "\n", "\n", "weight_dict", "=", "{", "\"loss_ce\"", ":", "class_weight", ",", "\"loss_mask\"", ":", "mask_weight", ",", "\"loss_dice\"", ":", "dice_weight", ",", "\"loss_l1\"", ":", "l1_weight", "}", "\n", "\n", "if", "deep_supervision", ":", "\n", "            ", "dec_layers", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DEC_LAYERS", "\n", "aux_weight_dict", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "dec_layers", "-", "1", ")", ":", "\n", "                ", "aux_weight_dict", ".", "update", "(", "{", "k", "+", "f\"_{i}\"", ":", "v", "for", "k", ",", "v", "in", "weight_dict", ".", "items", "(", ")", "}", ")", "\n", "", "weight_dict", ".", "update", "(", "aux_weight_dict", ")", "\n", "\n", "", "losses", "=", "[", "\"labels\"", ",", "\"masks\"", "]", "\n", "\n", "criterion", "=", "SetCriterion", "(", "\n", "sem_seg_head", ".", "num_classes", ",", "\n", "matcher", "=", "matcher", ",", "\n", "weight_dict", "=", "weight_dict", ",", "\n", "eos_coef", "=", "no_object_weight", ",", "\n", "losses", "=", "losses", ",", "\n", "num_points", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TRAIN_NUM_POINTS", ",", "\n", "oversample_ratio", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "OVERSAMPLE_RATIO", ",", "\n", "importance_sample_ratio", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "IMPORTANCE_SAMPLE_RATIO", ",", "\n", ")", "\n", "\n", "return", "{", "\n", "\"backbone\"", ":", "backbone", ",", "\n", "\"sem_seg_head\"", ":", "sem_seg_head", ",", "\n", "\"criterion\"", ":", "criterion", ",", "\n", "\"num_queries\"", ":", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NUM_OBJECT_QUERIES", ",", "\n", "\"object_mask_threshold\"", ":", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "OBJECT_MASK_THRESHOLD", ",", "\n", "\"overlap_threshold\"", ":", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "OVERLAP_THRESHOLD", ",", "\n", "\"metadata\"", ":", "MetadataCatalog", ".", "get", "(", "cfg", ".", "DATASETS", ".", "TRAIN", "[", "0", "]", ")", ",", "\n", "\"size_divisibility\"", ":", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "SIZE_DIVISIBILITY", ",", "\n", "\"sem_seg_postprocess_before_inference\"", ":", "(", "\n", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "SEM_SEG_POSTPROCESSING_BEFORE_INFERENCE", "\n", "or", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "PANOPTIC_ON", "\n", "or", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "INSTANCE_ON", "\n", ")", ",", "\n", "\"pixel_mean\"", ":", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ",", "\n", "\"pixel_std\"", ":", "cfg", ".", "MODEL", ".", "PIXEL_STD", ",", "\n", "# inference", "\n", "\"semantic_on\"", ":", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "SEMANTIC_ON", ",", "\n", "\"instance_on\"", ":", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "INSTANCE_ON", ",", "\n", "\"panoptic_on\"", ":", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TEST", ".", "PANOPTIC_ON", ",", "\n", "\"test_topk_per_image\"", ":", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.device": [[170, 173], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.forward": [[174, 275], ["detectron2.structures.ImageList.from_tensors", "hcformer_model.HCFormer.backbone", "hcformer_model.HCFormer.sem_seg_head", "x[].to", "list", "torch.nn.functional.interpolate", "zip", "hcformer_model.HCFormer.prepare_targets", "hcformer_model.HCFormer.criterion", "hcformer_model.HCFormer.criterion", "hcformer_model.HCFormer.keys", "input_per_image.get", "input_per_image.get", "processed_results.append", "x[].to", "sum().abs().sum", "hcformer_model.HCFormer.pop", "mask_cls_result.to.to.to", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.utils.memory.retry_if_cuda_oom", "sum().abs", "detectron2.utils.memory.retry_if_cuda_oom", "sum", "hcformer_model.HCFormer.modules", "isinstance"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.prepare_targets", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n                For now, each item in the list is a dict that contains:\n                   * \"image\": Tensor, image in (C, H, W) format.\n                   * \"instances\": per-region ground truth\n                   * Other information that's included in the original dicts, such as:\n                     \"height\", \"width\" (int): the output resolution of the model (may be different\n                     from input resolution), used in inference.\n        Returns:\n            list[dict]:\n                each dict has the results for one image. The dict contains the following keys:\n\n                * \"sem_seg\":\n                    A Tensor that represents the\n                    per-pixel segmentation prediced by the head.\n                    The prediction has shape KxHxW that represents the logits of\n                    each class for each pixel.\n                * \"panoptic_seg\":\n                    A tuple that represent panoptic output\n                    panoptic_seg (Tensor): of shape (height, width) where the values are ids for each segment.\n                    segments_info (list[dict]): Describe each segment in `panoptic_seg`.\n                        Each dict contains keys \"id\", \"category_id\", \"isthing\".\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "size_divisibility", ")", "\n", "\n", "outputs", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "features", ",", "assigns", "=", "outputs", "[", "\"res5\"", "]", ",", "outputs", "[", "\"assign\"", "]", "\n", "outputs", "=", "self", ".", "sem_seg_head", "(", "features", ",", "assigns", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "# mask classification target", "\n", "            ", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "                ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "self", ".", "prepare_targets", "(", "gt_instances", ",", "images", ")", "\n", "", "else", ":", "\n", "                ", "targets", "=", "None", "\n", "\n", "# bipartite matching-based loss", "\n", "", "if", "self", ".", "criterion", ".", "weight_dict", "[", "\"loss_l1\"", "]", ">", "0", ":", "\n", "                ", "losses", "=", "self", ".", "criterion", "(", "outputs", ",", "targets", ",", "sum", "(", "[", "m", ".", "temp", "for", "m", "in", "self", ".", "modules", "(", ")", "if", "isinstance", "(", "m", ",", "Clustering", ")", "]", ")", ".", "abs", "(", ")", ".", "sum", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "losses", "=", "self", ".", "criterion", "(", "outputs", ",", "targets", ")", "\n", "\n", "", "for", "k", "in", "list", "(", "losses", ".", "keys", "(", ")", ")", ":", "\n", "                ", "if", "k", "in", "self", ".", "criterion", ".", "weight_dict", ":", "\n", "                    ", "losses", "[", "k", "]", "*=", "self", ".", "criterion", ".", "weight_dict", "[", "k", "]", "\n", "", "else", ":", "\n", "# remove this loss if not specified in `weight_dict`", "\n", "                    ", "losses", ".", "pop", "(", "k", ")", "\n", "\n", "", "", "return", "losses", "\n", "", "else", ":", "\n", "            ", "mask_cls_results", "=", "outputs", "[", "\"pred_logits\"", "]", "\n", "mask_pred_results", "=", "outputs", "[", "\"pred_masks\"", "]", "\n", "# upsample masks", "\n", "mask_pred_results", "=", "F", ".", "interpolate", "(", "\n", "mask_pred_results", ",", "\n", "size", "=", "(", "images", ".", "tensor", ".", "shape", "[", "-", "2", "]", ",", "images", ".", "tensor", ".", "shape", "[", "-", "1", "]", ")", ",", "\n", "mode", "=", "\"bilinear\"", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", "\n", "\n", "del", "outputs", "\n", "\n", "processed_results", "=", "[", "]", "\n", "for", "mask_cls_result", ",", "mask_pred_result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "mask_cls_results", ",", "mask_pred_results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "                ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "processed_results", ".", "append", "(", "{", "}", ")", "\n", "\n", "if", "self", ".", "sem_seg_postprocess_before_inference", ":", "\n", "                    ", "mask_pred_result", "=", "retry_if_cuda_oom", "(", "sem_seg_postprocess", ")", "(", "\n", "mask_pred_result", ",", "image_size", ",", "height", ",", "width", "\n", ")", "\n", "mask_cls_result", "=", "mask_cls_result", ".", "to", "(", "mask_pred_result", ")", "\n", "\n", "# semantic segmentation inference", "\n", "", "if", "self", ".", "semantic_on", ":", "\n", "                    ", "r", "=", "retry_if_cuda_oom", "(", "self", ".", "semantic_inference", ")", "(", "mask_cls_result", ",", "mask_pred_result", ")", "\n", "if", "not", "self", ".", "sem_seg_postprocess_before_inference", ":", "\n", "                        ", "r", "=", "retry_if_cuda_oom", "(", "sem_seg_postprocess", ")", "(", "r", ",", "image_size", ",", "height", ",", "width", ")", "\n", "", "processed_results", "[", "-", "1", "]", "[", "\"sem_seg\"", "]", "=", "r", "\n", "\n", "# panoptic segmentation inference", "\n", "", "if", "self", ".", "panoptic_on", ":", "\n", "                    ", "panoptic_r", "=", "retry_if_cuda_oom", "(", "self", ".", "panoptic_inference", ")", "(", "mask_cls_result", ",", "mask_pred_result", ")", "\n", "processed_results", "[", "-", "1", "]", "[", "\"panoptic_seg\"", "]", "=", "panoptic_r", "\n", "\n", "# instance segmentation inference", "\n", "", "if", "self", ".", "instance_on", ":", "\n", "                    ", "instance_r", "=", "retry_if_cuda_oom", "(", "self", ".", "instance_inference", ")", "(", "mask_cls_result", ",", "mask_pred_result", ")", "\n", "processed_results", "[", "-", "1", "]", "[", "\"instances\"", "]", "=", "instance_r", "\n", "\n", "", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.prepare_targets": [[276, 291], ["torch.zeros", "new_targets.append"], "methods", ["None"], ["", "", "def", "prepare_targets", "(", "self", ",", "targets", ",", "images", ")", ":", "\n", "        ", "h_pad", ",", "w_pad", "=", "images", ".", "tensor", ".", "shape", "[", "-", "2", ":", "]", "\n", "new_targets", "=", "[", "]", "\n", "for", "targets_per_image", "in", "targets", ":", "\n", "# pad gt", "\n", "            ", "gt_masks", "=", "targets_per_image", ".", "gt_masks", "\n", "padded_masks", "=", "torch", ".", "zeros", "(", "(", "gt_masks", ".", "shape", "[", "0", "]", ",", "h_pad", ",", "w_pad", ")", ",", "dtype", "=", "gt_masks", ".", "dtype", ",", "device", "=", "gt_masks", ".", "device", ")", "\n", "padded_masks", "[", ":", ",", ":", "gt_masks", ".", "shape", "[", "1", "]", ",", ":", "gt_masks", ".", "shape", "[", "2", "]", "]", "=", "gt_masks", "\n", "new_targets", ".", "append", "(", "\n", "{", "\n", "\"labels\"", ":", "targets_per_image", ".", "gt_classes", ",", "\n", "\"masks\"", ":", "padded_masks", ",", "\n", "}", "\n", ")", "\n", "", "return", "new_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.semantic_inference": [[292, 297], ["mask_pred.sigmoid.sigmoid.sigmoid", "torch.einsum", "torch.nn.functional.softmax"], "methods", ["None"], ["", "def", "semantic_inference", "(", "self", ",", "mask_cls", ",", "mask_pred", ")", ":", "\n", "        ", "mask_cls", "=", "F", ".", "softmax", "(", "mask_cls", ",", "dim", "=", "-", "1", ")", "[", "...", ",", ":", "-", "1", "]", "\n", "mask_pred", "=", "mask_pred", ".", "sigmoid", "(", ")", "\n", "semseg", "=", "torch", ".", "einsum", "(", "\"qc,qhw->chw\"", ",", "mask_cls", ",", "mask_pred", ")", "\n", "return", "semseg", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.panoptic_inference": [[298, 355], ["torch.nn.functional.softmax().max", "mask_pred.sigmoid.sigmoid.sigmoid", "torch.zeros", "labels.ne", "cur_scores.view", "cur_prob_masks.argmax", "range", "torch.nn.functional.softmax", "cur_classes[].item", "hcformer_model.HCFormer.metadata.thing_dataset_id_to_contiguous_id.values", "segments_info.append", "mask.sum().item", "int", "stuff_memory_list.keys", "bool", "int", "mask.sum", "int", "int"], "methods", ["None"], ["", "def", "panoptic_inference", "(", "self", ",", "mask_cls", ",", "mask_pred", ")", ":", "\n", "        ", "scores", ",", "labels", "=", "F", ".", "softmax", "(", "mask_cls", ",", "dim", "=", "-", "1", ")", ".", "max", "(", "-", "1", ")", "\n", "mask_pred", "=", "mask_pred", ".", "sigmoid", "(", ")", "\n", "\n", "keep", "=", "labels", ".", "ne", "(", "self", ".", "sem_seg_head", ".", "num_classes", ")", "&", "(", "scores", ">", "self", ".", "object_mask_threshold", ")", "\n", "cur_scores", "=", "scores", "[", "keep", "]", "\n", "cur_classes", "=", "labels", "[", "keep", "]", "\n", "cur_masks", "=", "mask_pred", "[", "keep", "]", "\n", "cur_mask_cls", "=", "mask_cls", "[", "keep", "]", "\n", "cur_mask_cls", "=", "cur_mask_cls", "[", ":", ",", ":", "-", "1", "]", "\n", "\n", "cur_prob_masks", "=", "cur_scores", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", "*", "cur_masks", "\n", "\n", "h", ",", "w", "=", "cur_masks", ".", "shape", "[", "-", "2", ":", "]", "\n", "panoptic_seg", "=", "torch", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "torch", ".", "int32", ",", "device", "=", "cur_masks", ".", "device", ")", "\n", "segments_info", "=", "[", "]", "\n", "\n", "current_segment_id", "=", "0", "\n", "\n", "if", "cur_masks", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "# We didn't detect any mask :(", "\n", "            ", "return", "panoptic_seg", ",", "segments_info", "\n", "", "else", ":", "\n", "# take argmax", "\n", "            ", "cur_mask_ids", "=", "cur_prob_masks", ".", "argmax", "(", "0", ")", "\n", "stuff_memory_list", "=", "{", "}", "\n", "for", "k", "in", "range", "(", "cur_classes", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "pred_class", "=", "cur_classes", "[", "k", "]", ".", "item", "(", ")", "\n", "isthing", "=", "pred_class", "in", "self", ".", "metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", "\n", "mask_area", "=", "(", "cur_mask_ids", "==", "k", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "original_area", "=", "(", "cur_masks", "[", "k", "]", ">=", "0.5", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "mask", "=", "(", "cur_mask_ids", "==", "k", ")", "&", "(", "cur_masks", "[", "k", "]", ">=", "0.5", ")", "\n", "\n", "if", "mask_area", ">", "0", "and", "original_area", ">", "0", "and", "mask", ".", "sum", "(", ")", ".", "item", "(", ")", ">", "0", ":", "\n", "                    ", "if", "mask_area", "/", "original_area", "<", "self", ".", "overlap_threshold", ":", "\n", "                        ", "continue", "\n", "\n", "# merge stuff regions", "\n", "", "if", "not", "isthing", ":", "\n", "                        ", "if", "int", "(", "pred_class", ")", "in", "stuff_memory_list", ".", "keys", "(", ")", ":", "\n", "                            ", "panoptic_seg", "[", "mask", "]", "=", "stuff_memory_list", "[", "int", "(", "pred_class", ")", "]", "\n", "continue", "\n", "", "else", ":", "\n", "                            ", "stuff_memory_list", "[", "int", "(", "pred_class", ")", "]", "=", "current_segment_id", "+", "1", "\n", "\n", "", "", "current_segment_id", "+=", "1", "\n", "panoptic_seg", "[", "mask", "]", "=", "current_segment_id", "\n", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "current_segment_id", ",", "\n", "\"isthing\"", ":", "bool", "(", "isthing", ")", ",", "\n", "\"category_id\"", ":", "int", "(", "pred_class", ")", ",", "\n", "}", "\n", ")", "\n", "\n", "", "", "return", "panoptic_seg", ",", "segments_info", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.hcformer.hcformer_model.HCFormer.instance_inference": [[356, 393], ["torch.arange().unsqueeze().repeat().flatten", "scores.flatten().topk", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.nn.functional.softmax", "torch.zeros_like().bool", "enumerate", "torch.zeros", "torch.arange().unsqueeze().repeat", "scores.flatten", "mask_pred.size", "detectron2.structures.Instances.pred_masks.flatten().sum", "torch.zeros_like", "hcformer_model.HCFormer.metadata.thing_dataset_id_to_contiguous_id.values", "torch.arange().unsqueeze", "mask_pred.sigmoid().flatten", "detectron2.structures.Instances.pred_masks.flatten", "detectron2.structures.Instances.pred_masks.flatten", "torch.arange", "mask_pred.sigmoid"], "methods", ["None"], ["", "", "def", "instance_inference", "(", "self", ",", "mask_cls", ",", "mask_pred", ")", ":", "\n", "# mask_pred is already processed to have the same shape as original input", "\n", "        ", "image_size", "=", "mask_pred", ".", "shape", "[", "-", "2", ":", "]", "\n", "\n", "# [Q, K]", "\n", "scores", "=", "F", ".", "softmax", "(", "mask_cls", ",", "dim", "=", "-", "1", ")", "[", ":", ",", ":", "-", "1", "]", "\n", "labels", "=", "torch", ".", "arange", "(", "self", ".", "sem_seg_head", ".", "num_classes", ",", "device", "=", "self", ".", "device", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "self", ".", "num_queries", ",", "1", ")", ".", "flatten", "(", "0", ",", "1", ")", "\n", "# scores_per_image, topk_indices = scores.flatten(0, 1).topk(self.num_queries, sorted=False)", "\n", "scores_per_image", ",", "topk_indices", "=", "scores", ".", "flatten", "(", "0", ",", "1", ")", ".", "topk", "(", "self", ".", "test_topk_per_image", ",", "sorted", "=", "False", ")", "\n", "labels_per_image", "=", "labels", "[", "topk_indices", "]", "\n", "\n", "topk_indices", "=", "topk_indices", "//", "self", ".", "sem_seg_head", ".", "num_classes", "\n", "# mask_pred = mask_pred.unsqueeze(1).repeat(1, self.sem_seg_head.num_classes, 1).flatten(0, 1)", "\n", "mask_pred", "=", "mask_pred", "[", "topk_indices", "]", "\n", "\n", "# if this is panoptic segmentation, we only keep the \"thing\" classes", "\n", "if", "self", ".", "panoptic_on", ":", "\n", "            ", "keep", "=", "torch", ".", "zeros_like", "(", "scores_per_image", ")", ".", "bool", "(", ")", "\n", "for", "i", ",", "lab", "in", "enumerate", "(", "labels_per_image", ")", ":", "\n", "                ", "keep", "[", "i", "]", "=", "lab", "in", "self", ".", "metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", "\n", "\n", "", "scores_per_image", "=", "scores_per_image", "[", "keep", "]", "\n", "labels_per_image", "=", "labels_per_image", "[", "keep", "]", "\n", "mask_pred", "=", "mask_pred", "[", "keep", "]", "\n", "\n", "", "result", "=", "Instances", "(", "image_size", ")", "\n", "# mask (before sigmoid)", "\n", "result", ".", "pred_masks", "=", "(", "mask_pred", ">", "0", ")", ".", "float", "(", ")", "\n", "result", ".", "pred_boxes", "=", "Boxes", "(", "torch", ".", "zeros", "(", "mask_pred", ".", "size", "(", "0", ")", ",", "4", ")", ")", "\n", "# Uncomment the following to get boxes from masks (this is slow)", "\n", "# result.pred_boxes = BitMasks(mask_pred > 0).get_bounding_boxes()", "\n", "\n", "# calculate average mask prob", "\n", "mask_scores_per_image", "=", "(", "mask_pred", ".", "sigmoid", "(", ")", ".", "flatten", "(", "1", ")", "*", "result", ".", "pred_masks", ".", "flatten", "(", "1", ")", ")", ".", "sum", "(", "1", ")", "/", "(", "result", ".", "pred_masks", ".", "flatten", "(", "1", ")", ".", "sum", "(", "1", ")", "+", "1e-6", ")", "\n", "result", ".", "scores", "=", "scores_per_image", "*", "mask_scores_per_image", "\n", "result", ".", "pred_classes", "=", "labels_per_image", "\n", "return", "result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.__init__": [[26, 29], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "tensors", ",", "mask", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "self", ".", "tensors", "=", "tensors", "\n", "self", ".", "mask", "=", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to": [[30, 40], ["misc.NestedTensor.tensors.to", "misc.NestedTensor", "mask.to"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "# type: (Device) -> NestedTensor # noqa", "\n", "        ", "cast_tensor", "=", "self", ".", "tensors", ".", "to", "(", "device", ")", "\n", "mask", "=", "self", ".", "mask", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "assert", "mask", "is", "not", "None", "\n", "cast_mask", "=", "mask", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "            ", "cast_mask", "=", "None", "\n", "", "return", "NestedTensor", "(", "cast_tensor", ",", "cast_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.decompose": [[41, 43], ["None"], "methods", ["None"], ["", "def", "decompose", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tensors", ",", "self", ".", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.__repr__": [[44, 46], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "tensors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc._max_by_axis": [[16, 23], ["enumerate", "max"], "function", ["None"], ["def", "_max_by_axis", "(", "the_list", ")", ":", "\n", "# type: (List[List[int]]) -> List[int]", "\n", "    ", "maxes", "=", "the_list", "[", "0", "]", "\n", "for", "sublist", "in", "the_list", "[", "1", ":", "]", ":", "\n", "        ", "for", "index", ",", "item", "in", "enumerate", "(", "sublist", ")", ":", "\n", "            ", "maxes", "[", "index", "]", "=", "max", "(", "maxes", "[", "index", "]", ",", "item", ")", "\n", "", "", "return", "maxes", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.nested_tensor_from_tensor_list": [[48, 71], ["misc.NestedTensor", "torchvision._is_tracing", "misc._max_by_axis", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "zip", "ValueError", "misc._onnx_nested_tensor_from_tensor_list", "pad_img[].copy_", "list", "len"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc._max_by_axis", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc._onnx_nested_tensor_from_tensor_list"], ["", "", "def", "nested_tensor_from_tensor_list", "(", "tensor_list", ":", "List", "[", "Tensor", "]", ")", ":", "\n", "# TODO make this more general", "\n", "    ", "if", "tensor_list", "[", "0", "]", ".", "ndim", "==", "3", ":", "\n", "        ", "if", "torchvision", ".", "_is_tracing", "(", ")", ":", "\n", "# nested_tensor_from_tensor_list() does not export well to ONNX", "\n", "# call _onnx_nested_tensor_from_tensor_list() instead", "\n", "            ", "return", "_onnx_nested_tensor_from_tensor_list", "(", "tensor_list", ")", "\n", "\n", "# TODO make it support different-sized images", "\n", "", "max_size", "=", "_max_by_axis", "(", "[", "list", "(", "img", ".", "shape", ")", "for", "img", "in", "tensor_list", "]", ")", "\n", "# min_size = tuple(min(s) for s in zip(*[img.shape for img in tensor_list]))", "\n", "batch_shape", "=", "[", "len", "(", "tensor_list", ")", "]", "+", "max_size", "\n", "b", ",", "c", ",", "h", ",", "w", "=", "batch_shape", "\n", "dtype", "=", "tensor_list", "[", "0", "]", ".", "dtype", "\n", "device", "=", "tensor_list", "[", "0", "]", ".", "device", "\n", "tensor", "=", "torch", ".", "zeros", "(", "batch_shape", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "mask", "=", "torch", ".", "ones", "(", "(", "b", ",", "h", ",", "w", ")", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "for", "img", ",", "pad_img", ",", "m", "in", "zip", "(", "tensor_list", ",", "tensor", ",", "mask", ")", ":", "\n", "            ", "pad_img", "[", ":", "img", ".", "shape", "[", "0", "]", ",", ":", "img", ".", "shape", "[", "1", "]", ",", ":", "img", ".", "shape", "[", "2", "]", "]", ".", "copy_", "(", "img", ")", "\n", "m", "[", ":", "img", ".", "shape", "[", "1", "]", ",", ":", "img", ".", "shape", "[", "2", "]", "]", "=", "False", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"not supported\"", ")", "\n", "", "return", "NestedTensor", "(", "tensor", ",", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc._onnx_nested_tensor_from_tensor_list": [[75, 104], ["range", "tuple", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "misc.NestedTensor", "tensor_list[].dim", "torch.max().to", "torch.max().to", "tuple.append", "torch.nn.functional.pad", "torch.nn.functional.pad", "padded_imgs.append", "torch.zeros_like", "torch.zeros_like", "torch.nn.functional.pad", "torch.nn.functional.pad", "padded_masks.append", "torch.nn.functional.pad.to", "torch.max", "torch.max", "zip", "torch.stack().to", "torch.stack().to", "tuple", "torch.stack", "torch.stack"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "_onnx_nested_tensor_from_tensor_list", "(", "tensor_list", ":", "List", "[", "Tensor", "]", ")", "->", "NestedTensor", ":", "\n", "    ", "max_size", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "tensor_list", "[", "0", "]", ".", "dim", "(", ")", ")", ":", "\n", "        ", "max_size_i", "=", "torch", ".", "max", "(", "\n", "torch", ".", "stack", "(", "[", "img", ".", "shape", "[", "i", "]", "for", "img", "in", "tensor_list", "]", ")", ".", "to", "(", "torch", ".", "float32", ")", "\n", ")", ".", "to", "(", "torch", ".", "int64", ")", "\n", "max_size", ".", "append", "(", "max_size_i", ")", "\n", "", "max_size", "=", "tuple", "(", "max_size", ")", "\n", "\n", "# work around for", "\n", "# pad_img[: img.shape[0], : img.shape[1], : img.shape[2]].copy_(img)", "\n", "# m[: img.shape[1], :img.shape[2]] = False", "\n", "# which is not yet supported in onnx", "\n", "padded_imgs", "=", "[", "]", "\n", "padded_masks", "=", "[", "]", "\n", "for", "img", "in", "tensor_list", ":", "\n", "        ", "padding", "=", "[", "(", "s1", "-", "s2", ")", "for", "s1", ",", "s2", "in", "zip", "(", "max_size", ",", "tuple", "(", "img", ".", "shape", ")", ")", "]", "\n", "padded_img", "=", "torch", ".", "nn", ".", "functional", ".", "pad", "(", "img", ",", "(", "0", ",", "padding", "[", "2", "]", ",", "0", ",", "padding", "[", "1", "]", ",", "0", ",", "padding", "[", "0", "]", ")", ")", "\n", "padded_imgs", ".", "append", "(", "padded_img", ")", "\n", "\n", "m", "=", "torch", ".", "zeros_like", "(", "img", "[", "0", "]", ",", "dtype", "=", "torch", ".", "int", ",", "device", "=", "img", ".", "device", ")", "\n", "padded_mask", "=", "torch", ".", "nn", ".", "functional", ".", "pad", "(", "m", ",", "(", "0", ",", "padding", "[", "2", "]", ",", "0", ",", "padding", "[", "1", "]", ")", ",", "\"constant\"", ",", "1", ")", "\n", "padded_masks", ".", "append", "(", "padded_mask", ".", "to", "(", "torch", ".", "bool", ")", ")", "\n", "\n", "", "tensor", "=", "torch", ".", "stack", "(", "padded_imgs", ")", "\n", "mask", "=", "torch", ".", "stack", "(", "padded_masks", ")", "\n", "\n", "return", "NestedTensor", "(", "tensor", ",", "mask", "=", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.is_dist_avail_and_initialized": [[106, 112], ["torch.is_available", "torch.is_initialized"], "function", ["None"], ["", "def", "is_dist_avail_and_initialized", "(", ")", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "False", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "False", "\n", "", "return", "True", "\n", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.HungarianMatcher.__init__": [[78, 94], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "self", ",", "cost_class", ":", "float", "=", "1", ",", "cost_mask", ":", "float", "=", "1", ",", "cost_dice", ":", "float", "=", "1", ",", "num_points", ":", "int", "=", "0", ")", ":", "\n", "        ", "\"\"\"Creates the matcher\n\n        Params:\n            cost_class: This is the relative weight of the classification error in the matching cost\n            cost_mask: This is the relative weight of the focal loss of the binary mask in the matching cost\n            cost_dice: This is the relative weight of the dice loss of the binary mask in the matching cost\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cost_class", "=", "cost_class", "\n", "self", ".", "cost_mask", "=", "cost_mask", "\n", "self", ".", "cost_dice", "=", "cost_dice", "\n", "\n", "assert", "cost_class", "!=", "0", "or", "cost_mask", "!=", "0", "or", "cost_dice", "!=", "0", ",", "\"all costs cant be 0\"", "\n", "\n", "self", ".", "num_points", "=", "num_points", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.HungarianMatcher.memory_efficient_forward": [[95, 158], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "range", "[].softmax", "[].to", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "detectron2.projects.point_rend.point_features.point_sample().squeeze", "detectron2.projects.point_rend.point_features.point_sample().squeeze", "C.reshape().cpu.reshape().cpu.reshape().cpu", "indices.append", "torch.cuda.amp.autocast", "torch.cuda.amp.autocast", "out_mask.float.float.float", "tgt_mask.float.float.float", "matcher.batch_sigmoid_ce_loss", "matcher.batch_dice_loss", "scipy.optimize.linear_sum_assignment", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "detectron2.projects.point_rend.point_features.point_sample", "detectron2.projects.point_rend.point_features.point_sample", "C.reshape().cpu.reshape().cpu.reshape", "torch.rand.repeat", "torch.rand.repeat", "torch.rand.repeat", "torch.rand.repeat"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.batch_sigmoid_ce_loss", "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.batch_dice_loss"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "memory_efficient_forward", "(", "self", ",", "outputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"More memory-friendly matching\"\"\"", "\n", "bs", ",", "num_queries", "=", "outputs", "[", "\"pred_logits\"", "]", ".", "shape", "[", ":", "2", "]", "\n", "\n", "indices", "=", "[", "]", "\n", "\n", "# Iterate through batch size", "\n", "for", "b", "in", "range", "(", "bs", ")", ":", "\n", "\n", "            ", "out_prob", "=", "outputs", "[", "\"pred_logits\"", "]", "[", "b", "]", ".", "softmax", "(", "-", "1", ")", "# [num_queries, num_classes]", "\n", "tgt_ids", "=", "targets", "[", "b", "]", "[", "\"labels\"", "]", "\n", "\n", "# Compute the classification cost. Contrary to the loss, we don't use the NLL,", "\n", "# but approximate it in 1 - proba[target class].", "\n", "# The 1 is a constant that doesn't change the matching, it can be ommitted.", "\n", "cost_class", "=", "-", "out_prob", "[", ":", ",", "tgt_ids", "]", "\n", "\n", "out_mask", "=", "outputs", "[", "\"pred_masks\"", "]", "[", "b", "]", "# [num_queries, H_pred, W_pred]", "\n", "# gt masks are already padded when preparing target", "\n", "tgt_mask", "=", "targets", "[", "b", "]", "[", "\"masks\"", "]", ".", "to", "(", "out_mask", ")", "\n", "\n", "out_mask", "=", "out_mask", "[", ":", ",", "None", "]", "\n", "tgt_mask", "=", "tgt_mask", "[", ":", ",", "None", "]", "\n", "# all masks share the same set of points for efficient matching!", "\n", "point_coords", "=", "torch", ".", "rand", "(", "1", ",", "self", ".", "num_points", ",", "2", ",", "device", "=", "out_mask", ".", "device", ")", "\n", "# get gt labels", "\n", "tgt_mask", "=", "point_sample", "(", "\n", "tgt_mask", ",", "\n", "point_coords", ".", "repeat", "(", "tgt_mask", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ")", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "out_mask", "=", "point_sample", "(", "\n", "out_mask", ",", "\n", "point_coords", ".", "repeat", "(", "out_mask", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ")", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "with", "autocast", "(", "enabled", "=", "False", ")", ":", "\n", "                ", "out_mask", "=", "out_mask", ".", "float", "(", ")", "\n", "tgt_mask", "=", "tgt_mask", ".", "float", "(", ")", "\n", "# Compute the focal loss between masks", "\n", "# cost_mask = batch_sigmoid_ce_loss_jit(out_mask, tgt_mask)", "\n", "cost_mask", "=", "batch_sigmoid_ce_loss", "(", "out_mask", ",", "tgt_mask", ")", "\n", "\n", "# Compute the dice loss betwen masks", "\n", "# cost_dice = batch_dice_loss_jit(out_mask, tgt_mask)", "\n", "cost_dice", "=", "batch_dice_loss", "(", "out_mask", ",", "tgt_mask", ")", "\n", "\n", "# Final cost matrix", "\n", "", "C", "=", "(", "\n", "self", ".", "cost_mask", "*", "cost_mask", "\n", "+", "self", ".", "cost_class", "*", "cost_class", "\n", "+", "self", ".", "cost_dice", "*", "cost_dice", "\n", ")", "\n", "C", "=", "C", ".", "reshape", "(", "num_queries", ",", "-", "1", ")", ".", "cpu", "(", ")", "\n", "\n", "indices", ".", "append", "(", "linear_sum_assignment", "(", "C", ")", ")", "\n", "\n", "", "return", "[", "\n", "(", "torch", ".", "as_tensor", "(", "i", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "torch", ".", "as_tensor", "(", "j", ",", "dtype", "=", "torch", ".", "int64", ")", ")", "\n", "for", "i", ",", "j", "in", "indices", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.HungarianMatcher.forward": [[160, 182], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "matcher.HungarianMatcher.memory_efficient_forward"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.HungarianMatcher.memory_efficient_forward"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "forward", "(", "self", ",", "outputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"Performs the matching\n\n        Params:\n            outputs: This is a dict that contains at least these entries:\n                 \"pred_logits\": Tensor of dim [batch_size, num_queries, num_classes] with the classification logits\n                 \"pred_masks\": Tensor of dim [batch_size, num_queries, H_pred, W_pred] with the predicted masks\n\n            targets: This is a list of targets (len(targets) = batch_size), where each target is a dict containing:\n                 \"labels\": Tensor of dim [num_target_boxes] (where num_target_boxes is the number of ground-truth\n                           objects in the target) containing the class labels\n                 \"masks\": Tensor of dim [num_target_boxes, H_gt, W_gt] containing the target masks\n\n        Returns:\n            A list of size batch_size, containing tuples of (index_i, index_j) where:\n                - index_i is the indices of the selected predictions (in order)\n                - index_j is the indices of the corresponding selected targets (in order)\n            For each batch element, it holds:\n                len(index_i) = len(index_j) = min(num_queries, num_target_boxes)\n        \"\"\"", "\n", "return", "self", ".", "memory_efficient_forward", "(", "outputs", ",", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.HungarianMatcher.__repr__": [[183, 192], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ",", "_repr_indent", "=", "4", ")", ":", "\n", "        ", "head", "=", "\"Matcher \"", "+", "self", ".", "__class__", ".", "__name__", "\n", "body", "=", "[", "\n", "\"cost_class: {}\"", ".", "format", "(", "self", ".", "cost_class", ")", ",", "\n", "\"cost_mask: {}\"", ".", "format", "(", "self", ".", "cost_mask", ")", ",", "\n", "\"cost_dice: {}\"", ".", "format", "(", "self", ".", "cost_dice", ")", ",", "\n", "]", "\n", "lines", "=", "[", "head", "]", "+", "[", "\" \"", "*", "_repr_indent", "+", "line", "for", "line", "in", "body", "]", "\n", "return", "\"\\n\"", ".", "join", "(", "lines", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.batch_dice_loss": [[15, 31], ["inputs.flatten.sigmoid", "inputs.flatten.flatten", "torch.einsum", "torch.einsum", "inputs.flatten.sum", "targets.sum"], "function", ["None"], ["def", "batch_dice_loss", "(", "inputs", ":", "torch", ".", "Tensor", ",", "targets", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "\"\"\"\n    Compute the DICE loss, similar to generalized IOU for masks\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    \"\"\"", "\n", "inputs", "=", "inputs", ".", "sigmoid", "(", ")", "\n", "inputs", "=", "inputs", ".", "flatten", "(", "1", ")", "\n", "numerator", "=", "2", "*", "torch", ".", "einsum", "(", "\"nc,mc->nm\"", ",", "inputs", ",", "targets", ")", "\n", "denominator", "=", "inputs", ".", "sum", "(", "-", "1", ")", "[", ":", ",", "None", "]", "+", "targets", ".", "sum", "(", "-", "1", ")", "[", "None", ",", ":", "]", "\n", "loss", "=", "1", "-", "(", "numerator", "+", "1", ")", "/", "(", "denominator", "+", "1", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.matcher.batch_sigmoid_ce_loss": [[38, 63], ["torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.ones_like", "torch.ones_like", "torch.zeros_like", "torch.zeros_like", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum"], "function", ["None"], ["def", "batch_sigmoid_ce_loss", "(", "inputs", ":", "torch", ".", "Tensor", ",", "targets", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    Returns:\n        Loss tensor\n    \"\"\"", "\n", "hw", "=", "inputs", ".", "shape", "[", "1", "]", "\n", "\n", "pos", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "inputs", ",", "torch", ".", "ones_like", "(", "inputs", ")", ",", "reduction", "=", "\"none\"", "\n", ")", "\n", "neg", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "inputs", ",", "torch", ".", "zeros_like", "(", "inputs", ")", ",", "reduction", "=", "\"none\"", "\n", ")", "\n", "\n", "loss", "=", "torch", ".", "einsum", "(", "\"nc,mc->nm\"", ",", "pos", ",", "targets", ")", "+", "torch", ".", "einsum", "(", "\n", "\"nc,mc->nm\"", ",", "neg", ",", "(", "1", "-", "targets", ")", "\n", ")", "\n", "\n", "return", "loss", "/", "hw", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion.__init__": [[98, 122], ["torch.nn.Module.__init__", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "criterion.SetCriterion.register_buffer"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "matcher", ",", "weight_dict", ",", "eos_coef", ",", "losses", ",", "\n", "num_points", ",", "oversample_ratio", ",", "importance_sample_ratio", ")", ":", "\n", "        ", "\"\"\"Create the criterion.\n        Parameters:\n            num_classes: number of object categories, omitting the special no-object category\n            matcher: module able to compute a matching between targets and proposals\n            weight_dict: dict containing as key the names of the losses and as values their relative weight.\n            eos_coef: relative classification weight applied to the no-object category\n            losses: list of all the losses to be applied. See get_loss for list of available losses.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "matcher", "=", "matcher", "\n", "self", ".", "weight_dict", "=", "weight_dict", "\n", "self", ".", "eos_coef", "=", "eos_coef", "\n", "self", ".", "losses", "=", "losses", "\n", "empty_weight", "=", "torch", ".", "ones", "(", "self", ".", "num_classes", "+", "1", ")", "\n", "empty_weight", "[", "-", "1", "]", "=", "self", ".", "eos_coef", "\n", "self", ".", "register_buffer", "(", "\"empty_weight\"", ",", "empty_weight", ")", "\n", "\n", "# pointwise mask loss parameters", "\n", "self", ".", "num_points", "=", "num_points", "\n", "self", ".", "oversample_ratio", "=", "oversample_ratio", "\n", "self", ".", "importance_sample_ratio", "=", "importance_sample_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion.loss_labels": [[123, 140], ["outputs[].float", "criterion.SetCriterion._get_src_permutation_idx", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full", "torch.full", "torch.full", "torch.full", "torch.cross_entropy", "torch.cross_entropy", "outputs[].float.transpose", "zip"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion._get_src_permutation_idx"], ["", "def", "loss_labels", "(", "self", ",", "outputs", ",", "targets", ",", "indices", ",", "num_masks", ")", ":", "\n", "        ", "\"\"\"Classification loss (NLL)\n        targets dicts must contain the key \"labels\" containing a tensor of dim [nb_target_boxes]\n        \"\"\"", "\n", "assert", "\"pred_logits\"", "in", "outputs", "\n", "src_logits", "=", "outputs", "[", "\"pred_logits\"", "]", ".", "float", "(", ")", "\n", "\n", "idx", "=", "self", ".", "_get_src_permutation_idx", "(", "indices", ")", "\n", "target_classes_o", "=", "torch", ".", "cat", "(", "[", "t", "[", "\"labels\"", "]", "[", "J", "]", "for", "t", ",", "(", "_", ",", "J", ")", "in", "zip", "(", "targets", ",", "indices", ")", "]", ")", "\n", "target_classes", "=", "torch", ".", "full", "(", "\n", "src_logits", ".", "shape", "[", ":", "2", "]", ",", "self", ".", "num_classes", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "src_logits", ".", "device", "\n", ")", "\n", "target_classes", "[", "idx", "]", "=", "target_classes_o", "\n", "\n", "loss_ce", "=", "F", ".", "cross_entropy", "(", "src_logits", ".", "transpose", "(", "1", ",", "2", ")", ",", "target_classes", ",", "self", ".", "empty_weight", ")", "\n", "losses", "=", "{", "\"loss_ce\"", ":", "loss_ce", "}", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion.loss_masks": [[141, 192], ["criterion.SetCriterion._get_src_permutation_idx", "criterion.SetCriterion._get_tgt_permutation_idx", "utils.misc.nested_tensor_from_tensor_list().decompose", "target_masks.to.to.to", "detectron2.projects.point_rend.point_features.point_sample().squeeze", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "detectron2.projects.point_rend.point_features.get_uncertain_point_coords_with_randomness", "detectron2.projects.point_rend.point_features.point_sample().squeeze", "sigmoid_ce_loss_jit", "dice_loss_jit", "utils.misc.nested_tensor_from_tensor_list", "detectron2.projects.point_rend.point_features.point_sample", "criterion.calculate_uncertainty", "detectron2.projects.point_rend.point_features.point_sample"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion._get_src_permutation_idx", "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion._get_tgt_permutation_idx", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.decompose", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.nested_tensor_from_tensor_list", "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.calculate_uncertainty"], ["", "def", "loss_masks", "(", "self", ",", "outputs", ",", "targets", ",", "indices", ",", "num_masks", ")", ":", "\n", "        ", "\"\"\"Compute the losses related to the masks: the focal loss and the dice loss.\n        targets dicts must contain the key \"masks\" containing a tensor of dim [nb_target_boxes, h, w]\n        \"\"\"", "\n", "assert", "\"pred_masks\"", "in", "outputs", "\n", "\n", "src_idx", "=", "self", ".", "_get_src_permutation_idx", "(", "indices", ")", "\n", "tgt_idx", "=", "self", ".", "_get_tgt_permutation_idx", "(", "indices", ")", "\n", "src_masks", "=", "outputs", "[", "\"pred_masks\"", "]", "\n", "src_masks", "=", "src_masks", "[", "src_idx", "]", "\n", "masks", "=", "[", "t", "[", "\"masks\"", "]", "for", "t", "in", "targets", "]", "\n", "# TODO use valid to mask invalid areas due to padding in loss", "\n", "target_masks", ",", "valid", "=", "nested_tensor_from_tensor_list", "(", "masks", ")", ".", "decompose", "(", ")", "\n", "target_masks", "=", "target_masks", ".", "to", "(", "src_masks", ")", "\n", "target_masks", "=", "target_masks", "[", "tgt_idx", "]", "\n", "\n", "# No need to upsample predictions as we are using normalized coordinates :)", "\n", "# N x 1 x H x W", "\n", "src_masks", "=", "src_masks", "[", ":", ",", "None", "]", "\n", "target_masks", "=", "target_masks", "[", ":", ",", "None", "]", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# sample point_coords", "\n", "            ", "point_coords", "=", "get_uncertain_point_coords_with_randomness", "(", "\n", "src_masks", ",", "\n", "lambda", "logits", ":", "calculate_uncertainty", "(", "logits", ")", ",", "\n", "self", ".", "num_points", ",", "\n", "self", ".", "oversample_ratio", ",", "\n", "self", ".", "importance_sample_ratio", ",", "\n", ")", "\n", "# get gt labels", "\n", "point_labels", "=", "point_sample", "(", "\n", "target_masks", ",", "\n", "point_coords", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "", "point_logits", "=", "point_sample", "(", "\n", "src_masks", ",", "\n", "point_coords", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "losses", "=", "{", "\n", "\"loss_mask\"", ":", "sigmoid_ce_loss_jit", "(", "point_logits", ",", "point_labels", ",", "num_masks", ")", ",", "\n", "\"loss_dice\"", ":", "dice_loss_jit", "(", "point_logits", ",", "point_labels", ",", "num_masks", ")", ",", "\n", "}", "\n", "\n", "del", "src_masks", "\n", "del", "target_masks", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion._get_src_permutation_idx": [[193, 198], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "enumerate"], "methods", ["None"], ["", "def", "_get_src_permutation_idx", "(", "self", ",", "indices", ")", ":", "\n", "# permute predictions following indices", "\n", "        ", "batch_idx", "=", "torch", ".", "cat", "(", "[", "torch", ".", "full_like", "(", "src", ",", "i", ")", "for", "i", ",", "(", "src", ",", "_", ")", "in", "enumerate", "(", "indices", ")", "]", ")", "\n", "src_idx", "=", "torch", ".", "cat", "(", "[", "src", "for", "(", "src", ",", "_", ")", "in", "indices", "]", ")", "\n", "return", "batch_idx", ",", "src_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion._get_tgt_permutation_idx": [[199, 204], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "enumerate"], "methods", ["None"], ["", "def", "_get_tgt_permutation_idx", "(", "self", ",", "indices", ")", ":", "\n", "# permute targets following indices", "\n", "        ", "batch_idx", "=", "torch", ".", "cat", "(", "[", "torch", ".", "full_like", "(", "tgt", ",", "i", ")", "for", "i", ",", "(", "_", ",", "tgt", ")", "in", "enumerate", "(", "indices", ")", "]", ")", "\n", "tgt_idx", "=", "torch", ".", "cat", "(", "[", "tgt", "for", "(", "_", ",", "tgt", ")", "in", "indices", "]", ")", "\n", "return", "batch_idx", ",", "tgt_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion.get_loss": [[205, 212], ["None"], "methods", ["None"], ["", "def", "get_loss", "(", "self", ",", "loss", ",", "outputs", ",", "targets", ",", "indices", ",", "num_masks", ")", ":", "\n", "        ", "loss_map", "=", "{", "\n", "'labels'", ":", "self", ".", "loss_labels", ",", "\n", "'masks'", ":", "self", ".", "loss_masks", ",", "\n", "}", "\n", "assert", "loss", "in", "loss_map", ",", "f\"do you really want to compute {loss} loss?\"", "\n", "return", "loss_map", "[", "loss", "]", "(", "outputs", ",", "targets", ",", "indices", ",", "num_masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion.forward": [[213, 253], ["criterion.SetCriterion.matcher", "sum", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "utils.misc.is_dist_avail_and_initialized", "torch.clamp().item", "torch.clamp().item", "torch.clamp().item", "torch.clamp().item", "torch.distributed.all_reduce", "torch.distributed.all_reduce", "torch.distributed.all_reduce", "torch.distributed.all_reduce", "losses.update", "enumerate", "losses.update", "outputs.items", "len", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "criterion.SetCriterion.get_loss", "criterion.SetCriterion.matcher", "next", "criterion.SetCriterion.get_loss", "losses.update", "iter", "detectron2.utils.comm.get_world_size", "outputs.values", "criterion.SetCriterion.items"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.is_dist_avail_and_initialized", "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion.get_loss", "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion.get_loss"], ["", "def", "forward", "(", "self", ",", "outputs", ",", "targets", ",", "temperature", "=", "None", ")", ":", "\n", "        ", "\"\"\"This performs the loss computation.\n        Parameters:\n             outputs: dict of tensors, see the output specification of the model for the format\n             targets: list of dicts, such that len(targets) == batch_size.\n                      The expected keys in each dict depends on the losses applied, see each loss' doc\n        \"\"\"", "\n", "outputs_without_aux", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "outputs", ".", "items", "(", ")", "if", "k", "!=", "\"aux_outputs\"", "}", "\n", "\n", "# Retrieve the matching between the outputs of the last layer and the targets", "\n", "indices", "=", "self", ".", "matcher", "(", "outputs_without_aux", ",", "targets", ")", "\n", "\n", "# Compute the average number of target boxes accross all nodes, for normalization purposes", "\n", "num_masks", "=", "sum", "(", "len", "(", "t", "[", "\"labels\"", "]", ")", "for", "t", "in", "targets", ")", "\n", "num_masks", "=", "torch", ".", "as_tensor", "(", "\n", "[", "num_masks", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "next", "(", "iter", "(", "outputs", ".", "values", "(", ")", ")", ")", ".", "device", "\n", ")", "\n", "if", "is_dist_avail_and_initialized", "(", ")", ":", "\n", "            ", "torch", ".", "distributed", ".", "all_reduce", "(", "num_masks", ")", "\n", "", "num_masks", "=", "torch", ".", "clamp", "(", "num_masks", "/", "get_world_size", "(", ")", ",", "min", "=", "1", ")", ".", "item", "(", ")", "\n", "\n", "# Compute all the requested losses", "\n", "losses", "=", "{", "}", "\n", "for", "loss", "in", "self", ".", "losses", ":", "\n", "            ", "losses", ".", "update", "(", "self", ".", "get_loss", "(", "loss", ",", "outputs", ",", "targets", ",", "indices", ",", "num_masks", ")", ")", "\n", "\n", "# In case of auxiliary losses, we repeat this process with the output of each intermediate layer.", "\n", "", "if", "\"aux_outputs\"", "in", "outputs", ":", "\n", "            ", "for", "i", ",", "aux_outputs", "in", "enumerate", "(", "outputs", "[", "\"aux_outputs\"", "]", ")", ":", "\n", "                ", "indices", "=", "self", ".", "matcher", "(", "aux_outputs", ",", "targets", ")", "\n", "for", "loss", "in", "self", ".", "losses", ":", "\n", "                    ", "l_dict", "=", "self", ".", "get_loss", "(", "loss", ",", "aux_outputs", ",", "targets", ",", "indices", ",", "num_masks", ")", "\n", "l_dict", "=", "{", "k", "+", "f\"_{i}\"", ":", "v", "for", "k", ",", "v", "in", "l_dict", ".", "items", "(", ")", "}", "\n", "losses", ".", "update", "(", "l_dict", ")", "\n", "\n", "", "", "", "if", "temperature", "is", "not", "None", ":", "\n", "            ", "l_dict", "=", "{", "'loss_l1'", ":", "temperature", "}", "\n", "losses", ".", "update", "(", "l_dict", ")", "\n", "\n", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.SetCriterion.__repr__": [[254, 269], ["criterion.SetCriterion.matcher.__repr__"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.position_encoding.PositionEmbeddingSine.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "head", "=", "\"Criterion \"", "+", "self", ".", "__class__", ".", "__name__", "\n", "body", "=", "[", "\n", "\"matcher: {}\"", ".", "format", "(", "self", ".", "matcher", ".", "__repr__", "(", "_repr_indent", "=", "8", ")", ")", ",", "\n", "\"losses: {}\"", ".", "format", "(", "self", ".", "losses", ")", ",", "\n", "\"weight_dict: {}\"", ".", "format", "(", "self", ".", "weight_dict", ")", ",", "\n", "\"num_classes: {}\"", ".", "format", "(", "self", ".", "num_classes", ")", ",", "\n", "\"eos_coef: {}\"", ".", "format", "(", "self", ".", "eos_coef", ")", ",", "\n", "\"num_points: {}\"", ".", "format", "(", "self", ".", "num_points", ")", ",", "\n", "\"oversample_ratio: {}\"", ".", "format", "(", "self", ".", "oversample_ratio", ")", ",", "\n", "\"importance_sample_ratio: {}\"", ".", "format", "(", "self", ".", "importance_sample_ratio", ")", ",", "\n", "]", "\n", "_repr_indent", "=", "4", "\n", "lines", "=", "[", "head", "]", "+", "[", "\" \"", "*", "_repr_indent", "+", "line", "for", "line", "in", "body", "]", "\n", "return", "\"\\n\"", ".", "join", "(", "lines", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.dice_loss": [[22, 42], ["inputs.flatten.sigmoid", "inputs.flatten.flatten", "inputs.flatten.sum", "targets.sum", "loss.sum"], "function", ["None"], ["def", "dice_loss", "(", "\n", "inputs", ":", "torch", ".", "Tensor", ",", "\n", "targets", ":", "torch", ".", "Tensor", ",", "\n", "num_masks", ":", "float", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Compute the DICE loss, similar to generalized IOU for masks\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    \"\"\"", "\n", "inputs", "=", "inputs", ".", "sigmoid", "(", ")", "\n", "inputs", "=", "inputs", ".", "flatten", "(", "1", ")", "\n", "numerator", "=", "2", "*", "(", "inputs", "*", "targets", ")", ".", "sum", "(", "-", "1", ")", "\n", "denominator", "=", "inputs", ".", "sum", "(", "-", "1", ")", "+", "targets", ".", "sum", "(", "-", "1", ")", "\n", "loss", "=", "1", "-", "(", "numerator", "+", "1", ")", "/", "(", "denominator", "+", "1", ")", "\n", "return", "loss", ".", "sum", "(", ")", "/", "num_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.sigmoid_ce_loss": [[49, 67], ["torch.binary_cross_entropy_with_logits", "F.binary_cross_entropy_with_logits.mean().sum", "F.binary_cross_entropy_with_logits.mean"], "function", ["None"], ["def", "sigmoid_ce_loss", "(", "\n", "inputs", ":", "torch", ".", "Tensor", ",", "\n", "targets", ":", "torch", ".", "Tensor", ",", "\n", "num_masks", ":", "float", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n    Returns:\n        Loss tensor\n    \"\"\"", "\n", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "inputs", ",", "targets", ",", "reduction", "=", "\"none\"", ")", "\n", "\n", "return", "loss", ".", "mean", "(", "1", ")", ".", "sum", "(", ")", "/", "num_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.modeling.criterion.calculate_uncertainty": [[74, 89], ["logits.clone", "torch.abs", "torch.abs"], "function", ["None"], ["def", "calculate_uncertainty", "(", "logits", ")", ":", "\n", "    ", "\"\"\"\n    We estimate uncerainty as L1 distance between 0.0 and the logit prediction in 'logits' for the\n        foreground class in `classes`.\n    Args:\n        logits (Tensor): A tensor of shape (R, 1, ...) for class-specific or\n            class-agnostic, where R is the total number of predicted masks in all images and C is\n            the number of foreground classes. The values are logits.\n    Returns:\n        scores (Tensor): A tensor of shape (R, 1, ...) that contains uncertainty scores with\n            the most uncertain locations having the highest uncertainty score.\n    \"\"\"", "\n", "assert", "logits", ".", "shape", "[", "1", "]", "==", "1", "\n", "gt_class_logits", "=", "logits", ".", "clone", "(", ")", "\n", "return", "-", "(", "torch", ".", "abs", "(", "gt_class_logits", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.meta_arch.hcformer_head.HCFormerHead._load_from_state_dict": [[19, 40], ["local_metadata.get", "logging.getLogger", "list", "state_dict.keys", "logging.getLogger.warning"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["def", "_load_from_state_dict", "(", "\n", "self", ",", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", "\n", ")", ":", "\n", "        ", "version", "=", "local_metadata", ".", "get", "(", "\"version\"", ",", "None", ")", "\n", "if", "version", "is", "None", "or", "version", "<", "2", ":", "\n", "# Do not warn if train from scratch", "\n", "            ", "scratch", "=", "True", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "for", "k", "in", "list", "(", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "                ", "newk", "=", "k", "\n", "# if \"sem_seg_head\" in k and not k.startswith(prefix + \"predictor\"):", "\n", "#     newk = k.replace(prefix, prefix + \"pixel_decoder.\")", "\n", "# logger.debug(f\"{k} ==> {newk}\")", "\n", "if", "newk", "!=", "k", ":", "\n", "                    ", "state_dict", "[", "newk", "]", "=", "state_dict", "[", "k", "]", "\n", "del", "state_dict", "[", "k", "]", "\n", "scratch", "=", "False", "\n", "\n", "", "", "if", "not", "scratch", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "f\"Weight format of {self.__class__.__name__} have changed! \"", "\n", "\"Please upgrade your models. Applying automatic conversion now ...\"", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.meta_arch.hcformer_head.HCFormerHead.__init__": [[43, 82], ["torch.nn.Module.__init__", "sorted", "sorted.items"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["", "", "", "@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ",", "\n", "*", ",", "\n", "num_classes", ":", "int", ",", "\n", "# pixel_decoder: nn.Module,", "\n", "loss_weight", ":", "float", "=", "1.0", ",", "\n", "ignore_value", ":", "int", "=", "-", "1", ",", "\n", "# extra parameters", "\n", "transformer_predictor", ":", "nn", ".", "Module", ",", "\n", "transformer_in_feature", ":", "str", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        Args:\n            input_shape: shapes (channels and stride) of the input features\n            num_classes: number of classes to predict\n            pixel_decoder: the pixel decoder module\n            loss_weight: loss weight\n            ignore_value: category id to be ignored during training.\n            transformer_predictor: the transformer decoder that makes prediction\n            transformer_in_feature: input feature name to the transformer_predictor\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "input_shape", "=", "sorted", "(", "input_shape", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ".", "stride", ")", "\n", "self", ".", "in_features", "=", "[", "k", "for", "k", ",", "v", "in", "input_shape", "]", "\n", "feature_strides", "=", "[", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", "]", "\n", "feature_channels", "=", "[", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", "]", "\n", "\n", "self", ".", "ignore_value", "=", "ignore_value", "\n", "self", ".", "common_stride", "=", "4", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n", "# self.pixel_decoder = pixel_decoder", "\n", "self", ".", "predictor", "=", "transformer_predictor", "\n", "self", ".", "transformer_in_feature", "=", "transformer_in_feature", "\n", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.meta_arch.hcformer_head.HCFormerHead.from_config": [[83, 100], ["transformer_decoder.hcformer_decoder_mf.build_transformer_decoder", "input_shape.items"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.build_transformer_decoder"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "# figure out in_channels to transformer predictor", "\n", "        ", "transformer_predictor_in_channels", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "\n", "\n", "return", "{", "\n", "\"input_shape\"", ":", "{", "\n", "k", ":", "v", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "if", "k", "in", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "\n", "}", ",", "\n", "\"ignore_value\"", ":", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", ",", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", ",", "\n", "\"loss_weight\"", ":", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", ",", "\n", "\"transformer_in_feature\"", ":", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TRANSFORMER_IN_FEATURE", ",", "\n", "\"transformer_predictor\"", ":", "build_transformer_decoder", "(", "\n", "cfg", ",", "\n", "transformer_predictor_in_channels", ",", "\n", "mask_classification", "=", "True", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.meta_arch.hcformer_head.HCFormerHead.forward": [[103, 105], ["hcformer_head.HCFormerHead.layers"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.meta_arch.hcformer_head.HCFormerHead.layers"], ["", "def", "forward", "(", "self", ",", "features", ",", "assigns", ",", "mask", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "layers", "(", "features", ",", "assigns", ",", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.meta_arch.hcformer_head.HCFormerHead.layers": [[106, 110], ["hcformer_head.HCFormerHead.predictor"], "methods", ["None"], ["", "def", "layers", "(", "self", ",", "features", ",", "assigns", ",", "mask", "=", "None", ")", ":", "\n", "# mask_features, transformer_encoder_features, multi_scale_features = self.pixel_decoder.forward_features(features)", "\n", "        ", "predictions", "=", "self", ".", "predictor", "(", "features", ",", "features", ",", "assigns", ",", "mask", ")", "\n", "return", "predictions", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.HCStandardTransformerDecoder.__init__": [[58, 135], ["torch.nn.Module.__init__", "position_encoding.PositionEmbeddingSine", "transformer.Transformer.Transformer", "torch.nn.Embedding", "detectron2.layers.Conv2d", "fvcore.c2_xavier_fill", "hcformer_decoder_mf.MLP", "detectron2.layers.Conv2d", "fvcore.c2_xavier_fill", "torch.nn.Sequential", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "mask_classification", "=", "True", ",", "\n", "*", ",", "\n", "num_classes", ":", "int", ",", "\n", "hidden_dim", ":", "int", ",", "\n", "num_queries", ":", "int", ",", "\n", "nheads", ":", "int", ",", "\n", "dropout", ":", "float", ",", "\n", "dim_feedforward", ":", "int", ",", "\n", "enc_layers", ":", "int", ",", "\n", "dec_layers", ":", "int", ",", "\n", "pre_norm", ":", "bool", ",", "\n", "deep_supervision", ":", "bool", ",", "\n", "mask_dim", ":", "int", ",", "\n", "enforce_input_project", ":", "bool", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        Args:\n            in_channels: channels of the input features\n            mask_classification: whether to add mask classifier or not\n            num_classes: number of classes\n            hidden_dim: Transformer feature dimension\n            num_queries: number of queries\n            nheads: number of heads\n            dropout: dropout in Transformer\n            dim_feedforward: feature dimension in feedforward network\n            enc_layers: number of Transformer encoder layers\n            dec_layers: number of Transformer decoder layers\n            pre_norm: whether to use pre-LayerNorm or not\n            deep_supervision: whether to add supervision to every decoder layers\n            mask_dim: mask feature dimension\n            enforce_input_project: add input project 1x1 conv even if input\n                channels and hidden dim is identical\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mask_classification", "=", "mask_classification", "\n", "\n", "# positional encoding", "\n", "N_steps", "=", "hidden_dim", "//", "2", "\n", "self", ".", "pe_layer", "=", "PositionEmbeddingSine", "(", "N_steps", ",", "normalize", "=", "True", ")", "\n", "\n", "transformer", "=", "Transformer", "(", "\n", "d_model", "=", "hidden_dim", ",", "\n", "dropout", "=", "dropout", ",", "\n", "nhead", "=", "nheads", ",", "\n", "dim_feedforward", "=", "dim_feedforward", ",", "\n", "num_encoder_layers", "=", "enc_layers", ",", "\n", "num_decoder_layers", "=", "dec_layers", ",", "\n", "normalize_before", "=", "pre_norm", ",", "\n", "return_intermediate_dec", "=", "deep_supervision", ",", "\n", ")", "\n", "\n", "self", ".", "num_queries", "=", "num_queries", "\n", "self", ".", "transformer", "=", "transformer", "\n", "hidden_dim", "=", "transformer", ".", "d_model", "\n", "\n", "self", ".", "query_embed", "=", "nn", ".", "Embedding", "(", "num_queries", ",", "hidden_dim", ")", "\n", "\n", "if", "in_channels", "!=", "hidden_dim", "or", "enforce_input_project", ":", "\n", "            ", "self", ".", "input_proj", "=", "Conv2d", "(", "in_channels", ",", "hidden_dim", ",", "kernel_size", "=", "1", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "input_proj", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "input_proj", "=", "nn", ".", "Sequential", "(", ")", "\n", "", "self", ".", "aux_loss", "=", "deep_supervision", "\n", "\n", "self", ".", "mask_proj", "=", "Conv2d", "(", "in_channels", ",", "hidden_dim", ",", "kernel_size", "=", "1", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "mask_proj", ")", "\n", "\n", "# output FFNs", "\n", "if", "self", ".", "mask_classification", ":", "\n", "            ", "self", ".", "class_embed", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "num_classes", "+", "1", ")", "\n", "", "self", ".", "mask_embed", "=", "MLP", "(", "hidden_dim", ",", "hidden_dim", ",", "mask_dim", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.HCStandardTransformerDecoder.from_config": [[136, 158], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "in_channels", ",", "mask_classification", ")", ":", "\n", "        ", "ret", "=", "{", "}", "\n", "ret", "[", "\"in_channels\"", "]", "=", "in_channels", "\n", "ret", "[", "\"mask_classification\"", "]", "=", "mask_classification", "\n", "\n", "ret", "[", "\"num_classes\"", "]", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "\n", "ret", "[", "\"hidden_dim\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "HIDDEN_DIM", "\n", "ret", "[", "\"num_queries\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NUM_OBJECT_QUERIES", "\n", "# Transformer parameters:", "\n", "ret", "[", "\"nheads\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NHEADS", "\n", "ret", "[", "\"dropout\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DROPOUT", "\n", "ret", "[", "\"dim_feedforward\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DIM_FEEDFORWARD", "\n", "ret", "[", "\"enc_layers\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "ENC_LAYERS", "\n", "ret", "[", "\"dec_layers\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DEC_LAYERS", "\n", "ret", "[", "\"pre_norm\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "PRE_NORM", "\n", "ret", "[", "\"deep_supervision\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DEEP_SUPERVISION", "\n", "ret", "[", "\"enforce_input_project\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "ENFORCE_INPUT_PROJ", "\n", "\n", "ret", "[", "\"mask_dim\"", "]", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "MASK_DIM", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.HCStandardTransformerDecoder.forward": [[159, 196], ["hcformer_decoder_mf.HCStandardTransformerDecoder.pe_layer", "hcformer_decoder_mf.HCStandardTransformerDecoder.mask_proj", "hcformer_decoder_mf.HCStandardTransformerDecoder.transformer", "hcformer_decoder_mf.HCStandardTransformerDecoder.input_proj", "hcformer_decoder_mf.HCStandardTransformerDecoder.class_embed", "hcformer_decoder_mf.HCStandardTransformerDecoder.mask_embed", "torch.einsum", "upsampling.reshape", "hcformer_decoder_mf.upsampling", "upsampling.reshape", "hcformer_decoder_mf.HCStandardTransformerDecoder._set_aux_loss", "hcformer_decoder_mf.HCStandardTransformerDecoder.mask_embed", "torch.einsum", "hcformer_decoder_mf.upsampling", "torch.nn.functional.interpolate().to", "torch.nn.functional.interpolate", "mask[].float"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.upsampling", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder._set_aux_loss", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.upsampling", "home.repos.pwc.inspect_result.densoitlab_hcformer.utils.misc.NestedTensor.to"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask_features", ",", "assigns", ",", "mask", "=", "None", ")", ":", "\n", "        ", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "F", ".", "interpolate", "(", "mask", "[", "None", "]", ".", "float", "(", ")", ",", "size", "=", "x", ".", "shape", "[", "-", "2", ":", "]", ")", ".", "to", "(", "torch", ".", "bool", ")", "[", "0", "]", "\n", "", "pos", "=", "self", ".", "pe_layer", "(", "x", ",", "mask", ")", "\n", "\n", "mask_features", "=", "self", ".", "mask_proj", "(", "mask_features", ")", "\n", "\n", "src", "=", "x", "\n", "hs", ",", "memory", "=", "self", ".", "transformer", "(", "self", ".", "input_proj", "(", "src", ")", ",", "mask", ",", "self", ".", "query_embed", ".", "weight", ",", "pos", ")", "\n", "\n", "if", "self", ".", "mask_classification", ":", "\n", "            ", "outputs_class", "=", "self", ".", "class_embed", "(", "hs", ")", "\n", "out", "=", "{", "\"pred_logits\"", ":", "outputs_class", "[", "-", "1", "]", "}", "\n", "", "else", ":", "\n", "            ", "out", "=", "{", "}", "\n", "\n", "", "if", "self", ".", "aux_loss", ":", "\n", "# [l, bs, queries, embed]", "\n", "            ", "mask_embed", "=", "self", ".", "mask_embed", "(", "hs", ")", "\n", "outputs_seg_masks", "=", "torch", ".", "einsum", "(", "\"lbqc,bchw->lbqhw\"", ",", "mask_embed", ",", "mask_features", ")", "\n", "l", ",", "b", ",", "q", ",", "h", ",", "w", "=", "outputs_seg_masks", ".", "shape", "\n", "outputs_seg_masks", "=", "outputs_seg_masks", ".", "reshape", "(", "l", "*", "b", ",", "q", ",", "h", ",", "w", ")", "\n", "outputs_seg_masks", "=", "upsampling", "(", "outputs_seg_masks", ",", "assigns", ")", "\n", "h", ",", "w", "=", "outputs_seg_masks", ".", "shape", "[", "-", "2", ":", "]", "\n", "outputs_seg_masks", "=", "outputs_seg_masks", ".", "reshape", "(", "l", ",", "b", ",", "q", ",", "h", ",", "w", ")", "\n", "out", "[", "\"pred_masks\"", "]", "=", "outputs_seg_masks", "[", "-", "1", "]", "\n", "out", "[", "\"aux_outputs\"", "]", "=", "self", ".", "_set_aux_loss", "(", "\n", "outputs_class", "if", "self", ".", "mask_classification", "else", "None", ",", "outputs_seg_masks", "\n", ")", "\n", "", "else", ":", "\n", "# FIXME h_boxes takes the last one computed, keep this in mind", "\n", "# [bs, queries, embed]", "\n", "            ", "mask_embed", "=", "self", ".", "mask_embed", "(", "hs", "[", "-", "1", "]", ")", "\n", "outputs_seg_masks", "=", "torch", ".", "einsum", "(", "\"bqc,bchw->bqhw\"", ",", "mask_embed", ",", "mask_features", ")", "\n", "outputs_seg_masks", "=", "upsampling", "(", "outputs_seg_masks", ",", "assigns", ")", "\n", "out", "[", "\"pred_masks\"", "]", "=", "outputs_seg_masks", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.HCStandardTransformerDecoder._set_aux_loss": [[197, 209], ["zip"], "methods", ["None"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "_set_aux_loss", "(", "self", ",", "outputs_class", ",", "outputs_seg_masks", ")", ":", "\n", "# this is a workaround to make torchscript happy, as torchscript", "\n", "# doesn't support dictionary with non-homogeneous values, such", "\n", "# as a dict having both a Tensor and a list.", "\n", "        ", "if", "self", ".", "mask_classification", ":", "\n", "            ", "return", "[", "\n", "{", "\"pred_logits\"", ":", "a", ",", "\"pred_masks\"", ":", "b", "}", "\n", "for", "a", ",", "b", "in", "zip", "(", "outputs_class", "[", ":", "-", "1", "]", ",", "outputs_seg_masks", "[", ":", "-", "1", "]", ")", "\n", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "{", "\"pred_masks\"", ":", "b", "}", "for", "b", "in", "outputs_seg_masks", "[", ":", "-", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.MLP.__init__": [[214, 220], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "torch.nn.Linear", "zip"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "hidden_dim", ",", "output_dim", ",", "num_layers", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "h", "=", "[", "hidden_dim", "]", "*", "(", "num_layers", "-", "1", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", "\n", "nn", ".", "Linear", "(", "n", ",", "k", ")", "for", "n", ",", "k", "in", "zip", "(", "[", "input_dim", "]", "+", "h", ",", "h", "+", "[", "output_dim", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.MLP.forward": [[222, 226], ["enumerate", "torch.nn.functional.relu", "layer", "layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ")", "if", "i", "<", "self", ".", "num_layers", "-", "1", "else", "layer", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.build_transformer_decoder": [[25, 31], ["TRANSFORMER_DECODER_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["def", "build_transformer_decoder", "(", "cfg", ",", "in_channels", ",", "mask_classification", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Build a instance embedding branch from `cfg.MODEL.INS_EMBED_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "TRANSFORMER_DECODER_NAME", "\n", "return", "TRANSFORMER_DECODER_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "in_channels", ",", "mask_classification", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.upsampling": [[33, 40], ["hcformer_decoder_mf.decode", "a.repeat.repeat"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.decode"], ["", "def", "upsampling", "(", "preds", ",", "assigns", ")", ":", "\n", "    ", "for", "a", "in", "assigns", ":", "\n", "# print(a.shape, preds.shape)", "\n", "        ", "if", "a", ".", "shape", "[", "0", "]", "!=", "preds", ".", "shape", "[", "0", "]", ":", "\n", "            ", "a", "=", "a", ".", "repeat", "(", "preds", ".", "shape", "[", "0", "]", "//", "a", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ",", "1", ")", "\n", "", "preds", "=", "decode", "(", "preds", ",", "a", ")", "\n", "", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder_mf.decode": [[41, 54], ["torch.nn.functional.unfold().reshape", "torch.nn.functional.unfold().reshape", "candidate_clusters.permute().reshape.permute().reshape", "A.permute().reshape.permute().reshape", "torch.bmm().reshape().permute().contiguous", "torch.nn.functional.fold", "torch.nn.functional.unfold", "torch.nn.functional.unfold", "candidate_clusters.permute().reshape.permute", "A.permute().reshape.permute", "torch.bmm().reshape().permute", "torch.bmm().reshape", "torch.bmm"], "function", ["None"], ["", "def", "decode", "(", "x", ",", "A", ")", ":", "\n", "    ", "batch_size", ",", "_", ",", "height", ",", "width", "=", "A", ".", "shape", "\n", "n_channels", "=", "x", ".", "shape", "[", "1", "]", "\n", "# get 9 candidate clusters and corresponding assignments", "\n", "candidate_clusters", "=", "F", ".", "unfold", "(", "x", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ".", "reshape", "(", "batch_size", ",", "n_channels", ",", "9", ",", "-", "1", ")", "\n", "A", "=", "F", ".", "unfold", "(", "A", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", ".", "reshape", "(", "batch_size", ",", "9", ",", "4", ",", "-", "1", ")", "\n", "# linear decoding", "\n", "candidate_clusters", "=", "candidate_clusters", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "n_channels", ",", "9", ")", "\n", "A", "=", "A", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "9", ",", "4", ")", "\n", "decoded_features", "=", "torch", ".", "bmm", "(", "candidate_clusters", ",", "A", ")", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "n_channels", "*", "4", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "# decoded_features = torch.einsum('bkcn,bcpn->bkpn', (candidate_clusters, A)).reshape(batch_size, n_channels * 4, -1)", "\n", "decoded_features", "=", "F", ".", "fold", "(", "decoded_features", ",", "(", "height", ",", "width", ")", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "return", "decoded_features", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.SelfAttentionLayer.__init__": [[46, 58], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.LayerNorm", "torch.nn.Dropout", "hcformer_decoder._get_activation_fn", "hcformer_decoder.SelfAttentionLayer._reset_parameters"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_activation_fn", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc._reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dropout", "=", "0.0", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "\n", "self", ".", "norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n", "self", ".", "_reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.SelfAttentionLayer._reset_parameters": [[59, 63], ["hcformer_decoder.SelfAttentionLayer.parameters", "p.dim", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "_reset_parameters", "(", "self", ")", ":", "\n", "        ", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.SelfAttentionLayer.with_pos_embed": [[64, 66], ["None"], "methods", ["None"], ["", "", "", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.SelfAttentionLayer.forward_post": [[67, 78], ["hcformer_decoder.SelfAttentionLayer.with_pos_embed", "hcformer_decoder.SelfAttentionLayer.norm", "hcformer_decoder.SelfAttentionLayer.self_attn", "hcformer_decoder.SelfAttentionLayer.dropout"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed"], ["", "def", "forward_post", "(", "self", ",", "tgt", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm", "(", "tgt", ")", "\n", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.SelfAttentionLayer.forward_pre": [[79, 90], ["hcformer_decoder.SelfAttentionLayer.norm", "hcformer_decoder.SelfAttentionLayer.with_pos_embed", "hcformer_decoder.SelfAttentionLayer.self_attn", "hcformer_decoder.SelfAttentionLayer.dropout"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed"], ["", "def", "forward_pre", "(", "self", ",", "tgt", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "norm", "(", "tgt", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt2", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout", "(", "tgt2", ")", "\n", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.SelfAttentionLayer.forward": [[91, 100], ["hcformer_decoder.SelfAttentionLayer.forward_post", "hcformer_decoder.SelfAttentionLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_post", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_pre"], ["", "def", "forward", "(", "self", ",", "tgt", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "tgt", ",", "tgt_mask", ",", "\n", "tgt_key_padding_mask", ",", "query_pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "tgt", ",", "tgt_mask", ",", "\n", "tgt_key_padding_mask", ",", "query_pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.CrossAttentionLayer.__init__": [[104, 116], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.LayerNorm", "torch.nn.Dropout", "hcformer_decoder._get_activation_fn", "hcformer_decoder.CrossAttentionLayer._reset_parameters"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_activation_fn", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc._reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dropout", "=", "0.0", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "multihead_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "\n", "self", ".", "norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n", "self", ".", "_reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.CrossAttentionLayer._reset_parameters": [[117, 121], ["hcformer_decoder.CrossAttentionLayer.parameters", "p.dim", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "_reset_parameters", "(", "self", ")", ":", "\n", "        ", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.CrossAttentionLayer.with_pos_embed": [[122, 124], ["None"], "methods", ["None"], ["", "", "", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.CrossAttentionLayer.forward_post": [[125, 138], ["hcformer_decoder.CrossAttentionLayer.norm", "hcformer_decoder.CrossAttentionLayer.multihead_attn", "hcformer_decoder.CrossAttentionLayer.dropout", "hcformer_decoder.CrossAttentionLayer.with_pos_embed", "hcformer_decoder.CrossAttentionLayer.with_pos_embed"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed"], ["", "def", "forward_post", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm", "(", "tgt", ")", "\n", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.CrossAttentionLayer.forward_pre": [[139, 152], ["hcformer_decoder.CrossAttentionLayer.norm", "hcformer_decoder.CrossAttentionLayer.multihead_attn", "hcformer_decoder.CrossAttentionLayer.dropout", "hcformer_decoder.CrossAttentionLayer.with_pos_embed", "hcformer_decoder.CrossAttentionLayer.with_pos_embed"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed"], ["", "def", "forward_pre", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "norm", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout", "(", "tgt2", ")", "\n", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.CrossAttentionLayer.forward": [[153, 163], ["hcformer_decoder.CrossAttentionLayer.forward_post", "hcformer_decoder.CrossAttentionLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_post", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_pre"], ["", "def", "forward", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "tgt", ",", "memory", ",", "memory_mask", ",", "\n", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "tgt", ",", "memory", ",", "memory_mask", ",", "\n", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.FFNLayer.__init__": [[167, 181], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.LayerNorm", "hcformer_decoder._get_activation_fn", "hcformer_decoder.FFNLayer._reset_parameters"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_activation_fn", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc._reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.0", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n", "self", ".", "norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n", "self", ".", "_reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.FFNLayer._reset_parameters": [[182, 186], ["hcformer_decoder.FFNLayer.parameters", "p.dim", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "_reset_parameters", "(", "self", ")", ":", "\n", "        ", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.FFNLayer.with_pos_embed": [[187, 189], ["None"], "methods", ["None"], ["", "", "", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.FFNLayer.forward_post": [[190, 195], ["hcformer_decoder.FFNLayer.linear2", "hcformer_decoder.FFNLayer.norm", "hcformer_decoder.FFNLayer.dropout", "hcformer_decoder.FFNLayer.dropout", "hcformer_decoder.FFNLayer.activation", "hcformer_decoder.FFNLayer.linear1"], "methods", ["None"], ["", "def", "forward_post", "(", "self", ",", "tgt", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm", "(", "tgt", ")", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.FFNLayer.forward_pre": [[196, 201], ["hcformer_decoder.FFNLayer.norm", "hcformer_decoder.FFNLayer.linear2", "hcformer_decoder.FFNLayer.dropout", "hcformer_decoder.FFNLayer.dropout", "hcformer_decoder.FFNLayer.activation", "hcformer_decoder.FFNLayer.linear1"], "methods", ["None"], ["", "def", "forward_pre", "(", "self", ",", "tgt", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "norm", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt2", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout", "(", "tgt2", ")", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.FFNLayer.forward": [[202, 206], ["hcformer_decoder.FFNLayer.forward_post", "hcformer_decoder.FFNLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_post", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_pre"], ["", "def", "forward", "(", "self", ",", "tgt", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "tgt", ")", "\n", "", "return", "self", ".", "forward_post", "(", "tgt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.MLP.__init__": [[222, 227], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "torch.nn.Linear", "zip"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "hidden_dim", ",", "output_dim", ",", "num_layers", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "h", "=", "[", "hidden_dim", "]", "*", "(", "num_layers", "-", "1", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", "nn", ".", "Linear", "(", "n", ",", "k", ")", "for", "n", ",", "k", "in", "zip", "(", "[", "input_dim", "]", "+", "h", ",", "h", "+", "[", "output_dim", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.MLP.forward": [[228, 232], ["enumerate", "torch.nn.functional.relu", "layer", "layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ")", "if", "i", "<", "self", ".", "num_layers", "-", "1", "else", "layer", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder._load_from_state_dict": [[239, 259], ["local_metadata.get", "logging.getLogger", "list", "state_dict.keys", "logging.getLogger.warning", "k.replace"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["def", "_load_from_state_dict", "(", "\n", "self", ",", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", "\n", ")", ":", "\n", "        ", "version", "=", "local_metadata", ".", "get", "(", "\"version\"", ",", "None", ")", "\n", "if", "version", "is", "None", "or", "version", "<", "2", ":", "\n", "# Do not warn if train from scratch", "\n", "            ", "scratch", "=", "True", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "for", "k", "in", "list", "(", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "                ", "newk", "=", "k", "\n", "if", "\"static_query\"", "in", "k", ":", "\n", "                    ", "newk", "=", "k", ".", "replace", "(", "\"static_query\"", ",", "\"query_feat\"", ")", "\n", "", "if", "newk", "!=", "k", ":", "\n", "                    ", "state_dict", "[", "newk", "]", "=", "state_dict", "[", "k", "]", "\n", "del", "state_dict", "[", "k", "]", "\n", "scratch", "=", "False", "\n", "\n", "", "", "if", "not", "scratch", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "f\"Weight format of {self.__class__.__name__} have changed! \"", "\n", "\"Please upgrade your models. Applying automatic conversion now ...\"", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder.__init__": [[262, 361], ["torch.nn.Module.__init__", "position_encoding.PositionEmbeddingSine", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "range", "torch.nn.LayerNorm", "torch.nn.Embedding", "torch.nn.Sequential", "detectron2.layers.Conv2d", "fvcore.c2_xavier_fill", "hcformer_decoder.MLP", "hcformer_decoder.HCTransformerDecoder.transformer_self_attention_layers.append", "hcformer_decoder.HCTransformerDecoder.transformer_cross_attention_layers.append", "hcformer_decoder.HCTransformerDecoder.transformer_ffn_layers.append", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Linear", "hcformer_decoder.SelfAttentionLayer", "hcformer_decoder.CrossAttentionLayer", "hcformer_decoder.FFNLayer", "detectron2.layers.Conv2d", "fvcore.c2_xavier_fill"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["", "", "", "@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "mask_classification", "=", "True", ",", "\n", "*", ",", "\n", "num_classes", ":", "int", ",", "\n", "hidden_dim", ":", "int", ",", "\n", "num_queries", ":", "int", ",", "\n", "nheads", ":", "int", ",", "\n", "dim_feedforward", ":", "int", ",", "\n", "dec_layers", ":", "int", ",", "\n", "pre_norm", ":", "bool", ",", "\n", "mask_dim", ":", "int", ",", "\n", "enforce_input_project", ":", "bool", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        Args:\n            in_channels: channels of the input features\n            mask_classification: whether to add mask classifier or not\n            num_classes: number of classes\n            hidden_dim: Transformer feature dimension\n            num_queries: number of queries\n            nheads: number of heads\n            dim_feedforward: feature dimension in feedforward network\n            enc_layers: number of Transformer encoder layers\n            dec_layers: number of Transformer decoder layers\n            pre_norm: whether to use pre-LayerNorm or not\n            mask_dim: mask feature dimension\n            enforce_input_project: add input project 1x1 conv even if input\n                channels and hidden dim is identical\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "mask_classification", ",", "\"Only support mask classification model\"", "\n", "self", ".", "mask_classification", "=", "mask_classification", "\n", "\n", "# positional encoding", "\n", "N_steps", "=", "hidden_dim", "//", "2", "\n", "self", ".", "pe_layer", "=", "PositionEmbeddingSine", "(", "N_steps", ",", "normalize", "=", "True", ")", "\n", "\n", "# define Transformer decoder here", "\n", "self", ".", "num_heads", "=", "nheads", "\n", "self", ".", "num_layers", "=", "dec_layers", "\n", "self", ".", "transformer_self_attention_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "transformer_cross_attention_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "transformer_ffn_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "self", ".", "transformer_self_attention_layers", ".", "append", "(", "\n", "SelfAttentionLayer", "(", "\n", "d_model", "=", "hidden_dim", ",", "\n", "nhead", "=", "nheads", ",", "\n", "dropout", "=", "0.0", ",", "\n", "normalize_before", "=", "pre_norm", ",", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "transformer_cross_attention_layers", ".", "append", "(", "\n", "CrossAttentionLayer", "(", "\n", "d_model", "=", "hidden_dim", ",", "\n", "nhead", "=", "nheads", ",", "\n", "dropout", "=", "0.0", ",", "\n", "normalize_before", "=", "pre_norm", ",", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "transformer_ffn_layers", ".", "append", "(", "\n", "FFNLayer", "(", "\n", "d_model", "=", "hidden_dim", ",", "\n", "dim_feedforward", "=", "dim_feedforward", ",", "\n", "dropout", "=", "0.0", ",", "\n", "normalize_before", "=", "pre_norm", ",", "\n", ")", "\n", ")", "\n", "\n", "", "self", ".", "decoder_norm", "=", "nn", ".", "LayerNorm", "(", "hidden_dim", ")", "\n", "\n", "self", ".", "num_queries", "=", "num_queries", "\n", "# learnable query features", "\n", "self", ".", "query_feat", "=", "nn", ".", "Embedding", "(", "num_queries", ",", "hidden_dim", ")", "\n", "\n", "self", ".", "input_proj", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "self", ".", "num_layers", ">", "0", ":", "\n", "# learnable query p.e.", "\n", "            ", "self", ".", "query_embed", "=", "nn", ".", "Embedding", "(", "num_queries", ",", "hidden_dim", ")", "\n", "self", ".", "level_embed", "=", "nn", ".", "Embedding", "(", "1", ",", "hidden_dim", ")", "\n", "if", "(", "in_channels", "!=", "hidden_dim", "or", "enforce_input_project", ")", ":", "\n", "                ", "self", ".", "input_proj", "=", "Conv2d", "(", "in_channels", ",", "hidden_dim", ",", "kernel_size", "=", "1", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "input_proj", ")", "\n", "\n", "", "", "self", ".", "mask_proj", "=", "Conv2d", "(", "in_channels", ",", "hidden_dim", ",", "kernel_size", "=", "1", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "mask_proj", ")", "\n", "\n", "# output FFNs", "\n", "if", "self", ".", "mask_classification", ":", "\n", "            ", "self", ".", "class_embed", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "num_classes", "+", "1", ")", "\n", "", "self", ".", "mask_embed", "=", "MLP", "(", "hidden_dim", ",", "hidden_dim", ",", "mask_dim", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder.from_config": [[362, 388], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "in_channels", ",", "mask_classification", ")", ":", "\n", "        ", "ret", "=", "{", "}", "\n", "ret", "[", "\"in_channels\"", "]", "=", "in_channels", "\n", "ret", "[", "\"mask_classification\"", "]", "=", "mask_classification", "\n", "\n", "ret", "[", "\"num_classes\"", "]", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "\n", "ret", "[", "\"hidden_dim\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "HIDDEN_DIM", "\n", "ret", "[", "\"num_queries\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NUM_OBJECT_QUERIES", "\n", "# Transformer parameters:", "\n", "ret", "[", "\"nheads\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "NHEADS", "\n", "ret", "[", "\"dim_feedforward\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DIM_FEEDFORWARD", "\n", "\n", "# NOTE: because we add learnable query features which requires supervision,", "\n", "# we add minus 1 to decoder layers to be consistent with our loss", "\n", "# implementation: that is, number of auxiliary losses is always", "\n", "# equal to number of decoder layers. With learnable query features, the number of", "\n", "# auxiliary losses equals number of decoders plus 1.", "\n", "assert", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DEC_LAYERS", ">=", "1", "\n", "ret", "[", "\"dec_layers\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "DEC_LAYERS", "-", "1", "\n", "ret", "[", "\"pre_norm\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "PRE_NORM", "\n", "ret", "[", "\"enforce_input_project\"", "]", "=", "cfg", ".", "MODEL", ".", "MASK_FORMER", ".", "ENFORCE_INPUT_PROJ", "\n", "\n", "ret", "[", "\"mask_dim\"", "]", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "MASK_DIM", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder.forward": [[389, 453], ["hcformer_decoder.HCTransformerDecoder.pe_layer().flatten().permute", "hcformer_decoder.HCTransformerDecoder.mask_proj", "hcformer_decoder.HCTransformerDecoder.query_feat.weight.unsqueeze().repeat", "hcformer_decoder.HCTransformerDecoder.forward_prediction_heads", "predictions_class.append", "upsampling().chunk.append", "hcformer_decoder.HCTransformerDecoder.query_embed.weight.unsqueeze().repeat", "range", "len", "upsampling().chunk", "hcformer_decoder.upsampling", "hcformer_decoder.HCTransformerDecoder._set_aux_loss", "hcformer_decoder.HCTransformerDecoder.pe_layer().flatten", "hcformer_decoder.HCTransformerDecoder.query_feat.weight.unsqueeze", "hcformer_decoder.HCTransformerDecoder.forward_prediction_heads", "predictions_class.append", "upsampling().chunk.append", "len", "hcformer_decoder.HCTransformerDecoder.query_embed.weight.unsqueeze", "hcformer_decoder.upsampling", "hcformer_decoder.HCTransformerDecoder.pe_layer", "hcformer_decoder.HCTransformerDecoder.input_proj().flatten", "torch.where", "torch.cat", "hcformer_decoder.HCTransformerDecoder.input_proj", "attn_mask.sum"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder.forward_prediction_heads", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.upsampling", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder._set_aux_loss", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder.forward_prediction_heads", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.upsampling"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask_features", ",", "assigns", ",", "mask", "=", "None", ")", ":", "\n", "# x is a list of multi-scale feature", "\n", "# disable mask, it does not affect performance", "\n", "        ", "del", "mask", "\n", "\n", "bs", "=", "x", ".", "shape", "[", "0", "]", "\n", "size", "=", "x", ".", "shape", "[", "-", "2", ":", "]", "\n", "pos", "=", "self", ".", "pe_layer", "(", "x", ",", "None", ")", ".", "flatten", "(", "2", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "mask_features", "=", "self", ".", "mask_proj", "(", "mask_features", ")", "\n", "\n", "# QxNxC", "\n", "output", "=", "self", ".", "query_feat", ".", "weight", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "bs", ",", "1", ")", "\n", "\n", "predictions_class", "=", "[", "]", "\n", "predictions_mask", "=", "[", "]", "\n", "\n", "# prediction heads on learnable query features", "\n", "outputs_class", ",", "outputs_mask", ",", "attn_mask", "=", "self", ".", "forward_prediction_heads", "(", "output", ",", "mask_features", ",", "attn_mask_target_size", "=", "size", ")", "\n", "predictions_class", ".", "append", "(", "outputs_class", ")", "\n", "predictions_mask", ".", "append", "(", "outputs_mask", ")", "\n", "\n", "if", "self", ".", "num_layers", ">", "0", ":", "\n", "            ", "query_embed", "=", "self", ".", "query_embed", ".", "weight", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "bs", ",", "1", ")", "\n", "src", "=", "(", "self", ".", "input_proj", "(", "x", ")", ".", "flatten", "(", "2", ")", "+", "self", ".", "level_embed", ".", "weight", "[", "...", ",", "None", "]", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# here level_embed works as the bias term", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "                ", "attn_mask", "[", "torch", ".", "where", "(", "attn_mask", ".", "sum", "(", "-", "1", ")", "==", "attn_mask", ".", "shape", "[", "-", "1", "]", ")", "]", "=", "False", "\n", "# attention: cross-attention first", "\n", "output", "=", "self", ".", "transformer_cross_attention_layers", "[", "i", "]", "(", "\n", "output", ",", "src", ",", "\n", "memory_mask", "=", "attn_mask", ",", "\n", "memory_key_padding_mask", "=", "None", ",", "# here we do not apply masking on padded region", "\n", "pos", "=", "pos", ",", "query_pos", "=", "query_embed", "\n", ")", "\n", "\n", "output", "=", "self", ".", "transformer_self_attention_layers", "[", "i", "]", "(", "\n", "output", ",", "tgt_mask", "=", "None", ",", "\n", "tgt_key_padding_mask", "=", "None", ",", "\n", "query_pos", "=", "query_embed", "\n", ")", "\n", "\n", "# FFN", "\n", "output", "=", "self", ".", "transformer_ffn_layers", "[", "i", "]", "(", "\n", "output", "\n", ")", "\n", "\n", "outputs_class", ",", "outputs_mask", ",", "attn_mask", "=", "self", ".", "forward_prediction_heads", "(", "output", ",", "mask_features", ",", "attn_mask_target_size", "=", "size", ")", "\n", "predictions_class", ".", "append", "(", "outputs_class", ")", "\n", "predictions_mask", ".", "append", "(", "outputs_mask", ")", "\n", "\n", "", "", "assert", "len", "(", "predictions_class", ")", "==", "self", ".", "num_layers", "+", "1", "\n", "if", "self", ".", "training", ":", "\n", "            ", "predictions_mask", "=", "upsampling", "(", "torch", ".", "cat", "(", "predictions_mask", ")", ",", "assigns", ")", ".", "chunk", "(", "len", "(", "predictions_class", ")", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "predictions_mask", "[", "-", "1", "]", "=", "upsampling", "(", "predictions_mask", "[", "-", "1", "]", ",", "assigns", ")", "\n", "\n", "", "out", "=", "{", "\n", "'pred_logits'", ":", "predictions_class", "[", "-", "1", "]", ",", "\n", "'pred_masks'", ":", "predictions_mask", "[", "-", "1", "]", ",", "\n", "'aux_outputs'", ":", "self", ".", "_set_aux_loss", "(", "\n", "predictions_class", "if", "self", ".", "mask_classification", "else", "None", ",", "predictions_mask", "\n", ")", "\n", "}", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder.forward_prediction_heads": [[454, 471], ["hcformer_decoder.HCTransformerDecoder.decoder_norm", "decoder_output.transpose.transpose.transpose", "hcformer_decoder.HCTransformerDecoder.class_embed", "hcformer_decoder.HCTransformerDecoder.mask_embed", "torch.einsum", "attn_mask.detach.detach.detach", "torch.einsum.sigmoid().flatten().unsqueeze().repeat().flatten", "torch.einsum.sigmoid().flatten().unsqueeze().repeat", "torch.einsum.sigmoid().flatten().unsqueeze", "torch.einsum.sigmoid().flatten", "torch.einsum.sigmoid"], "methods", ["None"], ["", "def", "forward_prediction_heads", "(", "self", ",", "output", ",", "mask_features", ",", "attn_mask_target_size", ")", ":", "\n", "        ", "decoder_output", "=", "self", ".", "decoder_norm", "(", "output", ")", "\n", "decoder_output", "=", "decoder_output", ".", "transpose", "(", "0", ",", "1", ")", "\n", "outputs_class", "=", "self", ".", "class_embed", "(", "decoder_output", ")", "\n", "mask_embed", "=", "self", ".", "mask_embed", "(", "decoder_output", ")", "\n", "# outputs_mask = torch.bmm(mask_embed, mask_features)", "\n", "outputs_mask", "=", "torch", ".", "einsum", "(", "\"bqc,bchw->bqhw\"", ",", "mask_embed", ",", "mask_features", ")", "\n", "\n", "# NOTE: prediction is of higher-resolution", "\n", "# [B, Q, H, W] -> [B, Q, H*W] -> [B, h, Q, H*W] -> [B*h, Q, HW]", "\n", "# attn_mask = F.interpolate(outputs_mask, size=attn_mask_target_size, mode=\"bilinear\", align_corners=False)", "\n", "# must use bool type", "\n", "# If a BoolTensor is provided, positions with ``True`` are not allowed to attend while ``False`` values will be unchanged.", "\n", "attn_mask", "=", "(", "outputs_mask", ".", "sigmoid", "(", ")", ".", "flatten", "(", "2", ")", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "self", ".", "num_heads", ",", "1", ",", "1", ")", ".", "flatten", "(", "0", ",", "1", ")", "<", "0.5", ")", ".", "bool", "(", ")", "\n", "attn_mask", "=", "attn_mask", ".", "detach", "(", ")", "\n", "\n", "return", "outputs_class", ",", "outputs_mask", ",", "attn_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.HCTransformerDecoder._set_aux_loss": [[472, 484], ["zip"], "methods", ["None"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "_set_aux_loss", "(", "self", ",", "outputs_class", ",", "outputs_seg_masks", ")", ":", "\n", "# this is a workaround to make torchscript happy, as torchscript", "\n", "# doesn't support dictionary with non-homogeneous values, such", "\n", "# as a dict having both a Tensor and a list.", "\n", "        ", "if", "self", ".", "mask_classification", ":", "\n", "            ", "return", "[", "\n", "{", "\"pred_logits\"", ":", "a", ",", "\"pred_masks\"", ":", "b", "}", "\n", "for", "a", ",", "b", "in", "zip", "(", "outputs_class", "[", ":", "-", "1", "]", ",", "outputs_seg_masks", "[", ":", "-", "1", "]", ")", "\n", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "{", "\"pred_masks\"", ":", "b", "}", "for", "b", "in", "outputs_seg_masks", "[", ":", "-", "1", "]", "]", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.upsampling": [[21, 28], ["hcformer_decoder.decode", "a.repeat.repeat"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.decode"], ["def", "upsampling", "(", "preds", ",", "assigns", ")", ":", "\n", "    ", "for", "a", "in", "assigns", ":", "\n", "# print(a.shape, preds.shape)", "\n", "        ", "if", "a", ".", "shape", "[", "0", "]", "!=", "preds", ".", "shape", "[", "0", "]", ":", "\n", "            ", "a", "=", "a", ".", "repeat", "(", "preds", ".", "shape", "[", "0", "]", "//", "a", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ",", "1", ")", "\n", "", "preds", "=", "decode", "(", "preds", ",", "a", ")", "\n", "", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.decode": [[30, 42], ["torch.nn.functional.unfold().reshape", "torch.nn.functional.unfold().reshape", "candidate_clusters.permute().reshape.permute().reshape", "A.permute().reshape.permute().reshape", "torch.bmm().reshape().permute().contiguous", "torch.nn.functional.fold", "torch.nn.functional.unfold", "torch.nn.functional.unfold", "candidate_clusters.permute().reshape.permute", "A.permute().reshape.permute", "torch.bmm().reshape().permute", "torch.bmm().reshape", "torch.bmm"], "function", ["None"], ["", "def", "decode", "(", "x", ",", "A", ")", ":", "\n", "    ", "batch_size", ",", "_", ",", "height", ",", "width", "=", "A", ".", "shape", "\n", "n_channels", "=", "x", ".", "shape", "[", "1", "]", "\n", "# get 9 candidate clusters and corresponding assignments", "\n", "candidate_clusters", "=", "F", ".", "unfold", "(", "x", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ".", "reshape", "(", "batch_size", ",", "n_channels", ",", "9", ",", "-", "1", ")", "\n", "A", "=", "F", ".", "unfold", "(", "A", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", ".", "reshape", "(", "batch_size", ",", "9", ",", "4", ",", "-", "1", ")", "\n", "# linear decoding", "\n", "candidate_clusters", "=", "candidate_clusters", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "n_channels", ",", "9", ")", "\n", "A", "=", "A", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "9", ",", "4", ")", "\n", "decoded_features", "=", "torch", ".", "bmm", "(", "candidate_clusters", ",", "A", ")", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "n_channels", "*", "4", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "decoded_features", "=", "F", ".", "fold", "(", "decoded_features", ",", "(", "height", ",", "width", ")", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "return", "decoded_features", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder._get_activation_fn": [[208, 217], ["RuntimeError"], "function", ["None"], ["", "", "def", "_get_activation_fn", "(", "activation", ")", ":", "\n", "    ", "\"\"\"Return an activation function given a string\"\"\"", "\n", "if", "activation", "==", "\"relu\"", ":", "\n", "        ", "return", "F", ".", "relu", "\n", "", "if", "activation", "==", "\"gelu\"", ":", "\n", "        ", "return", "F", ".", "gelu", "\n", "", "if", "activation", "==", "\"glu\"", ":", "\n", "        ", "return", "F", ".", "glu", "\n", "", "raise", "RuntimeError", "(", "F\"activation should be relu/gelu, not {activation}.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.Transformer.__init__": [[20, 55], ["torch.nn.Module.__init__", "transformer.TransformerEncoderLayer", "transformer.TransformerEncoder", "transformer.TransformerDecoderLayer", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "transformer.TransformerDecoder", "transformer.Transformer._reset_parameters", "torch.nn.LayerNorm", "torch.nn.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc._reset_parameters"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "d_model", "=", "512", ",", "\n", "nhead", "=", "8", ",", "\n", "num_encoder_layers", "=", "6", ",", "\n", "num_decoder_layers", "=", "6", ",", "\n", "dim_feedforward", "=", "2048", ",", "\n", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "\n", "normalize_before", "=", "False", ",", "\n", "return_intermediate_dec", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "encoder_layer", "=", "TransformerEncoderLayer", "(", "\n", "d_model", ",", "nhead", ",", "dim_feedforward", ",", "dropout", ",", "activation", ",", "normalize_before", "\n", ")", "\n", "encoder_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "if", "normalize_before", "else", "None", "\n", "self", ".", "encoder", "=", "TransformerEncoder", "(", "encoder_layer", ",", "num_encoder_layers", ",", "encoder_norm", ")", "\n", "\n", "decoder_layer", "=", "TransformerDecoderLayer", "(", "\n", "d_model", ",", "nhead", ",", "dim_feedforward", ",", "dropout", ",", "activation", ",", "normalize_before", "\n", ")", "\n", "decoder_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "decoder", "=", "TransformerDecoder", "(", "\n", "decoder_layer", ",", "\n", "num_decoder_layers", ",", "\n", "decoder_norm", ",", "\n", "return_intermediate", "=", "return_intermediate_dec", ",", "\n", ")", "\n", "\n", "self", ".", "_reset_parameters", "(", ")", "\n", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "nhead", "=", "nhead", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.Transformer._reset_parameters": [[56, 60], ["transformer.Transformer.parameters", "p.dim", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "_reset_parameters", "(", "self", ")", ":", "\n", "        ", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.Transformer.forward": [[61, 76], ["src.flatten().permute.flatten().permute.flatten().permute", "pos_embed.flatten().permute.flatten().permute.flatten().permute", "query_embed.unsqueeze().repeat.unsqueeze().repeat.unsqueeze().repeat", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "transformer.Transformer.encoder", "transformer.Transformer.decoder", "mask.flatten.flatten.flatten", "transformer.Transformer.transpose", "transformer.Transformer.permute().view", "src.flatten().permute.flatten().permute.flatten", "pos_embed.flatten().permute.flatten().permute.flatten", "query_embed.unsqueeze().repeat.unsqueeze().repeat.unsqueeze", "transformer.Transformer.permute"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "src", ",", "mask", ",", "query_embed", ",", "pos_embed", ")", ":", "\n", "# flatten NxCxHxW to HWxNxC", "\n", "        ", "bs", ",", "c", ",", "h", ",", "w", "=", "src", ".", "shape", "\n", "src", "=", "src", ".", "flatten", "(", "2", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "pos_embed", "=", "pos_embed", ".", "flatten", "(", "2", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "query_embed", "=", "query_embed", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "bs", ",", "1", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "mask", ".", "flatten", "(", "1", ")", "\n", "\n", "", "tgt", "=", "torch", ".", "zeros_like", "(", "query_embed", ")", "\n", "memory", "=", "self", ".", "encoder", "(", "src", ",", "src_key_padding_mask", "=", "mask", ",", "pos", "=", "pos_embed", ")", "\n", "hs", "=", "self", ".", "decoder", "(", "\n", "tgt", ",", "memory", ",", "memory_key_padding_mask", "=", "mask", ",", "pos", "=", "pos_embed", ",", "query_pos", "=", "query_embed", "\n", ")", "\n", "return", "hs", ".", "transpose", "(", "1", ",", "2", ")", ",", "memory", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "view", "(", "bs", ",", "c", ",", "h", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerEncoder.__init__": [[79, 84], ["torch.nn.Module.__init__", "transformer._get_clones"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_clones"], ["    ", "def", "__init__", "(", "self", ",", "encoder_layer", ",", "num_layers", ",", "norm", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "_get_clones", "(", "encoder_layer", ",", "num_layers", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "norm", "=", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerEncoder.forward": [[85, 103], ["layer", "transformer.TransformerEncoder.norm"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "src", ",", "\n", "mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "output", "=", "src", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "output", "=", "layer", "(", "\n", "output", ",", "src_mask", "=", "mask", ",", "src_key_padding_mask", "=", "src_key_padding_mask", ",", "pos", "=", "pos", "\n", ")", "\n", "\n", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "output", "=", "self", ".", "norm", "(", "output", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoder.__init__": [[106, 112], ["torch.nn.Module.__init__", "transformer._get_clones"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_clones"], ["    ", "def", "__init__", "(", "self", ",", "decoder_layer", ",", "num_layers", ",", "norm", "=", "None", ",", "return_intermediate", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "_get_clones", "(", "decoder_layer", ",", "num_layers", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "return_intermediate", "=", "return_intermediate", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoder.forward": [[113, 152], ["transformer.TransformerDecoder.unsqueeze", "layer", "transformer.TransformerDecoder.norm", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "intermediate.append", "intermediate.pop", "intermediate.append", "transformer.TransformerDecoder.norm"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "tgt", ",", "\n", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "output", "=", "tgt", "\n", "\n", "intermediate", "=", "[", "]", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "output", "=", "layer", "(", "\n", "output", ",", "\n", "memory", ",", "\n", "tgt_mask", "=", "tgt_mask", ",", "\n", "memory_mask", "=", "memory_mask", ",", "\n", "tgt_key_padding_mask", "=", "tgt_key_padding_mask", ",", "\n", "memory_key_padding_mask", "=", "memory_key_padding_mask", ",", "\n", "pos", "=", "pos", ",", "\n", "query_pos", "=", "query_pos", ",", "\n", ")", "\n", "if", "self", ".", "return_intermediate", ":", "\n", "                ", "intermediate", ".", "append", "(", "self", ".", "norm", "(", "output", ")", ")", "\n", "\n", "", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "output", "=", "self", ".", "norm", "(", "output", ")", "\n", "if", "self", ".", "return_intermediate", ":", "\n", "                ", "intermediate", ".", "pop", "(", ")", "\n", "intermediate", ".", "append", "(", "output", ")", "\n", "\n", "", "", "if", "self", ".", "return_intermediate", ":", "\n", "            ", "return", "torch", ".", "stack", "(", "intermediate", ")", "\n", "\n", "", "return", "output", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerEncoderLayer.__init__": [[155, 178], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "transformer._get_activation_fn"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_activation_fn"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "d_model", ",", "\n", "nhead", ",", "\n", "dim_feedforward", "=", "2048", ",", "\n", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "\n", "normalize_before", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerEncoderLayer.with_pos_embed": [[179, 181], ["None"], "methods", ["None"], ["", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerEncoderLayer.forward_post": [[182, 199], ["transformer.TransformerEncoderLayer.with_pos_embed", "transformer.TransformerEncoderLayer.norm1", "transformer.TransformerEncoderLayer.linear2", "transformer.TransformerEncoderLayer.norm2", "transformer.TransformerEncoderLayer.self_attn", "transformer.TransformerEncoderLayer.dropout1", "transformer.TransformerEncoderLayer.dropout", "transformer.TransformerEncoderLayer.dropout2", "transformer.TransformerEncoderLayer.activation", "transformer.TransformerEncoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed"], ["", "def", "forward_post", "(", "\n", "self", ",", "\n", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "\n", "q", ",", "k", ",", "value", "=", "src", ",", "attn_mask", "=", "src_mask", ",", "key_padding_mask", "=", "src_key_padding_mask", "\n", ")", "[", "0", "]", "\n", "src", "=", "src", "+", "self", ".", "dropout1", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm1", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm2", "(", "src", ")", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerEncoderLayer.forward_pre": [[200, 217], ["transformer.TransformerEncoderLayer.norm1", "transformer.TransformerEncoderLayer.with_pos_embed", "transformer.TransformerEncoderLayer.norm2", "transformer.TransformerEncoderLayer.linear2", "transformer.TransformerEncoderLayer.self_attn", "transformer.TransformerEncoderLayer.dropout1", "transformer.TransformerEncoderLayer.dropout", "transformer.TransformerEncoderLayer.dropout2", "transformer.TransformerEncoderLayer.activation", "transformer.TransformerEncoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed"], ["", "def", "forward_pre", "(", "\n", "self", ",", "\n", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "src2", "=", "self", ".", "norm1", "(", "src", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src2", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "\n", "q", ",", "k", ",", "value", "=", "src2", ",", "attn_mask", "=", "src_mask", ",", "key_padding_mask", "=", "src_key_padding_mask", "\n", ")", "[", "0", "]", "\n", "src", "=", "src", "+", "self", ".", "dropout1", "(", "src2", ")", "\n", "src2", "=", "self", ".", "norm2", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src2", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerEncoderLayer.forward": [[218, 228], ["transformer.TransformerEncoderLayer.forward_post", "transformer.TransformerEncoderLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_post", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_pre"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.__init__": [[231, 257], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "transformer._get_activation_fn"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_activation_fn"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "d_model", ",", "\n", "nhead", ",", "\n", "dim_feedforward", "=", "2048", ",", "\n", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "\n", "normalize_before", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "multihead_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm3", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout3", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed": [[258, 260], ["None"], "methods", ["None"], ["", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_post": [[261, 291], ["transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.norm1", "transformer.TransformerDecoderLayer.norm2", "transformer.TransformerDecoderLayer.linear2", "transformer.TransformerDecoderLayer.norm3", "transformer.TransformerDecoderLayer.self_attn", "transformer.TransformerDecoderLayer.dropout1", "transformer.TransformerDecoderLayer.multihead_attn", "transformer.TransformerDecoderLayer.dropout2", "transformer.TransformerDecoderLayer.dropout", "transformer.TransformerDecoderLayer.dropout3", "transformer.TransformerDecoderLayer.activation", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed"], ["", "def", "forward_post", "(", "\n", "self", ",", "\n", "tgt", ",", "\n", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "\n", "q", ",", "k", ",", "value", "=", "tgt", ",", "attn_mask", "=", "tgt_mask", ",", "key_padding_mask", "=", "tgt_key_padding_mask", "\n", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "multihead_attn", "(", "\n", "query", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "\n", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ",", "\n", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_pre": [[292, 322], ["transformer.TransformerDecoderLayer.norm1", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.norm2", "transformer.TransformerDecoderLayer.norm3", "transformer.TransformerDecoderLayer.linear2", "transformer.TransformerDecoderLayer.self_attn", "transformer.TransformerDecoderLayer.dropout1", "transformer.TransformerDecoderLayer.multihead_attn", "transformer.TransformerDecoderLayer.dropout2", "transformer.TransformerDecoderLayer.dropout", "transformer.TransformerDecoderLayer.dropout3", "transformer.TransformerDecoderLayer.activation", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.with_pos_embed"], ["", "def", "forward_pre", "(", "\n", "self", ",", "\n", "tgt", ",", "\n", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "\n", "q", ",", "k", ",", "value", "=", "tgt2", ",", "attn_mask", "=", "tgt_mask", ",", "key_padding_mask", "=", "tgt_key_padding_mask", "\n", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "multihead_attn", "(", "\n", "query", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "\n", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ",", "\n", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt2", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "return", "tgt", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward": [[323, 354], ["transformer.TransformerDecoderLayer.forward_post", "transformer.TransformerDecoderLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_post", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer.TransformerDecoderLayer.forward_pre"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "tgt", ",", "\n", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "\n", "tgt", ",", "\n", "memory", ",", "\n", "tgt_mask", ",", "\n", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "\n", "memory_key_padding_mask", ",", "\n", "pos", ",", "\n", "query_pos", ",", "\n", ")", "\n", "", "return", "self", ".", "forward_post", "(", "\n", "tgt", ",", "\n", "memory", ",", "\n", "tgt_mask", ",", "\n", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "\n", "memory_key_padding_mask", ",", "\n", "pos", ",", "\n", "query_pos", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_clones": [[357, 359], ["torch.nn.ModuleList", "copy.deepcopy", "range"], "function", ["None"], ["", "", "def", "_get_clones", "(", "module", ",", "N", ")", ":", "\n", "    ", "return", "nn", ".", "ModuleList", "(", "[", "copy", ".", "deepcopy", "(", "module", ")", "for", "i", "in", "range", "(", "N", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.transformer._get_activation_fn": [[361, 370], ["RuntimeError"], "function", ["None"], ["", "def", "_get_activation_fn", "(", "activation", ")", ":", "\n", "    ", "\"\"\"Return an activation function given a string\"\"\"", "\n", "if", "activation", "==", "\"relu\"", ":", "\n", "        ", "return", "F", ".", "relu", "\n", "", "if", "activation", "==", "\"gelu\"", ":", "\n", "        ", "return", "F", ".", "gelu", "\n", "", "if", "activation", "==", "\"glu\"", ":", "\n", "        ", "return", "F", ".", "glu", "\n", "", "raise", "RuntimeError", "(", "f\"activation should be relu/gelu, not {activation}.\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.position_encoding.PositionEmbeddingSine.__init__": [[18, 28], ["torch.nn.Module.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "self", ",", "num_pos_feats", "=", "64", ",", "temperature", "=", "10000", ",", "normalize", "=", "False", ",", "scale", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_pos_feats", "=", "num_pos_feats", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "normalize", "=", "normalize", "\n", "if", "scale", "is", "not", "None", "and", "normalize", "is", "False", ":", "\n", "            ", "raise", "ValueError", "(", "\"normalize should be True if scale is passed\"", ")", "\n", "", "if", "scale", "is", "None", ":", "\n", "            ", "scale", "=", "2", "*", "math", ".", "pi", "\n", "", "self", ".", "scale", "=", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.position_encoding.PositionEmbeddingSine.forward": [[29, 53], ["not_mask.cumsum", "not_mask.cumsum", "torch.arange", "torch.stack().flatten", "torch.stack().flatten", "torch.cat().permute", "torch.zeros", "torch.stack", "torch.stack", "torch.cat", "x.size", "x.size", "x.size", "pos_x[].sin", "pos_x[].cos", "pos_y[].sin", "pos_y[].cos"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "torch", ".", "zeros", "(", "(", "x", ".", "size", "(", "0", ")", ",", "x", ".", "size", "(", "2", ")", ",", "x", ".", "size", "(", "3", ")", ")", ",", "device", "=", "x", ".", "device", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "", "not_mask", "=", "~", "mask", "\n", "y_embed", "=", "not_mask", ".", "cumsum", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "x_embed", "=", "not_mask", ".", "cumsum", "(", "2", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "            ", "eps", "=", "1e-6", "\n", "y_embed", "=", "y_embed", "/", "(", "y_embed", "[", ":", ",", "-", "1", ":", ",", ":", "]", "+", "eps", ")", "*", "self", ".", "scale", "\n", "x_embed", "=", "x_embed", "/", "(", "x_embed", "[", ":", ",", ":", ",", "-", "1", ":", "]", "+", "eps", ")", "*", "self", ".", "scale", "\n", "\n", "", "dim_t", "=", "torch", ".", "arange", "(", "self", ".", "num_pos_feats", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "x", ".", "device", ")", "\n", "dim_t", "=", "self", ".", "temperature", "**", "(", "2", "*", "(", "dim_t", "//", "2", ")", "/", "self", ".", "num_pos_feats", ")", "\n", "\n", "pos_x", "=", "x_embed", "[", ":", ",", ":", ",", ":", ",", "None", "]", "/", "dim_t", "\n", "pos_y", "=", "y_embed", "[", ":", ",", ":", ",", ":", ",", "None", "]", "/", "dim_t", "\n", "pos_x", "=", "torch", ".", "stack", "(", "\n", "(", "pos_x", "[", ":", ",", ":", ",", ":", ",", "0", ":", ":", "2", "]", ".", "sin", "(", ")", ",", "pos_x", "[", ":", ",", ":", ",", ":", ",", "1", ":", ":", "2", "]", ".", "cos", "(", ")", ")", ",", "dim", "=", "4", "\n", ")", ".", "flatten", "(", "3", ")", "\n", "pos_y", "=", "torch", ".", "stack", "(", "\n", "(", "pos_y", "[", ":", ",", ":", ",", ":", ",", "0", ":", ":", "2", "]", ".", "sin", "(", ")", ",", "pos_y", "[", ":", ",", ":", ",", ":", ",", "1", ":", ":", "2", "]", ".", "cos", "(", ")", ")", ",", "dim", "=", "4", "\n", ")", ".", "flatten", "(", "3", ")", "\n", "pos", "=", "torch", ".", "cat", "(", "(", "pos_y", ",", "pos_x", ")", ",", "dim", "=", "3", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "return", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.position_encoding.PositionEmbeddingSine.__repr__": [[54, 65], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ",", "_repr_indent", "=", "4", ")", ":", "\n", "        ", "head", "=", "\"Positional encoding \"", "+", "self", ".", "__class__", ".", "__name__", "\n", "body", "=", "[", "\n", "\"num_pos_feats: {}\"", ".", "format", "(", "self", ".", "num_pos_feats", ")", ",", "\n", "\"temperature: {}\"", ".", "format", "(", "self", ".", "temperature", ")", ",", "\n", "\"normalize: {}\"", ".", "format", "(", "self", ".", "normalize", ")", ",", "\n", "\"scale: {}\"", ".", "format", "(", "self", ".", "scale", ")", ",", "\n", "]", "\n", "# _repr_indent = 4", "\n", "lines", "=", "[", "head", "]", "+", "[", "\" \"", "*", "_repr_indent", "+", "line", "for", "line", "in", "body", "]", "\n", "return", "\"\\n\"", ".", "join", "(", "lines", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.resnet.HCResNet.__init__": [[25, 65], ["torch.Module.__init__", "detectron2.layers.FrozenBatchNorm2d.convert_frozen_batchnorm", "torch.Sequential", "range", "torch.ModuleList", "getattr", "clustering_layers.append", "reversed", "utils.TransformerEnc", "resnet.dconv_bottleneck", "setattr", "utils.Clustering"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.resnet.dconv_bottleneck"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "depth", "=", "50", ",", "\n", "hierarchical_level", "=", "3", ",", "\n", "temp", "=", "0.05", ",", "\n", "emb_dim", "=", "128", ",", "\n", "downsampling", "=", "'deform'", ",", "\n", "aux", "=", "None", ",", "\n", "n_tenc_layers", "=", "6", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "hierarchical_level", "<=", "3", "\n", "resnet", "=", "M", ".", "__dict__", "[", "f'resnet{depth}'", "]", "(", "pretrained", "=", "True", ")", "\n", "resnet", "=", "FrozenBatchNorm2d", ".", "convert_frozen_batchnorm", "(", "resnet", ")", "\n", "self", ".", "stem", "=", "nn", ".", "Sequential", "(", "resnet", ".", "conv1", ",", "\n", "resnet", ".", "bn1", ",", "\n", "resnet", ".", "relu", ",", "\n", "resnet", ".", "maxpool", ")", "\n", "self", ".", "layer1", "=", "resnet", ".", "layer1", "\n", "self", ".", "layer2", "=", "resnet", ".", "layer2", "\n", "self", ".", "layer3", "=", "resnet", ".", "layer3", "\n", "self", ".", "layer4", "=", "resnet", ".", "layer4", "\n", "\n", "clustering_layers", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "5", "-", "hierarchical_level", ",", "5", ")", ":", "\n", "            ", "ds_module", "=", "getattr", "(", "self", ",", "f'layer{idx}'", ")", "\n", "coarse_dim", ",", "fine_dim", "=", "ds_module", "[", "0", "]", ".", "downsample", "[", "0", "]", ".", "weight", ".", "shape", "[", ":", "2", "]", "\n", "if", "downsampling", "==", "'deform'", ":", "\n", "                ", "dconv_layer", "=", "dconv_bottleneck", "(", "ds_module", ",", "fine_dim", ",", "coarse_dim", ")", "\n", "setattr", "(", "self", ",", "f'layer{idx}'", ",", "dconv_layer", ")", "\n", "", "clustering_layers", ".", "append", "(", "Clustering", "(", "fine_dim", ",", "coarse_dim", ",", "emb_dim", ",", "temp", ")", ")", "\n", "\n", "", "self", ".", "clustering_layers", "=", "nn", ".", "ModuleList", "(", "reversed", "(", "clustering_layers", ")", ")", "\n", "self", ".", "level", "=", "hierarchical_level", "\n", "\n", "if", "aux", "==", "'transformer'", ":", "\n", "            ", "self", ".", "aux", "=", "TransformerEnc", "(", "2048", ",", "256", ",", "8", ",", "n_tenc_layers", ",", "2048", ")", "\n", "self", ".", "num_features", "=", "[", "256", ",", "512", ",", "1024", ",", "256", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "aux", "=", "None", "\n", "self", ".", "num_features", "=", "[", "256", ",", "512", ",", "1024", ",", "2048", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.resnet.HCResNet.forward": [[66, 87], ["resnet.HCResNet.stem", "resnet.HCResNet.layer1", "resnet.HCResNet.aux", "clustering", "zip"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "outs", "=", "{", "}", "\n", "x", "=", "self", ".", "stem", "(", "x", ")", "\n", "x1", "=", "self", ".", "layer1", "(", "x", ")", "\n", "d_x1", "=", "self", ".", "layer2", "[", "0", "]", "(", "x1", ")", "\n", "x2", "=", "self", ".", "layer2", "[", "1", ":", "]", "(", "d_x1", ")", "\n", "d_x2", "=", "self", ".", "layer3", "[", "0", "]", "(", "x2", ")", "\n", "x3", "=", "self", ".", "layer3", "[", "1", ":", "]", "(", "d_x2", ")", "\n", "d_x3", "=", "self", ".", "layer4", "[", "0", "]", "(", "x3", ")", "\n", "x4", "=", "self", ".", "layer4", "[", "1", ":", "]", "(", "d_x3", ")", "\n", "if", "self", ".", "aux", "is", "not", "None", ":", "\n", "            ", "x4", "=", "self", ".", "aux", "(", "x4", ")", "\n", "\n", "", "feat_pair", "=", "[", "(", "x3", ",", "d_x3", ")", ",", "(", "x2", ",", "d_x2", ")", ",", "(", "x1", ",", "d_x1", ")", "]", "\n", "assigns", "=", "[", "clustering", "(", "*", "feats", ")", "for", "feats", ",", "clustering", "in", "zip", "(", "feat_pair", ",", "self", ".", "clustering_layers", ")", "]", "\n", "outs", "[", "\"res2\"", "]", "=", "x1", "\n", "outs", "[", "\"res3\"", "]", "=", "x2", "\n", "outs", "[", "\"res4\"", "]", "=", "x3", "\n", "outs", "[", "\"res5\"", "]", "=", "x4", "\n", "outs", "[", "\"assign\"", "]", "=", "assigns", "\n", "return", "outs", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.resnet.D2HCResNet.__init__": [[91, 115], ["resnet.HCResNet.__init__", "resnet.HCResNet.__init__"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "depth", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEPTH", "\n", "level", "=", "cfg", ".", "MODEL", ".", "HC", ".", "LEVEL", "\n", "temp", "=", "cfg", ".", "MODEL", ".", "HC", ".", "TEMPERATURE", "\n", "hc_emb", "=", "cfg", ".", "MODEL", ".", "HC", ".", "EMB_DIM", "\n", "aux", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "AUX", "\n", "downsampling", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DOWNSAMPLING", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "depth", ",", "level", ",", "temp", ",", "hc_emb", ",", "downsampling", ",", "aux", ")", "\n", "\n", "self", ".", "_out_features", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "OUT_FEATURES", "\n", "\n", "self", ".", "_out_feature_strides", "=", "{", "\n", "\"res2\"", ":", "4", ",", "\n", "\"res3\"", ":", "8", ",", "\n", "\"res4\"", ":", "16", ",", "\n", "\"res5\"", ":", "32", ",", "\n", "}", "\n", "self", ".", "_out_feature_channels", "=", "{", "\n", "\"res2\"", ":", "self", ".", "num_features", "[", "0", "]", ",", "\n", "\"res3\"", ":", "self", ".", "num_features", "[", "1", "]", ",", "\n", "\"res4\"", ":", "self", ".", "num_features", "[", "2", "]", ",", "\n", "\"res5\"", ":", "self", ".", "num_features", "[", "3", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.resnet.D2HCResNet.forward": [[117, 127], ["resnet.HCResNet.forward", "super().forward.keys", "x.dim"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "(", "\n", "x", ".", "dim", "(", ")", "==", "4", "\n", ")", ",", "f\"HCResNet takes an input of shape (N, C, H, W). Got {x.shape} instead!\"", "\n", "outputs", "=", "{", "}", "\n", "y", "=", "super", "(", ")", ".", "forward", "(", "x", ")", "\n", "for", "k", "in", "y", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "in", "self", ".", "_out_features", "or", "k", "==", "'assign'", ":", "\n", "                ", "outputs", "[", "k", "]", "=", "y", "[", "k", "]", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.resnet.D2HCResNet.output_shape": [[129, 135], ["detectron2.modeling.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.resnet.D2HCResNet.size_divisibility": [[137, 140], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size_divisibility", "(", "self", ")", ":", "\n", "        ", "return", "32", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.resnet.dconv_bottleneck": [[11, 22], ["torch.Sequential", "downsample[].deform.weight.data.copy_", "utils.DeformConv", "utils.DeformConv.deform.weight.data.copy_", "torch.Sequential", "utils.DeformConv"], "function", ["None"], ["def", "dconv_bottleneck", "(", "module", ",", "in_c", ",", "out_c", ")", ":", "\n", "    ", "bneck0", "=", "module", "[", "0", "]", "\n", "downsample", "=", "nn", ".", "Sequential", "(", "DeformConv", "(", "in_c", ",", "out_c", ",", "1", ",", "padding", "=", "0", ")", ",", "\n", "bneck0", ".", "downsample", "[", "1", "]", ")", "\n", "downsample", "[", "0", "]", ".", "deform", ".", "weight", ".", "data", ".", "copy_", "(", "bneck0", ".", "downsample", "[", "0", "]", ".", "weight", ".", "data", ")", "\n", "bottleneck_conv", "=", "bneck0", ".", "conv2", "\n", "dconv", "=", "DeformConv", "(", "bottleneck_conv", ".", "in_channels", ",", "bottleneck_conv", ".", "out_channels", ")", "\n", "dconv", ".", "deform", ".", "weight", ".", "data", ".", "copy_", "(", "bottleneck_conv", ".", "weight", ".", "data", ")", "\n", "bneck0", ".", "conv2", "=", "dconv", "\n", "bneck0", ".", "downsample", "=", "downsample", "\n", "return", "nn", ".", "Sequential", "(", "bneck0", ",", "*", "[", "m", "for", "m", "in", "module", "[", "1", ":", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.Mlp.__init__": [[30, 40], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "act_layer", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "\n", "self", ",", "in_features", ",", "hidden_features", "=", "None", ",", "out_features", "=", "None", ",", "act_layer", "=", "nn", ".", "GELU", ",", "drop", "=", "0.0", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "out_features", "=", "out_features", "or", "in_features", "\n", "hidden_features", "=", "hidden_features", "or", "in_features", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "in_features", ",", "hidden_features", ")", "\n", "self", ".", "act", "=", "act_layer", "(", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "hidden_features", ",", "out_features", ")", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", "drop", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.Mlp.forward": [[41, 48], ["hcswin.Mlp.fc1", "hcswin.Mlp.act", "hcswin.Mlp.drop", "hcswin.Mlp.fc2", "hcswin.Mlp.drop"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "fc1", "(", "x", ")", "\n", "x", "=", "self", ".", "act", "(", "x", ")", "\n", "x", "=", "self", ".", "drop", "(", "x", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "x", "=", "self", ".", "drop", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.WindowAttention.__init__": [[93, 136], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "relative_coords.permute().contiguous.permute().contiguous.permute().contiguous", "relative_coords.permute().contiguous.permute().contiguous.sum", "hcswin.WindowAttention.register_buffer", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "timm.models.layers.trunc_normal_", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "relative_coords.permute().contiguous.permute().contiguous.permute"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dim", ",", "\n", "window_size", ",", "\n", "num_heads", ",", "\n", "qkv_bias", "=", "True", ",", "\n", "qk_scale", "=", "None", ",", "\n", "attn_drop", "=", "0.0", ",", "\n", "proj_drop", "=", "0.0", ",", "\n", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "window_size", "=", "window_size", "# Wh, Ww", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "head_dim", "=", "dim", "//", "num_heads", "\n", "self", ".", "scale", "=", "qk_scale", "or", "head_dim", "**", "-", "0.5", "\n", "\n", "# define a parameter table of relative position bias", "\n", "self", ".", "relative_position_bias_table", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "zeros", "(", "(", "2", "*", "window_size", "[", "0", "]", "-", "1", ")", "*", "(", "2", "*", "window_size", "[", "1", "]", "-", "1", ")", ",", "num_heads", ")", "\n", ")", "# 2*Wh-1 * 2*Ww-1, nH", "\n", "\n", "# get pair-wise relative position index for each token inside the window", "\n", "coords_h", "=", "torch", ".", "arange", "(", "self", ".", "window_size", "[", "0", "]", ")", "\n", "coords_w", "=", "torch", ".", "arange", "(", "self", ".", "window_size", "[", "1", "]", ")", "\n", "coords", "=", "torch", ".", "stack", "(", "torch", ".", "meshgrid", "(", "[", "coords_h", ",", "coords_w", "]", ")", ")", "# 2, Wh, Ww", "\n", "coords_flatten", "=", "torch", ".", "flatten", "(", "coords", ",", "1", ")", "# 2, Wh*Ww", "\n", "relative_coords", "=", "coords_flatten", "[", ":", ",", ":", ",", "None", "]", "-", "coords_flatten", "[", ":", ",", "None", ",", ":", "]", "# 2, Wh*Ww, Wh*Ww", "\n", "relative_coords", "=", "relative_coords", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "contiguous", "(", ")", "# Wh*Ww, Wh*Ww, 2", "\n", "relative_coords", "[", ":", ",", ":", ",", "0", "]", "+=", "self", ".", "window_size", "[", "0", "]", "-", "1", "# shift to start from 0", "\n", "relative_coords", "[", ":", ",", ":", ",", "1", "]", "+=", "self", ".", "window_size", "[", "1", "]", "-", "1", "\n", "relative_coords", "[", ":", ",", ":", ",", "0", "]", "*=", "2", "*", "self", ".", "window_size", "[", "1", "]", "-", "1", "\n", "relative_position_index", "=", "relative_coords", ".", "sum", "(", "-", "1", ")", "# Wh*Ww, Wh*Ww", "\n", "self", ".", "register_buffer", "(", "\"relative_position_index\"", ",", "relative_position_index", ")", "\n", "\n", "self", ".", "qkv", "=", "nn", ".", "Linear", "(", "dim", ",", "dim", "*", "3", ",", "bias", "=", "qkv_bias", ")", "\n", "self", ".", "attn_drop", "=", "nn", ".", "Dropout", "(", "attn_drop", ")", "\n", "self", ".", "proj", "=", "nn", ".", "Linear", "(", "dim", ",", "dim", ")", "\n", "self", ".", "proj_drop", "=", "nn", ".", "Dropout", "(", "proj_drop", ")", "\n", "\n", "trunc_normal_", "(", "self", ".", "relative_position_bias_table", ",", "std", "=", "0.02", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.WindowAttention.forward": [[137, 178], ["hcswin.WindowAttention.qkv().reshape().permute", "hcswin.WindowAttention.relative_position_bias_table[].view", "relative_position_bias.permute().contiguous.permute().contiguous.permute().contiguous", "hcswin.WindowAttention.attn_drop", "hcswin.WindowAttention.proj", "hcswin.WindowAttention.proj_drop", "k.transpose", "relative_position_bias.permute().contiguous.permute().contiguous.unsqueeze", "hcswin.WindowAttention.view", "hcswin.WindowAttention.softmax", "hcswin.WindowAttention.softmax", "hcswin.WindowAttention.qkv().reshape", "relative_position_bias.permute().contiguous.permute().contiguous.permute", "hcswin.WindowAttention.view", "mask.unsqueeze().unsqueeze", "hcswin.WindowAttention.qkv", "hcswin.WindowAttention.relative_position_index.view", "mask.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\n        Args:\n            x: input features with shape of (num_windows*B, N, C)\n            mask: (0/-inf) mask with shape of (num_windows, Wh*Ww, Wh*Ww) or None\n        \"\"\"", "\n", "B_", ",", "N", ",", "C", "=", "x", ".", "shape", "\n", "qkv", "=", "(", "\n", "self", ".", "qkv", "(", "x", ")", "\n", ".", "reshape", "(", "B_", ",", "N", ",", "3", ",", "self", ".", "num_heads", ",", "C", "//", "self", ".", "num_heads", ")", "\n", ".", "permute", "(", "2", ",", "0", ",", "3", ",", "1", ",", "4", ")", "\n", ")", "\n", "q", ",", "k", ",", "v", "=", "qkv", "[", "0", "]", ",", "qkv", "[", "1", "]", ",", "qkv", "[", "2", "]", "# make torchscript happy (cannot use tensor as tuple)", "\n", "\n", "q", "=", "q", "*", "self", ".", "scale", "\n", "attn", "=", "q", "@", "k", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", "\n", "\n", "relative_position_bias", "=", "self", ".", "relative_position_bias_table", "[", "\n", "self", ".", "relative_position_index", ".", "view", "(", "-", "1", ")", "\n", "]", ".", "view", "(", "\n", "self", ".", "window_size", "[", "0", "]", "*", "self", ".", "window_size", "[", "1", "]", ",", "self", ".", "window_size", "[", "0", "]", "*", "self", ".", "window_size", "[", "1", "]", ",", "-", "1", "\n", ")", "# Wh*Ww,Wh*Ww,nH", "\n", "relative_position_bias", "=", "relative_position_bias", ".", "permute", "(", "\n", "2", ",", "0", ",", "1", "\n", ")", ".", "contiguous", "(", ")", "# nH, Wh*Ww, Wh*Ww", "\n", "attn", "=", "attn", "+", "relative_position_bias", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "nW", "=", "mask", ".", "shape", "[", "0", "]", "\n", "attn", "=", "attn", ".", "view", "(", "B_", "//", "nW", ",", "nW", ",", "self", ".", "num_heads", ",", "N", ",", "N", ")", "+", "mask", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "attn", "=", "attn", ".", "view", "(", "-", "1", ",", "self", ".", "num_heads", ",", "N", ",", "N", ")", "\n", "attn", "=", "self", ".", "softmax", "(", "attn", ")", "\n", "", "else", ":", "\n", "            ", "attn", "=", "self", ".", "softmax", "(", "attn", ")", "\n", "\n", "", "attn", "=", "self", ".", "attn_drop", "(", "attn", ")", "\n", "\n", "x", "=", "(", "attn", "@", "v", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "B_", ",", "N", ",", "C", ")", "\n", "x", "=", "self", ".", "proj", "(", "x", ")", "\n", "x", "=", "self", ".", "proj_drop", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformerBlock.__init__": [[197, 240], ["torch.Module.__init__", "norm_layer", "hcswin.WindowAttention", "norm_layer", "int", "hcswin.Mlp", "timm.models.layers.DropPath", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity", "timm.models.layers.to_2tuple"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dim", ",", "\n", "num_heads", ",", "\n", "window_size", "=", "7", ",", "\n", "shift_size", "=", "0", ",", "\n", "mlp_ratio", "=", "4.0", ",", "\n", "qkv_bias", "=", "True", ",", "\n", "qk_scale", "=", "None", ",", "\n", "drop", "=", "0.0", ",", "\n", "attn_drop", "=", "0.0", ",", "\n", "drop_path", "=", "0.0", ",", "\n", "act_layer", "=", "nn", ".", "GELU", ",", "\n", "norm_layer", "=", "nn", ".", "LayerNorm", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "self", ".", "window_size", "=", "window_size", "\n", "self", ".", "shift_size", "=", "shift_size", "\n", "self", ".", "mlp_ratio", "=", "mlp_ratio", "\n", "assert", "0", "<=", "self", ".", "shift_size", "<", "self", ".", "window_size", ",", "\"shift_size must in 0-window_size\"", "\n", "\n", "self", ".", "norm1", "=", "norm_layer", "(", "dim", ")", "\n", "self", ".", "attn", "=", "WindowAttention", "(", "\n", "dim", ",", "\n", "window_size", "=", "to_2tuple", "(", "self", ".", "window_size", ")", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "qkv_bias", "=", "qkv_bias", ",", "\n", "qk_scale", "=", "qk_scale", ",", "\n", "attn_drop", "=", "attn_drop", ",", "\n", "proj_drop", "=", "drop", ",", "\n", ")", "\n", "\n", "self", ".", "drop_path", "=", "DropPath", "(", "drop_path", ")", "if", "drop_path", ">", "0.0", "else", "nn", ".", "Identity", "(", ")", "\n", "self", ".", "norm2", "=", "norm_layer", "(", "dim", ")", "\n", "mlp_hidden_dim", "=", "int", "(", "dim", "*", "mlp_ratio", ")", "\n", "self", ".", "mlp", "=", "Mlp", "(", "\n", "in_features", "=", "dim", ",", "hidden_features", "=", "mlp_hidden_dim", ",", "act_layer", "=", "act_layer", ",", "drop", "=", "drop", "\n", ")", "\n", "\n", "self", ".", "H", "=", "None", "\n", "self", ".", "W", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformerBlock.forward": [[241, 302], ["hcswin.SwinTransformerBlock.norm1", "x[].contiguous.view", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "hcswin.window_partition", "x_windows.view.view.view", "hcswin.SwinTransformerBlock.attn", "attn_windows.view.view.view", "hcswin.window_reverse", "x[].contiguous.view", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "x[].contiguous", "hcswin.SwinTransformerBlock.drop_path", "hcswin.SwinTransformerBlock.drop_path", "hcswin.SwinTransformerBlock.mlp", "hcswin.SwinTransformerBlock.norm2"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.window_partition", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.window_reverse"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask_matrix", ")", ":", "\n", "        ", "\"\"\"Forward function.\n        Args:\n            x: Input feature, tensor size (B, H*W, C).\n            H, W: Spatial resolution of the input feature.\n            mask_matrix: Attention mask for cyclic shift.\n        \"\"\"", "\n", "B", ",", "L", ",", "C", "=", "x", ".", "shape", "\n", "H", ",", "W", "=", "self", ".", "H", ",", "self", ".", "W", "\n", "assert", "L", "==", "H", "*", "W", ",", "\"input feature has wrong size\"", "\n", "\n", "shortcut", "=", "x", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "H", ",", "W", ",", "C", ")", "\n", "\n", "# pad feature maps to multiples of window size", "\n", "pad_l", "=", "pad_t", "=", "0", "\n", "pad_r", "=", "(", "self", ".", "window_size", "-", "W", "%", "self", ".", "window_size", ")", "%", "self", ".", "window_size", "\n", "pad_b", "=", "(", "self", ".", "window_size", "-", "H", "%", "self", ".", "window_size", ")", "%", "self", ".", "window_size", "\n", "x", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "0", ",", "pad_l", ",", "pad_r", ",", "pad_t", ",", "pad_b", ")", ")", "\n", "_", ",", "Hp", ",", "Wp", ",", "_", "=", "x", ".", "shape", "\n", "\n", "# cyclic shift", "\n", "if", "self", ".", "shift_size", ">", "0", ":", "\n", "            ", "shifted_x", "=", "torch", ".", "roll", "(", "x", ",", "shifts", "=", "(", "-", "self", ".", "shift_size", ",", "-", "self", ".", "shift_size", ")", ",", "dims", "=", "(", "1", ",", "2", ")", ")", "\n", "attn_mask", "=", "mask_matrix", "\n", "", "else", ":", "\n", "            ", "shifted_x", "=", "x", "\n", "attn_mask", "=", "None", "\n", "\n", "# partition windows", "\n", "", "x_windows", "=", "window_partition", "(", "\n", "shifted_x", ",", "self", ".", "window_size", "\n", ")", "# nW*B, window_size, window_size, C", "\n", "x_windows", "=", "x_windows", ".", "view", "(", "\n", "-", "1", ",", "self", ".", "window_size", "*", "self", ".", "window_size", ",", "C", "\n", ")", "# nW*B, window_size*window_size, C", "\n", "\n", "# W-MSA/SW-MSA", "\n", "attn_windows", "=", "self", ".", "attn", "(", "x_windows", ",", "mask", "=", "attn_mask", ")", "# nW*B, window_size*window_size, C", "\n", "\n", "# merge windows", "\n", "attn_windows", "=", "attn_windows", ".", "view", "(", "-", "1", ",", "self", ".", "window_size", ",", "self", ".", "window_size", ",", "C", ")", "\n", "shifted_x", "=", "window_reverse", "(", "attn_windows", ",", "self", ".", "window_size", ",", "Hp", ",", "Wp", ")", "# B H' W' C", "\n", "\n", "# reverse cyclic shift", "\n", "if", "self", ".", "shift_size", ">", "0", ":", "\n", "            ", "x", "=", "torch", ".", "roll", "(", "shifted_x", ",", "shifts", "=", "(", "self", ".", "shift_size", ",", "self", ".", "shift_size", ")", ",", "dims", "=", "(", "1", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "shifted_x", "\n", "\n", "", "if", "pad_r", ">", "0", "or", "pad_b", ">", "0", ":", "\n", "            ", "x", "=", "x", "[", ":", ",", ":", "H", ",", ":", "W", ",", ":", "]", ".", "contiguous", "(", ")", "\n", "\n", "", "x", "=", "x", ".", "view", "(", "B", ",", "H", "*", "W", ",", "C", ")", "\n", "\n", "# FFN", "\n", "x", "=", "shortcut", "+", "self", ".", "drop_path", "(", "x", ")", "\n", "x", "=", "x", "+", "self", ".", "drop_path", "(", "self", ".", "mlp", "(", "self", ".", "norm2", "(", "x", ")", ")", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.PatchMerging.__init__": [[311, 316], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "norm_layer"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "self", ",", "dim", ",", "norm_layer", "=", "nn", ".", "LayerNorm", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "reduction", "=", "nn", ".", "Linear", "(", "4", "*", "dim", ",", "2", "*", "dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "norm", "=", "norm_layer", "(", "4", "*", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.PatchMerging.forward": [[317, 344], ["torch.pad.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.pad.view", "hcswin.PatchMerging.norm", "hcswin.PatchMerging.reduction", "torch.pad", "torch.pad", "torch.pad", "torch.pad"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "H", ",", "W", ")", ":", "\n", "        ", "\"\"\"Forward function.\n        Args:\n            x: Input feature, tensor size (B, H*W, C).\n            H, W: Spatial resolution of the input feature.\n        \"\"\"", "\n", "B", ",", "L", ",", "C", "=", "x", ".", "shape", "\n", "assert", "L", "==", "H", "*", "W", ",", "\"input feature has wrong size\"", "\n", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "H", ",", "W", ",", "C", ")", "\n", "\n", "# padding", "\n", "pad_input", "=", "(", "H", "%", "2", "==", "1", ")", "or", "(", "W", "%", "2", "==", "1", ")", "\n", "if", "pad_input", ":", "\n", "            ", "x", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "0", ",", "0", ",", "W", "%", "2", ",", "0", ",", "H", "%", "2", ")", ")", "\n", "\n", "", "x0", "=", "x", "[", ":", ",", "0", ":", ":", "2", ",", "0", ":", ":", "2", ",", ":", "]", "# B H/2 W/2 C", "\n", "x1", "=", "x", "[", ":", ",", "1", ":", ":", "2", ",", "0", ":", ":", "2", ",", ":", "]", "# B H/2 W/2 C", "\n", "x2", "=", "x", "[", ":", ",", "0", ":", ":", "2", ",", "1", ":", ":", "2", ",", ":", "]", "# B H/2 W/2 C", "\n", "x3", "=", "x", "[", ":", ",", "1", ":", ":", "2", ",", "1", ":", ":", "2", ",", ":", "]", "# B H/2 W/2 C", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x0", ",", "x1", ",", "x2", ",", "x3", "]", ",", "-", "1", ")", "# B H/2 W/2 4*C", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "-", "1", ",", "4", "*", "C", ")", "# B H/2*W/2 4*C", "\n", "\n", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "x", "=", "self", ".", "reduction", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.BasicLayer.__init__": [[364, 418], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "downsample", "hcswin.SwinTransformerBlock", "utils.Clustering", "range", "isinstance"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dim", ",", "\n", "depth", ",", "\n", "num_heads", ",", "\n", "window_size", "=", "7", ",", "\n", "mlp_ratio", "=", "4.0", ",", "\n", "qkv_bias", "=", "True", ",", "\n", "qk_scale", "=", "None", ",", "\n", "drop", "=", "0.0", ",", "\n", "attn_drop", "=", "0.0", ",", "\n", "drop_path", "=", "0.0", ",", "\n", "norm_layer", "=", "nn", ".", "LayerNorm", ",", "\n", "downsample", "=", "None", ",", "\n", "use_checkpoint", "=", "False", ",", "\n", "emb_dim", "=", "128", ",", "\n", "clustering", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "window_size", "=", "window_size", "\n", "self", ".", "shift_size", "=", "window_size", "//", "2", "\n", "self", ".", "depth", "=", "depth", "\n", "self", ".", "use_checkpoint", "=", "use_checkpoint", "\n", "\n", "# build blocks", "\n", "self", ".", "blocks", "=", "nn", ".", "ModuleList", "(", "\n", "[", "\n", "SwinTransformerBlock", "(", "\n", "dim", "=", "dim", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "window_size", "=", "window_size", ",", "\n", "shift_size", "=", "0", "if", "(", "i", "%", "2", "==", "0", ")", "else", "window_size", "//", "2", ",", "\n", "mlp_ratio", "=", "mlp_ratio", ",", "\n", "qkv_bias", "=", "qkv_bias", ",", "\n", "qk_scale", "=", "qk_scale", ",", "\n", "drop", "=", "drop", ",", "\n", "attn_drop", "=", "attn_drop", ",", "\n", "drop_path", "=", "drop_path", "[", "i", "]", "if", "isinstance", "(", "drop_path", ",", "list", ")", "else", "drop_path", ",", "\n", "norm_layer", "=", "norm_layer", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "depth", ")", "\n", "]", "\n", ")", "\n", "\n", "# patch merging layer with clustering", "\n", "if", "downsample", "is", "not", "None", ":", "\n", "            ", "self", ".", "downsample", "=", "downsample", "(", "dim", "=", "dim", ",", "norm_layer", "=", "norm_layer", ")", "\n", "if", "clustering", ":", "\n", "                ", "self", ".", "clustering", "=", "Clustering", "(", "dim", ",", "2", "*", "dim", ",", "emb_dim", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "clustering", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "downsample", "=", "None", "\n", "self", ".", "clustering", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.BasicLayer.forward": [[419, 476], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "hcswin.window_partition", "mask_windows.view.view.view", "attn_mask.masked_fill().masked_fill.masked_fill().masked_fill.masked_fill().masked_fill", "int", "int", "slice", "slice", "slice", "slice", "slice", "slice", "mask_windows.view.view.unsqueeze", "mask_windows.view.view.unsqueeze", "float", "hcswin.BasicLayer.downsample", "x_down.flatten().transpose().contiguous.flatten().transpose().contiguous.transpose().reshape().contiguous", "blk.transpose().reshape().contiguous", "blk.flatten().transpose().contiguous", "x_down.flatten().transpose().contiguous.flatten().transpose().contiguous.flatten().transpose().contiguous", "numpy.ceil", "numpy.ceil", "attn_mask.masked_fill().masked_fill.masked_fill().masked_fill.masked_fill", "torch.checkpoint", "torch.checkpoint", "torch.checkpoint", "torch.checkpoint", "blk", "hcswin.BasicLayer.clustering", "float", "x_down.flatten().transpose().contiguous.flatten().transpose().contiguous.transpose().reshape", "blk.transpose().reshape", "blk.flatten().transpose", "x_down.flatten().transpose().contiguous.flatten().transpose().contiguous.flatten().transpose", "x_down.flatten().transpose().contiguous.flatten().transpose().contiguous.transpose", "blk.transpose", "blk.flatten", "x_down.flatten().transpose().contiguous.flatten().transpose().contiguous.flatten"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.window_partition"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "H", ",", "W", ")", ":", "\n", "        ", "\"\"\"Forward function.\n        Args:\n            x: Input feature, tensor size (B, H*W, C).\n            H, W: Spatial resolution of the input feature.\n        \"\"\"", "\n", "\n", "# calculate attention mask for SW-MSA", "\n", "Hp", "=", "int", "(", "np", ".", "ceil", "(", "H", "/", "self", ".", "window_size", ")", ")", "*", "self", ".", "window_size", "\n", "Wp", "=", "int", "(", "np", ".", "ceil", "(", "W", "/", "self", ".", "window_size", ")", ")", "*", "self", ".", "window_size", "\n", "img_mask", "=", "torch", ".", "zeros", "(", "(", "1", ",", "Hp", ",", "Wp", ",", "1", ")", ",", "device", "=", "x", ".", "device", ")", "# 1 Hp Wp 1", "\n", "h_slices", "=", "(", "\n", "slice", "(", "0", ",", "-", "self", ".", "window_size", ")", ",", "\n", "slice", "(", "-", "self", ".", "window_size", ",", "-", "self", ".", "shift_size", ")", ",", "\n", "slice", "(", "-", "self", ".", "shift_size", ",", "None", ")", ",", "\n", ")", "\n", "w_slices", "=", "(", "\n", "slice", "(", "0", ",", "-", "self", ".", "window_size", ")", ",", "\n", "slice", "(", "-", "self", ".", "window_size", ",", "-", "self", ".", "shift_size", ")", ",", "\n", "slice", "(", "-", "self", ".", "shift_size", ",", "None", ")", ",", "\n", ")", "\n", "cnt", "=", "0", "\n", "for", "h", "in", "h_slices", ":", "\n", "            ", "for", "w", "in", "w_slices", ":", "\n", "                ", "img_mask", "[", ":", ",", "h", ",", "w", ",", ":", "]", "=", "cnt", "\n", "cnt", "+=", "1", "\n", "\n", "", "", "mask_windows", "=", "window_partition", "(", "\n", "img_mask", ",", "self", ".", "window_size", "\n", ")", "# nW, window_size, window_size, 1", "\n", "mask_windows", "=", "mask_windows", ".", "view", "(", "-", "1", ",", "self", ".", "window_size", "*", "self", ".", "window_size", ")", "\n", "attn_mask", "=", "mask_windows", ".", "unsqueeze", "(", "1", ")", "-", "mask_windows", ".", "unsqueeze", "(", "2", ")", "\n", "attn_mask", "=", "attn_mask", ".", "masked_fill", "(", "attn_mask", "!=", "0", ",", "float", "(", "-", "100.0", ")", ")", ".", "masked_fill", "(", "\n", "attn_mask", "==", "0", ",", "float", "(", "0.0", ")", "\n", ")", "\n", "\n", "for", "blk", "in", "self", ".", "blocks", ":", "\n", "            ", "blk", ".", "H", ",", "blk", ".", "W", "=", "H", ",", "W", "\n", "if", "self", ".", "use_checkpoint", ":", "\n", "                ", "x", "=", "checkpoint", ".", "checkpoint", "(", "blk", ",", "x", ",", "attn_mask", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "blk", "(", "x", ",", "attn_mask", ")", "\n", "", "", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "b", ",", "_", ",", "c", "=", "x", ".", "shape", "\n", "Wh", ",", "Ww", "=", "(", "H", "+", "1", ")", "//", "2", ",", "(", "W", "+", "1", ")", "//", "2", "\n", "x_down", "=", "self", ".", "downsample", "(", "x", ",", "H", ",", "W", ")", "\n", "x_down", "=", "x_down", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "b", ",", "2", "*", "c", ",", "Wh", ",", "Ww", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "b", ",", "c", ",", "H", ",", "W", ")", ".", "contiguous", "(", ")", "\n", "if", "self", ".", "clustering", "is", "not", "None", ":", "\n", "                ", "assign", "=", "self", ".", "clustering", "(", "x", ",", "x_down", ")", "\n", "", "else", ":", "\n", "                ", "assign", "=", "None", "\n", "", "x", "=", "x", ".", "flatten", "(", "2", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "x_down", "=", "x_down", ".", "flatten", "(", "2", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "return", "x", ",", "H", ",", "W", ",", "x_down", ",", "Wh", ",", "Ww", ",", "assign", "\n", "", "else", ":", "\n", "            ", "return", "x", ",", "H", ",", "W", ",", "x", ",", "H", ",", "W", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.PatchEmbed.__init__": [[487, 500], ["torch.Module.__init__", "timm.models.layers.to_2tuple", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "norm_layer"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["def", "__init__", "(", "self", ",", "patch_size", "=", "4", ",", "in_chans", "=", "3", ",", "embed_dim", "=", "96", ",", "norm_layer", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "patch_size", "=", "to_2tuple", "(", "patch_size", ")", "\n", "self", ".", "patch_size", "=", "patch_size", "\n", "\n", "self", ".", "in_chans", "=", "in_chans", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "\n", "self", ".", "proj", "=", "nn", ".", "Conv2d", "(", "in_chans", ",", "embed_dim", ",", "kernel_size", "=", "patch_size", ",", "stride", "=", "patch_size", ")", "\n", "if", "norm_layer", "is", "not", "None", ":", "\n", "            ", "self", ".", "norm", "=", "norm_layer", "(", "embed_dim", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "norm", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.PatchEmbed.forward": [[501, 518], ["x.transpose().view.transpose().view.size", "hcswin.PatchEmbed.proj", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "x.transpose().view.transpose().view.flatten().transpose", "hcswin.PatchEmbed.norm", "x.transpose().view.transpose().view.transpose().view", "x.transpose().view.transpose().view.size", "x.transpose().view.transpose().view.size", "x.transpose().view.transpose().view.flatten", "x.transpose().view.transpose().view.transpose"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "# padding", "\n", "_", ",", "_", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "if", "W", "%", "self", ".", "patch_size", "[", "1", "]", "!=", "0", ":", "\n", "            ", "x", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "self", ".", "patch_size", "[", "1", "]", "-", "W", "%", "self", ".", "patch_size", "[", "1", "]", ")", ")", "\n", "", "if", "H", "%", "self", ".", "patch_size", "[", "0", "]", "!=", "0", ":", "\n", "            ", "x", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "0", ",", "0", ",", "self", ".", "patch_size", "[", "0", "]", "-", "H", "%", "self", ".", "patch_size", "[", "0", "]", ")", ")", "\n", "\n", "", "x", "=", "self", ".", "proj", "(", "x", ")", "# B C Wh Ww", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "Wh", ",", "Ww", "=", "x", ".", "size", "(", "2", ")", ",", "x", ".", "size", "(", "3", ")", "\n", "x", "=", "x", ".", "flatten", "(", "2", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "x", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", ".", "view", "(", "-", "1", ",", "self", ".", "embed_dim", ",", "Wh", ",", "Ww", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer.__init__": [[548, 650], ["torch.Module.__init__", "len", "hcswin.PatchEmbed", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "hcswin.SwinTransformer._freeze_stages", "timm.models.layers.to_2tuple", "timm.models.layers.to_2tuple", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "timm.models.layers.trunc_normal_", "x.item", "hcswin.BasicLayer", "hcswin.SwinTransformer.layers.append", "int", "norm_layer", "hcswin.SwinTransformer.add_module", "utils.TransformerEnc", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "range", "sum", "int", "sum", "sum"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer._freeze_stages"], ["def", "__init__", "(", "\n", "self", ",", "\n", "pretrain_img_size", "=", "224", ",", "\n", "patch_size", "=", "4", ",", "\n", "in_chans", "=", "3", ",", "\n", "embed_dim", "=", "96", ",", "\n", "depths", "=", "[", "2", ",", "2", ",", "6", ",", "2", "]", ",", "\n", "num_heads", "=", "[", "3", ",", "6", ",", "12", ",", "24", "]", ",", "\n", "window_size", "=", "7", ",", "\n", "mlp_ratio", "=", "4.0", ",", "\n", "qkv_bias", "=", "True", ",", "\n", "qk_scale", "=", "None", ",", "\n", "drop_rate", "=", "0.0", ",", "\n", "attn_drop_rate", "=", "0.0", ",", "\n", "drop_path_rate", "=", "0.2", ",", "\n", "norm_layer", "=", "nn", ".", "LayerNorm", ",", "\n", "ape", "=", "False", ",", "\n", "patch_norm", "=", "True", ",", "\n", "out_indices", "=", "(", "3", ",", ")", ",", "\n", "frozen_stages", "=", "-", "1", ",", "\n", "use_checkpoint", "=", "False", ",", "\n", "hierarchical_level", "=", "3", ",", "\n", "aux", "=", "'none'", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "hierarchical_level", "<=", "3", "\n", "self", ".", "level", "=", "hierarchical_level", "\n", "\n", "self", ".", "pretrain_img_size", "=", "pretrain_img_size", "\n", "self", ".", "num_layers", "=", "len", "(", "depths", ")", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "self", ".", "ape", "=", "ape", "\n", "self", ".", "patch_norm", "=", "patch_norm", "\n", "self", ".", "out_indices", "=", "out_indices", "\n", "self", ".", "frozen_stages", "=", "frozen_stages", "\n", "\n", "# split image into non-overlapping patches", "\n", "self", ".", "patch_embed", "=", "PatchEmbed", "(", "\n", "patch_size", "=", "patch_size", ",", "\n", "in_chans", "=", "in_chans", ",", "\n", "embed_dim", "=", "embed_dim", ",", "\n", "norm_layer", "=", "norm_layer", "if", "self", ".", "patch_norm", "else", "None", ",", "\n", ")", "\n", "\n", "# absolute position embedding", "\n", "if", "self", ".", "ape", ":", "\n", "            ", "pretrain_img_size", "=", "to_2tuple", "(", "pretrain_img_size", ")", "\n", "patch_size", "=", "to_2tuple", "(", "patch_size", ")", "\n", "patches_resolution", "=", "[", "\n", "pretrain_img_size", "[", "0", "]", "//", "patch_size", "[", "0", "]", ",", "\n", "pretrain_img_size", "[", "1", "]", "//", "patch_size", "[", "1", "]", ",", "\n", "]", "\n", "\n", "self", ".", "absolute_pos_embed", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "zeros", "(", "1", ",", "embed_dim", ",", "patches_resolution", "[", "0", "]", ",", "patches_resolution", "[", "1", "]", ")", "\n", ")", "\n", "trunc_normal_", "(", "self", ".", "absolute_pos_embed", ",", "std", "=", "0.02", ")", "\n", "\n", "", "self", ".", "pos_drop", "=", "nn", ".", "Dropout", "(", "p", "=", "drop_rate", ")", "\n", "\n", "# stochastic depth", "\n", "dpr", "=", "[", "\n", "x", ".", "item", "(", ")", "for", "x", "in", "torch", ".", "linspace", "(", "0", ",", "drop_path_rate", ",", "sum", "(", "depths", ")", ")", "\n", "]", "# stochastic depth decay rule", "\n", "\n", "\n", "# build layers", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i_layer", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "layer", "=", "BasicLayer", "(", "\n", "dim", "=", "int", "(", "embed_dim", "*", "2", "**", "i_layer", ")", ",", "\n", "depth", "=", "depths", "[", "i_layer", "]", ",", "\n", "num_heads", "=", "num_heads", "[", "i_layer", "]", ",", "\n", "window_size", "=", "window_size", ",", "\n", "mlp_ratio", "=", "mlp_ratio", ",", "\n", "qkv_bias", "=", "qkv_bias", ",", "\n", "qk_scale", "=", "qk_scale", ",", "\n", "drop", "=", "drop_rate", ",", "\n", "attn_drop", "=", "attn_drop_rate", ",", "\n", "drop_path", "=", "dpr", "[", "sum", "(", "depths", "[", ":", "i_layer", "]", ")", ":", "sum", "(", "depths", "[", ":", "i_layer", "+", "1", "]", ")", "]", ",", "\n", "norm_layer", "=", "norm_layer", ",", "\n", "downsample", "=", "PatchMerging", "if", "(", "i_layer", "<", "self", ".", "num_layers", "-", "1", ")", "else", "None", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "clustering", "=", "3", "-", "i_layer", "<=", "hierarchical_level", "\n", ")", "\n", "self", ".", "layers", ".", "append", "(", "layer", ")", "\n", "\n", "", "num_features", "=", "[", "int", "(", "embed_dim", "*", "2", "**", "i", ")", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", "]", "\n", "self", ".", "num_features", "=", "num_features", "\n", "\n", "# add a norm layer for each output", "\n", "for", "i_layer", "in", "out_indices", ":", "\n", "            ", "layer", "=", "norm_layer", "(", "num_features", "[", "i_layer", "]", ")", "\n", "layer_name", "=", "f\"norm{i_layer}\"", "\n", "self", ".", "add_module", "(", "layer_name", ",", "layer", ")", "\n", "\n", "", "if", "aux", "==", "'transformer'", ":", "\n", "            ", "self", ".", "aux", "=", "TransformerEnc", "(", "self", ".", "num_features", "[", "-", "1", "]", ",", "256", ",", "8", ",", "6", ",", "2048", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "aux", "=", "None", "\n", "\n", "", "self", ".", "_freeze_stages", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer._freeze_stages": [[651, 667], ["hcswin.SwinTransformer.patch_embed.eval", "hcswin.SwinTransformer.patch_embed.parameters", "hcswin.SwinTransformer.pos_drop.eval", "range", "m.eval", "m.parameters"], "methods", ["None"], ["", "def", "_freeze_stages", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "frozen_stages", ">=", "0", ":", "\n", "            ", "self", ".", "patch_embed", ".", "eval", "(", ")", "\n", "for", "param", "in", "self", ".", "patch_embed", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "if", "self", ".", "frozen_stages", ">=", "1", "and", "self", ".", "ape", ":", "\n", "            ", "self", ".", "absolute_pos_embed", ".", "requires_grad", "=", "False", "\n", "\n", "", "if", "self", ".", "frozen_stages", ">=", "2", ":", "\n", "            ", "self", ".", "pos_drop", ".", "eval", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "self", ".", "frozen_stages", "-", "1", ")", ":", "\n", "                ", "m", "=", "self", ".", "layers", "[", "i", "]", "\n", "m", ".", "eval", "(", ")", "\n", "for", "param", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                    ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer.init_weights": [[668, 683], ["isinstance", "timm.models.layers.trunc_normal_", "isinstance", "isinstance", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "", "", "", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights in backbone.\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Defaults to None.\n        \"\"\"", "\n", "\n", "def", "_init_weights", "(", "m", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "trunc_normal_", "(", "m", ".", "weight", ",", "std", "=", "0.02", ")", "\n", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", "and", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "LayerNorm", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer.forward": [[684, 718], ["hcswin.SwinTransformer.patch_embed", "hcswin.SwinTransformer.pos_drop", "range", "x.flatten().transpose.flatten().transpose.size", "x.flatten().transpose.flatten().transpose.size", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "x.flatten().transpose.flatten().transpose.flatten().transpose", "layer", "hcswin.SwinTransformer.aux", "getattr", "getattr.", "getattr.view().permute().contiguous", "assigns.append", "x.flatten().transpose.flatten().transpose.flatten", "getattr.view().permute", "getattr.view"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "x", "=", "self", ".", "patch_embed", "(", "x", ")", "\n", "\n", "Wh", ",", "Ww", "=", "x", ".", "size", "(", "2", ")", ",", "x", ".", "size", "(", "3", ")", "\n", "if", "self", ".", "ape", ":", "\n", "# interpolate the position embedding to the corresponding size", "\n", "            ", "absolute_pos_embed", "=", "F", ".", "interpolate", "(", "\n", "self", ".", "absolute_pos_embed", ",", "size", "=", "(", "Wh", ",", "Ww", ")", ",", "mode", "=", "\"bicubic\"", "\n", ")", "\n", "x", "=", "(", "x", "+", "absolute_pos_embed", ")", ".", "flatten", "(", "2", ")", ".", "transpose", "(", "1", ",", "2", ")", "# B Wh*Ww C", "\n", "", "else", ":", "\n", "            ", "x", "=", "x", ".", "flatten", "(", "2", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "x", "=", "self", ".", "pos_drop", "(", "x", ")", "\n", "\n", "outs", "=", "{", "}", "\n", "assigns", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "layer", "=", "self", ".", "layers", "[", "i", "]", "\n", "x_out", ",", "H", ",", "W", ",", "x", ",", "Wh", ",", "Ww", ",", "assign", "=", "layer", "(", "x", ",", "Wh", ",", "Ww", ")", "\n", "\n", "if", "i", "in", "self", ".", "out_indices", ":", "\n", "                ", "norm_layer", "=", "getattr", "(", "self", ",", "f\"norm{i}\"", ")", "\n", "x_out", "=", "norm_layer", "(", "x_out", ")", "\n", "\n", "out", "=", "x_out", ".", "view", "(", "-", "1", ",", "H", ",", "W", ",", "self", ".", "num_features", "[", "i", "]", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "outs", "[", "\"res{}\"", ".", "format", "(", "i", "+", "2", ")", "]", "=", "out", "\n", "\n", "", "if", "assign", "is", "not", "None", ":", "\n", "                ", "assigns", ".", "append", "(", "assign", ")", "\n", "", "", "outs", "[", "'assign'", "]", "=", "assigns", "[", ":", ":", "-", "1", "]", "\n", "if", "self", ".", "aux", "is", "not", "None", ":", "\n", "            ", "outs", "[", "\"res{}\"", ".", "format", "(", "i", "+", "2", ")", "]", "=", "self", ".", "aux", "(", "outs", "[", "\"res{}\"", ".", "format", "(", "i", "+", "2", ")", "]", ")", "\n", "", "return", "outs", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer.train": [[719, 723], ["super().train", "hcswin.SwinTransformer._freeze_stages"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer.train", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.SwinTransformer._freeze_stages"], ["", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"Convert the model into training mode while keep layers freezed.\"\"\"", "\n", "super", "(", "SwinTransformer", ",", "self", ")", ".", "train", "(", "mode", ")", "\n", "self", ".", "_freeze_stages", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.HCSwinTransformer.__init__": [[727, 784], ["hcswin.SwinTransformer.__init__"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "\n", "        ", "pretrain_img_size", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "PRETRAIN_IMG_SIZE", "\n", "patch_size", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "PATCH_SIZE", "\n", "in_chans", "=", "3", "\n", "embed_dim", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "EMBED_DIM", "\n", "depths", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "DEPTHS", "\n", "num_heads", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "NUM_HEADS", "\n", "window_size", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "WINDOW_SIZE", "\n", "mlp_ratio", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "MLP_RATIO", "\n", "qkv_bias", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "QKV_BIAS", "\n", "qk_scale", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "QK_SCALE", "\n", "drop_rate", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "DROP_RATE", "\n", "attn_drop_rate", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "ATTN_DROP_RATE", "\n", "drop_path_rate", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "DROP_PATH_RATE", "\n", "norm_layer", "=", "nn", ".", "LayerNorm", "\n", "ape", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "APE", "\n", "patch_norm", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "PATCH_NORM", "\n", "use_checkpoint", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "USE_CHECKPOINT", "\n", "level", "=", "cfg", ".", "MODEL", ".", "HC", ".", "LEVEL", "\n", "aux", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "AUX", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "pretrain_img_size", ",", "\n", "patch_size", ",", "\n", "in_chans", ",", "\n", "embed_dim", ",", "\n", "depths", ",", "\n", "num_heads", ",", "\n", "window_size", ",", "\n", "mlp_ratio", ",", "\n", "qkv_bias", ",", "\n", "qk_scale", ",", "\n", "drop_rate", ",", "\n", "attn_drop_rate", ",", "\n", "drop_path_rate", ",", "\n", "norm_layer", ",", "\n", "ape", ",", "\n", "patch_norm", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "hierarchical_level", "=", "level", ",", "\n", "aux", "=", "aux", "\n", ")", "\n", "\n", "self", ".", "_out_features", "=", "cfg", ".", "MODEL", ".", "SWIN", ".", "OUT_FEATURES", "\n", "\n", "self", ".", "_out_feature_strides", "=", "{", "\n", "\"res2\"", ":", "4", ",", "\n", "\"res3\"", ":", "8", ",", "\n", "\"res4\"", ":", "16", ",", "\n", "\"res5\"", ":", "32", ",", "\n", "}", "\n", "self", ".", "_out_feature_channels", "=", "{", "\n", "\"res2\"", ":", "self", ".", "num_features", "[", "0", "]", ",", "\n", "\"res3\"", ":", "self", ".", "num_features", "[", "1", "]", ",", "\n", "\"res4\"", ":", "self", ".", "num_features", "[", "2", "]", ",", "\n", "\"res5\"", ":", "self", ".", "num_features", "[", "3", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.HCSwinTransformer.forward": [[786, 802], ["hcswin.SwinTransformer.forward", "super().forward.keys", "x.dim"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: Tensor of shape (N,C,H,W). H, W must be a multiple of ``self.size_divisibility``.\n        Returns:\n            dict[str->Tensor]: names and the corresponding features\n        \"\"\"", "\n", "assert", "(", "\n", "x", ".", "dim", "(", ")", "==", "4", "\n", ")", ",", "f\"SwinTransformer takes an input of shape (N, C, H, W). Got {x.shape} instead!\"", "\n", "outputs", "=", "{", "}", "\n", "y", "=", "super", "(", ")", ".", "forward", "(", "x", ")", "\n", "for", "k", "in", "y", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "in", "self", ".", "_out_features", "or", "'assign'", "in", "k", ":", "\n", "                ", "outputs", "[", "k", "]", "=", "y", "[", "k", "]", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.HCSwinTransformer.output_shape": [[803, 809], ["detectron2.modeling.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.HCSwinTransformer.size_divisibility": [[811, 814], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size_divisibility", "(", "self", ")", ":", "\n", "        ", "return", "32", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.window_partition": [[50, 62], ["x.view.view", "x.view.permute().contiguous().view", "x.view.permute().contiguous", "x.view.permute"], "function", ["None"], ["", "", "def", "window_partition", "(", "x", ",", "window_size", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        x: (B, H, W, C)\n        window_size (int): window size\n    Returns:\n        windows: (num_windows*B, window_size, window_size, C)\n    \"\"\"", "\n", "B", ",", "H", ",", "W", ",", "C", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "H", "//", "window_size", ",", "window_size", ",", "W", "//", "window_size", ",", "window_size", ",", "C", ")", "\n", "windows", "=", "x", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ",", "4", ",", "5", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "window_size", ",", "window_size", ",", "C", ")", "\n", "return", "windows", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.hcswin.window_reverse": [[64, 78], ["int", "windows.view", "x.permute().contiguous().view.permute().contiguous().view", "x.permute().contiguous().view.permute().contiguous", "x.permute().contiguous().view.permute"], "function", ["None"], ["", "def", "window_reverse", "(", "windows", ",", "window_size", ",", "H", ",", "W", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        windows: (num_windows*B, window_size, window_size, C)\n        window_size (int): Window size\n        H (int): Height of image\n        W (int): Width of image\n    Returns:\n        x: (B, H, W, C)\n    \"\"\"", "\n", "B", "=", "int", "(", "windows", ".", "shape", "[", "0", "]", "/", "(", "H", "*", "W", "/", "window_size", "/", "window_size", ")", ")", "\n", "x", "=", "windows", ".", "view", "(", "B", ",", "H", "//", "window_size", ",", "W", "//", "window_size", ",", "window_size", ",", "window_size", ",", "-", "1", ")", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ",", "4", ",", "5", ")", ".", "contiguous", "(", ")", ".", "view", "(", "B", ",", "H", ",", "W", ",", "-", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.Clustering.__init__": [[13, 24], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "utils.Clustering.register_parameter", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["    ", "def", "__init__", "(", "self", ",", "fine_dim", ",", "coarse_dim", ",", "emb_dim", ",", "temp", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fine_emb", "=", "nn", ".", "Conv2d", "(", "fine_dim", ",", "emb_dim", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "coarse_emb", "=", "nn", ".", "Conv2d", "(", "coarse_dim", ",", "emb_dim", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "fine_norm", "=", "nn", ".", "LayerNorm", "(", "fine_dim", ")", "\n", "self", ".", "coarse_norm", "=", "nn", ".", "LayerNorm", "(", "coarse_dim", ")", "\n", "self", ".", "register_parameter", "(", "'temp'", ",", "nn", ".", "Parameter", "(", "temp", "*", "torch", ".", "ones", "(", "1", ")", ")", ")", "\n", "self", ".", "emb_dim", "=", "emb_dim", "\n", "\n", "nn", ".", "init", ".", "xavier_normal_", "(", "self", ".", "fine_emb", ".", "weight", ")", "\n", "nn", ".", "init", ".", "xavier_normal_", "(", "self", ".", "coarse_emb", ".", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.Clustering.forward": [[25, 56], ["fine_feat.permute().reshape.permute().reshape.flatten().transpose().contiguous", "torch.normalize.flatten().transpose().contiguous", "utils.Clustering.fine_norm", "utils.Clustering.coarse_norm", "fine_feat.permute().reshape.permute().reshape.transpose().contiguous().reshape", "torch.normalize.transpose().contiguous().reshape", "utils.Clustering.fine_emb", "utils.Clustering.coarse_emb", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.unfold().reshape", "torch.unfold().reshape", "torch.unfold().reshape", "torch.unfold().reshape", "torch.unfold().reshape", "torch.unfold().reshape", "candidate_clusters.permute().reshape.permute().reshape.permute().reshape", "fine_feat.permute().reshape.permute().reshape.permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.bmm().reshape().permute().reshape", "torch.fold().reshape", "torch.fold().reshape", "torch.fold().reshape", "fine_feat.permute().reshape.permute().reshape.flatten().transpose", "torch.normalize.flatten().transpose", "fine_feat.permute().reshape.permute().reshape.transpose().contiguous", "torch.normalize.transpose().contiguous", "torch.unfold", "torch.unfold", "torch.unfold", "torch.unfold", "torch.unfold", "torch.unfold", "candidate_clusters.permute().reshape.permute().reshape.permute", "fine_feat.permute().reshape.permute().reshape.permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.fold", "torch.fold", "torch.fold", "fine_feat.permute().reshape.permute().reshape.flatten", "torch.normalize.flatten", "fine_feat.permute().reshape.permute().reshape.transpose", "torch.normalize.transpose", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm().reshape", "utils.Clustering.temp.abs", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "fine_feat", ",", "coarse_feat", ")", ":", "\n", "        ", "batch_size", ",", "n_channels", ",", "height", ",", "width", "=", "fine_feat", ".", "shape", "\n", "coarse_shape", "=", "coarse_feat", ".", "shape", "\n", "# pre-norm", "\n", "fine_feat", "=", "fine_feat", ".", "flatten", "(", "-", "2", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "coarse_feat", "=", "coarse_feat", ".", "flatten", "(", "-", "2", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "fine_feat", "=", "self", ".", "fine_norm", "(", "fine_feat", ")", "\n", "coarse_feat", "=", "self", ".", "coarse_norm", "(", "coarse_feat", ")", "\n", "fine_feat", "=", "fine_feat", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "reshape", "(", "batch_size", ",", "n_channels", ",", "height", ",", "width", ")", "\n", "coarse_feat", "=", "coarse_feat", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "reshape", "(", "*", "coarse_shape", ")", "\n", "# map features into K-dimension space", "\n", "fine_feat", "=", "self", ".", "fine_emb", "(", "fine_feat", ")", "\n", "coarse_feat", "=", "self", ".", "coarse_emb", "(", "coarse_feat", ")", "\n", "# normalize", "\n", "fine_feat", "=", "F", ".", "normalize", "(", "fine_feat", ",", "2", ",", "1", ")", "\n", "coarse_feat", "=", "F", ".", "normalize", "(", "coarse_feat", ",", "2", ",", "1", ")", "\n", "# get 9 candidate clusters and corresponding pixel features", "\n", "candidate_clusters", "=", "F", ".", "unfold", "(", "coarse_feat", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ".", "reshape", "(", "batch_size", ",", "self", ".", "emb_dim", ",", "9", ",", "-", "1", ")", "\n", "fine_feat", "=", "F", ".", "unfold", "(", "fine_feat", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", ".", "reshape", "(", "batch_size", ",", "self", ".", "emb_dim", ",", "4", ",", "-", "1", ")", "\n", "# calculate similarities", "\n", "candidate_clusters", "=", "candidate_clusters", ".", "permute", "(", "0", ",", "3", ",", "2", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "9", ",", "self", ".", "emb_dim", ")", "\n", "fine_feat", "=", "fine_feat", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "emb_dim", ",", "4", ")", "\n", "similarities", "=", "torch", ".", "bmm", "(", "candidate_clusters", ",", "fine_feat", ")", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "9", ",", "4", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "batch_size", "*", "9", ",", "4", ",", "-", "1", ")", "\n", "# similarities = torch.einsum('bkcn,bkpn->bcpn', (candidate_clusters, fine_feat)).reshape(batch_size*9, 4, -1)", "\n", "similarities", "=", "F", ".", "fold", "(", "similarities", ",", "(", "height", ",", "width", ")", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", ".", "reshape", "(", "batch_size", ",", "9", ",", "height", ",", "width", ")", "\n", "# normalize", "\n", "# mask zero padding regions by using the fact that the inner product is zero", "\n", "mask", "=", "-", "1e12", "*", "(", "similarities", "==", "0", ")", ".", "float", "(", ")", "\n", "# soft_assignment = (similarities * self.inv_temp + mask).softmax(1)", "\n", "soft_assignment", "=", "(", "similarities", "/", "(", "1e-8", "+", "self", ".", "temp", ".", "abs", "(", ")", ")", "+", "mask", ")", ".", "softmax", "(", "1", ")", "\n", "return", "soft_assignment", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.DeformConv.__init__": [[74, 81], ["torch.Module.__init__", "detectron2.layers.ModulatedDeformConv", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "int"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_c", ",", "out_c", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "deform", "=", "ModulatedDeformConv", "(", "in_c", ",", "out_c", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "stride", "=", "stride", ")", "\n", "self", ".", "offset", "=", "nn", ".", "Conv2d", "(", "in_c", ",", "int", "(", "3", "*", "kernel_size", "**", "2", ")", ",", "3", ",", "padding", "=", "1", ",", "stride", "=", "stride", ")", "\n", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "offset", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "offset", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.DeformConv.forward": [[82, 90], ["utils.DeformConv.offset().float", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask.sigmoid.sigmoid.sigmoid", "utils.DeformConv.deform", "x.float", "utils.DeformConv.offset"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "offset_mask", "=", "self", ".", "offset", "(", "x", ")", ".", "float", "(", ")", "\n", "offset_x", ",", "offset_y", ",", "mask", "=", "torch", ".", "chunk", "(", "offset_mask", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "offset_x", ",", "offset_y", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "mask", ".", "sigmoid", "(", ")", "\n", "out", "=", "self", ".", "deform", "(", "x", ".", "float", "(", ")", ",", "offset", ",", "mask", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc.__init__": [[93, 114], ["torch.Module.__init__", "transformer_decoder.position_encoding.PositionEmbeddingSine", "torch.Sequential", "torch.Sequential", "torch.Sequential", "transformer_decoder.transformer.TransformerEncoderLayer", "transformer_decoder.transformer.TransformerEncoder", "utils.TransformerEnc._reset_parameters", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__", "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc._reset_parameters"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "conv_dim", ",", "\n", "nhead", ",", "\n", "num_encoder_layers", ",", "\n", "dim_feedforward", ",", "\n", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "\n", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pe_layer", "=", "PositionEmbeddingSine", "(", "conv_dim", "//", "2", ",", "normalize", "=", "True", ")", "\n", "self", ".", "input_proj", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "in_channels", ",", "conv_dim", ",", "kernel_size", "=", "1", ")", ",", "nn", ".", "GroupNorm", "(", "32", ",", "conv_dim", ")", ")", "\n", "\n", "encoder_layer", "=", "TransformerEncoderLayer", "(", "\n", "conv_dim", ",", "nhead", ",", "dim_feedforward", ",", "dropout", ",", "activation", ",", "normalize_before", "\n", ")", "\n", "encoder_norm", "=", "nn", ".", "LayerNorm", "(", "conv_dim", ")", "if", "normalize_before", "else", "None", "\n", "self", ".", "encoder", "=", "TransformerEncoder", "(", "encoder_layer", ",", "num_encoder_layers", ",", "encoder_norm", ")", "\n", "\n", "self", ".", "_reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc._reset_parameters": [[115, 119], ["utils.TransformerEnc.parameters", "p.dim", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_"], "methods", ["None"], ["", "def", "_reset_parameters", "(", "self", ")", ":", "\n", "        ", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.TransformerEnc.forward": [[120, 128], ["utils.TransformerEnc.input_proj", "utils.TransformerEnc.pe_layer", "x.flatten().permute.flatten().permute.flatten().permute", "pos.flatten().permute.flatten().permute.flatten().permute", "utils.TransformerEnc.encoder", "utils.TransformerEnc.permute().view", "x.flatten().permute.flatten().permute.flatten", "pos.flatten().permute.flatten().permute.flatten", "utils.TransformerEnc.permute"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "input_proj", "(", "x", ")", "\n", "pos", "=", "self", ".", "pe_layer", "(", "x", ")", "\n", "bs", ",", "c", ",", "h", ",", "w", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "flatten", "(", "2", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "pos", "=", "pos", ".", "flatten", "(", "2", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "memory", "=", "self", ".", "encoder", "(", "x", ",", "pos", "=", "pos", ")", "\n", "return", "memory", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "view", "(", "bs", ",", "c", ",", "h", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.backbone.utils.cluster_based_upsampling": [[58, 71], ["torch.unfold().reshape", "torch.unfold().reshape", "candidate_clusters.permute().reshape.permute().reshape", "A.permute().reshape.permute().reshape", "torch.bmm().reshape().permute().contiguous", "torch.bmm().reshape().permute().contiguous", "torch.bmm().reshape().permute().contiguous", "torch.fold", "torch.unfold", "torch.unfold", "candidate_clusters.permute().reshape.permute", "A.permute().reshape.permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm().reshape", "torch.bmm", "torch.bmm", "torch.bmm"], "function", ["None"], ["", "", "def", "cluster_based_upsampling", "(", "x", ",", "A", ")", ":", "\n", "    ", "batch_size", ",", "_", ",", "height", ",", "width", "=", "A", ".", "shape", "\n", "n_channels", "=", "x", ".", "shape", "[", "1", "]", "\n", "# get 9 candidate clusters and corresponding assignments", "\n", "candidate_clusters", "=", "F", ".", "unfold", "(", "x", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ".", "reshape", "(", "batch_size", ",", "n_channels", ",", "9", ",", "-", "1", ")", "\n", "A", "=", "F", ".", "unfold", "(", "A", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", ".", "reshape", "(", "batch_size", ",", "9", ",", "4", ",", "-", "1", ")", "\n", "# linear decoding", "\n", "candidate_clusters", "=", "candidate_clusters", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "n_channels", ",", "9", ")", "\n", "A", "=", "A", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "9", ",", "4", ")", "\n", "decoded_features", "=", "torch", ".", "bmm", "(", "candidate_clusters", ",", "A", ")", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "n_channels", "*", "4", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "# decoded_features = torch.einsum('bkcn,bcpn->bkpn', (candidate_clusters, A)).reshape(batch_size, n_channels * 4, -1)", "\n", "decoded_features", "=", "F", ".", "fold", "(", "decoded_features", ",", "(", "height", ",", "width", ")", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "return", "decoded_features", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_instance_new_baseline_dataset_mapper.COCOInstanceNewBaselineDatasetMapper.__init__": [[85, 108], ["logging.getLogger().info", "logging.getLogger", "str"], "methods", ["None"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "is_train", "=", "True", ",", "\n", "*", ",", "\n", "tfm_gens", ",", "\n", "image_format", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        Args:\n            is_train: for training or inference\n            augmentations: a list of augmentations or deterministic transforms to apply\n            tfm_gens: data augmentation\n            image_format: an image format supported by :func:`detection_utils.read_image`.\n        \"\"\"", "\n", "self", ".", "tfm_gens", "=", "tfm_gens", "\n", "logging", ".", "getLogger", "(", "__name__", ")", ".", "info", "(", "\n", "\"[COCOInstanceNewBaselineDatasetMapper] Full TransformGens used in training: {}\"", ".", "format", "(", "str", "(", "self", ".", "tfm_gens", ")", ")", "\n", ")", "\n", "\n", "self", ".", "img_format", "=", "image_format", "\n", "self", ".", "is_train", "=", "is_train", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_instance_new_baseline_dataset_mapper.COCOInstanceNewBaselineDatasetMapper.from_config": [[109, 120], ["coco_instance_new_baseline_dataset_mapper.build_transform_gen"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_panoptic_new_baseline_dataset_mapper.build_transform_gen"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "is_train", "=", "True", ")", ":", "\n", "# Build augmentation", "\n", "        ", "tfm_gens", "=", "build_transform_gen", "(", "cfg", ",", "is_train", ")", "\n", "\n", "ret", "=", "{", "\n", "\"is_train\"", ":", "is_train", ",", "\n", "\"tfm_gens\"", ":", "tfm_gens", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "}", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_instance_new_baseline_dataset_mapper.COCOInstanceNewBaselineDatasetMapper.__call__": [[121, 190], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "numpy.ones", "detectron2.data.transforms.apply_transform_gens", "detectron2.data.transforms.apply_segmentation", "torch.as_tensor", "torch.as_tensor", "detectron2.data.transforms.apply_segmentation.astype", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "copy.deepcopy.pop", "detectron2.data.detection_utils.annotations_to_instances", "detectron2.data.detection_utils.filter_empty_instances.gt_masks.get_bounding_boxes", "detectron2.data.detection_utils.filter_empty_instances", "hasattr", "detectron2.data.detection_utils.read_image.transpose", "anno.pop", "detectron2.data.detection_utils.transform_instance_annotations", "coco_instance_new_baseline_dataset_mapper.convert_coco_poly_to_mask", "copy.deepcopy.pop", "obj.get"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_instance_new_baseline_dataset_mapper.convert_coco_poly_to_mask", "home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.\n\n        Returns:\n            dict: a format that builtin models in detectron2 accept\n        \"\"\"", "\n", "dataset_dict", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "# it will be modified by code below", "\n", "image", "=", "utils", ".", "read_image", "(", "dataset_dict", "[", "\"file_name\"", "]", ",", "format", "=", "self", ".", "img_format", ")", "\n", "utils", ".", "check_image_size", "(", "dataset_dict", ",", "image", ")", "\n", "\n", "# TODO: get padding mask", "\n", "# by feeding a \"segmentation mask\" to the same transforms", "\n", "padding_mask", "=", "np", ".", "ones", "(", "image", ".", "shape", "[", ":", "2", "]", ")", "\n", "\n", "image", ",", "transforms", "=", "T", ".", "apply_transform_gens", "(", "self", ".", "tfm_gens", ",", "image", ")", "\n", "# the crop transformation has default padding value 0 for segmentation", "\n", "padding_mask", "=", "transforms", ".", "apply_segmentation", "(", "padding_mask", ")", "\n", "padding_mask", "=", "~", "padding_mask", ".", "astype", "(", "bool", ")", "\n", "\n", "image_shape", "=", "image", ".", "shape", "[", ":", "2", "]", "# h, w", "\n", "\n", "# Pytorch's dataloader is efficient on torch.Tensor due to shared-memory,", "\n", "# but not efficient on large generic data structures due to the use of pickle & mp.Queue.", "\n", "# Therefore it's important to use torch.Tensor.", "\n", "dataset_dict", "[", "\"image\"", "]", "=", "torch", ".", "as_tensor", "(", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "dataset_dict", "[", "\"padding_mask\"", "]", "=", "torch", ".", "as_tensor", "(", "np", ".", "ascontiguousarray", "(", "padding_mask", ")", ")", "\n", "\n", "if", "not", "self", ".", "is_train", ":", "\n", "# USER: Modify this if you want to keep them for some reason.", "\n", "            ", "dataset_dict", ".", "pop", "(", "\"annotations\"", ",", "None", ")", "\n", "return", "dataset_dict", "\n", "\n", "", "if", "\"annotations\"", "in", "dataset_dict", ":", "\n", "# USER: Modify this if you want to keep them for some reason.", "\n", "            ", "for", "anno", "in", "dataset_dict", "[", "\"annotations\"", "]", ":", "\n", "# Let's always keep mask", "\n", "# if not self.mask_on:", "\n", "#     anno.pop(\"segmentation\", None)", "\n", "                ", "anno", ".", "pop", "(", "\"keypoints\"", ",", "None", ")", "\n", "\n", "# USER: Implement additional transformations if you have other types of data", "\n", "", "annos", "=", "[", "\n", "utils", ".", "transform_instance_annotations", "(", "obj", ",", "transforms", ",", "image_shape", ")", "\n", "for", "obj", "in", "dataset_dict", ".", "pop", "(", "\"annotations\"", ")", "\n", "if", "obj", ".", "get", "(", "\"iscrowd\"", ",", "0", ")", "==", "0", "\n", "]", "\n", "# NOTE: does not support BitMask due to augmentation", "\n", "# Current BitMask cannot handle empty objects", "\n", "instances", "=", "utils", ".", "annotations_to_instances", "(", "annos", ",", "image_shape", ")", "\n", "# After transforms such as cropping are applied, the bounding box may no longer", "\n", "# tightly bound the object. As an example, imagine a triangle object", "\n", "# [(0,0), (2,0), (0,2)] cropped by a box [(1,0),(2,2)] (XYXY format). The tight", "\n", "# bounding box of the cropped triangle should be [(1,0),(2,1)], which is not equal to", "\n", "# the intersection of original bounding box and the cropping box.", "\n", "instances", ".", "gt_boxes", "=", "instances", ".", "gt_masks", ".", "get_bounding_boxes", "(", ")", "\n", "# Need to filter empty instances first (due to augmentation)", "\n", "instances", "=", "utils", ".", "filter_empty_instances", "(", "instances", ")", "\n", "# Generate masks from polygon", "\n", "h", ",", "w", "=", "instances", ".", "image_size", "\n", "# image_size_xyxy = torch.as_tensor([w, h, w, h], dtype=torch.float)", "\n", "if", "hasattr", "(", "instances", ",", "'gt_masks'", ")", ":", "\n", "                ", "gt_masks", "=", "instances", ".", "gt_masks", "\n", "gt_masks", "=", "convert_coco_poly_to_mask", "(", "gt_masks", ".", "polygons", ",", "h", ",", "w", ")", "\n", "instances", ".", "gt_masks", "=", "gt_masks", "\n", "", "dataset_dict", "[", "\"instances\"", "]", "=", "instances", "\n", "\n", "", "return", "dataset_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_instance_new_baseline_dataset_mapper.convert_coco_poly_to_mask": [[20, 35], ["pycocotools.mask.frPyObjects", "pycocotools.mask.decode", "torch.as_tensor", "mask.any.any", "torch.zeros.append", "torch.stack", "torch.zeros", "len"], "function", ["home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.decode"], ["def", "convert_coco_poly_to_mask", "(", "segmentations", ",", "height", ",", "width", ")", ":", "\n", "    ", "masks", "=", "[", "]", "\n", "for", "polygons", "in", "segmentations", ":", "\n", "        ", "rles", "=", "coco_mask", ".", "frPyObjects", "(", "polygons", ",", "height", ",", "width", ")", "\n", "mask", "=", "coco_mask", ".", "decode", "(", "rles", ")", "\n", "if", "len", "(", "mask", ".", "shape", ")", "<", "3", ":", "\n", "            ", "mask", "=", "mask", "[", "...", ",", "None", "]", "\n", "", "mask", "=", "torch", ".", "as_tensor", "(", "mask", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "mask", "=", "mask", ".", "any", "(", "dim", "=", "2", ")", "\n", "masks", ".", "append", "(", "mask", ")", "\n", "", "if", "masks", ":", "\n", "        ", "masks", "=", "torch", ".", "stack", "(", "masks", ",", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "masks", "=", "torch", ".", "zeros", "(", "(", "0", ",", "height", ",", "width", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_instance_new_baseline_dataset_mapper.build_transform_gen": [[37, 67], ["augmentation.extend", "augmentation.append", "detectron2.data.transforms.RandomFlip", "detectron2.data.transforms.ResizeScale", "detectron2.data.transforms.FixedSizeCrop"], "function", ["None"], ["", "def", "build_transform_gen", "(", "cfg", ",", "is_train", ")", ":", "\n", "    ", "\"\"\"\n    Create a list of default :class:`Augmentation` from config.\n    Now it includes resizing and flipping.\n    Returns:\n        list[Augmentation]\n    \"\"\"", "\n", "assert", "is_train", ",", "\"Only support training augmentation\"", "\n", "image_size", "=", "cfg", ".", "INPUT", ".", "IMAGE_SIZE", "\n", "min_scale", "=", "cfg", ".", "INPUT", ".", "MIN_SCALE", "\n", "max_scale", "=", "cfg", ".", "INPUT", ".", "MAX_SCALE", "\n", "\n", "augmentation", "=", "[", "]", "\n", "\n", "if", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "!=", "\"none\"", ":", "\n", "        ", "augmentation", ".", "append", "(", "\n", "T", ".", "RandomFlip", "(", "\n", "horizontal", "=", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "==", "\"horizontal\"", ",", "\n", "vertical", "=", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "==", "\"vertical\"", ",", "\n", ")", "\n", ")", "\n", "\n", "", "augmentation", ".", "extend", "(", "[", "\n", "T", ".", "ResizeScale", "(", "\n", "min_scale", "=", "min_scale", ",", "max_scale", "=", "max_scale", ",", "target_height", "=", "image_size", ",", "target_width", "=", "image_size", "\n", ")", ",", "\n", "T", ".", "FixedSizeCrop", "(", "crop_size", "=", "(", "image_size", ",", "image_size", ")", ")", ",", "\n", "]", ")", "\n", "\n", "return", "augmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_panoptic_dataset_mapper.MaskFormerPanopticDatasetMapper.__init__": [[32, 57], ["mask_former_semantic_dataset_mapper.MaskFormerSemanticDatasetMapper.__init__"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "is_train", "=", "True", ",", "\n", "*", ",", "\n", "augmentations", ",", "\n", "image_format", ",", "\n", "ignore_label", ",", "\n", "size_divisibility", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        Args:\n            is_train: for training or inference\n            augmentations: a list of augmentations or deterministic transforms to apply\n            image_format: an image format supported by :func:`detection_utils.read_image`.\n            ignore_label: the label that is ignored to evaluation\n            size_divisibility: pad image size to be divisible by this value\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "is_train", ",", "\n", "augmentations", "=", "augmentations", ",", "\n", "image_format", "=", "image_format", ",", "\n", "ignore_label", "=", "ignore_label", ",", "\n", "size_divisibility", "=", "size_divisibility", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_panoptic_dataset_mapper.MaskFormerPanopticDatasetMapper.__call__": [[59, 166], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "detectron2.data.transforms.AugInput", "detectron2.data.transforms.apply_transform_gens", "detectron2.data.transforms.apply_segmentation", "rgb2id", "torch.as_tensor", "torch.as_tensor", "torch.nn.functional.pad().contiguous.numpy", "detectron2.structures.Instances", "numpy.array", "torch.tensor", "detectron2.data.detection_utils.read_image().astype", "detectron2.data.detection_utils.read_image", "ValueError", "numpy.ascontiguousarray", "torch.as_tensor", "torch.nn.functional.pad().contiguous.astype", "torch.nn.functional.pad().contiguous", "torch.nn.functional.pad().contiguous", "torch.nn.functional.pad().contiguous.long", "ValueError", "len", "torch.zeros", "detectron2.structures.BitMasks", "copy.deepcopy.pop", "torch.nn.functional.pad().contiguous.transpose", "torch.nn.functional.pad().contiguous.astype", "torch.nn.functional.pad().contiguous", "numpy.array.append", "detectron2.structures.BitMasks.append", "torch.stack", "detectron2.data.detection_utils.read_image", "torch.nn.functional.pad", "torch.nn.functional.pad", "copy.deepcopy.pop", "torch.nn.functional.pad", "torch.from_numpy", "numpy.ascontiguousarray", "x.copy"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.\n\n        Returns:\n            dict: a format that builtin models in detectron2 accept\n        \"\"\"", "\n", "assert", "self", ".", "is_train", ",", "\"MaskFormerPanopticDatasetMapper should only be used for training!\"", "\n", "\n", "dataset_dict", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "# it will be modified by code below", "\n", "image", "=", "utils", ".", "read_image", "(", "dataset_dict", "[", "\"file_name\"", "]", ",", "format", "=", "self", ".", "img_format", ")", "\n", "utils", ".", "check_image_size", "(", "dataset_dict", ",", "image", ")", "\n", "\n", "# semantic segmentation", "\n", "if", "\"sem_seg_file_name\"", "in", "dataset_dict", ":", "\n", "# PyTorch transformation not implemented for uint16, so converting it to double first", "\n", "            ", "sem_seg_gt", "=", "utils", ".", "read_image", "(", "dataset_dict", ".", "pop", "(", "\"sem_seg_file_name\"", ")", ")", ".", "astype", "(", "\"double\"", ")", "\n", "", "else", ":", "\n", "            ", "sem_seg_gt", "=", "None", "\n", "\n", "# panoptic segmentation", "\n", "", "if", "\"pan_seg_file_name\"", "in", "dataset_dict", ":", "\n", "            ", "pan_seg_gt", "=", "utils", ".", "read_image", "(", "dataset_dict", ".", "pop", "(", "\"pan_seg_file_name\"", ")", ",", "\"RGB\"", ")", "\n", "segments_info", "=", "dataset_dict", "[", "\"segments_info\"", "]", "\n", "", "else", ":", "\n", "            ", "pan_seg_gt", "=", "None", "\n", "segments_info", "=", "None", "\n", "\n", "", "if", "pan_seg_gt", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Cannot find 'pan_seg_file_name' for panoptic segmentation dataset {}.\"", ".", "format", "(", "\n", "dataset_dict", "[", "\"file_name\"", "]", "\n", ")", "\n", ")", "\n", "\n", "", "aug_input", "=", "T", ".", "AugInput", "(", "image", ",", "sem_seg", "=", "sem_seg_gt", ")", "\n", "aug_input", ",", "transforms", "=", "T", ".", "apply_transform_gens", "(", "self", ".", "tfm_gens", ",", "aug_input", ")", "\n", "image", "=", "aug_input", ".", "image", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "            ", "sem_seg_gt", "=", "aug_input", ".", "sem_seg", "\n", "\n", "# apply the same transformation to panoptic segmentation", "\n", "", "pan_seg_gt", "=", "transforms", ".", "apply_segmentation", "(", "pan_seg_gt", ")", "\n", "\n", "from", "panopticapi", ".", "utils", "import", "rgb2id", "\n", "\n", "pan_seg_gt", "=", "rgb2id", "(", "pan_seg_gt", ")", "\n", "\n", "# Pad image and segmentation label here!", "\n", "image", "=", "torch", ".", "as_tensor", "(", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "            ", "sem_seg_gt", "=", "torch", ".", "as_tensor", "(", "sem_seg_gt", ".", "astype", "(", "\"long\"", ")", ")", "\n", "", "pan_seg_gt", "=", "torch", ".", "as_tensor", "(", "pan_seg_gt", ".", "astype", "(", "\"long\"", ")", ")", "\n", "\n", "if", "self", ".", "size_divisibility", ">", "0", ":", "\n", "            ", "image_size", "=", "(", "image", ".", "shape", "[", "-", "2", "]", ",", "image", ".", "shape", "[", "-", "1", "]", ")", "\n", "padding_size", "=", "[", "\n", "0", ",", "\n", "self", ".", "size_divisibility", "-", "image_size", "[", "1", "]", ",", "\n", "0", ",", "\n", "self", ".", "size_divisibility", "-", "image_size", "[", "0", "]", ",", "\n", "]", "\n", "image", "=", "F", ".", "pad", "(", "image", ",", "padding_size", ",", "value", "=", "128", ")", ".", "contiguous", "(", ")", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "                ", "sem_seg_gt", "=", "F", ".", "pad", "(", "sem_seg_gt", ",", "padding_size", ",", "value", "=", "self", ".", "ignore_label", ")", ".", "contiguous", "(", ")", "\n", "", "pan_seg_gt", "=", "F", ".", "pad", "(", "\n", "pan_seg_gt", ",", "padding_size", ",", "value", "=", "0", "\n", ")", ".", "contiguous", "(", ")", "# 0 is the VOID panoptic label", "\n", "\n", "", "image_shape", "=", "(", "image", ".", "shape", "[", "-", "2", "]", ",", "image", ".", "shape", "[", "-", "1", "]", ")", "# h, w", "\n", "\n", "# Pytorch's dataloader is efficient on torch.Tensor due to shared-memory,", "\n", "# but not efficient on large generic data structures due to the use of pickle & mp.Queue.", "\n", "# Therefore it's important to use torch.Tensor.", "\n", "dataset_dict", "[", "\"image\"", "]", "=", "image", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "            ", "dataset_dict", "[", "\"sem_seg\"", "]", "=", "sem_seg_gt", ".", "long", "(", ")", "\n", "\n", "", "if", "\"annotations\"", "in", "dataset_dict", ":", "\n", "            ", "raise", "ValueError", "(", "\"Pemantic segmentation dataset should not have 'annotations'.\"", ")", "\n", "\n", "# Prepare per-category binary masks", "\n", "", "pan_seg_gt", "=", "pan_seg_gt", ".", "numpy", "(", ")", "\n", "instances", "=", "Instances", "(", "image_shape", ")", "\n", "classes", "=", "[", "]", "\n", "masks", "=", "[", "]", "\n", "for", "segment_info", "in", "segments_info", ":", "\n", "            ", "class_id", "=", "segment_info", "[", "\"category_id\"", "]", "\n", "if", "not", "segment_info", "[", "\"iscrowd\"", "]", ":", "\n", "                ", "classes", ".", "append", "(", "class_id", ")", "\n", "masks", ".", "append", "(", "pan_seg_gt", "==", "segment_info", "[", "\"id\"", "]", ")", "\n", "\n", "", "", "classes", "=", "np", ".", "array", "(", "classes", ")", "\n", "instances", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "classes", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "# Some image does not have annotation (all ignored)", "\n", "            ", "instances", ".", "gt_masks", "=", "torch", ".", "zeros", "(", "(", "0", ",", "pan_seg_gt", ".", "shape", "[", "-", "2", "]", ",", "pan_seg_gt", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "masks", "=", "BitMasks", "(", "\n", "torch", ".", "stack", "(", "[", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "x", ".", "copy", "(", ")", ")", ")", "for", "x", "in", "masks", "]", ")", "\n", ")", "\n", "instances", ".", "gt_masks", "=", "masks", ".", "tensor", "\n", "\n", "", "dataset_dict", "[", "\"instances\"", "]", "=", "instances", "\n", "\n", "return", "dataset_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_panoptic_new_baseline_dataset_mapper.COCOPanopticNewBaselineDatasetMapper.__init__": [[66, 92], ["logging.getLogger().info", "logging.getLogger", "str"], "methods", ["None"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "is_train", "=", "True", ",", "\n", "*", ",", "\n", "tfm_gens", ",", "\n", "image_format", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        Args:\n            is_train: for training or inference\n            augmentations: a list of augmentations or deterministic transforms to apply\n            crop_gen: crop augmentation\n            tfm_gens: data augmentation\n            image_format: an image format supported by :func:`detection_utils.read_image`.\n        \"\"\"", "\n", "self", ".", "tfm_gens", "=", "tfm_gens", "\n", "logging", ".", "getLogger", "(", "__name__", ")", ".", "info", "(", "\n", "\"[COCOPanopticNewBaselineDatasetMapper] Full TransformGens used in training: {}\"", ".", "format", "(", "\n", "str", "(", "self", ".", "tfm_gens", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "img_format", "=", "image_format", "\n", "self", ".", "is_train", "=", "is_train", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_panoptic_new_baseline_dataset_mapper.COCOPanopticNewBaselineDatasetMapper.from_config": [[93, 104], ["coco_panoptic_new_baseline_dataset_mapper.build_transform_gen"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_panoptic_new_baseline_dataset_mapper.build_transform_gen"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "is_train", "=", "True", ")", ":", "\n", "# Build augmentation", "\n", "        ", "tfm_gens", "=", "build_transform_gen", "(", "cfg", ",", "is_train", ")", "\n", "\n", "ret", "=", "{", "\n", "\"is_train\"", ":", "is_train", ",", "\n", "\"tfm_gens\"", ":", "tfm_gens", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "}", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_panoptic_new_baseline_dataset_mapper.COCOPanopticNewBaselineDatasetMapper.__call__": [[105, 166], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "detectron2.data.transforms.apply_transform_gens", "torch.as_tensor", "numpy.ascontiguousarray", "copy.deepcopy.pop", "detectron2.data.detection_utils.read_image", "detectron2.data.transforms.apply_segmentation", "rgb2id", "detectron2.structures.Instances", "numpy.array", "torch.tensor", "detectron2.data.detection_utils.read_image.transpose", "copy.deepcopy.pop", "len", "torch.zeros", "detectron2.structures.Boxes", "detectron2.structures.BitMasks", "detectron2.structures.BitMasks.get_bounding_boxes", "numpy.array.append", "detectron2.structures.BitMasks.append", "torch.zeros", "torch.stack", "torch.from_numpy", "numpy.ascontiguousarray", "x.copy"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.\n\n        Returns:\n            dict: a format that builtin models in detectron2 accept\n        \"\"\"", "\n", "dataset_dict", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "# it will be modified by code below", "\n", "image", "=", "utils", ".", "read_image", "(", "dataset_dict", "[", "\"file_name\"", "]", ",", "format", "=", "self", ".", "img_format", ")", "\n", "utils", ".", "check_image_size", "(", "dataset_dict", ",", "image", ")", "\n", "\n", "image", ",", "transforms", "=", "T", ".", "apply_transform_gens", "(", "self", ".", "tfm_gens", ",", "image", ")", "\n", "image_shape", "=", "image", ".", "shape", "[", ":", "2", "]", "# h, w", "\n", "\n", "# Pytorch's dataloader is efficient on torch.Tensor due to shared-memory,", "\n", "# but not efficient on large generic data structures due to the use of pickle & mp.Queue.", "\n", "# Therefore it's important to use torch.Tensor.", "\n", "dataset_dict", "[", "\"image\"", "]", "=", "torch", ".", "as_tensor", "(", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "\n", "if", "not", "self", ".", "is_train", ":", "\n", "# USER: Modify this if you want to keep them for some reason.", "\n", "            ", "dataset_dict", ".", "pop", "(", "\"annotations\"", ",", "None", ")", "\n", "return", "dataset_dict", "\n", "\n", "", "if", "\"pan_seg_file_name\"", "in", "dataset_dict", ":", "\n", "            ", "pan_seg_gt", "=", "utils", ".", "read_image", "(", "dataset_dict", ".", "pop", "(", "\"pan_seg_file_name\"", ")", ",", "\"RGB\"", ")", "\n", "segments_info", "=", "dataset_dict", "[", "\"segments_info\"", "]", "\n", "\n", "# apply the same transformation to panoptic segmentation", "\n", "pan_seg_gt", "=", "transforms", ".", "apply_segmentation", "(", "pan_seg_gt", ")", "\n", "\n", "from", "panopticapi", ".", "utils", "import", "rgb2id", "\n", "\n", "pan_seg_gt", "=", "rgb2id", "(", "pan_seg_gt", ")", "\n", "\n", "instances", "=", "Instances", "(", "image_shape", ")", "\n", "classes", "=", "[", "]", "\n", "masks", "=", "[", "]", "\n", "for", "segment_info", "in", "segments_info", ":", "\n", "                ", "class_id", "=", "segment_info", "[", "\"category_id\"", "]", "\n", "if", "not", "segment_info", "[", "\"iscrowd\"", "]", ":", "\n", "                    ", "classes", ".", "append", "(", "class_id", ")", "\n", "masks", ".", "append", "(", "pan_seg_gt", "==", "segment_info", "[", "\"id\"", "]", ")", "\n", "\n", "", "", "classes", "=", "np", ".", "array", "(", "classes", ")", "\n", "instances", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "classes", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "# Some image does not have annotation (all ignored)", "\n", "                ", "instances", ".", "gt_masks", "=", "torch", ".", "zeros", "(", "(", "0", ",", "pan_seg_gt", ".", "shape", "[", "-", "2", "]", ",", "pan_seg_gt", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "instances", ".", "gt_boxes", "=", "Boxes", "(", "torch", ".", "zeros", "(", "(", "0", ",", "4", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "masks", "=", "BitMasks", "(", "\n", "torch", ".", "stack", "(", "[", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "x", ".", "copy", "(", ")", ")", ")", "for", "x", "in", "masks", "]", ")", "\n", ")", "\n", "instances", ".", "gt_masks", "=", "masks", ".", "tensor", "\n", "instances", ".", "gt_boxes", "=", "masks", ".", "get_bounding_boxes", "(", ")", "\n", "\n", "", "dataset_dict", "[", "\"instances\"", "]", "=", "instances", "\n", "\n", "", "return", "dataset_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.coco_panoptic_new_baseline_dataset_mapper.build_transform_gen": [[18, 48], ["augmentation.extend", "augmentation.append", "detectron2.data.transforms.RandomFlip", "detectron2.data.transforms.ResizeScale", "detectron2.data.transforms.FixedSizeCrop"], "function", ["None"], ["def", "build_transform_gen", "(", "cfg", ",", "is_train", ")", ":", "\n", "    ", "\"\"\"\n    Create a list of default :class:`Augmentation` from config.\n    Now it includes resizing and flipping.\n    Returns:\n        list[Augmentation]\n    \"\"\"", "\n", "assert", "is_train", ",", "\"Only support training augmentation\"", "\n", "image_size", "=", "cfg", ".", "INPUT", ".", "IMAGE_SIZE", "\n", "min_scale", "=", "cfg", ".", "INPUT", ".", "MIN_SCALE", "\n", "max_scale", "=", "cfg", ".", "INPUT", ".", "MAX_SCALE", "\n", "\n", "augmentation", "=", "[", "]", "\n", "\n", "if", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "!=", "\"none\"", ":", "\n", "        ", "augmentation", ".", "append", "(", "\n", "T", ".", "RandomFlip", "(", "\n", "horizontal", "=", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "==", "\"horizontal\"", ",", "\n", "vertical", "=", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "==", "\"vertical\"", ",", "\n", ")", "\n", ")", "\n", "\n", "", "augmentation", ".", "extend", "(", "[", "\n", "T", ".", "ResizeScale", "(", "\n", "min_scale", "=", "min_scale", ",", "max_scale", "=", "max_scale", ",", "target_height", "=", "image_size", ",", "target_width", "=", "image_size", "\n", ")", ",", "\n", "T", ".", "FixedSizeCrop", "(", "crop_size", "=", "(", "image_size", ",", "image_size", ")", ")", ",", "\n", "]", ")", "\n", "\n", "return", "augmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_semantic_dataset_mapper.MaskFormerSemanticDatasetMapper.__init__": [[32, 60], ["logging.getLogger", "logging.getLogger.info"], "methods", ["None"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "is_train", "=", "True", ",", "\n", "*", ",", "\n", "augmentations", ",", "\n", "image_format", ",", "\n", "ignore_label", ",", "\n", "size_divisibility", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        Args:\n            is_train: for training or inference\n            augmentations: a list of augmentations or deterministic transforms to apply\n            image_format: an image format supported by :func:`detection_utils.read_image`.\n            ignore_label: the label that is ignored to evaluation\n            size_divisibility: pad image size to be divisible by this value\n        \"\"\"", "\n", "self", ".", "is_train", "=", "is_train", "\n", "self", ".", "tfm_gens", "=", "augmentations", "\n", "self", ".", "img_format", "=", "image_format", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "self", ".", "size_divisibility", "=", "size_divisibility", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "mode", "=", "\"training\"", "if", "is_train", "else", "\"inference\"", "\n", "logger", ".", "info", "(", "f\"[{self.__class__.__name__}] Augmentations used in {mode}: {augmentations}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_semantic_dataset_mapper.MaskFormerSemanticDatasetMapper.from_config": [[61, 97], ["augs.append", "detectron2.data.MetadataCatalog.get", "detectron2.data.transforms.ResizeShortestEdge", "augs.append", "augs.append", "detectron2.data.transforms.RandomFlip", "detectron2.data.transforms.RandomCrop_CategoryAreaConstraint", "detectron2.projects.point_rend.ColorAugSSDTransform"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "is_train", "=", "True", ")", ":", "\n", "# Build augmentation", "\n", "        ", "augs", "=", "[", "\n", "T", ".", "ResizeShortestEdge", "(", "\n", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN", ",", "\n", "cfg", ".", "INPUT", ".", "MAX_SIZE_TRAIN", ",", "\n", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN_SAMPLING", ",", "\n", ")", "\n", "]", "\n", "if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", ":", "\n", "            ", "augs", ".", "append", "(", "\n", "T", ".", "RandomCrop_CategoryAreaConstraint", "(", "\n", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", ",", "\n", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", ",", "\n", "cfg", ".", "INPUT", ".", "CROP", ".", "SINGLE_CATEGORY_MAX_AREA", ",", "\n", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", ",", "\n", ")", "\n", ")", "\n", "", "if", "cfg", ".", "INPUT", ".", "COLOR_AUG_SSD", ":", "\n", "            ", "augs", ".", "append", "(", "ColorAugSSDTransform", "(", "img_format", "=", "cfg", ".", "INPUT", ".", "FORMAT", ")", ")", "\n", "", "augs", ".", "append", "(", "T", ".", "RandomFlip", "(", ")", ")", "\n", "\n", "# Assume always applies to the training set.", "\n", "dataset_names", "=", "cfg", ".", "DATASETS", ".", "TRAIN", "\n", "meta", "=", "MetadataCatalog", ".", "get", "(", "dataset_names", "[", "0", "]", ")", "\n", "ignore_label", "=", "meta", ".", "ignore_label", "\n", "\n", "ret", "=", "{", "\n", "\"is_train\"", ":", "is_train", ",", "\n", "\"augmentations\"", ":", "augs", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"ignore_label\"", ":", "ignore_label", ",", "\n", "\"size_divisibility\"", ":", "cfg", ".", "INPUT", ".", "SIZE_DIVISIBILITY", ",", "\n", "}", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_semantic_dataset_mapper.MaskFormerSemanticDatasetMapper.__call__": [[98, 185], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "detectron2.data.transforms.AugInput", "detectron2.data.transforms.apply_transform_gens", "torch.as_tensor", "detectron2.data.detection_utils.read_image().astype", "ValueError", "numpy.ascontiguousarray", "torch.as_tensor", "torch.nn.functional.pad().contiguous", "torch.nn.functional.pad().contiguous.long", "ValueError", "torch.nn.functional.pad().contiguous.numpy", "detectron2.structures.Instances", "numpy.unique", "torch.tensor", "torch.nn.functional.pad().contiguous.transpose", "torch.nn.functional.pad().contiguous.astype", "torch.nn.functional.pad().contiguous", "detectron2.structures.BitMasks.append", "len", "torch.zeros", "detectron2.structures.BitMasks", "detectron2.data.detection_utils.read_image", "torch.nn.functional.pad", "torch.stack", "copy.deepcopy.pop", "torch.nn.functional.pad", "torch.from_numpy", "numpy.ascontiguousarray", "x.copy"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.\n\n        Returns:\n            dict: a format that builtin models in detectron2 accept\n        \"\"\"", "\n", "assert", "self", ".", "is_train", ",", "\"MaskFormerSemanticDatasetMapper should only be used for training!\"", "\n", "\n", "dataset_dict", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "# it will be modified by code below", "\n", "image", "=", "utils", ".", "read_image", "(", "dataset_dict", "[", "\"file_name\"", "]", ",", "format", "=", "self", ".", "img_format", ")", "\n", "utils", ".", "check_image_size", "(", "dataset_dict", ",", "image", ")", "\n", "\n", "if", "\"sem_seg_file_name\"", "in", "dataset_dict", ":", "\n", "# PyTorch transformation not implemented for uint16, so converting it to double first", "\n", "            ", "sem_seg_gt", "=", "utils", ".", "read_image", "(", "dataset_dict", ".", "pop", "(", "\"sem_seg_file_name\"", ")", ")", ".", "astype", "(", "\"double\"", ")", "\n", "", "else", ":", "\n", "            ", "sem_seg_gt", "=", "None", "\n", "\n", "", "if", "sem_seg_gt", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Cannot find 'sem_seg_file_name' for semantic segmentation dataset {}.\"", ".", "format", "(", "\n", "dataset_dict", "[", "\"file_name\"", "]", "\n", ")", "\n", ")", "\n", "\n", "", "aug_input", "=", "T", ".", "AugInput", "(", "image", ",", "sem_seg", "=", "sem_seg_gt", ")", "\n", "aug_input", ",", "transforms", "=", "T", ".", "apply_transform_gens", "(", "self", ".", "tfm_gens", ",", "aug_input", ")", "\n", "image", "=", "aug_input", ".", "image", "\n", "sem_seg_gt", "=", "aug_input", ".", "sem_seg", "\n", "\n", "# Pad image and segmentation label here!", "\n", "image", "=", "torch", ".", "as_tensor", "(", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "            ", "sem_seg_gt", "=", "torch", ".", "as_tensor", "(", "sem_seg_gt", ".", "astype", "(", "\"long\"", ")", ")", "\n", "\n", "", "if", "self", ".", "size_divisibility", ">", "0", ":", "\n", "            ", "image_size", "=", "(", "image", ".", "shape", "[", "-", "2", "]", ",", "image", ".", "shape", "[", "-", "1", "]", ")", "\n", "padding_size", "=", "[", "\n", "0", ",", "\n", "self", ".", "size_divisibility", "-", "image_size", "[", "1", "]", ",", "\n", "0", ",", "\n", "self", ".", "size_divisibility", "-", "image_size", "[", "0", "]", ",", "\n", "]", "\n", "image", "=", "F", ".", "pad", "(", "image", ",", "padding_size", ",", "value", "=", "128", ")", ".", "contiguous", "(", ")", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "                ", "sem_seg_gt", "=", "F", ".", "pad", "(", "sem_seg_gt", ",", "padding_size", ",", "value", "=", "self", ".", "ignore_label", ")", ".", "contiguous", "(", ")", "\n", "\n", "", "", "image_shape", "=", "(", "image", ".", "shape", "[", "-", "2", "]", ",", "image", ".", "shape", "[", "-", "1", "]", ")", "# h, w", "\n", "\n", "# Pytorch's dataloader is efficient on torch.Tensor due to shared-memory,", "\n", "# but not efficient on large generic data structures due to the use of pickle & mp.Queue.", "\n", "# Therefore it's important to use torch.Tensor.", "\n", "dataset_dict", "[", "\"image\"", "]", "=", "image", "\n", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "            ", "dataset_dict", "[", "\"sem_seg\"", "]", "=", "sem_seg_gt", ".", "long", "(", ")", "\n", "\n", "", "if", "\"annotations\"", "in", "dataset_dict", ":", "\n", "            ", "raise", "ValueError", "(", "\"Semantic segmentation dataset should not have 'annotations'.\"", ")", "\n", "\n", "# Prepare per-category binary masks", "\n", "", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "            ", "sem_seg_gt", "=", "sem_seg_gt", ".", "numpy", "(", ")", "\n", "instances", "=", "Instances", "(", "image_shape", ")", "\n", "classes", "=", "np", ".", "unique", "(", "sem_seg_gt", ")", "\n", "# remove ignored region", "\n", "classes", "=", "classes", "[", "classes", "!=", "self", ".", "ignore_label", "]", "\n", "instances", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "classes", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "\n", "masks", "=", "[", "]", "\n", "for", "class_id", "in", "classes", ":", "\n", "                ", "masks", ".", "append", "(", "sem_seg_gt", "==", "class_id", ")", "\n", "\n", "", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "# Some image does not have annotation (all ignored)", "\n", "                ", "instances", ".", "gt_masks", "=", "torch", ".", "zeros", "(", "(", "0", ",", "sem_seg_gt", ".", "shape", "[", "-", "2", "]", ",", "sem_seg_gt", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "masks", "=", "BitMasks", "(", "\n", "torch", ".", "stack", "(", "[", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "x", ".", "copy", "(", ")", ")", ")", "for", "x", "in", "masks", "]", ")", "\n", ")", "\n", "instances", ".", "gt_masks", "=", "masks", ".", "tensor", "\n", "\n", "", "dataset_dict", "[", "\"instances\"", "]", "=", "instances", "\n", "\n", "", "return", "dataset_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__init__": [[32, 57], ["logging.getLogger", "logging.getLogger.info"], "methods", ["None"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "is_train", "=", "True", ",", "\n", "*", ",", "\n", "augmentations", ",", "\n", "image_format", ",", "\n", "size_divisibility", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        Args:\n            is_train: for training or inference\n            augmentations: a list of augmentations or deterministic transforms to apply\n            image_format: an image format supported by :func:`detection_utils.read_image`.\n            size_divisibility: pad image size to be divisible by this value\n        \"\"\"", "\n", "self", ".", "is_train", "=", "is_train", "\n", "self", ".", "tfm_gens", "=", "augmentations", "\n", "self", ".", "img_format", "=", "image_format", "\n", "self", ".", "size_divisibility", "=", "size_divisibility", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "mode", "=", "\"training\"", "if", "is_train", "else", "\"inference\"", "\n", "logger", ".", "info", "(", "f\"[{self.__class__.__name__}] Augmentations used in {mode}: {augmentations}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.from_config": [[58, 86], ["augs.append", "detectron2.data.transforms.ResizeShortestEdge", "augs.append", "augs.append", "detectron2.data.transforms.RandomFlip", "detectron2.data.transforms.RandomCrop", "detectron2.projects.point_rend.ColorAugSSDTransform"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "is_train", "=", "True", ")", ":", "\n", "# Build augmentation", "\n", "        ", "augs", "=", "[", "\n", "T", ".", "ResizeShortestEdge", "(", "\n", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN", ",", "\n", "cfg", ".", "INPUT", ".", "MAX_SIZE_TRAIN", ",", "\n", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN_SAMPLING", ",", "\n", ")", "\n", "]", "\n", "if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", ":", "\n", "            ", "augs", ".", "append", "(", "\n", "T", ".", "RandomCrop", "(", "\n", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", ",", "\n", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", ",", "\n", ")", "\n", ")", "\n", "", "if", "cfg", ".", "INPUT", ".", "COLOR_AUG_SSD", ":", "\n", "            ", "augs", ".", "append", "(", "ColorAugSSDTransform", "(", "img_format", "=", "cfg", ".", "INPUT", ".", "FORMAT", ")", ")", "\n", "", "augs", ".", "append", "(", "T", ".", "RandomFlip", "(", ")", ")", "\n", "\n", "ret", "=", "{", "\n", "\"is_train\"", ":", "is_train", ",", "\n", "\"augmentations\"", ":", "augs", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"size_divisibility\"", ":", "cfg", ".", "INPUT", ".", "SIZE_DIVISIBILITY", ",", "\n", "}", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.densoitlab_hcformer.dataset_mappers.mask_former_instance_dataset_mapper.MaskFormerInstanceDatasetMapper.__call__": [[87, 181], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "detectron2.data.transforms.AugInput", "detectron2.data.transforms.apply_transform_gens", "len", "torch.as_tensor", "torch.tensor", "detectron2.structures.Instances", "anno.pop", "detectron2.data.detection_utils.transform_instance_annotations", "isinstance", "numpy.ascontiguousarray", "torch.from_numpy", "int", "torch.nn.functional.pad().contiguous", "len", "torch.zeros", "detectron2.structures.BitMasks", "copy.deepcopy.pop", "detectron2.structures.BitMasks.append", "isinstance", "torch.nn.functional.pad().contiguous.transpose", "numpy.ascontiguousarray", "torch.nn.functional.pad().contiguous", "torch.stack", "obj.get", "detectron2.structures.polygons_to_bitmask", "detectron2.structures.BitMasks.append", "isinstance", "torch.nn.functional.pad", "pycocotools.decode", "detectron2.structures.BitMasks.append", "ValueError", "torch.nn.functional.pad", "type"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.densoitlab_hcformer.transformer_decoder.hcformer_decoder.decode"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.\n\n        Returns:\n            dict: a format that builtin models in detectron2 accept\n        \"\"\"", "\n", "assert", "self", ".", "is_train", ",", "\"MaskFormerPanopticDatasetMapper should only be used for training!\"", "\n", "\n", "dataset_dict", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "# it will be modified by code below", "\n", "image", "=", "utils", ".", "read_image", "(", "dataset_dict", "[", "\"file_name\"", "]", ",", "format", "=", "self", ".", "img_format", ")", "\n", "utils", ".", "check_image_size", "(", "dataset_dict", ",", "image", ")", "\n", "\n", "aug_input", "=", "T", ".", "AugInput", "(", "image", ")", "\n", "aug_input", ",", "transforms", "=", "T", ".", "apply_transform_gens", "(", "self", ".", "tfm_gens", ",", "aug_input", ")", "\n", "image", "=", "aug_input", ".", "image", "\n", "\n", "# transform instnace masks", "\n", "assert", "\"annotations\"", "in", "dataset_dict", "\n", "for", "anno", "in", "dataset_dict", "[", "\"annotations\"", "]", ":", "\n", "            ", "anno", ".", "pop", "(", "\"keypoints\"", ",", "None", ")", "\n", "\n", "", "annos", "=", "[", "\n", "utils", ".", "transform_instance_annotations", "(", "obj", ",", "transforms", ",", "image", ".", "shape", "[", ":", "2", "]", ")", "\n", "for", "obj", "in", "dataset_dict", ".", "pop", "(", "\"annotations\"", ")", "\n", "if", "obj", ".", "get", "(", "\"iscrowd\"", ",", "0", ")", "==", "0", "\n", "]", "\n", "\n", "if", "len", "(", "annos", ")", ":", "\n", "            ", "assert", "\"segmentation\"", "in", "annos", "[", "0", "]", "\n", "", "segms", "=", "[", "obj", "[", "\"segmentation\"", "]", "for", "obj", "in", "annos", "]", "\n", "masks", "=", "[", "]", "\n", "for", "segm", "in", "segms", ":", "\n", "            ", "if", "isinstance", "(", "segm", ",", "list", ")", ":", "\n", "# polygon", "\n", "                ", "masks", ".", "append", "(", "polygons_to_bitmask", "(", "segm", ",", "*", "image", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "", "elif", "isinstance", "(", "segm", ",", "dict", ")", ":", "\n", "# COCO RLE", "\n", "                ", "masks", ".", "append", "(", "mask_util", ".", "decode", "(", "segm", ")", ")", "\n", "", "elif", "isinstance", "(", "segm", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "assert", "segm", ".", "ndim", "==", "2", ",", "\"Expect segmentation of 2 dimensions, got {}.\"", ".", "format", "(", "\n", "segm", ".", "ndim", "\n", ")", "\n", "# mask array", "\n", "masks", ".", "append", "(", "segm", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Cannot convert segmentation of type '{}' to BitMasks!\"", "\n", "\"Supported types are: polygons as list[list[float] or ndarray],\"", "\n", "\" COCO-style RLE as a dict, or a binary segmentation mask \"", "\n", "\" in a 2D numpy array of shape HxW.\"", ".", "format", "(", "type", "(", "segm", ")", ")", "\n", ")", "\n", "\n", "# Pad image and segmentation label here!", "\n", "", "", "image", "=", "torch", ".", "as_tensor", "(", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "masks", "=", "[", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "x", ")", ")", "for", "x", "in", "masks", "]", "\n", "\n", "classes", "=", "[", "int", "(", "obj", "[", "\"category_id\"", "]", ")", "for", "obj", "in", "annos", "]", "\n", "classes", "=", "torch", ".", "tensor", "(", "classes", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "\n", "if", "self", ".", "size_divisibility", ">", "0", ":", "\n", "            ", "image_size", "=", "(", "image", ".", "shape", "[", "-", "2", "]", ",", "image", ".", "shape", "[", "-", "1", "]", ")", "\n", "padding_size", "=", "[", "\n", "0", ",", "\n", "self", ".", "size_divisibility", "-", "image_size", "[", "1", "]", ",", "\n", "0", ",", "\n", "self", ".", "size_divisibility", "-", "image_size", "[", "0", "]", ",", "\n", "]", "\n", "# pad image", "\n", "image", "=", "F", ".", "pad", "(", "image", ",", "padding_size", ",", "value", "=", "128", ")", ".", "contiguous", "(", ")", "\n", "# pad mask", "\n", "masks", "=", "[", "F", ".", "pad", "(", "x", ",", "padding_size", ",", "value", "=", "0", ")", ".", "contiguous", "(", ")", "for", "x", "in", "masks", "]", "\n", "\n", "", "image_shape", "=", "(", "image", ".", "shape", "[", "-", "2", "]", ",", "image", ".", "shape", "[", "-", "1", "]", ")", "# h, w", "\n", "\n", "# Pytorch's dataloader is efficient on torch.Tensor due to shared-memory,", "\n", "# but not efficient on large generic data structures due to the use of pickle & mp.Queue.", "\n", "# Therefore it's important to use torch.Tensor.", "\n", "dataset_dict", "[", "\"image\"", "]", "=", "image", "\n", "\n", "# Prepare per-category binary masks", "\n", "instances", "=", "Instances", "(", "image_shape", ")", "\n", "instances", ".", "gt_classes", "=", "classes", "\n", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "# Some image does not have annotation (all ignored)", "\n", "            ", "instances", ".", "gt_masks", "=", "torch", ".", "zeros", "(", "(", "0", ",", "image", ".", "shape", "[", "-", "2", "]", ",", "image", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "masks", "=", "BitMasks", "(", "torch", ".", "stack", "(", "masks", ")", ")", "\n", "instances", ".", "gt_masks", "=", "masks", ".", "tensor", "\n", "\n", "", "dataset_dict", "[", "\"instances\"", "]", "=", "instances", "\n", "\n", "return", "dataset_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.densoitlab_hcformer.evaluation.instance_evaluation.InstanceSegEvaluator._eval_predictions": [[43, 108], ["instance_evaluation.InstanceSegEvaluator._logger.info", "list", "hasattr", "instance_evaluation.InstanceSegEvaluator._logger.info", "sorted", "itertools.chain", "instance_evaluation.InstanceSegEvaluator._tasks_from_predictions", "os.path.join", "instance_evaluation.InstanceSegEvaluator._logger.info", "instance_evaluation.InstanceSegEvaluator._logger.info", "instance_evaluation.InstanceSegEvaluator._derive_coco_results", "detectron2.utils.file_io.PathManager.open", "f.write", "f.flush", "detectron2.evaluation.coco_evaluation._evaluate_predictions_on_coco", "dataset_id_to_contiguous_id.items", "json.dumps", "len", "instance_evaluation.InstanceSegEvaluator._metadata.get"], "methods", ["home.repos.pwc.inspect_result.densoitlab_hcformer.demo.predictor.AsyncPredictor.get"], ["def", "_eval_predictions", "(", "self", ",", "predictions", ",", "img_ids", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate predictions. Fill self._results with the metrics of the tasks.\n        \"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "\"Preparing results for COCO format ...\"", ")", "\n", "coco_results", "=", "list", "(", "itertools", ".", "chain", "(", "*", "[", "x", "[", "\"instances\"", "]", "for", "x", "in", "predictions", "]", ")", ")", "\n", "tasks", "=", "self", ".", "_tasks", "or", "self", ".", "_tasks_from_predictions", "(", "coco_results", ")", "\n", "\n", "# unmap the category ids for COCO", "\n", "if", "hasattr", "(", "self", ".", "_metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "            ", "dataset_id_to_contiguous_id", "=", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", "\n", "# all_contiguous_ids = list(dataset_id_to_contiguous_id.values())", "\n", "# num_classes = len(all_contiguous_ids)", "\n", "# assert min(all_contiguous_ids) == 0 and max(all_contiguous_ids) == num_classes - 1", "\n", "\n", "reverse_id_mapping", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "dataset_id_to_contiguous_id", ".", "items", "(", ")", "}", "\n", "for", "result", "in", "coco_results", ":", "\n", "                ", "category_id", "=", "result", "[", "\"category_id\"", "]", "\n", "# assert category_id < num_classes, (", "\n", "#     f\"A prediction has class={category_id}, \"", "\n", "#     f\"but the dataset only has {num_classes} classes and \"", "\n", "#     f\"predicted class id should be in [0, {num_classes - 1}].\"", "\n", "# )", "\n", "assert", "category_id", "in", "reverse_id_mapping", ",", "(", "\n", "f\"A prediction has class={category_id}, \"", "\n", "f\"but the dataset only has class ids in {dataset_id_to_contiguous_id}.\"", "\n", ")", "\n", "result", "[", "\"category_id\"", "]", "=", "reverse_id_mapping", "[", "category_id", "]", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"coco_instances_results.json\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Saving results to {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "coco_results", ")", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\n", "\"Evaluating predictions with {} COCO API...\"", ".", "format", "(", "\n", "\"unofficial\"", "if", "self", ".", "_use_fast_impl", "else", "\"official\"", "\n", ")", "\n", ")", "\n", "for", "task", "in", "sorted", "(", "tasks", ")", ":", "\n", "            ", "assert", "task", "in", "{", "\"bbox\"", ",", "\"segm\"", ",", "\"keypoints\"", "}", ",", "f\"Got unknown task: {task}!\"", "\n", "coco_eval", "=", "(", "\n", "_evaluate_predictions_on_coco", "(", "\n", "self", ".", "_coco_api", ",", "\n", "coco_results", ",", "\n", "task", ",", "\n", "kpt_oks_sigmas", "=", "self", ".", "_kpt_oks_sigmas", ",", "\n", "use_fast_impl", "=", "self", ".", "_use_fast_impl", ",", "\n", "img_ids", "=", "img_ids", ",", "\n", "max_dets_per_image", "=", "self", ".", "_max_dets_per_image", ",", "\n", ")", "\n", "if", "len", "(", "coco_results", ")", ">", "0", "\n", "else", "None", "# cocoapi does not handle empty results very well", "\n", ")", "\n", "\n", "res", "=", "self", ".", "_derive_coco_results", "(", "\n", "coco_eval", ",", "task", ",", "class_names", "=", "self", ".", "_metadata", ".", "get", "(", "\"thing_classes\"", ")", "\n", ")", "\n", "self", ".", "_results", "[", "task", "]", "=", "res", "\n", "", "", "", ""]]}