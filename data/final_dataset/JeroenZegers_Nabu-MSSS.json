{"home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.postprocessing.data_reader.DataReader.__init__": [[19, 59], ["len", "print", "six.moves.configparser.ConfigParser", "six.moves.configparser.ConfigParser.read", "dict", "data_reader.DataReader.processors.append", "open_fn", "open_fn.readlines", "data_reader.DataReader.start_index_set.append", "data_reader.DataReader.datafile_lines.extend", "os.path.isfile", "BaseException", "six.moves.configparser.ConfigParser.items", "nabu.processing.processors.processor_factory.factory", "len"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "dataconfs", ",", "segment_lengths", "=", "[", "'full'", "]", ")", ":", "\n", "\t\t", "\"\"\"DataReader constructor\n\n\t\tArgs:\n\t\t\tdataconfs: the database configuration\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\n\t\t\"\"\"", "\n", "\n", "if", "len", "(", "segment_lengths", ")", ">", "1", ":", "\n", "\t\t\t", "print", "(", "\n", "'Warning: Not yet implemented __call__ correctly for multiple segments. The returned utt_info, does not '", "'contain the _part sufix and processed returns only 1 processed'", ")", "\n", "", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "self", ".", "processors", "=", "[", "]", "\n", "self", ".", "start_index_set", "=", "[", "0", "]", "\n", "self", ".", "datafile_lines", "=", "[", "]", "\n", "for", "dataconf", "in", "dataconfs", ":", "\n", "# read the processor config", "\n", "\t\t\t", "proc_cfg_file", "=", "dataconf", "[", "'processor_config'", "]", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "proc_cfg_file", ")", ":", "\n", "\t\t\t\t", "raise", "BaseException", "(", "'%s does not exist'", "%", "proc_cfg_file", ")", "\n", "", "parsed_proc_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "parsed_proc_cfg", ".", "read", "(", "proc_cfg_file", ")", "\n", "proc_cfg", "=", "dict", "(", "parsed_proc_cfg", ".", "items", "(", "'processor'", ")", ")", "\n", "\n", "# create a processor", "\n", "self", ".", "processors", ".", "append", "(", "processor_factory", ".", "factory", "(", "proc_cfg", "[", "'processor'", "]", ")", "(", "proc_cfg", ",", "self", ".", "segment_lengths", ")", ")", "\n", "\n", "# get the datafiles lines", "\n", "datafile", "=", "dataconf", "[", "'datafiles'", "]", "# TODO: for the moment expecting only 1 file, but this also makes sense?", "\n", "if", "datafile", "[", "-", "3", ":", "]", "==", "'.gz'", ":", "\n", "\t\t\t\t", "open_fn", "=", "gzip", ".", "open", "\n", "", "else", ":", "\n", "\t\t\t\t", "open_fn", "=", "open", "\n", "", "f", "=", "open_fn", "(", "datafile", ")", "\n", "datalines", "=", "f", ".", "readlines", "(", ")", "\n", "self", ".", "start_index_set", ".", "append", "(", "self", ".", "start_index_set", "[", "-", "1", "]", "+", "len", "(", "datalines", ")", ")", "\n", "self", ".", "datafile_lines", ".", "extend", "(", "datalines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.postprocessing.data_reader.DataReader.__call__": [[60, 88], ["enumerate", "line.strip().split", "processor", "line.strip"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "list_pos", ")", ":", "\n", "\t\t", "\"\"\"read data from the datafile list\n\n\t\tArgs:\n\t\t\tlist_pos: position on the datafile list to read\n\n\t\tReturns:\n\t\t\tThe processed data as a numpy array\"\"\"", "\n", "\n", "line", "=", "self", ".", "datafile_lines", "[", "list_pos", "]", "\n", "for", "ind", ",", "start_index", "in", "enumerate", "(", "self", ".", "start_index_set", ")", ":", "\n", "\t\t\t", "if", "start_index", ">", "list_pos", ":", "\n", "\t\t\t\t", "processor", "=", "self", ".", "processors", "[", "ind", "-", "1", "]", "\n", "break", "\n", "\n", "# split the name and the data line", "\n", "", "", "splitline", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "utt_name", "=", "splitline", "[", "0", "]", "\n", "dataline", "=", "' '", ".", "join", "(", "splitline", "[", "1", ":", "]", ")", "\n", "\n", "# process the dataline", "\n", "processed", ",", "utt_info", "=", "processor", "(", "dataline", ")", "\n", "utt_info", "[", "'utt_name'", "]", "=", "utt_name", "\n", "\n", "# Currently only returning 1 processed!", "\n", "processed", "=", "processed", "[", "self", ".", "segment_lengths", "[", "0", "]", "]", "[", "0", "]", "\n", "\n", "return", "processed", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.postprocessing.data_reader.DataReader.get_name_for_pos": [[89, 105], ["line.strip().split", "line.strip"], "methods", ["None"], ["", "def", "get_name_for_pos", "(", "self", ",", "list_pos", ")", ":", "\n", "\t\t", "\"\"\" get the name of the utterance for the given position from the datafile list\n\n\t\tArgs:\n\t\t\tlist_pos: position on the datafile list to read\n\n\t\tReturns:\n\t\t\tThe name of the utterance\"\"\"", "\n", "\n", "line", "=", "self", ".", "datafile_lines", "[", "list_pos", "]", "\n", "\n", "# split the name and the data line", "\n", "splitline", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "utt_name", "=", "splitline", "[", "0", "]", "\n", "\n", "return", "utt_name", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.si_sdr_scorer.SiSdrScorer.__init__": [[23, 35], ["scorer.Scorer.__init__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "numbatches", ",", "task", ",", "scorer_name", ",", "checkpoint_file", ")", ":", "\n", "\t\t", "\"\"\"SdrScorer constructor\n\n\t\tArgs:\n\t\t\tconf: the scorer configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions are\n\t\t\tnumbatches: the number of batches to process\n\t\t\"\"\"", "\n", "\n", "super", "(", "SiSdrScorer", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "numbatches", ",", "task", ",", "scorer_name", ",", "checkpoint_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.si_sdr_scorer.SiSdrScorer._get_score": [[36, 76], ["dict", "nussl.ScaleInvariantSDR", "nussl.ScaleInvariantSDR", "nussl.ScaleInvariantSDR.evaluate", "nussl.ScaleInvariantSDR", "nussl.ScaleInvariantSDR", "nussl.ScaleInvariantSDR.evaluate", "len", "dict", "enumerate", "nussl.AudioSignal", "nussl.AudioSignal", "nussl.AudioSignal", "nussl.AudioSignal", "nussl.AudioSignal", "nussl.AudioSignal", "dict", "enumerate", "numpy.squeeze", "numpy.squeeze", "numpy.squeeze", "range"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_evaluator.TaskEvaluator.evaluate", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_evaluator.TaskEvaluator.evaluate"], ["", "def", "_get_score", "(", "self", ",", "org_src_signals", ",", "base_signals", ",", "rec_src_signals", ",", "utt_rate", ")", ":", "\n", "\t\t", "\"\"\"score the reconstructed utterances with respect to the original source signals\n\n\t\tArgs:\n\t\t\torg_src_signals: the original source signals, as a list of numpy arrarys\n\t\t\tbase_signals: the duplicated base signal (original mixture), as a list of numpy arrarys\n\t\t\trec_src_signals: the reconstructed source signals, as a list of numpy arrarys\n\n\t\tReturns:\n\t\t\tthe score\"\"\"", "\n", "\n", "# convert to numpy arrays", "\n", "org_src_signals", "=", "[", "audio_signal", ".", "AudioSignal", "(", "audio_data_array", "=", "np", ".", "squeeze", "(", "si", ")", ",", "sample_rate", "=", "utt_rate", ")", "for", "si", "in", "org_src_signals", "]", "\n", "rec_src_signals", "=", "[", "audio_signal", ".", "AudioSignal", "(", "audio_data_array", "=", "np", ".", "squeeze", "(", "si", ")", ",", "sample_rate", "=", "utt_rate", ")", "for", "si", "in", "rec_src_signals", "]", "\n", "base_signals", "=", "[", "audio_signal", ".", "AudioSignal", "(", "audio_data_array", "=", "np", ".", "squeeze", "(", "si", ")", ",", "sample_rate", "=", "utt_rate", ")", "for", "si", "in", "base_signals", "]", "\n", "\n", "collect_outputs", "=", "dict", "(", ")", "\n", "BaseSignalsSiSdrCalculator", "=", "si_sdr", ".", "ScaleInvariantSDR", "(", "true_sources_list", "=", "org_src_signals", ",", "estimated_sources_list", "=", "base_signals", ",", "compute_permutation", "=", "True", ",", "scaling", "=", "True", ")", "\n", "collect_outputs", "[", "self", ".", "score_scenarios", "[", "1", "]", "]", "=", "BaseSignalsSiSdrCalculator", ".", "evaluate", "(", ")", "\n", "\n", "EstSignalsSiSdrCalculator", "=", "si_sdr", ".", "ScaleInvariantSDR", "(", "true_sources_list", "=", "org_src_signals", ",", "estimated_sources_list", "=", "rec_src_signals", ",", "compute_permutation", "=", "True", ",", "scaling", "=", "True", ")", "\n", "collect_outputs", "[", "self", ".", "score_scenarios", "[", "0", "]", "]", "=", "EstSignalsSiSdrCalculator", ".", "evaluate", "(", ")", "\n", "\n", "nr_spk", "=", "len", "(", "org_src_signals", ")", "\n", "\n", "# convert the outputs to a single dictionary", "\n", "score_dict", "=", "dict", "(", ")", "\n", "for", "i", ",", "metric", "in", "enumerate", "(", "self", ".", "score_metrics", ")", ":", "\n", "\t\t\t", "score_dict", "[", "metric", "]", "=", "dict", "(", ")", "\n", "\n", "for", "j", ",", "scen", "in", "enumerate", "(", "self", ".", "score_scenarios", ")", ":", "\n", "\t\t\t\t", "score_dict", "[", "metric", "]", "[", "scen", "]", "=", "[", "]", "\n", "\n", "if", "metric", "==", "'perm'", ":", "\n", "\t\t\t\t\t", "score_dict", "[", "metric", "]", "[", "scen", "]", "=", "collect_outputs", "[", "scen", "]", "[", "'permutation'", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "for", "spk", "in", "range", "(", "nr_spk", ")", ":", "\n", "\t\t\t\t\t\t", "score_dict", "[", "metric", "]", "[", "scen", "]", "+=", "collect_outputs", "[", "scen", "]", "[", "'source_%d'", "%", "spk", "]", "[", "metric", "]", "\n", "\n", "", "", "", "", "return", "score_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.diar_scorer.DiarFromSigEstScorer.__init__": [[22, 39], ["int", "float", "scorer.Scorer.__init__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "numbatches", ",", "task", ",", "scorer_name", ",", "checkpoint_file", ")", ":", "\n", "\t\t", "\"\"\"SdrScorer constructor\n\n\t\tArgs:\n\t\t\tconf: the scorer configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions are\n\t\t\tnumbatches: the number of batches to process\n\t\t\"\"\"", "\n", "\n", "# the percentage of frame energy required for a speaker to be considered active.", "\n", "self", ".", "frame_len", "=", "int", "(", "conf", "[", "'frame_len'", "]", ")", "\n", "self", ".", "thr_std", "=", "float", "(", "conf", "[", "'thr_std'", "]", ")", "\n", "self", ".", "weight_frames", "=", "conf", "[", "'weight_frames'", "]", "in", "[", "'true'", ",", "'True'", "]", "\n", "\n", "super", "(", "DiarFromSigEstScorer", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "numbatches", ",", "task", ",", "scorer_name", ",", "checkpoint_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.diar_scorer.DiarFromSigEstScorer._get_score": [[40, 87], ["numpy.convolve", "len", "len", "numpy.mean", "numpy.std", "numpy.array", "numpy.array", "numpy.transpose", "list", "numpy.argmin", "numpy.abs", "numpy.ones", "numpy.shape", "itertools.permutations", "numpy.sum", "numpy.min", "perm_cost.append", "numpy.convolve", "numpy.sum", "numpy.ones", "range", "numpy.abs", "numpy.sum", "numpy.abs", "numpy.ones", "numpy.ones", "numpy.shape", "numpy.array"], "methods", ["None"], ["", "def", "_get_score", "(", "self", ",", "targets", ",", "base_signals", ",", "rec_src_signals", ",", "utt_rate", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\n\t\tArgs:\n\t\t\ttargets: the target vads, as a list of numpy arrarys\n\t\t\tbase_signals: the duplicated base signal (original mixture), as a list of numpy arrarys\n\t\t\trec_src_signals: the reconstructed source signals, as a list of numpy arrarys\n\n\t\tReturns:\n\t\t\tthe score\"\"\"", "\n", "\n", "# convert to numpy arrays", "\n", "base_signal", "=", "base_signals", "[", "0", "]", "[", ":", ",", "0", "]", "\n", "base_signal_framed", "=", "np", ".", "convolve", "(", "np", ".", "abs", "(", "base_signal", ")", ",", "np", ".", "ones", "(", "self", ".", "frame_len", ")", ",", "mode", "=", "'same'", ")", "\n", "num_samples", "=", "len", "(", "base_signal", ")", "\n", "num_frames", "=", "len", "(", "base_signal_framed", ")", "\n", "mean", "=", "np", ".", "mean", "(", "base_signal_framed", ")", "\n", "std", "=", "np", ".", "std", "(", "base_signal_framed", ")", "\n", "\n", "thr", "=", "self", ".", "thr_std", "*", "std", "\n", "\n", "#", "\n", "rec_src_signals_framed", "=", "np", ".", "array", "(", "[", "np", ".", "convolve", "(", "np", ".", "abs", "(", "rec_sr_sig", ")", ",", "np", ".", "ones", "(", "self", ".", "frame_len", ")", ",", "mode", "=", "'same'", ")", "for", "rec_sr_sig", "in", "rec_src_signals", "]", ")", "\n", "vad_est_signals", "=", "np", ".", "array", "(", "rec_src_signals_framed", ">", "thr", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n", "if", "self", ".", "weight_frames", ":", "\n", "\t\t\t", "bin_weights", "=", "base_signal_framed", "/", "np", ".", "sum", "(", "base_signal_framed", ")", "\n", "", "else", ":", "\n", "\t\t\t", "bin_weights", "=", "np", ".", "ones", "(", "num_frames", ")", "/", "num_frames", "\n", "\n", "", "targets", "=", "np", ".", "transpose", "(", "targets", "[", ":", "num_frames", "]", ")", "\n", "nr_spk", "=", "np", ".", "shape", "(", "targets", ")", "[", "0", "]", "\n", "permutations", "=", "list", "(", "itertools", ".", "permutations", "(", "range", "(", "nr_spk", ")", ",", "nr_spk", ")", ")", "\n", "\n", "perm_cost", "=", "[", "]", "\n", "for", "perm", "in", "permutations", ":", "\n", "\t\t\t", "all_cost", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "vad_est_signals", "[", "np", ".", "array", "(", "perm", ")", "]", "-", "targets", ")", ",", "axis", "=", "0", ")", "\n", "per_frame_cost", "=", "np", ".", "min", "(", "[", "all_cost", ",", "np", ".", "ones", "(", "np", ".", "shape", "(", "all_cost", ")", ")", "]", ",", "0", ")", "# frame can only be wrong or right", "\n", "weighted_per_frame_cost", "=", "bin_weights", "*", "per_frame_cost", "\n", "perm_cost", ".", "append", "(", "np", ".", "sum", "(", "weighted_per_frame_cost", ")", ")", "\n", "", "best_perm_ind", "=", "np", ".", "argmin", "(", "perm_cost", ")", "\n", "best_perm", "=", "permutations", "[", "best_perm_ind", "]", "\n", "best_cost", "=", "perm_cost", "[", "best_perm_ind", "]", "# cost already normalized via bin_weights", "\n", "\n", "score_dict", "=", "{", "'DER'", ":", "{", "'SS'", ":", "best_cost", "}", ",", "'perm'", ":", "{", "'SS'", ":", "best_perm", "}", "}", "\n", "\n", "return", "score_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.diar_scorer.framesig_padded": [[89, 119], ["len", "numpy.concatenate", "numpy.array", "numpy.tile", "numpy.ones", "int", "numpy.tile", "winfunc", "math.ceil", "numpy.zeros", "numpy.zeros", "numpy.arange", "numpy.tile", "numpy.arange"], "function", ["None"], ["", "", "def", "framesig_padded", "(", "sig", ",", "frame_len", ",", "frame_step", ",", "winfunc", "=", "lambda", "x", ":", "np", ".", "ones", "(", "(", "x", ",", ")", ")", ")", ":", "\n", "\t", "\"\"\"\n\tFrame a signal into overlapping frames. Also pad at the start\n\n\tArgs:\n\t\tsig: the audio signal to frame.\n\t\tframe_len: length of each frame measured in samples.\n\t\tframe_step: number of samples after the start of the previous frame that\n\t\t\tthe next frame should begin.\n\t\twinfunc: the analysis window to apply to each frame. By default no\n\t\t\twindow function is applied.\n\n\tReturns:\n\t\tan array of frames. Size is NUMFRAMES by frame_len.\n\t\"\"\"", "\n", "\n", "slen", "=", "len", "(", "sig", ")", "\n", "if", "slen", "<=", "frame_len", ":", "\n", "\t\t", "numframes", "=", "1", "\n", "", "else", ":", "\n", "\t\t", "numframes", "=", "int", "(", "math", ".", "ceil", "(", "(", "1.0", "*", "slen", ")", "/", "frame_step", ")", ")", "\n", "\n", "", "padsignal", "=", "np", ".", "concatenate", "(", "(", "np", ".", "zeros", "(", "frame_len", "/", "2", "-", "1", ")", ",", "sig", ",", "np", ".", "zeros", "(", "frame_len", "/", "2", ")", ")", ")", "\n", "\n", "indices", "=", "(", "np", ".", "tile", "(", "np", ".", "arange", "(", "0", ",", "frame_len", ")", ",", "(", "numframes", ",", "1", ")", ")", "+", "\n", "np", ".", "tile", "(", "np", ".", "arange", "(", "0", ",", "numframes", "*", "frame_step", ",", "frame_step", ")", ",", "(", "frame_len", ",", "1", ")", ")", ".", "T", ")", "\n", "indices", "=", "np", ".", "array", "(", "indices", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "frames", "=", "padsignal", "[", "indices", "]", "\n", "win", "=", "np", ".", "tile", "(", "winfunc", "(", "frame_len", ")", ",", "(", "numframes", ",", "1", ")", ")", "\n", "return", "frames", "*", "win", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.scorer_factory.factory": [[8, 33], ["Exception"], "function", ["None"], ["def", "factory", "(", "scorer", ")", ":", "\n", "    ", "\"\"\"\n    gets a scorer class\n\n    Args:\n        scorer: the scorer type\n\n    Returns:\n        a scorer class\n    \"\"\"", "\n", "\n", "if", "scorer", "==", "'sdr'", ":", "\n", "        ", "return", "sdr_scorer", ".", "SdrScorer", "\n", "# elif scorer == 'si_sdr':", "\n", "#     return si_sdr_scorer.SiSdrScorer", "\n", "", "elif", "scorer", "==", "'sdr_snr'", ":", "\n", "        ", "return", "sdr_snr_scorer", ".", "SdrSnrScorer", "\n", "", "elif", "scorer", "==", "'sdr_snr_noise'", ":", "\n", "        ", "return", "sdr_snr_noise_scorer", ".", "SdrSnrNoiseScorer", "\n", "# elif scorer == 'pesq':", "\n", "#     return pesq_scorer.PESQScorer", "\n", "", "elif", "scorer", "==", "'diar_from_sig_est'", ":", "\n", "        ", "return", "diar_scorer", ".", "DiarFromSigEstScorer", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Undefined scorer type: %s'", "%", "scorer", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.sdr_snr_scorer.SdrSnrScorer.__init__": [[25, 43], ["scorer.Scorer.__init__", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "noise_dataconfs.append", "dict", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "numbatches", ",", "task", ",", "scorer_name", ",", "checkpoint_file", ")", ":", "\n", "        ", "\"\"\"Reconstructor constructor\n        Args:\n            conf: the scorer configuration as a dictionary\n            evalconf: the evaluator configuration as a ConfigParser\n            dataconf: the database configuration\n            rec_dir: the directory where the reconstructions are\n            numbatches: the number of batches to process\n        \"\"\"", "\n", "\n", "super", "(", "SdrSnrScorer", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "numbatches", ",", "task", ",", "scorer_name", ",", "checkpoint_file", ")", "\n", "\n", "# get the original noise signal reader", "\n", "noise_names", "=", "conf", "[", "'noise'", "]", ".", "split", "(", "' '", ")", "\n", "noise_dataconfs", "=", "[", "]", "\n", "for", "noise_name", "in", "noise_names", ":", "\n", "            ", "noise_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "noise_name", ")", ")", ")", "\n", "", "self", ".", "noise_reader", "=", "data_reader", ".", "DataReader", "(", "noise_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.sdr_snr_scorer.SdrSnrScorer._get_score": [[44, 79], ["numpy.array", "numpy.squeeze", "dict", "bss_eval.bss_eval_sources_extended", "bss_eval.bss_eval_sources_extended", "len", "dict", "enumerate", "numpy.array", "numpy.array", "dict", "enumerate", "range", "[].append"], "methods", ["None"], ["", "def", "_get_score", "(", "self", ",", "org_src_signals", ",", "base_signals", ",", "rec_src_signals", ",", "noise_signal", ")", ":", "\n", "        ", "\"\"\"score the reconstructed utterances with respect to the original source signals\n\n        Args:\n            org_src_signals: the original source signals, as a list of numpy arrarys\n            base_signals: the duplicated base signal (original mixture), as a list of numpy arrarys\n            rec_src_signals: the reconstructed source signals, as a list of numpy arrarys\n\n        Returns:\n            the score\"\"\"", "\n", "\n", "# convert to numpy arrays", "\n", "org_src_signals", "=", "np", ".", "array", "(", "org_src_signals", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "base_signals", "=", "np", ".", "array", "(", "base_signals", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "rec_src_signals", "=", "np", ".", "array", "(", "rec_src_signals", ")", "\n", "noise_signal", "=", "np", ".", "squeeze", "(", "noise_signal", ")", "\n", "#", "\n", "collect_outputs", "=", "dict", "(", ")", "\n", "collect_outputs", "[", "self", ".", "score_scenarios", "[", "1", "]", "]", "=", "bss_eval", ".", "bss_eval_sources_extended", "(", "org_src_signals", ",", "base_signals", ",", "noise_signal", ")", "\n", "collect_outputs", "[", "self", ".", "score_scenarios", "[", "0", "]", "]", "=", "bss_eval", ".", "bss_eval_sources_extended", "(", "org_src_signals", ",", "rec_src_signals", ",", "noise_signal", ")", "\n", "\n", "nr_spk", "=", "len", "(", "org_src_signals", ")", "\n", "\n", "# convert the outputs to a single dictionary", "\n", "score_dict", "=", "dict", "(", ")", "\n", "for", "i", ",", "metric", "in", "enumerate", "(", "self", ".", "score_metrics", ")", ":", "\n", "            ", "score_dict", "[", "metric", "]", "=", "dict", "(", ")", "\n", "\n", "for", "j", ",", "scen", "in", "enumerate", "(", "self", ".", "score_scenarios", ")", ":", "\n", "                ", "score_dict", "[", "metric", "]", "[", "scen", "]", "=", "[", "]", "\n", "\n", "for", "spk", "in", "range", "(", "nr_spk", ")", ":", "\n", "                    ", "score_dict", "[", "metric", "]", "[", "scen", "]", ".", "append", "(", "collect_outputs", "[", "scen", "]", "[", "i", "]", "[", "spk", "]", ")", "\n", "\n", "", "", "", "return", "score_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.sdr_scorer.SdrScorer.__init__": [[22, 34], ["scorer.Scorer.__init__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "numbatches", ",", "task", ",", "scorer_name", ",", "checkpoint_file", ")", ":", "\n", "\t\t", "\"\"\"SdrScorer constructor\n\n\t\tArgs:\n\t\t\tconf: the scorer configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions are\n\t\t\tnumbatches: the number of batches to process\n\t\t\"\"\"", "\n", "\n", "super", "(", "SdrScorer", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "numbatches", ",", "task", ",", "scorer_name", ",", "checkpoint_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scorers.sdr_scorer.SdrScorer._get_score": [[35, 70], ["numpy.array", "dict", "bss_eval.bss_eval_sources", "bss_eval.bss_eval_sources", "len", "dict", "enumerate", "numpy.array", "dict", "enumerate", "range", "[].append"], "methods", ["None"], ["", "def", "_get_score", "(", "self", ",", "org_src_signals", ",", "base_signals", ",", "rec_src_signals", ",", "utt_rate", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"score the reconstructed utterances with respect to the original source signals\n\n\t\tArgs:\n\t\t\torg_src_signals: the original source signals, as a list of numpy arrarys\n\t\t\tbase_signals: the duplicated base signal (original mixture), as a list of numpy arrarys\n\t\t\trec_src_signals: the reconstructed source signals, as a list of numpy arrarys\n\n\t\tReturns:\n\t\t\tthe score\"\"\"", "\n", "\n", "# convert to numpy arrays", "\n", "org_src_signals", "=", "org_src_signals", "[", ":", ",", ":", ",", "0", "]", "\n", "base_signals", "=", "np", ".", "array", "(", "base_signals", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "rec_src_signals", "=", "np", ".", "array", "(", "rec_src_signals", ")", "\n", "\n", "#", "\n", "collect_outputs", "=", "dict", "(", ")", "\n", "collect_outputs", "[", "self", ".", "score_scenarios", "[", "1", "]", "]", "=", "bss_eval", ".", "bss_eval_sources", "(", "org_src_signals", ",", "base_signals", ")", "\n", "collect_outputs", "[", "self", ".", "score_scenarios", "[", "0", "]", "]", "=", "bss_eval", ".", "bss_eval_sources", "(", "org_src_signals", ",", "rec_src_signals", ")", "\n", "\n", "nr_spk", "=", "len", "(", "org_src_signals", ")", "\n", "\n", "# convert the outputs to a single dictionary", "\n", "score_dict", "=", "dict", "(", ")", "\n", "for", "i", ",", "metric", "in", "enumerate", "(", "self", ".", "score_metrics", ")", ":", "\n", "\t\t\t", "score_dict", "[", "metric", "]", "=", "dict", "(", ")", "\n", "\n", "for", "j", ",", "scen", "in", "enumerate", "(", "self", ".", "score_scenarios", ")", ":", "\n", "\t\t\t\t", "score_dict", "[", "metric", "]", "[", "scen", "]", "=", "[", "]", "\n", "\n", "for", "spk", "in", "range", "(", "nr_spk", ")", ":", "\n", "\t\t\t\t\t", "score_dict", "[", "metric", "]", "[", "scen", "]", ".", "append", "(", "collect_outputs", "[", "scen", "]", "[", "i", "]", "[", "spk", "]", ")", "\n", "\n", "", "", "", "return", "score_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.ivector_extractor.IvectorExtractor.__init__": [[10, 29], ["speaker_verification_handler.SpeakerVerificationHandler.__init__", "ivector_extractor.IvectorExtractor.conf[].split", "len", "BaseException", "len"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "store_dir", ",", "exp_dir", ",", "task", ")", ":", "\n", "\n", "\t\t", "super", "(", "IvectorExtractor", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "store_dir", ",", "exp_dir", ",", "task", ")", "\n", "\n", "self", ".", "cut_to_seq_length", "=", "False", "\n", "\n", "if", "'normalization'", "not", "in", "self", ".", "conf", "or", "self", ".", "conf", "[", "'normalization'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalization", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalization", "=", "False", "\n", "\n", "", "if", "'output_names'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "self", ".", "requested_output_names", "=", "self", ".", "conf", "[", "'output_names'", "]", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "requested_output_names", "=", "self", ".", "base_requested_output_names", "\n", "", "if", "len", "(", "self", ".", "requested_output_names", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "\n", "'Expected the amount of requested output names to be one, but was %d isntead'", "%", "\n", "len", "(", "self", ".", "requested_output_names", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.ivector_extractor.IvectorExtractor.handle_output": [[30, 36], ["numpy.linalg.norm"], "methods", ["None"], ["", "", "def", "handle_output", "(", "self", ",", "output", ",", "utt_name", ")", ":", "\n", "\t\t", "handled_output", "=", "output", "[", "self", ".", "requested_output_names", "[", "0", "]", "]", "\n", "\n", "if", "self", ".", "normalization", ":", "\n", "\t\t\t", "handled_output", "=", "handled_output", "/", "(", "np", ".", "linalg", ".", "norm", "(", "handled_output", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-10", ")", "\n", "", "return", "handled_output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.speaker_verification_handler_factory.factory": [[7, 26], ["Exception"], "function", ["None"], ["def", "factory", "(", "speaker_verification_handler", ")", ":", "\n", "    ", "\"\"\"\n    gets a reconstructor class\n\n    Args:\n        speaker_verification_handler: the speaker_verification_handler type\n\n    Returns:\n        a speaker_verification_handler class\n    \"\"\"", "\n", "\n", "if", "speaker_verification_handler", "==", "'averager'", ":", "\n", "        ", "return", "averager", ".", "Averager", "\n", "", "elif", "speaker_verification_handler", "==", "'ivector_extractor'", ":", "\n", "        ", "return", "ivector_extractor", ".", "IvectorExtractor", "\n", "", "elif", "speaker_verification_handler", "==", "'attractor_from_embeddings'", ":", "\n", "        ", "return", "attractor_from_embeddings", ".", "AttractorFromEmbeddings", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Undefined speaker verification handler type: %s'", "%", "speaker_verification_handler", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.attractor_from_embeddings.AttractorFromEmbeddings.__init__": [[13, 69], ["speaker_verification_handler.SpeakerVerificationHandler.__init__", "int", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "NotImplementedError", "os.path.join", "dict", "os.path.join", "float", "usedbins_dataconfs.append", "attractor_from_embeddings.AttractorFromEmbeddings.conf[].split", "len", "BaseException", "open", "BaseException", "open", "json.load", "dict", "line.strip().split", "json.load.keys", "dataconf.items", "len", "line.strip"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "store_dir", ",", "exp_dir", ",", "task", ")", ":", "\n", "\n", "\t\t", "super", "(", "AttractorFromEmbeddings", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "store_dir", ",", "exp_dir", ",", "task", ")", "\n", "\n", "self", ".", "cut_to_seq_length", "=", "True", "\n", "\n", "self", ".", "emb_dim", "=", "int", "(", "conf", "[", "'emb_dim'", "]", ")", "\n", "\n", "self", ".", "task_for_masks", "=", "self", ".", "conf", "[", "'task_for_masks'", "]", "\n", "if", "self", ".", "task_for_masks", "in", "[", "'here'", ",", "'None'", ",", "task", "]", ":", "\n", "# Find the masks here. This only makes sense if the same embeddings were used for the speaker separation and", "\n", "# speaker recognition task", "\n", "\t\t\t", "raise", "NotImplementedError", "(", ")", "\n", "", "else", ":", "\n", "\t\t\t", "masks_pointer_file", "=", "os", ".", "path", ".", "join", "(", "exp_dir", ",", "'reconstructions'", ",", "self", ".", "task_for_masks", ",", "'masks_pointers.scp'", ")", "\n", "self", ".", "mix2maskfile", "=", "dict", "(", ")", "\n", "with", "open", "(", "masks_pointer_file", ",", "'r'", ")", "as", "masks_pointer_fid", ":", "\n", "\t\t\t\t", "for", "line", "in", "masks_pointer_fid", ":", "\n", "\t\t\t\t\t", "splitline", "=", "line", ".", "strip", "(", "'\\n'", ")", ".", "split", "(", "' '", ")", "\n", "self", ".", "mix2maskfile", "[", "splitline", "[", "0", "]", "]", "=", "splitline", "[", "1", "]", "\n", "\n", "", "", "if", "'score_type_for_perm'", "not", "in", "conf", ":", "\n", "\t\t\t\t", "raise", "BaseException", "(", "''", ")", "\n", "", "result_file", "=", "os", ".", "path", ".", "join", "(", "\n", "exp_dir", ",", "'results_%s_%s_complete.json'", "%", "(", "self", ".", "task_for_masks", ",", "conf", "[", "'score_type_for_perm'", "]", ")", ")", "\n", "with", "open", "(", "result_file", ",", "'r'", ")", "as", "result_fid", ":", "\n", "\t\t\t\t", "all_results", "=", "json", ".", "load", "(", "result_fid", ")", "\n", "", "self", ".", "mix2permutation", "=", "{", "name", ":", "all_results", "[", "name", "]", "[", "'score'", "]", "[", "'perm'", "]", "[", "'SS'", "]", "for", "name", "in", "all_results", ".", "keys", "(", ")", "}", "\n", "\n", "", "if", "'thr_for_mask'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "thr_for_mask", "=", "float", "(", "conf", "[", "'thr_for_mask'", "]", ")", "\n", "self", ".", "binary_masks", "=", "conf", "[", "'binary_masks'", "]", "==", "'True'", "\n", "if", "not", "self", ".", "binary_masks", ":", "\n", "\t\t\t\t", "self", ".", "rescale_masks", "=", "conf", "[", "'rescale_masks'", "]", "==", "'True'", "\n", "", "", "else", ":", "\n", "\t\t\t", "self", ".", "thr_for_mask", "=", "False", "\n", "\n", "", "usedbins_names", "=", "conf", "[", "'usedbins'", "]", ".", "split", "(", "' '", ")", "\n", "usedbins_dataconfs", "=", "[", "]", "\n", "for", "usedbins_name", "in", "usedbins_names", ":", "\n", "\t\t\t", "usedbins_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "usedbins_name", ")", ")", ")", "\n", "", "self", ".", "usedbins_reader", "=", "data_reader", ".", "DataReader", "(", "usedbins_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n", "if", "'normalization'", "not", "in", "self", ".", "conf", "or", "self", ".", "conf", "[", "'normalization'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalization", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalization", "=", "False", "\n", "\n", "", "if", "'output_names'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "self", ".", "requested_output_names", "=", "self", ".", "conf", "[", "'output_names'", "]", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "requested_output_names", "=", "self", ".", "base_requested_output_names", "\n", "", "if", "len", "(", "self", ".", "requested_output_names", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "\n", "'Expected the amount of requested output names to be one, but was %d instead'", "%", "\n", "len", "(", "self", ".", "requested_output_names", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.attractor_from_embeddings.AttractorFromEmbeddings.handle_output": [[70, 104], ["numpy.reshape", "numpy.load", "attractor_from_embeddings.AttractorFromEmbeddings.usedbins_reader", "numpy.expand_dims", "numpy.expand_dims", "numpy.sum", "numpy.sum", "numpy.expand_dims", "numpy.shape", "numpy.linalg.norm", "numpy.min", "numpy.max"], "methods", ["None"], ["", "", "def", "handle_output", "(", "self", ",", "output", ",", "utt_name", ")", ":", "\n", "\t\t", "handled_output", "=", "output", "[", "self", ".", "requested_output_names", "[", "0", "]", "]", "\n", "handled_output", "=", "np", ".", "reshape", "(", "handled_output", ",", "[", "np", ".", "shape", "(", "handled_output", ")", "[", "0", "]", ",", "-", "1", ",", "self", ".", "emb_dim", "]", ")", "\n", "\n", "# get the masks", "\n", "masks_file", "=", "self", ".", "mix2maskfile", "[", "utt_name", "]", "\n", "masks", "=", "np", ".", "load", "(", "masks_file", ")", "\n", "usedbins", ",", "_", "=", "self", ".", "usedbins_reader", "(", "self", ".", "pos", ")", "\n", "masks", "=", "masks", "*", "np", ".", "expand_dims", "(", "usedbins", ",", "0", ")", "\n", "masks", "=", "np", ".", "expand_dims", "(", "masks", ",", "-", "1", ")", "\n", "if", "self", ".", "thr_for_mask", ":", "\n", "\t\t\t", "binary_masks", "=", "masks", ">=", "self", ".", "thr_for_mask", "\n", "if", "self", ".", "binary_masks", ":", "\n", "\t\t\t\t", "masks", "=", "binary_masks", "\n", "", "else", ":", "\n", "\t\t\t\t", "masks", "=", "masks", "*", "binary_masks", "\n", "if", "self", ".", "rescale_masks", ":", "\n", "\t\t\t\t\t", "masks", "[", "binary_masks", "]", "=", "masks", "[", "binary_masks", "]", "-", "np", ".", "min", "(", "masks", "[", "binary_masks", "]", ")", "\n", "masks", "[", "binary_masks", "]", "=", "masks", "[", "binary_masks", "]", "/", "np", ".", "max", "(", "masks", "[", "binary_masks", "]", ")", "\n", "\n", "# get the attractors", "\n", "", "", "", "handled_output", "=", "np", ".", "expand_dims", "(", "handled_output", ",", "0", ")", "\n", "nominator_attr", "=", "np", ".", "sum", "(", "handled_output", "*", "masks", ",", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", "denominator_attr", "=", "np", ".", "sum", "(", "masks", ",", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", "attractors", "=", "nominator_attr", "/", "denominator_attr", "\n", "\n", "# get the permutation", "\n", "permutation", "=", "self", ".", "mix2permutation", "[", "utt_name", "]", "\n", "attractors", "=", "attractors", "[", "permutation", "]", "\n", "\n", "#", "\n", "if", "self", ".", "normalization", ":", "\n", "\t\t\t", "attractors", "=", "attractors", "/", "(", "np", ".", "linalg", ".", "norm", "(", "attractors", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-10", ")", "\n", "", "return", "attractors", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.speaker_verification_handler.SpeakerVerificationHandler.__init__": [[17, 74], ["evalconf.has_option", "evalconf.get().split", "int", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "int", "int", "map", "os.path.isdir", "os.makedirs", "os.path.isdir", "os.makedirs", "os.path.join", "input_features_dataconfs.append", "evalconf.get", "evalconf.get", "evalconf.get", "conf[].split", "os.path.join", "os.path.join", "os.path.isdir", "os.makedirs", "dict", "dataconf.items"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "store_dir", ",", "exp_dir", ",", "task", ")", ":", "\n", "\t\t", "\"\"\"Reconstructor constructor\n\n\t\tArgs:\n\t\t\tconf: the reconstructor configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\tstore_dir: the directory where the handled data will be stored\n\t\t\"\"\"", "\n", "\n", "self", ".", "conf", "=", "conf", "\n", "self", ".", "dataconf", "=", "dataconf", "\n", "if", "evalconf", ".", "has_option", "(", "task", ",", "'batch_size'", ")", ":", "\n", "\t\t\t", "self", ".", "batch_size", "=", "int", "(", "evalconf", ".", "get", "(", "task", ",", "'batch_size'", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "batch_size", "=", "int", "(", "evalconf", ".", "get", "(", "'evaluator'", ",", "'batch_size'", ")", ")", "\n", "", "self", ".", "segment_lengths", "=", "evalconf", ".", "get", "(", "'evaluator'", ",", "'segment_length'", ")", ".", "split", "(", "' '", ")", "\n", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "\n", "if", "'transpose_order'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "transpose_order", "=", "map", "(", "int", ",", "conf", "[", "'transpose_order'", "]", ".", "split", "(", "' '", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "transpose_order", "=", "False", "\n", "\n", "", "if", "'cut_to_seq_length'", "not", "in", "conf", "or", "conf", "[", "'cut_to_seq_length'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "cut_to_seq_length", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "cut_to_seq_length", "=", "False", "\n", "\n", "# create the directory to write down the reconstructions", "\n", "", "self", ".", "store_dir", "=", "store_dir", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "store_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "store_dir", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "self", ".", "store_dir", ",", "'data'", ")", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "store_dir", ",", "'data'", ")", ")", "\n", "# for spk in range(self.nrS):", "\n", "# \tif not os.path.isdir(os.path.join(self.store_dir, 's' + str(spk+1))):", "\n", "# \t\tos.makedirs(os.path.join(self.store_dir, 's' + str(spk+1)))", "\n", "\n", "# the use of the position variable only works because in the evaluator the", "\n", "# shuffle option in the data_queue is set to False!!", "\n", "", "self", ".", "pos", "=", "0", "\n", "\n", "# Whether the raw output should also be stored", "\n", "self", ".", "store_output", "=", "conf", "[", "'store_output'", "]", "==", "'True'", "\n", "if", "self", ".", "store_output", ":", "\n", "\t\t\t", "self", ".", "raw_output_dir", "=", "os", ".", "path", ".", "join", "(", "store_dir", ",", "'raw_output'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "raw_output_dir", ")", ":", "\n", "\t\t\t\t", "os", ".", "makedirs", "(", "self", ".", "raw_output_dir", ")", "\n", "\n", "# get the feature input reader, only to get the name of the utterance actually.", "\n", "", "", "input_features_names", "=", "conf", "[", "'input_features'", "]", ".", "split", "(", "' '", ")", "\n", "input_features_dataconfs", "=", "[", "]", "\n", "for", "input_features_name", "in", "input_features_names", ":", "\n", "\t\t\t", "input_features_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "input_features_name", ")", ")", ")", "\n", "", "self", ".", "input_features_reader", "=", "data_reader", ".", "DataReader", "(", "input_features_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.speaker_verification_handler.SpeakerVerificationHandler.__call__": [[75, 111], ["range", "speaker_verification_handler.SpeakerVerificationHandler.input_features_reader.get_name_for_pos", "dict", "speaker_verification_handler.SpeakerVerificationHandler.handle_output", "os.path.join", "numpy.save", "numpy.transpose", "numpy.save", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.postprocessing.data_reader.DataReader.get_name_for_pos", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.averager.Averager.handle_output"], ["", "def", "__call__", "(", "self", ",", "batch_outputs", ",", "batch_sequence_lengths", ")", ":", "\n", "\t\t", "\"\"\" handle the output and store it\n\n\t\tArgs:\n\t\t- batch_outputs: A dictionary containing the batch outputs of the network\n\t\t- batch_sequence_lengths: A dictionary containing the sequence length for each utterance\n\t\t\"\"\"", "\n", "if", "self", ".", "transpose_order", ":", "\n", "\t\t\t", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t", "batch_outputs", "[", "output_name", "]", "=", "np", ".", "transpose", "(", "batch_outputs", "[", "output_name", "]", ",", "self", ".", "transpose_order", ")", "\n", "\n", "", "", "for", "utt_ind", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "\n", "\t\t\t", "utt_name", "=", "self", ".", "input_features_reader", ".", "get_name_for_pos", "(", "self", ".", "pos", ")", "\n", "\n", "utt_output", "=", "dict", "(", ")", "\n", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t", "utt_output", "[", "output_name", "]", "=", "batch_outputs", "[", "output_name", "]", "[", "utt_ind", "]", "\n", "if", "self", ".", "cut_to_seq_length", ":", "\n", "\t\t\t\t\t", "utt_output", "[", "output_name", "]", "=", "utt_output", "[", "output_name", "]", "[", ":", "batch_sequence_lengths", "[", "output_name", "]", "[", "utt_ind", "]", ",", ":", "]", "\n", "\n", "# handle the output", "\n", "", "", "handled_output", "=", "self", ".", "handle_output", "(", "utt_output", ",", "utt_name", ")", "\n", "\n", "# store the handled output", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "store_dir", ",", "'data'", ",", "utt_name", "+", "'.npy'", ")", "\n", "np", ".", "save", "(", "filename", ",", "handled_output", ")", "\n", "\n", "# if requested store the raw output", "\n", "if", "self", ".", "store_output", ":", "\n", "\t\t\t\t", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t\t", "savename", "=", "output_name", "+", "'_'", "+", "utt_name", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "raw_output_dir", ",", "savename", ")", ",", "utt_output", "[", "output_name", "]", ")", "\n", "\n", "", "", "self", ".", "pos", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.speaker_verification_handler.SpeakerVerificationHandler.handle_output": [[113, 123], ["None"], "methods", ["None"], ["", "", "@", "abstractmethod", "\n", "def", "handle_output", "(", "self", ",", "output", ",", "utt_name", ")", ":", "\n", "\t\t", "\"\"\"handle the output\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\tutt_name: the name of the utterance\n\n\t\tReturns:\n\t\t\tthe handled output\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.speaker_verification_handler.SpeakerVerificationHandler.open_scp_files": [[124, 126], ["None"], "methods", ["None"], ["", "def", "open_scp_files", "(", "self", ",", "from_start", "=", "True", ")", ":", "\n", "\t\t", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.averager.Averager.__init__": [[10, 37], ["speaker_verification_handler.SpeakerVerificationHandler.__init__", "BaseException", "int", "averager.Averager.conf[].split", "len", "BaseException", "len"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "store_dir", ",", "exp_dir", ",", "task", ")", ":", "\n", "\n", "\t\t", "super", "(", "Averager", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "store_dir", ",", "exp_dir", ",", "task", ")", "\n", "\n", "if", "'squeeze'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'squeeze'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "squeeze", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "squeeze", "=", "False", "\n", "\n", "", "if", "self", ".", "conf", "[", "'activation'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t", "self", ".", "activation", "=", "'sigmoid'", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "'Other activations not yet implemented'", ")", "\n", "\n", "", "if", "'average_dimension'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "self", ".", "average_dimension", "=", "int", "(", "self", ".", "conf", "[", "'average_dimension'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "average_dimension", "=", "-", "1", "\n", "\n", "", "if", "'output_names'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "self", ".", "requested_output_names", "=", "self", ".", "conf", "[", "'output_names'", "]", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "requested_output_names", "=", "self", ".", "base_requested_output_names", "\n", "", "if", "len", "(", "self", ".", "requested_output_names", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "\n", "'Expected the amount of requested output names to be one, but was %d isntead'", "%", "\n", "len", "(", "self", ".", "requested_output_names", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.averager.Averager.handle_output": [[38, 49], ["numpy.mean", "numpy.squeeze", "averager.sigmoid"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "", "def", "handle_output", "(", "self", ",", "output", ",", "utt_name", ")", ":", "\n", "\t\t", "handled_output", "=", "output", "[", "self", ".", "requested_output_names", "[", "0", "]", "]", "\n", "\n", "if", "self", ".", "squeeze", ":", "\n", "\t\t\t", "handled_output", "=", "np", ".", "squeeze", "(", "handled_output", ")", "\n", "", "if", "self", ".", "activation", "==", "'sigmoid'", ":", "\n", "\t\t\t", "handled_output", "=", "sigmoid", "(", "handled_output", ")", "\n", "\n", "", "handled_output", "=", "np", ".", "mean", "(", "handled_output", ",", "axis", "=", "self", ".", "average_dimension", ")", "\n", "\n", "return", "handled_output", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verification_handlers.averager.sigmoid": [[51, 54], ["numpy.exp"], "function", ["None"], ["", "", "def", "sigmoid", "(", "inp", ")", ":", "\n", "\t", "outp", "=", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "inp", ")", ")", "\n", "return", "outp", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.speaker_verificaion_scorers.scorer_factory.factory": [[7, 23], ["Exception"], "function", ["None"], ["\n", "def", "factory", "(", "scorer", ")", ":", "\n", "    ", "\"\"\"\n    gets a scorer class\n\n    Args:\n        scorer: the scorer type\n\n    Returns:\n        a scorer class\n    \"\"\"", "\n", "\n", "if", "scorer", "==", "'sdr'", ":", "\n", "        ", "return", "sdr_scorer", ".", "SdrScorer", "\n", "# elif scorer == 'si_sdr':", "\n", "#     return si_sdr_scorer.SiSdrScorer", "\n", "", "elif", "scorer", "==", "'sdr_snr'", ":", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.oracle_reconstructor_noise.OracleReconstructor.__init__": [[19, 29], ["mask_reconstructor.MaskReconstructor.__init__", "dict", "nabu.postprocessing.data_reader.DataReader", "dict", "nabu.postprocessing.data_reader.DataReader", "dataconf.items", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ")", ":", "\n", "        ", "super", "(", "OracleReconstructor", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ")", "\n", "\n", "#get the original mixtures reader", "\n", "noise_targets_name", "=", "conf", "[", "'noise_targets'", "]", "\n", "noise_targets_dataconf", "=", "dict", "(", "dataconf", ".", "items", "(", "noise_targets_name", ")", ")", "\n", "self", ".", "noise_targets_reader", "=", "data_reader", ".", "DataReader", "(", "usedbins_dataconf", ",", "self", ".", "segment_lengths", ")", "\n", "binary_targets_name", "=", "conf", "[", "'binary_targets'", "]", "\n", "binary_targets_dataconf", "=", "dict", "(", "dataconf", ".", "items", "(", "noise_targets_name", ")", ")", "\n", "self", ".", "binary_targets_reader", "=", "data_reader", ".", "DataReader", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.oracle_reconstructor_noise.OracleReconstructor._get_masks": [[31, 54], ["oracle_reconstructor_noise.OracleReconstructor.noise_targets_reader", "noise_targets[].astype", "oracle_reconstructor_noise.OracleReconstructor.binary_targets_reader", "numpy.zeros", "range", "binary_targets[].astype"], "methods", ["None"], ["", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "        ", "'''estimate the masks\n\n        Args:\n            output: the output of a single utterance of the neural network\n            utt_info: some info on the utterance\n\n        Returns:\n            the estimated masks'''", "\n", "\n", "#only the non-silence bins will be used for the clustering", "\n", "noise_targets_complete", ",", "_", "=", "self", ".", "noise_targets_reader", "(", "self", ".", "pos", ")", "\n", "noise_targets", "=", "noise_targets", "[", ":", ",", "self", ".", "nrS", ":", ":", "self", ".", "nrS", "+", "1", "]", ".", "astype", "(", "int", ")", "\n", "binary_targets", ",", "_", "=", "self", ".", "binary_targets_reader", "(", "self", ".", "pos", ")", "\n", "\n", "#reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "for", "spk", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "            ", "binary_targets_spk", "=", "binary_targets", "[", ":", ",", "spk", ":", ":", ",", "self", ".", "nrS", "]", ".", "astype", "(", "int", ")", "\n", "masks", "[", "spk", ",", ":", ",", ":", "]", "=", "(", "1", "-", "noise_targets", ")", "*", "binary_targets_spk", "\n", "\n", "\n", "", "return", "masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.time_anchor_read_heads_deepattractornet_softmax_reconstructor.TimeAnchorReadHeadsDeepattractorSoftmaxReconstructor.__init__": [[17, 35], ["mask_reconstructor.MaskReconstructor.__init__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"TimeAnchorDeepattractorSoftmaxReconstructor constructor\n\n\t\tArgs:\n\t\tconf: the reconstructor configuration as a dictionary\n\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\tdataconf: the database configuration\n\t\trec_dir: the directory where the reconstructions will be stored\n\t\ttask: task name\n\t\t\"\"\"", "\n", "\n", "super", "(", "TimeAnchorReadHeadsDeepattractorSoftmaxReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "if", "'normalize'", "in", "conf", "and", "conf", "[", "'normalize'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.time_anchor_read_heads_deepattractornet_softmax_reconstructor.TimeAnchorReadHeadsDeepattractorSoftmaxReconstructor._get_masks": [[41, 81], ["numpy.shape", "numpy.reshape", "numpy.matmul", "numpy.exp", "numpy.matmul", "numpy.transpose", "numpy.shape", "Exception", "numpy.transpose", "numpy.transpose", "numpy.shape", "numpy.linalg.norm", "numpy.sum"], "methods", ["None"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\t\ttensor of dimension [Txfeature_dimension*emb_dim]\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "anchors", "=", "output", "[", "'anchors'", "]", "\n", "read_heads", "=", "output", "[", "'read_heads'", "]", "\n", "\n", "# Get number of time frames and frequency cells", "\n", "T", ",", "out_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "\n", "# Calculate the used embedding dimension", "\n", "emb_dim", "=", "np", ".", "shape", "(", "anchors", ")", "[", "-", "1", "]", "\n", "F", "=", "out_dim", "/", "emb_dim", "\n", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Number of frames in embeddings does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "# output_resh is a N times emb_dim matrix with the embedding vectors for all cells", "\n", "output_resh", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", ",", "F", ",", "emb_dim", "]", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "\t\t\t", "output_resh", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "output_resh", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "", "prod_1", "=", "np", ".", "matmul", "(", "anchors", ",", "np", ".", "transpose", "(", "output_resh", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "# dim: T x nrS x F", "\n", "tmp", "=", "np", ".", "exp", "(", "prod_1", ")", "\n", "masks_S", "=", "tmp", "/", "(", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "masks_Stot", "=", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "masks_S", ",", "[", "0", ",", "2", ",", "1", "]", ")", ",", "read_heads", ")", "# dim: (T x F x nrSmax)", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "masks_Stot", "=", "np", ".", "transpose", "(", "masks_Stot", ",", "[", "2", ",", "0", ",", "1", "]", ")", "\n", "# np.save(os.path.join(self.center_store_dir, utt_info['utt_name']), anchors)", "\n", "return", "masks_Stot", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepattractornet_softmax_reconstructor.DeepattractorSoftmaxReconstructor.__init__": [[18, 47], ["warnings.warn", "mask_reconstructor.MaskReconstructor.__init__", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "os.path.join", "usedbins_dataconfs.append", "os.path.isdir", "os.makedirs", "dict", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "        ", "\"\"\"DeepclusteringReconstructor constructor\n\n        Args:\n        conf: the reconstructor configuration as a dictionary\n        evalconf: the evaluator configuration as a ConfigParser\n        dataconf: the database configuration\n        rec_dir: the directory where the reconstructions will be stored\n        task: task name\n        \"\"\"", "\n", "\n", "warnings", ".", "warn", "(", "\n", "'In following versions this function will become deprecated. Use deepattractornet_reconstructor.py instead'", ",", "\n", "Warning", ")", "\n", "\n", "super", "(", "DeepattractorSoftmaxReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "# get the usedbins reader", "\n", "usedbins_names", "=", "conf", "[", "'usedbins'", "]", ".", "split", "(", "' '", ")", "\n", "usedbins_dataconfs", "=", "[", "]", "\n", "for", "usedbins_name", "in", "usedbins_names", ":", "\n", "            ", "usedbins_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "usedbins_name", ")", ")", ")", "\n", "", "self", ".", "usedbins_reader", "=", "data_reader", ".", "DataReader", "(", "usedbins_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n", "# directory where cluster centroids will be stored", "\n", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepattractornet_softmax_reconstructor.DeepattractorSoftmaxReconstructor._get_masks": [[48, 100], ["deepattractornet_softmax_reconstructor.DeepattractorSoftmaxReconstructor.usedbins_reader", "numpy.shape", "numpy.reshape", "numpy.reshape", "sklearn.cluster.KMeans", "range", "numpy.matmul", "numpy.exp", "numpy.reshape", "numpy.save", "Exception", "numpy.sum", "os.path.join", "numpy.shape", "numpy.shape", "sklearn.cluster.KMeans.fit"], "methods", ["None"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "        ", "\"\"\"estimate the masks\n\n        Args:\n            output: the output of a single utterance of the neural network\n                    tensor of dimension [Txfeature_dimension*emb_dim]\n\n        Returns:\n            the estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "# only the non-silence bins will be used for the clustering", "\n", "usedbins", ",", "_", "=", "self", ".", "usedbins_reader", "(", "self", ".", "pos", ")", "\n", "\n", "# Get number of time frames and frequency cells", "\n", "[", "T", ",", "F", "]", "=", "np", ".", "shape", "(", "usedbins", ")", "\n", "# Calculate the used embedding dimension", "\n", "emb_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "[", "1", "]", "/", "F", "\n", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "            ", "raise", "Exception", "(", "'Number of frames in usedbins does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "# output_resh is a N times emb_dim matrix with the embedding vectors for all cells", "\n", "output_resh", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", "*", "F", ",", "emb_dim", "]", ")", "\n", "\n", "# Only keep the active bins (above threshold) for clustering", "\n", "usedbins_resh", "=", "np", ".", "reshape", "(", "usedbins", ",", "T", "*", "F", ")", "\n", "output_speech_resh", "=", "output_resh", "[", "usedbins_resh", "]", "# dim:K' x embdim (K' is number of bins that are used K'=<K)", "\n", "\n", "# apply kmeans clustering and assign each bin to a clustering", "\n", "kmeans_model", "=", "KMeans", "(", "n_clusters", "=", "self", ".", "nrS", ",", "init", "=", "'k-means++'", ",", "n_init", "=", "10", ",", "max_iter", "=", "100", ",", "n_jobs", "=", "7", ")", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "# Sometime it fails due to some indexerror and I'm not sure why. Just retry then. max 5 times", "\n", "            ", "try", ":", "\n", "                ", "kmeans_model", ".", "fit", "(", "output_speech_resh", ")", "\n", "", "except", "IndexError", ":", "\n", "                ", "continue", "\n", "", "break", "\n", "\n", "# get cluster centers", "\n", "", "A", "=", "kmeans_model", ".", "cluster_centers_", "# dim: nrS x embdim", "\n", "\n", "prod_1", "=", "np", ".", "matmul", "(", "A", ",", "output_resh", ".", "T", ")", "# dim: nrS x K", "\n", "tmp", "=", "np", ".", "exp", "(", "prod_1", ")", "\n", "masks", "=", "tmp", "/", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "0", ")", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "reshape", "(", "masks", ",", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "kmeans_model", ".", "cluster_centers_", ")", "\n", "return", "masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.reconstructor.Reconstructor.__init__": [[17, 69], ["evalconf.has_option", "evalconf.get().split", "int", "range", "os.path.join", "int", "int", "map", "os.path.isdir", "os.makedirs", "os.path.join", "evalconf.get", "evalconf.get", "evalconf.get", "conf[].split", "os.path.isdir", "os.makedirs", "os.path.isdir", "os.makedirs", "os.path.join", "os.path.join", "str", "str"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"Reconstructor constructor\n\n\t\tArgs:\n\t\t\tconf: the reconstructor configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions will be stored\n\t\t\"\"\"", "\n", "\n", "self", ".", "conf", "=", "conf", "\n", "self", ".", "dataconf", "=", "dataconf", "\n", "if", "evalconf", ".", "has_option", "(", "task", ",", "'batch_size'", ")", ":", "\n", "\t\t\t", "self", ".", "batch_size", "=", "int", "(", "evalconf", ".", "get", "(", "task", ",", "'batch_size'", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "batch_size", "=", "int", "(", "evalconf", ".", "get", "(", "'evaluator'", ",", "'batch_size'", ")", ")", "\n", "", "self", ".", "segment_lengths", "=", "evalconf", ".", "get", "(", "'evaluator'", ",", "'segment_length'", ")", ".", "split", "(", "' '", ")", "\n", "self", ".", "optimal_frame_permutation", "=", "optimal_frame_permutation", "\n", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "\n", "if", "'transpose_order'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "transpose_order", "=", "map", "(", "int", ",", "conf", "[", "'transpose_order'", "]", ".", "split", "(", "' '", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "transpose_order", "=", "False", "\n", "\n", "# create the directory to write down the reconstructions", "\n", "", "self", ".", "rec_dir", "=", "rec_dir", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "rec_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "rec_dir", ")", "\n", "", "for", "spk", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t", "if", "not", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'s'", "+", "str", "(", "spk", "+", "1", ")", ")", ")", ":", "\n", "\t\t\t\t", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'s'", "+", "str", "(", "spk", "+", "1", ")", ")", ")", "\n", "\n", "# the use of the position variable only works because in the evaluator the", "\n", "# shuffle option in the data_queue is set to False!!", "\n", "", "", "self", ".", "pos", "=", "0", "\n", "\n", "self", ".", "scp_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'pointers.scp'", ")", "\n", "\n", "# whether to save output as numpy instead of wav file", "\n", "if", "'save_as_numpy'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "save_as_numpy", "=", "conf", "[", "'save_as_numpy'", "]", "in", "[", "'True'", ",", "'true'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "save_as_numpy", "=", "False", "\n", "\n", "# Whether the raw output should also be stored (besides the reconstructed audiosignal)", "\n", "", "self", ".", "store_output", "=", "conf", "[", "'store_output'", "]", "==", "'True'", "\n", "if", "self", ".", "store_output", ":", "\n", "\t\t\t", "self", ".", "output_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'raw_output'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "output_dir", ")", ":", "\n", "\t\t\t\t", "os", ".", "makedirs", "(", "self", ".", "output_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.reconstructor.Reconstructor.__call__": [[70, 111], ["range", "dict", "reconstructor.Reconstructor.reconstruct_signals", "numpy.transpose", "os.path.join", "numpy.save", "reconstructor.Reconstructor.write_audiofile", "numpy.save", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor.reconstruct_signals", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.dummy_reconstructor.DummyReconstructor.write_audiofile"], ["", "", "", "def", "__call__", "(", "self", ",", "batch_outputs", ",", "batch_sequence_lengths", ")", ":", "\n", "\t\t", "\"\"\" reconstruct the signals and write the audio files\n\n\t\tArgs:\n\t\t- batch_outputs: A dictionary containing the batch outputs of the network\n\t\t- batch_sequence_lengths: A dictionary containing the sequence length for each utterance\n\t\t\"\"\"", "\n", "if", "self", ".", "transpose_order", ":", "\n", "\t\t\t", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t", "batch_outputs", "[", "output_name", "]", "=", "np", ".", "transpose", "(", "batch_outputs", "[", "output_name", "]", ",", "self", ".", "transpose_order", ")", "\n", "\n", "", "", "for", "utt_ind", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "\n", "\t\t\t", "utt_output", "=", "dict", "(", ")", "\n", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "# anchor output for anchor_deepattractornet_softmax_reconstructor is special case", "\n", "\t\t\t\t", "if", "output_name", "is", "'anchors'", "and", "self", ".", "__class__", ".", "__name__", "in", "[", "'AnchorDeepattractorSoftmaxReconstructor'", ",", "'WeightedAnchorDeepattractorSoftmaxReconstructor'", "]", ":", "\n", "\t\t\t\t\t", "utt_output", "[", "output_name", "]", "=", "batch_outputs", "[", "output_name", "]", "\n", "", "elif", "output_name", "is", "'anchors_scale'", "and", "self", ".", "__class__", ".", "__name__", "in", "[", "'TimeAnchorScalarDeepattractorSoftmaxReconstructor'", "]", ":", "\n", "\t\t\t\t\t", "utt_output", "[", "output_name", "]", "=", "batch_outputs", "[", "output_name", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "utt_output", "[", "output_name", "]", "=", "batch_outputs", "[", "output_name", "]", "[", "utt_ind", "]", "[", ":", "batch_sequence_lengths", "[", "output_name", "]", "[", "utt_ind", "]", ",", ":", "]", "\n", "\n", "# reconstruct the signals", "\n", "", "", "reconstructed_signals", ",", "utt_info", "=", "self", ".", "reconstruct_signals", "(", "utt_output", ")", "\n", "\n", "# make the audio files for the reconstructed signals", "\n", "if", "self", ".", "save_as_numpy", ":", "\n", "\t\t\t\t", "filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "utt_info", "[", "'utt_name'", "]", "+", "'.npy'", ")", "\n", "np", ".", "save", "(", "filename", ",", "reconstructed_signals", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "write_audiofile", "(", "reconstructed_signals", ",", "utt_info", ")", "\n", "\n", "# if requested store the raw output", "\n", "", "if", "self", ".", "store_output", ":", "\n", "\t\t\t\t", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t\t", "savename", "=", "output_name", "+", "'_'", "+", "utt_info", "[", "'utt_name'", "]", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "savename", ")", ",", "utt_output", "[", "output_name", "]", ")", "\n", "\n", "", "", "self", ".", "pos", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.reconstructor.Reconstructor.opt_frame_perm": [[112, 147], ["range", "dict", "reconstructor.Reconstructor.reconstruct_signals_opt_frame_perm", "reconstructor.Reconstructor.write_audiofile", "batch_targets.keys", "numpy.save", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor.reconstruct_signals_opt_frame_perm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.dummy_reconstructor.DummyReconstructor.write_audiofile"], ["", "", "def", "opt_frame_perm", "(", "self", ",", "batch_outputs", ",", "batch_targets", ",", "batch_sequence_lengths", ")", ":", "\n", "\t\t", "\"\"\" reconstruct the signals, using the optimal speaker permutations on frame level using the targets, and write\n\t\tthe audio files\n\n\t\tArgs:\n\t\t- batch_outputs: A dictionary containing the batch outputs of the network\n\t\t- batch_outputs: A dictionary containing the batch targets for the outputs\n\t\t- batch_sequence_lengths: A dictionary containing the sequence length for each utterance\n\t\t\"\"\"", "\n", "\n", "for", "utt_ind", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "\n", "\t\t\t", "utt_output", "=", "dict", "(", ")", "\n", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t", "utt_output", "[", "output_name", "]", "=", "batch_outputs", "[", "output_name", "]", "[", "utt_ind", "]", "[", ":", "batch_sequence_lengths", "[", "output_name", "]", "[", "utt_ind", "]", ",", ":", "]", "\n", "# assuming only one requested target", "\n", "", "target_keys", "=", "[", "key", "for", "key", "in", "batch_targets", ".", "keys", "(", ")", "if", "'target'", "in", "key", "]", "\n", "utt_target", "=", "{", "\n", "key", ":", "batch_targets", "[", "key", "]", "[", "utt_ind", "]", "[", ":", "batch_sequence_lengths", "[", "output_name", "]", "[", "utt_ind", "]", ",", ":", "]", "\n", "for", "key", "in", "target_keys", "}", "\n", "\n", "# reconstruct the signals", "\n", "reconstructed_signals", ",", "utt_info", "=", "self", ".", "reconstruct_signals_opt_frame_perm", "(", "utt_output", ",", "utt_target", ")", "\n", "\n", "# make the audio files for the reconstructed signals", "\n", "self", ".", "write_audiofile", "(", "reconstructed_signals", ",", "utt_info", ")", "\n", "\n", "# if requested store the raw output", "\n", "if", "self", ".", "store_output", ":", "\n", "\t\t\t\t", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t\t", "savename", "=", "output_name", "+", "'_'", "+", "utt_info", "[", "'utt_name'", "]", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "savename", ")", ",", "utt_output", "[", "output_name", "]", ")", "\n", "\n", "", "", "self", ".", "pos", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.reconstructor.Reconstructor.reconstruct_signals": [[148, 157], ["None"], "methods", ["None"], ["", "", "@", "abstractmethod", "\n", "def", "reconstruct_signals", "(", "self", ",", "output", ")", ":", "\n", "\t\t", "\"\"\"reconstruct the signals\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\n\t\tReturns:\n\t\t\tthe reconstructed signals\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.reconstructor.Reconstructor.write_audiofile": [[158, 178], ["range", "reconstructor.Reconstructor.scp_fid.write", "os.path.join", "os.path.join", "scipy.write", "numpy.float32", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_audiofile", "(", "self", ",", "reconstructed_signals", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"write the audiofiles for the reconstructions\n\n\t\tArgs:\n\t\t\treconstructed_signals: the reconstructed signals for a single mixture\n\t\t\tutt_info: some info on the utterance\n\t\"\"\"", "\n", "\n", "write_str", "=", "utt_info", "[", "'utt_name'", "]", "\n", "for", "spk", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t", "rec_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'s'", "+", "str", "(", "spk", "+", "1", ")", ")", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "utt_info", "[", "'utt_name'", "]", "+", "'.wav'", ")", "\n", "signal", "=", "reconstructed_signals", "[", "spk", "]", "\n", "if", "signal", ".", "dtype", "==", "np", ".", "float64", ":", "\n", "\t\t\t\t", "signal", "=", "np", ".", "float32", "(", "signal", ")", "\n", "", "wav", ".", "write", "(", "filename", ",", "utt_info", "[", "'rate'", "]", ",", "signal", ")", "\n", "write_str", "+=", "' '", "+", "filename", "\n", "\n", "", "write_str", "+=", "' \\n'", "\n", "self", ".", "scp_fid", ".", "write", "(", "write_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.reconstructor.Reconstructor.open_scp_files": [[179, 185], ["open"], "methods", ["None"], ["", "def", "open_scp_files", "(", "self", ",", "from_start", "=", "True", ")", ":", "\n", "\t\t", "if", "from_start", ":", "\n", "\t\t\t", "file_mode", "=", "'w'", "\n", "", "else", ":", "\n", "\t\t\t", "file_mode", "=", "'a+'", "\n", "", "self", ".", "scp_fid", "=", "open", "(", "self", ".", "scp_file", ",", "file_mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.time_anchor_deepattractornet_softmax_reconstructor.TimeAnchorDeepattractorSoftmaxReconstructor.__init__": [[15, 43], ["mask_reconstructor.MaskReconstructor.__init__", "os.path.join", "os.path.isdir", "os.makedirs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"TimeAnchorDeepattractorSoftmaxReconstructor constructor\n\n\t\tArgs:\n\t\tconf: the reconstructor configuration as a dictionary\n\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\tdataconf: the database configuration\n\t\trec_dir: the directory where the reconstructions will be stored\n\t\ttask: task name\n\t\t\"\"\"", "\n", "\n", "super", "(", "TimeAnchorDeepattractorSoftmaxReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "if", "'normalize'", "in", "conf", "and", "conf", "[", "'normalize'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "False", "\n", "\n", "", "if", "'normalize_anchor'", "in", "conf", "and", "conf", "[", "'normalize_anchor'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize_anchor", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize_anchor", "=", "False", "\n", "\n", "# directory where cluster centroids will be stored", "\n", "", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.time_anchor_deepattractornet_softmax_reconstructor.TimeAnchorDeepattractorSoftmaxReconstructor._get_masks": [[44, 83], ["numpy.shape", "numpy.reshape", "numpy.matmul", "numpy.exp", "numpy.transpose", "numpy.save", "numpy.shape", "Exception", "numpy.transpose", "os.path.join", "numpy.shape", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.sum"], "methods", ["None"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\t\ttensor of dimension [Txfeature_dimension*emb_dim]\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "anchors", "=", "output", "[", "'anchors'", "]", "\n", "\n", "# Get number of time frames and frequency cells", "\n", "T", ",", "out_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "\n", "# Calculate the used embedding dimension", "\n", "emb_dim", "=", "np", ".", "shape", "(", "anchors", ")", "[", "-", "1", "]", "\n", "F", "=", "out_dim", "/", "emb_dim", "\n", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Number of frames in usedbins does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "# output_resh is a N times emb_dim matrix with the embedding vectors for all cells", "\n", "output_resh", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", ",", "F", ",", "emb_dim", "]", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "\t\t\t", "output_resh", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "output_resh", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "", "if", "self", ".", "normalize_anchor", ":", "\n", "\t\t\t", "anchors", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "anchors", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "", "prod_1", "=", "np", ".", "matmul", "(", "anchors", ",", "np", ".", "transpose", "(", "output_resh", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "# dim: T x nrS x F", "\n", "tmp", "=", "np", ".", "exp", "(", "prod_1", ")", "\n", "masks", "=", "tmp", "/", "(", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "transpose", "(", "masks", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "anchors", ")", "\n", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.time_anchor_deepattractornet_softmax_reconstructor.TimeAnchorScalarDeepattractorSoftmaxReconstructor.__init__": [[91, 119], ["mask_reconstructor.MaskReconstructor.__init__", "os.path.join", "os.path.isdir", "os.makedirs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"TimeAnchorScalarDeepattractorSoftmaxReconstructor constructor\n\n\t\tArgs:\n\t\tconf: the reconstructor configuration as a dictionary\n\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\tdataconf: the database configuration\n\t\trec_dir: the directory where the reconstructions will be stored\n\t\ttask: task name\n\t\t\"\"\"", "\n", "\n", "super", "(", "TimeAnchorScalarDeepattractorSoftmaxReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "if", "'normalize'", "in", "conf", "and", "conf", "[", "'normalize'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "False", "\n", "\n", "", "if", "'normalize_anchor'", "in", "conf", "and", "conf", "[", "'normalize_anchor'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize_anchor", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize_anchor", "=", "False", "\n", "\n", "# directory where cluster centroids will be stored", "\n", "", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.time_anchor_deepattractornet_softmax_reconstructor.TimeAnchorScalarDeepattractorSoftmaxReconstructor._get_masks": [[120, 161], ["numpy.shape", "numpy.reshape", "numpy.matmul", "numpy.exp", "numpy.transpose", "numpy.save", "numpy.shape", "Exception", "numpy.transpose", "os.path.join", "numpy.shape", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.sum"], "methods", ["None"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\t\ttensor of dimension [Txfeature_dimension*emb_dim]\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "anchors", "=", "output", "[", "'anchors'", "]", "\n", "anchors_scale", "=", "output", "[", "'anchors_scale'", "]", "[", "0", ",", "0", "]", "\n", "\n", "# Get number of time frames and frequency cells", "\n", "T", ",", "out_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "\n", "# Calculate the used embedding dimension", "\n", "emb_dim", "=", "np", ".", "shape", "(", "anchors", ")", "[", "-", "1", "]", "\n", "F", "=", "out_dim", "/", "emb_dim", "\n", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Number of frames in usedbins does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "# output_resh is a N times emb_dim matrix with the embedding vectors for all cells", "\n", "output_resh", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", ",", "F", ",", "emb_dim", "]", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "\t\t\t", "output_resh", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "output_resh", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "", "if", "self", ".", "normalize_anchor", ":", "\n", "\t\t\t", "anchors", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "anchors", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "", "anchors", "*=", "anchors_scale", "\n", "\n", "prod_1", "=", "np", ".", "matmul", "(", "anchors", ",", "np", ".", "transpose", "(", "output_resh", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "# dim: T x nrS x F", "\n", "tmp", "=", "np", ".", "exp", "(", "prod_1", ")", "\n", "masks", "=", "tmp", "/", "(", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "transpose", "(", "masks", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "anchors", ")", "\n", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.time_anchor_deepattractornet_softmax_reconstructor.TimeAnchorSpkWeightsDeepattractorSoftmaxReconstructor.__init__": [[169, 202], ["mask_reconstructor.MaskReconstructor.__init__", "os.path.join", "os.path.isdir", "os.makedirs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"TimeAnchorScalarDeepattractorSoftmaxReconstructor constructor\n\n\t\tArgs:\n\t\tconf: the reconstructor configuration as a dictionary\n\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\tdataconf: the database configuration\n\t\trec_dir: the directory where the reconstructions will be stored\n\t\ttask: task name\n\t\t\"\"\"", "\n", "\n", "super", "(", "TimeAnchorSpkWeightsDeepattractorSoftmaxReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "if", "'normalize'", "in", "conf", "and", "conf", "[", "'normalize'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "False", "\n", "\n", "", "if", "'normalize_anchor'", "in", "conf", "and", "conf", "[", "'normalize_anchor'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize_anchor", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize_anchor", "=", "False", "\n", "\n", "", "if", "'av_speaker_logits_time_flag'", "in", "conf", "and", "conf", "[", "'av_speaker_logits_time_flag'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "av_speaker_logits_time_flag", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "av_speaker_logits_time_flag", "=", "False", "\n", "\n", "# directory where cluster centroids will be stored", "\n", "", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.time_anchor_deepattractornet_softmax_reconstructor.TimeAnchorSpkWeightsDeepattractorSoftmaxReconstructor._get_masks": [[203, 247], ["numpy.expand_dims", "numpy.shape", "numpy.reshape", "numpy.matmul", "numpy.exp", "numpy.transpose", "numpy.save", "numpy.shape", "Exception", "numpy.mean", "numpy.transpose", "os.path.join", "numpy.shape", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.sum"], "methods", ["None"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\t\ttensor of dimension [Txfeature_dimension*emb_dim]\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "anchors", "=", "output", "[", "'anchors'", "]", "\n", "speaker_logits", "=", "output", "[", "'speaker_logits'", "]", "\n", "speaker_logits", "=", "np", ".", "expand_dims", "(", "speaker_logits", ",", "-", "1", ")", "\n", "\n", "# Get number of time frames and frequency cells", "\n", "T", ",", "out_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "\n", "# Calculate the used embedding dimension", "\n", "emb_dim", "=", "np", ".", "shape", "(", "anchors", ")", "[", "-", "1", "]", "\n", "F", "=", "out_dim", "/", "emb_dim", "\n", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Number of frames in usedbins does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "# output_resh is a N times emb_dim matrix with the embedding vectors for all cells", "\n", "output_resh", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", ",", "F", ",", "emb_dim", "]", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "\t\t\t", "output_resh", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "output_resh", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "", "if", "self", ".", "normalize_anchor", ":", "\n", "\t\t\t", "anchors", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "anchors", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "", "if", "self", ".", "av_speaker_logits_time_flag", ":", "\n", "\t\t\t", "speaker_logits", "=", "np", ".", "mean", "(", "speaker_logits", ",", "0", ",", "keepdims", "=", "True", ")", "\n", "", "anchors", "*=", "speaker_logits", "\n", "\n", "prod_1", "=", "np", ".", "matmul", "(", "anchors", ",", "np", ".", "transpose", "(", "output_resh", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "# dim: T x nrS x F", "\n", "tmp", "=", "np", ".", "exp", "(", "prod_1", ")", "\n", "masks", "=", "tmp", "/", "(", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "transpose", "(", "masks", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "anchors", ")", "\n", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepattractornet_reconstructor.DeepattractorReconstructor.__init__": [[18, 45], ["mask_reconstructor.MaskReconstructor.__init__", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "os.path.join", "usedbins_dataconfs.append", "os.path.isdir", "os.makedirs", "dict", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "        ", "\"\"\"DeepclusteringReconstructor constructor\n\n        Args:\n        conf: the reconstructor configuration as a dictionary\n        evalconf: the evaluator configuration as a ConfigParser\n        dataconf: the database configuration\n        rec_dir: the directory where the reconstructions will be stored\n        task: task name\n        \"\"\"", "\n", "\n", "super", "(", "DeepattractorReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "self", ".", "activation", "=", "conf", "[", "'activation'", "]", "\n", "\n", "# get the usedbins reader", "\n", "usedbins_names", "=", "conf", "[", "'usedbins'", "]", ".", "split", "(", "' '", ")", "\n", "usedbins_dataconfs", "=", "[", "]", "\n", "for", "usedbins_name", "in", "usedbins_names", ":", "\n", "            ", "usedbins_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "usedbins_name", ")", ")", ")", "\n", "", "self", ".", "usedbins_reader", "=", "data_reader", ".", "DataReader", "(", "usedbins_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n", "# directory where cluster centroids will be stored", "\n", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepattractornet_reconstructor.DeepattractorReconstructor._get_masks": [[46, 102], ["deepattractornet_reconstructor.DeepattractorReconstructor.usedbins_reader", "numpy.shape", "numpy.reshape", "numpy.reshape", "sklearn.cluster.KMeans", "range", "numpy.matmul", "numpy.reshape", "numpy.save", "Exception", "scipy.special.softmax", "BaseException", "os.path.join", "numpy.shape", "numpy.shape", "sklearn.cluster.KMeans.fit"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "        ", "\"\"\"estimate the masks\n\n        Args:\n            output: the output of a single utterance of the neural network\n                    tensor of dimension [Txfeature_dimension*emb_dim]\n\n        Returns:\n            the estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "# only the non-silence bins will be used for the clustering", "\n", "usedbins", ",", "_", "=", "self", ".", "usedbins_reader", "(", "self", ".", "pos", ")", "\n", "\n", "# Get number of time frames and frequency cells", "\n", "[", "T", ",", "F", "]", "=", "np", ".", "shape", "(", "usedbins", ")", "\n", "# Calculate the used embedding dimension", "\n", "emb_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "[", "1", "]", "/", "F", "\n", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "            ", "raise", "Exception", "(", "'Number of frames in usedbins does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "# output_resh is a N times emb_dim matrix with the embedding vectors for all cells", "\n", "output_resh", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", "*", "F", ",", "emb_dim", "]", ")", "\n", "\n", "# Only keep the active bins (above threshold) for clustering", "\n", "usedbins_resh", "=", "np", ".", "reshape", "(", "usedbins", ",", "T", "*", "F", ")", "\n", "output_speech_resh", "=", "output_resh", "[", "usedbins_resh", "]", "# dim:K' x embdim (K' is number of bins that are used K'=<K)", "\n", "\n", "# apply kmeans clustering and assign each bin to a clustering", "\n", "kmeans_model", "=", "KMeans", "(", "n_clusters", "=", "self", ".", "nrS", ",", "init", "=", "'k-means++'", ",", "n_init", "=", "10", ",", "max_iter", "=", "100", ",", "n_jobs", "=", "7", ")", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "# Sometime it fails due to some indexerror and I'm not sure why. Just retry then. max 5 times", "\n", "            ", "try", ":", "\n", "                ", "kmeans_model", ".", "fit", "(", "output_speech_resh", ")", "\n", "", "except", "IndexError", ":", "\n", "                ", "continue", "\n", "", "break", "\n", "\n", "# get cluster centers", "\n", "", "A", "=", "kmeans_model", ".", "cluster_centers_", "# dim: nrS x embdim", "\n", "\n", "prod_1", "=", "np", ".", "matmul", "(", "A", ",", "output_resh", ".", "T", ")", "# dim: nrS x K", "\n", "if", "self", ".", "activation", "==", "'softmax'", ":", "\n", "# tmp = np.exp(prod_1)", "\n", "# masks = tmp / (np.sum(tmp, axis=0) + 1e-12)", "\n", "            ", "masks", "=", "scipy", ".", "special", ".", "softmax", "(", "prod_1", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "raise", "BaseException", "(", "'Unknown activation %s'", "%", "self", ".", "activation", ")", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "", "masks", "=", "np", ".", "reshape", "(", "masks", ",", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "kmeans_model", ".", "cluster_centers_", ")", "\n", "return", "masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_reconstructor.StackedmasksReconstructor.__init__": [[17, 46], ["mask_reconstructor.MaskReconstructor.__init__", "Exception", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "usedbins_dataconfs.append", "dict", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"StackedmasksReconstructor constructor\n\n\t\tArgs:\n\t\t\tconf: the reconstructor configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions will be stored\n\t\t\"\"\"", "\n", "if", "'softmax_flag'", "in", "conf", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Softmax argument is deprecated. Use activation'", ")", "\n", "\n", "", "if", "'activation'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "activation", "=", "conf", "[", "'activation'", "]", "\n", "", "elif", "'output_activation'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "activation", "=", "conf", "[", "'output_activation'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "activation", "=", "'softmax'", "\n", "\n", "", "super", "(", "StackedmasksReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "if", "optimal_frame_permutation", ":", "\n", "# get the usedbins reader", "\n", "\t\t\t", "usedbins_names", "=", "conf", "[", "'usedbins'", "]", ".", "split", "(", "' '", ")", "\n", "usedbins_dataconfs", "=", "[", "]", "\n", "for", "usedbins_name", "in", "usedbins_names", ":", "\n", "\t\t\t\t", "usedbins_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "usedbins_name", ")", ")", ")", "\n", "", "self", ".", "usedbins_reader", "=", "data_reader", ".", "DataReader", "(", "usedbins_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_reconstructor.StackedmasksReconstructor._get_masks": [[47, 82], ["numpy.shape", "numpy.transpose", "len", "numpy.reshape", "stackedmasks_reconstructor.softmax", "len", "Exception", "stackedmasks_reconstructor.sigmoid", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"get the masks by simply destacking the stacked masks into separate masks and\n\t\tnormalizing them with softmax\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\tutt_info: some info on the utterance\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "bin_ests", "=", "output", "[", "'bin_est'", "]", "\n", "\n", "bin_ests_shape", "=", "np", ".", "shape", "(", "bin_ests", ")", "\n", "if", "len", "(", "bin_ests_shape", ")", "==", "2", ":", "\n", "\t\t\t", "[", "T", ",", "target_dim", "]", "=", "bin_ests_shape", "\n", "F", "=", "target_dim", "/", "self", ".", "nrS", "\n", "masks", "=", "np", ".", "reshape", "(", "bin_ests", ",", "[", "T", ",", "F", ",", "self", ".", "nrS", "]", ",", "'F'", ")", "\n", "", "elif", "len", "(", "bin_ests_shape", ")", "==", "3", ":", "\n", "\t\t\t", "[", "T", ",", "F", ",", "_", "]", "=", "bin_ests_shape", "\n", "masks", "=", "bin_ests", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Unexpected shape for bin estimates'", ")", "\n", "", "masks", "=", "np", ".", "transpose", "(", "masks", ",", "[", "2", ",", "0", ",", "1", "]", ")", "\n", "\n", "# apply softmax", "\n", "if", "self", ".", "activation", "==", "'softmax'", ":", "\n", "\t\t\t", "masks", "=", "softmax", "(", "masks", ",", "axis", "=", "0", ")", "\n", "", "elif", "self", ".", "activation", "==", "'sigmoid'", ":", "\n", "\t\t\t", "masks", "=", "sigmoid", "(", "masks", ")", "\n", "", "elif", "self", ".", "activation", "in", "[", "'None'", ",", "'none'", ",", "None", "]", ":", "\n", "\t\t\t", "pass", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Unknown requested output activation'", ")", "\n", "\n", "", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_reconstructor.StackedmasksReconstructor._get_masks_opt_frame_perm": [[83, 126], ["stackedmasks_reconstructor.StackedmasksReconstructor.usedbins_reader", "numpy.shape", "stackedmasks_reconstructor.StackedmasksReconstructor._get_masks", "numpy.reshape", "numpy.transpose", "numpy.abs", "numpy.sum", "numpy.expand_dims", "numpy.zeros", "list", "range", "itertools.permutations", "numpy.zeros", "enumerate", "numpy.argmin", "range", "numpy.sum", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor._get_masks"], ["", "def", "_get_masks_opt_frame_perm", "(", "self", ",", "output", ",", "target", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\ttarget: the target of a single utterance of the neural network\n\t\t\tutt_info: some info on the utterance\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "# only the non-silence bins will be used for determining the optimal frame level permutation", "\n", "usedbins", ",", "_", "=", "self", ".", "usedbins_reader", "(", "self", ".", "pos", ")", "\n", "\n", "[", "T", ",", "F", "]", "=", "np", ".", "shape", "(", "usedbins", ")", "\n", "\n", "masks", "=", "self", ".", "_get_masks", "(", "output", ",", "utt_info", ")", "\n", "\n", "# apply frame lever permutations to get the optimal masks, according to the targets", "\n", "target", "=", "target", "[", "'multi_targets'", "]", "\n", "target", "=", "np", ".", "reshape", "(", "target", ",", "[", "T", ",", "F", ",", "self", ".", "nrS", "]", ")", "\n", "target", "=", "np", ".", "transpose", "(", "target", ",", "[", "2", ",", "0", ",", "1", "]", ")", "\n", "target", "=", "np", ".", "abs", "(", "target", ")", "\n", "sum_targets", "=", "np", ".", "sum", "(", "target", ",", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "irms", "=", "target", "/", "sum_targets", "\n", "usedbins_ext", "=", "np", ".", "expand_dims", "(", "usedbins", ",", "0", ")", "\n", "opt_masks", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "all_perms", "=", "list", "(", "itertools", ".", "permutations", "(", "range", "(", "self", ".", "nrS", ")", ")", ")", "\n", "for", "t", "in", "range", "(", "T", ")", ":", "\n", "\t\t\t", "mask_frame_t", "=", "masks", "[", ":", ",", "t", ",", ":", "]", "\n", "irms_frame_t", "=", "irms", "[", ":", ",", "t", ",", ":", "]", "\n", "usedbins_frame_t", "=", "usedbins_ext", "[", ":", ",", "t", ",", ":", "]", "\n", "\n", "perm_values", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrS", "]", ")", "\n", "for", "perm_ind", ",", "perm", "in", "enumerate", "(", "all_perms", ")", ":", "\n", "\t\t\t\t", "perm_value", "=", "np", ".", "sum", "(", "usedbins_frame_t", "*", "np", ".", "abs", "(", "mask_frame_t", "[", "perm", ",", ":", "]", "-", "irms_frame_t", ")", ")", "\n", "perm_values", "[", "perm_ind", "]", "=", "perm_value", "\n", "\n", "", "best_perm_ind", "=", "np", ".", "argmin", "(", "perm_values", ")", "\n", "best_perm", "=", "all_perms", "[", "best_perm_ind", "]", "\n", "\n", "opt_masks", "[", ":", ",", "t", ",", ":", "]", "=", "mask_frame_t", "[", "best_perm", ",", ":", "]", "\n", "\n", "", "return", "opt_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_reconstructor.sigmoid": [[127, 129], ["numpy.exp"], "function", ["None"], ["", "", "def", "sigmoid", "(", "x", ")", ":", "\n", "\t", "return", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_reconstructor.softmax": [[131, 134], ["numpy.exp", "numpy.sum"], "function", ["None"], ["", "def", "softmax", "(", "x", ",", "axis", "=", "0", ")", ":", "\n", "\t", "tmp", "=", "np", ".", "exp", "(", "x", ")", "\n", "return", "tmp", "/", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "axis", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.parallel_reconstructor.ParallelReconstructor.__init__": [[18, 58], ["evalconf.has_option", "evalconf.get().split", "int", "range", "os.path.join", "int", "int", "os.path.isdir", "os.makedirs", "os.path.join", "evalconf.get", "evalconf.get", "evalconf.get", "os.path.isdir", "os.makedirs", "os.path.isdir", "os.makedirs", "os.path.join", "os.path.join", "str", "str"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ")", ":", "\n", "\t\t", "\"\"\"ParallelReconstructor constructor\n\n\t\tArgs:\n\t\t\tconf: the reconstructor configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions will be stored\n\t\t\"\"\"", "\n", "\n", "self", ".", "conf", "=", "conf", "\n", "self", ".", "dataconf", "=", "dataconf", "\n", "if", "evalconf", ".", "has_option", "(", "task", ",", "'batch_size'", ")", ":", "\n", "\t\t\t", "self", ".", "batch_size", "=", "int", "(", "evalconf", ".", "get", "(", "task", ",", "'batch_size'", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "batch_size", "=", "int", "(", "evalconf", ".", "get", "(", "'evaluator'", ",", "'batch_size'", ")", ")", "\n", "", "self", ".", "segment_lengths", "=", "evalconf", ".", "get", "(", "'evaluator'", ",", "'segment_length'", ")", ".", "split", "(", "' '", ")", "\n", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "\n", "# create the directory to write down the reconstructions", "\n", "self", ".", "rec_dir", "=", "rec_dir", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "rec_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "rec_dir", ")", "\n", "", "for", "spk", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t", "if", "not", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'s'", "+", "str", "(", "spk", "+", "1", ")", ")", ")", ":", "\n", "\t\t\t\t", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'s'", "+", "str", "(", "spk", "+", "1", ")", ")", ")", "\n", "\n", "# the use of the position variable only works because in the evaluator the", "\n", "# shuffle option in the data_queue is set to False!!", "\n", "", "", "self", ".", "pos", "=", "0", "\n", "\n", "self", ".", "scp_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'pointers.scp'", ")", "\n", "\n", "# Wheter the raw output should also be stored (besides the reconstructed audiosignal)", "\n", "self", ".", "store_output", "=", "conf", "[", "'store_output'", "]", "==", "'True'", "\n", "if", "self", ".", "store_output", ":", "\n", "\t\t\t", "self", ".", "output_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'raw_output'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "output_dir", ")", ":", "\n", "\t\t\t\t", "os", ".", "makedirs", "(", "self", ".", "output_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.parallel_reconstructor.ParallelReconstructor.__call__": [[59, 71], ["joblib.Parallel", "joblib.delayed", "range"], "methods", ["None"], ["", "", "", "def", "__call__", "(", "self", ",", "batch_outputs", ",", "batch_sequence_lengths", ")", ":", "\n", "\t\t", "\"\"\" reconstruct the signals and write the audio files\n\t\t\n\t\tArgs:\n\t\t- batch_outputs: A dictionary containing the batch outputs of the network\n\t\t- batch_sequence_lengths: A dictionary containing the sequence length for each utterance\n\t\t\"\"\"", "\n", "\n", "Parallel", "(", "n_jobs", "=", "6", ")", "(", "delayed", "(", "self", ".", "reconstruct_1_signal", ")", "(", "\n", "i", ",", "batch_outputs", ",", "batch_sequence_lengths", ")", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ")", "\n", "\n", "self", ".", "pos", "+=", "self", ".", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.parallel_reconstructor.ParallelReconstructor.reconstruct_1_signal": [[72, 89], ["dict", "parallel_reconstructor.ParallelReconstructor.reconstruct_signals", "parallel_reconstructor.ParallelReconstructor.write_audiofile", "numpy.save", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor.reconstruct_signals", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.dummy_reconstructor.DummyReconstructor.write_audiofile"], ["", "def", "reconstruct_1_signal", "(", "self", ",", "utt_ind", ",", "batch_outputs", ",", "batch_sequence_lengths", ")", ":", "\n", "\t\t", "utt_output", "=", "dict", "(", ")", "\n", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t", "utt_output", "[", "output_name", "]", "=", "batch_outputs", "[", "output_name", "]", "[", "utt_ind", "]", "[", ":", "batch_sequence_lengths", "[", "output_name", "]", "[", "utt_ind", "]", ",", ":", "]", "\n", "\n", "# reconstruct the singnals", "\n", "", "reconstructed_signals", ",", "utt_info", "=", "self", ".", "reconstruct_signals", "(", "self", ".", "pos", "+", "utt_ind", ",", "utt_output", ")", "\n", "\n", "# make the audiofiles for the reconstructed signals", "\n", "self", ".", "write_audiofile", "(", "reconstructed_signals", ",", "utt_info", ")", "\n", "\n", "# if requested store the raw output", "\n", "if", "self", ".", "store_output", ":", "\n", "\t\t\t", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t", "savename", "=", "output_name", "+", "'_'", "+", "utt_info", "[", "'utt_name'", "]", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "savename", ")", ",", "utt_output", "[", "output_name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.parallel_reconstructor.ParallelReconstructor.reconstruct_signals": [[90, 99], ["None"], "methods", ["None"], ["", "", "", "@", "abstractmethod", "\n", "def", "reconstruct_signals", "(", "self", ",", "output", ")", ":", "\n", "\t\t", "\"\"\"reconstruct the signals\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\n\t\tReturns:\n\t\t\tthe reconstructed signals\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.parallel_reconstructor.ParallelReconstructor.write_audiofile": [[100, 118], ["range", "parallel_reconstructor.ParallelReconstructor.scp_fid.write", "os.path.join", "os.path.join", "scipy.write", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_audiofile", "(", "self", ",", "reconstructed_signals", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"write the audiofiles for the reconstructions\n\n\t\tArgs:\n\t\t\treconstructed_signals: the reconstructed signals for a single mixture\n\t\t\tutt_info: some info on the utterance\n\t\t\"\"\"", "\n", "\n", "write_str", "=", "utt_info", "[", "'utt_name'", "]", "\n", "for", "spk", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t", "rec_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'s'", "+", "str", "(", "spk", "+", "1", ")", ")", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "utt_info", "[", "'utt_name'", "]", "+", "'.wav'", ")", "\n", "signal", "=", "reconstructed_signals", "[", "spk", "]", "\n", "wav", ".", "write", "(", "filename", ",", "utt_info", "[", "'rate'", "]", ",", "signal", ")", "\n", "write_str", "+=", "' '", "+", "filename", "\n", "\n", "", "write_str", "+=", "' \\n'", "\n", "self", ".", "scp_fid", ".", "write", "(", "write_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.parallel_reconstructor.ParallelReconstructor.open_scp_files": [[119, 125], ["open"], "methods", ["None"], ["", "def", "open_scp_files", "(", "self", ",", "from_start", "=", "True", ")", ":", "\n", "\t\t", "if", "from_start", ":", "\n", "\t\t\t", "file_mode", "=", "'w'", "\n", "", "else", ":", "\n", "\t\t\t", "file_mode", "=", "'a+'", "\n", "", "self", ".", "scp_fid", "=", "open", "(", "self", ".", "scp_file", ",", "file_mode", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepattractornetnoise_soft_reconstructor.DeepattractornoisesoftReconstructor.__init__": [[17, 37], ["mask_reconstructor.MaskReconstructor.__init__", "dict", "nabu.postprocessing.data_reader.DataReader", "os.path.join", "dataconf.items", "os.path.isdir", "os.makedirs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ")", ":", "\n", "        ", "'''DeepclusteringReconstructor constructor\n\n        Args:\n        conf: the reconstructor configuration as a dictionary\n        evalconf: the evaluator configuration as a ConfigParser\n        dataconf: the database configuration\n        rec_dir: the directory where the reconstructions will be stored'''", "\n", "\n", "super", "(", "DeepattractornoisesoftReconstructor", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ")", "\n", "\n", "#get the usedbins reader", "\n", "usedbins_name", "=", "conf", "[", "'usedbins'", "]", "\n", "usedbins_dataconf", "=", "dict", "(", "dataconf", ".", "items", "(", "usedbins_name", ")", ")", "\n", "self", ".", "usedbins_reader", "=", "data_reader", ".", "DataReader", "(", "usedbins_dataconf", ",", "self", ".", "segment_lengths", ")", "\n", "\n", "#directory where cluster centroids will be stored", "\n", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepattractornetnoise_soft_reconstructor.DeepattractornoisesoftReconstructor._get_masks": [[39, 88], ["deepattractornetnoise_soft_reconstructor.DeepattractornoisesoftReconstructor.usedbins_reader", "numpy.shape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "weighted_kmeans.kmeans", "numpy.matmul", "numpy.exp", "numpy.sum", "numpy.multiply", "numpy.reshape", "numpy.save", "numpy.squeeze", "numpy.transpose", "os.path.join", "numpy.shape", "numpy.shape", "numpy.shape", "numpy.shape", "numpy.max"], "methods", ["None"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "        ", "'''estimate the masks\n\n        Args:\n            output: the output of a single utterance of the neural network\n                    tensor of dimension [Txfeature_dimension*emb_dim]\n\n        Returns:\n            the estimated masks'''", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "noise_filter", "=", "output", "[", "'noise_filter'", "]", "\n", "\n", "#only the non-silence bins will be used for the clustering", "\n", "usedbins", ",", "_", "=", "self", ".", "usedbins_reader", "(", "self", ".", "pos", ")", "\n", "\n", "[", "T", ",", "F", "]", "=", "np", ".", "shape", "(", "usedbins", ")", "\n", "emb_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "[", "1", "]", "/", "F", "\n", "N", "=", "T", "*", "F", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "            ", "raise", "'Number of frames in usedbins does not match the sequence length'", "\n", "", "if", "np", ".", "shape", "(", "noise_filter", ")", "[", "0", "]", "!=", "T", ":", "\n", "            ", "raise", "'Number of frames in usedbins does not match the sequence length'", "\n", "", "if", "np", ".", "shape", "(", "noise_filter", ")", "[", "1", "]", "!=", "F", ":", "\n", "            ", "raise", "'Number of noise filter outputs does not match number of frequency bins'", "\n", "#reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "emb_vec", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", "*", "F", ",", "emb_dim", "]", ")", "\n", "noise_filter_reshape", "=", "np", ".", "reshape", "(", "noise_filter", "[", ":", "T", ",", ":", "]", ",", "[", "T", "*", "F", ",", "1", "]", ")", "\n", "\n", "usedbins_resh", "=", "np", ".", "reshape", "(", "usedbins", ",", "T", "*", "F", ")", "\n", "#Only keep the active bins (above threshold) for clustering", "\n", "emb_vec_energy", "=", "emb_vec", "[", "usedbins_resh", "]", "# dim:N' x embdim (N' is number of bins that are used N'<N)", "\n", "\n", "#apply kmeans clustering and assign each bin to a clustering", "\n", "_", ",", "A", "=", "kmeans", "(", "emb_vec_energy", ",", "np", ".", "squeeze", "(", "noise_filter_reshape", "[", "usedbins_resh", "]", ")", ",", "self", ".", "nrS", ",", "steps", "=", "100", ")", "\n", "\n", "\n", "\n", "prod_1", "=", "np", ".", "matmul", "(", "A", ",", "emb_vec", ".", "T", ")", "\n", "numerator", "=", "np", ".", "exp", "(", "prod_1", "-", "np", ".", "max", "(", "prod_1", ",", "axis", "=", "0", ")", ")", "\n", "denominator", "=", "np", ".", "sum", "(", "numerator", ",", "axis", "=", "0", ")", "\n", "M", "=", "numerator", "/", "denominator", "\n", "M_final", "=", "np", ".", "multiply", "(", "M", ",", "np", ".", "transpose", "(", "noise_filter_reshape", ")", ")", "\n", "\n", "#reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "reshape", "(", "M_final", ",", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "A", ")", "\n", "return", "masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.anchor_deepattractornet_softmax_reconstructor.AnchorDeepattractorSoftmaxReconstructor.__init__": [[15, 38], ["mask_reconstructor.MaskReconstructor.__init__", "os.path.join", "os.path.isdir", "os.makedirs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"DeepclusteringReconstructor constructor\n\n\t\tArgs:\n\t\tconf: the reconstructor configuration as a dictionary\n\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\tdataconf: the database configuration\n\t\trec_dir: the directory where the reconstructions will be stored\n\t\ttask: task name\n\t\t\"\"\"", "\n", "\n", "super", "(", "AnchorDeepattractorSoftmaxReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "if", "'normalize'", "in", "conf", "and", "conf", "[", "'normalize'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "False", "\n", "\n", "# directory where cluster centroids will be stored", "\n", "", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.anchor_deepattractornet_softmax_reconstructor.AnchorDeepattractorSoftmaxReconstructor._get_masks": [[39, 76], ["numpy.shape", "numpy.reshape", "numpy.matmul", "numpy.exp", "numpy.reshape", "numpy.save", "numpy.shape", "Exception", "os.path.join", "numpy.shape", "numpy.linalg.norm", "numpy.sum"], "methods", ["None"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\t\ttensor of dimension [Txfeature_dimension*emb_dim]\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "anchors", "=", "output", "[", "'anchors'", "]", "\n", "\n", "# Get number of time frames and frequency cells", "\n", "T", ",", "out_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "\n", "# Calculate the used embedding dimension", "\n", "emb_dim", "=", "np", ".", "shape", "(", "anchors", ")", "[", "1", "]", "\n", "F", "=", "out_dim", "/", "emb_dim", "\n", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Number of frames in usedbins does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "# output_resh is a N times emb_dim matrix with the embedding vectors for all cells", "\n", "output_resh", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", "*", "F", ",", "emb_dim", "]", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "\t\t\t", "output_resh", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "output_resh", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "", "prod_1", "=", "np", ".", "matmul", "(", "anchors", ",", "output_resh", ".", "T", ")", "# dim: nrS x K", "\n", "tmp", "=", "np", ".", "exp", "(", "prod_1", ")", "\n", "masks", "=", "tmp", "/", "(", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "reshape", "(", "masks", ",", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "anchors", ")", "\n", "return", "masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.weighted_anchor_deepattractornet_softmax_reconstructor.WeightedAnchorDeepattractorSoftmaxReconstructor.__init__": [[15, 38], ["mask_reconstructor.MaskReconstructor.__init__", "os.path.join", "os.path.isdir", "os.makedirs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"WeightedAnchorDeepattractorSoftmaxReconstructor constructor\n\n\t\tArgs:\n\t\tconf: the reconstructor configuration as a dictionary\n\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\tdataconf: the database configuration\n\t\trec_dir: the directory where the reconstructions will be stored\n\t\ttask: task name\n\t\t\"\"\"", "\n", "\n", "super", "(", "WeightedAnchorDeepattractorSoftmaxReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "if", "'normalize'", "in", "conf", "and", "conf", "[", "'normalize'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "normalize", "=", "False", "\n", "\n", "# directory where cluster centroids will be stored", "\n", "", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.weighted_anchor_deepattractornet_softmax_reconstructor.WeightedAnchorDeepattractorSoftmaxReconstructor._get_masks": [[39, 80], ["numpy.shape", "numpy.reshape", "numpy.expand_dims", "numpy.matmul", "numpy.exp", "numpy.transpose", "numpy.save", "numpy.shape", "Exception", "numpy.expand_dims", "numpy.transpose", "os.path.join", "numpy.shape", "numpy.linalg.norm", "numpy.sum"], "methods", ["None"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\t\ttensor of dimension [Txfeature_dimension*emb_dim]\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "anchors", "=", "output", "[", "'anchors'", "]", "\n", "weights", "=", "output", "[", "'spk_weights'", "]", "\n", "\n", "# Get number of time frames and frequency cells", "\n", "T", ",", "out_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "\n", "# Calculate the used embedding dimension", "\n", "emb_dim", "=", "np", ".", "shape", "(", "anchors", ")", "[", "-", "1", "]", "\n", "F", "=", "out_dim", "/", "emb_dim", "\n", "\n", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Number of frames in usedbins does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "output", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "# output_resh is a N times emb_dim matrix with the embedding vectors for all cells", "\n", "output_resh", "=", "np", ".", "reshape", "(", "output", ",", "[", "T", ",", "F", ",", "emb_dim", "]", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "\t\t\t", "output_resh", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "output_resh", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "", "anchors", "=", "np", ".", "expand_dims", "(", "anchors", ",", "0", ")", "\n", "anchors", "=", "anchors", "*", "np", ".", "expand_dims", "(", "weights", ",", "-", "1", ")", "\n", "\n", "prod_1", "=", "np", ".", "matmul", "(", "anchors", ",", "np", ".", "transpose", "(", "output_resh", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "# dim: T x nrS x F", "\n", "tmp", "=", "np", ".", "exp", "(", "prod_1", ")", "\n", "masks", "=", "tmp", "/", "(", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "transpose", "(", "masks", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "anchors", ")", "\n", "return", "masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.oraclemask_reconstructor.OracleMaskReconstructor.__init__": [[19, 38], ["mask_reconstructor.MaskReconstructor.__init__", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "binarytargets_dataconfs.append", "dict", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"DeepclusteringReconstructor constructor\n\n\t\tArgs:\n\t\t\tconf: the reconstructor configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions will be stored\n\t\t\"\"\"", "\n", "\n", "super", "(", "OracleMaskReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "# get the binarytargets reader", "\n", "binarytargets_names", "=", "conf", "[", "'binary_targets'", "]", ".", "split", "(", "' '", ")", "\n", "binarytargets_dataconfs", "=", "[", "]", "\n", "for", "binarytargets_name", "in", "binarytargets_names", ":", "\n", "\t\t\t", "binarytargets_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "binarytargets_name", ")", ")", ")", "\n", "", "self", ".", "binarytargets_reader", "=", "data_reader", ".", "DataReader", "(", "binarytargets_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.oraclemask_reconstructor.OracleMaskReconstructor._get_masks": [[39, 59], ["oraclemask_reconstructor.OracleMaskReconstructor.binarytargets_reader", "numpy.shape", "numpy.reshape", "numpy.transpose"], "methods", ["None"], ["", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"returns the ideal masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network. Not used\n\t\t\t\tutt_info: some info on the utterance. Not used\n\n\t\tReturns:\n\t\t\tthe ideal masks\"\"\"", "\n", "\n", "binary_targets", ",", "_", "=", "self", ".", "binarytargets_reader", "(", "self", ".", "pos", ")", "\n", "[", "T", ",", "FS", "]", "=", "np", ".", "shape", "(", "binary_targets", ")", "\n", "F", "=", "FS", "/", "self", ".", "nrS", "\n", "\n", "# reshape the outputs", "\n", "binary_targets", "=", "binary_targets", "[", ":", "T", ",", ":", "]", "\n", "binary_targets_resh", "=", "np", ".", "reshape", "(", "binary_targets", ",", "[", "T", ",", "F", ",", "self", ".", "nrS", "]", ")", "\n", "ideal_masks", "=", "np", ".", "transpose", "(", "binary_targets_resh", ",", "[", "2", ",", "0", ",", "1", "]", ")", "\n", "\n", "return", "ideal_masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.reconstructor_factory.factory": [[14, 71], ["Exception"], "function", ["None"], ["def", "factory", "(", "reconstructor", ")", ":", "\n", "    ", "\"\"\"\n    gets a reconstructor class\n\n    Args:\n        reconstructor: the reconstructor type\n\n    Returns:\n        a reconstructor class\n    \"\"\"", "\n", "\n", "if", "reconstructor", "==", "'deepclustering'", "or", "reconstructor", "==", "'deepclustering_flat'", ":", "\n", "        ", "return", "deepclustering_reconstructor", ".", "DeepclusteringReconstructor", "\n", "", "elif", "reconstructor", "==", "'deepXclustering'", ":", "\n", "        ", "return", "deepXclustering_reconstructor", ".", "DeepXclusteringReconstructor", "\n", "", "elif", "reconstructor", "==", "'deepattractornet'", ":", "\n", "        ", "return", "deepattractornet_reconstructor", ".", "DeepattractorReconstructor", "\n", "", "elif", "reconstructor", "==", "'deepattractornet_softmax'", ":", "\n", "        ", "return", "deepattractornet_softmax_reconstructor", ".", "DeepattractorSoftmaxReconstructor", "\n", "", "elif", "reconstructor", "==", "'anchor_deepattractornet_softmax'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_reconstructor", ".", "AnchorDeepattractorSoftmaxReconstructor", "\n", "", "elif", "reconstructor", "==", "'time_anchor_deepattractornet_softmax'", ":", "\n", "        ", "return", "time_anchor_deepattractornet_softmax_reconstructor", ".", "TimeAnchorDeepattractorSoftmaxReconstructor", "\n", "", "elif", "reconstructor", "==", "'time_anchor_scalar_deepattractornet_softmax'", ":", "\n", "        ", "return", "time_anchor_deepattractornet_softmax_reconstructor", ".", "TimeAnchorScalarDeepattractorSoftmaxReconstructor", "\n", "", "elif", "reconstructor", "==", "'time_anchor_spk_weights_deepattractornet_softmax'", ":", "\n", "        ", "return", "time_anchor_deepattractornet_softmax_reconstructor", ".", "TimeAnchorSpkWeightsDeepattractorSoftmaxReconstructor", "\n", "", "elif", "reconstructor", "==", "'time_anchor_read_heads_deepattractornet_softmax'", ":", "\n", "        ", "return", "time_anchor_read_heads_deepattractornet_softmax_reconstructor", ".", "TimeAnchorReadHeadsDeepattractorSoftmaxReconstructor", "\n", "", "elif", "reconstructor", "==", "'weighted_anchor_deepattractornet_softmax'", ":", "\n", "        ", "return", "weighted_anchor_deepattractornet_softmax_reconstructor", ".", "WeightedAnchorDeepattractorSoftmaxReconstructor", "\n", "", "elif", "reconstructor", "==", "'stackedmasks'", ":", "\n", "        ", "return", "stackedmasks_reconstructor", ".", "StackedmasksReconstructor", "\n", "", "elif", "reconstructor", "==", "'pit_l41'", ":", "\n", "        ", "return", "pit_l41_reconstructor", ".", "PITL41Reconstructor", "\n", "", "elif", "reconstructor", "==", "'parallel_deepclustering'", ":", "\n", "        ", "return", "parallel_deepclustering_reconstructor", ".", "ParallelDeepclusteringReconstructor", "\n", "", "elif", "reconstructor", "==", "'deepclusteringnoise'", ":", "\n", "        ", "return", "deepclusteringnoise_reconstructor", ".", "DeepclusteringnoiseReconstructor", "\n", "", "elif", "reconstructor", "==", "'deepattractornetnoisehard'", ":", "\n", "        ", "return", "deepattractornetnoise_hard_reconstructor", ".", "DeepattractornoisehardReconstructor", "\n", "", "elif", "reconstructor", "==", "'deepattractornetnoisesoft'", ":", "\n", "        ", "return", "deepattractornetnoise_soft_reconstructor", ".", "DeepattractornoisesoftReconstructor", "\n", "", "elif", "reconstructor", "==", "'oraclemask'", ":", "\n", "        ", "return", "oraclemask_reconstructor", ".", "OracleMaskReconstructor", "\n", "", "elif", "reconstructor", "==", "'oraclenoise'", ":", "\n", "        ", "return", "oracle_reconstructor_noise", ".", "OracleReconstructor", "\n", "", "elif", "reconstructor", "==", "'noisefilter'", ":", "\n", "        ", "return", "noisefilter_reconstructor", ".", "NoiseFilterReconstructor", "\n", "", "elif", "reconstructor", "==", "'deepattractornet_noisefilter'", ":", "\n", "        ", "return", "deepattractornet_noisefilter_reconstructor", ".", "DeepattractornoisefilterReconstructor", "\n", "", "elif", "reconstructor", "==", "'stackedmasks_noise'", ":", "\n", "        ", "return", "stackedmasks_noise_reconstructor", ".", "StackedmasksNoiseReconstructor", "\n", "", "elif", "reconstructor", "==", "'dummy'", ":", "\n", "        ", "return", "dummy_reconstructor", ".", "DummyReconstructor", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Undefined reconstructor type: %s'", "%", "reconstructor", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepclustering_reconstructor.DeepclusteringReconstructor.__init__": [[19, 49], ["mask_reconstructor.MaskReconstructor.__init__", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "os.path.join", "usedbins_dataconfs.append", "os.path.isdir", "os.makedirs", "dict", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"DeepclusteringReconstructor constructor\n\n\t\tArgs:\n\t\t\tconf: the reconstructor configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions will be stored\n\t\t\"\"\"", "\n", "\n", "super", "(", "DeepclusteringReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "# get the usedbins reader", "\n", "usedbins_names", "=", "conf", "[", "'usedbins'", "]", ".", "split", "(", "' '", ")", "\n", "usedbins_dataconfs", "=", "[", "]", "\n", "for", "usedbins_name", "in", "usedbins_names", ":", "\n", "\t\t\t", "usedbins_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "usedbins_name", ")", ")", ")", "\n", "", "self", ".", "usedbins_reader", "=", "data_reader", ".", "DataReader", "(", "usedbins_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n", "# directory where cluster centroids will be stored", "\n", "self", ".", "center_store_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'cluster_centers'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "center_store_dir", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "self", ".", "center_store_dir", ")", "\n", "\n", "# whether output will be in [time x freq_dim*emb_dim] or", "\n", "# [time x freq_dim x emb_dim]", "\n", "", "self", ".", "flat", "=", "False", "\n", "if", "'flat'", "in", "conf", "[", "'reconstruct_type'", "]", ":", "\n", "\t\t\t", "self", ".", "flat", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepclustering_reconstructor.DeepclusteringReconstructor._get_masks": [[50, 104], ["deepclustering_reconstructor.DeepclusteringReconstructor.usedbins_reader", "numpy.shape", "numpy.reshape", "numpy.linalg.norm", "numpy.reshape", "sklearn.cluster.KMeans", "range", "sklearn.cluster.KMeans.predict", "numpy.reshape", "numpy.zeros", "range", "numpy.save", "Exception", "os.path.join", "numpy.shape", "numpy.shape", "sklearn.cluster.KMeans.fit", "numpy.shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.predict"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\tutt_info: some info on the utterance\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n", "embeddings", "=", "output", "[", "'bin_emb'", "]", "\n", "# only the non-silence bins will be used for the clustering", "\n", "usedbins", ",", "_", "=", "self", ".", "usedbins_reader", "(", "self", ".", "pos", ")", "\n", "[", "T", ",", "F", "]", "=", "np", ".", "shape", "(", "usedbins", ")", "\n", "if", "self", ".", "flat", ":", "\n", "\t\t\t", "emb_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t", "emb_dim", "=", "np", ".", "shape", "(", "embeddings", ")", "[", "-", "1", "]", "/", "F", "\n", "", "if", "np", ".", "shape", "(", "embeddings", ")", "[", "0", "]", "!=", "T", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Number of frames in usedbins does not match the sequence length'", ")", "\n", "\n", "# reshape the outputs", "\n", "", "embeddings", "=", "embeddings", "[", ":", "T", ",", ":", "]", "\n", "embeddings_resh", "=", "np", ".", "reshape", "(", "embeddings", ",", "[", "T", "*", "F", ",", "emb_dim", "]", ")", "\n", "embeddings_resh_norm", "=", "np", ".", "linalg", ".", "norm", "(", "embeddings_resh", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "embeddings_resh", "=", "embeddings_resh", "/", "embeddings_resh_norm", "\n", "\n", "# only keep the active bins (above threshold) for clustering", "\n", "usedbins_resh", "=", "np", ".", "reshape", "(", "usedbins", ",", "T", "*", "F", ")", "\n", "embeddings_speech_resh", "=", "embeddings_resh", "[", "usedbins_resh", "]", "\n", "\n", "# apply kmeans clustering and assign each bin to a clustering", "\n", "kmeans_model", "=", "KMeans", "(", "n_clusters", "=", "self", ".", "nrS", ",", "init", "=", "'k-means++'", ",", "n_init", "=", "10", ",", "max_iter", "=", "100", ",", "n_jobs", "=", "7", ")", "\n", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "# Sometime it fails due to some indexerror and I'm not sure why. Just retry then. max 5 times", "\n", "\t\t\t", "try", ":", "\n", "\t\t\t\t", "kmeans_model", ".", "fit", "(", "embeddings_speech_resh", ")", "\n", "", "except", "IndexError", ":", "\n", "\t\t\t\t", "continue", "\n", "", "break", "\n", "\n", "", "predicted_labels", "=", "kmeans_model", ".", "predict", "(", "embeddings_resh", ")", "\n", "predicted_labels_resh", "=", "np", ".", "reshape", "(", "predicted_labels", ",", "[", "T", ",", "F", "]", ")", "\n", "\n", "# reconstruct the masks from the cluster labels", "\n", "masks", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "for", "spk", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t", "masks", "[", "spk", ",", ":", ",", ":", "]", "=", "predicted_labels_resh", "==", "spk", "\n", "\n", "# store the clusters", "\n", "", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "center_store_dir", ",", "utt_info", "[", "'utt_name'", "]", ")", ",", "kmeans_model", ".", "cluster_centers_", ")", "\n", "\n", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.deepclustering_reconstructor.DeepclusteringReconstructor._get_masks_opt_frame_perm": [[105, 145], ["deepclustering_reconstructor.DeepclusteringReconstructor.usedbins_reader", "numpy.shape", "deepclustering_reconstructor.DeepclusteringReconstructor._get_masks", "numpy.reshape", "numpy.transpose", "numpy.expand_dims", "numpy.zeros", "list", "range", "itertools.permutations", "numpy.zeros", "enumerate", "numpy.argmin", "range", "numpy.sum", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor._get_masks"], ["", "def", "_get_masks_opt_frame_perm", "(", "self", ",", "output", ",", "target", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\ttarget: the target of a single utterance of the neural network\n\t\t\tutt_info: some info on the utterance\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "# only the non-silence bins will be used for determining the optimal frame level permutation", "\n", "usedbins", ",", "_", "=", "self", ".", "usedbins_reader", "(", "self", ".", "pos", ")", "\n", "\n", "[", "T", ",", "F", "]", "=", "np", ".", "shape", "(", "usedbins", ")", "\n", "\n", "masks", "=", "self", ".", "_get_masks", "(", "output", ",", "utt_info", ")", "\n", "\n", "# apply frame lever permutations to get the optimal masks, according to the targets", "\n", "target", "=", "target", "[", "'binary_targets'", "]", "\n", "target", "=", "np", ".", "reshape", "(", "target", ",", "[", "T", ",", "F", ",", "self", ".", "nrS", "]", ")", "\n", "target", "=", "np", ".", "transpose", "(", "target", ",", "[", "2", ",", "0", ",", "1", "]", ")", "\n", "usedbins_ext", "=", "np", ".", "expand_dims", "(", "usedbins", ",", "0", ")", "\n", "opt_masks", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "all_perms", "=", "list", "(", "itertools", ".", "permutations", "(", "range", "(", "self", ".", "nrS", ")", ")", ")", "\n", "for", "t", "in", "range", "(", "T", ")", ":", "\n", "\t\t\t", "mask_frame_t", "=", "masks", "[", ":", ",", "t", ",", ":", "]", "\n", "target_frame_t", "=", "target", "[", ":", ",", "t", ",", ":", "]", "\n", "usedbins_frame_t", "=", "usedbins_ext", "[", ":", ",", "t", ",", ":", "]", "\n", "\n", "perm_values", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrS", "]", ")", "\n", "for", "perm_ind", ",", "perm", "in", "enumerate", "(", "all_perms", ")", ":", "\n", "\t\t\t\t", "perm_value", "=", "np", ".", "sum", "(", "usedbins_frame_t", "*", "np", ".", "abs", "(", "mask_frame_t", "[", "perm", ",", ":", "]", "-", "target_frame_t", ")", ")", "\n", "perm_values", "[", "perm_ind", "]", "=", "perm_value", "\n", "\n", "", "best_perm_ind", "=", "np", ".", "argmin", "(", "perm_values", ")", "\n", "best_perm", "=", "all_perms", "[", "best_perm_ind", "]", "\n", "\n", "opt_masks", "[", ":", ",", "t", ",", ":", "]", "=", "mask_frame_t", "[", "best_perm", ",", ":", "]", "\n", "\n", "", "return", "opt_masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor.__init__": [[19, 59], ["reconstructor.Reconstructor.__init__", "int", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "range", "os.path.join", "os.path.join", "int", "org_mix_dataconfs.append", "conf[].split", "mask_reconstructor.MaskReconstructor.org_mix_readers.append", "os.path.isdir", "os.makedirs", "dict", "org_mix_dataconfs.append", "nabu.postprocessing.data_reader.DataReader", "dataconf.items", "dict", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"MaskReconstructor constructor\n\n\t\tArgs:\n\t\t\tconf: the reconstructor configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions will be stored\n\t\t\"\"\"", "\n", "\n", "super", "(", "MaskReconstructor", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "self", ".", "multi_mic_rec", "=", "False", "\n", "self", ".", "nrmic", "=", "1", "\n", "if", "'nrmic'", "in", "conf", "and", "int", "(", "conf", "[", "'nrmic'", "]", ")", ">", "1", ":", "\n", "\t\t\t", "self", ".", "multi_mic_rec", "=", "True", "\n", "self", ".", "nrmic", "=", "int", "(", "conf", "[", "'nrmic'", "]", ")", "\n", "\n", "", "if", "not", "self", ".", "multi_mic_rec", ":", "\n", "# get the original mixtures reader", "\n", "\t\t\t", "org_mix_names", "=", "conf", "[", "'org_mix'", "]", ".", "split", "(", "' '", ")", "\n", "org_mix_dataconfs", "=", "[", "]", "\n", "for", "org_mix_name", "in", "org_mix_names", ":", "\n", "\t\t\t\t", "org_mix_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "org_mix_name", ")", ")", ")", "\n", "", "self", ".", "org_mix_reader", "=", "data_reader", ".", "DataReader", "(", "org_mix_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "org_mix_readers", "=", "[", "]", "\n", "for", "mic_ind", "in", "range", "(", "self", ".", "nrmic", ")", ":", "\n", "\t\t\t\t", "org_mix_names", "=", "conf", "[", "'org_mix_%d'", ",", "(", "mic_ind", "+", "1", ")", "]", ".", "split", "(", "' '", ")", "\n", "org_mix_dataconfs", "=", "[", "]", "\n", "for", "org_mix_name", "in", "org_mix_names", ":", "\n", "\t\t\t\t\t", "org_mix_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "org_mix_name", ")", ")", ")", "\n", "", "self", ".", "org_mix_readers", ".", "append", "(", "data_reader", ".", "DataReader", "(", "org_mix_dataconfs", ",", "self", ".", "segment_lengths", ")", ")", "\n", "\n", "", "", "self", ".", "store_masks", "=", "'store_masks'", "in", "conf", "and", "conf", "[", "'store_masks'", "]", "==", "'True'", "\n", "if", "self", ".", "store_masks", ":", "\n", "\t\t\t", "self", ".", "masks_pointer_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "rec_dir", ",", "'masks_pointers.scp'", ")", "\n", "self", ".", "mask_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'masks'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "mask_dir", ")", ":", "\n", "\t\t\t\t", "os", ".", "makedirs", "(", "self", ".", "mask_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor.reconstruct_signals": [[60, 122], ["mask_reconstructor.MaskReconstructor._get_masks", "mask_reconstructor.MaskReconstructor.org_mix_reader", "range", "enumerate", "list", "range", "enumerate", "NotImplementedError", "os.path.join", "numpy.save", "mask_reconstructor.MaskReconstructor.masks_pointer_fid.write", "all_mixtures.append", "all_utt_infos.append", "list.append", "nabu.processing.feature_computers.base.spec2time_scipy", "nabu.processing.feature_computers.base.spec2time"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor._get_masks", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec2time_scipy", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.spec2time"], ["", "", "", "def", "reconstruct_signals", "(", "self", ",", "output", ")", ":", "\n", "\t\t", "\"\"\"reconstruct the signals\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\n\t\tReturns:\n\t\t\tthe reconstructed signals\n\t\t\tsome info on the utterance\"\"\"", "\n", "\n", "# get the original mixture(s)", "\n", "if", "self", ".", "nrmic", "==", "1", ":", "\n", "\t\t\t", "mixture", ",", "utt_info", "=", "self", ".", "org_mix_reader", "(", "self", ".", "pos", ")", "\n", "", "else", ":", "\n", "\t\t\t", "all_mixtures", "=", "[", "]", "\n", "all_utt_infos", "=", "[", "]", "\n", "for", "mic_ind", "in", "range", "(", "self", ".", "nrmic", ")", ":", "\n", "\t\t\t\t", "mixture", ",", "utt_info", "=", "self", ".", "org_mix_readers", "[", "mic_ind", "]", "(", "self", ".", "pos", ")", "\n", "all_mixtures", ".", "append", "(", "mixture", ")", "\n", "all_utt_infos", ".", "append", "(", "utt_info", ")", "\n", "# all utt_infos should be the same", "\n", "", "utt_info", "=", "all_utt_infos", "[", "0", "]", "\n", "\n", "# get the masks", "\n", "", "masks", "=", "self", ".", "_get_masks", "(", "output", ",", "utt_info", ")", "\n", "\n", "# apply the masks to obtain the reconstructed signals. Use the conf for feature", "\n", "# settings from the original mixture", "\n", "if", "self", ".", "nrmic", "==", "1", ":", "\n", "\t\t\t", "for", "ind", ",", "start_index", "in", "enumerate", "(", "self", ".", "org_mix_reader", ".", "start_index_set", ")", ":", "\n", "\t\t\t\t", "if", "start_index", ">", "self", ".", "pos", ":", "\n", "\t\t\t\t\t", "processor", "=", "self", ".", "org_mix_reader", ".", "processors", "[", "ind", "-", "1", "]", "\n", "comp_conf", "=", "processor", ".", "comp", ".", "conf", "\n", "break", "\n", "\n", "", "", "reconstructed_signals", "=", "list", "(", ")", "\n", "for", "spk", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t\t", "spec_est", "=", "mixture", "*", "masks", "[", "spk", ",", ":", ",", ":", "]", "\n", "if", "'scipy'", "in", "comp_conf", "and", "comp_conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "\t\t\t\t\t", "rec_signal", "=", "base", ".", "spec2time_scipy", "(", "spec_est", ",", "utt_info", "[", "'rate'", "]", ",", "utt_info", "[", "'siglen'", "]", ",", "comp_conf", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "rec_signal", "=", "base", ".", "spec2time", "(", "spec_est", ",", "utt_info", "[", "'rate'", "]", ",", "utt_info", "[", "'siglen'", "]", ",", "comp_conf", ")", "\n", "", "reconstructed_signals", ".", "append", "(", "rec_signal", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "for", "ind", ",", "start_index", "in", "enumerate", "(", "self", ".", "org_mix_readers", "[", "0", "]", ".", "start_index_set", ")", ":", "\n", "\t\t\t\t", "if", "start_index", ">", "self", ".", "pos", ":", "\n", "\t\t\t\t\t", "processor", "=", "self", ".", "org_mix_readers", "[", "0", "]", ".", "processors", "[", "ind", "-", "1", "]", "\n", "comp_conf", "=", "processor", ".", "comp", ".", "conf", "\n", "break", "\n", "\n", "# For each speaker, apply its mask to each microphone signal. The magnitude of the speaker's reconstructed", "\n", "# spectrogram is obtained by averaging the masked signals.", "\n", "# pass", "\n", "", "", "raise", "NotImplementedError", "(", ")", "\n", "\n", "", "if", "self", ".", "store_masks", ":", "\n", "\t\t\t", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "mask_dir", ",", "'%s.npy'", "%", "utt_info", "[", "'utt_name'", "]", ")", "\n", "np", ".", "save", "(", "save_file", ",", "masks", ")", "\n", "write_str", "=", "'%s %s\\n'", "%", "(", "utt_info", "[", "'utt_name'", "]", ",", "save_file", ")", "\n", "self", ".", "masks_pointer_fid", ".", "write", "(", "write_str", ")", "\n", "\n", "", "return", "reconstructed_signals", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor.reconstruct_signals_opt_frame_perm": [[123, 158], ["mask_reconstructor.MaskReconstructor.org_mix_reader", "mask_reconstructor.MaskReconstructor._get_masks_opt_frame_perm", "enumerate", "list", "range", "list.append", "nabu.processing.feature_computers.base.spec2time_scipy", "nabu.processing.feature_computers.base.spec2time"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor._get_masks_opt_frame_perm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec2time_scipy", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.spec2time"], ["", "def", "reconstruct_signals_opt_frame_perm", "(", "self", ",", "output", ",", "target", ")", ":", "\n", "\t\t", "\"\"\"reconstruct the signals, using optimal frame-level permutations\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\ttarget: the target of a single utterance of the neural network\n\n\t\tReturns:\n\t\t\tthe reconstructed signals\n\t\t\tsome info on the utterance\"\"\"", "\n", "\n", "# get the original mixture", "\n", "mixture", ",", "utt_info", "=", "self", ".", "org_mix_reader", "(", "self", ".", "pos", ")", "\n", "\n", "# get the masks", "\n", "masks", "=", "self", ".", "_get_masks_opt_frame_perm", "(", "output", ",", "target", ",", "utt_info", ")", "\n", "\n", "# apply the masks to obtain the reconstructed signals. Use the conf for feature", "\n", "# settings from the original mixture", "\n", "for", "ind", ",", "start_index", "in", "enumerate", "(", "self", ".", "org_mix_reader", ".", "start_index_set", ")", ":", "\n", "\t\t\t", "if", "start_index", ">", "self", ".", "pos", ":", "\n", "\t\t\t\t", "processor", "=", "self", ".", "org_mix_reader", ".", "processors", "[", "ind", "-", "1", "]", "\n", "comp_conf", "=", "processor", ".", "comp", ".", "conf", "\n", "break", "\n", "\n", "", "", "reconstructed_signals", "=", "list", "(", ")", "\n", "for", "spk", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t", "spec_est", "=", "mixture", "*", "masks", "[", "spk", ",", ":", ",", ":", "]", "\n", "if", "'scipy'", "in", "comp_conf", "and", "comp_conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "\t\t\t\t", "rec_signal", "=", "base", ".", "spec2time_scipy", "(", "spec_est", ",", "utt_info", "[", "'rate'", "]", ",", "utt_info", "[", "'siglen'", "]", ",", "comp_conf", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "rec_signal", "=", "base", ".", "spec2time", "(", "spec_est", ",", "utt_info", "[", "'rate'", "]", ",", "utt_info", "[", "'siglen'", "]", ",", "comp_conf", ")", "\n", "", "reconstructed_signals", ".", "append", "(", "rec_signal", ")", "\n", "\n", "", "return", "reconstructed_signals", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor._get_masks": [[159, 169], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\tutt_info: some info on the utterance\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor.open_scp_files": [[170, 179], ["super().open_scp_files", "open"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.mask_reconstructor.MaskReconstructor.open_scp_files"], ["", "def", "open_scp_files", "(", "self", ",", "from_start", "=", "True", ")", ":", "\n", "\t\t", "super", "(", "MaskReconstructor", ",", "self", ")", ".", "open_scp_files", "(", "from_start", ")", "\n", "\n", "if", "self", ".", "store_masks", ":", "\n", "\t\t\t", "if", "from_start", ":", "\n", "\t\t\t\t", "file_mode", "=", "'w'", "\n", "", "else", ":", "\n", "\t\t\t\t", "file_mode", "=", "'a+'", "\n", "", "self", ".", "masks_pointer_fid", "=", "open", "(", "self", ".", "masks_pointer_file", ",", "file_mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor.__init__": [[17, 45], ["mask_reconstructor.MaskReconstructor.__init__", "Exception", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "usedbins_dataconfs.append", "dict", "dataconf.items"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"StackedmasksReconstructor constructor\n\n\t\tArgs:\n\t\t\tconf: the reconstructor configuration as a dictionary\n\t\t\tevalconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\trec_dir: the directory where the reconstructions will be stored\n\t\t\"\"\"", "\n", "\n", "if", "'softmax_flag'", "in", "conf", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Softmax argument is deprecated. Use output_activation'", ")", "\n", "\n", "", "if", "'output_activation'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "output_activation", "=", "conf", "[", "'output_activation'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "output_activation", "=", "'softmax'", "\n", "\n", "", "super", "(", "StackedmasksNoiseReconstructor", ",", "self", ")", ".", "__init__", "(", "\n", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", ")", "\n", "\n", "if", "optimal_frame_permutation", ":", "\n", "# get the usedbins reader", "\n", "\t\t\t", "usedbins_names", "=", "conf", "[", "'usedbins'", "]", ".", "split", "(", "' '", ")", "\n", "usedbins_dataconfs", "=", "[", "]", "\n", "for", "usedbins_name", "in", "usedbins_names", ":", "\n", "\t\t\t\t", "usedbins_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "usedbins_name", ")", ")", ")", "\n", "", "self", ".", "usedbins_reader", "=", "data_reader", ".", "DataReader", "(", "usedbins_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor._get_masks": [[46, 80], ["numpy.shape", "numpy.reshape", "numpy.transpose", "numpy.expand_dims", "stackedmasks_noise_reconstructor.softmax", "stackedmasks_noise_reconstructor.sigmoid", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "", "def", "_get_masks", "(", "self", ",", "output", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"get the masks by simply destacking the stacked masks into separate masks and\n\t\tnormalizing them with softmax\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\t\tutt_info: some info on the utterance\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "\n", "[", "T", ",", "target_dim", "]", "=", "np", ".", "shape", "(", "output", "[", "'bin_est'", "]", ")", "\n", "F", "=", "target_dim", "/", "self", ".", "nrS", "\n", "\n", "masks", "=", "np", ".", "reshape", "(", "output", "[", "'bin_est'", "]", ",", "[", "T", ",", "F", ",", "self", ".", "nrS", "]", ",", "'F'", ")", "\n", "masks", "=", "np", ".", "transpose", "(", "masks", ",", "[", "2", ",", "0", ",", "1", "]", ")", "\n", "\n", "# apply softmax", "\n", "\n", "if", "self", ".", "output_activation", "==", "'softmax'", ":", "\n", "\t\t\t", "masks", "=", "softmax", "(", "masks", ",", "axis", "=", "0", ")", "\n", "", "elif", "self", ".", "output_activation", "==", "'sigmoid'", ":", "\n", "\t\t\t", "masks", "=", "sigmoid", "(", "masks", ")", "\n", "", "elif", "self", ".", "output_activation", "in", "[", "'None'", ",", "'none'", ",", "None", "]", ":", "\n", "\t\t\t", "pass", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Unknown requested output activation'", ")", "\n", "\n", "", "noise_filters", "=", "output", "[", "'noise_filter'", "]", "\n", "noise_filters", "=", "np", ".", "expand_dims", "(", "noise_filters", ",", "0", ")", "\n", "\n", "masks", "=", "masks", "*", "noise_filters", "\n", "\n", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor._get_masks_opt_frame_perm": [[81, 124], ["stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor.usedbins_reader", "numpy.shape", "stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor._get_masks", "numpy.reshape", "numpy.transpose", "numpy.abs", "numpy.sum", "numpy.expand_dims", "numpy.zeros", "list", "range", "itertools.permutations", "numpy.zeros", "enumerate", "numpy.argmin", "range", "numpy.sum", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.StackedmasksNoiseReconstructor._get_masks"], ["", "def", "_get_masks_opt_frame_perm", "(", "self", ",", "output", ",", "target", ",", "utt_info", ")", ":", "\n", "\t\t", "\"\"\"estimate the masks\n\n\t\tArgs:\n\t\t\toutput: the output of a single utterance of the neural network\n\t\t\ttarget: the target of a single utterance of the neural network\n\t\t\tutt_info: some info on the utterance\n\n\t\tReturns:\n\t\t\tthe estimated masks\"\"\"", "\n", "# only the non-silence bins will be used for determining the optimal frame level permutation", "\n", "usedbins", ",", "_", "=", "self", ".", "usedbins_reader", "(", "self", ".", "pos", ")", "\n", "\n", "[", "T", ",", "F", "]", "=", "np", ".", "shape", "(", "usedbins", ")", "\n", "\n", "masks", "=", "self", ".", "_get_masks", "(", "output", ",", "utt_info", ")", "\n", "\n", "# apply frame lever permutations to get the optimal masks, according to the targets", "\n", "target", "=", "target", "[", "'multi_targets'", "]", "\n", "target", "=", "np", ".", "reshape", "(", "target", ",", "[", "T", ",", "F", ",", "self", ".", "nrS", "]", ")", "\n", "target", "=", "np", ".", "transpose", "(", "target", ",", "[", "2", ",", "0", ",", "1", "]", ")", "\n", "target", "=", "np", ".", "abs", "(", "target", ")", "\n", "sum_targets", "=", "np", ".", "sum", "(", "target", ",", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "irms", "=", "target", "/", "sum_targets", "\n", "usedbins_ext", "=", "np", ".", "expand_dims", "(", "usedbins", ",", "0", ")", "\n", "opt_masks", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrS", ",", "T", ",", "F", "]", ")", "\n", "all_perms", "=", "list", "(", "itertools", ".", "permutations", "(", "range", "(", "self", ".", "nrS", ")", ")", ")", "\n", "for", "t", "in", "range", "(", "T", ")", ":", "\n", "\t\t\t", "mask_frame_t", "=", "masks", "[", ":", ",", "t", ",", ":", "]", "\n", "irms_frame_t", "=", "irms", "[", ":", ",", "t", ",", ":", "]", "\n", "usedbins_frame_t", "=", "usedbins_ext", "[", ":", ",", "t", ",", ":", "]", "\n", "\n", "perm_values", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrS", "]", ")", "\n", "for", "perm_ind", ",", "perm", "in", "enumerate", "(", "all_perms", ")", ":", "\n", "\t\t\t\t", "perm_value", "=", "np", ".", "sum", "(", "usedbins_frame_t", "*", "np", ".", "abs", "(", "mask_frame_t", "[", "perm", ",", ":", "]", "-", "irms_frame_t", ")", ")", "\n", "perm_values", "[", "perm_ind", "]", "=", "perm_value", "\n", "\n", "", "best_perm_ind", "=", "np", ".", "argmin", "(", "perm_values", ")", "\n", "best_perm", "=", "all_perms", "[", "best_perm_ind", "]", "\n", "\n", "opt_masks", "[", ":", ",", "t", ",", ":", "]", "=", "mask_frame_t", "[", "best_perm", ",", ":", "]", "\n", "\n", "", "return", "opt_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid": [[126, 128], ["numpy.exp"], "function", ["None"], ["", "", "def", "sigmoid", "(", "x", ")", ":", "\n", "\t", "return", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax": [[130, 133], ["numpy.exp", "numpy.sum"], "function", ["None"], ["", "def", "softmax", "(", "x", ",", "axis", "=", "0", ")", ":", "\n", "\t", "tmp", "=", "np", ".", "exp", "(", "x", ")", "\n", "return", "tmp", "/", "np", ".", "sum", "(", "tmp", ",", "axis", "=", "axis", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.dummy_reconstructor.DummyReconstructor.__init__": [[8, 31], ["os.path.join", "conf[].split", "evalconf.has_option", "evalconf.get().split", "conf[].split", "nabu.postprocessing.data_reader.DataReader", "os.path.isdir", "os.makedirs", "int", "int", "org_mix_dataconfs.append", "evalconf.get", "evalconf.get", "evalconf.get", "dict", "dataconf.items"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", ",", "evalconf", ",", "dataconf", ",", "rec_dir", ",", "task", ",", "optimal_frame_permutation", "=", "False", ")", ":", "\n", "# Whether the raw output should also be stored (besides the reconstructed audiosignal)", "\n", "\t\t", "self", ".", "store_output", "=", "conf", "[", "'store_output'", "]", "==", "'True'", "\n", "if", "self", ".", "store_output", ":", "\n", "\t\t\t", "self", ".", "output_dir", "=", "os", ".", "path", ".", "join", "(", "rec_dir", ",", "'raw_output'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "output_dir", ")", ":", "\n", "\t\t\t\t", "os", ".", "makedirs", "(", "self", ".", "output_dir", ")", "\n", "\n", "", "self", ".", "requested_output_names", "=", "conf", "[", "'output_names'", "]", ".", "split", "(", "' '", ")", "\n", "\n", "self", ".", "pos", "=", "0", "\n", "if", "evalconf", ".", "has_option", "(", "task", ",", "'batch_size'", ")", ":", "\n", "\t\t\t\t", "self", ".", "batch_size", "=", "int", "(", "evalconf", ".", "get", "(", "task", ",", "'batch_size'", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "batch_size", "=", "int", "(", "evalconf", ".", "get", "(", "'evaluator'", ",", "'batch_size'", ")", ")", "\n", "", "self", ".", "segment_lengths", "=", "evalconf", ".", "get", "(", "'evaluator'", ",", "'segment_length'", ")", ".", "split", "(", "' '", ")", "\n", "\n", "# get the original mixtures reader", "\n", "org_mix_names", "=", "conf", "[", "'org_mix'", "]", ".", "split", "(", "' '", ")", "\n", "org_mix_dataconfs", "=", "[", "]", "\n", "for", "org_mix_name", "in", "org_mix_names", ":", "\n", "\t\t\t\t", "org_mix_dataconfs", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "org_mix_name", ")", ")", ")", "\n", "", "self", ".", "org_mix_reader", "=", "data_reader", ".", "DataReader", "(", "org_mix_dataconfs", ",", "self", ".", "segment_lengths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.dummy_reconstructor.DummyReconstructor.__call__": [[32, 49], ["range", "dict", "dummy_reconstructor.DummyReconstructor.org_mix_reader.get_name_for_pos", "numpy.save", "BaseException", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.postprocessing.data_reader.DataReader.get_name_for_pos"], ["", "", "def", "__call__", "(", "self", ",", "batch_outputs", ",", "batch_sequence_lengths", ")", ":", "\n", "\t\t", "if", "self", ".", "store_output", ":", "\n", "\t\t\t", "for", "utt_ind", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "\t\t\t\t", "utt_output", "=", "dict", "(", ")", "\n", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t\t", "if", "output_name", "==", "'act_logit'", ":", "\n", "\t\t\t\t\t\t", "utt_output", "[", "output_name", "]", "=", "batch_outputs", "[", "output_name", "]", "[", "utt_ind", "]", "[", ":", ",", ":", "batch_sequence_lengths", "[", "output_name", "]", "[", "utt_ind", "]", ",", ":", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "raise", "BaseException", "(", "'Not yet implemented for other outputs.'", ")", "\n", "\n", "", "", "utt_name", "=", "self", ".", "org_mix_reader", ".", "get_name_for_pos", "(", "self", ".", "pos", ")", "\n", "\n", "for", "output_name", "in", "self", ".", "requested_output_names", ":", "\n", "\t\t\t\t\t", "savename", "=", "output_name", "+", "'_'", "+", "utt_name", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "savename", ")", ",", "utt_output", "[", "output_name", "]", ")", "\n", "\n", "", "self", ".", "pos", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.dummy_reconstructor.DummyReconstructor.opt_frame_perm": [[50, 52], ["None"], "methods", ["None"], ["", "", "", "def", "opt_frame_perm", "(", "self", ",", "batch_outputs", ",", "batch_targets", ",", "batch_sequence_lengths", ")", ":", "\n", "\t\t", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.dummy_reconstructor.DummyReconstructor.write_audiofile": [[53, 55], ["None"], "methods", ["None"], ["", "def", "write_audiofile", "(", "self", ",", "reconstructed_signals", ",", "utt_info", ")", ":", "\n", "\t\t", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.postprocessors.postprocessor_factory.factory": [[7, 22], ["Exception"], "function", ["None"], ["def", "factory", "(", "postprocessor", ")", ":", "\n", "\t", "\"\"\"\n\tgets a postprocessor class\n\n\tArgs:\n\t\tpostprocessor: the postprocessor type\n\n\tReturns:\n\t\ta postprocessor class\n\t\"\"\"", "\n", "\n", "if", "postprocessor", "==", "'ivector_extractor'", ":", "\n", "\t\t", "return", "ivector_extractor_matlab", ".", "IvectorExtractor", "\n", "", "else", ":", "\n", "\t\t", "raise", "Exception", "(", "'Undefined postprocessor type: %s'", "%", "postprocessor", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scripts.prepare_sweep.main": [[9, 84], ["enumerate", "BaseException", "BaseException", "BaseException", "BaseException", "open", "fid.read", "exp.split", "os.path.isdir", "os.makedirs", "os.system", "fid.read.strip().split", "param.split", "os.path.join", "os.path.join", "os.path.isdir", "shutil.copytree", "BaseException", "int", "int", "fid.read.strip", "os.path.join", "shutil.rmtree", "os.path.join", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "configparser.ConfigParser.set", "os.path.join", "os.path.join", "open", "configparser.ConfigParser.write", "os.path.join"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["def", "main", "(", "\n", "sweep", ",", "command", ",", "expdir", ",", "recipe", ",", "computing", ",", "minmemory", ",", "mincudamemory", ",", "resume", ",", "duplicates", ",", "duplicates_ind_offset", ",", "\n", "test_when_finished", ",", "allow_early_testing", ",", "test_task", ")", ":", "\n", "\t", "\"\"\"main function\"\"\"", "\n", "if", "expdir", "is", "None", ":", "\n", "\t\t", "raise", "BaseException", "(", "\n", "'no expdir specified. Command usage: run sweep --command=your_command --expdir=/path/to/recipe '", "\n", "'--recipe=/path/to/recipe --sweep=/path/to/recipe/sweep_file'", ")", "\n", "", "if", "recipe", "is", "None", ":", "\n", "\t\t", "raise", "BaseException", "(", "\n", "'no recipe specified. Command usage: run sweep --command=your_command --expdir=/path/to/recipe '", "\n", "'--recipe=/path/to/recipe --sweep=/path/to/recipe/sweep_file'", ")", "\n", "", "if", "command", "is", "None", ":", "\n", "\t\t", "raise", "BaseException", "(", "\n", "'no command specified. Command usage: run sweep --command=your_command --expdir=/path/to/recipe '", "\n", "'--recipe=/path/to/recipe --sweep=/path/to/recipe/sweep_file'", ")", "\n", "", "if", "sweep", "is", "None", ":", "\n", "\t\t", "raise", "BaseException", "(", "\n", "'no sweep specified. Command usage: run sweep --command=your_command --expdir=/path/to/recipe '", "\n", "'--recipe=/path/to/recipe --sweep=/path/to/recipe/sweep_file'", ")", "\n", "\n", "# read the sweep file", "\n", "", "with", "open", "(", "sweep", ")", "as", "fid", ":", "\n", "\t\t", "sweeptext", "=", "fid", ".", "read", "(", ")", "\n", "\n", "", "experiments", "=", "[", "exp", ".", "split", "(", "'\\n'", ")", "for", "exp", "in", "sweeptext", ".", "strip", "(", ")", ".", "split", "(", "'\\n\\n'", ")", "]", "\n", "params", "=", "[", "[", "param", ".", "split", "(", ")", "for", "param", "in", "exp", "[", "1", ":", "]", "]", "for", "exp", "in", "experiments", "]", "\n", "expnames", "=", "[", "exp", "[", "0", "]", "for", "exp", "in", "experiments", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "expdir", ")", ":", "\n", "\t\t", "os", ".", "makedirs", "(", "expdir", ")", "\n", "\n", "", "for", "i", ",", "expname", "in", "enumerate", "(", "expnames", ")", ":", "\n", "\t\t", "run_string", "=", "'run %s --expdir=%s --recipe=%s --computing=%s'", "%", "(", "\n", "command", ",", "os", ".", "path", ".", "join", "(", "expdir", ",", "expname", ")", ",", "os", ".", "path", ".", "join", "(", "expdir", ",", "'recipes'", ",", "expname", ")", ",", "computing", ")", "\n", "if", "computing", "!=", "'standard'", ":", "\n", "\t\t\t", "run_string", "+=", "' --minmemory=%s'", "%", "minmemory", "\n", "\n", "", "if", "command", "==", "'train'", ":", "\n", "# copy the recipe dir to the expdir", "\n", "\t\t\t", "if", "not", "resume", "==", "'True'", ":", "\n", "\t\t\t\t", "if", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'recipes'", ",", "expname", ")", ")", ":", "\n", "\t\t\t\t\t", "shutil", ".", "rmtree", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'recipes'", ",", "expname", ")", ")", "\n", "", "shutil", ".", "copytree", "(", "recipe", ",", "os", ".", "path", ".", "join", "(", "expdir", ",", "'recipes'", ",", "expname", ")", ")", "\n", "\n", "for", "param", "in", "params", "[", "i", "]", ":", "\n", "# read the config", "\n", "\t\t\t\t\t", "conf", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "conf", ".", "read", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'recipes'", ",", "expname", ",", "param", "[", "0", "]", ")", ")", "\n", "\n", "# create the new configuration", "\n", "conf", ".", "set", "(", "param", "[", "1", "]", ",", "param", "[", "2", "]", ",", "' '", ".", "join", "(", "param", "[", "3", ":", "]", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'recipes'", ",", "expname", ",", "param", "[", "0", "]", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t", "conf", ".", "write", "(", "fid", ")", "\n", "\n", "# compose the string that will be run.", "\n", "", "", "", "run_string", "+=", "' --resume=%s --sweep_flag=%s --test_when_finished=%s'", "%", "(", "\n", "resume", ",", "True", ",", "test_when_finished", ")", "\n", "\n", "if", "computing", "!=", "'standard'", ":", "\n", "\t\t\t\t", "run_string", "+=", "' --mincudamemory=%s'", "%", "mincudamemory", "\n", "\n", "", "", "elif", "command", "==", "'test'", ":", "\n", "# Expecting that recipe dir is already in place because run sweep --command=train should have already been called.", "\n", "\t\t\t", "run_string", "+=", "' --allow_early_testing=%s'", "%", "allow_early_testing", "\n", "if", "test_task", ":", "\n", "\t\t\t\t", "run_string", "+=", "' --task=%s'", "%", "test_task", "\n", "\n", "", "", "else", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "'Unknown command to sweep: %s'", "%", "command", ")", "\n", "\n", "", "if", "int", "(", "duplicates", ")", ">", "1", "or", "int", "(", "duplicates_ind_offset", ")", ">", "0", ":", "\n", "\t\t\t", "run_string", "+=", "' --duplicates=%s --duplicates_ind_offset=%s'", "%", "(", "duplicates", ",", "duplicates_ind_offset", ")", "\n", "\n", "", "os", ".", "system", "(", "run_string", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scripts.train.train": [[16, 144], ["six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "dict", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "os.path.join", "trainer_cfg[].split", "dict", "enumerate", "os.path.join", "os.path.join", "os.path.join", "configparser.ConfigParser.items", "os.path.join", "os.path.isfile", "warnings.warn", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "os.path.join", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "dict", "os.path.join", "print", "os.path.join", "os.path.join", "configparser.ConfigParser.items", "dict", "segment_trainer_cfg[].split", "print", "os.path.exists", "print", "print", "tr.train", "open", "print", "print", "print", "json.dump", "dict", "os.path.exists", "os.path.exists", "BaseException", "os.path.join", "os.path.join", "nabu.neuralnetworks.trainers.trainer_factory.factory", "configparser.ConfigParser.items", "os.path.join", "os.path.exists", "os.path.exists", "os.path.join", "round", "round", "zip"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.trainers.multi_task_trainer.MultiTaskTrainer.train", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "train", "(", "clusterfile", ",", "job_name", ",", "task_index", ",", "ssh_command", ",", "expdir", ")", ":", "\n", "\n", "\t", "\"\"\" does everything for ss training\n\n\tArgs:\n\t\tclusterfile: the file where all the machines in the cluster are\n\t\t\tspecified if None, local training will be done\n\t\tjob_name: one of ps or worker in the case of distributed training\n\t\ttask_index: the task index in this job\n\t\tssh_command: the command to use for ssh, if 'None' no tunnel will be\n\t\t\tcreated\n\t\texpdir: the experiments directory\n\t\"\"\"", "\n", "\n", "# read the database config file", "\n", "parsed_database_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "parsed_database_cfg", ".", "read", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'database.cfg'", ")", ")", "\n", "\n", "# read the ss config file", "\n", "model_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "model_cfg", ".", "read", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'model.cfg'", ")", ")", "\n", "\n", "# read the trainer config file", "\n", "parsed_trainer_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "parsed_trainer_cfg", ".", "read", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'trainer.cfg'", ")", ")", "\n", "trainer_cfg", "=", "dict", "(", "parsed_trainer_cfg", ".", "items", "(", "'trainer'", ")", ")", "\n", "\n", "# read the decoder config file", "\n", "evaluator_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "evaluator_cfg", ".", "read", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'evaluator.cfg'", ")", ")", "\n", "\n", "# read the loss config file", "\n", "losses_cfg_file", "=", "os", ".", "path", ".", "join", "(", "expdir", ",", "'loss.cfg'", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "losses_cfg_file", ")", ":", "\n", "\t\t", "warnings", ".", "warn", "(", "'In following versions it will be required to provide a loss config file'", ",", "Warning", ")", "\n", "losses_cfg_available", "=", "False", "\n", "losses_cfg", "=", "None", "\n", "", "else", ":", "\n", "\t\t", "losses_cfg_available", "=", "True", "\n", "losses_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "losses_cfg", ".", "read", "(", "losses_cfg_file", ")", "\n", "\n", "# Get the config files for each training stage. Each training stage has a different", "\n", "# segment length and its network is initliazed with the network of the previous", "\n", "# training stage", "\n", "", "segment_lengths", "=", "trainer_cfg", "[", "'segment_lengths'", "]", ".", "split", "(", "' '", ")", "\n", "# segment_lengths = [segment_lengths[-1]]", "\n", "\n", "val_sum", "=", "dict", "(", ")", "\n", "for", "seg_len_ind", ",", "segment_length", "in", "enumerate", "(", "segment_lengths", ")", ":", "\n", "\n", "\t\t", "segment_expdir", "=", "os", ".", "path", ".", "join", "(", "expdir", ",", "segment_length", ")", "\n", "\n", "segment_parsed_database_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "segment_parsed_database_cfg", ".", "read", "(", "\n", "os", ".", "path", ".", "join", "(", "segment_expdir", ",", "'database.cfg'", ")", ")", "\n", "\n", "segment_parsed_trainer_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "segment_parsed_trainer_cfg", ".", "read", "(", "\n", "os", ".", "path", ".", "join", "(", "segment_expdir", ",", "'trainer.cfg'", ")", ")", "\n", "segment_trainer_cfg", "=", "dict", "(", "segment_parsed_trainer_cfg", ".", "items", "(", "'trainer'", ")", ")", "\n", "\n", "if", "'multi_task'", "in", "segment_trainer_cfg", "[", "'trainer'", "]", ":", "\n", "\t\t\t", "segment_tasks_cfg", "=", "dict", "(", ")", "\n", "for", "task", "in", "segment_trainer_cfg", "[", "'tasks'", "]", ".", "split", "(", "' '", ")", ":", "\n", "\t\t\t\t", "segment_tasks_cfg", "[", "task", "]", "=", "dict", "(", "segment_parsed_trainer_cfg", ".", "items", "(", "task", ")", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "segment_tasks_cfg", "=", "None", "\n", "\n", "# If this is first segment length, and there is no previously validated training session for this segment length,", "\n", "# we can allow to use a different trained model to be used for bootstrapping the current model", "\n", "", "if", "seg_len_ind", "==", "0", "and", "not", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "segment_expdir", ",", "'logdir'", ",", "'validated.ckpt.index'", ")", ")", "and", "'init_file'", "in", "segment_trainer_cfg", ":", "\n", "\t\t\t", "if", "not", "os", ".", "path", ".", "exists", "(", "segment_trainer_cfg", "[", "'init_file'", "]", "+", "'.index'", ")", ":", "\n", "\t\t\t\t", "raise", "BaseException", "(", "'The requested bootstrapping model does not exist: %s'", "%", "segment_trainer_cfg", "[", "'init_file'", "]", ")", "\n", "", "init_filename", "=", "segment_trainer_cfg", "[", "'init_file'", "]", "\n", "print", "(", "'Using the following model for bootstrapping: %s'", "%", "init_filename", ")", "\n", "\n", "# If the above bootstrapping does not apply and there was no previously validated training sessions, use the", "\n", "# model of the previous segment length as initialization for the current one", "\n", "", "elif", "seg_len_ind", ">", "0", "and", "not", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "segment_expdir", ",", "'logdir'", ",", "'validated.ckpt.index'", ")", ")", ":", "\n", "\t\t\t", "init_filename", "=", "os", ".", "path", ".", "join", "(", "expdir", ",", "segment_lengths", "[", "seg_len_ind", "-", "1", "]", ",", "'model'", ",", "'network.ckpt'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "init_filename", "+", "'.index'", ")", ":", "\n", "\t\t\t\t", "init_filename", "=", "None", "\n", "\n", "", "", "else", ":", "\n", "\t\t\t", "init_filename", "=", "None", "\n", "\n", "# if this training stage has already successfully finished, skip it", "\n", "", "if", "segment_lengths", "[", "seg_len_ind", "]", "!=", "'full'", "and", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "segment_lengths", "[", "seg_len_ind", "]", ",", "'model'", ",", "'network.ckpt.index'", ")", ")", ":", "\n", "\t\t\t", "print", "(", "'Already found a fully trained model for segment length %s'", "%", "segment_length", ")", "\n", "", "else", ":", "\n", "\t\t\t", "tr", "=", "trainer_factory", ".", "factory", "(", "segment_trainer_cfg", "[", "'trainer'", "]", ")", "(", "\n", "conf", "=", "segment_trainer_cfg", ",", "\n", "tasksconf", "=", "segment_tasks_cfg", ",", "\n", "dataconf", "=", "segment_parsed_database_cfg", ",", "\n", "modelconf", "=", "model_cfg", ",", "\n", "evaluatorconf", "=", "evaluator_cfg", ",", "\n", "lossesconf", "=", "losses_cfg", ",", "\n", "expdir", "=", "segment_expdir", ",", "\n", "init_filename", "=", "init_filename", ",", "\n", "task_index", "=", "task_index", ")", "\n", "\n", "print", "(", "'starting training for segment length: %s'", "%", "segment_length", ")", "\n", "\n", "# train the model", "\n", "best_val_loss", "=", "tr", ".", "train", "(", ")", "\n", "if", "best_val_loss", "is", "not", "None", ":", "\n", "\t\t\t\t", "if", "tr", ".", "acc_steps", ":", "\n", "\t\t\t\t\t", "val_sum", "[", "segment_length", "]", "=", "{", "task", ":", "round", "(", "loss", "*", "1e5", ")", "/", "1e5", "for", "loss", ",", "task", "in", "zip", "(", "best_val_loss", ",", "tr", ".", "tasks", ")", "}", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "val_sum", "[", "segment_length", "]", "=", "round", "(", "best_val_loss", "*", "1e5", ")", "/", "1e5", "\n", "\n", "# best_val_losses, all_tasks = tr.train()", "\n", "# if best_val_losses is not None:", "\n", "# \tval_sum[segment_length] = {task: float(loss) for (loss, task) in zip(best_val_losses, all_tasks)}", "\n", "\n", "", "", "", "", "if", "val_sum", "and", "'full'", "in", "val_sum", ":", "\n", "\t\t", "out_file", "=", "os", ".", "path", ".", "join", "(", "expdir", ",", "'val_sum.json'", ")", "\n", "with", "open", "(", "out_file", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t", "print", "(", "'the validation loss ...'", ")", "\n", "print", "(", "val_sum", ")", "\n", "print", "(", "'... will be saved to memory'", ")", "\n", "json", ".", "dump", "(", "val_sum", ",", "fid", ")", "\n", "", "", "else", ":", "\n", "\t\t", "print", "(", "'Did not find a validation loss to save'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scripts.data.main": [[13, 107], ["six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "dict", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "dict", "dict", "processor.pre_loop", "conf[].split", "processor.post_loop", "processor.write_metadata", "os.path.join", "configparser.ConfigParser.sections", "configparser.ConfigParser.items", "conf[].split", "os.path.join", "configparser.ConfigParser.items", "nabu.processing.processors.processor_factory.factory", "os.path.join", "open_fn", "os.path.exists", "os.makedirs", "shutil.copyfile", "shutil.copyfile", "os.listdir", "all", "nabu.processing.tfwriters.tfwriter_factory.factory", "print", "line.strip().split", "processor", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "print", "enumerate", "line.strip", "writers[].write"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.pre_loop", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.processor.Processor.post_loop", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor.ScorelabelperfeatureProcessor.write_metadata", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["def", "main", "(", "expdir", ")", ":", "\n", "\t", "\"\"\"main function\"\"\"", "\n", "# read the data conf file", "\n", "parsed_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "parsed_cfg", ".", "read", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'database.cfg'", ")", ")", "\n", "\n", "# loop over the sections in the data config", "\n", "name", "=", "parsed_cfg", ".", "sections", "(", ")", "[", "0", "]", "\n", "\n", "# read the section", "\n", "conf", "=", "dict", "(", "parsed_cfg", ".", "items", "(", "name", ")", ")", "\n", "\n", "# the length of the segments. Possibly multiple segment lengths", "\n", "if", "'segment_lengths'", "in", "conf", ":", "\n", "\t\t", "segment_lengths", "=", "conf", "[", "'segment_lengths'", "]", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "\t\t", "segment_lengths", "=", "[", "'full'", "]", "\n", "\n", "", "if", "conf", "[", "'store_dir'", "]", "==", "'/esat/spchtemp/scratch/jzegers/dataforTF/sreMix_segmented_DANet_recs/singlefeatures_hamming_scipy/train_150k'", ":", "\n", "\t\t", "start_ind", "=", "106370", "\n", "start_ind_per_segment_length", "=", "{", "'500'", ":", "239577", ",", "'full'", ":", "106370", "}", "\n", "segment_lengths_still_to_process", "=", "segment_lengths", "\n", "", "else", ":", "\n", "\t\t", "start_ind", "=", "0", "\n", "start_ind_per_segment_length", "=", "{", "seg_len", ":", "0", "for", "seg_len", "in", "segment_lengths", "}", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "conf", "[", "'store_dir'", "]", ")", ":", "\n", "\t\t\t", "os", ".", "makedirs", "(", "conf", "[", "'store_dir'", "]", ")", "\n", "segment_lengths_still_to_process", "=", "segment_lengths", "\n", "\n", "# copy config files to store_dir for archive purposes", "\n", "shutil", ".", "copyfile", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'database.cfg'", ")", ",", "os", ".", "path", ".", "join", "(", "conf", "[", "'store_dir'", "]", ",", "'database.cfg'", ")", ")", "\n", "shutil", ".", "copyfile", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'processor.cfg'", ")", ",", "os", ".", "path", ".", "join", "(", "conf", "[", "'store_dir'", "]", ",", "'processor.cfg'", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "tmp", "=", "os", ".", "listdir", "(", "conf", "[", "'store_dir'", "]", ")", "\n", "if", "all", "(", "[", "seg_len", "in", "tmp", "for", "seg_len", "in", "segment_lengths", "]", ")", ":", "\n", "\t\t\t\t", "print", "(", "'%s already exists, skipping this section'", "%", "conf", "[", "'store_dir'", "]", ")", "\n", "return", "\n", "", "else", ":", "\n", "\t\t\t\t", "segment_lengths_still_to_process", "=", "[", "seg_len", "for", "seg_len", "in", "segment_lengths", "if", "seg_len", "not", "in", "tmp", "]", "\n", "\n", "# read the processor config", "\n", "", "", "", "parsed_proc_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "parsed_proc_cfg", ".", "read", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "'processor.cfg'", ")", ")", "\n", "proc_cfg", "=", "dict", "(", "parsed_proc_cfg", ".", "items", "(", "'processor'", ")", ")", "\n", "\n", "# create a processor", "\n", "processor", "=", "processor_factory", ".", "factory", "(", "proc_cfg", "[", "'processor'", "]", ")", "(", "proc_cfg", ",", "segment_lengths_still_to_process", ")", "\n", "\n", "# create the writers", "\n", "writers", "=", "dict", "(", ")", "\n", "for", "seg_length", "in", "segment_lengths_still_to_process", ":", "\n", "\t\t", "writer_store_dir", "=", "os", ".", "path", ".", "join", "(", "conf", "[", "'store_dir'", "]", ",", "seg_length", ")", "\n", "writers", "[", "seg_length", "]", "=", "tfwriter_factory", ".", "factory", "(", "conf", "[", "'writer_style'", "]", ")", "(", "\n", "writer_store_dir", ",", "start_ind", "=", "start_ind_per_segment_length", "[", "seg_length", "]", ")", "\n", "\n", "# before looping over the data, allow the processor to access the data (e.g.", "\n", "# for global mean and variance calculation) (or should this be done in init?)", "\n", "", "processor", ".", "pre_loop", "(", "conf", ")", "\n", "\n", "# loop over the data files", "\n", "for", "datafile", "in", "conf", "[", "'datafiles'", "]", ".", "split", "(", "' '", ")", ":", "\n", "\t\t", "if", "datafile", "[", "-", "3", ":", "]", "==", "'.gz'", ":", "\n", "\t\t\t", "open_fn", "=", "gzip", ".", "open", "\n", "", "else", ":", "\n", "\t\t\t", "open_fn", "=", "open", "\n", "\n", "# loop over the lines in the datafile", "\n", "", "ind", "=", "0", "\n", "for", "line", "in", "open_fn", "(", "datafile", ")", ":", "\n", "\t\t\t", "print", "(", "ind", ")", "\n", "if", "ind", "<", "start_ind", ":", "\n", "\t\t\t\t", "ind", "+=", "1", "\n", "continue", "\n", "# split the name and the data line", "\n", "", "splitline", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "utt_name", "=", "splitline", "[", "0", "]", "\n", "dataline", "=", "' '", ".", "join", "(", "splitline", "[", "1", ":", "]", ")", "\n", "\n", "# process the dataline", "\n", "processed", ",", "_", "=", "processor", "(", "dataline", ")", "\n", "\n", "# write the processed data to disk", "\n", "for", "seg_length", "in", "segment_lengths_still_to_process", ":", "\n", "\t\t\t\t", "for", "i", ",", "proc_seg", "in", "enumerate", "(", "processed", "[", "seg_length", "]", ")", ":", "\n", "\t\t\t\t\t", "seg_utt_name", "=", "utt_name", "+", "'_part %d'", "%", "i", "\n", "writers", "[", "seg_length", "]", ".", "write", "(", "proc_seg", ",", "seg_utt_name", ")", "\n", "", "", "ind", "+=", "1", "\n", "\n", "# after looping over the data, allow the processor to access the data", "\n", "", "", "processor", ".", "post_loop", "(", "conf", ")", "\n", "\n", "# write the metadata to file", "\n", "processor", ".", "write_metadata", "(", "conf", "[", "'store_dir'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scripts.prepare_data.main": [[14, 94], ["six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "configparser.ConfigParser.sections", "os.path.join", "Exception", "os.path.isdir", "Exception", "Exception", "Exception", "os.path.join", "os.path.isfile", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "dict", "dict", "parsed_cfg.sections.remove", "print", "dict", "configparser.ConfigParser.items", "configparser.ConfigParser.items", "configparser.ConfigParser.items", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.add_section", "shutil.copyfile", "print", "os.path.isdir", "os.makedirs", "open", "configparser.ConfigParser.write", "os.path.join", "subprocess.call", "data.main", "os.path.join", "os.path.join", "configparser.ConfigParser.set", "configparser.ConfigParser.set", "os.path.join", "six.moves.configparser.ConfigParser", "configparser.ConfigParser.read", "dict", "os.path.isdir", "os.makedirs", "os.path.join", "configparser.ConfigParser.items", "os.path.join", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.call", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.scripts.prepare_data.main"], ["def", "main", "(", "expdir", ",", "recipe", ",", "computing", ",", "minmemory", ")", ":", "\n", "\t", "\"\"\"main method\"\"\"", "\n", "\n", "if", "recipe", "is", "None", ":", "\n", "\t\t", "raise", "Exception", "(", "'no recipe specified. Command usage: run data --recipe=/path/to/recipe'", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "recipe", ")", ":", "\n", "\t\t", "raise", "Exception", "(", "'cannot find recipe %s'", "%", "recipe", ")", "\n", "", "if", "expdir", "is", "None", ":", "\n", "\t\t", "raise", "Exception", "(", "\n", "'no expdir specified. Command usage: run data --expdir=/path/to/recipe --recipe=/path/to/recipe'", ")", "\n", "", "if", "computing", "not", "in", "[", "'standard'", ",", "'condor'", "]", ":", "\n", "\t\t", "raise", "Exception", "(", "'unknown computing mode: %s'", "%", "computing", ")", "\n", "\n", "# read the data conf file", "\n", "", "parsed_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "parsed_cfg", ".", "read", "(", "os", ".", "path", ".", "join", "(", "recipe", ",", "'database.conf'", ")", ")", "\n", "cfg_sections", "=", "parsed_cfg", ".", "sections", "(", ")", "\n", "exp_specific_computing_cfg_file", "=", "os", ".", "path", ".", "join", "(", "recipe", ",", "'computing.cfg'", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "exp_specific_computing_cfg_file", ")", "and", "computing", "!=", "'standard'", "and", "not", "minmemory", ":", "\n", "\t\t", "parsed_exp_specific_computing_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "parsed_exp_specific_computing_cfg", ".", "read", "(", "exp_specific_computing_cfg_file", ")", "\n", "exp_specific_computing_cfg", "=", "dict", "(", "parsed_exp_specific_computing_cfg", ".", "items", "(", "'computing'", ")", ")", "\n", "minmemory", "=", "exp_specific_computing_cfg", "[", "'mindatamemory'", "]", "\n", "\n", "# check which parameters are defined globaly for database", "\n", "", "if", "'globalvars'", "in", "cfg_sections", ":", "\n", "\t\t", "globaldataconf", "=", "dict", "(", "parsed_cfg", ".", "items", "(", "'globalvars'", ")", ")", "\n", "\n", "cfg_sections", ".", "remove", "(", "'globalvars'", ")", "\n", "\n", "# loop over the sections in the data config", "\n", "", "for", "name", "in", "cfg_sections", ":", "\n", "\n", "\t\t", "print", "(", "'processing %s'", "%", "name", ")", "\n", "\n", "# read the section", "\n", "conf", "=", "dict", "(", "parsed_cfg", ".", "items", "(", "name", ")", ")", "\n", "\n", "if", "conf", "[", "'preprocess'", "]", "==", "'True'", ":", "\n", "# create the expdir for this section", "\n", "\t\t\t", "if", "not", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "name", ")", ")", ":", "\n", "\t\t\t\t", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "name", ")", ")", "\n", "\n", "# create the database configuration", "\n", "", "dataconf", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "dataconf", ".", "add_section", "(", "name", ")", "\n", "for", "item", "in", "conf", ":", "\n", "\t\t\t\t", "if", "conf", "[", "item", "]", "==", "'globalvars'", ":", "\n", "\t\t\t\t\t", "dataconf", ".", "set", "(", "name", ",", "item", ",", "globaldataconf", "[", "item", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "dataconf", ".", "set", "(", "name", ",", "item", ",", "conf", "[", "item", "]", ")", "\n", "\n", "", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "name", ",", "'database.cfg'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "dataconf", ".", "write", "(", "fid", ")", "\n", "\n", "# copy the processor config", "\n", "", "shutil", ".", "copyfile", "(", "\n", "conf", "[", "'processor_config'", "]", ",", "\n", "os", ".", "path", ".", "join", "(", "expdir", ",", "name", ",", "'processor.cfg'", ")", ")", "\n", "#", "\n", "computing_cfg_file", "=", "'config/computing/%s/%s.cfg'", "%", "(", "computing", ",", "'non_distributed'", ")", "\n", "\n", "if", "computing", "==", "'condor'", ":", "\n", "\t\t\t\t", "if", "not", "minmemory", ":", "\n", "# read the computing config file", "\n", "\t\t\t\t\t", "parsed_computing_cfg", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "parsed_computing_cfg", ".", "read", "(", "computing_cfg_file", ")", "\n", "computing_cfg", "=", "dict", "(", "parsed_computing_cfg", ".", "items", "(", "'computing'", ")", ")", "\n", "minmemory", "=", "computing_cfg", "[", "'mindatamemory'", "]", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "name", ",", "'outputs'", ")", ")", ":", "\n", "\t\t\t\t\t", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "name", ",", "'outputs'", ")", ")", "\n", "", "subprocess", ".", "call", "(", "[", "\n", "'condor_submit'", ",", "'expdir=%s'", "%", "os", ".", "path", ".", "join", "(", "expdir", ",", "name", ")", ",", "'memory=%s'", "%", "minmemory", ",", "\n", "'nabu/computing/condor/dataprep.job'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "data", ".", "main", "(", "os", ".", "path", ".", "join", "(", "expdir", ",", "name", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "\t\t\t", "print", "(", "'Did not require storage.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.angspec.Angspec.comp_feat": [[13, 41], ["sigproc.snip", "float", "float", "base.angspec_scipy", "base.angspec", "numpy.append", "base.fbank_scipy", "base.fbank"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.angspec_scipy", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.angspec", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "            ", "feat", "=", "base", ".", "angspec_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "            ", "feat", "=", "base", ".", "angspec", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "\n", "", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "                ", "_", ",", "energy", "=", "base", ".", "fbank_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "                ", "_", ",", "energy", "=", "base", ".", "fbank", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "feat", "=", "np", ".", "append", "(", "feat", ",", "energy", "[", ":", ",", "np", ".", "newaxis", "]", ",", "1", ")", "\n", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.angspec.Angspec.get_dim": [[42, 51], ["int"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "int", "(", "self", ".", "conf", "[", "'nfft'", "]", ")", "/", "2", "+", "1", "\n", "\n", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "dim", "+=", "1", "\n", "\n", "", "return", "dim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.raw": [[44, 59], ["signal.astype", "numpy.max", "numpy.max", "numpy.abs", "numpy.abs"], "function", ["None"], ["def", "raw", "(", "signal", ")", ":", "\n", "    ", "\"\"\"\n    compute the raw audio signal with limited range\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n\n    Returns:\n        A numpy array of size (N by 1) containing the raw audio limited to a\n        range between -1 and 1\n    \"\"\"", "\n", "feat", "=", "signal", ".", "astype", "(", "numpy", ".", "float32", ")", "/", "numpy", ".", "max", "(", "numpy", ".", "abs", "(", "signal", ")", ")", "\n", "\n", "return", "feat", "[", ":", ",", "numpy", ".", "newaxis", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec": [[61, 84], ["base._get_winfunc", "sigproc.framesig", "sigproc.spec", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.spec"], ["", "def", "spec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute complex spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the complex\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "spec", "=", "sigproc", ".", "spec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "spec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec_scipy": [[86, 114], ["int", "int", "scipy.signal.stft", "scipy.signal.stft", "numpy.transpose", "round", "round", "float", "float"], "function", ["None"], ["", "def", "spec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute complex spectrogram features from an audio signal., via scipy (I hope this takes into account the edge effect\n    that is being considered by Emmanuel Vincent in stft_multi.m\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the complex\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "\n", "frame_len", "=", "int", "(", "round", "(", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ")", ")", "\n", "frame_step", "=", "int", "(", "round", "(", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ")", ")", "\n", "frame_overlap", "=", "frame_len", "-", "frame_step", "\n", "# winfunc = _get_winfunc(conf['winfunc'])", "\n", "# win = winfunc(frame_len)", "\n", "\n", "[", "_", ",", "_", ",", "spec", "]", "=", "scipy", ".", "signal", ".", "stft", "(", "\n", "signal", ",", "window", "=", "conf", "[", "'winfunc'", "]", ",", "nperseg", "=", "frame_len", ",", "noverlap", "=", "frame_overlap", ",", "nfft", "=", "frame_len", ",", "detrend", "=", "False", ",", "\n", "return_onesided", "=", "True", ",", "boundary", "=", "'zeros'", ",", "padded", "=", "True", ",", "axis", "=", "-", "1", ")", "\n", "spec", "=", "np", ".", "transpose", "(", "spec", ")", "\n", "return", "spec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec2time": [[116, 145], ["sigproc.spec2frames", "base._get_winfunc", "sigproc.deframesig", "numpy.max", "numpy.max", "float", "float", "numpy.abs", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.spec2frames", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.deframesig"], ["", "def", "spec2time", "(", "spec", ",", "samplerate", ",", "siglen", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute the time domain signal from the complex spectrogram. No preemphasis is assumed.\n\n    Args:\n    spec: A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the complex\n        spectrum of the corresponding frame\n        samplerate: the samplerate of the signal we are working with.\n        siglen the: length of the desired signal, use 0 if unknown. Output will\n            be truncated to siglen samples.\n        conf: feature configuration\n\n    Returns:\n        signal: the audio signal from which to compute features. This is an\n            N*1 array\n    \"\"\"", "\n", "\n", "frames", "=", "sigproc", ".", "spec2frames", "(", "spec", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "signal", "=", "sigproc", ".", "deframesig", "(", "\n", "frames", ",", "siglen", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "winfunc", ")", "\n", "\n", "# Limit the range of the signal between -1.0 and 1.0", "\n", "signal", "=", "signal", "/", "numpy", ".", "max", "(", "numpy", ".", "abs", "(", "signal", ")", ")", "\n", "\n", "return", "signal", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec2time_scipy": [[147, 179], ["int", "int", "scipy.signal.istft", "scipy.signal.istft", "round", "round", "float", "float"], "function", ["None"], ["", "def", "spec2time_scipy", "(", "spec", ",", "samplerate", ",", "siglen", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute the time domain signal from the complex spectrogram. No preemphasis is assumed.\n\n    Args:\n    spec: A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the complex\n        spectrum of the corresponding frame\n        samplerate: the samplerate of the signal we are working with.\n        siglen the: length of the desired signal, use 0 if unknown. Output will\n            be truncated to siglen samples.\n        conf: feature configuration\n\n    Returns:\n        signal: the audio signal from which to compute features. This is an\n            N*1 array\n    \"\"\"", "\n", "\n", "frame_len", "=", "int", "(", "round", "(", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ")", ")", "\n", "frame_step", "=", "int", "(", "round", "(", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ")", ")", "\n", "frame_overlap", "=", "frame_len", "-", "frame_step", "\n", "# winfunc = _get_winfunc(conf['winfunc'])", "\n", "# win = winfunc(frame_len)", "\n", "\n", "[", "_", ",", "signal", "]", "=", "scipy", ".", "signal", ".", "istft", "(", "\n", "spec", ",", "window", "=", "conf", "[", "'winfunc'", "]", ",", "nperseg", "=", "frame_len", ",", "noverlap", "=", "frame_overlap", ",", "nfft", "=", "frame_len", ",", "input_onesided", "=", "True", ",", "boundary", "=", "True", ",", "\n", "time_axis", "=", "0", ",", "freq_axis", "=", "1", ")", "\n", "\n", "if", "siglen", "!=", "0", ":", "\n", "        ", "signal", "=", "signal", "[", ":", "siglen", "]", "\n", "\n", "", "return", "signal", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.frames": [[181, 204], ["sigproc.preemphasis", "base._get_winfunc", "sigproc.framesig", "float", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig"], ["", "def", "frames", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute frames from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by winlen) containing features. Each\n        row holds 1 feature vector\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "\n", "return", "frames", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.powspec": [[206, 231], ["sigproc.preemphasis", "base._get_winfunc", "sigproc.framesig", "sigproc.powspec", "float", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec"], ["", "def", "powspec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute squared magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "powspec", "=", "sigproc", ".", "powspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "powspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.powspec_scipy": [[233, 253], ["sigproc.preemphasis", "base.spec_scipy", "numpy.square", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec_scipy"], ["", "def", "powspec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute squared magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "spec", "=", "spec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", "\n", "powspec", "=", "np", ".", "square", "(", "spec", ")", "\n", "\n", "return", "powspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.magspec": [[255, 280], ["sigproc.preemphasis", "base._get_winfunc", "sigproc.framesig", "sigproc.magspec", "float", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.magspec"], ["", "def", "magspec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "magspec", "=", "sigproc", ".", "magspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "magspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.magspec_scipy": [[282, 302], ["sigproc.preemphasis", "base.spec_scipy", "numpy.abs", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec_scipy"], ["", "def", "magspec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "spec", "=", "spec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", "\n", "magspec", "=", "np", ".", "abs", "(", "spec", ")", "\n", "\n", "return", "magspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.angspec": [[304, 329], ["sigproc.preemphasis", "base._get_winfunc", "sigproc.framesig", "sigproc.angspec", "float", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.angspec"], ["", "def", "angspec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute angular spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the angular\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "angspec", "=", "sigproc", ".", "angspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "angspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.angspec_scipy": [[331, 351], ["sigproc.preemphasis", "base.spec_scipy", "numpy.angle", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec_scipy"], ["", "def", "angspec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute angular spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the angular\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "spec", "=", "spec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", "\n", "angspec", "=", "np", ".", "angle", "(", "spec", ")", "\n", "\n", "return", "angspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.logspec": [[353, 378], ["sigproc.preemphasis", "base._get_winfunc", "sigproc.framesig", "sigproc.logmagspec", "float", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.logmagspec"], ["", "def", "logspec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute log magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the log magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "logspec", "=", "sigproc", ".", "logmagspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "logspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.logspec_scipy": [[380, 402], ["sigproc.preemphasis", "base.spec_scipy", "numpy.abs", "float", "numpy.log10"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec_scipy"], ["", "def", "logspec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute log magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the log magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "spec", "=", "spec_scipy", "(", "signal", ",", "samplerate", ",", "conf", ")", "\n", "magspec", "=", "np", ".", "abs", "(", "spec", ")", "\n", "magspec", "[", "magspec", "<=", "1e-30", "]", "=", "1e-30", "\n", "logspec", "=", "10", "*", "np", ".", "log10", "(", "magspec", ")", "\n", "\n", "return", "logspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base._get_winfunc": [[404, 427], ["Exception", "numpy.ones", "numpy.ones"], "function", ["None"], ["", "def", "_get_winfunc", "(", "str_winfunc", ")", ":", "\n", "    ", "\"\"\"\n    Get the requested window function.\n\n    Args:\n    str_winfunc: a string indicating the desired window function\n\n    Returns:\n    winfunc: the desired window function as a python lambda function\n    \"\"\"", "\n", "\n", "if", "str_winfunc", "==", "'cosine'", ":", "\n", "        ", "winfunc", "=", "scipy", ".", "signal", ".", "cosine", "\n", "", "elif", "str_winfunc", "==", "'hanning'", ":", "\n", "        ", "winfunc", "=", "scipy", ".", "hanning", "\n", "", "elif", "str_winfunc", "==", "'hamming'", ":", "\n", "        ", "winfunc", "=", "scipy", ".", "signal", ".", "hamming", "\n", "", "elif", "str_winfunc", "==", "'none'", "or", "str_winfunc", "==", "'None'", ":", "\n", "        ", "winfunc", "=", "lambda", "x", ":", "numpy", ".", "ones", "(", "(", "x", ",", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'unknown window function: %s'", "%", "str_winfunc", ")", "\n", "\n", "", "return", "winfunc", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.mfcc": [[429, 450], ["base.fbank", "numpy.log", "numpy.log", "base.lifter", "scipy.fftpack.dct", "float", "numpy.log", "numpy.log", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.lifter"], ["", "def", "mfcc", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute MFCC features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numcep) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the signal\n        log-energy\n    \"\"\"", "\n", "\n", "feat", ",", "energy", "=", "fbank", "(", "signal", ",", "samplerate", ",", "conf", ")", "\n", "feat", "=", "numpy", ".", "log", "(", "feat", ")", "\n", "feat", "=", "dct", "(", "feat", ",", "type", "=", "2", ",", "axis", "=", "1", ",", "norm", "=", "'ortho'", ")", "[", ":", ",", ":", "int", "(", "conf", "[", "'numcep'", "]", ")", "]", "\n", "feat", "=", "lifter", "(", "feat", ",", "float", "(", "conf", "[", "'ceplifter'", "]", ")", ")", "\n", "return", "feat", ",", "numpy", ".", "log", "(", "energy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.fbank": [[452, 492], ["int", "sigproc.preemphasis", "sigproc.framesig", "sigproc.powspec", "numpy.sum", "numpy.sum", "numpy.where", "numpy.where", "base.get_filterbanks", "numpy.dot", "numpy.dot", "numpy.where", "numpy.where", "float", "int", "int", "int", "int", "float", "float", "numpy.finfo", "numpy.finfo", "numpy.finfo", "numpy.finfo"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.get_filterbanks"], ["", "def", "fbank", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute fbank features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by nfilt) containing features, a numpy\n        vector containing the signal energy\n    \"\"\"", "\n", "\n", "highfreq", "=", "int", "(", "conf", "[", "'highfreq'", "]", ")", "\n", "if", "highfreq", "<", "0", ":", "\n", "        ", "highfreq", "=", "samplerate", "/", "2", "\n", "\n", "", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ")", "\n", "pspec", "=", "sigproc", ".", "powspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "# this stores the total energy in each frame", "\n", "energy", "=", "numpy", ".", "sum", "(", "pspec", ",", "1", ")", "\n", "\n", "# if energy is zero, we get problems with log", "\n", "energy", "=", "numpy", ".", "where", "(", "energy", "==", "0", ",", "numpy", ".", "finfo", "(", "float", ")", ".", "eps", ",", "energy", ")", "\n", "\n", "filterbank", "=", "get_filterbanks", "(", "int", "(", "conf", "[", "'nfilt'", "]", ")", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ",", "\n", "samplerate", ",", "int", "(", "conf", "[", "'lowfreq'", "]", ")", ",", "highfreq", ")", "\n", "\n", "# compute the filterbank energies", "\n", "feat", "=", "numpy", ".", "dot", "(", "pspec", ",", "filterbank", ".", "T", ")", "\n", "\n", "# if feat is zero, we get problems with log", "\n", "feat", "=", "numpy", ".", "where", "(", "feat", "==", "0", ",", "numpy", ".", "finfo", "(", "float", ")", ".", "eps", ",", "feat", ")", "\n", "\n", "return", "feat", ",", "energy", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.logfbank": [[494, 510], ["base.fbank", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank"], ["", "def", "logfbank", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute log-fbank features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by nfilt) containing features, a numpy\n        vector containing the signal log-energy\n    \"\"\"", "\n", "feat", ",", "energy", "=", "fbank", "(", "signal", ",", "samplerate", ",", "conf", ")", "\n", "return", "numpy", ".", "log", "(", "feat", ")", ",", "numpy", ".", "log", "(", "energy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.ssc": [[512, 550], ["int", "sigproc.preemphasis", "sigproc.framesig", "sigproc.powspec", "numpy.sum", "numpy.sum", "numpy.where", "numpy.where", "base.get_filterbanks", "numpy.dot", "numpy.dot", "numpy.tile", "numpy.tile", "float", "int", "int", "int", "int", "numpy.linspace", "numpy.linspace", "numpy.log", "numpy.log", "float", "float", "numpy.finfo", "numpy.finfo", "numpy.size", "numpy.size", "numpy.size", "numpy.size", "numpy.dot", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.get_filterbanks"], ["", "def", "ssc", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute ssc features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by nfilt) containing features, a numpy\n        vector containing the signal log-energy\n    \"\"\"", "\n", "\n", "highfreq", "=", "int", "(", "conf", "[", "'highfreq'", "]", ")", "\n", "if", "highfreq", "<", "0", ":", "\n", "        ", "highfreq", "=", "samplerate", "/", "2", "\n", "", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ")", "\n", "pspec", "=", "sigproc", ".", "powspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "# this stores the total energy in each frame", "\n", "energy", "=", "numpy", ".", "sum", "(", "pspec", ",", "1", ")", "\n", "\n", "# if energy is zero, we get problems with log", "\n", "energy", "=", "numpy", ".", "where", "(", "energy", "==", "0", ",", "numpy", ".", "finfo", "(", "float", ")", ".", "eps", ",", "energy", ")", "\n", "\n", "filterbank", "=", "get_filterbanks", "(", "int", "(", "conf", "[", "'nfilt'", "]", ")", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ",", "\n", "samplerate", ",", "int", "(", "conf", "[", "'lowfreq'", "]", ")", ",", "highfreq", ")", "\n", "\n", "# compute the filterbank energies", "\n", "feat", "=", "numpy", ".", "dot", "(", "pspec", ",", "filterbank", ".", "T", ")", "\n", "tiles", "=", "numpy", ".", "tile", "(", "numpy", ".", "linspace", "(", "1", ",", "samplerate", "/", "2", ",", "numpy", ".", "size", "(", "pspec", ",", "1", ")", ")", ",", "\n", "(", "numpy", ".", "size", "(", "pspec", ",", "0", ")", ",", "1", ")", ")", "\n", "\n", "return", "numpy", ".", "dot", "(", "pspec", "*", "tiles", ",", "filterbank", ".", "T", ")", "/", "feat", ",", "numpy", ".", "log", "(", "energy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.hz2mel": [[552, 565], ["numpy.log10", "numpy.log10"], "function", ["None"], ["", "def", "hz2mel", "(", "rate", ")", ":", "\n", "    ", "\"\"\"\n    Convert a value in Hertz to Mels\n\n    Args:\n        rate: a value in Hz. This can also be a numpy array, conversion proceeds\n            element-wise.\n\n    Returns:\n        a value in Mels. If an array was passed in, an identical sized array is\n        returned.\n    \"\"\"", "\n", "return", "2595", "*", "numpy", ".", "log10", "(", "1", "+", "rate", "/", "700.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.mel2hz": [[567, 580], ["None"], "function", ["None"], ["", "def", "mel2hz", "(", "mel", ")", ":", "\n", "    ", "\"\"\"\n    Convert a value in Mels to Hertz\n\n    Args:\n        mel: a value in Mels. This can also be a numpy array, conversion\n            proceeds element-wise.\n\n    Returns:\n        a value in Hertz. If an array was passed in, an identical sized array is\n        returned.\n    \"\"\"", "\n", "return", "700", "*", "(", "10", "**", "(", "mel", "/", "2595.0", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.get_filterbanks": [[582, 622], ["base.hz2mel", "base.hz2mel", "numpy.linspace", "numpy.linspace", "numpy.floor", "numpy.floor", "numpy.zeros", "numpy.zeros", "xrange", "xrange", "xrange", "int", "int", "int", "int", "base.mel2hz"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.hz2mel", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.hz2mel", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.mel2hz"], ["", "def", "get_filterbanks", "(", "nfilt", "=", "20", ",", "nfft", "=", "512", ",", "samplerate", "=", "16000", ",", "lowfreq", "=", "0", ",", "\n", "highfreq", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute a Mel-filterbank.\n\n    The filters are stored in the rows, the columns correspond to fft bins.\n    The filters are returned as an array of size nfilt * (nfft/2 + 1)\n\n    Args:\n        nfilt: the number of filters in the filterbank, default 20.\n        nfft: the FFT size. Default is 512.\n        samplerate: the samplerate of the signal we are working with. Affects\n            mel spacing.\n        lowfreq: lowest band edge of mel filters, default 0 Hz\n        highfreq: highest band edge of mel filters, default samplerate/2\n\n    Returns:\n        A numpy array of size nfilt * (nfft/2 + 1) containing filterbank. Each\n        row holds 1 filter.\n    \"\"\"", "\n", "\n", "highfreq", "=", "highfreq", "or", "samplerate", "/", "2", "\n", "assert", "highfreq", "<=", "samplerate", "/", "2", ",", "\"highfreq is greater than samplerate/2\"", "\n", "\n", "# compute points evenly spaced in mels", "\n", "lowmel", "=", "hz2mel", "(", "lowfreq", ")", "\n", "highmel", "=", "hz2mel", "(", "highfreq", ")", "\n", "melpoints", "=", "numpy", ".", "linspace", "(", "lowmel", ",", "highmel", ",", "nfilt", "+", "2", ")", "\n", "\n", "# our points are in Hz, but we use fft bins, so we have to convert", "\n", "#  from Hz to fft bin number", "\n", "bins", "=", "numpy", ".", "floor", "(", "(", "nfft", "+", "1", ")", "*", "mel2hz", "(", "melpoints", ")", "/", "samplerate", ")", "\n", "\n", "fbanks", "=", "numpy", ".", "zeros", "(", "[", "nfilt", ",", "nfft", "/", "2", "+", "1", "]", ")", "\n", "for", "j", "in", "xrange", "(", "0", ",", "nfilt", ")", ":", "\n", "        ", "for", "i", "in", "xrange", "(", "int", "(", "bins", "[", "j", "]", ")", ",", "int", "(", "bins", "[", "j", "+", "1", "]", ")", ")", ":", "\n", "            ", "fbanks", "[", "j", ",", "i", "]", "=", "(", "i", "-", "bins", "[", "j", "]", ")", "/", "(", "bins", "[", "j", "+", "1", "]", "-", "bins", "[", "j", "]", ")", "\n", "", "for", "i", "in", "xrange", "(", "int", "(", "bins", "[", "j", "+", "1", "]", ")", ",", "int", "(", "bins", "[", "j", "+", "2", "]", ")", ")", ":", "\n", "            ", "fbanks", "[", "j", ",", "i", "]", "=", "(", "bins", "[", "j", "+", "2", "]", "-", "i", ")", "/", "(", "bins", "[", "j", "+", "2", "]", "-", "bins", "[", "j", "+", "1", "]", ")", "\n", "", "", "return", "fbanks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.lifter": [[624, 646], ["numpy.shape", "numpy.shape", "numpy.sin", "numpy.sin", "numpy.arange", "numpy.arange"], "function", ["None"], ["", "def", "lifter", "(", "cepstra", ",", "liftering", "=", "22.0", ")", ":", "\n", "    ", "\"\"\"\n    Apply a cepstral lifter the the matrix of cepstra.\n\n    This has the effect of increasing the magnitude of the high frequency DCT\n    coeffs.\n\n    Args:\n        cepstra: the matrix of mel-cepstra, will be numframes * numcep in size.\n        liftering: the liftering coefficient to use. Default is 22. L <= 0\n            disables lifter.\n\n    Returns:\n        the lifted cepstra\n    \"\"\"", "\n", "if", "liftering", ">", "0", ":", "\n", "        ", "_", ",", "ncoeff", "=", "numpy", ".", "shape", "(", "cepstra", ")", "\n", "lift", "=", "1", "+", "(", "liftering", "/", "2", ")", "*", "numpy", ".", "sin", "(", "numpy", ".", "pi", "*", "numpy", ".", "arange", "(", "ncoeff", ")", "/", "liftering", ")", "\n", "return", "lift", "*", "cepstra", "\n", "", "else", ":", "\n", "# values of liftering <= 0, do nothing", "\n", "        ", "return", "cepstra", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.deriv": [[648, 659], ["scipy.ndimage.convolve1d", "numpy.array", "numpy.array"], "function", ["None"], ["", "", "def", "deriv", "(", "features", ")", ":", "\n", "    ", "\"\"\"\n    Compute the first order derivative of the features\n\n    Args:\n        features: the input features\n\n    Returns:\n        the firs order derivative\n    \"\"\"", "\n", "return", "convolve1d", "(", "features", ",", "numpy", ".", "array", "(", "[", "2", ",", "1", ",", "0", ",", "-", "1", ",", "-", "2", "]", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.delta": [[661, 672], ["numpy.concatenate", "numpy.concatenate", "base.deriv"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.deriv"], ["", "def", "delta", "(", "features", ")", ":", "\n", "    ", "\"\"\"\n    concatenate the first order derivative to the features\n\n    Args:\n        features: the input features\n\n    Returns:\n        the features concatenated with the first order derivative\n    \"\"\"", "\n", "return", "numpy", ".", "concatenate", "(", "(", "features", ",", "deriv", "(", "features", ")", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.ddelta": [[674, 686], ["base.deriv", "numpy.concatenate", "numpy.concatenate", "base.deriv"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.deriv", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.deriv"], ["", "def", "ddelta", "(", "features", ")", ":", "\n", "    ", "\"\"\"\n    concatenate the first and second order derivative to the features\n\n    Args:\n        features: the input features\n\n    Returns:\n        the features concatenated with the first and second order derivative\n    \"\"\"", "\n", "deltafeat", "=", "deriv", "(", "features", ")", "\n", "return", "numpy", ".", "concatenate", "(", "(", "features", ",", "deltafeat", ",", "deriv", "(", "deltafeat", ")", ")", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.feature_computer_factory.factory": [[14, 42], ["Exception"], "function", ["None"], ["def", "factory", "(", "feature", ")", ":", "\n", "\t", "\"\"\"\n\tcreate a FeatureComputer\n\n\tArgs:\n\t\tfeature: the feature computer type\n\t\"\"\"", "\n", "\n", "if", "feature", "==", "'fbank'", ":", "\n", "\t\t", "return", "fbank", ".", "Fbank", "\n", "", "elif", "feature", "==", "'mfcc'", ":", "\n", "\t\t", "return", "mfcc", ".", "Mfcc", "\n", "", "elif", "feature", "==", "'logspec'", ":", "\n", "\t\t", "return", "logspec", ".", "Logspec", "\n", "", "elif", "feature", "==", "'magspec'", ":", "\n", "\t\t", "return", "magspec", ".", "Magspec", "\n", "", "elif", "feature", "==", "'powspec'", ":", "\n", "\t\t", "return", "magspec", ".", "Powspec", "\n", "", "elif", "feature", "==", "'angspec'", ":", "\n", "\t\t", "return", "angspec", ".", "Angspec", "\n", "", "elif", "feature", "==", "'spec'", ":", "\n", "\t\t", "return", "spec", ".", "Spec", "\n", "", "elif", "feature", "==", "'raw'", ":", "\n", "\t\t", "return", "raw", ".", "Raw", "\n", "", "elif", "feature", "==", "'frames'", ":", "\n", "\t\t", "return", "frames", ".", "Frames", "\n", "", "else", ":", "\n", "\t\t", "raise", "Exception", "(", "'Undefined feature type: %s'", "%", "feature", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.raw": [[20, 35], ["signal.astype", "numpy.max", "numpy.abs"], "function", ["None"], ["def", "raw", "(", "signal", ")", ":", "\n", "    ", "\"\"\"\n    compute the raw audio signal with limited range\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n\n    Returns:\n        A numpy array of size (N by 1) containing the raw audio limited to a\n        range between -1 and 1\n    \"\"\"", "\n", "feat", "=", "signal", ".", "astype", "(", "numpy", ".", "float32", ")", "/", "numpy", ".", "max", "(", "numpy", ".", "abs", "(", "signal", ")", ")", "\n", "\n", "return", "feat", "[", ":", ",", "numpy", ".", "newaxis", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.spec": [[37, 61], ["BaseException", "base_Jeroen._get_winfunc", "sigproc.framesig", "sigproc.spec", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.spec"], ["", "def", "spec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute complex spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the complex\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "spec", "=", "sigproc", ".", "spec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "spec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.spec2time": [[63, 93], ["BaseException", "sigproc.spec2frames", "base_Jeroen._get_winfunc", "sigproc.deframesig", "numpy.max", "float", "float", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.spec2frames", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.deframesig"], ["", "def", "spec2time", "(", "spec", ",", "samplerate", ",", "siglen", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute the time domain signal from the complex spectrogram. No preemphasis is assumed.\n\n    Args:\n    spec: A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the complex\n        spectrum of the corresponding frame\n        samplerate: the samplerate of the signal we are working with.\n        siglen the: length of the desired signal, use 0 if unknown. Output will\n            be truncated to siglen samples.\n        conf: feature configuration\n\n    Returns:\n        signal: the audio signal from which to compute features. This is an\n            N*1 array\n    \"\"\"", "\n", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "frames", "=", "sigproc", ".", "spec2frames", "(", "spec", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "signal", "=", "sigproc", ".", "deframesig", "(", "\n", "frames", ",", "siglen", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "winfunc", ")", "\n", "\n", "# Limit the range of the signal between -1.0 and 1.0", "\n", "signal", "=", "signal", "/", "numpy", ".", "max", "(", "numpy", ".", "abs", "(", "signal", ")", ")", "\n", "\n", "return", "signal", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.frames": [[95, 119], ["BaseException", "sigproc.preemphasis", "base_Jeroen._get_winfunc", "sigproc.framesig", "float", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig"], ["", "def", "frames", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute frames from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by winlen) containing features. Each\n        row holds 1 feature vector\n    \"\"\"", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "\n", "return", "frames", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.powspec": [[121, 148], ["BaseException", "sigproc.preemphasis", "base_Jeroen._get_winfunc", "sigproc.framesig", "sigproc.powspec", "float", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec"], ["", "def", "powspec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute squared magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "powspec", "=", "sigproc", ".", "powspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "powspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.magspec": [[150, 177], ["BaseException", "sigproc.preemphasis", "base_Jeroen._get_winfunc", "sigproc.framesig", "sigproc.magspec", "float", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.magspec"], ["", "def", "magspec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "magspec", "=", "sigproc", ".", "magspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "magspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.angspec": [[179, 206], ["BaseException", "sigproc.preemphasis", "base_Jeroen._get_winfunc", "sigproc.framesig", "sigproc.angspec", "float", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.angspec"], ["", "def", "angspec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute angular spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the angular\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "angspec", "=", "sigproc", ".", "angspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "angspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.logspec": [[208, 234], ["BaseException", "sigproc.preemphasis", "base_Jeroen._get_winfunc", "sigproc.framesig", "sigproc.logmagspec", "float", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.logmagspec"], ["", "def", "logspec", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute log magnitude spectrogram features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numfreq) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the log magnitude\n        spectrum of the corresponding frame\n    \"\"\"", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "\n", "winfunc", "=", "_get_winfunc", "(", "conf", "[", "'winfunc'", "]", ")", "\n", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ",", "\n", "winfunc", ")", "\n", "logspec", "=", "sigproc", ".", "logmagspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "return", "logspec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen._get_winfunc": [[236, 259], ["Exception", "numpy.ones"], "function", ["None"], ["", "def", "_get_winfunc", "(", "str_winfunc", ")", ":", "\n", "    ", "\"\"\"\n    Get the requested window function.\n\n    Args:\n    str_winfunc: a string indicating the desired window function\n\n    Returns:\n    winfunc: the desired window function as a python lambda function\n    \"\"\"", "\n", "\n", "if", "str_winfunc", "==", "'cosine'", ":", "\n", "        ", "winfunc", "=", "scipy", ".", "signal", ".", "cosine", "\n", "", "elif", "str_winfunc", "==", "'hanning'", ":", "\n", "        ", "winfunc", "=", "scipy", ".", "hanning", "\n", "", "elif", "str_winfunc", "==", "'hamming'", ":", "\n", "        ", "winfunc", "=", "scipy", ".", "signal", ".", "hamming", "\n", "", "elif", "str_winfunc", "==", "'none'", "or", "str_winfunc", "==", "'None'", ":", "\n", "        ", "winfunc", "=", "lambda", "x", ":", "numpy", ".", "ones", "(", "(", "x", ",", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'unknown window function: %s'", "%", "str_winfunc", ")", "\n", "\n", "", "return", "winfunc", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.mfcc": [[261, 283], ["BaseException", "base_Jeroen.fbank", "numpy.log", "base_Jeroen.lifter", "scipy.fftpack.dct", "float", "numpy.log", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.lifter"], ["", "def", "mfcc", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute MFCC features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by numcep) containing features. Each\n        row holds 1 feature vector, a numpy vector containing the signal\n        log-energy\n    \"\"\"", "\n", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "feat", ",", "energy", "=", "fbank", "(", "signal", ",", "samplerate", ",", "conf", ")", "\n", "feat", "=", "numpy", ".", "log", "(", "feat", ")", "\n", "feat", "=", "dct", "(", "feat", ",", "type", "=", "2", ",", "axis", "=", "1", ",", "norm", "=", "'ortho'", ")", "[", ":", ",", ":", "int", "(", "conf", "[", "'numcep'", "]", ")", "]", "\n", "feat", "=", "lifter", "(", "feat", ",", "float", "(", "conf", "[", "'ceplifter'", "]", ")", ")", "\n", "return", "feat", ",", "numpy", ".", "log", "(", "energy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank": [[285, 326], ["BaseException", "int", "sigproc.preemphasis", "sigproc.framesig", "sigproc.powspec", "numpy.sum", "numpy.where", "base_Jeroen.get_filterbanks", "numpy.dot", "numpy.where", "float", "int", "int", "int", "int", "float", "float", "numpy.finfo", "numpy.finfo"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.get_filterbanks"], ["", "def", "fbank", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute fbank features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by nfilt) containing features, a numpy\n        vector containing the signal energy\n    \"\"\"", "\n", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "highfreq", "=", "int", "(", "conf", "[", "'highfreq'", "]", ")", "\n", "if", "highfreq", "<", "0", ":", "\n", "        ", "highfreq", "=", "samplerate", "/", "2", "\n", "\n", "", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ")", "\n", "pspec", "=", "sigproc", ".", "powspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "# this stores the total energy in each frame", "\n", "energy", "=", "numpy", ".", "sum", "(", "pspec", ",", "1", ")", "\n", "\n", "# if energy is zero, we get problems with log", "\n", "energy", "=", "numpy", ".", "where", "(", "energy", "==", "0", ",", "numpy", ".", "finfo", "(", "float", ")", ".", "eps", ",", "energy", ")", "\n", "\n", "filterbank", "=", "get_filterbanks", "(", "int", "(", "conf", "[", "'nfilt'", "]", ")", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ",", "\n", "samplerate", ",", "int", "(", "conf", "[", "'lowfreq'", "]", ")", ",", "highfreq", ")", "\n", "\n", "# compute the filterbank energies", "\n", "feat", "=", "numpy", ".", "dot", "(", "pspec", ",", "filterbank", ".", "T", ")", "\n", "\n", "# if feat is zero, we get problems with log", "\n", "feat", "=", "numpy", ".", "where", "(", "feat", "==", "0", ",", "numpy", ".", "finfo", "(", "float", ")", ".", "eps", ",", "feat", ")", "\n", "\n", "return", "feat", ",", "energy", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.logfbank": [[328, 345], ["BaseException", "base_Jeroen.fbank", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank"], ["", "def", "logfbank", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute log-fbank features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by nfilt) containing features, a numpy\n        vector containing the signal log-energy\n    \"\"\"", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "feat", ",", "energy", "=", "fbank", "(", "signal", ",", "samplerate", ",", "conf", ")", "\n", "return", "numpy", ".", "log", "(", "feat", ")", ",", "numpy", ".", "log", "(", "energy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.ssc": [[347, 386], ["BaseException", "int", "sigproc.preemphasis", "sigproc.framesig", "sigproc.powspec", "numpy.sum", "numpy.where", "base_Jeroen.get_filterbanks", "numpy.dot", "numpy.tile", "float", "int", "int", "int", "int", "numpy.linspace", "numpy.log", "float", "float", "numpy.finfo", "numpy.size", "numpy.size", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.get_filterbanks"], ["", "def", "ssc", "(", "signal", ",", "samplerate", ",", "conf", ")", ":", "\n", "    ", "\"\"\"\n    Compute ssc features from an audio signal.\n\n    Args:\n        signal: the audio signal from which to compute features. Should be an\n            N*1 array\n        samplerate: the samplerate of the signal we are working with.\n        conf: feature configuration\n\n    Returns:\n        A numpy array of size (NUMFRAMES by nfilt) containing features, a numpy\n        vector containing the signal log-energy\n    \"\"\"", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "\n", "highfreq", "=", "int", "(", "conf", "[", "'highfreq'", "]", ")", "\n", "if", "highfreq", "<", "0", ":", "\n", "        ", "highfreq", "=", "samplerate", "/", "2", "\n", "", "signal", "=", "sigproc", ".", "preemphasis", "(", "signal", ",", "float", "(", "conf", "[", "'preemph'", "]", ")", ")", "\n", "frames", "=", "sigproc", ".", "framesig", "(", "signal", ",", "float", "(", "conf", "[", "'winlen'", "]", ")", "*", "samplerate", ",", "\n", "float", "(", "conf", "[", "'winstep'", "]", ")", "*", "samplerate", ")", "\n", "pspec", "=", "sigproc", ".", "powspec", "(", "frames", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ")", "\n", "\n", "# this stores the total energy in each frame", "\n", "energy", "=", "numpy", ".", "sum", "(", "pspec", ",", "1", ")", "\n", "\n", "# if energy is zero, we get problems with log", "\n", "energy", "=", "numpy", ".", "where", "(", "energy", "==", "0", ",", "numpy", ".", "finfo", "(", "float", ")", ".", "eps", ",", "energy", ")", "\n", "\n", "filterbank", "=", "get_filterbanks", "(", "int", "(", "conf", "[", "'nfilt'", "]", ")", ",", "int", "(", "conf", "[", "'nfft'", "]", ")", ",", "\n", "samplerate", ",", "int", "(", "conf", "[", "'lowfreq'", "]", ")", ",", "highfreq", ")", "\n", "\n", "# compute the filterbank energies", "\n", "feat", "=", "numpy", ".", "dot", "(", "pspec", ",", "filterbank", ".", "T", ")", "\n", "tiles", "=", "numpy", ".", "tile", "(", "numpy", ".", "linspace", "(", "1", ",", "samplerate", "/", "2", ",", "numpy", ".", "size", "(", "pspec", ",", "1", ")", ")", ",", "\n", "(", "numpy", ".", "size", "(", "pspec", ",", "0", ")", ",", "1", ")", ")", "\n", "\n", "return", "numpy", ".", "dot", "(", "pspec", "*", "tiles", ",", "filterbank", ".", "T", ")", "/", "feat", ",", "numpy", ".", "log", "(", "energy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.hz2mel": [[388, 401], ["numpy.log10"], "function", ["None"], ["", "def", "hz2mel", "(", "rate", ")", ":", "\n", "    ", "\"\"\"\n    Convert a value in Hertz to Mels\n\n    Args:\n        rate: a value in Hz. This can also be a numpy array, conversion proceeds\n            element-wise.\n\n    Returns:\n        a value in Mels. If an array was passed in, an identical sized array is\n        returned.\n    \"\"\"", "\n", "return", "2595", "*", "numpy", ".", "log10", "(", "1", "+", "rate", "/", "700.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.mel2hz": [[403, 416], ["None"], "function", ["None"], ["", "def", "mel2hz", "(", "mel", ")", ":", "\n", "    ", "\"\"\"\n    Convert a value in Mels to Hertz\n\n    Args:\n        mel: a value in Mels. This can also be a numpy array, conversion\n            proceeds element-wise.\n\n    Returns:\n        a value in Hertz. If an array was passed in, an identical sized array is\n        returned.\n    \"\"\"", "\n", "return", "700", "*", "(", "10", "**", "(", "mel", "/", "2595.0", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.get_filterbanks": [[418, 459], ["BaseException", "base_Jeroen.hz2mel", "base_Jeroen.hz2mel", "numpy.linspace", "numpy.floor", "numpy.zeros", "xrange", "xrange", "xrange", "int", "int", "int", "int", "base_Jeroen.mel2hz"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.hz2mel", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.hz2mel", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.mel2hz"], ["", "def", "get_filterbanks", "(", "nfilt", "=", "20", ",", "nfft", "=", "512", ",", "samplerate", "=", "16000", ",", "lowfreq", "=", "0", ",", "\n", "highfreq", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute a Mel-filterbank.\n\n    The filters are stored in the rows, the columns correspond to fft bins.\n    The filters are returned as an array of size nfilt * (nfft/2 + 1)\n\n    Args:\n        nfilt: the number of filters in the filterbank, default 20.\n        nfft: the FFT size. Default is 512.\n        samplerate: the samplerate of the signal we are working with. Affects\n            mel spacing.\n        lowfreq: lowest band edge of mel filters, default 0 Hz\n        highfreq: highest band edge of mel filters, default samplerate/2\n\n    Returns:\n        A numpy array of size nfilt * (nfft/2 + 1) containing filterbank. Each\n        row holds 1 filter.\n    \"\"\"", "\n", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "highfreq", "=", "highfreq", "or", "samplerate", "/", "2", "\n", "assert", "highfreq", "<=", "samplerate", "/", "2", ",", "\"highfreq is greater than samplerate/2\"", "\n", "\n", "# compute points evenly spaced in mels", "\n", "lowmel", "=", "hz2mel", "(", "lowfreq", ")", "\n", "highmel", "=", "hz2mel", "(", "highfreq", ")", "\n", "melpoints", "=", "numpy", ".", "linspace", "(", "lowmel", ",", "highmel", ",", "nfilt", "+", "2", ")", "\n", "\n", "# our points are in Hz, but we use fft bins, so we have to convert", "\n", "#  from Hz to fft bin number", "\n", "bins", "=", "numpy", ".", "floor", "(", "(", "nfft", "+", "1", ")", "*", "mel2hz", "(", "melpoints", ")", "/", "samplerate", ")", "\n", "\n", "fbanks", "=", "numpy", ".", "zeros", "(", "[", "nfilt", ",", "nfft", "/", "2", "+", "1", "]", ")", "\n", "for", "j", "in", "xrange", "(", "0", ",", "nfilt", ")", ":", "\n", "        ", "for", "i", "in", "xrange", "(", "int", "(", "bins", "[", "j", "]", ")", ",", "int", "(", "bins", "[", "j", "+", "1", "]", ")", ")", ":", "\n", "            ", "fbanks", "[", "j", ",", "i", "]", "=", "(", "i", "-", "bins", "[", "j", "]", ")", "/", "(", "bins", "[", "j", "+", "1", "]", "-", "bins", "[", "j", "]", ")", "\n", "", "for", "i", "in", "xrange", "(", "int", "(", "bins", "[", "j", "+", "1", "]", ")", ",", "int", "(", "bins", "[", "j", "+", "2", "]", ")", ")", ":", "\n", "            ", "fbanks", "[", "j", ",", "i", "]", "=", "(", "bins", "[", "j", "+", "2", "]", "-", "i", ")", "/", "(", "bins", "[", "j", "+", "2", "]", "-", "bins", "[", "j", "+", "1", "]", ")", "\n", "", "", "return", "fbanks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.lifter": [[461, 484], ["BaseException", "numpy.shape", "numpy.sin", "numpy.arange"], "function", ["None"], ["", "def", "lifter", "(", "cepstra", ",", "liftering", "=", "22.0", ")", ":", "\n", "    ", "\"\"\"\n    Apply a cepstral lifter the the matrix of cepstra.\n\n    This has the effect of increasing the magnitude of the high frequency DCT\n    coeffs.\n\n    Args:\n        cepstra: the matrix of mel-cepstra, will be numframes * numcep in size.\n        liftering: the liftering coefficient to use. Default is 22. L <= 0\n            disables lifter.\n\n    Returns:\n        the lifted cepstra\n    \"\"\"", "\n", "raise", "BaseException", "(", "'Not yet implemented'", ")", "\n", "if", "liftering", ">", "0", ":", "\n", "        ", "_", ",", "ncoeff", "=", "numpy", ".", "shape", "(", "cepstra", ")", "\n", "lift", "=", "1", "+", "(", "liftering", "/", "2", ")", "*", "numpy", ".", "sin", "(", "numpy", ".", "pi", "*", "numpy", ".", "arange", "(", "ncoeff", ")", "/", "liftering", ")", "\n", "return", "lift", "*", "cepstra", "\n", "", "else", ":", "\n", "# values of liftering <= 0, do nothing", "\n", "        ", "return", "cepstra", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.deriv": [[486, 497], ["scipy.ndimage.convolve1d", "numpy.array"], "function", ["None"], ["", "", "def", "deriv", "(", "features", ")", ":", "\n", "    ", "\"\"\"\n    Compute the first order derivative of the features\n\n    Args:\n        features: the input features\n\n    Returns:\n        the firs order derivative\n    \"\"\"", "\n", "return", "convolve1d", "(", "features", ",", "numpy", ".", "array", "(", "[", "2", ",", "1", ",", "0", ",", "-", "1", ",", "-", "2", "]", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.delta": [[499, 510], ["numpy.concatenate", "base_Jeroen.deriv"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.deriv"], ["", "def", "delta", "(", "features", ")", ":", "\n", "    ", "\"\"\"\n    concatenate the first order derivative to the features\n\n    Args:\n        features: the input features\n\n    Returns:\n        the features concatenated with the first order derivative\n    \"\"\"", "\n", "return", "numpy", ".", "concatenate", "(", "(", "features", ",", "deriv", "(", "features", ")", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.ddelta": [[512, 524], ["base_Jeroen.deriv", "numpy.concatenate", "base_Jeroen.deriv"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.deriv", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.deriv"], ["", "def", "ddelta", "(", "features", ")", ":", "\n", "    ", "\"\"\"\n    concatenate the first and second order derivative to the features\n\n    Args:\n        features: the input features\n\n    Returns:\n        the features concatenated with the first and second order derivative\n    \"\"\"", "\n", "deltafeat", "=", "deriv", "(", "features", ")", "\n", "return", "numpy", ".", "concatenate", "(", "(", "features", ",", "deltafeat", ",", "deriv", "(", "deltafeat", ")", ")", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.magspec.Magspec.comp_feat": [[13, 41], ["sigproc.snip", "float", "float", "base.magspec_scipy", "base.magspec", "numpy.append", "base.fbank_scipy", "base.fbank"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.magspec_scipy", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.magspec", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "            ", "feat", "=", "base", ".", "magspec_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "            ", "feat", "=", "base", ".", "magspec", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "\n", "", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "                ", "_", ",", "energy", "=", "base", ".", "fbank_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "                ", "_", ",", "energy", "=", "base", ".", "fbank", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "feat", "=", "np", ".", "append", "(", "feat", ",", "energy", "[", ":", ",", "np", ".", "newaxis", "]", ",", "1", ")", "\n", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.magspec.Magspec.get_dim": [[42, 51], ["int"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "int", "(", "self", ".", "conf", "[", "'nfft'", "]", ")", "/", "2", "+", "1", "\n", "\n", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "dim", "+=", "1", "\n", "\n", "", "return", "dim", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.magspec.Powspec.comp_feat": [[56, 84], ["sigproc.snip", "float", "float", "base.powspec_scipy", "base.powspec", "numpy.append", "base.fbank_scipy", "base.fbank"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.powspec_scipy", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "            ", "feat", "=", "base", ".", "powspec_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "            ", "feat", "=", "base", ".", "powspec", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "\n", "", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "                ", "_", ",", "energy", "=", "base", ".", "fbank_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "                ", "_", ",", "energy", "=", "base", ".", "fbank", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "feat", "=", "np", ".", "append", "(", "feat", ",", "energy", "[", ":", ",", "np", ".", "newaxis", "]", ",", "1", ")", "\n", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.magspec.Powspec.get_dim": [[85, 94], ["int"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "int", "(", "self", ".", "conf", "[", "'nfft'", "]", ")", "/", "2", "+", "1", "\n", "\n", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "dim", "+=", "1", "\n", "\n", "", "return", "dim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.mfcc.Mfcc.comp_feat": [[13, 45], ["sigproc.snip", "float", "float", "base.mfcc_scipy", "base.mfcc", "numpy.append", "base.delta", "base.ddelta", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.mfcc", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.delta", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.ddelta"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "\n", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "            ", "feat", ",", "energy", "=", "base", ".", "mfcc_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "            ", "feat", ",", "energy", "=", "base", ".", "mfcc", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "\n", "", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "feat", "=", "np", ".", "append", "(", "feat", ",", "energy", "[", ":", ",", "np", ".", "newaxis", "]", ",", "1", ")", "\n", "\n", "", "if", "self", ".", "conf", "[", "'dynamic'", "]", "==", "'delta'", ":", "\n", "            ", "feat", "=", "base", ".", "delta", "(", "feat", ")", "\n", "", "elif", "self", ".", "conf", "[", "'dynamic'", "]", "==", "'ddelta'", ":", "\n", "            ", "feat", "=", "base", ".", "ddelta", "(", "feat", ")", "\n", "", "elif", "self", ".", "conf", "[", "'dynamic'", "]", "!=", "'nodelta'", ":", "\n", "            ", "raise", "Exception", "(", "'unknown dynamic type'", ")", "\n", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.mfcc.Mfcc.get_dim": [[46, 60], ["int"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "int", "(", "self", ".", "conf", "[", "'numcep'", "]", ")", "\n", "\n", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "dim", "+=", "1", "\n", "\n", "", "if", "self", ".", "conf", "[", "'dynamic'", "]", "==", "'delta'", ":", "\n", "            ", "dim", "*=", "2", "\n", "", "elif", "self", ".", "conf", "[", "'dynamic'", "]", "==", "'ddelta'", ":", "\n", "            ", "dim", "*=", "3", "\n", "\n", "", "return", "dim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.framesig": [[37, 72], ["len", "int", "int", "int", "numpy.zeros", "numpy.concatenate", "numpy.array", "numpy.tile", "numpy.ones", "round", "round", "numpy.tile", "winfunc", "int", "numpy.arange", "numpy.tile", "math.ceil", "numpy.arange"], "function", ["None"], ["def", "framesig", "(", "sig", ",", "frame_len", ",", "frame_step", ",", "winfunc", "=", "lambda", "x", ":", "numpy", ".", "ones", "(", "(", "x", ",", ")", ")", ")", ":", "\n", "    ", "'''\n    Frame a signal into overlapping frames.\n\n    Args:\n        sig: the audio signal to frame.\n        frame_len: length of each frame measured in samples.\n        frame_step: number of samples after the start of the previous frame that\n            the next frame should begin.\n        winfunc: the analysis window to apply to each frame. By default no\n            window function is applied.\n\n    Returns:\n        an array of frames. Size is NUMFRAMES by frame_len.\n    '''", "\n", "\n", "slen", "=", "len", "(", "sig", ")", "\n", "frame_len", "=", "int", "(", "round", "(", "frame_len", ")", ")", "\n", "frame_step", "=", "int", "(", "round", "(", "frame_step", ")", ")", "\n", "if", "slen", "<=", "frame_len", ":", "\n", "        ", "numframes", "=", "1", "\n", "", "else", ":", "\n", "        ", "numframes", "=", "1", "+", "int", "(", "math", ".", "ceil", "(", "(", "1.0", "*", "slen", "-", "frame_len", ")", "/", "frame_step", ")", ")", "\n", "\n", "", "padlen", "=", "int", "(", "(", "numframes", "-", "1", ")", "*", "frame_step", "+", "frame_len", ")", "\n", "\n", "zeros", "=", "numpy", ".", "zeros", "(", "(", "padlen", "-", "slen", ",", ")", ")", "\n", "padsignal", "=", "numpy", ".", "concatenate", "(", "(", "sig", ",", "zeros", ")", ")", "\n", "\n", "indices", "=", "(", "numpy", ".", "tile", "(", "numpy", ".", "arange", "(", "0", ",", "frame_len", ")", ",", "(", "numframes", ",", "1", ")", ")", "+", "\n", "numpy", ".", "tile", "(", "numpy", ".", "arange", "(", "0", ",", "numframes", "*", "frame_step", ",", "frame_step", ")", ",", "(", "frame_len", ",", "1", ")", ")", ".", "T", ")", "\n", "indices", "=", "numpy", ".", "array", "(", "indices", ",", "dtype", "=", "numpy", ".", "int32", ")", "\n", "frames", "=", "padsignal", "[", "indices", "]", "\n", "win", "=", "numpy", ".", "tile", "(", "winfunc", "(", "frame_len", ")", ",", "(", "numframes", ",", "1", ")", ")", "\n", "return", "frames", "*", "win", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.deframesig": [[73, 121], ["int", "int", "numpy.array", "numpy.zeros", "numpy.zeros", "winfunc", "range", "numpy.ones", "round", "round", "numpy.shape", "numpy.tile", "numpy.shape", "numpy.arange", "numpy.tile", "numpy.arange"], "function", ["None"], ["", "def", "deframesig", "(", "frames", ",", "siglen", ",", "frame_len", ",", "frame_step", ",", "\n", "winfunc", "=", "lambda", "x", ":", "numpy", ".", "ones", "(", "(", "x", ",", ")", ")", ")", ":", "\n", "    ", "'''\n    Does overlap-add procedure to undo the action of framesig.\n\n    Args:\n        frames the: array of frames.\n        siglen the: length of the desired signal, use 0 if unknown. Output will\n            be truncated to siglen samples.\n        frame_len: length of each frame measured in samples.\n        frame_step: number of samples after the start of the previous frame that\n            the next frame should begin.\n        winfunc: the analysis window to apply to each frame. By default no\n            window is applied.\n\n    Returns:\n        a 1-D signal.\n    '''", "\n", "\n", "frame_len", "=", "int", "(", "round", "(", "frame_len", ")", ")", "\n", "frame_step", "=", "int", "(", "round", "(", "frame_step", ")", ")", "\n", "numframes", "=", "numpy", ".", "shape", "(", "frames", ")", "[", "0", "]", "\n", "assert", "numpy", ".", "shape", "(", "frames", ")", "[", "1", "]", "==", "frame_len", ",", "'''\"frames\" matrix is wrong\n        size, 2nd dim is not equal to frame_len'''", "\n", "\n", "indices", "=", "(", "numpy", ".", "tile", "(", "numpy", ".", "arange", "(", "0", ",", "frame_len", ")", ",", "(", "numframes", ",", "1", ")", ")", "\n", "+", "numpy", ".", "tile", "(", "numpy", ".", "arange", "(", "0", ",", "numframes", "*", "frame_step", ",", "frame_step", ")", ",", "\n", "(", "frame_len", ",", "1", ")", ")", ".", "T", ")", "\n", "\n", "indices", "=", "numpy", ".", "array", "(", "indices", ",", "dtype", "=", "numpy", ".", "int32", ")", "\n", "padlen", "=", "(", "numframes", "-", "1", ")", "*", "frame_step", "+", "frame_len", "\n", "\n", "if", "siglen", "<=", "0", ":", "\n", "        ", "siglen", "=", "padlen", "\n", "\n", "", "rec_signal", "=", "numpy", ".", "zeros", "(", "(", "padlen", ",", ")", ")", "\n", "window_correction", "=", "numpy", ".", "zeros", "(", "(", "padlen", ",", ")", ")", "\n", "win", "=", "winfunc", "(", "frame_len", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "numframes", ")", ":", "\n", "#add a little bit so it is never zero", "\n", "        ", "window_correction", "[", "indices", "[", "i", ",", ":", "]", "]", "=", "(", "window_correction", "[", "indices", "[", "i", ",", ":", "]", "]", "\n", "+", "win", "+", "1e-15", ")", "\n", "\n", "rec_signal", "[", "indices", "[", "i", ",", ":", "]", "]", "=", "rec_signal", "[", "indices", "[", "i", ",", ":", "]", "]", "+", "frames", "[", "i", ",", ":", "]", "\n", "\n", "", "rec_signal", "=", "rec_signal", "/", "window_correction", "\n", "return", "rec_signal", "[", "0", ":", "siglen", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.spec": [[122, 140], ["numpy.fft.rfft"], "function", ["None"], ["", "def", "spec", "(", "frames", ",", "nfft", ")", ":", "\n", "    ", "'''\n    Compute the complex spectrum of each frame in frames.\n\n    If frames is an NxD matrix, output will be NxNFFT.\n\n    Args:\n        frames: the array of frames. Each row is a frame.\n        nfft: the FFT length to use. If NFFT > frame_len, the frames are\n            zero-padded.\n\n    Returns:\n        If frames is an NxD matrix, output will be NxNFFT. Each row will be the\n        complex spectrum of the corresponding frame.\n    '''", "\n", "\n", "complex_spec", "=", "numpy", ".", "fft", ".", "rfft", "(", "frames", ",", "nfft", ")", "\n", "return", "complex_spec", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.spec2frames": [[141, 155], ["numpy.fft.irfft"], "function", ["None"], ["", "def", "spec2frames", "(", "spec", ")", ":", "\n", "    ", "'''\n    The reverse of the spec function. Computes an array of\n    time domain frames from a complex spectrum via the ifft.\n\n    Args:\n        spec: the complex spectrogram. Each row is a frame.\n\n    Returns:\n        the array of frames. Each row is a frame.\n    '''", "\n", "\n", "frames", "=", "numpy", ".", "fft", ".", "irfft", "(", "spec", ")", "\n", "return", "frames", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.magspec": [[156, 174], ["numpy.fft.rfft", "numpy.absolute"], "function", ["None"], ["", "def", "magspec", "(", "frames", ",", "nfft", ")", ":", "\n", "    ", "'''\n    Compute the magnitude spectrum of each frame in frames.\n\n    If frames is an NxD matrix, output will be NxNFFT.\n\n    Args:\n        frames: the array of frames. Each row is a frame.\n        nfft: the FFT length to use. If NFFT > frame_len, the frames are\n            zero-padded.\n\n    Returns:\n        If frames is an NxD matrix, output will be NxNFFT. Each row will be the\n        magnitude spectrum of the corresponding frame.\n    '''", "\n", "\n", "complex_spec", "=", "numpy", ".", "fft", ".", "rfft", "(", "frames", ",", "nfft", ")", "\n", "return", "numpy", ".", "absolute", "(", "complex_spec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.angspec": [[175, 193], ["numpy.fft.rfft", "numpy.angle"], "function", ["None"], ["", "def", "angspec", "(", "frames", ",", "nfft", ")", ":", "\n", "    ", "'''\n    Compute the angular spectrum of each frame in frames.\n\n    If frames is an NxD matrix, output will be NxNFFT.\n\n    Args:\n        frames: the array of frames. Each row is a frame.\n        nfft: the FFT length to use. If NFFT > frame_len, the frames are\n            zero-padded.\n\n    Returns:\n        If frames is an NxD matrix, output will be NxNFFT. Each row will be the\n        magnitude spectrum of the corresponding frame.\n    '''", "\n", "\n", "complex_spec", "=", "numpy", ".", "fft", ".", "rfft", "(", "frames", ",", "nfft", ")", "\n", "return", "numpy", ".", "angle", "(", "complex_spec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.logmagspec": [[194, 218], ["sigproc.magspec", "numpy.log10", "numpy.max"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.magspec"], ["", "def", "logmagspec", "(", "frames", ",", "nfft", ",", "norm", "=", "False", ")", ":", "\n", "    ", "'''\n    Compute the log magnitude spectrum of each frame in frames.\n\n    If frames is an NxD matrix, output will be NxNFFT.\n\n    Args:\n        frames: the array of frames. Each row is a frame.\n        nfft: the FFT length to use. If NFFT > frame_len, the frames are\n            zero-padded.\n        norm: If norm=True, the log power spectrum is normalised so that the max\n            value (across all frames) is 1.\n\n    Returns:\n        If frames is an NxD matrix, output will be NxNFFT. Each row will be the\n        log magnitude spectrum of the corresponding frame.\n    '''", "\n", "ms", "=", "magspec", "(", "frames", ",", "nfft", ")", "\n", "ms", "[", "ms", "<=", "1e-30", "]", "=", "1e-30", "\n", "lms", "=", "10", "*", "numpy", ".", "log10", "(", "ms", ")", "\n", "if", "norm", ":", "\n", "        ", "return", "lms", "-", "numpy", ".", "max", "(", "lms", ")", "\n", "", "else", ":", "\n", "        ", "return", "lms", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec": [[219, 235], ["numpy.square", "sigproc.magspec"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.magspec"], ["", "", "def", "powspec", "(", "frames", ",", "nfft", ")", ":", "\n", "    ", "'''\n    Compute the power spectrum of each frame in frames.\n\n    If frames is an NxD matrix, output will be NxNFFT.\n\n    Args:\n        frames: the array of frames. Each row is a frame.\n        nfft: the FFT length to use. If NFFT > frame_len, the frames are\n            zero-padded.\n\n    Returns:\n        If frames is an NxD matrix, output will be NxNFFT. Each row will be the\n        power spectrum of the corresponding frame.\n    '''", "\n", "return", "1.0", "/", "nfft", "*", "numpy", ".", "square", "(", "magspec", "(", "frames", ",", "nfft", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.logpowspec": [[236, 260], ["sigproc.powspec", "numpy.log10", "numpy.max"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.powspec"], ["", "def", "logpowspec", "(", "frames", ",", "nfft", ",", "norm", "=", "1", ")", ":", "\n", "    ", "'''\n    Compute the log power spectrum of each frame in frames.\n\n    If frames is an NxD matrix, output will be NxNFFT.\n\n    Args:\n        frames: the array of frames. Each row is a frame.\n        nfft: the FFT length to use. If NFFT > frame_len, the frames are\n            zero-padded.\n        norm: If norm=1, the log power spectrum is normalised so that the max\n            value (across all frames) is 1.\n\n    Returns:\n        If frames is an NxD matrix, output will be NxNFFT. Each row will be the\n        log power spectrum of the corresponding frame.\n    '''", "\n", "ps", "=", "powspec", "(", "frames", ",", "nfft", ")", "\n", "ps", "[", "ps", "<=", "1e-30", "]", "=", "1e-30", "\n", "lps", "=", "10", "*", "numpy", ".", "log10", "(", "ps", ")", "\n", "if", "norm", ":", "\n", "        ", "return", "lps", "-", "numpy", ".", "max", "(", "lps", ")", "\n", "", "else", ":", "\n", "        ", "return", "lps", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.preemphasis": [[261, 273], ["numpy.append"], "function", ["None"], ["", "", "def", "preemphasis", "(", "signal", ",", "coeff", "=", "0.95", ")", ":", "\n", "    ", "'''\n    perform preemphasis on the input signal.\n\n    Args:\n        signal: The signal to filter.\n        coeff: The preemphasis coefficient. 0 is no filter, default is 0.95.\n\n    Returns:\n        the filtered signal.\n    '''", "\n", "return", "numpy", ".", "append", "(", "signal", "[", "0", "]", ",", "signal", "[", "1", ":", "]", "-", "coeff", "*", "signal", "[", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip": [[274, 294], ["int", "int", "len", "round"], "function", ["None"], ["", "def", "snip", "(", "sig", ",", "rate", ",", "winlen", ",", "winstep", ")", ":", "\n", "    ", "'''\n    snip the edges of the utterance to fit the sliding window\n\n    Args:\n        sig: audio signal\n        rate: sampling rate\n        winlen: length of the sliding window [s]\n        winstep: stepsize of the sliding window [s]\n\n    Returns:\n        the snipped signal\n    '''", "\n", "# calculate the number of frames in the utterance as number of samples in", "\n", "#the utterance / number of samples in the frame", "\n", "num_frames", "=", "int", "(", "(", "len", "(", "sig", ")", "-", "winlen", "*", "rate", ")", "/", "(", "winstep", "*", "rate", ")", ")", "\n", "# cut of the edges to fit the number of frames", "\n", "sig", "=", "sig", "[", "0", ":", "int", "(", "round", "(", "num_frames", "*", "winstep", "*", "rate", "+", "winlen", "*", "rate", ")", ")", "]", "\n", "\n", "return", "sig", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.feature_computer.FeatureComputer.__init__": [[12, 21], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", ")", ":", "\n", "        ", "\"\"\"\n        FeatureComputer constructor\n\n        Args:\n            conf: the feature configuration\n        \"\"\"", "\n", "\n", "self", ".", "conf", "=", "conf", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.feature_computer.FeatureComputer.__call__": [[22, 37], ["feature_computer.FeatureComputer.comp_feat"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.comp_feat"], ["", "def", "__call__", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# compute the features and energy", "\n", "feat", "=", "self", ".", "comp_feat", "(", "sig", ",", "rate", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.feature_computer.FeatureComputer.comp_feat": [[38, 50], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.feature_computer.FeatureComputer.get_dim": [[51, 54], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.fbank.Fbank.comp_feat": [[13, 45], ["sigproc.snip", "float", "float", "base.logfbank_scipy", "base.logfbank", "numpy.append", "base.delta", "base.ddelta", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.logfbank", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.delta", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.ddelta"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "\n", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "            ", "feat", ",", "energy", "=", "base", ".", "logfbank_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "            ", "feat", ",", "energy", "=", "base", ".", "logfbank", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "\n", "", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "feat", "=", "np", ".", "append", "(", "feat", ",", "energy", "[", ":", ",", "np", ".", "newaxis", "]", ",", "1", ")", "\n", "\n", "", "if", "self", ".", "conf", "[", "'dynamic'", "]", "==", "'delta'", ":", "\n", "            ", "feat", "=", "base", ".", "delta", "(", "feat", ")", "\n", "", "elif", "self", ".", "conf", "[", "'dynamic'", "]", "==", "'ddelta'", ":", "\n", "            ", "feat", "=", "base", ".", "ddelta", "(", "feat", ")", "\n", "", "elif", "self", ".", "conf", "[", "'dynamic'", "]", "!=", "'nodelta'", ":", "\n", "            ", "raise", "Exception", "(", "'unknown dynamic type'", ")", "\n", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.fbank.Fbank.get_dim": [[46, 60], ["int"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "int", "(", "self", ".", "conf", "[", "'nfilt'", "]", ")", "\n", "\n", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "dim", "+=", "1", "\n", "\n", "", "if", "self", ".", "conf", "[", "'dynamic'", "]", "==", "'delta'", ":", "\n", "            ", "dim", "*=", "2", "\n", "", "elif", "self", ".", "conf", "[", "'dynamic'", "]", "==", "'ddelta'", ":", "\n", "            ", "dim", "*=", "3", "\n", "\n", "", "return", "dim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.logspec.Logspec.comp_feat": [[13, 41], ["sigproc.snip", "float", "float", "base.logspec_scipy", "base.logspec", "numpy.append", "base.fbank_scipy", "base.fbank"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.logspec_scipy", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.logspec", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.fbank"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n        sig: the audio signal as a 1-D numpy array\n        rate: the sampling rate\n\n        Returns:\n        the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "            ", "feat", "=", "base", ".", "logspec_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "            ", "feat", "=", "base", ".", "logspec", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "\n", "", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "                ", "_", ",", "energy", "=", "base", ".", "fbank_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "                ", "_", ",", "energy", "=", "base", ".", "fbank", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "feat", "=", "np", ".", "append", "(", "feat", ",", "energy", "[", ":", ",", "np", ".", "newaxis", "]", ",", "1", ")", "\n", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.logspec.Logspec.get_dim": [[42, 51], ["int"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "int", "(", "self", ".", "conf", "[", "'nfft'", "]", ")", "/", "2", "+", "1", "\n", "\n", "if", "self", ".", "conf", "[", "'include_energy'", "]", "==", "'True'", ":", "\n", "            ", "dim", "+=", "1", "\n", "\n", "", "return", "dim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.raw.Raw.comp_feat": [[13, 32], ["sigproc.snip", "base.raw", "float", "float"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.raw"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "\n", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "feat", "=", "base", ".", "raw", "(", "sig", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.raw.Raw.get_dim": [[33, 39], ["None"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "None", "\n", "\n", "return", "dim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.spec.Spec.comp_feat": [[13, 35], ["sigproc.snip", "float", "float", "base.spec_scipy", "base.spec"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base.spec_scipy", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.spec"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "\n", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "            ", "feat", "=", "base", ".", "spec_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "            ", "feat", "=", "base", ".", "spec", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.spec.Spec.get_dim": [[36, 42], ["int"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "int", "(", "self", ".", "conf", "[", "'nfft'", "]", ")", "/", "2", "+", "1", "\n", "\n", "return", "dim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.comp_feat": [[13, 35], ["sigproc.snip", "float", "float", "base.frames_scipy", "base.frames"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.sigproc.snip", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.base_Jeroen.frames"], ["def", "comp_feat", "(", "self", ",", "sig", ",", "rate", ")", ":", "\n", "        ", "\"\"\"\n        compute the features\n\n        Args:\n            sig: the audio signal as a 1-D numpy array\n            rate: the sampling rate\n\n        Returns:\n            the features as a [seq_length x feature_dim] numpy array\n        \"\"\"", "\n", "\n", "# snip the edges", "\n", "sig", "=", "snip", "(", "sig", ",", "rate", ",", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ",", "\n", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "\n", "if", "'scipy'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'scipy'", "]", "==", "'True'", ":", "\n", "            ", "feat", "=", "base", ".", "frames_scipy", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "", "else", ":", "\n", "            ", "feat", "=", "base", ".", "frames", "(", "sig", ",", "rate", ",", "self", ".", "conf", ")", "\n", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim": [[36, 42], ["int"], "methods", ["None"], ["", "def", "get_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"the feature dimemsion\"\"\"", "\n", "\n", "dim", "=", "int", "(", "self", ".", "conf", "[", "'l'", "]", ")", "\n", "\n", "return", "dim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter_factory.factory": [[7, 26], ["Exception"], "function", ["None"], ["def", "factory", "(", "writer_style", ")", ":", "\n", "    ", "'''\n    Args:\n        writer_style: the way the data should be written\n\n    Returns:\n        a tfwriter class\n    '''", "\n", "\n", "if", "writer_style", "==", "'numpy_float_array_as_tfrecord'", ":", "\n", "        ", "return", "numpy_float_array_as_tfrecord_writer", ".", "NumpyFloatArrayAsTfrecordWriter", "\n", "", "elif", "writer_style", "==", "'numpy_bool_array_as_tfrecord'", ":", "\n", "        ", "return", "numpy_bool_array_as_tfrecord_writer", ".", "NumpyBoolArrayAsTfrecordWriter", "\n", "", "elif", "writer_style", "==", "'index_list_as_tfrecord'", ":", "\n", "        ", "return", "index_list_as_tfrecord_writer", ".", "IndexListAsTfrecordWriter", "\n", "", "elif", "writer_style", "==", "'float_list_as_tfrecord'", ":", "\n", "        ", "return", "float_list_as_tfrecord_writer", ".", "FloatListAsTfrecordWriter", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'unknown writer style: %s'", "%", "writer_style", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.numpy_float_array_as_tfrecord_writer.NumpyFloatArrayAsTfrecordWriter._get_example": [[12, 29], ["tensorflow.train.Feature", "tensorflow.train.Feature", "tensorflow.train.Example", "tensorflow.train.BytesList", "tensorflow.train.BytesList", "tensorflow.train.Features", "numpy.array().tostring", "data.reshape().astype().tostring", "numpy.array", "data.reshape().astype", "data.astype", "data.reshape"], "methods", ["None"], ["def", "_get_example", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"write data to a file\n\n        Args:\n            data: the data to be written\"\"\"", "\n", "\n", "shape_feature", "=", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "\n", "value", "=", "[", "np", ".", "array", "(", "data", ".", "astype", "(", "np", ".", "int32", ")", ".", "shape", ")", ".", "tostring", "(", ")", "]", ")", ")", "\n", "data_feature", "=", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "\n", "value", "=", "[", "data", ".", "reshape", "(", "[", "-", "1", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", ".", "tostring", "(", ")", "]", ")", ")", "\n", "\n", "# create the example proto", "\n", "example", "=", "tf", ".", "train", ".", "Example", "(", "features", "=", "tf", ".", "train", ".", "Features", "(", "feature", "=", "{", "\n", "'shape'", ":", "shape_feature", ",", "\n", "'data'", ":", "data_feature", "}", ")", ")", "\n", "\n", "return", "example", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.float_list_as_tfrecord_writer.FloatListAsTfrecordWriter._get_example": [[11, 29], ["tensorflow.train.Feature", "tensorflow.train.Feature", "tensorflow.train.Example", "tensorflow.train.BytesList", "tensorflow.train.BytesList", "tensorflow.train.Features", "numpy.array().tostring", "numpy.array().astype().tostring", "numpy.array", "numpy.array().astype", "numpy.array().astype", "numpy.array", "numpy.array"], "methods", ["None"], ["def", "_get_example", "(", "self", ",", "data", ")", ":", "\n", "        ", "'''write data to a file\n\n        Args:\n            data: the data to be written'''", "\n", "\n", "shape_feature", "=", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "\n", "value", "=", "[", "np", ".", "array", "(", "np", ".", "array", "(", "data", ")", ".", "astype", "(", "np", ".", "int32", ")", ".", "shape", ")", ".", "tostring", "(", ")", "]", ")", ")", "\n", "data_feature", "=", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "\n", "value", "=", "[", "np", ".", "array", "(", "data", ")", ".", "astype", "(", "np", ".", "float32", ")", ".", "tostring", "(", ")", "]", ")", ")", "\n", "\n", "\n", "#create the example proto", "\n", "example", "=", "tf", ".", "train", ".", "Example", "(", "features", "=", "tf", ".", "train", ".", "Features", "(", "feature", "=", "{", "\n", "'shape'", ":", "shape_feature", ",", "\n", "'data'", ":", "data_feature", "}", ")", ")", "\n", "\n", "return", "example", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.index_list_as_tfrecord_writer.IndexListAsTfrecordWriter._get_example": [[11, 29], ["tensorflow.train.Feature", "tensorflow.train.Feature", "tensorflow.train.Example", "tensorflow.train.BytesList", "tensorflow.train.BytesList", "tensorflow.train.Features", "numpy.array().tostring", "numpy.array().astype().tostring", "numpy.array", "numpy.array().astype", "numpy.array().astype", "numpy.array", "numpy.array"], "methods", ["None"], ["def", "_get_example", "(", "self", ",", "data", ")", ":", "\n", "        ", "'''write data to a file\n\n        Args:\n            data: the data to be written'''", "\n", "\n", "shape_feature", "=", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "\n", "value", "=", "[", "np", ".", "array", "(", "np", ".", "array", "(", "data", ")", ".", "astype", "(", "np", ".", "int32", ")", ".", "shape", ")", ".", "tostring", "(", ")", "]", ")", ")", "\n", "data_feature", "=", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "\n", "value", "=", "[", "np", ".", "array", "(", "data", ")", ".", "astype", "(", "np", ".", "int32", ")", ".", "tostring", "(", ")", "]", ")", ")", "\n", "\n", "\n", "#create the example proto", "\n", "example", "=", "tf", ".", "train", ".", "Example", "(", "features", "=", "tf", ".", "train", ".", "Features", "(", "feature", "=", "{", "\n", "'shape'", ":", "shape_feature", ",", "\n", "'data'", ":", "data_feature", "}", ")", ")", "\n", "\n", "return", "example", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.numpy_bool_array_as_tfrecord_writer.NumpyBoolArrayAsTfrecordWriter._get_example": [[11, 29], ["tensorflow.train.Feature", "tensorflow.train.Feature", "tensorflow.train.Example", "tensorflow.train.BytesList", "tensorflow.train.BytesList", "tensorflow.train.Features", "numpy.array().tostring", "data.reshape().astype().tostring", "numpy.array", "data.reshape().astype", "data.astype", "data.reshape"], "methods", ["None"], ["def", "_get_example", "(", "self", ",", "data", ")", ":", "\n", "        ", "'''write data to a file\n\n        Args:\n            data: the data to be written'''", "\n", "\n", "shape_feature", "=", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "\n", "value", "=", "[", "np", ".", "array", "(", "data", ".", "astype", "(", "np", ".", "int32", ")", ".", "shape", ")", ".", "tostring", "(", ")", "]", ")", ")", "\n", "data_feature", "=", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "\n", "value", "=", "[", "data", ".", "reshape", "(", "[", "-", "1", "]", ")", ".", "astype", "(", "np", ".", "bool", ")", ".", "tostring", "(", ")", "]", ")", ")", "\n", "\n", "\n", "#create the example proto", "\n", "example", "=", "tf", ".", "train", ".", "Example", "(", "features", "=", "tf", ".", "train", ".", "Features", "(", "feature", "=", "{", "\n", "'shape'", ":", "shape_feature", ",", "\n", "'data'", ":", "data_feature", "}", ")", ")", "\n", "\n", "return", "example", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.__init__": [[14, 36], ["os.path.join", "os.path.join", "os.path.exists", "os.makedirs", "os.makedirs"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "datadir", ",", "start_ind", "=", "0", ")", ":", "\n", "        ", "\"\"\"TfWriter constructor\n\n        Args:\n            datadir: the directory where the data will be written\n            start_ind: set the starting file number\n        \"\"\"", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "datadir", ")", ":", "\n", "# if the directory does not exist create it", "\n", "            ", "os", ".", "makedirs", "(", "datadir", ")", "\n", "\n", "# store the path to the scp file", "\n", "", "self", ".", "scp_file", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "'pointers.scp'", ")", "\n", "\n", "# set the current file number to start_ind", "\n", "self", ".", "filenum", "=", "start_ind", "\n", "\n", "# store te path to the write directory", "\n", "self", ".", "write_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "'data'", ")", "\n", "if", "self", ".", "filenum", "==", "0", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "write_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write": [[37, 59], ["tfwriter.TfWriter._get_example", "os.path.join", "tensorflow.python_io.TFRecordWriter", "tensorflow.python_io.TFRecordWriter.write", "tensorflow.python_io.TFRecordWriter.close", "tfwriter.TfWriter.SerializeToString", "open", "fid.write"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter._get_example", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "", "def", "write", "(", "self", ",", "data", ",", "name", ")", ":", "\n", "        ", "\"\"\"write data to a file\n\n        Args:\n            data: the data to be written\n            name: the name of the data\"\"\"", "\n", "\n", "# creater the example", "\n", "example", "=", "self", ".", "_get_example", "(", "data", ")", "\n", "\n", "# the filename for this example", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "write_dir", ",", "'file%d'", "%", "self", ".", "filenum", ")", "\n", "self", ".", "filenum", "+=", "1", "\n", "\n", "# write the example to file", "\n", "writer", "=", "tf", ".", "python_io", ".", "TFRecordWriter", "(", "filename", ")", "\n", "writer", ".", "write", "(", "example", ".", "SerializeToString", "(", ")", ")", "\n", "writer", ".", "close", "(", ")", "\n", "\n", "# put a pointer in the scp file", "\n", "with", "open", "(", "self", ".", "scp_file", ",", "'a'", ")", "as", "fid", ":", "\n", "            ", "fid", ".", "write", "(", "'%s\\t%s\\n'", "%", "(", "name", ",", "filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter._get_example": [[60, 66], ["None"], "methods", ["None"], ["", "", "@", "abstractmethod", "\n", "def", "_get_example", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"write data to a file\n\n        Args:\n            data: the data to be written\"\"\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader.TfReader.__init__": [[12, 28], ["tfreader.TfReader._read_metadata", "tfreader.TfReader._create_features", "tensorflow.TFRecordReader"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader.TfReader._read_metadata", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader.TfReader._create_features"], ["def", "__init__", "(", "self", ",", "datadirs", ")", ":", "\n", "        ", "'''TfReader constructor\n\n        Args:\n            datadirs: the directories where the metadata was stored as a list\n                of strings\n        '''", "\n", "\n", "#read the metadata", "\n", "self", ".", "metadata", "=", "self", ".", "_read_metadata", "(", "datadirs", ")", "\n", "\n", "#create the features object", "\n", "self", ".", "features", "=", "self", ".", "_create_features", "(", ")", "\n", "\n", "#create a reader", "\n", "self", ".", "reader", "=", "tf", ".", "TFRecordReader", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader.TfReader.__call__": [[30, 55], ["tensorflow.name_scope", "tfreader.TfReader.reader.read", "tensorflow.parse_single_example", "tfreader.TfReader._process_features", "type"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader.TfReader._process_features"], ["", "def", "__call__", "(", "self", ",", "queue", ",", "name", "=", "None", ")", ":", "\n", "        ", "'''read all data from the queue\n\n        Args:\n            queue: a queue containing filenames of tf record files\n            name: the name of the operation\n\n        Returns:\n            a pair of tensor and sequence length\n        '''", "\n", "with", "tf", ".", "name_scope", "(", "name", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "#read all the elements in the queue", "\n", "            ", "_", ",", "serialized", "=", "self", ".", "reader", ".", "read", "(", "queue", ")", "\n", "\n", "#parse the serialized strings into features", "\n", "features", "=", "tf", ".", "parse_single_example", "(", "serialized", ",", "self", ".", "features", ")", "\n", "\n", "#data_name = tf.parse_single_example(data_name_serialized,{'data_name': tf.VarLenFeature(dtype=tf.string)})", "\n", "#data_name = data_name['data_name']", "\n", "\n", "#process the parsed features", "\n", "processed", "=", "self", ".", "_process_features", "(", "features", ")", "\n", "\n", "", "return", "processed", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader.TfReader._read_metadata": [[56, 67], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_read_metadata", "(", "self", ",", "datadirs", ")", ":", "\n", "        ", "'''read the metadata for the reader (writen by the processor)\n\n            Args:\n                datadirs: the directories where the metadata was stored as a\n                    list of strings\n\n            Returns:\n                the metadata as a dictionary\n        '''", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader.TfReader._create_features": [[68, 77], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_create_features", "(", "self", ")", ":", "\n", "        ", "'''\n            creates the information about the features\n\n            Returns:\n                A dict mapping feature keys to FixedLenFeature, VarLenFeature,\n                and SparseFeature values\n        '''", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader.TfReader._process_features": [[78, 88], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_process_features", "(", "self", ",", "features", ")", ":", "\n", "        ", "'''process the read features\n\n        features:\n            A dict mapping feature keys to Tensor and SparseTensor values\n\n        Returns:\n            a pair of tensor and sequence length\n        '''", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfreaders.tfreader_factory.factory": [[7, 27], ["Exception"], "function", ["None"], ["def", "factory", "(", "writer_style", ")", ":", "\n", "    ", "'''factory for tfreaders\n\n    Args:\n        writer_style: the way the data was written\n\n    Returns:\n        a tfreader class\n    '''", "\n", "\n", "if", "writer_style", "==", "'numpy_float_array_as_tfrecord'", ":", "\n", "        ", "return", "numpy_float_array_as_tfrecord_reader", ".", "NumpyFloatArrayAsTfrecordReader", "\n", "", "elif", "writer_style", "==", "'numpy_bool_array_as_tfrecord'", ":", "\n", "        ", "return", "numpy_bool_array_as_tfrecord_reader", ".", "NumpyBoolArrayAsTfrecordReader", "\n", "", "elif", "writer_style", "==", "'index_list_as_tfrecord'", ":", "\n", "        ", "return", "index_list_as_tfrecord_reader", ".", "IndexListAsTfrecordReader", "\n", "", "elif", "writer_style", "==", "'float_list_as_tfrecord'", ":", "\n", "        ", "return", "float_list_as_tfrecord_reader", ".", "FloatListAsTfrecordReader", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'unknown writer style: %s'", "%", "writer_style", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.spatial_feat_processor.SpatialFeatProcessor.__init__": [[18, 43], ["conf[].split", "numpy.zeros", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory", "map", "len", "len", "pair.split", "spatial_feat_processor.SpatialFeatProcessor.comp.get_dim"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"AudioFeatProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: SpatialFeatProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments. \n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "# the channel pairs for which to compute the spatial features", "\n", "channel_pairs", "=", "conf", "[", "'channels_pairs'", "]", ".", "split", "(", "' '", ")", "\n", "channel_pairs", "=", "[", "map", "(", "int", ",", "pair", ".", "split", "(", "'-'", ")", ")", "for", "pair", "in", "channel_pairs", "]", "\n", "self", ".", "channel_pairs", "=", "[", "[", "ch", "-", "1", "for", "ch", "in", "pair", "]", "for", "pair", "in", "channel_pairs", "]", "# python index starts at 0", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "*", "2", "*", "len", "(", "channel_pairs", ")", "\n", "self", ".", "max_length", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "segment_lengths", ")", ")", "\n", "# self.sequence_length_histogram = np.zeros(0, dtype=np.int32)", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "SpatialFeatProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.spatial_feat_processor.SpatialFeatProcessor.__call__": [[44, 87], ["dict", "dataline.strip().split", "numpy.concatenate", "spatial_feat_processor.SpatialFeatProcessor.segment_data", "enumerate", "spatial_feat_processor._read_wav", "spatial_feat_processor.SpatialFeatProcessor.comp", "spatial_feat_processor._read_wav", "spatial_feat_processor.SpatialFeatProcessor.comp", "numpy.cos", "numpy.sin", "numpy.concatenate", "numpy.concatenate.append", "max", "dataline.strip", "numpy.shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented features as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "spatial_feats", "=", "[", "]", "\n", "for", "ch_pair", "in", "self", ".", "channel_pairs", ":", "\n", "\t\t\t", "datalines", "=", "[", "splitdatalines", "[", "ch", "]", "for", "ch", "in", "ch_pair", "]", "\n", "\n", "# read the wav file and compute the features", "\n", "rate1", ",", "utt1", "=", "_read_wav", "(", "datalines", "[", "0", "]", ")", "\n", "angs_spec_1", "=", "self", ".", "comp", "(", "utt1", ",", "rate1", ")", "\n", "\n", "# read the wav file and compute the features", "\n", "rate2", ",", "utt2", "=", "_read_wav", "(", "datalines", "[", "1", "]", ")", "\n", "angs_spec_2", "=", "self", ".", "comp", "(", "utt2", ",", "rate2", ")", "\n", "\n", "ang_diff", "=", "angs_spec_1", "-", "angs_spec_2", "\n", "cos_ipd", "=", "np", ".", "cos", "(", "ang_diff", ")", "\n", "sin_ipd", "=", "np", ".", "sin", "(", "ang_diff", ")", "\n", "spatial_feat", "=", "np", ".", "concatenate", "(", "[", "cos_ipd", ",", "sin_ipd", "]", ",", "axis", "=", "1", ")", "\n", "\n", "spatial_feats", ".", "append", "(", "spatial_feat", ")", "\n", "\n", "", "spatial_feats", "=", "np", ".", "concatenate", "(", "spatial_feats", ",", "axis", "=", "1", ")", "\n", "\n", "# split the data for all desired segment lengths", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "spatial_feats", ")", "\n", "\n", "# update the metadata", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "self", ".", "max_length", "[", "i", "]", "=", "max", "(", "self", ".", "max_length", "[", "i", "]", ",", "np", ".", "shape", "(", "segmented_data", "[", "seg_length", "]", "[", "0", "]", ")", "[", "0", "]", ")", "\n", "\n", "", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.spatial_feat_processor.SpatialFeatProcessor.write_metadata": [[88, 104], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "# with open(os.path.join(seg_dir, 'sequence_length_histogram.npy'), 'w') as fid:", "\n", "# np.save(fid, self.sequence_length_histogram[i])", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'max_length'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "max_length", "[", "i", "]", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.spatial_feat_processor._read_wav": [[106, 140], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "spatial_feat_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_multimic_processor.MultiTargetMultimicProcessor.__init__": [[17, 38], ["multi_target_multimic_processor.MultiTargetMultimicProcessor.comp.get_dim", "int", "int", "multi_target_multimic_processor.MultiTargetMultimicProcessor.comp.get_dim", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"MultiTargetMultimicProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: MultiTargetProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "# initialize the metadata", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "self", ".", "nr_channels", "=", "int", "(", "conf", "[", "'nr_channels'", "]", ")", "\n", "self", ".", "target_dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "target_dim", ",", "self", ".", "nrS", "]", "\n", "\n", "super", "(", "MultiTargetMultimicProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_multimic_processor.MultiTargetMultimicProcessor.__call__": [[39, 85], ["dict", "dataline.strip().split", "range", "multi_target_multimic_processor.MultiTargetMultimicProcessor.segment_data", "range", "splitdatalines_per_spk.append", "numpy.mean", "dataline.strip", "multi_target_multimic_processor._read_wav", "multi_target_multimic_processor.MultiTargetMultimicProcessor.comp", "numpy.expand_dims", "numpy.append", "numpy.append"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented targets as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "splitdatalines_per_spk", "=", "[", "]", "\n", "for", "spk_ind", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t", "inds", "=", "range", "(", "spk_ind", "*", "self", ".", "nr_channels", ",", "(", "spk_ind", "+", "1", ")", "*", "self", ".", "nr_channels", ")", "\n", "splitdatalines_per_spk", ".", "append", "(", "[", "splitdatalines", "[", "ind", "]", "for", "ind", "in", "inds", "]", ")", "\n", "\n", "", "targets", "=", "None", "\n", "for", "splitdatalines", "in", "splitdatalines_per_spk", ":", "\n", "\t\t\t", "targets_spk", "=", "None", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "# read the wav file", "\n", "\t\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "features", "=", "np", ".", "expand_dims", "(", "features", ",", "2", ")", "\n", "\n", "if", "targets_spk", "is", "None", ":", "\n", "\t\t\t\t\t", "targets_spk", "=", "features", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "targets_spk", "=", "np", ".", "append", "(", "targets_spk", ",", "features", ",", "2", ")", "\n", "\n", "", "", "targets_averaged", "=", "np", ".", "mean", "(", "targets_spk", ",", "2", ",", "keepdims", "=", "True", ")", "\n", "\n", "if", "targets", "is", "None", ":", "\n", "\t\t\t\t", "targets", "=", "targets_averaged", "\n", "", "else", ":", "\n", "\t\t\t\t", "targets", "=", "np", ".", "append", "(", "targets", ",", "targets_averaged", ",", "2", ")", "\n", "\n", "# split the data for all desired segment lengths", "\n", "", "", "segmented_data", "=", "self", ".", "segment_data", "(", "targets", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_multimic_processor.MultiTargetMultimicProcessor.write_metadata": [[86, 100], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nrS'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nrS", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "target_dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_multimic_processor._read_wav": [[102, 136], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "multi_target_multimic_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.processor.Processor.__init__": [[13, 21], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", ")", ":", "\n", "\t\t", "\"\"\"Processor constructor\n\n\t\tArgs:\n\t\t\tconf: processor configuration as a dictionary of strings\n\t\t\"\"\"", "\n", "\n", "self", ".", "conf", "=", "conf", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.processor.Processor.__call__": [[22, 30], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: a string, can be a line of text a pointer to a file etc.\n\n\t\tReturns:\n\t\t\tThe processed data\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.processor.Processor.segment_data": [[31, 81], ["dict", "numpy.shape", "int", "int", "int", "numpy.floor", "range", "numpy.floor", "range", "numpy.concatenate", "range", "seg_data.append", "numpy.concatenate", "range", "seg_data.append", "float", "float", "numpy.take", "float", "float", "numpy.take", "numpy.zeros", "numpy.zeros", "list", "numpy.shape"], "methods", ["None"], ["", "def", "segment_data", "(", "self", ",", "data", ",", "time_dim", "=", "0", ",", "winlen_sample", "=", "None", ",", "winstep_sample", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"split the data into segments for all desired segment lengths\n\n\t\tArgs:\n\t\t\tdata: the data to be split in numpy format. [... x time_steps x ...]\n\t\t\ttime_dim: the dimension to segment on.\n\t\t\twinlen_sample: optional, can be given as arguments, when\n\t\t\tsegment_lengths is given in frames, but data is given in samples\n\t\t\twinstep_sample: optional, can be given as arguments, when\n\t\t\tsegment_lengths is given in frames, but data is given in samples\n\n\t\tReturns:\n\t\t\tthe segmented data: a list of [... x segment_length x ...]\n\t\t\"\"\"", "\n", "\n", "segmented_data", "=", "dict", "(", ")", "\n", "N", "=", "np", ".", "shape", "(", "data", ")", "[", "time_dim", "]", "\n", "\n", "for", "seg_length", "in", "self", ".", "segment_lengths", ":", "\n", "\t\t\t", "if", "seg_length", "==", "'full'", ":", "\n", "\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "seg_len", "=", "int", "(", "seg_length", ")", "# in frames", "\n", "\n", "if", "winlen_sample", "is", "None", "and", "winstep_sample", "is", "None", ":", "\n", "\t\t\t\t\t", "Nseg", "=", "int", "(", "np", ".", "floor", "(", "float", "(", "N", ")", "/", "float", "(", "seg_len", ")", ")", ")", "\n", "if", "Nseg", "<", "1", ":", "\n", "\t\t\t\t\t\t", "seg_data", "=", "[", "np", ".", "concatenate", "(", "(", "data", ",", "np", ".", "zeros", "(", "[", "seg_len", "-", "N", "]", "+", "list", "(", "np", ".", "shape", "(", "data", ")", "[", "1", ":", "]", ")", ")", ")", ",", "axis", "=", "0", ")", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "seg_data", "=", "[", "]", "\n", "for", "seg_ind", "in", "range", "(", "Nseg", ")", ":", "\n", "\t\t\t\t\t\t\t", "time_indices", "=", "range", "(", "seg_ind", "*", "seg_len", ",", "(", "seg_ind", "+", "1", ")", "*", "seg_len", ")", "\n", "seg_data", ".", "append", "(", "np", ".", "take", "(", "data", ",", "time_indices", ",", "axis", "=", "time_dim", ")", ")", "\n", "\n", "", "", "", "else", ":", "\n", "\t\t\t\t\t", "winoverlap_sample", "=", "winlen_sample", "-", "winstep_sample", "\n", "seg_len_sample", "=", "seg_len", "*", "winstep_sample", "+", "winoverlap_sample", "\n", "Nseg", "=", "int", "(", "np", ".", "floor", "(", "float", "(", "N", "-", "winoverlap_sample", ")", "/", "float", "(", "seg_len", "*", "winstep_sample", ")", ")", ")", "\n", "if", "Nseg", "<", "1", ":", "\n", "\t\t\t\t\t\t", "seg_data", "=", "[", "np", ".", "concatenate", "(", "(", "data", ",", "np", ".", "zeros", "(", "(", "seg_len_sample", "-", "N", ",", "self", ".", "dim", ")", ")", ")", ",", "axis", "=", "0", ")", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "seg_data", "=", "[", "]", "\n", "for", "seg_ind", "in", "range", "(", "Nseg", ")", ":", "\n", "\t\t\t\t\t\t\t", "start_offset", "=", "seg_ind", "*", "(", "seg_len", "*", "winstep_sample", ")", "\n", "time_indices", "=", "range", "(", "start_offset", ",", "start_offset", "+", "seg_len_sample", ")", "\n", "seg_data", ".", "append", "(", "np", ".", "take", "(", "data", ",", "time_indices", ",", "axis", "=", "time_dim", ")", ")", "\n", "\n", "", "", "", "", "segmented_data", "[", "seg_length", "]", "=", "seg_data", "\n", "\n", "", "return", "segmented_data", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.processor.Processor.write_metadata": [[82, 88], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.processor.Processor.pre_loop": [[89, 94], ["None"], "methods", ["None"], ["", "def", "pre_loop", "(", "self", ",", "dataconf", ")", ":", "\n", "\t\t", "\"\"\"allow the processor to access data before looping over all the data\n\n\t\tArgs:\n\t\t\tdataconf: config file on the part of the database being processed\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.processor.Processor.post_loop": [[95, 100], ["None"], "methods", ["None"], ["", "def", "post_loop", "(", "self", ",", "dataconf", ")", ":", "\n", "\t\t", "\"\"\"allow the processor to access data after looping over all the data\n\n\t\tArgs:\n\t\t\tdataconf: config file on the part of the database being processed\"\"\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_multi_signal_processor.AudioMultiSignalProcessor.__init__": [[17, 35], ["audio_multi_signal_processor.AudioMultiSignalProcessor.comp.get_dim", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"AudioMultiSignalProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: AudioMultiSignalProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "\n", "super", "(", "AudioMultiSignalProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_multi_signal_processor.AudioMultiSignalProcessor.__call__": [[36, 74], ["dict", "dataline.strip().split", "list", "numpy.array", "int", "int", "audio_multi_signal_processor.AudioMultiSignalProcessor.segment_data", "len", "audio_multi_signal_processor._read_wav", "audio_multi_signal_processor.AudioMultiSignalProcessor.comp", "numpy.array.append", "dataline.strip", "float", "float"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline.\n\t\tWarning: will not work in combination with a tfwriter since the output\n\t\tis a list and not numpy array\n\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The multiple audio signals as list of numpy arrays per signal per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "multi_signal", "=", "list", "(", ")", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "# read the wav file", "\n", "\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "multi_signal", ".", "append", "(", "features", ")", "\n", "\n", "", "multi_signal", "=", "np", ".", "array", "(", "multi_signal", ")", "\n", "# split the data for all desired segment lengths", "\n", "winlen_sample", "=", "int", "(", "rate", "*", "float", "(", "self", ".", "conf", "[", "'winlen'", "]", ")", ")", "\n", "winstep_sample", "=", "int", "(", "rate", "*", "float", "(", "self", ".", "conf", "[", "'winstep'", "]", ")", ")", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "\n", "multi_signal", ",", "time_dim", "=", "1", ",", "winlen_sample", "=", "winlen_sample", ",", "winstep_sample", "=", "winstep_sample", ")", "\n", "\n", "utt_info", "[", "'rate'", "]", "=", "rate", "\n", "utt_info", "[", "'nrSig'", "]", "=", "len", "(", "splitdatalines", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_multi_signal_processor.AudioMultiSignalProcessor.write_metadata": [[75, 86], ["enumerate", "os.path.join", "open", "fid.write", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_multi_signal_processor._read_wav": [[88, 122], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "audio_multi_signal_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.index_processor.indexProcessor.__init__": [[18, 36], ["int", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"indexProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: indexProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments. \n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# create the string label to index dictionary", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "super", "(", "indexProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.index_processor.indexProcessor.__call__": [[37, 66], ["dict", "dataline.split", "map", "index_processor._read_wav", "index_processor.indexProcessor.comp", "index_processor.indexProcessor.segment_data", "numpy.shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: contains the audio mixture and the indices\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented features as a list of indices per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "split_dataline", "=", "dataline", ".", "split", "(", "' '", ")", "\n", "audiofile", "=", "split_dataline", "[", "0", "]", "\n", "string_labels", "=", "split_dataline", "[", "1", ":", "]", "\n", "\n", "utt_info", "[", "'nrS'", "]", "=", "self", ".", "nrS", "\n", "index_labels", "=", "map", "(", "int", ",", "string_labels", ")", "\n", "# convert to python indexing", "\n", "index_labels", "=", "[", "lab", "-", "1", "for", "lab", "in", "index_labels", "]", "\n", "\n", "# get the number of frames from the mixture audio file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "audiofile", ")", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "Nfram", "=", "np", ".", "shape", "(", "features", ")", "[", "0", "]", "\n", "\n", "# split the data for all desired segment lengths", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "index_labels", ",", "Nfram", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.index_processor.indexProcessor.write_metadata": [[67, 78], ["enumerate", "os.path.join", "open", "fid.write", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nrS'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nrS", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.index_processor.indexProcessor.segment_data": [[79, 111], ["dict", "int", "int", "numpy.floor", "range", "seg_data.append", "float", "float"], "methods", ["None"], ["", "", "", "def", "segment_data", "(", "self", ",", "data", ",", "N", ")", ":", "\n", "\t\t", "\"\"\"Usually data is segmented by splitting an utterance into different parts\n\t\t(see processor.py). For this processor, we just replicate the label index\n\t\tmultiple times.\n\n\t\tArgs:\n\t\t\tdata: the data to be split\n\t\t\tN: the the number of frames. To seen how many segments are required\n\n\t\tReturns:\n\t\t\tthe segmented data\n\t\t\"\"\"", "\n", "\n", "segmented_data", "=", "dict", "(", ")", "\n", "\n", "for", "seg_length", "in", "self", ".", "segment_lengths", ":", "\n", "\t\t\t", "if", "seg_length", "==", "'full'", ":", "\n", "\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "seg_len", "=", "int", "(", "seg_length", ")", "\n", "Nseg", "=", "int", "(", "np", ".", "floor", "(", "float", "(", "N", ")", "/", "float", "(", "seg_len", ")", ")", ")", "\n", "\n", "if", "Nseg", "==", "0", ":", "\n", "\t\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "seg_data", "=", "[", "]", "\n", "for", "seg_ind", "in", "range", "(", "Nseg", ")", ":", "\n", "\t\t\t\t\t\t", "seg_data", ".", "append", "(", "data", ")", "\n", "\n", "", "", "", "segmented_data", "[", "seg_length", "]", "=", "seg_data", "\n", "\n", "", "return", "segmented_data", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.index_processor._read_wav": [[113, 147], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "index_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_averager_encapsulator.MultiAveragerEncapsulator.__init__": [[13, 25], ["int", "processor.Processor.__init__", "processor_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"ZeroProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: ScorelabelperfeatureProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "self", ".", "encapsulated_processor", "=", "processor_factory", ".", "factory", "(", "conf", "[", "'encapsulated_processor'", "]", ")", "(", "conf", ",", "segment_lengths", ")", "\n", "self", ".", "comp", "=", "self", ".", "encapsulated_processor", ".", "comp", "\n", "self", ".", "n_channels", "=", "int", "(", "conf", "[", "'n_channels'", "]", ")", "\n", "super", "(", "MultiAveragerEncapsulator", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_averager_encapsulator.MultiAveragerEncapsulator.__call__": [[26, 88], ["dataline.strip().split", "list", "list", "dict", "len", "range", "multi_averager_encapsulator.MultiAveragerEncapsulator.encapsulated_processor", "list.append", "list.append", "len", "range", "dataline.strip", "Exception", "numpy.mean", "numpy.mean", "numpy.std", "range", "tmp.append", "len", "BaseException", "numpy.mean", "multi_signal_segs_average.append", "multi_averager_encapsulator.MultiAveragerEncapsulator.encapsulated_processor", "all_mvn_data.append", "len", "numpy.array", "enumerate"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented zeros\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "if", "'mvn_type'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'mvn_type'", "]", "==", "'from_files'", ":", "\n", "\t\t\t", "if", "'mvn_from_files'", "not", "in", "splitdatalines", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Expected files to determine mean and variance'", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "keyword_ind", "=", "[", "ind", "for", "ind", ",", "splitword", "in", "enumerate", "(", "splitdatalines", ")", "if", "splitword", "==", "'mvn_from_files'", "]", "[", "0", "]", "\n", "mvn_files", "=", "splitdatalines", "[", "keyword_ind", "+", "1", ":", "]", "\n", "splitdatalines", "=", "splitdatalines", "[", ":", "keyword_ind", "]", "\n", "\n", "all_mvn_data", "=", "[", "]", "\n", "for", "mvn_file", "in", "mvn_files", ":", "\n", "\t\t\t\t\t", "mvn_data", ",", "utt_info", "=", "self", ".", "encapsulated_processor", "(", "mvn_file", ")", "\n", "all_mvn_data", ".", "append", "(", "mvn_data", ")", "\n", "", "combined_mvn_data", "=", "np", ".", "mean", "(", "[", "data", "[", "'full'", "]", "[", "0", "]", "for", "data", "in", "all_mvn_data", "]", ",", "0", ")", "\n", "mean_to_use", "=", "np", ".", "mean", "(", "combined_mvn_data", ",", "0", ",", "keepdims", "=", "True", ")", "\n", "std_to_use", "=", "np", ".", "std", "(", "combined_mvn_data", ",", "0", ",", "keepdims", "=", "True", ")", "\n", "\n", "", "", "if", "len", "(", "splitdatalines", ")", ">", "self", ".", "n_channels", ":", "\n", "# some encapsulated processors require multichannel data them self", "\n", "\t\t\t", "tmp", "=", "[", "]", "\n", "for", "ch_ind", "in", "range", "(", "self", ".", "n_channels", ")", ":", "\n", "\t\t\t\t", "to_combine", "=", "range", "(", "ch_ind", ",", "len", "(", "splitdatalines", ")", ",", "self", ".", "n_channels", ")", "\n", "tmp", ".", "append", "(", "' '", ".", "join", "(", "[", "splitdatalines", "[", "ind", "]", "for", "ind", "in", "to_combine", "]", ")", ")", "\n", "", "splitdatalines", "=", "tmp", "\n", "\n", "", "elif", "len", "(", "splitdatalines", ")", "<", "self", ".", "n_channels", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "'Received less data lines then requested number of input channels'", ")", "\n", "\n", "", "multi_processed", "=", "list", "(", ")", "\n", "utt_infos", "=", "list", "(", ")", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "\t\t\t", "segmented_data", ",", "utt_info", "=", "self", ".", "encapsulated_processor", "(", "splitdataline", ")", "\n", "multi_processed", ".", "append", "(", "segmented_data", ")", "\n", "utt_infos", ".", "append", "(", "utt_info", ")", "\n", "\n", "# average over the segments", "\n", "", "multi_signal_averaged", "=", "dict", "(", ")", "\n", "for", "seg_len", "in", "self", ".", "encapsulated_processor", ".", "segment_lengths", ":", "\n", "\t\t\t", "multi_signal_seg", "=", "[", "mul_sig", "[", "seg_len", "]", "for", "mul_sig", "in", "multi_processed", "]", "\n", "n_seg", "=", "len", "(", "multi_signal_seg", "[", "0", "]", ")", "\n", "multi_signal_segs_average", "=", "[", "]", "\n", "for", "seg_ind", "in", "range", "(", "n_seg", ")", ":", "\n", "\t\t\t\t", "multi_signal_seg_channels", "=", "[", "multi_signal_seg_ch", "[", "seg_ind", "]", "for", "multi_signal_seg_ch", "in", "multi_signal_seg", "]", "\n", "multi_signal_seg_average", "=", "np", ".", "mean", "(", "np", ".", "array", "(", "multi_signal_seg_channels", ")", ",", "0", ")", "\n", "if", "'mvn_type'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'mvn_type'", "]", "==", "'from_files'", ":", "\n", "\t\t\t\t\t", "multi_signal_seg_average", "=", "(", "multi_signal_seg_average", "-", "mean_to_use", ")", "/", "(", "std_to_use", "+", "1e-12", ")", "\n", "", "multi_signal_segs_average", ".", "append", "(", "multi_signal_seg_average", ")", "\n", "", "multi_signal_averaged", "[", "seg_len", "]", "=", "multi_signal_segs_average", "\n", "\n", "# for the moment just taking utt_info from the first channel", "\n", "", "return", "multi_signal_averaged", ",", "utt_infos", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_averager_encapsulator.MultiAveragerEncapsulator.write_metadata": [[89, 96], ["multi_averager_encapsulator.MultiAveragerEncapsulator.encapsulated_processor.write_metadata"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor.ScorelabelperfeatureProcessor.write_metadata"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "self", ".", "encapsulated_processor", ".", "write_metadata", "(", "datadir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_feat_processor.AudioFeatProcessor.__init__": [[18, 50], ["audio_feat_processor.AudioFeatProcessor.comp.get_dim", "numpy.zeros", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory", "len", "numpy.zeros", "numpy.zeros", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"AudioFeatProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: AudioFeatProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments. \n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "max_length", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "segment_lengths", ")", ")", "\n", "# self.sequence_length_histogram = np.zeros(0, dtype=np.int32)", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "# set the type of mean and variance normalisation", "\n", "self", ".", "mvn_type", "=", "conf", "[", "'mvn_type'", "]", "\n", "if", "conf", "[", "'mvn_type'", "]", "==", "'global'", ":", "\n", "\t\t\t", "self", ".", "obs_cnt", "=", "0", "\n", "self", ".", "glob_mean", "=", "np", ".", "zeros", "(", "[", "1", ",", "self", ".", "dim", "]", ")", "\n", "self", ".", "glob_std", "=", "np", ".", "zeros", "(", "[", "1", ",", "self", ".", "dim", "]", ")", "\n", "", "elif", "conf", "[", "'mvn_type'", "]", "in", "[", "'local'", ",", "'none'", ",", "'None'", ",", "'from_files'", "]", ":", "\n", "\t\t\t", "pass", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Unknown way to apply mvn: %s'", "%", "conf", "[", "'mvn_type'", "]", ")", "\n", "\n", "", "super", "(", "AudioFeatProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_feat_processor.AudioFeatProcessor.__call__": [[51, 91], ["dict", "audio_feat_processor._read_wav", "audio_feat_processor.AudioFeatProcessor.comp", "audio_feat_processor.AudioFeatProcessor.segment_data", "enumerate", "max", "numpy.shape", "numpy.mean", "numpy.std"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented features as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "# read the wav file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "dataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "# mean and variance normalize the features", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "features", "=", "(", "features", "-", "self", ".", "glob_mean", ")", "/", "(", "self", ".", "glob_std", "+", "1e-12", ")", "\n", "", "elif", "self", ".", "mvn_type", "==", "'local'", ":", "\n", "\t\t\t", "features", "=", "(", "features", "-", "np", ".", "mean", "(", "features", ",", "0", ")", ")", "/", "(", "np", ".", "std", "(", "features", ",", "0", ")", "+", "1e-12", ")", "\n", "\n", "# split the data for all desired segment lengths", "\n", "", "segmented_data", "=", "self", ".", "segment_data", "(", "features", ")", "\n", "\n", "# update the metadata", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "self", ".", "max_length", "[", "i", "]", "=", "max", "(", "self", ".", "max_length", "[", "i", "]", ",", "np", ".", "shape", "(", "segmented_data", "[", "seg_length", "]", "[", "0", "]", ")", "[", "0", "]", ")", "\n", "# seq_length = np.shape(segmented_data[seg_length][0])[0]", "\n", "# if seq_length >= np.shape(self.sequence_length_histogram[i])[0]:", "\n", "# self.sequence_length_histogram[i] = np.concatenate(", "\n", "# [self.sequence_length_histogram[i], np.zeros(", "\n", "# seq_length-np.shape(self.sequence_length_histogram[i])[0]+1,", "\n", "# dtype=np.int32)]", "\n", "# )", "\n", "# self.sequence_length_histogram[i][seq_length] += len(segmented_data[seg_length])", "\n", "\n", "", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_feat_processor.AudioFeatProcessor.pre_loop": [[92, 142], ["dataconf[].split", "open_fn", "line.strip().split", "float", "open", "numpy.save", "numpy.sqrt", "open", "numpy.load", "audio_feat_processor.AudioFeatProcessor.acc_mean", "os.path.join", "open", "numpy.save", "os.path.join", "open", "numpy.load", "line.strip", "audio_feat_processor.AudioFeatProcessor.acc_std", "float", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.acc_mean", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.acc_std"], ["", "def", "pre_loop", "(", "self", ",", "dataconf", ")", ":", "\n", "\t\t", "\"\"\"before looping over all the data to process and store it, calculate the\n\t\tglobal mean and variance to normalize the features later on\n\t\t\n\t\tArgs:\n\t\t\tdataconf: config file on the part of the database being processed\"\"\"", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "loop_types", "=", "[", "'mean'", ",", "'std'", "]", "\n", "\n", "# calculate the mean and variance", "\n", "for", "loop_type", "in", "loop_types", ":", "\n", "# if the directory of mean and variance are pointing to the store directory,", "\n", "# this means that the mean and variance should be calculated here.", "\n", "\t\t\t\t", "if", "dataconf", "[", "'meanandvar_dir'", "]", "==", "dataconf", "[", "'store_dir'", "]", ":", "\n", "\t\t\t\t\t", "for", "datafile", "in", "dataconf", "[", "'datafiles'", "]", ".", "split", "(", "' '", ")", ":", "\n", "\t\t\t\t\t\t", "if", "datafile", "[", "-", "3", ":", "]", "==", "'.gz'", ":", "\n", "\t\t\t\t\t\t\t", "open_fn", "=", "gzip", ".", "open", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "open_fn", "=", "open", "\n", "\n", "# loop over the lines in the datafile", "\n", "", "for", "line", "in", "open_fn", "(", "datafile", ")", ":", "\n", "\n", "# split the name and the data line", "\n", "\t\t\t\t\t\t\t", "splitline", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "utt_name", "=", "splitline", "[", "0", "]", "\n", "dataline", "=", "' '", ".", "join", "(", "splitline", "[", "1", ":", "]", ")", "\n", "\n", "# process the dataline", "\n", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "acc_mean", "(", "dataline", ")", "\n", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "acc_std", "(", "dataline", ")", "\n", "\n", "", "", "", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t", "self", ".", "glob_mean", "=", "self", ".", "glob_mean", "/", "float", "(", "self", ".", "obs_cnt", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_mean.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_mean", ")", "\n", "", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t", "self", ".", "glob_std", "=", "np", ".", "sqrt", "(", "self", ".", "glob_std", "/", "float", "(", "self", ".", "obs_cnt", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_std.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_std", ")", "\n", "", "", "", "else", ":", "\n", "# get mean and variance calculated on training set", "\n", "\t\t\t\t\t", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_mean.npy'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "self", ".", "glob_mean", "=", "np", ".", "load", "(", "fid", ")", "\n", "", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_std.npy'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "self", ".", "glob_std", "=", "np", ".", "load", "(", "fid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_feat_processor.AudioFeatProcessor.acc_mean": [[143, 161], ["audio_feat_processor._read_wav", "audio_feat_processor.AudioFeatProcessor.comp", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "", "", "def", "acc_mean", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"accumulate the features to get the mean\n\t\tArgs:\n\t\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\t\tan audio file\"\"\"", "\n", "\n", "# read the wav file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "dataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "# accumulate the features", "\n", "acc_feat", "=", "np", ".", "sum", "(", "features", ",", "0", ")", "\n", "\n", "# update the mean and observation count", "\n", "self", ".", "glob_mean", "+=", "acc_feat", "\n", "self", ".", "obs_cnt", "+=", "features", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_feat_processor.AudioFeatProcessor.acc_std": [[162, 179], ["audio_feat_processor._read_wav", "audio_feat_processor.AudioFeatProcessor.comp", "numpy.sum", "numpy.square"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "acc_std", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"accumulate the features to get the standard deviation\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\"\"\"", "\n", "\n", "# read the wav file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "dataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "# accumulate the features", "\n", "acc_feat", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "features", "-", "self", ".", "glob_mean", ")", ",", "0", ")", "\n", "\n", "# update the standard deviation", "\n", "self", ".", "glob_std", "+=", "acc_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_feat_processor.AudioFeatProcessor.write_metadata": [[180, 202], ["enumerate", "os.path.join", "open", "numpy.save", "open", "numpy.save", "open", "fid.write", "open", "fid.write", "open", "fid.write", "os.path.join", "os.path.join", "os.path.join", "str", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "datadir", ",", "'glob_mean.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_mean", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "datadir", ",", "'glob_std.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_std", ")", "\n", "\n", "", "", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "# with open(os.path.join(seg_dir, 'sequence_length_histogram.npy'), 'w') as fid:", "\n", "# np.save(fid, self.sequence_length_histogram[i])", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'max_length'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "max_length", "[", "i", "]", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.audio_feat_processor._read_wav": [[204, 238], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "audio_feat_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.VadTimingsProcessor.__init__": [[18, 43], ["float", "float", "int", "numpy.zeros", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory", "len"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"VadTimingsProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: VadTimingsProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments. \n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "'frames'", ")", "(", "conf", ")", "\n", "self", ".", "winlen", "=", "float", "(", "conf", "[", "'winlen'", "]", ")", "\n", "self", ".", "winstep", "=", "float", "(", "conf", "[", "'winstep'", "]", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "dim", "=", "self", ".", "nrS", "\n", "self", ".", "max_length", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "segment_lengths", ")", ")", "\n", "# self.sequence_length_histogram = np.zeros(0, dtype=np.int32)", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "VadTimingsProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.VadTimingsProcessor.__call__": [[44, 114], ["dict", "datalines.split", "datalines.split.pop", "vad_timings_processor._read_wav", "vad_timings_processor.VadTimingsProcessor.comp", "numpy.zeros", "vad_timings_processor.VadTimingsProcessor.segment_data", "enumerate", "numpy.shape", "max", "float", "vad_timings_processor.sec2frames", "float", "vad_timings_processor.sec2frames", "len", "numpy.shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.sec2frames", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.sec2frames"], ["", "def", "__call__", "(", "self", ",", "datalines", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdatalines: in format 'mix_wav spk_id1 seg1_start seg1_end seg2_start seg2_end ... spk_id1 spk_id2 ... spk_id2\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented features as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "split_lines", "=", "datalines", ".", "split", "(", "' '", ")", "\n", "mix_file", "=", "split_lines", ".", "pop", "(", "0", ")", "\n", "\n", "# read the wav file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "mix_file", ")", "\n", "\n", "# compute the features", "\n", "frames", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "audio_length", "=", "np", ".", "shape", "(", "frames", ")", "[", "-", "2", "]", "\n", "\n", "vad_indicator", "=", "np", ".", "zeros", "(", "[", "audio_length", ",", "self", ".", "dim", "]", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "\n", "ind", "=", "0", "\n", "spk_ind", "=", "0", "\n", "new_id", "=", "True", "\n", "prev_id", "=", "''", "\n", "while", "True", ":", "\n", "\t\t\t", "if", "new_id", ":", "\n", "\t\t\t\t", "prev_id", "=", "split_lines", "[", "ind", "]", "\n", "ind", "+=", "1", "\n", "new_id", "=", "False", "\n", "", "if", "prev_id", "==", "split_lines", "[", "ind", "]", ":", "\n", "\t\t\t\t", "ind", "+=", "1", "\n", "new_id", "=", "True", "\n", "spk_ind", "+=", "1", "\n", "", "else", ":", "\n", "\t\t\t\t", "seg_st", "=", "float", "(", "split_lines", "[", "ind", "]", ")", "\n", "seg_st_frames", "=", "sec2frames", "(", "seg_st", ",", "self", ".", "winlen", ",", "self", ".", "winstep", ")", "\n", "if", "seg_st_frames", ">", "audio_length", "-", "1", ":", "\n", "\t\t\t\t\t", "seg_st_frames", "=", "audio_length", "-", "1", "\n", "", "seg_end", "=", "float", "(", "split_lines", "[", "ind", "+", "1", "]", ")", "\n", "seg_end_frames", "=", "sec2frames", "(", "seg_end", ",", "self", ".", "winlen", ",", "self", ".", "winstep", ")", "\n", "if", "seg_end_frames", ">", "audio_length", ":", "\n", "\t\t\t\t\t", "seg_end_frames", "=", "audio_length", "\n", "\n", "", "vad_indicator", "[", "seg_st_frames", ":", "seg_end_frames", ",", "spk_ind", "]", "=", "1", "\n", "\n", "ind", "+=", "2", "\n", "\n", "", "if", "ind", ">=", "len", "(", "split_lines", ")", ":", "\n", "\t\t\t\t", "break", "\n", "\n", "# split the data for all desired segment lengths", "\n", "", "", "segmented_data", "=", "self", ".", "segment_data", "(", "vad_indicator", ")", "\n", "\n", "# update the metadata", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "self", ".", "max_length", "[", "i", "]", "=", "max", "(", "self", ".", "max_length", "[", "i", "]", ",", "np", ".", "shape", "(", "segmented_data", "[", "seg_length", "]", "[", "0", "]", ")", "[", "0", "]", ")", "\n", "# seq_length = np.shape(segmented_data[seg_length][0])[0]", "\n", "# if seq_length >= np.shape(self.sequence_length_histogram[i])[0]:", "\n", "# self.sequence_length_histogram[i] = np.concatenate(", "\n", "# [self.sequence_length_histogram[i], np.zeros(", "\n", "# seq_length-np.shape(self.sequence_length_histogram[i])[0]+1,", "\n", "# dtype=np.int32)]", "\n", "# )", "\n", "# self.sequence_length_histogram[i][seq_length] += len(segmented_data[seg_length])", "\n", "\n", "", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.VadTimingsProcessor.write_metadata": [[115, 131], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "# with open(os.path.join(seg_dir, 'sequence_length_histogram.npy'), 'w') as fid:", "\n", "# np.save(fid, self.sequence_length_histogram[i])", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'max_length'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "max_length", "[", "i", "]", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.VadTimings2SamplesProcessor.__init__": [[136, 156], ["int", "numpy.zeros", "processor.Processor.__init__", "len"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"VadTimingsProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: VadTimingsProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "dim", "=", "self", ".", "nrS", "\n", "self", ".", "max_length", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "segment_lengths", ")", ")", "\n", "# self.sequence_length_histogram = np.zeros(0, dtype=np.int32)", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "VadTimings2SamplesProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.VadTimings2SamplesProcessor.__call__": [[157, 224], ["dict", "datalines.split", "datalines.split.pop", "vad_timings_processor._read_wav", "len", "numpy.zeros", "vad_timings_processor.VadTimings2SamplesProcessor.segment_data", "enumerate", "max", "float", "vad_timings_processor.sec2samples", "float", "vad_timings_processor.sec2samples", "len", "numpy.shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.sec2samples", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.sec2samples"], ["", "def", "__call__", "(", "self", ",", "datalines", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdatalines: in format 'mix_wav spk_id1 seg1_start seg1_end seg2_start seg2_end ... spk_id1 spk_id2 ... spk_id2\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented features as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "split_lines", "=", "datalines", ".", "split", "(", "' '", ")", "\n", "mix_file", "=", "split_lines", ".", "pop", "(", "0", ")", "\n", "\n", "# read the wav file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "mix_file", ")", "\n", "\n", "audio_length", "=", "len", "(", "utt", ")", "\n", "\n", "vad_indicator", "=", "np", ".", "zeros", "(", "[", "audio_length", ",", "self", ".", "dim", "]", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "\n", "ind", "=", "0", "\n", "spk_ind", "=", "0", "\n", "new_id", "=", "True", "\n", "prev_id", "=", "''", "\n", "while", "True", ":", "\n", "\t\t\t", "if", "new_id", ":", "\n", "\t\t\t\t", "prev_id", "=", "split_lines", "[", "ind", "]", "\n", "ind", "+=", "1", "\n", "new_id", "=", "False", "\n", "", "if", "prev_id", "==", "split_lines", "[", "ind", "]", ":", "\n", "\t\t\t\t", "ind", "+=", "1", "\n", "new_id", "=", "True", "\n", "spk_ind", "+=", "1", "\n", "", "else", ":", "\n", "\t\t\t\t", "seg_st", "=", "float", "(", "split_lines", "[", "ind", "]", ")", "\n", "seg_st_samples", "=", "sec2samples", "(", "seg_st", ",", "rate", ")", "\n", "if", "seg_st_samples", ">", "audio_length", "-", "1", ":", "\n", "\t\t\t\t\t", "seg_st_samples", "=", "audio_length", "-", "1", "\n", "", "seg_end", "=", "float", "(", "split_lines", "[", "ind", "+", "1", "]", ")", "\n", "seg_end_samples", "=", "sec2samples", "(", "seg_end", ",", "rate", ")", "\n", "if", "seg_end_samples", ">", "audio_length", ":", "\n", "\t\t\t\t\t", "seg_end_samples", "=", "audio_length", "\n", "\n", "", "vad_indicator", "[", "seg_st_samples", ":", "seg_end_samples", ",", "spk_ind", "]", "=", "1", "\n", "\n", "ind", "+=", "2", "\n", "\n", "", "if", "ind", ">=", "len", "(", "split_lines", ")", ":", "\n", "\t\t\t\t", "break", "\n", "\n", "# split the data for all desired segment lengths", "\n", "", "", "segmented_data", "=", "self", ".", "segment_data", "(", "vad_indicator", ")", "\n", "\n", "# update the metadata", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "self", ".", "max_length", "[", "i", "]", "=", "max", "(", "self", ".", "max_length", "[", "i", "]", ",", "np", ".", "shape", "(", "segmented_data", "[", "seg_length", "]", "[", "0", "]", ")", "[", "0", "]", ")", "\n", "# seq_length = np.shape(segmented_data[seg_length][0])[0]", "\n", "# if seq_length >= np.shape(self.sequence_length_histogram[i])[0]:", "\n", "# self.sequence_length_histogram[i] = np.concatenate(", "\n", "# [self.sequence_length_histogram[i], np.zeros(", "\n", "# seq_length-np.shape(self.sequence_length_histogram[i])[0]+1,", "\n", "# dtype=np.int32)]", "\n", "# )", "\n", "# self.sequence_length_histogram[i][seq_length] += len(segmented_data[seg_length])", "\n", "\n", "", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.VadTimings2SamplesProcessor.write_metadata": [[225, 241], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "# with open(os.path.join(seg_dir, 'sequence_length_histogram.npy'), 'w') as fid:", "\n", "# np.save(fid, self.sequence_length_histogram[i])", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'max_length'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "max_length", "[", "i", "]", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.sec2frames": [[243, 250], ["int", "round"], "function", ["None"], ["", "", "", "", "def", "sec2frames", "(", "time_in_seconds", ",", "winlength", ",", "winstep", ")", ":", "\n", "\t", "\"\"\" turn time in seconds into time in frames\"\"\"", "\n", "time_in_frames", "=", "(", "time_in_seconds", "-", "winlength", "/", "2", ")", "/", "winstep", "\n", "time_in_frames", "=", "int", "(", "round", "(", "time_in_frames", ")", ")", "\n", "if", "time_in_frames", "<", "0", ":", "\n", "\t\t", "time_in_frames", "=", "0", "\n", "", "return", "time_in_frames", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor.sec2samples": [[252, 259], ["int", "round"], "function", ["None"], ["", "def", "sec2samples", "(", "time_in_seconds", ",", "rate", ")", ":", "\n", "\t", "\"\"\" turn time in seconds into time in samples\"\"\"", "\n", "time_in_samples", "=", "int", "(", "round", "(", "time_in_seconds", "*", "rate", ")", ")", "\n", "\n", "if", "time_in_samples", "<", "0", ":", "\n", "\t\t", "time_in_samples", "=", "0", "\n", "", "return", "time_in_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.vad_timings_processor._read_wav": [[261, 295], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "vad_timings_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_multimic_processor.ScorelabelperfeatureMultimicProcessor.__init__": [[18, 39], ["float", "scorelabelperfeature_multimic_processor.ScorelabelperfeatureMultimicProcessor.comp.get_dim", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"ScorelabelperfeatureMultimicProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: ScorelabelperfeatureMultimicProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "self", ".", "mag_thres", "=", "float", "(", "conf", "[", "'mag_thres'", "]", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "ScorelabelperfeatureMultimicProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_multimic_processor.ScorelabelperfeatureMultimicProcessor.__call__": [[40, 83], ["dict", "dataline.strip().split", "enumerate", "numpy.mean", "numpy.max", "numpy.greater", "scorelabelperfeature_multimic_processor.ScorelabelperfeatureMultimicProcessor.segment_data", "scorelabelperfeature_multimic_processor._read_wav", "scorelabelperfeature_multimic_processor.ScorelabelperfeatureMultimicProcessor.comp", "numpy.expand_dims", "dataline.strip", "numpy.append"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented info on bins to be used for scoring as a list of numpy arrays per segment\n\t\t\tlength\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "# stack the features for each line/mic", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "features", "=", "None", "\n", "for", "mic_ind", ",", "splitdataline", "in", "enumerate", "(", "splitdatalines", ")", ":", "\n", "# read the wav file", "\n", "\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features_mic", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "features_mic", "=", "np", ".", "expand_dims", "(", "features_mic", ",", "2", ")", "\n", "\n", "if", "features", "is", "None", ":", "\n", "\t\t\t\t", "features", "=", "features_mic", "\n", "", "else", ":", "\n", "\t\t\t\t", "features", "=", "np", ".", "append", "(", "features", ",", "features_mic", ",", "2", ")", "\n", "\n", "# Average the features over the microphones", "\n", "", "", "features", "=", "np", ".", "mean", "(", "features", ",", "axis", "=", "-", "1", ")", "\n", "\n", "# compute the floor", "\n", "maxbin", "=", "np", ".", "max", "(", "features", ")", "\n", "floor", "=", "maxbin", "/", "self", ".", "mag_thres", "\n", "\n", "# apply floor to get the used bins", "\n", "usedbins", "=", "np", ".", "greater", "(", "features", ",", "floor", ")", "\n", "\n", "# split the data for all desired segment lengths", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "usedbins", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_multimic_processor.ScorelabelperfeatureMultimicProcessor.write_metadata": [[84, 96], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_multimic_processor._read_wav": [[98, 132], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "scorelabelperfeature_multimic_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.onehotperfeature_target_multimic_processor.onehotperfeatureTargetMultimicProcessor.__init__": [[17, 42], ["int", "int", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory", "map", "range", "onehotperfeature_target_multimic_processor.onehotperfeatureTargetMultimicProcessor.comp.get_dim", "len", "conf[].split"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"onehotperfeatureTargetProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: onehotperfeatureTargetProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "if", "'spk_select'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "nrS_select", "=", "map", "(", "int", ",", "conf", "[", "'spk_select'", "]", ".", "split", "(", "' '", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "nrS_select", "=", "range", "(", "0", ",", "self", ".", "nrS", ")", "\n", "", "self", ".", "nr_channels", "=", "int", "(", "conf", "[", "'nr_channels'", "]", ")", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "*", "len", "(", "self", ".", "nrS_select", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "onehotperfeatureTargetMultimicProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.onehotperfeature_target_multimic_processor.onehotperfeatureTargetMultimicProcessor.__call__": [[43, 94], ["dict", "dataline.strip().split", "range", "numpy.argmax", "numpy.empty", "enumerate", "onehotperfeature_target_multimic_processor.onehotperfeatureTargetMultimicProcessor.segment_data", "range", "splitdatalines_per_spk.append", "numpy.mean", "dataline.strip", "onehotperfeature_target_multimic_processor._read_wav", "onehotperfeature_target_multimic_processor.onehotperfeatureTargetMultimicProcessor.comp", "numpy.expand_dims", "numpy.append", "numpy.append", "len"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented targets as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "splitdatalines_per_spk", "=", "[", "]", "\n", "for", "spk_ind", "in", "range", "(", "self", ".", "nrS", ")", ":", "\n", "\t\t\t", "inds", "=", "range", "(", "spk_ind", "*", "self", ".", "nr_channels", ",", "(", "spk_ind", "+", "1", ")", "*", "self", ".", "nr_channels", ")", "\n", "splitdatalines_per_spk", ".", "append", "(", "[", "splitdatalines", "[", "ind", "]", "for", "ind", "in", "inds", "]", ")", "\n", "\n", "", "clean_features", "=", "None", "\n", "for", "splitdatalines", "in", "splitdatalines_per_spk", ":", "\n", "\t\t\t", "clean_features_spk", "=", "None", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "# read the wav file", "\n", "\t\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "features", "=", "np", ".", "expand_dims", "(", "features", ",", "2", ")", "\n", "\n", "if", "clean_features_spk", "is", "None", ":", "\n", "\t\t\t\t\t", "clean_features_spk", "=", "features", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "clean_features_spk", "=", "np", ".", "append", "(", "clean_features_spk", ",", "features", ",", "2", ")", "\n", "\n", "", "", "clean_features_averaged", "=", "np", ".", "mean", "(", "clean_features_spk", ",", "2", ",", "keepdims", "=", "True", ")", "\n", "\n", "if", "clean_features", "is", "None", ":", "\n", "\t\t\t\t", "clean_features", "=", "clean_features_averaged", "\n", "", "else", ":", "\n", "\t\t\t\t", "clean_features", "=", "np", ".", "append", "(", "clean_features", ",", "clean_features_averaged", ",", "2", ")", "\n", "\n", "", "", "winner", "=", "np", ".", "argmax", "(", "clean_features", ",", "axis", "=", "2", ")", "\n", "targets", "=", "np", ".", "empty", "(", "[", "features", ".", "shape", "[", "0", "]", ",", "self", ".", "dim", "]", ",", "dtype", "=", "bool", ")", "\n", "for", "s_ind", ",", "spk_id", "in", "enumerate", "(", "self", ".", "nrS_select", ")", ":", "\n", "\t\t\t", "targets", "[", ":", ",", "s_ind", ":", ":", "len", "(", "self", ".", "nrS_select", ")", "]", "=", "winner", "==", "spk_id", "\n", "\n", "# split the data for all desired segment lengths", "\n", "", "segmented_data", "=", "self", ".", "segment_data", "(", "targets", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.onehotperfeature_target_multimic_processor.onehotperfeatureTargetMultimicProcessor.write_metadata": [[95, 109], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nrS'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nrS_select", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.onehotperfeature_target_multimic_processor._read_wav": [[111, 145], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "onehotperfeature_target_multimic_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.processor_factory.factory": [[13, 78], ["Exception"], "function", ["None"], ["def", "factory", "(", "processor", ")", ":", "\n", "    ", "\"\"\"gets a Processor class\n\n    Args:\n        processor: the processor type\n\n    Returns:\n        a Processor class\"\"\"", "\n", "\n", "if", "processor", "==", "'audio_feat_processor'", ":", "\n", "        ", "return", "audio_feat_processor", ".", "AudioFeatProcessor", "\n", "", "elif", "processor", "==", "'onehotperfeature_target_processor'", ":", "\n", "        ", "return", "onehotperfeature_target_processor", ".", "onehotperfeatureTargetProcessor", "\n", "", "elif", "processor", "==", "'onehotperfeature_target_multimic_processor'", ":", "\n", "        ", "return", "onehotperfeature_target_multimic_processor", ".", "onehotperfeatureTargetMultimicProcessor", "\n", "", "elif", "processor", "==", "'multi_target_processor'", ":", "\n", "        ", "return", "multi_target_processor", ".", "MultiTargetProcessor", "\n", "", "elif", "processor", "==", "'multi_target_multimic_processor'", ":", "\n", "        ", "return", "multi_target_multimic_processor", ".", "MultiTargetMultimicProcessor", "\n", "", "elif", "processor", "==", "'scorelabelperfeature_processor'", ":", "\n", "        ", "return", "scorelabelperfeature_processor", ".", "ScorelabelperfeatureProcessor", "\n", "", "elif", "processor", "==", "'scorelabelperfeature_multimic_processor'", ":", "\n", "        ", "return", "scorelabelperfeature_multimic_processor", ".", "ScorelabelperfeatureMultimicProcessor", "\n", "", "elif", "processor", "==", "'scorelabelperfeatureinmixture_processor'", ":", "\n", "        ", "return", "scorelabelperfeatureinmixture_processor", ".", "ScorelabelperfeatureinmixtureProcessor", "\n", "", "elif", "processor", "==", "'fracscorelabelperfeature_processor'", ":", "\n", "        ", "return", "fracscorelabelperfeature_processor", ".", "FracScorelabelperfeatureProcessor", "\n", "", "elif", "processor", "==", "'audio_multi_signal_processor'", ":", "\n", "        ", "return", "audio_multi_signal_processor", ".", "AudioMultiSignalProcessor", "\n", "", "elif", "processor", "==", "'audio_signal_processor'", ":", "\n", "        ", "return", "audio_signal_processor", ".", "AudioSignalProcessor", "\n", "", "elif", "processor", "==", "'strlabel2index_processor'", ":", "\n", "        ", "return", "strlabel2index_processor", ".", "Strlabel2indexProcessor", "\n", "", "elif", "processor", "==", "'matrix2vector_processor'", ":", "\n", "        ", "return", "matrix2vector_processor", ".", "Matrix2VectorProcessor", "\n", "", "elif", "processor", "==", "'matrix2matrix_processor'", ":", "\n", "        ", "return", "matrix2vector_processor", ".", "Matrix2MatrixProcessor", "\n", "", "elif", "processor", "==", "'onehotperfeature_target_dummy_processor'", ":", "\n", "        ", "return", "onehotperfeature_target_dummy_processor", ".", "onehotperfeatureTargetDummyProcessor", "\n", "", "elif", "processor", "==", "'multi_target_dummy_processor'", ":", "\n", "        ", "return", "multi_target_dummy_processor", ".", "MultiTargetDummyProcessor", "\n", "", "elif", "processor", "==", "'audio_feat_conc_processor'", ":", "\n", "        ", "return", "audio_feat_conc_processor", ".", "AudioFeatConcProcessor", "\n", "", "elif", "processor", "==", "'multi_averager_encapsulator'", ":", "\n", "        ", "return", "multi_averager_encapsulator", ".", "MultiAveragerEncapsulator", "\n", "", "elif", "processor", "==", "'spatial_feat_processor'", ":", "\n", "        ", "return", "spatial_feat_processor", ".", "SpatialFeatProcessor", "\n", "", "elif", "processor", "==", "'ideal_ratio_processor'", ":", "\n", "        ", "return", "ideal_ratio_processor", ".", "IdealRatioProcessor", "\n", "", "elif", "processor", "==", "'ideal_ratio_multimic_processor'", ":", "\n", "        ", "return", "ideal_ratio_multimic_processor", ".", "IdealRatioMultimicProcessor", "\n", "", "elif", "processor", "==", "'snr_multimic_processor'", ":", "\n", "        ", "return", "ideal_ratio_multimic_processor", ".", "SnrMultimicProcessor", "\n", "", "elif", "processor", "==", "'one_processor'", ":", "\n", "        ", "return", "one_processor", ".", "OneProcessor", "\n", "", "elif", "processor", "==", "'zero_processor'", ":", "\n", "        ", "return", "one_processor", ".", "ZeroProcessor", "\n", "", "elif", "processor", "==", "'vad_timings_processor'", ":", "\n", "        ", "return", "vad_timings_processor", ".", "VadTimingsProcessor", "\n", "", "elif", "processor", "==", "'vad_timings_samples_processor'", ":", "\n", "        ", "return", "vad_timings_processor", ".", "VadTimings2SamplesProcessor", "\n", "", "elif", "processor", "==", "'index_processor'", ":", "\n", "        ", "return", "index_processor", ".", "indexProcessor", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'unknown processor type: %s'", "%", "processor", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_processor.IdealRatioProcessor.__init__": [[16, 42], ["ideal_ratio_processor.IdealRatioProcessor.comp.get_dim", "processor.Processor.__init__", "print", "Exception", "Exception", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"IdealRatioProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: IdealRatioProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "if", "'pow'", "not", "in", "conf", "[", "'feature'", "]", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'expecting feature to be in power domain'", ")", "\n", "\n", "", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "IdealRatioProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n", "print", "(", "'WARNING: untested script'", ")", "\n", "raise", "Exception", "(", "\n", "'Speaker signals are summed before energy is calculated. This is wrong. '", "\n", "'Look at ideal_ratio_multimic_processor.py'", ")", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_processor.IdealRatioProcessor.__call__": [[44, 83], ["dict", "dataline.strip().split", "range", "ideal_ratio_processor.IdealRatioProcessor.comp", "ideal_ratio_processor._read_wav", "ideal_ratio_processor.IdealRatioProcessor.comp", "numpy.sqrt", "ideal_ratio_processor.IdealRatioProcessor.segment_data", "len", "ideal_ratio_processor._read_wav", "dataline.strip", "Exception", "len", "len", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented info on bins to be used for scoring as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "nrS", "=", "len", "(", "splitdatalines", ")", "-", "1", "\n", "speaker_rate", "=", "None", "\n", "speaker_utt", "=", "None", "\n", "# Add speaker signals", "\n", "for", "s", "in", "range", "(", "nrS", ")", ":", "\n", "\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdatalines", "[", "s", "]", ")", "\n", "if", "speaker_rate", "is", "None", ":", "\n", "\t\t\t\t", "speaker_rate", "=", "rate", "\n", "speaker_utt", "=", "utt", "\n", "", "else", ":", "\n", "\t\t\t\t", "if", "speaker_rate", "!=", "rate", ":", "\n", "\t\t\t\t\t", "raise", "Exception", "(", "'Unequal sampling rates!'", ")", "\n", "", "if", "len", "(", "speaker_utt", ")", "!=", "len", "(", "utt", ")", ":", "\n", "\t\t\t\t\t", "raise", "Exception", "(", "'Unequal length'", ")", "\n", "", "speaker_utt", "=", "speaker_utt", "+", "utt", "\n", "", "", "speaker_features", "=", "self", ".", "comp", "(", "speaker_utt", ",", "speaker_rate", ")", "\n", "\n", "ref_rate", ",", "ref_utt", "=", "_read_wav", "(", "splitdatalines", "[", "-", "1", "]", ")", "\n", "ref_features", "=", "self", ".", "comp", "(", "ref_utt", ",", "ref_rate", ")", "\n", "\n", "# calculate ideal ratio mask", "\n", "targets", "=", "speaker_features", "/", "(", "speaker_features", "+", "ref_features", "+", "1e-48", ")", "\n", "targets", "=", "np", ".", "sqrt", "(", "targets", ")", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "targets", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_processor.IdealRatioProcessor.write_metadata": [[84, 96], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_processor._read_wav": [[98, 132], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "ideal_ratio_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tread a wav file\n\n\t\tArgs:\n\t\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\t- the sampling rate\n\t\t\t- the utterance as a numpy array\n\t\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.strlabel2index_processor.Strlabel2indexProcessor.__init__": [[19, 39], ["int", "dict", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"Strlabel2indexProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: Strlabel2indexProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments. \n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# create the string label to index dictionary", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "self", ".", "label2index", "=", "dict", "(", ")", "\n", "self", ".", "next_index", "=", "0", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "super", "(", "Strlabel2indexProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.strlabel2index_processor.Strlabel2indexProcessor.__call__": [[40, 74], ["dict", "dataline.split", "strlabel2index_processor._read_wav", "strlabel2index_processor.Strlabel2indexProcessor.comp", "strlabel2index_processor.Strlabel2indexProcessor.segment_data", "index_labels.append", "numpy.shape", "strlabel2index_processor.Strlabel2indexProcessor.label2index.keys"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: contains the audio mixture, the speaker labels and genders. Eg for 3 speakers:\n\t\t\tfilename.wav 001 M 002 F 003 M\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented features as a list of indices per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "split_dataline", "=", "dataline", ".", "split", "(", "' '", ")", "\n", "audiofile", "=", "split_dataline", "[", "0", "]", "\n", "string_labels", "=", "split_dataline", "[", "1", ":", ":", "2", "]", "\n", "\n", "utt_info", "[", "'nrS'", "]", "=", "self", ".", "nrS", "\n", "index_labels", "=", "[", "]", "\n", "for", "str_label", "in", "string_labels", ":", "\n", "\t\t\t", "if", "str_label", "not", "in", "self", ".", "label2index", ".", "keys", "(", ")", ":", "\n", "\t\t\t\t", "self", ".", "label2index", "[", "str_label", "]", "=", "self", ".", "next_index", "\n", "self", ".", "next_index", "+=", "1", "\n", "\n", "", "index_labels", ".", "append", "(", "self", ".", "label2index", "[", "str_label", "]", ")", "\n", "\n", "# get the number of frames from the mixture audiofile", "\n", "", "rate", ",", "utt", "=", "_read_wav", "(", "audiofile", ")", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "Nfram", "=", "np", ".", "shape", "(", "features", ")", "[", "0", "]", "\n", "\n", "# split the data for all desired segment lengths", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "index_labels", ",", "Nfram", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.strlabel2index_processor.Strlabel2indexProcessor.pre_loop": [[75, 88], ["os.path.join", "len", "open", "json.load", "os.path.join"], "methods", ["None"], ["", "def", "pre_loop", "(", "self", ",", "dataconf", ")", ":", "\n", "\t\t", "\"\"\"before looping over all the data to process and store it, see if there is\n\t\ta label2index dictionary already available and load it. Otherwise start from\n\t\tan empty dictionary as defined in __init__\n\n\t\tArgs:\n\t\t\tdataconf: config file on the part of the database being processed\"\"\"", "\n", "\n", "if", "'label2index_dir'", "in", "dataconf", "and", "dataconf", "[", "'label2index_dir'", "]", "!=", "dataconf", "[", "'store_dir'", "]", ":", "\n", "\t\t\t", "tmp_dir", "=", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'label2index_dir'", "]", ",", "'full'", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "'label2index.json'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t", "self", ".", "label2index", "=", "json", ".", "load", "(", "fid", ")", "\n", "", "self", ".", "next_index", "=", "len", "(", "self", ".", "label2index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.strlabel2index_processor.Strlabel2indexProcessor.write_metadata": [[89, 104], ["enumerate", "os.path.join", "open", "json.dump", "open", "fid.write", "open", "fid.write", "os.path.join", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'label2index.json'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "json", ".", "dump", "(", "self", ".", "label2index", ",", "fid", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'totnrS'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "next_index", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nrS'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nrS", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.strlabel2index_processor.Strlabel2indexProcessor.segment_data": [[105, 137], ["dict", "int", "int", "numpy.floor", "range", "seg_data.append", "float", "float"], "methods", ["None"], ["", "", "", "def", "segment_data", "(", "self", ",", "data", ",", "N", ")", ":", "\n", "\t\t", "\"\"\"Usually data is segmented by splitting an utterance into different parts\n\t\t(see processor.py). For this processor, we just replicate the label index\n\t\tmultiple times.\n\n\t\tArgs:\n\t\t\tdata: the data to be split\n\t\t\tN: the the number of frames. To seen how many segments are required\n\n\t\tReturns:\n\t\t\tthe segmented data\n\t\t\"\"\"", "\n", "\n", "segmented_data", "=", "dict", "(", ")", "\n", "\n", "for", "seg_length", "in", "self", ".", "segment_lengths", ":", "\n", "\t\t\t", "if", "seg_length", "==", "'full'", ":", "\n", "\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "seg_len", "=", "int", "(", "seg_length", ")", "\n", "Nseg", "=", "int", "(", "np", ".", "floor", "(", "float", "(", "N", ")", "/", "float", "(", "seg_len", ")", ")", ")", "\n", "\n", "if", "Nseg", "==", "0", ":", "\n", "\t\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "seg_data", "=", "[", "]", "\n", "for", "seg_ind", "in", "range", "(", "Nseg", ")", ":", "\n", "\t\t\t\t\t\t", "seg_data", ".", "append", "(", "data", ")", "\n", "\n", "", "", "", "segmented_data", "[", "seg_length", "]", "=", "seg_data", "\n", "\n", "", "return", "segmented_data", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.strlabel2index_processor._read_wav": [[139, 173], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "strlabel2index_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2VectorProcessor.__init__": [[17, 48], ["int", "int", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory", "numpy.zeros", "numpy.zeros", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"Matrix2VectorProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: Matrix2VectorProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# the number of rows in the matrix", "\n", "self", ".", "nrCol", "=", "int", "(", "conf", "[", "'nrcol'", "]", ")", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "self", ".", "dim", "=", "self", ".", "nrS", "*", "self", ".", "nrCol", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# set the type of mean and variance normalisation", "\n", "self", ".", "mvn_type", "=", "conf", "[", "'mvn_type'", "]", "\n", "if", "conf", "[", "'mvn_type'", "]", "==", "'global'", ":", "\n", "\t\t\t", "self", ".", "obs_cnt", "=", "0", "\n", "self", ".", "glob_mean", "=", "np", ".", "zeros", "(", "[", "self", ".", "dim", "]", ")", "\n", "self", ".", "glob_std", "=", "np", ".", "zeros", "(", "[", "self", ".", "dim", "]", ")", "\n", "", "elif", "conf", "[", "'mvn_type'", "]", "==", "'None'", ":", "\n", "\t\t\t", "pass", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Unknown way to apply mvn: %s'", "%", "conf", "[", "'mvn_type'", "]", ")", "\n", "\n", "", "super", "(", "Matrix2VectorProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2VectorProcessor.__call__": [[49, 83], ["dict", "dataline.split", "open().read().strip().split", "numpy.zeros", "enumerate", "matrix2vector_processor._read_wav", "matrix2vector_processor.Matrix2VectorProcessor.comp", "matrix2vector_processor.Matrix2VectorProcessor.segment_data", "map", "numpy.shape", "open().read().strip", "matrix_row.strip().split", "open().read", "matrix_row.strip", "open"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: contains the audio mixture, and the matrix file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented features as a list of a vector per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "split_dataline", "=", "dataline", ".", "split", "(", "' '", ")", "\n", "audiofile", "=", "split_dataline", "[", "0", "]", "\n", "matrixfile", "=", "split_dataline", "[", "1", "]", "\n", "\n", "matrix", "=", "open", "(", "matrixfile", ")", ".", "read", "(", ")", ".", "strip", "(", ")", ".", "split", "(", "','", ")", "\n", "utt_info", "[", "'nrS'", "]", "=", "self", ".", "nrS", "\n", "vector", "=", "np", ".", "zeros", "(", "self", ".", "dim", ")", "\n", "for", "ind", ",", "matrix_row", "in", "enumerate", "(", "matrix", ")", ":", "\n", "\t\t\t", "vector", "[", "ind", "*", "self", ".", "nrCol", ":", "(", "ind", "+", "1", ")", "*", "self", ".", "nrCol", "]", "=", "map", "(", "float", ",", "matrix_row", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", ")", "\n", "\n", "# mean and variance normalize the features", "\n", "", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "vector", "=", "(", "vector", "-", "self", ".", "glob_mean", ")", "/", "self", ".", "glob_std", "\n", "\n", "# get the number of frames from the mixture audiofile", "\n", "", "rate", ",", "utt", "=", "_read_wav", "(", "audiofile", ")", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "Nfram", "=", "np", ".", "shape", "(", "features", ")", "[", "0", "]", "\n", "\n", "# split the data for all desired segment lengths", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "vector", ",", "Nfram", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2VectorProcessor.pre_loop": [[84, 141], ["dataconf[].split", "open_fn", "line.strip().split", "open().read().strip().split", "numpy.zeros", "enumerate", "float", "open", "numpy.save", "numpy.sqrt", "open", "numpy.load", "map", "os.path.join", "open", "numpy.save", "os.path.join", "open", "numpy.load", "line.strip", "open().read().strip", "matrix_row.strip().split", "numpy.square", "float", "os.path.join", "os.path.join", "open().read", "matrix_row.strip", "open"], "methods", ["None"], ["", "def", "pre_loop", "(", "self", ",", "dataconf", ")", ":", "\n", "\t\t", "\"\"\"before looping over all the data to process and store it, calculate the\n\t\tglobal mean and variance to normalize the features later on\n\n\t\tArgs:\n\t\tdataconf: config file on the part of the database being processed\"\"\"", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "loop_types", "=", "[", "'mean'", ",", "'std'", "]", "\n", "\n", "# calculate the mean and variance", "\n", "for", "loop_type", "in", "loop_types", ":", "\n", "\n", "# if the directory of mean and variance are pointing to the store directory,", "\n", "# this means that the mean and variance should be calculated here.", "\n", "\t\t\t\t", "if", "dataconf", "[", "'meanandvar_dir'", "]", "==", "dataconf", "[", "'store_dir'", "]", ":", "\n", "# raise BaseException('Mean and variance are defined as a nrS*nrCol vector, should just be a nrCol vector')", "\n", "\n", "\t\t\t\t\t", "for", "datafile", "in", "dataconf", "[", "'datafiles'", "]", ".", "split", "(", "' '", ")", ":", "\n", "\t\t\t\t\t\t", "if", "datafile", "[", "-", "3", ":", "]", "==", "'.gz'", ":", "\n", "\t\t\t\t\t\t\t", "open_fn", "=", "gzip", ".", "open", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "open_fn", "=", "open", "\n", "\n", "# loop over the lines in the datafile", "\n", "", "for", "line", "in", "open_fn", "(", "datafile", ")", ":", "\n", "# split the name and the data line", "\n", "\t\t\t\t\t\t\t", "split_dataline", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "matrixfile", "=", "split_dataline", "[", "-", "1", "]", "\n", "\n", "matrix", "=", "open", "(", "matrixfile", ")", ".", "read", "(", ")", ".", "strip", "(", ")", ".", "split", "(", "','", ")", "\n", "vector", "=", "np", ".", "zeros", "(", "self", ".", "dim", ")", "\n", "for", "ind", ",", "matrix_row", "in", "enumerate", "(", "matrix", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "vector", "[", "ind", "*", "self", ".", "nrCol", ":", "(", "ind", "+", "1", ")", "*", "self", ".", "nrCol", "]", "=", "map", "(", "float", ",", "matrix_row", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", ")", "\n", "\n", "# process the dataline", "\n", "", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "glob_mean", "+=", "vector", "\n", "self", ".", "obs_cnt", "+=", "1", "\n", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "glob_std", "+=", "np", ".", "square", "(", "vector", "-", "self", ".", "glob_mean", ")", "\n", "\n", "", "", "", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t", "self", ".", "glob_mean", "=", "self", ".", "glob_mean", "/", "float", "(", "self", ".", "obs_cnt", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_mean.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_mean", ")", "\n", "", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t", "self", ".", "glob_std", "=", "np", ".", "sqrt", "(", "self", ".", "glob_std", "/", "float", "(", "self", ".", "obs_cnt", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_std.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_std", ")", "\n", "", "", "", "else", ":", "\n", "# get mean and variance calculated on training set", "\n", "\t\t\t\t\t", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_mean.npy'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "self", ".", "glob_mean", "=", "np", ".", "load", "(", "fid", ")", "\n", "", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_std.npy'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "self", ".", "glob_std", "=", "np", ".", "load", "(", "fid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2VectorProcessor.write_metadata": [[142, 158], ["enumerate", "os.path.join", "open", "numpy.save", "open", "numpy.save", "open", "fid.write", "os.path.join", "os.path.join", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "", "", "", "", "", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "datadir", ",", "'glob_mean.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_mean", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "datadir", ",", "'glob_std.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_std", ")", "\n", "\n", "", "", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2VectorProcessor.segment_data": [[159, 191], ["dict", "int", "int", "numpy.floor", "range", "seg_data.append", "float", "float"], "methods", ["None"], ["", "", "", "def", "segment_data", "(", "self", ",", "data", ",", "N", ")", ":", "\n", "\t\t", "\"\"\"Usually data is segmented by splitting an utterance into different parts\n\t\t(see processor.py). For this processor, we just replicate the vector\n\t\tmultiple times.\n\n\t\tArgs:\n\t\t\tdata: the data to be split\n\t\t\tN: the the number of frames. To seen how many segments are required\n\n\t\tReturns:\n\t\t\tthe segmented data\n\t\t\"\"\"", "\n", "\n", "segmented_data", "=", "dict", "(", ")", "\n", "\n", "for", "seg_length", "in", "self", ".", "segment_lengths", ":", "\n", "\t\t\t", "if", "seg_length", "==", "'full'", ":", "\n", "\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "seg_len", "=", "int", "(", "seg_length", ")", "\n", "Nseg", "=", "int", "(", "np", ".", "floor", "(", "float", "(", "N", ")", "/", "float", "(", "seg_len", ")", ")", ")", "\n", "\n", "if", "Nseg", "==", "0", ":", "\n", "\t\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "seg_data", "=", "[", "]", "\n", "for", "seg_ind", "in", "range", "(", "Nseg", ")", ":", "\n", "\t\t\t\t\t\t", "seg_data", ".", "append", "(", "data", ")", "\n", "\n", "", "", "", "segmented_data", "[", "seg_length", "]", "=", "seg_data", "\n", "\n", "", "return", "segmented_data", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.__init__": [[196, 225], ["int", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory", "numpy.zeros", "numpy.zeros", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"Matrix2MatrixProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: Matrix2MatrixProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# the number of rows in the matrix", "\n", "self", ".", "nrCol", "=", "int", "(", "conf", "[", "'nrcol'", "]", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# set the type of mean and variance normalisation", "\n", "self", ".", "mvn_type", "=", "conf", "[", "'mvn_type'", "]", "\n", "if", "conf", "[", "'mvn_type'", "]", "==", "'global'", ":", "\n", "\t\t\t", "self", ".", "obs_cnt", "=", "0", "\n", "self", ".", "glob_mean", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrCol", "]", ")", "\n", "self", ".", "glob_std", "=", "np", ".", "zeros", "(", "[", "self", ".", "nrCol", "]", ")", "\n", "", "elif", "conf", "[", "'mvn_type'", "]", "==", "'None'", ":", "\n", "\t\t\t", "pass", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Unknown way to apply mvn: %s'", "%", "conf", "[", "'mvn_type'", "]", ")", "\n", "\n", "", "super", "(", "Matrix2MatrixProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.__call__": [[226, 261], ["dict", "dataline.split", "open().read().strip().split", "len", "numpy.zeros", "enumerate", "matrix2vector_processor._read_wav", "matrix2vector_processor.Matrix2MatrixProcessor.comp", "matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "map", "numpy.shape", "open().read().strip", "matrix_row.strip().split", "numpy.expand_dims", "numpy.expand_dims", "open().read", "matrix_row.strip", "open"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: contains the audio mixture, and the matrix file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented features as a list of a vector per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "split_dataline", "=", "dataline", ".", "split", "(", "' '", ")", "\n", "audiofile", "=", "split_dataline", "[", "0", "]", "\n", "matrixfile", "=", "split_dataline", "[", "1", "]", "\n", "\n", "matrix", "=", "open", "(", "matrixfile", ")", ".", "read", "(", ")", ".", "strip", "(", ")", ".", "split", "(", "','", ")", "\n", "nrRow", "=", "len", "(", "matrix", ")", "\n", "utt_info", "[", "'nrS'", "]", "=", "nrRow", "\n", "new_matrix", "=", "np", ".", "zeros", "(", "[", "nrRow", ",", "self", ".", "nrCol", "]", ")", "\n", "for", "ind", ",", "matrix_row", "in", "enumerate", "(", "matrix", ")", ":", "\n", "\t\t\t", "new_matrix", "[", "ind", "]", "=", "map", "(", "float", ",", "matrix_row", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", ")", "\n", "\n", "# mean and variance normalize the features", "\n", "", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "new_matrix", "=", "(", "new_matrix", "-", "np", ".", "expand_dims", "(", "self", ".", "glob_mean", ",", "0", ")", ")", "/", "np", ".", "expand_dims", "(", "self", ".", "glob_std", ",", "0", ")", "\n", "\n", "# get the number of frames from the mixture audiofile", "\n", "", "rate", ",", "utt", "=", "_read_wav", "(", "audiofile", ")", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "Nfram", "=", "np", ".", "shape", "(", "features", ")", "[", "0", "]", "\n", "\n", "# split the data for all desired segment lengths", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "new_matrix", ",", "Nfram", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.pre_loop": [[262, 319], ["dataconf[].split", "open_fn", "line.strip().split", "open().read().strip().split", "len", "numpy.zeros", "enumerate", "float", "numpy.sqrt", "open", "numpy.load", "numpy.sum", "os.path.join", "open", "numpy.load", "line.strip", "open().read().strip", "map", "numpy.sum", "float", "os.path.join", "matrix_row.strip().split", "numpy.square", "open().read", "matrix_row.strip", "numpy.expand_dims", "open"], "methods", ["None"], ["", "def", "pre_loop", "(", "self", ",", "dataconf", ")", ":", "\n", "\t\t", "\"\"\"before looping over all the data to process and store it, calculate the\n\t\tglobal mean and variance to normalize the features later on\n\n\t\tArgs:\n\t\tdataconf: config file on the part of the database being processed\"\"\"", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "loop_types", "=", "[", "'mean'", ",", "'std'", "]", "\n", "\n", "# calculate the mean and variance", "\n", "for", "loop_type", "in", "loop_types", ":", "\n", "\n", "# if the directory of mean and variance are pointing to the store directory,", "\n", "# this means that the mean and variance should be calculated here.", "\n", "\t\t\t\t", "if", "dataconf", "[", "'meanandvar_dir'", "]", "==", "dataconf", "[", "'store_dir'", "]", ":", "\n", "\n", "\t\t\t\t\t", "for", "datafile", "in", "dataconf", "[", "'datafiles'", "]", ".", "split", "(", "' '", ")", ":", "\n", "\t\t\t\t\t\t", "if", "datafile", "[", "-", "3", ":", "]", "==", "'.gz'", ":", "\n", "\t\t\t\t\t\t\t", "open_fn", "=", "gzip", ".", "open", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "open_fn", "=", "open", "\n", "\n", "# loop over the lines in the datafile", "\n", "", "for", "line", "in", "open_fn", "(", "datafile", ")", ":", "\n", "# split the name and the data line", "\n", "\t\t\t\t\t\t\t", "split_dataline", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "matrixfile", "=", "split_dataline", "[", "2", "]", "\n", "\n", "matrix", "=", "open", "(", "matrixfile", ")", ".", "read", "(", ")", ".", "strip", "(", ")", ".", "split", "(", "','", ")", "\n", "nrRow", "=", "len", "(", "matrix", ")", "\n", "new_matrix", "=", "np", ".", "zeros", "(", "[", "nrRow", ",", "self", ".", "nrCol", "]", ")", "\n", "for", "ind", ",", "matrix_row", "in", "enumerate", "(", "matrix", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "try", ":", "\n", "\t\t\t\t\t\t\t\t\t", "new_matrix", "[", "ind", "]", "=", "map", "(", "float", ",", "matrix_row", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", ")", "\n", "", "except", ":", "\n", "\t\t\t\t\t\t\t\t\t", "jer", "=", "1", "\n", "\n", "\n", "# process the dataline", "\n", "", "", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "glob_mean", "+=", "np", ".", "sum", "(", "new_matrix", ",", "0", ")", "\n", "self", ".", "obs_cnt", "+=", "nrRow", "\n", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "glob_std", "+=", "np", ".", "sum", "(", "np", ".", "square", "(", "new_matrix", "-", "np", ".", "expand_dims", "(", "self", ".", "glob_mean", ",", "0", ")", ")", ",", "0", ")", "\n", "\n", "", "", "", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t", "self", ".", "glob_mean", "=", "self", ".", "glob_mean", "/", "float", "(", "self", ".", "obs_cnt", ")", "\n", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t", "self", ".", "glob_std", "=", "np", ".", "sqrt", "(", "self", ".", "glob_std", "/", "float", "(", "self", ".", "obs_cnt", ")", ")", "\n", "", "", "else", ":", "\n", "# get mean and variance calculated on training set", "\n", "\t\t\t\t\t", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_mean.npy'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "self", ".", "glob_mean", "=", "np", ".", "load", "(", "fid", ")", "\n", "", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_std.npy'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "self", ".", "glob_std", "=", "np", ".", "load", "(", "fid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.write_metadata": [[320, 336], ["enumerate", "os.path.join", "open", "numpy.save", "open", "numpy.save", "open", "fid.write", "os.path.join", "os.path.join", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "", "", "", "", "", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "datadir", ",", "'glob_mean.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_mean", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "datadir", ",", "'glob_std.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_std", ")", "\n", "\n", "", "", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nrCol", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data": [[337, 369], ["dict", "int", "int", "numpy.floor", "range", "seg_data.append", "float", "float"], "methods", ["None"], ["", "", "", "def", "segment_data", "(", "self", ",", "data", ",", "N", ")", ":", "\n", "\t\t", "\"\"\"Usually data is segmented by splitting an utterance into different parts\n\t\t(see processor.py). For this processor, we just replicate the vector\n\t\tmultiple times.\n\n\t\tArgs:\n\t\t\tdata: the data to be split\n\t\t\tN: the the number of frames. To seen how many segments are required\n\n\t\tReturns:\n\t\t\tthe segmented data\n\t\t\"\"\"", "\n", "\n", "segmented_data", "=", "dict", "(", ")", "\n", "\n", "for", "seg_length", "in", "self", ".", "segment_lengths", ":", "\n", "\t\t\t", "if", "seg_length", "==", "'full'", ":", "\n", "\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "seg_len", "=", "int", "(", "seg_length", ")", "\n", "Nseg", "=", "int", "(", "np", ".", "floor", "(", "float", "(", "N", ")", "/", "float", "(", "seg_len", ")", ")", ")", "\n", "\n", "if", "Nseg", "==", "0", ":", "\n", "\t\t\t\t\t", "seg_data", "=", "[", "data", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "seg_data", "=", "[", "]", "\n", "for", "seg_ind", "in", "range", "(", "Nseg", ")", ":", "\n", "\t\t\t\t\t\t", "seg_data", ".", "append", "(", "data", ")", "\n", "\n", "", "", "", "segmented_data", "[", "seg_length", "]", "=", "seg_data", "\n", "\n", "", "return", "segmented_data", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor._read_wav": [[371, 405], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "matrix2vector_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.__init__": [[18, 51], ["multi_target_processor.MultiTargetProcessor.comp.get_dim", "int", "multi_target_processor.MultiTargetProcessor.comp.get_dim", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory", "numpy.zeros", "numpy.zeros", "Exception"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"MultiTargetProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: MultiTargetProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments. \n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "# initialize the metadata", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "self", ".", "target_dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "target_dim", ",", "self", ".", "nrS", "]", "\n", "\n", "if", "'mvn_type'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "mvn_type", "=", "conf", "[", "'mvn_type'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "mvn_type", "=", "'None'", "\n", "", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "self", ".", "obs_cnt", "=", "0", "\n", "self", ".", "glob_mean", "=", "np", ".", "zeros", "(", "[", "1", ",", "self", ".", "dim", "]", ")", "\n", "self", ".", "glob_std", "=", "np", ".", "zeros", "(", "[", "1", ",", "self", ".", "dim", "]", ")", "\n", "", "elif", "self", ".", "mvn_type", "in", "[", "'local'", ",", "'none'", ",", "'None'", ",", "'from_files'", "]", ":", "\n", "\t\t\t", "pass", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'Unknown way to apply mvn: %s'", "%", "conf", "[", "'mvn_type'", "]", ")", "\n", "\n", "", "super", "(", "MultiTargetProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.__call__": [[52, 91], ["dict", "dataline.strip().split", "multi_target_processor.MultiTargetProcessor.segment_data", "multi_target_processor._read_wav", "multi_target_processor.MultiTargetProcessor.comp", "numpy.expand_dims", "dataline.strip", "numpy.append", "numpy.mean", "numpy.std"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented targets as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "targets", "=", "None", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "# read the wav file", "\n", "\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "# mean and variance normalize the features", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t\t", "features", "=", "(", "features", "-", "self", ".", "glob_mean", ")", "/", "(", "self", ".", "glob_std", "+", "1e-12", ")", "\n", "", "elif", "self", ".", "mvn_type", "==", "'local'", ":", "\n", "\t\t\t\t", "features", "=", "(", "features", "-", "np", ".", "mean", "(", "features", ",", "0", ")", ")", "/", "(", "np", ".", "std", "(", "features", ",", "0", ")", "+", "1e-12", ")", "\n", "\n", "", "features", "=", "np", ".", "expand_dims", "(", "features", ",", "2", ")", "\n", "\n", "if", "targets", "is", "None", ":", "\n", "\t\t\t\t", "targets", "=", "features", "\n", "", "else", ":", "\n", "\t\t\t\t", "targets", "=", "np", ".", "append", "(", "targets", ",", "features", ",", "2", ")", "\n", "\n", "# split the data for all desired segment lengths", "\n", "", "", "segmented_data", "=", "self", ".", "segment_data", "(", "targets", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.pre_loop": [[92, 144], ["dataconf[].split", "open_fn", "line.strip().split", "float", "open", "numpy.save", "numpy.sqrt", "open", "numpy.load", "os.path.join", "open", "numpy.save", "os.path.join", "open", "numpy.load", "line.strip", "multi_target_processor.MultiTargetProcessor.acc_mean", "float", "os.path.join", "os.path.join", "multi_target_processor.MultiTargetProcessor.acc_std"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.acc_mean", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.acc_std"], ["", "def", "pre_loop", "(", "self", ",", "dataconf", ")", ":", "\n", "\t\t", "\"\"\"before looping over all the data to process and store it, calculate the\n\t\tglobal mean and variance to normalize the features later on\n\n\t\tArgs:\n\t\t\tdataconf: config file on the part of the database being processed\"\"\"", "\n", "if", "self", ".", "mvn_type", "==", "'global'", ":", "\n", "\t\t\t", "loop_types", "=", "[", "'mean'", ",", "'std'", "]", "\n", "\n", "# calculate the mean and variance", "\n", "for", "loop_type", "in", "loop_types", ":", "\n", "# if the directory of mean and variance are pointing to the store directory,", "\n", "# this means that the mean and variance should be calculated here.", "\n", "\t\t\t\t", "if", "dataconf", "[", "'meanandvar_dir'", "]", "==", "dataconf", "[", "'store_dir'", "]", ":", "\n", "\t\t\t\t\t", "for", "datafile", "in", "dataconf", "[", "'datafiles'", "]", ".", "split", "(", "' '", ")", ":", "\n", "\t\t\t\t\t\t", "if", "datafile", "[", "-", "3", ":", "]", "==", "'.gz'", ":", "\n", "\t\t\t\t\t\t\t", "open_fn", "=", "gzip", ".", "open", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "open_fn", "=", "open", "\n", "\n", "# loop over the lines in the datafile", "\n", "", "for", "line", "in", "open_fn", "(", "datafile", ")", ":", "\n", "\n", "# split the name and the data line", "\n", "\t\t\t\t\t\t\t", "splitline", "=", "line", ".", "strip", "(", "'\\n'", ")", ".", "split", "(", "' '", ")", "\n", "utt_name", "=", "splitline", "[", "0", "]", "\n", "splitdatalines", "=", "splitline", "[", "1", ":", "]", "\n", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "# process the dataline", "\n", "\t\t\t\t\t\t\t\t", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t\t\t\t", "self", ".", "acc_mean", "(", "splitdataline", ")", "\n", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t\t\t\t", "self", ".", "acc_std", "(", "splitdataline", ")", "\n", "\n", "", "", "", "", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t", "self", ".", "glob_mean", "=", "self", ".", "glob_mean", "/", "float", "(", "self", ".", "obs_cnt", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_mean.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_mean", ")", "\n", "", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t", "self", ".", "glob_std", "=", "np", ".", "sqrt", "(", "self", ".", "glob_std", "/", "float", "(", "self", ".", "obs_cnt", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_std.npy'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "np", ".", "save", "(", "fid", ",", "self", ".", "glob_std", ")", "\n", "\n", "", "", "", "else", ":", "\n", "# get mean and variance calculated on training set", "\n", "\t\t\t\t\t", "if", "loop_type", "==", "'mean'", ":", "\n", "\t\t\t\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_mean.npy'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "self", ".", "glob_mean", "=", "np", ".", "load", "(", "fid", ")", "\n", "", "", "elif", "loop_type", "==", "'std'", ":", "\n", "\t\t\t\t\t\t", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dataconf", "[", "'meanandvar_dir'", "]", ",", "'glob_std.npy'", ")", ")", "as", "fid", ":", "\n", "\t\t\t\t\t\t\t", "self", ".", "glob_std", "=", "np", ".", "load", "(", "fid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.acc_mean": [[145, 163], ["multi_target_processor._read_wav", "multi_target_processor.MultiTargetProcessor.comp", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "", "", "def", "acc_mean", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"accumulate the features to get the mean\n\t\tArgs:\n\t\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\t\tan audio file\"\"\"", "\n", "\n", "# read the wav file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "dataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "# accumulate the features", "\n", "acc_feat", "=", "np", ".", "sum", "(", "features", ",", "0", ")", "\n", "\n", "# update the mean and observation count", "\n", "self", ".", "glob_mean", "+=", "acc_feat", "\n", "self", ".", "obs_cnt", "+=", "features", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.acc_std": [[164, 181], ["multi_target_processor._read_wav", "multi_target_processor.MultiTargetProcessor.comp", "numpy.sum", "numpy.square"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "acc_std", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"accumulate the features to get the standard deviation\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\"\"\"", "\n", "\n", "# read the wav file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "dataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "# accumulate the features", "\n", "acc_feat", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "features", "-", "self", ".", "glob_mean", ")", ",", "0", ")", "\n", "\n", "# update the standard deviation", "\n", "self", ".", "glob_std", "+=", "acc_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor.MultiTargetProcessor.write_metadata": [[182, 196], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nrS'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nrS", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "target_dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.multi_target_processor._read_wav": [[198, 232], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "multi_target_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.onehotperfeature_target_processor.onehotperfeatureTargetProcessor.__init__": [[17, 41], ["int", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory", "map", "range", "onehotperfeature_target_processor.onehotperfeatureTargetProcessor.comp.get_dim", "len", "conf[].split"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"onehotperfeatureTargetProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: onehotperfeatureTargetProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "nrS", "=", "int", "(", "conf", "[", "'nrs'", "]", ")", "\n", "if", "'spk_select'", "in", "conf", ":", "\n", "\t\t\t", "self", ".", "nrS_select", "=", "map", "(", "int", ",", "conf", "[", "'spk_select'", "]", ".", "split", "(", "' '", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "nrS_select", "=", "range", "(", "0", ",", "self", ".", "nrS", ")", "\n", "", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "*", "len", "(", "self", ".", "nrS_select", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "onehotperfeatureTargetProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.onehotperfeature_target_processor.onehotperfeatureTargetProcessor.__call__": [[42, 79], ["dict", "dataline.strip().split", "numpy.argmax", "numpy.empty", "enumerate", "onehotperfeature_target_processor.onehotperfeatureTargetProcessor.segment_data", "onehotperfeature_target_processor._read_wav", "onehotperfeature_target_processor.onehotperfeatureTargetProcessor.comp", "numpy.expand_dims", "dataline.strip", "numpy.append", "len"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented targets as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "clean_features", "=", "None", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "# read the wav file", "\n", "\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "features", "=", "np", ".", "expand_dims", "(", "features", ",", "2", ")", "\n", "\n", "if", "clean_features", "is", "None", ":", "\n", "\t\t\t\t", "clean_features", "=", "features", "\n", "", "else", ":", "\n", "\t\t\t\t", "clean_features", "=", "np", ".", "append", "(", "clean_features", ",", "features", ",", "2", ")", "\n", "\n", "", "", "winner", "=", "np", ".", "argmax", "(", "clean_features", ",", "axis", "=", "2", ")", "\n", "targets", "=", "np", ".", "empty", "(", "[", "features", ".", "shape", "[", "0", "]", ",", "self", ".", "dim", "]", ",", "dtype", "=", "bool", ")", "\n", "for", "s_ind", ",", "spk_id", "in", "enumerate", "(", "self", ".", "nrS_select", ")", ":", "\n", "\t\t\t", "targets", "[", ":", ",", "s_ind", ":", ":", "len", "(", "self", ".", "nrS_select", ")", "]", "=", "winner", "==", "spk_id", "\n", "\n", "# split the data for all desired segment lengths", "\n", "", "segmented_data", "=", "self", ".", "segment_data", "(", "targets", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.onehotperfeature_target_processor.onehotperfeatureTargetProcessor.write_metadata": [[80, 94], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nrS'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nrS_select", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.onehotperfeature_target_processor._read_wav": [[96, 130], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "onehotperfeature_target_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t", "\"\"\"\n\tread a wav file\n\n\tArgs:\n\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\tan audio file\n\n\tReturns:\n\t\t- the sampling rate\n\t\t- the utterance as a numpy array\n\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.one_processor.OneProcessor.__init__": [[16, 34], ["one_processor.OneProcessor.comp.get_dim", "one_processor.OneProcessor.comp.get_dim", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "        ", "\"\"\"OneProcessor constructor\n\n        Args:\n            conf: ScorelabelperfeatureProcessor configuration as a dict of strings\n            segment_lengths: A list containing the desired lengths of segments.\n            Possibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "target_dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "target_dim", "]", "\n", "super", "(", "OneProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.one_processor.OneProcessor.__call__": [[35, 56], ["dict", "one_processor._read_wav", "one_processor.OneProcessor.comp", "numpy.ones", "one_processor.OneProcessor.segment_data", "numpy.shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "        ", "\"\"\"process the data in dataline\n        Args:\n            dataline: either a path to a wav file or a command to read and pipe\n                an audio file\n\n        Returns:\n            segmented_data: The segmented ones\n            utt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "dataline", ")", "\n", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "T", "=", "np", ".", "shape", "(", "features", ")", "[", "0", "]", "\n", "\n", "targets", "=", "np", ".", "ones", "(", "(", "T", ",", "self", ".", "dim", ")", ")", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "targets", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.one_processor.OneProcessor.write_metadata": [[57, 69], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "        ", "\"\"\"write the processor metadata to disk\n\n        Args:\n            datadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "            ", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "                ", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "                ", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.one_processor.ZeroProcessor.__init__": [[74, 92], ["one_processor.ZeroProcessor.comp.get_dim", "one_processor.ZeroProcessor.comp.get_dim", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "        ", "\"\"\"ZeroProcessor constructor\n\n        Args:\n            conf: ScorelabelperfeatureProcessor configuration as a dict of strings\n            segment_lengths: A list containing the desired lengths of segments.\n            Possibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "target_dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "target_dim", "]", "\n", "super", "(", "ZeroProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.one_processor.ZeroProcessor.__call__": [[93, 114], ["dict", "one_processor._read_wav", "one_processor.ZeroProcessor.comp", "numpy.zeros", "one_processor.ZeroProcessor.segment_data", "numpy.shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "        ", "\"\"\"process the data in dataline\n        Args:\n            dataline: either a path to a wav file or a command to read and pipe\n                an audio file\n\n        Returns:\n            segmented_data: The segmented zeros\n            utt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "dataline", ")", "\n", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "T", "=", "np", ".", "shape", "(", "features", ")", "[", "0", "]", "\n", "\n", "targets", "=", "np", ".", "zeros", "(", "(", "T", ",", "self", ".", "dim", ")", ")", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "targets", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.one_processor.ZeroProcessor.write_metadata": [[115, 127], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "        ", "\"\"\"write the processor metadata to disk\n\n        Args:\n            datadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "            ", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "                ", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "                ", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.one_processor._read_wav": [[129, 163], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "one_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "    ", "\"\"\"\n    read a wav file\n\n    Args:\n        wavfile: either a path to a wav file or a command to read and pipe\n            an audio file\n\n    Returns:\n        - the sampling rate\n        - the utterance as a numpy array\n    \"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "        ", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "        ", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "        ", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_multimic_processor.IdealRatioMultimicProcessor.__init__": [[17, 44], ["int", "ideal_ratio_multimic_processor.IdealRatioMultimicProcessor.comp.get_dim", "processor.Processor.__init__", "Exception", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "\t\t", "\"\"\"IdealRatioProcessor constructor\n\n\t\tArgs:\n\t\t\tconf: IdealRatioProcessor configuration as a dict of strings\n\t\t\tsegment_lengths: A list containing the desired lengths of segments.\n\t\t\tPossibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "if", "'pow'", "not", "in", "conf", "[", "'feature'", "]", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'expecting feature to be in power domain'", ")", "\n", "", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "if", "'apply_sqrt'", "in", "conf", "and", "conf", "[", "'apply_sqrt'", "]", "!=", "'True'", ":", "\n", "\t\t\t", "self", ".", "apply_sqrt", "=", "False", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "apply_sqrt", "=", "True", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "nr_channels", "=", "int", "(", "conf", "[", "'nr_channels'", "]", ")", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "IdealRatioMultimicProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_multimic_processor.IdealRatioMultimicProcessor.__call__": [[45, 113], ["dict", "dataline.strip().split", "range", "range", "numpy.mean", "ideal_ratio_multimic_processor.IdealRatioMultimicProcessor.segment_data", "range", "splitdatalines_per_src.append", "len", "numpy.mean", "ideal_ratio_multimic_processor._read_wav", "ideal_ratio_multimic_processor.IdealRatioMultimicProcessor.comp", "numpy.expand_dims", "numpy.sqrt", "dataline.strip", "len", "ideal_ratio_multimic_processor._read_wav", "ideal_ratio_multimic_processor.IdealRatioMultimicProcessor.comp", "numpy.expand_dims", "numpy.append", "numpy.append"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented info on bins to be used for scoring as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "splitdatalines_per_src", "=", "[", "]", "\n", "for", "src_ind", "in", "range", "(", "len", "(", "splitdatalines", ")", "/", "self", ".", "nr_channels", ")", ":", "\n", "\t\t\t", "inds", "=", "range", "(", "src_ind", "*", "self", ".", "nr_channels", ",", "(", "src_ind", "+", "1", ")", "*", "self", ".", "nr_channels", ")", "\n", "splitdatalines_per_src", ".", "append", "(", "[", "splitdatalines", "[", "ind", "]", "for", "ind", "in", "inds", "]", ")", "\n", "\n", "", "nr_spk", "=", "len", "(", "splitdatalines_per_src", ")", "-", "1", "\n", "\n", "speaker_features", "=", "None", "\n", "for", "spk_ind", "in", "range", "(", "nr_spk", ")", ":", "\n", "\t\t\t", "splitdatalines", "=", "splitdatalines_per_src", "[", "spk_ind", "]", "\n", "src_features", "=", "None", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "# read the wav file", "\n", "\t\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "features", "=", "np", ".", "expand_dims", "(", "features", ",", "2", ")", "\n", "\n", "if", "src_features", "is", "None", ":", "\n", "\t\t\t\t\t", "src_features", "=", "features", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "src_features", "=", "np", ".", "append", "(", "src_features", ",", "features", ",", "2", ")", "\n", "\n", "", "", "src_features_averaged", "=", "np", ".", "mean", "(", "src_features", ",", "2", ",", "keepdims", "=", "False", ")", "\n", "\n", "if", "speaker_features", "is", "None", ":", "\n", "\t\t\t\t", "speaker_features", "=", "src_features_averaged", "\n", "", "else", ":", "\n", "\t\t\t\t", "speaker_features", "+=", "src_features_averaged", "\n", "\n", "", "", "ref_features", "=", "None", "\n", "for", "splitdataline", "in", "splitdatalines_per_src", "[", "-", "1", "]", ":", "\n", "# read the wav file", "\n", "\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "features", "=", "np", ".", "expand_dims", "(", "features", ",", "2", ")", "\n", "\n", "if", "ref_features", "is", "None", ":", "\n", "\t\t\t\t", "ref_features", "=", "features", "\n", "", "else", ":", "\n", "\t\t\t\t", "ref_features", "=", "np", ".", "append", "(", "ref_features", ",", "features", ",", "2", ")", "\n", "\n", "", "", "ref_features_averaged", "=", "np", ".", "mean", "(", "ref_features", ",", "2", ",", "keepdims", "=", "False", ")", "\n", "\n", "# calculate ideal ratio mask", "\n", "targets", "=", "speaker_features", "/", "(", "speaker_features", "+", "ref_features_averaged", "+", "1e-48", ")", "\n", "if", "self", ".", "apply_sqrt", ":", "\n", "\t\t\t", "targets", "=", "np", ".", "sqrt", "(", "targets", ")", "\n", "", "segmented_data", "=", "self", ".", "segment_data", "(", "targets", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_multimic_processor.IdealRatioMultimicProcessor.write_metadata": [[114, 126], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "\t\t", "\"\"\"write the processor metadata to disk\n\n\t\tArgs:\n\t\t\tdatadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "\t\t\t", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "\t\t\t\t", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_multimic_processor.SnrMultimicProcessor.__call__": [[130, 197], ["dict", "dataline.strip().split", "range", "range", "numpy.mean", "ideal_ratio_multimic_processor.SnrMultimicProcessor.segment_data", "range", "splitdatalines_per_src.append", "len", "numpy.mean", "ideal_ratio_multimic_processor._read_wav", "ideal_ratio_multimic_processor.SnrMultimicProcessor.comp", "numpy.expand_dims", "numpy.log10", "dataline.strip", "len", "ideal_ratio_multimic_processor._read_wav", "ideal_ratio_multimic_processor.SnrMultimicProcessor.comp", "numpy.expand_dims", "numpy.append", "numpy.append"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "\t\t", "\"\"\"process the data in dataline\n\t\tArgs:\n\t\t\tdataline: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\tsegmented_data: The segmented info on bins to be used for scoring as a list of numpy arrays per segment length\n\t\t\tutt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "splitdatalines", "=", "dataline", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n", "splitdatalines_per_src", "=", "[", "]", "\n", "for", "src_ind", "in", "range", "(", "len", "(", "splitdatalines", ")", "/", "self", ".", "nr_channels", ")", ":", "\n", "\t\t\t", "inds", "=", "range", "(", "src_ind", "*", "self", ".", "nr_channels", ",", "(", "src_ind", "+", "1", ")", "*", "self", ".", "nr_channels", ")", "\n", "splitdatalines_per_src", ".", "append", "(", "[", "splitdatalines", "[", "ind", "]", "for", "ind", "in", "inds", "]", ")", "\n", "\n", "", "nr_spk", "=", "len", "(", "splitdatalines_per_src", ")", "-", "1", "\n", "\n", "speaker_features", "=", "None", "\n", "for", "spk_ind", "in", "range", "(", "nr_spk", ")", ":", "\n", "\t\t\t", "splitdatalines", "=", "splitdatalines_per_src", "[", "spk_ind", "]", "\n", "src_features", "=", "None", "\n", "for", "splitdataline", "in", "splitdatalines", ":", "\n", "# read the wav file", "\n", "\t\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "features", "=", "np", ".", "expand_dims", "(", "features", ",", "2", ")", "\n", "\n", "if", "src_features", "is", "None", ":", "\n", "\t\t\t\t\t", "src_features", "=", "features", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "src_features", "=", "np", ".", "append", "(", "src_features", ",", "features", ",", "2", ")", "\n", "\n", "", "", "src_features_averaged", "=", "np", ".", "mean", "(", "src_features", ",", "2", ",", "keepdims", "=", "False", ")", "\n", "\n", "if", "speaker_features", "is", "None", ":", "\n", "\t\t\t\t", "speaker_features", "=", "src_features_averaged", "\n", "", "else", ":", "\n", "\t\t\t\t", "speaker_features", "+=", "src_features_averaged", "\n", "\n", "", "", "ref_features", "=", "None", "\n", "for", "splitdataline", "in", "splitdatalines_per_src", "[", "-", "1", "]", ":", "\n", "# read the wav file", "\n", "\t\t\t", "rate", ",", "utt", "=", "_read_wav", "(", "splitdataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "features", "=", "np", ".", "expand_dims", "(", "features", ",", "2", ")", "\n", "\n", "if", "ref_features", "is", "None", ":", "\n", "\t\t\t\t", "ref_features", "=", "features", "\n", "", "else", ":", "\n", "\t\t\t\t", "ref_features", "=", "np", ".", "append", "(", "ref_features", ",", "features", ",", "2", ")", "\n", "\n", "", "", "ref_features_averaged", "=", "np", ".", "mean", "(", "ref_features", ",", "2", ",", "keepdims", "=", "False", ")", "\n", "\n", "# calculate the SNR", "\n", "snr", "=", "10", "*", "np", ".", "log10", "(", "speaker_features", "/", "(", "ref_features_averaged", "+", "1e-48", ")", ")", "\n", "\n", "segmented_data", "=", "self", ".", "segment_data", "(", "snr", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.ideal_ratio_multimic_processor._read_wav": [[199, 233], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "ideal_ratio_multimic_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tread a wav file\n\n\t\tArgs:\n\t\t\twavfile: either a path to a wav file or a command to read and pipe\n\t\t\t\tan audio file\n\n\t\tReturns:\n\t\t\t- the sampling rate\n\t\t\t- the utterance as a numpy array\n\t\t\"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "\t\t\t", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "\t\t\t", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "\t\t\t", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor.ScorelabelperfeatureProcessor.__init__": [[18, 39], ["float", "scorelabelperfeature_processor.ScorelabelperfeatureProcessor.comp.get_dim", "processor.Processor.__init__", "nabu.processing.feature_computers.feature_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.feature_computers.frames.Frames.get_dim", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "segment_lengths", ")", ":", "\n", "        ", "\"\"\"ScorelabelperfeatureProcessor constructor\n\n        Args:\n            conf: ScorelabelperfeatureProcessor configuration as a dict of strings\n            segment_lengths: A list containing the desired lengths of segments.\n            Possibly multiple segment lengths\"\"\"", "\n", "\n", "# create the feature computer", "\n", "self", ".", "comp", "=", "feature_computer_factory", ".", "factory", "(", "conf", "[", "'feature'", "]", ")", "(", "conf", ")", "\n", "\n", "self", ".", "mag_thres", "=", "float", "(", "conf", "[", "'mag_thres'", "]", ")", "\n", "\n", "# set the length of the segments. Possibly multiple segment lengths", "\n", "self", ".", "segment_lengths", "=", "segment_lengths", "\n", "\n", "# initialize the metadata", "\n", "self", ".", "dim", "=", "self", ".", "comp", ".", "get_dim", "(", ")", "\n", "self", ".", "nontime_dims", "=", "[", "self", ".", "dim", "]", "\n", "\n", "super", "(", "ScorelabelperfeatureProcessor", ",", "self", ")", ".", "__init__", "(", "conf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor.ScorelabelperfeatureProcessor.__call__": [[40, 73], ["dict", "scorelabelperfeature_processor._read_wav", "scorelabelperfeature_processor.ScorelabelperfeatureProcessor.comp", "numpy.max", "numpy.greater", "scorelabelperfeature_processor.ScorelabelperfeatureProcessor.segment_data", "numpy.mean", "print"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.matrix2vector_processor.Matrix2MatrixProcessor.segment_data"], ["", "def", "__call__", "(", "self", ",", "dataline", ")", ":", "\n", "        ", "\"\"\"process the data in dataline\n        Args:\n            dataline: either a path to a wav file or a command to read and pipe\n                an audio file\n\n        Returns:\n            segmented_data: The segmented info on bins to be used for scoring as a list of numpy arrays per segment\n            length\n            utt_info: some info on the utterance\"\"\"", "\n", "\n", "utt_info", "=", "dict", "(", ")", "\n", "\n", "# read the wav file", "\n", "rate", ",", "utt", "=", "_read_wav", "(", "dataline", ")", "\n", "\n", "# compute the features", "\n", "features", "=", "self", ".", "comp", "(", "utt", ",", "rate", ")", "\n", "\n", "# compute the floor", "\n", "maxbin", "=", "np", ".", "max", "(", "features", ")", "\n", "floor", "=", "maxbin", "/", "self", ".", "mag_thres", "\n", "\n", "# apply floor to get the used bins", "\n", "usedbins", "=", "np", ".", "greater", "(", "features", ",", "floor", ")", "\n", "\n", "if", "np", ".", "mean", "(", "usedbins", ")", "<", "0.01", ":", "\n", "            ", "print", "(", "'WARNING: less than 1% of the time-frequency bins were considered active'", ")", "\n", "\n", "# split the data for all desired segment lengths", "\n", "", "segmented_data", "=", "self", ".", "segment_data", "(", "usedbins", ")", "\n", "\n", "return", "segmented_data", ",", "utt_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor.ScorelabelperfeatureProcessor.write_metadata": [[74, 86], ["enumerate", "os.path.join", "open", "fid.write", "open", "fid.write", "os.path.join", "str", "os.path.join", "str"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.tfwriters.tfwriter.TfWriter.write"], ["", "def", "write_metadata", "(", "self", ",", "datadir", ")", ":", "\n", "        ", "\"\"\"write the processor metadata to disk\n\n        Args:\n            datadir: the directory where the metadata should be written\"\"\"", "\n", "\n", "for", "i", ",", "seg_length", "in", "enumerate", "(", "self", ".", "segment_lengths", ")", ":", "\n", "            ", "seg_dir", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "seg_length", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'dim'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "                ", "fid", ".", "write", "(", "str", "(", "self", ".", "dim", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "seg_dir", ",", "'nontime_dims'", ")", ",", "'w'", ")", "as", "fid", ":", "\n", "                ", "fid", ".", "write", "(", "str", "(", "self", ".", "nontime_dims", ")", "[", "1", ":", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav": [[88, 122], ["os.path.exists", "scipy.read", "subprocess.Popen", "subprocess.Popen.communicate", "StringIO.StringIO", "scipy.read", "wavfile.split", "float", "float", "scorelabelperfeature_processor._read_wav", "int", "int"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.processors.scorelabelperfeature_processor._read_wav"], ["", "", "", "", "def", "_read_wav", "(", "wavfile", ")", ":", "\n", "    ", "\"\"\"\n    read a wav file\n\n    Args:\n        wavfile: either a path to a wav file or a command to read and pipe\n            an audio file\n\n    Returns:\n        - the sampling rate\n        - the utterance as a numpy array\n    \"\"\"", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "wavfile", ")", ":", "\n", "# its a file", "\n", "        ", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "wavfile", ")", "\n", "", "elif", "wavfile", "[", "-", "1", "]", "==", "'|'", ":", "\n", "# its a command", "\n", "\n", "# read the audio file", "\n", "        ", "pid", "=", "subprocess", ".", "Popen", "(", "wavfile", "+", "' tee'", ",", "shell", "=", "True", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", "\n", "output", ",", "_", "=", "pid", ".", "communicate", "(", ")", "\n", "output_buffer", "=", "StringIO", ".", "StringIO", "(", "output", ")", "\n", "(", "rate", ",", "utterance", ")", "=", "wav", ".", "read", "(", "output_buffer", ")", "\n", "", "else", ":", "\n", "# its a segment of an utterance", "\n", "        ", "split", "=", "wavfile", ".", "split", "(", "' '", ")", "\n", "begin", "=", "float", "(", "split", "[", "-", "2", "]", ")", "\n", "end", "=", "float", "(", "split", "[", "-", "1", "]", ")", "\n", "unsegmented", "=", "' '", ".", "join", "(", "split", "[", ":", "-", "2", "]", ")", "\n", "rate", ",", "full_utterance", "=", "_read_wav", "(", "unsegmented", ")", "\n", "utterance", "=", "full_utterance", "[", "int", "(", "begin", "*", "rate", ")", ":", "int", "(", "end", "*", "rate", ")", "]", "\n", "\n", "", "return", "rate", ",", "utterance", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.hyperparameteroptimization.optimizer_plots.plot_objective": [[13, 166], ["utils.check_parameter_count_for_sample", "utils.check_parameter_count_for_sample", "numpy.asarray", "len", "matplotlib.pyplot.subplots", "fig.subplots_adjust", "enumerate", "optimizer_plots._format_scatter_plot_axes", "fig.set_size_inches", "matplotlib.pyplot.savefig", "range", "matplotlib.ticker.LogLocator", "enumerate", "ValueError", "utils.partial_dependence_valid_samples_allow_paramcounts", "ax[].plot", "ax[].plot", "ax[].plot", "isinstance", "ax[].axvline", "str", "utils.partial_dependence_valid_samples_allow_paramcounts", "ax[].contourf", "matplotlib.pyplot.colorbar", "isinstance", "isinstance", "ax[].scatter", "ax[].scatter"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.hyperparameteroptimization.optimizer_plots._format_scatter_plot_axes"], ["def", "plot_objective", "(", "\n", "result", ",", "param_thr", ",", "hyper_param_names", ",", "par_cnt_scheme", "=", "'enc_dec_cnn_lstm_ff'", ",", "levels", "=", "10", ",", "n_points", "=", "20", ",", "\n", "n_samples", "=", "250", ",", "size", "=", "2", ",", "zscale", "=", "'linear'", ",", "selected_dimensions", "=", "None", ",", "dimensions", "=", "None", ")", ":", "\n", "\t", "\"\"\"\n\tCopied from skopt and altered\n\tPairwise partial dependence plot of the objective function.\n\n\tThe diagonal shows the partial dependence for dimension `i` with\n\trespect to the objective function. The off-diagonal shows the\n\tpartial dependence for dimensions `i` and `j` with\n\trespect to the objective function. The objective function is\n\tapproximated by `result.model.`\n\n\tPairwise scatter plots of the points at which the objective\n\tfunction was directly evaluated are shown on the off-diagonal.\n\tA red point indicates the found minimum.\n\n\tNote: search spaces that contain `Categorical` dimensions are currently not supported by this function.\n\n\tParameters\n\t----------\n\t* `result` [`OptimizeResult`]\n\t\tThe result for which to create the scatter plot matrix.\n\n\t* `param_thr` [int]\n\t\tthreshold on trainable parameter count\n\n\t* `hyper_param_names`\n\t\tNames of the hyper parameters\n\n\t* `par_cnt_scheme` [default='enc_dec_cnn_lstm_ff']\n\t\tThe scheme to use to count the trainable parameters, to check if a sample is valid.\n\n\t* `levels` [int, default=10]\n\t\tNumber of levels to draw on the contour plot, passed directly\n\t\tto `plt.contour()`.\n\n\t* `n_points` [int, default=20]\n\t\tNumber of points at which to evaluate the partial dependence\n\t\talong each dimension.\n\n\t* `n_samples` [int, default=250]\n\t\tNumber of random samples to use for averaging the model function\n\t\tat each of the `n_points`.\n\n\t* `size` [float, default=2]\n\t\tHeight (in inches) of each facet.\n\n\t* `zscale` [str, default='linear']\n\t\tScale to use for the z axis of the contour plots. Either 'linear'\n\t\tor 'log'..\n\n\t* `selected_dimensions` [list, default='None']\n\t\tDimensions chosen to plot. If 'None', plot all dimensions\n\n\t* `dimensions` [list of str, default=None] Labels of the dimension\n\t\tvariables. `None` defaults to `space.dimensions[i].name`, or\n\t\tif also `None` to `['X_0', 'X_1', ..]`.\n\n\tReturns\n\t-------\n\t* `ax`: [`Axes`]:\n\t\tThe matplotlib axes.\n\t\"\"\"", "\n", "space", "=", "result", ".", "space", "\n", "exps", "=", "result", ".", "x_iters", "\n", "_", ",", "exps_par_dicts", "=", "check_parameter_count_for_sample", "(", "exps", ",", "hyper_param_names", ",", "param_thr", ",", "par_cnt_scheme", ")", "\n", "_", ",", "res_x_par_dict", "=", "check_parameter_count_for_sample", "(", "result", ".", "x", ",", "hyper_param_names", ",", "param_thr", ",", "par_cnt_scheme", ")", "\n", "exps", "=", "np", ".", "asarray", "(", "exps", ")", "\n", "# samples = space.rvs(n_samples=n_samples)", "\n", "# suitable_samples, _ = check_parameter_count_for_sample(samples, hyper_param_names, param_thr, par_cnt_scheme)", "\n", "#", "\n", "# samples = [samples[ind] for ind, suit in enumerate(suitable_samples) if suit]", "\n", "#", "\n", "# rvs_transformed = space.transform(samples)", "\n", "\n", "if", "selected_dimensions", "is", "None", ":", "\n", "\t\t", "selected_dimensions", "=", "range", "(", "space", ".", "n_dims", ")", "\n", "", "n_dims", "=", "len", "(", "selected_dimensions", ")", "\n", "\n", "if", "dimensions", "is", "not", "None", ":", "\n", "\t\t", "dimensions", "=", "[", "dimensions", "[", "ind", "]", "for", "ind", "in", "selected_dimensions", "]", "\n", "\n", "", "if", "zscale", "==", "'log'", ":", "\n", "\t\t", "locator", "=", "LogLocator", "(", ")", "\n", "", "elif", "zscale", "==", "'linear'", ":", "\n", "\t\t", "locator", "=", "None", "\n", "", "else", ":", "\n", "\t\t", "raise", "ValueError", "(", "\"Valid values for zscale are 'linear' and 'log', not '%s'.\"", "%", "zscale", ")", "\n", "\n", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "n_dims", ",", "n_dims", ",", "figsize", "=", "(", "size", "*", "n_dims", ",", "size", "*", "n_dims", ")", ")", "\n", "\n", "fig", ".", "subplots_adjust", "(", "left", "=", "0.05", ",", "right", "=", "0.95", ",", "bottom", "=", "0.05", ",", "top", "=", "0.95", ",", "hspace", "=", "0.1", ",", "wspace", "=", "0.1", ")", "\n", "\n", "for", "i", ",", "dim_i", "in", "enumerate", "(", "selected_dimensions", ")", ":", "\n", "\t\t", "for", "j", ",", "dim_j", "in", "enumerate", "(", "selected_dimensions", ")", ":", "\n", "\t\t\t", "if", "i", "==", "j", ":", "\n", "\t\t\t\t", "xi", ",", "yi", ",", "yi_std", "=", "partial_dependence_valid_samples_allow_paramcounts", "(", "\n", "space", ",", "result", ".", "models", "[", "-", "1", "]", ",", "param_thr", ",", "hyper_param_names", ",", "dim_i", ",", "j", "=", "None", ",", "\n", "par_cnt_scheme", "=", "par_cnt_scheme", ",", "n_samples", "=", "n_samples", ",", "n_points", "=", "n_points", ")", "\n", "\n", "ax", "[", "i", ",", "i", "]", ".", "plot", "(", "xi", ",", "yi", ")", "\n", "ax", "[", "i", ",", "i", "]", ".", "plot", "(", "xi", ",", "yi", "+", "yi_std", ",", "':'", ",", "color", "=", "'C0'", ")", "\n", "ax", "[", "i", ",", "i", "]", ".", "plot", "(", "xi", ",", "yi", "-", "yi_std", ",", "':'", ",", "color", "=", "'C0'", ")", "\n", "if", "isinstance", "(", "dim_i", ",", "str", ")", ":", "\n", "# using parameter counts.", "\n", "\t\t\t\t\t", "res_xi", "=", "res_x_par_dict", "[", "dim_i", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "res_xi", "=", "result", ".", "x", "[", "dim_i", "]", "\n", "", "ax", "[", "i", ",", "i", "]", ".", "axvline", "(", "res_xi", ",", "linestyle", "=", "\"--\"", ",", "color", "=", "\"r\"", ",", "lw", "=", "1", ")", "\n", "\n", "# lower triangle", "\n", "", "elif", "i", ">", "j", ":", "\n", "\t\t\t\t", "xi", ",", "yi", ",", "zi", "=", "partial_dependence_valid_samples_allow_paramcounts", "(", "\n", "space", ",", "result", ".", "models", "[", "-", "1", "]", ",", "param_thr", ",", "hyper_param_names", ",", "dim_i", ",", "dim_j", ",", "par_cnt_scheme", ",", "\n", "n_samples", "=", "n_samples", ",", "n_points", "=", "n_points", ")", "\n", "cont", "=", "ax", "[", "i", ",", "j", "]", ".", "contourf", "(", "xi", ",", "yi", ",", "zi", ",", "levels", ",", "locator", "=", "locator", ",", "cmap", "=", "'viridis_r'", ")", "\n", "plt", ".", "colorbar", "(", "cont", ",", "ax", "=", "ax", "[", "i", ",", "j", "]", ")", "\n", "if", "isinstance", "(", "dim_j", ",", "str", ")", ":", "\n", "# using parameter counts.", "\n", "\t\t\t\t\t", "x_param_cnt", "=", "True", "\n", "exps_xi", "=", "[", "exp_par_dict", "[", "dim_j", "]", "for", "exp_par_dict", "in", "exps_par_dicts", "]", "\n", "res_xi", "=", "res_x_par_dict", "[", "dim_j", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "x_param_cnt", "=", "False", "\n", "exps_xi", "=", "exps", "[", ":", ",", "dim_j", "]", "\n", "res_xi", "=", "result", ".", "x", "[", "dim_j", "]", "\n", "", "if", "isinstance", "(", "dim_i", ",", "str", ")", ":", "\n", "# using parameter counts.", "\n", "\t\t\t\t\t", "y_param_cnt", "=", "True", "\n", "exps_yi", "=", "[", "exp_par_dict", "[", "dim_i", "]", "for", "exp_par_dict", "in", "exps_par_dicts", "]", "\n", "res_yi", "=", "res_x_par_dict", "[", "dim_i", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "y_param_cnt", "=", "False", "\n", "exps_yi", "=", "exps", "[", ":", ",", "dim_i", "]", "\n", "res_yi", "=", "result", ".", "x", "[", "dim_i", "]", "\n", "\n", "", "ax", "[", "i", ",", "j", "]", ".", "scatter", "(", "exps_xi", ",", "exps_yi", ",", "c", "=", "'k'", ",", "s", "=", "10", ",", "lw", "=", "0.", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "scatter", "(", "res_xi", ",", "res_yi", ",", "c", "=", "[", "'r'", "]", ",", "s", "=", "20", ",", "lw", "=", "0.", ")", "\n", "\n", "", "", "", "complete_ax", "=", "_format_scatter_plot_axes", "(", "\n", "ax", ",", "space", ",", "ylabel", "=", "\"Partial dependence\"", ",", "param_thr", "=", "param_thr", ",", "selected_dimensions", "=", "selected_dimensions", ",", "\n", "dim_labels", "=", "dimensions", ")", "\n", "\n", "fig_name", "=", "'figures/dim'", "\n", "for", "dim", "in", "selected_dimensions", ":", "\n", "\t\t", "fig_name", "=", "'%s_%s'", "%", "(", "fig_name", ",", "str", "(", "dim", ")", ")", "\n", "", "fig_name", "=", "'%s_%d.png'", "%", "(", "fig_name", ",", "n_samples", ")", "\n", "\n", "fig", ".", "set_size_inches", "(", "(", "16", ",", "11", ")", ",", "forward", "=", "False", ")", "\n", "plt", ".", "savefig", "(", "fig_name", ",", "dpi", "=", "700", ")", "\n", "\n", "return", "complete_ax", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.hyperparameteroptimization.optimizer_plots._format_scatter_plot_axes": [[168, 263], ["len", "enumerate", "range", "numpy.min", "numpy.max", "enumerate", "enumerate", "ax_.axis", "isinstance", "isinstance", "zip", "ax_.set_ylim", "ax_.yaxis.tick_right", "ax_.yaxis.set_label_position", "ax_.yaxis.set_ticks_position", "ax_.set_ylabel", "ax_.xaxis.tick_top", "ax_.xaxis.set_label_position", "ax_.set_xlabel", "ax[].get_ylim", "range", "ax[].get_ylim", "range", "ax_.set_ylim", "ax_.set_ylim", "ax_.set_xlim", "ax_.set_xlim", "ax_.set_yticklabels", "ax_.set_ylabel", "ax_.set_xticklabels", "ax_.set_xlabel", "ax_.set_xscale", "ax_.xaxis.set_major_locator", "l.set_rotation", "set_scale", "set_major_locator", "matplotlib.ticker.MaxNLocator", "ax_.get_xticklabels", "matplotlib.ticker.MaxNLocator"], "function", ["None"], ["", "def", "_format_scatter_plot_axes", "(", "ax", ",", "space", ",", "ylabel", ",", "param_thr", ",", "selected_dimensions", "=", "None", ",", "dim_labels", "=", "None", ")", ":", "\n", "\t", "if", "selected_dimensions", "is", "None", ":", "\n", "\t\t", "selected_dimensions", "=", "range", "(", "space", ".", "n_dims", ")", "\n", "", "n_dims", "=", "len", "(", "selected_dimensions", ")", "\n", "\n", "# Work out min, max of y axis for the diagonal so we can adjust", "\n", "# them all to the same value", "\n", "diagonal_ylim", "=", "(", "\n", "np", ".", "min", "(", "[", "ax", "[", "i", ",", "i", "]", ".", "get_ylim", "(", ")", "[", "0", "]", "for", "i", "in", "range", "(", "n_dims", ")", "]", ")", ",", "\n", "np", ".", "max", "(", "[", "ax", "[", "i", ",", "i", "]", ".", "get_ylim", "(", ")", "[", "1", "]", "for", "i", "in", "range", "(", "n_dims", ")", "]", ")", ")", "\n", "\n", "if", "dim_labels", "is", "None", ":", "\n", "\t\t", "dim_labels", "=", "[", "\"$X_{%i}$\"", "%", "i", "if", "d", ".", "name", "is", "None", "else", "d", ".", "name", "for", "i", ",", "d", "in", "enumerate", "(", "space", ".", "dimensions", ")", "]", "\n", "\n", "# Deal with formatting of the axes", "\n", "", "for", "i", ",", "dim_i", "in", "enumerate", "(", "selected_dimensions", ")", ":", "\n", "\t\t", "for", "j", ",", "dim_j", "in", "enumerate", "(", "selected_dimensions", ")", ":", "\n", "\t\t\t", "ax_", "=", "ax", "[", "i", ",", "j", "]", "\n", "\n", "if", "j", ">", "i", ":", "\n", "\t\t\t\t", "ax_", ".", "axis", "(", "\"off\"", ")", "\n", "\n", "# off-diagonal axis", "\n", "", "if", "i", "!=", "j", ":", "\n", "\t\t\t\t", "if", "isinstance", "(", "dim_j", ",", "str", ")", ":", "\n", "# using parameter counts.", "\n", "\t\t\t\t\t", "x_param_cnt", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "x_param_cnt", "=", "False", "\n", "", "if", "isinstance", "(", "dim_i", ",", "str", ")", ":", "\n", "# using parameter counts.", "\n", "\t\t\t\t\t", "y_param_cnt", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "y_param_cnt", "=", "False", "\n", "# plots on the diagonal are special, like Texas. They have", "\n", "# their own range so do not mess with them.", "\n", "", "if", "y_param_cnt", ":", "\n", "\t\t\t\t\t", "ax_", ".", "set_ylim", "(", "[", "0", ",", "param_thr", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "ax_", ".", "set_ylim", "(", "*", "space", ".", "dimensions", "[", "dim_i", "]", ".", "bounds", ")", "\n", "", "if", "x_param_cnt", ":", "\n", "\t\t\t\t\t", "ax_", ".", "set_xlim", "(", "[", "0", ",", "param_thr", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "ax_", ".", "set_xlim", "(", "*", "space", ".", "dimensions", "[", "dim_j", "]", ".", "bounds", ")", "\n", "\n", "", "if", "j", ">", "0", ":", "\n", "\t\t\t\t\t", "ax_", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "ax_", ".", "set_ylabel", "(", "dim_labels", "[", "i", "]", ")", "\n", "\n", "# for all rows except ...", "\n", "", "if", "i", "<", "n_dims", "-", "1", ":", "\n", "\t\t\t\t\t", "ax_", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "# ... the bottom row", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "[", "l", ".", "set_rotation", "(", "45", ")", "for", "l", "in", "ax_", ".", "get_xticklabels", "(", ")", "]", "\n", "ax_", ".", "set_xlabel", "(", "dim_labels", "[", "j", "]", ")", "\n", "\n", "# configure plot for linear vs log-scale", "\n", "", "if", "y_param_cnt", ":", "\n", "\t\t\t\t\t", "y_prior", "=", "''", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "y_prior", "=", "space", ".", "dimensions", "[", "dim_i", "]", ".", "prior", "\n", "", "if", "x_param_cnt", ":", "\n", "\t\t\t\t\t", "x_prior", "=", "''", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "x_prior", "=", "space", ".", "dimensions", "[", "dim_j", "]", ".", "prior", "\n", "\n", "", "priors", "=", "(", "x_prior", ",", "y_prior", ")", "\n", "scale_setters", "=", "(", "ax_", ".", "set_xscale", ",", "ax_", ".", "set_yscale", ")", "\n", "loc_setters", "=", "(", "ax_", ".", "xaxis", ".", "set_major_locator", ",", "ax_", ".", "yaxis", ".", "set_major_locator", ")", "\n", "for", "set_major_locator", ",", "set_scale", ",", "prior", "in", "zip", "(", "\n", "loc_setters", ",", "scale_setters", ",", "priors", ")", ":", "\n", "\t\t\t\t\t", "if", "prior", "==", "'log-uniform'", ":", "\n", "\t\t\t\t\t\t", "set_scale", "(", "'log'", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "set_major_locator", "(", "MaxNLocator", "(", "6", ",", "prune", "=", "'both'", ")", ")", "\n", "\n", "", "", "", "else", ":", "\n", "\t\t\t\t", "ax_", ".", "set_ylim", "(", "*", "diagonal_ylim", ")", "\n", "ax_", ".", "yaxis", ".", "tick_right", "(", ")", "\n", "ax_", ".", "yaxis", ".", "set_label_position", "(", "'right'", ")", "\n", "ax_", ".", "yaxis", ".", "set_ticks_position", "(", "'both'", ")", "\n", "ax_", ".", "set_ylabel", "(", "ylabel", ")", "\n", "\n", "ax_", ".", "xaxis", ".", "tick_top", "(", ")", "\n", "ax_", ".", "xaxis", ".", "set_label_position", "(", "'top'", ")", "\n", "ax_", ".", "set_xlabel", "(", "dim_labels", "[", "j", "]", ")", "\n", "\n", "if", "space", ".", "dimensions", "[", "i", "]", ".", "prior", "==", "'log-uniform'", ":", "\n", "\t\t\t\t\t", "ax_", ".", "set_xscale", "(", "'log'", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "ax_", ".", "xaxis", ".", "set_major_locator", "(", "MaxNLocator", "(", "6", ",", "prune", "=", "'both'", ")", ")", "\n", "\n", "", "", "", "", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.hyperparameteroptimization.optimizer_plots.plot_flat_objective": [[265, 436], ["numpy.asarray", "utils.check_parameter_count_for_sample", "utils.check_parameter_count_for_sample", "len", "matplotlib.pyplot.subplots", "fig.subplots_adjust", "enumerate", "optimizer_plots._format_scatter_plot_axes", "range", "matplotlib.ticker.LogLocator", "enumerate", "ValueError", "utils.partial_dependence_valid_samples_allow_paramcounts", "ax[].plot", "ax[].plot", "ax[].plot", "ax[].axvline", "numpy.linspace", "numpy.linspace", "matplotlib.tri.Triangulation", "matplotlib.tri.LinearTriInterpolator", "numpy.meshgrid", "tri.LinearTriInterpolator.", "ax[].contourf", "fig.colorbar", "isinstance", "isinstance", "ax[].scatter", "ax[].scatter", "float", "float", "max", "min", "max", "min", "min", "max", "min", "max"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.hyperparameteroptimization.optimizer_plots._format_scatter_plot_axes"], ["", "def", "plot_flat_objective", "(", "\n", "result", ",", "param_thr", ",", "hyper_param_names", ",", "par_cnt_scheme", "=", "'enc_dec_cnn_lstm_ff'", ",", "levels", "=", "10", ",", "n_points", "=", "20", ",", "\n", "n_samples", "=", "250", ",", "size", "=", "2", ",", "zscale", "=", "'linear'", ",", "selected_dimensions", "=", "None", ",", "dimensions", "=", "None", ")", ":", "\n", "\t", "\"\"\"\n\tCopied from skopt and altered\n\tPairwise partial dependence plot of the objective function.\n\n\tThe diagonal shows the partial dependence for dimension `i` with\n\trespect to the objective function. The off-diagonal shows the\n\tpartial dependence for dimensions `i` and `j` with\n\trespect to the objective function. The objective function is\n\tapproximated by `result.model.`\n\n\tPairwise scatter plots of the points at which the objective\n\tfunction was directly evaluated are shown on the off-diagonal.\n\tA red point indicates the found minimum.\n\n\tNote: search spaces that contain `Categorical` dimensions are currently not supported by this function.\n\n\tParameters\n\t----------\n\t* `result` [`OptimizeResult`]\n\t\tThe result for which to create the scatter plot matrix.\n\n\t* `param_thr` [int]\n\t\tthreshold on trainable parameter count\n\n\t* `hyper_param_names`\n\t\tNames of the hyper parameters\n\n\t* `par_cnt_scheme` [default='enc_dec_cnn_lstm_ff']\n\t\tThe scheme to use to count the trainable parameters, to check if a sample is valid.\n\n\t* `levels` [int, default=10]\n\t\tNumber of levels to draw on the contour plot, passed directly\n\t\tto `plt.contour()`.\n\n\t* `n_points` [int, default=20]\n\t\tNumber of points at which to evaluate the partial dependence\n\t\talong each dimension.\n\n\t* `n_samples` [int, default=250]\n\t\tNumber of random samples to use for averaging the model function\n\t\tat each of the `n_points`.\n\n\t* `size` [float, default=2]\n\t\tHeight (in inches) of each facet.\n\n\t* `zscale` [str, default='linear']\n\t\tScale to use for the z axis of the contour plots. Either 'linear'\n\t\tor 'log'..\n\n\t* `selected_dimensions` [list, default='None']\n\t\tDimensions chosen to plot. If 'None', plot all dimensions\n\n\t* `dimensions` [list of str, default=None] Labels of the dimension\n\t\tvariables. `None` defaults to `space.dimensions[i].name`, or\n\t\tif also `None` to `['X_0', 'X_1', ..]`.\n\n\tReturns\n\t-------\n\t* `ax`: [`Axes`]:\n\t\tThe matplotlib axes.\n\t\"\"\"", "\n", "space", "=", "result", ".", "space", "\n", "exps", "=", "np", ".", "asarray", "(", "result", ".", "x_iters", ")", "\n", "_", ",", "exps_par_dicts", "=", "check_parameter_count_for_sample", "(", "exps", ",", "hyper_param_names", ",", "param_thr", ",", "par_cnt_scheme", ")", "\n", "_", ",", "res_x_par_dict", "=", "check_parameter_count_for_sample", "(", "result", ".", "x", ",", "hyper_param_names", ",", "param_thr", ",", "par_cnt_scheme", ")", "\n", "# samples = space.rvs(n_samples=n_samples)", "\n", "# suitable_samples, _ = check_parameter_count_for_sample(samples, hyper_param_names, param_thr, par_cnt_scheme)", "\n", "#", "\n", "# samples = [samples[ind] for ind, suit in enumerate(suitable_samples) if suit]", "\n", "#", "\n", "# rvs_transformed = space.transform(samples)", "\n", "\n", "if", "selected_dimensions", "is", "None", ":", "\n", "\t\t", "selected_dimensions", "=", "range", "(", "space", ".", "n_dims", ")", "\n", "", "n_dims", "=", "len", "(", "selected_dimensions", ")", "\n", "\n", "if", "dimensions", "is", "not", "None", ":", "\n", "\t\t", "dimensions", "=", "[", "dimensions", "[", "ind", "]", "for", "ind", "in", "selected_dimensions", "]", "\n", "\n", "", "if", "zscale", "==", "'log'", ":", "\n", "\t\t", "locator", "=", "LogLocator", "(", ")", "\n", "", "elif", "zscale", "==", "'linear'", ":", "\n", "\t\t", "locator", "=", "None", "\n", "", "else", ":", "\n", "\t\t", "raise", "ValueError", "(", "\"Valid values for zscale are 'linear' and 'log', not '%s'.\"", "%", "zscale", ")", "\n", "\n", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "n_dims", ",", "n_dims", ",", "figsize", "=", "(", "size", "*", "n_dims", ",", "size", "*", "n_dims", ")", ")", "\n", "\n", "fig", ".", "subplots_adjust", "(", "left", "=", "0.05", ",", "right", "=", "0.95", ",", "bottom", "=", "0.05", ",", "top", "=", "0.95", ",", "hspace", "=", "0.1", ",", "wspace", "=", "0.1", ")", "\n", "\n", "for", "i", ",", "dim_i", "in", "enumerate", "(", "selected_dimensions", ")", ":", "\n", "\t\t", "for", "j", ",", "dim_j", "in", "enumerate", "(", "selected_dimensions", ")", ":", "\n", "\t\t\t", "if", "i", "==", "j", ":", "\n", "\t\t\t\t", "xi", ",", "yi", ",", "yi_std", "=", "partial_dependence_valid_samples_allow_paramcounts", "(", "\n", "space", ",", "result", ".", "models", "[", "-", "1", "]", ",", "param_thr", ",", "hyper_param_names", ",", "dim_i", ",", "j", "=", "None", ",", "\n", "par_cnt_scheme", "=", "par_cnt_scheme", ",", "n_samples", "=", "n_samples", ",", "n_points", "=", "n_points", ")", "\n", "# xi = exps[:, dim_i]", "\n", "# yi = result.func_vals", "\n", "#", "\n", "# sort_inds = np.argsort(xi)", "\n", "# xi_sorted = [xi[ind] for ind in sort_inds]", "\n", "# yi_sorted = [yi[ind] for ind in sort_inds]", "\n", "\n", "ax", "[", "i", ",", "i", "]", ".", "plot", "(", "xi", ",", "yi", ")", "\n", "ax", "[", "i", ",", "i", "]", ".", "plot", "(", "xi", ",", "yi", "+", "yi_std", ",", "':'", ",", "color", "=", "'C0'", ")", "\n", "ax", "[", "i", ",", "i", "]", ".", "plot", "(", "xi", ",", "yi", "-", "yi_std", ",", "':'", ",", "color", "=", "'C0'", ")", "\n", "ax", "[", "i", ",", "i", "]", ".", "axvline", "(", "result", ".", "x", "[", "dim_i", "]", ",", "linestyle", "=", "\"--\"", ",", "color", "=", "\"r\"", ",", "lw", "=", "1", ")", "\n", "\n", "# lower triangle", "\n", "", "elif", "i", ">", "j", ":", "\n", "# xi, yi, zi = partial_dependence_valid_samples_allow_paramcounts(", "\n", "# \tspace, result.models[-1], param_thr, hyper_param_names, dim_i, dim_j, par_cnt_scheme,", "\n", "# \trvs_transformed, n_points)", "\n", "\n", "\t\t\t\t", "x", "=", "exps", "[", ":", ",", "dim_j", "]", "\n", "x", "=", "[", "float", "(", "xi", ")", "for", "xi", "in", "x", "]", "\n", "y", "=", "exps", "[", ":", ",", "dim_i", "]", "\n", "y", "=", "[", "float", "(", "yi", ")", "for", "yi", "in", "y", "]", "\n", "z", "=", "result", ".", "func_vals", "\n", "\n", "x_range", "=", "max", "(", "x", ")", "-", "min", "(", "x", ")", "\n", "y_range", "=", "max", "(", "y", ")", "-", "min", "(", "y", ")", "\n", "xi", "=", "np", ".", "linspace", "(", "min", "(", "x", ")", "-", "x_range", "/", "10", ",", "max", "(", "x", ")", "+", "x_range", "/", "10", ",", "1000", ")", "\n", "yi", "=", "np", ".", "linspace", "(", "min", "(", "y", ")", "-", "y_range", "/", "10", ",", "max", "(", "y", ")", "+", "y_range", "/", "10", ",", "1000", ")", "\n", "\n", "# Perform linear interpolation of the data (x,y)", "\n", "# on a grid defined by (xi,yi)", "\n", "triang", "=", "tri", ".", "Triangulation", "(", "x", ",", "y", ")", "\n", "interpolator", "=", "tri", ".", "LinearTriInterpolator", "(", "triang", ",", "z", ")", "\n", "Xi", ",", "Yi", "=", "np", ".", "meshgrid", "(", "xi", ",", "yi", ")", "\n", "zi", "=", "interpolator", "(", "Xi", ",", "Yi", ")", "\n", "\n", "# Note that scipy.interpolate provides means to interpolate data on a grid", "\n", "# as well. The following would be an alternative to the four lines above:", "\n", "# from scipy.interpolate import griddata", "\n", "# zi = griddata((x, y), z, (xi[None,:], yi[:,None]), method='linear')", "\n", "\n", "# ax[i, j].contour(xi, yi, zi, levels=14, linewidths=0.5, colors='k')", "\n", "cntr1", "=", "ax", "[", "i", ",", "j", "]", ".", "contourf", "(", "xi", ",", "yi", ",", "zi", ",", "levels", ",", "locator", "=", "locator", ",", "cmap", "=", "\"viridis_r\"", ")", "\n", "\n", "fig", ".", "colorbar", "(", "cntr1", ",", "ax", "=", "ax", "[", "i", ",", "j", "]", ")", "\n", "\n", "# cont = ax[i, j].contourf(xi, yi, zi, levels, locator=locator, cmap='viridis_r')", "\n", "# plt.colorbar(cont, ax=ax[i, j])", "\n", "if", "isinstance", "(", "dim_j", ",", "str", ")", ":", "\n", "# using parameter counts.", "\n", "\t\t\t\t\t", "x_param_cnt", "=", "True", "\n", "exps_xi", "=", "[", "exp_par_dict", "[", "dim_j", "]", "for", "exp_par_dict", "in", "exps_par_dicts", "]", "\n", "res_xi", "=", "res_x_par_dict", "[", "dim_j", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "x_param_cnt", "=", "False", "\n", "exps_xi", "=", "exps", "[", ":", ",", "dim_j", "]", "\n", "res_xi", "=", "result", ".", "x", "[", "dim_j", "]", "\n", "", "if", "isinstance", "(", "dim_i", ",", "str", ")", ":", "\n", "# using parameter counts.", "\n", "\t\t\t\t\t", "y_param_cnt", "=", "True", "\n", "exps_yi", "=", "[", "exp_par_dict", "[", "dim_i", "]", "for", "exp_par_dict", "in", "exps_par_dicts", "]", "\n", "res_yi", "=", "res_x_par_dict", "[", "dim_i", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "y_param_cnt", "=", "False", "\n", "exps_yi", "=", "exps", "[", ":", ",", "dim_i", "]", "\n", "res_yi", "=", "result", ".", "x", "[", "dim_i", "]", "\n", "\n", "", "ax", "[", "i", ",", "j", "]", ".", "scatter", "(", "exps_xi", ",", "exps_yi", ",", "c", "=", "'k'", ",", "s", "=", "10", ",", "lw", "=", "0.", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "scatter", "(", "res_xi", ",", "res_yi", ",", "c", "=", "[", "'r'", "]", ",", "s", "=", "20", ",", "lw", "=", "0.", ")", "\n", "\n", "", "", "", "return", "_format_scatter_plot_axes", "(", "\n", "ax", ",", "space", ",", "ylabel", "=", "\"Partial dependence\"", ",", "selected_dimensions", "=", "selected_dimensions", ",", "dim_labels", "=", "dimensions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.hyperparameteroptimization.optimizer_plots.plot_param_count": [[438, 503], ["enumerate", "numpy.argsort", "numpy.array", "numpy.array", "numpy.array", "len", "numpy.arange", "matplotlib.rc", "matplotlib.pyplot.figure", "plt.figure.add_subplot", "mpl_fig.add_subplot.scatter", "mpl_fig.add_subplot.set_ylabel", "plt.figure.add_subplot", "mpl_fig.add_subplot.bar", "mpl_fig.add_subplot.bar", "mpl_fig.add_subplot.bar", "mpl_fig.add_subplot.legend", "mpl_fig.add_subplot.set_ylabel", "mpl_fig.add_subplot.set_xlabel", "numpy.arange", "numpy.arange", "mpl_fig.add_subplot.set_yticks", "mpl_fig.add_subplot.set_yticklabels", "mpl_fig.add_subplot.axvline", "mpl_fig.add_subplot.axvline", "utils.check_parameter_count_for_sample", "all_par_dicts.append", "str", "bad_param_cnt_inds.append", "bad_param_dict.append", "enumerate"], "function", ["None"], ["", "def", "plot_param_count", "(", "optimizer", ",", "result", ")", ":", "\n", "\t", "all_dim_values", "=", "result", ".", "x_iters", "\n", "losses", "=", "result", ".", "func_vals", "\n", "\n", "par_cnt_scheme", "=", "optimizer", ".", "adapt_param", "[", "'par_cnt_scheme'", "]", "\n", "param_thr", "=", "optimizer", ".", "adapt_param", "[", "'param_thr'", "]", "\n", "\n", "all_par_dicts", "=", "[", "]", "\n", "\n", "bad_param_cnt_inds", "=", "[", "]", "\n", "bad_param_dict", "=", "[", "]", "\n", "for", "ind", ",", "dim_values", "in", "enumerate", "(", "all_dim_values", ")", ":", "\n", "\t\t", "_", ",", "par_dict", "=", "check_parameter_count_for_sample", "(", "\n", "dim_values", ",", "optimizer", ".", "hyper_param_names", ",", "param_thr", ",", "par_cnt_scheme", "=", "par_cnt_scheme", ")", "\n", "all_par_dicts", ".", "append", "(", "par_dict", ")", "\n", "if", "par_dict", "[", "'total'", "]", "<", "param_thr", "*", "0.95", "or", "par_dict", "[", "'total'", "]", ">", "param_thr", ":", "\n", "\t\t\t", "bad_param_cnt_inds", ".", "append", "(", "ind", ")", "\n", "bad_param_dict", ".", "append", "(", "par_dict", ")", "\n", "\n", "", "", "sorted_inds", "=", "np", ".", "argsort", "(", "losses", ")", "\n", "sorted_losses", "=", "[", "losses", "[", "ind", "]", "for", "ind", "in", "sorted_inds", "]", "\n", "sorted_par_dicts", "=", "[", "all_par_dicts", "[", "ind", "]", "for", "ind", "in", "sorted_inds", "]", "\n", "cnn_cnts", "=", "np", ".", "array", "(", "[", "par_dict", "[", "'cnn'", "]", "for", "par_dict", "in", "sorted_par_dicts", "]", ")", "\n", "lstm_cnts", "=", "np", ".", "array", "(", "[", "par_dict", "[", "'lstm'", "]", "for", "par_dict", "in", "sorted_par_dicts", "]", ")", "\n", "ff_cnts", "=", "np", ".", "array", "(", "[", "par_dict", "[", "'ff'", "]", "for", "par_dict", "in", "sorted_par_dicts", "]", ")", "\n", "\n", "n_exps", "=", "len", "(", "sorted_losses", ")", "\n", "exps_range", "=", "np", ".", "arange", "(", "n_exps", ")", "\n", "\n", "font", "=", "{", "'size'", ":", "16", "}", "\n", "matplotlib", ".", "rc", "(", "'font'", ",", "**", "font", ")", "\n", "# matplotlib.rcParams.update({'font.size': 22})", "\n", "\n", "mpl_fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax_loss", "=", "mpl_fig", ".", "add_subplot", "(", "211", ")", "\n", "ax_loss", ".", "scatter", "(", "exps_range", ",", "sorted_losses", ")", "\n", "ax_loss", ".", "set_ylabel", "(", "'Validation loss'", ")", "\n", "# ax_loss.plot(sorted_losses)", "\n", "\n", "ax", "=", "mpl_fig", ".", "add_subplot", "(", "212", ",", "sharex", "=", "ax_loss", ")", "\n", "width", "=", "0.50", "\n", "p1", "=", "ax", ".", "bar", "(", "exps_range", ",", "cnn_cnts", ",", "width", ")", "\n", "p2", "=", "ax", ".", "bar", "(", "exps_range", ",", "lstm_cnts", ",", "width", ",", "bottom", "=", "cnn_cnts", ")", "\n", "p3", "=", "ax", ".", "bar", "(", "exps_range", ",", "ff_cnts", ",", "width", ",", "bottom", "=", "lstm_cnts", "+", "cnn_cnts", ")", "\n", "\n", "ax", ".", "legend", "(", "[", "'CNN'", ",", "'LSTM'", ",", "'FC'", "]", ",", "loc", "=", "'upper right'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Trainable parameter count (in millions)'", ")", "\n", "ax", ".", "set_xlabel", "(", "'Experiments ordered by loss'", ")", "\n", "# ax.set_title('Trainable parameter count per experiment, ordered by loss')", "\n", "\n", "# ax.set_xticks(np.arange(0, n_exps+7, 20))", "\n", "# ax.set_xticks(exps_range)", "\n", "# # ax.set_xticks(exps_range + width/2.)", "\n", "# ax.set_xticklabels(exps_range)", "\n", "y_ticks", "=", "np", ".", "arange", "(", "0", ",", "param_thr", ",", "2e6", ")", "\n", "y_tickslabels", "=", "np", ".", "arange", "(", "0", ",", "param_thr", "/", "1e6", ",", "2e6", "/", "1e6", ")", "\n", "y_tickslabels", "=", "[", "str", "(", "lab", ")", "for", "lab", "in", "y_tickslabels", "]", "\n", "ax", ".", "set_yticks", "(", "y_ticks", ")", "\n", "ax", ".", "set_yticklabels", "(", "y_tickslabels", ")", "\n", "\n", "# make vertical line befor experiments with loss>0.17", "\n", "tmp", "=", "[", "ind", "for", "ind", ",", "loss", "in", "enumerate", "(", "sorted_losses", ")", "if", "loss", ">=", "0.17", "]", "\n", "\n", "ax_loss", ".", "axvline", "(", "tmp", "[", "0", "]", "-", "0.5", ",", "linestyle", "=", "\"-\"", ",", "lw", "=", "1", ")", "\n", "ax", ".", "axvline", "(", "tmp", "[", "0", "]", "-", "0.5", ",", "linestyle", "=", "\"-\"", ",", "lw", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.hyperparameteroptimization.optimizer_plots.plot_param_count_and_window_size": [[515, 611], ["enumerate", "numpy.argsort", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "len", "numpy.arange", "matplotlib.pyplot.figure", "plt.figure.add_subplot", "mpl_fig.add_subplot.scatter", "mpl_fig.add_subplot.set_ylim", "mpl_fig.add_subplot.set_ylabel", "plt.figure.add_subplot", "mpl_fig.add_subplot.bar", "mpl_fig.add_subplot.bar", "mpl_fig.add_subplot.bar", "mpl_fig.add_subplot.set_ylabel", "mpl_fig.add_subplot.set_xticks", "mpl_fig.add_subplot.set_xticklabels", "numpy.arange", "numpy.arange", "mpl_fig.add_subplot.set_yticks", "mpl_fig.add_subplot.set_yticklabels", "plt.figure.add_subplot", "mpl_fig.add_subplot.bar", "mpl_fig.add_subplot.bar", "mpl_fig.add_subplot.set_ylabel", "mpl_fig.add_subplot.set_xlabel", "mpl_fig.add_subplot.set_xticks", "mpl_fig.add_subplot.set_xticklabels", "mpl_fig.add_subplot.axvline", "mpl_fig.add_subplot.axvline", "mpl_fig.add_subplot.axvline", "utils.check_parameter_count_for_sample", "all_par_dicts.append", "numpy.floor", "numpy.ceil", "str", "bad_param_cnt_inds.append", "bad_param_dict.append", "enumerate", "numpy.min", "numpy.max"], "function", ["None"], ["", "def", "plot_param_count_and_window_size", "(", "optimizer", ",", "result", ")", ":", "\n", "\t", "all_dim_values", "=", "result", ".", "x_iters", "\n", "losses", "=", "result", ".", "func_vals", "\n", "\n", "par_cnt_scheme", "=", "optimizer", ".", "adapt_param", "[", "'par_cnt_scheme'", "]", "\n", "param_thr", "=", "optimizer", ".", "adapt_param", "[", "'param_thr'", "]", "\n", "\n", "all_par_dicts", "=", "[", "]", "\n", "\n", "bad_param_cnt_inds", "=", "[", "]", "\n", "bad_param_dict", "=", "[", "]", "\n", "for", "ind", ",", "dim_values", "in", "enumerate", "(", "all_dim_values", ")", ":", "\n", "\t\t", "_", ",", "par_dict", "=", "check_parameter_count_for_sample", "(", "\n", "dim_values", ",", "optimizer", ".", "hyper_param_names", ",", "param_thr", ",", "par_cnt_scheme", "=", "par_cnt_scheme", ")", "\n", "all_par_dicts", ".", "append", "(", "par_dict", ")", "\n", "if", "par_dict", "[", "'total'", "]", "<", "param_thr", "*", "0.95", "or", "par_dict", "[", "'total'", "]", ">", "param_thr", ":", "\n", "\t\t\t", "bad_param_cnt_inds", ".", "append", "(", "ind", ")", "\n", "bad_param_dict", ".", "append", "(", "par_dict", ")", "\n", "\n", "", "", "sorted_inds", "=", "np", ".", "argsort", "(", "losses", ")", "\n", "sorted_losses", "=", "[", "losses", "[", "ind", "]", "for", "ind", "in", "sorted_inds", "]", "\n", "sorted_par_dicts", "=", "[", "all_par_dicts", "[", "ind", "]", "for", "ind", "in", "sorted_inds", "]", "\n", "cnn_cnts", "=", "np", ".", "array", "(", "[", "par_dict", "[", "'cnn'", "]", "for", "par_dict", "in", "sorted_par_dicts", "]", ")", "\n", "lstm_cnts", "=", "np", ".", "array", "(", "[", "par_dict", "[", "'lstm'", "]", "for", "par_dict", "in", "sorted_par_dicts", "]", ")", "\n", "ff_cnts", "=", "np", ".", "array", "(", "[", "par_dict", "[", "'ff'", "]", "for", "par_dict", "in", "sorted_par_dicts", "]", ")", "\n", "\n", "win_t_sizes", "=", "np", ".", "array", "(", "[", "all_dim_values", "[", "ind", "]", "[", "4", "]", "for", "ind", "in", "sorted_inds", "]", ")", "\n", "win_f_sizes", "=", "np", ".", "array", "(", "[", "all_dim_values", "[", "ind", "]", "[", "6", "]", "for", "ind", "in", "sorted_inds", "]", ")", "\n", "\n", "n_exps", "=", "len", "(", "sorted_losses", ")", "\n", "exps_range", "=", "np", ".", "arange", "(", "n_exps", ")", "\n", "\n", "mpl_fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax_loss", "=", "mpl_fig", ".", "add_subplot", "(", "311", ")", "\n", "ax_loss", ".", "scatter", "(", "exps_range", ",", "sorted_losses", ")", "\n", "# ax_loss.plot(sorted_losses)", "\n", "ymin", "=", "np", ".", "floor", "(", "(", "np", ".", "min", "(", "sorted_losses", ")", "-", "1e-10", ")", "*", "100", ")", "/", "100", "\n", "ymax", "=", "np", ".", "ceil", "(", "(", "np", ".", "max", "(", "sorted_losses", ")", "+", "1e-10", ")", "*", "100", ")", "/", "100", "\n", "ax_loss", ".", "set_ylim", "(", "[", "ymin", ",", "ymax", "]", ")", "\n", "ax_loss", ".", "set_ylabel", "(", "'Validation loss'", ")", "\n", "\n", "ax", "=", "mpl_fig", ".", "add_subplot", "(", "312", ")", "\n", "width", "=", "0.50", "\n", "p1", "=", "ax", ".", "bar", "(", "exps_range", ",", "cnn_cnts", ",", "width", ")", "\n", "p2", "=", "ax", ".", "bar", "(", "exps_range", ",", "lstm_cnts", ",", "width", ",", "bottom", "=", "cnn_cnts", ")", "\n", "p3", "=", "ax", ".", "bar", "(", "exps_range", ",", "ff_cnts", ",", "width", ",", "bottom", "=", "lstm_cnts", "+", "cnn_cnts", ")", "\n", "\n", "ax", ".", "set_ylabel", "(", "'Trainable parameter count (in millions)'", ")", "\n", "# ax.set_xlabel('Experiments ordered by loss')", "\n", "# ax.set_title('Trainable parameter count per experiment, ordered by loss')", "\n", "\n", "ax", ".", "set_xticks", "(", "exps_range", ")", "\n", "# ax.set_xticks(exps_range + width/2.)", "\n", "ax", ".", "set_xticklabels", "(", "exps_range", ")", "\n", "y_ticks", "=", "np", ".", "arange", "(", "0", ",", "param_thr", ",", "2e6", ")", "\n", "y_tickslabels", "=", "np", ".", "arange", "(", "0", ",", "param_thr", "/", "1e6", ",", "2e6", "/", "1e6", ")", "\n", "y_tickslabels", "=", "[", "str", "(", "lab", ")", "for", "lab", "in", "y_tickslabels", "]", "\n", "ax", ".", "set_yticks", "(", "y_ticks", ")", "\n", "ax", ".", "set_yticklabels", "(", "y_tickslabels", ")", "\n", "\n", "#", "\n", "\n", "ax_win", "=", "mpl_fig", ".", "add_subplot", "(", "313", ")", "\n", "width", "=", "0.50", "\n", "p1", "=", "ax_win", ".", "bar", "(", "exps_range", ",", "win_t_sizes", ",", "width", ")", "\n", "p2", "=", "ax_win", ".", "bar", "(", "exps_range", ",", "win_f_sizes", ",", "width", ",", "bottom", "=", "win_t_sizes", ")", "\n", "\n", "ax_win", ".", "set_ylabel", "(", "'Convolutional window sizes'", ")", "\n", "ax_win", ".", "set_xlabel", "(", "'Experiments ordered by loss'", ")", "\n", "# ax_win.set_title('Convolutional window sizes')", "\n", "\n", "ax_win", ".", "set_xticks", "(", "exps_range", ")", "\n", "# ax.set_xticks(exps_range + width/2.)", "\n", "ax_win", ".", "set_xticklabels", "(", "exps_range", ")", "\n", "# y_ticks = np.arange(0, param_thr, 2e6)", "\n", "# y_tickslabels = np.arange(0, param_thr / 1e6, 2e6 / 1e6)", "\n", "# y_tickslabels = [str(lab) for lab in y_tickslabels]", "\n", "# ax_win.set_yticks(y_ticks)", "\n", "# ax_win.set_yticklabels(y_tickslabels)", "\n", "\n", "# make vertical line befor experiments with loss>0.17", "\n", "tmp", "=", "[", "ind", "for", "ind", ",", "loss", "in", "enumerate", "(", "sorted_losses", ")", "if", "loss", ">=", "0.17", "]", "\n", "\n", "ax_loss", ".", "axvline", "(", "tmp", "[", "0", "]", "-", "0.5", ",", "linestyle", "=", "\"--\"", ",", "lw", "=", "1", ")", "\n", "ax", ".", "axvline", "(", "tmp", "[", "0", "]", "-", "0.5", ",", "linestyle", "=", "\"--\"", ",", "lw", "=", "1", ")", "\n", "ax_win", ".", "axvline", "(", "tmp", "[", "0", "]", "-", "0.5", ",", "linestyle", "=", "\"--\"", ",", "lw", "=", "1", ")", "\n", "\n", "# plotly_fig = tls.mpl_to_plotly(mpl_fig)", "\n", "#", "\n", "# # For Legend", "\n", "# plotly_fig[\"layout\"][\"showlegend\"] = True", "\n", "# plotly_fig[\"data\"][0][\"name\"] = \"CNN param count\"", "\n", "# plotly_fig[\"data\"][1][\"name\"] = \"LSTM param count\"", "\n", "# plotly_fig[\"data\"][2][\"name\"] = \"Output param count\"", "\n", "# plotlypy.iplot(plotly_fig, filename='stacked-bar-chart')", "\n", "1", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.static.kill_processes.kill_processes": [[7, 23], ["os.listdir", "f.split", "os.system", "os.system", "socket.gethostbyname", "socket.gethostname"], "function", ["None"], ["def", "kill_processes", "(", "processdir", ")", ":", "\n", "    ", "'''kill all processes that reported in the processdir'''", "\n", "\n", "files", "=", "os", ".", "listdir", "(", "processdir", ")", "\n", "\n", "for", "f", "in", "files", ":", "\n", "        ", "splitfile", "=", "f", ".", "split", "(", "'-'", ")", "\n", "machine", "=", "splitfile", "[", "0", "]", "\n", "pid", "=", "splitfile", "[", "1", "]", "\n", "if", "(", "machine", "==", "socket", ".", "gethostbyname", "(", "socket", ".", "gethostname", "(", ")", ")", "\n", "or", "machine", "==", "'127.0.0.1'", ")", ":", "\n", "            ", "os", ".", "system", "(", "'kill %s'", "%", "pid", ")", "\n", "", "else", ":", "\n", "            ", "os", ".", "system", "(", "'ssh -o StrictHostKeyChecking=no -o '", "\n", "'UserKnownHostsFile=/dev/null %s \"kill %s\"'", "\n", "%", "(", "machine", ",", "pid", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn.bidirectional_dynamic_rnn_time_input": [[30, 156], ["tensorflow.python.ops.rnn_cell_impl.assert_like_rnncell", "tensorflow.python.ops.rnn_cell_impl.assert_like_rnncell", "tensorflow.python.ops.variable_scope.variable_scope", "type", "tuple", "rnn.bidirectional_dynamic_rnn_time_input._reverse"], "function", ["None"], ["def", "bidirectional_dynamic_rnn_time_input", "(", "cell_fw", ",", "cell_bw", ",", "inputs", ",", "sequence_length", "=", "None", ",", "\n", "initial_state_fw", "=", "None", ",", "initial_state_bw", "=", "None", ",", "\n", "dtype", "=", "None", ",", "parallel_iterations", "=", "None", ",", "\n", "swap_memory", "=", "False", ",", "time_major", "=", "False", ",", "scope", "=", "None", ")", ":", "\n", "  ", "\"\"\"Creates a dynamic version of bidirectional recurrent neural network, add current\n  time to input of cell.\n  Takes input and builds independent forward and backward RNNs. The input_size\n  of forward and backward cell must match. The initial state for both directions\n  is zero by default (but can be set optionally) and no intermediate states are\n  ever returned -- the network is fully unrolled for the given (passed in)\n  length(s) of the sequence(s) or completely unrolled if length(s) is not\n  given.\n  Args:\n    cell_fw: An instance of RNNCell, to be used for forward direction.\n    cell_bw: An instance of RNNCell, to be used for backward direction.\n    inputs: The RNN inputs.\n      If time_major == False (default), this must be a tensor of shape:\n        `[batch_size, max_time, ...]`, or a nested tuple of such elements.\n      If time_major == True, this must be a tensor of shape:\n        `[max_time, batch_size, ...]`, or a nested tuple of such elements.\n    sequence_length: (optional) An int32/int64 vector, size `[batch_size]`,\n      containing the actual lengths for each of the sequences in the batch.\n      If not provided, all batch entries are assumed to be full sequences; and\n      time reversal is applied from time `0` to `max_time` for each sequence.\n    initial_state_fw: (optional) An initial state for the forward RNN.\n      This must be a tensor of appropriate type and shape\n      `[batch_size, cell_fw.state_size]`.\n      If `cell_fw.state_size` is a tuple, this should be a tuple of\n      tensors having shapes `[batch_size, s] for s in cell_fw.state_size`.\n    initial_state_bw: (optional) Same as for `initial_state_fw`, but using\n      the corresponding properties of `cell_bw`.\n    dtype: (optional) The data type for the initial states and expected output.\n      Required if initial_states are not provided or RNN states have a\n      heterogeneous dtype.\n    parallel_iterations: (Default: 32).  The number of iterations to run in\n      parallel.  Those operations which do not have any temporal dependency\n      and can be run in parallel, will be.  This parameter trades off\n      time for space.  Values >> 1 use more memory but take less time,\n      while smaller values use less memory but computations take longer.\n    swap_memory: Transparently swap the tensors produced in forward inference\n      but needed for back prop from GPU to CPU.  This allows training RNNs\n      which would typically not fit on a single GPU, with very minimal (or no)\n      performance penalty.\n    time_major: The shape format of the `inputs` and `outputs` Tensors.\n      If true, these `Tensors` must be shaped `[max_time, batch_size, depth]`.\n      If false, these `Tensors` must be shaped `[batch_size, max_time, depth]`.\n      Using `time_major = True` is a bit more efficient because it avoids\n      transposes at the beginning and end of the RNN calculation.  However,\n      most TensorFlow data is batch-major, so by default this function\n      accepts input and emits output in batch-major form.\n    scope: VariableScope for the created subgraph; defaults to\n      \"bidirectional_rnn\"\n  Returns:\n    A tuple (outputs, output_states) where:\n      outputs: A tuple (output_fw, output_bw) containing the forward and\n        the backward rnn output `Tensor`.\n        If time_major == False (default),\n          output_fw will be a `Tensor` shaped:\n          `[batch_size, max_time, cell_fw.output_size]`\n          and output_bw will be a `Tensor` shaped:\n          `[batch_size, max_time, cell_bw.output_size]`.\n        If time_major == True,\n          output_fw will be a `Tensor` shaped:\n          `[max_time, batch_size, cell_fw.output_size]`\n          and output_bw will be a `Tensor` shaped:\n          `[max_time, batch_size, cell_bw.output_size]`.\n        It returns a tuple instead of a single concatenated `Tensor`, unlike\n        in the `bidirectional_rnn`. If the concatenated one is preferred,\n        the forward and backward outputs can be concatenated as\n        `tf.concat(outputs, 2)`.\n      output_states: A tuple (output_state_fw, output_state_bw) containing\n        the forward and the backward final states of bidirectional rnn.\n  Raises:\n    TypeError: If `cell_fw` or `cell_bw` is not an instance of `RNNCell`.\n  \"\"\"", "\n", "rnn_cell_impl", ".", "assert_like_rnncell", "(", "\"cell_fw\"", ",", "cell_fw", ")", "\n", "rnn_cell_impl", ".", "assert_like_rnncell", "(", "\"cell_bw\"", ",", "cell_bw", ")", "\n", "\n", "with", "vs", ".", "variable_scope", "(", "scope", "or", "\"bidirectional_rnn\"", ")", ":", "\n", "# Forward direction", "\n", "    ", "with", "vs", ".", "variable_scope", "(", "\"fw\"", ")", "as", "fw_scope", ":", "\n", "      ", "output_fw", ",", "output_state_fw", "=", "dynamic_rnn_time_input", "(", "\n", "cell", "=", "cell_fw", ",", "inputs", "=", "inputs", ",", "sequence_length", "=", "sequence_length", ",", "\n", "initial_state", "=", "initial_state_fw", ",", "dtype", "=", "dtype", ",", "\n", "parallel_iterations", "=", "parallel_iterations", ",", "swap_memory", "=", "swap_memory", ",", "\n", "time_major", "=", "time_major", ",", "scope", "=", "fw_scope", ")", "\n", "\n", "# Backward direction", "\n", "", "if", "not", "time_major", ":", "\n", "      ", "time_dim", "=", "1", "\n", "batch_dim", "=", "0", "\n", "", "else", ":", "\n", "      ", "time_dim", "=", "0", "\n", "batch_dim", "=", "1", "\n", "\n", "", "def", "_reverse", "(", "input_", ",", "seq_lengths", ",", "seq_axis", ",", "batch_axis", ")", ":", "\n", "      ", "if", "seq_lengths", "is", "not", "None", ":", "\n", "        ", "return", "array_ops", ".", "reverse_sequence", "(", "\n", "input", "=", "input_", ",", "seq_lengths", "=", "seq_lengths", ",", "\n", "seq_axis", "=", "seq_axis", ",", "batch_axis", "=", "batch_axis", ")", "\n", "", "else", ":", "\n", "        ", "return", "array_ops", ".", "reverse", "(", "input_", ",", "axis", "=", "[", "seq_axis", "]", ")", "\n", "\n", "", "", "with", "vs", ".", "variable_scope", "(", "\"bw\"", ")", "as", "bw_scope", ":", "\n", "      ", "inputs_reverse", "=", "_reverse", "(", "\n", "inputs", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "\n", "tmp", ",", "output_state_bw", "=", "dynamic_rnn_time_input", "(", "\n", "cell", "=", "cell_bw", ",", "inputs", "=", "inputs_reverse", ",", "sequence_length", "=", "sequence_length", ",", "\n", "initial_state", "=", "initial_state_bw", ",", "dtype", "=", "dtype", ",", "\n", "parallel_iterations", "=", "parallel_iterations", ",", "swap_memory", "=", "swap_memory", ",", "\n", "time_major", "=", "time_major", ",", "scope", "=", "bw_scope", ")", "\n", "\n", "", "", "if", "type", "(", "tmp", ")", "==", "tuple", ":", "\n", "    ", "output_bw", "=", "tuple", "(", "(", "_reverse", "(", "\n", "tmp_i", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "for", "tmp_i", "in", "tmp", ")", ")", "\n", "", "else", ":", "\n", "    ", "output_bw", "=", "_reverse", "(", "\n", "tmp", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "\n", "\n", "", "outputs", "=", "(", "output_fw", ",", "output_bw", ")", "\n", "output_states", "=", "(", "output_state_fw", ",", "output_state_bw", ")", "\n", "\n", "return", "(", "outputs", ",", "output_states", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn.bidirectional_dynamic_rnn_2inputs_time_input": [[158, 296], ["tensorflow.python.ops.rnn_cell_impl.assert_like_rnncell", "tensorflow.python.ops.rnn_cell_impl.assert_like_rnncell", "tensorflow.python.ops.variable_scope.variable_scope", "type", "tuple", "rnn.bidirectional_dynamic_rnn_time_input._reverse"], "function", ["None"], ["", "def", "bidirectional_dynamic_rnn_2inputs_time_input", "(", "cell_fw", ",", "cell_bw", ",", "inputs_fw", ",", "inputs_bw", ",", "\n", "sequence_length", "=", "None", ",", "time_input_for_fw", "=", "True", ",", "time_input_for_bw", "=", "True", ",", "\n", "initial_state_fw", "=", "None", ",", "initial_state_bw", "=", "None", ",", "\n", "dtype", "=", "None", ",", "parallel_iterations", "=", "None", ",", "\n", "swap_memory", "=", "False", ",", "time_major", "=", "False", ",", "scope", "=", "None", ")", ":", "\n", "  ", "\"\"\"Creates a dynamic version of bidirectional recurrent neural network, add current\n  time to input of cell. A different input for forward and backward direction are used,\n  which means they are actually fully decoupled, and 2 unidirectional RNNs could be used.\n  For sake of concistency, we allow this function as well.\n  Takes input and builds independent forward and backward RNNs. The input_size\n  of forward and backward cell must match. The initial state for both directions\n  is zero by default (but can be set optionally) and no intermediate states are\n  ever returned -- the network is fully unrolled for the given (passed in)\n  length(s) of the sequence(s) or completely unrolled if length(s) is not\n  given.\n  Args:\n    cell_fw: An instance of RNNCell, to be used for forward direction.\n    cell_bw: An instance of RNNCell, to be used for backward direction.\n    inputs_fw: The RNN inputs for forward direction.\n      If time_major == False (default), this must be a tensor of shape:\n        `[batch_size, max_time, ...]`, or a nested tuple of such elements.\n      If time_major == True, this must be a tensor of shape:\n        `[max_time, batch_size, ...]`, or a nested tuple of such elements.\n    inputs_bw: The RNN inputs for backward direction.\n    sequence_length: (optional) An int32/int64 vector, size `[batch_size]`,\n      containing the actual lengths for each of the sequences in the batch.\n      If not provided, all batch entries are assumed to be full sequences; and\n      time reversal is applied from time `0` to `max_time` for each sequence.\n    initial_state_fw: (optional) An initial state for the forward RNN.\n      This must be a tensor of appropriate type and shape\n      `[batch_size, cell_fw.state_size]`.\n      If `cell_fw.state_size` is a tuple, this should be a tuple of\n      tensors having shapes `[batch_size, s] for s in cell_fw.state_size`.\n    initial_state_bw: (optional) Same as for `initial_state_fw`, but using\n      the corresponding properties of `cell_bw`.\n    dtype: (optional) The data type for the initial states and expected output.\n      Required if initial_states are not provided or RNN states have a\n      heterogeneous dtype.\n    parallel_iterations: (Default: 32).  The number of iterations to run in\n      parallel.  Those operations which do not have any temporal dependency\n      and can be run in parallel, will be.  This parameter trades off\n      time for space.  Values >> 1 use more memory but take less time,\n      while smaller values use less memory but computations take longer.\n    swap_memory: Transparently swap the tensors produced in forward inference\n      but needed for back prop from GPU to CPU.  This allows training RNNs\n      which would typically not fit on a single GPU, with very minimal (or no)\n      performance penalty.\n    time_major: The shape format of the `inputs` and `outputs` Tensors.\n      If true, these `Tensors` must be shaped `[max_time, batch_size, depth]`.\n      If false, these `Tensors` must be shaped `[batch_size, max_time, depth]`.\n      Using `time_major = True` is a bit more efficient because it avoids\n      transposes at the beginning and end of the RNN calculation.  However,\n      most TensorFlow data is batch-major, so by default this function\n      accepts input and emits output in batch-major form.\n    scope: VariableScope for the created subgraph; defaults to\n      \"bidirectional_rnn\"\n  Returns:\n    A tuple (outputs, output_states) where:\n      outputs: A tuple (output_fw, output_bw) containing the forward and\n        the backward rnn output `Tensor`.\n        If time_major == False (default),\n          output_fw will be a `Tensor` shaped:\n          `[batch_size, max_time, cell_fw.output_size]`\n          and output_bw will be a `Tensor` shaped:\n          `[batch_size, max_time, cell_bw.output_size]`.\n        If time_major == True,\n          output_fw will be a `Tensor` shaped:\n          `[max_time, batch_size, cell_fw.output_size]`\n          and output_bw will be a `Tensor` shaped:\n          `[max_time, batch_size, cell_bw.output_size]`.\n        It returns a tuple instead of a single concatenated `Tensor`, unlike\n        in the `bidirectional_rnn`. If the concatenated one is preferred,\n        the forward and backward outputs can be concatenated as\n        `tf.concat(outputs, 2)`.\n      output_states: A tuple (output_state_fw, output_state_bw) containing\n        the forward and the backward final states of bidirectional rnn.\n  Raises:\n    TypeError: If `cell_fw` or `cell_bw` is not an instance of `RNNCell`.\n  \"\"\"", "\n", "rnn_cell_impl", ".", "assert_like_rnncell", "(", "\"cell_fw\"", ",", "cell_fw", ")", "\n", "rnn_cell_impl", ".", "assert_like_rnncell", "(", "\"cell_bw\"", ",", "cell_bw", ")", "\n", "\n", "with", "vs", ".", "variable_scope", "(", "scope", "or", "\"bidirectional_rnn\"", ")", ":", "\n", "# Forward direction", "\n", "    ", "with", "vs", ".", "variable_scope", "(", "\"fw\"", ")", "as", "fw_scope", ":", "\n", "      ", "if", "time_input_for_fw", ":", "\n", "        ", "dynamic_rnn_fw_type", "=", "dynamic_rnn_time_input", "\n", "", "else", ":", "\n", "        ", "dynamic_rnn_fw_type", "=", "rnn", ".", "dynamic_rnn", "\n", "", "output_fw", ",", "output_state_fw", "=", "dynamic_rnn_fw_type", "(", "\n", "cell", "=", "cell_fw", ",", "inputs", "=", "inputs_fw", ",", "sequence_length", "=", "sequence_length", ",", "\n", "initial_state", "=", "initial_state_fw", ",", "dtype", "=", "dtype", ",", "\n", "parallel_iterations", "=", "parallel_iterations", ",", "swap_memory", "=", "swap_memory", ",", "\n", "time_major", "=", "time_major", ",", "scope", "=", "fw_scope", ")", "\n", "\n", "# Backward direction", "\n", "", "if", "not", "time_major", ":", "\n", "      ", "time_dim", "=", "1", "\n", "batch_dim", "=", "0", "\n", "", "else", ":", "\n", "      ", "time_dim", "=", "0", "\n", "batch_dim", "=", "1", "\n", "\n", "", "def", "_reverse", "(", "input_", ",", "seq_lengths", ",", "seq_axis", ",", "batch_axis", ")", ":", "\n", "      ", "if", "seq_lengths", "is", "not", "None", ":", "\n", "        ", "return", "array_ops", ".", "reverse_sequence", "(", "\n", "input", "=", "input_", ",", "seq_lengths", "=", "seq_lengths", ",", "\n", "seq_axis", "=", "seq_axis", ",", "batch_axis", "=", "batch_axis", ")", "\n", "", "else", ":", "\n", "        ", "return", "array_ops", ".", "reverse", "(", "input_", ",", "axis", "=", "[", "seq_axis", "]", ")", "\n", "\n", "", "", "with", "vs", ".", "variable_scope", "(", "\"bw\"", ")", "as", "bw_scope", ":", "\n", "      ", "inputs_reverse", "=", "_reverse", "(", "\n", "inputs_bw", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "\n", "if", "time_input_for_bw", ":", "\n", "        ", "dynamic_rnn_bw_type", "=", "dynamic_rnn_time_input", "\n", "", "else", ":", "\n", "        ", "dynamic_rnn_bw_type", "=", "rnn", ".", "dynamic_rnn", "\n", "", "tmp", ",", "output_state_bw", "=", "dynamic_rnn_bw_type", "(", "\n", "cell", "=", "cell_bw", ",", "inputs", "=", "inputs_reverse", ",", "sequence_length", "=", "sequence_length", ",", "\n", "initial_state", "=", "initial_state_bw", ",", "dtype", "=", "dtype", ",", "\n", "parallel_iterations", "=", "parallel_iterations", ",", "swap_memory", "=", "swap_memory", ",", "\n", "time_major", "=", "time_major", ",", "scope", "=", "bw_scope", ")", "\n", "\n", "", "", "if", "type", "(", "tmp", ")", "==", "tuple", ":", "\n", "    ", "output_bw", "=", "tuple", "(", "(", "_reverse", "(", "\n", "tmp_i", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "for", "tmp_i", "in", "tmp", ")", ")", "\n", "", "else", ":", "\n", "    ", "output_bw", "=", "_reverse", "(", "\n", "tmp", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "\n", "\n", "", "outputs", "=", "(", "output_fw", ",", "output_bw", ")", "\n", "output_states", "=", "(", "output_state_fw", ",", "output_state_bw", ")", "\n", "\n", "return", "(", "outputs", ",", "output_states", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn.bidirectional_dynamic_rnn_2inputs": [[297, 427], ["tensorflow.python.ops.rnn_cell_impl.assert_like_rnncell", "tensorflow.python.ops.rnn_cell_impl.assert_like_rnncell", "tensorflow.python.ops.variable_scope.variable_scope", "type", "tuple", "rnn.bidirectional_dynamic_rnn_time_input._reverse"], "function", ["None"], ["", "def", "bidirectional_dynamic_rnn_2inputs", "(", "cell_fw", ",", "cell_bw", ",", "inputs_fw", ",", "inputs_bw", ",", "\n", "sequence_length", "=", "None", ",", "\n", "initial_state_fw", "=", "None", ",", "initial_state_bw", "=", "None", ",", "\n", "dtype", "=", "None", ",", "parallel_iterations", "=", "None", ",", "\n", "swap_memory", "=", "False", ",", "time_major", "=", "False", ",", "scope", "=", "None", ")", ":", "\n", "  ", "\"\"\"Creates a dynamic version of bidirectional recurrent neural network. \n  A different input for forward and backward direction are used,\n  which means they are actually fully decoupled, and 2 unidirectional RNNs could be used.\n  For sake of concistency, we allow this function as well.\n  Takes input and builds independent forward and backward RNNs. The input_size\n  of forward and backward cell must match. The initial state for both directions\n  is zero by default (but can be set optionally) and no intermediate states are\n  ever returned -- the network is fully unrolled for the given (passed in)\n  length(s) of the sequence(s) or completely unrolled if length(s) is not\n  given.\n  Args:\n    cell_fw: An instance of RNNCell, to be used for forward direction.\n    cell_bw: An instance of RNNCell, to be used for backward direction.\n    inputs_fw: The RNN inputs for forward direction.\n      If time_major == False (default), this must be a tensor of shape:\n        `[batch_size, max_time, ...]`, or a nested tuple of such elements.\n      If time_major == True, this must be a tensor of shape:\n        `[max_time, batch_size, ...]`, or a nested tuple of such elements.\n    inputs_bw: The RNN inputs for backward direction.\n    sequence_length: (optional) An int32/int64 vector, size `[batch_size]`,\n      containing the actual lengths for each of the sequences in the batch.\n      If not provided, all batch entries are assumed to be full sequences; and\n      time reversal is applied from time `0` to `max_time` for each sequence.\n    initial_state_fw: (optional) An initial state for the forward RNN.\n      This must be a tensor of appropriate type and shape\n      `[batch_size, cell_fw.state_size]`.\n      If `cell_fw.state_size` is a tuple, this should be a tuple of\n      tensors having shapes `[batch_size, s] for s in cell_fw.state_size`.\n    initial_state_bw: (optional) Same as for `initial_state_fw`, but using\n      the corresponding properties of `cell_bw`.\n    dtype: (optional) The data type for the initial states and expected output.\n      Required if initial_states are not provided or RNN states have a\n      heterogeneous dtype.\n    parallel_iterations: (Default: 32).  The number of iterations to run in\n      parallel.  Those operations which do not have any temporal dependency\n      and can be run in parallel, will be.  This parameter trades off\n      time for space.  Values >> 1 use more memory but take less time,\n      while smaller values use less memory but computations take longer.\n    swap_memory: Transparently swap the tensors produced in forward inference\n      but needed for back prop from GPU to CPU.  This allows training RNNs\n      which would typically not fit on a single GPU, with very minimal (or no)\n      performance penalty.\n    time_major: The shape format of the `inputs` and `outputs` Tensors.\n      If true, these `Tensors` must be shaped `[max_time, batch_size, depth]`.\n      If false, these `Tensors` must be shaped `[batch_size, max_time, depth]`.\n      Using `time_major = True` is a bit more efficient because it avoids\n      transposes at the beginning and end of the RNN calculation.  However,\n      most TensorFlow data is batch-major, so by default this function\n      accepts input and emits output in batch-major form.\n    scope: VariableScope for the created subgraph; defaults to\n      \"bidirectional_rnn\"\n  Returns:\n    A tuple (outputs, output_states) where:\n      outputs: A tuple (output_fw, output_bw) containing the forward and\n        the backward rnn output `Tensor`.\n        If time_major == False (default),\n          output_fw will be a `Tensor` shaped:\n          `[batch_size, max_time, cell_fw.output_size]`\n          and output_bw will be a `Tensor` shaped:\n          `[batch_size, max_time, cell_bw.output_size]`.\n        If time_major == True,\n          output_fw will be a `Tensor` shaped:\n          `[max_time, batch_size, cell_fw.output_size]`\n          and output_bw will be a `Tensor` shaped:\n          `[max_time, batch_size, cell_bw.output_size]`.\n        It returns a tuple instead of a single concatenated `Tensor`, unlike\n        in the `bidirectional_rnn`. If the concatenated one is preferred,\n        the forward and backward outputs can be concatenated as\n        `tf.concat(outputs, 2)`.\n      output_states: A tuple (output_state_fw, output_state_bw) containing\n        the forward and the backward final states of bidirectional rnn.\n  Raises:\n    TypeError: If `cell_fw` or `cell_bw` is not an instance of `RNNCell`.\n  \"\"\"", "\n", "rnn_cell_impl", ".", "assert_like_rnncell", "(", "\"cell_fw\"", ",", "cell_fw", ")", "\n", "rnn_cell_impl", ".", "assert_like_rnncell", "(", "\"cell_bw\"", ",", "cell_bw", ")", "\n", "\n", "with", "vs", ".", "variable_scope", "(", "scope", "or", "\"bidirectional_rnn\"", ")", ":", "\n", "# Forward direction", "\n", "    ", "with", "vs", ".", "variable_scope", "(", "\"fw\"", ")", "as", "fw_scope", ":", "\n", "      ", "output_fw", ",", "output_state_fw", "=", "rnn", ".", "dynamic_rnn", "(", "\n", "cell", "=", "cell_fw", ",", "inputs", "=", "inputs_fw", ",", "sequence_length", "=", "sequence_length", ",", "\n", "initial_state", "=", "initial_state_fw", ",", "dtype", "=", "dtype", ",", "\n", "parallel_iterations", "=", "parallel_iterations", ",", "swap_memory", "=", "swap_memory", ",", "\n", "time_major", "=", "time_major", ",", "scope", "=", "fw_scope", ")", "\n", "\n", "# Backward direction", "\n", "", "if", "not", "time_major", ":", "\n", "      ", "time_dim", "=", "1", "\n", "batch_dim", "=", "0", "\n", "", "else", ":", "\n", "      ", "time_dim", "=", "0", "\n", "batch_dim", "=", "1", "\n", "\n", "", "def", "_reverse", "(", "input_", ",", "seq_lengths", ",", "seq_axis", ",", "batch_axis", ")", ":", "\n", "      ", "if", "seq_lengths", "is", "not", "None", ":", "\n", "        ", "return", "array_ops", ".", "reverse_sequence", "(", "\n", "input", "=", "input_", ",", "seq_lengths", "=", "seq_lengths", ",", "\n", "seq_axis", "=", "seq_axis", ",", "batch_axis", "=", "batch_axis", ")", "\n", "", "else", ":", "\n", "        ", "return", "array_ops", ".", "reverse", "(", "input_", ",", "axis", "=", "[", "seq_axis", "]", ")", "\n", "\n", "", "", "with", "vs", ".", "variable_scope", "(", "\"bw\"", ")", "as", "bw_scope", ":", "\n", "      ", "inputs_reverse", "=", "_reverse", "(", "\n", "inputs_bw", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "\n", "tmp", ",", "output_state_bw", "=", "rnn", ".", "dynamic_rnn", "(", "\n", "cell", "=", "cell_bw", ",", "inputs", "=", "inputs_reverse", ",", "sequence_length", "=", "sequence_length", ",", "\n", "initial_state", "=", "initial_state_bw", ",", "dtype", "=", "dtype", ",", "\n", "parallel_iterations", "=", "parallel_iterations", ",", "swap_memory", "=", "swap_memory", ",", "\n", "time_major", "=", "time_major", ",", "scope", "=", "bw_scope", ")", "\n", "\n", "", "", "if", "type", "(", "tmp", ")", "==", "tuple", ":", "\n", "    ", "output_bw", "=", "tuple", "(", "(", "_reverse", "(", "\n", "tmp_i", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "for", "tmp_i", "in", "tmp", ")", ")", "\n", "", "else", ":", "\n", "    ", "output_bw", "=", "_reverse", "(", "\n", "tmp", ",", "seq_lengths", "=", "sequence_length", ",", "\n", "seq_axis", "=", "time_dim", ",", "batch_axis", "=", "batch_dim", ")", "\n", "\n", "", "outputs", "=", "(", "output_fw", ",", "output_bw", ")", "\n", "output_states", "=", "(", "output_state_fw", ",", "output_state_bw", ")", "\n", "\n", "return", "(", "outputs", ",", "output_states", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn.dynamic_rnn_time_input": [[428, 597], ["tensorflow.python.ops.rnn_cell_impl.assert_like_rnncell", "tensorflow.python.ops.variable_scope.variable_scope", "tensorflow.python.util.nest.flatten", "tensorflow.python.ops.rnn._best_effort_input_batch_size", "tensorflow.python.util.nest.pack_sequence_as", "rnn._dynamic_rnn_time_input_loop", "tensorflow.python.eager.context.executing_eagerly", "tuple", "tensorflow.python.ops.math_ops.to_int32", "tensorflow.python.ops.array_ops.identity", "cell.zero_state", "tensorflow.python.ops.array_ops.shape", "tensorflow.python.ops.array_ops.stack", "tensorflow.python.ops.control_flow_ops.Assert", "tensorflow.python.util.nest.map_structure", "varscope.set_caching_device", "tensorflow.python.framework.ops.convert_to_tensor", "ValueError", "ValueError", "tensorflow.python.ops.math_ops.reduce_all", "tensorflow.python.eager.context.executing_eagerly", "tensorflow.python.framework.ops.control_dependencies", "tensorflow.python.ops.array_ops.identity", "tensorflow.python.ops.rnn._transpose_batch_time", "array_ops.identity.get_shape", "tensorflow.python.ops.math_ops.equal", "array_ops.identity.get_shape", "rnn.dynamic_rnn_time_input._assert_has_shape"], "function", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn._dynamic_rnn_time_input_loop", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.zero_state"], ["", "def", "dynamic_rnn_time_input", "(", "cell", ",", "inputs", ",", "sequence_length", "=", "None", ",", "initial_state", "=", "None", ",", "\n", "dtype", "=", "None", ",", "parallel_iterations", "=", "None", ",", "swap_memory", "=", "False", ",", "\n", "time_major", "=", "False", ",", "scope", "=", "None", ")", ":", "\n", "  ", "\"\"\"Creates a recurrent neural network specified by RNNCell `cell`, add current\n  time to input of cell\n  Performs fully dynamic unrolling of `inputs`.\n  Example:\n  ```python\n  # create a BasicRNNCell\n  rnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\n  # 'outputs' is a tensor of shape [batch_size, max_time, cell_state_size]\n  # defining initial state\n  initial_state = rnn_cell.zero_state(batch_size, dtype=tf.float32)\n  # 'state' is a tensor of shape [batch_size, cell_state_size]\n  outputs, state = tf.nn.dynamic_rnn(rnn_cell, input_data,\n                                     initial_state=initial_state,\n                                     dtype=tf.float32)\n  ```\n  ```python\n  # create 2 LSTMCells\n  rnn_layers = [tf.nn.rnn_cell.LSTMCell(size) for size in [128, 256]]\n  # create a RNN cell composed sequentially of a number of RNNCells\n  multi_rnn_cell = tf.nn.rnn_cell.MultiRNNCell(rnn_layers)\n  # 'outputs' is a tensor of shape [batch_size, max_time, 256]\n  # 'state' is a N-tuple where N is the number of LSTMCells containing a\n  # tf.contrib.rnn.LSTMStateTuple for each cell\n  outputs, state = tf.nn.dynamic_rnn(cell=multi_rnn_cell,\n                                     inputs=data,\n                                     dtype=tf.float32)\n  ```\n  Args:\n    cell: An instance of RNNCell.\n    inputs: The RNN inputs.\n      If `time_major == False` (default), this must be a `Tensor` of shape:\n        `[batch_size, max_time, ...]`, or a nested tuple of such\n        elements.\n      If `time_major == True`, this must be a `Tensor` of shape:\n        `[max_time, batch_size, ...]`, or a nested tuple of such\n        elements.\n      This may also be a (possibly nested) tuple of Tensors satisfying\n      this property.  The first two dimensions must match across all the inputs,\n      but otherwise the ranks and other shape components may differ.\n      In this case, input to `cell` at each time-step will replicate the\n      structure of these tuples, except for the time dimension (from which the\n      time is taken).\n      The input to `cell` at each time step will be a `Tensor` or (possibly\n      nested) tuple of Tensors each with dimensions `[batch_size, ...]`.\n    sequence_length: (optional) An int32/int64 vector sized `[batch_size]`.\n      Used to copy-through state and zero-out outputs when past a batch\n      element's sequence length.  So it's more for correctness than performance.\n    initial_state: (optional) An initial state for the RNN.\n      If `cell.state_size` is an integer, this must be\n      a `Tensor` of appropriate type and shape `[batch_size, cell.state_size]`.\n      If `cell.state_size` is a tuple, this should be a tuple of\n      tensors having shapes `[batch_size, s] for s in cell.state_size`.\n    dtype: (optional) The data type for the initial state and expected output.\n      Required if initial_state is not provided or RNN state has a heterogeneous\n      dtype.\n    parallel_iterations: (Default: 32).  The number of iterations to run in\n      parallel.  Those operations which do not have any temporal dependency\n      and can be run in parallel, will be.  This parameter trades off\n      time for space.  Values >> 1 use more memory but take less time,\n      while smaller values use less memory but computations take longer.\n    swap_memory: Transparently swap the tensors produced in forward inference\n      but needed for back prop from GPU to CPU.  This allows training RNNs\n      which would typically not fit on a single GPU, with very minimal (or no)\n      performance penalty.\n    time_major: The shape format of the `inputs` and `outputs` Tensors.\n      If true, these `Tensors` must be shaped `[max_time, batch_size, depth]`.\n      If false, these `Tensors` must be shaped `[batch_size, max_time, depth]`.\n      Using `time_major = True` is a bit more efficient because it avoids\n      transposes at the beginning and end of the RNN calculation.  However,\n      most TensorFlow data is batch-major, so by default this function\n      accepts input and emits output in batch-major form.\n    scope: VariableScope for the created subgraph; defaults to \"rnn\".\n  Returns:\n    A pair (outputs, state) where:\n    outputs: The RNN output `Tensor`.\n      If time_major == False (default), this will be a `Tensor` shaped:\n        `[batch_size, max_time, cell.output_size]`.\n      If time_major == True, this will be a `Tensor` shaped:\n        `[max_time, batch_size, cell.output_size]`.\n      Note, if `cell.output_size` is a (possibly nested) tuple of integers\n      or `TensorShape` objects, then `outputs` will be a tuple having the\n      same structure as `cell.output_size`, containing Tensors having shapes\n      corresponding to the shape data in `cell.output_size`.\n    state: The final state.  If `cell.state_size` is an int, this\n      will be shaped `[batch_size, cell.state_size]`.  If it is a\n      `TensorShape`, this will be shaped `[batch_size] + cell.state_size`.\n      If it is a (possibly nested) tuple of ints or `TensorShape`, this will\n      be a tuple having the corresponding shapes. If cells are `LSTMCells`\n      `state` will be a tuple containing a `LSTMStateTuple` for each cell.\n  Raises:\n    TypeError: If `cell` is not an instance of RNNCell.\n    ValueError: If inputs is None or an empty list.\n  \"\"\"", "\n", "rnn_cell_impl", ".", "assert_like_rnncell", "(", "\"cell\"", ",", "cell", ")", "\n", "\n", "with", "vs", ".", "variable_scope", "(", "scope", "or", "\"rnn\"", ")", "as", "varscope", ":", "\n", "# Create a new scope in which the caching device is either", "\n", "# determined by the parent scope, or is set to place the cached", "\n", "# Variable using the same placement as for the rest of the RNN.", "\n", "    ", "if", "not", "context", ".", "executing_eagerly", "(", ")", ":", "\n", "      ", "if", "varscope", ".", "caching_device", "is", "None", ":", "\n", "        ", "varscope", ".", "set_caching_device", "(", "lambda", "op", ":", "op", ".", "device", ")", "\n", "\n", "# By default, time_major==False and inputs are batch-major: shaped", "\n", "#   [batch, time, depth]", "\n", "# For internal calculations, we transpose to [time, batch, depth]", "\n", "", "", "flat_input", "=", "nest", ".", "flatten", "(", "inputs", ")", "\n", "\n", "if", "not", "time_major", ":", "\n", "# (B,T,D) => (T,B,D)", "\n", "      ", "flat_input", "=", "[", "ops", ".", "convert_to_tensor", "(", "input_", ")", "for", "input_", "in", "flat_input", "]", "\n", "flat_input", "=", "tuple", "(", "rnn", ".", "_transpose_batch_time", "(", "input_", ")", "for", "input_", "in", "flat_input", ")", "\n", "\n", "", "parallel_iterations", "=", "parallel_iterations", "or", "32", "\n", "if", "sequence_length", "is", "not", "None", ":", "\n", "      ", "sequence_length", "=", "math_ops", ".", "to_int32", "(", "sequence_length", ")", "\n", "if", "sequence_length", ".", "get_shape", "(", ")", ".", "ndims", "not", "in", "(", "None", ",", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"sequence_length must be a vector of length batch_size, \"", "\n", "\"but saw shape: %s\"", "%", "sequence_length", ".", "get_shape", "(", ")", ")", "\n", "", "sequence_length", "=", "array_ops", ".", "identity", "(", "# Just to find it in the graph.", "\n", "sequence_length", ",", "name", "=", "\"sequence_length\"", ")", "\n", "\n", "", "batch_size", "=", "rnn", ".", "_best_effort_input_batch_size", "(", "flat_input", ")", "\n", "\n", "if", "initial_state", "is", "not", "None", ":", "\n", "      ", "state", "=", "initial_state", "\n", "", "else", ":", "\n", "      ", "if", "not", "dtype", ":", "\n", "        ", "raise", "ValueError", "(", "\"If there is no initial_state, you must give a dtype.\"", ")", "\n", "", "state", "=", "cell", ".", "zero_state", "(", "batch_size", ",", "dtype", ")", "\n", "\n", "", "def", "_assert_has_shape", "(", "x", ",", "shape", ")", ":", "\n", "      ", "x_shape", "=", "array_ops", ".", "shape", "(", "x", ")", "\n", "packed_shape", "=", "array_ops", ".", "stack", "(", "shape", ")", "\n", "return", "control_flow_ops", ".", "Assert", "(", "\n", "math_ops", ".", "reduce_all", "(", "math_ops", ".", "equal", "(", "x_shape", ",", "packed_shape", ")", ")", ",", "\n", "[", "\"Expected shape for Tensor %s is \"", "%", "x", ".", "name", ",", "\n", "packed_shape", ",", "\" but saw shape: \"", ",", "x_shape", "]", ")", "\n", "\n", "", "if", "not", "context", ".", "executing_eagerly", "(", ")", "and", "sequence_length", "is", "not", "None", ":", "\n", "# Perform some shape validation", "\n", "      ", "with", "ops", ".", "control_dependencies", "(", "\n", "[", "_assert_has_shape", "(", "sequence_length", ",", "[", "batch_size", "]", ")", "]", ")", ":", "\n", "        ", "sequence_length", "=", "array_ops", ".", "identity", "(", "\n", "sequence_length", ",", "name", "=", "\"CheckSeqLen\"", ")", "\n", "\n", "", "", "inputs", "=", "nest", ".", "pack_sequence_as", "(", "structure", "=", "inputs", ",", "flat_sequence", "=", "flat_input", ")", "\n", "\n", "(", "outputs", ",", "final_state", ")", "=", "_dynamic_rnn_time_input_loop", "(", "\n", "cell", ",", "\n", "inputs", ",", "\n", "state", ",", "\n", "parallel_iterations", "=", "parallel_iterations", ",", "\n", "swap_memory", "=", "swap_memory", ",", "\n", "sequence_length", "=", "sequence_length", ",", "\n", "dtype", "=", "dtype", ")", "\n", "\n", "# Outputs of _dynamic_rnn_time_input_loop are always shaped [time, batch, depth].", "\n", "# If we are performing batch-major calculations, transpose output back", "\n", "# to shape [batch, time, depth]", "\n", "if", "not", "time_major", ":", "\n", "# (T,B,D) => (B,T,D)", "\n", "      ", "outputs", "=", "nest", ".", "map_structure", "(", "rnn", ".", "_transpose_batch_time", ",", "outputs", ")", "\n", "\n", "", "return", "(", "outputs", ",", "final_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn._dynamic_rnn_time_input_loop": [[599, 800], ["isinstance", "tensorflow.python.util.nest.flatten", "tensorflow.python.util.nest.flatten", "tensorflow.python.ops.array_ops.shape", "tensorflow.python.ops.rnn._best_effort_input_batch_size", "tuple", "tuple", "tensorflow.python.util.nest.pack_sequence_as", "tensorflow.python.ops.array_ops.constant", "tensorflow.python.ops.control_flow_ops.while_loop", "tensorflow.python.util.nest.pack_sequence_as", "inputs_got_shape[].as_list", "_concat", "tensorflow.python.ops.array_ops.zeros", "tensorflow.python.ops.math_ops.reduce_min", "tensorflow.python.ops.math_ops.reduce_max", "tensorflow.python.framework.ops.name_scope", "tensorflow.python.ops.tensor_array_ops.TensorArray", "tensorflow.python.eager.context.executing_eagerly", "tuple", "tuple", "tuple", "tuple", "tensorflow.python.util.nest.pack_sequence_as", "tensorflow.python.util.nest.flatten", "tensorflow.python.ops.math_ops.minimum", "tuple", "zip", "tensorflow.python.util.nest.map_structure_up_to", "input_.get_shape().with_rank_at_least", "shape[].is_fully_defined", "ValueError", "ValueError", "ValueError", "tensorflow.python.ops.array_ops.stack", "tensorflow.python.ops.rnn._infer_state_dtype", "rnn._dynamic_rnn_time_input_loop._create_zero_arrays"], "function", ["None"], ["", "", "def", "_dynamic_rnn_time_input_loop", "(", "cell", ",", "\n", "inputs", ",", "\n", "initial_state", ",", "\n", "parallel_iterations", ",", "\n", "swap_memory", ",", "\n", "sequence_length", "=", "None", ",", "\n", "dtype", "=", "None", ")", ":", "\n", "  ", "\"\"\"Internal implementation of Dynamic RNN, add current time to input of cell.\n  Args:\n    cell: An instance of RNNCell.\n    inputs: A `Tensor` of shape [time, batch_size, input_size], or a nested\n      tuple of such elements.\n    initial_state: A `Tensor` of shape `[batch_size, state_size]`, or if\n      `cell.state_size` is a tuple, then this should be a tuple of\n      tensors having shapes `[batch_size, s] for s in cell.state_size`.\n    parallel_iterations: Positive Python int.\n    swap_memory: A Python boolean\n    sequence_length: (optional) An `int32` `Tensor` of shape [batch_size].\n    dtype: (optional) Expected dtype of output. If not specified, inferred from\n      initial_state.\n  Returns:\n    Tuple `(final_outputs, final_state)`.\n    final_outputs:\n      A `Tensor` of shape `[time, batch_size, cell.output_size]`.  If\n      `cell.output_size` is a (possibly nested) tuple of ints or `TensorShape`\n      objects, then this returns a (possibly nested) tuple of Tensors matching\n      the corresponding shapes.\n    final_state:\n      A `Tensor`, or possibly nested tuple of Tensors, matching in length\n      and shapes to `initial_state`.\n  Raises:\n    ValueError: If the input depth cannot be inferred via shape inference\n      from the inputs.\n  \"\"\"", "\n", "state", "=", "initial_state", "\n", "assert", "isinstance", "(", "parallel_iterations", ",", "int", ")", ",", "\"parallel_iterations must be int\"", "\n", "\n", "state_size", "=", "cell", ".", "state_size", "\n", "\n", "flat_input", "=", "nest", ".", "flatten", "(", "inputs", ")", "\n", "flat_output_size", "=", "nest", ".", "flatten", "(", "cell", ".", "output_size", ")", "\n", "\n", "# Construct an initial output", "\n", "input_shape", "=", "array_ops", ".", "shape", "(", "flat_input", "[", "0", "]", ")", "\n", "time_steps", "=", "input_shape", "[", "0", "]", "\n", "batch_size", "=", "rnn", ".", "_best_effort_input_batch_size", "(", "flat_input", ")", "\n", "\n", "inputs_got_shape", "=", "tuple", "(", "input_", ".", "get_shape", "(", ")", ".", "with_rank_at_least", "(", "3", ")", "\n", "for", "input_", "in", "flat_input", ")", "\n", "\n", "const_time_steps", ",", "const_batch_size", "=", "inputs_got_shape", "[", "0", "]", ".", "as_list", "(", ")", "[", ":", "2", "]", "\n", "\n", "for", "shape", "in", "inputs_got_shape", ":", "\n", "    ", "if", "not", "shape", "[", "2", ":", "]", ".", "is_fully_defined", "(", ")", ":", "\n", "      ", "raise", "ValueError", "(", "\n", "\"Input size (depth of inputs) must be accessible via shape inference,\"", "\n", "\" but saw value None.\"", ")", "\n", "", "got_time_steps", "=", "shape", "[", "0", "]", ".", "value", "\n", "got_batch_size", "=", "shape", "[", "1", "]", ".", "value", "\n", "if", "const_time_steps", "!=", "got_time_steps", ":", "\n", "      ", "raise", "ValueError", "(", "\n", "\"Time steps is not the same for all the elements in the input in a \"", "\n", "\"batch.\"", ")", "\n", "", "if", "const_batch_size", "!=", "got_batch_size", ":", "\n", "      ", "raise", "ValueError", "(", "\n", "\"Batch_size is not the same for all the elements in the input.\"", ")", "\n", "\n", "# Prepare dynamic conditional copying of state & output", "\n", "", "", "def", "_create_zero_arrays", "(", "size", ")", ":", "\n", "    ", "size", "=", "_concat", "(", "batch_size", ",", "size", ")", "\n", "return", "array_ops", ".", "zeros", "(", "\n", "array_ops", ".", "stack", "(", "size", ")", ",", "rnn", ".", "_infer_state_dtype", "(", "dtype", ",", "state", ")", ")", "\n", "\n", "", "flat_zero_output", "=", "tuple", "(", "_create_zero_arrays", "(", "output", ")", "\n", "for", "output", "in", "flat_output_size", ")", "\n", "zero_output", "=", "nest", ".", "pack_sequence_as", "(", "structure", "=", "cell", ".", "output_size", ",", "\n", "flat_sequence", "=", "flat_zero_output", ")", "\n", "\n", "if", "sequence_length", "is", "not", "None", ":", "\n", "    ", "min_sequence_length", "=", "math_ops", ".", "reduce_min", "(", "sequence_length", ")", "\n", "max_sequence_length", "=", "math_ops", ".", "reduce_max", "(", "sequence_length", ")", "\n", "", "else", ":", "\n", "    ", "max_sequence_length", "=", "time_steps", "\n", "\n", "", "time", "=", "array_ops", ".", "constant", "(", "0", ",", "dtype", "=", "dtypes", ".", "int32", ",", "name", "=", "\"time\"", ")", "\n", "\n", "with", "ops", ".", "name_scope", "(", "\"dynamic_rnn\"", ")", "as", "scope", ":", "\n", "    ", "base_name", "=", "scope", "\n", "\n", "", "def", "_create_ta", "(", "name", ",", "element_shape", ",", "dtype", ")", ":", "\n", "    ", "return", "tensor_array_ops", ".", "TensorArray", "(", "dtype", "=", "dtype", ",", "\n", "size", "=", "time_steps", ",", "\n", "element_shape", "=", "element_shape", ",", "\n", "tensor_array_name", "=", "base_name", "+", "name", ")", "\n", "\n", "", "in_graph_mode", "=", "not", "context", ".", "executing_eagerly", "(", ")", "\n", "if", "in_graph_mode", ":", "\n", "    ", "output_ta", "=", "tuple", "(", "\n", "_create_ta", "(", "\n", "\"output_%d\"", "%", "i", ",", "\n", "element_shape", "=", "(", "tensor_shape", ".", "TensorShape", "(", "[", "const_batch_size", "]", ")", "\n", ".", "concatenate", "(", "\n", "rnn", ".", "_maybe_tensor_shape_from_tensor", "(", "out_size", ")", ")", ")", ",", "\n", "dtype", "=", "rnn", ".", "_infer_state_dtype", "(", "dtype", ",", "state", ")", ")", "\n", "for", "i", ",", "out_size", "in", "enumerate", "(", "flat_output_size", ")", ")", "\n", "input_ta", "=", "tuple", "(", "\n", "_create_ta", "(", "\n", "\"input_%d\"", "%", "i", ",", "\n", "element_shape", "=", "flat_input_i", ".", "shape", "[", "1", ":", "]", ",", "\n", "dtype", "=", "flat_input_i", ".", "dtype", ")", "\n", "for", "i", ",", "flat_input_i", "in", "enumerate", "(", "flat_input", ")", ")", "\n", "input_ta", "=", "tuple", "(", "ta", ".", "unstack", "(", "input_", ")", "\n", "for", "ta", ",", "input_", "in", "zip", "(", "input_ta", ",", "flat_input", ")", ")", "\n", "", "else", ":", "\n", "    ", "output_ta", "=", "tuple", "(", "[", "0", "for", "_", "in", "range", "(", "time_steps", ".", "numpy", "(", ")", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "flat_output_size", ")", ")", ")", "\n", "input_ta", "=", "flat_input", "\n", "\n", "", "def", "_time_step", "(", "time", ",", "output_ta_t", ",", "state", ")", ":", "\n", "    ", "\"\"\"Take a time step of the dynamic RNN.\n    Args:\n      time: int32 scalar Tensor.\n      output_ta_t: List of `TensorArray`s that represent the output.\n      state: nested tuple of vector tensors that represent the state.\n    Returns:\n      The tuple (time + 1, output_ta_t with updated flow, new_state).\n    \"\"\"", "\n", "\n", "if", "in_graph_mode", ":", "\n", "      ", "input_t", "=", "tuple", "(", "ta", ".", "read", "(", "time", ")", "for", "ta", "in", "input_ta", ")", "\n", "# Restore some shape information", "\n", "for", "input_", ",", "shape", "in", "zip", "(", "input_t", ",", "inputs_got_shape", ")", ":", "\n", "        ", "input_", ".", "set_shape", "(", "shape", "[", "1", ":", "]", ")", "\n", "", "", "else", ":", "\n", "      ", "input_t", "=", "tuple", "(", "ta", "[", "time", ".", "numpy", "(", ")", "]", "for", "ta", "in", "input_ta", ")", "\n", "\n", "", "input_t", "=", "nest", ".", "pack_sequence_as", "(", "structure", "=", "inputs", ",", "flat_sequence", "=", "input_t", ")", "\n", "#Here, we make the change to add 'time' as input when calling the cell. ", "\n", "call_cell", "=", "lambda", ":", "cell", "(", "input_t", ",", "state", ",", "time", ")", "\n", "\n", "if", "sequence_length", "is", "not", "None", ":", "\n", "      ", "(", "output", ",", "new_state", ")", "=", "rnn", ".", "_rnn_step", "(", "\n", "time", "=", "time", ",", "\n", "sequence_length", "=", "sequence_length", ",", "\n", "min_sequence_length", "=", "min_sequence_length", ",", "\n", "max_sequence_length", "=", "max_sequence_length", ",", "\n", "zero_output", "=", "zero_output", ",", "\n", "state", "=", "state", ",", "\n", "call_cell", "=", "call_cell", ",", "\n", "state_size", "=", "state_size", ",", "\n", "skip_conditionals", "=", "True", ")", "\n", "", "else", ":", "\n", "      ", "(", "output", ",", "new_state", ")", "=", "call_cell", "(", ")", "\n", "\n", "# Pack state if using state tuples", "\n", "", "output", "=", "nest", ".", "flatten", "(", "output", ")", "\n", "\n", "if", "in_graph_mode", ":", "\n", "      ", "output_ta_t", "=", "tuple", "(", "\n", "ta", ".", "write", "(", "time", ",", "out", ")", "for", "ta", ",", "out", "in", "zip", "(", "output_ta_t", ",", "output", ")", ")", "\n", "", "else", ":", "\n", "      ", "for", "ta", ",", "out", "in", "zip", "(", "output_ta_t", ",", "output", ")", ":", "\n", "        ", "ta", "[", "time", ".", "numpy", "(", ")", "]", "=", "out", "\n", "\n", "", "", "return", "(", "time", "+", "1", ",", "output_ta_t", ",", "new_state", ")", "\n", "\n", "", "if", "in_graph_mode", ":", "\n", "# Make sure that we run at least 1 step, if necessary, to ensure", "\n", "# the TensorArrays pick up the dynamic shape.", "\n", "    ", "loop_bound", "=", "math_ops", ".", "minimum", "(", "\n", "time_steps", ",", "math_ops", ".", "maximum", "(", "1", ",", "max_sequence_length", ")", ")", "\n", "", "else", ":", "\n", "# Using max_sequence_length isn't currently supported in the Eager branch.", "\n", "    ", "loop_bound", "=", "time_steps", "\n", "\n", "", "_", ",", "output_final_ta", ",", "final_state", "=", "control_flow_ops", ".", "while_loop", "(", "\n", "cond", "=", "lambda", "time", ",", "*", "_", ":", "time", "<", "loop_bound", ",", "\n", "body", "=", "_time_step", ",", "\n", "loop_vars", "=", "(", "time", ",", "output_ta", ",", "state", ")", ",", "\n", "parallel_iterations", "=", "parallel_iterations", ",", "\n", "maximum_iterations", "=", "time_steps", ",", "\n", "swap_memory", "=", "swap_memory", ")", "\n", "\n", "# Unpack final output if not using output tuples.", "\n", "if", "in_graph_mode", ":", "\n", "    ", "final_outputs", "=", "tuple", "(", "ta", ".", "stack", "(", ")", "for", "ta", "in", "output_final_ta", ")", "\n", "# Restore some shape information", "\n", "for", "output", ",", "output_size", "in", "zip", "(", "final_outputs", ",", "flat_output_size", ")", ":", "\n", "      ", "shape", "=", "_concat", "(", "\n", "[", "const_time_steps", ",", "const_batch_size", "]", ",", "output_size", ",", "static", "=", "True", ")", "\n", "output", ".", "set_shape", "(", "shape", ")", "\n", "", "", "else", ":", "\n", "    ", "final_outputs", "=", "output_final_ta", "\n", "\n", "", "final_outputs", "=", "nest", ".", "pack_sequence_as", "(", "\n", "structure", "=", "cell", ".", "output_size", ",", "flat_sequence", "=", "final_outputs", ")", "\n", "if", "not", "in_graph_mode", ":", "\n", "    ", "final_outputs", "=", "nest", ".", "map_structure_up_to", "(", "\n", "cell", ".", "output_size", ",", "lambda", "x", ":", "array_ops", ".", "stack", "(", "x", ",", "axis", "=", "0", ")", ",", "final_outputs", ")", "\n", "\n", "", "return", "(", "final_outputs", ",", "final_state", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.sessions.MonitoredTrainingSession": [[34, 132], ["tensorflow.train.ChiefSessionCreator", "tensorflow.train.MonitoredSession", "all_hooks.extend", "all_hooks.extend", "all_hooks.append", "all_hooks.append", "tensorflow.python.training.basic_session_run_hooks.StepCounterHook", "nabu.neuralnetworks.components.hooks.CheckpointSaverHook", "tensorflow.summary.FileWriter"], "function", ["None"], ["def", "MonitoredTrainingSession", "(", "master", "=", "''", ",", "# pylint: disable=invalid-name", "\n", "is_chief", "=", "True", ",", "\n", "checkpoint_dir", "=", "None", ",", "\n", "scaffold", "=", "None", ",", "\n", "hooks", "=", "None", ",", "\n", "chief_only_hooks", "=", "None", ",", "\n", "save_checkpoint_secs", "=", "None", ",", "\n", "save_summaries_steps", "=", "None", ",", "\n", "save_summaries_secs", "=", "None", ",", "\n", "config", "=", "None", ",", "\n", "stop_grace_period_secs", "=", "120", ",", "\n", "log_step_count_steps", "=", "100", ",", "\n", "max_wait_secs", "=", "7200", ",", "\n", "save_checkpoint_steps", "=", "None", ")", ":", "\n", "  ", "\"\"\"Creates a `MonitoredSession` for training.\n\n  For a chief, this utility sets proper session initializer/restorer. It also\n  creates hooks related to checkpoint and summary saving. For workers, this\n  utility sets proper session creator which waits for the chief to\n  initialize/restore. Please check `tf.train.MonitoredSession` for more\n  information.\n\n\n  Args:\n    master: `String` the TensorFlow master to use.\n    is_chief: If `True`, it will take care of initialization and recovery the\n      underlying TensorFlow session. If `False`, it will wait on a chief to\n      initialize or recover the TensorFlow session.\n    checkpoint_dir: A string.  Optional path to a directory where to restore\n      variables.\n    scaffold: A `Scaffold` used for gathering or building supportive ops. If\n      not specified, a default one is created. It's used to finalize the graph.\n    hooks: Optional list of `SessionRunHook` objects.\n    chief_only_hooks: list of `SessionRunHook` objects. Activate these hooks if\n      `is_chief==True`, ignore otherwise.\n    save_checkpoint_secs: The frequency, in seconds, that a checkpoint is saved\n      using a default checkpoint saver. If both `save_checkpoint_steps` and\n      `save_checkpoint_secs` are set to `None`, then the default checkpoint\n      saver isn't used. If both are provided, then only `save_checkpoint_secs`\n      is used. Default 600.\n    save_summaries_steps: The frequency, in number of global steps, that the\n      summaries are written to disk using a default summary saver. If both\n      `save_summaries_steps` and `save_summaries_secs` are set to `None`, then\n      the default summary saver isn't used. Default 100.\n    save_summaries_secs: The frequency, in secs, that the summaries are written\n      to disk using a default summary saver.  If both `save_summaries_steps` and\n      `save_summaries_secs` are set to `None`, then the default summary saver\n      isn't used. Default not enabled.\n    config: an instance of `tf.ConfigProto` proto used to configure the session.\n      It's the `config` argument of constructor of `tf.Session`.\n    stop_grace_period_secs: Number of seconds given to threads to stop after\n      `close()` has been called.\n    log_step_count_steps: The frequency, in number of global steps, that the\n      global step/sec is logged.\n    max_wait_secs: Maximum time workers should wait for the session to\n      become available. This should be kept relatively short to help detect\n      incorrect code, but sometimes may need to be increased if the chief takes\n      a while to start up.\n    save_checkpoint_steps: The frequency, in number of global steps, that a\n      checkpoint is saved using a default checkpoint saver. If both\n      `save_checkpoint_steps` and `save_checkpoint_secs` are set to `None`, then\n      the default checkpoint saver isn't used. If both are provided, then only\n      `save_checkpoint_secs` is used. Default not enabled.\n\n  Returns:\n    A `MonitoredSession` object.\n  \"\"\"", "\n", "\n", "save_checkpoint_secs", "=", "1800", "\n", "save_checkpoint_steps", "=", "None", "\n", "\n", "all_hooks", "=", "[", "]", "\n", "if", "chief_only_hooks", ":", "\n", "    ", "all_hooks", ".", "extend", "(", "chief_only_hooks", ")", "\n", "", "session_creator", "=", "tf", ".", "train", ".", "ChiefSessionCreator", "(", "\n", "scaffold", "=", "scaffold", ",", "\n", "checkpoint_dir", "=", "checkpoint_dir", ",", "\n", "master", "=", "master", ",", "\n", "config", "=", "config", ")", "\n", "\n", "if", "checkpoint_dir", ":", "\n", "    ", "if", "log_step_count_steps", "and", "log_step_count_steps", ">", "0", ":", "\n", "      ", "all_hooks", ".", "append", "(", "\n", "basic_session_run_hooks", ".", "StepCounterHook", "(", "\n", "output_dir", "=", "checkpoint_dir", ",", "every_n_steps", "=", "log_step_count_steps", ",", "summary_writer", "=", "tf", ".", "summary", ".", "FileWriter", "(", "checkpoint_dir", ")", ")", ")", "\n", "\n", "", "if", "(", "save_checkpoint_secs", "and", "save_checkpoint_secs", ">", "0", ")", "or", "(", "\n", "save_checkpoint_steps", "and", "save_checkpoint_steps", ">", "0", ")", ":", "\n", "      ", "all_hooks", ".", "append", "(", "nabu_hooks", ".", "CheckpointSaverHook", "(", "\n", "checkpoint_dir", ",", "\n", "save_steps", "=", "save_checkpoint_steps", ",", "\n", "save_secs", "=", "save_checkpoint_secs", ",", "\n", "scaffold", "=", "scaffold", ")", ")", "\n", "\n", "", "", "if", "hooks", ":", "\n", "    ", "all_hooks", ".", "extend", "(", "hooks", ")", "\n", "", "return", "tf", ".", "train", ".", "MonitoredSession", "(", "session_creator", "=", "session_creator", ",", "hooks", "=", "all_hooks", ",", "\n", "stop_grace_period_secs", "=", "stop_grace_period_secs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.RNNCell.__call__": [[65, 92], ["getattr", "tensorflow.python.ops.variable_scope.variable_scope", "super().__call__", "tensorflow.python.ops.variable_scope.variable_scope", "setattr", "super().__call__", "tensorflow.python.ops.variable_scope.get_variable_scope"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.TimeAnchorReadHeadsNormDeepattractornetSoftmaxFramebasedLoss.__call__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.TimeAnchorReadHeadsNormDeepattractornetSoftmaxFramebasedLoss.__call__"], ["def", "__call__", "(", "self", ",", "inputs", ",", "state", ",", "time", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Run this RNN cell on inputs, starting from the given state.\n\t\tArgs:\n\t\t\tinputs: `2-D` tensor with shape `[batch_size, input_size]`.\n\t\t\tstate: if `self.state_size` is an integer, this should be a `2-D Tensor`\n\t\t\twith shape `[batch_size, self.state_size]`.  Otherwise, if\n\t\t\t`self.state_size` is a tuple of integers, this should be a tuple\n\t\t\twith shapes `[batch_size, s] for s in self.state_size`.\n\t\t\ttime: `0-D` tensor with shape indicating the current time in the rnn loop.\n\t\t\tscope: VariableScope for the created subgraph; defaults to class name.\n\t\tReturns:\n\t\t\tA pair containing:\n\t\t\t\t- Output: A `2-D` tensor with shape `[batch_size, self.output_size]`.\n\t\t\t\t- New state: Either a single `2-D` tensor, or a tuple of tensors matching\n\t\t\t\tthe arity and shapes of `state`.\n\t\t\"\"\"", "\n", "if", "scope", "is", "not", "None", ":", "\n", "\t\t\t", "with", "vs", ".", "variable_scope", "(", "scope", ",", "custom_getter", "=", "self", ".", "_rnn_get_variable", ")", "as", "scope", ":", "\n", "\t\t\t\t", "return", "super", "(", "RNNCell", ",", "self", ")", ".", "__call__", "(", "inputs", ",", "state", ",", "time", ",", "scope", "=", "scope", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "scope_attrname", "=", "\"rnncell_scope\"", "\n", "scope", "=", "getattr", "(", "self", ",", "scope_attrname", ",", "None", ")", "\n", "if", "scope", "is", "None", ":", "\n", "\t\t\t\t", "scope", "=", "vs", ".", "variable_scope", "(", "vs", ".", "get_variable_scope", "(", ")", ",", "custom_getter", "=", "self", ".", "_rnn_get_variable", ")", "\n", "setattr", "(", "self", ",", "scope_attrname", ",", "scope", ")", "\n", "", "with", "scope", ":", "\n", "\t\t\t\t", "return", "super", "(", "RNNCell", ",", "self", ")", ".", "__call__", "(", "inputs", ",", "state", ",", "time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.RNNCell._rnn_get_variable": [[93, 108], ["getter", "tensorflow.python.eager.context.executing_eagerly", "tensorflow.python.ops.rnn_cell_impl.RNNCell._trainable_weights.append", "tensorflow.python.ops.rnn_cell_impl.RNNCell._non_trainable_weights.append", "tensorflow.python.ops.variables.trainable_variables", "isinstance", "tensorflow.python.ops.variables.trainable_variables", "list"], "methods", ["None"], ["", "", "", "def", "_rnn_get_variable", "(", "self", ",", "getter", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\t\t", "variable", "=", "getter", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "if", "context", ".", "executing_eagerly", "(", ")", ":", "\n", "\t\t\t", "trainable", "=", "variable", ".", "_trainable", "# pylint: disable=protected-access", "\n", "", "else", ":", "\n", "\t\t\t", "trainable", "=", "(", "\n", "variable", "in", "tf_variables", ".", "trainable_variables", "(", ")", "or", "\n", "(", "\n", "isinstance", "(", "variable", ",", "tf_variables", ".", "PartitionedVariable", ")", "and", "\n", "list", "(", "variable", ")", "[", "0", "]", "in", "tf_variables", ".", "trainable_variables", "(", ")", ")", ")", "\n", "", "if", "trainable", "and", "variable", "not", "in", "self", ".", "_trainable_weights", ":", "\n", "\t\t\t", "self", ".", "_trainable_weights", ".", "append", "(", "variable", ")", "\n", "", "elif", "not", "trainable", "and", "variable", "not", "in", "self", ".", "_non_trainable_weights", ":", "\n", "\t\t\t", "self", ".", "_non_trainable_weights", ".", "append", "(", "variable", ")", "\n", "", "return", "variable", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.RNNCell.state_size": [[109, 116], ["NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"size(s) of state(s) used by this cell.\n\t\tIt can be represented by an Integer, a TensorShape or a tuple of Integers\n\t\tor TensorShapes.\n\t\t\"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Abstract method\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.RNNCell.output_size": [[117, 121], ["NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"Integer or TensorShape: size of outputs produced by this cell.\"\"\"", "\n", "raise", "NotImplementedError", "(", "\"Abstract method\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.RNNCell.build": [[122, 126], ["None"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "_", ")", ":", "\n", "# This tells the parent Layer object that it's OK to call", "\n", "# self.add_variable() inside the call() method.", "\n", "\t\t", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.RNNCell.zero_state": [[127, 153], ["tensorflow.python.eager.context.executing_eagerly", "hasattr", "getattr", "tensorflow.python.framework.ops.name_scope", "tensorflow.python.ops.rnn_cell_impl._zero_state_tensors", "type"], "methods", ["None"], ["", "def", "zero_state", "(", "self", ",", "batch_size", ",", "dtype", ")", ":", "\n", "\t\t", "\"\"\"Return zero-filled state tensor(s).\n\t\tArgs:\n\t\t\tbatch_size: int, float, or unit Tensor representing the batch size.\n\t\t\tdtype: the data type to use for the state.\n\t\tReturns:\n\t\t\tIf `state_size` is an int or TensorShape, then the return value is a\n\t\t\t`N-D` tensor of shape `[batch_size, state_size]` filled with zeros.\n\t\t\tIf `state_size` is a nested list or tuple, then the return value is\n\t\t\ta nested list or tuple (of the same structure) of `2-D` tensors with\n\t\t\tthe shapes `[batch_size, s]` for each s in `state_size`.\n\t\t\"\"\"", "\n", "# Try to use the last cached zero_state. This is done to avoid recreating", "\n", "# zeros, especially when eager execution is enabled.", "\n", "state_size", "=", "self", ".", "state_size", "\n", "is_eager", "=", "context", ".", "executing_eagerly", "(", ")", "\n", "if", "is_eager", "and", "hasattr", "(", "self", ",", "\"_last_zero_state\"", ")", ":", "\n", "\t\t\t", "(", "last_state_size", ",", "last_batch_size", ",", "last_dtype", ",", "\n", "last_output", ")", "=", "getattr", "(", "self", ",", "\"_last_zero_state\"", ")", "\n", "if", "(", "last_batch_size", "==", "batch_size", "and", "last_dtype", "==", "dtype", "and", "last_state_size", "==", "state_size", ")", ":", "\n", "\t\t\t\t", "return", "last_output", "\n", "", "", "with", "ops", ".", "name_scope", "(", "type", "(", "self", ")", ".", "__name__", "+", "\"ZeroState\"", ",", "values", "=", "[", "batch_size", "]", ")", ":", "\n", "\t\t\t", "output", "=", "rnn_cell_impl", ".", "_zero_state_tensors", "(", "state_size", ",", "batch_size", ",", "dtype", ")", "\n", "", "if", "is_eager", ":", "\n", "\t\t\t", "self", ".", "_last_zero_state", "=", "(", "state_size", ",", "batch_size", ",", "dtype", ",", "output", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.LayerRNNCell.__call__": [[167, 188], ["tensorflow.python.layers.base.Layer.__call__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.TimeAnchorReadHeadsNormDeepattractornetSoftmaxFramebasedLoss.__call__"], ["def", "__call__", "(", "self", ",", "inputs", ",", "state", ",", "scope", "=", "None", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\t\t", "\"\"\"Run this RNN cell on inputs, starting from the given state.\n\t\tArgs:\n\t\t\tinputs: `2-D` tensor with shape `[batch_size, input_size]`.\n\t\t\tstate: if `self.state_size` is an integer, this should be a `2-D Tensor`\n\t\t\twith shape `[batch_size, self.state_size]`.  Otherwise, if\n\t\t\t`self.state_size` is a tuple of integers, this should be a tuple\n\t\t\twith shapes `[batch_size, s] for s in self.state_size`.\n\t\t\tscope: optional cell scope.\n\t\t\t*args: Additional positional arguments.\n\t\t\t**kwargs: Additional keyword arguments.\n\t\tReturns:\n\t\t\tA pair containing:\n\t\t\t\t- Output: A `2-D` tensor with shape `[batch_size, self.output_size]`.\n\t\t\t\t- New state: Either a single `2-D` tensor, or a tuple of tensors matching\n\t\t\t\tthe arity and shapes of `state`.\n\t\t\"\"\"", "\n", "# Bypass RNNCell's variable capturing semantics for LayerRNNCell.", "\n", "# Instead, it is up to subclasses to provide a proper build", "\n", "# method.  See the class docstring for more details.", "\n", "return", "base_layer", ".", "Layer", ".", "__call__", "(", "self", ",", "inputs", ",", "state", ",", "scope", "=", "scope", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.ResetGRUCell.__init__": [[206, 225], ["tensorflow.python.layers.base.Layer.__init__", "tensorflow.python.layers.base.InputSpec"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_units", ",", "\n", "t_reset", "=", "1", ",", "\n", "activation", "=", "None", ",", "\n", "reuse", "=", "None", ",", "\n", "kernel_initializer", "=", "None", ",", "\n", "bias_initializer", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "\t\t", "super", "(", "ResetGRUCell", ",", "self", ")", ".", "__init__", "(", "_reuse", "=", "reuse", ",", "name", "=", "name", ")", "\n", "\n", "# Inputs must be 2-dimensional.", "\n", "self", ".", "input_spec", "=", "base_layer", ".", "InputSpec", "(", "ndim", "=", "3", ")", "\n", "\n", "self", ".", "_num_units", "=", "num_units", "\n", "self", ".", "_t_reset", "=", "t_reset", "\n", "self", ".", "_activation", "=", "activation", "or", "math_ops", ".", "tanh", "\n", "self", ".", "_kernel_initializer", "=", "kernel_initializer", "\n", "self", ".", "_bias_initializer", "=", "bias_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.ResetGRUCell.state_size": [[226, 229], ["tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "tf", ".", "TensorShape", "(", "[", "self", ".", "_t_reset", ",", "self", ".", "_num_units", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.ResetGRUCell.output_size": [[230, 233], ["tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", ",", "tf", ".", "TensorShape", "(", "[", "self", ".", "_t_reset", ",", "self", ".", "_num_units", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.ResetGRUCell.build": [[234, 263], ["tensorflow.python.ops.rnn_cell_impl.ResetGRUCell.add_variable", "tensorflow.python.ops.rnn_cell_impl.ResetGRUCell.add_variable", "tensorflow.python.ops.rnn_cell_impl.ResetGRUCell.add_variable", "tensorflow.python.ops.rnn_cell_impl.ResetGRUCell.add_variable", "ValueError", "tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.python.ops.init_ops.zeros_initializer"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "inputs_shape", ")", ":", "\n", "\t\t", "if", "inputs_shape", "[", "-", "1", "]", ".", "value", "is", "None", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"Expected inputs.shape[-1] to be known, saw shape: %s\"", "%", "inputs_shape", ")", "\n", "\n", "", "input_depth", "=", "inputs_shape", "[", "-", "1", "]", ".", "value", "\n", "self", ".", "_gate_kernel", "=", "self", ".", "add_variable", "(", "\n", "\"gates/%s\"", "%", "_WEIGHTS_VARIABLE_NAME", ",", "\n", "shape", "=", "[", "input_depth", "+", "self", ".", "_num_units", ",", "2", "*", "self", ".", "_num_units", "]", ",", "\n", "initializer", "=", "self", ".", "_kernel_initializer", ")", "\n", "self", ".", "_gate_bias", "=", "self", ".", "add_variable", "(", "\n", "\"gates/%s\"", "%", "_BIAS_VARIABLE_NAME", ",", "\n", "shape", "=", "[", "2", "*", "self", ".", "_num_units", "]", ",", "\n", "initializer", "=", "(", "\n", "self", ".", "_bias_initializer", "\n", "if", "self", ".", "_bias_initializer", "is", "not", "None", "\n", "else", "init_ops", ".", "constant_initializer", "(", "1.0", ",", "dtype", "=", "self", ".", "dtype", ")", ")", ")", "\n", "self", ".", "_candidate_kernel", "=", "self", ".", "add_variable", "(", "\n", "\"candidate/%s\"", "%", "_WEIGHTS_VARIABLE_NAME", ",", "\n", "shape", "=", "[", "input_depth", "+", "self", ".", "_num_units", ",", "self", ".", "_num_units", "]", ",", "\n", "initializer", "=", "self", ".", "_kernel_initializer", ")", "\n", "self", ".", "_candidate_bias", "=", "self", ".", "add_variable", "(", "\n", "\"candidate/%s\"", "%", "_BIAS_VARIABLE_NAME", ",", "\n", "shape", "=", "[", "self", ".", "_num_units", "]", ",", "\n", "initializer", "=", "(", "\n", "self", ".", "_bias_initializer", "\n", "if", "self", ".", "_bias_initializer", "is", "not", "None", "\n", "else", "init_ops", ".", "zeros_initializer", "(", "dtype", "=", "self", ".", "dtype", ")", ")", ")", "\n", "\n", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.ResetGRUCell.call": [[264, 295], ["tensorflow.mod", "tensorflow.tensordot", "tensorflow.python.ops.nn_ops.bias_add", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.array_ops.split", "tensorflow.tensordot", "tensorflow.python.ops.nn_ops.bias_add", "tensorflow.python.ops.rnn_cell_impl.ResetGRUCell._activation", "tensorflow.gather", "tensorflow.expand_dims", "tensorflow.python.ops.array_ops.concat", "tensorflow.python.ops.array_ops.concat", "tensorflow.scatter_nd", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.constant", "tensorflow.constant", "tensorflow.expand_dims"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ",", "time", ")", ":", "\n", "\t\t", "\"\"\"Gated recurrent unit (GRU) with nunits cells.\"\"\"", "\n", "\n", "state_index", "=", "tf", ".", "mod", "(", "time", ",", "self", ".", "_t_reset", ")", "\n", "\n", "gate_inputs", "=", "tf", ".", "tensordot", "(", "array_ops", ".", "concat", "(", "[", "inputs", ",", "state", "]", ",", "2", ")", ",", "self", ".", "_gate_kernel", ",", "[", "[", "-", "1", "]", ",", "[", "0", "]", "]", ")", "\n", "# gate_inputs = math_ops.matmul(array_ops.concat([inputs, state], 2), self._gate_kernel)", "\n", "gate_inputs", "=", "nn_ops", ".", "bias_add", "(", "gate_inputs", ",", "self", ".", "_gate_bias", ")", "\n", "\n", "value", "=", "math_ops", ".", "sigmoid", "(", "gate_inputs", ")", "\n", "r", ",", "u", "=", "array_ops", ".", "split", "(", "value", "=", "value", ",", "num_or_size_splits", "=", "2", ",", "axis", "=", "2", ")", "\n", "\n", "r_state", "=", "r", "*", "state", "\n", "\n", "candidate", "=", "tf", ".", "tensordot", "(", "array_ops", ".", "concat", "(", "[", "inputs", ",", "r_state", "]", ",", "2", ")", ",", "self", ".", "_candidate_kernel", ",", "[", "[", "-", "1", "]", ",", "[", "0", "]", "]", ")", "\n", "# candidate = math_ops.matmul(array_ops.concat([inputs, r_state], 2), self._candidate_kernel)", "\n", "candidate", "=", "nn_ops", ".", "bias_add", "(", "candidate", ",", "self", ".", "_candidate_bias", ")", "\n", "\n", "c", "=", "self", ".", "_activation", "(", "candidate", ")", "\n", "new_h", "=", "u", "*", "state", "+", "(", "1", "-", "u", ")", "*", "c", "\n", "\n", "new_h_current", "=", "tf", ".", "gather", "(", "new_h", ",", "state_index", ",", "axis", "=", "1", ")", "\n", "\n", "# here we reset the correct state", "\n", "tmp", "=", "1", "-", "tf", ".", "scatter_nd", "(", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "state_index", ",", "0", ")", ",", "0", ")", ",", "tf", ".", "constant", "(", "[", "1.0", "]", ")", ",", "tf", ".", "constant", "(", "[", "self", ".", "_t_reset", "]", ")", ")", "\n", "reset_mask", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "tmp", ",", "0", ")", ",", "-", "1", ")", "\n", "\n", "new_h_reset", "=", "new_h", "*", "reset_mask", "\n", "\n", "return", "(", "new_h_current", ",", "new_h", ")", ",", "new_h_reset", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.GroupResetGRUCell.__init__": [[313, 338], ["tensorflow.python.ops.rnn_cell_impl.ResetGRUCell.__init__", "int", "float", "float", "ValueError"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_units", ",", "\n", "t_reset", "=", "1", ",", "\n", "group_size", "=", "1", ",", "\n", "activation", "=", "None", ",", "\n", "reuse", "=", "None", ",", "\n", "kernel_initializer", "=", "None", ",", "\n", "bias_initializer", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "\t\t", "super", "(", "GroupResetGRUCell", ",", "self", ")", ".", "__init__", "(", "\n", "num_units", ",", "\n", "t_reset", "=", "t_reset", ",", "\n", "activation", "=", "activation", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", ",", "\n", "reuse", "=", "reuse", ")", "\n", "\n", "self", ".", "_group_size", "=", "group_size", "\n", "num_replicates", "=", "float", "(", "self", ".", "_t_reset", ")", "/", "float", "(", "self", ".", "_group_size", ")", "\n", "self", ".", "_num_replicates", "=", "int", "(", "num_replicates", ")", "\n", "\n", "if", "self", ".", "_num_replicates", "!=", "num_replicates", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'t_reset should be a multiple of group_size'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.GroupResetGRUCell.state_size": [[339, 342], ["tensorflow.TensorShape"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "tf", ".", "TensorShape", "(", "[", "self", ".", "_num_replicates", ",", "self", ".", "_num_units", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.GroupResetGRUCell.output_size": [[343, 346], ["tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", ",", "tf", ".", "TensorShape", "(", "[", "self", ".", "_num_replicates", ",", "self", ".", "_num_units", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell_impl.GroupResetGRUCell.call": [[347, 382], ["tensorflow.mod", "tensorflow.floor_div", "tensorflow.mod", "tensorflow.tensordot", "tensorflow.python.ops.nn_ops.bias_add", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.array_ops.split", "tensorflow.tensordot", "tensorflow.python.ops.nn_ops.bias_add", "tensorflow.python.ops.rnn_cell_impl.GroupResetGRUCell._activation", "tensorflow.gather", "tensorflow.expand_dims", "tensorflow.equal", "tensorflow.cond", "tensorflow.python.ops.array_ops.concat", "tensorflow.python.ops.array_ops.concat", "tensorflow.scatter_nd", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.constant", "tensorflow.constant", "tensorflow.expand_dims"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ",", "time", ")", ":", "\n", "\t\t", "\"\"\"Gated recurrent unit (GRU) with nunits cells.\"\"\"", "\n", "\n", "state_index_in_group", "=", "tf", ".", "mod", "(", "time", ",", "self", ".", "_group_size", ")", "\n", "group_index", "=", "tf", ".", "floor_div", "(", "time", ",", "self", ".", "_group_size", ")", "\n", "replicate_index", "=", "tf", ".", "mod", "(", "group_index", ",", "self", ".", "_num_replicates", ")", "\n", "\n", "gate_inputs", "=", "tf", ".", "tensordot", "(", "array_ops", ".", "concat", "(", "[", "inputs", ",", "state", "]", ",", "2", ")", ",", "self", ".", "_gate_kernel", ",", "[", "[", "-", "1", "]", ",", "[", "0", "]", "]", ")", "\n", "# gate_inputs = math_ops.matmul(#array_ops.concat([inputs, state], 2), self._gate_kernel)", "\n", "gate_inputs", "=", "nn_ops", ".", "bias_add", "(", "gate_inputs", ",", "self", ".", "_gate_bias", ")", "\n", "\n", "value", "=", "math_ops", ".", "sigmoid", "(", "gate_inputs", ")", "\n", "r", ",", "u", "=", "array_ops", ".", "split", "(", "value", "=", "value", ",", "num_or_size_splits", "=", "2", ",", "axis", "=", "2", ")", "\n", "\n", "r_state", "=", "r", "*", "state", "\n", "\n", "candidate", "=", "tf", ".", "tensordot", "(", "array_ops", ".", "concat", "(", "[", "inputs", ",", "r_state", "]", ",", "2", ")", ",", "self", ".", "_candidate_kernel", ",", "[", "[", "-", "1", "]", ",", "[", "0", "]", "]", ")", "\n", "# candidate = math_ops.matmul(array_ops.concat([inputs, r_state], 2), self._candidate_kernel)", "\n", "candidate", "=", "nn_ops", ".", "bias_add", "(", "candidate", ",", "self", ".", "_candidate_bias", ")", "\n", "\n", "c", "=", "self", ".", "_activation", "(", "candidate", ")", "\n", "new_h", "=", "u", "*", "state", "+", "(", "1", "-", "u", ")", "*", "c", "\n", "\n", "new_h_current", "=", "tf", ".", "gather", "(", "new_h", ",", "replicate_index", ",", "axis", "=", "1", ")", "\n", "\n", "# here we reset the correct state", "\n", "tmp", "=", "1", "-", "tf", ".", "scatter_nd", "(", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "replicate_index", ",", "0", ")", ",", "0", ")", ",", "\n", "tf", ".", "constant", "(", "[", "1.0", "]", ")", ",", "tf", ".", "constant", "(", "[", "self", ".", "_num_replicates", "]", ")", ")", "\n", "reset_mask", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "tmp", ",", "0", ")", ",", "-", "1", ")", "\n", "\n", "reset_flag", "=", "tf", ".", "equal", "(", "state_index_in_group", "+", "1", ",", "self", ".", "_group_size", ")", "\n", "new_h_reset", "=", "tf", ".", "cond", "(", "reset_flag", ",", "lambda", ":", "new_h", "*", "reset_mask", ",", "lambda", ":", "new_h", ")", "\n", "\n", "return", "(", "new_h_current", ",", "new_h", ")", ",", "new_h_reset", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.ntm_ops.create_linear_initializer": [[8, 11], ["tensorflow.truncated_normal_initializer", "numpy.sqrt"], "function", ["None"], ["def", "create_linear_initializer", "(", "input_size", ",", "dtype", "=", "tf", ".", "float32", ")", ":", "\n", "\t", "stddev", "=", "1.0", "/", "np", ".", "sqrt", "(", "input_size", ")", "\n", "return", "tf", ".", "truncated_normal_initializer", "(", "stddev", "=", "stddev", ",", "dtype", "=", "dtype", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCell.__init__": [[37, 55], ["tensorflow.contrib.rnn.LayerRNNCell.__init__", "tensorflow.python.layers.base.InputSpec", "nabu.neuralnetworks.components.ops.capsule_initializer", "tensorflow.zeros_initializer"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "num_capsules", ",", "capsule_dim", ",", "routing_iters", ",", "activation", "=", "None", ",", "input_probability_fn", "=", "None", ",", "\n", "recurrent_probability_fn", "=", "None", ",", "kernel_initializer", "=", "None", ",", "logits_initializer", "=", "None", ",", "logits_prior", "=", "False", ",", "\n", "reuse", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "\t\t", "super", "(", "RecCapsuleCell", ",", "self", ")", ".", "__init__", "(", "_reuse", "=", "reuse", ",", "name", "=", "name", ")", "\n", "\n", "# For the moment expecting inputs to be 3-dimensional at every time step.", "\n", "# [batch_size x num_in_capsules X dim_in_capsules]", "\n", "self", ".", "input_spec", "=", "base_layer", ".", "InputSpec", "(", "ndim", "=", "3", ")", "\n", "\n", "self", ".", "num_capsules", "=", "num_capsules", "\n", "self", ".", "capsule_dim", "=", "capsule_dim", "\n", "self", ".", "kernel_initializer", "=", "kernel_initializer", "or", "capsule_initializer", "(", ")", "\n", "self", ".", "logits_initializer", "=", "logits_initializer", "or", "tf", ".", "zeros_initializer", "(", ")", "\n", "self", ".", "logits_prior", "=", "logits_prior", "\n", "self", ".", "routing_iters", "=", "routing_iters", "\n", "self", ".", "_activation", "=", "activation", "or", "ops", ".", "squash", "\n", "self", ".", "input_probability_fn", "=", "input_probability_fn", "or", "tf", ".", "nn", ".", "softmax", "\n", "self", ".", "recurrent_probability_fn", "=", "recurrent_probability_fn", "or", "tf", ".", "nn", ".", "sigmoid", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCell.state_size": [[56, 59], ["tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "tf", ".", "TensorShape", "(", "[", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCell.output_size": [[60, 63], ["tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "tf", ".", "TensorShape", "(", "[", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCell.build": [[64, 102], ["rnn_cell.RecCapsuleCell.add_variable", "rnn_cell.RecCapsuleCell.add_variable", "rnn_cell.RecCapsuleCell.add_variable", "rnn_cell.RecCapsuleCell.add_variable", "ValueError", "ValueError"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "input_shapes", ")", ":", "\n", "\t\t", "num_capsules_in", "=", "input_shapes", "[", "-", "2", "]", ".", "value", "\n", "capsule_dim_in", "=", "input_shapes", "[", "-", "1", "]", ".", "value", "\n", "\n", "if", "num_capsules_in", "is", "None", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'number of input capsules must be defined'", ")", "\n", "", "if", "capsule_dim_in", "is", "None", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'input capsules dimension must be defined'", ")", "\n", "\n", "", "self", ".", "input_kernel", "=", "self", ".", "add_variable", "(", "\n", "name", "=", "'input_kernel'", ",", "\n", "dtype", "=", "self", ".", "dtype", ",", "\n", "shape", "=", "[", "num_capsules_in", ",", "capsule_dim_in", ",", "\n", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ")", "\n", "\n", "self", ".", "state_kernel", "=", "self", ".", "add_variable", "(", "\n", "name", "=", "'recurrent_kernel'", ",", "\n", "dtype", "=", "self", ".", "dtype", ",", "\n", "shape", "=", "[", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", ",", "\n", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ")", "\n", "\n", "self", ".", "input_logits", "=", "self", ".", "add_variable", "(", "\n", "name", "=", "'init_input_logits'", ",", "\n", "dtype", "=", "self", ".", "dtype", ",", "\n", "shape", "=", "[", "num_capsules_in", ",", "self", ".", "num_capsules", "]", ",", "\n", "initializer", "=", "self", ".", "logits_initializer", ",", "\n", "trainable", "=", "self", ".", "logits_prior", ")", "\n", "\n", "self", ".", "state_logits", "=", "self", ".", "add_variable", "(", "\n", "name", "=", "'init_recurrent_logits'", ",", "\n", "dtype", "=", "self", ".", "dtype", ",", "\n", "shape", "=", "[", "self", ".", "num_capsules", ",", "self", ".", "num_capsules", "]", ",", "\n", "initializer", "=", "self", ".", "logits_initializer", ",", "\n", "trainable", "=", "self", ".", "logits_prior", ")", "\n", "\n", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCell.call": [[103, 122], ["rnn_cell.RecCapsuleCell.predict", "rnn_cell.RecCapsuleCell.cluster"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.predict", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.cluster"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tapply the layer\n\t\targs:\n\t\tinputs: the inputs to the layer. the final two dimensions are\n\t\t  num_capsules_in and capsule_dim_in\n\t\tstate: the recurrent inputs to the layer. the final two dimensions are\n\t\t  num_capsules and capsule_dim\n\t\treturns the output capsules as output capsule and as state. The last two dimensions are\n\t\tnum_capsules and capsule_dim\n\t\t\"\"\"", "\n", "\n", "# compute the predictions from the inputs", "\n", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", "=", "self", ".", "predict", "(", "inputs", ",", "state", ")", "\n", "\n", "# cluster the predictions", "\n", "outputs", "=", "self", ".", "cluster", "(", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", ")", "\n", "\n", "return", "outputs", ",", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCell.predict": [[123, 176], ["tensorflow.name_scope", "len", "tensorflow.einsum", "tensorflow.einsum", "range", "range", "Exception", "tensorflow.tile", "tensorflow.tile", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.shape", "len", "tensorflow.shape", "len"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tcompute the predictions for the output capsules and initialize the\n\t\trouting logits\n\t\targs:\n\t\tinputs: the inputs to the layer. the final two dimensions are\n\t\t\tnum_capsules_in and capsule_dim_in\n\t\t state: the recurrent inputs to the layer. the final two dimensions are\n\t\t\tnum_capsules and capsule_dim\n\t\t returns: the output capsule predictions\n\t\t \"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'predict'", ")", ":", "\n", "\n", "# number of shared dimensions. Assuming this is equal for inputs and state", "\n", "\t\t\t", "rank", "=", "len", "(", "inputs", ".", "shape", ")", "\n", "shared", "=", "rank", "-", "2", "\n", "\n", "if", "shared", ">", "26", "-", "4", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Not enough letters in the alphabet to use Einstein notation'", ")", "\n", "\n", "# input_shape = [shared (typicaly batch size),Nin,Din], kernel_shape = [Nin, Din, Nout, Dout],", "\n", "# input_predictions_shape = [shared,Nin,Nout,Dout]", "\n", "", "shared_shape_str", "=", "_alphabet_str", "[", "0", ":", "shared", "]", "\n", "input_shape_str", "=", "shared_shape_str", "+", "'wx'", "\n", "kernel_shape_str", "=", "'wxyz'", "\n", "output_shape_str", "=", "shared_shape_str", "+", "'wyz'", "\n", "ein_not", "=", "'%s,%s->%s'", "%", "(", "input_shape_str", ",", "kernel_shape_str", ",", "output_shape_str", ")", "\n", "\n", "input_predictions", "=", "tf", ".", "einsum", "(", "ein_not", ",", "inputs", ",", "self", ".", "input_kernel", ")", "\n", "state_predictions", "=", "tf", ".", "einsum", "(", "ein_not", ",", "state", ",", "self", ".", "state_kernel", ")", "\n", "\n", "# compute the logits for the inputs", "\n", "input_logits", "=", "self", ".", "input_logits", "\n", "for", "i", "in", "range", "(", "shared", ")", ":", "\n", "\t\t\t\t", "if", "input_predictions", ".", "shape", "[", "shared", "-", "i", "-", "1", "]", ".", "value", "is", "None", ":", "\n", "\t\t\t\t\t", "shape", "=", "tf", ".", "shape", "(", "input_predictions", ")", "[", "shared", "-", "i", "-", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "shape", "=", "input_predictions", ".", "shape", "[", "shared", "-", "i", "-", "1", "]", ".", "value", "\n", "", "tile", "=", "[", "shape", "]", "+", "[", "1", "]", "*", "len", "(", "input_logits", ".", "shape", ")", "\n", "input_logits", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "input_logits", ",", "0", ")", ",", "tile", ")", "\n", "\n", "# compute the logits for the states", "\n", "", "state_logits", "=", "self", ".", "state_logits", "\n", "for", "i", "in", "range", "(", "shared", ")", ":", "\n", "\t\t\t\t", "if", "state_predictions", ".", "shape", "[", "shared", "-", "i", "-", "1", "]", ".", "value", "is", "None", ":", "\n", "\t\t\t\t\t", "shape", "=", "tf", ".", "shape", "(", "state_predictions", ")", "[", "shared", "-", "i", "-", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "shape", "=", "state_predictions", ".", "shape", "[", "shared", "-", "i", "-", "1", "]", ".", "value", "\n", "", "tile", "=", "[", "shape", "]", "+", "[", "1", "]", "*", "len", "(", "state_logits", ".", "shape", ")", "\n", "state_logits", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "state_logits", ",", "0", ")", ",", "tile", ")", "\n", "\n", "", "", "return", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCell.cluster": [[177, 230], ["tensorflow.name_scope", "tensorflow.while_loop", "rnn_cell.RecCapsuleCell.cluster.m_step"], "methods", ["None"], ["", "def", "cluster", "(", "self", ",", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", ")", ":", "\n", "\t\t", "\"\"\"cluster the predictions into output capsules\n\t\targs:\n\t\tpredictions: the predicted output capsules\n\t\tlogits: the initial routing logits\n\t\treturns:\n\t\tthe output capsules\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'cluster'", ")", ":", "\n", "\n", "# define m-step", "\n", "\t\t\t", "def", "m_step", "(", "in_l", ",", "state_l", ")", ":", "\n", "\t\t\t\t", "\"\"\"m step\"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "'m_step'", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "name_scope", "(", "'m_step_in'", ")", ":", "\n", "# compute the capsule contents", "\n", "\t\t\t\t\t\t", "in_w", "=", "self", ".", "input_probability_fn", "(", "in_l", ")", "\n", "in_caps", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "expand_dims", "(", "in_w", ",", "-", "1", ")", "*", "input_predictions", ",", "-", "3", ")", "\n", "\n", "", "with", "tf", ".", "name_scope", "(", "'m_step_state'", ")", ":", "\n", "# compute the capsule contents", "\n", "\t\t\t\t\t\t", "state_w", "=", "self", ".", "recurrent_probability_fn", "(", "state_l", ")", "\n", "state_caps", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "expand_dims", "(", "state_w", ",", "-", "1", ")", "*", "state_predictions", ",", "-", "3", ")", "\n", "\n", "", "capsules", "=", "in_caps", "+", "state_caps", "\n", "\n", "", "return", "capsules", ",", "in_caps", ",", "state_caps", "\n", "\n", "# define body of the while loop", "\n", "", "def", "body", "(", "in_l", ",", "state_l", ")", ":", "\n", "\t\t\t\t", "\"\"\"body\"\"\"", "\n", "\n", "caps", ",", "_", ",", "_", "=", "m_step", "(", "in_l", ",", "state_l", ")", "\n", "caps", "=", "self", ".", "_activation", "(", "caps", ")", "\n", "\n", "# compare the capsule contents with the predictions", "\n", "in_similarity", "=", "tf", ".", "reduce_sum", "(", "input_predictions", "*", "tf", ".", "expand_dims", "(", "caps", ",", "-", "3", ")", ",", "-", "1", ")", "\n", "state_similarity", "=", "tf", ".", "reduce_sum", "(", "state_predictions", "*", "tf", ".", "expand_dims", "(", "caps", ",", "-", "3", ")", ",", "-", "1", ")", "\n", "\n", "return", "[", "in_l", "+", "in_similarity", ",", "state_l", "+", "state_similarity", "]", "\n", "\n", "# get the final logits with the while loop", "\n", "", "[", "in_lo", ",", "state_lo", "]", "=", "tf", ".", "while_loop", "(", "\n", "lambda", "l", ",", "ll", ":", "True", ",", "\n", "body", ",", "[", "input_logits", ",", "state_logits", "]", ",", "\n", "maximum_iterations", "=", "self", ".", "routing_iters", ")", "\n", "\n", "# get the final output capsules", "\n", "capsules", ",", "_", ",", "_", "=", "m_step", "(", "in_lo", ",", "state_lo", ")", "\n", "capsules", "=", "self", ".", "_activation", "(", "capsules", ")", "\n", "\n", "", "return", "capsules", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCellRecOnlyVote.__init__": [[238, 251], ["rnn_cell.RecCapsuleCell.__init__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "num_capsules", ",", "capsule_dim", ",", "routing_iters", ",", "activation", "=", "None", ",", "\n", "input_probability_fn", "=", "None", ",", "recurrent_probability_fn", "=", "None", ",", "\n", "kernel_initializer", "=", "None", ",", "logits_initializer", "=", "None", ",", "logits_prior", "=", "False", ",", "\n", "accumulate_input_logits", "=", "True", ",", "accumulate_state_logits", "=", "True", ",", "reuse", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "\t\t", "super", "(", "RecCapsuleCellRecOnlyVote", ",", "self", ")", ".", "__init__", "(", "num_capsules", ",", "capsule_dim", ",", "\n", "routing_iters", ",", "activation", ",", "\n", "input_probability_fn", ",", "recurrent_probability_fn", ",", "\n", "kernel_initializer", ",", "logits_initializer", ",", "\n", "logits_prior", "=", "logits_prior", ",", "reuse", "=", "reuse", ",", "name", "=", "name", ")", "\n", "\n", "self", ".", "accumulate_input_logits", "=", "accumulate_input_logits", "\n", "self", ".", "accumulate_state_logits", "=", "accumulate_state_logits", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RecCapsuleCellRecOnlyVote.cluster": [[252, 317], ["tensorflow.while_loop", "rnn_cell.RecCapsuleCellRecOnlyVote.cluster.m_step"], "methods", ["None"], ["", "def", "cluster", "(", "self", ",", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", ")", ":", "\n", "\t\t", "\"\"\"cluster the predictions into output capsules\n\t\targs:\n\t\tpredictions: the predicted output capsules\n\t\tlogits: the initial routing logits\n\t\treturns:\n\t\tthe output capsules\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'cluster'", ")", ":", "\n", "\n", "# define m-step", "\n", "\t\t\t", "def", "m_step", "(", "in_l", ",", "state_l", ")", ":", "\n", "\t\t\t\t", "\"\"\"m step\"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "'m_step'", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "name_scope", "(", "'m_step_in'", ")", ":", "\n", "# compute the capsule contents", "\n", "\t\t\t\t\t\t", "in_w", "=", "self", ".", "input_probability_fn", "(", "in_l", ")", "\n", "in_caps", "=", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "expand_dims", "(", "in_w", ",", "-", "1", ")", "*", "input_predictions", ",", "-", "3", ")", "\n", "\n", "", "with", "tf", ".", "name_scope", "(", "'m_step_state'", ")", ":", "\n", "# compute the capsule contents", "\n", "\t\t\t\t\t\t", "state_w", "=", "self", ".", "recurrent_probability_fn", "(", "state_l", ")", "\n", "state_caps", "=", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "expand_dims", "(", "state_w", ",", "-", "1", ")", "*", "state_predictions", ",", "-", "3", ")", "\n", "\n", "", "", "capsules", "=", "in_caps", "+", "state_caps", "\n", "\n", "return", "capsules", ",", "in_caps", ",", "state_caps", "\n", "\n", "# define body of the while loop", "\n", "", "", "def", "body", "(", "in_l", ",", "state_l", ",", "init_input_logits", ",", "init_state_logits", ")", ":", "\n", "\t\t\t", "\"\"\"body\"\"\"", "\n", "\n", "caps", ",", "_", ",", "_", "=", "m_step", "(", "in_l", ",", "state_l", ")", "\n", "caps", "=", "self", ".", "_activation", "(", "caps", ")", "\n", "\n", "# compare the capsule contents with the predictions", "\n", "in_similarity", "=", "tf", ".", "reduce_sum", "(", "input_predictions", "*", "tf", ".", "expand_dims", "(", "caps", ",", "-", "3", ")", ",", "-", "1", ")", "\n", "state_similarity", "=", "tf", ".", "reduce_sum", "(", "state_predictions", "*", "tf", ".", "expand_dims", "(", "caps", ",", "-", "3", ")", ",", "-", "1", ")", "\n", "\n", "if", "self", ".", "accumulate_input_logits", ":", "\n", "\t\t\t\t", "in_l", "+=", "in_similarity", "\n", "", "else", ":", "\n", "\t\t\t\t", "in_l", "=", "in_similarity", "+", "init_input_logits", "\n", "\n", "", "if", "self", ".", "accumulate_state_logits", ":", "\n", "\t\t\t\t", "state_l", "+=", "state_similarity", "\n", "", "else", ":", "\n", "\t\t\t\t", "state_l", "=", "state_similarity", "+", "init_state_logits", "\n", "\n", "", "return", "[", "in_l", ",", "state_l", ",", "init_input_logits", ",", "init_state_logits", "]", "\n", "\n", "# get the final logits with the while loop", "\n", "", "[", "in_lo", ",", "state_lo", ",", "_", ",", "_", "]", "=", "tf", ".", "while_loop", "(", "\n", "lambda", "l", ",", "ll", ",", "lll", ",", "llll", ":", "True", ",", "\n", "body", ",", "[", "input_logits", ",", "state_logits", ",", "input_logits", ",", "state_logits", "]", ",", "\n", "maximum_iterations", "=", "self", ".", "routing_iters", ")", "\n", "\n", "# get the final output capsules, only using the input predictions!", "\n", "_", ",", "capsules", ",", "_", "=", "m_step", "(", "in_lo", ",", "state_lo", ")", "\n", "capsules", "=", "self", ".", "_activation", "(", "capsules", ")", "\n", "\n", "return", "capsules", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVote.__init__": [[325, 342], ["rnn_cell.RecCapsuleCellRecOnlyVote.__init__", "tensorflow.python.layers.base.InputSpec"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "num_capsules", ",", "capsule_dim", ",", "routing_iters", ",", "forget_bias", "=", "1.0", ",", "\n", "activation", "=", "None", ",", "input_probability_fn", "=", "None", ",", "recurrent_probability_fn", "=", "None", ",", "\n", "kernel_initializer", "=", "None", ",", "logits_initializer", "=", "None", ",", "logits_prior", "=", "False", ",", "\n", "accumulate_input_logits", "=", "True", ",", "accumulate_state_logits", "=", "True", ",", "gates_fc", "=", "False", ",", "reuse", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "\t\t", "super", "(", "LSTMCapsuleCellRecOnlyVote", ",", "self", ")", ".", "__init__", "(", "num_capsules", ",", "capsule_dim", ",", "routing_iters", ",", "activation", ",", "\n", "input_probability_fn", ",", "recurrent_probability_fn", ",", "\n", "kernel_initializer", ",", "logits_initializer", ",", "logits_prior", ",", "\n", "accumulate_input_logits", ",", "accumulate_state_logits", ",", "reuse", "=", "reuse", ",", "\n", "name", "=", "name", ")", "\n", "\n", "self", ".", "input_spec", "=", "base_layer", ".", "InputSpec", "(", "ndim", "=", "3", ")", "\n", "self", ".", "_forget_bias", "=", "forget_bias", "\n", "if", "gates_fc", ":", "\n", "\t\t\t", "self", ".", "gates_output_shape", "=", "[", "3", "*", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "gates_output_shape", "=", "[", "3", "*", "self", ".", "num_capsules", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVote.state_size": [[343, 347], ["tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "tensorflow.TensorShape", "tensorflow.TensorShape"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "tf", ".", "TensorShape", "(", "[", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ")", ",", "\n", "tf", ".", "TensorShape", "(", "[", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVote.output_size": [[348, 351], ["tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "tf", ".", "TensorShape", "(", "[", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVote._linear": [[352, 361], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.math_ops.matmul", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.nn_ops.bias_add", "args.get_shape"], "methods", ["None"], ["", "def", "_linear", "(", "self", ",", "args", ",", "out_size", ")", ":", "\n", "\t\t", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "dtype", "=", "args", ".", "dtype", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel_gates\"", ",", "[", "proj_size", ",", "out_size", "]", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "math_ops", ".", "matmul", "(", "args", ",", "weights", ")", "\n", "bias", "=", "vs", ".", "get_variable", "(", "\"bias_gates\"", ",", "[", "out_size", "]", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "nn_ops", ".", "bias_add", "(", "out", ",", "bias", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVote.call": [[362, 405], ["rnn_cell.LSTMCapsuleCellRecOnlyVote.predict", "rnn_cell.LSTMCapsuleCellRecOnlyVote.cluster", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.python.ops.array_ops.concat", "rnn_cell.LSTMCapsuleCellRecOnlyVote._linear", "tensorflow.reshape", "tensorflow.python.ops.array_ops.split", "rnn_cell.LSTMCapsuleCellRecOnlyVote._activation", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "inputs.get_shape", "inputs.get_shape", "inputs.get_shape", "rnn_cell.LSTMCapsuleCellRecOnlyVote._activation", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.predict", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.cluster", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tapply the layer\n\t\targs:\n\t\tinputs: the inputs to the layer. the final two dimensions are\n\t\t  num_capsules_in and capsule_dim_in\n\t\tstate: the recurrent inputs to the layer. the final two dimensions are\n\t\t  num_capsules and capsule_dim\n\t\treturns the output capsules as output capsule and as state. The last two dimensions are\n\t\tnum_capsules and capsule_dim\n\t\t\"\"\"", "\n", "\n", "batch_size", "=", "inputs", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "inputs_num_capsules", "=", "inputs", ".", "get_shape", "(", ")", "[", "-", "2", "]", "\n", "inputs_caps_dim", "=", "inputs", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "\n", "c", ",", "h", "=", "state", "\n", "\n", "# compute the predictions from the inputs", "\n", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", "=", "self", ".", "predict", "(", "inputs", ",", "h", ")", "\n", "\n", "# cluster the predictions", "\n", "j", "=", "self", ".", "cluster", "(", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", ")", "\n", "\n", "inputs_flat", "=", "tf", ".", "reshape", "(", "inputs", ",", "[", "batch_size", ",", "inputs_num_capsules", "*", "inputs_caps_dim", "]", ")", "\n", "h_flat", "=", "tf", ".", "reshape", "(", "h", ",", "[", "batch_size", ",", "self", ".", "num_capsules", "*", "self", ".", "capsule_dim", "]", ")", "\n", "\n", "args", "=", "array_ops", ".", "concat", "(", "[", "inputs_flat", ",", "h_flat", "]", ",", "1", ")", "\n", "\n", "concat", "=", "self", ".", "_linear", "(", "args", ",", "out_size", "=", "self", ".", "gates_output_shape", "[", "0", "]", "*", "self", ".", "gates_output_shape", "[", "1", "]", ")", "\n", "concat", "=", "tf", ".", "reshape", "(", "concat", ",", "[", "batch_size", "]", "+", "self", ".", "gates_output_shape", ")", "\n", "\n", "i", ",", "f", ",", "o", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "3", ",", "axis", "=", "1", ")", "\n", "\n", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "\n", "new_c", "=", "(", "c", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "\n", "new_h", "=", "self", ".", "_activation", "(", "new_c", ")", "*", "math_ops", ".", "sigmoid", "(", "o", ")", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "\n", "return", "new_h", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix.__init__": [[414, 432], ["rnn_cell.LSTMCapsuleCellRecOnlyVote.__init__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "num_capsules", ",", "capsule_dim", ",", "routing_iters", ",", "forget_bias", "=", "1.0", ",", "\n", "activation", "=", "None", ",", "input_probability_fn", "=", "None", ",", "recurrent_probability_fn", "=", "None", ",", "\n", "kernel_initializer", "=", "None", ",", "logits_initializer", "=", "None", ",", "logits_prior", "=", "False", ",", "\n", "accumulate_input_logits", "=", "True", ",", "accumulate_state_logits", "=", "True", ",", "gates_fc", "=", "False", ",", "reuse", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "\t\t", "super", "(", "LSTMCapsuleCellRecOnlyVoteOutputMatrix", ",", "self", ")", ".", "__init__", "(", "num_capsules", ",", "capsule_dim", ",", "routing_iters", ",", "\n", "forget_bias", ",", "activation", ",", "\n", "input_probability_fn", ",", "recurrent_probability_fn", ",", "\n", "kernel_initializer", ",", "logits_initializer", ",", "\n", "logits_prior", ",", "accumulate_input_logits", ",", "\n", "accumulate_state_logits", ",", "gates_fc", ",", "\n", "reuse", "=", "reuse", ",", "name", "=", "name", ")", "\n", "\n", "if", "gates_fc", ":", "\n", "\t\t\t", "self", ".", "gates_output_shape", "=", "[", "2", "*", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "gates_output_shape", "=", "[", "2", "*", "self", ".", "num_capsules", ",", "1", "]", "\n", "", "self", ".", "rot_matrix_shape", "=", "[", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", ",", "self", ".", "capsule_dim", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix._linear": [[433, 442], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.math_ops.matmul", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.nn_ops.bias_add", "args.get_shape"], "methods", ["None"], ["", "def", "_linear", "(", "self", ",", "args", ",", "out_size", ")", ":", "\n", "\t\t", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "dtype", "=", "args", ".", "dtype", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel_gates\"", ",", "[", "proj_size", ",", "out_size", "]", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "math_ops", ".", "matmul", "(", "args", ",", "weights", ")", "\n", "bias", "=", "vs", ".", "get_variable", "(", "\"bias_gates\"", ",", "[", "out_size", "]", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "nn_ops", ".", "bias_add", "(", "out", ",", "bias", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix._linear_matrix": [[443, 452], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.tensordot", "tensorflow.python.ops.variable_scope.get_variable", "args.get_shape", "tensorflow.expand_dims"], "methods", ["None"], ["", "def", "_linear_matrix", "(", "self", ",", "args", ",", "out_shape", ")", ":", "\n", "\t\t", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "dtype", "=", "args", ".", "dtype", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel_output_matrix\"", ",", "[", "proj_size", "]", "+", "out_shape", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "tf", ".", "tensordot", "(", "args", ",", "weights", ",", "axes", "=", "[", "[", "-", "1", "]", ",", "[", "0", "]", "]", ")", "\n", "bias", "=", "vs", ".", "get_variable", "(", "\"bias_output_matrix\"", ",", "out_shape", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "out", "+", "tf", ".", "expand_dims", "(", "bias", ",", "0", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix.call": [[453, 502], ["rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix.predict", "rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix.cluster", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.python.ops.array_ops.concat", "rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix._linear", "tensorflow.reshape", "tensorflow.python.ops.array_ops.split", "rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix._activation", "rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix._linear_matrix", "rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix._activation", "tensorflow.squeeze", "rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix._activation", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "inputs.get_shape", "inputs.get_shape", "inputs.get_shape", "tensorflow.matmul", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.expand_dims"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.predict", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.cluster", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LSTMCapsuleCellRecOnlyVoteOutputMatrix._linear_matrix", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tapply the layer\n\t\targs:\n\t\tinputs: the inputs to the layer. the final two dimensions are\n\t\t  num_capsules_in and capsule_dim_in\n\t\tstate: the recurrent inputs to the layer. the final two dimensions are\n\t\t  num_capsules and capsule_dim\n\t\treturns the output capsules as output capsule and as state. The last two dimensions are\n\t\tnum_capsules and capsule_dim\n\t\t\"\"\"", "\n", "\n", "batch_size", "=", "inputs", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "inputs_num_capsules", "=", "inputs", ".", "get_shape", "(", ")", "[", "-", "2", "]", "\n", "inputs_caps_dim", "=", "inputs", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "\n", "c", ",", "h", "=", "state", "\n", "\n", "# compute the predictions from the inputs", "\n", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", "=", "self", ".", "predict", "(", "inputs", ",", "h", ")", "\n", "\n", "# cluster the predictions", "\n", "j", "=", "self", ".", "cluster", "(", "input_predictions", ",", "state_predictions", ",", "input_logits", ",", "state_logits", ")", "\n", "\n", "inputs_flat", "=", "tf", ".", "reshape", "(", "inputs", ",", "[", "batch_size", ",", "inputs_num_capsules", "*", "inputs_caps_dim", "]", ")", "\n", "h_flat", "=", "tf", ".", "reshape", "(", "h", ",", "[", "batch_size", ",", "self", ".", "num_capsules", "*", "self", ".", "capsule_dim", "]", ")", "\n", "\n", "args", "=", "array_ops", ".", "concat", "(", "[", "inputs_flat", ",", "h_flat", "]", ",", "1", ")", "\n", "\n", "concat", "=", "self", ".", "_linear", "(", "args", ",", "out_size", "=", "self", ".", "gates_output_shape", "[", "0", "]", "*", "self", ".", "gates_output_shape", "[", "1", "]", ")", "\n", "concat", "=", "tf", ".", "reshape", "(", "concat", ",", "[", "batch_size", "]", "+", "self", ".", "gates_output_shape", ")", "\n", "\n", "i", ",", "f", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "2", ",", "axis", "=", "1", ")", "\n", "\n", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "\n", "new_c", "=", "(", "c", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "\n", "o", "=", "self", ".", "_linear_matrix", "(", "args", ",", "out_shape", "=", "self", ".", "rot_matrix_shape", ")", "\n", "\n", "activated_new_c", "=", "self", ".", "_activation", "(", "new_c", ")", "\n", "\n", "# apply the matrix multiplication to the activated capsule cell states", "\n", "tmp", "=", "tf", ".", "squeeze", "(", "tf", ".", "matmul", "(", "o", ",", "tf", ".", "expand_dims", "(", "activated_new_c", ",", "-", "1", ")", ")", ",", "-", "1", ")", "\n", "new_h", "=", "self", ".", "_activation", "(", "tmp", ")", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "\n", "return", "new_h", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.RNNCellLinearOut.call": [[509, 516], ["tensorflow.python.ops.math_ops.matmul", "tensorflow.python.ops.nn_ops.bias_add", "rnn_cell.RNNCellLinearOut._activation", "tensorflow.python.ops.array_ops.concat"], "methods", ["None"], ["def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "gate_inputs", "=", "math_ops", ".", "matmul", "(", "\n", "array_ops", ".", "concat", "(", "[", "inputs", ",", "state", "]", ",", "1", ")", ",", "self", ".", "_kernel", ")", "\n", "gate_inputs", "=", "nn_ops", ".", "bias_add", "(", "gate_inputs", ",", "self", ".", "_bias", ")", "\n", "output", "=", "self", ".", "_activation", "(", "gate_inputs", ")", "\n", "\n", "return", "gate_inputs", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLSTMCellLineairOut.call": [[523, 549], ["tensorflow.python.ops.array_ops.concat", "rnn_cell.LayerNormBasicLSTMCellLineairOut._linear", "tensorflow.python.ops.array_ops.split", "rnn_cell.LayerNormBasicLSTMCellLineairOut._activation", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "rnn_cell.LayerNormBasicLSTMCellLineairOut._norm", "rnn_cell.LayerNormBasicLSTMCellLineairOut._norm", "rnn_cell.LayerNormBasicLSTMCellLineairOut._norm", "rnn_cell.LayerNormBasicLSTMCellLineairOut._norm", "tensorflow.python.ops.nn_ops.dropout", "rnn_cell.LayerNormBasicLSTMCellLineairOut._norm", "tensorflow.python.ops.math_ops.sigmoid", "isinstance", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"LSTM cell with layer normalization and recurrent dropout.\"\"\"", "\n", "c", ",", "h", "=", "state", "\n", "args", "=", "array_ops", ".", "concat", "(", "[", "inputs", ",", "h", "]", ",", "1", ")", "\n", "concat", "=", "self", ".", "_linear", "(", "args", ")", "\n", "dtype", "=", "args", ".", "dtype", "\n", "\n", "i", ",", "j", ",", "f", ",", "o", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "1", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "i", "=", "self", ".", "_norm", "(", "i", ",", "\"input\"", ",", "dtype", "=", "dtype", ")", "\n", "j", "=", "self", ".", "_norm", "(", "j", ",", "\"transform\"", ",", "dtype", "=", "dtype", ")", "\n", "f", "=", "self", ".", "_norm", "(", "f", ",", "\"forget\"", ",", "dtype", "=", "dtype", ")", "\n", "o", "=", "self", ".", "_norm", "(", "o", ",", "\"output\"", ",", "dtype", "=", "dtype", ")", "\n", "\n", "", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "if", "(", "not", "isinstance", "(", "self", ".", "_keep_prob", ",", "float", ")", ")", "or", "self", ".", "_keep_prob", "<", "1", ":", "\n", "\t\t\t", "g", "=", "nn_ops", ".", "dropout", "(", "g", ",", "self", ".", "_keep_prob", ",", "seed", "=", "self", ".", "_seed", ")", "\n", "\n", "", "new_c", "=", "(", "\n", "c", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "new_c", "=", "self", ".", "_norm", "(", "new_c", ",", "\"state\"", ",", "dtype", "=", "dtype", ")", "\n", "", "new_h", "=", "new_c", "*", "math_ops", ".", "sigmoid", "(", "o", ")", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "return", "new_h", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LeakGRUCell.__init__": [[571, 589], ["tensorflow.contrib.rnn.LayerRNNCell.__init__", "tensorflow.python.layers.base.InputSpec"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_units", ",", "\n", "leak_factor", "=", "1.0", ",", "\n", "activation", "=", "None", ",", "\n", "reuse", "=", "None", ",", "\n", "kernel_initializer", "=", "None", ",", "\n", "bias_initializer", "=", "None", ",", "\n", "name", "=", "None", ")", ":", "\n", "\t\t", "super", "(", "LeakGRUCell", ",", "self", ")", ".", "__init__", "(", "_reuse", "=", "reuse", ",", "name", "=", "name", ")", "\n", "\n", "# Inputs must be 2-dimensional.", "\n", "self", ".", "input_spec", "=", "base_layer", ".", "InputSpec", "(", "ndim", "=", "2", ")", "\n", "\n", "self", ".", "_num_units", "=", "num_units", "\n", "self", ".", "_leak_factor", "=", "leak_factor", "\n", "self", ".", "_activation", "=", "activation", "or", "math_ops", ".", "tanh", "\n", "self", ".", "_kernel_initializer", "=", "kernel_initializer", "\n", "self", ".", "_bias_initializer", "=", "bias_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LeakGRUCell.state_size": [[590, 593], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LeakGRUCell.output_size": [[594, 597], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LeakGRUCell.build": [[598, 628], ["rnn_cell.LeakGRUCell.add_variable", "rnn_cell.LeakGRUCell.add_variable", "rnn_cell.LeakGRUCell.add_variable", "rnn_cell.LeakGRUCell.add_variable", "ValueError", "tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.python.ops.init_ops.zeros_initializer"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "inputs_shape", ")", ":", "\n", "\t\t", "if", "inputs_shape", "[", "1", "]", ".", "value", "is", "None", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"Expected inputs.shape[-1] to be known, saw shape: %s\"", "\n", "%", "inputs_shape", ")", "\n", "\n", "", "input_depth", "=", "inputs_shape", "[", "1", "]", ".", "value", "\n", "self", ".", "_gate_kernel", "=", "self", ".", "add_variable", "(", "\n", "\"gates/%s\"", "%", "_WEIGHTS_VARIABLE_NAME", ",", "\n", "shape", "=", "[", "input_depth", "+", "self", ".", "_num_units", ",", "2", "*", "self", ".", "_num_units", "]", ",", "\n", "initializer", "=", "self", ".", "_kernel_initializer", ")", "\n", "self", ".", "_gate_bias", "=", "self", ".", "add_variable", "(", "\n", "\"gates/%s\"", "%", "_BIAS_VARIABLE_NAME", ",", "\n", "shape", "=", "[", "2", "*", "self", ".", "_num_units", "]", ",", "\n", "initializer", "=", "(", "\n", "self", ".", "_bias_initializer", "\n", "if", "self", ".", "_bias_initializer", "is", "not", "None", "\n", "else", "init_ops", ".", "constant_initializer", "(", "1.0", ",", "dtype", "=", "self", ".", "dtype", ")", ")", ")", "\n", "self", ".", "_candidate_kernel", "=", "self", ".", "add_variable", "(", "\n", "\"candidate/%s\"", "%", "_WEIGHTS_VARIABLE_NAME", ",", "\n", "shape", "=", "[", "input_depth", "+", "self", ".", "_num_units", ",", "self", ".", "_num_units", "]", ",", "\n", "initializer", "=", "self", ".", "_kernel_initializer", ")", "\n", "self", ".", "_candidate_bias", "=", "self", ".", "add_variable", "(", "\n", "\"candidate/%s\"", "%", "_BIAS_VARIABLE_NAME", ",", "\n", "shape", "=", "[", "self", ".", "_num_units", "]", ",", "\n", "initializer", "=", "(", "\n", "self", ".", "_bias_initializer", "\n", "if", "self", ".", "_bias_initializer", "is", "not", "None", "\n", "else", "init_ops", ".", "zeros_initializer", "(", "dtype", "=", "self", ".", "dtype", ")", ")", ")", "\n", "\n", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LeakGRUCell.call": [[629, 649], ["tensorflow.python.ops.math_ops.matmul", "tensorflow.python.ops.nn_ops.bias_add", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.array_ops.split", "tensorflow.python.ops.math_ops.matmul", "tensorflow.python.ops.nn_ops.bias_add", "rnn_cell.LeakGRUCell._activation", "tensorflow.python.ops.array_ops.concat", "tensorflow.python.ops.array_ops.concat"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"Gated recurrent unit (GRU) with nunits cells.\"\"\"", "\n", "\n", "gate_inputs", "=", "math_ops", ".", "matmul", "(", "\n", "array_ops", ".", "concat", "(", "[", "inputs", ",", "state", "]", ",", "1", ")", ",", "self", ".", "_gate_kernel", ")", "\n", "gate_inputs", "=", "nn_ops", ".", "bias_add", "(", "gate_inputs", ",", "self", ".", "_gate_bias", ")", "\n", "\n", "value", "=", "math_ops", ".", "sigmoid", "(", "gate_inputs", ")", "\n", "r", ",", "u", "=", "array_ops", ".", "split", "(", "value", "=", "value", ",", "num_or_size_splits", "=", "2", ",", "axis", "=", "1", ")", "\n", "\n", "r_state", "=", "r", "*", "state", "\n", "\n", "candidate", "=", "math_ops", ".", "matmul", "(", "\n", "array_ops", ".", "concat", "(", "[", "inputs", ",", "r_state", "]", ",", "1", ")", ",", "self", ".", "_candidate_kernel", ")", "\n", "candidate", "=", "nn_ops", ".", "bias_add", "(", "candidate", ",", "self", ".", "_candidate_bias", ")", "\n", "\n", "c", "=", "self", ".", "_activation", "(", "candidate", ")", "\n", "new_h", "=", "u", "*", "state", "+", "(", "1", "-", "u", ")", "*", "c", "\n", "new_h_recurrent", "=", "new_h", "*", "self", ".", "_leak_factor", "\n", "return", "new_h", ",", "new_h_recurrent", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakLSTMCell.__init__": [[673, 712], ["tensorflow.python.ops.rnn_cell_impl.RNNCell.__init__", "tensorflow.python.platform.tf_logging.warn"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "num_units", ",", "leak_factor", "=", "1.0", ",", "forget_bias", "=", "1.0", ",", "input_size", "=", "None", ",", "activation", "=", "math_ops", ".", "tanh", ",", "\n", "layer_norm", "=", "True", ",", "norm_gain", "=", "1.0", ",", "norm_shift", "=", "0.0", ",", "dropout_keep_prob", "=", "1.0", ",", "dropout_prob_seed", "=", "None", ",", "\n", "reuse", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Initializes the basic LSTM cell.\n\n\t\tArgs:\n\t\t  num_units: int, The number of units in the LSTM cell.\n\t\t  leak_factor:\n\t\t  forget_bias: float, The bias added to forget gates (see above).\n\t\t  input_size: Deprecated and unused.\n\t\t  activation: Activation function of the inner states.\n\t\t  layer_norm: If `True`, layer normalization will be applied.\n\t\t  norm_gain: float, The layer normalization gain initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  norm_shift: float, The layer normalization shift initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  dropout_keep_prob: unit Tensor or float between 0 and 1 representing the\n\t\t\trecurrent dropout probability value. If float and 1.0, no dropout will\n\t\t\tbe applied.\n\t\t  dropout_prob_seed: (optional) integer, the randomness seed.\n\t\t  reuse: (optional) Python boolean describing whether to reuse variables\n\t\t\tin an existing scope.  If not `True`, and the existing scope already has\n\t\t\tthe given variables, an error is raised.\n\t\t\"\"\"", "\n", "super", "(", "LayerNormBasicLeakLSTMCell", ",", "self", ")", ".", "__init__", "(", "_reuse", "=", "reuse", ")", "\n", "\n", "if", "input_size", "is", "not", "None", ":", "\n", "\t\t\t", "logging", ".", "warn", "(", "\"%s: The input_size parameter is deprecated.\"", ",", "self", ")", "\n", "\n", "", "self", ".", "_num_units", "=", "num_units", "\n", "self", ".", "_leak_factor", "=", "leak_factor", "\n", "self", ".", "_activation", "=", "activation", "\n", "self", ".", "_forget_bias", "=", "forget_bias", "\n", "self", ".", "_keep_prob", "=", "dropout_keep_prob", "\n", "self", ".", "_seed", "=", "dropout_prob_seed", "\n", "self", ".", "_layer_norm", "=", "layer_norm", "\n", "self", ".", "_g", "=", "norm_gain", "\n", "self", ".", "_b", "=", "norm_shift", "\n", "self", ".", "_reuse", "=", "reuse", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakLSTMCell.state_size": [[713, 716], ["tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "self", ".", "_num_units", ",", "self", ".", "_num_units", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakLSTMCell.output_size": [[717, 720], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakLSTMCell._norm": [[721, 731], ["tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.contrib.layers.python.layers.layers.layer_norm", "inp.get_shape", "tensorflow.python.ops.variable_scope.variable_scope", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.variable_scope.get_variable"], "methods", ["None"], ["", "def", "_norm", "(", "self", ",", "inp", ",", "scope", ")", ":", "\n", "\t\t", "shape", "=", "inp", ".", "get_shape", "(", ")", "[", "-", "1", ":", "]", "\n", "gamma_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_g", ")", "\n", "beta_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_b", ")", "\n", "with", "vs", ".", "variable_scope", "(", "scope", ")", ":", "\n", "# Initialize beta and gamma for use by layer_norm.", "\n", "\t\t\t", "vs", ".", "get_variable", "(", "\"gamma\"", ",", "shape", "=", "shape", ",", "initializer", "=", "gamma_init", ")", "\n", "vs", ".", "get_variable", "(", "\"beta\"", ",", "shape", "=", "shape", ",", "initializer", "=", "beta_init", ")", "\n", "", "normalized", "=", "layers", ".", "layer_norm", "(", "inp", ",", "reuse", "=", "True", ",", "scope", "=", "scope", ")", "\n", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakLSTMCell._linear": [[732, 741], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.math_ops.matmul", "args.get_shape", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.nn_ops.bias_add"], "methods", ["None"], ["", "def", "_linear", "(", "self", ",", "args", ")", ":", "\n", "\t\t", "out_size", "=", "4", "*", "self", ".", "_num_units", "\n", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel\"", ",", "[", "proj_size", ",", "out_size", "]", ")", "\n", "out", "=", "math_ops", ".", "matmul", "(", "args", ",", "weights", ")", "\n", "if", "not", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "bias", "=", "vs", ".", "get_variable", "(", "\"bias\"", ",", "[", "out_size", "]", ")", "\n", "out", "=", "nn_ops", ".", "bias_add", "(", "out", ",", "bias", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakLSTMCell.call": [[742, 769], ["tensorflow.python.ops.array_ops.concat", "rnn_cell.LayerNormBasicLeakLSTMCell._linear", "tensorflow.python.ops.array_ops.split", "rnn_cell.LayerNormBasicLeakLSTMCell._activation", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "rnn_cell.LayerNormBasicLeakLSTMCell._norm", "rnn_cell.LayerNormBasicLeakLSTMCell._norm", "rnn_cell.LayerNormBasicLeakLSTMCell._norm", "rnn_cell.LayerNormBasicLeakLSTMCell._norm", "tensorflow.python.ops.nn_ops.dropout", "rnn_cell.LayerNormBasicLeakLSTMCell._norm", "rnn_cell.LayerNormBasicLeakLSTMCell._activation", "tensorflow.python.ops.math_ops.sigmoid", "isinstance", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"LSTM cell with layer normalization and recurrent dropout.\"\"\"", "\n", "c", ",", "h", "=", "state", "\n", "args", "=", "array_ops", ".", "concat", "(", "[", "inputs", ",", "h", "]", ",", "1", ")", "\n", "concat", "=", "self", ".", "_linear", "(", "args", ")", "\n", "\n", "i", ",", "j", ",", "f", ",", "o", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "1", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "i", "=", "self", ".", "_norm", "(", "i", ",", "\"input\"", ")", "\n", "j", "=", "self", ".", "_norm", "(", "j", ",", "\"transform\"", ")", "\n", "f", "=", "self", ".", "_norm", "(", "f", ",", "\"forget\"", ")", "\n", "o", "=", "self", ".", "_norm", "(", "o", ",", "\"output\"", ")", "\n", "\n", "", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "if", "(", "not", "isinstance", "(", "self", ".", "_keep_prob", ",", "float", ")", ")", "or", "self", ".", "_keep_prob", "<", "1", ":", "\n", "\t\t\t", "g", "=", "nn_ops", ".", "dropout", "(", "g", ",", "self", ".", "_keep_prob", ",", "seed", "=", "self", ".", "_seed", ")", "\n", "\n", "", "new_c", "=", "(", "c", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "\n", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "new_c", "=", "self", ".", "_norm", "(", "new_c", ",", "\"state\"", ")", "\n", "", "new_h", "=", "self", ".", "_activation", "(", "new_c", ")", "*", "math_ops", ".", "sigmoid", "(", "o", ")", "\n", "\n", "new_c", "=", "new_c", "*", "self", ".", "_leak_factor", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "return", "new_h", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell.__init__": [[794, 833], ["tensorflow.python.ops.rnn_cell_impl.RNNCell.__init__", "tensorflow.python.platform.tf_logging.warn"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "num_units", ",", "leak_factor", "=", "1.0", ",", "forget_bias", "=", "1.0", ",", "input_size", "=", "None", ",", "activation", "=", "math_ops", ".", "tanh", ",", "\n", "layer_norm", "=", "True", ",", "norm_gain", "=", "1.0", ",", "norm_shift", "=", "0.0", ",", "dropout_keep_prob", "=", "1.0", ",", "dropout_prob_seed", "=", "None", ",", "\n", "reuse", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Initializes the basic LSTM cell.\n\n\t\tArgs:\n\t\t  num_units: int, The number of units in the LSTM cell.\n\t\t  leak_factor:\n\t\t  forget_bias: float, The bias added to forget gates (see above).\n\t\t  input_size: Deprecated and unused.\n\t\t  activation: Activation function of the inner states.\n\t\t  layer_norm: If `True`, layer normalization will be applied.\n\t\t  norm_gain: float, The layer normalization gain initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  norm_shift: float, The layer normalization shift initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  dropout_keep_prob: unit Tensor or float between 0 and 1 representing the\n\t\t\trecurrent dropout probability value. If float and 1.0, no dropout will\n\t\t\tbe applied.\n\t\t  dropout_prob_seed: (optional) integer, the randomness seed.\n\t\t  reuse: (optional) Python boolean describing whether to reuse variables\n\t\t\tin an existing scope.  If not `True`, and the existing scope already has\n\t\t\tthe given variables, an error is raised.\n\t\t\"\"\"", "\n", "super", "(", "LayerNormIZNotRecLeakLSTMCell", ",", "self", ")", ".", "__init__", "(", "_reuse", "=", "reuse", ")", "\n", "\n", "if", "input_size", "is", "not", "None", ":", "\n", "\t\t\t", "logging", ".", "warn", "(", "\"%s: The input_size parameter is deprecated.\"", ",", "self", ")", "\n", "\n", "", "self", ".", "_num_units", "=", "num_units", "\n", "self", ".", "_leak_factor", "=", "leak_factor", "\n", "self", ".", "_activation", "=", "activation", "\n", "self", ".", "_forget_bias", "=", "forget_bias", "\n", "self", ".", "_keep_prob", "=", "dropout_keep_prob", "\n", "self", ".", "_seed", "=", "dropout_prob_seed", "\n", "self", ".", "_layer_norm", "=", "layer_norm", "\n", "self", ".", "_g", "=", "norm_gain", "\n", "self", ".", "_b", "=", "norm_shift", "\n", "self", ".", "_reuse", "=", "reuse", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell.state_size": [[834, 837], ["tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "self", ".", "_num_units", ",", "self", ".", "_num_units", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell.output_size": [[838, 841], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell._norm": [[842, 852], ["tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.contrib.layers.python.layers.layers.layer_norm", "inp.get_shape", "tensorflow.python.ops.variable_scope.variable_scope", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.variable_scope.get_variable"], "methods", ["None"], ["", "def", "_norm", "(", "self", ",", "inp", ",", "scope", ")", ":", "\n", "\t\t", "shape", "=", "inp", ".", "get_shape", "(", ")", "[", "-", "1", ":", "]", "\n", "gamma_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_g", ")", "\n", "beta_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_b", ")", "\n", "with", "vs", ".", "variable_scope", "(", "scope", ")", ":", "\n", "# Initialize beta and gamma for use by layer_norm.", "\n", "\t\t\t", "vs", ".", "get_variable", "(", "\"gamma\"", ",", "shape", "=", "shape", ",", "initializer", "=", "gamma_init", ")", "\n", "vs", ".", "get_variable", "(", "\"beta\"", ",", "shape", "=", "shape", ",", "initializer", "=", "beta_init", ")", "\n", "", "normalized", "=", "layers", ".", "layer_norm", "(", "inp", ",", "reuse", "=", "True", ",", "scope", "=", "scope", ")", "\n", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell._linear": [[853, 862], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.math_ops.matmul", "args.get_shape", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.nn_ops.bias_add"], "methods", ["None"], ["", "def", "_linear", "(", "self", ",", "args", ")", ":", "\n", "\t\t", "out_size", "=", "2", "*", "self", ".", "_num_units", "\n", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel\"", ",", "[", "proj_size", ",", "out_size", "]", ")", "\n", "out", "=", "math_ops", ".", "matmul", "(", "args", ",", "weights", ")", "\n", "if", "not", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "bias", "=", "vs", ".", "get_variable", "(", "\"bias\"", ",", "[", "out_size", "]", ")", "\n", "out", "=", "nn_ops", ".", "bias_add", "(", "out", ",", "bias", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell._linear_inonly": [[863, 872], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.math_ops.matmul", "args.get_shape", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.nn_ops.bias_add"], "methods", ["None"], ["", "def", "_linear_inonly", "(", "self", ",", "args", ")", ":", "\n", "\t\t", "out_size", "=", "2", "*", "self", ".", "_num_units", "\n", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel_inonly\"", ",", "[", "proj_size", ",", "out_size", "]", ")", "\n", "out", "=", "math_ops", ".", "matmul", "(", "args", ",", "weights", ")", "\n", "if", "not", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "bias", "=", "vs", ".", "get_variable", "(", "\"bias_inonly\"", ",", "[", "out_size", "]", ")", "\n", "out", "=", "nn_ops", ".", "bias_add", "(", "out", ",", "bias", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell.call": [[873, 902], ["tensorflow.python.ops.array_ops.concat", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._linear", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._linear_inonly", "tensorflow.python.ops.array_ops.split", "tensorflow.python.ops.array_ops.split", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._activation", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._norm", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._norm", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._norm", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._norm", "tensorflow.python.ops.nn_ops.dropout", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._norm", "rnn_cell.LayerNormIZNotRecLeakLSTMCell._activation", "tensorflow.python.ops.math_ops.sigmoid", "isinstance", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell._linear_inonly", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"LSTM cell with layer normalization and recurrent dropout.\"\"\"", "\n", "c", ",", "h", "=", "state", "\n", "args", "=", "array_ops", ".", "concat", "(", "[", "inputs", ",", "h", "]", ",", "1", ")", "\n", "concat", "=", "self", ".", "_linear", "(", "args", ")", "\n", "concat_inonly", "=", "self", ".", "_linear_inonly", "(", "inputs", ")", "\n", "\n", "f", ",", "o", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "2", ",", "axis", "=", "1", ")", "\n", "i", ",", "j", "=", "array_ops", ".", "split", "(", "value", "=", "concat_inonly", ",", "num_or_size_splits", "=", "2", ",", "axis", "=", "1", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "i", "=", "self", ".", "_norm", "(", "i", ",", "\"input\"", ")", "\n", "j", "=", "self", ".", "_norm", "(", "j", ",", "\"transform\"", ")", "\n", "f", "=", "self", ".", "_norm", "(", "f", ",", "\"forget\"", ")", "\n", "o", "=", "self", ".", "_norm", "(", "o", ",", "\"output\"", ")", "\n", "\n", "", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "if", "(", "not", "isinstance", "(", "self", ".", "_keep_prob", ",", "float", ")", ")", "or", "self", ".", "_keep_prob", "<", "1", ":", "\n", "\t\t\t", "g", "=", "nn_ops", ".", "dropout", "(", "g", ",", "self", ".", "_keep_prob", ",", "seed", "=", "self", ".", "_seed", ")", "\n", "\n", "", "new_c", "=", "(", "c", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "\n", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "new_c", "=", "self", ".", "_norm", "(", "new_c", ",", "\"state\"", ")", "\n", "", "new_h", "=", "self", ".", "_activation", "(", "new_c", ")", "*", "math_ops", ".", "sigmoid", "(", "o", ")", "\n", "\n", "new_c", "=", "new_c", "*", "self", ".", "_leak_factor", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "return", "new_h", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormNotRecLeakLSTMCell.__init__": [[927, 966], ["tensorflow.python.ops.rnn_cell_impl.RNNCell.__init__", "tensorflow.python.platform.tf_logging.warn"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "num_units", ",", "leak_factor", "=", "1.0", ",", "forget_bias", "=", "1.0", ",", "input_size", "=", "None", ",", "activation", "=", "math_ops", ".", "tanh", ",", "\n", "layer_norm", "=", "True", ",", "norm_gain", "=", "1.0", ",", "norm_shift", "=", "0.0", ",", "dropout_keep_prob", "=", "1.0", ",", "dropout_prob_seed", "=", "None", ",", "\n", "reuse", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Initializes the basic LSTM cell.\n\n\t\tArgs:\n\t\t  num_units: int, The number of units in the LSTM cell.\n\t\t  leak_factor:\n\t\t  forget_bias: float, The bias added to forget gates (see above).\n\t\t  input_size: Deprecated and unused.\n\t\t  activation: Activation function of the inner states.\n\t\t  layer_norm: If `True`, layer normalization will be applied.\n\t\t  norm_gain: float, The layer normalization gain initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  norm_shift: float, The layer normalization shift initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  dropout_keep_prob: unit Tensor or float between 0 and 1 representing the\n\t\t\trecurrent dropout probability value. If float and 1.0, no dropout will\n\t\t\tbe applied.\n\t\t  dropout_prob_seed: (optional) integer, the randomness seed.\n\t\t  reuse: (optional) Python boolean describing whether to reuse variables\n\t\t\tin an existing scope.  If not `True`, and the existing scope already has\n\t\t\tthe given variables, an error is raised.\n\t\t\"\"\"", "\n", "super", "(", "LayerNormNotRecLeakLSTMCell", ",", "self", ")", ".", "__init__", "(", "_reuse", "=", "reuse", ")", "\n", "\n", "if", "input_size", "is", "not", "None", ":", "\n", "\t\t  ", "logging", ".", "warn", "(", "\"%s: The input_size parameter is deprecated.\"", ",", "self", ")", "\n", "\n", "", "self", ".", "_num_units", "=", "num_units", "\n", "self", ".", "_leak_factor", "=", "leak_factor", "\n", "self", ".", "_activation", "=", "activation", "\n", "self", ".", "_forget_bias", "=", "forget_bias", "\n", "self", ".", "_keep_prob", "=", "dropout_keep_prob", "\n", "self", ".", "_seed", "=", "dropout_prob_seed", "\n", "self", ".", "_layer_norm", "=", "layer_norm", "\n", "self", ".", "_g", "=", "norm_gain", "\n", "self", ".", "_b", "=", "norm_shift", "\n", "self", ".", "_reuse", "=", "reuse", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormNotRecLeakLSTMCell.state_size": [[967, 970], ["tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "self", ".", "_num_units", ",", "self", ".", "_num_units", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormNotRecLeakLSTMCell.output_size": [[971, 974], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormNotRecLeakLSTMCell._norm": [[975, 985], ["tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.contrib.layers.python.layers.layers.layer_norm", "inp.get_shape", "tensorflow.python.ops.variable_scope.variable_scope", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.variable_scope.get_variable"], "methods", ["None"], ["", "def", "_norm", "(", "self", ",", "inp", ",", "scope", ")", ":", "\n", "\t\t", "shape", "=", "inp", ".", "get_shape", "(", ")", "[", "-", "1", ":", "]", "\n", "gamma_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_g", ")", "\n", "beta_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_b", ")", "\n", "with", "vs", ".", "variable_scope", "(", "scope", ")", ":", "\n", "# Initialize beta and gamma for use by layer_norm.", "\n", "\t\t\t", "vs", ".", "get_variable", "(", "\"gamma\"", ",", "shape", "=", "shape", ",", "initializer", "=", "gamma_init", ")", "\n", "vs", ".", "get_variable", "(", "\"beta\"", ",", "shape", "=", "shape", ",", "initializer", "=", "beta_init", ")", "\n", "", "normalized", "=", "layers", ".", "layer_norm", "(", "inp", ",", "reuse", "=", "True", ",", "scope", "=", "scope", ")", "\n", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormNotRecLeakLSTMCell._linear": [[986, 995], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.math_ops.matmul", "args.get_shape", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.nn_ops.bias_add"], "methods", ["None"], ["", "def", "_linear", "(", "self", ",", "args", ")", ":", "\n", "\t\t", "out_size", "=", "4", "*", "self", ".", "_num_units", "\n", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel\"", ",", "[", "proj_size", ",", "out_size", "]", ")", "\n", "out", "=", "math_ops", ".", "matmul", "(", "args", ",", "weights", ")", "\n", "if", "not", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "bias", "=", "vs", ".", "get_variable", "(", "\"bias\"", ",", "[", "out_size", "]", ")", "\n", "out", "=", "nn_ops", ".", "bias_add", "(", "out", ",", "bias", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormNotRecLeakLSTMCell.call": [[996, 1023], ["rnn_cell.LayerNormNotRecLeakLSTMCell._linear", "tensorflow.python.ops.array_ops.split", "rnn_cell.LayerNormNotRecLeakLSTMCell._activation", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "rnn_cell.LayerNormNotRecLeakLSTMCell._norm", "rnn_cell.LayerNormNotRecLeakLSTMCell._norm", "rnn_cell.LayerNormNotRecLeakLSTMCell._norm", "rnn_cell.LayerNormNotRecLeakLSTMCell._norm", "tensorflow.python.ops.nn_ops.dropout", "rnn_cell.LayerNormNotRecLeakLSTMCell._norm", "rnn_cell.LayerNormNotRecLeakLSTMCell._activation", "tensorflow.python.ops.math_ops.sigmoid", "isinstance", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"LSTM cell with layer normalization and recurrent dropout.\"\"\"", "\n", "c", ",", "h", "=", "state", "\n", "# args = array_ops.concat([inputs, h], 1)", "\n", "concat", "=", "self", ".", "_linear", "(", "inputs", ")", "\n", "\n", "i", ",", "j", ",", "f", ",", "o", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "1", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "i", "=", "self", ".", "_norm", "(", "i", ",", "\"input\"", ")", "\n", "j", "=", "self", ".", "_norm", "(", "j", ",", "\"transform\"", ")", "\n", "f", "=", "self", ".", "_norm", "(", "f", ",", "\"forget\"", ")", "\n", "o", "=", "self", ".", "_norm", "(", "o", ",", "\"output\"", ")", "\n", "\n", "", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "if", "(", "not", "isinstance", "(", "self", ".", "_keep_prob", ",", "float", ")", ")", "or", "self", ".", "_keep_prob", "<", "1", ":", "\n", "\t\t\t", "g", "=", "nn_ops", ".", "dropout", "(", "g", ",", "self", ".", "_keep_prob", ",", "seed", "=", "self", ".", "_seed", ")", "\n", "\n", "", "new_c", "=", "(", "c", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "\n", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "new_c", "=", "self", ".", "_norm", "(", "new_c", ",", "\"state\"", ")", "\n", "", "new_h", "=", "self", ".", "_activation", "(", "new_c", ")", "*", "math_ops", ".", "sigmoid", "(", "o", ")", "\n", "\n", "new_c", "=", "new_c", "*", "self", ".", "_leak_factor", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "return", "new_h", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakchLSTMCell.__init__": [[1047, 1086], ["tensorflow.python.ops.rnn_cell_impl.RNNCell.__init__", "tensorflow.python.platform.tf_logging.warn"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "num_units", ",", "leak_factor", "=", "1.0", ",", "forget_bias", "=", "1.0", ",", "input_size", "=", "None", ",", "activation", "=", "math_ops", ".", "tanh", ",", "\n", "layer_norm", "=", "True", ",", "norm_gain", "=", "1.0", ",", "norm_shift", "=", "0.0", ",", "dropout_keep_prob", "=", "1.0", ",", "dropout_prob_seed", "=", "None", ",", "\n", "reuse", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Initializes the basic LSTM cell.\n\n\t\tArgs:\n\t\t  num_units: int, The number of units in the LSTM cell.\n\t\t  leak_factor:\n\t\t  forget_bias: float, The bias added to forget gates (see above).\n\t\t  input_size: Deprecated and unused.\n\t\t  activation: Activation function of the inner states.\n\t\t  layer_norm: If `True`, layer normalization will be applied.\n\t\t  norm_gain: float, The layer normalization gain initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  norm_shift: float, The layer normalization shift initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  dropout_keep_prob: unit Tensor or float between 0 and 1 representing the\n\t\t\trecurrent dropout probability value. If float and 1.0, no dropout will\n\t\t\tbe applied.\n\t\t  dropout_prob_seed: (optional) integer, the randomness seed.\n\t\t  reuse: (optional) Python boolean describing whether to reuse variables\n\t\t\tin an existing scope.  If not `True`, and the existing scope already has\n\t\t\tthe given variables, an error is raised.\n\t\t\"\"\"", "\n", "super", "(", "LayerNormBasicLeakchLSTMCell", ",", "self", ")", ".", "__init__", "(", "_reuse", "=", "reuse", ")", "\n", "\n", "if", "input_size", "is", "not", "None", ":", "\n", "\t\t\t", "logging", ".", "warn", "(", "\"%s: The input_size parameter is deprecated.\"", ",", "self", ")", "\n", "\n", "", "self", ".", "_num_units", "=", "num_units", "\n", "self", ".", "_leak_factor", "=", "leak_factor", "\n", "self", ".", "_activation", "=", "activation", "\n", "self", ".", "_forget_bias", "=", "forget_bias", "\n", "self", ".", "_keep_prob", "=", "dropout_keep_prob", "\n", "self", ".", "_seed", "=", "dropout_prob_seed", "\n", "self", ".", "_layer_norm", "=", "layer_norm", "\n", "self", ".", "_g", "=", "norm_gain", "\n", "self", ".", "_b", "=", "norm_shift", "\n", "self", ".", "_reuse", "=", "reuse", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakchLSTMCell.state_size": [[1087, 1090], ["tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "self", ".", "_num_units", ",", "self", ".", "_num_units", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakchLSTMCell.output_size": [[1091, 1094], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakchLSTMCell._norm": [[1095, 1105], ["tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.contrib.layers.python.layers.layers.layer_norm", "inp.get_shape", "tensorflow.python.ops.variable_scope.variable_scope", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.variable_scope.get_variable"], "methods", ["None"], ["", "def", "_norm", "(", "self", ",", "inp", ",", "scope", ")", ":", "\n", "\t\t", "shape", "=", "inp", ".", "get_shape", "(", ")", "[", "-", "1", ":", "]", "\n", "gamma_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_g", ")", "\n", "beta_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_b", ")", "\n", "with", "vs", ".", "variable_scope", "(", "scope", ")", ":", "\n", "# Initialize beta and gamma for use by layer_norm.", "\n", "\t\t\t", "vs", ".", "get_variable", "(", "\"gamma\"", ",", "shape", "=", "shape", ",", "initializer", "=", "gamma_init", ")", "\n", "vs", ".", "get_variable", "(", "\"beta\"", ",", "shape", "=", "shape", ",", "initializer", "=", "beta_init", ")", "\n", "", "normalized", "=", "layers", ".", "layer_norm", "(", "inp", ",", "reuse", "=", "True", ",", "scope", "=", "scope", ")", "\n", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakchLSTMCell._linear": [[1106, 1115], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.math_ops.matmul", "args.get_shape", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.nn_ops.bias_add"], "methods", ["None"], ["", "def", "_linear", "(", "self", ",", "args", ")", ":", "\n", "\t\t", "out_size", "=", "4", "*", "self", ".", "_num_units", "\n", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel\"", ",", "[", "proj_size", ",", "out_size", "]", ")", "\n", "out", "=", "math_ops", ".", "matmul", "(", "args", ",", "weights", ")", "\n", "if", "not", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "bias", "=", "vs", ".", "get_variable", "(", "\"bias\"", ",", "[", "out_size", "]", ")", "\n", "out", "=", "nn_ops", ".", "bias_add", "(", "out", ",", "bias", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormBasicLeakchLSTMCell.call": [[1116, 1146], ["tensorflow.python.ops.array_ops.concat", "rnn_cell.LayerNormBasicLeakchLSTMCell._linear", "tensorflow.python.ops.array_ops.split", "rnn_cell.LayerNormBasicLeakchLSTMCell._activation", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "rnn_cell.LayerNormBasicLeakchLSTMCell._norm", "rnn_cell.LayerNormBasicLeakchLSTMCell._norm", "rnn_cell.LayerNormBasicLeakchLSTMCell._norm", "rnn_cell.LayerNormBasicLeakchLSTMCell._norm", "tensorflow.python.ops.nn_ops.dropout", "rnn_cell.LayerNormBasicLeakchLSTMCell._norm", "rnn_cell.LayerNormBasicLeakchLSTMCell._activation", "tensorflow.python.ops.math_ops.sigmoid", "isinstance", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"LSTM cell with layer normalization and recurrent dropout.\"\"\"", "\n", "c", ",", "h", "=", "state", "\n", "\n", "# leak recurrent memory", "\n", "c", "=", "c", "*", "self", ".", "_leak_factor", "\n", "h", "=", "h", "*", "self", ".", "_leak_factor", "\n", "\n", "args", "=", "array_ops", ".", "concat", "(", "[", "inputs", ",", "h", "]", ",", "1", ")", "\n", "concat", "=", "self", ".", "_linear", "(", "args", ")", "\n", "\n", "i", ",", "j", ",", "f", ",", "o", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "1", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "i", "=", "self", ".", "_norm", "(", "i", ",", "\"input\"", ")", "\n", "j", "=", "self", ".", "_norm", "(", "j", ",", "\"transform\"", ")", "\n", "f", "=", "self", ".", "_norm", "(", "f", ",", "\"forget\"", ")", "\n", "o", "=", "self", ".", "_norm", "(", "o", ",", "\"output\"", ")", "\n", "\n", "", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "if", "(", "not", "isinstance", "(", "self", ".", "_keep_prob", ",", "float", ")", ")", "or", "self", ".", "_keep_prob", "<", "1", ":", "\n", "\t\t\t", "g", "=", "nn_ops", ".", "dropout", "(", "g", ",", "self", ".", "_keep_prob", ",", "seed", "=", "self", ".", "_seed", ")", "\n", "\n", "", "new_c", "=", "(", "c", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "\n", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "new_c", "=", "self", ".", "_norm", "(", "new_c", ",", "\"state\"", ")", "\n", "", "new_h", "=", "self", ".", "_activation", "(", "new_c", ")", "*", "math_ops", ".", "sigmoid", "(", "o", ")", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "return", "new_h", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell.__init__": [[1152, 1199], ["nabu.neuralnetworks.components.rnn_cell_impl.RNNCell.__init__", "tensorflow.python.platform.tf_logging.warn"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_units", ",", "\n", "t_reset", "=", "1", ",", "\n", "forget_bias", "=", "1.0", ",", "\n", "input_size", "=", "None", ",", "\n", "activation", "=", "math_ops", ".", "tanh", ",", "\n", "layer_norm", "=", "True", ",", "\n", "norm_gain", "=", "1.0", ",", "\n", "norm_shift", "=", "0.0", ",", "\n", "dropout_keep_prob", "=", "1.0", ",", "\n", "dropout_prob_seed", "=", "None", ",", "\n", "reuse", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Initializes the reset LSTM cell.\n\t\tArgs:\n\t\t  num_units: int, The number of units in the LSTM cell.\n\t\t  t_reset: int, the reset cycle period.\n\t\t  forget_bias: float, The bias added to forget gates (see above).\n\t\t  input_size: Deprecated and unused.\n\t\t  activation: Activation function of the inner states.\n\t\t  layer_norm: If `True`, layer normalization will be applied.\n\t\t  norm_gain: float, The layer normalization gain initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  norm_shift: float, The layer normalization shift initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  dropout_keep_prob: unit Tensor or float between 0 and 1 representing the\n\t\t\trecurrent dropout probability value. If float and 1.0, no dropout will\n\t\t\tbe applied.\n\t\t  dropout_prob_seed: (optional) integer, the randomness seed.\n\t\t  reuse: (optional) Python boolean describing whether to reuse variables\n\t\t\tin an existing scope.  If not `True`, and the existing scope already has\n\t\t\tthe given variables, an error is raised.\n\t\t\"\"\"", "\n", "super", "(", "LayerNormResetLSTMCell", ",", "self", ")", ".", "__init__", "(", "_reuse", "=", "reuse", ")", "\n", "\n", "if", "input_size", "is", "not", "None", ":", "\n", "\t\t\t", "logging", ".", "warn", "(", "\"%s: The input_size parameter is deprecated.\"", ",", "self", ")", "\n", "\n", "", "self", ".", "_num_units", "=", "num_units", "\n", "self", ".", "_t_reset", "=", "t_reset", "\n", "self", ".", "_activation", "=", "activation", "\n", "self", ".", "_forget_bias", "=", "forget_bias", "\n", "self", ".", "_keep_prob", "=", "dropout_keep_prob", "\n", "self", ".", "_seed", "=", "dropout_prob_seed", "\n", "self", ".", "_layer_norm", "=", "layer_norm", "\n", "self", ".", "_norm_gain", "=", "norm_gain", "\n", "self", ".", "_norm_shift", "=", "norm_shift", "\n", "self", ".", "_reuse", "=", "reuse", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell.state_size": [[1200, 1203], ["tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "tensorflow.TensorShape", "tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "tf", ".", "TensorShape", "(", "[", "self", ".", "_t_reset", ",", "self", ".", "_num_units", "]", ")", ",", "tf", ".", "TensorShape", "(", "[", "self", ".", "_t_reset", ",", "self", ".", "_num_units", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell.output_size": [[1204, 1208], ["tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "# output tuple: (actual output, multi state output)", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", ",", "tf", ".", "TensorShape", "(", "[", "self", ".", "_t_reset", ",", "self", ".", "_num_units", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm": [[1209, 1219], ["tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.contrib.layers.python.layers.layers.layer_norm", "inp.get_shape", "tensorflow.python.ops.variable_scope.variable_scope", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.variable_scope.get_variable"], "methods", ["None"], ["", "def", "_norm", "(", "self", ",", "inp", ",", "scope", ",", "dtype", "=", "dtypes", ".", "float32", ")", ":", "\n", "\t\t", "shape", "=", "inp", ".", "get_shape", "(", ")", "[", "-", "1", ":", "]", "\n", "gamma_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_norm_gain", ")", "\n", "beta_init", "=", "init_ops", ".", "constant_initializer", "(", "self", ".", "_norm_shift", ")", "\n", "with", "vs", ".", "variable_scope", "(", "scope", ")", ":", "\n", "# Initialize beta and gamma for use by layer_norm.", "\n", "\t\t\t", "vs", ".", "get_variable", "(", "\"gamma\"", ",", "shape", "=", "shape", ",", "initializer", "=", "gamma_init", ",", "dtype", "=", "dtype", ")", "\n", "vs", ".", "get_variable", "(", "\"beta\"", ",", "shape", "=", "shape", ",", "initializer", "=", "beta_init", ",", "dtype", "=", "dtype", ")", "\n", "", "normalized", "=", "layers", ".", "layer_norm", "(", "inp", ",", "reuse", "=", "True", ",", "scope", "=", "scope", ")", "\n", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear": [[1220, 1230], ["tensorflow.python.ops.variable_scope.get_variable", "tensorflow.tensordot", "args.get_shape", "tensorflow.python.ops.variable_scope.get_variable", "tensorflow.python.ops.nn_ops.bias_add"], "methods", ["None"], ["", "def", "_linear", "(", "self", ",", "args", ")", ":", "\n", "\t\t", "out_size", "=", "4", "*", "self", ".", "_num_units", "\n", "proj_size", "=", "args", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "dtype", "=", "args", ".", "dtype", "\n", "weights", "=", "vs", ".", "get_variable", "(", "\"kernel\"", ",", "[", "proj_size", ",", "out_size", "]", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "tf", ".", "tensordot", "(", "args", ",", "weights", ",", "[", "[", "-", "1", "]", ",", "[", "0", "]", "]", ")", "\n", "if", "not", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "bias", "=", "vs", ".", "get_variable", "(", "\"bias\"", ",", "[", "out_size", "]", ",", "dtype", "=", "dtype", ")", "\n", "out", "=", "nn_ops", ".", "bias_add", "(", "out", ",", "bias", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell.call": [[1231, 1270], ["tensorflow.mod", "tensorflow.mod", "tensorflow.expand_dims", "tensorflow.python.ops.array_ops.concat", "rnn_cell.LayerNormResetLSTMCell._linear", "tensorflow.python.ops.array_ops.split", "rnn_cell.LayerNormResetLSTMCell._activation", "tensorflow.gather", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "tensorflow.scatter_nd", "tensorflow.expand_dims", "rnn_cell.LayerNormResetLSTMCell._norm", "rnn_cell.LayerNormResetLSTMCell._norm", "rnn_cell.LayerNormResetLSTMCell._norm", "rnn_cell.LayerNormResetLSTMCell._norm", "tensorflow.python.ops.nn_ops.dropout", "rnn_cell.LayerNormResetLSTMCell._norm", "rnn_cell.LayerNormResetLSTMCell._activation", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.expand_dims", "tensorflow.constant", "tensorflow.constant", "isinstance", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.expand_dims"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ",", "time", ")", ":", "\n", "\t\t", "\"\"\"LSTM cell with layer normalization and recurrent dropout.\"\"\"", "\n", "\n", "state_index", "=", "tf", ".", "mod", "(", "time", ",", "self", ".", "_t_reset", ")", "\n", "next_state_index", "=", "tf", ".", "mod", "(", "time", "+", "1", ",", "self", ".", "_t_reset", ")", "\n", "c", ",", "h", "=", "state", "\n", "\n", "# apply reset", "\n", "tmp", "=", "1", "-", "tf", ".", "scatter_nd", "(", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "state_index", ",", "0", ")", ",", "0", ")", ",", "tf", ".", "constant", "(", "[", "1.0", "]", ")", ",", "\n", "tf", ".", "constant", "(", "[", "self", ".", "_t_reset", "]", ")", ")", "\n", "reset_mask", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "tmp", ",", "0", ")", ",", "-", "1", ")", "\n", "\n", "c_reset", "=", "c", "*", "reset_mask", "\n", "h_reset", "=", "h", "*", "reset_mask", "\n", "\n", "args", "=", "array_ops", ".", "concat", "(", "[", "inputs", ",", "h_reset", "]", ",", "-", "1", ")", "\n", "concat", "=", "self", ".", "_linear", "(", "args", ")", "\n", "dtype", "=", "args", ".", "dtype", "\n", "\n", "i", ",", "j", ",", "f", ",", "o", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "-", "1", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "i", "=", "self", ".", "_norm", "(", "i", ",", "\"input\"", ",", "dtype", "=", "dtype", ")", "\n", "j", "=", "self", ".", "_norm", "(", "j", ",", "\"transform\"", ",", "dtype", "=", "dtype", ")", "\n", "f", "=", "self", ".", "_norm", "(", "f", ",", "\"forget\"", ",", "dtype", "=", "dtype", ")", "\n", "o", "=", "self", ".", "_norm", "(", "o", ",", "\"output\"", ",", "dtype", "=", "dtype", ")", "\n", "\n", "", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "if", "(", "not", "isinstance", "(", "self", ".", "_keep_prob", ",", "float", ")", ")", "or", "self", ".", "_keep_prob", "<", "1", ":", "\n", "\t\t\t", "g", "=", "nn_ops", ".", "dropout", "(", "g", ",", "self", ".", "_keep_prob", ",", "seed", "=", "self", ".", "_seed", ")", "\n", "# (i,g,f,o) = (tf.expand_dims(val, -1) for val in (i,g,f,o))", "\n", "\n", "", "new_c", "=", "(", "c_reset", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "new_c", "=", "self", ".", "_norm", "(", "new_c", ",", "\"state\"", ",", "dtype", "=", "dtype", ")", "\n", "", "new_h", "=", "self", ".", "_activation", "(", "new_c", ")", "*", "math_ops", ".", "sigmoid", "(", "o", ")", "\n", "new_h_maxmem", "=", "tf", ".", "gather", "(", "new_h", ",", "next_state_index", ",", "axis", "=", "1", ")", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "return", "(", "new_h_maxmem", ",", "new_h", ")", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormGroupResetLSTMCell.__init__": [[1276, 1325], ["rnn_cell.LayerNormResetLSTMCell.__init__", "int", "tensorflow.python.platform.tf_logging.warn", "float", "float", "ValueError"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_units", ",", "\n", "t_reset", "=", "1", ",", "\n", "group_size", "=", "1", ",", "\n", "forget_bias", "=", "1.0", ",", "\n", "input_size", "=", "None", ",", "\n", "activation", "=", "math_ops", ".", "tanh", ",", "\n", "layer_norm", "=", "True", ",", "\n", "norm_gain", "=", "1.0", ",", "\n", "norm_shift", "=", "0.0", ",", "\n", "dropout_keep_prob", "=", "1.0", ",", "\n", "dropout_prob_seed", "=", "None", ",", "\n", "reuse", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Initializes the reset LSTM cell.\n\t\tArgs:\n\t\t  num_units: int, The number of units in the LSTM cell.\n\t\t  t_reset: int, the reset cycle period.\n\t\t  group_size: int, the size of the group\n\t\t  forget_bias: float, The bias added to forget gates (see above).\n\t\t  input_size: Deprecated and unused.\n\t\t  activation: Activation function of the inner states.\n\t\t  layer_norm: If `True`, layer normalization will be applied.\n\t\t  norm_gain: float, The layer normalization gain initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  norm_shift: float, The layer normalization shift initial value. If\n\t\t\t`layer_norm` has been set to `False`, this argument will be ignored.\n\t\t  dropout_keep_prob: unit Tensor or float between 0 and 1 representing the\n\t\t\trecurrent dropout probability value. If float and 1.0, no dropout will\n\t\t\tbe applied.\n\t\t  dropout_prob_seed: (optional) integer, the randomness seed.\n\t\t  reuse: (optional) Python boolean describing whether to reuse variables\n\t\t\tin an existing scope.  If not `True`, and the existing scope already has\n\t\t\tthe given variables, an error is raised.\n\t\t\"\"\"", "\n", "super", "(", "LayerNormGroupResetLSTMCell", ",", "self", ")", ".", "__init__", "(", "num_units", ",", "t_reset", "=", "t_reset", ",", "forget_bias", "=", "forget_bias", ",", "\n", "input_size", "=", "input_size", ",", "activation", "=", "activation", ",", "\n", "layer_norm", "=", "layer_norm", ",", "norm_gain", "=", "norm_gain", ",", "\n", "norm_shift", "=", "norm_shift", ",", "dropout_keep_prob", "=", "dropout_keep_prob", ",", "\n", "dropout_prob_seed", "=", "dropout_prob_seed", ",", "reuse", "=", "reuse", ")", "\n", "\n", "if", "input_size", "is", "not", "None", ":", "\n", "\t\t\t", "logging", ".", "warn", "(", "\"%s: The input_size parameter is deprecated.\"", ",", "self", ")", "\n", "\n", "", "self", ".", "_group_size", "=", "group_size", "\n", "num_replicates", "=", "float", "(", "self", ".", "_t_reset", ")", "/", "float", "(", "self", ".", "_group_size", ")", "\n", "self", ".", "_num_replicates", "=", "int", "(", "num_replicates", ")", "\n", "\n", "if", "self", ".", "_num_replicates", "!=", "num_replicates", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'t_reset should be a multiple of group_size'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormGroupResetLSTMCell.state_size": [[1326, 1330], ["tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "tensorflow.TensorShape", "tensorflow.TensorShape"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "tf", ".", "TensorShape", "(", "[", "self", ".", "_num_replicates", ",", "self", ".", "_num_units", "]", ")", ",", "\n", "tf", ".", "TensorShape", "(", "[", "self", ".", "_num_replicates", ",", "self", ".", "_num_units", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormGroupResetLSTMCell.output_size": [[1331, 1335], ["tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "# output tuple: (actual output, multi state output)", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "_num_units", ",", "tf", ".", "TensorShape", "(", "[", "self", ".", "_num_replicates", ",", "self", ".", "_num_units", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormGroupResetLSTMCell.call": [[1336, 1381], ["tensorflow.mod", "tensorflow.floor_div", "tensorflow.mod", "tensorflow.floor_div", "tensorflow.mod", "tensorflow.expand_dims", "tensorflow.equal", "tensorflow.cond", "tensorflow.cond", "tensorflow.python.ops.array_ops.concat", "rnn_cell.LayerNormGroupResetLSTMCell._linear", "tensorflow.python.ops.array_ops.split", "rnn_cell.LayerNormGroupResetLSTMCell._activation", "tensorflow.gather", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "tensorflow.scatter_nd", "tensorflow.expand_dims", "rnn_cell.LayerNormGroupResetLSTMCell._norm", "rnn_cell.LayerNormGroupResetLSTMCell._norm", "rnn_cell.LayerNormGroupResetLSTMCell._norm", "rnn_cell.LayerNormGroupResetLSTMCell._norm", "tensorflow.python.ops.nn_ops.dropout", "rnn_cell.LayerNormGroupResetLSTMCell._norm", "rnn_cell.LayerNormGroupResetLSTMCell._activation", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.expand_dims", "tensorflow.constant", "tensorflow.constant", "isinstance", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.python.ops.math_ops.sigmoid", "tensorflow.expand_dims"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._linear", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.LayerNormResetLSTMCell._norm", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "call", "(", "self", ",", "inputs", ",", "state", ",", "time", ")", ":", "\n", "\t\t", "\"\"\"LSTM cell with layer normalization and recurrent dropout.\"\"\"", "\n", "\n", "state_index_in_group", "=", "tf", ".", "mod", "(", "time", ",", "self", ".", "_group_size", ")", "\n", "group_index", "=", "tf", ".", "floor_div", "(", "time", ",", "self", ".", "_group_size", ")", "\n", "replicate_index", "=", "tf", ".", "mod", "(", "group_index", ",", "self", ".", "_num_replicates", ")", "\n", "next_group_index", "=", "tf", ".", "floor_div", "(", "time", "+", "1", ",", "self", ".", "_group_size", ")", "\n", "next_replicate_index", "=", "tf", ".", "mod", "(", "next_group_index", ",", "self", ".", "_num_replicates", ")", "\n", "\n", "c", ",", "h", "=", "state", "\n", "\n", "# here we reset the correct state (but only if we reached the end of the group)", "\n", "tmp", "=", "1", "-", "tf", ".", "scatter_nd", "(", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "replicate_index", ",", "0", ")", ",", "0", ")", ",", "tf", ".", "constant", "(", "[", "1.0", "]", ")", ",", "\n", "tf", ".", "constant", "(", "[", "self", ".", "_num_replicates", "]", ")", ")", "\n", "reset_mask", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "tmp", ",", "0", ")", ",", "-", "1", ")", "\n", "\n", "reset_flag", "=", "tf", ".", "equal", "(", "state_index_in_group", "+", "1", ",", "self", ".", "_group_size", ")", "\n", "c_reset", "=", "tf", ".", "cond", "(", "reset_flag", ",", "lambda", ":", "c", "*", "reset_mask", ",", "lambda", ":", "c", ")", "\n", "h_reset", "=", "tf", ".", "cond", "(", "reset_flag", ",", "lambda", ":", "h", "*", "reset_mask", ",", "lambda", ":", "h", ")", "\n", "\n", "args", "=", "array_ops", ".", "concat", "(", "[", "inputs", ",", "h_reset", "]", ",", "-", "1", ")", "\n", "concat", "=", "self", ".", "_linear", "(", "args", ")", "\n", "dtype", "=", "args", ".", "dtype", "\n", "\n", "i", ",", "j", ",", "f", ",", "o", "=", "array_ops", ".", "split", "(", "value", "=", "concat", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "-", "1", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "i", "=", "self", ".", "_norm", "(", "i", ",", "\"input\"", ",", "dtype", "=", "dtype", ")", "\n", "j", "=", "self", ".", "_norm", "(", "j", ",", "\"transform\"", ",", "dtype", "=", "dtype", ")", "\n", "f", "=", "self", ".", "_norm", "(", "f", ",", "\"forget\"", ",", "dtype", "=", "dtype", ")", "\n", "o", "=", "self", ".", "_norm", "(", "o", ",", "\"output\"", ",", "dtype", "=", "dtype", ")", "\n", "\n", "", "g", "=", "self", ".", "_activation", "(", "j", ")", "\n", "if", "(", "not", "isinstance", "(", "self", ".", "_keep_prob", ",", "float", ")", ")", "or", "self", ".", "_keep_prob", "<", "1", ":", "\n", "\t\t\t", "g", "=", "nn_ops", ".", "dropout", "(", "g", ",", "self", ".", "_keep_prob", ",", "seed", "=", "self", ".", "_seed", ")", "\n", "# (i,g,f,o) = (tf.expand_dims(val, -1) for val in (i,g,f,o))", "\n", "\n", "", "new_c", "=", "(", "\n", "c_reset", "*", "math_ops", ".", "sigmoid", "(", "f", "+", "self", ".", "_forget_bias", ")", "+", "math_ops", ".", "sigmoid", "(", "i", ")", "*", "g", ")", "\n", "if", "self", ".", "_layer_norm", ":", "\n", "\t\t\t", "new_c", "=", "self", ".", "_norm", "(", "new_c", ",", "\"state\"", ",", "dtype", "=", "dtype", ")", "\n", "", "new_h", "=", "self", ".", "_activation", "(", "new_c", ")", "*", "math_ops", ".", "sigmoid", "(", "o", ")", "\n", "new_h_maxmem", "=", "tf", ".", "gather", "(", "new_h", ",", "next_replicate_index", ",", "axis", "=", "1", ")", "\n", "\n", "new_state", "=", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "return", "(", "new_h_maxmem", ",", "new_h", ")", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.NTMCell.__init__": [[1388, 1408], ["numpy.min", "ntm_ops.create_linear_initializer"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.ntm_ops.create_linear_initializer"], ["def", "__init__", "(", "\n", "self", ",", "input_size", ",", "memory_size", ",", "memory_vector_dim", ",", "read_head_num", ",", "write_head_num", ",", "addressing_mode", "=", "'content_and_location'", ",", "\n", "shift_win_size", "=", "3", ",", "clip_value", "=", "20", ",", "init_mode", "=", "'constant'", ",", "init_mode_other_params", "=", "'constant_other_params'", ",", "reuse", "=", "False", ")", ":", "\n", "\t\t", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "memory_size", "=", "memory_size", "\n", "self", ".", "memory_vector_dim", "=", "memory_vector_dim", "\n", "self", ".", "read_head_num", "=", "read_head_num", "\n", "self", ".", "write_head_num", "=", "write_head_num", "\n", "self", ".", "addressing_mode", "=", "addressing_mode", "\n", "self", ".", "reuse", "=", "reuse", "\n", "self", ".", "clip_value", "=", "clip_value", "\n", "\n", "self", ".", "init_mode", "=", "init_mode", "\n", "self", ".", "init_mode_other_params", "=", "init_mode_other_params", "\n", "\n", "self", ".", "output_dim", "=", "[", "read_head_num", ",", "memory_vector_dim", "]", "\n", "self", ".", "read_head_dim", "=", "[", "read_head_num", ",", "memory_size", "]", "\n", "self", ".", "shift_win_size", "=", "np", ".", "min", "(", "[", "shift_win_size", ",", "self", ".", "memory_size", "]", ")", "\n", "\n", "self", ".", "o2p_initializer", "=", "create_linear_initializer", "(", "self", ".", "input_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.NTMCell.__call__": [[1409, 1459], ["int", "tensorflow.concat", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.tanh", "tensorflow.nn.softplus", "tensorflow.sigmoid", "tensorflow.nn.softmax", "rnn_cell.NTMCell.addressing", "tensorflow.expand_dims", "tensorflow.reduce_sum", "tensorflow.expand_dims", "tensorflow.reduce_prod", "tensorflow.reduce_sum", "tensorflow.squeeze", "tensorflow.variable_scope", "tensorflow.contrib.layers.fully_connected", "tensorflow.clip_by_value", "tensorflow.nn.softplus", "tensorflow.matmul", "NTMControllerState", "inputs.get_shape", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.matmul", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.tanh", "tensorflow.sigmoid"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.NTMCell.addressing", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "prev_state", ")", ":", "\n", "\t\t", "batch_size", "=", "int", "(", "inputs", ".", "get_shape", "(", ")", "[", "0", "]", ")", "\n", "prev_read_vector", "=", "prev_state", ".", "read_vector", "\n", "\n", "combined_inputs", "=", "tf", ".", "concat", "(", "\n", "[", "inputs", ",", "tf", ".", "reshape", "(", "prev_read_vector", ",", "[", "batch_size", ",", "self", ".", "read_head_num", "*", "self", ".", "memory_vector_dim", "]", ")", "]", ",", "axis", "=", "1", ")", "\n", "\n", "num_parameters_per_head", "=", "self", ".", "memory_vector_dim", "+", "1", "+", "1", "+", "self", ".", "shift_win_size", "+", "1", "\n", "num_heads", "=", "self", ".", "read_head_num", "+", "self", ".", "write_head_num", "\n", "num_parameters_erase_per_write_head", "=", "self", ".", "memory_vector_dim", "\n", "total_parameter_num", "=", "num_parameters_per_head", "*", "num_heads", "+", "num_parameters_erase_per_write_head", "*", "2", "*", "self", ".", "write_head_num", "\n", "with", "tf", ".", "variable_scope", "(", "\"o2p\"", ",", "self", ".", "reuse", ")", ":", "\n", "\t\t\t", "parameters", "=", "tf", ".", "contrib", ".", "layers", ".", "fully_connected", "(", "\n", "combined_inputs", ",", "total_parameter_num", ",", "activation_fn", "=", "None", ",", "\n", "weights_initializer", "=", "self", ".", "o2p_initializer", ")", "\n", "parameters", "=", "tf", ".", "clip_by_value", "(", "parameters", ",", "-", "self", ".", "clip_value", ",", "self", ".", "clip_value", ")", "\n", "", "head_parameters", "=", "parameters", "[", ":", ",", ":", "num_parameters_per_head", "*", "num_heads", "]", "\n", "head_parameters", "=", "tf", ".", "reshape", "(", "head_parameters", ",", "[", "batch_size", ",", "num_heads", ",", "num_parameters_per_head", "]", ")", "\n", "erase_parameters", "=", "parameters", "[", ":", ",", "num_parameters_per_head", "*", "num_heads", ":", "\n", "num_parameters_per_head", "*", "num_heads", "+", "num_parameters_erase_per_write_head", "*", "self", ".", "write_head_num", "]", "\n", "erase_parameters", "=", "tf", ".", "reshape", "(", "erase_parameters", ",", "[", "batch_size", ",", "self", ".", "write_head_num", ",", "num_parameters_erase_per_write_head", "]", ")", "\n", "add_parameters", "=", "parameters", "[", ":", ",", "num_parameters_per_head", "*", "num_heads", "+", "num_parameters_erase_per_write_head", "*", "self", ".", "write_head_num", ":", "]", "\n", "add_parameters", "=", "tf", ".", "reshape", "(", "add_parameters", ",", "[", "batch_size", ",", "self", ".", "write_head_num", ",", "num_parameters_erase_per_write_head", "]", ")", "\n", "\n", "prev_w", "=", "prev_state", ".", "w", "\n", "prev_M", "=", "prev_state", ".", "M", "\n", "\n", "k", "=", "tf", ".", "tanh", "(", "head_parameters", "[", ":", ",", ":", ",", "0", ":", "self", ".", "memory_vector_dim", "]", ")", "\n", "beta", "=", "tf", ".", "nn", ".", "softplus", "(", "head_parameters", "[", ":", ",", ":", ",", "self", ".", "memory_vector_dim", "]", ")", "\n", "g", "=", "tf", ".", "sigmoid", "(", "head_parameters", "[", ":", ",", ":", ",", "self", ".", "memory_vector_dim", "+", "1", "]", ")", "\n", "s", "=", "tf", ".", "nn", ".", "softmax", "(", "\n", "head_parameters", "[", ":", ",", ":", ",", "self", ".", "memory_vector_dim", "+", "2", ":", "self", ".", "memory_vector_dim", "+", "2", "+", "self", ".", "shift_win_size", "]", ",", "-", "1", ")", "\n", "gamma", "=", "tf", ".", "nn", ".", "softplus", "(", "head_parameters", "[", ":", ",", ":", ",", "-", "1", "]", ")", "+", "1", "\n", "\n", "w", "=", "self", ".", "addressing", "(", "k", ",", "beta", ",", "g", ",", "s", ",", "gamma", ",", "prev_M", ",", "prev_w", ")", "\n", "\n", "read_w", "=", "tf", ".", "expand_dims", "(", "w", "[", ":", ",", ":", "self", ".", "read_head_num", "]", ",", "-", "1", ")", "\n", "read_vector", "=", "tf", ".", "reduce_sum", "(", "read_w", "*", "tf", ".", "expand_dims", "(", "prev_M", ",", "1", ")", ",", "axis", "=", "2", ")", "\n", "\n", "# Writing (Sec 3.2)", "\n", "\n", "M", "=", "prev_M", "\n", "write_w", "=", "tf", ".", "expand_dims", "(", "w", "[", ":", ",", "self", ".", "read_head_num", ":", "]", ",", "-", "1", ")", "\n", "forget_vectors", "=", "tf", ".", "reduce_prod", "(", "1", "-", "tf", ".", "matmul", "(", "write_w", ",", "tf", ".", "expand_dims", "(", "tf", ".", "sigmoid", "(", "erase_parameters", ")", ",", "2", ")", ")", ",", "1", ")", "\n", "add_vectors", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "matmul", "(", "write_w", ",", "tf", ".", "expand_dims", "(", "tf", ".", "tanh", "(", "add_parameters", ")", ",", "2", ")", ")", ",", "1", ")", "\n", "M", "=", "M", "*", "forget_vectors", "+", "add_vectors", "\n", "\n", "read_w", "=", "tf", ".", "squeeze", "(", "read_w", ",", "-", "1", ")", "\n", "\n", "return", "(", "read_vector", ",", "read_w", ")", ",", "NTMControllerState", "(", "read_vector", "=", "read_vector", ",", "w", "=", "w", ",", "M", "=", "M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.NTMCell.addressing": [[1460, 1509], ["tensorflow.expand_dims", "tensorflow.norm", "tensorflow.tile", "tensorflow.norm", "tensorflow.squeeze", "tensorflow.exp", "tensorflow.nn.softmax", "tensorflow.expand_dims", "tensorflow.concat", "tensorflow.concat", "tensorflow.stack", "tensorflow.reduce_sum", "tensorflow.pow", "prev_w.get_shape", "tensorflow.expand_dims", "tensorflow.matmul", "tensorflow.expand_dims", "tensorflow.reduce_sum", "tensorflow.expand_dims", "tensorflow.zeros", "tensorflow.reverse", "tensorflow.reverse", "tensorflow.expand_dims", "[].concatenate", "range", "tensorflow.TensorShape", "tensorflow.concat.get_shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax"], ["", "def", "addressing", "(", "self", ",", "k", ",", "beta", ",", "g", ",", "s", ",", "gamma", ",", "prev_M", ",", "prev_w", ")", ":", "\n", "\t\t", "num_head", "=", "prev_w", ".", "get_shape", "(", ")", "[", "1", "]", "\n", "# Sec 3.3.1 Focusing by Content", "\n", "\n", "# Cosine Similarity", "\n", "\n", "k", "=", "tf", ".", "expand_dims", "(", "k", ",", "axis", "=", "-", "1", ")", "\n", "k_norm", "=", "tf", ".", "norm", "(", "k", ",", "axis", "=", "2", ",", "keepdims", "=", "True", ")", "\n", "k_normalized", "=", "k", "/", "(", "k_norm", "+", "1e-12", ")", "\n", "prev_M", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "prev_M", ",", "1", ")", ",", "[", "1", ",", "num_head", ",", "1", ",", "1", "]", ")", "\n", "prev_M_norm", "=", "tf", ".", "norm", "(", "prev_M", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "prev_M_normalized", "=", "prev_M", "/", "(", "prev_M_norm", "+", "1e-12", ")", "\n", "\n", "K", "=", "tf", ".", "squeeze", "(", "tf", ".", "matmul", "(", "prev_M_normalized", ",", "k_normalized", ")", ",", "-", "1", ")", "# eq (6)", "\n", "\n", "# Calculating w^c", "\n", "\n", "K_amplified", "=", "tf", ".", "exp", "(", "tf", ".", "expand_dims", "(", "beta", ",", "axis", "=", "2", ")", "*", "K", ")", "\n", "w_c", "=", "tf", ".", "nn", ".", "softmax", "(", "K_amplified", ",", "axis", "=", "2", ")", "# eq (5)", "\n", "\n", "if", "self", ".", "addressing_mode", "==", "'content'", ":", "# Only focus on content", "\n", "\t\t\t", "return", "w_c", "\n", "\n", "# Sec 3.3.2 Focusing by Location", "\n", "\n", "", "g", "=", "tf", ".", "expand_dims", "(", "g", ",", "axis", "=", "2", ")", "\n", "w_g", "=", "g", "*", "w_c", "+", "(", "1", "-", "g", ")", "*", "prev_w", "# eq (7)", "\n", "\n", "if", "self", ".", "addressing_mode", "==", "'content_gated'", ":", "# Only focus on content and gated with previous", "\n", "\t\t\t", "return", "w_g", "\n", "\n", "# s shift coefficients for (i-j; eq.8) are in the order 0,-1,...,-shift_range,+shift_range,...,+1", "\n", "", "shift_range", "=", "self", ".", "shift_win_size", "/", "2", "# round down for odd size", "\n", "s", "=", "tf", ".", "concat", "(", "\n", "[", "\n", "s", "[", ":", ",", ":", ",", ":", "shift_range", "+", "1", "]", ",", "\n", "tf", ".", "zeros", "(", "s", ".", "get_shape", "(", ")", "[", "0", ":", "2", "]", ".", "concatenate", "(", "tf", ".", "TensorShape", "(", "[", "self", ".", "memory_size", "-", "self", ".", "shift_win_size", "]", ")", ")", ")", ",", "\n", "s", "[", ":", ",", ":", ",", "shift_range", "+", "1", ":", "]", "]", ",", "\n", "axis", "=", "-", "1", ")", "\n", "t", "=", "tf", ".", "concat", "(", "[", "tf", ".", "reverse", "(", "s", ",", "axis", "=", "[", "-", "1", "]", ")", ",", "tf", ".", "reverse", "(", "s", ",", "axis", "=", "[", "-", "1", "]", ")", "]", ",", "axis", "=", "-", "1", ")", "\n", "s_matrix", "=", "tf", ".", "stack", "(", "\n", "[", "t", "[", ":", ",", ":", ",", "self", ".", "memory_size", "-", "i", "-", "1", ":", "self", ".", "memory_size", "*", "2", "-", "i", "-", "1", "]", "for", "i", "in", "range", "(", "self", ".", "memory_size", ")", "]", ",", "\n", "axis", "=", "-", "1", "\n", ")", "\n", "w_", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "expand_dims", "(", "w_g", ",", "axis", "=", "2", ")", "*", "s_matrix", ",", "axis", "=", "-", "1", ")", "# eq (8)", "\n", "w_sharpen", "=", "tf", ".", "pow", "(", "w_", ",", "tf", ".", "expand_dims", "(", "gamma", ",", "axis", "=", "-", "1", ")", ")", "\n", "w", "=", "w_sharpen", "/", "tf", ".", "reduce_sum", "(", "w_sharpen", ",", "axis", "=", "-", "1", ",", "keep_dims", "=", "True", ")", "# eq (9)", "\n", "\n", "return", "w", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.NTMCell.zero_state": [[1510, 1546], ["tensorflow.variable_scope", "tensorflow.tanh", "tensorflow.tile", "tensorflow.nn.softmax", "tensorflow.tile", "tensorflow.tile", "NTMControllerState", "tensorflow.get_variable", "tensorflow.expand_dims", "tensorflow.get_variable", "tensorflow.expand_dims", "tensorflow.tanh", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.get_variable", "tensorflow.random_normal", "ntm_ops.create_linear_initializer", "ntm_ops.create_linear_initializer", "tensorflow.get_variable", "Exception", "ntm_ops.create_linear_initializer", "tensorflow.constant_initializer"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.ntm_ops.create_linear_initializer", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.ntm_ops.create_linear_initializer", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.ntm_ops.create_linear_initializer"], ["", "def", "zero_state", "(", "self", ",", "batch_size", ",", "dtype", ")", ":", "\n", "\t\t", "with", "tf", ".", "variable_scope", "(", "'init'", ",", "reuse", "=", "self", ".", "reuse", ")", ":", "\n", "\t\t\t", "read_vector_init", "=", "tf", ".", "tanh", "(", "\n", "tf", ".", "get_variable", "(", "\n", "name", "=", "'init_read_vector'", ",", "shape", "=", "self", ".", "memory_vector_dim", ",", "\n", "initializer", "=", "create_linear_initializer", "(", "self", ".", "memory_vector_dim", ")", ",", "\n", "trainable", "=", "self", ".", "init_mode_other_params", "==", "'learned'", ")", "\n", ")", "\n", "read_vector_init", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "read_vector_init", ",", "0", ")", ",", "0", ")", ",", "[", "batch_size", ",", "self", ".", "read_head_num", ",", "1", "]", ")", "\n", "\n", "w_init", "=", "tf", ".", "nn", ".", "softmax", "(", "\n", "tf", ".", "get_variable", "(", "\n", "name", "=", "'init_w'", ",", "shape", "=", "[", "self", ".", "read_head_num", "+", "self", ".", "write_head_num", ",", "self", ".", "memory_size", "]", ",", "\n", "initializer", "=", "create_linear_initializer", "(", "self", ".", "memory_size", ")", ",", "\n", "trainable", "=", "self", ".", "init_mode_other_params", "==", "'learned'", ")", ",", "\n", "-", "1", ")", "\n", "w_init", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "w_init", ",", "0", ")", ",", "[", "batch_size", ",", "1", ",", "1", "]", ")", "\n", "\n", "if", "self", ".", "init_mode", "==", "'learned'", ":", "\n", "\t\t\t\t", "M", "=", "tf", ".", "tanh", "(", "tf", ".", "get_variable", "(", "\n", "name", "=", "'init_M'", ",", "shape", "=", "[", "self", ".", "memory_size", ",", "self", ".", "memory_vector_dim", "]", ",", "\n", "initializer", "=", "create_linear_initializer", "(", "self", ".", "memory_vector_dim", ")", ")", ")", "\n", "", "elif", "self", ".", "init_mode", "==", "'random'", ":", "\n", "\t\t\t\t", "M", "=", "tf", ".", "random_normal", "(", "shape", "=", "[", "self", ".", "memory_size", ",", "self", ".", "memory_vector_dim", "]", ",", "mean", "=", "0.0", ",", "stddev", "=", "0.5", ",", "name", "=", "'init_M'", ")", "\n", "", "elif", "self", ".", "init_mode", "==", "'constant'", ":", "\n", "\t\t\t\t", "M", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'init_M'", ",", "shape", "=", "[", "self", ".", "memory_size", ",", "self", ".", "memory_vector_dim", "]", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1e-6", ")", ",", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Unknown initialization method'", ")", "\n", "", "M", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "M", ",", "0", ")", ",", "[", "batch_size", ",", "1", ",", "1", "]", ")", "\n", "\n", "return", "NTMControllerState", "(", "\n", "read_vector", "=", "read_vector_init", ",", "\n", "w", "=", "w_init", ",", "\n", "M", "=", "M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.NTMCell.state_size": [[1547, 1553], ["NTMControllerState", "tensorflow.TensorShape"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "return", "NTMControllerState", "(", "\n", "read_vector", "=", "[", "self", ".", "read_head_num", ",", "self", ".", "memory_vector_dim", "]", ",", "\n", "w", "=", "[", "self", ".", "read_head_num", "+", "self", ".", "write_head_num", ",", "self", ".", "memory_size", "]", ",", "\n", "M", "=", "tf", ".", "TensorShape", "(", "[", "self", ".", "memory_size", "*", "self", ".", "memory_vector_dim", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.NTMCell.output_size": [[1554, 1557], ["tensorflow.TensorShape", "tensorflow.TensorShape"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "return", "tf", ".", "TensorShape", "(", "self", ".", "output_dim", ")", ",", "tf", ".", "TensorShape", "(", "self", ".", "read_head_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.ScopeRNNCellWrapper.__init__": [[1562, 1567], ["tensorflow.VariableScope"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "cell", ",", "name", ")", ":", "\n", "\t\t", "\"\"\"ScopeRNNCellWrapper constructor\"\"\"", "\n", "\n", "self", ".", "_cell", "=", "cell", "\n", "self", ".", "scope", "=", "tf", ".", "VariableScope", "(", "None", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.ScopeRNNCellWrapper.output_size": [[1568, 1573], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"return cell output size\"\"\"", "\n", "\n", "return", "self", ".", "_cell", ".", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.ScopeRNNCellWrapper.state_size": [[1574, 1579], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"return cell state size\"\"\"", "\n", "\n", "return", "self", ".", "_cell", ".", "state_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.ScopeRNNCellWrapper.zero_state": [[1580, 1584], ["rnn_cell.ScopeRNNCellWrapper._cell.zero_state"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.zero_state"], ["", "def", "zero_state", "(", "self", ",", "batch_size", ",", "dtype", ")", ":", "\n", "\t\t", "\"\"\"the cell zero state\"\"\"", "\n", "\n", "return", "self", ".", "_cell", ".", "zero_state", "(", "batch_size", ",", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.ScopeRNNCellWrapper.__call__": [[1585, 1592], ["tensorflow.variable_scope", "rnn_cell.ScopeRNNCellWrapper._cell"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "state", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"call wrapped cell with constant scope\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "output", ",", "new_state", "=", "self", ".", "_cell", "(", "inputs", ",", "state", ",", "scope", ")", "\n", "\n", "", "return", "output", ",", "new_state", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.StateOutputWrapper.__init__": [[1597, 1601], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "cell", ")", ":", "\n", "\t\t", "\"\"\"StateOutputWrapper constructor\"\"\"", "\n", "\n", "self", ".", "_cell", "=", "cell", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.StateOutputWrapper.output_size": [[1602, 1607], ["sum", "int", "tensorflow.python.util.nest.flatten"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"return cell output size\"\"\"", "\n", "\n", "return", "sum", "(", "[", "int", "(", "x", ")", "for", "x", "in", "nest", ".", "flatten", "(", "self", ".", "_cell", ".", "state_size", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.StateOutputWrapper.state_size": [[1608, 1613], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_size", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"return cell state size\"\"\"", "\n", "\n", "return", "self", ".", "_cell", ".", "state_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.StateOutputWrapper.zero_state": [[1614, 1618], ["rnn_cell.StateOutputWrapper._cell.zero_state"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.zero_state"], ["", "def", "zero_state", "(", "self", ",", "batch_size", ",", "dtype", ")", ":", "\n", "\t\t", "\"\"\"the cell zero state\"\"\"", "\n", "\n", "return", "self", ".", "_cell", ".", "zero_state", "(", "batch_size", ",", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn_cell.StateOutputWrapper.__call__": [[1619, 1626], ["rnn_cell.StateOutputWrapper._cell", "tensorflow.concat", "tensorflow.python.util.nest.flatten"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "state", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"call wrapped cell with constant scope\"\"\"", "\n", "\n", "_", ",", "new_state", "=", "self", ".", "_cell", "(", "inputs", ",", "state", ",", "scope", ")", "\n", "output", "=", "tf", ".", "concat", "(", "nest", ".", "flatten", "(", "new_state", ")", ",", "axis", "=", "1", ")", "\n", "\n", "return", "output", ",", "new_state", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.__init__": [[19, 61], ["super().__init__", "nabu.neuralnetworks.components.ops.capsule_initializer", "tensorflow.zeros_initializer"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "\n", "self", ",", "num_capsules", ",", "capsule_dim", ",", "\n", "kernel_initializer", "=", "None", ",", "\n", "logits_initializer", "=", "None", ",", "\n", "logits_prior", "=", "False", ",", "\n", "routing_iters", "=", "3", ",", "\n", "activation_fn", "=", "None", ",", "\n", "probability_fn", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "\t\t", "\"\"\"Capsule layer constructor\n\t\targs:\n\t\t\tnum_capsules: number of output capsules\n\t\t\tcapsule_dim: output capsule dimsension\n\t\t\tkernel_initializer: an initializer for the prediction kernel\n\t\t\tlogits_initializer: the initializer for the initial logits\n\t\t\trouting_iters: the number of routing iterations (default: 5)\n\t\t\tactivation_fn: a callable activation function (default: squash)\n\t\t\tprobability_fn: a callable that takes in logits and returns weights\n\t\t\t\t(default: tf.nn.softmax)\n\t\t\tactivity_regularizer: Regularizer instance for the output (callable)\n\t\t\ttrainable: wether layer is trainable\n\t\t\tname: the name of the layer\n\t\t\"\"\"", "\n", "\n", "super", "(", "Capsule", ",", "self", ")", ".", "__init__", "(", "\n", "trainable", "=", "trainable", ",", "\n", "name", "=", "name", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "**", "kwargs", ")", "\n", "\n", "self", ".", "num_capsules", "=", "num_capsules", "\n", "self", ".", "capsule_dim", "=", "capsule_dim", "\n", "self", ".", "kernel_initializer", "=", "kernel_initializer", "or", "capsule_initializer", "(", ")", "\n", "self", ".", "logits_initializer", "=", "logits_initializer", "or", "tf", ".", "zeros_initializer", "(", ")", "\n", "self", ".", "logits_prior", "=", "logits_prior", "\n", "self", ".", "routing_iters", "=", "routing_iters", "\n", "self", ".", "activation_fn", "=", "activation_fn", "or", "ops", ".", "squash", "\n", "self", ".", "probability_fn", "=", "probability_fn", "or", "tf", ".", "nn", ".", "softmax", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.build": [[62, 94], ["layer.Capsule.add_variable", "layer.Capsule.add_variable", "super().build", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "\t\t", "\"\"\"creates the variables of this layer\n\t\targs:\n\t\t\tinput_shape: the shape of the input\n\t\t\"\"\"", "\n", "\n", "# pylint: disable=W0201", "\n", "\n", "# input dimensions", "\n", "num_capsules_in", "=", "input_shape", "[", "-", "2", "]", ".", "value", "\n", "capsule_dim_in", "=", "input_shape", "[", "-", "1", "]", ".", "value", "\n", "\n", "if", "num_capsules_in", "is", "None", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'number of input capsules must be defined'", ")", "\n", "", "if", "capsule_dim_in", "is", "None", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'input capsules dimension must be defined'", ")", "\n", "\n", "", "self", ".", "kernel", "=", "self", ".", "add_variable", "(", "\n", "name", "=", "'kernel'", ",", "\n", "dtype", "=", "self", ".", "dtype", ",", "\n", "shape", "=", "[", "num_capsules_in", ",", "capsule_dim_in", ",", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ")", "\n", "\n", "self", ".", "logits", "=", "self", ".", "add_variable", "(", "\n", "name", "=", "'init_logits'", ",", "\n", "dtype", "=", "self", ".", "dtype", ",", "\n", "shape", "=", "[", "num_capsules_in", ",", "self", ".", "num_capsules", "]", ",", "\n", "initializer", "=", "self", ".", "logits_initializer", ",", "\n", "trainable", "=", "self", ".", "logits_prior", "\n", ")", "\n", "\n", "super", "(", "Capsule", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.call": [[96, 113], ["layer.Capsule.predict", "layer.Capsule.cluster"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.predict", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.cluster"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tapply the layer\n\t\targs:\n\t\t\tinputs: the inputs to the layer. the final two dimensions are\n\t\t\t\tnum_capsules_in and capsule_dim_in\n\t\treturns the output capsules with the last two dimensions\n\t\t\tnum_capsules and capsule_dim\n\t\t\"\"\"", "\n", "\n", "# compute the predictions", "\n", "predictions", ",", "logits", "=", "self", ".", "predict", "(", "inputs", ")", "\n", "\n", "# cluster the predictions", "\n", "outputs", "=", "self", ".", "cluster", "(", "predictions", ",", "logits", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.predict": [[114, 153], ["tensorflow.name_scope", "len", "tensorflow.transpose", "tensorflow.map_fn", "tensorflow.transpose", "range", "tensorflow.tile", "tensorflow.expand_dims", "range", "tensorflow.tensordot", "range", "tensorflow.shape", "len"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "inputs", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tcompute the predictions for the output capsules and initialize the\n\t\trouting logits\n\t\targs:\n\t\t\tinputs: the inputs to the layer. the final two dimensions are\n\t\t\t\tnum_capsules_in and capsule_dim_in\n\t\treturns: the output capsule predictions\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'predict'", ")", ":", "\n", "\n", "# number of shared dimensions", "\n", "\t\t\t", "rank", "=", "len", "(", "inputs", ".", "shape", ")", "\n", "shared", "=", "rank", "-", "2", "\n", "\n", "# put the input capsules as the first dimension", "\n", "inputs", "=", "tf", ".", "transpose", "(", "inputs", ",", "[", "shared", "]", "+", "range", "(", "shared", ")", "+", "[", "rank", "-", "1", "]", ")", "\n", "\n", "# compute the predictins", "\n", "predictions", "=", "tf", ".", "map_fn", "(", "\n", "fn", "=", "lambda", "x", ":", "tf", ".", "tensordot", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ",", "[", "[", "shared", "]", ",", "[", "0", "]", "]", ")", ",", "\n", "elems", "=", "(", "inputs", ",", "self", ".", "kernel", ")", ",", "\n", "dtype", "=", "self", ".", "dtype", "or", "tf", ".", "float32", ")", "\n", "\n", "# transpose back", "\n", "predictions", "=", "tf", ".", "transpose", "(", "\n", "predictions", ",", "range", "(", "1", ",", "shared", "+", "1", ")", "+", "[", "0", "]", "+", "[", "rank", "-", "1", ",", "rank", "]", ")", "\n", "\n", "logits", "=", "self", ".", "logits", "\n", "for", "i", "in", "range", "(", "shared", ")", ":", "\n", "\t\t\t\t", "if", "predictions", ".", "shape", "[", "shared", "-", "i", "-", "1", "]", ".", "value", "is", "None", ":", "\n", "\t\t\t\t\t", "shape", "=", "tf", ".", "shape", "(", "predictions", ")", "[", "shared", "-", "i", "-", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "shape", "=", "predictions", ".", "shape", "[", "shared", "-", "i", "-", "1", "]", ".", "value", "\n", "", "tile", "=", "[", "shape", "]", "+", "[", "1", "]", "*", "len", "(", "logits", ".", "shape", ")", "\n", "logits", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "logits", ",", "0", ")", ",", "tile", ")", "\n", "\n", "", "", "return", "predictions", ",", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.predict_slow": [[154, 192], ["tensorflow.name_scope", "len", "tensorflow.einsum", "range", "ValueError", "tensorflow.tile", "tensorflow.expand_dims", "tensorflow.shape", "len"], "methods", ["None"], ["", "def", "predict_slow", "(", "self", ",", "inputs", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tcompute the predictions for the output capsules and initialize the\n\t\trouting logits\n\t\targs:\n\t\t\tinputs: the inputs to the layer. the final two dimensions are\n\t\t\t\tnum_capsules_in and capsule_dim_in\n\t\treturns: the output capsule predictions\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'predict'", ")", ":", "\n", "\n", "# number of shared dimensions", "\n", "\t\t\t", "rank", "=", "len", "(", "inputs", ".", "shape", ")", "\n", "shared", "=", "rank", "-", "2", "\n", "\n", "if", "shared", ">", "26", "-", "4", ":", "\n", "\t\t\t\t", "raise", "ValueError", "(", "'Not enough letters in the alphabet to use Einstein notation'", ")", "\n", "# input_shape = [shared (typicaly batch_size,time),Nin,Din], kernel_shape = [Nin, Din, Nout, Dout],", "\n", "# predictions_shape = [shared,Nin,Nout,Dout]", "\n", "", "shared_shape_str", "=", "_alphabet_str", "[", "0", ":", "shared", "]", "\n", "input_shape_str", "=", "shared_shape_str", "+", "'wx'", "\n", "kernel_shape_str", "=", "'wxyz'", "\n", "output_shape_str", "=", "shared_shape_str", "+", "'wyz'", "\n", "ein_not", "=", "'%s,%s->%s'", "%", "(", "input_shape_str", ",", "kernel_shape_str", ",", "output_shape_str", ")", "\n", "\n", "predictions", "=", "tf", ".", "einsum", "(", "ein_not", ",", "inputs", ",", "self", ".", "kernel", ")", "\n", "\n", "logits", "=", "self", ".", "logits", "\n", "for", "i", "in", "range", "(", "shared", ")", ":", "\n", "\t\t\t\t", "if", "predictions", ".", "shape", "[", "shared", "-", "i", "-", "1", "]", ".", "value", "is", "None", ":", "\n", "\t\t\t\t\t", "shape", "=", "tf", ".", "shape", "(", "predictions", ")", "[", "shared", "-", "i", "-", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "shape", "=", "predictions", ".", "shape", "[", "shared", "-", "i", "-", "1", "]", ".", "value", "\n", "", "tile", "=", "[", "shape", "]", "+", "[", "1", "]", "*", "len", "(", "logits", ".", "shape", ")", "\n", "logits", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "logits", ",", "0", ")", ",", "tile", ")", "\n", "\n", "", "", "return", "predictions", ",", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.cluster": [[193, 239], ["tensorflow.name_scope", "tensorflow.while_loop", "layer.Capsule.cluster.m_step"], "methods", ["None"], ["", "def", "cluster", "(", "self", ",", "predictions", ",", "logits", ")", ":", "\n", "\t\t", "\"\"\"cluster the predictions into output capsules\n\t\targs:\n\t\t\tpredictions: the predicted output capsules\n\t\t\tlogits: the initial routing logits\n\t\treturns:\n\t\t\tthe output capsules\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'cluster'", ")", ":", "\n", "\n", "# define m-step", "\n", "\t\t\t", "def", "m_step", "(", "l", ")", ":", "\n", "\t\t\t\t", "\"\"\"m step\"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "'m_step'", ")", ":", "\n", "# compute the capsule contents", "\n", "\t\t\t\t\t", "w", "=", "self", ".", "probability_fn", "(", "l", ")", "\n", "caps", "=", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "expand_dims", "(", "w", ",", "-", "1", ")", "*", "predictions", ",", "-", "3", ")", "\n", "\n", "", "return", "caps", ",", "w", "\n", "\n", "# define body of the while loop", "\n", "", "def", "body", "(", "l", ")", ":", "\n", "\t\t\t\t", "\"\"\"body\"\"\"", "\n", "\n", "caps", ",", "_", "=", "m_step", "(", "l", ")", "\n", "caps", "=", "self", ".", "activation_fn", "(", "caps", ")", "\n", "\n", "# compare the capsule contents with the predictions", "\n", "similarity", "=", "tf", ".", "reduce_sum", "(", "\n", "predictions", "*", "tf", ".", "expand_dims", "(", "caps", ",", "-", "3", ")", ",", "-", "1", ")", "\n", "\n", "return", "l", "+", "similarity", "\n", "\n", "# get the final logits with the while loop", "\n", "", "lo", "=", "tf", ".", "while_loop", "(", "\n", "lambda", "l", ":", "True", ",", "\n", "body", ",", "[", "logits", "]", ",", "\n", "maximum_iterations", "=", "self", ".", "routing_iters", ")", "\n", "\n", "# get the final output capsules", "\n", "capsules", ",", "_", "=", "m_step", "(", "lo", ")", "\n", "capsules", "=", "self", ".", "activation_fn", "(", "capsules", ")", "\n", "\n", "", "return", "capsules", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Capsule.compute_output_shape": [[240, 254], ["input_shape[].concatenate", "ValueError", "ValueError"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "\t\t", "\"\"\"compute the output shape\"\"\"", "\n", "\n", "if", "input_shape", "[", "-", "2", "]", ".", "value", "is", "None", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\n", "'The number of capsules must be defined, but saw: %s'", "\n", "%", "input_shape", ")", "\n", "", "if", "input_shape", "[", "-", "1", "]", ".", "value", "is", "None", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\n", "'The capsule dimension must be defined, but saw: %s'", "\n", "%", "input_shape", ")", "\n", "\n", "", "return", "input_shape", "[", ":", "-", "2", "]", ".", "concatenate", "(", "\n", "[", "self", ".", "num_capsules", ",", "self", ".", "capsule_dim", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BRCapsuleLayer.__init__": [[259, 280], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "num_capsules", ",", "capsule_dim", ",", "routing_iters", "=", "3", ",", "activation", "=", "None", ",", "input_probability_fn", "=", "None", ",", "\n", "recurrent_probability_fn", "=", "None", ",", "rec_only_vote", "=", "False", ",", "logits_prior", "=", "False", ",", "accumulate_input_logits", "=", "True", ",", "\n", "accumulate_state_logits", "=", "True", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBRCapsuleLayer constructor\n\n\t\tArgs:\n\t\t\tTODO\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_capsules", "=", "num_capsules", "\n", "self", ".", "capsule_dim", "=", "capsule_dim", "\n", "self", ".", "routing_iters", "=", "routing_iters", "\n", "self", ".", "_activation", "=", "activation", "\n", "self", ".", "input_probability_fn", "=", "input_probability_fn", "\n", "self", ".", "recurrent_probability_fn", "=", "recurrent_probability_fn", "\n", "self", ".", "rec_only_vote", "=", "rec_only_vote", "\n", "self", ".", "logits_prior", "=", "logits_prior", "\n", "self", ".", "accumulate_input_logits", "=", "accumulate_input_logits", "\n", "self", ".", "accumulate_state_logits", "=", "accumulate_state_logits", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BRCapsuleLayer.__call__": [[281, 355], ["tensorflow.variable_scope", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "nabu.neuralnetworks.components.rnn_cell.RecCapsuleCellRecOnlyVote", "nabu.neuralnetworks.components.rnn_cell.RecCapsuleCellRecOnlyVote", "nabu.neuralnetworks.components.rnn_cell.RecCapsuleCell", "nabu.neuralnetworks.components.rnn_cell.RecCapsuleCell", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the rnn cell that will be used for the forward and backward", "\n", "# pass", "\n", "\n", "\t\t\t", "if", "self", ".", "rec_only_vote", ":", "\n", "\t\t\t\t", "rnn_cell_fw", "=", "rnn_cell", ".", "RecCapsuleCellRecOnlyVote", "(", "\n", "num_capsules", "=", "self", ".", "num_capsules", ",", "\n", "capsule_dim", "=", "self", ".", "capsule_dim", ",", "\n", "routing_iters", "=", "self", ".", "routing_iters", ",", "\n", "activation", "=", "self", ".", "_activation", ",", "\n", "input_probability_fn", "=", "self", ".", "input_probability_fn", ",", "\n", "recurrent_probability_fn", "=", "self", ".", "recurrent_probability_fn", ",", "\n", "logits_prior", "=", "self", ".", "logits_prior", ",", "\n", "accumulate_input_logits", "=", "self", ".", "accumulate_input_logits", ",", "\n", "accumulate_state_logits", "=", "self", ".", "accumulate_state_logits", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "rnn_cell_bw", "=", "rnn_cell", ".", "RecCapsuleCellRecOnlyVote", "(", "\n", "num_capsules", "=", "self", ".", "num_capsules", ",", "\n", "capsule_dim", "=", "self", ".", "capsule_dim", ",", "\n", "routing_iters", "=", "self", ".", "routing_iters", ",", "\n", "activation", "=", "self", ".", "_activation", ",", "\n", "input_probability_fn", "=", "self", ".", "input_probability_fn", ",", "\n", "recurrent_probability_fn", "=", "self", ".", "recurrent_probability_fn", ",", "\n", "logits_prior", "=", "self", ".", "logits_prior", ",", "\n", "accumulate_input_logits", "=", "self", ".", "accumulate_input_logits", ",", "\n", "accumulate_state_logits", "=", "self", ".", "accumulate_state_logits", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "rnn_cell_fw", "=", "rnn_cell", ".", "RecCapsuleCell", "(", "\n", "num_capsules", "=", "self", ".", "num_capsules", ",", "\n", "capsule_dim", "=", "self", ".", "capsule_dim", ",", "\n", "routing_iters", "=", "self", ".", "routing_iters", ",", "\n", "activation", "=", "self", ".", "_activation", ",", "\n", "input_probability_fn", "=", "self", ".", "input_probability_fn", ",", "\n", "recurrent_probability_fn", "=", "self", ".", "recurrent_probability_fn", ",", "\n", "logits_prior", "=", "self", ".", "logits_prior", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "rnn_cell_bw", "=", "rnn_cell", ".", "RecCapsuleCell", "(", "\n", "num_capsules", "=", "self", ".", "num_capsules", ",", "\n", "capsule_dim", "=", "self", ".", "capsule_dim", ",", "\n", "routing_iters", "=", "self", ".", "routing_iters", ",", "\n", "activation", "=", "self", ".", "_activation", ",", "\n", "input_probability_fn", "=", "self", ".", "input_probability_fn", ",", "\n", "recurrent_probability_fn", "=", "self", ".", "recurrent_probability_fn", ",", "\n", "logits_prior", "=", "self", ".", "logits_prior", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "rnn_cell_fw", ",", "rnn_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BLSTMCapsuleLayer.__init__": [[360, 382], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "num_capsules", ",", "capsule_dim", ",", "routing_iters", "=", "3", ",", "activation", "=", "None", ",", "input_probability_fn", "=", "None", ",", "\n", "recurrent_probability_fn", "=", "None", ",", "logits_prior", "=", "False", ",", "accumulate_input_logits", "=", "True", ",", "\n", "accumulate_state_logits", "=", "True", ",", "gates_fc", "=", "False", ",", "use_output_matrix", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBRCapsuleLayer constructor\n\n\t\tArgs:\n\t\t\tTODO\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_capsules", "=", "num_capsules", "\n", "self", ".", "capsule_dim", "=", "capsule_dim", "\n", "self", ".", "routing_iters", "=", "routing_iters", "\n", "self", ".", "_activation", "=", "activation", "\n", "self", ".", "input_probability_fn", "=", "input_probability_fn", "\n", "self", ".", "recurrent_probability_fn", "=", "recurrent_probability_fn", "\n", "self", ".", "logits_prior", "=", "logits_prior", "\n", "self", ".", "accumulate_input_logits", "=", "accumulate_input_logits", "\n", "self", ".", "accumulate_state_logits", "=", "accumulate_state_logits", "\n", "self", ".", "gates_fc", "=", "gates_fc", "\n", "self", ".", "use_output_matrix", "=", "use_output_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BLSTMCapsuleLayer.__call__": [[383, 443], ["tensorflow.variable_scope", "lstm_cell_type", "lstm_cell_type", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the rnn cell that will be used for the forward and backward", "\n", "# pass", "\n", "\n", "\t\t\t", "if", "self", ".", "use_output_matrix", ":", "\n", "\t\t\t\t", "lstm_cell_type", "=", "rnn_cell", ".", "LSTMCapsuleCellRecOnlyVoteOutputMatrix", "\n", "", "else", ":", "\n", "\t\t\t\t", "lstm_cell_type", "=", "rnn_cell", ".", "LSTMCapsuleCellRecOnlyVote", "\n", "\n", "", "lstm_cell_fw", "=", "lstm_cell_type", "(", "\n", "num_capsules", "=", "self", ".", "num_capsules", ",", "\n", "capsule_dim", "=", "self", ".", "capsule_dim", ",", "\n", "routing_iters", "=", "self", ".", "routing_iters", ",", "\n", "activation", "=", "self", ".", "_activation", ",", "\n", "input_probability_fn", "=", "self", ".", "input_probability_fn", ",", "\n", "recurrent_probability_fn", "=", "self", ".", "recurrent_probability_fn", ",", "\n", "logits_prior", "=", "self", ".", "logits_prior", ",", "\n", "accumulate_input_logits", "=", "self", ".", "accumulate_input_logits", ",", "\n", "accumulate_state_logits", "=", "self", ".", "accumulate_state_logits", ",", "\n", "gates_fc", "=", "self", ".", "gates_fc", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "lstm_cell_bw", "=", "lstm_cell_type", "(", "\n", "num_capsules", "=", "self", ".", "num_capsules", ",", "\n", "capsule_dim", "=", "self", ".", "capsule_dim", ",", "\n", "routing_iters", "=", "self", ".", "routing_iters", ",", "\n", "activation", "=", "self", ".", "_activation", ",", "\n", "input_probability_fn", "=", "self", ".", "input_probability_fn", ",", "\n", "recurrent_probability_fn", "=", "self", ".", "recurrent_probability_fn", ",", "\n", "logits_prior", "=", "self", ".", "logits_prior", ",", "\n", "accumulate_input_logits", "=", "self", ".", "accumulate_input_logits", ",", "\n", "accumulate_state_logits", "=", "self", ".", "accumulate_state_logits", ",", "\n", "gates_fc", "=", "self", ".", "gates_fc", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "lstm_cell_fw", ",", "lstm_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BRNNLayer.__init__": [[448, 462], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", ",", "linear_out_flag", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBRNNLayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tactivation_fn: activation function\n\t\t\tlinear_out_flag: if set to True, activation function will only be applied\n\t\t\tto the recurrent output.\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "self", ".", "linear_out_flag", "=", "linear_out_flag", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BRNNLayer.__call__": [[463, 505], ["tensorflow.variable_scope", "rnn_cell_type", "rnn_cell_type", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the rnn cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "if", "self", ".", "linear_out_flag", ":", "\n", "\t\t\t\t", "rnn_cell_type", "=", "rnn_cell", ".", "RNNCellLinearOut", "\n", "", "else", ":", "\n", "\t\t\t\t", "rnn_cell_type", "=", "tf", ".", "contrib", ".", "rnn", ".", "BasicRNNCell", "\n", "\n", "", "rnn_cell_fw", "=", "rnn_cell_type", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "rnn_cell_bw", "=", "rnn_cell_type", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "rnn_cell_fw", ",", "rnn_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LSTMLayer.__init__": [[510, 525], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "layer_norm", "=", "False", ",", "recurrent_dropout", "=", "1.0", ",", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLSTMLayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\tactivation_fn: activation function\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LSTMLayer.__call__": [[526, 559], ["tensorflow.variable_scope", "tensorflow.contrib.rnn.LayerNormBasicLSTMCell", "tensorflow.python.ops.rnn.dynamic_rnn", "type", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the lstm cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "lstm_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "LayerNormBasicLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs", ",", "_", "=", "dynamic_rnn", "(", "\n", "lstm_cell", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BLSTMLayer.__init__": [[564, 586], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "num_units", ",", "layer_norm", "=", "False", ",", "recurrent_dropout", "=", "1.0", ",", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", ",", "\n", "separate_directions", "=", "False", ",", "linear_out_flag", "=", "False", ",", "fast_version", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBLSTMLayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\tseparate_directions: wether the forward and backward directions should\n\t\t\tbe separated for deep networks.\n\t\t\tfast_version: deprecated\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "self", ".", "separate_directions", "=", "separate_directions", "\n", "self", ".", "linear_out_flag", "=", "linear_out_flag", "\n", "self", ".", "fast_version", "=", "fast_version", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BLSTMLayer.__call__": [[587, 638], ["tensorflow.variable_scope", "lstm_cell_type", "lstm_cell_type", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "nabu.neuralnetworks.components.rnn.bidirectional_dynamic_rnn_2inputs", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn.bidirectional_dynamic_rnn_2inputs"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the lstm cell that will be used for the forward and backward", "\n", "# pass", "\n", "\n", "\t\t\t", "if", "self", ".", "linear_out_flag", ":", "\n", "\t\t\t\t", "lstm_cell_type", "=", "rnn_cell", ".", "LayerNormBasicLSTMCellLineairOut", "\n", "", "else", ":", "\n", "\t\t\t\t", "lstm_cell_type", "=", "tf", ".", "contrib", ".", "rnn", ".", "LayerNormBasicLSTMCell", "\n", "\n", "", "lstm_cell_fw", "=", "lstm_cell_type", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "lstm_cell_bw", "=", "lstm_cell_type", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "if", "not", "self", ".", "separate_directions", ":", "\n", "\t\t\t\t", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "lstm_cell_fw", ",", "lstm_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "outputs", ",", "_", "=", "rnn", ".", "bidirectional_dynamic_rnn_2inputs", "(", "\n", "lstm_cell_fw", ",", "lstm_cell_bw", ",", "inputs", "[", "0", "]", ",", "inputs", "[", "1", "]", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyLSTMLayer.__init__": [[643, 658], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "layer_norm", "=", "False", ",", "recurrent_dropout", "=", "1.0", ",", "leak_factor", "=", "1.0", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLeakyLSTMLayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\tleak_factor: the leak factor (if 1, there is no leakage)\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "leak_factor", "=", "leak_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyLSTMLayer.__call__": [[659, 692], ["tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn_cell.LayerNormBasicLeakLSTMCell", "tensorflow.python.ops.rnn.dynamic_rnn", "type", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the lstm cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "lstm_cell", "=", "rnn_cell", ".", "LayerNormBasicLeakLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs", ",", "_", "=", "dynamic_rnn", "(", "\n", "lstm_cell", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyBLSTMLayer.__init__": [[697, 712], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "layer_norm", "=", "False", ",", "recurrent_dropout", "=", "1.0", ",", "leak_factor", "=", "1.0", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLeakyBLSTMLayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\tleak_factor: the leak factor (if 1, there is no leakage)\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "leak_factor", "=", "leak_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyBLSTMLayer.__call__": [[713, 754], ["tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn_cell.LayerNormBasicLeakLSTMCell", "nabu.neuralnetworks.components.rnn_cell.LayerNormBasicLeakLSTMCell", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the lstm cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "lstm_cell_fw", "=", "rnn_cell", ".", "LayerNormBasicLeakLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "lstm_cell_bw", "=", "rnn_cell", ".", "LayerNormBasicLeakLSTMCell", "(", "\n", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "lstm_cell_fw", ",", "lstm_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyBLSTMIZNotRecLayer.__init__": [[759, 774], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "layer_norm", "=", "False", ",", "recurrent_dropout", "=", "1.0", ",", "leak_factor", "=", "1.0", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLeakyBLSTMIZNotRecLayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\tleak_factor: the leak factor (if 1, there is no leakage)\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "leak_factor", "=", "leak_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyBLSTMIZNotRecLayer.__call__": [[775, 816], ["tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell", "nabu.neuralnetworks.components.rnn_cell.LayerNormIZNotRecLeakLSTMCell", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the lstm cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "lstm_cell_fw", "=", "rnn_cell", ".", "LayerNormIZNotRecLeakLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "lstm_cell_bw", "=", "rnn_cell", ".", "LayerNormIZNotRecLeakLSTMCell", "(", "\n", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "lstm_cell_fw", ",", "lstm_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyBLSTMNotRecLayer.__init__": [[821, 836], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "layer_norm", "=", "False", ",", "recurrent_dropout", "=", "1.0", ",", "leak_factor", "=", "1.0", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLeakyBLSTMNotRecLayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one direction\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\tleak_factor: the leak factor (if 1, there is no leakage)\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "leak_factor", "=", "leak_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyBLSTMNotRecLayer.__call__": [[837, 878], ["tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn_cell.LayerNormNotRecLeakLSTMCell", "nabu.neuralnetworks.components.rnn_cell.LayerNormNotRecLeakLSTMCell", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the lstm cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "lstm_cell_fw", "=", "rnn_cell", ".", "LayerNormNotRecLeakLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "lstm_cell_bw", "=", "rnn_cell", ".", "LayerNormNotRecLeakLSTMCell", "(", "\n", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "lstm_cell_fw", ",", "lstm_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakychBLSTMLayer.__init__": [[883, 898], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "layer_norm", "=", "False", ",", "recurrent_dropout", "=", "1.0", ",", "leak_factor", "=", "1.0", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLeakyBLSTMLayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\tleak_factor: the leak factor (if 1, there is no leakage)\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "leak_factor", "=", "leak_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakychBLSTMLayer.__call__": [[899, 940], ["tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn_cell.LayerNormBasicLeakchLSTMCell", "nabu.neuralnetworks.components.rnn_cell.LayerNormBasicLeakchLSTMCell", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the lstm cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "lstm_cell_fw", "=", "rnn_cell", ".", "LayerNormBasicLeakchLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "lstm_cell_bw", "=", "rnn_cell", ".", "LayerNormBasicLeakchLSTMCell", "(", "\n", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "lstm_cell_fw", ",", "lstm_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.ResetLSTMLayer.__init__": [[945, 968], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "num_units", ",", "t_reset", "=", "1", ",", "next_t_reset", "=", "None", ",", "layer_norm", "=", "False", ",", "recurrent_dropout", "=", "1.0", ",", "\n", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tResetLSTM constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "t_reset", "=", "t_reset", "\n", "if", "next_t_reset", ":", "\n", "\t\t\t", "if", "next_t_reset", "<", "t_reset", ":", "\n", "\t\t\t\t", "raise", "ValueError", "(", "'T_reset in next layer must be equal to or bigger than T_reset in current layer'", ")", "\n", "", "self", ".", "next_t_reset", "=", "next_t_reset", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "next_t_reset", "=", "t_reset", "\n", "", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.ResetLSTMLayer.__call__": [[969, 1043], ["inputs.get_shape", "tensorflow.shape", "tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn_cell.LayerNormResetLSTMCell", "nabu.neuralnetworks.components.rnn.dynamic_rnn_time_input", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.mod", "tensorflow.mod", "tensorflow.tile", "tensorflow.where", "tensorflow.tile", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.mod", "tensorflow.expand_dims", "tensorflow.expand_dims", "range", "type", "tensorflow.get_variable_scope"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn.dynamic_rnn_time_input"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "batch_size", "=", "inputs", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "max_length", "=", "tf", ".", "shape", "(", "inputs", ")", "[", "1", "]", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the lstm cell that will be used for the forward", "\n", "\t\t\t", "lstm_cell", "=", "rnn_cell", ".", "LayerNormResetLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "rnn", ".", "dynamic_rnn_time_input", "(", "\n", "lstm_cell", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "if", "self", ".", "next_t_reset", "==", "self", ".", "t_reset", ":", "\n", "\t\t\t\t", "return", "outputs_tupple", "\n", "\n", "", "actual_outputs", "=", "outputs_tupple", "[", "0", "]", "\n", "replicas", "=", "outputs_tupple", "[", "1", "]", "\n", "\n", "# the output replicas need to be permuted correctly such that the next layer receives", "\n", "# the replicas in the correct order", "\n", "\n", "# numbers_to_maxT: [1, Tmax,1]", "\n", "numbers_to_maxT", "=", "tf", ".", "range", "(", "0", ",", "max_length", ")", "\n", "numbers_to_maxT", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "numbers_to_maxT", ",", "-", "1", ")", ",", "0", ")", "\n", "\n", "# numbers_to_k: [1, 1,k]", "\n", "numbers_to_k", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "range", "(", "0", ",", "self", ".", "next_t_reset", ")", ",", "0", ")", ",", "0", ")", "\n", "\n", "mod1", "=", "tf", ".", "mod", "(", "numbers_to_maxT", "-", "1", "-", "numbers_to_k", ",", "self", ".", "next_t_reset", ")", "\n", "mod2", "=", "tf", ".", "mod", "(", "numbers_to_maxT", "-", "mod1", "-", "1", ",", "self", ".", "t_reset", ")", "\n", "mod3", "=", "tf", ".", "tile", "(", "tf", ".", "mod", "(", "numbers_to_maxT", ",", "self", ".", "t_reset", ")", ",", "[", "1", ",", "1", ",", "self", ".", "next_t_reset", "]", ")", "\n", "\n", "indices_for_next_layer", "=", "tf", ".", "where", "(", "\n", "mod1", "<", "self", ".", "t_reset", ",", "\n", "x", "=", "mod2", ",", "\n", "y", "=", "mod3", ",", "\n", ")", "\n", "indices_for_next_layer", "=", "tf", ".", "tile", "(", "indices_for_next_layer", ",", "[", "batch_size", ",", "1", ",", "1", "]", ")", "\n", "\n", "# ra1: [B,Tmax,k]", "\n", "ra1", "=", "tf", ".", "range", "(", "batch_size", ")", "\n", "ra1", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "ra1", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "ra1", "=", "tf", ".", "tile", "(", "ra1", ",", "[", "1", ",", "max_length", ",", "self", ".", "next_t_reset", "]", ")", "\n", "ra2", "=", "tf", ".", "range", "(", "max_length", ")", "\n", "ra2", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "ra2", ",", "0", ")", ",", "-", "1", ")", "\n", "ra2", "=", "tf", ".", "tile", "(", "ra2", ",", "[", "batch_size", ",", "1", ",", "self", ".", "next_t_reset", "]", ")", "\n", "full_indices_for_next_layer", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "indices_for_next_layer", "]", ",", "axis", "=", "-", "1", ")", "\n", "output_for_next_layer", "=", "tf", ".", "gather_nd", "(", "replicas", ",", "full_indices_for_next_layer", ")", "\n", "\n", "outputs", "=", "(", "actual_outputs", ",", "output_for_next_layer", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BResetLSTMLayer.__init__": [[1048, 1076], ["int", "float", "float", "int", "ValueError"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "num_units", ",", "t_reset", "=", "1", ",", "group_size", "=", "1", ",", "forward_reset", "=", "True", ",", "backward_reset", "=", "True", ",", "layer_norm", "=", "False", ",", "\n", "recurrent_dropout", "=", "1.0", ",", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBResetLSTM constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tgroup_size: units in the same group share a state replicate\n\t\t\tforward_reset: whether to apply the reset in forward direction\n\t\t\tbackward_reset: whether to apply the reset in the backward direction\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\trecurrent_dropout: the recurrent dropout keep probability\n\t\t\tactivation_fn: the used activation function for the LSTM cell\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "t_reset", "=", "t_reset", "\n", "self", ".", "group_size", "=", "group_size", "\n", "self", ".", "forward_reset", "=", "forward_reset", "\n", "self", ".", "backward_reset", "=", "backward_reset", "\n", "self", ".", "num_replicates", "=", "float", "(", "self", ".", "t_reset", ")", "/", "float", "(", "self", ".", "group_size", ")", "\n", "if", "int", "(", "self", ".", "num_replicates", ")", "!=", "self", ".", "num_replicates", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'t_reset should be a multiple of group_size'", ")", "\n", "", "self", ".", "num_replicates", "=", "int", "(", "self", ".", "num_replicates", ")", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "recurrent_dropout", "=", "recurrent_dropout", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BResetLSTMLayer.__call__": [[1077, 1174], ["tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn.bidirectional_dynamic_rnn_2inputs_time_input", "tensorflow.contrib.rnn.LayerNormBasicLSTMCell", "tensorflow.contrib.rnn.LayerNormBasicLSTMCell", "nabu.neuralnetworks.components.rnn_cell.LayerNormResetLSTMCell", "nabu.neuralnetworks.components.rnn_cell.LayerNormGroupResetLSTMCell", "nabu.neuralnetworks.components.rnn_cell.LayerNormResetLSTMCell", "nabu.neuralnetworks.components.rnn_cell.LayerNormGroupResetLSTMCell", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn.bidirectional_dynamic_rnn_2inputs_time_input"], ["", "def", "__call__", "(", "self", ",", "inputs_for_forward", ",", "inputs_for_backward", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "if", "inputs_for_backward", "is", "None", ":", "\n", "\t\t\t", "inputs_for_backward", "=", "inputs_for_forward", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "# create the lstm cells that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "if", "not", "self", ".", "forward_reset", ":", "\n", "\t\t\t\t", "lstm_cell_fw", "=", "tf", ".", "contrib", ".", "rnn", ".", "LayerNormBasicLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "", "elif", "self", ".", "group_size", "==", "1", ":", "\n", "\t\t\t\t", "lstm_cell_fw", "=", "rnn_cell", ".", "LayerNormResetLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "lstm_cell_fw", "=", "rnn_cell", ".", "LayerNormGroupResetLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "group_size", "=", "self", ".", "group_size", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "", "if", "not", "self", ".", "backward_reset", ":", "\n", "\t\t\t\t", "lstm_cell_bw", "=", "tf", ".", "contrib", ".", "rnn", ".", "LayerNormBasicLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "", "elif", "self", ".", "group_size", "==", "1", ":", "\n", "\t\t\t\t", "lstm_cell_bw", "=", "rnn_cell", ".", "LayerNormResetLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "lstm_cell_bw", "=", "rnn_cell", ".", "LayerNormGroupResetLSTMCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "group_size", "=", "self", ".", "group_size", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "layer_norm", "=", "self", ".", "layer_norm", ",", "\n", "dropout_keep_prob", "=", "self", ".", "recurrent_dropout", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "", "outputs_tupple", ",", "_", "=", "rnn", ".", "bidirectional_dynamic_rnn_2inputs_time_input", "(", "\n", "lstm_cell_fw", ",", "lstm_cell_bw", ",", "inputs_for_forward", ",", "inputs_for_backward", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "sequence_length", "=", "sequence_length", ",", "time_input_for_fw", "=", "self", ".", "forward_reset", ",", "\n", "time_input_for_bw", "=", "self", ".", "backward_reset", ")", "\n", "\n", "if", "self", ".", "forward_reset", ":", "\n", "\t\t\t\t", "actual_outputs_forward", "=", "outputs_tupple", "[", "0", "]", "[", "0", "]", "\n", "forward_replicas", "=", "outputs_tupple", "[", "0", "]", "[", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "actual_outputs_forward", "=", "outputs_tupple", "[", "0", "]", "\n", "forward_replicas", "=", "None", "\n", "\n", "", "if", "self", ".", "backward_reset", ":", "\n", "\t\t\t\t", "actual_outputs_backward", "=", "outputs_tupple", "[", "1", "]", "[", "0", "]", "\n", "backward_replicas", "=", "outputs_tupple", "[", "1", "]", "[", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "actual_outputs_backward", "=", "outputs_tupple", "[", "1", "]", "\n", "backward_replicas", "=", "None", "\n", "\n", "", "actual_outputs", "=", "(", "actual_outputs_forward", ",", "actual_outputs_backward", ")", "\n", "\n", "replicas_tupple", "=", "(", "forward_replicas", ",", "backward_replicas", ")", "\n", "\n", "", "return", "actual_outputs", ",", "replicas_tupple", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BGRULayer.__init__": [[1179, 1189], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBGRULayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BGRULayer.__call__": [[1190, 1227], ["tensorflow.variable_scope", "tensorflow.contrib.rnn.GRUCell", "tensorflow.contrib.rnn.GRUCell", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the gru cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "gru_cell_fw", "=", "tf", ".", "contrib", ".", "rnn", ".", "GRUCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "gru_cell_bw", "=", "tf", ".", "contrib", ".", "rnn", ".", "GRUCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "gru_cell_fw", ",", "gru_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyBGRULayer.__init__": [[1232, 1244], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", ",", "leak_factor", "=", "1.0", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tLeakyBGRULayer constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tleak_factor: the leak factor (if 1, there is no leakage)\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "self", ".", "leak_factor", "=", "leak_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.LeakyBGRULayer.__call__": [[1245, 1284], ["tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn_cell.LeakGRUCell", "nabu.neuralnetworks.components.rnn_cell.LeakGRUCell", "tensorflow.python.ops.rnn.bidirectional_dynamic_rnn", "tensorflow.concat", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "# create the gru cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "gru_cell_fw", "=", "rnn_cell", ".", "LeakGRUCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "gru_cell_bw", "=", "rnn_cell", ".", "LeakGRUCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "leak_factor", "=", "self", ".", "leak_factor", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs_tupple", ",", "_", "=", "bidirectional_dynamic_rnn", "(", "\n", "gru_cell_fw", ",", "gru_cell_bw", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "outputs", "=", "tf", ".", "concat", "(", "outputs_tupple", ",", "2", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BResetGRULayer.__init__": [[1289, 1309], ["int", "float", "float", "int", "ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_units", ",", "t_reset", "=", "1", ",", "group_size", "=", "1", ",", "symmetric_context", "=", "False", ",", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBResetLSTM constructor\n\n\t\tArgs:\n\t\t\tnum_units: The number of units in the one directon\n\t\t\tgroup_size: units in the same group share a state replicate\n\t\t\tsymmetric_context: if True, input to next layer should have same amount of context\n\t\t\tin both directions. If False, reversed input to next layers has full (t_reset) context.\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_units", "=", "num_units", "\n", "self", ".", "t_reset", "=", "t_reset", "\n", "self", ".", "group_size", "=", "group_size", "\n", "self", ".", "num_replicates", "=", "float", "(", "self", ".", "t_reset", ")", "/", "float", "(", "self", ".", "group_size", ")", "\n", "if", "int", "(", "self", ".", "num_replicates", ")", "!=", "self", ".", "num_replicates", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'t_reset should be a multiple of group_size'", ")", "\n", "", "self", ".", "symmetric_context", "=", "symmetric_context", "\n", "self", ".", "num_replicates", "=", "int", "(", "self", ".", "num_replicates", ")", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.BResetGRULayer.__call__": [[1310, 1426], ["inputs_for_forward.get_shape", "tensorflow.shape", "tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn.bidirectional_dynamic_rnn_2inputs_time_input", "tensorflow.concat", "nabu.neuralnetworks.components.rnn_cell_impl.ResetGRUCell", "nabu.neuralnetworks.components.rnn_cell_impl.ResetGRUCell", "nabu.neuralnetworks.components.rnn_cell_impl.GroupResetGRUCell", "nabu.neuralnetworks.components.rnn_cell_impl.GroupResetGRUCell", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.concat", "tensorflow.concat", "tensorflow.to_int32", "tensorflow.expand_dims", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.mod", "tensorflow.expand_dims", "tensorflow.mod", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.concat", "tensorflow.concat", "tensorflow.ceil", "tensorflow.expand_dims", "range", "tensorflow.expand_dims", "tensorflow.expand_dims", "type", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.get_variable_scope", "tensorflow.to_float", "tensorflow.to_float"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.rnn.bidirectional_dynamic_rnn_2inputs_time_input"], ["", "def", "__call__", "(", "self", ",", "inputs_for_forward", ",", "inputs_for_backward", ",", "sequence_length", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim] tensor\n\t\t\tsequence_length: the length of the input sequences as a\n\t\t\t\t[batch_size] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "if", "inputs_for_backward", "is", "None", ":", "\n", "\t\t\t", "inputs_for_backward", "=", "inputs_for_forward", "\n", "\n", "", "batch_size", "=", "inputs_for_forward", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "max_length", "=", "tf", ".", "shape", "(", "inputs_for_forward", ")", "[", "1", "]", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "# create the gru cell that will be used for the forward and backward", "\n", "# pass", "\n", "\t\t\t", "if", "self", ".", "group_size", "==", "1", ":", "\n", "\t\t\t\t", "gru_cell_fw", "=", "rnn_cell_impl", ".", "ResetGRUCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "gru_cell_bw", "=", "rnn_cell_impl", ".", "ResetGRUCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "tile_shape", "=", "[", "1", ",", "1", ",", "self", ".", "t_reset", ",", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "gru_cell_fw", "=", "rnn_cell_impl", ".", "GroupResetGRUCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "group_size", "=", "self", ".", "group_size", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "gru_cell_bw", "=", "rnn_cell_impl", ".", "GroupResetGRUCell", "(", "\n", "num_units", "=", "self", ".", "num_units", ",", "\n", "t_reset", "=", "self", ".", "t_reset", ",", "\n", "group_size", "=", "self", ".", "group_size", ",", "\n", "activation", "=", "self", ".", "activation_fn", ",", "\n", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "tile_shape", "=", "[", "1", ",", "1", ",", "gru_cell_fw", ".", "_num_replicates", ",", "1", "]", "\n", "\n", "# do the forward computation", "\n", "", "outputs_tupple", ",", "_", "=", "rnn", ".", "bidirectional_dynamic_rnn_2inputs_time_input", "(", "\n", "gru_cell_fw", ",", "gru_cell_bw", ",", "inputs_for_forward", ",", "inputs_for_backward", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "sequence_length", "=", "sequence_length", ")", "\n", "\n", "actual_outputs_forward", "=", "outputs_tupple", "[", "0", "]", "[", "0", "]", "\n", "actual_outputs_backward", "=", "outputs_tupple", "[", "1", "]", "[", "0", "]", "\n", "actual_outputs", "=", "tf", ".", "concat", "(", "(", "actual_outputs_forward", ",", "actual_outputs_backward", ")", ",", "-", "1", ")", "\n", "\n", "forward_replicas", "=", "outputs_tupple", "[", "0", "]", "[", "1", "]", "\n", "backward_replicas", "=", "outputs_tupple", "[", "1", "]", "[", "1", "]", "\n", "\n", "if", "not", "self", ".", "symmetric_context", ":", "\n", "\t\t\t\t", "forward_for_backward", "=", "tf", ".", "expand_dims", "(", "actual_outputs_forward", ",", "-", "2", ")", "\n", "forward_for_backward", "=", "tf", ".", "tile", "(", "forward_for_backward", ",", "tile_shape", ")", "\n", "\n", "backward_for_forward", "=", "tf", ".", "expand_dims", "(", "actual_outputs_backward", ",", "-", "2", ")", "\n", "backward_for_forward", "=", "tf", ".", "tile", "(", "backward_for_forward", ",", "tile_shape", ")", "\n", "\n", "outputs_for_forward", "=", "tf", ".", "concat", "(", "(", "forward_replicas", ",", "backward_for_forward", ")", ",", "-", "1", ")", "\n", "outputs_for_backward", "=", "tf", ".", "concat", "(", "(", "forward_for_backward", ",", "backward_replicas", ")", ",", "-", "1", ")", "\n", "\n", "", "else", ":", "\n", "# the output replicas need to be permutated correclty such that the next layer receives", "\n", "# the replicas in the correct order", "\n", "\t\t\t\t", "T", "=", "tf", ".", "to_int32", "(", "tf", ".", "ceil", "(", "tf", ".", "to_float", "(", "sequence_length", ")", "/", "tf", ".", "to_float", "(", "self", ".", "group_size", ")", ")", ")", "\n", "T_min_1", "=", "tf", ".", "expand_dims", "(", "T", "-", "1", ",", "-", "1", ")", "\n", "\n", "numbers_to_maxT", "=", "tf", ".", "range", "(", "0", ",", "max_length", ")", "\n", "numbers_to_maxT", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "numbers_to_maxT", ",", "0", ")", ",", "-", "1", ")", "\n", "\n", "numbers_to_k", "=", "tf", ".", "expand_dims", "(", "range", "(", "0", ",", "self", ".", "num_replicates", ")", ",", "0", ")", "\n", "\n", "backward_indices_for_forward_t_0", "=", "numbers_to_k", "+", "T_min_1", "\n", "#backward_indices_for_forward_t_0 = tf.mod(backward_indices_for_forward_t_0, self.num_replicates) #unnecessary since mod will be applied again further on", "\n", "backward_indices_for_forward_t_0", "=", "tf", ".", "expand_dims", "(", "backward_indices_for_forward_t_0", ",", "1", ")", "\n", "backward_indices_for_forward_t", "=", "tf", ".", "mod", "(", "backward_indices_for_forward_t_0", "-", "2", "*", "numbers_to_maxT", ",", "\n", "self", ".", "num_replicates", ")", "\n", "\n", "forward_indices_for_backward_t_0", "=", "numbers_to_k", "-", "T_min_1", "\n", "#forward_indices_for_backward_t_0 = tf.mod(forward_indices_for_backward_t_0, self.num_replicates) #unnecessary since mod will be applied again further on", "\n", "forward_indices_for_backward_t_0", "=", "tf", ".", "expand_dims", "(", "forward_indices_for_backward_t_0", ",", "1", ")", "\n", "forward_indices_for_backward_t", "=", "tf", ".", "mod", "(", "forward_indices_for_backward_t_0", "+", "2", "*", "numbers_to_maxT", ",", "\n", "self", ".", "num_replicates", ")", "\n", "\n", "ra1", "=", "tf", ".", "range", "(", "batch_size", ")", "\n", "ra1", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "ra1", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "ra1", "=", "tf", ".", "tile", "(", "ra1", ",", "[", "1", ",", "max_length", ",", "self", ".", "num_replicates", "]", ")", "\n", "ra2", "=", "tf", ".", "range", "(", "max_length", ")", "\n", "ra2", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "ra2", ",", "0", ")", ",", "-", "1", ")", "\n", "ra2", "=", "tf", ".", "tile", "(", "ra2", ",", "[", "batch_size", ",", "1", ",", "self", ".", "num_replicates", "]", ")", "\n", "stacked_backward_indices_for_forward_t", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "backward_indices_for_forward_t", "]", ",", "axis", "=", "-", "1", ")", "\n", "backward_for_forward", "=", "tf", ".", "gather_nd", "(", "backward_replicas", ",", "stacked_backward_indices_for_forward_t", ")", "\n", "stacked_forward_indices_for_backward_t", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "forward_indices_for_backward_t", "]", ",", "axis", "=", "-", "1", ")", "\n", "forward_for_backward", "=", "tf", ".", "gather_nd", "(", "forward_replicas", ",", "stacked_forward_indices_for_backward_t", ")", "\n", "\n", "outputs_for_forward", "=", "tf", ".", "concat", "(", "(", "forward_replicas", ",", "backward_for_forward", ")", ",", "-", "1", ")", "\n", "outputs_for_backward", "=", "tf", ".", "concat", "(", "(", "forward_for_backward", ",", "backward_replicas", ")", ",", "-", "1", ")", "\n", "\n", "", "outputs", "=", "(", "actual_outputs", ",", "outputs_for_forward", ",", "outputs_for_backward", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Conv2D.__init__": [[1431, 1456], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "num_filters", ",", "kernel_size", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'same'", ",", "activation_fn", "=", "tf", ".", "nn", ".", "relu", ",", "layer_norm", "=", "False", ",", "\n", "max_pool_filter", "=", "(", "1", ",", "1", ")", ",", "transpose", "=", "False", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBLSTMLayer constructor\n\n\t\tArgs:\n\t\t\tnum_filters: The number of filters\n\t\t\tkernel_size: kernel filter size\n\t\t\tstrides: stride size\n\t\t\tpadding: padding algorithm\n\t\t\tactivation_fn: hidden unit activation\n\t\t\tlayer_norm: whether layer normalization should be applied\n\t\t\tmax_pool_filter: pooling filter size\n\t\t\ttranspose: if true use tf.layers.conv2d_transpose\n\t\t\"\"\"", "\n", "\n", "self", ".", "num_filters", "=", "num_filters", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "activation_fn", "=", "activation_fn", "\n", "self", ".", "layer_norm", "=", "layer_norm", "\n", "self", ".", "max_pool_filter", "=", "max_pool_filter", "\n", "self", ".", "transpose", "=", "transpose", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.Conv2D.__call__": [[1457, 1500], ["tensorflow.variable_scope", "tensorflow.layers.batch_normalization", "tensorflow.layers.max_pooling2d", "tensorflow.layers.conv2d", "tensorflow.layers.conv2d_transpose", "type"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "scope", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the input to the layer as a\n\t\t\t\t[batch_size, max_length, dim, in_channel] tensor\n\t\t\tscope: The variable scope sets the namespace under which\n\t\t\t\tthe variables created during this call will be stored.\n\n\t\tReturns:\n\t\t\tthe output of the layer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "type", "(", "self", ")", ".", "__name__", ")", ":", "\n", "\n", "\t\t\t", "if", "not", "self", ".", "transpose", ":", "\n", "\t\t\t\t", "outputs", "=", "tf", ".", "layers", ".", "conv2d", "(", "\n", "inputs", "=", "inputs", ",", "\n", "filters", "=", "self", ".", "num_filters", ",", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "activation", "=", "self", ".", "activation_fn", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "outputs", "=", "tf", ".", "layers", ".", "conv2d_transpose", "(", "\n", "inputs", "=", "inputs", ",", "\n", "filters", "=", "self", ".", "num_filters", ",", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "activation", "=", "self", ".", "activation_fn", ")", "\n", "\n", "", "", "if", "self", ".", "layer_norm", ":", "\n", "\t\t\t", "outputs", "=", "tf", ".", "layers", ".", "batch_normalization", "(", "outputs", ")", "\n", "\n", "", "outputs_before_pool", "=", "outputs", "\n", "\n", "if", "self", ".", "max_pool_filter", "!=", "(", "1", ",", "1", ")", ":", "\n", "\t\t\t", "outputs", "=", "tf", ".", "layers", ".", "max_pooling2d", "(", "\n", "outputs", ",", "self", ".", "max_pool_filter", ",", "strides", "=", "self", ".", "max_pool_filter", ",", "padding", "=", "'valid'", ")", "\n", "\n", "", "return", "outputs", ",", "outputs_before_pool", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.unpool": [[1502, 1519], ["tensorflow.python.ops.gen_nn_ops.max_pool_grad", "len", "ValueError", "len", "ValueError"], "function", ["None"], ["", "", "def", "unpool", "(", "pool_input", ",", "pool_output", ",", "unpool_input", ",", "pool_kernel_size", ",", "pool_stride", ",", "padding", "=", "'VALID'", ")", ":", "\n", "\t", "\"\"\" An unpooling layer as described in Adaptive Deconvolutional Networks for Mid and High Level Feature Learning\n\tfrom Matthew D. Zeiler, Graham W. Taylor and Rob Fergus,\n\tusing the implementation of https://assiaben.github.io/posts/2018-06-tf-unpooling/\n\t\"\"\"", "\n", "\n", "# Assuming pool_kernel_size and pool_stride are given in 'HW' format, converting them to 'NHWC' format", "\n", "if", "len", "(", "pool_kernel_size", ")", "!=", "2", ":", "\n", "\t\t", "raise", "ValueError", "(", "'Expected kernel size to be in \"HW\" format.'", ")", "\n", "", "pool_kernel_size", "=", "[", "1", "]", "+", "pool_kernel_size", "+", "[", "1", "]", "\n", "if", "len", "(", "pool_stride", ")", "!=", "2", ":", "\n", "\t\t", "raise", "ValueError", "(", "'Expected stride size to be in \"HW\" format.'", ")", "\n", "", "pool_stride", "=", "[", "1", "]", "+", "pool_stride", "+", "[", "1", "]", "\n", "\n", "unpool_op", "=", "gen_nn_ops", ".", "max_pool_grad", "(", "pool_input", ",", "pool_output", ",", "unpool_input", ",", "pool_kernel_size", ",", "pool_stride", ",", "padding", ")", "\n", "\n", "return", "unpool_op", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.trainers.multi_task_trainer.MultiTaskTrainer.__init__": [[20, 479], ["int", "multi_task_trainer.MultiTaskTrainer.conf[].split", "tensorflow.Graph", "os.path.join", "modelconf.get().split", "dict", "evaluatorconf.get", "len", "map", "open", "cPickle.dump", "nabu.neuralnetworks.trainers.task_trainer.TaskTrainer", "multi_task_trainer.MultiTaskTrainer.task_trainers.append", "multi_task_trainer.MultiTaskTrainer.graph.as_default", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.logical_or", "tensorflow.group", "tensorflow.train.Scaffold", "multi_task_trainer.MultiTaskTrainer.conf[].split", "len", "len", "BaseException", "len", "modelconf.get", "dict", "multi_task_trainer.MultiTaskTrainer.should_save_final_model.assign", "tensorflow.get_variable.assign", "tensorflow.greater_equal", "nabu.neuralnetworks.trainers.task_trainer.TaskTrainer.set_dataqueues", "num_steps.append", "multi_task_trainer.MultiTaskTrainer.num_steps.assign", "tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.group", "tensorflow.group", "tensorflow.get_collection", "multi_task_trainer.MultiTaskTrainer.global_step.assign_add", "tensorflow.group", "nabu.neuralnetworks.models.model_factory.factory", "lossesconf.items", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "min", "tensorflow.train.exponential_decay", "tensorflow.train.AdamOptimizer", "dict", "zip", "zip", "tensorflow.variable_scope", "tensorflow.reduce_sum", "tensorflow.train.AdamOptimizer.apply_gradients", "tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.greater_equal", "evaluatorconf.has_option", "len", "tensorflow.group", "tensorflow.group", "tensorflow.reduce_sum", "tensorflow.get_variable", "tensorflow.equal", "tensorflow.train.Saver", "modelconf.get", "dict", "tensorflow.constant_initializer", "dict", "dict", "dict", "zip", "zip", "zip", "all_batch_grads_and_vars.append", "dict.values", "dict.keys", "tmp.append", "int", "evaluatorconf.get().split", "valbatches.append", "min", "multi_task_trainer.MultiTaskTrainer.val_loss_all_tasks.append", "tensorflow.get_variable.assign", "tensorflow.get_variable.assign", "tensorflow.get_variable", "multi_task_trainer.MultiTaskTrainer.best_validation.assign", "tensorflow.get_variable", "multi_task_trainer.MultiTaskTrainer.previous_validation.assign", "tensorflow.get_variable", "tensorflow.concat", "tensorflow.assign", "tensorflow.get_variable", "multi_task_trainer.MultiTaskTrainer.num_tries.assign", "multi_task_trainer.MultiTaskTrainer.num_tries.assign", "tensorflow.get_variable.assign_add", "len", "len", "modelconf.items", "float", "float", "tensorflow.train.AdamOptimizer", "nabu.neuralnetworks.trainers.task_trainer.TaskTrainer.gather_grads", "nabu.neuralnetworks.trainers.task_trainer.TaskTrainer.train", "nabu.neuralnetworks.trainers.task_trainer.TaskTrainer.train", "nabu.neuralnetworks.trainers.task_trainer.TaskTrainer.gather_grads", "tensorflow.constant_initializer", "nabu.neuralnetworks.trainers.task_trainer.TaskTrainer.evaluate_evaluator", "tensorflow.get_variable", "best_val_task.assign", "tensorflow.get_variable", "prev_val_task.assign", "tensorflow.get_variable", "tensorflow.concat", "tensorflow.assign", "tensorflow.get_variable", "num_tries.assign", "num_tries.assign", "tensorflow.constant_initializer", "zip", "evaluatorconf.get", "zip", "range", "enumerate", "range", "enumerate", "range", "range", "enumerate", "enumerate", "range", "enumerate", "enumerate", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.expand_dims", "tensorflow.constant_initializer", "int", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.expand_dims", "tensorflow.constant_initializer", "int", "int"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.trainers.multi_task_trainer.MultiTaskTrainer.train", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.trainers.multi_task_trainer.MultiTaskTrainer.train"], ["def", "__init__", "(", "\n", "self", ",", "\n", "conf", ",", "\n", "tasksconf", ",", "\n", "dataconf", ",", "\n", "modelconf", ",", "\n", "evaluatorconf", ",", "\n", "lossesconf", ",", "\n", "expdir", ",", "\n", "init_filename", ",", "\n", "task_index", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tMultiTaskTrainer constructor, creates the training graph\n\n\t\tArgs:\n\t\t\tconf: the trainer config\n\t\t\ttasksconf: the config file for each task\n\t\t\tdataconf: the data configuration as a ConfigParser\n\t\t\tmodelconf: the neural net model configuration\n\t\t\tevaluatorconf: the evaluator configuration for evaluating\n\t\t\t\tif None no evaluation will be done\n\t\t\tlossesconf: the configuration of the loss functions\n\t\t\texpdir: directory where the summaries will be written\n\t\t\tinit_filename: filename of the network that should be used to\n\t\t\tinitialize the model. Put to None if no network is available/wanted.\n\t\t\ttask_index: optional index of the worker task in the cluster\n\t\t\"\"\"", "\n", "\n", "self", ".", "expdir", "=", "expdir", "\n", "self", ".", "conf", "=", "conf", "\n", "self", ".", "tasksconf", "=", "tasksconf", "\n", "self", ".", "task_index", "=", "task_index", "\n", "self", ".", "init_filename", "=", "init_filename", "\n", "\n", "self", ".", "batch_size", "=", "int", "(", "conf", "[", "'batch_size'", "]", ")", "\n", "self", ".", "tasks", "=", "self", ".", "conf", "[", "'tasks'", "]", ".", "split", "(", "' '", ")", "\n", "\n", "self", ".", "acc_steps", "=", "'acc_steps'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'acc_steps'", "]", "==", "'True'", "\n", "self", ".", "normalize_weights_acc_steps", "=", "self", ".", "acc_steps", "and", "'normalize_weights_acc_steps'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'normalize_weights_acc_steps'", "]", "==", "'True'", "\n", "\n", "if", "'task_weights'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "self", ".", "task_weights", "=", "map", "(", "float", ",", "self", ".", "conf", "[", "'task_weights'", "]", ".", "split", "(", "' '", ")", ")", "\n", "if", "len", "(", "self", ".", "tasks", ")", "!=", "len", "(", "self", ".", "task_weights", ")", ":", "\n", "\t\t\t\t", "raise", "BaseException", "(", "'Number of task weights must equal number of tasks. but was %d and %d'", "%", "(", "\n", "len", "(", "self", ".", "task_weights", ")", ",", "len", "(", "self", ".", "tasks", ")", ")", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "self", ".", "task_weights", "=", "[", "1.0", "]", "*", "len", "(", "self", ".", "tasks", ")", "\n", "\n", "# create the graph", "\n", "", "self", ".", "graph", "=", "tf", ".", "Graph", "(", ")", "\n", "\n", "# create the model", "\n", "modelfile", "=", "os", ".", "path", ".", "join", "(", "expdir", ",", "'model'", ",", "'model.pkl'", ")", "\n", "model_names", "=", "modelconf", ".", "get", "(", "'hyper'", ",", "'model_names'", ")", ".", "split", "(", "' '", ")", "\n", "self", ".", "models", "=", "dict", "(", ")", "\n", "with", "open", "(", "modelfile", ",", "'wb'", ")", "as", "fid", ":", "\n", "\t\t\t", "for", "model_name", "in", "model_names", ":", "\n", "\t\t\t\t", "self", ".", "models", "[", "model_name", "]", "=", "model_factory", ".", "factory", "(", "\n", "modelconf", ".", "get", "(", "model_name", ",", "'architecture'", ")", ")", "(", "\n", "conf", "=", "dict", "(", "modelconf", ".", "items", "(", "model_name", ")", ")", ",", "\n", "name", "=", "model_name", ")", "\n", "", "Pickle", ".", "dump", "(", "self", ".", "models", ",", "fid", ")", "\n", "\n", "", "evaltype", "=", "evaluatorconf", ".", "get", "(", "'evaluator'", ",", "'evaluator'", ")", "\n", "\n", "# define a trainer per traintask", "\n", "self", ".", "task_trainers", "=", "[", "]", "\n", "for", "task", "in", "self", ".", "tasks", ":", "\n", "\t\t\t", "taskconf", "=", "self", ".", "tasksconf", "[", "task", "]", "\n", "if", "lossesconf", ":", "\n", "\t\t\t\t", "lossconf", "=", "dict", "(", "lossesconf", ".", "items", "(", "taskconf", "[", "'loss_type'", "]", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "lossconf", "=", "None", "\n", "", "task_trainer", "=", "task_trainer_script", ".", "TaskTrainer", "(", "\n", "task", ",", "conf", ",", "taskconf", ",", "self", ".", "models", ",", "modelconf", ",", "dataconf", ",", "evaluatorconf", ",", "lossconf", ",", "self", ".", "batch_size", ")", "\n", "\n", "self", ".", "task_trainers", ".", "append", "(", "task_trainer", ")", "\n", "", "nr_tasks", "=", "len", "(", "self", ".", "task_trainers", ")", "\n", "\n", "num_replicas", "=", "1", "\n", "# device = tf.DeviceSpec(job='local')", "\n", "\n", "self", ".", "is_chief", "=", "task_index", "==", "0", "\n", "\n", "# define the placeholders in the graph", "\n", "with", "self", ".", "graph", ".", "as_default", "(", ")", ":", "\n", "\n", "# create a local num_steps variable", "\n", "\t\t\t", "self", ".", "num_steps", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'num_steps'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "int32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "0", ")", ",", "\n", "trainable", "=", "False", "\n", ")", "\n", "\n", "# a variable to hold the amount of steps already taken", "\n", "self", ".", "global_step", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'global_step'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "int32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "0", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "should_terminate", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'should_terminate'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "bool", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "False", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "self", ".", "should_save_final_model", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'should_save_final_model'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "bool", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "False", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "self", ".", "do_save_final_model", "=", "self", ".", "should_save_final_model", ".", "assign", "(", "True", ")", ".", "op", "\n", "\n", "self", ".", "terminate", "=", "should_terminate", ".", "assign", "(", "True", ")", ".", "op", "\n", "\n", "# create a check if training should continue", "\n", "self", ".", "should_stop", "=", "tf", ".", "logical_or", "(", "\n", "tf", ".", "greater_equal", "(", "self", ".", "global_step", ",", "self", ".", "num_steps", ")", ",", "\n", "should_terminate", ")", "\n", "\n", "# with tf.device(device):", "\n", "num_steps", "=", "[", "]", "\n", "done_ops", "=", "[", "]", "\n", "\n", "# set the dataqueues for each trainer", "\n", "for", "task_trainer", "in", "self", ".", "task_trainers", ":", "\n", "\n", "\t\t\t\t", "task_num_steps", ",", "task_done_ops", "=", "task_trainer", ".", "set_dataqueues", "(", ")", "\n", "\n", "num_steps", ".", "append", "(", "task_num_steps", ")", "\n", "done_ops", "+=", "task_done_ops", "\n", "\n", "", "self", ".", "set_num_steps", "=", "self", ".", "num_steps", ".", "assign", "(", "min", "(", "num_steps", ")", ")", ".", "op", "\n", "self", ".", "done", "=", "tf", ".", "group", "(", "*", "done_ops", ")", "\n", "\n", "# training part", "\n", "with", "tf", ".", "variable_scope", "(", "'train'", ")", ":", "\n", "\n", "# a variable to scale the learning rate (used to reduce the", "\n", "# learning rate in case validation performance drops)", "\n", "\t\t\t\t", "learning_rate_fact", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'learning_rate_fact'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1.0", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# compute the learning rate with exponential decay and scale", "\n", "# with the learning rate factor", "\n", "self", ".", "learning_rate", "=", "(", "tf", ".", "train", ".", "exponential_decay", "(", "\n", "learning_rate", "=", "float", "(", "conf", "[", "'initial_learning_rate'", "]", ")", ",", "\n", "global_step", "=", "self", ".", "global_step", ",", "\n", "decay_steps", "=", "self", ".", "num_steps", ",", "\n", "decay_rate", "=", "float", "(", "conf", "[", "'learning_rate_decay'", "]", ")", ")", "*", "learning_rate_fact", ")", "\n", "\n", "# For each task, set the task specific training ops", "\n", "if", "self", ".", "acc_steps", ":", "\n", "\t\t\t\t\t", "if", "self", ".", "normalize_weights_acc_steps", ":", "\n", "# Normalize the weights used to accumulate steps over tasks. Since it is possible that some vars", "\n", "# are not optimized by all tasks, this might cause different learning rates per var per task.", "\n", "# Find which var is optimized by which task (by using a dummy optimizer)", "\n", "\t\t\t\t\t\t", "vars_norm_weight", "=", "dict", "(", ")", "\n", "all_task_var_names", "=", "dict", "(", ")", "\n", "all_task_batch_grads_and_vars", "=", "dict", "(", ")", "\n", "for", "task_trainer", ",", "task_weight", "in", "zip", "(", "self", ".", "task_trainers", ",", "self", ".", "task_weights", ")", ":", "\n", "\t\t\t\t\t\t\t", "dummy_optimizer", "=", "optimizer", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "self", ".", "learning_rate", ")", "\n", "task_batch_grads_and_vars", "=", "task_trainer", ".", "gather_grads", "(", "dummy_optimizer", ")", "\n", "task_var_names", "=", "[", "task_var", ".", "name", "for", "_", ",", "task_var", "in", "task_batch_grads_and_vars", "]", "\n", "all_task_var_names", "[", "task_trainer", ".", "task_name", "]", "=", "task_var_names", "\n", "all_task_batch_grads_and_vars", "[", "task_trainer", ".", "task_name", "]", "=", "task_batch_grads_and_vars", "\n", "for", "task_var_name", "in", "task_var_names", ":", "\n", "\t\t\t\t\t\t\t\t", "if", "task_var_name", "not", "in", "vars_norm_weight", ":", "\n", "\t\t\t\t\t\t\t\t\t", "vars_norm_weight", "[", "task_var_name", "]", "=", "0.0", "\n", "", "vars_norm_weight", "[", "task_var_name", "]", "+=", "task_weight", "\n", "\n", "# for each task, find the normalized var weights", "\n", "", "", "for", "task_trainer", ",", "task_weight", "in", "zip", "(", "self", ".", "task_trainers", ",", "self", ".", "task_weights", ")", ":", "\n", "\t\t\t\t\t\t\t", "task_var_names", "=", "all_task_var_names", "[", "task_trainer", ".", "task_name", "]", "\n", "task_batch_grads_and_vars", "=", "all_task_batch_grads_and_vars", "[", "task_trainer", ".", "task_name", "]", "\n", "task_vars_norm_weights", "=", "{", "\n", "task_var_name", ":", "task_weight", "/", "vars_norm_weight", "[", "task_var_name", "]", "\n", "for", "task_var_name", "in", "task_var_names", "}", "\n", "task_trainer", ".", "train", "(", "\n", "self", ".", "learning_rate", ",", "var_weights", "=", "task_vars_norm_weights", ",", "\n", "batch_grads_and_vars", "=", "task_batch_grads_and_vars", ")", "\n", "\n", "", "", "else", ":", "\n", "\n", "\t\t\t\t\t\t", "for", "task_trainer", ",", "task_weight", "in", "zip", "(", "self", ".", "task_trainers", ",", "self", ".", "task_weights", ")", ":", "\n", "\t\t\t\t\t\t\t", "task_trainer", ".", "train", "(", "self", ".", "learning_rate", "*", "task_weight", ")", "\n", "\n", "", "", "", "else", ":", "\n", "\t\t\t\t\t", "optimizer", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "self", ".", "learning_rate", ")", "\n", "all_batch_grads_and_vars", "=", "[", "]", "\n", "for", "task_trainer", "in", "self", ".", "task_trainers", ":", "\n", "\t\t\t\t\t\t", "all_batch_grads_and_vars", ".", "append", "(", "task_trainer", ".", "gather_grads", "(", "optimizer", ")", ")", "\n", "", "batch_grads_and_vars_dict", "=", "dict", "(", ")", "\n", "for", "batch_grads_and_vars", ",", "task_weight", "in", "zip", "(", "all_batch_grads_and_vars", ",", "self", ".", "task_weights", ")", ":", "\n", "\t\t\t\t\t\t", "for", "grad", ",", "var", "in", "batch_grads_and_vars", ":", "\n", "\t\t\t\t\t\t\t", "if", "var", "in", "batch_grads_and_vars_dict", ":", "\n", "\t\t\t\t\t\t\t\t", "batch_grads_and_vars_dict", "[", "var", "]", "+=", "grad", "*", "task_weight", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t", "batch_grads_and_vars_dict", "[", "var", "]", "=", "grad", "*", "task_weight", "\n", "", "", "", "batch_grads_and_vars", "=", "zip", "(", "batch_grads_and_vars_dict", ".", "values", "(", ")", ",", "batch_grads_and_vars_dict", ".", "keys", "(", ")", ")", "\n", "self", ".", "batch_grads_and_vars", "=", "batch_grads_and_vars", "\n", "\n", "# Group ops over tasks", "\n", "# self.process_minibatch = tf.group(", "\n", "# \t*([task_trainer.process_minibatch for task_trainer in self.task_trainers]),", "\n", "# \tname='process_minibatch_all_tasks')", "\n", "\n", "", "self", ".", "reset_grad_loss_norm", "=", "tf", ".", "group", "(", "\n", "*", "(", "[", "task_trainer", ".", "reset_grad_loss_norm", "for", "task_trainer", "in", "self", ".", "task_trainers", "]", ")", ",", "\n", "name", "=", "'reset_grad_loss_norm_all_tasks'", ")", "\n", "\n", "tmp", "=", "[", "]", "\n", "for", "task_trainer", "in", "self", ".", "task_trainers", ":", "\n", "\t\t\t\t\t", "tmp", "+=", "task_trainer", ".", "normalize_gradients", "\n", "", "self", ".", "normalize_gradients", "=", "tf", ".", "group", "(", "*", "tmp", ",", "name", "=", "'normalize_gradients_all_tasks'", ")", "\n", "\n", "# accumulate losses from tasks", "\n", "with", "tf", ".", "variable_scope", "(", "'accumulate_losses_from_tasks'", ")", ":", "\n", "\t\t\t\t\t", "self", ".", "loss_all_tasks", "=", "[", "task_trainer", ".", "normalized_loss", "for", "task_trainer", "in", "self", ".", "task_trainers", "]", "\n", "self", ".", "total_loss", "=", "tf", ".", "reduce_sum", "(", "\n", "[", "loss", "*", "weight", "for", "loss", ",", "weight", "in", "zip", "(", "self", ".", "loss_all_tasks", ",", "self", ".", "task_weights", ")", "]", ",", "name", "=", "'acc_loss'", ")", "\n", "# an op to apply the gradients", "\n", "", "if", "self", ".", "acc_steps", ":", "\n", "\t\t\t\t\t", "tmp", "=", "[", "]", "\n", "for", "task_trainer", "in", "self", ".", "task_trainers", ":", "\n", "\t\t\t\t\t\t", "tmp", ".", "append", "(", "task_trainer", ".", "apply_gradients", ")", "\n", "", "", "else", ":", "\n", "# an op to apply the accumulated gradients to the variables", "\n", "\t\t\t\t\t", "self", ".", "apply_gradients", "=", "optimizer", ".", "apply_gradients", "(", "\n", "grads_and_vars", "=", "self", ".", "batch_grads_and_vars", ",", "name", "=", "'apply_gradients'", ")", "\n", "\n", "# all remaining operations with the UPDATE_OPS GraphKeys", "\n", "", "update_ops", "=", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "UPDATE_OPS", ")", "\n", "\n", "# an op to increment the global step", "\n", "global_step_inc", "=", "self", ".", "global_step", ".", "assign_add", "(", "1", ")", "\n", "\n", "# create an operation to update the gradients, the batch_loss", "\n", "# and do all other update ops", "\n", "# self.update_op = tf.group(", "\n", "# *(tmp + update_ops + [global_step_inc]),", "\n", "# name='update')", "\n", "\n", "self", ".", "other_update_op", "=", "tf", ".", "group", "(", "\n", "*", "(", "update_ops", "+", "[", "global_step_inc", "]", ")", ",", "\n", "name", "=", "'other_update'", ")", "\n", "\n", "", "if", "evaltype", "!=", "'None'", ":", "\n", "\n", "# validation part", "\n", "\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'validate'", ")", ":", "\n", "\n", "# create a variable to save the last step where the model", "\n", "# was validated", "\n", "\t\t\t\t\t", "validated_step", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'validated_step'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "int32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "-", "int", "(", "conf", "[", "'valid_frequency'", "]", ")", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# a check if validation is due", "\n", "self", ".", "should_validate", "=", "tf", ".", "greater_equal", "(", "\n", "self", ".", "global_step", "-", "validated_step", ",", "int", "(", "conf", "[", "'valid_frequency'", "]", ")", ")", "\n", "\n", "# For each task, if requested, set the task specific validation ops", "\n", "# The number of validation batches is the minimum number of validation", "\n", "# batches over all tasks.", "\n", "tasks_excluded_for_val", "=", "[", "'None'", "]", "\n", "if", "evaluatorconf", ".", "has_option", "(", "'evaluator'", ",", "'tasks_excluded_for_val'", ")", ":", "\n", "\t\t\t\t\t\t", "tasks_excluded_for_val", "=", "evaluatorconf", ".", "get", "(", "'evaluator'", ",", "'tasks_excluded_for_val'", ")", ".", "split", "(", "' '", ")", "\n", "", "self", ".", "val_task_trainers", "=", "[", "\n", "task_trainer", "for", "task_trainer", "in", "self", ".", "task_trainers", "\n", "if", "task_trainer", ".", "task_name", "not", "in", "tasks_excluded_for_val", "]", "\n", "nr_val_tasks", "=", "len", "(", "self", ".", "val_task_trainers", ")", "\n", "\n", "valbatches", "=", "[", "]", "\n", "for", "task_trainer", "in", "self", ".", "val_task_trainers", ":", "\n", "\t\t\t\t\t\t", "valbatches", ".", "append", "(", "task_trainer", ".", "evaluate_evaluator", "(", ")", ")", "\n", "self", ".", "valbatches", "=", "min", "(", "valbatches", ")", "\n", "\n", "# Group ops over tasks", "\n", "", "self", ".", "process_val_batch", "=", "tf", ".", "group", "(", "*", "(", "\n", "[", "task_trainer", ".", "process_val_batch", "for", "task_trainer", "in", "self", ".", "val_task_trainers", "]", ")", ")", "\n", "\n", "self", ".", "reset_val_loss_norm", "=", "tf", ".", "group", "(", "*", "(", "\n", "[", "task_trainer", ".", "reset_val_loss_norm", "for", "task_trainer", "in", "self", ".", "val_task_trainers", "]", ")", ")", "\n", "\n", "self", ".", "val_loss_all_tasks", "=", "[", "]", "\n", "for", "task_trainer", "in", "self", ".", "val_task_trainers", ":", "\n", "\t\t\t\t\t\t", "self", ".", "val_loss_all_tasks", ".", "append", "(", "task_trainer", ".", "val_loss_normalized", ")", "\n", "", "self", ".", "validation_loss", "=", "tf", ".", "reduce_sum", "(", "\n", "[", "loss", "*", "weight", "for", "loss", ",", "weight", "in", "zip", "(", "self", ".", "val_loss_all_tasks", ",", "self", ".", "task_weights", ")", "]", ")", "\n", "\n", "# update the learning rate factor", "\n", "self", ".", "half_lr", "=", "learning_rate_fact", ".", "assign", "(", "learning_rate_fact", "/", "2", ")", ".", "op", "\n", "\n", "# create an operation to updated the validated step", "\n", "self", ".", "update_validated_step", "=", "validated_step", ".", "assign", "(", "self", ".", "global_step", ")", ".", "op", "\n", "\n", "if", "self", ".", "acc_steps", ":", "\n", "# variable to hold the best validation loss so far", "\n", "\t\t\t\t\t\t", "self", ".", "best_validation_all_tasks", "=", "[", "tf", ".", "get_variable", "(", "\n", "name", "=", "'best_validation_task_%i'", "%", "ind", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1.79e+308", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "for", "ind", "in", "range", "(", "nr_val_tasks", ")", "]", "\n", "\n", "# op to update the best validation loss", "\n", "self", ".", "update_best_all_tasks", "=", "[", "\n", "best_val_task", ".", "assign", "(", "self", ".", "val_loss_all_tasks", "[", "ind", "]", ")", "\n", "for", "ind", ",", "best_val_task", "in", "enumerate", "(", "self", ".", "best_validation_all_tasks", ")", "]", "\n", "\n", "# variable to hold the previous validation loss", "\n", "self", ".", "previous_validation_all_tasks", "=", "[", "tf", ".", "get_variable", "(", "\n", "name", "=", "'previous_validation_task_%i'", "%", "ind", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1.79e+308", ")", ",", "\n", "trainable", "=", "False", ")", "for", "ind", "in", "range", "(", "nr_val_tasks", ")", "]", "\n", "\n", "# op to update the previous validation loss", "\n", "self", ".", "update_prev_all_tasks", "=", "[", "\n", "prev_val_task", ".", "assign", "(", "self", ".", "val_loss_all_tasks", "[", "ind", "]", ")", "\n", "for", "ind", ",", "prev_val_task", "in", "enumerate", "(", "self", ".", "previous_validation_all_tasks", ")", "]", "\n", "\n", "# variable to hold the last x relative loss improvements. x=num_tries", "\n", "self", ".", "rel_validation_all_tasks", "=", "[", "tf", ".", "get_variable", "(", "\n", "name", "=", "'rel_validation_task_%i'", "%", "ind", ",", "\n", "shape", "=", "[", "int", "(", "self", ".", "conf", "[", "'num_tries'", "]", ")", "]", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1.79e+308", ")", ",", "\n", "trainable", "=", "False", ")", "for", "ind", "in", "range", "(", "nr_val_tasks", ")", "]", "\n", "\n", "# op to update the relative loss improvements", "\n", "rel_impr", "=", "[", "\n", "(", "self", ".", "previous_validation_all_tasks", "[", "ind", "]", "-", "self", ".", "val_loss_all_tasks", "[", "ind", "]", ")", "/", "\n", "self", ".", "previous_validation_all_tasks", "[", "ind", "]", "for", "ind", "in", "range", "(", "nr_val_tasks", ")", "]", "\n", "all_rel_imprs", "=", "[", "\n", "tf", ".", "concat", "(", "[", "rel_val_task", "[", "1", ":", "]", ",", "tf", ".", "expand_dims", "(", "rel_impr", "[", "ind", "]", ",", "-", "1", ")", "]", ",", "axis", "=", "0", ")", "\n", "for", "ind", ",", "rel_val_task", "in", "enumerate", "(", "self", ".", "rel_validation_all_tasks", ")", "]", "\n", "self", ".", "update_rel_all_tasks", "=", "[", "\n", "tf", ".", "assign", "(", "rel_val_task", ",", "all_rel_imprs", "[", "ind", "]", ")", "\n", "for", "ind", ",", "rel_val_task", "in", "enumerate", "(", "self", ".", "rel_validation_all_tasks", ")", "]", "\n", "\n", "# variable to hold the number of times validation performance was worse", "\n", "self", ".", "num_tries_all_tasks", "=", "[", "tf", ".", "get_variable", "(", "\n", "name", "=", "'num_tries_task_%i'", "%", "ind", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "int32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "0", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "for", "ind", "in", "range", "(", "nr_val_tasks", ")", "]", "\n", "\n", "# op to increment the number of times validation performance was worse", "\n", "self", ".", "incr_num_tries_all_tasks", "=", "[", "\n", "num_tries", ".", "assign", "(", "num_tries", "+", "1", ")", "\n", "for", "ind", ",", "num_tries", "in", "enumerate", "(", "self", ".", "num_tries_all_tasks", ")", "]", "\n", "\n", "# op to reset the number of times validation performance was worse", "\n", "self", ".", "reset_num_tries_all_tasks", "=", "[", "\n", "num_tries", ".", "assign", "(", "0", ")", "\n", "for", "ind", ",", "num_tries", "in", "enumerate", "(", "self", ".", "num_tries_all_tasks", ")", "]", "\n", "\n", "", "else", ":", "\n", "# variable to hold the best validation loss so far", "\n", "\t\t\t\t\t\t", "self", ".", "best_validation", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'best_validation'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1.79e+308", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# op to update the best validation loss", "\n", "self", ".", "update_best", "=", "self", ".", "best_validation", ".", "assign", "(", "self", ".", "validation_loss", ")", "\n", "\n", "# variable to hold the previous validation loss", "\n", "self", ".", "previous_validation", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'previous_validation'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1.79e+308", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# op to update the previous validation loss", "\n", "self", ".", "update_prev", "=", "self", ".", "previous_validation", ".", "assign", "(", "self", ".", "validation_loss", ")", "\n", "\n", "# variable to hold the last x relative loss improvements. x=num_tries", "\n", "self", ".", "rel_validation", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'rel_validation'", ",", "\n", "shape", "=", "[", "int", "(", "self", ".", "conf", "[", "'num_tries'", "]", ")", "]", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1.79e+308", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# op to update the relative loss improvements", "\n", "rel_impr", "=", "(", "self", ".", "previous_validation", "-", "self", ".", "validation_loss", ")", "/", "self", ".", "previous_validation", "\n", "all_rel_imprs", "=", "tf", ".", "concat", "(", "[", "self", ".", "rel_validation", "[", "1", ":", "]", ",", "tf", ".", "expand_dims", "(", "rel_impr", ",", "-", "1", ")", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "update_rel", "=", "tf", ".", "assign", "(", "self", ".", "rel_validation", ",", "all_rel_imprs", ")", "\n", "\n", "# variable to hold the number of times validation performance was worse", "\n", "self", ".", "num_tries", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'num_tries'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "int32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "0", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# op to increment the number of times validation performance was worse", "\n", "self", ".", "incr_num_tries", "=", "self", ".", "num_tries", ".", "assign", "(", "self", ".", "num_tries", "+", "1", ")", "\n", "\n", "# op to reset the number of times validation performance was worse", "\n", "self", ".", "reset_num_tries", "=", "self", ".", "num_tries", ".", "assign", "(", "0", ")", "\n", "\n", "# a variable that holds the amount of workers at the", "\n", "# validation point", "\n", "", "waiting_workers", "=", "tf", ".", "get_variable", "(", "\n", "name", "=", "'waiting_workers'", ",", "\n", "shape", "=", "[", "]", ",", "\n", "dtype", "=", "tf", ".", "int32", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "0", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# an operation to signal a waiting worker", "\n", "self", ".", "waiting", "=", "waiting_workers", ".", "assign_add", "(", "1", ")", ".", "op", "\n", "\n", "# an operation to set the waiting workers to zero", "\n", "self", ".", "reset_waiting", "=", "waiting_workers", ".", "initializer", "\n", "\n", "# an operation to check if all workers are waiting", "\n", "self", ".", "all_waiting", "=", "tf", ".", "equal", "(", "waiting_workers", ",", "num_replicas", "-", "1", ")", "\n", "\n", "# tf.summary.scalar('validation loss', self.validation_loss)", "\n", "\n", "", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "process_val_batch", "=", "None", "\n", "\n", "# tf.summary.scalar('learning rate', self.learning_rate)", "\n", "\n", "# create a histogram for all trainable parameters", "\n", "# for param in tf.trainable_variables():", "\n", "# \ttf.summary.histogram(param.name, param)", "\n", "\n", "# create the scaffold", "\n", "", "self", ".", "scaffold", "=", "tf", ".", "train", ".", "Scaffold", "(", "saver", "=", "tf", ".", "train", ".", "Saver", "(", "max_to_keep", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.trainers.multi_task_trainer.MultiTaskTrainer.train": [[480, 888], ["tensorflow.ConfigProto", "nabu.neuralnetworks.components.hooks.SaveAtEnd", "chief_only_hooks.append", "nabu.neuralnetworks.components.hooks.ValidationSaveHook", "chief_only_hooks.append", "nabu.neuralnetworks.components.hooks.StopHook", "chief_only_hooks.append", "enumerate", "list", "sorted", "nabu.neuralnetworks.components.hooks.LoadAtBegin", "chief_only_hooks.append", "os.path.join", "os.path.join", "set", "multi_task_trainer.MultiTaskTrainer.graph.as_default", "print", "print", "nabu.neuralnetworks.components.sessions.MonitoredTrainingSession", "multi_task_trainer.MultiTaskTrainer.set_num_steps.run", "print", "enumerate", "numpy.sum", "print", "print", "numpy.sum", "numpy.sum", "numpy.sum", "print", "sess.run", "sess.run", "time.time", "sess.run", "sess.run", "range", "sess.run", "any", "print", "os.path.join", "numpy.prod", "sess.should_stop", "multi_task_trainer.MultiTaskTrainer.should_stop.eval", "multi_task_trainer.MultiTaskTrainer.should_validate.eval", "int", "enumerate", "numpy.sum", "sess.run", "numpy.isnan", "multi_task_trainer.MultiTaskTrainer.terminate.run", "BaseException", "len", "enumerate", "enumerate", "multi_task_trainer.get_grad_stats", "v.get_shape().as_list", "tensorflow.trainable_variables", "numpy.prod", "numpy.prod", "numpy.prod", "print", "multi_task_trainer.MultiTaskTrainer.reset_val_loss_norm.run", "time.time", "range", "sess.run", "print", "enumerate", "loss_all_tasks.append", "new_task_param_values.append", "task_params_diff.append", "numpy.mean", "len", "enumerate", "v.get_shape().as_list", "tensorflow.trainable_variables", "v.get_shape().as_list", "tensorflow.trainable_variables", "v.get_shape().as_list", "tensorflow.trainable_variables", "sess.run", "sess.run", "multi_task_trainer.MultiTaskTrainer.process_val_batch.run", "len", "enumerate", "sess.run", "sess.run", "enumerate", "sess.run", "sess.run", "sess.run", "sess.run", "nabu.neuralnetworks.components.hooks.ValidationSaveHook.restore", "multi_task_trainer.MultiTaskTrainer.do_save_final_model.run", "print", "multi_task_trainer.MultiTaskTrainer.terminate.run", "multi_task_trainer.MultiTaskTrainer.reset_waiting.run", "print", "nabu.neuralnetworks.components.hooks.ValidationSaveHook.restore", "multi_task_trainer.MultiTaskTrainer.update_validated_step.run", "print", "multi_task_trainer.MultiTaskTrainer.half_lr.run", "nabu.neuralnetworks.components.hooks.ValidationSaveHook.save", "multi_task_trainer.MultiTaskTrainer.waiting.run", "multi_task_trainer.MultiTaskTrainer.should_stop.eval", "sess.run", "old_task_param_values.append", "old_task_param_values.append", "len", "sess.run", "sess.run", "sess.run", "numpy.mean", "range", "time.time", "numpy.array", "len", "enumerate", "v.get_shape", "print", "sess.run", "sess.run", "sess.run", "multi_task_trainer.MultiTaskTrainer.all_waiting.eval", "time.sleep", "numpy.sum", "multi_task_trainer.MultiTaskTrainer.reset_waiting.run", "nabu.neuralnetworks.components.hooks.ValidationSaveHook.save", "sess.run", "multi_task_trainer.MultiTaskTrainer.reset_waiting.run", "nabu.neuralnetworks.components.hooks.ValidationSaveHook.save", "multi_task_trainer.MultiTaskTrainer.should_validate.eval", "time.sleep", "numpy.abs", "len", "v.get_shape", "v.name.split", "v.get_shape", "v.name.split", "v.get_shape", "v.name.split", "time.time", "print", "sess.run", "sess.run", "sess.run", "sess.run", "print", "sess.run", "sess.run", "multi_task_trainer.MultiTaskTrainer.should_stop.eval", "numpy.mean", "range", "numpy.mean", "sess.run", "print", "sess.run", "int", "numpy.sum", "numpy.abs", "len", "numpy.array", "int", "numpy.sum", "numpy.abs", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.sessions.MonitoredTrainingSession", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.trainers.multi_task_trainer.get_grad_stats"], ["", "", "def", "train", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"train the model\"\"\"", "\n", "\n", "# start the session and standard services", "\n", "config", "=", "tf", ".", "ConfigProto", "(", "device_count", "=", "{", "'CPU'", ":", "1", "}", ")", "\n", "config", ".", "gpu_options", ".", "allow_growth", "=", "True", "\n", "config", ".", "allow_soft_placement", "=", "True", "\n", "# config.log_device_placement = True", "\n", "\n", "# added this 2 lines to fix a \"AlreadyExistsError\" encountered when training", "\n", "# \"config/recipes_Jeroen_Default17/DBLSTM/dialogue_sepNTMAnch_DANet_4spk\".", "\n", "# See https://github.com/tensorflow/tensorflow/issues/23780", "\n", "# off = rewriter_config_pb2.RewriterConfig.OFF", "\n", "# config.graph_options.rewrite_options.arithmetic_optimization = off", "\n", "# config.graph_options.rewrite_options.memory_optimization = off", "\n", "\n", "chief_only_hooks", "=", "[", "]", "\n", "\n", "if", "self", ".", "init_filename", "is", "not", "None", ":", "\n", "\t\t\t", "init_hook", "=", "hooks", ".", "LoadAtBegin", "(", "self", ".", "init_filename", ",", "self", ".", "models", ")", "\n", "chief_only_hooks", ".", "append", "(", "init_hook", ")", "\n", "\n", "# create a hook for saving the final model", "\n", "", "save_hook", "=", "hooks", ".", "SaveAtEnd", "(", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "expdir", ",", "'model'", ",", "'network.ckpt'", ")", ",", "\n", "self", ".", "models", ",", "\n", "self", ".", "should_save_final_model", ")", "\n", "chief_only_hooks", ".", "append", "(", "save_hook", ")", "\n", "\n", "# create a hook for saving and restoring the validated model", "\n", "validation_hook", "=", "hooks", ".", "ValidationSaveHook", "(", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "expdir", ",", "'logdir'", ",", "'validated.ckpt'", ")", ",", "\n", "self", ".", "models", ")", "\n", "chief_only_hooks", ".", "append", "(", "validation_hook", ")", "\n", "\n", "stop_hook", "=", "hooks", ".", "StopHook", "(", "self", ".", "done", ")", "\n", "chief_only_hooks", ".", "append", "(", "stop_hook", ")", "\n", "\n", "# determine all parameters", "\n", "all_params", "=", "[", "]", "\n", "for", "ind", ",", "_", "in", "enumerate", "(", "self", ".", "task_trainers", ")", ":", "\n", "\t\t\t", "all_params", "+=", "self", ".", "task_trainers", "[", "ind", "]", ".", "params", "\n", "", "all_params", "=", "list", "(", "set", "(", "all_params", ")", ")", "\n", "all_params", "=", "sorted", "(", "all_params", ",", "key", "=", "lambda", "par", ":", "par", ".", "name", ")", "\n", "\n", "with", "self", ".", "graph", ".", "as_default", "(", ")", ":", "\n", "# with tf.train.MonitoredTrainingSession(", "\n", "# \tcheckpoint_dir=os.path.join(self.expdir, 'logdir'),", "\n", "# \tscaffold=self.scaffold,", "\n", "# \thooks=chief_only_hooks,", "\n", "# \tchief_only_hooks=chief_only_hooks,", "\n", "# \tsave_summaries_steps=None,", "\n", "# \tsave_summaries_secs=None,", "\n", "# \tconfig=config) as sess:", "\n", "\t\t\t", "with", "nabu_sessions", ".", "MonitoredTrainingSession", "(", "\n", "checkpoint_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "expdir", ",", "'logdir'", ")", ",", "\n", "scaffold", "=", "self", ".", "scaffold", ",", "\n", "hooks", "=", "chief_only_hooks", ",", "\n", "# chief_only_hooks=chief_only_hooks,", "\n", "save_summaries_steps", "=", "None", ",", "\n", "save_summaries_secs", "=", "None", ",", "\n", "config", "=", "config", ")", "as", "sess", ":", "\n", "\n", "# set the number of steps", "\n", "\t\t\t\t", "self", ".", "set_num_steps", ".", "run", "(", "session", "=", "sess", ")", "\n", "\n", "# print the params that will be updated", "\n", "print", "(", "'parameters that will be trained:'", ")", "\n", "for", "ind", ",", "param", "in", "enumerate", "(", "all_params", ")", ":", "\n", "\t\t\t\t\t", "print", "(", "'param ind %i: %s'", "%", "(", "ind", ",", "param", ".", "name", ")", ")", "\n", "", "param_count", "=", "np", ".", "sum", "(", "[", "np", ".", "prod", "(", "v", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "for", "v", "in", "tf", ".", "trainable_variables", "(", ")", "]", ")", "\n", "print", "(", "'Trainable parameter count is %d'", "%", "param_count", ")", "\n", "try", ":", "\n", "\t\t\t\t\t", "cnn_param_count", "=", "np", ".", "sum", "(", "[", "\n", "np", ".", "prod", "(", "v", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "for", "v", "in", "tf", ".", "trainable_variables", "(", ")", "\n", "if", "v", ".", "name", ".", "split", "(", "'/'", ")", "[", "0", "]", "==", "'main'", "]", ")", "\n", "lstm_param_count", "=", "np", ".", "sum", "(", "[", "\n", "np", ".", "prod", "(", "v", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "for", "v", "in", "tf", ".", "trainable_variables", "(", ")", "\n", "if", "v", ".", "name", ".", "split", "(", "'/'", ")", "[", "0", "]", "==", "'aux_lstm'", "]", ")", "\n", "ff_param_count", "=", "np", ".", "sum", "(", "[", "\n", "np", ".", "prod", "(", "v", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "for", "v", "in", "tf", ".", "trainable_variables", "(", ")", "\n", "if", "v", ".", "name", ".", "split", "(", "'/'", ")", "[", "0", "]", "in", "[", "'feedforward'", ",", "'outlayer'", "]", "]", ")", "\n", "print", "(", "'%d for main, %d for auxilary LSTM, %d for feedforward and output layer'", "%", "(", "cnn_param_count", ",", "lstm_param_count", ",", "ff_param_count", ")", ")", "\n", "", "except", ":", "\n", "\t\t\t\t\t", "pass", "\n", "\n", "# get the previous best validation loss for each validation task", "\n", "", "if", "self", ".", "acc_steps", ":", "\n", "\t\t\t\t\t", "prev_best_val_loss_all_tasks", "=", "sess", ".", "run", "(", "self", ".", "best_validation_all_tasks", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "prev_best_val_loss", "=", "sess", ".", "run", "(", "self", ".", "best_validation", ")", "\n", "\n", "# start the training loop", "\n", "# pylint: disable=E1101", "\n", "", "while", "not", "(", "sess", ".", "should_stop", "(", ")", "or", "self", ".", "should_stop", ".", "eval", "(", "session", "=", "sess", ")", ")", ":", "\n", "## Validation part", "\n", "# check if validation is due", "\n", "\t\t\t\t\t", "if", "self", ".", "process_val_batch", "is", "not", "None", "and", "self", ".", "should_validate", ".", "eval", "(", "session", "=", "sess", ")", ":", "\n", "\t\t\t\t\t\t", "if", "self", ".", "is_chief", ":", "\n", "\t\t\t\t\t\t\t", "print", "(", "'Validating model'", ")", "\n", "\n", "# get the previous best validation loss for each validation task", "\n", "if", "self", ".", "acc_steps", ":", "\n", "\t\t\t\t\t\t\t\t", "prev_best_val_loss_all_tasks", "=", "sess", ".", "run", "(", "self", ".", "best_validation_all_tasks", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t", "prev_best_val_loss", "=", "sess", ".", "run", "(", "self", ".", "best_validation", ")", "\n", "\n", "# reset the validation loss", "\n", "", "self", ".", "reset_val_loss_norm", ".", "run", "(", "session", "=", "sess", ")", "\n", "\n", "# start time", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "# compute the validation loss", "\n", "for", "_", "in", "range", "(", "self", ".", "valbatches", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "process_val_batch", ".", "run", "(", "session", "=", "sess", ")", "\n", "\n", "# get the current validation loss", "\n", "", "[", "validation_loss", ",", "val_loss_all_tasks", "]", "=", "sess", ".", "run", "(", "\n", "[", "self", ".", "validation_loss", ",", "self", ".", "val_loss_all_tasks", "]", ")", "\n", "\n", "print_str", "=", "(", "\n", "'validation loss:%.6g, time: %f sec'", "%", "\n", "(", "validation_loss", ",", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "# if multiple tasks, also print individual task losses", "\n", "if", "len", "(", "val_loss_all_tasks", ")", ">", "1", ":", "\n", "\t\t\t\t\t\t\t\t", "for", "ind", ",", "loss_task", "in", "enumerate", "(", "val_loss_all_tasks", ")", ":", "\n", "\t\t\t\t\t\t\t\t\t", "print_str", "+=", "(", "\n", "', task_loss %s: %.6g'", "%", "\n", "(", "self", ".", "task_trainers", "[", "ind", "]", ".", "task_name", ",", "loss_task", ")", ")", "\n", "", "", "print", "(", "print_str", ")", "\n", "\n", "if", "self", ".", "acc_steps", ":", "\n", "# update the relative validation improvements", "\n", "\t\t\t\t\t\t\t\t", "sess", ".", "run", "(", "self", ".", "update_rel_all_tasks", ")", "\n", "rel_val_loss_all_tasks", "=", "sess", ".", "run", "(", "self", ".", "rel_validation_all_tasks", ")", "\n", "\n", "# check if the validation loss is better, for every task", "\n", "terminate_train", "=", "False", "\n", "restore_validation", "=", "False", "\n", "continue_validation", "=", "True", "\n", "do_halve_lr", "=", "False", "\n", "for", "task_ind", ",", "val_task", "in", "enumerate", "(", "self", ".", "val_task_trainers", ")", ":", "\n", "\t\t\t\t\t\t\t\t\t", "if", "val_loss_all_tasks", "[", "task_ind", "]", ">=", "prev_best_val_loss_all_tasks", "[", "task_ind", "]", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "print", "(", "'Validation loss is worse for %s!'", "%", "val_task", ".", "task_name", ")", "\n", "\n", "# check how many times validation performance was", "\n", "# worse", "\n", "sess", ".", "run", "(", "self", ".", "incr_num_tries_all_tasks", "[", "task_ind", "]", ")", "\n", "if", "self", ".", "conf", "[", "'num_tries'", "]", "!=", "'None'", ":", "\n", "\t\t\t\t\t\t\t\t\t\t\t", "num_tries", "=", "sess", ".", "run", "(", "self", ".", "num_tries_all_tasks", "[", "task_ind", "]", ")", "\n", "if", "num_tries", "==", "int", "(", "self", ".", "conf", "[", "'num_tries'", "]", ")", ":", "\n", "\t\t\t\t\t\t\t\t\t\t\t\t", "terminate_train", "=", "True", "\n", "", "", "global_step", "=", "sess", ".", "run", "(", "self", ".", "global_step", ")", "\n", "if", "global_step", ">", "1000", "and", "np", ".", "sum", "(", "np", ".", "abs", "(", "rel_val_loss_all_tasks", "[", "task_ind", "]", ")", ")", "<", "0.004", ":", "\n", "\t\t\t\t\t\t\t\t\t\t\t", "print", "(", "'Relative improvements are becoming to small. Terminating training.'", ")", "\n", "terminate_train", "=", "True", "\n", "\n", "", "if", "self", ".", "conf", "[", "'go_back'", "]", "==", "'True'", ":", "\n", "\t\t\t\t\t\t\t\t\t\t\t", "continue_validation", "=", "False", "\n", "restore_validation", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t\t\t\t", "continue_validation", "=", "True", "\n", "\n", "", "if", "self", ".", "conf", "[", "'valid_adapt'", "]", "==", "'True'", ":", "\n", "\t\t\t\t\t\t\t\t\t\t\t", "do_halve_lr", "=", "True", "\n", "\n", "", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "sess", ".", "run", "(", "self", ".", "update_best_all_tasks", "[", "task_ind", "]", ")", "\n", "prev_best_val_loss_all_tasks", "[", "task_ind", "]", "=", "val_loss_all_tasks", "[", "task_ind", "]", "\n", "if", "self", ".", "conf", "[", "'reset_tries'", "]", "==", "'True'", ":", "\n", "\t\t\t\t\t\t\t\t\t\t\t", "sess", ".", "run", "(", "self", ".", "reset_num_tries_all_tasks", "[", "task_ind", "]", ")", "\n", "\n", "", "", "", "sess", ".", "run", "(", "self", ".", "update_prev_all_tasks", ")", "\n", "", "else", ":", "\n", "# update the relative validation improvement", "\n", "\t\t\t\t\t\t\t\t", "sess", ".", "run", "(", "self", ".", "update_rel", ")", "\n", "rel_val_loss", "=", "sess", ".", "run", "(", "self", ".", "rel_validation", ")", "\n", "\n", "# check if the validation loss is better", "\n", "terminate_train", "=", "False", "\n", "restore_validation", "=", "False", "\n", "continue_validation", "=", "True", "\n", "do_halve_lr", "=", "False", "\n", "\n", "if", "validation_loss", ">=", "prev_best_val_loss", ":", "\n", "\t\t\t\t\t\t\t\t\t", "print", "(", "'Validation loss is worse!'", ")", "\n", "\n", "# check how many times validation performance was worse", "\n", "sess", ".", "run", "(", "self", ".", "incr_num_tries", ")", "\n", "if", "self", ".", "conf", "[", "'num_tries'", "]", "!=", "'None'", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "num_tries", "=", "sess", ".", "run", "(", "self", ".", "num_tries", ")", "\n", "if", "num_tries", "==", "int", "(", "self", ".", "conf", "[", "'num_tries'", "]", ")", ":", "\n", "\t\t\t\t\t\t\t\t\t\t\t", "terminate_train", "=", "True", "\n", "", "", "global_step", "=", "sess", ".", "run", "(", "self", ".", "global_step", ")", "\n", "if", "global_step", ">", "1000", "and", "np", ".", "sum", "(", "np", ".", "abs", "(", "rel_val_loss", ")", ")", "<", "0.004", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "print", "(", "'Relative improvements are becoming to small. Terminating training.'", ")", "\n", "terminate_train", "=", "True", "\n", "\n", "", "if", "self", ".", "conf", "[", "'go_back'", "]", "==", "'True'", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "continue_validation", "=", "False", "\n", "restore_validation", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "continue_validation", "=", "True", "\n", "\n", "", "if", "self", ".", "conf", "[", "'valid_adapt'", "]", "==", "'True'", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "do_halve_lr", "=", "True", "\n", "\n", "", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t\t", "sess", ".", "run", "(", "self", ".", "update_best", ")", "\n", "prev_best_val_loss", "=", "validation_loss", "\n", "if", "self", ".", "conf", "[", "'reset_tries'", "]", "==", "'True'", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "sess", ".", "run", "(", "self", ".", "reset_num_tries", ")", "\n", "\n", "", "", "sess", ".", "run", "(", "self", ".", "update_prev", ")", "\n", "\n", "# decide what to do for training based on the above task validations", "\n", "", "if", "terminate_train", ":", "\n", "\t\t\t\t\t\t\t\t", "validation_hook", ".", "restore", "(", ")", "\n", "self", ".", "do_save_final_model", ".", "run", "(", "session", "=", "sess", ")", "\n", "print", "(", "'Terminating training'", ")", "\n", "self", ".", "terminate", ".", "run", "(", "session", "=", "sess", ")", "\n", "break", "\n", "\n", "", "if", "restore_validation", ":", "\n", "# wait untill all workers are at validation", "\n", "# point", "\n", "\t\t\t\t\t\t\t\t", "while", "not", "self", ".", "all_waiting", ".", "eval", "(", "\n", "session", "=", "sess", ")", ":", "\n", "\t\t\t\t\t\t\t\t\t", "time", ".", "sleep", "(", "1", ")", "\n", "", "self", ".", "reset_waiting", ".", "run", "(", "session", "=", "sess", ")", "\n", "\n", "print", "(", "'Loading previous model'", ")", "\n", "\n", "# load the previous model", "\n", "validation_hook", ".", "restore", "(", ")", "\n", "\n", "", "if", "continue_validation", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "update_validated_step", ".", "run", "(", "session", "=", "sess", ")", "\n", "\n", "", "if", "do_halve_lr", ":", "\n", "\t\t\t\t\t\t\t\t", "print", "(", "'Halving learning rate'", ")", "\n", "self", ".", "half_lr", ".", "run", "(", "session", "=", "sess", ")", "\n", "validation_hook", ".", "save", "(", ")", "\n", "\n", "#", "\n", "", "if", "self", ".", "acc_steps", ":", "\n", "\t\t\t\t\t\t\t\t", "if", "np", ".", "sum", "(", "sess", ".", "run", "(", "self", ".", "num_tries_all_tasks", ")", ")", "==", "0", ":", "\n", "\t\t\t\t\t\t\t\t\t", "self", ".", "reset_waiting", ".", "run", "(", "session", "=", "sess", ")", "\n", "\n", "# store the validated model", "\n", "validation_hook", ".", "save", "(", ")", "\n", "", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t", "if", "sess", ".", "run", "(", "self", ".", "num_tries", ")", "==", "0", ":", "\n", "\t\t\t\t\t\t\t\t\t", "self", ".", "reset_waiting", ".", "run", "(", "session", "=", "sess", ")", "\n", "\n", "# store the validated model", "\n", "validation_hook", ".", "save", "(", ")", "\n", "\n", "", "", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "if", "self", ".", "conf", "[", "'go_back'", "]", "==", "'True'", "and", "self", ".", "process_val_batch", "is", "not", "None", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "waiting", ".", "run", "(", "session", "=", "sess", ")", "\n", "while", "(", "\n", "self", ".", "should_validate", ".", "eval", "(", "session", "=", "sess", ")", "and", "\n", "not", "self", ".", "should_stop", ".", "eval", "(", "session", "=", "sess", ")", ")", ":", "\n", "\t\t\t\t\t\t\t\t\t", "time", ".", "sleep", "(", "1", ")", "\n", "\n", "", "if", "self", ".", "should_stop", ".", "eval", "(", "session", "=", "sess", ")", ":", "\n", "\t\t\t\t\t\t\t\t\t", "break", "\n", "\n", "## Training part", "\n", "# start time", "\n", "", "", "", "", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "# reset the gradients for the next step", "\n", "sess", ".", "run", "(", "fetches", "=", "[", "self", ".", "reset_grad_loss_norm", "]", ")", "\n", "\n", "old_param_values", "=", "sess", ".", "run", "(", "all_params", ")", "\n", "\n", "# First, accumulate the gradients as often as requested for each linkedset in each task trainer.", "\n", "for", "_", "in", "range", "(", "int", "(", "self", ".", "conf", "[", "'numbatches_to_aggregate'", "]", ")", ")", ":", "\n", "\t\t\t\t\t\t", "for", "task_trainer", "in", "self", ".", "task_trainers", ":", "\n", "\t\t\t\t\t\t\t", "for", "set_ind", ",", "linkedset", "in", "enumerate", "(", "task_trainer", ".", "linkedsets", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "_", "=", "sess", ".", "run", "(", "[", "task_trainer", ".", "process_minibatch", "[", "set_ind", "]", "]", ")", "\n", "\n", "# # First, accumulate the gradients", "\n", "# for _ in range(int(self.conf['numbatches_to_aggregate'])):", "\n", "# \t_ = sess.run([self.process_minibatch])", "\n", "\n", "# Then, normalize the gradients", "\n", "", "", "", "_", "=", "sess", ".", "run", "(", "[", "self", ".", "normalize_gradients", "]", ")", "\n", "\n", "if", "self", ".", "acc_steps", ":", "\n", "# Finally, apply the gradients for each task optimizer. Get the variable values before", "\n", "# and after the update, so stepsizes for each task can be displayed.", "\n", "\t\t\t\t\t\t", "old_task_param_values", "=", "[", "]", "\n", "new_task_param_values", "=", "[", "]", "\n", "task_params_diff", "=", "[", "]", "\n", "loss_all_tasks", "=", "[", "]", "\n", "\n", "for", "ind", ",", "task_trainer", "in", "enumerate", "(", "self", ".", "task_trainers", ")", ":", "\n", "# get the variable values before update", "\n", "\t\t\t\t\t\t\t", "if", "ind", "==", "0", ":", "\n", "\t\t\t\t\t\t\t\t", "old_task_param_values", ".", "append", "(", "old_param_values", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t", "old_task_param_values", ".", "append", "(", "new_task_param_values", "[", "ind", "-", "1", "]", ")", "\n", "\n", "# Apply the gradients in the task optimizer and get the task loss. If it is the last", "\n", "# task, also get some other stuff", "\n", "", "if", "ind", "+", "1", "<", "len", "(", "self", ".", "task_trainers", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "[", "_", ",", "task_loss", "]", "=", "sess", ".", "run", "(", "[", "task_trainer", ".", "apply_gradients", ",", "task_trainer", ".", "normalized_loss", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t\t", "_", ",", "_", ",", "task_loss", ",", "lr", ",", "global_step", ",", "num_steps", "=", "sess", ".", "run", "(", "fetches", "=", "[", "\n", "task_trainer", ".", "apply_gradients", ",", "\n", "self", ".", "other_update_op", ",", "\n", "task_trainer", ".", "normalized_loss", ",", "\n", "self", ".", "learning_rate", ",", "\n", "self", ".", "global_step", ",", "\n", "self", ".", "num_steps", "]", ")", "\n", "", "loss_all_tasks", ".", "append", "(", "task_loss", ")", "\n", "# get the variable values after update", "\n", "new_task_param_values", ".", "append", "(", "sess", ".", "run", "(", "all_params", ")", ")", "\n", "\n", "# Calculate the stepsize for each variable by calculating the difference between old", "\n", "# and new variable values. Average this per variable type (eg weights layer 1) and average.", "\n", "# Also multiply with 10000 (this is just for printing format purposes)", "\n", "task_params_diff", ".", "append", "(", "[", "\n", "10000.0", "*", "np", ".", "mean", "(", "np", ".", "abs", "(", "new_task_param_values", "[", "ind", "]", "[", "par_ind", "]", "-", "old_task_param_values", "[", "ind", "]", "[", "par_ind", "]", ")", ")", "\n", "for", "par_ind", "in", "range", "(", "len", "(", "new_task_param_values", "[", "ind", "]", ")", ")", "]", ")", "\n", "\n", "# Calculate loss and step size over all task optimizations", "\n", "", "loss", "=", "np", ".", "sum", "(", "loss_all_tasks", ")", "\n", "new_param_values", "=", "new_task_param_values", "[", "-", "1", "]", "\n", "params_diff", "=", "[", "\n", "10000.0", "*", "np", ".", "mean", "(", "np", ".", "abs", "(", "new_param_values", "[", "ind", "]", "-", "old_param_values", "[", "ind", "]", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "new_param_values", ")", ")", "]", "\n", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "grads", ",", "_", ",", "_", ",", "loss", ",", "loss_all_tasks", ",", "lr", ",", "global_step", ",", "num_steps", "=", "sess", ".", "run", "(", "fetches", "=", "[", "\n", "[", "grad", "for", "grad", ",", "var", "in", "self", ".", "batch_grads_and_vars", "]", ",", "\n", "self", ".", "apply_gradients", ",", "\n", "self", ".", "other_update_op", ",", "\n", "self", ".", "total_loss", ",", "\n", "[", "task_trainer", ".", "normalized_loss", "for", "task_trainer", "in", "self", ".", "task_trainers", "]", ",", "\n", "self", ".", "learning_rate", ",", "\n", "self", ".", "global_step", ",", "\n", "self", ".", "num_steps", "]", ")", "\n", "\n", "", "if", "any", "(", "np", ".", "isnan", "(", "loss_all_tasks", ")", ")", ":", "\n", "\t\t\t\t\t\t", "self", ".", "terminate", ".", "run", "(", "session", "=", "sess", ")", "\n", "raise", "BaseException", "(", "'Terminating training because loss became \"Not A Number\". Best model will not be saved.'", ")", "\n", "## Output prompt", "\n", "# Start the printing string with most important information", "\n", "", "print_str", "=", "'step %d/%d loss: %.6g, learning rate: %f, time: %.2f sec'", "%", "(", "global_step", ",", "num_steps", ",", "loss", ",", "lr", ",", "time", ".", "time", "(", ")", "-", "start", ")", "\n", "\n", "# if multiple tasks, also print individual task losses", "\n", "if", "len", "(", "loss_all_tasks", ")", ">", "1", ":", "\n", "\t\t\t\t\t\t", "print_str", "+=", "' ('", "\n", "for", "ind", ",", "loss_task", "in", "enumerate", "(", "loss_all_tasks", ")", ":", "\n", "\t\t\t\t\t\t\t", "print_str", "+=", "(", "'%s: %.6g. '", "%", "(", "self", ".", "task_trainers", "[", "ind", "]", ".", "task_name", ",", "loss_task", ")", ")", "\n", "", "print_str", "+=", "')'", "\n", "\n", "", "if", "'print_var_updates'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'print_var_updates'", "]", "==", "'True'", ":", "\n", "# print the average variable step size", "\n", "\t\t\t\t\t\t", "print_str", "+=", "'\\n Av param upd (*10000): %.3f'", "%", "np", ".", "mean", "(", "np", ".", "array", "(", "params_diff", ")", ")", "\n", "# if multiple tasks, also print individual task average variable step size", "\n", "if", "len", "(", "task_params_diff", ")", ">", "1", ":", "\n", "\t\t\t\t\t\t\t", "print_str", "+=", "' ('", "\n", "for", "ind", ",", "task_param_diff", "in", "enumerate", "(", "task_params_diff", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "print_str", "+=", "'%s: %.3f; '", "%", "(", "\n", "self", ".", "task_trainers", "[", "ind", "]", ".", "task_name", ",", "\n", "np", ".", "mean", "(", "np", ".", "array", "(", "task_param_diff", ")", ")", ")", "\n", "", "print_str", "+=", "')'", "\n", "\n", "# For each variable type (eg weights layer 1) print the average step size", "\n", "", "print_str", "+=", "' ('", "\n", "for", "par_ind", ",", "param", "in", "enumerate", "(", "all_params", ")", ":", "\n", "\t\t\t\t\t\t\t", "if", "par_ind", ">", "0", ":", "\n", "\t\t\t\t\t\t\t\t", "print_str", "+=", "';'", "\n", "", "print_str", "+=", "(", "'%i: %.3f '", "%", "(", "par_ind", ",", "params_diff", "[", "par_ind", "]", ")", ")", "\n", "# if multiple tasks, also print for each variable type the individual task average step size", "\n", "if", "len", "(", "task_params_diff", ")", ">", "1", ":", "\n", "\t\t\t\t\t\t\t\t", "print_str", "+=", "'{'", "\n", "for", "ind", ",", "task_param_diff", "in", "enumerate", "(", "task_params_diff", ")", ":", "\n", "\t\t\t\t\t\t\t\t\t", "if", "ind", ">", "0", ":", "\n", "\t\t\t\t\t\t\t\t\t\t", "print_str", "+=", "'+'", "\n", "", "print_str", "+=", "(", "'%.3f'", "%", "task_param_diff", "[", "par_ind", "]", ")", "\n", "", "print_str", "+=", "'} '", "\n", "", "", "print_str", "+=", "')'", "\n", "\n", "", "if", "'print_grads_stats'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'print_grads_stats'", "]", "==", "'True'", ":", "\n", "\t\t\t\t\t\t", "print_str", "+=", "get_grad_stats", "(", "grads", ",", "var_names", "=", "[", "var", ".", "name", "for", "_", ",", "var", "in", "self", ".", "batch_grads_and_vars", "]", ")", "\n", "\n", "# print the complete string", "\n", "", "print", "(", "print_str", ")", "\n", "\n", "", "", "", "if", "self", ".", "acc_steps", ":", "\n", "\t\t\t", "print", "(", "prev_best_val_loss_all_tasks", ")", "\n", "return", "prev_best_val_loss_all_tasks", "\n", "", "else", ":", "\n", "\t\t\t", "print", "(", "prev_best_val_loss", ")", "\n", "return", "prev_best_val_loss", "\n", "# return prev_best_val_loss_all_tasks, self.tasks", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.trainers.multi_task_trainer.get_grad_stats": [[891, 917], ["numpy.concatenate", "numpy.min", "numpy.max", "numpy.mean", "numpy.std", "zip", "numpy.reshape", "numpy.abs", "numpy.min", "numpy.max", "numpy.mean", "numpy.std", "numpy.abs"], "function", ["None"], ["", "", "", "def", "get_grad_stats", "(", "grads", ",", "var_names", ")", ":", "\n", "\t", "print_str", "=", "\"\"", "\n", "abs_flat_grads", "=", "[", "np", ".", "reshape", "(", "np", ".", "abs", "(", "grad", ")", ",", "-", "1", ")", "for", "grad", "in", "grads", "]", "\n", "all_abs_grads", "=", "np", ".", "concatenate", "(", "abs_flat_grads", ")", "\n", "\n", "min_all_abs_grad", "=", "np", ".", "min", "(", "all_abs_grads", ")", "\n", "max_all_abs_grad", "=", "np", ".", "max", "(", "all_abs_grads", ")", "\n", "mean_all_abs_grad", "=", "np", ".", "mean", "(", "all_abs_grads", ")", "\n", "std_all_abs_grad", "=", "np", ".", "std", "(", "all_abs_grads", ")", "\n", "\n", "print_str", "+=", "'\\n all: min_abs=%.2E, max_abs=%.2E, mean_abs=%.2E, std_abs=%.2E \\n'", "%", "(", "min_all_abs_grad", ",", "max_all_abs_grad", ",", "mean_all_abs_grad", ",", "std_all_abs_grad", ")", "\n", "\n", "for", "grad", ",", "var_name", "in", "zip", "(", "grads", ",", "var_names", ")", ":", "\n", "\t\t", "abs_grad", "=", "np", ".", "abs", "(", "grad", ")", "\n", "min_abs_grad", "=", "np", ".", "min", "(", "abs_grad", ")", "\n", "max_abs_grad", "=", "np", ".", "max", "(", "abs_grad", ")", "\n", "mean_abs_grad", "=", "np", ".", "mean", "(", "abs_grad", ")", "\n", "std_abs_grad", "=", "np", ".", "std", "(", "abs_grad", ")", "\n", "\n", "print_str", "+=", "'\\t %s: min_abs=%.2E, max_abs=%.2E, mean_abs=%.2E, std_abs=%.2E \\n'", "%", "(", "var_name", ",", "min_abs_grad", ",", "max_abs_grad", ",", "mean_abs_grad", ",", "std_abs_grad", ")", "\n", "\n", "", "return", "print_str", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.trainers.trainer_factory.factory": [[7, 22], ["Exception"], "function", ["None"], ["def", "factory", "(", "train_type", "=", "'single_task'", ")", ":", "\n", "\t", "\"\"\"\n\tgets a trainer class\n\n\tArgs:\n\t\ttrain_type: the trainer type\n\n\tReturns:\n\t\ta trainer class\n\t\"\"\"", "\n", "\n", "if", "train_type", "==", "'multi_task'", ":", "\n", "\t\t", "return", "multi_task_trainer", ".", "MultiTaskTrainer", "\n", "", "else", ":", "\n", "\t\t", "raise", "Exception", "(", "'Undefined trainer type: %s'", "%", "train_type", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dlstm.DLSTM._get_outputs": [[13, 97], ["int", "int", "float", "range", "float", "int", "lstm_layers.append", "len", "tensorflow.variable_scope", "range", "math.ceil", "range", "nabu.neuralnetworks.components.layer.LSTMLayer", "len", "float", "tensorflow.random_normal", "tensorflow.nn.dropout", "len", "BaseException", "Exception", "tensorflow.shape", "str", "float", "float", "output.get_shape", "float"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "# the lstm layer", "\n", "num_layers", "=", "int", "(", "self", ".", "conf", "[", "'num_layers'", "]", ")", "\n", "num_units_first_layer", "=", "int", "(", "self", ".", "conf", "[", "'num_units'", "]", ")", "\n", "if", "'fac_per_layer'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "fac_per_layer", "=", "float", "(", "self", ".", "conf", "[", "'fac_per_layer'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "fac_per_layer", "=", "1.0", "\n", "", "num_units", "=", "[", "\n", "int", "(", "math", ".", "ceil", "(", "num_units_first_layer", "*", "(", "fac_per_layer", "**", "l", ")", ")", ")", "\n", "for", "l", "in", "range", "(", "num_layers", ")", "]", "\n", "\n", "layer_norm", "=", "self", ".", "conf", "[", "'layer_norm'", "]", "==", "'True'", "\n", "recurrent_dropout", "=", "float", "(", "self", ".", "conf", "[", "'recurrent_dropout'", "]", ")", "\n", "if", "'activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "\n", "", "if", "'only_last_frame'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "only_last_frame", "=", "self", ".", "conf", "[", "'only_last_frame'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "only_last_frame", "=", "False", "\n", "\n", "", "lstm_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_layers", ")", ":", "\n", "\t\t\t", "lstm_layers", ".", "append", "(", "layer", ".", "LSTMLayer", "(", "\n", "num_units", "=", "num_units", "[", "l", "]", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "activation_fn", "=", "activation_fn", ")", ")", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of DLSTM expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "", "if", "num_layers", "==", "0", ":", "\n", "\t\t\t", "output", "=", "inputs", "\n", "return", "output", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "for", "l", "in", "range", "(", "num_layers", ")", ":", "\n", "\t\t\t\t", "logits", "=", "lstm_layers", "[", "l", "]", "(", "logits", ",", "input_seq_length", ",", "'layer'", "+", "str", "(", "l", ")", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t", "logits", "=", "tf", ".", "nn", ".", "dropout", "(", "logits", ",", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", ")", "\n", "\n", "", "", "output", "=", "logits", "\n", "\n", "if", "only_last_frame", ":", "\n", "\t\t\t\t", "if", "len", "(", "output", ".", "get_shape", "(", ")", ")", "!=", "3", ":", "\n", "\t\t\t\t\t", "raise", "BaseException", "(", "'Not yet implemented for rank different from 3'", ")", "\n", "", "output", "=", "output", "[", ":", ",", "-", "1", ",", ":", "]", "\n", "\n", "", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.permute_stacker.PermuteStacker._get_outputs": [[13, 44], ["int", "int", "len", "tensorflow.variable_scope", "list", "tensorflow.concat", "len", "input.get_shape", "itertools.permutations", "tensorflow.gather", "range"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tpermutes and stacks the inputs\n\n\t\tArgs:\n\t\t\tinputs: the inputs to concatenate, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors and/or [batch_size x ...] tensors\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, the reshaped input\n\t\t\"\"\"", "\n", "\n", "permute_dim", "=", "int", "(", "self", ".", "conf", "[", "'permute_dim'", "]", ")", "\n", "stack_dim", "=", "int", "(", "self", ".", "conf", "[", "'stack_dim'", "]", ")", "\n", "\n", "# code not available for multiple inputs!!", "\n", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of PermuteStacker expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "input", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "permute_dim_size", "=", "input", ".", "get_shape", "(", ")", "[", "permute_dim", "]", "\n", "permutations", "=", "list", "(", "itertools", ".", "permutations", "(", "range", "(", "permute_dim_size", ")", ",", "permute_dim_size", ")", ")", "\n", "\n", "all_inp_perms", "=", "[", "tf", ".", "gather", "(", "input", ",", "perm", ",", "axis", "=", "permute_dim", ")", "for", "perm", "in", "permutations", "]", "\n", "output", "=", "tf", ".", "concat", "(", "all_inp_perms", ",", "axis", "=", "stack_dim", ")", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.reshaper.Reshaper._get_outputs": [[12, 45], ["map", "int", "reshaper.Reshaper.conf[].split", "len", "tensorflow.variable_scope", "tensorflow.shape", "tensorflow.concat", "tensorflow.reshape", "len"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\treshapes the inputs\n\n\t\tArgs:\n\t\t\tinputs: the inputs to concatenate, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors and/or [batch_size x ...] tensors\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, the reshaped input\n\t\t\"\"\"", "\n", "\n", "requested_shape", "=", "map", "(", "int", ",", "self", ".", "conf", "[", "'requested_shape'", "]", ".", "split", "(", "' '", ")", ")", "\n", "reshape_dim", "=", "int", "(", "self", ".", "conf", "[", "'reshape_dim'", "]", ")", "\n", "\n", "# code not available for multiple inputs!!", "\n", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of Reshaper expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "input", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "input_shape", "=", "tf", ".", "shape", "(", "input", ")", "\n", "left_in_shape", "=", "input_shape", "[", ":", "reshape_dim", "]", "\n", "right_in_shape", "=", "input_shape", "[", "reshape_dim", "+", "1", ":", "]", "\n", "\n", "reshape_dim_shape", "=", "tf", ".", "concat", "(", "[", "left_in_shape", ",", "requested_shape", ",", "right_in_shape", "]", ",", "0", ")", "\n", "\n", "output", "=", "tf", ".", "reshape", "(", "input", ",", "reshape_dim_shape", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.reshaper.DimInserter._get_outputs": [[50, 84], ["int", "int", "len", "tensorflow.variable_scope", "tensorflow.expand_dims", "len", "numpy.ones", "tensorflow.tile", "len", "tensorflow.tile.get_shape"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\treshapes the inputs\n\n\t\tArgs:\n\t\t\tinputs: the inputs to concatenate, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors and/or [batch_size x ...] tensors\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, the reshaped input\n\t\t\"\"\"", "\n", "\n", "insert_dim", "=", "int", "(", "self", ".", "conf", "[", "'insert_dim'", "]", ")", "\n", "if", "'duplicates'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "duplicates", "=", "int", "(", "self", ".", "conf", "[", "'duplicates'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "duplicates", "=", "False", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of DimInserter expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "input", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "output", "=", "tf", ".", "expand_dims", "(", "input", ",", "insert_dim", ")", "\n", "if", "duplicates", ":", "\n", "\t\t\t\t", "multiplicates", "=", "np", ".", "ones", "(", "len", "(", "output", ".", "get_shape", "(", ")", ")", ")", "\n", "multiplicates", "[", "insert_dim", "]", "=", "duplicates", "\n", "output", "=", "tf", ".", "tile", "(", "output", ",", "multiplicates", ")", "\n", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.reshaper.Transposer._get_outputs": [[89, 115], ["map", "reshaper.Transposer.conf[].split", "len", "tensorflow.variable_scope", "tensorflow.transpose", "len"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\treshapes the inputs\n\n\t\tArgs:\n\t\t\tinputs: the inputs to concatenate, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors and/or [batch_size x ...] tensors\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, the reshaped input\n\t\t\"\"\"", "\n", "\n", "transpose_permutation", "=", "map", "(", "int", ",", "self", ".", "conf", "[", "'transpose_permutation'", "]", ".", "split", "(", "' '", ")", ")", "\n", "\n", "# code not available for multiple inputs!!", "\n", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of Transposer expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "input", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "output", "=", "tf", ".", "transpose", "(", "input", ",", "perm", "=", "transpose_permutation", ")", "\n", "\n", "", "return", "output", "", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dcnn.DCNN._get_outputs": [[16, 112], ["int", "int", "int", "int", "range", "tensorflow.expand_dims", "map", "float", "int", "cnn_layers.append", "len", "tensorflow.variable_scope", "dcnn.DCNN.conf[].split", "int", "int", "ValueError", "math.ceil", "range", "nabu.neuralnetworks.components.layer.Conv2D", "len", "tensorflow.variable_scope", "range", "tensorflow.reshape.get_shape().as_list", "tensorflow.reshape", "float", "tensorflow.random_normal", "Exception", "tensorflow.shape", "tensorflow.variable_scope", "tensorflow.reshape.get_shape", "float", "Exception", "float"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "if", "'filters'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "kernel_size", "=", "map", "(", "int", ",", "self", ".", "conf", "[", "'filters'", "]", ".", "split", "(", "' '", ")", ")", "\n", "", "elif", "'filter_size_t'", "in", "self", ".", "conf", "and", "'filter_size_f'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "kernel_size_t", "=", "int", "(", "self", ".", "conf", "[", "'filter_size_t'", "]", ")", "\n", "kernel_size_f", "=", "int", "(", "self", ".", "conf", "[", "'filter_size_f'", "]", ")", "\n", "kernel_size", "=", "(", "kernel_size_t", ",", "kernel_size_f", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'Kernel convolution size not specified.'", ")", "\n", "\n", "", "f_stride", "=", "int", "(", "self", ".", "conf", "[", "'f_stride'", "]", ")", "\n", "t_stride", "=", "int", "(", "self", ".", "conf", "[", "'t_stride'", "]", ")", "\n", "num_layers", "=", "int", "(", "self", ".", "conf", "[", "'num_layers'", "]", ")", "\n", "num_filters_1st_layer", "=", "int", "(", "self", ".", "conf", "[", "'num_filters_1st_layer'", "]", ")", "\n", "if", "'fac_per_layer'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "fac_per_layer", "=", "float", "(", "self", ".", "conf", "[", "'fac_per_layer'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "fac_per_layer", "=", "1.0", "\n", "", "num_filters", "=", "[", "int", "(", "math", ".", "ceil", "(", "num_filters_1st_layer", "*", "(", "fac_per_layer", "**", "l", ")", ")", ")", "for", "l", "in", "range", "(", "num_layers", ")", "]", "\n", "\n", "layer_norm", "=", "self", ".", "conf", "[", "'layer_norm'", "]", "==", "'True'", "\n", "flat_freq", "=", "self", ".", "conf", "[", "'flat_freq'", "]", "==", "'True'", "\n", "\n", "if", "'activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "\n", "# the cnn layers", "\n", "", "cnn_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_layers", ")", ":", "\n", "\t\t\t", "num_filters_l", "=", "num_filters", "[", "l", "]", "\n", "\n", "cnn_layers", ".", "append", "(", "layer", ".", "Conv2D", "(", "\n", "num_filters", "=", "num_filters_l", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "(", "t_stride", ",", "f_stride", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation_fn", "=", "activation_fn", ",", "\n", "layer_norm", "=", "layer_norm", ")", ")", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of DCNN expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "", "if", "num_layers", "==", "0", ":", "\n", "\t\t\t", "output", "=", "inputs", "\n", "return", "output", "\n", "\n", "# Convolutional layers expect input channels, making 1 here.", "\n", "", "inputs", "=", "tf", ".", "expand_dims", "(", "inputs", ",", "-", "1", ")", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "'cnn'", ")", ":", "\n", "\t\t\t\t", "for", "l", "in", "range", "(", "num_layers", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'layer_%s'", "%", "l", ")", ":", "\n", "\n", "\t\t\t\t\t\t", "logits", ",", "_", "=", "cnn_layers", "[", "l", "]", "(", "logits", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t\t\t", "raise", "Exception", "(", "'have to check whether dropout is implemented correctly'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "", "", "", "", "if", "flat_freq", ":", "\n", "\t\t\t\t", "shapes", "=", "logits", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "logits", "=", "tf", ".", "reshape", "(", "logits", ",", "[", "shapes", "[", "0", "]", ",", "-", "1", ",", "shapes", "[", "2", "]", "*", "shapes", "[", "3", "]", "]", ")", "\n", "", "output", "=", "logits", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.concat.Concat._get_outputs": [[12, 90], ["concat.Concat.conf[].split", "concat.Concat.conf[].split", "concat.Concat.conf[].split", "int", "map", "tensorflow.variable_scope", "enumerate", "enumerate", "tensorflow.concat", "len", "len", "concat.Concat.conf[].split", "len", "ValueError", "len", "numpy.ones().tolist", "tensorflow.stack", "tensorflow.random_normal", "zip", "enumerate", "enumerate", "enumerate", "tensorflow.shape", "tensorflow.expand_dims.get_shape().as_list", "tensorflow.concat", "tensorflow.reshape", "tensorflow.shape", "inputs[].get_shape", "tensorflow.expand_dims", "tensorflow.tile", "len", "tensorflow.shape", "ValueError", "numpy.ones", "tensorflow.expand_dims.get_shape"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tconcatenate the inputs over the last dimension.\n\n\t\tArgs:\n\t\t\tinputs: the inputs to concatenate, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors and/or [batch_size x ...] tensors\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, the concatenated inputs\n\t\t\"\"\"", "\n", "\n", "if", "'select_inputs'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "select_inputs", "=", "self", ".", "conf", "[", "'select_inputs'", "]", ".", "split", "(", "' '", ")", "\n", "select_inputs", "=", "[", "sel", "==", "'True'", "for", "sel", "in", "select_inputs", "]", "\n", "", "else", ":", "\n", "\t\t\t", "select_inputs", "=", "[", "True", "]", "*", "len", "(", "inputs", ")", "\n", "\n", "", "if", "'flatten_last_2_dims'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "flatten_last_2_dims", "=", "self", ".", "conf", "[", "'flatten_last_2_dims'", "]", ".", "split", "(", "' '", ")", "\n", "flatten_last_2_dims", "=", "[", "flat", "==", "'True'", "for", "flat", "in", "flatten_last_2_dims", "]", "\n", "", "else", ":", "\n", "\t\t\t", "flatten_last_2_dims", "=", "[", "False", "]", "*", "len", "(", "inputs", ")", "\n", "\n", "", "if", "'expand_dim_to_first_input'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "expand_dim_to_first_input", "=", "self", ".", "conf", "[", "'expand_dim_to_first_input'", "]", ".", "split", "(", "' '", ")", "\n", "expand_dim_to_first_input", "=", "[", "exp", "==", "'True'", "for", "exp", "in", "expand_dim_to_first_input", "]", "\n", "", "else", ":", "\n", "\t\t\t", "expand_dim_to_first_input", "=", "[", "False", "]", "+", "[", "True", "]", "*", "(", "len", "(", "inputs", ")", "-", "1", ")", "\n", "# The dimension that will be expanded", "\n", "", "if", "'expand_dimension'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "expand_dimension", "=", "int", "(", "self", ".", "conf", "[", "'expand_dimension'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "expand_dimension", "=", "-", "2", "\n", "\n", "", "if", "is_training", "and", "'input_noise'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "inputs_noise", "=", "map", "(", "float", ",", "self", ".", "conf", "[", "'input_noise'", "]", ".", "split", "(", "' '", ")", ")", "\n", "inputs", "=", "[", "\n", "inp", "+", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "inp", ")", ",", "stddev", "=", "inp_noise", ")", "for", "inp", ",", "inp_noise", "in", "zip", "(", "inputs", ",", "inputs_noise", ")", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "inputs", "=", "[", "inputs", "[", "ind", "]", "for", "ind", ",", "sel", "in", "enumerate", "(", "select_inputs", ")", "if", "sel", "]", "\n", "flatten_last_2_dims", "=", "[", "flatten_last_2_dims", "[", "ind", "]", "for", "ind", ",", "sel", "in", "enumerate", "(", "select_inputs", ")", "if", "sel", "]", "\n", "expand_dim_to_first_input", "=", "[", "expand_dim_to_first_input", "[", "ind", "]", "for", "ind", ",", "sel", "in", "enumerate", "(", "select_inputs", ")", "if", "sel", "]", "\n", "\n", "for", "ind", ",", "inp", "in", "enumerate", "(", "inputs", ")", ":", "\n", "\t\t\t\t", "if", "flatten_last_2_dims", "[", "ind", "]", ":", "\n", "\t\t\t\t\t", "inp_shape", "=", "tf", ".", "shape", "(", "inp", ")", "\n", "inp_stat_shape", "=", "inp", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "if", "None", "in", "inp_stat_shape", "[", "-", "2", ":", "]", ":", "\n", "\t\t\t\t\t\t", "raise", "ValueError", "(", "'Last two dimensions of tensor should be known before flattening.'", ")", "\n", "", "new_last_shape", "=", "inp_stat_shape", "[", "-", "2", "]", "*", "inp_stat_shape", "[", "-", "1", "]", "\n", "new_shape", "=", "tf", ".", "concat", "(", "[", "inp_shape", "[", ":", "-", "2", "]", ",", "[", "new_last_shape", "]", "]", ",", "axis", "=", "0", ")", "\n", "inputs", "[", "ind", "]", "=", "tf", ".", "reshape", "(", "inp", ",", "new_shape", ")", "\n", "\n", "", "", "if", "len", "(", "inputs", ")", "==", "1", ":", "\n", "\t\t\t\t", "return", "inputs", "[", "0", "]", "\n", "\n", "", "if", "expand_dim_to_first_input", "[", "0", "]", ":", "\n", "\t\t\t\t", "raise", "ValueError", "(", "\n", "'The expanded dimension is tiled to match the first input. Therefor it is not possible for the first input'", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "size_of_expanded_dim", "=", "tf", ".", "shape", "(", "inputs", "[", "0", "]", ")", "[", "expand_dimension", "]", "\n", "out_dim", "=", "len", "(", "inputs", "[", "0", "]", ".", "get_shape", "(", ")", ")", "\n", "multiplicates", "=", "np", ".", "ones", "(", "out_dim", ",", "np", ".", "int", ")", ".", "tolist", "(", ")", "\n", "multiplicates", "[", "expand_dimension", "]", "=", "size_of_expanded_dim", "\n", "multiplicates", "=", "tf", ".", "stack", "(", "multiplicates", ")", "\n", "\n", "", "for", "ind", ",", "inp", "in", "enumerate", "(", "inputs", ")", ":", "\n", "\t\t\t\t", "if", "expand_dim_to_first_input", "[", "ind", "]", ":", "\n", "\t\t\t\t\t", "inp", "=", "tf", ".", "expand_dims", "(", "inp", ",", "expand_dimension", ")", "\n", "inputs", "[", "ind", "]", "=", "tf", ".", "tile", "(", "inp", ",", "multiplicates", ")", "\n", "\n", "", "", "output", "=", "tf", ".", "concat", "(", "inputs", ",", "-", "1", ")", "\n", "\n", "", "return", "output", "", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model_factory.factory": [[12, 99], ["Exception"], "function", ["None"], ["def", "factory", "(", "architecture", ")", ":", "\n", "    ", "\"\"\"get a model class\n\n    Args:\n        conf: the model conf\n\n    Returns:\n        a model class\"\"\"", "\n", "\n", "if", "architecture", "==", "'dblstm'", ":", "\n", "        ", "return", "dblstm", ".", "DBLSTM", "\n", "", "elif", "architecture", "==", "'leaky_dblstm'", ":", "\n", "        ", "return", "leaky_dblstm", ".", "LeakyDBLSTM", "\n", "", "elif", "architecture", "==", "'leaky_dblstm_iznotrec'", ":", "\n", "        ", "return", "leaky_dblstm_iznotrec", ".", "LeakyDBLSTMIZNotRec", "\n", "", "elif", "architecture", "==", "'leaky_dblstm_notrec'", ":", "\n", "        ", "return", "leaky_dblstm_notrec", ".", "LeakyDBLSTMNotRec", "\n", "", "elif", "architecture", "==", "'dbrnn'", ":", "\n", "        ", "return", "dbrnn", ".", "DBRNN", "\n", "", "elif", "architecture", "==", "'linear'", ":", "\n", "        ", "return", "linear", ".", "Linear", "\n", "", "elif", "architecture", "==", "'feedforward'", ":", "\n", "        ", "return", "feedforward", ".", "Feedforward", "\n", "", "elif", "architecture", "==", "'plain_variables'", ":", "\n", "        ", "return", "plain_variables", ".", "PlainVariables", "\n", "", "elif", "architecture", "==", "'concat'", ":", "\n", "        ", "return", "concat", ".", "Concat", "\n", "", "elif", "architecture", "==", "'multiaverage'", ":", "\n", "        ", "return", "multi_averager", ".", "MultiAverager", "\n", "", "elif", "architecture", "==", "'capsnet'", ":", "\n", "        ", "return", "capsnet", ".", "CapsNet", "\n", "", "elif", "architecture", "==", "'dbr_capsnet'", ":", "\n", "        ", "return", "dbr_capsnet", ".", "DBRCapsNet", "\n", "", "elif", "architecture", "==", "'dblstm_capsnet'", ":", "\n", "        ", "return", "dblstm_capsnet", ".", "DBLSTMCapsNet", "\n", "", "elif", "architecture", "==", "'dbgru'", ":", "\n", "        ", "return", "dbgru", ".", "DBGRU", "\n", "", "elif", "architecture", "==", "'leaky_dbgru'", ":", "\n", "        ", "return", "leaky_dbgru", ".", "LeakyDBGRU", "\n", "", "elif", "architecture", "==", "'dbresetgru'", ":", "\n", "        ", "return", "dbresetgru", ".", "DBResetGRU", "\n", "", "elif", "architecture", "==", "'dbresetlstm'", ":", "\n", "        ", "return", "dbresetlstm", ".", "DBResetLSTM", "\n", "", "elif", "architecture", "==", "'dbresetlstm_insert_additional_input'", ":", "\n", "        ", "return", "dbresetlstm_insert_additional_input", ".", "DBResetLSTM", "\n", "", "elif", "architecture", "==", "'dlstm'", ":", "\n", "        ", "return", "dlstm", ".", "DLSTM", "\n", "", "elif", "architecture", "==", "'dresetlstm'", ":", "\n", "        ", "return", "dresetlstm", ".", "DResetLSTM", "\n", "", "elif", "architecture", "==", "'leaky_dlstm'", ":", "\n", "        ", "return", "leaky_dlstm", ".", "LeakyDLSTM", "\n", "", "elif", "architecture", "==", "'encoder_decoder_cnn'", ":", "\n", "        ", "return", "encoder_decoder_cnn", ".", "EncoderDecoderCNN", "\n", "", "elif", "architecture", "==", "'encoder_lstm_decoder'", ":", "\n", "        ", "return", "encoder_lstm_decoder", ".", "EncoderLSTMDecoder", "\n", "", "elif", "architecture", "==", "'dcnn'", ":", "\n", "        ", "return", "dcnn", ".", "DCNN", "\n", "", "elif", "architecture", "==", "'regular_cnn'", ":", "\n", "        ", "return", "regular_cnn", ".", "RegularCNN", "\n", "", "elif", "architecture", "==", "'framer'", ":", "\n", "        ", "return", "framer", ".", "Framer", "\n", "", "elif", "architecture", "==", "'deframer_select'", ":", "\n", "        ", "return", "framer", ".", "DeframerSelect", "\n", "", "elif", "architecture", "==", "'reconstruction_layer'", ":", "\n", "        ", "return", "reconstruction_layer", ".", "Reconstruction_Layer", "\n", "", "elif", "architecture", "==", "'ntm'", ":", "\n", "        ", "return", "ntm", ".", "NTM", "\n", "", "elif", "architecture", "==", "'ntt_rec'", ":", "\n", "        ", "return", "ntt_rec", ".", "NTTRec", "\n", "", "elif", "architecture", "==", "'attractor'", ":", "\n", "        ", "return", "attractor", ".", "Attractor", "\n", "", "elif", "architecture", "==", "'averager'", ":", "\n", "        ", "return", "averager", ".", "Averager", "\n", "", "elif", "architecture", "==", "'reshaper'", ":", "\n", "        ", "return", "reshaper", ".", "Reshaper", "\n", "", "elif", "architecture", "==", "'diminserter'", ":", "\n", "        ", "return", "reshaper", ".", "DimInserter", "\n", "", "elif", "architecture", "==", "'transposer'", ":", "\n", "        ", "return", "reshaper", ".", "Transposer", "\n", "", "elif", "architecture", "==", "'permute_stacker'", ":", "\n", "        ", "return", "permute_stacker", ".", "PermuteStacker", "\n", "", "elif", "architecture", "==", "'mask_estimator_from_attractors'", ":", "\n", "        ", "return", "mask_estimator_from_attractors", ".", "MaskEstimatorFromAttractors", "\n", "", "elif", "architecture", "==", "'constant_generator'", ":", "\n", "        ", "return", "constant_generator", ".", "ConstantGenerator", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'undefined architecture type: %s'", "%", "architecture", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dbresetlstm.DBResetLSTM._get_outputs": [[13, 130], ["int", "int", "map.split", "map", "any", "map", "any", "float", "len", "ValueError", "group_sizes.split.split.split", "len", "ValueError", "len", "Exception", "tensorflow.variable_scope", "range", "tensorflow.concat", "nabu.neuralnetworks.components.layer.BResetLSTMLayer", "nabu.neuralnetworks.components.layer.BResetLSTMLayer.", "Exception", "range", "numpy.mod", "zip", "len", "float", "tensorflow.random_normal", "tensorflow.expand_dims", "int", "tensorflow.tile", "dbresetlstm.permute_versions", "float", "Exception", "tensorflow.shape", "tensorflow.constant", "str", "float", "float", "float"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dbresetlstm_insert_additional_input.permute_versions"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "# the bresetlstm layer", "\n", "num_units", "=", "int", "(", "self", ".", "conf", "[", "'num_units'", "]", ")", "\n", "num_lay", "=", "int", "(", "self", ".", "conf", "[", "'num_layers'", "]", ")", "\n", "t_resets", "=", "self", ".", "conf", "[", "'t_reset'", "]", "\n", "t_resets", "=", "t_resets", ".", "split", "(", "' '", ")", "\n", "if", "len", "(", "t_resets", ")", "==", "1", ":", "\n", "\t\t\t", "t_resets", "=", "t_resets", "*", "num_lay", "\n", "", "t_resets", "=", "map", "(", "int", ",", "t_resets", ")", "\n", "if", "any", "(", "[", "t_resets", "[", "l", "+", "1", "]", "<", "t_resets", "[", "l", "]", "for", "l", "in", "range", "(", "num_lay", "-", "1", ")", "]", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'T_reset in next layer must be equal to or bigger than T_reset in current layer'", ")", "\n", "", "if", "'group_size'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "group_sizes", "=", "self", ".", "conf", "[", "'group_size'", "]", "\n", "group_sizes", "=", "group_sizes", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "\t\t\t", "group_sizes", "=", "'1'", "\n", "", "if", "len", "(", "group_sizes", ")", "==", "1", ":", "\n", "\t\t\t", "group_sizes", "=", "group_sizes", "*", "num_lay", "\n", "", "group_sizes", "=", "map", "(", "int", ",", "group_sizes", ")", "\n", "if", "any", "(", "[", "np", ".", "mod", "(", "t_res", ",", "group_size", ")", "!=", "0", "for", "t_res", ",", "group_size", "in", "zip", "(", "t_resets", ",", "group_sizes", ")", "]", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'t_reset should be a multiple of group_size'", ")", "\n", "\n", "", "if", "'forward_reset'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "forward_reset", "=", "self", ".", "conf", "[", "'forward_reset'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "forward_reset", "=", "True", "\n", "", "if", "'backward_reset'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "backward_reset", "=", "self", ".", "conf", "[", "'backward_reset'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "backward_reset", "=", "True", "\n", "\n", "", "if", "'separate_directions'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "separate_directions", "=", "self", ".", "conf", "[", "'separate_directions'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "separate_directions", "=", "False", "\n", "\n", "", "layer_norm", "=", "self", ".", "conf", "[", "'layer_norm'", "]", "==", "'True'", "\n", "recurrent_dropout", "=", "float", "(", "self", ".", "conf", "[", "'recurrent_dropout'", "]", ")", "\n", "if", "'activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'The implementation of DBLSTM expects 1 input and not %d'", "%", "len", "(", "inputs", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "for", "l", "in", "range", "(", "num_lay", ")", ":", "\n", "\n", "\t\t\t\t", "blstm", "=", "layer", ".", "BResetLSTMLayer", "(", "\n", "num_units", "=", "num_units", ",", "\n", "t_reset", "=", "t_resets", "[", "l", "]", ",", "\n", "group_size", "=", "group_sizes", "[", "l", "]", ",", "\n", "forward_reset", "=", "forward_reset", ",", "\n", "backward_reset", "=", "backward_reset", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "activation_fn", "=", "activation_fn", ")", "\n", "\n", "if", "l", "==", "0", ":", "\n", "# expand the dimension of inputs since the reset lstm expect multistate input", "\n", "\t\t\t\t\t", "multistate_input", "=", "tf", ".", "expand_dims", "(", "logits", ",", "2", ")", "\n", "num_replicates", "=", "int", "(", "float", "(", "t_resets", "[", "l", "]", ")", "/", "float", "(", "group_sizes", "[", "l", "]", ")", ")", "\n", "multistate_input", "=", "tf", ".", "tile", "(", "multistate_input", ",", "tf", ".", "constant", "(", "[", "1", ",", "1", ",", "num_replicates", ",", "1", "]", ")", ")", "\n", "if", "forward_reset", ":", "\n", "\t\t\t\t\t\t", "for_forward", "=", "multistate_input", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "for_forward", "=", "logits", "\n", "", "if", "backward_reset", ":", "\n", "\t\t\t\t\t\t", "for_backward", "=", "multistate_input", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "for_backward", "=", "logits", "\n", "", "", "else", ":", "\n", "\t\t\t\t\t", "for_forward", ",", "for_backward", "=", "permute_versions", "(", "\n", "logits_multistate", ",", "logits", ",", "input_seq_length", ",", "t_resets", "[", "l", "]", ",", "t_resets", "[", "l", "-", "1", "]", ",", "group_sizes", "[", "l", "]", ",", "\n", "group_sizes", "[", "l", "-", "1", "]", ",", "forward_reset", ",", "backward_reset", ",", "separate_directions", ")", "\n", "\n", "", "logits", ",", "logits_multistate", "=", "blstm", "(", "for_forward", ",", "for_backward", ",", "input_seq_length", ",", "'layer'", "+", "str", "(", "l", ")", ")", "\n", "\n", "", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'dropout not yet implemented for state reset lstm'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "", "output", "=", "tf", ".", "concat", "(", "logits", ",", "-", "1", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dbresetlstm.permute_versions": [[132, 229], ["int", "int", "tensorflow.expand_dims", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.expand_dims", "tensorflow.tile", "numpy.expand_dims", "tensorflow.tile", "tensorflow.mod", "tensorflow.minimum", "tensorflow.mod", "tensorflow.minimum", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.stack", "tensorflow.stack", "tensorflow.stack", "tensorflow.stack", "forward_output.get_shape", "tensorflow.shape", "ValueError", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "numpy.expand_dims", "tensorflow.constant", "tensorflow.mod", "tensorflow.mod", "tensorflow.mod", "tensorflow.mod", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.concat", "tensorflow.concat", "numpy.mod", "numpy.mod", "float", "float", "float", "float", "range", "numpy.expand_dims", "tensorflow.ceil", "tensorflow.ceil", "tensorflow.ceil", "tensorflow.ceil", "tensorflow.tile", "tensorflow.truediv", "tensorflow.truediv", "tensorflow.truediv", "tensorflow.truediv", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.expand_dims"], "function", ["None"], ["", "", "def", "permute_versions", "(", "\n", "replicas", ",", "actual_outputs", ",", "sequence_length", ",", "t_reset", ",", "previous_t_reset", ",", "group_size", ",", "previous_group_size", ",", "\n", "forward_reset", "=", "True", ",", "backward_reset", "=", "True", ",", "separate_directions", "=", "False", ")", ":", "\n", "\t", "forward_output", "=", "actual_outputs", "[", "0", "]", "\n", "backward_output", "=", "actual_outputs", "[", "1", "]", "\n", "forward_replicas", "=", "replicas", "[", "0", "]", "\n", "backward_replicas", "=", "replicas", "[", "1", "]", "\n", "\n", "batch_size", "=", "forward_output", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "max_length", "=", "tf", ".", "shape", "(", "forward_output", ")", "[", "1", "]", "\n", "\n", "int_dtype", "=", "sequence_length", ".", "dtype", "\n", "if", "np", ".", "mod", "(", "t_reset", ",", "group_size", ")", "!=", "0", "or", "np", ".", "mod", "(", "previous_t_reset", ",", "previous_group_size", ")", "!=", "0", ":", "\n", "\t\t", "raise", "ValueError", "(", "'Reset period must be multiple of group size'", ")", "\n", "", "num_replicas", "=", "int", "(", "float", "(", "t_reset", ")", "/", "float", "(", "group_size", ")", ")", "\n", "previous_num_replicas", "=", "int", "(", "float", "(", "previous_t_reset", ")", "/", "float", "(", "previous_group_size", ")", ")", "\n", "# the output replicas need to be permuted correctly such that the next layer receives", "\n", "# the replicas in the correct order", "\n", "\n", "# T: [B,1, 1]", "\n", "T", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "sequence_length", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "\n", "# numbers_to_maxT: [B,Tmax,k]", "\n", "numbers_to_maxT", "=", "tf", ".", "range", "(", "0", ",", "max_length", ")", "\n", "numbers_to_maxT", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "numbers_to_maxT", ",", "0", ")", ",", "-", "1", ")", "\n", "numbers_to_maxT", "=", "tf", ".", "tile", "(", "numbers_to_maxT", ",", "[", "batch_size", ",", "1", ",", "num_replicas", "]", ")", "\n", "reversed_numbers_to_maxT", "=", "T", "-", "1", "-", "numbers_to_maxT", "\n", "\n", "# numbers_to_k: [B,Tmax,k]", "\n", "numbers_to_k", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "range", "(", "0", ",", "num_replicas", ")", ",", "0", ")", ",", "0", ")", "\n", "numbers_to_k", "=", "tf", ".", "tile", "(", "numbers_to_k", ",", "[", "batch_size", ",", "max_length", ",", "1", "]", ")", "\n", "\n", "# taus", "\n", "max_tau", "=", "previous_t_reset", "-", "1", "\n", "max_tau", "=", "np", ".", "expand_dims", "(", "np", ".", "expand_dims", "(", "np", ".", "expand_dims", "(", "max_tau", ",", "-", "1", ")", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "max_tau_tf", "=", "tf", ".", "tile", "(", "tf", ".", "constant", "(", "max_tau", ",", "dtype", "=", "int_dtype", ")", ",", "[", "batch_size", ",", "max_length", ",", "num_replicas", "]", ")", "\n", "tau_forward", "=", "tf", ".", "mod", "(", "numbers_to_maxT", "-", "group_size", "*", "numbers_to_k", ",", "t_reset", ")", "\n", "tau_forward", "=", "tf", ".", "minimum", "(", "tau_forward", ",", "max_tau_tf", ")", "\n", "tau_backward", "=", "tf", ".", "mod", "(", "reversed_numbers_to_maxT", "-", "group_size", "*", "numbers_to_k", ",", "t_reset", ")", "\n", "tau_backward", "=", "tf", ".", "minimum", "(", "tau_backward", ",", "max_tau_tf", ")", "\n", "\n", "# forward for forward", "\n", "forward_indices_for_forward", "=", "tf", ".", "cast", "(", "tf", ".", "mod", "(", "\n", "tf", ".", "ceil", "(", "tf", ".", "truediv", "(", "numbers_to_maxT", "-", "tau_forward", ",", "previous_group_size", ")", ")", ",", "previous_num_replicas", ")", ",", "int_dtype", ")", "\n", "\n", "# backward for forward", "\n", "backward_indices_for_forward", "=", "tf", ".", "cast", "(", "tf", ".", "mod", "(", "\n", "tf", ".", "ceil", "(", "tf", ".", "truediv", "(", "reversed_numbers_to_maxT", "-", "tau_forward", ",", "previous_group_size", ")", ")", ",", "previous_num_replicas", ")", ",", "int_dtype", ")", "\n", "\n", "# backward for backward", "\n", "backward_indices_for_backward", "=", "tf", ".", "cast", "(", "tf", ".", "mod", "(", "\n", "tf", ".", "ceil", "(", "tf", ".", "truediv", "(", "reversed_numbers_to_maxT", "-", "tau_backward", ",", "previous_group_size", ")", ")", ",", "previous_num_replicas", ")", ",", "int_dtype", ")", "\n", "\n", "# forward for backward", "\n", "forward_indices_for_backward", "=", "tf", ".", "cast", "(", "tf", ".", "mod", "(", "\n", "tf", ".", "ceil", "(", "tf", ".", "truediv", "(", "numbers_to_maxT", "-", "tau_backward", ",", "previous_group_size", ")", ")", ",", "previous_num_replicas", ")", ",", "int_dtype", ")", "\n", "\n", "# ra1: [B,Tmax,k]", "\n", "ra1", "=", "tf", ".", "range", "(", "batch_size", ")", "\n", "ra1", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "ra1", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "ra1", "=", "tf", ".", "tile", "(", "ra1", ",", "[", "1", ",", "max_length", ",", "num_replicas", "]", ")", "\n", "ra2", "=", "tf", ".", "range", "(", "max_length", ")", "\n", "ra2", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "ra2", ",", "0", ")", ",", "-", "1", ")", "\n", "ra2", "=", "tf", ".", "tile", "(", "ra2", ",", "[", "batch_size", ",", "1", ",", "num_replicas", "]", ")", "\n", "stacked_forward_indices_for_forward", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "forward_indices_for_forward", "]", ",", "axis", "=", "-", "1", ")", "\n", "stacked_backward_indices_for_forward", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "backward_indices_for_forward", "]", ",", "axis", "=", "-", "1", ")", "\n", "stacked_forward_indices_for_backward", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "forward_indices_for_backward", "]", ",", "axis", "=", "-", "1", ")", "\n", "stacked_backward_indices_for_backward", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "backward_indices_for_backward", "]", ",", "axis", "=", "-", "1", ")", "\n", "\n", "if", "forward_reset", ":", "\n", "\t\t", "forward_for_forward", "=", "tf", ".", "gather_nd", "(", "forward_replicas", ",", "stacked_forward_indices_for_forward", ")", "\n", "", "else", ":", "\n", "\t\t", "forward_for_forward", "=", "forward_output", "\n", "\n", "", "if", "backward_reset", ":", "\n", "\t\t", "backward_for_backward", "=", "tf", ".", "gather_nd", "(", "backward_replicas", ",", "stacked_backward_indices_for_backward", ")", "\n", "", "else", ":", "\n", "\t\t", "backward_for_backward", "=", "backward_output", "\n", "\n", "", "if", "forward_reset", "and", "backward_reset", ":", "\n", "\t\t", "backward_for_forward", "=", "tf", ".", "gather_nd", "(", "backward_replicas", ",", "stacked_backward_indices_for_forward", ")", "\n", "forward_for_backward", "=", "tf", ".", "gather_nd", "(", "forward_replicas", ",", "stacked_forward_indices_for_backward", ")", "\n", "", "elif", "forward_reset", "and", "not", "backward_reset", ":", "\n", "\t\t", "backward_for_forward", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "backward_output", ",", "-", "2", ")", ",", "[", "1", ",", "1", ",", "num_replicas", ",", "1", "]", ")", "\n", "forward_for_backward", "=", "forward_output", "\n", "", "elif", "not", "forward_reset", "and", "backward_reset", ":", "\n", "\t\t", "backward_for_forward", "=", "backward_output", "\n", "forward_for_backward", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "forward_output", ",", "-", "2", ")", ",", "[", "1", ",", "1", ",", "num_replicas", ",", "1", "]", ")", "\n", "\n", "", "if", "separate_directions", ":", "\n", "\t\t", "for_forward", "=", "forward_for_forward", "\n", "for_backward", "=", "backward_for_backward", "\n", "", "else", ":", "\n", "\t\t", "for_forward", "=", "tf", ".", "concat", "(", "(", "forward_for_forward", ",", "backward_for_forward", ")", ",", "-", "1", ")", "\n", "for_backward", "=", "tf", ".", "concat", "(", "(", "forward_for_backward", ",", "backward_for_backward", ")", ",", "-", "1", ")", "\n", "\n", "", "return", "for_forward", ",", "for_backward", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.mask_estimator_from_attractors.MaskEstimatorFromAttractors._get_outputs": [[11, 100], ["float", "tensorflow.expand_dims.get_shape", "tensorflow.expand_dims.get_shape", "tensorflow.reshape", "len", "tensorflow.variable_scope", "tensorflow.to_float", "len", "tensorflow.nn.l2_normalize", "tensorflow.nn.l2_normalize", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.reduce_mean", "tensorflow.einsum", "tensorflow.nn.softmax", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.nn.sigmoid", "BaseException", "tensorflow.reduce_min", "tensorflow.reduce_max"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "normalization", "=", "self", ".", "conf", "[", "'normalization'", "]", "==", "'True'", "\n", "activation", "=", "self", ".", "conf", "[", "'activation'", "]", "\n", "\n", "thr", "=", "float", "(", "self", ".", "conf", "[", "'thr'", "]", ")", "\n", "use_binary_masks", "=", "self", ".", "conf", "[", "'binary_masks'", "]", "==", "'True'", "\n", "rescale_masks", "=", "self", ".", "conf", "[", "'rescale_masks'", "]", "==", "'True'", "and", "not", "use_binary_masks", "\n", "\n", "# Whether to store the output in tf_targets_format (BxTxFS)", "\n", "tf_targets_format", "=", "self", ".", "conf", "[", "'tf_targets_format'", "]", "==", "'True'", "\n", "# Whether to store the output in pit_loss_format (BxTxSF)", "\n", "pit_loss_format", "=", "'pit_loss_format'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'pit_loss_format'", "]", "==", "'True'", "and", "not", "tf_targets_format", "\n", "\n", "if", "len", "(", "inputs", ")", ">", "2", ":", "\n", "\t\t\t", "raise", "'The implementation of MaskEstimatorFromAttractors expects 2 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "bin_embs", "=", "inputs", "[", "0", "]", "\n", "attractors", "=", "inputs", "[", "1", "]", "\n", "\n", "", "bin_embs_shape", "=", "bin_embs", ".", "get_shape", "(", ")", "\n", "attractors_shape", "=", "attractors", ".", "get_shape", "(", ")", "\n", "batch_size", "=", "bin_embs_shape", "[", "0", "]", "\n", "output_dim", "=", "bin_embs_shape", "[", "-", "1", "]", "\n", "emb_dim", "=", "attractors_shape", "[", "-", "1", "]", "\n", "nrS", "=", "attractors_shape", "[", "1", "]", "\n", "feat_dim", "=", "output_dim", "/", "emb_dim", "\n", "\n", "bin_embs", "=", "tf", ".", "reshape", "(", "bin_embs", ",", "[", "batch_size", ",", "-", "1", ",", "feat_dim", ",", "emb_dim", "]", ")", "\n", "\n", "if", "'einsum'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "einsum", "=", "self", ".", "conf", "[", "'einsum'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "einsum", "=", "False", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "normalization", ":", "\n", "\t\t\t\t", "bin_embs", "=", "tf", ".", "nn", ".", "l2_normalize", "(", "bin_embs", ",", "axis", "=", "-", "1", ")", "\n", "attractors", "=", "tf", ".", "nn", ".", "l2_normalize", "(", "attractors", ",", "axis", "=", "-", "1", ")", "\n", "", "if", "not", "einsum", ":", "\n", "\t\t\t\t", "bin_embs", "=", "tf", ".", "expand_dims", "(", "bin_embs", ",", "1", ")", "\n", "attractors", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "attractors", ",", "2", ")", ",", "3", ")", "\n", "logits", "=", "tf", ".", "reduce_mean", "(", "bin_embs", "*", "attractors", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "logits", "=", "tf", ".", "einsum", "(", "einsum", ",", "bin_embs", ",", "attractors", ")", "\n", "\n", "", "if", "activation", "==", "'softmax'", ":", "\n", "\t\t\t\t", "masks", "=", "tf", ".", "nn", ".", "softmax", "(", "logits", ",", "axis", "=", "1", ")", "\n", "", "elif", "activation", "in", "[", "'None'", ",", "'none'", ",", "None", "]", ":", "\n", "\t\t\t\t", "masks", "=", "logits", "\n", "", "elif", "activation", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "masks", "=", "tf", ".", "nn", ".", "sigmoid", "(", "logits", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "BaseException", "(", ")", "\n", "\n", "", "binary_masks", "=", "masks", ">", "thr", "\n", "binary_masks", "=", "tf", ".", "to_float", "(", "binary_masks", ")", "\n", "if", "use_binary_masks", ":", "\n", "\t\t\t\t", "masks", "=", "binary_masks", "\n", "", "else", ":", "\n", "\t\t\t\t", "masks", "=", "masks", "*", "binary_masks", "\n", "if", "rescale_masks", ":", "\n", "\t\t\t\t\t", "rescaled_masks", "=", "masks", "-", "tf", ".", "reduce_min", "(", "masks", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ",", "keepdims", "=", "True", ")", "\n", "rescaled_masks", "=", "rescaled_masks", "*", "binary_masks", "\n", "rescaled_masks", "=", "rescaled_masks", "/", "(", "tf", ".", "reduce_max", "(", "rescaled_masks", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "rescaled_masks", "=", "rescaled_masks", "*", "binary_masks", "\n", "masks", "=", "rescaled_masks", "\n", "\n", "", "", "if", "tf_targets_format", ":", "\n", "\t\t\t\t", "masks", "=", "tf", ".", "transpose", "(", "masks", ",", "[", "0", ",", "2", ",", "3", ",", "1", "]", ")", "\n", "masks", "=", "tf", ".", "reshape", "(", "masks", ",", "[", "batch_size", ",", "-", "1", ",", "feat_dim", "*", "nrS", "]", ")", "\n", "", "elif", "pit_loss_format", ":", "\n", "\t\t\t\t", "masks", "=", "tf", ".", "transpose", "(", "masks", ",", "[", "0", ",", "2", ",", "1", ",", "3", "]", ")", "\n", "masks", "=", "tf", ".", "reshape", "(", "masks", ",", "[", "batch_size", ",", "-", "1", ",", "nrS", "*", "feat_dim", "]", ")", "\n", "\n", "", "", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.run_multi_model.run_multi_model": [[7, 73], ["dict", "hasattr", "isinstance", "node_model", "isinstance", "node_tensors.update", "seq_lengths.update", "range", "range"], "function", ["None"], ["def", "run_multi_model", "(", "\n", "models", ",", "model_nodes", ",", "model_links", ",", "inputs", ",", "inputs_links", ",", "nodes_output_names", ",", "output_names", ",", "seq_lengths", ",", "\n", "is_training", ")", ":", "\n", "\t", "\"\"\"get the outputs by passing the inputs trough the requested models.\n\tModel nodes are used to store intermediate results\n\n\tArgs:\n\tmodels: dict containing all the models available\n\tmodel_nodes: list of all the intermediate model nodes\n\tmodel_links: dict containing a model fo each node\n\tinputs: the inputs to the hybrid model\n\tinputs_links: dict containing the inputs to the model of the node\n\tnodes_output_names: dict containing the output names of the node's model. It can thus be allowed to make a\n\t\t'multi-node' node. Typically only one output name is expected, which is the name of the node itself.\n\tseq_lengths: sequence lengths of the inputs.\n\tis_training: whether or not the network is in training mode\n\n\tReturns:\n\toutputs: the requested outputs of the hybrid model\n\tused_models: the models used to form the hybrid model\n\t\"\"\"", "\n", "\n", "node_tensors", "=", "inputs", "\n", "used_models", "=", "dict", "(", ")", "\n", "for", "node", "in", "model_nodes", ":", "\n", "\t\t", "node_inputs", "=", "[", "node_tensors", "[", "x", "]", "for", "x", "in", "inputs_links", "[", "node", "]", "]", "\n", "node_model_name", "=", "model_links", "[", "node", "]", "\n", "node_model", "=", "models", "[", "node_model_name", "]", "\n", "used_models", "[", "node_model_name", "]", "=", "node_model", "\n", "node_output_names", "=", "nodes_output_names", "[", "node", "]", "\n", "\n", "# else condition is also for legacy models.", "\n", "if", "hasattr", "(", "node_model", ",", "'num_outputs'", ")", ":", "\n", "\t\t\t", "node_num_outputs", "=", "node_model", ".", "num_outputs", "\n", "", "else", ":", "\n", "\t\t\t", "node_num_outputs", "=", "1", "\n", "\n", "", "if", "isinstance", "(", "node_model", ",", "Framer", ")", ":", "\n", "# exceptional case", "\n", "# batch_size = node_inputs[0].get_shape()[0]", "\n", "# T = tf.shape(node_inputs)[1]", "\n", "\t\t\t", "node_seq_length_before_framer", "=", "seq_lengths", "[", "inputs_links", "[", "node", "]", "[", "0", "]", "]", "\n", "# node_seq_length = tf.ones(batch_size*T,dtype=tf.int32)*node_model.frame_length", "\n", "node_seq_length", "=", "None", "\n", "", "elif", "isinstance", "(", "node_model", ",", "DeframerSelect", ")", ":", "\n", "# exceptional case", "\n", "\t\t\t", "node_seq_length", "=", "node_seq_length_before_framer", "\n", "", "else", ":", "\n", "# if a model has multiple inputs, only the sequence length of the", "\n", "# first input will be considered", "\n", "\t\t\t", "node_seq_length", "=", "seq_lengths", "[", "inputs_links", "[", "node", "]", "[", "0", "]", "]", "\n", "\n", "", "model_outputs", "=", "node_model", "(", "\n", "inputs", "=", "node_inputs", ",", "\n", "input_seq_length", "=", "node_seq_length", ",", "\n", "is_training", "=", "is_training", ")", "\n", "if", "node_num_outputs", "==", "1", ":", "\n", "\t\t\t", "node_tensors", "[", "node_output_names", "]", "=", "model_outputs", "\n", "seq_lengths", "[", "node_output_names", "]", "=", "node_seq_length", "\n", "", "else", ":", "\n", "\t\t\t", "node_tensors", ".", "update", "(", "{", "node_output_names", "[", "ind", "]", ":", "model_outputs", "[", "ind", "]", "for", "ind", "in", "range", "(", "node_num_outputs", ")", "}", ")", "\n", "seq_lengths", ".", "update", "(", "{", "node_output_names", "[", "ind", "]", ":", "node_seq_length", "for", "ind", "in", "range", "(", "node_num_outputs", ")", "}", ")", "\n", "\n", "", "", "outputs", "=", "{", "name", ":", "node_tensors", "[", "name", "]", "for", "name", "in", "output_names", "}", "\n", "\n", "return", "outputs", ",", "used_models", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.run_multi_model.get_variables": [[75, 90], ["models.keys"], "function", ["None"], ["", "def", "get_variables", "(", "models", ")", ":", "\n", "\t", "\"\"\"get variables of all models\n\n\tArgs:\n\tmodels: dict containing all the models available\n\n\tReturns:\n\tvariables: variables of all models\n\t\"\"\"", "\n", "\n", "variables", "=", "[", "]", "\n", "for", "model", "in", "models", ".", "keys", "(", ")", ":", "\n", "\t\t", "variables", "+=", "models", "[", "model", "]", ".", "variables", "\n", "\n", "", "return", "variables", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.encoder_decoder_cnn.EncoderDecoderCNN._get_outputs": [[17, 245], ["int", "int", "int", "int", "int", "float", "range", "range", "range", "tensorflow.expand_dims", "map", "float", "float", "int", "copy.deepcopy", "kernel_size_enc.append", "ideal_kernel_size_enc.append", "encoder_layers.append", "map", "centre_layers.append", "decoder_layers.append", "len", "tensorflow.variable_scope", "tensorflow.concat.get_shape().as_list", "tensorflow.concat.set_shape", "encoder_decoder_cnn.EncoderDecoderCNN.conf[].split", "int", "int", "ValueError", "math.ceil", "range", "int", "int", "numpy.mod", "numpy.mod", "nabu.neuralnetworks.components.layer.Conv2D", "int", "nabu.neuralnetworks.components.layer.Conv2D", "nabu.neuralnetworks.components.layer.Conv2D", "len", "tensorflow.variable_scope", "range", "tensorflow.variable_scope", "range", "tensorflow.variable_scope", "range", "tensorflow.expand_dims.get_shape", "math.ceil", "math.ceil", "float", "tensorflow.random_normal", "tensorflow.concat.get_shape", "Exception", "tensorflow.shape", "tensorflow.variable_scope", "encoder_outputs.append", "encoder_outputs_before_pool.append", "tensorflow.variable_scope", "tensorflow.variable_scope", "tensorflow.shape", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.concat", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.concat", "float", "Exception", "Exception", "tensorflow.concat", "nabu.neuralnetworks.components.layer.unpool", "Exception", "tensorflow.shape", "tensorflow.shape", "float", "float", "float"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.unpool"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "if", "'filters'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "kernel_size_lay1", "=", "map", "(", "int", ",", "self", ".", "conf", "[", "'filters'", "]", ".", "split", "(", "' '", ")", ")", "\n", "", "elif", "'filter_size_t'", "in", "self", ".", "conf", "and", "'filter_size_f'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "kernel_size_t_lay1", "=", "int", "(", "self", ".", "conf", "[", "'filter_size_t'", "]", ")", "\n", "kernel_size_f_lay1", "=", "int", "(", "self", ".", "conf", "[", "'filter_size_f'", "]", ")", "\n", "kernel_size_lay1", "=", "[", "kernel_size_t_lay1", ",", "kernel_size_f_lay1", "]", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'Kernel convolution size not specified.'", ")", "\n", "", "if", "'filter_size_t'", "in", "self", ".", "conf", "and", "'filter_size_f'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "kernel_size_t_fac_after_pool", "=", "float", "(", "self", ".", "conf", "[", "'filter_size_t_fac_after_pool'", "]", ")", "\n", "kernel_size_f_fac_after_pool", "=", "float", "(", "self", ".", "conf", "[", "'filter_size_f_fac_after_pool'", "]", ")", "\n", "kernel_fac_after_pool", "=", "[", "kernel_size_t_fac_after_pool", ",", "kernel_size_f_fac_after_pool", "]", "\n", "", "else", ":", "\n", "\t\t\t", "kernel_fac_after_pool", "=", "[", "1", ",", "1", "]", "\n", "\n", "", "f_pool_rate", "=", "int", "(", "self", ".", "conf", "[", "'f_pool_rate'", "]", ")", "\n", "t_pool_rate", "=", "int", "(", "self", ".", "conf", "[", "'t_pool_rate'", "]", ")", "\n", "num_encoder_layers", "=", "int", "(", "self", ".", "conf", "[", "'num_encoder_layers'", "]", ")", "\n", "num_decoder_layers", "=", "num_encoder_layers", "\n", "num_centre_layers", "=", "int", "(", "self", ".", "conf", "[", "'num_centre_layers'", "]", ")", "\n", "num_filters_1st_layer", "=", "int", "(", "self", ".", "conf", "[", "'num_filters_1st_layer'", "]", ")", "\n", "fac_per_layer", "=", "float", "(", "self", ".", "conf", "[", "'fac_per_layer'", "]", ")", "\n", "num_filters_enc", "=", "[", "\n", "int", "(", "math", ".", "ceil", "(", "num_filters_1st_layer", "*", "(", "fac_per_layer", "**", "l", ")", ")", ")", "\n", "for", "l", "in", "range", "(", "num_encoder_layers", ")", "]", "\n", "num_filters_dec", "=", "num_filters_enc", "[", ":", ":", "-", "1", "]", "\n", "num_filters_dec", "=", "num_filters_dec", "[", "1", ":", "]", "+", "[", "(", "int", "(", "self", ".", "conf", "[", "'num_output_filters'", "]", ")", ")", "]", "\n", "\n", "kernel_size_enc", "=", "[", "]", "\n", "ideal_kernel_size_enc", "=", "[", "kernel_size_lay1", "]", "\n", "\n", "bypass", "=", "self", ".", "conf", "[", "'bypass'", "]", "\n", "\n", "layer_norm", "=", "self", ".", "conf", "[", "'layer_norm'", "]", "==", "'True'", "\n", "\n", "if", "'activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "\n", "# the encoder layers", "\n", "", "encoder_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_encoder_layers", ")", ":", "\n", "\t\t\t", "kernel_size_l", "=", "copy", ".", "deepcopy", "(", "ideal_kernel_size_enc", "[", "l", "]", ")", "\n", "kernel_size_l_plus_1", "=", "kernel_size_l", "\n", "kernel_size_l", "=", "[", "int", "(", "math", ".", "ceil", "(", "k", ")", ")", "for", "k", "in", "kernel_size_l", "]", "\n", "kernel_size_enc", ".", "append", "(", "kernel_size_l", ")", "\n", "\n", "num_filters_l", "=", "num_filters_enc", "[", "l", "]", "\n", "\n", "max_pool_filter", "=", "[", "1", ",", "1", "]", "\n", "if", "np", ".", "mod", "(", "l", "+", "1", ",", "t_pool_rate", ")", "==", "0", ":", "\n", "\t\t\t\t", "max_pool_filter", "[", "0", "]", "=", "2", "\n", "kernel_size_l_plus_1", "[", "0", "]", "=", "kernel_size_l_plus_1", "[", "0", "]", "*", "kernel_fac_after_pool", "[", "0", "]", "\n", "", "if", "np", ".", "mod", "(", "l", "+", "1", ",", "f_pool_rate", ")", "==", "0", ":", "\n", "\t\t\t\t", "max_pool_filter", "[", "1", "]", "=", "2", "\n", "kernel_size_l_plus_1", "[", "1", "]", "=", "kernel_size_l_plus_1", "[", "1", "]", "*", "kernel_fac_after_pool", "[", "1", "]", "\n", "", "ideal_kernel_size_enc", ".", "append", "(", "kernel_size_l_plus_1", ")", "\n", "\n", "encoder_layers", ".", "append", "(", "layer", ".", "Conv2D", "(", "\n", "num_filters", "=", "num_filters_l", ",", "\n", "kernel_size", "=", "kernel_size_l", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation_fn", "=", "activation_fn", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "max_pool_filter", "=", "max_pool_filter", ")", ")", "\n", "\n", "# the centre layers", "\n", "", "centre_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_centre_layers", ")", ":", "\n", "\t\t\t", "num_filters_l", "=", "num_filters_enc", "[", "-", "1", "]", "\n", "kernel_size_l", "=", "ideal_kernel_size_enc", "[", "-", "1", "]", "\n", "kernel_size_l", "=", "map", "(", "int", "(", "math", ".", "ceil", "(", ")", ")", ",", "kernel_size_l", ")", "\n", "\n", "centre_layers", ".", "append", "(", "layer", ".", "Conv2D", "(", "\n", "num_filters", "=", "num_filters_l", ",", "\n", "kernel_size", "=", "kernel_size_l", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation_fn", "=", "activation_fn", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "max_pool_filter", "=", "(", "1", ",", "1", ")", ")", ")", "\n", "\n", "# the decoder layers", "\n", "", "decoder_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_decoder_layers", ")", ":", "\n", "\t\t\t", "corresponding_encoder_l", "=", "num_encoder_layers", "-", "1", "-", "l", "\n", "num_filters_l", "=", "num_filters_dec", "[", "l", "]", "\n", "kernel_size_l", "=", "kernel_size_enc", "[", "corresponding_encoder_l", "]", "\n", "if", "bypass", "==", "'unpool'", ":", "\n", "\t\t\t\t", "strides", "=", "[", "1", ",", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "strides", "=", "encoder_layers", "[", "corresponding_encoder_l", "]", ".", "max_pool_filter", "\n", "\n", "", "decoder_layers", ".", "append", "(", "layer", ".", "Conv2D", "(", "\n", "num_filters", "=", "num_filters_l", ",", "\n", "kernel_size", "=", "kernel_size_l", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation_fn", "=", "activation_fn", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "max_pool_filter", "=", "(", "1", ",", "1", ")", ",", "\n", "transpose", "=", "True", ")", ")", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of DCNN expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "", "if", "(", "num_encoder_layers", "+", "num_centre_layers", "+", "num_decoder_layers", ")", "==", "0", ":", "\n", "\t\t\t", "output", "=", "inputs", "\n", "return", "output", "\n", "\n", "# Convolutional layers expect input channels, making 1 here.", "\n", "", "inputs", "=", "tf", ".", "expand_dims", "(", "inputs", ",", "-", "1", ")", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "'encoder'", ")", ":", "\n", "\t\t\t\t", "encoder_outputs", "=", "[", "]", "\n", "encoder_outputs_before_pool", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_encoder_layers", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'layer_%s'", "%", "l", ")", ":", "\n", "\n", "\t\t\t\t\t\t", "logits", ",", "outputs_before_pool", "=", "encoder_layers", "[", "l", "]", "(", "logits", ")", "\n", "\n", "encoder_outputs", ".", "append", "(", "logits", ")", "\n", "encoder_outputs_before_pool", ".", "append", "(", "outputs_before_pool", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t\t\t", "raise", "Exception", "(", "'have to check whether dropout is implemented correctly'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "", "", "", "", "with", "tf", ".", "variable_scope", "(", "'centre'", ")", ":", "\n", "\t\t\t\t", "for", "l", "in", "range", "(", "num_centre_layers", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'layer_%s'", "%", "l", ")", ":", "\n", "\n", "\t\t\t\t\t\t", "logits", ",", "_", "=", "centre_layers", "[", "l", "]", "(", "logits", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t\t\t", "raise", "Exception", "(", "'have to check whether dropout is implemented correctly'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "", "", "", "", "with", "tf", ".", "variable_scope", "(", "'decoder'", ")", ":", "\n", "\t\t\t\t", "for", "l", "in", "range", "(", "num_decoder_layers", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'layer_%s'", "%", "l", ")", ":", "\n", "\t\t\t\t\t\t", "corresponding_encoder_l", "=", "num_encoder_layers", "-", "1", "-", "l", "\n", "corresponding_encoder_output", "=", "encoder_outputs", "[", "corresponding_encoder_l", "]", "\n", "corresponding_encoder_output_before_pool", "=", "encoder_outputs_before_pool", "[", "corresponding_encoder_l", "]", "\n", "corresponding_encoder_max_pool_filter", "=", "encoder_layers", "[", "corresponding_encoder_l", "]", ".", "max_pool_filter", "\n", "if", "bypass", "==", "'True'", "and", "(", "num_centre_layers", ">", "0", "or", "l", ">", "0", ")", ":", "\n", "# don't use bypass for layer 0 if no centre layers", "\n", "\t\t\t\t\t\t\t", "decoder_input", "=", "tf", ".", "concat", "(", "[", "logits", ",", "corresponding_encoder_output", "]", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "decoder_input", "=", "logits", "\n", "\n", "", "if", "bypass", "==", "'unpool'", "and", "corresponding_encoder_max_pool_filter", "!=", "[", "1", ",", "1", "]", ":", "\n", "\t\t\t\t\t\t\t", "decoder_input", "=", "layer", ".", "unpool", "(", "\n", "pool_input", "=", "corresponding_encoder_output_before_pool", ",", "\n", "pool_output", "=", "corresponding_encoder_output", ",", "unpool_input", "=", "decoder_input", ",", "\n", "pool_kernel_size", "=", "corresponding_encoder_max_pool_filter", ",", "\n", "pool_stride", "=", "corresponding_encoder_max_pool_filter", ",", "padding", "=", "'VALID'", ")", "\n", "\n", "", "logits", ",", "_", "=", "decoder_layers", "[", "l", "]", "(", "decoder_input", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t\t\t", "raise", "Exception", "(", "'have to check whether dropout is implemented correctly'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "# get wanted output size", "\n", "", "if", "corresponding_encoder_l", "==", "0", ":", "\n", "\t\t\t\t\t\t\t", "wanted_size", "=", "tf", ".", "shape", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "wanted_size", "=", "tf", ".", "shape", "(", "encoder_outputs", "[", "corresponding_encoder_l", "-", "1", "]", ")", "\n", "", "wanted_t_size", "=", "wanted_size", "[", "1", "]", "\n", "wanted_f_size", "=", "wanted_size", "[", "2", "]", "\n", "\n", "# get actual output size", "\n", "output_size", "=", "tf", ".", "shape", "(", "logits", ")", "\n", "output_t_size", "=", "output_size", "[", "1", "]", "\n", "output_f_size", "=", "output_size", "[", "2", "]", "\n", "\n", "# compensate for potential mismatch, by adding duplicates", "\n", "missing_t_size", "=", "wanted_t_size", "-", "output_t_size", "\n", "missing_f_size", "=", "wanted_f_size", "-", "output_f_size", "\n", "\n", "last_t_slice", "=", "tf", ".", "expand_dims", "(", "logits", "[", ":", ",", "-", "1", ",", ":", ",", ":", "]", ",", "1", ")", "\n", "duplicate_logits", "=", "tf", ".", "tile", "(", "last_t_slice", ",", "[", "1", ",", "missing_t_size", ",", "1", ",", "1", "]", ")", "\n", "logits", "=", "tf", ".", "concat", "(", "[", "logits", ",", "duplicate_logits", "]", ",", "1", ")", "\n", "last_f_slice", "=", "tf", ".", "expand_dims", "(", "logits", "[", ":", ",", ":", ",", "-", "1", ",", ":", "]", ",", "2", ")", "\n", "duplicate_logits", "=", "tf", ".", "tile", "(", "last_f_slice", ",", "[", "1", ",", "1", ",", "missing_f_size", ",", "1", "]", ")", "\n", "logits", "=", "tf", ".", "concat", "(", "[", "logits", ",", "duplicate_logits", "]", ",", "2", ")", "\n", "\n", "# set the shape of the logits as we know", "\n", "", "", "", "dyn_shape", "=", "logits", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "dyn_shape", "[", "-", "2", "]", "=", "inputs", ".", "get_shape", "(", ")", "[", "-", "2", "]", "\n", "logits", ".", "set_shape", "(", "dyn_shape", ")", "\n", "output", "=", "logits", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.feedforward.Feedforward._get_outputs": [[12, 76], ["int", "int", "float", "int", "len", "tensorflow.variable_scope", "range", "math.ceil", "range", "len", "tensorflow.contrib.layers.fully_connected", "tensorflow.nn.dropout", "float", "tensorflow.random_normal", "float", "float", "Exception", "tensorflow.shape", "float"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "num_layers", "=", "int", "(", "self", ".", "conf", "[", "'num_layers'", "]", ")", "\n", "num_units_first_layer", "=", "int", "(", "self", ".", "conf", "[", "'num_units'", "]", ")", "\n", "if", "'fac_per_layer'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "fac_per_layer", "=", "float", "(", "self", ".", "conf", "[", "'fac_per_layer'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "fac_per_layer", "=", "1.0", "\n", "", "num_units", "=", "[", "\n", "int", "(", "math", ".", "ceil", "(", "num_units_first_layer", "*", "(", "fac_per_layer", "**", "l", ")", ")", ")", "\n", "for", "l", "in", "range", "(", "num_layers", ")", "]", "\n", "\n", "# activation function", "\n", "if", "'activation_func'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_func'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_func'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "elif", "self", ".", "conf", "[", "'activation_func'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_func'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of Feedforward expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "for", "l", "in", "range", "(", "num_layers", ")", ":", "\n", "\t\t\t\t", "logits", "=", "tf", ".", "contrib", ".", "layers", ".", "fully_connected", "(", "\n", "inputs", "=", "logits", ",", "\n", "num_outputs", "=", "num_units", "[", "l", "]", ",", "\n", "activation_fn", "=", "activation_fn", ")", "\n", "\n", "", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t", "logits", "=", "tf", ".", "nn", ".", "dropout", "(", "logits", ",", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", ")", "\n", "\n", "", "output", "=", "logits", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.Model.__init__": [[12, 28], ["tensorflow.VariableScope", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", ",", "name", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Model constructor\n\n\t\tArgs:\n\t\t\tconf: The model configuration as a configparser object\n\t\t\"\"\"", "\n", "\n", "self", ".", "conf", "=", "conf", "\n", "\n", "# The number of outputs of the model is one by default.", "\n", "self", ".", "num_outputs", "=", "1", "\n", "\n", "# Whether the model is trainable. Default = True", "\n", "self", ".", "trainable", "=", "'trainable'", "not", "in", "conf", "or", "conf", "[", "'trainable'", "]", "==", "'True'", "\n", "\n", "self", ".", "scope", "=", "tf", ".", "VariableScope", "(", "False", ",", "name", "or", "type", "(", "self", ")", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.Model.__call__": [[29, 69], ["model.Model._get_outputs", "model.Model.scope.reuse_variables", "hasattr", "tensorflow.get_collection_ref", "tensorflow.get_collection_ref.remove"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_loss_evaluator.TaskLossEvaluator._get_outputs"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\n", "\t\t", "\"\"\"\n\t\tAdd the neural net variables and operations to the graph.\n\t\tThe model scope attribute reuse is initialized to False. After it has\n\t\tbeen called for the first time, it is set to True, so that the weights\n\t\tare shared when it is called the next time\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a dictionary of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a dictionary of [batch_size] vectors\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output logits, which is a dictionary of [batch_size x time x ...]\n\t\t\t\ttensors\n\t\t\t- the output logits sequence lengths which is a dictionary of\n\t\t\t\t[batch_size] vectors\n\t\t\"\"\"", "\n", "\n", "# compute the output logits", "\n", "logits", "=", "self", ".", "_get_outputs", "(", "\n", "inputs", "=", "inputs", ",", "\n", "input_seq_length", "=", "input_seq_length", ",", "\n", "is_training", "=", "is_training", ")", "\n", "\n", "self", ".", "scope", ".", "reuse_variables", "(", ")", "\n", "\n", "if", "hasattr", "(", "self", ",", "'trainable'", ")", "and", "not", "self", ".", "trainable", ":", "\n", "# Find all variables of the model", "\n", "\t\t\t", "model_variables", "=", "self", ".", "variables", "\n", "# remove variable from trainable variables list", "\n", "trainable_collection", "=", "tf", ".", "get_collection_ref", "(", "tf", ".", "GraphKeys", ".", "TRAINABLE_VARIABLES", ")", "\n", "for", "var", "in", "model_variables", ":", "\n", "\t\t\t\t", "if", "var", "in", "trainable_collection", ":", "\n", "\t\t\t\t\t", "trainable_collection", ".", "remove", "(", "var", ")", "\n", "\n", "", "", "", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.Model.variables": [[70, 75], ["tensorflow.get_collection"], "methods", ["None"], ["", "@", "property", "\n", "def", "variables", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"get a list of the models's variables\"\"\"", "\n", "\n", "return", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "GLOBAL_VARIABLES", ",", "scope", "=", "self", ".", "scope", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.Model._get_outputs": [[76, 92], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tAdd the neural net variables and operations to the graph\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a dictionary of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a dictionary of [batch_size] vectors\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output logits, which is a dictionary of [batch_size x time x ...]\n\t\t\t\ttensors\n\t\t\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.__init__": [[98, 106], ["model.Model.__init__", "int"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "name", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"IterableModel constructor\n\n\t\tArgs:\n\t\t\tconf: The model configuration as a configparser object\n\t\t\"\"\"", "\n", "super", "(", "IterableModel", ",", "self", ")", ".", "__init__", "(", "conf", ",", "name", "=", "name", ")", "\n", "self", ".", "max_iters", "=", "int", "(", "conf", "[", "'max_iters'", "]", ")", "or", "100", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.__call__": [[107, 138], ["model.IterableModel._get_iterable_outputs", "model.IterableModel.scope.reuse_variables"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel._get_iterable_outputs"], ["", "def", "__call__", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\n", "\t\t", "\"\"\"\n\t\tAdd the neural net variables and operations to the graph.\n\t\tThe model scope attribute reuse is initialized to False. After it has\n\t\tbeen called for the first time, it is set to True, so that the weights\n\t\tare shared when it is called the next time\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a dictionary of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a dictionary of [batch_size] vectors\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output logits, which is a dictionary of [batch_size x time x ...]\n\t\t\t\ttensors\n\t\t\t- the output logits sequence lengths which is a dictionary of\n\t\t\t\t[batch_size] vectors\n\t\t\"\"\"", "\n", "\n", "# compute the output logits", "\n", "logits", "=", "self", ".", "_get_iterable_outputs", "(", "\n", "inputs", "=", "inputs", ",", "\n", "input_seq_length", "=", "input_seq_length", ",", "\n", "is_training", "=", "is_training", ")", "\n", "\n", "self", ".", "scope", ".", "reuse_variables", "(", ")", "\n", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel._get_iterable_outputs": [[139, 172], ["model.IterableModel.output_inds", "tensorflow.variable_scope", "tensorflow.while_loop", "len", "model.IterableModel.zero_state"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.output_inds", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.zero_state"], ["", "def", "_get_iterable_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tAdd the neural net variables and operations to the graph\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a dictionary of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a dictionary of [batch_size] vectors\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output logits, which is a dictionary of [batch_size x time x ...]\n\t\t\t\ttensors\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "logits", "=", "tf", ".", "while_loop", "(", "\n", "cond", "=", "self", ".", "stop_condition", ",", "\n", "body", "=", "self", ".", "_get_outputs", ",", "\n", "loop_vars", "=", "[", "self", ".", "zero_state", "(", "inputs", ",", "input_seq_length", ",", "is_training", ")", "]", ",", "\n", "back_prop", "=", "True", ",", "\n", "maximum_iterations", "=", "self", ".", "max_iters", "\n", ")", "\n", "\n", "# set iteration dimension last", "\n", "", "output_indices", "=", "self", ".", "output_inds", "(", ")", "\n", "if", "len", "(", "output_indices", ")", "==", "1", ":", "\n", "\t\t\t", "outputs", "=", "logits", "[", "output_indices", "[", "0", "]", "]", "\n", "", "else", ":", "\n", "\t\t\t", "outputs", "=", "logits", "[", "output_indices", "]", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel._get_outputs": [[173, 185], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_get_outputs", "(", "self", ",", "inputs", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tAdd the neural net variables and operations to the graph\n\n\t\tArgs:\n\t\t\tinputs: see zero_state\n\n\t\tReturns:\n\t\t\t- output logits, which is a dictionary of [batch_size x time x ...]\n\t\t\t\ttensors\n\t\t\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.stop_condition": [[186, 198], ["None"], "methods", ["None"], ["", "def", "stop_condition", "(", "self", ",", "state", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tDefine a stop condition to halt the iterative process\n\n\t\tArgs:\n\t\t\tstate: the state of the iterative process\n\n\t\tReturns:\n\t\t\tstop_cond: a boolean indicating wether to stop or not\n\t\t\"\"\"", "\n", "stop_cond", "=", "state", ".", "iter_count", "<", "self", ".", "max_iters", "\n", "return", "stop_cond", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.zero_state": [[199, 216], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "zero_state", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\n", "\t\t", "\"\"\"\n\t\tDefine a zero state to initialize the iterative process\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a dictionary of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a dictionary of [batch_size] vectors\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\tzero_state: initial state for the iterative process\n\n\t\t\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.model.IterableModel.output_inds": [[217, 228], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "output_inds", "(", "self", ")", ":", "\n", "\n", "\t\t", "\"\"\"\n\t\tIndices that indicate with loopvariables will be used in the output of the model\n\n\t\tReturns:\n\t\t\tindices: indicate with loopvariables will be used in the output of the model\n\n\t\t\"\"\"", "", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.reconstruction_layer.Reconstruction_Layer._get_outputs": [[11, 40], ["len", "Exception", "tensorflow.variable_scope", "tensorflow.multiply", "tensorflow.where", "tensorflow.log", "tensorflow.log", "tensorflow.constant", "len", "tensorflow.ones_like"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "        ", "'''\n        Create the variables and do the forward computation\n\n        Args:\n            inputs: the inputs to the neural network, this is a list of\n                [batch_size x time x ...] tensors\n            input_seq_length: The sequence lengths of the input utterances, this\n                is a [batch_size] vector\n            is_training: whether or not the network is in training mode\n\n        Returns:\n            - output, which is a [batch_size x time x ...] tensors\n        '''", "\n", "\n", "#code not available for multiple inputs!!", "\n", "if", "len", "(", "inputs", ")", "!=", "2", ":", "\n", "            ", "raise", "Exception", "(", "'The implementation of Reconstruction layer expects 2 inputs and not %d'", "%", "len", "(", "inputs", ")", ")", "\n", "", "else", ":", "\n", "            ", "signal", "=", "inputs", "[", "0", "]", "\n", "mask", "=", "inputs", "[", "1", "]", "\n", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "            ", "output", "=", "tf", ".", "multiply", "(", "mask", ",", "signal", ")", "\n", "output", "=", "tf", ".", "where", "(", "output", "<=", "1e-30", ",", "tf", ".", "ones_like", "(", "output", ")", "*", "1e-30", ",", "output", ")", "\n", "nom", "=", "10", "*", "tf", ".", "log", "(", "output", ")", "\n", "denom", "=", "tf", ".", "log", "(", "tf", ".", "constant", "(", "10", ",", "dtype", "=", "nom", ".", "dtype", ")", ")", "\n", "", "return", "nom", "/", "denom", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dbresetlstm_insert_additional_input.DBResetLSTM._get_outputs": [[15, 152], ["int", "int", "map.split", "map", "any", "map", "any", "float", "concat.Concat", "len", "ValueError", "group_sizes.split.split.split", "len", "ValueError", "len", "Exception", "int", "tensorflow.variable_scope", "range", "tensorflow.concat", "nabu.neuralnetworks.components.layer.BResetLSTMLayer", "nabu.neuralnetworks.components.layer.BResetLSTMLayer.", "Exception", "range", "numpy.mod", "zip", "len", "float", "tensorflow.random_normal", "tensorflow.expand_dims", "int", "tensorflow.tile", "dbresetlstm_insert_additional_input.permute_versions", "numpy.ones().tolist", "tensorflow.stack", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.concat", "tensorflow.concat", "float", "Exception", "tensorflow.shape", "tensorflow.constant", "tensorflow.shape", "tensorflow.shape", "tensorflow.expand_dims", "str", "float", "float", "float", "numpy.ones", "len", "tensorflow.concat.get_shape"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dbresetlstm_insert_additional_input.permute_versions"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "# the bresetlstm layer", "\n", "num_units", "=", "int", "(", "self", ".", "conf", "[", "'num_units'", "]", ")", "\n", "num_lay", "=", "int", "(", "self", ".", "conf", "[", "'num_layers'", "]", ")", "\n", "t_resets", "=", "self", ".", "conf", "[", "'t_reset'", "]", "\n", "t_resets", "=", "t_resets", ".", "split", "(", "' '", ")", "\n", "if", "len", "(", "t_resets", ")", "==", "1", ":", "\n", "\t\t\t", "t_resets", "=", "t_resets", "*", "num_lay", "\n", "", "t_resets", "=", "map", "(", "int", ",", "t_resets", ")", "\n", "if", "any", "(", "[", "t_resets", "[", "l", "+", "1", "]", "<", "t_resets", "[", "l", "]", "for", "l", "in", "range", "(", "num_lay", "-", "1", ")", "]", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'T_reset in next layer must be equal to or bigger than T_reset in current layer'", ")", "\n", "", "if", "'group_size'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "group_sizes", "=", "self", ".", "conf", "[", "'group_size'", "]", "\n", "group_sizes", "=", "group_sizes", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "\t\t\t", "group_sizes", "=", "'1'", "\n", "", "if", "len", "(", "group_sizes", ")", "==", "1", ":", "\n", "\t\t\t", "group_sizes", "=", "group_sizes", "*", "num_lay", "\n", "", "group_sizes", "=", "map", "(", "int", ",", "group_sizes", ")", "\n", "if", "any", "(", "[", "np", ".", "mod", "(", "t_res", ",", "group_size", ")", "!=", "0", "for", "t_res", ",", "group_size", "in", "zip", "(", "t_resets", ",", "group_sizes", ")", "]", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'t_reset should be a multiple of group_size'", ")", "\n", "\n", "", "if", "'forward_reset'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "forward_reset", "=", "self", ".", "conf", "[", "'forward_reset'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "forward_reset", "=", "True", "\n", "", "if", "'backward_reset'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "backward_reset", "=", "self", ".", "conf", "[", "'backward_reset'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "backward_reset", "=", "True", "\n", "\n", "", "if", "'separate_directions'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "separate_directions", "=", "self", ".", "conf", "[", "'separate_directions'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "separate_directions", "=", "False", "\n", "\n", "", "layer_norm", "=", "self", ".", "conf", "[", "'layer_norm'", "]", "==", "'True'", "\n", "recurrent_dropout", "=", "float", "(", "self", ".", "conf", "[", "'recurrent_dropout'", "]", ")", "\n", "if", "'activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "2", ":", "\n", "\t\t\t", "raise", "Exception", "(", "'The implementation of DBLSTM expects 2 input and not %d'", "%", "len", "(", "inputs", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "add_input", "=", "inputs", "[", "1", "]", "\n", "inputs", "=", "inputs", "[", "0", "]", "\n", "\n", "# combine output of first lstm layers with additional input. combine_layer indicates which layer will receive", "\n", "# the combination as input", "\n", "", "self", ".", "combine_layer", "=", "int", "(", "self", ".", "conf", "[", "'combine_layer'", "]", ")", "-", "1", "\n", "\n", "# concat model to combine output of first  combine_layer lstm layers with additional input", "\n", "self", ".", "concat_model", "=", "concat", ".", "Concat", "(", "self", ".", "conf", ")", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "for", "l", "in", "range", "(", "num_lay", ")", ":", "\n", "\n", "\t\t\t\t", "blstm", "=", "layer", ".", "BResetLSTMLayer", "(", "\n", "num_units", "=", "num_units", ",", "\n", "t_reset", "=", "t_resets", "[", "l", "]", ",", "\n", "group_size", "=", "group_sizes", "[", "l", "]", ",", "\n", "forward_reset", "=", "forward_reset", ",", "\n", "backward_reset", "=", "backward_reset", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "activation_fn", "=", "activation_fn", ")", "\n", "\n", "if", "l", "==", "0", ":", "\n", "# expand the dimension of inputs since the reset lstm expect multistate input", "\n", "\t\t\t\t\t", "multistate_input", "=", "tf", ".", "expand_dims", "(", "logits", ",", "2", ")", "\n", "num_replicates", "=", "int", "(", "float", "(", "t_resets", "[", "l", "]", ")", "/", "float", "(", "group_sizes", "[", "l", "]", ")", ")", "\n", "multistate_input", "=", "tf", ".", "tile", "(", "multistate_input", ",", "tf", ".", "constant", "(", "[", "1", ",", "1", ",", "num_replicates", ",", "1", "]", ")", ")", "\n", "if", "forward_reset", ":", "\n", "\t\t\t\t\t\t", "for_forward", "=", "multistate_input", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "for_forward", "=", "logits", "\n", "", "if", "backward_reset", ":", "\n", "\t\t\t\t\t\t", "for_backward", "=", "multistate_input", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t", "for_backward", "=", "logits", "\n", "", "", "else", ":", "\n", "\t\t\t\t\t", "for_forward", ",", "for_backward", "=", "permute_versions", "(", "\n", "logits_multistate", ",", "logits", ",", "input_seq_length", ",", "t_resets", "[", "l", "]", ",", "t_resets", "[", "l", "-", "1", "]", ",", "group_sizes", "[", "l", "]", ",", "\n", "group_sizes", "[", "l", "-", "1", "]", ",", "forward_reset", ",", "backward_reset", ",", "separate_directions", ")", "\n", "\n", "", "if", "l", "==", "self", ".", "combine_layer", ":", "\n", "\t\t\t\t\t", "multiplicates", "=", "np", ".", "ones", "(", "len", "(", "for_forward", ".", "get_shape", "(", ")", ")", ",", "np", ".", "int", ")", ".", "tolist", "(", ")", "\n", "multiplicates", "[", "1", "]", "=", "tf", ".", "shape", "(", "for_forward", ")", "[", "1", "]", "\n", "multiplicates", "[", "2", "]", "=", "tf", ".", "shape", "(", "for_forward", ")", "[", "2", "]", "\n", "multiplicates", "=", "tf", ".", "stack", "(", "multiplicates", ")", "\n", "\n", "add_input_broadcast", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "add_input", ",", "1", ")", ",", "-", "2", ")", "\n", "add_input_broadcast", "=", "tf", ".", "tile", "(", "add_input_broadcast", ",", "multiplicates", ")", "\n", "\n", "for_forward", "=", "tf", ".", "concat", "(", "[", "for_forward", ",", "add_input_broadcast", "]", ",", "-", "1", ")", "\n", "for_backward", "=", "tf", ".", "concat", "(", "[", "for_backward", ",", "add_input_broadcast", "]", ",", "-", "1", ")", "\n", "\n", "", "logits", ",", "logits_multistate", "=", "blstm", "(", "for_forward", ",", "for_backward", ",", "input_seq_length", ",", "'layer'", "+", "str", "(", "l", ")", ")", "\n", "\n", "", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'dropout not yet implemented for state reset lstm'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "", "output", "=", "tf", ".", "concat", "(", "logits", ",", "-", "1", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dbresetlstm_insert_additional_input.permute_versions": [[154, 251], ["int", "int", "tensorflow.expand_dims", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.expand_dims", "tensorflow.tile", "numpy.expand_dims", "tensorflow.tile", "tensorflow.mod", "tensorflow.minimum", "tensorflow.mod", "tensorflow.minimum", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.range", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.stack", "tensorflow.stack", "tensorflow.stack", "tensorflow.stack", "forward_output.get_shape", "tensorflow.shape", "ValueError", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "numpy.expand_dims", "tensorflow.constant", "tensorflow.mod", "tensorflow.mod", "tensorflow.mod", "tensorflow.mod", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.concat", "tensorflow.concat", "numpy.mod", "numpy.mod", "float", "float", "float", "float", "range", "numpy.expand_dims", "tensorflow.ceil", "tensorflow.ceil", "tensorflow.ceil", "tensorflow.ceil", "tensorflow.tile", "tensorflow.truediv", "tensorflow.truediv", "tensorflow.truediv", "tensorflow.truediv", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.expand_dims"], "function", ["None"], ["", "", "def", "permute_versions", "(", "\n", "replicas", ",", "actual_outputs", ",", "sequence_length", ",", "t_reset", ",", "previous_t_reset", ",", "group_size", ",", "previous_group_size", ",", "\n", "forward_reset", "=", "True", ",", "backward_reset", "=", "True", ",", "separate_directions", "=", "False", ")", ":", "\n", "\t", "forward_output", "=", "actual_outputs", "[", "0", "]", "\n", "backward_output", "=", "actual_outputs", "[", "1", "]", "\n", "forward_replicas", "=", "replicas", "[", "0", "]", "\n", "backward_replicas", "=", "replicas", "[", "1", "]", "\n", "\n", "batch_size", "=", "forward_output", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "max_length", "=", "tf", ".", "shape", "(", "forward_output", ")", "[", "1", "]", "\n", "\n", "int_dtype", "=", "sequence_length", ".", "dtype", "\n", "if", "np", ".", "mod", "(", "t_reset", ",", "group_size", ")", "!=", "0", "or", "np", ".", "mod", "(", "previous_t_reset", ",", "previous_group_size", ")", "!=", "0", ":", "\n", "\t\t", "raise", "ValueError", "(", "'Reset period must be multiple of group size'", ")", "\n", "", "num_replicas", "=", "int", "(", "float", "(", "t_reset", ")", "/", "float", "(", "group_size", ")", ")", "\n", "previous_num_replicas", "=", "int", "(", "float", "(", "previous_t_reset", ")", "/", "float", "(", "previous_group_size", ")", ")", "\n", "# the output replicas need to be permuted correctly such that the next layer receives", "\n", "# the replicas in the correct order", "\n", "\n", "# T: [B,1, 1]", "\n", "T", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "sequence_length", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "\n", "# numbers_to_maxT: [B,Tmax,k]", "\n", "numbers_to_maxT", "=", "tf", ".", "range", "(", "0", ",", "max_length", ")", "\n", "numbers_to_maxT", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "numbers_to_maxT", ",", "0", ")", ",", "-", "1", ")", "\n", "numbers_to_maxT", "=", "tf", ".", "tile", "(", "numbers_to_maxT", ",", "[", "batch_size", ",", "1", ",", "num_replicas", "]", ")", "\n", "reversed_numbers_to_maxT", "=", "T", "-", "1", "-", "numbers_to_maxT", "\n", "\n", "# numbers_to_k: [B,Tmax,k]", "\n", "numbers_to_k", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "range", "(", "0", ",", "num_replicas", ")", ",", "0", ")", ",", "0", ")", "\n", "numbers_to_k", "=", "tf", ".", "tile", "(", "numbers_to_k", ",", "[", "batch_size", ",", "max_length", ",", "1", "]", ")", "\n", "\n", "# taus", "\n", "max_tau", "=", "previous_t_reset", "-", "1", "\n", "max_tau", "=", "np", ".", "expand_dims", "(", "np", ".", "expand_dims", "(", "np", ".", "expand_dims", "(", "max_tau", ",", "-", "1", ")", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "max_tau_tf", "=", "tf", ".", "tile", "(", "tf", ".", "constant", "(", "max_tau", ",", "dtype", "=", "int_dtype", ")", ",", "[", "batch_size", ",", "max_length", ",", "num_replicas", "]", ")", "\n", "tau_forward", "=", "tf", ".", "mod", "(", "numbers_to_maxT", "-", "group_size", "*", "numbers_to_k", ",", "t_reset", ")", "\n", "tau_forward", "=", "tf", ".", "minimum", "(", "tau_forward", ",", "max_tau_tf", ")", "\n", "tau_backward", "=", "tf", ".", "mod", "(", "reversed_numbers_to_maxT", "-", "group_size", "*", "numbers_to_k", ",", "t_reset", ")", "\n", "tau_backward", "=", "tf", ".", "minimum", "(", "tau_backward", ",", "max_tau_tf", ")", "\n", "\n", "# forward for forward", "\n", "forward_indices_for_forward", "=", "tf", ".", "cast", "(", "tf", ".", "mod", "(", "\n", "tf", ".", "ceil", "(", "tf", ".", "truediv", "(", "numbers_to_maxT", "-", "tau_forward", ",", "previous_group_size", ")", ")", ",", "previous_num_replicas", ")", ",", "int_dtype", ")", "\n", "\n", "# backward for forward", "\n", "backward_indices_for_forward", "=", "tf", ".", "cast", "(", "tf", ".", "mod", "(", "\n", "tf", ".", "ceil", "(", "tf", ".", "truediv", "(", "reversed_numbers_to_maxT", "-", "tau_forward", ",", "previous_group_size", ")", ")", ",", "previous_num_replicas", ")", ",", "int_dtype", ")", "\n", "\n", "# backward for backward", "\n", "backward_indices_for_backward", "=", "tf", ".", "cast", "(", "tf", ".", "mod", "(", "\n", "tf", ".", "ceil", "(", "tf", ".", "truediv", "(", "reversed_numbers_to_maxT", "-", "tau_backward", ",", "previous_group_size", ")", ")", ",", "previous_num_replicas", ")", ",", "int_dtype", ")", "\n", "\n", "# forward for backward", "\n", "forward_indices_for_backward", "=", "tf", ".", "cast", "(", "tf", ".", "mod", "(", "\n", "tf", ".", "ceil", "(", "tf", ".", "truediv", "(", "numbers_to_maxT", "-", "tau_backward", ",", "previous_group_size", ")", ")", ",", "previous_num_replicas", ")", ",", "int_dtype", ")", "\n", "\n", "# ra1: [B,Tmax,k]", "\n", "ra1", "=", "tf", ".", "range", "(", "batch_size", ")", "\n", "ra1", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "ra1", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "ra1", "=", "tf", ".", "tile", "(", "ra1", ",", "[", "1", ",", "max_length", ",", "num_replicas", "]", ")", "\n", "ra2", "=", "tf", ".", "range", "(", "max_length", ")", "\n", "ra2", "=", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "ra2", ",", "0", ")", ",", "-", "1", ")", "\n", "ra2", "=", "tf", ".", "tile", "(", "ra2", ",", "[", "batch_size", ",", "1", ",", "num_replicas", "]", ")", "\n", "stacked_forward_indices_for_forward", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "forward_indices_for_forward", "]", ",", "axis", "=", "-", "1", ")", "\n", "stacked_backward_indices_for_forward", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "backward_indices_for_forward", "]", ",", "axis", "=", "-", "1", ")", "\n", "stacked_forward_indices_for_backward", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "forward_indices_for_backward", "]", ",", "axis", "=", "-", "1", ")", "\n", "stacked_backward_indices_for_backward", "=", "tf", ".", "stack", "(", "[", "ra1", ",", "ra2", ",", "backward_indices_for_backward", "]", ",", "axis", "=", "-", "1", ")", "\n", "\n", "if", "forward_reset", ":", "\n", "\t\t", "forward_for_forward", "=", "tf", ".", "gather_nd", "(", "forward_replicas", ",", "stacked_forward_indices_for_forward", ")", "\n", "", "else", ":", "\n", "\t\t", "forward_for_forward", "=", "forward_output", "\n", "\n", "", "if", "backward_reset", ":", "\n", "\t\t", "backward_for_backward", "=", "tf", ".", "gather_nd", "(", "backward_replicas", ",", "stacked_backward_indices_for_backward", ")", "\n", "", "else", ":", "\n", "\t\t", "backward_for_backward", "=", "backward_output", "\n", "\n", "", "if", "forward_reset", "and", "backward_reset", ":", "\n", "\t\t", "backward_for_forward", "=", "tf", ".", "gather_nd", "(", "backward_replicas", ",", "stacked_backward_indices_for_forward", ")", "\n", "forward_for_backward", "=", "tf", ".", "gather_nd", "(", "forward_replicas", ",", "stacked_forward_indices_for_backward", ")", "\n", "", "elif", "forward_reset", "and", "not", "backward_reset", ":", "\n", "\t\t", "backward_for_forward", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "backward_output", ",", "-", "2", ")", ",", "[", "1", ",", "1", ",", "num_replicas", ",", "1", "]", ")", "\n", "forward_for_backward", "=", "forward_output", "\n", "", "elif", "not", "forward_reset", "and", "backward_reset", ":", "\n", "\t\t", "backward_for_forward", "=", "backward_output", "\n", "forward_for_backward", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "forward_output", ",", "-", "2", ")", ",", "[", "1", ",", "1", ",", "num_replicas", ",", "1", "]", ")", "\n", "\n", "", "if", "separate_directions", ":", "\n", "\t\t", "for_forward", "=", "forward_for_forward", "\n", "for_backward", "=", "backward_for_backward", "\n", "", "else", ":", "\n", "\t\t", "for_forward", "=", "tf", ".", "concat", "(", "(", "forward_for_forward", ",", "backward_for_forward", ")", ",", "-", "1", ")", "\n", "for_backward", "=", "tf", ".", "concat", "(", "(", "forward_for_backward", ",", "backward_for_backward", ")", ",", "-", "1", ")", "\n", "\n", "", "return", "for_forward", ",", "for_backward", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dblstm.DBLSTM._get_outputs": [[14, 137], ["int", "int", "float", "range", "float", "int", "blstm_layers.append", "len", "tensorflow.variable_scope", "tensorflow.reshape.get_shape", "range", "math.ceil", "range", "nabu.neuralnetworks.components.layer.BLSTMLayer", "len", "len", "tensorflow.concat", "tensorflow.reshape.get_shape", "tensorflow.reshape", "len", "float", "tensorflow.random_normal", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.reshape", "BaseException", "tensorflow.nn.dropout", "tensorflow.stack", "tensorflow.reshape.get_shape", "Exception", "tensorflow.shape", "str", "float", "float", "BaseException", "float", "numpy.prod", "numpy.prod", "other_dims.as_list"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "# the blstm layer", "\n", "num_layers", "=", "int", "(", "self", ".", "conf", "[", "'num_layers'", "]", ")", "\n", "num_units_first_layer", "=", "int", "(", "self", ".", "conf", "[", "'num_units'", "]", ")", "\n", "if", "'fac_per_layer'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "fac_per_layer", "=", "float", "(", "self", ".", "conf", "[", "'fac_per_layer'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "fac_per_layer", "=", "1.0", "\n", "", "num_units", "=", "[", "\n", "int", "(", "math", ".", "ceil", "(", "num_units_first_layer", "*", "(", "fac_per_layer", "**", "l", ")", ")", ")", "\n", "for", "l", "in", "range", "(", "num_layers", ")", "]", "\n", "\n", "layer_norm", "=", "self", ".", "conf", "[", "'layer_norm'", "]", "==", "'True'", "\n", "recurrent_dropout", "=", "float", "(", "self", ".", "conf", "[", "'recurrent_dropout'", "]", ")", "\n", "if", "'activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "\n", "# Taking only the last frame output makes less sense in a bi-directional network", "\n", "", "only_last_frame", "=", "'only_last_frame'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'only_last_frame'", "]", "==", "'True'", "\n", "\n", "separate_directions", "=", "False", "\n", "if", "'separate_directions'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'separate_directions'", "]", "==", "'True'", ":", "\n", "\t\t\t", "separate_directions", "=", "True", "\n", "\n", "", "allow_more_than_3dim", "=", "False", "\n", "if", "'allow_more_than_3dim'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'allow_more_than_3dim'", "]", "==", "'True'", ":", "\n", "# Assuming time dimension is one to last", "\n", "\t\t\t", "allow_more_than_3dim", "=", "True", "\n", "\n", "", "blstm_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_layers", ")", ":", "\n", "\t\t\t", "blstm_layers", ".", "append", "(", "layer", ".", "BLSTMLayer", "(", "\n", "num_units", "=", "num_units", "[", "l", "]", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "activation_fn", "=", "activation_fn", ",", "\n", "separate_directions", "=", "separate_directions", ",", "\n", "fast_version", "=", "False", ")", ")", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of DBLSTM expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "", "if", "num_layers", "==", "0", ":", "\n", "\t\t\t", "output", "=", "inputs", "\n", "return", "output", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "input_shape", "=", "inputs", ".", "get_shape", "(", ")", "\n", "input_reshaped", "=", "False", "\n", "if", "len", "(", "input_shape", ")", ">", "3", ":", "\n", "\t\t\t\t", "if", "allow_more_than_3dim", ":", "\n", "\t\t\t\t\t", "batch_size", "=", "input_shape", "[", "0", "]", "\n", "other_dims", "=", "input_shape", "[", "1", ":", "-", "2", "]", "\n", "num_inp_units", "=", "input_shape", "[", "-", "1", "]", "\n", "inputs", "=", "tf", ".", "reshape", "(", "inputs", ",", "[", "batch_size", "*", "np", ".", "prod", "(", "other_dims", ")", ",", "-", "1", ",", "num_inp_units", "]", ")", "\n", "input_seq_length", "=", "tf", ".", "expand_dims", "(", "input_seq_length", ",", "-", "1", ")", "\n", "input_seq_length", "=", "tf", ".", "tile", "(", "input_seq_length", ",", "[", "1", ",", "np", ".", "prod", "(", "other_dims", ")", "]", ")", "\n", "input_seq_length", "=", "tf", ".", "reshape", "(", "input_seq_length", ",", "[", "-", "1", "]", ")", "\n", "input_reshaped", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "raise", "BaseException", "(", "'Input has to many dimensions'", ")", "\n", "\n", "", "", "logits", "=", "inputs", "\n", "\n", "if", "separate_directions", ":", "\n", "\t\t\t\t", "logits", "=", "(", "logits", ",", "logits", ")", "\n", "\n", "", "for", "l", "in", "range", "(", "num_layers", ")", ":", "\n", "\t\t\t\t", "logits", "=", "blstm_layers", "[", "l", "]", "(", "logits", ",", "input_seq_length", ",", "'layer'", "+", "str", "(", "l", ")", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t", "logits", "=", "tf", ".", "nn", ".", "dropout", "(", "logits", ",", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", ")", "\n", "\n", "", "", "output", "=", "logits", "\n", "\n", "if", "separate_directions", ":", "\n", "\t\t\t\t", "output", "=", "tf", ".", "concat", "(", "output", ",", "2", ")", "\n", "\n", "", "if", "input_reshaped", ":", "\n", "\t\t\t\t", "output_shape", "=", "output", ".", "get_shape", "(", ")", "\n", "num_output_units", "=", "output_shape", "[", "-", "1", "]", "\n", "output", "=", "tf", ".", "reshape", "(", "output", ",", "tf", ".", "stack", "(", "[", "batch_size", "]", "+", "other_dims", ".", "as_list", "(", ")", "+", "[", "-", "1", "]", "+", "[", "num_output_units", "]", ",", "0", ")", ")", "\n", "\n", "", "if", "only_last_frame", ":", "\n", "\t\t\t\t", "output_rank", "=", "len", "(", "output", ".", "get_shape", "(", ")", ")", "\n", "if", "output_rank", "==", "3", ":", "\n", "\t\t\t\t\t", "output", "=", "output", "[", ":", ",", "-", "1", ",", ":", "]", "\n", "", "elif", "output_rank", "==", "4", "and", "allow_more_than_3dim", ":", "\n", "\t\t\t\t\t", "output", "=", "output", "[", ":", ",", ":", ",", "-", "1", ",", ":", "]", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "raise", "BaseException", "(", "'Not yet implemented for rank different from 3 (or 4)'", ")", "\n", "\n", "", "", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.attractor.Attractor._get_outputs": [[12, 93], ["len", "tensorflow.to_float", "tensorflow.matmul", "tensorflow.where", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.divide", "tensorflow.to_float.get_shape", "data.get_shape", "data.get_shape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.multiply", "tensorflow.tile", "tensorflow.to_float", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.multiply", "tensorflow.reshape", "tensorflow.to_float", "tensorflow.multiply", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.less", "tensorflow.ones_like", "tensorflow.nn.l2_normalize", "BaseException", "data.get_shape", "labels.get_shape", "tensorflow.ones_like", "len", "BaseException", "data.get_shape", "len", "len", "data.get_shape"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCaclulates the attractors of the first input based on the second input and third input\n\n\t\tArgs:\n\t\t\tinputs: the inputs to concatenate, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors and/or [batch_size x ...] tensors\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, the concatenated inputs\n\t\t\"\"\"", "\n", "num_inputs", "=", "len", "(", "inputs", ")", "\n", "\n", "if", "num_inputs", "==", "3", ":", "\n", "\t\t\t", "data", "=", "inputs", "[", "0", "]", "\n", "labels", "=", "inputs", "[", "1", "]", "\n", "usedbins", "=", "inputs", "[", "2", "]", "\n", "data_per_spk", "=", "False", "\n", "", "elif", "num_inputs", "==", "2", ":", "\n", "\t\t\t", "data", "=", "inputs", "[", "0", "]", "\n", "usedbins", "=", "inputs", "[", "1", "]", "\n", "if", "len", "(", "data", ".", "get_shape", "(", ")", ")", "!=", "4", ":", "\n", "\t\t\t\t", "raise", "BaseException", "(", "\n", "'If Attractor only receives 2 inputs, data and usedbins, it expects data to have 4 dimensions '", "\n", "'(batch_size x num_speakers x time x num_un) and not %d.'", "%", "len", "(", "data", ".", "get_shape", "(", ")", ")", ")", "\n", "", "data_per_spk", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "'The implementation of Attractor does not expect %d inputs'", "%", "len", "(", "inputs", ")", ")", "\n", "\n", "", "feat_dim", "=", "usedbins", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "output_dim", "=", "data", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "emb_dim", "=", "output_dim", "/", "feat_dim", "\n", "\n", "if", "data_per_spk", ":", "\n", "\t\t\t", "nrS", "=", "data", ".", "get_shape", "(", ")", "[", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t", "target_dim", "=", "labels", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "nrS", "=", "target_dim", "/", "feat_dim", "\n", "\n", "", "batch_size", "=", "data", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "\n", "# with tf.variable_scope(self.scope):", "\n", "usedbins", "=", "tf", ".", "to_float", "(", "usedbins", ")", "\n", "\n", "if", "data_per_spk", ":", "\n", "\t\t\t", "ubresh", "=", "tf", ".", "reshape", "(", "usedbins", ",", "[", "batch_size", ",", "1", ",", "-", "1", ",", "1", "]", ",", "name", "=", "'ebresh'", ")", "\n", "V", "=", "tf", ".", "reshape", "(", "data", ",", "[", "batch_size", ",", "nrS", ",", "-", "1", ",", "emb_dim", "]", ",", "name", "=", "'V'", ")", "\n", "V", "=", "tf", ".", "multiply", "(", "V", ",", "ubresh", ")", "\n", "Y", "=", "ubresh", "\n", "Y", "=", "tf", ".", "tile", "(", "Y", ",", "[", "1", ",", "nrS", ",", "1", ",", "1", "]", ")", "\n", "Y", "=", "tf", ".", "to_float", "(", "Y", ")", "\n", "", "else", ":", "\n", "\t\t\t", "ubresh", "=", "tf", ".", "reshape", "(", "usedbins", ",", "[", "batch_size", ",", "-", "1", ",", "1", "]", ",", "name", "=", "'ebresh'", ")", "\n", "V", "=", "tf", ".", "reshape", "(", "data", ",", "[", "batch_size", ",", "-", "1", ",", "emb_dim", "]", ",", "name", "=", "'V'", ")", "\n", "V", "=", "tf", ".", "multiply", "(", "V", ",", "ubresh", ")", "\n", "Y", "=", "tf", ".", "reshape", "(", "labels", ",", "[", "batch_size", ",", "-", "1", ",", "nrS", "]", ",", "name", "=", "'Y'", ")", "\n", "Y", "=", "tf", ".", "to_float", "(", "Y", ")", "\n", "Y", "=", "tf", ".", "multiply", "(", "Y", ",", "ubresh", ")", "\n", "\n", "", "numerator_A", "=", "tf", ".", "matmul", "(", "Y", ",", "V", ",", "transpose_a", "=", "True", ",", "transpose_b", "=", "False", ",", "name", "=", "'YTV'", ")", "\n", "if", "data_per_spk", ":", "\n", "\t\t\t", "numerator_A", "=", "tf", ".", "squeeze", "(", "numerator_A", ")", "\n", "Y", "=", "tf", ".", "squeeze", "(", "Y", ",", "-", "1", ")", "\n", "# Number of bins each speaker dominates", "\n", "nb_bins_class", "=", "tf", ".", "reduce_sum", "(", "Y", ",", "axis", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "# Number of bins each speaker dominates", "\n", "\t\t\t", "nb_bins_class", "=", "tf", ".", "reduce_sum", "(", "Y", ",", "axis", "=", "1", ")", "# dim: (rank 2) (B x nrS)", "\n", "# Set number of bins of each speaker to at least 1 to avoid division by zero", "\n", "", "nb_bins_class", "=", "tf", ".", "where", "(", "tf", ".", "less", "(", "nb_bins_class", ",", "tf", ".", "ones_like", "(", "nb_bins_class", ")", ")", ",", "tf", ".", "ones_like", "(", "nb_bins_class", ")", ",", "nb_bins_class", ")", "\n", "# nb_bins_class = tf.where(tf.equal(nb_bins_class, tf.zeros_like(nb_bins_class)), tf.ones_like(nb_bins_class), nb_bins_class)", "\n", "nb_bins_class", "=", "tf", ".", "expand_dims", "(", "nb_bins_class", ",", "-", "1", ")", "# dim: (rank 3) (B x nrS x 1)", "\n", "denominator_A", "=", "tf", ".", "tile", "(", "nb_bins_class", ",", "[", "1", ",", "1", ",", "emb_dim", "]", ",", "name", "=", "'denominator_A'", ")", "# dim: (B x nrS x D)", "\n", "A", "=", "tf", ".", "divide", "(", "numerator_A", ",", "denominator_A", ",", "name", "=", "'A'", ")", "# dim: (B x nrS x D)", "\n", "\n", "if", "'normalization'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'normalization'", "]", "==", "'True'", ":", "\n", "\t\t\t", "A", "=", "tf", ".", "nn", ".", "l2_normalize", "(", "A", ",", "axis", "=", "-", "1", ",", "epsilon", "=", "1e-12", ")", "\n", "\n", "", "return", "A", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.encoder_lstm_decoder.EncoderLSTMDecoder._get_outputs": [[17, 281], ["int", "int", "int", "int", "float", "int", "int", "float", "range", "range", "range", "tensorflow.expand_dims", "map", "float", "float", "BaseException", "int", "float", "int", "copy.deepcopy", "kernel_size_enc.append", "ideal_kernel_size_enc.append", "encoder_layers.append", "blstm_layers.append", "decoder_layers.append", "len", "tensorflow.variable_scope", "tensorflow.concat.get_shape().as_list", "tensorflow.concat.set_shape", "encoder_lstm_decoder.EncoderLSTMDecoder.conf[].split", "int", "int", "ValueError", "math.ceil", "range", "int", "math.ceil", "range", "int", "numpy.mod", "numpy.mod", "nabu.neuralnetworks.components.layer.Conv2D", "nabu.neuralnetworks.components.layer.BLSTMLayer", "nabu.neuralnetworks.components.layer.Conv2D", "len", "tensorflow.variable_scope", "range", "tensorflow.variable_scope", "tensorflow.concat.get_shape", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.reshape", "range", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.variable_scope", "range", "tensorflow.expand_dims.get_shape", "math.ceil", "float", "tensorflow.random_normal", "tensorflow.concat.get_shape", "Exception", "Exception", "tensorflow.shape", "tensorflow.variable_scope", "encoder_outputs.append", "encoder_outputs_before_pool.append", "tensorflow.variable_scope", "tensorflow.variable_scope", "tensorflow.shape", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.concat", "tensorflow.expand_dims", "tensorflow.tile", "tensorflow.concat", "float", "Exception", "Exception", "tensorflow.concat", "nabu.neuralnetworks.components.layer.unpool", "Exception", "tensorflow.shape", "tensorflow.shape", "float", "float", "float"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.components.layer.unpool"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "# CNN hyper params", "\n", "if", "'filters'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "kernel_size_lay1", "=", "map", "(", "int", ",", "self", ".", "conf", "[", "'filters'", "]", ".", "split", "(", "' '", ")", ")", "\n", "", "elif", "'filter_size_t'", "in", "self", ".", "conf", "and", "'filter_size_f'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "kernel_size_t_lay1", "=", "int", "(", "self", ".", "conf", "[", "'filter_size_t'", "]", ")", "\n", "kernel_size_f_lay1", "=", "int", "(", "self", ".", "conf", "[", "'filter_size_f'", "]", ")", "\n", "kernel_size_lay1", "=", "[", "kernel_size_t_lay1", ",", "kernel_size_f_lay1", "]", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'Kernel convolution size not specified.'", ")", "\n", "", "if", "'filter_size_t'", "in", "self", ".", "conf", "and", "'filter_size_f'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "kernel_size_t_fac_after_pool", "=", "float", "(", "self", ".", "conf", "[", "'filter_size_t_fac_after_pool'", "]", ")", "\n", "kernel_size_f_fac_after_pool", "=", "float", "(", "self", ".", "conf", "[", "'filter_size_f_fac_after_pool'", "]", ")", "\n", "kernel_fac_after_pool", "=", "[", "kernel_size_t_fac_after_pool", ",", "kernel_size_f_fac_after_pool", "]", "\n", "", "else", ":", "\n", "\t\t\t", "kernel_fac_after_pool", "=", "[", "1", ",", "1", "]", "\n", "\n", "", "f_pool_rate", "=", "int", "(", "self", ".", "conf", "[", "'f_pool_rate'", "]", ")", "\n", "t_pool_rate", "=", "int", "(", "self", ".", "conf", "[", "'t_pool_rate'", "]", ")", "\n", "num_encoder_layers", "=", "int", "(", "self", ".", "conf", "[", "'num_encoder_layers'", "]", ")", "\n", "if", "t_pool_rate", "<=", "num_encoder_layers", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "\n", "'Expecting that not time pooling takes place. Need to adapt input sequence length tensor for lstm part '", "\n", "'if time pooling is wanted'", ")", "\n", "", "num_decoder_layers", "=", "num_encoder_layers", "\n", "num_filters_1st_layer", "=", "int", "(", "self", ".", "conf", "[", "'num_filters_1st_layer'", "]", ")", "\n", "fac_per_layer", "=", "float", "(", "self", ".", "conf", "[", "'fac_per_layer'", "]", ")", "\n", "num_filters_enc", "=", "[", "\n", "int", "(", "math", ".", "ceil", "(", "num_filters_1st_layer", "*", "(", "fac_per_layer", "**", "l", ")", ")", ")", "\n", "for", "l", "in", "range", "(", "num_encoder_layers", ")", "]", "\n", "num_filters_dec", "=", "num_filters_enc", "[", ":", ":", "-", "1", "]", "\n", "num_filters_dec", "=", "num_filters_dec", "[", "1", ":", "]", "+", "[", "(", "int", "(", "self", ".", "conf", "[", "'num_output_filters'", "]", ")", ")", "]", "\n", "\n", "kernel_size_enc", "=", "[", "]", "\n", "ideal_kernel_size_enc", "=", "[", "kernel_size_lay1", "]", "\n", "\n", "bypass", "=", "self", ".", "conf", "[", "'bypass'", "]", "\n", "\n", "layer_norm", "=", "self", ".", "conf", "[", "'layer_norm'", "]", "==", "'True'", "\n", "\n", "if", "'activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "\n", "# LSTM hyper parameters", "\n", "", "lstm_num_layers", "=", "int", "(", "self", ".", "conf", "[", "'lstm_num_layers'", "]", ")", "\n", "lstm_num_units_first_layer", "=", "int", "(", "self", ".", "conf", "[", "'lstm_num_units'", "]", ")", "\n", "if", "'lstm_fac_per_layer'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "lstm_fac_per_layer", "=", "float", "(", "self", ".", "conf", "[", "'lstm_fac_per_layer'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "lstm_fac_per_layer", "=", "1.0", "\n", "", "lstm_num_units", "=", "[", "\n", "int", "(", "math", ".", "ceil", "(", "lstm_num_units_first_layer", "*", "(", "lstm_fac_per_layer", "**", "l", ")", ")", ")", "\n", "for", "l", "in", "range", "(", "lstm_num_layers", ")", "]", "\n", "\n", "recurrent_dropout", "=", "float", "(", "self", ".", "conf", "[", "'recurrent_dropout'", "]", ")", "\n", "if", "'lstm_activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'lstm_activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "lstm_activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'lstm_activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "lstm_activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'lstm_activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "lstm_activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined LSTM activation function: %s'", "%", "self", ".", "conf", "[", "'lstm_activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "lstm_activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "\n", "", "separate_directions", "=", "False", "\n", "if", "'separate_directions'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'separate_directions'", "]", "==", "'True'", ":", "\n", "\t\t\t", "separate_directions", "=", "True", "\n", "\n", "# the encoder layers", "\n", "", "encoder_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_encoder_layers", ")", ":", "\n", "\t\t\t", "kernel_size_l", "=", "copy", ".", "deepcopy", "(", "ideal_kernel_size_enc", "[", "l", "]", ")", "\n", "kernel_size_l_plus_1", "=", "kernel_size_l", "\n", "kernel_size_l", "=", "[", "int", "(", "math", ".", "ceil", "(", "k", ")", ")", "for", "k", "in", "kernel_size_l", "]", "\n", "kernel_size_enc", ".", "append", "(", "kernel_size_l", ")", "\n", "\n", "num_filters_l", "=", "num_filters_enc", "[", "l", "]", "\n", "\n", "max_pool_filter", "=", "[", "1", ",", "1", "]", "\n", "if", "np", ".", "mod", "(", "l", "+", "1", ",", "t_pool_rate", ")", "==", "0", ":", "\n", "\t\t\t\t", "max_pool_filter", "[", "0", "]", "=", "2", "\n", "kernel_size_l_plus_1", "[", "0", "]", "=", "kernel_size_l_plus_1", "[", "0", "]", "*", "kernel_fac_after_pool", "[", "0", "]", "\n", "", "if", "np", ".", "mod", "(", "l", "+", "1", ",", "f_pool_rate", ")", "==", "0", ":", "\n", "\t\t\t\t", "max_pool_filter", "[", "1", "]", "=", "2", "\n", "kernel_size_l_plus_1", "[", "1", "]", "=", "kernel_size_l_plus_1", "[", "1", "]", "*", "kernel_fac_after_pool", "[", "1", "]", "\n", "", "ideal_kernel_size_enc", ".", "append", "(", "kernel_size_l_plus_1", ")", "\n", "\n", "encoder_layers", ".", "append", "(", "layer", ".", "Conv2D", "(", "\n", "num_filters", "=", "num_filters_l", ",", "\n", "kernel_size", "=", "kernel_size_l", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation_fn", "=", "activation_fn", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "max_pool_filter", "=", "max_pool_filter", ")", ")", "\n", "\n", "# the centre LSTM layers", "\n", "", "blstm_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "lstm_num_layers", ")", ":", "\n", "\t\t\t", "blstm_layers", ".", "append", "(", "layer", ".", "BLSTMLayer", "(", "\n", "num_units", "=", "lstm_num_units", "[", "l", "]", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "activation_fn", "=", "lstm_activation_fn", ",", "\n", "separate_directions", "=", "separate_directions", ",", "\n", "fast_version", "=", "False", ")", ")", "\n", "\n", "# the decoder layers", "\n", "", "decoder_layers", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_decoder_layers", ")", ":", "\n", "\t\t\t", "corresponding_encoder_l", "=", "num_encoder_layers", "-", "1", "-", "l", "\n", "num_filters_l", "=", "num_filters_dec", "[", "l", "]", "\n", "kernel_size_l", "=", "kernel_size_enc", "[", "corresponding_encoder_l", "]", "\n", "if", "bypass", "==", "'unpool'", ":", "\n", "\t\t\t\t", "strides", "=", "[", "1", ",", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "strides", "=", "encoder_layers", "[", "corresponding_encoder_l", "]", ".", "max_pool_filter", "\n", "\n", "", "decoder_layers", ".", "append", "(", "layer", ".", "Conv2D", "(", "\n", "num_filters", "=", "num_filters_l", ",", "\n", "kernel_size", "=", "kernel_size_l", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "'same'", ",", "\n", "activation_fn", "=", "activation_fn", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "max_pool_filter", "=", "(", "1", ",", "1", ")", ",", "\n", "transpose", "=", "True", ")", ")", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of DCNN expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "", "if", "(", "num_encoder_layers", "+", "lstm_num_layers", "+", "num_decoder_layers", ")", "==", "0", ":", "\n", "\t\t\t", "output", "=", "inputs", "\n", "return", "output", "\n", "\n", "# Convolutional layers expect input channels, making 1 here.", "\n", "", "inputs", "=", "tf", ".", "expand_dims", "(", "inputs", ",", "-", "1", ")", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "'encoder'", ")", ":", "\n", "\t\t\t\t", "encoder_outputs", "=", "[", "]", "\n", "encoder_outputs_before_pool", "=", "[", "]", "\n", "for", "l", "in", "range", "(", "num_encoder_layers", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'layer_%s'", "%", "l", ")", ":", "\n", "\n", "\t\t\t\t\t\t", "logits", ",", "outputs_before_pool", "=", "encoder_layers", "[", "l", "]", "(", "logits", ")", "\n", "\n", "encoder_outputs", ".", "append", "(", "logits", ")", "\n", "encoder_outputs_before_pool", ".", "append", "(", "outputs_before_pool", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t\t\t", "raise", "Exception", "(", "'have to check whether dropout is implemented correctly'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "", "", "", "", "with", "tf", ".", "variable_scope", "(", "'lstm_centre'", ")", ":", "\n", "\t\t\t\t", "[", "batch_size", ",", "_", ",", "new_freq_dim", ",", "num_chan", "]", "=", "logits", ".", "get_shape", "(", ")", "\n", "logits", "=", "tf", ".", "transpose", "(", "logits", ",", "[", "0", ",", "2", ",", "1", ",", "3", "]", ")", "\n", "logits", "=", "tf", ".", "reshape", "(", "logits", ",", "[", "batch_size", "*", "new_freq_dim", ",", "-", "1", ",", "num_chan", "]", ")", "\n", "tmp_input_seq_length", "=", "tf", ".", "expand_dims", "(", "input_seq_length", ",", "1", ")", "\n", "tmp_input_seq_length", "=", "tf", ".", "tile", "(", "tmp_input_seq_length", ",", "[", "1", ",", "new_freq_dim", "]", ")", "\n", "tmp_input_seq_length", "=", "tf", ".", "reshape", "(", "tmp_input_seq_length", ",", "[", "batch_size", "*", "new_freq_dim", "]", ")", "\n", "for", "l", "in", "range", "(", "lstm_num_layers", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'layer_%s'", "%", "l", ")", ":", "\n", "\n", "\t\t\t\t\t\t", "logits", "=", "blstm_layers", "[", "l", "]", "(", "logits", ",", "tmp_input_seq_length", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t\t\t", "raise", "Exception", "(", "'have to check whether dropout is implemented correctly'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "", "", "", "logits", "=", "tf", ".", "reshape", "(", "logits", ",", "[", "batch_size", ",", "new_freq_dim", ",", "-", "1", ",", "2", "*", "lstm_num_units", "[", "-", "1", "]", "]", ")", "\n", "logits", "=", "tf", ".", "transpose", "(", "logits", ",", "[", "0", ",", "2", ",", "1", ",", "3", "]", ")", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "'decoder'", ")", ":", "\n", "\t\t\t\t", "for", "l", "in", "range", "(", "num_decoder_layers", ")", ":", "\n", "\t\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'layer_%s'", "%", "l", ")", ":", "\n", "\t\t\t\t\t\t", "corresponding_encoder_l", "=", "num_encoder_layers", "-", "1", "-", "l", "\n", "corresponding_encoder_output", "=", "encoder_outputs", "[", "corresponding_encoder_l", "]", "\n", "corresponding_encoder_output_before_pool", "=", "encoder_outputs_before_pool", "[", "corresponding_encoder_l", "]", "\n", "corresponding_encoder_max_pool_filter", "=", "encoder_layers", "[", "corresponding_encoder_l", "]", ".", "max_pool_filter", "\n", "if", "bypass", "==", "'True'", "and", "(", "lstm_num_layers", ">", "0", "or", "l", ">", "0", ")", ":", "\n", "# don't use bypass for layer 0 if no centre layers", "\n", "\t\t\t\t\t\t\t", "decoder_input", "=", "tf", ".", "concat", "(", "[", "logits", ",", "corresponding_encoder_output", "]", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "decoder_input", "=", "logits", "\n", "\n", "", "if", "bypass", "==", "'unpool'", "and", "corresponding_encoder_max_pool_filter", "!=", "[", "1", ",", "1", "]", ":", "\n", "\t\t\t\t\t\t\t", "decoder_input", "=", "layer", ".", "unpool", "(", "\n", "pool_input", "=", "corresponding_encoder_output_before_pool", ",", "\n", "pool_output", "=", "corresponding_encoder_output", ",", "unpool_input", "=", "decoder_input", ",", "\n", "pool_kernel_size", "=", "corresponding_encoder_max_pool_filter", ",", "\n", "pool_stride", "=", "corresponding_encoder_max_pool_filter", ",", "padding", "=", "'VALID'", ")", "\n", "\n", "", "logits", ",", "_", "=", "decoder_layers", "[", "l", "]", "(", "decoder_input", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t\t\t", "raise", "Exception", "(", "'have to check whether dropout is implemented correctly'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "# get wanted output size", "\n", "", "if", "corresponding_encoder_l", "==", "0", ":", "\n", "\t\t\t\t\t\t\t", "wanted_size", "=", "tf", ".", "shape", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t\t\t", "wanted_size", "=", "tf", ".", "shape", "(", "encoder_outputs", "[", "corresponding_encoder_l", "-", "1", "]", ")", "\n", "", "wanted_t_size", "=", "wanted_size", "[", "1", "]", "\n", "wanted_f_size", "=", "wanted_size", "[", "2", "]", "\n", "\n", "# get actual output size", "\n", "output_size", "=", "tf", ".", "shape", "(", "logits", ")", "\n", "output_t_size", "=", "output_size", "[", "1", "]", "\n", "output_f_size", "=", "output_size", "[", "2", "]", "\n", "\n", "# compensate for potential mismatch, by adding duplicates", "\n", "missing_t_size", "=", "wanted_t_size", "-", "output_t_size", "\n", "missing_f_size", "=", "wanted_f_size", "-", "output_f_size", "\n", "\n", "last_t_slice", "=", "tf", ".", "expand_dims", "(", "logits", "[", ":", ",", "-", "1", ",", ":", ",", ":", "]", ",", "1", ")", "\n", "duplicate_logits", "=", "tf", ".", "tile", "(", "last_t_slice", ",", "[", "1", ",", "missing_t_size", ",", "1", ",", "1", "]", ")", "\n", "logits", "=", "tf", ".", "concat", "(", "[", "logits", ",", "duplicate_logits", "]", ",", "1", ")", "\n", "last_f_slice", "=", "tf", ".", "expand_dims", "(", "logits", "[", ":", ",", ":", ",", "-", "1", ",", ":", "]", ",", "2", ")", "\n", "duplicate_logits", "=", "tf", ".", "tile", "(", "last_f_slice", ",", "[", "1", ",", "1", ",", "missing_f_size", ",", "1", "]", ")", "\n", "logits", "=", "tf", ".", "concat", "(", "[", "logits", ",", "duplicate_logits", "]", ",", "2", ")", "\n", "\n", "# set the shape of the logits as we know", "\n", "", "", "", "dyn_shape", "=", "logits", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "dyn_shape", "[", "-", "2", "]", "=", "inputs", ".", "get_shape", "(", ")", "[", "-", "2", "]", "\n", "logits", ".", "set_shape", "(", "dyn_shape", ")", "\n", "output", "=", "logits", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.plain_variables.PlainVariables._get_outputs": [[12, 61], ["tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.get_variable", "int", "int", "float", "tensorflow.constant_initializer", "tensorflow.truncated_normal", "float", "float", "tensorflow.clip_by_value", "tensorflow.norm", "tensorflow.constant_initializer", "numpy.ones", "tensorflow.sqrt", "float"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables\n\n\t\tArgs:\n\t\t\tinputs: None\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, which is a [tot_vecs x vec_dim]\n\t\t\t\ttensor\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "# the complete vector set", "\n", "\t\t\t", "array_shape", "=", "[", "int", "(", "self", ".", "conf", "[", "'tot_vecs'", "]", ")", ",", "int", "(", "self", ".", "conf", "[", "'vec_dim'", "]", ")", "]", "\n", "if", "'init_value'", "in", "self", ".", "conf", ":", "\n", "\t\t\t\t", "init_value", "=", "float", "(", "self", ".", "conf", "[", "'init_value'", "]", ")", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "np", ".", "ones", "(", "array_shape", ")", "*", "init_value", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "initializer", "=", "tf", ".", "truncated_normal", "(", "array_shape", ",", "stddev", "=", "tf", ".", "sqrt", "(", "2", "/", "float", "(", "self", ".", "conf", "[", "'vec_dim'", "]", ")", ")", ")", "\n", "array_shape", "=", "None", "\n", "\n", "", "floor_val", "=", "None", "\n", "ceil_val", "=", "None", "\n", "if", "'floor_val'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'floor_val'", "]", "!=", "'None'", ":", "\n", "\t\t\t\t", "floor_val", "=", "float", "(", "self", ".", "conf", "[", "'floor_val'", "]", ")", "\n", "", "if", "'ceil_val'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'ceil_val'", "]", "!=", "'None'", ":", "\n", "\t\t\t\t", "ceil_val", "=", "float", "(", "self", ".", "conf", "[", "'ceil_val'", "]", ")", "\n", "", "constraint", "=", "None", "\n", "if", "floor_val", "or", "ceil_val", ":", "\n", "\t\t\t\t", "if", "not", "ceil_val", ":", "\n", "\t\t\t\t\t", "ceil_val", "=", "np", ".", "infty", "\n", "", "if", "not", "floor_val", ":", "\n", "\t\t\t\t\t", "floor_val", "=", "-", "np", ".", "infty", "\n", "", "constraint", "=", "lambda", "x", ":", "tf", ".", "clip_by_value", "(", "x", ",", "floor_val", ",", "ceil_val", ")", "\n", "\n", "# vector_set = tf.get_variable('vector_set', initializer=initializer, constraint=constraint)", "\n", "", "vector_set", "=", "tf", ".", "get_variable", "(", "'vector_set'", ",", "shape", "=", "array_shape", ",", "initializer", "=", "initializer", ",", "constraint", "=", "constraint", ")", "\n", "\n", "", "if", "'normalize'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'normalize'", "]", "==", "'True'", ":", "\n", "\t\t\t", "vector_set", "=", "vector_set", "/", "(", "tf", ".", "norm", "(", "vector_set", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "", "if", "'single_scale_weight'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'single_scale_weight'", "]", "==", "'True'", ":", "\n", "\t\t\t", "scale", "=", "tf", ".", "get_variable", "(", "'single_scale'", ",", "initializer", "=", "tf", ".", "constant_initializer", "(", "1.0", ")", ",", "shape", "=", "[", "1", "]", ")", "\n", "vector_set", "*=", "scale", "\n", "\n", "", "return", "vector_set", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.plain_variables.PlainVariablesWithIndexing._get_outputs": [[66, 105], ["len", "tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.expand_dims", "tensorflow.gather_nd", "tensorflow.reshape", "len", "int", "int", "float", "tensorflow.constant_initializer", "tensorflow.truncated_normal", "numpy.ones", "tensorflow.sqrt", "tensorflow.shape", "float"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and index them\n\n\t\tArgs:\n\t\t\tinputs: the indexes, this is a list of\n\t\t\t\t[batch_size x nr_indeces] tensors\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, which is a [batch_size x 1 x (nr_indeces*vec_dim)]\n\t\t\t\ttensor\n\t\t\"\"\"", "\n", "\n", "# code not available for multiple inputs!!", "\n", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of PlainVariables expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "# the complete vector set", "\n", "# the complete vector set", "\n", "\t\t\t", "array_shape", "=", "[", "int", "(", "self", ".", "conf", "[", "'tot_vecs'", "]", ")", ",", "int", "(", "self", ".", "conf", "[", "'vec_dim'", "]", ")", "]", "\n", "if", "'init_value'", "in", "self", ".", "conf", ":", "\n", "\t\t\t\t", "init_value", "=", "float", "(", "self", ".", "conf", "[", "'init_value'", "]", ")", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "np", ".", "ones", "(", "array_shape", ")", "*", "init_value", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "initializer", "=", "tf", ".", "truncated_normal", "(", "array_shape", ",", "stddev", "=", "tf", ".", "sqrt", "(", "2", "/", "float", "(", "self", ".", "conf", "[", "'vec_dim'", "]", ")", ")", ")", "\n", "\n", "", "vector_set", "=", "tf", ".", "get_variable", "(", "'vector_set'", ",", "shape", "=", "array_shape", ",", "initializer", "=", "initializer", ")", "\n", "\n", "inputs", "=", "tf", ".", "expand_dims", "(", "inputs", ",", "-", "1", ")", "\n", "\n", "output", "=", "tf", ".", "gather_nd", "(", "vector_set", ",", "inputs", ")", "\n", "output", "=", "tf", ".", "reshape", "(", "output", ",", "[", "tf", ".", "shape", "(", "output", ")", "[", "0", "]", ",", "1", ",", "-", "1", "]", ")", "\n", "\n", "return", "output", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.averager.Averager._get_outputs": [[12, 68], ["NotImplementedError", "len", "tensorflow.reduce_sum", "tensorflow.einsum", "int", "len", "len", "tensorflow.ones", "warnings.warn", "tensorflow.tanh", "tensorflow.shape", "tensorflow.reduce_sum", "tensorflow.sigmoid", "tensorflow.nn.relu", "tensorflow.nn.softmax"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax"], ["\t\t", "super", "(", "Averager", ",", "self", ")", ".", "__init__", "(", "conf", ",", "evalconf", ",", "dataconf", ",", "store_dir", ",", "exp_dir", ",", "task", ")", "\n", "\n", "if", "'squeeze'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'squeeze'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "squeeze", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "squeeze", "=", "False", "\n", "\n", "", "if", "self", ".", "conf", "[", "'activation'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t", "self", ".", "activation", "=", "'sigmoid'", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "'Other activations not yet implemented'", ")", "\n", "\n", "", "if", "'average_dimension'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "self", ".", "average_dimension", "=", "int", "(", "self", ".", "conf", "[", "'average_dimension'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "average_dimension", "=", "-", "1", "\n", "\n", "", "if", "'output_names'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "self", ".", "requested_output_names", "=", "self", ".", "conf", "[", "'output_names'", "]", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "requested_output_names", "=", "self", ".", "base_requested_output_names", "\n", "", "if", "len", "(", "self", ".", "requested_output_names", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "\n", "'Expected the amount of requested output names to be one, but was %d isntead'", "%", "\n", "len", "(", "self", ".", "requested_output_names", ")", ")", "\n", "\n", "", "", "def", "handle_output", "(", "self", ",", "output", ",", "utt_name", ")", ":", "\n", "\t\t", "handled_output", "=", "output", "[", "self", ".", "requested_output_names", "[", "0", "]", "]", "\n", "\n", "if", "self", ".", "squeeze", ":", "\n", "\t\t\t", "handled_output", "=", "np", ".", "squeeze", "(", "handled_output", ")", "\n", "", "if", "self", ".", "activation", "==", "'sigmoid'", ":", "\n", "\t\t\t", "handled_output", "=", "sigmoid", "(", "handled_output", ")", "\n", "\n", "", "handled_output", "=", "np", ".", "mean", "(", "handled_output", ",", "axis", "=", "self", ".", "average_dimension", ")", "\n", "\n", "return", "handled_output", "\n", "\n", "\n", "", "", "def", "sigmoid", "(", "inp", ")", ":", "\n", "\t", "outp", "=", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "inp", ")", ")", "\n", "return", "outp", "\n", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dresetlstm.DResetLSTM._get_outputs": [[12, 88], ["int", "int", "map.split", "map.append", "map", "float", "len", "len", "tensorflow.variable_scope", "tensorflow.expand_dims", "tensorflow.tile", "range", "len", "tensorflow.constant", "nabu.neuralnetworks.components.layer.ResetLSTMLayer", "nabu.neuralnetworks.components.layer.ResetLSTMLayer.", "float", "tensorflow.random_normal", "Exception", "Exception", "tensorflow.shape", "str", "float", "float"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "# the bresetlstm layer", "\n", "num_units", "=", "int", "(", "self", ".", "conf", "[", "'num_units'", "]", ")", "\n", "num_lay", "=", "int", "(", "self", ".", "conf", "[", "'num_layers'", "]", ")", "\n", "t_resets", "=", "self", ".", "conf", "[", "'t_reset'", "]", "\n", "t_resets", "=", "t_resets", ".", "split", "(", "' '", ")", "\n", "if", "len", "(", "t_resets", ")", "==", "1", ":", "\n", "\t\t\t", "t_resets", "=", "t_resets", "*", "num_lay", "\n", "", "t_resets", ".", "append", "(", "t_resets", "[", "-", "1", "]", ")", "\n", "t_resets", "=", "map", "(", "int", ",", "t_resets", ")", "\n", "\n", "layer_norm", "=", "self", ".", "conf", "[", "'layer_norm'", "]", "==", "'True'", "\n", "recurrent_dropout", "=", "float", "(", "self", ".", "conf", "[", "'recurrent_dropout'", "]", ")", "\n", "if", "'activation_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "relu", "\n", "", "elif", "self", ".", "conf", "[", "'activation_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "else", ":", "\n", "\t\t\t\t", "raise", "Exception", "(", "'Undefined activation function: %s'", "%", "self", ".", "conf", "[", "'activation_fn'", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "activation_fn", "=", "tf", ".", "nn", ".", "tanh", "\n", "\n", "# code not available for multiple inputs!!", "\n", "", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of DLSTM expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "# expand the dimension of inputs since the reset lstm expect multistate input", "\n", "logits_multistate", "=", "tf", ".", "expand_dims", "(", "logits", ",", "2", ")", "\n", "logits_multistate", "=", "tf", ".", "tile", "(", "logits_multistate", ",", "tf", ".", "constant", "(", "[", "1", ",", "1", ",", "t_resets", "[", "0", "]", ",", "1", "]", ")", ")", "\n", "\n", "for", "l", "in", "range", "(", "num_lay", ")", ":", "\n", "\n", "\t\t\t\t", "lstm", "=", "layer", ".", "ResetLSTMLayer", "(", "\n", "num_units", "=", "num_units", ",", "\n", "t_reset", "=", "t_resets", "[", "l", "]", ",", "\n", "next_t_reset", "=", "t_resets", "[", "l", "+", "1", "]", ",", "\n", "layer_norm", "=", "layer_norm", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "activation_fn", "=", "activation_fn", ")", "\n", "\n", "logits", ",", "logits_multistate", "=", "lstm", "(", "logits_multistate", ",", "input_seq_length", ",", "'layer'", "+", "str", "(", "l", ")", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t", "raise", "Exception", "(", "'dropout not yet implemented for state reset lstm'", ")", "\n", "# logits = tf.nn.dropout(logits, float(self.conf['dropout']))", "\n", "\n", "", "", "output", "=", "logits", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.linear.Linear._get_outputs": [[12, 75], ["len", "tensorflow.variable_scope", "map", "numpy.prod", "tensorflow.contrib.layers.linear", "len", "linear.Linear.conf[].split", "tensorflow.zeros_initializer", "len", "tensorflow.reshape", "tensorflow.nn.dropout", "tensorflow.expand_dims", "float", "tensorflow.random_normal", "tensorflow.shape", "tensorflow.concat", "tensorflow.tanh", "float", "float", "tensorflow.shape", "tensorflow.sigmoid", "float", "tensorflow.constant", "tensorflow.nn.relu", "tensorflow.nn.softmax"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "# code not available for multiple inputs!!", "\n", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of Linear expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "inputs", ")", ",", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "logits", "=", "inputs", "\n", "\n", "output_shape", "=", "map", "(", "int", ",", "self", ".", "conf", "[", "'output_dims'", "]", ".", "split", "(", "' '", ")", ")", "\n", "output_size", "=", "np", ".", "prod", "(", "output_shape", ")", "\n", "\n", "no_bias", "=", "'no_bias'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'no_bias'", "]", "==", "'True'", "\n", "if", "no_bias", ":", "\n", "\t\t\t\t", "biases_initializer", "=", "None", "\n", "", "else", ":", "\n", "\t\t\t\t", "biases_initializer", "=", "tf", ".", "zeros_initializer", "(", ")", "\n", "\n", "", "output", "=", "tf", ".", "contrib", ".", "layers", ".", "linear", "(", "inputs", "=", "logits", ",", "num_outputs", "=", "output_size", ",", "biases_initializer", "=", "biases_initializer", ")", "\n", "\n", "if", "len", "(", "output_shape", ")", ">", "1", ":", "\n", "\t\t\t\t", "fixed_shape", "=", "tf", ".", "shape", "(", "output", ")", "[", ":", "-", "1", "]", "\n", "output", "=", "tf", ".", "reshape", "(", "output", ",", "tf", ".", "concat", "(", "[", "fixed_shape", ",", "tf", ".", "constant", "(", "output_shape", ")", "]", ",", "-", "1", ")", ")", "\n", "\n", "", "if", "'activation_func'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'activation_func'", "]", "!=", "'None'", ":", "\n", "\t\t\t\t", "if", "self", ".", "conf", "[", "'activation_func'", "]", "==", "'tanh'", ":", "\n", "\t\t\t\t\t", "output", "=", "tf", ".", "tanh", "(", "output", ")", "\n", "", "elif", "self", ".", "conf", "[", "'activation_func'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t\t", "output", "=", "tf", ".", "sigmoid", "(", "output", ")", "\n", "", "elif", "self", ".", "conf", "[", "'activation_func'", "]", "==", "'relu'", ":", "\n", "\t\t\t\t\t", "output", "=", "tf", ".", "nn", ".", "relu", "(", "output", ")", "\n", "", "elif", "self", ".", "conf", "[", "'activation_func'", "]", "==", "'softmax'", ":", "\n", "\t\t\t\t\t", "output", "=", "tf", ".", "nn", ".", "softmax", "(", "output", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "raise", "'Activation function %s not found'", "%", "self", ".", "conf", "[", "'activation_func'", "]", "\n", "\n", "# dropout is not recommended", "\n", "", "", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t", "output", "=", "tf", ".", "nn", ".", "dropout", "(", "output", ",", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", ")", "\n", "\n", "", "if", "'last_only'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'last_only'", "]", "==", "'True'", ":", "\n", "\t\t\t\t", "output", "=", "output", "[", ":", ",", "-", "1", ",", ":", "]", "\n", "output", "=", "tf", ".", "expand_dims", "(", "output", ",", "1", ")", "\n", "\n", "", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.constant_generator.ConstantGenerator._get_outputs": [[12, 39], ["float", "map", "constant_generator.ConstantGenerator.conf[].split", "numpy.ones", "map", "inputs[].get_shape", "constant_generator.ConstantGenerator.conf[].split", "tensorflow.random_normal", "tensorflow.shape"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", "=", "None", ",", "is_training", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tconcatenate the inputs over the last dimension.\n\n\t\tArgs:\n\t\t\tinputs: the inputs to concatenate, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors and/or [batch_size x ...] tensors\n\t\t\tinput_seq_length: None\n\t\t\tis_training: None\n\n\t\tReturns:\n\t\t\t- outputs, the concatenated inputs\n\t\t\"\"\"", "\n", "\n", "constant_value", "=", "float", "(", "self", ".", "conf", "[", "'constant_value'", "]", ")", "\n", "tensor_shape", "=", "map", "(", "int", ",", "self", ".", "conf", "[", "'tensor_shape'", "]", ".", "split", "(", "','", ")", ")", "\n", "if", "'include_batch_size'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'include_batch_size'", "]", "==", "'True'", ":", "\n", "\t\t\t", "batch_size", "=", "inputs", "[", "0", "]", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "tensor_shape", "=", "[", "batch_size", "]", "+", "tensor_shape", "\n", "\n", "", "output", "=", "constant_value", "*", "np", ".", "ones", "(", "tensor_shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "if", "is_training", "and", "'output_noise'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "output_noise", "=", "map", "(", "float", ",", "self", ".", "conf", "[", "'output_noise'", "]", ".", "split", "(", "' '", ")", ")", "\n", "output", "=", "output", "+", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "output", ")", ",", "stddev", "=", "output_noise", ")", "\n", "\n", "", "return", "output", "", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.ntm.NTM.__init__": [[13, 21], ["model.Model.__init__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "conf", ",", "name", "=", "None", ")", ":", "\n", "\t\t", "super", "(", "NTM", ",", "self", ")", ".", "__init__", "(", "conf", ",", "name", "=", "name", ")", "\n", "if", "'return_read_heads'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'return_read_heads'", "]", "==", "'True'", ":", "\n", "\t\t\t", "self", ".", "return_read_heads", "=", "True", "\n", "self", ".", "num_outputs", "=", "2", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "return_read_heads", "=", "False", "\n", "self", ".", "num_outputs", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.ntm.NTM._get_outputs": [[22, 79], ["int", "int", "int", "int", "int", "int", "len", "tensorflow.variable_scope", "nabu.neuralnetworks.components.rnn_cell.NTMCell", "tensorflow.python.ops.rnn.dynamic_rnn", "len", "inputs.get_shape", "float", "tensorflow.random_normal", "tensorflow.shape", "tensorflow.get_variable_scope", "float"], "methods", ["None"], ["", "", "def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "# code not available for multiple inputs!!", "\n", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of NTM expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "\n", "", "input_size", "=", "int", "(", "inputs", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", "\n", "memory_size", "=", "int", "(", "self", ".", "conf", "[", "'memory_size'", "]", ")", "\n", "memory_vector_dim", "=", "int", "(", "self", ".", "conf", "[", "'memory_vector_dim'", "]", ")", "\n", "read_head_num", "=", "int", "(", "self", ".", "conf", "[", "'read_head_num'", "]", ")", "\n", "write_head_num", "=", "int", "(", "self", ".", "conf", "[", "'write_head_num'", "]", ")", "\n", "shift_win_size", "=", "int", "(", "self", ".", "conf", "[", "'shift_win_size'", "]", ")", "\n", "addressing_mode", "=", "self", ".", "conf", "[", "'addressing_mode'", "]", "\n", "if", "'init_mode'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "init_mode", "=", "self", ".", "conf", "[", "'init_mode'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "init_mode", "=", "'constant'", "\n", "", "if", "'init_mode_other_params'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "init_mode_other_params", "=", "self", ".", "conf", "[", "'init_mode_other_params'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "init_mode_other_params", "=", "'constant'", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "", "ntm_cell", "=", "NTMCell", "(", "\n", "input_size", "=", "input_size", ",", "memory_size", "=", "memory_size", ",", "memory_vector_dim", "=", "memory_vector_dim", ",", "\n", "read_head_num", "=", "read_head_num", ",", "write_head_num", "=", "write_head_num", ",", "addressing_mode", "=", "addressing_mode", ",", "\n", "shift_win_size", "=", "shift_win_size", ",", "clip_value", "=", "20", ",", "init_mode", "=", "init_mode", ",", "\n", "init_mode_other_params", "=", "init_mode_other_params", ",", "reuse", "=", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse", ")", "\n", "\n", "# do the forward computation", "\n", "outputs", ",", "_", "=", "dynamic_rnn", "(", "ntm_cell", ",", "inputs", ",", "dtype", "=", "tf", ".", "float32", ",", "sequence_length", "=", "input_seq_length", ")", "\n", "\n", "# if read heads are not requested, only keep the first part of outputs", "\n", "if", "not", "self", ".", "return_read_heads", ":", "\n", "\t\t\t\t", "outputs", "=", "outputs", "[", "0", "]", "\n", "\n", "", "", "return", "outputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.dblstm_capsnet.DBLSTMCapsNet._get_outputs": [[13, 110], ["int", "int", "int", "len", "tensorflow.variable_scope", "range", "tensorflow.reshape", "len", "tensorflow.variable_scope", "tensorflow.identity", "tensorflow.identity", "nabu.neuralnetworks.components.layer.BLSTMLayer", "nabu.neuralnetworks.components.layer.BLSTMLayer.", "tensorflow.reshape", "nabu.neuralnetworks.components.ops.squash", "tensorflow.identity", "int", "float", "tensorflow.random_normal", "tensorflow.variable_scope", "nabu.neuralnetworks.components.layer.BLSTMCapsuleLayer", "nabu.neuralnetworks.components.layer.BLSTMCapsuleLayer.", "tensorflow.shape", "tensorflow.nn.dropout", "tensorflow.shape", "float", "tensorflow.shape", "float", "float"], "methods", ["None"], ["def", "_get_outputs", "(", "self", ",", "inputs", ",", "input_seq_length", ",", "is_training", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCreate the variables and do the forward computation\n\t\t\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x time x ...] tensors\n\t\t\tinput_seq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a [batch_size] vector\n\t\t\tis_training: whether or not the network is in training mode\n\t\t\n\t\tReturns:\n\t\t\t- output, which is a [batch_size x time x ...] tensors\n\t\t\"\"\"", "\n", "\n", "num_capsules", "=", "int", "(", "self", ".", "conf", "[", "'num_capsules'", "]", ")", "\n", "capsule_dim", "=", "int", "(", "self", ".", "conf", "[", "'capsule_dim'", "]", ")", "\n", "routing_iters", "=", "int", "(", "self", ".", "conf", "[", "'routing_iters'", "]", ")", "\n", "\n", "if", "'recurrent_probability_fn'", "in", "self", ".", "conf", ":", "\n", "\t\t\t", "if", "self", ".", "conf", "[", "'recurrent_probability_fn'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "recurrent_probability_fn", "=", "tf", ".", "nn", ".", "sigmoid", "\n", "", "elif", "self", ".", "conf", "[", "'recurrent_probability_fn'", "]", "==", "'unit'", ":", "\n", "\t\t\t\t", "recurrent_probability_fn", "=", "ops", ".", "unit_activation", "\n", "", "", "else", ":", "\n", "\t\t\t", "recurrent_probability_fn", "=", "None", "\n", "\n", "", "if", "'accumulate_input_logits'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'accumulate_input_logits'", "]", "==", "'False'", ":", "\n", "\t\t\t", "accumulate_input_logits", "=", "False", "\n", "", "else", ":", "\n", "\t\t\t", "accumulate_input_logits", "=", "True", "\n", "\n", "", "if", "'accumulate_state_logits'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'accumulate_state_logits'", "]", "==", "'False'", ":", "\n", "\t\t\t", "accumulate_state_logits", "=", "False", "\n", "", "else", ":", "\n", "\t\t\t", "accumulate_state_logits", "=", "True", "\n", "\n", "", "if", "'logits_prior'", "in", "self", ".", "conf", "and", "self", ".", "conf", "[", "'logits_prior'", "]", "==", "'True'", ":", "\n", "\t\t\t", "logits_prior", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "logits_prior", "=", "False", "\n", "\n", "", "gates_fc", "=", "self", ".", "conf", "[", "'gates_fc'", "]", "==", "'True'", "\n", "use_output_matrix", "=", "self", ".", "conf", "[", "'use_output_matrix'", "]", "==", "'True'", "\n", "\n", "# code not available for multiple inputs!!", "\n", "if", "len", "(", "inputs", ")", ">", "1", ":", "\n", "\t\t\t", "raise", "'The implementation of CapsNet expects 1 input and not %d'", "%", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "\t\t\t", "inputs", "=", "inputs", "[", "0", "]", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "\t\t\t", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ">", "0", ":", "\n", "\t\t\t\t", "inputs", "=", "inputs", "+", "tf", ".", "random_normal", "(", "\n", "tf", ".", "shape", "(", "inputs", ")", ",", "\n", "stddev", "=", "float", "(", "self", ".", "conf", "[", "'input_noise'", "]", ")", ")", "\n", "\n", "# Primary capsule.", "\n", "", "with", "tf", ".", "variable_scope", "(", "'primary_capsule'", ")", ":", "\n", "\t\t\t\t", "output", "=", "tf", ".", "identity", "(", "inputs", ",", "'inputs'", ")", "\n", "input_seq_length", "=", "tf", ".", "identity", "(", "input_seq_length", ",", "'input_seq_length'", ")", "\n", "\n", "# First layer is simple bidirectional rnn layer, without activation (squash activation", "\n", "# will be applied later)", "\n", "primary_output_dim", "=", "num_capsules", "*", "capsule_dim", "\n", "primary_capsules_layer", "=", "layer", ".", "BLSTMLayer", "(", "num_units", "=", "primary_output_dim", ",", "linear_out_flag", "=", "True", ")", "\n", "\n", "primary_capsules", "=", "primary_capsules_layer", "(", "output", ",", "input_seq_length", ")", "\n", "primary_capsules", "=", "tf", ".", "reshape", "(", "primary_capsules", ",", "[", "output", ".", "shape", "[", "0", "]", ".", "value", ",", "tf", ".", "shape", "(", "output", ")", "[", "1", "]", ",", "\n", "num_capsules", "*", "2", ",", "capsule_dim", "]", ")", "\n", "\n", "primary_capsules", "=", "ops", ".", "squash", "(", "primary_capsules", ")", "\n", "\n", "output", "=", "tf", ".", "identity", "(", "primary_capsules", ",", "'primary_capsules'", ")", "\n", "\n", "# non-primary capsules", "\n", "", "for", "l", "in", "range", "(", "1", ",", "int", "(", "self", ".", "conf", "[", "'num_layers'", "]", ")", ")", ":", "\n", "\t\t\t\t", "with", "tf", ".", "variable_scope", "(", "'layer%d'", "%", "l", ")", ":", "\n", "# a capsule layer", "\n", "\t\t\t\t\t", "caps_blstm_layer", "=", "layer", ".", "BLSTMCapsuleLayer", "(", "num_capsules", "=", "num_capsules", ",", "capsule_dim", "=", "capsule_dim", ",", "\n", "routing_iters", "=", "routing_iters", ",", "\n", "recurrent_probability_fn", "=", "recurrent_probability_fn", ",", "\n", "logits_prior", "=", "logits_prior", ",", "\n", "accumulate_input_logits", "=", "accumulate_input_logits", ",", "\n", "accumulate_state_logits", "=", "accumulate_state_logits", ",", "\n", "gates_fc", "=", "gates_fc", ",", "\n", "use_output_matrix", "=", "use_output_matrix", ")", "\n", "\n", "output", "=", "caps_blstm_layer", "(", "output", ",", "input_seq_length", ")", "\n", "\n", "if", "is_training", "and", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", "<", "1", ":", "\n", "\t\t\t\t\t\t", "output", "=", "tf", ".", "nn", ".", "dropout", "(", "output", ",", "float", "(", "self", ".", "conf", "[", "'dropout'", "]", ")", ")", "\n", "\n", "", "", "", "output_dim", "=", "num_capsules", "*", "2", "*", "capsule_dim", "\n", "output", "=", "tf", ".", "reshape", "(", "output", ",", "[", "output", ".", "shape", "[", "0", "]", ".", "value", ",", "tf", ".", "shape", "(", "output", ")", "[", "1", "]", ",", "output_dim", "]", ")", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_evaluator.TaskEvaluator.__init__": [[17, 98], ["dict", "task_eval_conf[].split", "task_eval_conf[].split", "task_eval_conf[].split", "task_eval_conf[].split", "dict", "dict", "dict", "dict", "dict", "conf.items", "int", "int", "int", "int", "task_eval_conf[].split", "dict", "task_eval_conf[].split", "task_evaluator.TaskEvaluator.conf.get", "task_evaluator.TaskEvaluator.conf.get", "numpy.array", "numpy.array", "task_eval_conf[].split", "task_evaluator.TaskEvaluator.input_dataconfs[].append", "task_eval_conf[].split", "task_evaluator.TaskEvaluator.target_dataconfs[].append", "task_eval_conf[].split", "map", "zip", "dataconfs_for_input.append", "dataconfs_for_target.append", "task_eval_conf[].split", "len", "dict", "dict", "dataconf.items", "dataconf.items"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", ",", "dataconf", ",", "models", ",", "task", ")", ":", "\n", "\t\t", "\"\"\"TaskEvaluator constructor\n\n\t\tArgs:\n\t\t\tconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\tmodels: the models to be evaluated\n\t\t\"\"\"", "\n", "\n", "self", ".", "conf", "=", "conf", "\n", "self", ".", "models", "=", "models", "\n", "self", ".", "task", "=", "task", "\n", "task_eval_conf", "=", "dict", "(", "conf", ".", "items", "(", "task", ")", ")", "\n", "\n", "if", "'requested_utts'", "in", "task_eval_conf", ":", "\n", "\t\t\t", "self", ".", "requested_utts", "=", "int", "(", "task_eval_conf", "[", "'requested_utts'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "requested_utts", "=", "int", "(", "self", ".", "conf", ".", "get", "(", "'evaluator'", ",", "'requested_utts'", ")", ")", "\n", "", "if", "'batch_size'", "in", "task_eval_conf", ":", "\n", "\t\t\t", "self", ".", "batch_size", "=", "int", "(", "task_eval_conf", "[", "'batch_size'", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "batch_size", "=", "int", "(", "self", ".", "conf", ".", "get", "(", "'evaluator'", ",", "'batch_size'", ")", ")", "\n", "\n", "# get the database configurations for all inputs, outputs, intermediate model nodes and models.", "\n", "", "self", ".", "output_names", "=", "task_eval_conf", "[", "'outputs'", "]", ".", "split", "(", "' '", ")", "\n", "self", ".", "input_names", "=", "task_eval_conf", "[", "'inputs'", "]", ".", "split", "(", "' '", ")", "\n", "self", ".", "model_nodes", "=", "task_eval_conf", "[", "'nodes'", "]", ".", "split", "(", "' '", ")", "\n", "self", ".", "target_names", "=", "task_eval_conf", "[", "'targets'", "]", ".", "split", "(", "' '", ")", "\n", "if", "self", ".", "target_names", "==", "[", "''", "]", ":", "\n", "\t\t\t", "self", ".", "target_names", "=", "[", "]", "\n", "\n", "", "if", "'linkedsets'", "in", "task_eval_conf", ":", "\n", "\t\t\t", "set_names", "=", "task_eval_conf", "[", "'linkedsets'", "]", ".", "split", "(", "' '", ")", "\n", "self", ".", "linkedsets", "=", "dict", "(", ")", "\n", "for", "set_name", "in", "set_names", ":", "\n", "\t\t\t\t", "set_input_names", "=", "[", "'%s_%s'", "%", "(", "set_name", ",", "in_name", ")", "for", "in_name", "in", "self", ".", "input_names", "]", "\n", "set_target_names", "=", "[", "'%s_%s'", "%", "(", "set_name", ",", "tar_name", ")", "for", "tar_name", "in", "self", ".", "target_names", "]", "\n", "self", ".", "linkedsets", "[", "set_name", "]", "=", "{", "'inputs'", ":", "set_input_names", ",", "'targets'", ":", "set_target_names", "}", "\n", "\n", "", "if", "'linkedset_weighting'", "in", "task_eval_conf", ":", "\n", "\t\t\t\t", "linkedset_weighting", "=", "np", ".", "array", "(", "map", "(", "float", ",", "task_eval_conf", "[", "'linkedset_weighting'", "]", ".", "split", "(", "' '", ")", ")", ")", "\n", "# the first set has the reference weight", "\n", "linkedset_weighting", "/=", "linkedset_weighting", "[", "0", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "linkedset_weighting", "=", "np", ".", "array", "(", "[", "1.0", "]", "*", "len", "(", "self", ".", "linkedsets", ")", ")", "\n", "", "self", ".", "linkedset_weighting", "=", "{", "set_name", ":", "weight", "for", "set_name", ",", "weight", "in", "zip", "(", "set_names", ",", "linkedset_weighting", ")", "}", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "linkedsets", "=", "{", "'set0'", ":", "{", "'inputs'", ":", "self", ".", "input_names", ",", "'targets'", ":", "self", ".", "target_names", "}", "}", "\n", "self", ".", "linkedset_weighting", "=", "{", "'set0'", ":", "1.0", "}", "\n", "\n", "", "self", ".", "input_dataconfs", "=", "dict", "(", ")", "\n", "self", ".", "target_dataconfs", "=", "dict", "(", ")", "\n", "for", "linkedset", "in", "self", ".", "linkedsets", ":", "\n", "\t\t\t", "self", ".", "input_dataconfs", "[", "linkedset", "]", "=", "[", "]", "\n", "for", "input_name", "in", "self", ".", "linkedsets", "[", "linkedset", "]", "[", "'inputs'", "]", ":", "\n", "# input config", "\n", "\t\t\t\t", "dataconfs_for_input", "=", "[", "]", "\n", "sections", "=", "task_eval_conf", "[", "input_name", "]", ".", "split", "(", "' '", ")", "\n", "for", "section", "in", "sections", ":", "\n", "\t\t\t\t\t", "dataconfs_for_input", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "section", ")", ")", ")", "\n", "", "self", ".", "input_dataconfs", "[", "linkedset", "]", ".", "append", "(", "dataconfs_for_input", ")", "\n", "\n", "", "self", ".", "target_dataconfs", "[", "linkedset", "]", "=", "[", "]", "\n", "for", "target_name", "in", "self", ".", "linkedsets", "[", "linkedset", "]", "[", "'targets'", "]", ":", "\n", "# target config", "\n", "\t\t\t\t", "dataconfs_for_target", "=", "[", "]", "\n", "sections", "=", "task_eval_conf", "[", "target_name", "]", ".", "split", "(", "' '", ")", "\n", "for", "section", "in", "sections", ":", "\n", "\t\t\t\t\t", "dataconfs_for_target", ".", "append", "(", "dict", "(", "dataconf", ".", "items", "(", "section", ")", ")", ")", "\n", "", "self", ".", "target_dataconfs", "[", "linkedset", "]", ".", "append", "(", "dataconfs_for_target", ")", "\n", "\n", "", "", "self", ".", "model_links", "=", "dict", "(", ")", "\n", "self", ".", "inputs_links", "=", "dict", "(", ")", "\n", "self", ".", "nodes_output_names", "=", "dict", "(", ")", "\n", "for", "node", "in", "self", ".", "model_nodes", ":", "\n", "\t\t\t", "self", ".", "model_links", "[", "node", "]", "=", "task_eval_conf", "[", "'%s_model'", "%", "node", "]", "\n", "self", ".", "inputs_links", "[", "node", "]", "=", "task_eval_conf", "[", "'%s_inputs'", "%", "node", "]", ".", "split", "(", "' '", ")", "\n", "if", "'%s_output_names'", "%", "node", "in", "task_eval_conf", ":", "\n", "\t\t\t\t", "self", ".", "nodes_output_names", "[", "node", "]", "=", "task_eval_conf", "[", "'%s_output_names'", "%", "node", "]", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "nodes_output_names", "[", "node", "]", "=", "node", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_evaluator.TaskEvaluator.evaluate": [[99, 172], ["tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.name_scope", "dict", "dict", "dict", "enumerate", "nabu.processing.input_pipeline.get_filenames", "len", "min", "print", "tensorflow.train.string_input_producer", "nabu.processing.input_pipeline.input_pipeline", "enumerate", "enumerate", "task_evaluator.TaskEvaluator._get_outputs", "task_evaluator.TaskEvaluator.compute_loss", "tensorflow.reduce_sum.append", "tensorflow.reduce_sum.append", "BaseException", "len"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_loss_evaluator.TaskLossEvaluator._get_outputs", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_loss_evaluator.TaskLossEvaluator.compute_loss"], ["", "", "", "def", "evaluate", "(", "self", ",", "start_utt_ind", "=", "0", ")", ":", "\n", "\t\t", "\"\"\"evaluate the performance of the model\n\n\t\tReturns:\n\t\t\t- the loss as a scalar tensor\n\t\t\t- the number of batches in the validation set as an integer\n\t\t\"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'evaluate'", ")", ":", "\n", "\t\t\t", "inputs", "=", "dict", "(", ")", "\n", "seq_lengths", "=", "dict", "(", ")", "\n", "targets", "=", "dict", "(", ")", "\n", "loss", "=", "[", "]", "\n", "norm", "=", "[", "]", "\n", "for", "set_ind", ",", "linkedset", "in", "enumerate", "(", "self", ".", "linkedsets", ")", ":", "\n", "\t\t\t\t", "data_queue_elements", ",", "_", "=", "input_pipeline", ".", "get_filenames", "(", "\n", "self", ".", "input_dataconfs", "[", "linkedset", "]", "+", "self", ".", "target_dataconfs", "[", "linkedset", "]", ")", "\n", "\n", "max_number_of_elements", "=", "len", "(", "data_queue_elements", ")", "\n", "number_of_elements", "=", "min", "(", "[", "max_number_of_elements", ",", "self", ".", "requested_utts", "]", ")", "\n", "\n", "# compute the number of batches in the validation set", "\n", "numbatches", "=", "number_of_elements", "/", "self", ".", "batch_size", "\n", "number_of_elements", "=", "numbatches", "*", "self", ".", "batch_size", "\n", "if", "number_of_elements", "==", "0", ":", "\n", "\t\t\t\t\t", "raise", "BaseException", "(", "'The number of elements used for validation must be larger than 0.'", ")", "\n", "", "print", "(", "'%d utterances will be used for evaluation'", "%", "number_of_elements", ")", "\n", "\n", "# cut the data so it has a whole number of batches", "\n", "data_queue_elements", "=", "data_queue_elements", "[", "start_utt_ind", ":", "number_of_elements", "]", "\n", "\n", "# create the data queue and queue runners (inputs are not allowed to get shuffled. I already did this so set to False)", "\n", "data_queue", "=", "tf", ".", "train", ".", "string_input_producer", "(", "\n", "string_tensor", "=", "data_queue_elements", ",", "\n", "shuffle", "=", "False", ",", "\n", "seed", "=", "None", ",", "\n", "capacity", "=", "self", ".", "batch_size", "*", "2", ")", "\n", "\n", "# create the input pipeline", "\n", "data", ",", "seq_length", "=", "input_pipeline", ".", "input_pipeline", "(", "\n", "data_queue", "=", "data_queue", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "numbuckets", "=", "1", ",", "\n", "dataconfs", "=", "self", ".", "input_dataconfs", "[", "linkedset", "]", "+", "self", ".", "target_dataconfs", "[", "linkedset", "]", "\n", ")", "\n", "# split data into inputs and targets", "\n", "for", "ind", ",", "input_name", "in", "enumerate", "(", "self", ".", "input_names", ")", ":", "\n", "\t\t\t\t\t", "inputs", "[", "input_name", "]", "=", "data", "[", "ind", "]", "\n", "seq_lengths", "[", "input_name", "]", "=", "seq_length", "[", "ind", "]", "\n", "\n", "# out_seq_lengths = {", "\n", "# \tseq_name: seq for seq_name, seq in seq_lengths.iteritems()", "\n", "# \tif seq_name in self.output_names}", "\n", "", "out_seq_lengths", "=", "{", "\n", "output_name", ":", "seq_lengths", "[", "self", ".", "input_names", "[", "0", "]", "]", "for", "output_name", "in", "self", ".", "output_names", "}", "\n", "\n", "for", "ind", ",", "target_name", "in", "enumerate", "(", "self", ".", "target_names", ")", ":", "\n", "\t\t\t\t\t", "targets", "[", "target_name", "]", "=", "data", "[", "len", "(", "self", ".", "input_names", ")", "+", "ind", "]", "\n", "\n", "# get the logits", "\n", "", "logits", "=", "self", ".", "_get_outputs", "(", "\n", "inputs", "=", "inputs", ",", "\n", "seq_lengths", "=", "seq_lengths", ")", "\n", "\n", "set_loss", ",", "set_norm", "=", "self", ".", "compute_loss", "(", "targets", ",", "logits", ",", "seq_lengths", ")", "\n", "set_loss", "*=", "self", ".", "linkedset_weighting", "[", "linkedset", "]", "\n", "set_norm", "*=", "self", ".", "linkedset_weighting", "[", "linkedset", "]", "\n", "loss", ".", "append", "(", "set_loss", ")", "\n", "norm", ".", "append", "(", "set_norm", ")", "\n", "", "", "loss", "=", "tf", ".", "reduce_sum", "(", "loss", ")", "\n", "norm", "=", "tf", ".", "reduce_sum", "(", "norm", ")", "\n", "\n", "return", "loss", ",", "norm", ",", "numbatches", ",", "logits", ",", "targets", ",", "out_seq_lengths", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_evaluator.TaskEvaluator._get_outputs": [[173, 185], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_get_outputs", "(", "self", ",", "inputs", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"compute the validation outputs for a batch of data\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a list of\n\t\t\t\t[batch_size x ...] tensors\n\t\t\tseq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a list of [batch_size] vectors\n\n\t\tReturns:\n\t\t\tthe outputs\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_evaluator.TaskEvaluator.compute_loss": [[186, 200], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "compute_loss", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"compute the validation loss for a batch of data\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\ta scalar value containing the loss\"\"\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.evaluator_factory.factory": [[7, 22], ["Exception"], "function", ["None"], ["def", "factory", "(", "evaluator", ")", ":", "\n", "    ", "\"\"\"\n    gets an evaluator class\n\n    Args:\n    evaluator: the evaluator type\n\n    Returns:\n    an evaluator class\n    \"\"\"", "\n", "\n", "if", "evaluator", "==", "'task_loss_evaluator'", ":", "\n", "        ", "return", "task_loss_evaluator", ".", "TaskLossEvaluator", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Undefined evaluator type: %s'", "%", "evaluator", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_loss_evaluator.TaskLossEvaluator.__init__": [[13, 31], ["task_evaluator.TaskEvaluator.__init__", "conf.get", "nabu.neuralnetworks.loss_computers.loss_computer_factory.factory"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory"], ["def", "__init__", "(", "self", ",", "conf", ",", "dataconf", ",", "lossconf", ",", "models", ",", "task", ")", ":", "\n", "\t\t", "\"\"\"TaskLossEvaluator constructor\n\n\t\tArgs:\n\t\t\tconf: the evaluator configuration as a ConfigParser\n\t\t\tdataconf: the database configuration\n\t\t\tlossconf: a configuration for the loss function\n\t\t\tmodels: the models to be evaluated\n\t\t\ttask: the name of the task being evaluated\n\t\t\"\"\"", "\n", "\n", "super", "(", "TaskLossEvaluator", ",", "self", ")", ".", "__init__", "(", "conf", ",", "dataconf", ",", "models", ",", "task", ")", "\n", "\n", "if", "lossconf", ":", "\n", "\t\t\t", "loss_type", "=", "lossconf", "[", "'loss_type'", "]", "\n", "", "else", ":", "\n", "\t\t\t", "loss_type", "=", "conf", ".", "get", "(", "task", ",", "'loss_type'", ")", "\n", "", "self", ".", "loss_computer", "=", "loss_computer_factory", ".", "factory", "(", "loss_type", ")", "(", "lossconf", ",", "self", ".", "batch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_loss_evaluator.TaskLossEvaluator._get_outputs": [[32, 57], ["tensorflow.name_scope", "nabu.neuralnetworks.models.run_multi_model.run_multi_model"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.models.run_multi_model.run_multi_model"], ["", "def", "_get_outputs", "(", "self", ",", "inputs", ",", "seq_lengths", ")", ":", "\n", "\t\t", "\"\"\"compute the evaluation logits for a batch of data\n\n\t\tArgs:\n\t\t\tinputs: the inputs to the neural network, this is a dictionary of\n\t\t\t\t[batch_size x ...] tensors\n\t\t\tseq_length: The sequence lengths of the input utterances, this\n\t\t\t\tis a list of [batch_size] vectors\n\n\t\tReturns:\n\t\t\tthe logits\"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'evaluate_logits'", ")", ":", "\n", "\t\t\t", "logits", ",", "_", "=", "run_multi_model", ".", "run_multi_model", "(", "\n", "models", "=", "self", ".", "models", ",", "\n", "model_nodes", "=", "self", ".", "model_nodes", ",", "\n", "model_links", "=", "self", ".", "model_links", ",", "\n", "inputs", "=", "inputs", ",", "\n", "inputs_links", "=", "self", ".", "inputs_links", ",", "\n", "nodes_output_names", "=", "self", ".", "nodes_output_names", ",", "\n", "output_names", "=", "self", ".", "output_names", ",", "\n", "seq_lengths", "=", "seq_lengths", ",", "\n", "is_training", "=", "False", ")", "\n", "\n", "", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.evaluators.task_loss_evaluator.TaskLossEvaluator.compute_loss": [[58, 76], ["tensorflow.name_scope", "task_loss_evaluator.TaskLossEvaluator.loss_computer"], "methods", ["None"], ["", "def", "compute_loss", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"compute the evaluation loss for a batch of data\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tthe loss as a scalar\"\"\"", "\n", "\n", "with", "tf", ".", "name_scope", "(", "'evaluate_loss'", ")", ":", "\n", "\t\t\t", "loss", ",", "norm", "=", "self", ".", "loss_computer", "(", "targets", ",", "logits", ",", "seq_length", ")", "\n", "\n", "", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer.LossComputer.__init__": [[11, 20], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lossconf", ",", "batch_size", ")", ":", "\n", "\t\t", "\"\"\"LossComputer constructor\n\n\t\tArgs:\n\t\t\tlossconf: the configuration file for the loss function\n\t\t\tbatch_size: the size of the batch to compute the loss over\n\t\t\"\"\"", "\n", "self", ".", "lossconf", "=", "lossconf", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseLoss.__call__": [[12, 43], ["nabu.neuralnetworks.components.ops.deepclustering_noise_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the deep clustering loss when\n        modified network architecture is used\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n        seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss (of mini-batch)\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "binary_target", "=", "targets", "[", "'binary_targets'", "]", "# partition targets", "\n", "energybins", "=", "targets", "[", "'usedbins'", "]", "# which bins contain enough energy", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "# Sequence length of utterances in batch", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "# Embeddingvectors", "\n", "alpha", "=", "logits", "[", "'noise_filter'", "]", "# alpha outputs", "\n", "noisybins", "=", "targets", "[", "'noisybins'", "]", "# Dominates noise the cell", "\n", "ideal_ratio", "=", "targets", "[", "'rel_speech_targets'", "]", "# Ideal ratio masker to filter noise", "\n", "# Calculate cost and normalisation", "\n", "loss", ",", "norm", "=", "ops", ".", "deepclustering_noise_loss", "(", "\n", "binary_target", ",", "noisybins", ",", "ideal_ratio", ",", "emb_vec", ",", "alpha", ",", "energybins", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseRatAsWeightLoss.__call__": [[48, 80], ["nabu.neuralnetworks.components.ops.deepclustering_noise_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the deep clustering loss when\n        modified network architecture is used\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n        seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss (of mini-batch)\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "binary_target", "=", "targets", "[", "'binary_targets'", "]", "# partition targets", "\n", "energybins", "=", "targets", "[", "'usedbins'", "]", "# which bins contain enough energy", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "# Sequence length of utterances in batch", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "# Embeddingvectors", "\n", "alpha", "=", "logits", "[", "'noise_filter'", "]", "# alpha outputs", "\n", "noisybins", "=", "targets", "[", "'noisybins'", "]", "# Dominates noise the cell", "\n", "ideal_ratio", "=", "targets", "[", "'rel_speech_targets'", "]", "# Ideal ratio masker to filter noise", "\n", "# Calculate cost and normalisation", "\n", "loss", ",", "norm", "=", "ops", ".", "deepclustering_noise_loss", "(", "\n", "binary_target", ",", "noisybins", ",", "ideal_ratio", ",", "emb_vec", ",", "alpha", ",", "energybins", ",", "seq_length", ",", "self", ".", "batch_size", ",", "\n", "rat_as_weight", "=", "True", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseAlphaAsWeightLoss.__call__": [[85, 117], ["nabu.neuralnetworks.components.ops.deepclustering_noise_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the deep clustering loss when\n        modified network architecture is used\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n        seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss (of mini-batch)\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "binary_target", "=", "targets", "[", "'binary_targets'", "]", "# partition targets", "\n", "energybins", "=", "targets", "[", "'usedbins'", "]", "# which bins contain enough energy", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "# Sequence length of utterances in batch", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "# Embeddingvectors", "\n", "alpha", "=", "logits", "[", "'noise_filter'", "]", "# alpha outputs", "\n", "noisybins", "=", "targets", "[", "'noisybins'", "]", "# Dominates noise the cell", "\n", "ideal_ratio", "=", "targets", "[", "'rel_speech_targets'", "]", "# Ideal ratio masker to filter noise", "\n", "# Calculate cost and normalisation", "\n", "loss", ",", "norm", "=", "ops", ".", "deepclustering_noise_loss", "(", "\n", "binary_target", ",", "noisybins", ",", "ideal_ratio", ",", "emb_vec", ",", "alpha", ",", "energybins", ",", "seq_length", ",", "self", ".", "batch_size", ",", "\n", "rat_as_weight", "=", "False", ",", "alpha_as_weight", "=", "True", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__": [[122, 127], ["loss_computer.LossComputer.__init__"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__init__"], ["def", "__init__", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "self", ".", "alpha", "=", "0.2", "\n", "self", ".", "beta", "=", "-", "6.0", "\n", "\n", "super", "(", "DeepclusteringnoiseSnrTargetLoss", ",", "self", ")", ".", "__init__", "(", "batch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseSnrTargetLoss.__call__": [[128, 160], ["nabu.neuralnetworks.components.ops.deepclustering_noise_loss", "tensorflow.exp"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the deep clustering loss when\n        modified network architecture is used\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n        seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss (of mini-batch)\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "binary_target", "=", "targets", "[", "'binary_targets'", "]", "# partition targets", "\n", "energybins", "=", "targets", "[", "'usedbins'", "]", "# which bins contain enough energy", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "# Sequence length of utterances in batch", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "# Embeddingvectors", "\n", "alpha", "=", "logits", "[", "'noise_filter'", "]", "# alpha outputs", "\n", "noisybins", "=", "targets", "[", "'noisybins'", "]", "# Dominates noise the cell", "\n", "snr", "=", "targets", "[", "'snr_targets'", "]", "# Ideal ratio masker to filter noise", "\n", "desired_targets", "=", "1", "/", "(", "1", "+", "tf", ".", "exp", "(", "-", "self", ".", "alpha", "*", "(", "snr", "-", "self", ".", "beta", ")", ")", ")", "\n", "# Calculate cost and normalisation", "\n", "loss", ",", "norm", "=", "ops", ".", "deepclustering_noise_loss", "(", "\n", "binary_target", ",", "noisybins", ",", "desired_targets", ",", "emb_vec", ",", "alpha", ",", "energybins", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseDConlyLoss.__call__": [[165, 195], ["nabu.neuralnetworks.components.ops.deepclustering_noise_DC_only_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Ignore this class, just for analysis\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n        seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss (of mini-batch)\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "binary_target", "=", "targets", "[", "'binary_targets'", "]", "# partition targets", "\n", "energybins", "=", "targets", "[", "'usedbins'", "]", "# which bins contain enough energy", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "# Sequence length of utterances in batch", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "# Embeddingvectors", "\n", "alpha", "=", "logits", "[", "'noise_filter'", "]", "# alpha outputs", "\n", "noisybins", "=", "targets", "[", "'noisybins'", "]", "# Dominates noise the cell", "\n", "ideal_ratio", "=", "targets", "[", "'rel_speech_targets'", "]", "# Ideal ratio masker to filter noise", "\n", "# Calculate cost and normalisation", "\n", "loss", ",", "norm", "=", "ops", ".", "deepclustering_noise_DC_only_loss", "(", "\n", "binary_target", ",", "noisybins", ",", "ideal_ratio", ",", "emb_vec", ",", "alpha", ",", "energybins", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclusteringnoise_loss.DeepclusteringnoiseNoiseonlyLoss.__call__": [[200, 225], ["nabu.neuralnetworks.components.ops.noise_mask_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Ignore this class, just for analysis\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n        seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss (of mini-batch)\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "energybins", "=", "targets", "[", "'usedbins'", "]", "# which bins contain enough energy", "\n", "alpha", "=", "logits", "[", "'noise_filter'", "]", "# alpha outputs", "\n", "ideal_ratio", "=", "targets", "[", "'rel_speech_targets'", "]", "# Ideal ratio masker to filter noise", "\n", "# Calculate cost and normalisation", "\n", "loss", ",", "norm", "=", "ops", ".", "noise_mask_loss", "(", "ideal_ratio", ",", "alpha", ",", "energybins", ")", "\n", "\n", "return", "loss", ",", "norm", "", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.direct_loss.DirectLoss.__call__": [[12, 40], ["warnings.warn", "nabu.neuralnetworks.components.ops.direct_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the Permutation Invariant Training loss\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "\n", "warnings", ".", "warn", "(", "'In following versions it will be required to use PITLoss'", ",", "Warning", ")", "\n", "\n", "multi_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "seq_length", "=", "seq_length", "[", "'bin_est'", "]", "\n", "logits", "=", "logits", "[", "'bin_est'", "]", "\n", "\n", "loss", ",", "norm", "=", "ops", ".", "direct_loss", "(", "multi_targets", ",", "logits", ",", "mix_to_mask", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepattractornetnoise_soft_loss.DeepattractornetnoisesoftLoss.__call__": [[11, 47], ["nabu.neuralnetworks.components.ops.deepattractornetnoise_soft_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the Deep attractor network loss with\n        adapted architecture and soft decissions\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n            seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "# To which class belongs bin", "\n", "partioning", "=", "targets", "[", "'partitioning'", "]", "\n", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'spectogram_targets'", "]", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "# Which bins contain enough energy", "\n", "energybins", "=", "targets", "[", "'energybins'", "]", "\n", "seq_length", "=", "seq_length", "[", "'emb_vec'", "]", "\n", "emb_vec", "=", "logits", "[", "'emb_vec'", "]", "\n", "alpha", "=", "logits", "[", "'alpha'", "]", "\n", "\n", "loss", ",", "norm", "=", "ops", ".", "deepattractornetnoise_soft_loss", "(", "\n", "partioning", ",", "spectrogram_targets", ",", "mix_to_mask", ",", "energybins", ",", "emb_vec", ",", "alpha", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepattractornet_loss.DeepattractornetLoss.__call__": [[11, 57], ["warnings.warn", "nabu.neuralnetworks.components.ops.deepattractornet_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the deep attractor loss\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n            seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "warnings", ".", "warn", "(", "'Since 2020/03/02 the norm is computed in the same way as for PIT.'", ",", "Warning", ")", "\n", "\n", "activation", "=", "self", ".", "lossconf", "[", "'activation'", "]", "\n", "if", "'frame_based'", "in", "self", ".", "lossconf", ":", "\n", "            ", "frame_based", "=", "self", ".", "lossconf", "[", "'frame_based'", "]", "in", "[", "'true'", ",", "'True'", "]", "\n", "", "else", ":", "\n", "            ", "frame_based", "=", "False", "\n", "\n", "# To which class belongs bin", "\n", "", "partioning", "=", "targets", "[", "'binary_targets'", "]", "\n", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Which bins contain enough energy", "\n", "energybins", "=", "targets", "[", "'usedbins'", "]", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "# calculate loss and normalisation factor of mini-batch", "\n", "loss", ",", "norm", "=", "ops", ".", "deepattractornet_loss", "(", "\n", "partioning", ",", "spectrogram_targets", ",", "mix_to_mask", ",", "energybins", ",", "emb_vec", ",", "seq_length", ",", "self", ".", "batch_size", ",", "\n", "activation", "=", "activation", ",", "frame_based", "=", "frame_based", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.pit_noise_loss.PITNoiseLoss.__call__": [[11, 39], ["nabu.neuralnetworks.components.ops.pit_noise_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the Permudation Invariant Training loss, including a noise mask\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "\n", "multi_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "seq_length", "=", "seq_length", "[", "'bin_est'", "]", "\n", "bin_est", "=", "logits", "[", "'bin_est'", "]", "\n", "noise_filter", "=", "logits", "[", "'noise_filter'", "]", "\n", "\n", "loss", ",", "norm", "=", "ops", ".", "pit_noise_loss", "(", "\n", "multi_targets", ",", "bin_est", ",", "noise_filter", ",", "mix_to_mask", ",", "seq_length", ",", "self", ".", "batch_size", ",", "activation", "=", "'softmax'", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.dummy_loss.DummyLoss.__call__": [[11, 27], ["tensorflow.constant", "tensorflow.constant"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "\n", "return", "tf", ".", "constant", "(", "0.0", ")", ",", "tf", ".", "constant", "(", "1.0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.crossentropy_multi_loss.CrossEntropyMultiLoss.__call__": [[12, 55], ["nabu.neuralnetworks.components.ops.crossentropy_multi_loss", "tensorflow.reduce_mean", "tensorflow.reshape", "spkids.get_shape"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the crossentropy multi loss\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x ... x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x ... x ...] tensors containing the logits\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "\n", "if", "'av_anchors_time_flag'", "in", "self", ".", "lossconf", "and", "self", ".", "lossconf", "[", "'av_anchors_time_flag'", "]", "in", "[", "'true'", ",", "'True'", "]", ":", "\n", "\t\t\t", "av_anchors_time_flag", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "av_anchors_time_flag", "=", "False", "\n", "\n", "", "if", "'resh_logits'", "in", "self", ".", "lossconf", "and", "self", ".", "lossconf", "[", "'resh_logits'", "]", "in", "[", "'true'", ",", "'True'", "]", ":", "\n", "\t\t\t", "resh_logits", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "resh_logits", "=", "False", "\n", "\n", "", "if", "'allow_permutation'", "not", "in", "self", ".", "lossconf", "or", "self", ".", "lossconf", "[", "'allow_permutation'", "]", "==", "'True'", ":", "\n", "\t\t\t", "allow_permutation", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "allow_permutation", "=", "False", "\n", "\n", "", "spkids", "=", "targets", "[", "'spkids'", "]", "\n", "logits", "=", "logits", "[", "'spkest'", "]", "\n", "\n", "if", "av_anchors_time_flag", ":", "\n", "\t\t\t", "logits", "=", "tf", ".", "reduce_mean", "(", "logits", ",", "1", ")", "\n", "", "if", "resh_logits", ":", "\n", "\t\t\t", "nrS", "=", "spkids", ".", "get_shape", "(", ")", "[", "1", "]", "\n", "logits", "=", "tf", ".", "reshape", "(", "logits", ",", "[", "self", ".", "batch_size", ",", "nrS", ",", "-", "1", "]", ")", "\n", "\n", "", "loss", ",", "norm", "=", "ops", ".", "crossentropy_multi_loss", "(", "spkids", ",", "logits", ",", "self", ".", "batch_size", ",", "allow_permutation", "=", "allow_permutation", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepattractornet_noisefilter_loss.DeepattractornetnoisefilterLoss.__call__": [[11, 44], ["nabu.neuralnetworks.components.ops.deepattractornet_noisefilter_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the deep attractor network loss for the connected network\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n            seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "# To which class belongs bin", "\n", "partitioning", "=", "targets", "[", "'partitioning'", "]", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'spectrogram_targets'", "]", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "# Which bins contain enough energy", "\n", "seq_length", "=", "seq_length", "[", "'emb_vec'", "]", "\n", "emb_vec", "=", "logits", "[", "'emb_vec'", "]", "\n", "alpha", "=", "logits", "[", "'alpha'", "]", "\n", "\n", "loss", ",", "norm", "=", "ops", ".", "deepattractornet_noisefilter_loss", "(", "\n", "partitioning", ",", "spectrogram_targets", ",", "mix_to_mask", ",", "emb_vec", ",", "alpha", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepattractornetnoise_hard_loss.DeepattractornetnoisehardLoss.__call__": [[11, 46], ["nabu.neuralnetworks.components.ops.deepattractornetnoise_hard_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the Deep attractor network loss with\n        adapted architecture and hard decissions\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n            seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "# To which class belongs bin", "\n", "partioning", "=", "targets", "[", "'partitioning'", "]", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'spectogram_targets'", "]", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "# Which bins contain enough energy", "\n", "energybins", "=", "targets", "[", "'energybins'", "]", "\n", "seq_length", "=", "seq_length", "[", "'emb_vec'", "]", "\n", "emb_vec", "=", "logits", "[", "'emb_vec'", "]", "\n", "alpha", "=", "logits", "[", "'alpha'", "]", "\n", "\n", "loss", ",", "norm", "=", "ops", ".", "deepattractornetnoise_hard_loss", "(", "\n", "partioning", ",", "spectrogram_targets", ",", "mix_to_mask", ",", "energybins", ",", "emb_vec", ",", "alpha", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.noisefilter_loss.NoisefilterLoss.__call__": [[11, 38], ["nabu.neuralnetworks.components.ops.noise_filter_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the loss of the noise filtering network\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n        seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "clean_spectrogram", "=", "targets", "[", "'cleanspectrogram'", "]", "\n", "noise_spectrogram", "=", "targets", "[", "'noisespectrogram'", "]", "\n", "seq_length", "=", "seq_length", "[", "'alpha'", "]", "\n", "alpha", "=", "logits", "[", "'alpha'", "]", "\n", "\n", "loss", ",", "norm", "=", "ops", ".", "noise_filter_loss", "(", "\n", "clean_spectrogram", ",", "noise_spectrogram", ",", "alpha", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.ms_loss.MsLoss.__call__": [[13, 53], ["tensorflow.squeeze", "range", "tensorflow.concat", "tensorflow.concat", "tensorflow.reduce_sum", "tensorflow.to_float", "multi_targets.get_shape", "tensorflow.divide.get_shape", "tensorflow.divide.get_shape", "tensorflow.sigmoid", "BaseException", "len", "BaseException", "tensorflow.divide.get_shape", "tensorflow.shape", "tmp.append", "tensorflow.reduce_sum", "tensorflow.divide", "tensorflow.square", "tensorflow.divide.get_shape", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.ones", "tensorflow.zeros", "tensorflow.concat", "tensorflow.to_float", "tensorflow.ones", "tensorflow.zeros"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "# target is actually only required for it's shape to derive the number of active speakers", "\n", "\t\t", "multi_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "nr_act_spk", "=", "multi_targets", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "# seq_length = seq_length['bin_est']", "\n", "logits", "=", "logits", "[", "'act_logit'", "]", "\n", "logits", "=", "tf", ".", "squeeze", "(", "logits", ",", "axis", "=", "-", "1", ")", "\n", "nr_spk", "=", "logits", ".", "get_shape", "(", ")", "[", "1", "]", "\n", "batch_size", "=", "logits", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "\n", "if", "self", ".", "lossconf", "[", "'activation'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t", "logits", "=", "tf", ".", "sigmoid", "(", "logits", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "'Other activations not yet implemented'", ")", "\n", "\n", "", "if", "len", "(", "logits", ".", "get_shape", "(", ")", ")", "!=", "3", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "'Hardcoded some stuff for 3 dimensions'", ")", "\n", "", "second_dim", "=", "logits", ".", "get_shape", "(", ")", "[", "1", "]", "\n", "seq_length", "=", "seq_length", "[", "'features'", "]", "# have to do this better", "\n", "max_len", "=", "tf", ".", "shape", "(", "logits", ")", "[", "-", "1", "]", "\n", "tmp", "=", "[", "]", "\n", "for", "utt_ind", "in", "range", "(", "batch_size", ")", ":", "\n", "\t\t\t", "tmp", ".", "append", "(", "\n", "tf", ".", "expand_dims", "(", "\n", "tf", ".", "concat", "(", "\n", "[", "tf", ".", "ones", "(", "[", "second_dim", ",", "seq_length", "[", "utt_ind", "]", "]", ")", ",", "tf", ".", "zeros", "(", "[", "second_dim", ",", "max_len", "-", "seq_length", "[", "utt_ind", "]", "]", ")", "]", ",", "-", "1", ")", ",", "0", ")", ")", "\n", "# seq_length_mask[utt_ind, :seq_length[utt_ind]] = 1", "\n", "", "seq_length_mask", "=", "tf", ".", "concat", "(", "tmp", ",", "0", ")", "\n", "logits", "=", "logits", "*", "seq_length_mask", "\n", "\n", "if", "self", ".", "lossconf", "[", "'av_time'", "]", "==", "'True'", ":", "\n", "\t\t\t", "logits", "=", "tf", ".", "reduce_sum", "(", "logits", ",", "2", ")", "\n", "logits", "=", "tf", ".", "divide", "(", "logits", ",", "tf", ".", "expand_dims", "(", "tf", ".", "to_float", "(", "seq_length", ")", ",", "-", "1", ")", ")", "\n", "\n", "", "targets", "=", "tf", ".", "concat", "(", "[", "tf", ".", "ones", "(", "[", "batch_size", ",", "nr_act_spk", "]", ")", ",", "tf", ".", "zeros", "(", "[", "batch_size", ",", "nr_spk", "-", "nr_act_spk", "]", ")", "]", ",", "-", "1", ")", "\n", "\n", "loss", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "logits", "-", "targets", ")", ")", "\n", "norm", "=", "tf", ".", "to_float", "(", "batch_size", "*", "nr_spk", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.ms_loss.MsLoss.oldcall": [[54, 78], ["tensorflow.squeeze", "tensorflow.concat", "tensorflow.reduce_sum", "tensorflow.to_float", "multi_targets.get_shape", "tensorflow.reduce_mean.get_shape", "tensorflow.reduce_mean.get_shape", "tensorflow.sigmoid", "BaseException", "tensorflow.reduce_mean", "tensorflow.square", "tensorflow.ones", "tensorflow.zeros"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["", "def", "oldcall", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "# target is actually only required for it's shape to derive the number of active speakers", "\n", "\t\t", "multi_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "nr_act_spk", "=", "multi_targets", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "# seq_length = seq_length['bin_est']", "\n", "logits", "=", "logits", "[", "'act_logit'", "]", "\n", "logits", "=", "tf", ".", "squeeze", "(", "logits", ",", "axis", "=", "-", "1", ")", "\n", "nr_spk", "=", "logits", ".", "get_shape", "(", ")", "[", "1", "]", "\n", "batch_size", "=", "logits", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "\n", "if", "self", ".", "lossconf", "[", "'activation'", "]", "==", "'sigmoid'", ":", "\n", "\t\t\t", "logits", "=", "tf", ".", "sigmoid", "(", "logits", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "BaseException", "(", "'Other activations not yet implemented'", ")", "\n", "\n", "", "if", "self", ".", "lossconf", "[", "'av_time'", "]", "==", "'True'", ":", "\n", "\t\t\t", "logits", "=", "tf", ".", "reduce_mean", "(", "logits", ",", "2", ")", "\n", "\n", "", "targets", "=", "tf", ".", "concat", "(", "[", "tf", ".", "ones", "(", "[", "batch_size", ",", "nr_act_spk", "]", ")", ",", "tf", ".", "zeros", "(", "[", "batch_size", ",", "nr_spk", "-", "nr_act_spk", "]", ")", "]", ",", "-", "1", ")", "\n", "\n", "loss", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "logits", "-", "targets", ")", ")", "\n", "norm", "=", "tf", ".", "to_float", "(", "batch_size", "*", "nr_spk", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclustering_loss.DeepclusteringLoss.__call__": [[11, 37], ["nabu.neuralnetworks.components.ops.deepclustering_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the deep clustering loss\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n            seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "binary_target", "=", "targets", "[", "'binary_targets'", "]", "\n", "usedbins", "=", "targets", "[", "'usedbins'", "]", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "logits", "=", "logits", "[", "'bin_emb'", "]", "\n", "\n", "loss", ",", "norm", "=", "ops", ".", "deepclustering_loss", "(", "binary_target", ",", "logits", ",", "usedbins", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.loss_computer_factory.factory": [[18, 111], ["Exception"], "function", ["None"], ["def", "factory", "(", "loss_type", ")", ":", "\n", "    ", "\"\"\"gets a Loss computer class\n\n    Args:\n        loss_type: the loss type\n\n    Returns: a Loss computer class\n    \"\"\"", "\n", "\n", "if", "loss_type", "==", "'deepclustering'", ":", "\n", "        ", "return", "deepclustering_loss", ".", "DeepclusteringLoss", "\n", "", "elif", "loss_type", "==", "'deepclustering_flat'", ":", "\n", "        ", "return", "deepclustering_flat_loss", ".", "DeepclusteringFlatLoss", "\n", "", "elif", "loss_type", "==", "'deepclustering_2and3spk'", ":", "\n", "        ", "return", "deepclustering_2and3spk_loss", ".", "Deepclustering2and3SpkLoss", "\n", "", "elif", "loss_type", "==", "'pit'", ":", "\n", "        ", "return", "pit_loss", ".", "PITLoss", "\n", "", "elif", "loss_type", "==", "'deepattractornet'", ":", "\n", "        ", "return", "deepattractornet_loss", ".", "DeepattractornetLoss", "\n", "", "elif", "loss_type", "==", "'anchor_deepattractornet'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_loss", ".", "AnchorDeepattractornetLoss", "\n", "", "elif", "loss_type", "==", "'anchor_deepattractornet_softmax'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_loss", ".", "AnchorDeepattractornetSoftmaxLoss", "\n", "", "elif", "loss_type", "==", "'anchor_normdeepattractornet_softmax'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_loss", ".", "AnchorNormDeepattractornetSoftmaxLoss", "\n", "", "elif", "loss_type", "==", "'weighted_anchor_normdeepattractornet_softmax'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_loss", ".", "WeightedAnchorNormDeepattractornetSoftmaxLoss", "\n", "", "elif", "loss_type", "==", "'time_anchor_deepattractornet_softmax'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_loss", ".", "TimeAnchorDeepattractornetSoftmaxLoss", "\n", "", "elif", "loss_type", "==", "'time_anchor_normdeepattractornet_softmax'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_loss", ".", "TimeAnchorNormDeepattractornetSoftmaxLoss", "\n", "", "elif", "loss_type", "==", "'time_anchor_read_heads_normdeepattractornet_softmax'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_loss", ".", "TimeAnchorReadHeadsNormDeepattractornetSoftmaxLoss", "\n", "", "elif", "loss_type", "==", "'time_anchor_read_heads_normdeepattractornet_softmax_framebased'", ":", "\n", "        ", "return", "anchor_deepattractornet_softmax_loss", ".", "TimeAnchorReadHeadsNormDeepattractornetSoftmaxFramebasedLoss", "\n", "", "elif", "loss_type", "==", "'l41'", ":", "\n", "        ", "return", "l41_loss", ".", "L41Loss", "\n", "", "elif", "loss_type", "==", "'pit_l41'", ":", "\n", "        ", "return", "pit_l41_loss", ".", "PITL41Loss", "\n", "", "elif", "loss_type", "==", "'deepclustering_l1'", ":", "\n", "        ", "return", "deepclustering_L1_loss", ".", "DeepclusteringL1Loss", "\n", "", "elif", "loss_type", "==", "'intravar2centervar_rat'", ":", "\n", "        ", "return", "intravar2centervar_rat_loss", ".", "IntraVar2CenterVarRatLoss", "\n", "", "elif", "loss_type", "==", "'dist2mean_rat'", ":", "\n", "        ", "return", "dist2mean_rat_loss", ".", "Dist2MeanRatLoss", "\n", "", "elif", "loss_type", "==", "'dist2mean_rat_squared'", ":", "\n", "        ", "return", "dist2mean_rat_squared_loss", ".", "Dist2MeanRatSquaredLoss", "\n", "", "elif", "loss_type", "==", "'dist2mean_rat_fracbins'", ":", "\n", "        ", "return", "dist2mean_rat_fracbins_loss", ".", "Dist2MeanRatFracBinsLoss", "\n", "", "elif", "loss_type", "==", "'dist2mean_closest_rat'", ":", "\n", "        ", "return", "dist2mean_closest_rat_loss", ".", "Dist2MeanClosestRatLoss", "\n", "", "elif", "loss_type", "==", "'dist2mean_epsilon_closest_rat'", ":", "\n", "        ", "return", "dist2mean_epsilon_closest_rat_loss", ".", "Dist2MeanEpsilonClosestRatLoss", "\n", "", "elif", "loss_type", "==", "'direct'", ":", "\n", "        ", "return", "direct_loss", ".", "DirectLoss", "\n", "", "elif", "loss_type", "==", "'crossentropy'", ":", "\n", "        ", "return", "crossentropy_loss", ".", "CrossEntropyLoss", "\n", "", "elif", "loss_type", "==", "'crossentropy_multi'", ":", "\n", "        ", "return", "crossentropy_multi_loss", ".", "CrossEntropyMultiLoss", "\n", "", "elif", "loss_type", "==", "'dc_pit'", ":", "\n", "        ", "return", "dc_pit_loss", ".", "DcPitLoss", "\n", "", "elif", "loss_type", "==", "'deepclustering_full_crossentropy_multi_reshapelogits_avtime'", ":", "\n", "        ", "return", "deepclustering_full_crossentropy_multi_reshapedlogits_avtime_loss", ".", "DeepclusteringFullCrossEntropyMultiReshapedLogitsAvTimeLoss", "\n", "", "elif", "loss_type", "==", "'deepclusteringnoise'", ":", "\n", "        ", "return", "deepclusteringnoise_loss", ".", "DeepclusteringnoiseLoss", "\n", "", "elif", "loss_type", "==", "'deepattractornetnoisehard'", ":", "\n", "        ", "return", "deepattractornetnoise_hard_loss", ".", "DeepattractornetnoisehardLoss", "\n", "", "elif", "loss_type", "==", "'deepattractornetnoisesoft'", ":", "\n", "        ", "return", "deepattractornetnoise_soft_loss", ".", "DeepattractornetnoisesoftLoss", "\n", "", "elif", "loss_type", "==", "'noisefilter'", ":", "\n", "        ", "return", "noisefilter_loss", ".", "NoisefilterLoss", "\n", "", "elif", "loss_type", "==", "'deepattractornet_noisefilter'", ":", "\n", "        ", "return", "deepattractornet_noisefilter_loss", ".", "DeepattractornetnoisefilterLoss", "\n", "", "elif", "loss_type", "==", "'pit_noise'", ":", "\n", "        ", "return", "pit_noise_loss", ".", "PITNoiseLoss", "\n", "", "elif", "loss_type", "==", "'deepclusteringnoise_rat_as_weight'", ":", "\n", "        ", "return", "deepclusteringnoise_loss", ".", "DeepclusteringnoiseRatAsWeightLoss", "\n", "", "elif", "loss_type", "==", "'deepclusteringnoise_alpha_as_weight'", ":", "\n", "        ", "return", "deepclusteringnoise_loss", ".", "DeepclusteringnoiseAlphaAsWeightLoss", "\n", "", "elif", "loss_type", "==", "'deepclusteringnoise_snr_target'", ":", "\n", "        ", "return", "deepclusteringnoise_loss", ".", "DeepclusteringnoiseSnrTargetLoss", "\n", "", "elif", "loss_type", "==", "'deepclusteringnoise_dconly'", ":", "\n", "        ", "return", "deepclusteringnoise_loss", ".", "DeepclusteringnoiseDConlyLoss", "\n", "", "elif", "loss_type", "==", "'deepclusteringnoise_noiseonly'", ":", "\n", "        ", "return", "deepclusteringnoise_loss", ".", "DeepclusteringnoiseNoiseonlyLoss", "\n", "", "elif", "loss_type", "==", "'deepclustering_diar'", ":", "\n", "        ", "return", "deepclustering_diar_loss", ".", "DeepclusteringDiarLoss", "\n", "", "elif", "loss_type", "==", "'msl'", ":", "\n", "        ", "return", "ms_loss", ".", "MsLoss", "\n", "", "elif", "loss_type", "in", "[", "'dummy_loss'", ",", "'dummy'", "]", ":", "\n", "        ", "return", "dummy_loss", ".", "DummyLoss", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Undefined loss type: %s'", "%", "loss_type", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.crossentropy_loss.CrossEntropyLoss.__call__": [[12, 42], ["tensorflow.squeeze", "nabu.neuralnetworks.components.ops.crossentropy_loss", "tensorflow.reduce_mean"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the crossentropy loss\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x ... x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x ... x ...] tensors containing the logits\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "\n", "if", "'av_anchors_time_flag'", "in", "self", ".", "lossconf", "and", "self", ".", "lossconf", "[", "'av_anchors_time_flag'", "]", "in", "[", "'true'", ",", "'True'", "]", ":", "\n", "\t\t\t", "av_anchors_time_flag", "=", "True", "\n", "", "else", ":", "\n", "\t\t\t", "av_anchors_time_flag", "=", "False", "\n", "\n", "", "spkids", "=", "tf", ".", "squeeze", "(", "targets", "[", "'spkids'", "]", ",", "1", ")", "\n", "logits", "=", "logits", "[", "'spkest'", "]", "\n", "\n", "if", "av_anchors_time_flag", ":", "\n", "\t\t\t", "logits", "=", "tf", ".", "reduce_mean", "(", "logits", ",", "1", ")", "\n", "\n", "", "loss", ",", "norm", "=", "ops", ".", "crossentropy_loss", "(", "spkids", ",", "logits", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.deepclustering_diar_loss.DeepclusteringDiarLoss.__call__": [[11, 36], ["nabu.neuralnetworks.components.ops.deepclustering_diar_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss\n\n        Creates the operation to compute the deep clustering diarization loss\n\n        Args:\n            targets: a dictionary of [batch_size x time x ...] tensor containing\n                the targets\n            logits: a dictionary of [batch_size x time x ...] tensors containing the logits\n            seq_length: a dictionary of [batch_size] vectors containing\n                the sequence lengths\n\n        Returns:\n            loss: a scalar value containing the loss\n            norm: a scalar value indicating how to normalize the loss\n        \"\"\"", "\n", "\n", "vad_target", "=", "targets", "[", "'diar_targets'", "]", "\n", "seq_length", "=", "seq_length", "[", "'features'", "]", "\n", "read_heads", "=", "logits", "[", "'read_heads'", "]", "\n", "\n", "loss", ",", "norm", "=", "ops", ".", "deepclustering_diar_loss", "(", "vad_target", ",", "read_heads", ",", "seq_length", ",", "self", ".", "batch_size", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.AnchorDeepattractornetSoftmaxLoss.__call__": [[13, 47], ["warnings.warn", "nabu.neuralnetworks.components.ops.anchor_deepattractornet_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the deep attractor network with softmax loss, using anchors\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "warnings", ".", "warn", "(", "'In following versions it will be required to use the AnchorDeepattractornetLoss'", ",", "Warning", ")", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "anchors", "=", "logits", "[", "'anchors'", "]", "\n", "# calculate loss and normalisation factor of mini-batch", "\n", "loss", ",", "norm", "=", "ops", ".", "anchor_deepattractornet_loss", "(", "\n", "spectrogram_targets", ",", "mix_to_mask", ",", "emb_vec", ",", "anchors", ",", "seq_length", ",", "self", ".", "batch_size", ",", "activation", "=", "'softmax'", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.AnchorNormDeepattractornetSoftmaxLoss.__call__": [[52, 88], ["warnings.warn", "nabu.neuralnetworks.components.ops.anchor_deepattractornet_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the deep attractor network with softmax loss, using anchors. Embeddings will be\n\t\t normalized.\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "warnings", ".", "warn", "(", "'In following versions it will be required to use the AnchorDeepattractornetLoss'", ",", "Warning", ")", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "anchors", "=", "logits", "[", "'anchors'", "]", "\n", "# calculate loss and normalisation factor of mini-batch", "\n", "loss", ",", "norm", "=", "ops", ".", "anchor_deepattractornet_loss", "(", "\n", "spectrogram_targets", ",", "mix_to_mask", ",", "emb_vec", ",", "anchors", ",", "seq_length", ",", "self", ".", "batch_size", ",", "activation", "=", "'softmax'", ",", "\n", "normalize", "=", "True", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.WeightedAnchorNormDeepattractornetSoftmaxLoss.__call__": [[93, 130], ["warnings.warn", "nabu.neuralnetworks.components.ops.weighted_anchor_deepattractornet_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the deep attractor network with softmax loss, using weighted anchors.\n\t\tEmbeddings will be normalized.\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "warnings", ".", "warn", "(", "'In following versions it will be required to use the AnchorDeepattractornetLoss'", ",", "Warning", ")", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "anchors", "=", "logits", "[", "'anchors'", "]", "\n", "spk_weights", "=", "logits", "[", "'spk_weights'", "]", "\n", "# calculate loss and normalisation factor of mini-batch", "\n", "loss", ",", "norm", "=", "ops", ".", "weighted_anchor_deepattractornet_loss", "(", "\n", "spectrogram_targets", ",", "mix_to_mask", ",", "emb_vec", ",", "anchors", ",", "spk_weights", ",", "seq_length", ",", "self", ".", "batch_size", ",", "activation", "=", "'softmax'", ",", "\n", "normalize", "=", "True", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.TimeAnchorDeepattractornetSoftmaxLoss.__call__": [[135, 169], ["warnings.warn", "nabu.neuralnetworks.components.ops.time_anchor_deepattractornet_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the deep attractor network with softmax loss, using anchors\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "warnings", ".", "warn", "(", "'In following versions it will be required to use the AnchorDeepattractornetLoss'", ",", "Warning", ")", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "anchors", "=", "logits", "[", "'anchors'", "]", "\n", "# calculate loss and normalisation factor of mini-batch", "\n", "loss", ",", "norm", "=", "ops", ".", "time_anchor_deepattractornet_loss", "(", "\n", "spectrogram_targets", ",", "mix_to_mask", ",", "emb_vec", ",", "anchors", ",", "seq_length", ",", "self", ".", "batch_size", ",", "activation", "=", "'softmax'", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.AnchorDeepattractornetLoss.__call__": [[174, 291], ["tensorflow.name_scope", "tensorflow.reshape", "tensorflow.matmul", "tensorflow.expand_dims", "tensorflow.multiply", "tensorflow.transpose", "tensorflow.transpose", "nabu.neuralnetworks.components.ops.base_pit_loss", "spectrogram_targets.get_shape", "tensorflow.tile.get_shape", "tensorflow.shape", "spectrogram_targets.get_shape", "tensorflow.shape", "tensorflow.tile", "tensorflow.expand_dims", "tensorflow.reduce_mean", "tensorflow.tile", "tensorflow.nn.softmax", "float", "tensorflow.reduce_sum", "tensorflow.where", "tensorflow.expand_dims", "tensorflow.to_float", "tensorflow.expand_dims", "tensorflow.reduce_mean", "tensorflow.ones", "tensorflow.reduce_sum", "tensorflow.to_float", "tensorflow.norm", "tensorflow.expand_dims", "tensorflow.norm", "tensorflow.nn.sigmoid", "tensorflow.nn.sigmoid", "tensorflow.ones", "tensorflow.reduce_sum"], "methods", ["home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.softmax", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid", "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.reconstructors.stackedmasks_noise_reconstructor.sigmoid"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the deep attractor network using anchors\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "anchors", "=", "logits", "[", "'anchors'", "]", "\n", "\n", "if", "'speaker_logits'", "in", "logits", ":", "\n", "# Assuming dimensions are B x T x S", "\n", "\t\t\t", "speaker_logits", "=", "logits", "[", "'speaker_logits'", "]", "\n", "av_speaker_logits_time_flag", "=", "self", ".", "lossconf", "[", "'av_speaker_logits_time_flag'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "speaker_logits", "=", "None", "\n", "\n", "", "if", "'anchors_scale'", "in", "logits", ":", "\n", "# Assuming dimensions are B x T x S", "\n", "\t\t\t", "anchors_scale", "=", "logits", "[", "'anchors_scale'", "]", "\n", "anchors_scale", "=", "anchors_scale", "[", "0", ",", "0", "]", "\n", "", "else", ":", "\n", "\t\t\t", "anchors_scale", "=", "None", "\n", "\n", "", "time_anchors_flag", "=", "self", ".", "lossconf", "[", "'time_anchors_flag'", "]", "==", "'True'", "\n", "av_anchors_time_flag", "=", "(", "self", ".", "lossconf", "[", "'av_anchors_time_flag'", "]", "==", "'True'", ")", "and", "time_anchors_flag", "\n", "activation", "=", "self", ".", "lossconf", "[", "'activation'", "]", "\n", "normalize_embs", "=", "self", ".", "lossconf", "[", "'normalize_embs'", "]", "==", "'True'", "\n", "normalize_anchors", "=", "self", ".", "lossconf", "[", "'normalize_anchors'", "]", "==", "'True'", "\n", "if", "'do_square'", "in", "self", ".", "lossconf", ":", "\n", "\t\t\t", "do_square", "=", "self", ".", "lossconf", "[", "'do_square'", "]", "==", "'True'", "\n", "", "else", ":", "\n", "\t\t\t", "do_square", "=", "True", "\n", "\n", "", "with", "tf", ".", "name_scope", "(", "'anchor_deepattractornet_loss'", ")", ":", "\n", "\n", "\t\t\t", "feat_dim", "=", "spectrogram_targets", ".", "get_shape", "(", ")", "[", "2", "]", "\n", "emb_dim", "=", "anchors", ".", "get_shape", "(", ")", "[", "-", "1", "]", "\n", "time_dim", "=", "tf", ".", "shape", "(", "anchors", ")", "[", "1", "]", "\n", "nrS", "=", "spectrogram_targets", ".", "get_shape", "(", ")", "[", "3", "]", "\n", "\n", "V", "=", "tf", ".", "reshape", "(", "emb_vec", ",", "[", "self", ".", "batch_size", ",", "-", "1", ",", "feat_dim", ",", "emb_dim", "]", ",", "name", "=", "'V'", ")", "# dim: (B x T x F x D)", "\n", "if", "normalize_embs", ":", "\n", "\t\t\t\t", "V", "=", "V", "/", "(", "tf", ".", "norm", "(", "V", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "", "time_dim", "=", "tf", ".", "shape", "(", "V", ")", "[", "1", "]", "\n", "\n", "if", "not", "time_anchors_flag", ":", "\n", "\t\t\t\t", "anchors", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "anchors", ",", "0", ")", ",", "0", ")", ",", "[", "self", ".", "batch_size", ",", "time_dim", ",", "1", ",", "1", "]", ")", "# dim: (B x T x S x D)", "\n", "\n", "", "if", "normalize_anchors", ":", "\n", "\t\t\t\t", "anchors", "=", "anchors", "/", "(", "tf", ".", "norm", "(", "anchors", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "+", "1e-12", ")", "\n", "\n", "", "if", "speaker_logits", "is", "not", "None", ":", "\n", "\t\t\t\t", "speaker_logits", "=", "tf", ".", "expand_dims", "(", "speaker_logits", ",", "-", "1", ")", "\n", "if", "av_speaker_logits_time_flag", ":", "\n", "\t\t\t\t\t", "speaker_logits", "=", "tf", ".", "reduce_mean", "(", "speaker_logits", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "", "anchors", "*=", "speaker_logits", "\n", "\n", "", "if", "anchors_scale", "is", "not", "None", ":", "\n", "\t\t\t\t", "anchors", "*=", "anchors_scale", "\n", "\n", "", "if", "av_anchors_time_flag", ":", "\n", "\t\t\t\t", "anchors", "=", "tf", ".", "reduce_mean", "(", "anchors", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "anchors", "=", "tf", ".", "tile", "(", "anchors", ",", "[", "1", ",", "time_dim", ",", "1", ",", "1", "]", ")", "\n", "\n", "", "prod_1", "=", "tf", ".", "matmul", "(", "V", ",", "anchors", ",", "transpose_a", "=", "False", ",", "transpose_b", "=", "True", ",", "name", "=", "'AVT'", ")", "\n", "\n", "if", "activation", "==", "'softmax'", ":", "\n", "\t\t\t\t", "masks", "=", "tf", ".", "nn", ".", "softmax", "(", "prod_1", ",", "axis", "=", "-", "1", ",", "name", "=", "'M'", ")", "# dim: (B x T x F x nrS)", "\n", "", "elif", "activation", "in", "[", "'None'", ",", "'none'", ",", "None", "]", ":", "\n", "\t\t\t\t", "masks", "=", "prod_1", "\n", "", "elif", "activation", "==", "'sigmoid'", ":", "\n", "\t\t\t\t", "masks", "=", "tf", ".", "nn", ".", "sigmoid", "(", "prod_1", ",", "name", "=", "'M'", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "masks", "=", "tf", ".", "nn", ".", "sigmoid", "(", "prod_1", ",", "name", "=", "'M'", ")", "\n", "\n", "", "X", "=", "tf", ".", "expand_dims", "(", "mix_to_mask", ",", "-", "1", ",", "name", "=", "'X'", ")", "# dim: (B x T x F x 1)", "\n", "reconstructions", "=", "tf", ".", "multiply", "(", "masks", ",", "X", ")", "# dim: (B x T x F x nrS)", "\n", "reconstructions", "=", "tf", ".", "transpose", "(", "reconstructions", ",", "perm", "=", "[", "3", ",", "0", ",", "1", ",", "2", "]", ")", "# dim: (nrS x B x T x F)", "\n", "\n", "S", "=", "tf", ".", "transpose", "(", "spectrogram_targets", ",", "[", "3", ",", "0", ",", "1", ",", "2", "]", ")", "# nrS x B x T x F", "\n", "\n", "if", "'vad_targets'", "in", "targets", ":", "\n", "\t\t\t\t", "overlap_weight", "=", "float", "(", "self", ".", "lossconf", "[", "'overlap_weight'", "]", ")", "\n", "vad_sum", "=", "tf", ".", "reduce_sum", "(", "targets", "[", "'vad_targets'", "]", ",", "-", "1", ")", "\n", "bin_weights", "=", "tf", ".", "where", "(", "\n", "vad_sum", ">", "1", ",", "\n", "tf", ".", "ones", "(", "[", "self", ".", "batch_size", ",", "time_dim", "]", ")", "*", "overlap_weight", ",", "\n", "tf", ".", "ones", "(", "[", "self", ".", "batch_size", ",", "time_dim", "]", ")", ")", "\n", "bin_weights", "=", "tf", ".", "expand_dims", "(", "bin_weights", ",", "-", "1", ")", "# broadcast the frame weights to all bins", "\n", "norm", "=", "tf", ".", "reduce_sum", "(", "bin_weights", ")", "*", "tf", ".", "to_float", "(", "feat_dim", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "bin_weights", "=", "None", "\n", "norm", "=", "tf", ".", "to_float", "(", "tf", ".", "reduce_sum", "(", "seq_length", ")", "*", "feat_dim", ")", "\n", "\n", "", "loss", "=", "ops", ".", "base_pit_loss", "(", "reconstructions", ",", "S", ",", "bin_weights", "=", "bin_weights", ",", "overspeakererized", "=", "False", ",", "do_square", "=", "do_square", ")", "\n", "\n", "", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.TimeAnchorNormDeepattractornetSoftmaxLoss.__call__": [[296, 332], ["warnings.warn", "nabu.neuralnetworks.components.ops.time_anchor_deepattractornet_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the deep attractor network with softmax loss, using anchors. Embeddings will be\n\t\t normalized.\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "warnings", ".", "warn", "(", "'In following versions it will be required to use the AnchorDeepattractornetLoss'", ",", "Warning", ")", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "anchors", "=", "logits", "[", "'anchors'", "]", "\n", "# calculate loss and normalisation factor of mini-batch", "\n", "loss", ",", "norm", "=", "ops", ".", "time_anchor_deepattractornet_loss", "(", "\n", "spectrogram_targets", ",", "mix_to_mask", ",", "emb_vec", ",", "anchors", ",", "seq_length", ",", "self", ".", "batch_size", ",", "activation", "=", "'softmax'", ",", "\n", "normalize", "=", "True", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.TimeAnchorReadHeadsNormDeepattractornetSoftmaxLoss.__call__": [[337, 374], ["warnings.warn", "nabu.neuralnetworks.components.ops.time_anchor_read_heads_deepattractornet_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the deep attractor network with softmax loss, using anchors. Embeddings will be\n\t\t normalized. Use read heads for assignments.\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "warnings", ".", "warn", "(", "'In following versions it will be required to use the AnchorDeepattractornetLoss'", ",", "Warning", ")", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "anchors", "=", "logits", "[", "'anchors'", "]", "\n", "read_heads", "=", "logits", "[", "'read_heads'", "]", "\n", "# calculate loss and normalisation factor of mini-batch", "\n", "loss", ",", "norm", "=", "ops", ".", "time_anchor_read_heads_deepattractornet_loss", "(", "\n", "spectrogram_targets", ",", "mix_to_mask", ",", "emb_vec", ",", "anchors", ",", "read_heads", ",", "seq_length", ",", "self", ".", "batch_size", ",", "\n", "activation", "=", "'softmax'", ",", "normalize", "=", "True", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.JeroenZegers_Nabu-MSSS.loss_computers.anchor_deepattractornet_softmax_loss.TimeAnchorReadHeadsNormDeepattractornetSoftmaxFramebasedLoss.__call__": [[379, 416], ["warnings.warn", "nabu.neuralnetworks.components.ops.time_anchor_read_heads_deepattractornet_loss"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "targets", ",", "logits", ",", "seq_length", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tCompute the loss\n\n\t\tCreates the operation to compute the deep attractor network with softmax loss, using anchors. Embeddings will be\n\t\t normalized. Use read heads for assignments.\n\n\t\tArgs:\n\t\t\ttargets: a dictionary of [batch_size x time x ...] tensor containing\n\t\t\t\tthe targets\n\t\t\tlogits: a dictionary of [batch_size x time x ...] tensors containing the logits\n\t\t\tseq_length: a dictionary of [batch_size] vectors containing\n\t\t\t\tthe sequence lengths\n\n\t\tReturns:\n\t\t\tloss: a scalar value containing the loss\n\t\t\tnorm: a scalar value indicating how to normalize the loss\n\t\t\"\"\"", "\n", "warnings", ".", "warn", "(", "'In following versions it will be required to use the AnchorDeepattractornetLoss'", ",", "Warning", ")", "\n", "# Clean spectograms of sources", "\n", "spectrogram_targets", "=", "targets", "[", "'multi_targets'", "]", "\n", "\n", "# Spectogram of the original mixture, used to mask for scoring", "\n", "mix_to_mask", "=", "targets", "[", "'mix_to_mask'", "]", "\n", "\n", "# Length of sequences", "\n", "seq_length", "=", "seq_length", "[", "'bin_emb'", "]", "\n", "# Logits (=output network)", "\n", "emb_vec", "=", "logits", "[", "'bin_emb'", "]", "\n", "anchors", "=", "logits", "[", "'anchors'", "]", "\n", "read_heads", "=", "logits", "[", "'read_heads'", "]", "\n", "# calculate loss and normalisation factor of mini-batch", "\n", "loss", ",", "norm", "=", "ops", ".", "time_anchor_read_heads_deepattractornet_loss", "(", "\n", "spectrogram_targets", ",", "mix_to_mask", ",", "emb_vec", ",", "anchors", ",", "read_heads", ",", "seq_length", ",", "self", ".", "batch_size", ",", "\n", "activation", "=", "'softmax'", ",", "normalize", "=", "True", ",", "frame_based", "=", "True", ")", "\n", "\n", "return", "loss", ",", "norm", "\n", "", "", ""]]}