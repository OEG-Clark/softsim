{"home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.__init__": [[363, 436], ["_dynet.ParameterCollection", "int", "trainer_algo", "trainer_algo", "load_model", "lib.mio.load_dict", "print", "print", "len", "len"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.load_dict"], ["def", "__init__", "(", "self", ",", "in_dim", ",", "h_dim", ",", "c_in_dim", ",", "c_h_dim", ",", "h_layers", ",", "pred_layer", ",", "learning_algo", "=", "\"sgd\"", ",", "learning_rate", "=", "0", ",", "\n", "embeds_file", "=", "None", ",", "embeds_in_file", "=", "False", ",", "embeds_in_file_dim", "=", "0", ",", "activation", "=", "ACTIVATION_MAP", "[", "\"tanh\"", "]", ",", "mlp", "=", "0", ",", "\n", "activation_mlp", "=", "ACTIVATION_MAP", "[", "\"rectify\"", "]", ",", "backprob_embeds", "=", "True", ",", "noise_sigma", "=", "0.1", ",", "\n", "w_dropout_rate", "=", "0.25", ",", "c_dropout_rate", "=", "0.25", ",", "initializer", "=", "INITIALIZER_MAP", "[", "\"glorot\"", "]", ",", "\n", "builder", "=", "BUILDERS", "[", "\"lstmc\"", "]", ",", "crf", "=", "False", ",", "viterbi_loss", "=", "False", ",", "\n", "mimickx_model_path", "=", "None", ",", "dictionary", "=", "None", ",", "type_constraint", "=", "False", ",", "\n", "lex_dim", "=", "0", ",", "embed_lex", "=", "False", ")", ":", "\n", "        ", "self", ".", "w2i", "=", "{", "}", "# word to index mapping", "\n", "self", ".", "c2i", "=", "{", "}", "# char to index mapping", "\n", "self", ".", "w2c_cache", "=", "{", "}", "# word to char index cache for frequent words", "\n", "self", ".", "wcount", "=", "None", "# word count", "\n", "self", ".", "ccount", "=", "None", "# char count", "\n", "self", ".", "task2tag2idx", "=", "{", "}", "# need one dictionary per task", "\n", "self", ".", "pred_layer", "=", "[", "int", "(", "layer", ")", "for", "layer", "in", "pred_layer", "]", "# at which layer to predict each task", "\n", "self", ".", "model", "=", "dynet", ".", "ParameterCollection", "(", ")", "#init model", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "h_dim", "=", "h_dim", "\n", "self", ".", "c_in_dim", "=", "c_in_dim", "\n", "self", ".", "c_h_dim", "=", "c_h_dim", "\n", "self", ".", "w_dropout_rate", "=", "w_dropout_rate", "\n", "self", ".", "c_dropout_rate", "=", "c_dropout_rate", "\n", "self", ".", "activation", "=", "activation", "\n", "self", ".", "mlp", "=", "mlp", "\n", "self", ".", "activation_mlp", "=", "activation_mlp", "\n", "self", ".", "noise_sigma", "=", "noise_sigma", "\n", "self", ".", "h_layers", "=", "h_layers", "\n", "self", ".", "predictors", "=", "{", "\"inner\"", ":", "[", "]", ",", "\"output_layers_dict\"", ":", "{", "}", ",", "\"task_expected_at\"", ":", "{", "}", "}", "# the inner layers and predictors", "\n", "self", ".", "wembeds", "=", "None", "# lookup: embeddings for words", "\n", "self", ".", "cembeds", "=", "None", "# lookup: embeddings for characters", "\n", "self", ".", "lembeds", "=", "None", "# lookup: embeddings for lexical features (optional)", "\n", "self", ".", "embeds_file", "=", "embeds_file", "\n", "self", ".", "embeds_in_file", "=", "embeds_in_file", "\n", "self", ".", "embeds_in_file_dim", "=", "embeds_in_file_dim", "\n", "trainer_algo", "=", "TRAINER_MAP", "[", "learning_algo", "]", "\n", "if", "learning_rate", ">", "0", ":", "\n", "### TODO: better handling of additional learning-specific parameters", "\n", "            ", "self", ".", "trainer", "=", "trainer_algo", "(", "self", ".", "model", ",", "learning_rate", "=", "learning_rate", ")", "\n", "", "else", ":", "\n", "# using default learning rate", "\n", "            ", "self", ".", "trainer", "=", "trainer_algo", "(", "self", ".", "model", ")", "\n", "", "self", ".", "backprob_embeds", "=", "backprob_embeds", "\n", "self", ".", "initializer", "=", "initializer", "\n", "self", ".", "char_rnn", "=", "None", "# biRNN for character input", "\n", "self", ".", "builder", "=", "builder", "# default biRNN is an LSTM", "\n", "self", ".", "crf", "=", "crf", "\n", "self", ".", "viterbi_loss", "=", "viterbi_loss", "\n", "self", ".", "mimickx_model_path", "=", "mimickx_model_path", "\n", "if", "mimickx_model_path", ":", "# load", "\n", "            ", "self", ".", "mimickx_model", "=", "load_model", "(", "mimickx_model_path", ")", "\n", "", "self", ".", "dictionary", "=", "None", "\n", "self", ".", "type_constraint", "=", "type_constraint", "\n", "self", ".", "embed_lex", "=", "False", "\n", "self", ".", "l2i", "=", "{", "UNK", ":", "0", "}", "# lex feature to index mapping", "\n", "if", "dictionary", ":", "\n", "            ", "self", ".", "dictionary", ",", "self", ".", "dictionary_values", "=", "load_dict", "(", "dictionary", ")", "\n", "self", ".", "path_to_dictionary", "=", "dictionary", "\n", "if", "type_constraint", ":", "\n", "                ", "self", ".", "lex_dim", "=", "0", "\n", "", "else", ":", "\n", "                ", "if", "embed_lex", ":", "\n", "                    ", "self", ".", "lex_dim", "=", "lex_dim", "\n", "self", ".", "embed_lex", "=", "True", "\n", "print", "(", "\"Embed lexical features\"", ")", "\n", "# register property indices", "\n", "for", "prop", "in", "self", ".", "dictionary_values", ":", "\n", "                        ", "self", ".", "l2i", "[", "prop", "]", "=", "len", "(", "self", ".", "l2i", ")", "\n", "", "", "else", ":", "\n", "                    ", "self", ".", "lex_dim", "=", "len", "(", "self", ".", "dictionary_values", ")", "#n-hot encoding", "\n", "", "print", "(", "\"Lex_dim: {}\"", ".", "format", "(", "self", ".", "lex_dim", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "dictionary", "=", "None", "\n", "self", ".", "path_to_dictionary", "=", "None", "\n", "self", ".", "lex_dim", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.fit": [[437, 546], ["print", "structbilty.NNTagger.init_parameters", "print", "structbilty.NNTagger.build_computation_graph", "print", "range", "print", "structbilty.NNTagger.trainer.set_clip_threshold", "len", "len", "print", "print", "random.shuffle", "collections.defaultdict", "collections.defaultdict", "print", "sorted", "len", "losses_log[].append", "dill.dump", "structbilty.NNTagger.evaluate", "print", "range", "structbilty.NNTagger.predict", "len", "batch.append", "_dynet.renew_cg", "structbilty.NNTagger.predict", "len", "structbilty.NNTagger.value", "len", "structbilty.NNTagger.value", "structbilty.NNTagger.backward", "structbilty.NNTagger.trainer.update", "open", "print", "structbilty.save", "print", "len", "len", "_dynet.esum", "_dynet.esum.value", "len", "_dynet.esum.value", "_dynet.esum.backward", "structbilty.NNTagger.trainer.update", "_dynet.renew_cg", "print"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.init_parameters", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.build_computation_graph", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.Seq.evaluate", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.predict", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.predict", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.save"], ["", "", "def", "fit", "(", "self", ",", "train", ",", "num_iterations", ",", "dev", "=", "None", ",", "model_path", "=", "None", ",", "patience", "=", "0", ",", "minibatch_size", "=", "0", ",", "log_losses", "=", "False", ",", "clip_threshold", "=", "0", ",", "embeds_in_file", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        train the tagger\n        \"\"\"", "\n", "losses_log", "=", "{", "}", "# log losses", "\n", "\n", "print", "(", "\"init parameters\"", ")", "\n", "self", ".", "init_parameters", "(", "train", ")", "\n", "if", "clip_threshold", ">", "0", ":", "\n", "            ", "print", "(", "\"set clip threshold\"", ")", "\n", "self", ".", "trainer", ".", "set_clip_threshold", "(", "clip_threshold", ")", "\n", "\n", "# init lookup parameters and define graph", "\n", "", "print", "(", "\"build graph\"", ")", "\n", "self", ".", "build_computation_graph", "(", "len", "(", "self", ".", "w2i", ")", ",", "len", "(", "self", ".", "c2i", ")", ")", "\n", "\n", "update_embeds", "=", "True", "\n", "if", "self", ".", "backprob_embeds", "==", "False", ":", "## disable backprob into embeds", "\n", "            ", "print", "(", "\">>> disable wembeds update <<<\"", ")", "\n", "update_embeds", "=", "False", "\n", "\n", "", "best_val_acc", ",", "epochs_no_improvement", "=", "0.0", ",", "0", "\n", "\n", "if", "dev", "and", "model_path", "is", "not", "None", "and", "patience", ">", "0", ":", "\n", "            ", "print", "(", "'Using early stopping with patience of {}...'", ".", "format", "(", "patience", ")", ")", "\n", "\n", "", "if", "embeds_in_file", ":", "\n", "## make sure embeds_in_file match argument", "\n", "            ", "assert", "(", "len", "(", "train", ".", "seqs", "[", "0", "]", ".", "embeds", "[", "0", "]", ")", "==", "self", ".", "embeds_in_file_dim", ")", "\n", "\n", "", "batch", "=", "[", "]", "\n", "print", "(", "\"train..\"", ")", "\n", "for", "iteration", "in", "range", "(", "num_iterations", ")", ":", "\n", "\n", "            ", "total_loss", "=", "0.0", "\n", "total_tagged", "=", "0.0", "\n", "\n", "indices", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "train", ".", "seqs", ")", ")", "]", "\n", "random", ".", "shuffle", "(", "indices", ")", "\n", "\n", "loss_accum_loss", "=", "defaultdict", "(", "float", ")", "\n", "loss_accum_tagged", "=", "defaultdict", "(", "float", ")", "\n", "\n", "for", "idx", "in", "indices", ":", "\n", "                ", "seq", "=", "train", ".", "seqs", "[", "idx", "]", "\n", "#assert(len(seq.words)==len(seq.embeds))", "\n", "if", "seq", ".", "task_id", "not", "in", "losses_log", ":", "\n", "                    ", "losses_log", "[", "seq", ".", "task_id", "]", "=", "[", "]", "#initialize", "\n", "\n", "", "if", "minibatch_size", ">", "1", ":", "\n", "# accumulate instances for minibatch update", "\n", "                    ", "loss1", "=", "self", ".", "predict", "(", "seq", ",", "train", "=", "True", ",", "update_embeds", "=", "update_embeds", ",", "embeds_in_file", "=", "embeds_in_file", ")", "\n", "total_tagged", "+=", "len", "(", "seq", ".", "words", ")", "\n", "batch", ".", "append", "(", "loss1", ")", "\n", "if", "len", "(", "batch", ")", "==", "minibatch_size", ":", "\n", "                        ", "loss", "=", "dynet", ".", "esum", "(", "batch", ")", "\n", "total_loss", "+=", "loss", ".", "value", "(", ")", "\n", "\n", "# logging", "\n", "loss_accum_tagged", "[", "seq", ".", "task_id", "]", "+=", "len", "(", "seq", ".", "words", ")", "\n", "loss_accum_loss", "[", "seq", ".", "task_id", "]", "+=", "loss", ".", "value", "(", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "trainer", ".", "update", "(", ")", "\n", "dynet", ".", "renew_cg", "(", ")", "# use new computational graph for each BATCH when batching is active", "\n", "batch", "=", "[", "]", "\n", "", "", "else", ":", "\n", "                    ", "dynet", ".", "renew_cg", "(", ")", "# new graph per item", "\n", "loss1", "=", "self", ".", "predict", "(", "seq", ",", "train", "=", "True", ",", "update_embeds", "=", "update_embeds", ",", "embeds_in_file", "=", "embeds_in_file", ")", "\n", "total_tagged", "+=", "len", "(", "seq", ".", "words", ")", "\n", "lv", "=", "loss1", ".", "value", "(", ")", "\n", "total_loss", "+=", "lv", "\n", "\n", "# logging", "\n", "loss_accum_tagged", "[", "seq", ".", "task_id", "]", "+=", "len", "(", "seq", ".", "words", ")", "\n", "loss_accum_loss", "[", "seq", ".", "task_id", "]", "+=", "loss1", ".", "value", "(", ")", "\n", "\n", "loss1", ".", "backward", "(", ")", "\n", "self", ".", "trainer", ".", "update", "(", ")", "\n", "\n", "", "", "print", "(", "\"iter {2} {0:>12}: {1:.2f}\"", ".", "format", "(", "\"total loss\"", ",", "total_loss", "/", "total_tagged", ",", "iteration", ")", ")", "\n", "\n", "# log losses", "\n", "for", "task_id", "in", "sorted", "(", "losses_log", ")", ":", "\n", "                ", "losses_log", "[", "task_id", "]", ".", "append", "(", "loss_accum_loss", "[", "task_id", "]", "/", "loss_accum_tagged", "[", "task_id", "]", ")", "\n", "\n", "", "if", "log_losses", ":", "\n", "                ", "dill", ".", "dump", "(", "losses_log", ",", "open", "(", "model_path", "+", "\".model\"", "+", "\".losses.pickle\"", ",", "\"wb\"", ")", ")", "\n", "\n", "", "if", "dev", ":", "\n", "# evaluate after every epoch", "\n", "                ", "correct", ",", "total", "=", "self", ".", "evaluate", "(", "dev", ",", "\"task0\"", ",", "embeds_in_file", "=", "embeds_in_file", ")", "\n", "val_accuracy", "=", "correct", "/", "total", "\n", "print", "(", "\"dev accuracy: {0:.4f}\"", ".", "format", "(", "val_accuracy", ")", ")", "\n", "\n", "if", "val_accuracy", ">", "best_val_acc", ":", "\n", "                    ", "print", "(", "'Accuracy {0:.4f} is better than best val accuracy '", "\n", "'{1:.4f}.'", ".", "format", "(", "val_accuracy", ",", "best_val_acc", ")", ")", "\n", "best_val_acc", "=", "val_accuracy", "\n", "epochs_no_improvement", "=", "0", "\n", "save", "(", "self", ",", "model_path", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "'Accuracy {0:.4f} is worse than best val loss {1:.4f}.'", ".", "format", "(", "val_accuracy", ",", "best_val_acc", ")", ")", "\n", "epochs_no_improvement", "+=", "1", "\n", "\n", "", "if", "patience", ">", "0", ":", "\n", "                    ", "if", "epochs_no_improvement", "==", "patience", ":", "\n", "                        ", "print", "(", "'No improvement for {} epochs. Early stopping...'", ".", "format", "(", "epochs_no_improvement", ")", ")", "\n", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.set_indices": [[547, 555], ["None"], "methods", ["None"], ["", "", "", "", "", "def", "set_indices", "(", "self", ",", "w2i", ",", "c2i", ",", "task2t2i", ",", "w2c_cache", ",", "l2i", "=", "None", ")", ":", "\n", "        ", "\"\"\" helper function for loading model\"\"\"", "\n", "for", "task_id", "in", "task2t2i", ":", "\n", "            ", "self", ".", "task2tag2idx", "[", "task_id", "]", "=", "task2t2i", "[", "task_id", "]", "\n", "", "self", ".", "w2i", "=", "w2i", "\n", "self", ".", "c2i", "=", "c2i", "\n", "self", ".", "w2c_cache", "=", "w2c_cache", "\n", "self", ".", "l2i", "=", "l2i", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.set_counts": [[556, 562], ["None"], "methods", ["None"], ["", "def", "set_counts", "(", "self", ",", "wcount", ",", "wtotal", ",", "ccount", ",", "ctotal", ")", ":", "\n", "        ", "\"\"\" helper function for loading model\"\"\"", "\n", "self", ".", "wcount", "=", "wcount", "\n", "self", ".", "wtotal", "=", "wtotal", "\n", "self", ".", "ccount", "=", "ccount", "\n", "self", ".", "ctotal", "=", "ctotal", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.build_computation_graph": [[563, 660], ["range", "lib.mnnl.BiRNNSequencePredictor", "print", "lib.mio.load_embeddings_file", "len", "structbilty.NNTagger.model.add_lookup_parameters", "embeddings.keys", "print", "structbilty.NNTagger.model.add_lookup_parameters", "structbilty.NNTagger.model.add_lookup_parameters", "structbilty.NNTagger.model.add_lookup_parameters", "len", "print", "len", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder", "set().union", "layers.append", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder", "layers.append", "zip", "lib.mnnl.FFSequencePredictor", "print", "lib.mnnl.CRFSequencePredictor", "set", "len", "structbilty.NNTagger.wembeds.init_row", "_dynet.GlorotInitializer", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder", "lib.mnnl.BiRNNSequencePredictor", "lib.mnnl.BiRNNSequencePredictor", "lib.mnnl.Layer", "lib.mnnl.Layer", "set", "structbilty.NNTagger.w2i.keys", "structbilty.NNTagger.w2i.keys", "structbilty.NNTagger.wembeds.init_row", "len", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder", "embeddings.keys", "len", "structbilty.NNTagger.builder", "structbilty.NNTagger.builder"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.load_embeddings_file"], ["", "def", "build_computation_graph", "(", "self", ",", "num_words", ",", "num_chars", ")", ":", "\n", "        ", "\"\"\"\n        build graph and link to parameters\n        self.predictors, self.char_rnn, self.wembeds, self.cembeds =\n        \"\"\"", "\n", "## initialize word embeddings", "\n", "if", "self", ".", "embeds_file", ":", "\n", "            ", "print", "(", "\"loading embeddings\"", ")", "\n", "embeddings", ",", "emb_dim", "=", "load_embeddings_file", "(", "self", ".", "embeds_file", ")", "\n", "assert", "(", "emb_dim", "==", "self", ".", "in_dim", ")", "\n", "num_words", "=", "len", "(", "set", "(", "embeddings", ".", "keys", "(", ")", ")", ".", "union", "(", "set", "(", "self", ".", "w2i", ".", "keys", "(", ")", ")", ")", ")", "# initialize all with embeddings", "\n", "# init model parameters and initialize them", "\n", "self", ".", "wembeds", "=", "self", ".", "model", ".", "add_lookup_parameters", "(", "(", "num_words", ",", "self", ".", "in_dim", ")", ",", "init", "=", "self", ".", "initializer", ")", "\n", "\n", "init", "=", "0", "\n", "for", "word", "in", "embeddings", ".", "keys", "(", ")", ":", "\n", "                ", "if", "word", "not", "in", "self", ".", "w2i", ":", "\n", "                    ", "self", ".", "w2i", "[", "word", "]", "=", "len", "(", "self", ".", "w2i", ".", "keys", "(", ")", ")", "# add new word", "\n", "self", ".", "wembeds", ".", "init_row", "(", "self", ".", "w2i", "[", "word", "]", ",", "embeddings", "[", "word", "]", ")", "\n", "init", "+=", "1", "\n", "", "elif", "word", "in", "embeddings", ":", "\n", "                    ", "self", ".", "wembeds", ".", "init_row", "(", "self", ".", "w2i", "[", "word", "]", ",", "embeddings", "[", "word", "]", ")", "\n", "init", "+=", "1", "\n", "", "", "print", "(", "\"initialized: {}\"", ".", "format", "(", "init", ")", ")", "\n", "del", "embeddings", "# clean up", "\n", "", "else", ":", "\n", "            ", "self", ".", "wembeds", "=", "self", ".", "model", ".", "add_lookup_parameters", "(", "(", "num_words", ",", "self", ".", "in_dim", ")", ",", "init", "=", "self", ".", "initializer", ")", "\n", "\n", "## initialize character embeddings", "\n", "", "self", ".", "cembeds", "=", "None", "\n", "if", "self", ".", "c_in_dim", ">", "0", ":", "\n", "            ", "self", ".", "cembeds", "=", "self", ".", "model", ".", "add_lookup_parameters", "(", "(", "num_chars", ",", "self", ".", "c_in_dim", ")", ",", "init", "=", "self", ".", "initializer", ")", "\n", "", "if", "self", ".", "lex_dim", ">", "0", "and", "self", ".", "embed_lex", ":", "\n", "# +1 for UNK property", "\n", "            ", "self", ".", "lembeds", "=", "self", ".", "model", ".", "add_lookup_parameters", "(", "(", "len", "(", "self", ".", "dictionary_values", ")", "+", "1", ",", "self", ".", "lex_dim", ")", ",", "init", "=", "dynet", ".", "GlorotInitializer", "(", ")", ")", "#init=self.initializer)", "\n", "\n", "# make it more flexible to add number of layers as specified by parameter", "\n", "", "layers", "=", "[", "]", "# inner layers", "\n", "output_layers_dict", "=", "{", "}", "# from task_id to actual softmax predictor", "\n", "for", "layer_num", "in", "range", "(", "0", ",", "self", ".", "h_layers", ")", ":", "\n", "            ", "if", "layer_num", "==", "0", ":", "\n", "                ", "if", "self", ".", "c_in_dim", ">", "0", ":", "\n", "# in_dim: size of each layer", "\n", "                    ", "if", "self", ".", "lex_dim", ">", "0", "and", "self", ".", "embed_lex", ":", "\n", "                        ", "lex_embed_size", "=", "self", ".", "lex_dim", "*", "len", "(", "self", ".", "dictionary_values", ")", "\n", "f_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "in_dim", "+", "self", ".", "c_h_dim", "*", "2", "+", "lex_embed_size", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "b_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "in_dim", "+", "self", ".", "c_h_dim", "*", "2", "+", "lex_embed_size", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "", "else", ":", "\n", "                        ", "f_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "in_dim", "+", "self", ".", "c_h_dim", "*", "2", "+", "self", ".", "lex_dim", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "b_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "in_dim", "+", "self", ".", "c_h_dim", "*", "2", "+", "self", ".", "lex_dim", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "if", "self", ".", "embeds_in_file_dim", ">", "0", ":", "\n", "# overwrite and append embeds in file", "\n", "                            ", "f_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "in_dim", "+", "self", ".", "c_h_dim", "*", "2", "+", "self", ".", "lex_dim", "+", "self", ".", "embeds_in_file_dim", ",", "self", ".", "h_dim", ",", "\n", "self", ".", "model", ")", "\n", "b_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "in_dim", "+", "self", ".", "c_h_dim", "*", "2", "+", "self", ".", "lex_dim", "+", "self", ".", "embeds_in_file_dim", ",", "self", ".", "h_dim", ",", "\n", "self", ".", "model", ")", "\n", "", "", "", "else", ":", "\n", "                    ", "f_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "in_dim", "+", "self", ".", "lex_dim", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "b_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "in_dim", "+", "self", ".", "lex_dim", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "if", "self", ".", "embeds_in_file_dim", ">", "0", ":", "\n", "# overwrite and append embeds in file", "\n", "                        ", "f_builder", "=", "self", ".", "builder", "(", "1", ",", "\n", "self", ".", "in_dim", "+", "self", ".", "lex_dim", "+", "self", ".", "embeds_in_file_dim", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "b_builder", "=", "self", ".", "builder", "(", "1", ",", "\n", "self", ".", "in_dim", "+", "self", ".", "lex_dim", "+", "self", ".", "embeds_in_file_dim", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "\n", "", "", "layers", ".", "append", "(", "BiRNNSequencePredictor", "(", "f_builder", ",", "b_builder", ")", ")", "#returns forward and backward sequence", "\n", "", "else", ":", "\n", "# add inner layers (if h_layers >1)", "\n", "                ", "f_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "h_dim", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "b_builder", "=", "self", ".", "builder", "(", "1", ",", "self", ".", "h_dim", ",", "self", ".", "h_dim", ",", "self", ".", "model", ")", "\n", "layers", ".", "append", "(", "BiRNNSequencePredictor", "(", "f_builder", ",", "b_builder", ")", ")", "\n", "\n", "# store at which layer to predict task", "\n", "", "", "task2layer", "=", "{", "task_id", ":", "out_layer", "for", "task_id", ",", "out_layer", "in", "zip", "(", "self", ".", "task2tag2idx", ",", "self", ".", "pred_layer", ")", "}", "\n", "if", "len", "(", "task2layer", ")", ">", "1", ":", "\n", "            ", "print", "(", "\"task2layer\"", ",", "task2layer", ")", "\n", "", "for", "task_id", "in", "task2layer", ":", "\n", "            ", "task_num_labels", "=", "len", "(", "self", ".", "task2tag2idx", "[", "task_id", "]", ")", "\n", "if", "not", "self", ".", "crf", ":", "\n", "                ", "output_layers_dict", "[", "task_id", "]", "=", "FFSequencePredictor", "(", "self", ".", "task2tag2idx", "[", "task_id", "]", ",", "Layer", "(", "self", ".", "model", ",", "self", ".", "h_dim", "*", "2", ",", "task_num_labels", ",", "\n", "dynet", ".", "softmax", ",", "mlp", "=", "self", ".", "mlp", ",", "mlp_activation", "=", "self", ".", "activation_mlp", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"CRF\"", ")", "\n", "output_layers_dict", "[", "task_id", "]", "=", "CRFSequencePredictor", "(", "self", ".", "model", ",", "task_num_labels", ",", "\n", "self", ".", "task2tag2idx", "[", "task_id", "]", ",", "\n", "Layer", "(", "self", ".", "model", ",", "self", ".", "h_dim", "*", "2", ",", "task_num_labels", ",", "\n", "None", ",", "mlp", "=", "self", ".", "mlp", ",", "\n", "mlp_activation", "=", "self", ".", "activation_mlp", ")", ",", "viterbi_loss", "=", "self", ".", "viterbi_loss", ")", "\n", "\n", "", "", "self", ".", "char_rnn", "=", "BiRNNSequencePredictor", "(", "self", ".", "builder", "(", "1", ",", "self", ".", "c_in_dim", ",", "self", ".", "c_h_dim", ",", "self", ".", "model", ")", ",", "\n", "self", ".", "builder", "(", "1", ",", "self", ".", "c_in_dim", ",", "self", ".", "c_h_dim", ",", "self", ".", "model", ")", ")", "\n", "\n", "self", ".", "predictors", "=", "{", "}", "\n", "self", ".", "predictors", "[", "\"inner\"", "]", "=", "layers", "\n", "self", ".", "predictors", "[", "\"output_layers_dict\"", "]", "=", "output_layers_dict", "\n", "self", ".", "predictors", "[", "\"task_expected_at\"", "]", "=", "task2layer", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_features": [[662, 690], ["numpy.array", "numpy.array", "structbilty.NNTagger.get_w_repr", "structbilty.NNTagger.get_c_repr", "_dynet.concatenate", "_dynet.concatenate", "_dynet.concatenate", "_dynet.noise", "zip", "structbilty.NNTagger.get_lex_repr", "zip", "zip", "_dynet.inputTensor", "_dynet.inputVector"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_w_repr", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_c_repr", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_lex_repr"], ["", "def", "get_features", "(", "self", ",", "seqs", ",", "train", "=", "False", ",", "update", "=", "True", ",", "embeds_in_file", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        get feature representations\n        \"\"\"", "\n", "# word embeddings", "\n", "words", "=", "seqs", ".", "words", "\n", "features", "=", "np", ".", "array", "(", "\n", "[", "self", ".", "get_w_repr", "(", "word", ",", "train", "=", "train", ",", "update", "=", "update", ")", "for", "word", "in", "words", "]", ")", "\n", "\n", "# char embeddings", "\n", "if", "self", ".", "c_in_dim", ">", "0", ":", "\n", "            ", "cfeatures", "=", "[", "self", ".", "get_c_repr", "(", "word", ",", "train", "=", "train", ")", "for", "word", "in", "words", "]", "\n", "features", "=", "[", "dynet", ".", "concatenate", "(", "[", "w", ",", "c", "]", ")", "for", "w", ",", "c", "in", "zip", "(", "features", ",", "cfeatures", ")", "]", "\n", "\n", "# DsDs features", "\n", "", "if", "self", ".", "dictionary", "and", "not", "self", ".", "type_constraint", ":", "\n", "## add lexicon features", "\n", "            ", "lex_features", "=", "np", ".", "array", "(", "[", "self", ".", "get_lex_repr", "(", "word", ")", "for", "word", "in", "words", "]", ")", "\n", "features", "=", "[", "dynet", ".", "concatenate", "(", "[", "f", ",", "l", "]", ")", "for", "f", ",", "l", "in", "zip", "(", "features", ",", "dynet", ".", "inputTensor", "(", "lex_features", ")", ")", "]", "\n", "\n", "# embeddings (contextualized) from --embeds_in_file", "\n", "", "if", "embeds_in_file", ":", "\n", "            ", "features", "=", "[", "dynet", ".", "concatenate", "(", "[", "f", ",", "dynet", ".", "inputVector", "(", "ce", ")", "]", ")", "\n", "for", "f", ",", "ce", "in", "zip", "(", "features", ",", "seqs", ".", "embeds", ")", "]", "\n", "\n", "", "if", "train", ":", "# only do at training time", "\n", "            ", "features", "=", "[", "dynet", ".", "noise", "(", "fe", ",", "self", ".", "noise_sigma", ")", "for", "fe", "in", "features", "]", "\n", "", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.predict": [[691, 736], ["structbilty.NNTagger.get_features", "range", "_dynet.renew_cg", "predictor.predict_sequence", "output_predictor.predict_sequence", "structbilty.NNTagger.activation", "structbilty.NNTagger.activation", "_dynet.concatenate", "zip", "_dynet.noise", "reversed"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_features", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.BiRNNSequencePredictor.predict_sequence", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.BiRNNSequencePredictor.predict_sequence"], ["", "def", "predict", "(", "self", ",", "seq", ",", "train", "=", "False", ",", "output_confidences", "=", "False", ",", "unk_tag", "=", "None", ",", "update_embeds", "=", "True", ",", "embeds_in_file", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        predict tags for a sentence represented as char+word embeddings and compute losses for this instance\n        \"\"\"", "\n", "if", "not", "train", ":", "\n", "            ", "dynet", ".", "renew_cg", "(", ")", "\n", "", "features", "=", "self", ".", "get_features", "(", "seq", ",", "train", "=", "train", ",", "update", "=", "update_embeds", ",", "embeds_in_file", "=", "embeds_in_file", ")", "\n", "\n", "output_expected_at_layer", "=", "self", ".", "predictors", "[", "\"task_expected_at\"", "]", "[", "seq", ".", "task_id", "]", "\n", "output_expected_at_layer", "-=", "1", "\n", "\n", "# go through layers", "\n", "# input is now combination of w + char emb", "\n", "prev", "=", "features", "\n", "prev_rev", "=", "features", "\n", "num_layers", "=", "self", ".", "h_layers", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "num_layers", ")", ":", "\n", "            ", "predictor", "=", "self", ".", "predictors", "[", "\"inner\"", "]", "[", "i", "]", "\n", "forward_sequence", ",", "backward_sequence", "=", "predictor", ".", "predict_sequence", "(", "prev", ",", "prev_rev", ")", "\n", "if", "i", ">", "0", "and", "self", ".", "activation", ":", "\n", "# activation between LSTM layers", "\n", "                ", "forward_sequence", "=", "[", "self", ".", "activation", "(", "s", ")", "for", "s", "in", "forward_sequence", "]", "\n", "backward_sequence", "=", "[", "self", ".", "activation", "(", "s", ")", "for", "s", "in", "backward_sequence", "]", "\n", "\n", "", "if", "i", "==", "output_expected_at_layer", ":", "\n", "                ", "output_predictor", "=", "self", ".", "predictors", "[", "\"output_layers_dict\"", "]", "[", "seq", ".", "task_id", "]", "\n", "concat_layer", "=", "[", "dynet", ".", "concatenate", "(", "[", "f", ",", "b", "]", ")", "for", "f", ",", "b", "in", "zip", "(", "forward_sequence", ",", "reversed", "(", "backward_sequence", ")", ")", "]", "\n", "\n", "if", "train", "and", "self", ".", "noise_sigma", ">", "0.0", ":", "\n", "                    ", "concat_layer", "=", "[", "dynet", ".", "noise", "(", "fe", ",", "self", ".", "noise_sigma", ")", "for", "fe", "in", "concat_layer", "]", "\n", "# fill-in predictions and get loss per tag", "\n", "", "losses", "=", "output_predictor", ".", "predict_sequence", "(", "seq", ",", "concat_layer", ",", "\n", "train", "=", "train", ",", "output_confidences", "=", "output_confidences", ",", "\n", "unk_tag", "=", "unk_tag", ",", "dictionary", "=", "self", ".", "dictionary", ",", "\n", "type_constraint", "=", "self", ".", "type_constraint", ")", "\n", "\n", "", "prev", "=", "forward_sequence", "\n", "prev_rev", "=", "backward_sequence", "\n", "\n", "", "if", "train", ":", "\n", "# return losses", "\n", "            ", "return", "losses", "\n", "", "else", ":", "\n", "            ", "return", "seq", ".", "pred_tags", ",", "seq", ".", "tag_confidences", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.output_preds": [[737, 755], ["zip", "print", "print", "print", "print", "print"], "methods", ["None"], ["", "", "def", "output_preds", "(", "self", ",", "seq", ",", "raw", "=", "False", ",", "output_confidences", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        output predictions to a file\n        \"\"\"", "\n", "i", "=", "0", "\n", "for", "w", ",", "g", ",", "p", "in", "zip", "(", "seq", ".", "words", ",", "seq", ".", "tags", ",", "seq", ".", "pred_tags", ")", ":", "\n", "            ", "if", "raw", ":", "\n", "                ", "if", "output_confidences", ":", "\n", "                    ", "print", "(", "u\"{0}\\t{1}\\t{2:.2f}\"", ".", "format", "(", "w", ",", "p", ",", "seq", ".", "tag_confidences", "[", "i", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "u\"{}\\t{}\"", ".", "format", "(", "w", ",", "p", ")", ")", "# do not print DUMMY tag when --raw is on", "\n", "", "", "else", ":", "\n", "                ", "if", "output_confidences", ":", "\n", "                    ", "print", "(", "u\"{0}\\t{1}\\t{2}\\t{3:.2f}\"", ".", "format", "(", "w", ",", "g", ",", "p", ",", "seq", ".", "tag_confidences", "[", "i", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "u\"{}\\t{}\\t{}\"", ".", "format", "(", "w", ",", "g", ",", "p", ")", ")", "\n", "", "", "i", "+=", "1", "\n", "", "print", "(", "\"\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.evaluate": [[756, 774], ["structbilty.NNTagger.predict", "seq.evaluate", "structbilty.NNTagger.output_preds"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.predict", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.Seq.evaluate", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.output_preds"], ["", "def", "evaluate", "(", "self", ",", "test_file", ",", "task_id", ",", "output_predictions", "=", "None", ",", "raw", "=", "False", ",", "output_confidences", "=", "False", ",", "unk_tag", "=", "None", ",", "embeds_in_file", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        compute accuracy on a test file, optionally output to file\n        \"\"\"", "\n", "correct", "=", "0", "\n", "total", "=", "0", "\n", "\n", "for", "seq", "in", "test_file", ":", "\n", "            ", "if", "seq", ".", "task_id", "!=", "task_id", ":", "\n", "                ", "continue", "# we evaluate only on a specific task", "\n", "#TODO, isnt update_embeds=False better for evaluation? otherwise get from parent def", "\n", "", "self", ".", "predict", "(", "seq", ",", "output_confidences", "=", "output_confidences", ",", "unk_tag", "=", "unk_tag", ",", "update_embeds", "=", "False", ",", "embeds_in_file", "=", "embeds_in_file", ")", "\n", "if", "output_predictions", ":", "\n", "                ", "self", ".", "output_preds", "(", "seq", ",", "raw", "=", "raw", ",", "output_confidences", "=", "output_confidences", ")", "\n", "", "correct_inst", ",", "total_inst", "=", "seq", ".", "evaluate", "(", ")", "\n", "correct", "+=", "correct_inst", "\n", "total", "+=", "total_inst", "\n", "", "return", "correct", ",", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_w_repr": [[776, 796], ["structbilty.NNTagger.w2i.get", "_dynet.nobackprop", "structbilty.NNTagger.w2i.get", "structbilty.drop", "structbilty.NNTagger.w2i.get", "_dynet.inputVector", "structbilty.NNTagger.mimickx_model.predict().npvalue", "structbilty.NNTagger.mimickx_model.predict"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.drop", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.predict"], ["", "def", "get_w_repr", "(", "self", ",", "word", ",", "train", "=", "False", ",", "update", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Get representation of word (word embedding)\n        \"\"\"", "\n", "if", "train", ":", "\n", "            ", "if", "self", ".", "w_dropout_rate", ">", "0.0", ":", "\n", "                ", "w_id", "=", "self", ".", "w2i", "[", "UNK", "]", "if", "drop", "(", "word", ",", "self", ".", "wcount", ",", "self", ".", "w_dropout_rate", ")", "else", "self", ".", "w2i", ".", "get", "(", "word", ",", "self", ".", "w2i", "[", "UNK", "]", ")", "\n", "", "else", ":", "\n", "                ", "w_id", "=", "self", ".", "w2i", ".", "get", "(", "word", ",", "self", ".", "w2i", "[", "UNK", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "mimickx_model_path", ":", "# if given use MIMICKX -- not implemented", "\n", "                ", "if", "word", "not", "in", "self", ".", "w2i", ":", "#", "\n", "#print(\"predict with MIMICKX for: \", word)", "\n", "                    ", "return", "dynet", ".", "inputVector", "(", "self", ".", "mimickx_model", ".", "predict", "(", "word", ")", ".", "npvalue", "(", ")", ")", "\n", "", "", "w_id", "=", "self", ".", "w2i", ".", "get", "(", "word", ",", "self", ".", "w2i", "[", "UNK", "]", ")", "\n", "\n", "", "if", "not", "update", ":", "\n", "            ", "return", "dynet", ".", "nobackprop", "(", "self", ".", "wembeds", "[", "w_id", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "wembeds", "[", "w_id", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_c_repr": [[797, 813], ["structbilty.NNTagger.char_rnn.predict_sequence", "_dynet.concatenate", "array.array", "structbilty.drop", "array.array", "array.array", "structbilty.NNTagger.get_c_idx"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.BiRNNSequencePredictor.predict_sequence", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.drop", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_c_idx"], ["", "", "def", "get_c_repr", "(", "self", ",", "word", ",", "train", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Get representation of word via characters sub-LSTMs\n        \"\"\"", "\n", "# get representation for words", "\n", "if", "word", "in", "self", ".", "w2c_cache", ":", "\n", "            ", "chars_of_token", "=", "self", ".", "w2c_cache", "[", "word", "]", "\n", "if", "train", ":", "\n", "                ", "chars_of_token", "=", "[", "drop", "(", "c", ",", "self", ".", "ccount", ",", "self", ".", "c_dropout_rate", ")", "for", "c", "in", "chars_of_token", "]", "\n", "", "", "else", ":", "\n", "            ", "chars_of_token", "=", "array", ".", "array", "(", "'I'", ",", "[", "self", ".", "c2i", "[", "WORD_START", "]", "]", ")", "+", "array", ".", "array", "(", "'I'", ",", "[", "self", ".", "get_c_idx", "(", "c", ",", "train", "=", "train", ")", "for", "c", "in", "word", "]", ")", "+", "array", ".", "array", "(", "'I'", ",", "[", "self", ".", "c2i", "[", "WORD_END", "]", "]", ")", "\n", "\n", "", "char_feats", "=", "[", "self", ".", "cembeds", "[", "c_id", "]", "for", "c_id", "in", "chars_of_token", "]", "\n", "# use last state as word representation", "\n", "f_char", ",", "b_char", "=", "self", ".", "char_rnn", ".", "predict_sequence", "(", "char_feats", ",", "char_feats", ")", "\n", "return", "dynet", ".", "concatenate", "(", "[", "f_char", "[", "-", "1", "]", ",", "b_char", "[", "-", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_c_idx": [[815, 821], ["structbilty.drop", "structbilty.NNTagger.c2i.get", "structbilty.NNTagger.c2i.get"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.drop"], ["", "def", "get_c_idx", "(", "self", ",", "c", ",", "train", "=", "False", ")", ":", "\n", "        ", "\"\"\" helper function to get index of character\"\"\"", "\n", "if", "self", ".", "c_dropout_rate", ">", "0.0", "and", "train", "and", "drop", "(", "c", ",", "self", ".", "ccount", ",", "self", ".", "c_dropout_rate", ")", ":", "\n", "            ", "return", "self", ".", "c2i", ".", "get", "(", "UNK", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "c2i", ".", "get", "(", "c", ",", "self", ".", "c2i", "[", "UNK", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_lex_repr": [[822, 845], ["numpy.zeros", "lib.mnnl.is_in_dict", "numpy.concatenate", "len", "lib.mnnl.is_in_dict", "lex_feats.append", "lex_feats.append", "lex_feats.append", "structbilty.NNTagger.lembeds[].npvalue", "structbilty.NNTagger.dictionary_values.index", "structbilty.NNTagger.lembeds[].npvalue", "structbilty.NNTagger.lembeds[].npvalue"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.is_in_dict", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.is_in_dict"], ["", "", "def", "get_lex_repr", "(", "self", ",", "word", ")", ":", "\n", "        ", "\"\"\"\n        Get representation for lexical feature\n        \"\"\"", "\n", "if", "not", "self", ".", "embed_lex", ":", "## n-hot representation", "\n", "            ", "n_hot", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "dictionary_values", ")", ")", "\n", "values", "=", "is_in_dict", "(", "word", ",", "self", ".", "dictionary", ")", "\n", "if", "values", ":", "\n", "                ", "for", "v", "in", "values", ":", "\n", "                    ", "n_hot", "[", "self", ".", "dictionary_values", ".", "index", "(", "v", ")", "]", "=", "1.0", "\n", "", "", "return", "n_hot", "\n", "", "else", ":", "\n", "            ", "lex_feats", "=", "[", "]", "\n", "for", "property", "in", "self", ".", "dictionary_values", ":", "\n", "                ", "values", "=", "is_in_dict", "(", "word", ",", "self", ".", "dictionary", ")", "\n", "if", "values", ":", "\n", "                    ", "if", "property", "in", "values", ":", "\n", "                        ", "lex_feats", ".", "append", "(", "self", ".", "lembeds", "[", "self", ".", "l2i", "[", "property", "]", "]", ".", "npvalue", "(", ")", ")", "\n", "", "else", ":", "\n", "                        ", "lex_feats", ".", "append", "(", "self", ".", "lembeds", "[", "self", ".", "l2i", "[", "UNK", "]", "]", ".", "npvalue", "(", ")", ")", "\n", "", "", "else", ":", "\n", "                    ", "lex_feats", ".", "append", "(", "self", ".", "lembeds", "[", "self", ".", "l2i", "[", "UNK", "]", "]", ".", "npvalue", "(", ")", ")", "# unknown word", "\n", "", "", "return", "np", ".", "concatenate", "(", "lex_feats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.init_parameters": [[846, 890], ["collections.Counter", "collections.Counter", "int", "print", "structbilty.NNTagger.wcount.most_common", "numpy.sum", "numpy.sum", "print", "structbilty.NNTagger.wcount.update", "structbilty.NNTagger.ccount.update", "zip", "len", "array.array", "len", "len", "len", "len", "array.array", "array.array", "len", "structbilty.NNTagger.get_c_idx"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_c_idx"], ["", "", "def", "init_parameters", "(", "self", ",", "train_data", ")", ":", "\n", "        ", "\"\"\"init parameters from training data\"\"\"", "\n", "# word 2 indices and tag 2 indices", "\n", "self", ".", "w2i", "=", "{", "}", "# word to index", "\n", "self", ".", "c2i", "=", "{", "}", "# char to index", "\n", "self", ".", "task2tag2idx", "=", "{", "}", "# id of the task -> tag2idx", "\n", "\n", "self", ".", "w2i", "[", "UNK", "]", "=", "0", "# unk word / OOV", "\n", "self", ".", "c2i", "[", "UNK", "]", "=", "0", "# unk char", "\n", "self", ".", "c2i", "[", "WORD_START", "]", "=", "1", "# word start", "\n", "self", ".", "c2i", "[", "WORD_END", "]", "=", "2", "# word end index", "\n", "\n", "# word and char counters", "\n", "self", ".", "wcount", "=", "Counter", "(", ")", "\n", "self", ".", "ccount", "=", "Counter", "(", ")", "\n", "\n", "for", "seq", "in", "train_data", ":", "\n", "            ", "self", ".", "wcount", ".", "update", "(", "[", "w", "for", "w", "in", "seq", ".", "words", "]", ")", "\n", "self", ".", "ccount", ".", "update", "(", "[", "c", "for", "w", "in", "seq", ".", "words", "for", "c", "in", "w", "]", ")", "\n", "\n", "if", "seq", ".", "task_id", "not", "in", "self", ".", "task2tag2idx", ":", "\n", "                ", "self", ".", "task2tag2idx", "[", "seq", ".", "task_id", "]", "=", "{", "\"<START>\"", ":", "START_TAG", ",", "\"<END>\"", ":", "END_TAG", "}", "\n", "\n", "# record words and chars", "\n", "", "for", "word", ",", "tag", "in", "zip", "(", "seq", ".", "words", ",", "seq", ".", "tags", ")", ":", "\n", "                ", "if", "word", "not", "in", "self", ".", "w2i", ":", "\n", "                    ", "self", ".", "w2i", "[", "word", "]", "=", "len", "(", "self", ".", "w2i", ")", "\n", "\n", "", "if", "self", ".", "c_in_dim", ">", "0", ":", "\n", "                    ", "for", "char", "in", "word", ":", "\n", "                        ", "if", "char", "not", "in", "self", ".", "c2i", ":", "\n", "                            ", "self", ".", "c2i", "[", "char", "]", "=", "len", "(", "self", ".", "c2i", ")", "\n", "\n", "", "", "", "if", "tag", "not", "in", "self", ".", "task2tag2idx", "[", "seq", ".", "task_id", "]", ":", "\n", "                    ", "self", ".", "task2tag2idx", "[", "seq", ".", "task_id", "]", "[", "tag", "]", "=", "len", "(", "self", ".", "task2tag2idx", "[", "seq", ".", "task_id", "]", ")", "\n", "\n", "", "", "", "n", "=", "int", "(", "len", "(", "self", ".", "w2i", ")", "*", "0.3", ")", "# top 30%", "\n", "print", "(", "\"Caching top {} words\"", ".", "format", "(", "n", ")", ")", "\n", "for", "word", "in", "self", ".", "wcount", ".", "most_common", "(", "n", ")", ":", "\n", "            ", "self", ".", "w2c_cache", "[", "word", "]", "=", "array", ".", "array", "(", "'I'", ",", "[", "self", ".", "c2i", "[", "WORD_START", "]", "]", ")", "+", "array", ".", "array", "(", "'I'", ",", "[", "self", ".", "get_c_idx", "(", "c", ")", "for", "c", "in", "word", "]", ")", "+", "array", ".", "array", "(", "'I'", ",", "[", "self", ".", "c2i", "[", "WORD_END", "]", "]", ")", "\n", "# get total counts", "\n", "", "self", ".", "wtotal", "=", "np", ".", "sum", "(", "[", "self", ".", "wcount", "[", "w", "]", "for", "w", "in", "self", ".", "wcount", "]", ")", "\n", "self", ".", "ctotal", "=", "np", ".", "sum", "(", "[", "self", ".", "ccount", "[", "c", "]", "for", "c", "in", "self", ".", "ccount", "]", ")", "\n", "print", "(", "\"{} w features, {} c features\"", ".", "format", "(", "len", "(", "self", ".", "w2i", ")", ",", "len", "(", "self", ".", "c2i", ")", ")", ")", "\n", "#print(self.wtotal, self.ctotal)", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_embeds": [[893, 907], ["open", "i2w.keys", "open.close", "open.write", "structbilty.NNTagger.w2i.keys", "str", "wembeds_expression.npvalue"], "methods", ["None"], ["", "def", "save_embeds", "(", "self", ",", "out_filename", ")", ":", "\n", "        ", "\"\"\"\n        save final embeddings to file\n        :param out_filename: filename\n        \"\"\"", "\n", "# construct reverse mapping", "\n", "i2w", "=", "{", "self", ".", "w2i", "[", "w", "]", ":", "w", "for", "w", "in", "self", ".", "w2i", ".", "keys", "(", ")", "}", "\n", "\n", "OUT", "=", "open", "(", "out_filename", "+", "\".w.emb\"", ",", "\"w\"", ")", "\n", "for", "word_id", "in", "i2w", ".", "keys", "(", ")", ":", "\n", "            ", "wembeds_expression", "=", "self", ".", "wembeds", "[", "word_id", "]", "\n", "word", "=", "i2w", "[", "word_id", "]", "\n", "OUT", ".", "write", "(", "\"{} {}\\n\"", ".", "format", "(", "word", ",", "\" \"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "wembeds_expression", ".", "npvalue", "(", ")", "]", ")", ")", ")", "\n", "", "OUT", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_lex_embeds": [[909, 923], ["open", "i2l.keys", "open.close", "open.write", "structbilty.NNTagger.l2i.keys", "str", "lembeds_expression.npvalue"], "methods", ["None"], ["", "def", "save_lex_embeds", "(", "self", ",", "out_filename", ")", ":", "\n", "        ", "\"\"\"\n        save final embeddings to file\n        :param out_filename: filename\n        \"\"\"", "\n", "# construct reverse mapping", "\n", "i2l", "=", "{", "self", ".", "l2i", "[", "w", "]", ":", "w", "for", "w", "in", "self", ".", "l2i", ".", "keys", "(", ")", "}", "\n", "\n", "OUT", "=", "open", "(", "out_filename", "+", "\".l.emb\"", ",", "\"w\"", ")", "\n", "for", "lex_id", "in", "i2l", ".", "keys", "(", ")", ":", "\n", "            ", "lembeds_expression", "=", "self", ".", "lembeds", "[", "lex_id", "]", "\n", "lex", "=", "i2l", "[", "lex_id", "]", "\n", "OUT", ".", "write", "(", "\"{} {}\\n\"", ".", "format", "(", "lex", ",", "\" \"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "lembeds_expression", ".", "npvalue", "(", ")", "]", ")", ")", ")", "\n", "", "OUT", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_cw_embeds": [[925, 939], ["open", "i2cw.keys", "open.close", "open.write", "structbilty.NNTagger.w2i.keys", "v.npvalue", "structbilty.NNTagger.get_c_repr", "str"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.get_c_repr"], ["", "def", "save_cw_embeds", "(", "self", ",", "out_filename", ")", ":", "\n", "        ", "\"\"\"\n        save final character-based word-embeddings to file\n        :param out_filename: filename\n        \"\"\"", "\n", "# construct reverse mapping using word embeddings", "\n", "i2cw", "=", "{", "self", ".", "w2i", "[", "w", "]", ":", "w", "for", "w", "in", "self", ".", "w2i", ".", "keys", "(", ")", "}", "\n", "\n", "OUT", "=", "open", "(", "out_filename", "+", "\".cw.emb\"", ",", "\"w\"", ")", "\n", "for", "word_id", "in", "i2cw", ".", "keys", "(", ")", ":", "\n", "            ", "word", "=", "i2cw", "[", "word_id", "]", "\n", "cwembeds", "=", "[", "v", ".", "npvalue", "(", ")", "[", "0", "]", "for", "v", "in", "self", ".", "get_c_repr", "(", "word", ")", "]", "\n", "OUT", ".", "write", "(", "\"{} {}\\n\"", ".", "format", "(", "word", ",", "\" \"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "cwembeds", "]", ")", ")", ")", "\n", "", "OUT", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_wordlex_map": [[941, 966], ["open", "i2wl.keys", "open.close", "open.write", "structbilty.NNTagger.w2i.keys", "lib.mnnl.is_in_dict", "lex_feats.append", "lex_feats.append", "lex_feats.append", "str"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.is_in_dict"], ["", "def", "save_wordlex_map", "(", "self", ",", "out_filename", ")", ":", "\n", "        ", "\"\"\"\n        save final word-to-lexicon-embedding map to file\n        :param out_filename: filename\n        \"\"\"", "\n", "# construct reverse mapping using word embeddings", "\n", "i2wl", "=", "{", "self", ".", "w2i", "[", "w", "]", ":", "w", "for", "w", "in", "self", ".", "w2i", ".", "keys", "(", ")", "}", "\n", "\n", "OUT", "=", "open", "(", "out_filename", "+", "\".wlmap.emb\"", ",", "\"w\"", ")", "\n", "for", "word_id", "in", "i2wl", ".", "keys", "(", ")", ":", "\n", "            ", "word", "=", "i2wl", "[", "word_id", "]", "\n", "\n", "lex_feats", "=", "[", "]", "\n", "for", "property", "in", "self", ".", "dictionary_values", ":", "\n", "                ", "values", "=", "is_in_dict", "(", "word", ",", "self", ".", "dictionary", ")", "\n", "if", "values", ":", "\n", "                    ", "if", "property", "in", "values", ":", "\n", "                        ", "lex_feats", ".", "append", "(", "property", ")", "\n", "", "else", ":", "\n", "                        ", "lex_feats", ".", "append", "(", "UNK", ")", "\n", "", "", "else", ":", "\n", "                    ", "lex_feats", ".", "append", "(", "UNK", ")", "# unknown word", "\n", "\n", "", "", "OUT", ".", "write", "(", "\"{} {}\\n\"", ".", "format", "(", "word", ",", "\" \"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "lex_feats", "]", ")", ")", ")", "\n", "", "OUT", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_transition_matrix": [[967, 975], ["structbilty.NNTagger.predictors[].keys", "output_predictor.save_parameters"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.save_parameters"], ["", "def", "save_transition_matrix", "(", "self", ",", "out_filename", ")", ":", "\n", "        ", "\"\"\"\n        save transition matrix\n        :param out_filename: filename\n        \"\"\"", "\n", "for", "task_id", "in", "self", ".", "predictors", "[", "\"output_layers_dict\"", "]", ".", "keys", "(", ")", ":", "\n", "            ", "output_predictor", "=", "self", ".", "predictors", "[", "\"output_layers_dict\"", "]", "[", "task_id", "]", "\n", "output_predictor", ".", "save_parameters", "(", "out_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.main": [[24, 264], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "argparse.ArgumentParser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "argparse.ArgumentParser.add_argument_group", "parser.add_argument_group.add_argument", "argparse.ArgumentParser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "argparse.ArgumentParser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "argparse.ArgumentParser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "print", "numpy.random.seed", "random.seed", "lib.mnnl.init_dynet", "time.time", "structbilty.load", "argparse.ArgumentParser.parse_args", "print", "print", "os.path.isdir", "random.randint", "print", "structbilty.NNTagger", "lib.mio.SeqData", "load.fit", "structbilty.load", "print", "print", "load.save_embeds", "load.save_lex_embeds", "load.save_cw_embeds", "load.save_lw_embeds", "load.save_transition_matrix", "lib.mmappers.BUILDERS.keys", "lib.mmappers.ACTIVATION_MAP.keys", "lib.mmappers.ACTIVATION_MAP.keys", "lib.mmappers.TRAINER_MAP.keys", "lib.mmappers.INITIALIZER_MAP.keys", "argparse.ArgumentParser.print_help", "exit", "len", "print", "exit", "print", "print", "print", "exit", "os.path.isdir", "os.makedirs", "len", "print", "exit", "lib.mio.SeqData", "structbilty.save", "len", "load_model", "lib.mio.SeqData", "enumerate", "print", "exit", "os.path.exists", "print", "os.makedirs", "os.path.isdir", "print", "os.makedirs", "os.path.dirname", "os.path.exists", "os.path.dirname", "time.time", "print", "print", "load.evaluate", "print", "len", "os.path.dirname", "os.path.exists", "os.path.dirname", "os.path.dirname", "codecs.open", "print", "os.path.dirname", "os.path.dirname", "time.time", "time.time", "vars().items", "vars().items", "vars", "vars"], "function", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.init_dynet", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.load", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.fit", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.load", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_embeds", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_lex_embeds", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_cw_embeds", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.save_transition_matrix", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.save", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.Seq.evaluate"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"\"\"Run the bi-LSTM tagger\"\"\"", ",", "formatter_class", "=", "argparse", ".", "ArgumentDefaultsHelpFormatter", ")", "\n", "group_main", "=", "parser", ".", "add_argument_group", "(", "'Main'", ",", "'main arguments'", ")", "\n", "group_main", ".", "add_argument", "(", "\"--model\"", ",", "help", "=", "\"path to store/load model [required]\"", ",", "required", "=", "True", ")", "\n", "group_main", ".", "add_argument", "(", "\"--train\"", ",", "nargs", "=", "'*'", ",", "help", "=", "\"path to train file [if multiple files are given actives MTL]\"", ")", "# allow multiple train files, each asociated with a task = position in the list", "\n", "group_main", ".", "add_argument", "(", "\"--dev\"", ",", "nargs", "=", "'*'", ",", "help", "=", "\"dev file(s)\"", ",", "required", "=", "False", ")", "\n", "group_main", ".", "add_argument", "(", "\"--test\"", ",", "nargs", "=", "'*'", ",", "help", "=", "\"test file(s) [same order as --train]\"", ",", "required", "=", "False", ")", "\n", "\n", "group_model", "=", "parser", ".", "add_argument_group", "(", "'Model'", ",", "'specify model parameters'", ")", "\n", "group_model", ".", "add_argument", "(", "\"--in_dim\"", ",", "help", "=", "\"input dimension\"", ",", "type", "=", "int", ",", "default", "=", "64", ")", "# default Polyglot size", "\n", "group_model", ".", "add_argument", "(", "\"--h_dim\"", ",", "help", "=", "\"hidden dimension [default: 100]\"", ",", "type", "=", "int", ",", "default", "=", "100", ")", "\n", "group_model", ".", "add_argument", "(", "\"--c_in_dim\"", ",", "help", "=", "\"input dimension for character embeddings\"", ",", "type", "=", "int", ",", "default", "=", "100", ")", "\n", "group_model", ".", "add_argument", "(", "\"--c_h_dim\"", ",", "help", "=", "\"hidden dimension for character embeddings\"", ",", "type", "=", "int", ",", "default", "=", "100", ")", "\n", "group_model", ".", "add_argument", "(", "\"--h_layers\"", ",", "help", "=", "\"number of stacked LSTMs [default: 1 = no stacking]\"", ",", "required", "=", "False", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "group_model", ".", "add_argument", "(", "\"--pred_layer\"", ",", "nargs", "=", "'*'", ",", "help", "=", "\"predict task at this layer [default: last layer]\"", ",", "required", "=", "False", ")", "# for each task the layer on which it is predicted (default 1)", "\n", "group_model", ".", "add_argument", "(", "\"--embeds\"", ",", "help", "=", "\"word embeddings file\"", ",", "required", "=", "False", ",", "default", "=", "None", ")", "\n", "group_model", ".", "add_argument", "(", "\"--embeds_in_file\"", ",", "help", "=", "\"you can save the embeddings in the file using a format like emb=0.1,-0.4\"", ",", "required", "=", "False", ",", "action", "=", "\"store_true\"", ",", "default", "=", "False", ")", "\n", "group_model", ".", "add_argument", "(", "\"--embeds_in_file_dim\"", ",", "help", "=", "\"input dimension of external frozen embeddings\"", ",", "type", "=", "int", ",", "default", "=", "0", ")", "# eg. 768 for BERT base", "\n", "group_model", ".", "add_argument", "(", "\"--crf\"", ",", "help", "=", "\"use CRF instead of local decoding\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ")", "\n", "group_model", ".", "add_argument", "(", "\"--viterbi-loss\"", ",", "help", "=", "\"Use viterbi loss training (only active if --crf is on)\"", ",", "action", "=", "\"store_true\"", ",", "default", "=", "False", ")", "\n", "group_model", ".", "add_argument", "(", "\"--transition-matrix\"", ",", "help", "=", "\"store transition matrix from CRF\"", ")", "\n", "\n", "group_model", ".", "add_argument", "(", "\"--builder\"", ",", "help", "=", "\"RNN builder (default: lstmc)\"", ",", "choices", "=", "BUILDERS", ".", "keys", "(", ")", ",", "default", "=", "\"lstmc\"", ")", "\n", "\n", "group_model", ".", "add_argument", "(", "\"--mlp\"", ",", "help", "=", "\"add additional MLP layer of this dimension [default 0=disabled]\"", ",", "default", "=", "0", ",", "type", "=", "int", ")", "\n", "group_model", ".", "add_argument", "(", "\"--ac-mlp\"", ",", "help", "=", "\"activation function for optional MLP layer [rectify, tanh, ...] (default: tanh)\"", ",", "\n", "default", "=", "\"tanh\"", ",", "choices", "=", "ACTIVATION_MAP", ".", "keys", "(", ")", ")", "\n", "group_model", ".", "add_argument", "(", "\"--ac\"", ",", "help", "=", "\"activation function between hidden layers [rectify, tanh, ...]\"", ",", "default", "=", "\"tanh\"", ",", "\n", "choices", "=", "ACTIVATION_MAP", ".", "keys", "(", ")", ")", "\n", "\n", "group_input", "=", "parser", ".", "add_argument_group", "(", "'Input'", ",", "'specific input options'", ")", "\n", "group_input", ".", "add_argument", "(", "\"--raw\"", ",", "help", "=", "\"expects raw text input (one sentence per line)\"", ",", "required", "=", "False", ",", "action", "=", "\"store_true\"", ",", "default", "=", "False", ")", "\n", "\n", "group_output", "=", "parser", ".", "add_argument_group", "(", "'Output'", ",", "'specific output options'", ")", "\n", "group_output", ".", "add_argument", "(", "\"--dictionary\"", ",", "help", "=", "\"use dictionary as additional features or type constraints (with --type-constraints)\"", ",", "default", "=", "None", ")", "\n", "group_output", ".", "add_argument", "(", "\"--type-constraint\"", ",", "help", "=", "\"use dictionary as type constraints\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ")", "\n", "group_output", ".", "add_argument", "(", "\"--embed-lex\"", ",", "help", "=", "\"use dictionary as type constraints\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ")", "\n", "group_output", ".", "add_argument", "(", "\"--lex-dim\"", ",", "help", "=", "\"input dimension for lexical features\"", ",", "default", "=", "0", ",", "type", "=", "int", ")", "\n", "group_output", ".", "add_argument", "(", "\"--output\"", ",", "help", "=", "\"output predictions to file [word|gold|pred]\"", ",", "default", "=", "None", ")", "\n", "group_output", ".", "add_argument", "(", "\"--output-confidences\"", ",", "help", "=", "\"output tag confidences\"", ",", "action", "=", "\"store_true\"", ",", "default", "=", "False", ")", "\n", "group_output", ".", "add_argument", "(", "\"--save-embeds\"", ",", "help", "=", "\"save word embeddings to file\"", ",", "required", "=", "False", ",", "default", "=", "None", ")", "\n", "group_output", ".", "add_argument", "(", "\"--save-lexembeds\"", ",", "help", "=", "\"save lexicon embeddings to file\"", ",", "required", "=", "False", ",", "default", "=", "None", ")", "\n", "group_output", ".", "add_argument", "(", "\"--save-cwembeds\"", ",", "help", "=", "\"save character-based word-embeddings to file\"", ",", "required", "=", "False", ",", "default", "=", "None", ")", "\n", "group_output", ".", "add_argument", "(", "\"--save-lwembeds\"", ",", "help", "=", "\"save lexicon-based word-embeddings to file\"", ",", "required", "=", "False", ",", "default", "=", "None", ")", "\n", "group_output", ".", "add_argument", "(", "\"--mimickx-model\"", ",", "help", "=", "\"use mimickx model for OOVs\"", ",", "required", "=", "False", ",", "default", "=", "None", ",", "type", "=", "str", ")", "\n", "\n", "\n", "group_opt", "=", "parser", ".", "add_argument_group", "(", "'Optimizer'", ",", "'specify training parameters'", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--iters\"", ",", "help", "=", "\"training iterations\"", ",", "type", "=", "int", ",", "default", "=", "20", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--sigma\"", ",", "help", "=", "\"sigma of Gaussian noise\"", ",", "default", "=", "0.2", ",", "type", "=", "float", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--trainer\"", ",", "help", "=", "\"trainer [default: sgd]\"", ",", "choices", "=", "TRAINER_MAP", ".", "keys", "(", ")", ",", "default", "=", "\"sgd\"", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--learning-rate\"", ",", "help", "=", "\"learning rate [0: use default]\"", ",", "default", "=", "0", ",", "type", "=", "float", ")", "# see: http://dynet.readthedocs.io/en/latest/optimizers.html", "\n", "group_opt", ".", "add_argument", "(", "\"--patience\"", ",", "help", "=", "\"patience [default: 0=not used], requires specification of --dev and model path --save\"", ",", "required", "=", "False", ",", "default", "=", "0", ",", "type", "=", "int", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--log-losses\"", ",", "help", "=", "\"log loss (for each task if multiple active)\"", ",", "required", "=", "False", ",", "action", "=", "\"store_true\"", ",", "default", "=", "False", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--clip-threshold\"", ",", "help", "=", "\"gradient clip threshold (by default off)\"", ",", "required", "=", "False", ",", "default", "=", "0", ",", "type", "=", "float", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--word-dropout-rate\"", ",", "help", "=", "\"word dropout rate [default: 0.25], if 0=disabled, recommended: 0.25 (Kiperwasser & Goldberg, 2016)\"", ",", "required", "=", "False", ",", "default", "=", "0.25", ",", "type", "=", "float", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--char-dropout-rate\"", ",", "help", "=", "\"char dropout rate [default: 0=disabled]\"", ",", "required", "=", "False", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--disable-backprob-embeds\"", ",", "help", "=", "\"disable backprob into embeddings (default is to update)\"", ",", "\n", "required", "=", "False", ",", "action", "=", "\"store_false\"", ",", "default", "=", "True", ")", "\n", "group_opt", ".", "add_argument", "(", "\"--initializer\"", ",", "help", "=", "\"initializer for embeddings (default: constant)\"", ",", "\n", "choices", "=", "INITIALIZER_MAP", ".", "keys", "(", ")", ",", "default", "=", "\"constant\"", ")", "\n", "\n", "\n", "group_dynet", "=", "parser", ".", "add_argument_group", "(", "'DyNet'", ",", "'DyNet parameters'", ")", "\n", "group_dynet", ".", "add_argument", "(", "\"--seed\"", ",", "help", "=", "\"random seed (also for DyNet)\"", ",", "required", "=", "False", ",", "type", "=", "int", ")", "\n", "group_dynet", ".", "add_argument", "(", "\"--dynet-mem\"", ",", "help", "=", "\"memory for DyNet\"", ",", "required", "=", "False", ",", "type", "=", "int", ")", "\n", "group_dynet", ".", "add_argument", "(", "\"--dynet-gpus\"", ",", "help", "=", "\"1 for GPU usage\"", ",", "default", "=", "0", ",", "type", "=", "int", ")", "# warning: non-deterministic results on GPU https://github.com/clab/dynet/issues/399", "\n", "group_dynet", ".", "add_argument", "(", "\"--dynet-autobatch\"", ",", "help", "=", "\"if 1 enable autobatching\"", ",", "default", "=", "0", ",", "type", "=", "int", ")", "\n", "group_dynet", ".", "add_argument", "(", "\"--minibatch-size\"", ",", "help", "=", "\"size of minibatch for autobatching (1=disabled)\"", ",", "default", "=", "1", ",", "type", "=", "int", ")", "\n", "\n", "try", ":", "\n", "        ", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "", "except", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "exit", "(", ")", "\n", "\n", "", "if", "args", ".", "train", ":", "\n", "        ", "if", "len", "(", "args", ".", "train", ")", ">", "1", ":", "\n", "            ", "if", "not", "args", ".", "pred_layer", ":", "\n", "                ", "print", "(", "\"--pred_layer required!\"", ")", "\n", "exit", "(", ")", "\n", "", "", "elif", "len", "(", "args", ".", "train", ")", "==", "1", "and", "not", "args", ".", "pred_layer", ":", "\n", "            ", "args", ".", "pred_layer", "=", "[", "args", ".", "h_layers", "]", "# assumes h_layers is 1", "\n", "\n", "", "", "if", "args", ".", "c_in_dim", "==", "0", ":", "\n", "        ", "print", "(", "\">>> disable character embeddings <<<\"", ")", "\n", "\n", "", "if", "args", ".", "minibatch_size", ">", "1", ":", "\n", "        ", "print", "(", "\">>> using minibatch_size {} <<<\"", ".", "format", "(", "args", ".", "minibatch_size", ")", ")", "\n", "\n", "", "if", "args", ".", "viterbi_loss", ":", "\n", "        ", "if", "not", "args", ".", "crf", ":", "\n", "            ", "print", "(", "\"--crf (global decoding) needs to be active when --viterbi is used\"", ")", "\n", "exit", "(", ")", "\n", "", "", "if", "args", ".", "crf", ":", "\n", "        ", "if", "args", ".", "viterbi_loss", ":", "\n", "            ", "print", "(", "\">>> using global decoding (Viterbi loss) <<<\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\">>> using global decoding (CRF, neg-log loss) <<<\"", ")", "\n", "\n", "", "", "if", "args", ".", "patience", ":", "\n", "        ", "if", "not", "args", ".", "dev", "or", "not", "args", ".", "model", ":", "\n", "            ", "print", "(", "\"patience requires a dev set and model path (--dev and --model)\"", ")", "\n", "exit", "(", ")", "\n", "\n", "# check if --save folder exists", "\n", "", "", "if", "args", ".", "model", ":", "\n", "        ", "if", "os", ".", "path", ".", "isdir", "(", "args", ".", "model", ")", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "model", ")", ":", "\n", "                ", "print", "(", "\"Creating {}..\"", ".", "format", "(", "args", ".", "model", ")", ")", "\n", "os", ".", "makedirs", "(", "args", ".", "model", ")", "\n", "", "", "elif", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "dirname", "(", "args", ".", "model", ")", ")", "and", "not", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "dirname", "(", "args", ".", "model", ")", ")", ":", "\n", "            ", "print", "(", "\"Creating {}..\"", ".", "format", "(", "os", ".", "path", ".", "dirname", "(", "args", ".", "model", ")", ")", ")", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "args", ".", "model", ")", ")", "\n", "\n", "", "", "if", "args", ".", "output", ":", "\n", "        ", "if", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "dirname", "(", "args", ".", "output", ")", ")", "and", "not", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "dirname", "(", "args", ".", "output", ")", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "args", ".", "output", ")", ")", "\n", "\n", "", "", "if", "not", "args", ".", "seed", ":", "\n", "## set seed", "\n", "        ", "seed", "=", "random", ".", "randint", "(", "1", ",", "MAX_SEED", ")", "\n", "", "else", ":", "\n", "        ", "seed", "=", "args", ".", "seed", "\n", "\n", "", "print", "(", "\">>> using seed: {} <<< \"", ".", "format", "(", "seed", ")", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "init_dynet", "(", "seed", ")", "\n", "\n", "if", "args", ".", "mimickx_model", ":", "\n", "        ", "from", "mimickx", "import", "Mimickx", ",", "load_model", "# make sure PYTHONPATH is set", "\n", "print", "(", "\">>> Loading mimickx model {} <<<\"", ".", "format", "(", "args", ".", "mimickx_model", ")", ")", "\n", "\n", "", "model_path", "=", "args", ".", "model", "\n", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "args", ".", "train", "and", "len", "(", "args", ".", "train", ")", "!=", "0", ":", "\n", "\n", "        ", "if", "args", ".", "embeds_in_file", "and", "not", "args", ".", "embeds_in_file_dim", ":", "\n", "            ", "print", "(", "\"--embeds_in_file_dim DIM required when activating --embeds_in_file\"", ")", "\n", "exit", "(", ")", "\n", "\n", "", "tagger", "=", "NNTagger", "(", "args", ".", "in_dim", ",", "\n", "args", ".", "h_dim", ",", "\n", "args", ".", "c_in_dim", ",", "\n", "args", ".", "c_h_dim", ",", "\n", "args", ".", "h_layers", ",", "\n", "args", ".", "pred_layer", ",", "\n", "embeds_file", "=", "args", ".", "embeds", ",", "\n", "embeds_in_file", "=", "args", ".", "embeds_in_file", ",", "\n", "embeds_in_file_dim", "=", "args", ".", "embeds_in_file_dim", ",", "\n", "w_dropout_rate", "=", "args", ".", "word_dropout_rate", ",", "\n", "c_dropout_rate", "=", "args", ".", "char_dropout_rate", ",", "\n", "activation", "=", "ACTIVATION_MAP", "[", "args", ".", "ac", "]", ",", "\n", "mlp", "=", "args", ".", "mlp", ",", "\n", "activation_mlp", "=", "ACTIVATION_MAP", "[", "args", ".", "ac_mlp", "]", ",", "\n", "noise_sigma", "=", "args", ".", "sigma", ",", "\n", "learning_algo", "=", "args", ".", "trainer", ",", "\n", "learning_rate", "=", "args", ".", "learning_rate", ",", "\n", "backprob_embeds", "=", "args", ".", "disable_backprob_embeds", ",", "\n", "initializer", "=", "INITIALIZER_MAP", "[", "args", ".", "initializer", "]", ",", "\n", "builder", "=", "BUILDERS", "[", "args", ".", "builder", "]", ",", "\n", "crf", "=", "args", ".", "crf", ",", "\n", "mimickx_model_path", "=", "args", ".", "mimickx_model", ",", "\n", "dictionary", "=", "args", ".", "dictionary", ",", "type_constraint", "=", "args", ".", "type_constraint", ",", "\n", "lex_dim", "=", "args", ".", "lex_dim", ",", "embed_lex", "=", "args", ".", "embed_lex", ")", "\n", "\n", "dev", "=", "None", "\n", "train", "=", "SeqData", "(", "args", ".", "train", ",", "embeds_in_file", "=", "args", ".", "embeds_in_file", ")", "\n", "if", "args", ".", "dev", ":", "\n", "            ", "dev", "=", "SeqData", "(", "args", ".", "dev", ",", "embeds_in_file", "=", "args", ".", "embeds_in_file", ")", "\n", "\n", "", "tagger", ".", "fit", "(", "train", ",", "args", ".", "iters", ",", "\n", "dev", "=", "dev", ",", "\n", "model_path", "=", "model_path", ",", "patience", "=", "args", ".", "patience", ",", "minibatch_size", "=", "args", ".", "minibatch_size", ",", "log_losses", "=", "args", ".", "log_losses", ",", "clip_threshold", "=", "args", ".", "clip_threshold", ",", "embeds_in_file", "=", "args", ".", "embeds_in_file", ")", "\n", "\n", "if", "not", "args", ".", "dev", "and", "not", "args", ".", "patience", ":", "# in case patience is active it gets saved in the fit function", "\n", "            ", "save", "(", "tagger", ",", "model_path", ")", "\n", "\n", "", "", "if", "args", ".", "test", "and", "len", "(", "args", ".", "test", ")", "!=", "0", ":", "\n", "\n", "        ", "tagger", "=", "load", "(", "args", ".", "model", ",", "args", ".", "dictionary", ")", "\n", "\n", "# check if mimickx provided after training", "\n", "if", "args", ".", "mimickx_model", ":", "\n", "            ", "tagger", ".", "mimickx_model_path", "=", "args", ".", "mimickx_model", "\n", "tagger", ".", "mimickx_model", "=", "load_model", "(", "args", ".", "mimickx_model", ")", "\n", "\n", "", "stdout", "=", "sys", ".", "stdout", "\n", "# One file per test ...", "\n", "if", "args", ".", "test", ":", "\n", "            ", "test", "=", "SeqData", "(", "args", ".", "test", ",", "raw", "=", "args", ".", "raw", ",", "embeds_in_file", "=", "args", ".", "embeds_in_file", ")", "# read in all test data", "\n", "\n", "for", "i", ",", "test_file", "in", "enumerate", "(", "args", ".", "test", ")", ":", "# expect them in same order", "\n", "                ", "if", "args", ".", "output", "is", "not", "None", ":", "\n", "                    ", "sys", ".", "stdout", "=", "codecs", ".", "open", "(", "args", ".", "output", "+", "\".task{}\"", ".", "format", "(", "i", ")", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "\n", "\n", "", "start_testing", "=", "time", ".", "time", "(", ")", "\n", "\n", "print", "(", "'\\nTesting task{}'", ".", "format", "(", "i", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'*******\\n'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "correct", ",", "total", "=", "tagger", ".", "evaluate", "(", "test", ",", "\"task{}\"", ".", "format", "(", "i", ")", ",", "\n", "output_predictions", "=", "args", ".", "output", ",", "\n", "output_confidences", "=", "args", ".", "output_confidences", ",", "raw", "=", "args", ".", "raw", ",", "\n", "unk_tag", "=", "None", ",", "embeds_in_file", "=", "args", ".", "embeds_in_file", ")", "\n", "if", "not", "args", ".", "raw", ":", "\n", "                    ", "print", "(", "\"\\nTask{} test accuracy on {} items: {:.4f}\"", ".", "format", "(", "i", ",", "i", "+", "1", ",", "correct", "/", "total", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "", "print", "(", "(", "\"Done. Took {0:.2f} seconds in total (testing took {1:.2f} seconds).\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ",", "\n", "time", ".", "time", "(", ")", "-", "start_testing", ")", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "sys", ".", "stdout", "=", "stdout", "\n", "", "", "", "if", "args", ".", "train", ":", "\n", "        ", "print", "(", "\"Info: biLSTM\\n\\t\"", "+", "\"\\n\\t\"", ".", "join", "(", "[", "\"{}: {}\"", ".", "format", "(", "a", ",", "v", ")", "for", "a", ",", "v", "in", "vars", "(", "args", ")", ".", "items", "(", ")", "\n", "if", "a", "not", "in", "[", "\"train\"", ",", "\"test\"", ",", "\"dev\"", ",", "\"pred_layer\"", "]", "]", ")", ")", "\n", "", "else", ":", "\n", "# print less when only testing, as not all train params are stored explicitly", "\n", "        ", "print", "(", "\"Info: biLSTM\\n\\t\"", "+", "\"\\n\\t\"", ".", "join", "(", "[", "\"{}: {}\"", ".", "format", "(", "a", ",", "v", ")", "for", "a", ",", "v", "in", "vars", "(", "args", ")", ".", "items", "(", ")", "\n", "if", "a", "not", "in", "[", "\"train\"", ",", "\"test\"", ",", "\"dev\"", ",", "\"pred_layer\"", ",", "\n", "\"initializer\"", ",", "\"ac\"", ",", "\"word_dropout_rate\"", ",", "\n", "\"patience\"", ",", "\"sigma\"", ",", "\"disable_backprob_embed\"", ",", "\n", "\"trainer\"", ",", "\"dynet_seed\"", ",", "\"dynet_mem\"", ",", "\"iters\"", "]", "]", ")", ")", "\n", "\n", "", "tagger", "=", "load", "(", "args", ".", "model", ",", "args", ".", "dictionary", ")", "\n", "\n", "if", "args", ".", "save_embeds", ":", "\n", "        ", "tagger", ".", "save_embeds", "(", "args", ".", "save_embeds", ")", "\n", "\n", "", "if", "args", ".", "save_lexembeds", ":", "\n", "        ", "tagger", ".", "save_lex_embeds", "(", "args", ".", "save_lexembeds", ")", "\n", "\n", "", "if", "args", ".", "save_cwembeds", ":", "\n", "        ", "tagger", ".", "save_cw_embeds", "(", "args", ".", "save_cwembeds", ")", "\n", "\n", "", "if", "args", ".", "save_lwembeds", ":", "\n", "        ", "tagger", ".", "save_lw_embeds", "(", "args", ".", "save_lwembeds", ")", "\n", "\n", "", "if", "args", ".", "transition_matrix", ":", "\n", "        ", "tagger", ".", "save_transition_matrix", "(", "args", ".", "transition_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.load": [[268, 303], ["print", "dill.load", "structbilty.NNTagger", "structbilty.NNTagger.set_indices", "structbilty.NNTagger.set_counts", "structbilty.NNTagger.build_computation_graph", "NNTagger.model.populate", "print", "open"], "function", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.load", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.set_indices", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.set_counts", "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.NNTagger.build_computation_graph"], ["", "", "def", "load", "(", "model_path", ",", "local_dictionary", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    load a model from file; specify the .model file, it assumes the *pickle file in the same location\n    \"\"\"", "\n", "print", "(", "\"load model.. \"", ",", "model_path", ")", "\n", "myparams", "=", "dill", ".", "load", "(", "open", "(", "model_path", "+", "\".params.pickle\"", ",", "\"rb\"", ")", ")", "\n", "if", "not", "\"mimickx_model_path\"", "in", "myparams", ":", "\n", "        ", "myparams", "[", "\"mimickx_model_path\"", "]", "=", "None", "\n", "", "if", "local_dictionary", ":", "\n", "        ", "myparams", "[", "\"path_to_dictionary\"", "]", "=", "local_dictionary", "\n", "", "tagger", "=", "NNTagger", "(", "myparams", "[", "\"in_dim\"", "]", ",", "\n", "myparams", "[", "\"h_dim\"", "]", ",", "\n", "myparams", "[", "\"c_in_dim\"", "]", ",", "\n", "myparams", "[", "\"c_h_dim\"", "]", ",", "\n", "myparams", "[", "\"h_layers\"", "]", ",", "\n", "myparams", "[", "\"pred_layer\"", "]", ",", "\n", "activation", "=", "myparams", "[", "\"activation\"", "]", ",", "\n", "mlp", "=", "myparams", "[", "\"mlp\"", "]", ",", "\n", "activation_mlp", "=", "myparams", "[", "\"activation_mlp\"", "]", ",", "\n", "builder", "=", "myparams", "[", "\"builder\"", "]", ",", "\n", "crf", "=", "myparams", "[", "\"crf\"", "]", ",", "\n", "mimickx_model_path", "=", "myparams", "[", "\"mimickx_model_path\"", "]", ",", "\n", "dictionary", "=", "myparams", "[", "\"path_to_dictionary\"", "]", ",", "\n", "type_constraint", "=", "myparams", "[", "\"type_constraint\"", "]", ",", "\n", "lex_dim", "=", "myparams", "[", "\"lex_dim\"", "]", ",", "\n", "embed_lex", "=", "myparams", "[", "\"embed_lex\"", "]", ",", "\n", "embeds_in_file_dim", "=", "myparams", "[", "\"embeds_in_file_dim\"", "]", "\n", ")", "\n", "tagger", ".", "set_indices", "(", "myparams", "[", "\"w2i\"", "]", ",", "myparams", "[", "\"c2i\"", "]", ",", "myparams", "[", "\"task2tag2idx\"", "]", ",", "myparams", "[", "\"w2c_cache\"", "]", ",", "myparams", "[", "\"l2i\"", "]", ")", "\n", "tagger", ".", "set_counts", "(", "myparams", "[", "\"wcount\"", "]", ",", "myparams", "[", "\"wtotal\"", "]", ",", "myparams", "[", "\"ccount\"", "]", ",", "myparams", "[", "\"ctotal\"", "]", ")", "\n", "tagger", ".", "build_computation_graph", "(", "myparams", "[", "\"num_words\"", "]", ",", "\n", "myparams", "[", "\"num_chars\"", "]", ")", "\n", "tagger", ".", "model", ".", "populate", "(", "model_path", "+", "\".model\"", ")", "\n", "print", "(", "\"model loaded: {}\"", ".", "format", "(", "model_path", ")", ")", "\n", "return", "tagger", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.save": [[305, 343], ["nntagger.model.save", "dill.dump", "print", "len", "len", "open"], "function", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.save"], ["", "def", "save", "(", "nntagger", ",", "model_path", ")", ":", "\n", "    ", "\"\"\"\n    save a model; dynet only saves the parameters, need to store the rest separately\n    \"\"\"", "\n", "modelname", "=", "model_path", "+", "\".model\"", "\n", "nntagger", ".", "model", ".", "save", "(", "modelname", ")", "\n", "myparams", "=", "{", "\"num_words\"", ":", "len", "(", "nntagger", ".", "w2i", ")", ",", "\n", "\"num_chars\"", ":", "len", "(", "nntagger", ".", "c2i", ")", ",", "\n", "\"w2i\"", ":", "nntagger", ".", "w2i", ",", "\n", "\"c2i\"", ":", "nntagger", ".", "c2i", ",", "\n", "\"wcount\"", ":", "nntagger", ".", "wcount", ",", "\n", "\"wtotal\"", ":", "nntagger", ".", "wtotal", ",", "\n", "\"ccount\"", ":", "nntagger", ".", "ccount", ",", "\n", "\"ctotal\"", ":", "nntagger", ".", "ctotal", ",", "\n", "\"w2c_cache\"", ":", "nntagger", ".", "w2c_cache", ",", "\n", "\"task2tag2idx\"", ":", "nntagger", ".", "task2tag2idx", ",", "\n", "\"activation\"", ":", "nntagger", ".", "activation", ",", "\n", "\"mlp\"", ":", "nntagger", ".", "mlp", ",", "\n", "\"activation_mlp\"", ":", "nntagger", ".", "activation_mlp", ",", "\n", "\"in_dim\"", ":", "nntagger", ".", "in_dim", ",", "\n", "\"h_dim\"", ":", "nntagger", ".", "h_dim", ",", "\n", "\"c_in_dim\"", ":", "nntagger", ".", "c_in_dim", ",", "\n", "\"c_h_dim\"", ":", "nntagger", ".", "c_h_dim", ",", "\n", "\"h_layers\"", ":", "nntagger", ".", "h_layers", ",", "\n", "\"embeds_in_file_dim\"", ":", "nntagger", ".", "embeds_in_file_dim", ",", "\n", "\"pred_layer\"", ":", "nntagger", ".", "pred_layer", ",", "\n", "\"builder\"", ":", "nntagger", ".", "builder", ",", "\n", "\"crf\"", ":", "nntagger", ".", "crf", ",", "\n", "\"mimickx_model_path\"", ":", "nntagger", ".", "mimickx_model_path", ",", "\n", "\"path_to_dictionary\"", ":", "nntagger", ".", "path_to_dictionary", ",", "\n", "\"type_constraint\"", ":", "nntagger", ".", "type_constraint", ",", "\n", "\"lex_dim\"", ":", "nntagger", ".", "lex_dim", ",", "\n", "\"embed_lex\"", ":", "nntagger", ".", "embed_lex", ",", "\n", "\"l2i\"", ":", "nntagger", ".", "l2i", "\n", "}", "\n", "dill", ".", "dump", "(", "myparams", ",", "open", "(", "model_path", "+", "\".params.pickle\"", ",", "\"wb\"", ")", ")", "\n", "print", "(", "\"model stored: {}\"", ".", "format", "(", "modelname", ")", ")", "\n", "del", "nntagger", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.drop": [[345, 350], ["random.random", "xcount.get", "xcount.get"], "function", ["None"], ["", "def", "drop", "(", "x", ",", "xcount", ",", "dropout_rate", ")", ":", "\n", "    ", "\"\"\"\n    drop x if x is less frequent (cf. Kiperwasser & Goldberg, 2016)\n    \"\"\"", "\n", "return", "random", ".", "random", "(", ")", ">", "(", "xcount", ".", "get", "(", "x", ")", "/", "(", "dropout_rate", "+", "xcount", ".", "get", "(", "x", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.Seq.__init__": [[14, 21], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "words", ",", "tags", "=", "None", ",", "task_id", "=", "None", ",", "embeds", "=", "None", ")", ":", "\n", "        ", "self", ".", "words", "=", "words", "\n", "self", ".", "tags", "=", "tags", "\n", "self", ".", "task_id", "=", "task_id", "\n", "self", ".", "embeds", "=", "embeds", "\n", "self", ".", "tag_confidences", "=", "[", "]", "\n", "self", ".", "pred_tags", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.Seq.evaluate": [[22, 26], ["numpy.sum", "len", "zip"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "correct", "=", "np", ".", "sum", "(", "[", "i", "==", "j", "for", "i", ",", "j", "in", "zip", "(", "self", ".", "pred_tags", ",", "self", ".", "tags", ")", "]", ")", "\n", "total", "=", "len", "(", "self", ".", "tags", ")", "\n", "return", "correct", ",", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.SeqData.__init__": [[33, 41], ["set", "enumerate", "mio.SeqData.task_ids.add", "mio.read_conll_file", "mio.SeqData.seqs.append", "mio.Seq"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.read_conll_file"], ["def", "__init__", "(", "self", ",", "list_folders_name", ",", "raw", "=", "False", ",", "embeds_in_file", "=", "False", ")", ":", "\n", "        ", "self", ".", "seqs", "=", "[", "]", "\n", "self", ".", "task_ids", "=", "set", "(", ")", "\n", "for", "i", ",", "file_name", "in", "enumerate", "(", "list_folders_name", ")", ":", "\n", "            ", "task_id", "=", "\"task{}\"", ".", "format", "(", "i", ")", "\n", "self", ".", "task_ids", ".", "add", "(", "task_id", ")", "\n", "for", "word_seq", ",", "tag_seq", ",", "emb_seq", "in", "read_conll_file", "(", "file_name", ",", "raw", "=", "raw", ",", "embeds_in_file", "=", "embeds_in_file", ")", ":", "\n", "                ", "self", ".", "seqs", ".", "append", "(", "Seq", "(", "word_seq", ",", "tag_seq", ",", "task_id", ",", "embeds", "=", "emb_seq", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.SeqData.__iter__": [[42, 46], ["None"], "methods", ["None"], ["", "", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "\"\"\"iterate over data\"\"\"", "\n", "for", "seq", "in", "self", ".", "seqs", ":", "\n", "            ", "yield", "seq", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.load_dict": [[48, 57], ["collections.defaultdict", "set", "codecs.open", "print", "line.strip().split", "d[].add", "set.add", "sorted", "len", "line.strip"], "function", ["None"], ["", "", "", "def", "load_dict", "(", "file_name", ")", ":", "\n", "    ", "d", "=", "defaultdict", "(", "set", ")", "\n", "dict_values", "=", "set", "(", ")", "\n", "for", "line", "in", "codecs", ".", "open", "(", "file_name", ",", "encoding", "=", "\"utf-8\"", ",", "errors", "=", "\"ignore\"", ")", ":", "\n", "        ", "word", ",", "tag", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "\"\\t\"", ")", "\n", "d", "[", "word", "]", ".", "add", "(", "tag", ")", "\n", "dict_values", ".", "add", "(", "tag", ")", "\n", "", "print", "(", "\"Loaded dictionary with {} word types\"", ".", "format", "(", "len", "(", "d", ")", ")", ")", "\n", "return", "d", ",", "sorted", "(", "dict_values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.load_embeddings_file": [[59, 86], ["open", "print", "len", "re.split", "len", "float", "word.lower.lower", "scipy.linalg.norm", "print", "len"], "function", ["None"], ["", "def", "load_embeddings_file", "(", "file_name", ",", "sep", "=", "\" \"", ",", "lower", "=", "False", ",", "normalize", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    load embeddings file\n    \"\"\"", "\n", "emb", "=", "{", "}", "\n", "first", "=", "True", "\n", "for", "line", "in", "open", "(", "file_name", ",", "errors", "=", "'ignore'", ",", "encoding", "=", "'utf-8'", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "fields", "=", "re", ".", "split", "(", "\" \"", ",", "line", ")", "\n", "if", "len", "(", "fields", ")", "<", "5", "and", "first", ":", "\n", "                ", "first", "=", "False", "\n", "continue", "\n", "", "if", "fields", "[", "-", "1", "]", "==", "\"\\n\"", ":", "\n", "                ", "fields", "=", "fields", "[", ":", "-", "1", "]", "\n", "", "vec", "=", "[", "float", "(", "x", ")", "for", "x", "in", "fields", "[", "1", ":", "]", "]", "\n", "word", "=", "fields", "[", "0", "]", "\n", "if", "lower", ":", "\n", "                ", "word", "=", "word", ".", "lower", "(", ")", "\n", "", "emb", "[", "word", "]", "=", "vec", "\n", "if", "normalize", ":", "\n", "                ", "emb", "[", "word", "]", "/=", "linalg", ".", "norm", "(", "emb", "[", "w", "]", ")", "\n", "", "first", "=", "False", "\n", "", "except", "ValueError", ":", "\n", "            ", "print", "(", "\"Error converting: {}\"", ".", "format", "(", "line", ")", ")", "\n", "\n", "", "", "print", "(", "\"loaded pre-trained embeddings (word->emb_vec) size: {}\"", ".", "format", "(", "len", "(", "emb", ")", ")", ")", "\n", "return", "emb", ",", "len", "(", "emb", "[", "word", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mio.read_conll_file": [[88, 148], ["re.compile", "codecs.open", "print", "exit", "re.compile.match", "line.split", "line.split", "line.split.append", "current_tags.append", "current_embeds.append", "len", "IOError", "len", "float", "len", "IOError", "IOError", "[].split", "line.split"], "function", ["None"], ["", "def", "read_conll_file", "(", "file_name", ",", "raw", "=", "False", ",", "embeds_in_file", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    read in conll file\n    word1    tag1\n    ...      ...\n    wordN    tagN\n\n    Sentences MUST be separated by newlines!\n\n    :param file_name: file to read in\n    :param raw: if raw text file (with one sentence per line) -- adds 'DUMMY' label\n    :return: generator of instances ((list of  words, list of tags) pairs)\n\n    \"\"\"", "\n", "if", "raw", "and", "embeds_in_file", ":", "\n", "        ", "print", "(", "\"sorry, combining --raw and --embeds_in_file is currently not supported, please retry with adding dummy labels\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "current_words", "=", "[", "]", "\n", "current_tags", "=", "[", "]", "\n", "current_embeds", "=", "[", "]", "\n", "ws_pattern", "=", "re", ".", "compile", "(", "\"^\\s+$\"", ")", "# match emtpy lines that contain some whitespace", "\n", "\n", "for", "line", "in", "codecs", ".", "open", "(", "file_name", ",", "encoding", "=", "'utf-8'", ")", ":", "\n", "#line = line.strip()", "\n", "        ", "line", "=", "line", "[", ":", "-", "1", "]", "\n", "\n", "if", "not", "line", "or", "ws_pattern", ".", "match", "(", "line", ")", ":", "\n", "            ", "if", "current_words", "and", "not", "raw", ":", "#skip emtpy lines", "\n", "                ", "yield", "(", "current_words", ",", "current_tags", ",", "current_embeds", ")", "\n", "", "current_words", "=", "[", "]", "\n", "current_tags", "=", "[", "]", "\n", "current_embeds", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "if", "raw", ":", "\n", "                ", "current_words", "=", "line", ".", "split", "(", ")", "## simple splitting by whitespace", "\n", "current_tags", "=", "[", "'DUMMY'", "for", "_", "in", "current_words", "]", "\n", "current_embeds", "=", "[", "[", "]", "for", "_", "in", "current_words", "]", "\n", "yield", "(", "current_words", ",", "current_tags", ",", "current_embeds", ")", "\n", "", "else", ":", "\n", "                ", "tok", "=", "line", ".", "split", "(", "'\\t'", ")", "\n", "if", "len", "(", "tok", ")", "==", "2", "and", "not", "embeds_in_file", ":", "\n", "                    ", "word", ",", "tag", "=", "tok", "\n", "embed", "=", "[", "]", "\n", "if", "not", "tag", ":", "\n", "                        ", "raise", "IOError", "(", "\"empty tag in line line: {}\"", ".", "format", "(", "line", ")", ")", "\n", "", "", "elif", "len", "(", "tok", ")", "==", "3", "and", "embeds_in_file", ":", "\n", "                    ", "word", "=", "tok", "[", "0", "]", "\n", "tag", "=", "tok", "[", "1", "]", "\n", "embed", "=", "[", "float", "(", "x", ")", "for", "x", "in", "tok", "[", "2", "]", "[", "4", ":", "]", ".", "split", "(", "','", ")", "]", "\n", "", "else", ":", "\n", "                    ", "if", "len", "(", "line", ".", "split", "(", "\"\\t\"", ")", ")", "==", "1", ":", "# emtpy words in gimpel", "\n", "                        ", "raise", "IOError", "(", "\"Issue with input file - doesn't have a tag or token?\"", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "IOError", "(", "\"erroneous line: {}\"", ".", "format", "(", "line", ")", ")", "\n", "", "", "current_words", ".", "append", "(", "word", ")", "\n", "current_tags", ".", "append", "(", "tag", ")", "\n", "current_embeds", ".", "append", "(", "embed", ")", "\n", "# check for last one", "\n", "", "", "", "if", "current_tags", "!=", "[", "]", "and", "not", "raw", ":", "\n", "        ", "yield", "(", "current_words", ",", "current_tags", ",", "current_embeds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.SequencePredictor.__init__": [[37, 39], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.SequencePredictor.predict_sequence": [[40, 42], ["NotImplementedError"], "methods", ["None"], ["", "def", "predict_sequence", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"SequencePredictor predict_sequence: Not Implemented\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.OutputSequencePredictor.__init__": [[45, 47], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.OutputSequencePredictor.predict_sequence": [[48, 50], ["NotImplementedError"], "methods", ["None"], ["", "def", "predict_sequence", "(", "self", ",", "seq", ",", "inputs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"SequencePredictor predict_sequence: Not Implemented\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.FFSequencePredictor.__init__": [[56, 60], ["mnnl.FFSequencePredictor.tag2index.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "tag2index", ",", "network_builder", ")", ":", "\n", "        ", "self", ".", "network_builder", "=", "network_builder", "\n", "self", ".", "tag2index", "=", "tag2index", "\n", "self", ".", "index2tag", "=", "{", "self", ".", "tag2index", "[", "t", "]", ":", "t", "for", "t", "in", "self", ".", "tag2index", ".", "keys", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.FFSequencePredictor.prune_softmax": [[62, 72], ["mnnl.is_in_dict", "len", "mnnl.FFSequencePredictor.index2tag.keys", "mnnl.is_in_dict"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.is_in_dict", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.is_in_dict"], ["", "def", "prune_softmax", "(", "self", ",", "softmax_distr", ",", "word", ",", "dictionary", ")", ":", "\n", "## implement type-constraint decoding", "\n", "        ", "if", "is_in_dict", "(", "word", ",", "dictionary", ")", ":", "\n", "            ", "allowed_tag_indices", "=", "[", "self", ".", "tag2index", "[", "tag", "]", "for", "tag", "in", "is_in_dict", "(", "word", ",", "dictionary", ")", "if", "tag", "in", "self", ".", "tag2index", "]", "\n", "if", "len", "(", "allowed_tag_indices", ")", ">", "1", ":", "\n", "                ", "for", "tag_idx", "in", "self", ".", "index2tag", ".", "keys", "(", ")", ":", "\n", "                    ", "if", "tag_idx", "not", "in", "allowed_tag_indices", ":", "\n", "                        ", "softmax_distr", "[", "tag_idx", "]", "=", "0", "\n", "#                        print(len([x for x in softmax_distr if x ==0]))", "\n", "", "", "", "", "return", "softmax_distr", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.FFSequencePredictor.predict_sequence": [[73, 93], ["mnnl.FFSequencePredictor.network_builder", "array.array", "array.array", "_dynet.esum", "enumerate", "o.npvalue", "mnnl.FFSequencePredictor.prune_softmax", "pred_tags.append", "numpy.max", "mnnl.pick_neg_log", "o.npvalue", "zip", "numpy.argmax", "numpy.argmax", "o.npvalue"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.FFSequencePredictor.prune_softmax", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.pick_neg_log"], ["", "def", "predict_sequence", "(", "self", ",", "seq", ",", "inputs", ",", "train", "=", "False", ",", "output_confidences", "=", "False", ",", "unk_tag", "=", "None", ",", "dictionary", "=", "None", ",", "type_constraint", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "output", "=", "[", "self", ".", "network_builder", "(", "x", ",", "**", "kwargs", ")", "for", "x", "in", "inputs", "]", "\n", "if", "not", "train", ":", "\n", "            ", "if", "dictionary", "and", "type_constraint", ":", "# to type constraint decoding only during testing", "\n", "                ", "pred_tags", "=", "[", "]", "\n", "for", "i", ",", "o", "in", "enumerate", "(", "output", ")", ":", "\n", "                    ", "softmax_distr", "=", "o", ".", "npvalue", "(", ")", "\n", "word", "=", "seq", ".", "words", "[", "i", "]", "\n", "softmax_distr", "=", "self", ".", "prune_softmax", "(", "softmax_distr", ",", "word", ",", "dictionary", ")", "\n", "tag_best", "=", "self", ".", "index2tag", "[", "np", ".", "argmax", "(", "softmax_distr", ")", "]", "\n", "pred_tags", ".", "append", "(", "tag_best", ")", "\n", "", "seq", ".", "pred_tags", "=", "pred_tags", "\n", "", "else", ":", "\n", "                ", "seq", ".", "pred_tags", "=", "[", "self", ".", "index2tag", "[", "np", ".", "argmax", "(", "o", ".", "npvalue", "(", ")", ")", "]", "for", "o", "in", "output", "]", "# logprobs to indices", "\n", "", "", "if", "output_confidences", ":", "\n", "            ", "seq", ".", "tag_confidences", "=", "array", ".", "array", "(", "'f'", ",", "[", "np", ".", "max", "(", "o", ".", "npvalue", "(", ")", ")", "for", "o", "in", "output", "]", ")", "\n", "", "if", "train", ":", "\n", "# return loss per tag", "\n", "            ", "gold_tag_indices", "=", "array", ".", "array", "(", "'I'", ",", "[", "self", ".", "tag2index", "[", "t", "]", "for", "t", "in", "seq", ".", "tags", "]", ")", "\n", "return", "dynet", ".", "esum", "(", "[", "pick_neg_log", "(", "pred", ",", "gold", ")", "for", "pred", ",", "gold", "in", "zip", "(", "output", ",", "gold_tag_indices", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.FFSequencePredictor.save_parameters": [[94, 96], ["None"], "methods", ["None"], ["", "", "def", "save_parameters", "(", "self", ",", "out_filename", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.__init__": [[101, 110], ["model.add_lookup_parameters", "mnnl.CRFSequencePredictor.tag2index.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "num_tags", ",", "tag2index", ",", "network_builder", ",", "viterbi_loss", "=", "False", ")", ":", "\n", "        ", "self", ".", "network_builder", "=", "network_builder", "# the per-class layers", "\n", "self", ".", "tag2index", "=", "tag2index", "\n", "self", ".", "index2tag", "=", "{", "self", ".", "tag2index", "[", "t", "]", ":", "t", "for", "t", "in", "self", ".", "tag2index", ".", "keys", "(", ")", "}", "\n", "self", ".", "viterbi_loss", "=", "viterbi_loss", "\n", "\n", "self", ".", "num_tags", "=", "num_tags", "\n", "# Transition matrix for tagging layer, transitioning *to* i *from* j.", "\n", "self", ".", "trans_mat", "=", "model", ".", "add_lookup_parameters", "(", "(", "num_tags", ",", "num_tags", ")", ")", "# tags x tags", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.save_parameters": [[111, 124], ["open", "mnnl.CRFSequencePredictor.index2tag.keys", "open.close", "print", "mnnl.CRFSequencePredictor.index2tag.keys", "open.write", "str", "tag2tag_expression.npvalue"], "methods", ["None"], ["", "def", "save_parameters", "(", "self", ",", "out_filename", ")", ":", "\n", "# save transition matrix", "\n", "        ", "OUT", "=", "open", "(", "out_filename", "+", "\".trans.mat\"", ",", "\"w\"", ")", "\n", "for", "tag", "in", "self", ".", "index2tag", ".", "keys", "(", ")", ":", "\n", "            ", "for", "tag_prev", "in", "self", ".", "index2tag", ".", "keys", "(", ")", ":", "\n", "                ", "tag2tag_expression", "=", "self", ".", "trans_mat", "[", "tag_prev", "]", "[", "tag", "]", "\n", "tag_prev_name", "=", "self", ".", "index2tag", "[", "tag_prev", "]", "\n", "tag_i_name", "=", "self", ".", "index2tag", "[", "tag", "]", "\n", "OUT", ".", "write", "(", "\"{} {} {}\\n\"", ".", "format", "(", "tag_prev_name", ",", "tag_i_name", ",", "\" \"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "tag2tag_expression", ".", "npvalue", "(", ")", "]", ")", ")", ")", "\n", "", "", "OUT", ".", "close", "(", ")", "\n", "\n", "#np.savetxt(out_filename+'.matrix.out', self.trans_mat.npvalue(), delimiter=',')", "\n", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.predict_sequence": [[125, 147], ["mnnl.CRFSequencePredictor.network_builder", "mnnl.CRFSequencePredictor.viterbi", "array.array", "mnnl.CRFSequencePredictor.score_sentence", "print", "mnnl.CRFSequencePredictor.viterbi", "mnnl.CRFSequencePredictor.forward"], "methods", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.viterbi", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.score_sentence", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.viterbi", "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.forward"], ["", "def", "predict_sequence", "(", "self", ",", "seq", ",", "inputs", ",", "train", "=", "False", ",", "output_confidences", "=", "False", ",", "unk_tag", "=", "None", ",", "dictionary", "=", "None", ",", "type_constraint", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "score_vecs", "=", "[", "self", ".", "network_builder", "(", "x", ",", "**", "kwargs", ")", "for", "x", "in", "inputs", "]", "\n", "\n", "if", "not", "train", ":", "\n", "#pred_tag_indices = self.viterbi(start_b, T, end_b, score_vecs)", "\n", "            ", "pred_tag_indices", ",", "tag_scores", "=", "self", ".", "viterbi", "(", "score_vecs", ",", "unk_tag", "=", "unk_tag", ",", "dictionary", "=", "dictionary", ")", "\n", "seq", ".", "pred_tags", "=", "[", "self", ".", "index2tag", "[", "t", "]", "for", "t", "in", "pred_tag_indices", "]", "\n", "if", "output_confidences", ":", "\n", "                ", "print", "(", "\"not implemented\"", ")", "\n", "", "return", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "viterbi_loss", ":", "\n", "                ", "pred_tag_indices", ",", "path_score", "=", "self", ".", "viterbi", "(", "score_vecs", ")", "\n", "instance_score", "=", "path_score", "#viterbi score", "\n", "", "else", ":", "\n", "                ", "forward_score", "=", "self", ".", "forward", "(", "score_vecs", ")", "\n", "instance_score", "=", "forward_score", "\n", "# return loss", "\n", "", "gold_tag_indices", "=", "array", ".", "array", "(", "'I'", ",", "[", "self", ".", "tag2index", "[", "t", "]", "for", "t", "in", "seq", ".", "tags", "]", ")", "\n", "# decode CRF", "\n", "gold_score", "=", "self", ".", "score_sentence", "(", "score_vecs", ",", "gold_tag_indices", ")", "\n", "return", "instance_score", "-", "gold_score", "\n", "# return normalizer - gold_score", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.score_sentence": [[150, 160], ["tags.insert", "_dynet.scalarInput", "enumerate", "_dynet.pick", "len", "len", "_dynet.pick", "_dynet.pick"], "methods", ["None"], ["", "", "def", "score_sentence", "(", "self", ",", "score_vecs", ",", "tags", ")", ":", "\n", "        ", "assert", "(", "len", "(", "score_vecs", ")", "==", "len", "(", "tags", ")", ")", "\n", "tags", ".", "insert", "(", "0", ",", "START_TAG", ")", "# add start", "\n", "total", "=", "dynet", ".", "scalarInput", "(", ".0", ")", "\n", "for", "i", ",", "obs", "in", "enumerate", "(", "score_vecs", ")", ":", "\n", "# transition to next from i and emission", "\n", "            ", "next_tag", "=", "tags", "[", "i", "+", "1", "]", "\n", "total", "+=", "dynet", ".", "pick", "(", "self", ".", "trans_mat", "[", "next_tag", "]", ",", "tags", "[", "i", "]", ")", "+", "dynet", ".", "pick", "(", "obs", ",", "next_tag", ")", "\n", "", "total", "+=", "dynet", ".", "pick", "(", "self", ".", "trans_mat", "[", "END_TAG", "]", ",", "tags", "[", "-", "1", "]", ")", "\n", "return", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.viterbi": [[162, 202], ["_dynet.inputVector", "terminal_expr.npvalue", "numpy.argmax", "_dynet.pick", "reversed", "best_path.pop", "best_path.reverse", "range", "backpointers.append", "best_path.append", "range", "next_tag_expr.npvalue", "numpy.argmax", "bptrs_t.append", "vvars_t.append", "_dynet.concatenate", "_dynet.pick", "numpy.argmax", "numpy.argmax"], "methods", ["None"], ["", "def", "viterbi", "(", "self", ",", "observations", ",", "unk_tag", "=", "None", ",", "dictionary", "=", "None", ")", ":", "\n", "#if dictionary:", "\n", "#    raise NotImplementedError(\"type constraints not yet implemented for CRF\")", "\n", "        ", "backpointers", "=", "[", "]", "\n", "init_vvars", "=", "[", "-", "1e10", "]", "*", "self", ".", "num_tags", "\n", "init_vvars", "[", "START_TAG", "]", "=", "0", "# <Start> has all the probability", "\n", "for_expr", "=", "dynet", ".", "inputVector", "(", "init_vvars", ")", "\n", "trans_exprs", "=", "[", "self", ".", "trans_mat", "[", "idx", "]", "for", "idx", "in", "range", "(", "self", ".", "num_tags", ")", "]", "\n", "for", "obs", "in", "observations", ":", "\n", "            ", "bptrs_t", "=", "[", "]", "\n", "vvars_t", "=", "[", "]", "\n", "for", "next_tag", "in", "range", "(", "self", ".", "num_tags", ")", ":", "\n", "                ", "next_tag_expr", "=", "for_expr", "+", "trans_exprs", "[", "next_tag", "]", "\n", "next_tag_arr", "=", "next_tag_expr", ".", "npvalue", "(", ")", "\n", "best_tag_id", "=", "np", ".", "argmax", "(", "next_tag_arr", ")", "\n", "if", "unk_tag", ":", "\n", "                    ", "best_tag", "=", "self", ".", "index2tag", "[", "best_tag_id", "]", "\n", "if", "best_tag", "==", "unk_tag", ":", "\n", "                        ", "next_tag_arr", "[", "np", ".", "argmax", "(", "next_tag_arr", ")", "]", "=", "0", "# set to 0", "\n", "best_tag_id", "=", "np", ".", "argmax", "(", "next_tag_arr", ")", "# get second best", "\n", "\n", "", "", "bptrs_t", ".", "append", "(", "best_tag_id", ")", "\n", "vvars_t", ".", "append", "(", "dynet", ".", "pick", "(", "next_tag_expr", ",", "best_tag_id", ")", ")", "\n", "", "for_expr", "=", "dynet", ".", "concatenate", "(", "vvars_t", ")", "+", "obs", "\n", "backpointers", ".", "append", "(", "bptrs_t", ")", "\n", "# Perform final transition to terminal", "\n", "", "terminal_expr", "=", "for_expr", "+", "trans_exprs", "[", "END_TAG", "]", "\n", "terminal_arr", "=", "terminal_expr", ".", "npvalue", "(", ")", "\n", "best_tag_id", "=", "np", ".", "argmax", "(", "terminal_arr", ")", "\n", "path_score", "=", "dynet", ".", "pick", "(", "terminal_expr", ",", "best_tag_id", ")", "\n", "# Reverse over the backpointers to get the best path", "\n", "best_path", "=", "[", "best_tag_id", "]", "# Start with the tag that was best for terminal", "\n", "for", "bptrs_t", "in", "reversed", "(", "backpointers", ")", ":", "\n", "            ", "best_tag_id", "=", "bptrs_t", "[", "best_tag_id", "]", "\n", "best_path", ".", "append", "(", "best_tag_id", ")", "\n", "", "start", "=", "best_path", ".", "pop", "(", ")", "# Remove the start symbol", "\n", "best_path", ".", "reverse", "(", ")", "\n", "assert", "start", "==", "START_TAG", "\n", "# Return best path and best path's score", "\n", "return", "best_path", ",", "path_score", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.CRFSequencePredictor.forward": [[203, 225], ["_dynet.inputVector", "mnnl.CRFSequencePredictor.forward.log_sum_exp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "observations", ")", ":", "\n", "# calculate forward pass", "\n", "        ", "def", "log_sum_exp", "(", "scores", ")", ":", "\n", "            ", "npval", "=", "scores", ".", "npvalue", "(", ")", "\n", "argmax_score", "=", "np", ".", "argmax", "(", "npval", ")", "\n", "max_score_expr", "=", "dynet", ".", "pick", "(", "scores", ",", "argmax_score", ")", "\n", "max_score_expr_broadcast", "=", "dynet", ".", "concatenate", "(", "[", "max_score_expr", "]", "*", "self", ".", "num_tags", ")", "\n", "return", "max_score_expr", "+", "dynet", ".", "logsumexp_dim", "(", "(", "scores", "-", "max_score_expr_broadcast", ")", ",", "0", ")", "\n", "\n", "", "init_alphas", "=", "[", "-", "1e10", "]", "*", "self", ".", "num_tags", "\n", "init_alphas", "[", "START_TAG", "]", "=", "0", "\n", "for_expr", "=", "dynet", ".", "inputVector", "(", "init_alphas", ")", "\n", "for", "obs", "in", "observations", ":", "\n", "            ", "alphas_t", "=", "[", "]", "\n", "for", "next_tag", "in", "range", "(", "self", ".", "num_tags", ")", ":", "\n", "                ", "obs_broadcast", "=", "dynet", ".", "concatenate", "(", "[", "dynet", ".", "pick", "(", "obs", ",", "next_tag", ")", "]", "*", "self", ".", "num_tags", ")", "\n", "next_tag_expr", "=", "for_expr", "+", "self", ".", "trans_mat", "[", "next_tag", "]", "+", "obs_broadcast", "\n", "alphas_t", ".", "append", "(", "log_sum_exp", "(", "next_tag_expr", ")", ")", "\n", "", "for_expr", "=", "dynet", ".", "concatenate", "(", "alphas_t", ")", "\n", "", "terminal_expr", "=", "for_expr", "+", "self", ".", "trans_mat", "[", "END_TAG", "]", "\n", "alpha", "=", "log_sum_exp", "(", "terminal_expr", ")", "\n", "return", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.RNNSequencePredictor.__init__": [[228, 233], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "rnn_builder", ")", ":", "\n", "        ", "\"\"\"\n        rnn_builder: a LSTMBuilder/SimpleRNNBuilder or GRU builder object\n        \"\"\"", "\n", "self", ".", "builder", "=", "rnn_builder", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.RNNSequencePredictor.predict_sequence": [[234, 237], ["mnnl.RNNSequencePredictor.builder.initial_state", "mnnl.RNNSequencePredictor.transduce"], "methods", ["None"], ["", "def", "predict_sequence", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "s_init", "=", "self", ".", "builder", ".", "initial_state", "(", ")", "\n", "return", "s_init", ".", "transduce", "(", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.BiRNNSequencePredictor.__init__": [[241, 244], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "f_builder", ",", "b_builder", ")", ":", "\n", "        ", "self", ".", "f_builder", "=", "f_builder", "\n", "self", ".", "b_builder", "=", "b_builder", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.BiRNNSequencePredictor.predict_sequence": [[245, 251], ["mnnl.BiRNNSequencePredictor.f_builder.initial_state", "mnnl.BiRNNSequencePredictor.b_builder.initial_state", "mnnl.BiRNNSequencePredictor.transduce", "mnnl.BiRNNSequencePredictor.transduce", "reversed"], "methods", ["None"], ["", "def", "predict_sequence", "(", "self", ",", "f_inputs", ",", "b_inputs", ")", ":", "\n", "        ", "f_init", "=", "self", ".", "f_builder", ".", "initial_state", "(", ")", "\n", "b_init", "=", "self", ".", "b_builder", ".", "initial_state", "(", ")", "\n", "forward_sequence", "=", "f_init", ".", "transduce", "(", "f_inputs", ")", "\n", "backward_sequence", "=", "b_init", ".", "transduce", "(", "reversed", "(", "b_inputs", ")", ")", "\n", "return", "forward_sequence", ",", "backward_sequence", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.Layer.__init__": [[255, 269], ["model.add_parameters", "model.add_parameters", "print", "model.add_parameters", "model.add_parameters"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "in_dim", ",", "output_dim", ",", "activation", "=", "dynet", ".", "tanh", ",", "mlp", "=", "0", ",", "mlp_activation", "=", "dynet", ".", "rectify", ")", ":", "\n", "# if mlp > 0, add a hidden layer of that dimension", "\n", "        ", "self", ".", "act", "=", "activation", "\n", "self", ".", "mlp", "=", "mlp", "\n", "if", "mlp", ":", "\n", "            ", "print", "(", "'>>> use mlp with dim {} ({})<<<'", ".", "format", "(", "mlp", ",", "mlp_activation", ")", ")", "\n", "mlp_dim", "=", "mlp", "\n", "self", ".", "mlp_activation", "=", "mlp_activation", "\n", "self", ".", "W_mlp", "=", "model", ".", "add_parameters", "(", "(", "mlp_dim", ",", "in_dim", ")", ")", "\n", "self", ".", "b_mlp", "=", "model", ".", "add_parameters", "(", "(", "mlp_dim", ")", ")", "\n", "", "else", ":", "\n", "            ", "mlp_dim", "=", "in_dim", "\n", "", "self", ".", "W", "=", "model", ".", "add_parameters", "(", "(", "output_dim", ",", "mlp_dim", ")", ")", "\n", "self", ".", "b", "=", "model", ".", "add_parameters", "(", "(", "output_dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.Layer.__call__": [[270, 286], ["act", "_dynet.exp", "_dynet.cdiv", "mnnl.Layer.act", "_dynet.sum_elems"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ",", "soft_labels", "=", "False", ",", "temperature", "=", "None", ",", "train", "=", "False", ")", ":", "\n", "        ", "if", "self", ".", "mlp", ":", "\n", "            ", "act", "=", "self", ".", "mlp_activation", "\n", "x_in", "=", "act", "(", "self", ".", "W_mlp", "*", "x", "+", "self", ".", "b_mlp", ")", "\n", "", "else", ":", "\n", "            ", "x_in", "=", "x", "\n", "\n", "", "logits", "=", "self", ".", "W", "*", "x_in", "+", "self", ".", "b", "\n", "if", "soft_labels", "and", "temperature", ":", "\n", "# calculate the soft labels smoothed with the temperature", "\n", "# see Distilling the Knowledge in a Neural Network", "\n", "            ", "elems", "=", "dynet", ".", "exp", "(", "logits", "/", "temperature", ")", "\n", "return", "dynet", ".", "cdiv", "(", "elems", ",", "dynet", ".", "sum_elems", "(", "elems", ")", ")", "\n", "", "if", "self", ".", "act", ":", "\n", "            ", "return", "self", ".", "act", "(", "logits", ")", "\n", "", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.init_dynet": [[11, 21], ["_dynet.DynetParams", "dynet.DynetParams.from_args", "dynet.DynetParams.set_random_seed", "dynet.DynetParams.init"], "function", ["None"], ["def", "init_dynet", "(", "seed", ")", ":", "\n", "    ", "\"\"\"initialize DyNet\"\"\"", "\n", "dyparams", "=", "dynet", ".", "DynetParams", "(", ")", "\n", "# Fetch the command line arguments (optional)", "\n", "dyparams", ".", "from_args", "(", ")", "\n", "# Set some parameters manualy (see the command line arguments documentation)", "\n", "dyparams", ".", "set_random_seed", "(", "seed", ")", "\n", "# Initialize with the given parameters", "\n", "dyparams", ".", "init", "(", ")", "\n", "return", "dyparams", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.pick_neg_log": [[23, 25], ["_dynet.log", "_dynet.pick"], "function", ["None"], ["", "def", "pick_neg_log", "(", "pred", ",", "gold", ")", ":", "\n", "    ", "return", "-", "dynet", ".", "log", "(", "dynet", ".", "pick", "(", "pred", ",", "gold", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.lib.mnnl.is_in_dict": [[27, 34], ["word.lower", "word.lower"], "function", ["None"], ["", "def", "is_in_dict", "(", "word", ",", "dictionary", ")", ":", "\n", "    ", "\"\"\" dictionary lookup \"\"\"", "\n", "if", "word", "in", "dictionary", ":", "\n", "        ", "return", "dictionary", "[", "word", "]", "\n", "", "if", "word", ".", "lower", "(", ")", "in", "dictionary", ":", "\n", "        ", "return", "dictionary", "[", "word", ".", "lower", "(", ")", "]", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.embeds.transf.sentToEmbed": [[19, 37], ["tokenizer", "enumerate", "startOfWords.append", "model"], "function", ["None"], ["def", "sentToEmbed", "(", "sent", ")", ":", "\n", "    ", "tokens_pt", "=", "tokenizer", "(", "sent", ",", "return_tensors", "=", "\"pt\"", ",", "return_offsets_mapping", "=", "True", ",", "is_split_into_words", "=", "True", ")", "\n", "\n", "# first dimension=first sent. Second dimensions = remove special tokens", "\n", "offsets", "=", "tokens_pt", "[", "'offset_mapping'", "]", "[", "0", "]", "[", "1", ":", "-", "1", "]", "\n", "\n", "# first dimension, get full output (not pool) second dimension, get first sentence, third dimension remove special tokens", "\n", "outputs", "=", "model", "(", "tokens_pt", "[", "'input_ids'", "]", ")", "[", "0", "]", "[", "0", "]", "[", "1", ":", "-", "1", "]", "\n", "# size of outputs is now the number of wordpieces without special tokens, 2nd dimensions is embeddings size", "\n", "\n", "# get all indexes that should be kept", "\n", "startOfWords", "=", "[", "]", "\n", "for", "offsetIdx", ",", "offset", "in", "enumerate", "(", "offsets", ")", ":", "\n", "        ", "if", "offset", "[", "0", "]", "==", "0", ":", "\n", "            ", "startOfWords", ".", "append", "(", "offsetIdx", ")", "\n", "\n", "# keep only the first embedding of each word", "\n", "", "", "return", "outputs", "[", "startOfWords", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.embeds.poly.loadEmbs": [[8, 15], ["print", "pickle.load", "range", "open", "len"], "function", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.load"], ["", "def", "loadEmbs", "(", "path", ")", ":", "\n", "    ", "print", "(", "'Loading '", "+", "path", "+", "'...'", ")", "\n", "words", ",", "vect", "=", "pickle", ".", "load", "(", "open", "(", "path", ",", "'rb'", ")", ",", "encoding", "=", "'latin1'", ")", "\n", "embs", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "words", ")", ")", ":", "\n", "        ", "embs", "[", "words", "[", "i", "]", "]", "=", "vect", "[", "i", "]", "\n", "", "return", "embs", "\n", "", "embs", "=", "loadEmbs", "(", "sys", ".", "argv", "[", "1", "]", ")", "\n"]], "home.repos.pwc.inspect_result.bplank_bilstm-aux.embeds.poly.conv": [[6, 24], ["print", "pickle.load", "print", "print", "open", "range", "open.close", "os.remove", "embeds.endswith", "open", "len", "len", "print", "len", "open.write", "open.write", "str", "embeds.replace", "embeds.replace", "open.write", "str", "len", "len", "str", "str", "str", "len", "len"], "function", ["home.repos.pwc.inspect_result.bplank_bilstm-aux.src.structbilty.load"], ["exit", "(", "0", ")", "\n", "\n", "", "def", "loadEmbs", "(", "path", ")", ":", "\n", "    ", "print", "(", "'Loading '", "+", "path", "+", "'...'", ")", "\n", "words", ",", "vect", "=", "pickle", ".", "load", "(", "open", "(", "path", ",", "'rb'", ")", ",", "encoding", "=", "'latin1'", ")", "\n", "embs", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "words", ")", ")", ":", "\n", "        ", "embs", "[", "words", "[", "i", "]", "]", "=", "vect", "[", "i", "]", "\n", "", "return", "embs", "\n", "", "embs", "=", "loadEmbs", "(", "sys", ".", "argv", "[", "1", "]", ")", "\n", "\n", "unk", "=", "'<UNK>'", "\n", "\n", "outFile", "=", "open", "(", "sys", ".", "argv", "[", "2", "]", "+", "'.poly'", ",", "'w'", ")", "\n", "curSent", "=", "''", "\n", "for", "line", "in", "open", "(", "sys", ".", "argv", "[", "2", "]", ")", ":", "\n", "    ", "if", "len", "(", "line", ")", "<", "2", ":", "\n", "        ", "outFile", ".", "write", "(", "curSent", "+", "'\\n'", ")", "\n", "curSent", "=", "''", "\n"]]}