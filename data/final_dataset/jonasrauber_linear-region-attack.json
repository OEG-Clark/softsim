{"home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.main.main": [[11, 48], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "logging.getLogger().setLevel", "lr_attack.run", "os.path.exists", "os.path.dirname", "logging.getLogger", "logging.warning", "examples.get_example", "os.makedirs", "open", "pickle.dump", "len", "os.path.exists"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.run", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.get_example"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'model'", ",", "help", "=", "'name of the model to attack'", ")", "\n", "parser", ".", "add_argument", "(", "'--image'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'--accuracy'", ",", "action", "=", "'store_true'", ",", "help", "=", "'first determines the accuracy of the model'", ")", "\n", "parser", ".", "add_argument", "(", "'--save'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "help", "=", "'filename to save result to'", ")", "\n", "\n", "# hyperparameters", "\n", "parser", ".", "add_argument", "(", "'--regions'", ",", "type", "=", "int", ",", "default", "=", "400", ")", "\n", "parser", ".", "add_argument", "(", "'--iterations'", ",", "type", "=", "int", ",", "default", "=", "500", ")", "\n", "parser", ".", "add_argument", "(", "'--gamma'", ",", "type", "=", "int", ",", "default", "=", "6", ",", "help", "=", "'hyperparam of region selection'", ")", "\n", "parser", ".", "add_argument", "(", "'--misc-factor'", ",", "type", "=", "float", ",", "default", "=", "75.", ")", "\n", "\n", "# advanced control over certain aspects (only if you know what you are doing)", "\n", "parser", ".", "add_argument", "(", "'--nth-likely-class-starting-point'", ",", "type", "=", "int", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--no-line-search'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--max-other-classes'", ",", "type", "=", "int", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--no-normalization'", ",", "action", "=", "'store_true'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "logging", ".", "getLogger", "(", ")", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "\n", "if", "args", ".", "save", "is", "not", "None", ":", "\n", "        ", "if", "os", ".", "path", ".", "exists", "(", "args", ".", "save", ")", ":", "\n", "            ", "logging", ".", "warning", "(", "f'not runnning because results already exist: {args.save}'", ")", "\n", "return", "\n", "\n", "", "", "result", "=", "run", "(", "*", "get_example", "(", "args", ".", "model", ")", ",", "args", "=", "args", ")", "\n", "\n", "if", "args", ".", "save", "is", "not", "None", ":", "\n", "        ", "directory", "=", "os", ".", "path", ".", "dirname", "(", "args", ".", "save", ")", "\n", "if", "len", "(", "directory", ")", ">", "0", "and", "not", "os", ".", "path", ".", "exists", "(", "directory", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "directory", ")", "\n", "", "with", "open", "(", "args", ".", "save", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "result", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.accuracy": [[15, 23], ["len", "tqdm.trange", "len", "lr_attack.run.predict_class", "numpy.sum"], "function", ["None"], ["def", "accuracy", "(", "predict_class", ",", "images", ",", "labels", ",", "batch_size", "=", "100", ")", ":", "\n", "    ", "total", "=", "len", "(", "images", ")", "\n", "correct", "=", "0", "\n", "for", "i", "in", "tqdm", ".", "trange", "(", "0", ",", "len", "(", "images", ")", ",", "batch_size", ")", ":", "\n", "        ", "j", "=", "i", "+", "batch_size", "\n", "predicted_class", "=", "predict_class", "(", "images", "[", "i", ":", "j", "]", ")", "\n", "correct", "+=", "onp", ".", "sum", "(", "predicted_class", "==", "labels", "[", "i", ":", "j", "]", ")", "\n", "", "return", "correct", "/", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.l2_distance": [[25, 28], ["numpy.linalg.norm", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get"], "function", ["None"], ["", "def", "l2_distance", "(", "x0", ",", "x", ")", ":", "\n", "    ", "assert", "x0", ".", "shape", "==", "x", ".", "shape", "\n", "return", "onp", ".", "linalg", ".", "norm", "(", "jax", ".", "device_get", "(", "x0", ")", "-", "jax", ".", "device_get", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.misclassification_polytope": [[30, 46], ["jax.atleast_1d", "jax.atleast_1d", "jax.asarray().squeeze", "jax.asarray().squeeze", "utils.scatter", "utils.scatter", "jax.asarray", "jax.asarray", "jax.sum", "jax.atleast_2d", "jax.atleast_2d"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.scatter", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.scatter"], ["", "def", "misclassification_polytope", "(", "a", ",", "c", ",", "ls", ")", ":", "\n", "    ", "\"\"\"creates misclassification constraints\"\"\"", "\n", "assert", "a", ".", "ndim", "==", "2", "\n", "assert", "a", ".", "shape", "[", "0", "]", "==", "1", "# only batch size 1 is supported", "\n", "n_classes", "=", "a", ".", "shape", "[", "1", "]", "\n", "\n", "u", "=", "a", "[", ":", ",", "ls", "]", "-", "a", "[", ":", ",", "c", "]", "\n", "\n", "c", "=", "np", ".", "atleast_1d", "(", "np", ".", "asarray", "(", "[", "c", "]", ")", ".", "squeeze", "(", ")", ")", "\n", "ls", "=", "np", ".", "atleast_1d", "(", "np", ".", "asarray", "(", "[", "ls", "]", ")", ".", "squeeze", "(", ")", ")", "\n", "\n", "Av", "=", "lambda", "Vv", ":", "Vv", "[", ":", ",", "c", "]", "-", "Vv", "[", ":", ",", "ls", "]", "# noqa: E731", "\n", "vA", "=", "lambda", "v", ":", "(", "scatter", "(", "c", ",", "np", ".", "sum", "(", "np", ".", "atleast_2d", "(", "v", ")", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", ",", "n_classes", ")", "+", "# noqa: E731", "\n", "scatter", "(", "ls", ",", "-", "np", ".", "atleast_2d", "(", "v", ")", ",", "n_classes", ")", ")", "\n", "\n", "return", "Av", ",", "vA", ",", "u", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.relu_polytope": [[48, 65], ["jax.sign", "non_trivial.astype"], "function", ["None"], ["", "def", "relu_polytope", "(", "a", ",", "f", ")", ":", "\n", "    ", "\"\"\"creates polytope constraints\"\"\"", "\n", "sf", "=", "np", ".", "sign", "(", "f", ")", "\n", "nsf", "=", "-", "sf", "\n", "u", "=", "sf", "*", "a", "\n", "\n", "Av", "=", "lambda", "Vv", ":", "nsf", "*", "Vv", "# noqa: E731", "\n", "vA", "=", "lambda", "v", ":", "nsf", "*", "v", "# noqa: E731", "\n", "\n", "# Some of these constrains are always fulfilled and can be removed.", "\n", "non_trivial", "=", "sf", "!=", "0", "\n", "# create a vector with 0s for all non-trivial ones,", "\n", "# and inf for trivial ones", "\n", "trivial_inf", "=", "1", "/", "non_trivial", ".", "astype", "(", "np", ".", "float32", ")", "-", "1", "\n", "# make the upper bound of trivial ones infinity to make them least violated", "\n", "u", "=", "u", "+", "trivial_inf", "\n", "return", "Av", ",", "vA", ",", "u", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.get_other_classes": [[67, 72], ["random.shuffle", "range"], "function", ["None"], ["", "def", "get_other_classes", "(", "*", ",", "exclude", ",", "total", ",", "first", "=", "None", ")", ":", "\n", "    ", "rest", "=", "[", "x", "for", "x", "in", "range", "(", "total", ")", "if", "x", "!=", "exclude", "and", "x", "!=", "first", "]", "\n", "random", ".", "shuffle", "(", "rest", ")", "\n", "first", "=", "[", "]", "if", "first", "is", "None", "else", "[", "first", "]", "\n", "return", "first", "+", "rest", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.flatten": [[74, 82], ["isinstance", "isinstance", "lr_attack.flatten"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.flatten"], ["", "def", "flatten", "(", "x", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "        ", "for", "y", "in", "x", ":", "\n", "            ", "yield", "from", "flatten", "(", "y", ")", "\n", "", "", "else", ":", "\n", "        ", "assert", "isinstance", "(", "x", ",", "tuple", ")", "\n", "for", "y", "in", "x", ":", "\n", "            ", "yield", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.flatten_dims": [[84, 86], ["jax.reshape"], "function", ["None"], ["", "", "", "def", "flatten_dims", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "reshape", "(", "x", ",", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.layer_size": [[88, 91], ["None"], "function", ["None"], ["", "def", "layer_size", "(", "x", ")", ":", "\n", "    ", "_", ",", "n", "=", "x", ".", "shape", "\n", "return", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.flatten_predict": [[93, 103], ["functools.wraps", "predict", "list", "list", "jax.concatenate", "lr_attack.flatten", "map"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.flatten"], ["", "def", "flatten_predict", "(", "predict", ")", ":", "\n", "    ", "@", "wraps", "(", "predict", ")", "\n", "def", "flat_predict", "(", "x", ")", ":", "\n", "        ", "output", ",", "additional_outputs", "=", "predict", "(", "x", ")", "\n", "additional_outputs", "=", "list", "(", "flatten", "(", "additional_outputs", ")", ")", "\n", "additional_outputs", "=", "list", "(", "map", "(", "flatten_dims", ",", "additional_outputs", ")", ")", "\n", "additional_outputs", "=", "np", ".", "concatenate", "(", "additional_outputs", ",", "axis", "=", "-", "1", ")", "\n", "return", "output", ",", "additional_outputs", "\n", "\n", "", "return", "flat_predict", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.return_classes_logits_layer_sizes": [[105, 112], ["logging.info", "f", "list", "list", "list", "lr_attack.flatten", "map", "map", "jax.argmax"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.flatten"], ["", "def", "return_classes_logits_layer_sizes", "(", "f", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "logging", ".", "info", "(", "f'compiling return_classes_logits_layer_sizes'", ")", "\n", "logits", ",", "additional_outputs", "=", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "additional_outputs", "=", "list", "(", "flatten", "(", "additional_outputs", ")", ")", "\n", "additional_outputs", "=", "list", "(", "map", "(", "flatten_dims", ",", "additional_outputs", ")", ")", "\n", "rows_per_layer", "=", "list", "(", "map", "(", "layer_size", ",", "additional_outputs", ")", ")", "\n", "return", "np", ".", "argmax", "(", "logits", ",", "axis", "=", "-", "1", ")", ",", "logits", ",", "rows_per_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.generic_get_A": [[114, 170], ["jax.vjp", "jax.vjp", "functools.partial", "functools.partial.", "tuple", "lr_attack.misclassification_polytope", "lr_attack.relu_polytope", "v.reshape.reshape", "functools.partial.", "Av_misc", "Av_relu", "jax.concatenate", "r.reshape.squeeze", "vA_misc", "vA_relu", "vjp_fun", "r.reshape.reshape", "len", "zip"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.misclassification_polytope", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.relu_polytope"], ["", "def", "generic_get_A", "(", "predict", ",", "label", ",", "other_classes", ",", "xr", ",", "normalizer", ")", ":", "\n", "# linearize net around xr", "\n", "    ", "fxr", ",", "vjp_fun", "=", "jax", ".", "vjp", "(", "predict", ",", "xr", ")", "\n", "jvp_fun", "=", "partial", "(", "jax", ".", "jvp", ",", "predict", ",", "(", "xr", ",", ")", ")", "\n", "_", ",", "jxrp", "=", "jvp_fun", "(", "(", "xr", ",", ")", ")", "\n", "offset", "=", "tuple", "(", "fx", "-", "Jx", "for", "fx", ",", "Jx", "in", "zip", "(", "fxr", ",", "jxrp", ")", ")", "\n", "\n", "Av_misc", ",", "vA_misc", ",", "u_misc", "=", "misclassification_polytope", "(", "offset", "[", "0", "]", ",", "label", ",", "other_classes", ")", "\n", "Av_relu", ",", "vA_relu", ",", "u_relu", "=", "relu_polytope", "(", "offset", "[", "1", "]", ",", "fxr", "[", "1", "]", ")", "\n", "\n", "assert", "u_misc", ".", "ndim", "==", "u_relu", ".", "ndim", "==", "2", "\n", "assert", "u_misc", ".", "shape", "[", "0", "]", "==", "u_relu", ".", "shape", "[", "0", "]", "# batch dimension", "\n", "\n", "n_constraints", "=", "u_misc", ".", "shape", "[", "1", "]", "+", "u_relu", ".", "shape", "[", "1", "]", "\n", "\n", "if", "normalizer", "is", "not", "None", ":", "\n", "        ", "assert", "normalizer", ".", "shape", "==", "(", "n_constraints", ",", ")", "\n", "assert", "normalizer", ".", "dtype", "==", "np", ".", "float32", "\n", "\n", "", "_", ",", "N", "=", "u_misc", ".", "shape", "\n", "if", "normalizer", "is", "not", "None", ":", "\n", "        ", "u_misc", "=", "u_misc", "*", "normalizer", "[", ":", "N", "]", "\n", "u_relu", "=", "u_relu", "*", "normalizer", "[", "N", ":", "]", "\n", "\n", "", "def", "Adot", "(", "v", ")", ":", "\n", "        ", "v", "=", "v", ".", "reshape", "(", "(", "1", ",", ")", "+", "xr", ".", "shape", "[", "1", ":", "]", ")", "\n", "_", ",", "Vv", "=", "jvp_fun", "(", "(", "v", ",", ")", ")", "\n", "Vv_misc", ",", "Vv_relu", "=", "Vv", "\n", "r_misc", "=", "Av_misc", "(", "Vv_misc", ")", "\n", "r_relu", "=", "Av_relu", "(", "Vv_relu", ")", "\n", "assert", "r_misc", ".", "ndim", "==", "r_relu", ".", "ndim", "==", "2", "\n", "assert", "r_misc", ".", "shape", "[", "0", "]", "==", "r_relu", ".", "shape", "[", "0", "]", "# batch dimension", "\n", "r", "=", "np", ".", "concatenate", "(", "(", "r_misc", ",", "r_relu", ")", ",", "axis", "=", "1", ")", "\n", "r", "=", "r", ".", "squeeze", "(", "axis", "=", "0", ")", "\n", "assert", "r", ".", "shape", "==", "(", "n_constraints", ",", ")", "\n", "if", "normalizer", "is", "not", "None", ":", "\n", "            ", "r", "=", "normalizer", "*", "r", "\n", "", "return", "r", "\n", "\n", "", "def", "ATdot", "(", "v", ")", ":", "\n", "        ", "assert", "v", ".", "shape", "==", "(", "n_constraints", ",", ")", "\n", "v", "=", "v", "[", "onp", ".", "newaxis", "]", "\n", "if", "normalizer", "is", "not", "None", ":", "\n", "            ", "v", "=", "normalizer", "*", "v", "\n", "", "_", ",", "N", "=", "u_misc", ".", "shape", "\n", "assert", "v", ".", "ndim", "==", "2", "\n", "v_misc", ",", "v_relu", "=", "v", "[", ":", ",", ":", "N", "]", ",", "v", "[", ":", ",", "N", ":", "]", "\n", "v_misc", "=", "vA_misc", "(", "v_misc", ")", "\n", "v_relu", "=", "vA_relu", "(", "v_relu", ")", "\n", "v", "=", "(", "v_misc", ",", "v_relu", ")", "\n", "r", ",", "=", "vjp_fun", "(", "v", ")", "\n", "r", "=", "r", ".", "reshape", "(", "(", "-", "1", ",", ")", ")", "\n", "return", "r", "\n", "\n", "", "assert", "u_misc", ".", "shape", "[", "1", "]", "==", "len", "(", "other_classes", ")", "\n", "return", "Adot", ",", "ATdot", ",", "n_constraints", ",", "u_misc", ",", "u_relu", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.operator_norm_lower_bound": [[172, 187], ["functools.partial", "logging.info", "get_A", "xr.reshape", "jax.lax.fori_loop", "jax.lax.fori_loop", "lr_attack.generic_get_A.ATdot", "jax.linalg.norm", "lr_attack.generic_get_A.Adot"], "function", ["None"], ["", "@", "partial", "(", "jax", ".", "jit", ",", "static_argnums", "=", "(", "0", ",", ")", ")", "\n", "def", "operator_norm_lower_bound", "(", "get_A", ",", "xr", ",", "normalizer", ")", ":", "\n", "    ", "logging", ".", "info", "(", "'compiling operator_norm_lower_bound'", ")", "\n", "Adot", ",", "ATdot", ",", "_", ",", "_", ",", "_", "=", "get_A", "(", "xr", ",", "normalizer", ")", "\n", "\n", "def", "body_fun", "(", "i", ",", "state", ")", ":", "\n", "        ", "z", ",", "n", "=", "state", "\n", "u", "=", "ATdot", "(", "Adot", "(", "z", ")", ")", "\n", "n", "=", "np", ".", "linalg", ".", "norm", "(", "u", ")", "\n", "return", "u", "/", "n", ",", "n", "\n", "\n", "# z = np.ones_like(xr.reshape(-1))", "\n", "", "z", "=", "xr", ".", "reshape", "(", "-", "1", ")", "# a constant vector of e.g. ones fails if mean is subtracted", "\n", "_", ",", "n", "=", "jax", ".", "lax", ".", "fori_loop", "(", "0", ",", "20", ",", "body_fun", ",", "(", "z", ",", "0.", ")", ")", "\n", "return", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.init_region": [[189, 195], ["functools.partial", "logging.info", "get_A", "lr_attack.generic_get_A.Adot"], "function", ["None"], ["", "@", "partial", "(", "jax", ".", "jit", ",", "static_argnums", "=", "(", "0", ",", ")", ")", "\n", "def", "init_region", "(", "get_A", ",", "xr", ",", "normalizer", ",", "v", ")", ":", "\n", "    ", "logging", ".", "info", "(", "'compiling init_region'", ")", "\n", "Adot", ",", "_", ",", "_", ",", "u_misc", ",", "u_relu", "=", "get_A", "(", "xr", ",", "normalizer", ")", "\n", "Av", "=", "Adot", "(", "v", ")", "\n", "return", "Av", ",", "u_misc", ",", "u_relu", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.calculate_normalizer": [[197, 212], ["functools.partial", "logging.info", "get_A", "lr_attack.estimate_layer_norms", "zip", "jax.concatenate", "jax.ones", "len", "len", "np.ones.append", "jax.ones"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.estimate_layer_norms"], ["", "@", "partial", "(", "jax", ".", "jit", ",", "static_argnums", "=", "(", "0", ",", "2", ",", "3", ")", ")", "\n", "def", "calculate_normalizer", "(", "get_A", ",", "xr", ",", "n_constraints", ",", "rows_per_layer", ",", "*", ",", "k", ",", "normalizer", "=", "None", ",", "misc_factor", "=", "1.", ")", ":", "\n", "    ", "logging", ".", "info", "(", "'compiling calculate_normalizer'", ")", "\n", "if", "normalizer", "is", "None", ":", "\n", "        ", "normalizer", "=", "np", ".", "ones", "(", "(", "n_constraints", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "_", ",", "ATdot", ",", "_", ",", "u_misc", ",", "u_relu", "=", "get_A", "(", "xr", ",", "normalizer", ")", "\n", "_", ",", "n_misc", "=", "u_misc", ".", "shape", "\n", "misc_norms", ",", "layer_norms", "=", "estimate_layer_norms", "(", "ATdot", ",", "n_misc", ",", "rows_per_layer", ",", "k", "=", "k", ")", "\n", "assert", "misc_norms", ".", "shape", "==", "(", "n_misc", ",", ")", "\n", "normalizer", "=", "[", "misc_factor", "/", "misc_norms", "]", "\n", "assert", "len", "(", "rows_per_layer", ")", "==", "len", "(", "layer_norms", ")", "\n", "for", "n", ",", "norm", "in", "zip", "(", "rows_per_layer", ",", "layer_norms", ")", ":", "\n", "        ", "normalizer", ".", "append", "(", "np", ".", "ones", "(", "(", "n", ",", ")", ")", "/", "norm", ")", "\n", "", "normalizer", "=", "np", ".", "concatenate", "(", "normalizer", ")", "\n", "return", "normalizer", ",", "misc_norms", ",", "layer_norms", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.estimate_layer_norms": [[214, 251], ["list", "logging.info", "numpy.zeros", "enumerate", "jax.vmap", "jax.vmap", "jax.vmap.", "jax.linalg.norm", "range", "range", "list.extend", "len", "jax.mean", "layer_norms.append", "random.sample", "len", "len", "range", "len"], "function", ["None"], ["", "def", "estimate_layer_norms", "(", "ATdot", ",", "n_misc", ",", "rows_per_layer", ",", "*", ",", "k", ")", ":", "\n", "    ", "\"\"\"for each layer, samples k of the rows of A corresponding to that\n    layer as well as all rows corresponding to the n logits and then\n    estimates the norm of rows of A corresponding to each layer\"\"\"", "\n", "\n", "# TODO: consider using jax.random and thus drawing new samples every time;", "\n", "# right now we do the whole onehot vector creation statically", "\n", "indices", "=", "list", "(", "range", "(", "n_misc", ")", ")", "\n", "offset", "=", "n_misc", "\n", "for", "layer_size", "in", "rows_per_layer", ":", "\n", "        ", "indices", ".", "extend", "(", "random", ".", "sample", "(", "range", "(", "offset", ",", "offset", "+", "layer_size", ")", ",", "k", ")", ")", "\n", "offset", "+=", "layer_size", "\n", "\n", "", "logging", ".", "info", "(", "f'{len(indices)} randomly selected rows of A: {indices}'", ")", "\n", "\n", "n_constraints", "=", "offset", "\n", "\n", "vs", "=", "onp", ".", "zeros", "(", "(", "len", "(", "indices", ")", ",", "n_constraints", ")", ",", "dtype", "=", "onp", ".", "float32", ")", "\n", "for", "row", ",", "col", "in", "enumerate", "(", "indices", ")", ":", "\n", "        ", "vs", "[", "row", ",", "col", "]", "=", "1.", "\n", "\n", "", "ATdot", "=", "jax", ".", "vmap", "(", "ATdot", ")", "\n", "rows", "=", "ATdot", "(", "vs", ")", "\n", "assert", "rows", ".", "ndim", "==", "2", "\n", "\n", "norms", "=", "np", ".", "linalg", ".", "norm", "(", "rows", ",", "axis", "=", "-", "1", ")", "\n", "\n", "# TODO: use median once supported by jax.numpy:", "\n", "# https://github.com/google/jax/issues/70", "\n", "\n", "layer_norms", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_misc", ",", "len", "(", "norms", ")", ",", "k", ")", ":", "\n", "        ", "assert", "i", "+", "k", "<=", "len", "(", "norms", ")", "\n", "m", "=", "np", ".", "mean", "(", "norms", "[", "i", ":", "i", "+", "k", "]", ")", "\n", "layer_norms", ".", "append", "(", "m", ")", "\n", "\n", "", "return", "norms", "[", ":", "n_misc", "]", ",", "layer_norms", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.line_search": [[253, 281], ["jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "numpy.flatnonzero", "logging.info", "utils.is_device_array", "utils.is_device_array", "s.reshape", "lr_attack.run.predict_class", "numpy.linspace"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array"], ["", "def", "line_search", "(", "predict_class", ",", "x0", ",", "label", ",", "x", ",", "minimum", "=", "0.", ",", "maximum", "=", "1.", ",", "num", "=", "100", ",", "s", "=", "None", ")", ":", "\n", "    ", "x", "=", "jax", ".", "device_get", "(", "x", ")", "\n", "\n", "assert", "not", "is_device_array", "(", "x0", ")", "\n", "assert", "not", "is_device_array", "(", "label", ")", "\n", "\n", "assert", "x0", ".", "shape", "==", "x", ".", "shape", "\n", "assert", "x0", ".", "shape", "[", "0", "]", "==", "1", "# batch dimension", "\n", "\n", "if", "s", "is", "None", ":", "\n", "        ", "s", "=", "onp", ".", "linspace", "(", "minimum", ",", "maximum", ",", "num", "=", "num", "+", "1", ")", "[", "1", ":", "]", "\n", "\n", "", "p", "=", "x", "-", "x0", "\n", "ps", "=", "s", ".", "reshape", "(", "(", "-", "1", ",", ")", "+", "(", "1", ",", ")", "*", "(", "p", ".", "ndim", "-", "1", ")", ")", "*", "p", "\n", "xs", "=", "x0", "+", "ps", "\n", "\n", "assert", "xs", ".", "shape", "[", "1", ":", "]", "==", "x0", ".", "shape", "[", "1", ":", "]", "\n", "\n", "classes", "=", "jax", ".", "device_get", "(", "predict_class", "(", "xs", ")", ")", "\n", "assert", "classes", ".", "ndim", "==", "1", "\n", "indices", "=", "onp", ".", "flatnonzero", "(", "classes", "!=", "label", ")", "\n", "assert", "indices", ".", "ndim", "==", "1", "\n", "try", ":", "\n", "        ", "best", "=", "indices", "[", "0", "]", "\n", "", "except", "IndexError", ":", "\n", "        ", "raise", "ValueError", "\n", "", "logging", ".", "info", "(", "f'best: {best} -> {s[best]}'", ")", "\n", "return", "xs", "[", "best", "]", "[", "onp", ".", "newaxis", "]", ",", "classes", "[", "best", "]", ",", "best", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.get_region": [[283, 300], ["jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "lr_attack.biased_direction", "numpy.linalg.norm", "numpy.random.uniform", "logging.debug", "jax.device_put", "jax.device_put", "numpy.linalg.norm"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.biased_direction"], ["", "def", "get_region", "(", "k", ",", "x0", ",", "best_adv", ",", "*", ",", "gamma", ")", ":", "\n", "    ", "x0", "=", "jax", ".", "device_get", "(", "x0", ")", "\n", "best_adv", "=", "jax", ".", "device_get", "(", "best_adv", ")", "\n", "\n", "# TODO: maybe check region around original input", "\n", "# if k == 0:", "\n", "#     # try the region around the original input", "\n", "#     return x0", "\n", "\n", "delta", "=", "biased_direction", "(", "x0", ",", "best_adv", ",", "prob", "=", "0.8", ")", "\n", "\n", "u", "=", "onp", ".", "linalg", ".", "norm", "(", "best_adv", "-", "x0", ")", "\n", "r", "=", "onp", ".", "random", ".", "uniform", "(", ")", "\n", "logging", ".", "debug", "(", "f'sampled r = {r}'", ")", "\n", "x", "=", "best_adv", "+", "delta", "/", "onp", ".", "linalg", ".", "norm", "(", "delta", ")", "*", "u", "*", "r", "**", "gamma", "\n", "x", "=", "jax", ".", "device_put", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.biased_direction": [[302, 317], ["numpy.random.normal", "numpy.random.uniform", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.random.uniform", "dx.reshape", "numpy.dot", "onp.random.normal.reshape", "numpy.sin", "numpy.cos", "onp.random.normal.reshape", "dx.reshape"], "function", ["None"], ["", "def", "biased_direction", "(", "x0", ",", "best_adv", ",", "*", ",", "prob", ")", ":", "\n", "    ", "dx", "=", "x0", "-", "best_adv", "\n", "dx", "=", "dx", "/", "onp", ".", "linalg", ".", "norm", "(", "dx", ".", "reshape", "(", "-", "1", ")", ")", "\n", "\n", "delta", "=", "onp", ".", "random", ".", "normal", "(", "size", "=", "x0", ".", "shape", ")", "\n", "delta", "=", "delta", "-", "onp", ".", "dot", "(", "delta", ".", "reshape", "(", "-", "1", ")", ",", "dx", ".", "reshape", "(", "-", "1", ")", ")", "*", "dx", "\n", "delta", "=", "delta", "/", "onp", ".", "linalg", ".", "norm", "(", "delta", ".", "reshape", "(", "-", "1", ")", ")", "\n", "\n", "alpha", "=", "onp", ".", "random", ".", "uniform", "(", "0.", ",", "onp", ".", "pi", ")", "\n", "\n", "if", "onp", ".", "random", ".", "uniform", "(", ")", ">", "prob", ":", "\n", "# with probability 1 - prob, sample from the half space further away from x0", "\n", "        ", "alpha", "=", "-", "alpha", "\n", "\n", "", "return", "onp", ".", "sin", "(", "alpha", ")", "*", "dx", "+", "onp", ".", "cos", "(", "alpha", ")", "*", "delta", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.run": [[319, 500], ["time.time", "random.seed", "numpy.random.seed", "logging.info", "logging.info", "functools.partial", "functools.partial", "jax.jit", "jax.jit", "lr_attack.flatten_predict", "logging.info", "jax.device_put", "jax.device_put", "jax.device_put.reshape", "functools.partial", "jax.device_get", "jax.device_get", "logging.info", "logging.info", "jax.device_put", "jax.device_put", "find_starting_point", "functools.partial.", "best_adv_l2_hist.append", "logging.info", "lr_attack.get_other_classes", "logging.info", "logging.info", "functools.partial", "range", "logging.info", "functools.partial.", "logging.info", "logging.info", "logging.info", "jax.jit.", "logging.warning", "logging.info", "lr_attack.line_search", "functools.partial.", "len", "sum", "logging.info", "logging.info", "logging.info", "lr_attack.get_region", "lr_attack.init_region", "lr_attack.operator_norm_lower_bound", "logging.info", "range", "logging.info", "best_adv_l2_hist_hist.append", "label_host.item", "numpy.asarray().tolist", "jax.jit.", "label_host.item", "jax.device_put.squeeze", "lr_attack.calculate_normalizer", "logging.info", "logging.info", "len", "utils.onehot", "jax.concatenate", "u.squeeze.squeeze", "logging.info", "qpsolver.solve", "jax.device_get().item", "jax.device_get().item", "potential_adv.reshape.reshape", "functools.partial.", "logging.info", "best_adv_l2_hist.append", "logging.info", "time.time", "len", "time.time", "time.time", "time.time", "len", "round", "numpy.asarray", "lr_attack.accuracy", "time.time", "jax.device_get", "jax.device_get", "logging.info", "lr_attack.line_search", "functools.partial.", "logging.info", "numpy.linspace", "numpy.linspace", "logging.info", "logging.info", "lr_attack.line_search", "functools.partial.", "logging.info", "time.time", "onp.linspace.min", "onp.linspace.max"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.flatten_predict", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.find_starting_point", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.get_other_classes", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.line_search", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.get_region", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.init_region", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.operator_norm_lower_bound", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.calculate_normalizer", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.onehot", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.qpsolver.solve", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.accuracy", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.line_search", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.lr_attack.line_search"], ["", "def", "run", "(", "n_classes", ",", "predict", ",", "params", ",", "images", ",", "labels", ",", "find_starting_point", ",", "args", ")", ":", "\n", "    ", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "random", ".", "seed", "(", "22", ")", "\n", "onp", ".", "random", ".", "seed", "(", "22", ")", "\n", "\n", "logging", ".", "info", "(", "f'number of samples: {len(images)}'", ")", "\n", "logging", ".", "info", "(", "f'n_classes: {n_classes}'", ")", "\n", "\n", "predict", "=", "partial", "(", "predict", ",", "params", ")", "\n", "\n", "predict_class_logits_layer_sizes", "=", "partial", "(", "return_classes_logits_layer_sizes", ",", "predict", ")", "\n", "predict_class_logits_layer_sizes", "=", "jax", ".", "jit", "(", "predict_class_logits_layer_sizes", ")", "\n", "\n", "predict", "=", "flatten_predict", "(", "predict", ")", "\n", "\n", "def", "predict_class", "(", "x", ")", ":", "\n", "        ", "return", "predict_class_logits_layer_sizes", "(", "x", ")", "[", "0", "]", "\n", "\n", "", "if", "args", ".", "accuracy", ":", "\n", "        ", "logging", ".", "info", "(", "f'accuracy: {accuracy(predict_class, images, labels)}'", ")", "\n", "\n", "", "x0_host", "=", "images", "[", "args", ".", "image", "]", "[", "onp", ".", "newaxis", "]", "\n", "label_host", "=", "labels", "[", "args", ".", "image", "]", "[", "onp", ".", "newaxis", "]", "\n", "logging", ".", "info", "(", "f'label: {label_host}'", ")", "\n", "\n", "x0", "=", "jax", ".", "device_put", "(", "x0_host", ")", "\n", "x0_flat", "=", "x0", ".", "reshape", "(", "(", "-", "1", ",", ")", ")", "\n", "\n", "l2", "=", "partial", "(", "l2_distance", ",", "x0_host", ")", "\n", "\n", "x0_class", ",", "x0_logits", ",", "rows_per_layer", "=", "jax", ".", "device_get", "(", "predict_class_logits_layer_sizes", "(", "x0", ")", ")", "\n", "logging", ".", "info", "(", "f'predicted class: {x0_class}, logits: {x0_logits}'", ")", "\n", "\n", "logging", ".", "info", "(", "f'rows per layer: {rows_per_layer}'", ")", "\n", "\n", "if", "x0_class", "!=", "label_host", ":", "\n", "        ", "logging", ".", "warning", "(", "f'unperturbed input is misclassified by the model as {x0_class}'", ")", "\n", "result", "=", "{", "\n", "'is_adv'", ":", "True", ",", "\n", "'x0'", ":", "x0_host", ",", "\n", "'label'", ":", "label_host", ".", "item", "(", ")", ",", "\n", "'adv'", ":", "x0_host", ",", "\n", "'adv_class'", ":", "x0_class", ",", "\n", "'l2'", ":", "0.", ",", "\n", "'duration'", ":", "time", ".", "time", "(", ")", "-", "t0", ",", "\n", "}", "\n", "return", "result", "\n", "\n", "", "label", "=", "jax", ".", "device_put", "(", "label_host", ")", "\n", "\n", "best_adv", ",", "best_adv_class", "=", "find_starting_point", "(", "args", ",", "x0_host", ",", "label_host", ",", "x0_logits", ",", "predict_class", ")", "\n", "best_adv_l2", "=", "l2", "(", "best_adv", ")", "\n", "best_adv_l2_hist", "=", "[", "(", "time", ".", "time", "(", ")", "-", "t0", ",", "best_adv_l2", ")", "]", "\n", "\n", "if", "not", "args", ".", "no_line_search", ":", "\n", "        ", "logging", ".", "info", "(", "'running line search to determine better starting point'", ")", "\n", "best_adv", ",", "best_adv_class", ",", "_", "=", "line_search", "(", "predict_class", ",", "x0_host", ",", "label_host", ",", "best_adv", ")", "\n", "best_adv_l2", "=", "l2", "(", "best_adv", ")", "\n", "\n", "", "best_adv_l2_hist", ".", "append", "(", "(", "time", ".", "time", "(", ")", "-", "t0", ",", "best_adv_l2", ")", ")", "\n", "\n", "logging", ".", "info", "(", "f'starting point class: {best_adv_class}'", ")", "\n", "\n", "best_adv_l2_hist_hist", "=", "[", "best_adv_l2_hist", "]", "\n", "\n", "other_classes", "=", "get_other_classes", "(", "exclude", "=", "label", ".", "squeeze", "(", ")", ",", "total", "=", "n_classes", ",", "first", "=", "best_adv_class", ")", "\n", "if", "args", ".", "max_other_classes", ":", "\n", "        ", "other_classes", "=", "other_classes", "[", ":", "args", ".", "max_other_classes", "]", "\n", "", "logging", ".", "info", "(", "f'other classes: {other_classes}'", ")", "\n", "\n", "n_constraints", "=", "len", "(", "other_classes", ")", "+", "sum", "(", "rows_per_layer", ")", "\n", "logging", ".", "info", "(", "f'n_constraints: {n_constraints}'", ")", "\n", "\n", "total_solver_iterations", "=", "0", "\n", "\n", "get_A", "=", "partial", "(", "generic_get_A", ",", "predict", ",", "label", ",", "other_classes", ")", "\n", "\n", "# ------------------------------------------------------------------------", "\n", "# Loop over region", "\n", "# ------------------------------------------------------------------------", "\n", "for", "region", "in", "range", "(", "args", ".", "regions", ")", ":", "\n", "        ", "logging", ".", "info", "(", "'-'", "*", "70", ")", "\n", "logging", ".", "info", "(", "f'{region + 1}. REGION'", ")", "\n", "logging", ".", "info", "(", "'-'", "*", "70", ")", "\n", "\n", "xr", "=", "get_region", "(", "region", ",", "x0", ",", "best_adv", ",", "gamma", "=", "args", ".", "gamma", ")", "\n", "\n", "if", "not", "args", ".", "no_normalization", ":", "\n", "            ", "normalizer", ",", "misc_norms", ",", "layer_norms", "=", "calculate_normalizer", "(", "\n", "get_A", ",", "xr", ",", "n_constraints", ",", "rows_per_layer", ",", "k", "=", "10", ",", "misc_factor", "=", "args", ".", "misc_factor", ")", "\n", "logging", ".", "info", "(", "f'misc norms: {misc_norms}'", ")", "\n", "logging", ".", "info", "(", "f'layer norms: {layer_norms}'", ")", "\n", "", "else", ":", "\n", "            ", "normalizer", "=", "None", "\n", "\n", "", "Ax0", ",", "u_misc", ",", "u_relu", "=", "init_region", "(", "get_A", ",", "xr", ",", "normalizer", ",", "x0", ")", "\n", "\n", "L", "=", "operator_norm_lower_bound", "(", "get_A", ",", "xr", ",", "normalizer", ")", "\n", "logging", ".", "info", "(", "f'L = {L}'", ")", "\n", "\n", "best_adv_l2_hist", "=", "[", "(", "time", ".", "time", "(", ")", "-", "t0", ",", "best_adv_l2", ")", "]", "\n", "\n", "# ------------------------------------------------------------------------", "\n", "# Loop over other classes", "\n", "# ------------------------------------------------------------------------", "\n", "for", "active", "in", "range", "(", "len", "(", "other_classes", ")", ")", ":", "\n", "# update upper bounds", "\n", "            ", "mask", "=", "onehot", "(", "active", ",", "len", "(", "other_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "infs", "=", "1", "/", "mask", "-", "1", "\n", "u_misc_active", "=", "u_misc", "+", "infs", "\n", "u", "=", "np", ".", "concatenate", "(", "(", "u_misc_active", ",", "u_relu", ")", ",", "axis", "=", "1", ")", "\n", "u", "=", "u", ".", "squeeze", "(", "axis", "=", "0", ")", "\n", "\n", "assert", "best_adv", ".", "shape", "[", "0", "]", "==", "x0", ".", "shape", "[", "0", "]", "==", "1", "\n", "bound", "=", "0.5", "*", "best_adv_l2", "**", "2", "\n", "logging", ".", "info", "(", "f'bound: {bound}'", ")", "\n", "\n", "potential_adv", ",", "best_dual", ",", "counter", "=", "solve", "(", "\n", "x0_flat", ",", "Ax0", ",", "get_A", ",", "xr", ",", "normalizer", ",", "u", ",", "L", ",", "\n", "bound", "=", "bound", ",", "maxiter", "=", "args", ".", "iterations", ")", "\n", "\n", "total_solver_iterations", "+=", "jax", ".", "device_get", "(", "counter", ")", ".", "item", "(", ")", "\n", "\n", "potential_adv", "=", "potential_adv", ".", "reshape", "(", "x0", ".", "shape", ")", "\n", "potential_adv_l2", "=", "l2", "(", "potential_adv", ")", "\n", "closer", "=", "potential_adv_l2", "<", "best_adv_l2", "\n", "logging", ".", "info", "(", "f'closer = {closer}'", ")", "\n", "\n", "if", "closer", ":", "\n", "                ", "try", ":", "\n", "                    ", "ratio", "=", "best_adv_l2", "/", "potential_adv_l2", "\n", "if", "ratio", ">", "1.1", ":", "\n", "                        ", "s", "=", "onp", ".", "linspace", "(", "0.9", ",", "1.1", ",", "num", "=", "101", ",", "endpoint", "=", "True", ")", "\n", "", "else", ":", "\n", "                        ", "s", "=", "onp", ".", "linspace", "(", "0.9", ",", "ratio", ",", "num", "=", "101", ",", "endpoint", "=", "False", ")", "\n", "\n", "", "logging", ".", "info", "(", "f'running line search with factors between {s.min()} and {s.max()}'", ")", "\n", "best_adv", ",", "best_adv_class", ",", "index", "=", "line_search", "(", "\n", "predict_class", ",", "x0_host", ",", "label_host", ",", "potential_adv", ",", "s", "=", "s", ")", "\n", "new_l2", "=", "l2", "(", "best_adv", ")", "\n", "logging", ".", "info", "(", "f'-> new best adv with l2 = {new_l2} (before: {best_adv_l2})'", ")", "\n", "assert", "new_l2", "<", "best_adv_l2", "\n", "best_adv_l2", "=", "new_l2", "\n", "", "except", "ValueError", ":", "\n", "                    ", "logging", ".", "info", "(", "f'-> result not adversarial (tried with line search)'", ")", "\n", "", "else", ":", "# the first line search succeeded", "\n", "                    ", "if", "index", "==", "0", ":", "# the range of our line search can be extended to even smaller values", "\n", "                        ", "logging", ".", "info", "(", "f'running another line search with factors between 0 and 0.9'", ")", "\n", "# this line search should not fail because 0.9 works for sure", "\n", "best_adv", ",", "best_adv_class", ",", "_", "=", "line_search", "(", "predict_class", ",", "x0_host", ",", "label_host", ",", "potential_adv", ",", "\n", "minimum", "=", "0.", ",", "maximum", "=", "0.90", ",", "num", "=", "100", ")", "\n", "new_l2", "=", "l2", "(", "best_adv", ")", "\n", "logging", ".", "info", "(", "f'-> new best adv with l2 = {new_l2} (before: {best_adv_l2})'", ")", "\n", "assert", "new_l2", "<=", "best_adv_l2", "\n", "best_adv_l2", "=", "new_l2", "\n", "\n", "", "", "", "best_adv_l2_hist", ".", "append", "(", "(", "time", ".", "time", "(", ")", "-", "t0", ",", "best_adv_l2", ")", ")", "\n", "logging", ".", "info", "(", "'-'", "*", "70", ")", "\n", "\n", "", "logging", ".", "info", "(", "[", "l", "for", "_", ",", "l", "in", "best_adv_l2_hist", "]", ")", "\n", "best_adv_l2_hist_hist", ".", "append", "(", "best_adv_l2_hist", ")", "\n", "\n", "", "logging", ".", "info", "(", "[", "[", "round", "(", "l", ",", "2", ")", "for", "_", ",", "l", "in", "h", "]", "for", "h", "in", "best_adv_l2_hist_hist", "]", ")", "\n", "\n", "best_adv_l2", "=", "l2", "(", "best_adv", ")", "\n", "logging", ".", "info", "(", "f'final adversarial has l2 = {best_adv_l2}'", ")", "\n", "logging", ".", "info", "(", "f'total number of iterations in QP solver: {total_solver_iterations}'", ")", "\n", "\n", "result", "=", "{", "\n", "'x0'", ":", "x0_host", ",", "\n", "'label'", ":", "label_host", ".", "item", "(", ")", ",", "\n", "'adv'", ":", "best_adv", ",", "\n", "'adv_class'", ":", "best_adv_class", ",", "\n", "'l2'", ":", "best_adv_l2", ",", "\n", "'duration'", ":", "time", ".", "time", "(", ")", "-", "t0", ",", "\n", "'history'", ":", "best_adv_l2_hist_hist", ",", "\n", "'other_classes'", ":", "onp", ".", "asarray", "(", "other_classes", ")", ".", "tolist", "(", ")", ",", "\n", "'total_solver_iterations'", ":", "total_solver_iterations", ",", "\n", "}", "\n", "return", "result", "\n", "", ""]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.qpsolver.step": [[8, 50], ["logging.info", "get_A", "Adot", "jax.maximum", "jax.maximum", "ATdot", "jax.maximum", "jax.maximum", "jax.amax", "jax.sum", "jax.linalg.norm", "b_finite.T.dot", "x0.T.dot", "jax.linalg.norm"], "function", ["None"], ["def", "step", "(", "x0", ",", "get_A", ",", "xr", ",", "normalizer", ",", "b_finite", ",", "vec", ",", "L", ",", "counter", ",", "xp", ",", "mustar", ",", "mu", ")", ":", "\n", "# ---------------------------------------------------------------------", "\n", "\n", "# fixed param: x0, b_finite, vec", "\n", "# variable param: L, counter", "\n", "# taken and returned: xp, mustar, mu", "\n", "# returned: maxfeasible, dual_objective, primal_dual_gap", "\n", "\n", "# ---------------------------------------------------------------------", "\n", "\n", "    ", "logging", ".", "info", "(", "'compiling step'", ")", "\n", "\n", "Adot", ",", "ATdot", ",", "_", ",", "_", ",", "_", "=", "get_A", "(", "xr", ",", "normalizer", ")", "\n", "\n", "# compute gradient of the dual objective", "\n", "Axp", "=", "Adot", "(", "xp", ")", "\n", "gradq", "=", "Axp", "-", "vec", "\n", "\n", "# compute step of accelerated projected gradient descent", "\n", "mustarold", "=", "mustar", "\n", "mustar", "=", "np", ".", "maximum", "(", "0", ",", "mu", "-", "gradq", "/", "L", ")", "\n", "mu", "=", "mustar", "+", "(", "counter", "/", "(", "counter", "+", "3", ")", ")", "*", "(", "mustar", "-", "mustarold", ")", "\n", "mu", "=", "np", ".", "maximum", "(", "0", ",", "mu", ")", "\n", "\n", "# update ATmu, alpha, beta are set to their optimal values in the dual", "\n", "# NOTICE: this improves the dual value, but it is a HACK as we optimize", "\n", "# over mu (and jump around wrt to alpha, beta)", "\n", "ATmu", "=", "ATdot", "(", "mu", ")", "\n", "alpha", "=", "np", ".", "maximum", "(", "0", ",", "x0", "-", "ATmu", "-", "1", ")", "\n", "beta", "=", "np", ".", "maximum", "(", "0", ",", "ATmu", "-", "x0", ")", "\n", "xp", "=", "alpha", "+", "ATmu", "-", "beta", "\n", "\n", "# compute primal objective", "\n", "# x = x0 - xp is the primal variable (at the dual optimal), need not be feasible", "\n", "primal_objective", "=", "0.5", "*", "np", ".", "linalg", ".", "norm", "(", "xp", ")", "**", "2", "\n", "dual_objective", "=", "-", "0.5", "*", "np", ".", "linalg", ".", "norm", "(", "xp", ")", "**", "2", "+", "x0", ".", "T", ".", "dot", "(", "xp", ")", "-", "b_finite", ".", "T", ".", "dot", "(", "mu", ")", "-", "np", ".", "sum", "(", "alpha", ")", "\n", "primal_dual_gap", "=", "primal_objective", "-", "dual_objective", "\n", "\n", "feasible", "=", "vec", "-", "Axp", "\n", "maxfeasible", "=", "np", ".", "amax", "(", "feasible", ")", "\n", "\n", "return", "xp", ",", "mustar", ",", "mu", ",", "dual_objective", ",", "primal_dual_gap", ",", "maxfeasible", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.qpsolver.cond_fun": [[52, 67], ["logging.info", "jax.logical_or", "jax.logical_and", "jax.logical_or", "jax.logical_and", "jax.absolute", "jax.logical_and"], "function", ["None"], ["", "def", "cond_fun", "(", "maxiter", ",", "bound", ",", "feasStop", ",", "state", ")", ":", "\n", "    ", "logging", ".", "info", "(", "'compiling cond_fun'", ")", "\n", "counter", "=", "state", "[", "1", "]", "\n", "dual_objective", ",", "primal_dual_gap", ",", "maxfeasible", "=", "state", "[", "7", ":", "10", "]", "\n", "\n", "cond1", "=", "counter", "<=", "maxiter", "\n", "cond2", "=", "dual_objective", "<", "bound", "\n", "cond3", "=", "np", ".", "logical_or", "(", "\n", "np", ".", "absolute", "(", "primal_dual_gap", ")", ">", "1e-6", ",", "\n", "np", ".", "logical_or", "(", "\n", "maxfeasible", ">", "feasStop", ",", "\n", "np", ".", "logical_and", "(", "counter", "<", "200", ",", "maxfeasible", ">=", "0", ")", "\n", ")", "\n", ")", "\n", "return", "np", ".", "logical_and", "(", "cond1", ",", "np", ".", "logical_and", "(", "cond2", ",", "cond3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.qpsolver.state_update_fun": [[69, 101], ["logging.info", "qpsolver.step", "jax.lax.gt", "jax.lax.gt"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.qpsolver.step"], ["", "def", "state_update_fun", "(", "get_A", ",", "xr", ",", "normalizer", ",", "b_finite", ",", "vec", ",", "x0", ",", "state", ")", ":", "\n", "    ", "logging", ".", "info", "(", "'compiling state_update_fun'", ")", "\n", "\n", "L", ",", "counter", "=", "state", "[", "0", ":", "2", "]", "\n", "xp", ",", "mustar", ",", "mu", "=", "state", "[", "2", ":", "5", "]", "\n", "xp", ",", "mustar", ",", "mu", ",", "dual_objective", ",", "primal_dual_gap", ",", "maxfeasible", "=", "step", "(", "\n", "x0", ",", "get_A", ",", "xr", ",", "normalizer", ",", "b_finite", ",", "vec", ",", "\n", "L", ",", "counter", ",", "xp", ",", "mustar", ",", "mu", ")", "\n", "\n", "# TODO: maybe use lax.cond once available https://github.com/google/jax/issues/325", "\n", "best_dual_objective", ",", "best_x", "=", "state", "[", "5", ":", "7", "]", "\n", "update_best", "=", "jax", ".", "lax", ".", "gt", "(", "dual_objective", ",", "best_dual_objective", ")", "\n", "best_x", "=", "update_best", "*", "(", "x0", "-", "xp", ")", "+", "(", "1", "-", "update_best", ")", "*", "best_x", "\n", "best_dual_objective", "=", "update_best", "*", "dual_objective", "+", "(", "1", "-", "update_best", ")", "*", "best_dual_objective", "\n", "\n", "counter", "=", "counter", "+", "1", "\n", "\n", "# TODO: update L if dual smaller than -100", "\n", "# if dual_objective < -100:", "\n", "#     logging.warning('divergence due to hack with Lipschitz constant')", "\n", "#     if L < LMAX:", "\n", "#         logging.warning('increasing L and restarting from scratch')", "\n", "#         L = min(10 * L, LMAX)", "\n", "#         mu = np.zeros_like(mu)", "\n", "#         mustar = mu", "\n", "#         counter = 1", "\n", "\n", "return", "(", "\n", "L", ",", "counter", ",", "\n", "xp", ",", "mustar", ",", "mu", ",", "\n", "best_dual_objective", ",", "best_x", ",", "\n", "dual_objective", ",", "primal_dual_gap", ",", "maxfeasible", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.qpsolver.solve_jit": [[105, 134], ["functools.partial", "logging.info", "jax.zeros_like", "jax.zeros_like", "jax.where", "functools.partial", "functools.partial", "jax.lax.while_loop", "jax.lax.while_loop", "jax.isposinf", "jax.array", "jax.finfo"], "function", ["None"], ["", "@", "partial", "(", "jax", ".", "jit", ",", "static_argnums", "=", "(", "0", ",", "2", ")", ")", "\n", "def", "solve_jit", "(", "x0", ",", "Ax0", ",", "get_A", ",", "xr", ",", "normalizer", ",", "b", ",", "L", ",", "bound", ",", "maxiter", ",", "feasStop", ")", ":", "\n", "    ", "logging", ".", "info", "(", "'compiling solve_jit'", ")", "\n", "\n", "# constants", "\n", "vec", "=", "Ax0", "-", "b", "\n", "\n", "# initialization", "\n", "mu", "=", "np", ".", "zeros_like", "(", "b", ")", "\n", "mustar", "=", "mu", "\n", "xp", "=", "np", ".", "zeros_like", "(", "x0", ")", "\n", "best_dual_objective", "=", "0.", "\n", "best_x", "=", "x0", "\n", "counter", "=", "1", "\n", "\n", "b_finite", "=", "np", ".", "where", "(", "np", ".", "isposinf", "(", "b", ")", ",", "np", ".", "array", "(", "np", ".", "finfo", "(", "b", ".", "dtype", ")", ".", "max", ")", ",", "b", ")", "\n", "\n", "init_state", "=", "(", "L", ",", "counter", ",", "xp", ",", "mustar", ",", "mu", ",", "best_dual_objective", ",", "best_x", ",", "0.", ",", "np", ".", "inf", ",", "np", ".", "inf", ")", "\n", "\n", "_cond_fun", "=", "partial", "(", "cond_fun", ",", "maxiter", ",", "bound", ",", "feasStop", ")", "\n", "_state_update_fun", "=", "partial", "(", "state_update_fun", ",", "get_A", ",", "xr", ",", "normalizer", ",", "b_finite", ",", "vec", ",", "x0", ")", "\n", "\n", "final_state", "=", "jax", ".", "lax", ".", "while_loop", "(", "_cond_fun", ",", "_state_update_fun", ",", "init_state", ")", "\n", "\n", "counter", "=", "final_state", "[", "1", "]", "\n", "best_dual_objective", "=", "final_state", "[", "5", "]", "\n", "best_x", "=", "final_state", "[", "6", "]", "\n", "\n", "return", "counter", ",", "best_dual_objective", ",", "best_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.qpsolver.solve": [[136, 149], ["time.time", "qpsolver.solve_jit", "logging.info", "time.time"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.qpsolver.solve_jit"], ["", "def", "solve", "(", "x0", ",", "Ax0", ",", "get_A", ",", "xr", ",", "normalizer", ",", "b", ",", "L", ",", "*", ",", "bound", "=", "np", ".", "inf", ",", "maxiter", "=", "4000", ",", "feasStop", "=", "1e-8", ")", ":", "\n", "    ", "\"\"\"Solves the following quadratic programming (QP) problem:\n\n    min_x 1/2 (x - x0)' * (x - x0)\n    s.t. A * x \u2264 b and 0 \u2264 x \u2264 1\n    \"\"\"", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "counter", ",", "best_dual_objective", ",", "best_x", "=", "solve_jit", "(", "x0", ",", "Ax0", ",", "get_A", ",", "xr", ",", "normalizer", ",", "b", ",", "L", ",", "bound", ",", "maxiter", ",", "feasStop", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "-", "t0", "\n", "\n", "logging", ".", "info", "(", "f'took {t0:.1f} secs for {counter} it -> {counter / t0:.1f} it/sec'", ")", "\n", "return", "best_x", ",", "best_dual_objective", ",", "counter", "\n", "", ""]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.load_cifar10": [[28, 58], ["numpy.vstack().reshape().transpose", "numpy.asarray", "onp.vstack().reshape().transpose.astype", "os.path.join", "os.path.expanduser", "onp.vstack().reshape().transpose.append", "onp.asarray.extend", "logging.error", "sys.exit", "numpy.vstack().reshape", "open", "pickle.load", "numpy.vstack"], "function", ["None"], ["def", "load_cifar10", "(", "*", ",", "train", ")", ":", "\n", "    ", "if", "train", ":", "\n", "        ", "filenames", "=", "train_list", "\n", "", "else", ":", "\n", "        ", "filenames", "=", "test_list", "\n", "\n", "", "images", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "\n", "try", ":", "\n", "        ", "for", "filename", ",", "checksum", "in", "filenames", ":", "\n", "            ", "path", "=", "os", ".", "path", ".", "join", "(", "'cifar-10-batches-py'", ",", "filename", ")", "\n", "path", "=", "os", ".", "path", ".", "expanduser", "(", "path", ")", "\n", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "entry", "=", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "'latin1'", ")", "\n", "", "images", ".", "append", "(", "entry", "[", "'data'", "]", ")", "\n", "labels", ".", "extend", "(", "entry", "[", "'labels'", "]", ")", "\n", "", "", "except", "FileNotFoundError", ":", "\n", "        ", "logging", ".", "error", "(", "'Could not load CIFAR. Run the following commands to download it:\\n'", "\n", "'\\n'", "\n", "'wget http://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz\\n'", "\n", "'tar -zxvf cifar-10-python.tar.gz'", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "images", "=", "onp", ".", "vstack", "(", "images", ")", ".", "reshape", "(", "(", "-", "1", ",", "3", ",", "32", ",", "32", ")", ")", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", "\n", "labels", "=", "onp", ".", "asarray", "(", "labels", ",", "dtype", "=", "onp", ".", "int32", ")", "\n", "\n", "assert", "images", ".", "dtype", "==", "onp", ".", "uint8", "\n", "images", "=", "images", ".", "astype", "(", "onp", ".", "float32", ")", "/", "255.", "\n", "return", "images", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.ConvNet": [[60, 73], ["staxmod.serial", "staxmod.Conv", "staxmod.Conv", "staxmod.Conv", "staxmod.Conv", "staxmod.Conv", "staxmod.Conv", "staxmod.Conv", "staxmod.Conv", "staxmod.Dense", "staxmod.Dense"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.staxmod.serial"], ["", "def", "ConvNet", "(", ")", ":", "\n", "    ", "return", "serial", "(", "\n", "Conv", "(", "96", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'SAME'", ")", ",", "Relu", ",", "\n", "Conv", "(", "96", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'SAME'", ")", ",", "Relu", ",", "\n", "Conv", "(", "192", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'SAME'", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "Relu", ",", "\n", "Conv", "(", "192", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'SAME'", ")", ",", "Relu", ",", "\n", "Conv", "(", "192", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'SAME'", ")", ",", "Relu", ",", "\n", "Conv", "(", "192", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'SAME'", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "Relu", ",", "\n", "Conv", "(", "192", ",", "(", "3", ",", "3", ")", ",", "padding", "=", "'SAME'", ")", ",", "Relu", ",", "\n", "Conv", "(", "384", ",", "(", "2", ",", "2", ")", ",", "padding", "=", "'SAME'", ",", "strides", "=", "(", "2", ",", "2", ")", ")", ",", "Relu", ",", "\n", "Flatten", ",", "\n", "Dense", "(", "1200", ")", ",", "Relu", ",", "\n", "Dense", "(", "10", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.load_params": [[75, 80], ["jax.tree_map", "open", "pickle.load"], "function", ["None"], ["", "def", "load_params", "(", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "params", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "params", "=", "jax", ".", "tree_map", "(", "jax", ".", "device_put", ",", "params", ")", "\n", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.find_starting_point": [[82, 87], ["examples.find_starting_point_likely_class_strategy", "examples.find_starting_point_simple_strategy"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.find_starting_point_likely_class_strategy", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.find_starting_point_simple_strategy"], ["", "def", "find_starting_point", "(", "images", ",", "labels", ",", "args", ",", "x", ",", "label", ",", "logits", ",", "predict_class", ")", ":", "\n", "    ", "strategy", "=", "args", ".", "nth_likely_class_starting_point", "\n", "if", "strategy", "is", "None", ":", "\n", "        ", "return", "find_starting_point_simple_strategy", "(", "images", ",", "labels", ",", "x", ",", "label", ",", "predict_class", ")", "\n", "", "return", "find_starting_point_likely_class_strategy", "(", "images", ",", "labels", ",", "x", ",", "label", ",", "logits", ",", "predict_class", ",", "nth", "=", "strategy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.find_starting_point_simple_strategy": [[89, 120], ["onp.argsort.reshape", "numpy.square().sum", "numpy.argsort", "enumerate", "utils.is_device_array", "utils.is_device_array", "utils.is_device_array", "utils.is_device_array", "utils.is_device_array", "utils.is_device_array", "logging.info", "jax.device_get", "logging.info", "numpy.square", "predict_class().squeeze", "predict_class"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array"], ["", "def", "find_starting_point_simple_strategy", "(", "images", ",", "labels", ",", "x", ",", "label", ",", "predict_class", ")", ":", "\n", "    ", "\"\"\"returns the image in images that is closest to x that has a\n    different label and predicted class than the provided label of x\"\"\"", "\n", "\n", "assert", "x", ".", "shape", "[", "0", "]", "==", "1", "\n", "\n", "assert", "not", "is_device_array", "(", "x", ")", "\n", "assert", "not", "is_device_array", "(", "label", ")", "\n", "\n", "assert", "not", "is_device_array", "(", "images", ")", "\n", "assert", "not", "is_device_array", "(", "labels", ")", "\n", "assert", "not", "is_device_array", "(", "x", ")", "\n", "assert", "not", "is_device_array", "(", "label", ")", "\n", "\n", "# filter those with the same label", "\n", "images", "=", "images", "[", "labels", "!=", "label", "]", "\n", "\n", "# get closest images from other classes", "\n", "diff", "=", "images", "-", "x", "\n", "diff", "=", "diff", ".", "reshape", "(", "(", "diff", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "diff", "=", "onp", ".", "square", "(", "diff", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", "\n", "diff", "=", "onp", ".", "argsort", "(", "diff", ")", "\n", "assert", "diff", ".", "ndim", "==", "1", "\n", "\n", "for", "j", ",", "index", "in", "enumerate", "(", "diff", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f'trying {j + 1}. candidate ({index})'", ")", "\n", "candidate", "=", "images", "[", "index", "]", "[", "onp", ".", "newaxis", "]", "\n", "class_", "=", "jax", ".", "device_get", "(", "predict_class", "(", "candidate", ")", ".", "squeeze", "(", "axis", "=", "0", ")", ")", "\n", "logging", ".", "info", "(", "f'label = {label}, candidate class = {class_}'", ")", "\n", "if", "class_", "!=", "label", ":", "\n", "            ", "return", "candidate", ",", "class_", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.find_starting_point_likely_class_strategy": [[122, 158], ["logits.squeeze.squeeze", "numpy.argsort", "onp.argsort.reshape", "numpy.square().sum", "numpy.argsort", "enumerate", "utils.is_device_array", "utils.is_device_array", "utils.is_device_array", "utils.is_device_array", "utils.is_device_array", "utils.is_device_array", "len", "logging.info", "jax.device_get", "logging.info", "numpy.square", "predict_class().squeeze", "predict_class"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array"], ["", "", "", "def", "find_starting_point_likely_class_strategy", "(", "images", ",", "labels", ",", "x", ",", "label", ",", "logits", ",", "predict_class", ",", "*", ",", "nth", ")", ":", "\n", "    ", "assert", "x", ".", "shape", "[", "0", "]", "==", "1", "\n", "\n", "assert", "not", "is_device_array", "(", "x", ")", "\n", "assert", "not", "is_device_array", "(", "label", ")", "\n", "\n", "assert", "not", "is_device_array", "(", "images", ")", "\n", "assert", "not", "is_device_array", "(", "labels", ")", "\n", "assert", "not", "is_device_array", "(", "x", ")", "\n", "assert", "not", "is_device_array", "(", "label", ")", "\n", "\n", "# determine nth likely class", "\n", "logits", "=", "logits", ".", "squeeze", "(", "axis", "=", "0", ")", "\n", "ordered_classes", "=", "onp", ".", "argsort", "(", "logits", ")", "\n", "assert", "ordered_classes", "[", "-", "1", "]", "==", "label", "\n", "\n", "assert", "2", "<=", "nth", "<=", "len", "(", "logits", ")", "\n", "nth_class", "=", "ordered_classes", "[", "-", "nth", "]", "\n", "\n", "# select those from the nth most likely  class", "\n", "images", "=", "images", "[", "labels", "==", "nth_class", "]", "\n", "\n", "# get closest images from other classes", "\n", "diff", "=", "images", "-", "x", "\n", "diff", "=", "diff", ".", "reshape", "(", "(", "diff", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "diff", "=", "onp", ".", "square", "(", "diff", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", "\n", "diff", "=", "onp", ".", "argsort", "(", "diff", ")", "\n", "assert", "diff", ".", "ndim", "==", "1", "\n", "\n", "for", "j", ",", "index", "in", "enumerate", "(", "diff", ")", ":", "\n", "        ", "logging", ".", "info", "(", "f'trying {j + 1}. candidate ({index})'", ")", "\n", "candidate", "=", "images", "[", "index", "]", "[", "onp", ".", "newaxis", "]", "\n", "class_", "=", "jax", ".", "device_get", "(", "predict_class", "(", "candidate", ")", ".", "squeeze", "(", "axis", "=", "0", ")", ")", "\n", "logging", ".", "info", "(", "f'label = {label}, candidate class = {class_}'", ")", "\n", "if", "class_", "!=", "label", ":", "\n", "            ", "return", "candidate", ",", "class_", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples._cifar_example": [[160, 171], ["init", "examples.load_cifar10", "examples.load_cifar10", "functools.partial", "examples.load_params", "utils.is_device_array", "utils.is_device_array", "examples.ConvNet"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.load_cifar10", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.load_cifar10", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.load_params", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array", "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.ConvNet"], ["", "", "", "def", "_cifar_example", "(", "architecture", ",", "weights", "=", "None", ")", ":", "\n", "    ", "init", ",", "predict", "=", "architecture", "(", ")", "\n", "output_shape", ",", "params", "=", "init", "(", "(", "-", "1", ",", "32", ",", "32", ",", "3", ")", ")", "\n", "if", "weights", "is", "not", "None", ":", "\n", "        ", "params", "=", "load_params", "(", "weights", ")", "\n", "", "n_classes", "=", "output_shape", "[", "-", "1", "]", "\n", "images", ",", "labels", "=", "load_cifar10", "(", "train", "=", "False", ")", "\n", "train_images", ",", "train_labels", "=", "load_cifar10", "(", "train", "=", "True", ")", "\n", "assert", "not", "is_device_array", "(", "train_images", ")", "and", "not", "is_device_array", "(", "train_labels", ")", "\n", "find_starting_point_2", "=", "partial", "(", "find_starting_point", ",", "train_images", ",", "train_labels", ")", "\n", "return", "n_classes", ",", "predict", ",", "params", ",", "images", ",", "labels", ",", "find_starting_point_2", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.get_cifar_example": [[173, 176], ["examples._cifar_example"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples._cifar_example"], ["", "def", "get_cifar_example", "(", "load_weights", "=", "True", ")", ":", "\n", "    ", "weights", "=", "'weights/convnet.pickle'", "if", "load_weights", "else", "None", "\n", "return", "_cifar_example", "(", "ConvNet", ",", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.get_example": [[178, 182], ["examples.get_cifar_example"], "function", ["home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.examples.get_cifar_example"], ["", "def", "get_example", "(", "name", ")", ":", "\n", "    ", "return", "{", "\n", "'cifar_convnet'", ":", "lambda", ":", "get_cifar_example", "(", "load_weights", "=", "True", ")", ",", "\n", "}", "[", "name", "]", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.staxmod.affine": [[11, 22], ["staxmod.serial.apply_fun", "jax.experimental.stax.AvgPool", "jax.experimental.stax.BatchNorm", "jax.experimental.stax.Conv", "jax.experimental.stax.Dense", "jax.experimental.stax.FanOut", "jax.experimental.stax.GeneralConv"], "function", ["None"], ["def", "affine", "(", "layer_fun", ")", ":", "\n", "    ", "\"\"\"Decorator that turns a layer into one that's compatible with tracking\n    of additional outputs.\"\"\"", "\n", "# @functools.wraps(layer_fun)", "\n", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "init_fun", ",", "apply_fun", "=", "layer_fun", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "def", "new_apply_fun", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "return", "apply_fun", "(", "*", "args", ",", "**", "kwargs", ")", ",", "(", ")", "\n", "", "return", "init_fun", ",", "new_apply_fun", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.staxmod.affine_no_params": [[24, 32], ["staxmod.serial.apply_fun", "jax.experimental.stax.FanInSum", "jax.experimental.stax.Flatten", "jax.experimental.stax.Identity"], "function", ["None"], ["", "def", "affine_no_params", "(", "layer", ")", ":", "\n", "    ", "\"\"\"Decorator that turns a layer into one that's compatible with tracking\n    of additional outputs.\"\"\"", "\n", "init_fun", ",", "apply_fun", "=", "layer", "\n", "\n", "def", "new_apply_fun", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "apply_fun", "(", "*", "args", ",", "**", "kwargs", ")", ",", "(", ")", "\n", "", "return", "init_fun", ",", "new_apply_fun", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.staxmod.track_input_no_params": [[34, 40], ["staxmod.serial.apply_fun", "jax.experimental.stax.Relu"], "function", ["None"], ["", "def", "track_input_no_params", "(", "layer", ")", ":", "\n", "    ", "init_fun", ",", "apply_fun", "=", "layer", "\n", "\n", "def", "new_apply_fun", "(", "params", ",", "inputs", ",", "rng", "=", "None", ")", ":", "\n", "        ", "return", "apply_fun", "(", "params", ",", "inputs", ",", "rng", "=", "rng", ")", ",", "(", "inputs", ",", ")", "\n", "", "return", "init_fun", ",", "new_apply_fun", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.staxmod.serial": [[42, 63], ["len", "zip", "zip", "staxmod.serial.init_fun"], "function", ["None"], ["", "def", "serial", "(", "*", "layers", ")", ":", "\n", "    ", "\"\"\"Like stax.serial but separately tracks additional outputs\n    for each layer.\"\"\"", "\n", "nlayers", "=", "len", "(", "layers", ")", "\n", "init_funs", ",", "apply_funs", "=", "zip", "(", "*", "layers", ")", "\n", "\n", "def", "init_fun", "(", "input_shape", ")", ":", "\n", "        ", "params", "=", "[", "]", "\n", "for", "init_fun", "in", "init_funs", ":", "\n", "            ", "input_shape", ",", "param", "=", "init_fun", "(", "input_shape", ")", "\n", "params", ".", "append", "(", "param", ")", "\n", "", "return", "input_shape", ",", "params", "\n", "\n", "", "def", "apply_fun", "(", "params", ",", "inputs", ",", "rng", "=", "None", ")", ":", "\n", "        ", "rngs", "=", "random", ".", "split", "(", "rng", ",", "nlayers", ")", "if", "rng", "is", "not", "None", "else", "(", "None", ",", ")", "*", "nlayers", "\n", "additional_outputs", "=", "[", "]", "\n", "for", "fun", ",", "param", ",", "rng", "in", "zip", "(", "apply_funs", ",", "params", ",", "rngs", ")", ":", "\n", "            ", "inputs", ",", "additional_output", "=", "fun", "(", "param", ",", "inputs", ",", "rng", "=", "rng", ")", "\n", "additional_outputs", ".", "append", "(", "additional_output", ")", "\n", "", "return", "inputs", ",", "additional_outputs", "\n", "", "return", "init_fun", ",", "apply_fun", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.staxmod.parallel": [[65, 84], ["len", "zip", "zip", "zip", "jax.random.split", "f", "outputs.append", "additional_outputs.append", "init", "zip"], "function", ["None"], ["", "def", "parallel", "(", "*", "layers", ")", ":", "\n", "    ", "\"\"\"Like stax.parallel but separately tracks additional outputs\n    for each layer.\"\"\"", "\n", "nlayers", "=", "len", "(", "layers", ")", "\n", "init_funs", ",", "apply_funs", "=", "zip", "(", "*", "layers", ")", "\n", "\n", "def", "init_fun", "(", "input_shape", ")", ":", "\n", "        ", "return", "zip", "(", "*", "[", "init", "(", "shape", ")", "for", "init", ",", "shape", "in", "zip", "(", "init_funs", ",", "input_shape", ")", "]", ")", "\n", "\n", "", "def", "apply_fun", "(", "params", ",", "inputs", ",", "rng", "=", "None", ")", ":", "\n", "        ", "rngs", "=", "random", ".", "split", "(", "rng", ",", "nlayers", ")", "if", "rng", "is", "not", "None", "else", "(", "None", ",", ")", "*", "nlayers", "\n", "outputs", "=", "[", "]", "\n", "additional_outputs", "=", "[", "]", "\n", "for", "f", ",", "p", ",", "x", ",", "r", "in", "zip", "(", "apply_funs", ",", "params", ",", "inputs", ",", "rngs", ")", ":", "\n", "            ", "output", ",", "additional_output", "=", "f", "(", "p", ",", "x", ",", "rng", "=", "r", ")", "\n", "outputs", ".", "append", "(", "output", ")", "\n", "additional_outputs", ".", "append", "(", "additional_output", ")", "\n", "", "return", "outputs", ",", "additional_outputs", "\n", "", "return", "init_fun", ",", "apply_fun", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.staxmod.leaky_relu": [[99, 101], ["jax.where"], "function", ["None"], ["def", "leaky_relu", "(", "x", ",", "leakiness", "=", "0.01", ")", ":", "\n", "    ", "return", "np", ".", "where", "(", "x", ">=", "0", ",", "x", ",", "leakiness", "*", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.is_device_array": [[6, 8], ["isinstance"], "function", ["None"], ["def", "is_device_array", "(", "x", ")", ":", "\n", "    ", "return", "isinstance", "(", "x", ",", "xla", ".", "DeviceArray", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.scatter": [[10, 22], ["jax.zeros", "jax.vjp", "jax.vjp", "grad"], "function", ["None"], ["", "def", "scatter", "(", "indices", ",", "values", ",", "length", ")", ":", "\n", "    ", "assert", "indices", ".", "ndim", "==", "1", "\n", "assert", "values", ".", "shape", "[", "1", ":", "]", "==", "indices", ".", "shape", "\n", "batch_size", "=", "values", ".", "shape", "[", "0", "]", "\n", "\n", "def", "f", "(", "a", ")", ":", "\n", "        ", "return", "a", "[", ":", ",", "indices", "]", "\n", "\n", "", "base", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "length", ")", ",", "np", ".", "float32", ")", "\n", "_", ",", "grad", "=", "jax", ".", "vjp", "(", "f", ",", "base", ")", "\n", "(", "out", ",", ")", "=", "grad", "(", "values", ")", "\n", "return", "base", "+", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jonasrauber_linear-region-attack.None.utils.onehot": [[37, 42], ["isinstance", "onehot.astype.astype", "jax.arange"], "function", ["None"], ["", "def", "onehot", "(", "index", ",", "length", ",", "dtype", "=", "np", ".", "int32", ")", ":", "\n", "    ", "assert", "isinstance", "(", "index", ",", "int", ")", "\n", "onehot", "=", "np", ".", "arange", "(", "length", ")", "==", "index", "\n", "onehot", "=", "onehot", ".", "astype", "(", "dtype", ")", "\n", "return", "onehot", "\n", "", ""]]}