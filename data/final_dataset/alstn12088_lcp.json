{"home.repos.pwc.inspect_result.alstn12088_lcp.None.options.get_options": [[7, 90], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.join", "torch.cuda.is_available", "time.strftime"], "function", ["None"], ["def", "get_options", "(", "args", "=", "None", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "\"Attention based model for solving the Travelling Salesman Problem with Reinforcement Learning\"", ")", "\n", "\n", "# Data", "\n", "parser", ".", "add_argument", "(", "'--problem'", ",", "default", "=", "'tsp'", ",", "help", "=", "\"The problem to solve, default 'tsp'\"", ")", "\n", "parser", ".", "add_argument", "(", "'--graph_size'", ",", "type", "=", "int", ",", "default", "=", "20", ",", "help", "=", "\"The size of the problem graph\"", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "help", "=", "'Number of instances per batch during training'", ")", "\n", "parser", ".", "add_argument", "(", "'--epoch_size'", ",", "type", "=", "int", ",", "default", "=", "1280000", ",", "help", "=", "'Number of instances per epoch during training'", ")", "\n", "parser", ".", "add_argument", "(", "'--val_size'", ",", "type", "=", "int", ",", "default", "=", "10000", ",", "\n", "help", "=", "'Number of instances used for reporting validation performance'", ")", "\n", "parser", ".", "add_argument", "(", "'--val_dataset'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "help", "=", "'Dataset file to use for validation'", ")", "\n", "\n", "# Model", "\n", "parser", ".", "add_argument", "(", "'--model'", ",", "default", "=", "'attention'", ",", "help", "=", "\"Model, 'attention' (default) or 'pointer'\"", ")", "\n", "parser", ".", "add_argument", "(", "'--policy_mode'", ",", "default", "=", "'seeder'", ",", "help", "=", "\"policy mode for collaborative policies training, 'seeder or 'reviser'\"", ")", "\n", "parser", ".", "add_argument", "(", "'--embedding_dim'", ",", "type", "=", "int", ",", "default", "=", "128", ",", "help", "=", "'Dimension of input embedding'", ")", "\n", "parser", ".", "add_argument", "(", "'--hidden_dim'", ",", "type", "=", "int", ",", "default", "=", "128", ",", "help", "=", "'Dimension of hidden layers in Enc/Dec'", ")", "\n", "parser", ".", "add_argument", "(", "'--n_encode_layers'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "\n", "help", "=", "'Number of layers in the encoder/critic network'", ")", "\n", "parser", ".", "add_argument", "(", "'--tanh_clipping'", ",", "type", "=", "float", ",", "default", "=", "10.", ",", "\n", "help", "=", "'Clip the parameters to within +- this value using tanh. '", "\n", "'Set to 0 to not perform any clipping.'", ")", "\n", "parser", ".", "add_argument", "(", "'--normalization'", ",", "default", "=", "'batch'", ",", "help", "=", "\"Normalization type, 'batch' (default) or 'instance'\"", ")", "\n", "\n", "# Training", "\n", "parser", ".", "add_argument", "(", "'--alp'", ",", "type", "=", "float", ",", "default", "=", "2", ",", "help", "=", "\"Set weight (alpha) for scaled entropy regularization\"", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_model'", ",", "type", "=", "float", ",", "default", "=", "1e-4", ",", "help", "=", "\"Set the learning rate for the actor network\"", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_critic'", ",", "type", "=", "float", ",", "default", "=", "1e-4", ",", "help", "=", "\"Set the learning rate for the critic network\"", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_decay'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "'Learning rate decay per epoch'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_only'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Set this value to only evaluate model'", ")", "\n", "parser", ".", "add_argument", "(", "'--n_epochs'", ",", "type", "=", "int", ",", "default", "=", "100", ",", "help", "=", "'The number of epochs to train'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "1234", ",", "help", "=", "'Random seed to use'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_grad_norm'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "'Maximum L2 norm for gradient clipping, default 1.0 (0 to disable clipping)'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_cuda'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Disable CUDA'", ")", "\n", "parser", ".", "add_argument", "(", "'--exp_beta'", ",", "type", "=", "float", ",", "default", "=", "0.8", ",", "\n", "help", "=", "'Exponential moving average baseline decay (default 0.8)'", ")", "\n", "parser", ".", "add_argument", "(", "'--baseline'", ",", "default", "=", "'rollout'", ",", "\n", "help", "=", "\"Baseline to use: 'rollout', 'critic' or 'exponential'. Defaults to no baseline.\"", ")", "\n", "parser", ".", "add_argument", "(", "'--bl_alpha'", ",", "type", "=", "float", ",", "default", "=", "0.05", ",", "\n", "help", "=", "'Significance in the t-test for updating rollout baseline'", ")", "\n", "parser", ".", "add_argument", "(", "'--bl_warmup_epochs'", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "'Number of epochs to warmup the baseline, default None means 1 for rollout (exponential '", "\n", "'used for warmup phase), 0 otherwise. Can only be used with rollout baseline.'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_batch_size'", ",", "type", "=", "int", ",", "default", "=", "1024", ",", "\n", "help", "=", "\"Batch size to use during (baseline) evaluation\"", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_encoder'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Set to decrease memory usage by checkpointing encoder'", ")", "\n", "parser", ".", "add_argument", "(", "'--shrink_size'", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "'Shrink the batch size if at least this many instances in the batch are finished'", "\n", "' to save memory (default None means no shrinking)'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_distribution'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "'Data distribution to use during training, defaults and options depend on problem.'", ")", "\n", "\n", "# Misc", "\n", "parser", ".", "add_argument", "(", "'--log_step'", ",", "type", "=", "int", ",", "default", "=", "50", ",", "help", "=", "'Log info every log_step steps'", ")", "\n", "parser", ".", "add_argument", "(", "'--log_dir'", ",", "default", "=", "'logs'", ",", "help", "=", "'Directory to write TensorBoard information to'", ")", "\n", "parser", ".", "add_argument", "(", "'--run_name'", ",", "default", "=", "'run'", ",", "help", "=", "'Name to identify the run'", ")", "\n", "parser", ".", "add_argument", "(", "'--output_dir'", ",", "default", "=", "'outputs'", ",", "help", "=", "'Directory to write output models to'", ")", "\n", "parser", ".", "add_argument", "(", "'--epoch_start'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Start at epoch # (relevant for learning rate decay)'", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_epochs'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Save checkpoint every n epochs (default 1), 0 to save no checkpoints'", ")", "\n", "parser", ".", "add_argument", "(", "'--load_path'", ",", "help", "=", "'Path to load model parameters and optimizer state from'", ")", "\n", "parser", ".", "add_argument", "(", "'--resume'", ",", "help", "=", "'Resume from previous checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_tensorboard'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Disable logging TensorBoard files'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_progress_bar'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Disable progress bar'", ")", "\n", "\n", "opts", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "\n", "opts", ".", "use_cuda", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "not", "opts", ".", "no_cuda", "\n", "opts", ".", "run_name", "=", "\"{}_{}\"", ".", "format", "(", "opts", ".", "run_name", ",", "time", ".", "strftime", "(", "\"%Y%m%dT%H%M%S\"", ")", ")", "\n", "opts", ".", "save_dir", "=", "os", ".", "path", ".", "join", "(", "\n", "opts", ".", "output_dir", ",", "\n", "\"{}_{}\"", ".", "format", "(", "opts", ".", "problem", ",", "opts", ".", "graph_size", ")", ",", "\n", "opts", ".", "run_name", "\n", ")", "\n", "if", "opts", ".", "bl_warmup_epochs", "is", "None", ":", "\n", "        ", "opts", ".", "bl_warmup_epochs", "=", "1", "if", "opts", ".", "baseline", "==", "'rollout'", "else", "0", "\n", "", "assert", "(", "opts", ".", "bl_warmup_epochs", "==", "0", ")", "or", "(", "opts", ".", "baseline", "==", "'rollout'", ")", "\n", "assert", "opts", ".", "epoch_size", "%", "opts", ".", "batch_size", "==", "0", ",", "\"Epoch size must be integer multiple of batch size!\"", "\n", "return", "opts", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.eval.get_best": [[21, 43], ["numpy.hstack", "numpy.minimum.reduceat", "numpy.diff", "numpy.flatnonzero", "numpy.full", "cost.argmin", "numpy.hstack", "numpy.repeat", "len", "len", "numpy.where"], "function", ["None"], ["def", "get_best", "(", "sequences", ",", "cost", ",", "ids", "=", "None", ",", "batch_size", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Ids contains [0, 0, 0, 1, 1, 2, ..., n, n, n] if 3 solutions found for 0th instance, 2 for 1st, etc\n    :param sequences:\n    :param lengths:\n    :param ids:\n    :return: list with n sequences and list with n lengths of solutions\n    \"\"\"", "\n", "if", "ids", "is", "None", ":", "\n", "        ", "idx", "=", "cost", ".", "argmin", "(", ")", "\n", "return", "sequences", "[", "idx", ":", "idx", "+", "1", ",", "...", "]", ",", "cost", "[", "idx", ":", "idx", "+", "1", ",", "...", "]", "\n", "\n", "", "splits", "=", "np", ".", "hstack", "(", "[", "0", ",", "np", ".", "where", "(", "ids", "[", ":", "-", "1", "]", "!=", "ids", "[", "1", ":", "]", ")", "[", "0", "]", "+", "1", "]", ")", "\n", "mincosts", "=", "np", ".", "minimum", ".", "reduceat", "(", "cost", ",", "splits", ")", "\n", "\n", "group_lengths", "=", "np", ".", "diff", "(", "np", ".", "hstack", "(", "[", "splits", ",", "len", "(", "ids", ")", "]", ")", ")", "\n", "all_argmin", "=", "np", ".", "flatnonzero", "(", "np", ".", "repeat", "(", "mincosts", ",", "group_lengths", ")", "==", "cost", ")", "\n", "result", "=", "np", ".", "full", "(", "len", "(", "group_lengths", ")", "if", "batch_size", "is", "None", "else", "batch_size", ",", "-", "1", ",", "dtype", "=", "int", ")", "\n", "\n", "result", "[", "ids", "[", "all_argmin", "[", ":", ":", "-", "1", "]", "]", "]", "=", "all_argmin", "[", ":", ":", "-", "1", "]", "\n", "\n", "return", "[", "sequences", "[", "i", "]", "if", "i", ">=", "0", "else", "None", "for", "i", "in", "result", "]", ",", "[", "cost", "[", "i", "]", "if", "i", ">=", "0", "else", "math", ".", "inf", "for", "i", "in", "result", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.eval.eval_dataset_mp": [[45, 54], ["utils.load_model", "model.problem.make_dataset", "torch.device", "eval._eval_dataset"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_model", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.None.eval._eval_dataset"], ["", "def", "eval_dataset_mp", "(", "args", ")", ":", "\n", "    ", "(", "dataset_path", ",", "width", ",", "softmax_temp", ",", "opts", ",", "i", ",", "num_processes", ")", "=", "args", "\n", "\n", "model", ",", "_", "=", "load_model", "(", "opts", ".", "model", ")", "\n", "val_size", "=", "opts", ".", "val_size", "//", "num_processes", "\n", "dataset", "=", "model", ".", "problem", ".", "make_dataset", "(", "filename", "=", "dataset_path", ",", "num_samples", "=", "val_size", ",", "offset", "=", "opts", ".", "offset", "+", "val_size", "*", "i", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:{}\"", ".", "format", "(", "i", ")", ")", "\n", "\n", "return", "_eval_dataset", "(", "model", ",", "dataset", ",", "width", ",", "softmax_temp", ",", "opts", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.eval.eval_dataset": [[56, 107], ["utils.load_model", "zip", "print", "print", "print", "print", "utils.load_model", "torch.cuda.is_available", "torch.cuda.device_count", "torch.device", "seeder.problem.make_dataset", "eval._eval_dataset", "print", "utils.load_model", "mp.Pool", "list", "numpy.mean", "numpy.mean", "datetime.timedelta", "itertools.chain.from_iterable", "numpy.sqrt", "numpy.mean", "numpy.sqrt", "numpy.mean", "pool.map", "numpy.std", "len", "numpy.sqrt", "numpy.std", "len", "int", "numpy.std", "len", "numpy.sum", "range"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_model", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_model", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.None.eval._eval_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_model"], ["", "def", "eval_dataset", "(", "dataset_path", ",", "width", ",", "softmax_temp", ",", "opts", ")", ":", "\n", "# Even with multiprocessing, we load the model here since it contains the name where to write results", "\n", "    ", "seeder", ",", "_", "=", "load_model", "(", "opts", ".", "seeder", ")", "\n", "\n", "\n", "if", "opts", ".", "problem", "==", "'tsp'", ":", "\n", "        ", "reviser", ",", "_", "=", "load_model", "(", "opts", ".", "reviser", ",", "is_local", "=", "True", ")", "\n", "\n", "if", "opts", ".", "reviser_2", "is", "not", "None", ":", "\n", "            ", "reviser_2", ",", "_", "=", "load_model", "(", "opts", ".", "reviser_2", ",", "is_local", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "reviser_2", "=", "None", "\n", "", "", "else", ":", "\n", "        ", "reviser", "=", "None", "\n", "reviser_2", "=", "None", "\n", "\n", "", "use_cuda", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "not", "opts", ".", "no_cuda", "\n", "\n", "if", "opts", ".", "multiprocessing", ":", "\n", "        ", "assert", "use_cuda", ",", "\"Can only do multiprocessing with cuda\"", "\n", "num_processes", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "assert", "opts", ".", "val_size", "%", "num_processes", "==", "0", "\n", "\n", "with", "mp", ".", "Pool", "(", "num_processes", ")", "as", "pool", ":", "\n", "            ", "results", "=", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "pool", ".", "map", "(", "\n", "eval_dataset_mp", ",", "\n", "[", "(", "dataset_path", ",", "width", ",", "softmax_temp", ",", "opts", ",", "i", ",", "num_processes", ")", "for", "i", "in", "range", "(", "num_processes", ")", "]", "\n", ")", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "use_cuda", "else", "\"cpu\"", ")", "\n", "dataset", "=", "seeder", ".", "problem", ".", "make_dataset", "(", "filename", "=", "dataset_path", ",", "num_samples", "=", "opts", ".", "val_size", ",", "offset", "=", "opts", ".", "offset", ")", "\n", "results", "=", "_eval_dataset", "(", "seeder", ",", "dataset", ",", "width", ",", "softmax_temp", ",", "opts", ",", "device", ",", "reviser", "=", "reviser", ",", "reviser_2", "=", "reviser_2", ")", "\n", "\n", "# This is parallelism, even if we use multiprocessing (we report as if we did not use multiprocessing, e.g. 1 GPU)", "\n", "", "parallelism", "=", "opts", ".", "eval_batch_size", "\n", "\n", "costs", ",", "costs_revised", ",", "tours", ",", "durations", "=", "zip", "(", "*", "results", ")", "# Not really costs since they should be negative", "\n", "\n", "print", "(", "\"Average cost: {} +- {}\"", ".", "format", "(", "np", ".", "mean", "(", "costs", ")", ",", "2", "*", "np", ".", "std", "(", "costs", ")", "/", "np", ".", "sqrt", "(", "len", "(", "costs", ")", ")", ")", ")", "\n", "if", "opts", ".", "problem", "==", "\"tsp\"", ":", "\n", "\n", "        ", "print", "(", "\"Average cost_revised: {} +- {}\"", ".", "format", "(", "np", ".", "mean", "(", "costs_revised", ")", ",", "2", "*", "np", ".", "std", "(", "costs_revised", ")", "/", "np", ".", "sqrt", "(", "len", "(", "costs_revised", ")", ")", ")", ")", "\n", "", "print", "(", "\"Average serial duration: {} +- {}\"", ".", "format", "(", "\n", "np", ".", "mean", "(", "durations", ")", ",", "2", "*", "np", ".", "std", "(", "durations", ")", "/", "np", ".", "sqrt", "(", "len", "(", "durations", ")", ")", ")", ")", "\n", "print", "(", "\"Average parallel duration: {}\"", ".", "format", "(", "np", ".", "mean", "(", "durations", ")", "/", "parallelism", ")", ")", "\n", "print", "(", "\"Calculated total duration: {}\"", ".", "format", "(", "timedelta", "(", "seconds", "=", "int", "(", "np", ".", "sum", "(", "durations", ")", "/", "parallelism", ")", ")", ")", ")", "\n", "\n", "\n", "\n", "return", "costs", ",", "tours", ",", "durations", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.eval._eval_dataset": [[109, 161], ["model.to", "model.eval", "model.set_decode_type", "torch.utils.data.DataLoader", "tqdm.tqdm", "reviser.to", "reviser.eval", "reviser.set_decode_type", "reviser_2.to", "reviser_2.eval", "reviser_2.set_decode_type", "utils.move_to", "time.time", "torch.no_grad", "time.time", "results.append", "results.append", "model.sample_many", "costs.item", "costs_revised.item", "costs.item"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.set_decode_type", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.set_decode_type", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.set_decode_type", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.move_to", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.sample_many"], ["", "def", "_eval_dataset", "(", "model", ",", "dataset", ",", "width", ",", "softmax_temp", ",", "opts", ",", "device", ",", "reviser", "=", "None", ",", "reviser_2", "=", "None", ")", ":", "\n", "\n", "    ", "model", ".", "to", "(", "device", ")", "\n", "model", ".", "eval", "(", ")", "\n", "if", "reviser", "is", "not", "None", ":", "\n", "        ", "reviser", ".", "to", "(", "device", ")", "\n", "reviser", ".", "eval", "(", ")", "\n", "reviser", ".", "set_decode_type", "(", "\"greedy\"", ")", "\n", "", "if", "reviser_2", "is", "not", "None", ":", "\n", "        ", "reviser_2", ".", "to", "(", "device", ")", "\n", "reviser_2", ".", "eval", "(", ")", "\n", "reviser_2", ".", "set_decode_type", "(", "\"greedy\"", ")", "\n", "\n", "", "model", ".", "set_decode_type", "(", "\n", "\"greedy\"", "if", "opts", ".", "decode_strategy", "in", "(", "'bs'", ",", "'greedy'", ")", "else", "\"sampling\"", ",", "\n", "temp", "=", "softmax_temp", ")", "\n", "\n", "dataloader", "=", "DataLoader", "(", "dataset", ",", "batch_size", "=", "opts", ".", "eval_batch_size", ")", "\n", "\n", "results", "=", "[", "]", "\n", "for", "batch", "in", "tqdm", "(", "dataloader", ",", "disable", "=", "opts", ".", "no_progress_bar", ")", ":", "\n", "        ", "batch", "=", "move_to", "(", "batch", ",", "device", ")", "\n", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "opts", ".", "decode_strategy", "in", "(", "'sample'", ",", "'greedy'", ")", ":", "\n", "                ", "if", "opts", ".", "decode_strategy", "==", "'greedy'", ":", "\n", "                    ", "assert", "width", "==", "0", ",", "\"Do not set width when using greedy\"", "\n", "assert", "opts", ".", "eval_batch_size", "<=", "opts", ".", "max_calc_batch_size", ",", "\"eval_batch_size should be smaller than calc batch size\"", "\n", "batch_rep", "=", "1", "\n", "iter_rep", "=", "1", "\n", "", "else", ":", "\n", "                    ", "batch_rep", "=", "width", "\n", "iter_rep", "=", "1", "\n", "", "assert", "batch_rep", ">", "0", "\n", "# This returns (batch_size, iter_rep shape)", "\n", "\n", "\n", "tours", ",", "costs", ",", "costs_revised", "=", "model", ".", "sample_many", "(", "batch", ",", "opts", ",", "batch_rep", "=", "batch_rep", ",", "iter_rep", "=", "iter_rep", ",", "reviser", "=", "reviser", ",", "reviser_2", "=", "reviser_2", ")", "\n", "\n", "\n", "\n", "\n", "", "", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "if", "costs_revised", "is", "not", "None", ":", "\n", "            ", "results", ".", "append", "(", "(", "costs", ".", "item", "(", ")", ",", "costs_revised", ".", "item", "(", ")", ",", "tours", ",", "duration", ")", ")", "\n", "", "else", ":", "\n", "            ", "results", ".", "append", "(", "(", "costs", ".", "item", "(", ")", ",", "None", ",", "tours", ",", "duration", ")", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.get_inner_model": [[15, 17], ["isinstance"], "function", ["None"], ["def", "get_inner_model", "(", "model", ")", ":", "\n", "    ", "return", "model", ".", "module", "if", "isinstance", "(", "model", ",", "DataParallel", ")", "else", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.validate": [[19, 28], ["print", "train.rollout", "rollout.mean", "print", "torch.std", "math.sqrt", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.train.rollout"], ["", "def", "validate", "(", "model", ",", "dataset", ",", "opts", ")", ":", "\n", "# Validate", "\n", "    ", "print", "(", "'Validating...'", ")", "\n", "cost", "=", "rollout", "(", "model", ",", "dataset", ",", "opts", ")", "\n", "avg_cost", "=", "cost", ".", "mean", "(", ")", "\n", "print", "(", "'Validation overall avg_cost: {} +- {}'", ".", "format", "(", "\n", "avg_cost", ",", "torch", ".", "std", "(", "cost", ")", "/", "math", ".", "sqrt", "(", "len", "(", "cost", ")", ")", ")", ")", "\n", "\n", "return", "avg_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.rollout": [[30, 45], ["nets.attention_model.set_decode_type", "model.eval", "torch.cat", "cost.data.cpu", "torch.no_grad", "model", "train.rollout.eval_model_bat"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.set_decode_type", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.cpu"], ["", "def", "rollout", "(", "model", ",", "dataset", ",", "opts", ")", ":", "\n", "# Put in greedy evaluation mode!", "\n", "    ", "set_decode_type", "(", "model", ",", "\"greedy\"", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "def", "eval_model_bat", "(", "bat", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "cost", ",", "_", ",", "_", "=", "model", "(", "move_to", "(", "bat", ",", "opts", ".", "device", ")", ")", "\n", "", "return", "cost", ".", "data", ".", "cpu", "(", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "[", "\n", "eval_model_bat", "(", "bat", ")", "\n", "for", "bat", "\n", "in", "tqdm", "(", "DataLoader", "(", "dataset", ",", "batch_size", "=", "opts", ".", "eval_batch_size", ")", ",", "disable", "=", "opts", ".", "no_progress_bar", ")", "\n", "]", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.clip_grad_norms": [[47, 65], ["torch.nn.utils.clip_grad_norm_", "min"], "function", ["None"], ["", "def", "clip_grad_norms", "(", "param_groups", ",", "max_norm", "=", "math", ".", "inf", ")", ":", "\n", "    ", "\"\"\"\n    Clips the norms for all param groups to max_norm and returns gradient norms before clipping\n    :param optimizer:\n    :param max_norm:\n    :param gradient_norms_log:\n    :return: grad_norms, clipped_grad_norms: list with (clipped) gradient norms per group\n    \"\"\"", "\n", "grad_norms", "=", "[", "\n", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "\n", "group", "[", "'params'", "]", ",", "\n", "max_norm", "if", "max_norm", ">", "0", "else", "math", ".", "inf", ",", "# Inf so no clipping but still call to calc", "\n", "norm_type", "=", "2", "\n", ")", "\n", "for", "group", "in", "param_groups", "\n", "]", "\n", "grad_norms_clipped", "=", "[", "min", "(", "g_norm", ",", "max_norm", ")", "for", "g_norm", "in", "grad_norms", "]", "if", "max_norm", ">", "0", "else", "grad_norms", "\n", "return", "grad_norms", ",", "grad_norms_clipped", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.train_epoch": [[67, 125], ["print", "time.time", "baseline.wrap_dataset", "torch.utils.data.DataLoader", "model.train", "nets.attention_model.set_decode_type", "enumerate", "print", "train.validate", "baseline.epoch_callback", "lr_scheduler.step", "tb_logger.log_value", "problem.make_dataset", "tqdm.tqdm", "train.train_batch", "time.time", "print", "torch.save", "tb_logger.log_value", "time.strftime", "os.path.join", "time.gmtime", "get_inner_model().state_dict", "optimizer.state_dict", "torch.get_rng_state", "torch.cuda.get_rng_state_all", "baseline.state_dict", "train.get_inner_model"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.wrap_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.set_decode_type", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.validate", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.epoch_callback", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.train_batch", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.get_inner_model"], ["", "def", "train_epoch", "(", "model", ",", "optimizer", ",", "baseline", ",", "lr_scheduler", ",", "epoch", ",", "val_dataset", ",", "problem", ",", "tb_logger", ",", "opts", ")", ":", "\n", "    ", "print", "(", "\"Start train epoch {}, lr={} for run {}\"", ".", "format", "(", "epoch", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", ",", "opts", ".", "run_name", ")", ")", "\n", "step", "=", "epoch", "*", "(", "opts", ".", "epoch_size", "//", "opts", ".", "batch_size", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "not", "opts", ".", "no_tensorboard", ":", "\n", "        ", "tb_logger", ".", "log_value", "(", "'learnrate_pg0'", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", ",", "step", ")", "\n", "\n", "# Generate new training data for each epoch", "\n", "", "training_dataset", "=", "baseline", ".", "wrap_dataset", "(", "problem", ".", "make_dataset", "(", "\n", "size", "=", "opts", ".", "graph_size", ",", "num_samples", "=", "opts", ".", "epoch_size", ",", "distribution", "=", "opts", ".", "data_distribution", ")", ")", "\n", "training_dataloader", "=", "DataLoader", "(", "training_dataset", ",", "batch_size", "=", "opts", ".", "batch_size", ",", "num_workers", "=", "1", ")", "\n", "\n", "# Put model in train mode!", "\n", "model", ".", "train", "(", ")", "\n", "set_decode_type", "(", "model", ",", "\"sampling\"", ")", "\n", "\n", "for", "batch_id", ",", "batch", "in", "enumerate", "(", "tqdm", "(", "training_dataloader", ",", "disable", "=", "opts", ".", "no_progress_bar", ")", ")", ":", "\n", "\n", "        ", "train_batch", "(", "\n", "model", ",", "\n", "optimizer", ",", "\n", "baseline", ",", "\n", "epoch", ",", "\n", "batch_id", ",", "\n", "step", ",", "\n", "batch", ",", "\n", "tb_logger", ",", "\n", "opts", "\n", ")", "\n", "\n", "step", "+=", "1", "\n", "\n", "", "epoch_duration", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"Finished epoch {}, took {} s\"", ".", "format", "(", "epoch", ",", "time", ".", "strftime", "(", "'%H:%M:%S'", ",", "time", ".", "gmtime", "(", "epoch_duration", ")", ")", ")", ")", "\n", "\n", "if", "(", "opts", ".", "checkpoint_epochs", "!=", "0", "and", "epoch", "%", "opts", ".", "checkpoint_epochs", "==", "0", ")", "or", "epoch", "==", "opts", ".", "n_epochs", "-", "1", ":", "\n", "        ", "print", "(", "'Saving model and state...'", ")", "\n", "torch", ".", "save", "(", "\n", "{", "\n", "'model'", ":", "get_inner_model", "(", "model", ")", ".", "state_dict", "(", ")", ",", "\n", "'optimizer'", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'rng_state'", ":", "torch", ".", "get_rng_state", "(", ")", ",", "\n", "'cuda_rng_state'", ":", "torch", ".", "cuda", ".", "get_rng_state_all", "(", ")", ",", "\n", "'baseline'", ":", "baseline", ".", "state_dict", "(", ")", "\n", "}", ",", "\n", "os", ".", "path", ".", "join", "(", "opts", ".", "save_dir", ",", "'epoch-{}.pt'", ".", "format", "(", "epoch", ")", ")", "\n", ")", "\n", "\n", "", "avg_reward", "=", "validate", "(", "model", ",", "val_dataset", ",", "opts", ")", "\n", "\n", "if", "not", "opts", ".", "no_tensorboard", ":", "\n", "        ", "tb_logger", ".", "log_value", "(", "'val_avg_reward'", ",", "avg_reward", ",", "step", ")", "\n", "\n", "", "baseline", ".", "epoch_callback", "(", "model", ",", "epoch", ")", "\n", "\n", "# lr_scheduler should be called at end of epoch", "\n", "lr_scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.train_batch": [[127, 166], ["baseline.unwrap_batch", "utils.move_to", "model", "optimizer.zero_grad", "loss.backward", "train.clip_grad_norms", "optimizer.step", "utils.move_to", "baseline.eval", "utils.log_utils.log_values", "int", "entropies.detach"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.unwrap_batch", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.move_to", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.clip_grad_norms", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.move_to", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.log_utils.log_values"], ["", "def", "train_batch", "(", "\n", "model", ",", "\n", "optimizer", ",", "\n", "baseline", ",", "\n", "epoch", ",", "\n", "batch_id", ",", "\n", "step", ",", "\n", "batch", ",", "\n", "tb_logger", ",", "\n", "opts", "\n", ")", ":", "\n", "    ", "x", ",", "bl_val", "=", "baseline", ".", "unwrap_batch", "(", "batch", ")", "\n", "x", "=", "move_to", "(", "x", ",", "opts", ".", "device", ")", "\n", "bl_val", "=", "move_to", "(", "bl_val", ",", "opts", ".", "device", ")", "if", "bl_val", "is", "not", "None", "else", "None", "\n", "\n", "# Evaluate model, get costs and log probabilities", "\n", "cost", ",", "log_likelihood", ",", "entropies", "=", "model", "(", "x", ")", "\n", "\n", "# Evaluate baseline, get baseline loss if any (only for critic)", "\n", "bl_val", ",", "bl_loss", "=", "baseline", ".", "eval", "(", "x", ",", "cost", ")", "if", "bl_val", "is", "None", "else", "(", "bl_val", ",", "0", ")", "\n", "\n", "\n", "\n", "# Calculate loss with Scaled Entropy Reward", "\n", "reinforce_loss", "=", "(", "(", "cost", "-", "bl_val", "-", "opts", ".", "alp", "*", "entropies", ".", "detach", "(", ")", ")", "*", "log_likelihood", ")", ".", "mean", "(", ")", "\n", "\n", "loss", "=", "reinforce_loss", "+", "bl_loss", "\n", "\n", "# Perform backward pass and optimization step", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "# Clip gradient norms and get (clipped) gradient norms for logging", "\n", "grad_norms", "=", "clip_grad_norms", "(", "optimizer", ".", "param_groups", ",", "opts", ".", "max_grad_norm", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Logging", "\n", "if", "step", "%", "int", "(", "opts", ".", "log_step", ")", "==", "0", ":", "\n", "        ", "log_values", "(", "cost", ",", "grad_norms", ",", "epoch", ",", "batch_id", ",", "step", ",", "\n", "log_likelihood", ",", "reinforce_loss", ",", "bl_loss", ",", "tb_logger", ",", "opts", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.run.run": [[25, 173], ["pprint.pprint", "torch.manual_seed", "torch.manual_seed", "os.makedirs", "torch.device", "torch.device", "utils.load_problem", "model_class().to", "train.get_inner_model", "train.get_inner_model.load_state_dict", "torch.Adam", "torch.lr_scheduler.LambdaLR", "utils.load_problem.make_dataset", "vars", "tensorboard_logger.Logger", "open", "json.dump", "print", "utils.torch_load_cpu", "torch.nn.DataParallel", "torch.nn.DataParallel", "reinforce_baselines.ExponentialBaseline", "reinforce_baselines.WarmupBaseline", "reinforce_baselines.NoBaseline.load_state_dict", "optim.Adam.load_state_dict", "optim.Adam.state.values", "int", "torch.set_rng_state", "torch.set_rng_state", "reinforce_baselines.NoBaseline.epoch_callback", "print", "train.validate", "range", "os.path.join", "os.path.join", "vars", "model_class", "torch.cuda.device_count", "torch.cuda.device_count", "train.get_inner_model.state_dict", "utils.torch_load_cpu.get", "reinforce_baselines.CriticBaseline", "state.items", "torch.cuda.set_rng_state_all", "torch.cuda.set_rng_state_all", "train.train_epoch", "reinforce_baselines.RolloutBaseline", "reinforce_baselines.NoBaseline", "torch.is_tensor", "torch.is_tensor", "[].split", "torch.nn.DataParallel.parameters", "len", "v.to", "reinforce_baselines.NoBaseline.get_learnable_parameters", "reinforce_baselines.NoBaseline.get_learnable_parameters", "nets.pointer_network.CriticNetworkLSTM", "nets.critic_network.CriticNetwork", "os.path.splitext", "os.path.split"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_problem", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.get_inner_model", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.torch_load_cpu", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.epoch_callback", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.validate", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.train_epoch", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.CriticBaseline.get_learnable_parameters", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.CriticBaseline.get_learnable_parameters"], ["def", "run", "(", "opts", ")", ":", "\n", "\n", "# Pretty print the run args", "\n", "    ", "pp", ".", "pprint", "(", "vars", "(", "opts", ")", ")", "\n", "\n", "# Set the random seed", "\n", "torch", ".", "manual_seed", "(", "opts", ".", "seed", ")", "\n", "\n", "# Optionally configure tensorboard", "\n", "tb_logger", "=", "None", "\n", "if", "not", "opts", ".", "no_tensorboard", ":", "\n", "        ", "tb_logger", "=", "TbLogger", "(", "os", ".", "path", ".", "join", "(", "opts", ".", "log_dir", ",", "\"{}_{}\"", ".", "format", "(", "opts", ".", "problem", ",", "opts", ".", "graph_size", ")", ",", "opts", ".", "run_name", ")", ")", "\n", "\n", "", "os", ".", "makedirs", "(", "opts", ".", "save_dir", ")", "\n", "# Save arguments so exact configuration can always be found", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "opts", ".", "save_dir", ",", "\"args.json\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "vars", "(", "opts", ")", ",", "f", ",", "indent", "=", "True", ")", "\n", "\n", "# Set the device", "\n", "", "opts", ".", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "opts", ".", "use_cuda", "else", "\"cpu\"", ")", "\n", "\n", "# Figure out what's the problem", "\n", "problem", "=", "load_problem", "(", "opts", ".", "problem", ")", "\n", "\n", "# Load data from load_path", "\n", "load_data", "=", "{", "}", "\n", "assert", "opts", ".", "load_path", "is", "None", "or", "opts", ".", "resume", "is", "None", ",", "\"Only one of load path and resume can be given\"", "\n", "load_path", "=", "opts", ".", "load_path", "if", "opts", ".", "load_path", "is", "not", "None", "else", "opts", ".", "resume", "\n", "if", "load_path", "is", "not", "None", ":", "\n", "        ", "print", "(", "'  [*] Loading data from {}'", ".", "format", "(", "load_path", ")", ")", "\n", "load_data", "=", "torch_load_cpu", "(", "load_path", ")", "\n", "\n", "# Initialize model", "\n", "", "model_class", "=", "{", "\n", "'attention'", ":", "AttentionModel", ",", "\n", "'pointer'", ":", "PointerNetwork", "\n", "}", ".", "get", "(", "opts", ".", "model", ",", "None", ")", "\n", "assert", "model_class", "is", "not", "None", ",", "\"Unknown model: {}\"", ".", "format", "(", "model_class", ")", "\n", "model", "=", "model_class", "(", "\n", "opts", ".", "embedding_dim", ",", "\n", "opts", ".", "hidden_dim", ",", "\n", "problem", ",", "\n", "n_encode_layers", "=", "opts", ".", "n_encode_layers", ",", "\n", "mask_inner", "=", "True", ",", "\n", "mask_logits", "=", "True", ",", "\n", "normalization", "=", "opts", ".", "normalization", ",", "\n", "tanh_clipping", "=", "opts", ".", "tanh_clipping", ",", "\n", "checkpoint_encoder", "=", "opts", ".", "checkpoint_encoder", ",", "\n", "shrink_size", "=", "opts", ".", "shrink_size", "\n", ")", ".", "to", "(", "opts", ".", "device", ")", "\n", "\n", "if", "opts", ".", "use_cuda", "and", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "1", ":", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ")", "\n", "\n", "# Overwrite model parameters by parameters to load", "\n", "", "model_", "=", "get_inner_model", "(", "model", ")", "\n", "model_", ".", "load_state_dict", "(", "{", "**", "model_", ".", "state_dict", "(", ")", ",", "**", "load_data", ".", "get", "(", "'model'", ",", "{", "}", ")", "}", ")", "\n", "\n", "# Initialize baseline", "\n", "if", "opts", ".", "baseline", "==", "'exponential'", ":", "\n", "        ", "baseline", "=", "ExponentialBaseline", "(", "opts", ".", "exp_beta", ")", "\n", "", "elif", "opts", ".", "baseline", "==", "'critic'", "or", "opts", ".", "baseline", "==", "'critic_lstm'", ":", "\n", "        ", "assert", "problem", ".", "NAME", "==", "'tsp'", ",", "\"Critic only supported for TSP\"", "\n", "baseline", "=", "CriticBaseline", "(", "\n", "(", "\n", "CriticNetworkLSTM", "(", "\n", "2", ",", "\n", "opts", ".", "embedding_dim", ",", "\n", "opts", ".", "hidden_dim", ",", "\n", "opts", ".", "n_encode_layers", ",", "\n", "opts", ".", "tanh_clipping", "\n", ")", "\n", "if", "opts", ".", "baseline", "==", "'critic_lstm'", "\n", "else", "\n", "CriticNetwork", "(", "\n", "2", ",", "\n", "opts", ".", "embedding_dim", ",", "\n", "opts", ".", "hidden_dim", ",", "\n", "opts", ".", "n_encode_layers", ",", "\n", "opts", ".", "normalization", "\n", ")", "\n", ")", ".", "to", "(", "opts", ".", "device", ")", "\n", ")", "\n", "", "elif", "opts", ".", "baseline", "==", "'rollout'", ":", "\n", "        ", "baseline", "=", "RolloutBaseline", "(", "model", ",", "problem", ",", "opts", ")", "\n", "", "else", ":", "\n", "        ", "assert", "opts", ".", "baseline", "is", "None", ",", "\"Unknown baseline: {}\"", ".", "format", "(", "opts", ".", "baseline", ")", "\n", "baseline", "=", "NoBaseline", "(", ")", "\n", "\n", "", "if", "opts", ".", "bl_warmup_epochs", ">", "0", ":", "\n", "        ", "baseline", "=", "WarmupBaseline", "(", "baseline", ",", "opts", ".", "bl_warmup_epochs", ",", "warmup_exp_beta", "=", "opts", ".", "exp_beta", ")", "\n", "\n", "# Load baseline from data, make sure script is called with same type of baseline", "\n", "", "if", "'baseline'", "in", "load_data", ":", "\n", "        ", "baseline", ".", "load_state_dict", "(", "load_data", "[", "'baseline'", "]", ")", "\n", "\n", "# Initialize optimizer", "\n", "", "optimizer", "=", "optim", ".", "Adam", "(", "\n", "[", "{", "'params'", ":", "model", ".", "parameters", "(", ")", ",", "'lr'", ":", "opts", ".", "lr_model", "}", "]", "\n", "+", "(", "\n", "[", "{", "'params'", ":", "baseline", ".", "get_learnable_parameters", "(", ")", ",", "'lr'", ":", "opts", ".", "lr_critic", "}", "]", "\n", "if", "len", "(", "baseline", ".", "get_learnable_parameters", "(", ")", ")", ">", "0", "\n", "else", "[", "]", "\n", ")", "\n", ")", "\n", "\n", "# Load optimizer state", "\n", "if", "'optimizer'", "in", "load_data", ":", "\n", "        ", "optimizer", ".", "load_state_dict", "(", "load_data", "[", "'optimizer'", "]", ")", "\n", "for", "state", "in", "optimizer", ".", "state", ".", "values", "(", ")", ":", "\n", "            ", "for", "k", ",", "v", "in", "state", ".", "items", "(", ")", ":", "\n", "# if isinstance(v, torch.Tensor):", "\n", "                ", "if", "torch", ".", "is_tensor", "(", "v", ")", ":", "\n", "                    ", "state", "[", "k", "]", "=", "v", ".", "to", "(", "opts", ".", "device", ")", "\n", "\n", "# Initialize learning rate scheduler, decay by lr_decay once per epoch!", "\n", "", "", "", "", "lr_scheduler", "=", "optim", ".", "lr_scheduler", ".", "LambdaLR", "(", "optimizer", ",", "lambda", "epoch", ":", "opts", ".", "lr_decay", "**", "epoch", ")", "\n", "\n", "# Start the actual training loop", "\n", "val_dataset", "=", "problem", ".", "make_dataset", "(", "\n", "size", "=", "opts", ".", "graph_size", ",", "num_samples", "=", "opts", ".", "val_size", ",", "filename", "=", "opts", ".", "val_dataset", ",", "distribution", "=", "opts", ".", "data_distribution", ")", "\n", "\n", "if", "opts", ".", "resume", ":", "\n", "        ", "epoch_resume", "=", "int", "(", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "split", "(", "opts", ".", "resume", ")", "[", "-", "1", "]", ")", "[", "0", "]", ".", "split", "(", "\"-\"", ")", "[", "1", "]", ")", "\n", "\n", "torch", ".", "set_rng_state", "(", "load_data", "[", "'rng_state'", "]", ")", "\n", "if", "opts", ".", "use_cuda", ":", "\n", "            ", "torch", ".", "cuda", ".", "set_rng_state_all", "(", "load_data", "[", "'cuda_rng_state'", "]", ")", "\n", "# Set the random states", "\n", "# Dumping of state was done before epoch callback, so do that now (model is loaded)", "\n", "", "baseline", ".", "epoch_callback", "(", "model", ",", "epoch_resume", ")", "\n", "print", "(", "\"Resuming after {}\"", ".", "format", "(", "epoch_resume", ")", ")", "\n", "opts", ".", "epoch_start", "=", "epoch_resume", "+", "1", "\n", "\n", "", "if", "opts", ".", "eval_only", ":", "\n", "        ", "validate", "(", "model", ",", "val_dataset", ",", "opts", ")", "\n", "", "else", ":", "\n", "        ", "for", "epoch", "in", "range", "(", "opts", ".", "epoch_start", ",", "opts", ".", "epoch_start", "+", "opts", ".", "n_epochs", ")", ":", "\n", "            ", "train_epoch", "(", "\n", "model", ",", "\n", "optimizer", ",", "\n", "baseline", ",", "\n", "lr_scheduler", ",", "\n", "epoch", ",", "\n", "val_dataset", ",", "\n", "problem", ",", "\n", "tb_logger", ",", "\n", "opts", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.generate_data.generate_tsp_data": [[7, 9], ["numpy.random.uniform().tolist", "numpy.random.uniform"], "function", ["None"], ["def", "generate_tsp_data", "(", "dataset_size", ",", "tsp_size", ")", ":", "\n", "    ", "return", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "tsp_size", ",", "2", ")", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.generate_data.generate_vrp_data": [[11, 25], ["list", "zip", "numpy.random.uniform().tolist", "numpy.random.uniform().tolist", "numpy.random.randint().tolist", "numpy.full().tolist", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.randint", "numpy.full"], "function", ["None"], ["", "def", "generate_vrp_data", "(", "dataset_size", ",", "vrp_size", ")", ":", "\n", "    ", "CAPACITIES", "=", "{", "\n", "10", ":", "20.", ",", "\n", "20", ":", "30.", ",", "\n", "50", ":", "40.", ",", "\n", "100", ":", "50.", ",", "\n", "200", ":", "50.", ",", "\n", "500", ":", "50.", "\n", "}", "\n", "return", "list", "(", "zip", "(", "\n", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "2", ")", ")", ".", "tolist", "(", ")", ",", "# Depot location", "\n", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "vrp_size", ",", "2", ")", ")", ".", "tolist", "(", ")", ",", "# Node locations", "\n", "np", ".", "random", ".", "randint", "(", "1", ",", "10", ",", "size", "=", "(", "dataset_size", ",", "vrp_size", ")", ")", ".", "tolist", "(", ")", ",", "# Demand, uniform integer 1 ... 9", "\n", "np", ".", "full", "(", "dataset_size", ",", "CAPACITIES", "[", "vrp_size", "]", ")", ".", "tolist", "(", ")", "# Capacity, same for whole dataset", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.generate_data.generate_op_data": [[28, 55], ["numpy.random.uniform", "numpy.random.uniform", "list", "numpy.ones", "zip", "numpy.linalg.norm", "np.random.uniform.tolist", "np.random.uniform.tolist", "np.ones.tolist", "numpy.full().tolist", "numpy.random.randint", "numpy.full", "np.linalg.norm.max"], "function", ["None"], ["", "def", "generate_op_data", "(", "dataset_size", ",", "op_size", ",", "prize_type", "=", "'const'", ")", ":", "\n", "    ", "depot", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "2", ")", ")", "\n", "loc", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "op_size", ",", "2", ")", ")", "\n", "\n", "# Methods taken from Fischetti et al. 1998", "\n", "if", "prize_type", "==", "'const'", ":", "\n", "        ", "prize", "=", "np", ".", "ones", "(", "(", "dataset_size", ",", "op_size", ")", ")", "\n", "", "elif", "prize_type", "==", "'unif'", ":", "\n", "        ", "prize", "=", "(", "1", "+", "np", ".", "random", ".", "randint", "(", "0", ",", "100", ",", "size", "=", "(", "dataset_size", ",", "op_size", ")", ")", ")", "/", "100.", "\n", "", "else", ":", "# Based on distance to depot", "\n", "        ", "assert", "prize_type", "==", "'dist'", "\n", "prize_", "=", "np", ".", "linalg", ".", "norm", "(", "depot", "[", ":", ",", "None", ",", ":", "]", "-", "loc", ",", "axis", "=", "-", "1", ")", "\n", "prize", "=", "(", "1", "+", "(", "prize_", "/", "prize_", ".", "max", "(", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "*", "99", ")", ".", "astype", "(", "int", ")", ")", "/", "100.", "\n", "\n", "# Max length is approximately half of optimal TSP tour, such that half (a bit more) of the nodes can be visited", "\n", "# which is maximally difficult as this has the largest number of possibilities", "\n", "", "MAX_LENGTHS", "=", "{", "\n", "20", ":", "2.", ",", "\n", "50", ":", "3.", ",", "\n", "100", ":", "4.", "\n", "}", "\n", "\n", "return", "list", "(", "zip", "(", "\n", "depot", ".", "tolist", "(", ")", ",", "\n", "loc", ".", "tolist", "(", ")", ",", "\n", "prize", ".", "tolist", "(", ")", ",", "\n", "np", ".", "full", "(", "dataset_size", ",", "MAX_LENGTHS", "[", "op_size", "]", ")", ".", "tolist", "(", ")", "# Capacity, same for whole dataset", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.generate_data.generate_pctsp_data": [[58, 95], ["numpy.random.uniform", "numpy.random.uniform", "list", "float", "numpy.random.uniform", "float", "zip", "numpy.random.uniform", "numpy.random.uniform", "np.random.uniform.tolist", "np.random.uniform.tolist", "penalty.tolist", "deterministic_prize.tolist", "stochastic_prize.tolist"], "function", ["None"], ["", "def", "generate_pctsp_data", "(", "dataset_size", ",", "pctsp_size", ",", "penalty_factor", "=", "3", ")", ":", "\n", "    ", "depot", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "2", ")", ")", "\n", "loc", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "pctsp_size", ",", "2", ")", ")", "\n", "\n", "# For the penalty to make sense it should be not too large (in which case all nodes will be visited) nor too small", "\n", "# so we want the objective term to be approximately equal to the length of the tour, which we estimate with half", "\n", "# of the nodes by half of the tour length (which is very rough but similar to op)", "\n", "# This means that the sum of penalties for all nodes will be approximately equal to the tour length (on average)", "\n", "# The expected total (uniform) penalty of half of the nodes (since approx half will be visited by the constraint)", "\n", "# is (n / 2) / 2 = n / 4 so divide by this means multiply by 4 / n,", "\n", "# However instead of 4 we use penalty_factor (3 works well) so we can make them larger or smaller", "\n", "MAX_LENGTHS", "=", "{", "\n", "20", ":", "2.", ",", "\n", "50", ":", "3.", ",", "\n", "100", ":", "4.", "\n", "}", "\n", "penalty_max", "=", "MAX_LENGTHS", "[", "pctsp_size", "]", "*", "(", "penalty_factor", ")", "/", "float", "(", "pctsp_size", ")", "\n", "penalty", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "pctsp_size", ")", ")", "*", "penalty_max", "\n", "\n", "# Take uniform prizes", "\n", "# Now expectation is 0.5 so expected total prize is n / 2, we want to force to visit approximately half of the nodes", "\n", "# so the constraint will be that total prize >= (n / 2) / 2 = n / 4", "\n", "# equivalently, we divide all prizes by n / 4 and the total prize should be >= 1", "\n", "deterministic_prize", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "pctsp_size", ")", ")", "*", "4", "/", "float", "(", "pctsp_size", ")", "\n", "\n", "# In the deterministic setting, the stochastic_prize is not used and the deterministic prize is known", "\n", "# In the stochastic setting, the deterministic prize is the expected prize and is known up front but the", "\n", "# stochastic prize is only revealed once the node is visited", "\n", "# Stochastic prize is between (0, 2 * expected_prize) such that E(stochastic prize) = E(deterministic_prize)", "\n", "stochastic_prize", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "dataset_size", ",", "pctsp_size", ")", ")", "*", "deterministic_prize", "*", "2", "\n", "\n", "return", "list", "(", "zip", "(", "\n", "depot", ".", "tolist", "(", ")", ",", "\n", "loc", ".", "tolist", "(", ")", ",", "\n", "penalty", ".", "tolist", "(", ")", ",", "\n", "deterministic_prize", ".", "tolist", "(", ")", ",", "\n", "stochastic_prize", ".", "tolist", "(", ")", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.Baseline.wrap_dataset": [[10, 12], ["None"], "methods", ["None"], ["    ", "def", "wrap_dataset", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.Baseline.unwrap_batch": [[13, 15], ["None"], "methods", ["None"], ["", "def", "unwrap_batch", "(", "self", ",", "batch", ")", ":", "\n", "        ", "return", "batch", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.Baseline.eval": [[16, 18], ["NotImplementedError"], "methods", ["None"], ["", "def", "eval", "(", "self", ",", "x", ",", "c", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Override this method\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.Baseline.get_learnable_parameters": [[19, 21], ["None"], "methods", ["None"], ["", "def", "get_learnable_parameters", "(", "self", ")", ":", "\n", "        ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.Baseline.epoch_callback": [[22, 24], ["None"], "methods", ["None"], ["", "def", "epoch_callback", "(", "self", ",", "model", ",", "epoch", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.Baseline.state_dict": [[25, 27], ["None"], "methods", ["None"], ["", "def", "state_dict", "(", "self", ")", ":", "\n", "        ", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.Baseline.load_state_dict": [[28, 30], ["None"], "methods", ["None"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.WarmupBaseline.__init__": [[34, 42], ["object.__init__", "reinforce_baselines.ExponentialBaseline"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "baseline", ",", "n_epochs", "=", "1", ",", "warmup_exp_beta", "=", "0.8", ",", ")", ":", "\n", "        ", "super", "(", "Baseline", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "baseline", "=", "baseline", "\n", "assert", "n_epochs", ">", "0", ",", "\"n_epochs to warmup must be positive\"", "\n", "self", ".", "warmup_baseline", "=", "ExponentialBaseline", "(", "warmup_exp_beta", ")", "\n", "self", ".", "alpha", "=", "0", "\n", "self", ".", "n_epochs", "=", "n_epochs", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.WarmupBaseline.wrap_dataset": [[43, 47], ["reinforce_baselines.WarmupBaseline.warmup_baseline.wrap_dataset", "reinforce_baselines.WarmupBaseline.baseline.wrap_dataset"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.wrap_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.wrap_dataset"], ["", "def", "wrap_dataset", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "if", "self", ".", "alpha", ">", "0", ":", "\n", "            ", "return", "self", ".", "baseline", ".", "wrap_dataset", "(", "dataset", ")", "\n", "", "return", "self", ".", "warmup_baseline", ".", "wrap_dataset", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.WarmupBaseline.unwrap_batch": [[48, 52], ["reinforce_baselines.WarmupBaseline.warmup_baseline.unwrap_batch", "reinforce_baselines.WarmupBaseline.baseline.unwrap_batch"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.unwrap_batch", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.unwrap_batch"], ["", "def", "unwrap_batch", "(", "self", ",", "batch", ")", ":", "\n", "        ", "if", "self", ".", "alpha", ">", "0", ":", "\n", "            ", "return", "self", ".", "baseline", ".", "unwrap_batch", "(", "batch", ")", "\n", "", "return", "self", ".", "warmup_baseline", ".", "unwrap_batch", "(", "batch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.WarmupBaseline.eval": [[53, 63], ["reinforce_baselines.WarmupBaseline.baseline.eval", "reinforce_baselines.WarmupBaseline.warmup_baseline.eval", "reinforce_baselines.WarmupBaseline.baseline.eval", "reinforce_baselines.WarmupBaseline.warmup_baseline.eval"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval"], ["", "def", "eval", "(", "self", ",", "x", ",", "c", ")", ":", "\n", "\n", "        ", "if", "self", ".", "alpha", "==", "1", ":", "\n", "            ", "return", "self", ".", "baseline", ".", "eval", "(", "x", ",", "c", ")", "\n", "", "if", "self", ".", "alpha", "==", "0", ":", "\n", "            ", "return", "self", ".", "warmup_baseline", ".", "eval", "(", "x", ",", "c", ")", "\n", "", "v", ",", "l", "=", "self", ".", "baseline", ".", "eval", "(", "x", ",", "c", ")", "\n", "vw", ",", "lw", "=", "self", ".", "warmup_baseline", ".", "eval", "(", "x", ",", "c", ")", "\n", "# Return convex combination of baseline and of loss", "\n", "return", "self", ".", "alpha", "*", "v", "+", "(", "1", "-", "self", ".", "alpha", ")", "*", "vw", ",", "self", ".", "alpha", "*", "l", "+", "(", "1", "-", "self", ".", "alpha", "*", "lw", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.WarmupBaseline.epoch_callback": [[64, 70], ["reinforce_baselines.WarmupBaseline.baseline.epoch_callback", "float", "print"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.epoch_callback"], ["", "def", "epoch_callback", "(", "self", ",", "model", ",", "epoch", ")", ":", "\n", "# Need to call epoch callback of inner model (also after first epoch if we have not used it)", "\n", "        ", "self", ".", "baseline", ".", "epoch_callback", "(", "model", ",", "epoch", ")", "\n", "self", ".", "alpha", "=", "(", "epoch", "+", "1", ")", "/", "float", "(", "self", ".", "n_epochs", ")", "\n", "if", "epoch", "<", "self", ".", "n_epochs", ":", "\n", "            ", "print", "(", "\"Set warmup alpha = {}\"", ".", "format", "(", "self", ".", "alpha", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.WarmupBaseline.state_dict": [[71, 74], ["reinforce_baselines.WarmupBaseline.baseline.state_dict"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict"], ["", "", "def", "state_dict", "(", "self", ")", ":", "\n", "# Checkpointing within warmup stage makes no sense, only save inner baseline", "\n", "        ", "return", "self", ".", "baseline", ".", "state_dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.WarmupBaseline.load_state_dict": [[75, 78], ["reinforce_baselines.WarmupBaseline.baseline.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ")", ":", "\n", "# Checkpointing within warmup stage makes no sense, only load inner baseline", "\n", "        ", "self", ".", "baseline", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.NoBaseline.eval": [[82, 84], ["None"], "methods", ["None"], ["    ", "def", "eval", "(", "self", ",", "x", ",", "c", ")", ":", "\n", "        ", "return", "0", ",", "0", "# No baseline, no loss", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.ExponentialBaseline.__init__": [[88, 93], ["object.__init__"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "beta", ")", ":", "\n", "        ", "super", "(", "Baseline", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "v", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.ExponentialBaseline.eval": [[94, 103], ["c.mean.detach", "c.mean", "c.mean"], "methods", ["None"], ["", "def", "eval", "(", "self", ",", "x", ",", "c", ")", ":", "\n", "\n", "        ", "if", "self", ".", "v", "is", "None", ":", "\n", "            ", "v", "=", "c", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "            ", "v", "=", "self", ".", "beta", "*", "self", ".", "v", "+", "(", "1.", "-", "self", ".", "beta", ")", "*", "c", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "v", "=", "v", ".", "detach", "(", ")", "# Detach since we never want to backprop", "\n", "return", "self", ".", "v", ",", "0", "# No loss", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.ExponentialBaseline.state_dict": [[104, 107], ["None"], "methods", ["None"], ["", "def", "state_dict", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "'v'", ":", "self", ".", "v", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.ExponentialBaseline.load_state_dict": [[109, 111], ["None"], "methods", ["None"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ")", ":", "\n", "        ", "self", ".", "v", "=", "state_dict", "[", "'v'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.CriticBaseline.__init__": [[115, 119], ["object.__init__"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "critic", ")", ":", "\n", "        ", "super", "(", "Baseline", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "critic", "=", "critic", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.CriticBaseline.eval": [[120, 124], ["reinforce_baselines.CriticBaseline.critic", "reinforce_baselines.CriticBaseline.detach", "torch.mse_loss", "torch.mse_loss", "c.detach"], "methods", ["None"], ["", "def", "eval", "(", "self", ",", "x", ",", "c", ")", ":", "\n", "        ", "v", "=", "self", ".", "critic", "(", "x", ")", "\n", "# Detach v since actor should not backprop through baseline, only for loss", "\n", "return", "v", ".", "detach", "(", ")", ",", "F", ".", "mse_loss", "(", "v", ",", "c", ".", "detach", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.CriticBaseline.get_learnable_parameters": [[125, 127], ["list", "reinforce_baselines.CriticBaseline.critic.parameters"], "methods", ["None"], ["", "def", "get_learnable_parameters", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "self", ".", "critic", ".", "parameters", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.CriticBaseline.epoch_callback": [[128, 130], ["None"], "methods", ["None"], ["", "def", "epoch_callback", "(", "self", ",", "model", ",", "epoch", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.CriticBaseline.state_dict": [[131, 134], ["reinforce_baselines.CriticBaseline.critic.state_dict"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict"], ["", "def", "state_dict", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "'critic'", ":", "self", ".", "critic", ".", "state_dict", "(", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.CriticBaseline.load_state_dict": [[136, 141], ["state_dict.get", "reinforce_baselines.CriticBaseline.critic.load_state_dict", "isinstance", "critic_state_dict.state_dict.state_dict.state_dict", "reinforce_baselines.CriticBaseline.critic.state_dict"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ")", ":", "\n", "        ", "critic_state_dict", "=", "state_dict", ".", "get", "(", "'critic'", ",", "{", "}", ")", "\n", "if", "not", "isinstance", "(", "critic_state_dict", ",", "dict", ")", ":", "# backwards compatibility", "\n", "            ", "critic_state_dict", "=", "critic_state_dict", ".", "state_dict", "(", ")", "\n", "", "self", ".", "critic", ".", "load_state_dict", "(", "{", "**", "self", ".", "critic", ".", "state_dict", "(", ")", ",", "**", "critic_state_dict", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.__init__": [[145, 152], ["object.__init__", "reinforce_baselines.RolloutBaseline._update_model"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline._update_model"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "problem", ",", "opts", ",", "epoch", "=", "0", ")", ":", "\n", "        ", "super", "(", "Baseline", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "problem", "=", "problem", "\n", "self", ".", "opts", "=", "opts", "\n", "\n", "self", ".", "_update_model", "(", "model", ",", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline._update_model": [[153, 174], ["copy.deepcopy", "print", "train.rollout().cpu().numpy", "reinforce_baselines.RolloutBaseline.bl_vals.mean", "reinforce_baselines.RolloutBaseline.problem.make_dataset", "len", "print", "train.rollout().cpu", "print", "train.rollout"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.cpu", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.rollout"], ["", "def", "_update_model", "(", "self", ",", "model", ",", "epoch", ",", "dataset", "=", "None", ")", ":", "\n", "        ", "self", ".", "model", "=", "copy", ".", "deepcopy", "(", "model", ")", "\n", "# Always generate baseline dataset when updating model to prevent overfitting to the baseline dataset", "\n", "\n", "if", "dataset", "is", "not", "None", ":", "\n", "            ", "if", "len", "(", "dataset", ")", "!=", "self", ".", "opts", ".", "val_size", ":", "\n", "                ", "print", "(", "\"Warning: not using saved baseline dataset since val_size does not match\"", ")", "\n", "dataset", "=", "None", "\n", "", "elif", "(", "dataset", "[", "0", "]", "if", "self", ".", "problem", ".", "NAME", "==", "'tsp'", "else", "dataset", "[", "0", "]", "[", "'loc'", "]", ")", ".", "size", "(", "0", ")", "!=", "self", ".", "opts", ".", "graph_size", ":", "\n", "                ", "print", "(", "\"Warning: not using saved baseline dataset since graph_size does not match\"", ")", "\n", "dataset", "=", "None", "\n", "\n", "", "", "if", "dataset", "is", "None", ":", "\n", "            ", "self", ".", "dataset", "=", "self", ".", "problem", ".", "make_dataset", "(", "\n", "size", "=", "self", ".", "opts", ".", "graph_size", ",", "num_samples", "=", "self", ".", "opts", ".", "val_size", ",", "distribution", "=", "self", ".", "opts", ".", "data_distribution", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "dataset", "=", "dataset", "\n", "", "print", "(", "\"Evaluating baseline model on evaluation dataset\"", ")", "\n", "self", ".", "bl_vals", "=", "rollout", "(", "self", ".", "model", ",", "self", ".", "dataset", ",", "self", ".", "opts", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "mean", "=", "self", ".", "bl_vals", ".", "mean", "(", ")", "\n", "self", ".", "epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.wrap_dataset": [[175, 180], ["print", "reinforce_baselines.BaselineDataset", "train.rollout().view", "train.rollout"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.train.rollout"], ["", "def", "wrap_dataset", "(", "self", ",", "dataset", ")", ":", "\n", "        ", "print", "(", "\"Evaluating baseline on dataset...\"", ")", "\n", "# Need to convert baseline to 2D to prevent converting to double, see", "\n", "# https://discuss.pytorch.org/t/dataloader-gives-double-instead-of-float/717/3", "\n", "return", "BaselineDataset", "(", "dataset", ",", "rollout", "(", "self", ".", "model", ",", "dataset", ",", "self", ".", "opts", ")", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.unwrap_batch": [[181, 183], ["batch[].view"], "methods", ["None"], ["", "def", "unwrap_batch", "(", "self", ",", "batch", ")", ":", "\n", "        ", "return", "batch", "[", "'data'", "]", ",", "batch", "[", "'baseline'", "]", ".", "view", "(", "-", "1", ")", "# Flatten result to undo wrapping as 2D", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval": [[184, 191], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "reinforce_baselines.RolloutBaseline.model"], "methods", ["None"], ["", "def", "eval", "(", "self", ",", "x", ",", "c", ")", ":", "\n", "# Use volatile mode for efficient inference (single batch so we do not use rollout function)", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "v", ",", "_", "=", "self", ".", "model", "(", "x", ")", "\n", "\n", "# There is no loss", "\n", "", "return", "v", ",", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.epoch_callback": [[192, 215], ["print", "train.rollout().cpu().numpy", "train.rollout().cpu().numpy.mean", "print", "scipy.stats.ttest_rel", "print", "train.rollout().cpu", "print", "reinforce_baselines.RolloutBaseline._update_model", "train.rollout"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.cpu", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline._update_model", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.rollout"], ["", "def", "epoch_callback", "(", "self", ",", "model", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Challenges the current baseline with the model and replaces the baseline model if it is improved.\n        :param model: The model to challenge the baseline by\n        :param epoch: The current epoch\n        \"\"\"", "\n", "print", "(", "\"Evaluating candidate model on evaluation dataset\"", ")", "\n", "candidate_vals", "=", "rollout", "(", "model", ",", "self", ".", "dataset", ",", "self", ".", "opts", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "candidate_mean", "=", "candidate_vals", ".", "mean", "(", ")", "\n", "\n", "print", "(", "\"Epoch {} candidate mean {}, baseline epoch {} mean {}, difference {}\"", ".", "format", "(", "\n", "epoch", ",", "candidate_mean", ",", "self", ".", "epoch", ",", "self", ".", "mean", ",", "candidate_mean", "-", "self", ".", "mean", ")", ")", "\n", "if", "candidate_mean", "-", "self", ".", "mean", "<", "0", ":", "\n", "# Calc p value", "\n", "            ", "t", ",", "p", "=", "ttest_rel", "(", "candidate_vals", ",", "self", ".", "bl_vals", ")", "\n", "\n", "p_val", "=", "p", "/", "2", "# one-sided", "\n", "assert", "t", "<", "0", ",", "\"T-statistic should be negative\"", "\n", "print", "(", "\"p-value: {}\"", ".", "format", "(", "p_val", ")", ")", "\n", "if", "p_val", "<", "self", ".", "opts", ".", "bl_alpha", ":", "\n", "                ", "print", "(", "'Update baseline'", ")", "\n", "self", ".", "_update_model", "(", "model", ",", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict": [[216, 221], ["None"], "methods", ["None"], ["", "", "", "def", "state_dict", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "'model'", ":", "self", ".", "model", ",", "\n", "'dataset'", ":", "self", ".", "dataset", ",", "\n", "'epoch'", ":", "self", ".", "epoch", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.load_state_dict": [[223, 228], ["copy.deepcopy", "train.get_inner_model().load_state_dict", "reinforce_baselines.RolloutBaseline._update_model", "train.get_inner_model().state_dict", "train.get_inner_model", "train.get_inner_model"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline._update_model", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.get_inner_model", "home.repos.pwc.inspect_result.alstn12088_lcp.None.train.get_inner_model"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ")", ":", "\n", "# We make it such that it works whether model was saved as data parallel or not", "\n", "        ", "load_model", "=", "copy", ".", "deepcopy", "(", "self", ".", "model", ")", "\n", "get_inner_model", "(", "load_model", ")", ".", "load_state_dict", "(", "get_inner_model", "(", "state_dict", "[", "'model'", "]", ")", ".", "state_dict", "(", ")", ")", "\n", "self", ".", "_update_model", "(", "load_model", ",", "state_dict", "[", "'epoch'", "]", ",", "state_dict", "[", "'dataset'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.BaselineDataset.__init__": [[232, 238], ["torch.utils.data.Dataset.__init__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset", "=", "None", ",", "baseline", "=", "None", ")", ":", "\n", "        ", "super", "(", "BaselineDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "baseline", "=", "baseline", "\n", "assert", "(", "len", "(", "self", ".", "dataset", ")", "==", "len", "(", "self", ".", "baseline", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.BaselineDataset.__getitem__": [[239, 243], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "return", "{", "\n", "'data'", ":", "self", ".", "dataset", "[", "item", "]", ",", "\n", "'baseline'", ":", "self", ".", "baseline", "[", "item", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.BaselineDataset.__len__": [[245, 247], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "dataset", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.ids": [[68, 71], ["beam_search.BatchBeam.state.ids.view"], "methods", ["None"], ["@", "property", "\n", "def", "ids", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state", ".", "ids", ".", "view", "(", "-", "1", ")", "# Need to flat as state has steps dimension", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.__getitem__": [[72, 80], ["beam_search.BatchBeam._replace", "torch.is_tensor", "isinstance"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "# If tensor, idx all tensors by this tensor:", "\n", "return", "self", ".", "_replace", "(", "\n", "# ids=self.ids[key],", "\n", "score", "=", "self", ".", "score", "[", "key", "]", "if", "self", ".", "score", "is", "not", "None", "else", "None", ",", "\n", "state", "=", "self", ".", "state", "[", "key", "]", ",", "\n", "parent", "=", "self", ".", "parent", "[", "key", "]", "if", "self", ".", "parent", "is", "not", "None", "else", "None", ",", "\n", "action", "=", "self", ".", "action", "[", "key", "]", "if", "self", ".", "action", "is", "not", "None", "else", "None", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.initialize": [[86, 97], ["len", "beam_search.BatchBeam", "torch.zeros"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "initialize", "(", "state", ")", ":", "\n", "        ", "batch_size", "=", "len", "(", "state", ".", "ids", ")", "\n", "device", "=", "state", ".", "ids", ".", "device", "\n", "return", "BatchBeam", "(", "\n", "score", "=", "torch", ".", "zeros", "(", "batch_size", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", ",", "\n", "state", "=", "state", ",", "\n", "parent", "=", "None", ",", "\n", "action", "=", "None", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "device", "=", "device", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.propose_expansions": [[99, 105], ["beam_search.BatchBeam.state.get_mask", "torch.nonzero", "torch.unbind"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_mask"], ["", "def", "propose_expansions", "(", "self", ")", ":", "\n", "        ", "mask", "=", "self", ".", "state", ".", "get_mask", "(", ")", "\n", "# Mask always contains a feasible action", "\n", "expansions", "=", "torch", ".", "nonzero", "(", "mask", "[", ":", ",", "0", ",", ":", "]", "==", "0", ")", "\n", "parent", ",", "action", "=", "torch", ".", "unbind", "(", "expansions", ",", "-", "1", ")", "\n", "return", "parent", ",", "action", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand": [[106, 112], ["beam_search.BatchBeam._replace", "beam_search.BatchBeam.state[].update"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.update"], ["", "def", "expand", "(", "self", ",", "parent", ",", "action", ",", "score", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "_replace", "(", "\n", "score", "=", "score", ",", "# The score is cleared upon expanding as it is no longer valid, or it must be provided", "\n", "state", "=", "self", ".", "state", "[", "parent", "]", ".", "update", "(", "action", ")", ",", "# Pass ids since we replicated state", "\n", "parent", "=", "parent", ",", "\n", "action", "=", "action", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.topk": [[114, 117], ["beam_search.segment_topk_idx"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.segment_topk_idx"], ["", "def", "topk", "(", "self", ",", "k", ")", ":", "\n", "        ", "idx_topk", "=", "segment_topk_idx", "(", "self", ".", "score", ",", "k", ",", "self", ".", "ids", ")", "\n", "return", "self", "[", "idx_topk", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.all_finished": [[118, 120], ["beam_search.BatchBeam.state.all_finished"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished"], ["", "def", "all_finished", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state", ".", "all_finished", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.cpu": [[121, 123], ["beam_search.BatchBeam.to", "torch.device"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to"], ["", "def", "cpu", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "to", "(", "torch", ".", "device", "(", "'cpu'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to": [[124, 132], ["beam_search.BatchBeam._replace", "beam_search.BatchBeam.state.to", "beam_search.BatchBeam.score.to", "beam_search.BatchBeam.parent.to", "beam_search.BatchBeam.action.to"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "if", "device", "==", "self", ".", "device", ":", "\n", "            ", "return", "self", "\n", "", "return", "self", ".", "_replace", "(", "\n", "score", "=", "self", ".", "score", ".", "to", "(", "device", ")", "if", "self", ".", "score", "is", "not", "None", "else", "None", ",", "\n", "state", "=", "self", ".", "state", ".", "to", "(", "device", ")", ",", "\n", "parent", "=", "self", ".", "parent", ".", "to", "(", "device", ")", "if", "self", ".", "parent", "is", "not", "None", "else", "None", ",", "\n", "action", "=", "self", ".", "action", ".", "to", "(", "device", ")", "if", "self", ".", "action", "is", "not", "None", "else", "None", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.clear_state": [[134, 136], ["beam_search.BatchBeam._replace"], "methods", ["None"], ["", "def", "clear_state", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_replace", "(", "state", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size": [[137, 139], ["beam_search.BatchBeam.state.ids.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "state", ".", "ids", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.CachedLookup.__init__": [[200, 204], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "data", ")", ":", "\n", "        ", "self", ".", "orig", "=", "data", "\n", "self", ".", "key", "=", "None", "\n", "self", ".", "current", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.CachedLookup.__getitem__": [[205, 219], ["torch.is_tensor", "isinstance", "len", "len"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "not", "isinstance", "(", "key", ",", "slice", ")", ",", "\"CachedLookup does not support slicing, \"", "\"you can slice the result of an index operation instead\"", "\n", "\n", "assert", "torch", ".", "is_tensor", "(", "key", ")", "# If tensor, idx all tensors by this tensor:", "\n", "\n", "if", "self", ".", "key", "is", "None", ":", "\n", "            ", "self", ".", "key", "=", "key", "\n", "self", ".", "current", "=", "self", ".", "orig", "[", "key", "]", "\n", "", "elif", "len", "(", "key", ")", "!=", "len", "(", "self", ".", "key", ")", "or", "(", "key", "!=", "self", ".", "key", ")", ".", "any", "(", ")", ":", "\n", "            ", "self", ".", "key", "=", "key", "\n", "self", ".", "current", "=", "self", ".", "orig", "[", "key", "]", "\n", "\n", "", "return", "self", ".", "current", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.beam_search": [[7, 10], ["beam_search._beam_search", "beam_search.get_beam_search_results"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search._beam_search", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.get_beam_search_results"], ["def", "beam_search", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "beams", ",", "final_state", "=", "_beam_search", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "return", "get_beam_search_results", "(", "beams", ",", "final_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.get_beam_search_results": [[12, 23], ["final_state.construct_solutions", "beam_search.backtrack", "final_state.ids.view", "final_state.get_final_cost"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.construct_solutions", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.backtrack", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_final_cost"], ["", "def", "get_beam_search_results", "(", "beams", ",", "final_state", ")", ":", "\n", "    ", "beam", "=", "beams", "[", "-", "1", "]", "# Final beam", "\n", "if", "final_state", "is", "None", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", ",", "None", ",", "beam", ".", "batch_size", "\n", "\n", "# First state has no actions/parents and should be omitted when backtracking", "\n", "", "actions", "=", "[", "beam", ".", "action", "for", "beam", "in", "beams", "[", "1", ":", "]", "]", "\n", "parents", "=", "[", "beam", ".", "parent", "for", "beam", "in", "beams", "[", "1", ":", "]", "]", "\n", "\n", "solutions", "=", "final_state", ".", "construct_solutions", "(", "backtrack", "(", "parents", ",", "actions", ")", ")", "\n", "return", "beam", ".", "score", ",", "solutions", ",", "final_state", ".", "get_final_cost", "(", ")", "[", ":", ",", "0", "]", ",", "final_state", ".", "ids", ".", "view", "(", "-", "1", ")", ",", "beam", ".", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search._beam_search": [[25, 52], ["beam_search.BatchBeam.initialize", "beam.topk.all_finished", "beam.topk.expand", "beam.topk.topk", "beams.append", "beam.topk.clear_state", "beam.topk.propose_expansions", "propose_expansions", "beam.topk.clear_state"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.topk", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.clear_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.clear_state"], ["", "def", "_beam_search", "(", "state", ",", "beam_size", ",", "propose_expansions", "=", "None", ",", "\n", "keep_states", "=", "False", ")", ":", "\n", "\n", "    ", "beam", "=", "BatchBeam", ".", "initialize", "(", "state", ")", "\n", "\n", "# Initial state", "\n", "beams", "=", "[", "beam", "if", "keep_states", "else", "beam", ".", "clear_state", "(", ")", "]", "\n", "\n", "# Perform decoding steps", "\n", "while", "not", "beam", ".", "all_finished", "(", ")", ":", "\n", "\n", "# Use the model to propose and score expansions", "\n", "        ", "parent", ",", "action", ",", "score", "=", "beam", ".", "propose_expansions", "(", ")", "if", "propose_expansions", "is", "None", "else", "propose_expansions", "(", "beam", ")", "\n", "if", "parent", "is", "None", ":", "\n", "            ", "return", "beams", ",", "None", "\n", "\n", "# Expand and update the state according to the selected actions", "\n", "", "beam", "=", "beam", ".", "expand", "(", "parent", ",", "action", ",", "score", "=", "score", ")", "\n", "\n", "# Get topk", "\n", "beam", "=", "beam", ".", "topk", "(", "beam_size", ")", "\n", "\n", "# Collect output of step", "\n", "beams", ".", "append", "(", "beam", "if", "keep_states", "else", "beam", ".", "clear_state", "(", ")", ")", "\n", "\n", "# Return the final state separately since beams may not keep state", "\n", "", "return", "beams", ",", "beam", ".", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.segment_topk_idx": [[141, 184], ["torch.nonzero", "torch.cat", "torch.cat.new_zeros", "utils.lexsort.torch_lexsort", "x.dim", "ids.dim", "len", "x.topk", "min", "ids.new_tensor", "x.size", "torch.cat.max", "torch.arange", "ids.size", "ids.new", "x.int"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.lexsort.torch_lexsort", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.topk", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "", "def", "segment_topk_idx", "(", "x", ",", "k", ",", "ids", ")", ":", "\n", "    ", "\"\"\"\n    Finds the topk per segment of data x given segment ids (0, 0, 0, 1, 1, 2, ...).\n    Note that there may be fewer than k elements in a segment so the returned length index can vary.\n    x[result], ids[result] gives the sorted elements per segment as well as corresponding segment ids after sorting.\n    :param x:\n    :param k:\n    :param ids:\n    :return:\n    \"\"\"", "\n", "assert", "x", ".", "dim", "(", ")", "==", "1", "\n", "assert", "ids", ".", "dim", "(", ")", "==", "1", "\n", "\n", "# Since we may have varying beam size per batch entry we cannot reshape to (batch_size, beam_size)", "\n", "# And use default topk along dim -1, so we have to be creative", "\n", "# Now we have to get the topk per segment which is really annoying :(", "\n", "# we use lexsort on (ids, score), create array with offset per id", "\n", "# offsets[ids] then gives offsets repeated and only keep for which arange(len) < offsets + k", "\n", "splits_", "=", "torch", ".", "nonzero", "(", "ids", "[", "1", ":", "]", "-", "ids", "[", ":", "-", "1", "]", ")", "\n", "\n", "if", "len", "(", "splits_", ")", "==", "0", ":", "# Only one group", "\n", "        ", "_", ",", "idx_topk", "=", "x", ".", "topk", "(", "min", "(", "k", ",", "x", ".", "size", "(", "0", ")", ")", ")", "\n", "return", "idx_topk", "\n", "\n", "", "splits", "=", "torch", ".", "cat", "(", "(", "ids", ".", "new_tensor", "(", "[", "0", "]", ")", ",", "splits_", "[", ":", ",", "0", "]", "+", "1", ")", ")", "\n", "# Make a new array in which we store for each id the offset (start) of the group", "\n", "# This way ids does not need to be increasing or adjacent, as long as each group is a single range", "\n", "group_offsets", "=", "splits", ".", "new_zeros", "(", "(", "splits", ".", "max", "(", ")", "+", "1", ",", ")", ")", "\n", "group_offsets", "[", "ids", "[", "splits", "]", "]", "=", "splits", "\n", "offsets", "=", "group_offsets", "[", "ids", "]", "# Look up offsets based on ids, effectively repeating for the repetitions per id", "\n", "\n", "# We want topk so need to sort x descending so sort -x (be careful with unsigned data type!)", "\n", "idx_sorted", "=", "torch_lexsort", "(", "(", "-", "(", "x", "if", "x", ".", "dtype", "!=", "torch", ".", "uint8", "else", "x", ".", "int", "(", ")", ")", ".", "detach", "(", ")", ",", "ids", ")", ")", "\n", "\n", "# This will filter first k per group (example k = 2)", "\n", "# ids     = [0, 0, 0, 1, 1, 1, 1, 2]", "\n", "# splits  = [0, 3, 7]", "\n", "# offsets = [0, 0, 0, 3, 3, 3, 3, 7]", "\n", "# offs+2  = [2, 2, 2, 5, 5, 5, 5, 9]", "\n", "# arange  = [0, 1, 2, 3, 4, 5, 6, 7]", "\n", "# filter  = [1, 1, 0, 1, 1, 0, 0, 1]", "\n", "# Use filter to get only topk of sorting idx", "\n", "return", "idx_sorted", "[", "torch", ".", "arange", "(", "ids", ".", "size", "(", "0", ")", ",", "out", "=", "ids", ".", "new", "(", ")", ")", "<", "offsets", "+", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.backtrack": [[186, 196], ["reversed", "torch.stack", "list", "reversed_aligned_sequences.append", "parent.gather", "list", "zip", "sequence.gather", "reversed"], "function", ["None"], ["", "def", "backtrack", "(", "parents", ",", "actions", ")", ":", "\n", "\n", "# Now backtrack to find aligned action sequences in reversed order", "\n", "    ", "cur_parent", "=", "parents", "[", "-", "1", "]", "\n", "reversed_aligned_sequences", "=", "[", "actions", "[", "-", "1", "]", "]", "\n", "for", "parent", ",", "sequence", "in", "reversed", "(", "list", "(", "zip", "(", "parents", "[", ":", "-", "1", "]", ",", "actions", "[", ":", "-", "1", "]", ")", ")", ")", ":", "\n", "        ", "reversed_aligned_sequences", ".", "append", "(", "sequence", ".", "gather", "(", "-", "1", ",", "cur_parent", ")", ")", "\n", "cur_parent", "=", "parent", ".", "gather", "(", "-", "1", ",", "cur_parent", ")", "\n", "\n", "", "return", "torch", ".", "stack", "(", "list", "(", "reversed", "(", "reversed_aligned_sequences", ")", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict": [[7, 68], ["copy.deepcopy", "any", "collections.defaultdict", "state_dict[].items", "monkey_patch..__setstate__", "len", "len", "ValueError", "len", "len", "ValueError", "torch.is_tensor", "monkey_patch.load_state_dict.update_group"], "function", ["None"], ["def", "load_state_dict", "(", "self", ",", "state_dict", ")", ":", "\n", "    ", "\"\"\"Loads the optimizer state.\n    Arguments:\n        state_dict (dict): optimizer state. Should be an object returned\n            from a call to :meth:`state_dict`.\n    \"\"\"", "\n", "# deepcopy, to be consistent with module API", "\n", "state_dict", "=", "deepcopy", "(", "state_dict", ")", "\n", "# Validate the state_dict", "\n", "groups", "=", "self", ".", "param_groups", "\n", "saved_groups", "=", "state_dict", "[", "'param_groups'", "]", "\n", "\n", "if", "len", "(", "groups", ")", "!=", "len", "(", "saved_groups", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"loaded state dict has a different number of \"", "\n", "\"parameter groups\"", ")", "\n", "", "param_lens", "=", "(", "len", "(", "g", "[", "'params'", "]", ")", "for", "g", "in", "groups", ")", "\n", "saved_lens", "=", "(", "len", "(", "g", "[", "'params'", "]", ")", "for", "g", "in", "saved_groups", ")", "\n", "if", "any", "(", "p_len", "!=", "s_len", "for", "p_len", ",", "s_len", "in", "zip", "(", "param_lens", ",", "saved_lens", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"loaded state dict contains a parameter group \"", "\n", "\"that doesn't match the size of optimizer's group\"", ")", "\n", "\n", "# Update the state", "\n", "", "id_map", "=", "{", "old_id", ":", "p", "for", "old_id", ",", "p", "in", "\n", "zip", "(", "chain", "(", "*", "(", "g", "[", "'params'", "]", "for", "g", "in", "saved_groups", ")", ")", ",", "\n", "chain", "(", "*", "(", "g", "[", "'params'", "]", "for", "g", "in", "groups", ")", ")", ")", "}", "\n", "\n", "def", "cast", "(", "param", ",", "value", ")", ":", "\n", "        ", "\"\"\"Make a deep copy of value, casting all tensors to device of param.\"\"\"", "\n", "if", "torch", ".", "is_tensor", "(", "value", ")", ":", "\n", "# Floating-point types are a bit special here. They are the only ones", "\n", "# that are assumed to always match the type of params.", "\n", "            ", "if", "any", "(", "tp", "in", "type", "(", "param", ".", "data", ")", ".", "__name__", "for", "tp", "in", "{", "'Half'", ",", "'Float'", ",", "'Double'", "}", ")", ":", "\n", "                ", "value", "=", "value", ".", "type_as", "(", "param", ".", "data", ")", "\n", "", "value", "=", "value", ".", "to", "(", "param", ".", "device", ")", "\n", "return", "value", "\n", "", "elif", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "            ", "return", "{", "k", ":", "cast", "(", "param", ",", "v", ")", "for", "k", ",", "v", "in", "value", ".", "items", "(", ")", "}", "\n", "", "elif", "isinstance", "(", "value", ",", "Iterable", ")", ":", "\n", "            ", "return", "type", "(", "value", ")", "(", "cast", "(", "param", ",", "v", ")", "for", "v", "in", "value", ")", "\n", "", "else", ":", "\n", "            ", "return", "value", "\n", "\n", "# Copy state assigned to params (and cast tensors to appropriate types).", "\n", "# State that is not assigned to params is copied as is (needed for", "\n", "# backward compatibility).", "\n", "", "", "state", "=", "defaultdict", "(", "dict", ")", "\n", "for", "k", ",", "v", "in", "state_dict", "[", "'state'", "]", ".", "items", "(", ")", ":", "\n", "        ", "if", "k", "in", "id_map", ":", "\n", "            ", "param", "=", "id_map", "[", "k", "]", "\n", "state", "[", "param", "]", "=", "cast", "(", "param", ",", "v", ")", "\n", "", "else", ":", "\n", "            ", "state", "[", "k", "]", "=", "v", "\n", "\n", "# Update parameter groups, setting their 'params' value", "\n", "", "", "def", "update_group", "(", "group", ",", "new_group", ")", ":", "\n", "        ", "new_group", "[", "'params'", "]", "=", "group", "[", "'params'", "]", "\n", "return", "new_group", "\n", "\n", "", "param_groups", "=", "[", "\n", "update_group", "(", "g", ",", "ng", ")", "for", "g", ",", "ng", "in", "zip", "(", "groups", ",", "saved_groups", ")", "]", "\n", "self", ".", "__setstate__", "(", "{", "'state'", ":", "state", ",", "'param_groups'", ":", "param_groups", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.lexsort.torch_lexsort": [[5, 11], ["lexsort._torch_lexsort_cuda", "torch.from_numpy", "numpy.lexsort", "k.numpy"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.lexsort._torch_lexsort_cuda"], ["def", "torch_lexsort", "(", "keys", ",", "dim", "=", "-", "1", ")", ":", "\n", "    ", "if", "keys", "[", "0", "]", ".", "is_cuda", ":", "\n", "        ", "return", "_torch_lexsort_cuda", "(", "keys", ",", "dim", ")", "\n", "", "else", ":", "\n", "# Use numpy lex sort", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "np", ".", "lexsort", "(", "[", "k", ".", "numpy", "(", ")", "for", "k", "in", "keys", "]", ",", "axis", "=", "dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.lexsort._torch_lexsort_cuda": [[13, 56], ["tuple", "tuple", "keys[].size", "flat_keys[].numel", "[].repeat().view", "[].repeat().view", "idx[].view().transpose", "key.transpose().contiguous", "key.view", "[].repeat", "tuple", "k.sort", "k[].sort", "[].repeat", "idx[].view", "key.transpose", "k.repeat", "torch.arange", "reordered_keys[].size", "torch.arange"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "", "def", "_torch_lexsort_cuda", "(", "keys", ",", "dim", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"\n    Function calculates a lexicographical sort order on GPU, similar to np.lexsort\n    Relies heavily on undocumented behavior of torch.sort, namely that when sorting more than\n    2048 entries in the sorting dim, it performs a sort using Thrust and it uses a stable sort\n    https://github.com/pytorch/pytorch/blob/695fd981924bd805704ecb5ccd67de17c56d7308/aten/src/THC/generic/THCTensorSort.cu#L330\n    \"\"\"", "\n", "\n", "MIN_NUMEL_STABLE_SORT", "=", "2049", "# Minimum number of elements for stable sort", "\n", "\n", "# Swap axis such that sort dim is last and reshape all other dims to a single (batch) dimension", "\n", "reordered_keys", "=", "tuple", "(", "key", ".", "transpose", "(", "dim", ",", "-", "1", ")", ".", "contiguous", "(", ")", "for", "key", "in", "keys", ")", "\n", "flat_keys", "=", "tuple", "(", "key", ".", "view", "(", "-", "1", ")", "for", "key", "in", "keys", ")", "\n", "d", "=", "keys", "[", "0", "]", ".", "size", "(", "dim", ")", "# Sort dimension size", "\n", "numel", "=", "flat_keys", "[", "0", "]", ".", "numel", "(", ")", "\n", "batch_size", "=", "numel", "//", "d", "\n", "batch_key", "=", "torch", ".", "arange", "(", "batch_size", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "keys", "[", "0", "]", ".", "device", ")", "[", ":", ",", "None", "]", ".", "repeat", "(", "1", ",", "d", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "flat_keys", "=", "flat_keys", "+", "(", "batch_key", ",", ")", "\n", "\n", "# We rely on undocumented behavior that the sort is stable provided that", "\n", "if", "numel", "<", "MIN_NUMEL_STABLE_SORT", ":", "\n", "        ", "n_rep", "=", "(", "MIN_NUMEL_STABLE_SORT", "+", "numel", "-", "1", ")", "//", "numel", "# Ceil", "\n", "rep_key", "=", "torch", ".", "arange", "(", "n_rep", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "keys", "[", "0", "]", ".", "device", ")", "[", ":", ",", "None", "]", ".", "repeat", "(", "1", ",", "numel", ")", ".", "view", "(", "-", "1", ")", "\n", "flat_keys", "=", "tuple", "(", "k", ".", "repeat", "(", "n_rep", ")", "for", "k", "in", "flat_keys", ")", "+", "(", "rep_key", ",", ")", "\n", "\n", "", "idx", "=", "None", "# Identity sorting initially", "\n", "for", "k", "in", "flat_keys", ":", "\n", "        ", "if", "idx", "is", "None", ":", "\n", "            ", "_", ",", "idx", "=", "k", ".", "sort", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "# Order data according to idx and then apply", "\n", "# found ordering to current idx (so permutation of permutation)", "\n", "# such that we can order the next key according to the current sorting order", "\n", "            ", "_", ",", "idx_", "=", "k", "[", "idx", "]", ".", "sort", "(", "-", "1", ")", "\n", "idx", "=", "idx", "[", "idx_", "]", "\n", "\n", "# In the end gather only numel and strip of extra sort key", "\n", "", "", "if", "numel", "<", "MIN_NUMEL_STABLE_SORT", ":", "\n", "        ", "idx", "=", "idx", "[", ":", "numel", "]", "\n", "\n", "# Get only numel (if we have replicated), swap axis back and shape results", "\n", "", "return", "idx", "[", ":", "numel", "]", ".", "view", "(", "*", "reordered_keys", "[", "0", "]", ".", "size", "(", ")", ")", ".", "transpose", "(", "dim", ",", "-", "1", ")", "%", "d", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.check_extension": [[5, 9], ["os.path.splitext"], "function", ["None"], ["def", "check_extension", "(", "filename", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "!=", "\".pkl\"", ":", "\n", "        ", "return", "filename", "+", "\".pkl\"", "\n", "", "return", "filename", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset": [[11, 20], ["os.path.split", "os.path.isdir", "os.makedirs", "open", "pickle.dump", "data_utils.check_extension"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.check_extension"], ["", "def", "save_dataset", "(", "dataset", ",", "filename", ")", ":", "\n", "\n", "    ", "filedir", "=", "os", ".", "path", ".", "split", "(", "filename", ")", "[", "0", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "filedir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "filedir", ")", "\n", "\n", "", "with", "open", "(", "check_extension", "(", "filename", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "pickle", ".", "dump", "(", "dataset", ",", "f", ",", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.load_dataset": [[22, 26], ["open", "pickle.load", "data_utils.check_extension"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.check_extension"], ["", "", "def", "load_dataset", "(", "filename", ")", ":", "\n", "\n", "    ", "with", "open", "(", "check_extension", "(", "filename", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "return", "pickle", ".", "load", "(", "f", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._pad_mask": [[5, 12], ["torch.pad", "F.pad.size", "F.pad.size"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["def", "_pad_mask", "(", "mask", ")", ":", "\n", "# By taking -size % 8, we get 0 if exactly divisible by 8", "\n", "# and required padding otherwise (i.e. -1 % 8 = 7 pad)", "\n", "    ", "pad", "=", "-", "mask", ".", "size", "(", "-", "1", ")", "%", "8", "\n", "if", "pad", "!=", "0", ":", "\n", "        ", "mask", "=", "F", ".", "pad", "(", "mask", ",", "[", "0", ",", "pad", "]", ")", "\n", "", "return", "mask", ",", "mask", ".", "size", "(", "-", "1", ")", "//", "8", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._mask_bool2byte": [[14, 19], ["boolmask._pad_mask", "mask.view", "torch.arange", "torch.arange", "mask.new", "mask.size"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._pad_mask", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_mask_bool2byte", "(", "mask", ")", ":", "\n", "    ", "assert", "mask", ".", "dtype", "==", "torch", ".", "uint8", "\n", "# assert (mask <= 1).all()  # Precondition, disabled for efficiency", "\n", "mask", ",", "d", "=", "_pad_mask", "(", "mask", ")", "\n", "return", "(", "mask", ".", "view", "(", "*", "mask", ".", "size", "(", ")", "[", ":", "-", "1", "]", ",", "d", ",", "8", ")", "<<", "torch", ".", "arange", "(", "8", ",", "out", "=", "mask", ".", "new", "(", ")", ")", ")", ".", "sum", "(", "-", "1", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._mask_byte2long": [[21, 28], ["boolmask._pad_mask", "mask.view().long", "torch.arange", "torch.arange", "mask.view", "mask.size"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._pad_mask", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_mask_byte2long", "(", "mask", ")", ":", "\n", "    ", "assert", "mask", ".", "dtype", "==", "torch", ".", "uint8", "\n", "mask", ",", "d", "=", "_pad_mask", "(", "mask", ")", "\n", "# Note this corresponds to a temporary factor 8", "\n", "# memory overhead by converting to long before summing", "\n", "# Alternatively, aggregate using for loop", "\n", "return", "(", "mask", ".", "view", "(", "*", "mask", ".", "size", "(", ")", "[", ":", "-", "1", "]", ",", "d", ",", "8", ")", ".", "long", "(", ")", "<<", "(", "torch", ".", "arange", "(", "8", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "mask", ".", "device", ")", "*", "8", ")", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_bool2long": [[30, 33], ["boolmask._mask_byte2long", "boolmask._mask_bool2byte"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._mask_byte2long", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._mask_bool2byte"], ["", "def", "mask_bool2long", "(", "mask", ")", ":", "\n", "    ", "assert", "mask", ".", "dtype", "==", "torch", ".", "uint8", "\n", "return", "_mask_byte2long", "(", "_mask_bool2byte", "(", "mask", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._mask_long2byte": [[35, 39], ["[].to().view", "mask.size", "[].to", "mask.size", "torch.arange", "torch.arange", "mask.new"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_mask_long2byte", "(", "mask", ",", "n", "=", "None", ")", ":", "\n", "    ", "if", "n", "is", "None", ":", "\n", "        ", "n", "=", "8", "*", "mask", ".", "size", "(", "-", "1", ")", "\n", "", "return", "(", "mask", "[", "...", ",", "None", "]", ">>", "(", "torch", ".", "arange", "(", "8", ",", "out", "=", "mask", ".", "new", "(", ")", ")", "*", "8", ")", ")", "[", "...", ",", ":", "n", "]", ".", "to", "(", "torch", ".", "uint8", ")", ".", "view", "(", "*", "mask", ".", "size", "(", ")", "[", ":", "-", "1", "]", ",", "-", "1", ")", "[", "...", ",", ":", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._mask_byte2bool": [[41, 45], ["mask.size", "mask.size", "mask.new_ones", "torch.arange", "torch.arange", "mask.new"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_mask_byte2bool", "(", "mask", ",", "n", "=", "None", ")", ":", "\n", "    ", "if", "n", "is", "None", ":", "\n", "        ", "n", "=", "8", "*", "mask", ".", "size", "(", "-", "1", ")", "\n", "", "return", "(", "mask", "[", "...", ",", "None", "]", "&", "(", "mask", ".", "new_ones", "(", "8", ")", "<<", "torch", ".", "arange", "(", "8", ",", "out", "=", "mask", ".", "new", "(", ")", ")", "*", "1", ")", ")", ".", "view", "(", "*", "mask", ".", "size", "(", ")", "[", ":", "-", "1", "]", ",", "-", "1", ")", "[", "...", ",", ":", "n", "]", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long2bool": [[47, 50], ["boolmask._mask_byte2bool", "boolmask._mask_long2byte"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._mask_byte2bool", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask._mask_long2byte"], ["", "def", "mask_long2bool", "(", "mask", ",", "n", "=", "None", ")", ":", "\n", "    ", "assert", "mask", ".", "dtype", "==", "torch", ".", "int64", "\n", "return", "_mask_byte2bool", "(", "_mask_long2byte", "(", "mask", ")", ",", "n", "=", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long_scatter": [[52, 69], ["torch.arange", "torch.arange", "values.size", "mask.size", "mask.size", "mask.new", "where.long", "where.long"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "mask_long_scatter", "(", "mask", ",", "values", ",", "check_unset", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Sets values in mask in dimension -1 with arbitrary batch dimensions\n    If values contains -1, nothing is set\n    Note: does not work for setting multiple values at once (like normal scatter)\n    \"\"\"", "\n", "assert", "mask", ".", "size", "(", ")", "[", ":", "-", "1", "]", "==", "values", ".", "size", "(", ")", "\n", "rng", "=", "torch", ".", "arange", "(", "mask", ".", "size", "(", "-", "1", ")", ",", "out", "=", "mask", ".", "new", "(", ")", ")", "\n", "values_", "=", "values", "[", "...", ",", "None", "]", "# Need to broadcast up do mask dim", "\n", "# This indicates in which value of the mask a bit should be set", "\n", "where", "=", "(", "values_", ">=", "(", "rng", "*", "64", ")", ")", "&", "(", "values_", "<", "(", "(", "rng", "+", "1", ")", "*", "64", ")", ")", "\n", "# Optional: check that bit is not already set", "\n", "assert", "not", "(", "check_unset", "and", "(", "(", "mask", "&", "(", "where", ".", "long", "(", ")", "<<", "(", "values_", "%", "64", ")", ")", ")", ">", "0", ")", ".", "any", "(", ")", ")", "\n", "# Set bit by shifting a 1 to the correct position", "\n", "# (% not strictly necessary as bitshift is cyclic)", "\n", "# since where is 0 if no value needs to be set, the bitshift has no effect", "\n", "return", "mask", "|", "(", "where", ".", "long", "(", ")", "<<", "(", "values_", "%", "64", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.log_utils.log_values": [[1, 25], ["cost.mean().item", "print", "print", "tb_logger.log_value", "tb_logger.log_value", "tb_logger.log_value", "tb_logger.log_value", "tb_logger.log_value", "cost.mean", "reinforce_loss.item", "tb_logger.log_value", "tb_logger.log_value", "tb_logger.log_value", "log_likelihood.mean().item", "bl_loss.item", "log_likelihood.mean"], "function", ["None"], ["def", "log_values", "(", "cost", ",", "grad_norms", ",", "epoch", ",", "batch_id", ",", "step", ",", "\n", "log_likelihood", ",", "reinforce_loss", ",", "bl_loss", ",", "tb_logger", ",", "opts", ")", ":", "\n", "    ", "avg_cost", "=", "cost", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "grad_norms", ",", "grad_norms_clipped", "=", "grad_norms", "\n", "\n", "# Log values to screen", "\n", "print", "(", "'epoch: {}, train_batch_id: {}, avg_cost: {}'", ".", "format", "(", "epoch", ",", "batch_id", ",", "avg_cost", ")", ")", "\n", "\n", "print", "(", "'grad_norm: {}, clipped: {}'", ".", "format", "(", "grad_norms", "[", "0", "]", ",", "grad_norms_clipped", "[", "0", "]", ")", ")", "\n", "\n", "# Log values to tensorboard", "\n", "if", "not", "opts", ".", "no_tensorboard", ":", "\n", "        ", "tb_logger", ".", "log_value", "(", "'avg_cost'", ",", "avg_cost", ",", "step", ")", "\n", "\n", "tb_logger", ".", "log_value", "(", "'actor_loss'", ",", "reinforce_loss", ".", "item", "(", ")", ",", "step", ")", "\n", "tb_logger", ".", "log_value", "(", "'nll'", ",", "-", "log_likelihood", ".", "mean", "(", ")", ".", "item", "(", ")", ",", "step", ")", "\n", "\n", "tb_logger", ".", "log_value", "(", "'grad_norm'", ",", "grad_norms", "[", "0", "]", ",", "step", ")", "\n", "tb_logger", ".", "log_value", "(", "'grad_norm_clipped'", ",", "grad_norms_clipped", "[", "0", "]", ",", "step", ")", "\n", "\n", "if", "opts", ".", "baseline", "==", "'critic'", ":", "\n", "            ", "tb_logger", ".", "log_value", "(", "'critic_loss'", ",", "bl_loss", ".", "item", "(", ")", ",", "step", ")", "\n", "tb_logger", ".", "log_value", "(", "'critic_grad_norm'", ",", "grad_norms", "[", "1", "]", ",", "step", ")", "\n", "tb_logger", ".", "log_value", "(", "'critic_grad_norm_clipped'", ",", "grad_norms_clipped", "[", "1", "]", ",", "step", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_problem": [[13, 26], ["None"], "function", ["None"], ["def", "load_problem", "(", "name", ")", ":", "\n", "    ", "from", "problems", "import", "TSP", ",", "CVRP", ",", "SDVRP", ",", "OP", ",", "PCTSPDet", ",", "PCTSPStoch", ",", "LOCAL", "\n", "problem", "=", "{", "\n", "'local'", ":", "LOCAL", ",", "\n", "'tsp'", ":", "TSP", ",", "\n", "'cvrp'", ":", "CVRP", ",", "\n", "'sdvrp'", ":", "SDVRP", ",", "\n", "'op'", ":", "OP", ",", "\n", "'pctsp_det'", ":", "PCTSPDet", ",", "\n", "'pctsp_stoch'", ":", "PCTSPStoch", ",", "\n", "}", ".", "get", "(", "name", ",", "None", ")", "\n", "assert", "problem", "is", "not", "None", ",", "\"Currently unsupported problem: {}!\"", ".", "format", "(", "name", ")", "\n", "return", "problem", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.solve_gurobi": [[27, 61], ["os.path.join", "calc_tsp_length", "print", "os.path.isfile", "load_dataset", "time.time", "loc.append", "solve_euclidian_tsp_gurobi", "print", "print", "time.time", "int", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset"], ["", "def", "solve_gurobi", "(", "directory", ",", "name", ",", "loc", ",", "disable_cache", "=", "False", ",", "timeout", "=", "None", ",", "gap", "=", "None", ")", ":", "\n", "# Lazy import so we do not need to have gurobi installed to run this script", "\n", "    ", "from", "problems", ".", "tsp", ".", "tsp_gurobi", "import", "solve_euclidian_tsp", "as", "solve_euclidian_tsp_gurobi", "\n", "\n", "try", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.gurobi{}{}.pkl\"", ".", "format", "(", "\n", "name", ",", "\"\"", "if", "timeout", "is", "None", "else", "\"t{}\"", ".", "format", "(", "timeout", ")", ",", "\"\"", "if", "gap", "is", "None", "else", "\"gap{}\"", ".", "format", "(", "gap", ")", ")", ")", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "problem_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "(", "cost", ",", "tour", ",", "duration", ")", "=", "load_dataset", "(", "problem_filename", ")", "\n", "", "else", ":", "\n", "# 0 = start, 1 = end so add depot twice", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "loc", ".", "append", "(", "loc", "[", "int", "(", "len", "(", "loc", ")", "-", "1", ")", "]", ")", "\n", "\n", "cost", ",", "tour", "=", "solve_euclidian_tsp_gurobi", "(", "loc", ",", "threads", "=", "1", ",", "timeout", "=", "timeout", ",", "gap", "=", "gap", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "# Measure clock time", "\n", "\n", "#             save_dataset((cost, tour, duration), problem_filename)", "\n", "\n", "# First and last node are depot(s), so first node is 2 but should be 1 (as depot is 0) so subtract 1", "\n", "", "total_cost", "=", "calc_tsp_length", "(", "loc", ",", "tour", ")", "\n", "print", "(", "total_cost", ")", "\n", "\n", "#         assert abs(total_cost - cost) <= 1e-5, \"Cost is incorrect\"", "\n", "return", "total_cost", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "# For some stupid reason, sometimes OR tools cannot find a feasible solution?", "\n", "# By letting it fail we do not get total results, but we dcan retry by the caching mechanism", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "", "", "def", "torch_load_cpu", "(", "load_path", ")", ":", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.torch_load_cpu": [[61, 63], ["torch.load", "torch.load"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load"], ["", "", "def", "torch_load_cpu", "(", "load_path", ")", ":", "\n", "    ", "return", "torch", ".", "load", "(", "load_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "# Load on CPU", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.move_to": [[65, 69], ["isinstance", "var.to", "functions.move_to", "var.items"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.move_to"], ["", "def", "move_to", "(", "var", ",", "device", ")", ":", "\n", "    ", "if", "isinstance", "(", "var", ",", "dict", ")", ":", "\n", "        ", "return", "{", "k", ":", "move_to", "(", "v", ",", "device", ")", "for", "k", ",", "v", "in", "var", ".", "items", "(", ")", "}", "\n", "", "return", "var", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions._load_model_file": [[71, 97], ["print", "torch.load", "torch.load", "isinstance", "model.state_dict", "model.state_dict.update", "model.load_state_dict", "os.path.join", "torch.load.get", "torch.load.get", "torch.load.state_dict", "os.getcwd"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.update", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict"], ["", "def", "_load_model_file", "(", "load_path", ",", "model", ")", ":", "\n", "    ", "\"\"\"Loads the model with parameters from the file and returns optimizer state dict if it is in the file\"\"\"", "\n", "\n", "# Load the model parameters from a saved state", "\n", "load_optimizer_state_dict", "=", "None", "\n", "print", "(", "'  [*] Loading model from {}'", ".", "format", "(", "load_path", ")", ")", "\n", "\n", "load_data", "=", "torch", ".", "load", "(", "\n", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "getcwd", "(", ")", ",", "\n", "load_path", "\n", ")", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "\n", "if", "isinstance", "(", "load_data", ",", "dict", ")", ":", "\n", "        ", "load_optimizer_state_dict", "=", "load_data", ".", "get", "(", "'optimizer'", ",", "None", ")", "\n", "load_model_state_dict", "=", "load_data", ".", "get", "(", "'model'", ",", "load_data", ")", "\n", "", "else", ":", "\n", "        ", "load_model_state_dict", "=", "load_data", ".", "state_dict", "(", ")", "\n", "\n", "", "state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "\n", "state_dict", ".", "update", "(", "load_model_state_dict", ")", "\n", "\n", "model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n", "return", "model", ",", "load_optimizer_state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_args": [[99, 111], ["open", "json.load", "args[].split"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load"], ["", "def", "load_args", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "args", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "# Backwards compatibility", "\n", "", "if", "'data_distribution'", "not", "in", "args", ":", "\n", "        ", "args", "[", "'data_distribution'", "]", "=", "None", "\n", "probl", ",", "*", "dist", "=", "args", "[", "'problem'", "]", ".", "split", "(", "\"_\"", ")", "\n", "if", "probl", "==", "\"op\"", ":", "\n", "            ", "args", "[", "'problem'", "]", "=", "probl", "\n", "args", "[", "'data_distribution'", "]", "=", "dist", "[", "0", "]", "\n", "", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_model": [[113, 184], ["os.path.isfile", "functions.load_args", "functions.torch_load_cpu", "model_class.load_state_dict", "functions._load_model_file", "model_class.eval", "os.path.dirname", "os.path.isdir", "os.path.join", "AttentionModel", "functions.load_problem", "model_class", "os.path.join", "functions.load_problem", "load_args.get", "model_class.state_dict", "torch_load_cpu.get", "max", "load_args.get", "load_args.get", "load_args.get", "load_args.get", "int", "os.listdir", "[].split", "os.path.splitext", "os.path.splitext"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_args", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.torch_load_cpu", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.monkey_patch.load_state_dict", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions._load_model_file", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.eval", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_problem", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.load_problem", "home.repos.pwc.inspect_result.alstn12088_lcp.None.reinforce_baselines.RolloutBaseline.state_dict"], ["", "def", "load_model", "(", "path", ",", "epoch", "=", "None", ",", "is_local", "=", "False", ",", "n_points", "=", "None", ")", ":", "\n", "    ", "from", "nets", ".", "attention_model", "import", "AttentionModel", "\n", "\n", "from", "nets", ".", "pointer_network", "import", "PointerNetwork", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "path", ")", ":", "\n", "        ", "model_filename", "=", "path", "\n", "path", "=", "os", ".", "path", ".", "dirname", "(", "model_filename", ")", "\n", "", "elif", "os", ".", "path", ".", "isdir", "(", "path", ")", ":", "\n", "        ", "if", "epoch", "is", "None", ":", "\n", "            ", "epoch", "=", "max", "(", "\n", "int", "(", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "0", "]", ".", "split", "(", "\"-\"", ")", "[", "1", "]", ")", "\n", "for", "filename", "in", "os", ".", "listdir", "(", "path", ")", "\n", "if", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "==", "'.pt'", "\n", ")", "\n", "", "model_filename", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'epoch-{}.pt'", ".", "format", "(", "epoch", ")", ")", "\n", "", "else", ":", "\n", "        ", "assert", "False", ",", "\"{} is not a valid directory or file\"", ".", "format", "(", "path", ")", "\n", "\n", "\n", "\n", "", "args", "=", "load_args", "(", "os", ".", "path", ".", "join", "(", "path", ",", "'args.json'", ")", ")", "\n", "\n", "\n", "if", "is_local", ":", "\n", "        ", "from", "nets", ".", "attention_local", "import", "AttentionModel", "\n", "model", "=", "AttentionModel", "(", "\n", "args", "[", "'embedding_dim'", "]", ",", "\n", "args", "[", "'hidden_dim'", "]", ",", "\n", "load_problem", "(", "'local'", ")", ",", "\n", "n_encode_layers", "=", "args", "[", "'n_encode_layers'", "]", ",", "\n", "mask_inner", "=", "True", ",", "\n", "mask_logits", "=", "True", ",", "\n", "normalization", "=", "args", "[", "'normalization'", "]", ",", "\n", "tanh_clipping", "=", "args", "[", "'tanh_clipping'", "]", ",", "\n", "checkpoint_encoder", "=", "args", ".", "get", "(", "'checkpoint_encoder'", ",", "False", ")", ",", "\n", "shrink_size", "=", "args", ".", "get", "(", "'shrink_size'", ",", "None", ")", "\n", ")", "\n", "\n", "\n", "\n", "\n", "", "else", ":", "\n", "        ", "problem", "=", "load_problem", "(", "args", "[", "'problem'", "]", ")", "\n", "model_class", "=", "{", "\n", "'attention'", ":", "AttentionModel", ",", "\n", "'pointer'", ":", "PointerNetwork", "\n", "}", ".", "get", "(", "args", ".", "get", "(", "'model'", ",", "'attention'", ")", ",", "None", ")", "\n", "assert", "model_class", "is", "not", "None", ",", "\"Unknown model: {}\"", ".", "format", "(", "model_class", ")", "\n", "\n", "model", "=", "model_class", "(", "\n", "args", "[", "'embedding_dim'", "]", ",", "\n", "args", "[", "'hidden_dim'", "]", ",", "\n", "problem", ",", "\n", "n_encode_layers", "=", "args", "[", "'n_encode_layers'", "]", ",", "\n", "mask_inner", "=", "True", ",", "\n", "mask_logits", "=", "True", ",", "\n", "normalization", "=", "args", "[", "'normalization'", "]", ",", "\n", "tanh_clipping", "=", "args", "[", "'tanh_clipping'", "]", ",", "\n", "checkpoint_encoder", "=", "args", ".", "get", "(", "'checkpoint_encoder'", ",", "False", ")", ",", "\n", "shrink_size", "=", "args", ".", "get", "(", "'shrink_size'", ",", "None", ")", "\n", ")", "\n", "# Overwrite model parameters by parameters to load", "\n", "", "load_data", "=", "torch_load_cpu", "(", "model_filename", ")", "\n", "model", ".", "load_state_dict", "(", "{", "**", "model", ".", "state_dict", "(", ")", ",", "**", "load_data", ".", "get", "(", "'model'", ",", "{", "}", ")", "}", ")", "\n", "\n", "model", ",", "*", "_", "=", "_load_model_file", "(", "model_filename", ",", "model", ")", "\n", "\n", "model", ".", "eval", "(", ")", "# Put in eval mode", "\n", "\n", "return", "model", ",", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.parse_softmax_temperature": [[186, 191], ["os.path.isfile", "float", "numpy.loadtxt"], "function", ["None"], ["", "def", "parse_softmax_temperature", "(", "raw_temp", ")", ":", "\n", "# Load from file", "\n", "    ", "if", "os", ".", "path", ".", "isfile", "(", "raw_temp", ")", ":", "\n", "        ", "return", "np", ".", "loadtxt", "(", "raw_temp", ")", "[", "-", "1", ",", "0", "]", "\n", "", "return", "float", "(", "raw_temp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.run_all_in_pool": [[193, 222], ["len", "getattr", "os.cpu_count", "str", "pool_cls", "list", "str", "len", "tqdm.tqdm", "enumerate", "len", "len", "pool.imap", "len", "str().zfill", "enumerate", "str"], "function", ["None"], ["", "def", "run_all_in_pool", "(", "func", ",", "directory", ",", "dataset", ",", "opts", ",", "use_multiprocessing", "=", "True", ")", ":", "\n", "# # Test", "\n", "# res = func((directory, 'test', *dataset[0]))", "\n", "# return [res]", "\n", "\n", "    ", "num_cpus", "=", "os", ".", "cpu_count", "(", ")", "if", "opts", ".", "cpus", "is", "None", "else", "opts", ".", "cpus", "\n", "\n", "w", "=", "len", "(", "str", "(", "len", "(", "dataset", ")", "-", "1", ")", ")", "\n", "offset", "=", "getattr", "(", "opts", ",", "'offset'", ",", "None", ")", "\n", "if", "offset", "is", "None", ":", "\n", "        ", "offset", "=", "0", "\n", "", "ds", "=", "dataset", "[", "offset", ":", "(", "offset", "+", "opts", ".", "n", "if", "opts", ".", "n", "is", "not", "None", "else", "len", "(", "dataset", ")", ")", "]", "\n", "pool_cls", "=", "(", "Pool", "if", "use_multiprocessing", "and", "num_cpus", ">", "1", "else", "ThreadPool", ")", "\n", "with", "pool_cls", "(", "num_cpus", ")", "as", "pool", ":", "\n", "        ", "results", "=", "list", "(", "tqdm", "(", "pool", ".", "imap", "(", "\n", "func", ",", "\n", "[", "\n", "(", "\n", "directory", ",", "\n", "str", "(", "i", "+", "offset", ")", ".", "zfill", "(", "w", ")", ",", "\n", "*", "problem", "\n", ")", "\n", "for", "i", ",", "problem", "in", "enumerate", "(", "ds", ")", "\n", "]", "\n", ")", ",", "total", "=", "len", "(", "ds", ")", ",", "mininterval", "=", "opts", ".", "progress_bar_mininterval", ")", ")", "\n", "\n", "", "failed", "=", "[", "str", "(", "i", "+", "offset", ")", "for", "i", ",", "res", "in", "enumerate", "(", "results", ")", "if", "res", "is", "None", "]", "\n", "assert", "len", "(", "failed", ")", "==", "0", ",", "\"Some instances failed: {}\"", ".", "format", "(", "\" \"", ".", "join", "(", "failed", ")", ")", "\n", "return", "results", ",", "num_cpus", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.do_batch_rep": [[224, 233], ["isinstance", "v[].expand().contiguous().view", "isinstance", "functions.do_batch_rep", "isinstance", "v[].expand().contiguous", "v.items", "functions.do_batch_rep", "tuple", "v.size", "v[].expand", "functions.do_batch_rep", "v.size"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.do_batch_rep", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.do_batch_rep", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.do_batch_rep", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "do_batch_rep", "(", "v", ",", "n", ")", ":", "\n", "    ", "if", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "        ", "return", "{", "k", ":", "do_batch_rep", "(", "v_", ",", "n", ")", "for", "k", ",", "v_", "in", "v", ".", "items", "(", ")", "}", "\n", "", "elif", "isinstance", "(", "v", ",", "list", ")", ":", "\n", "        ", "return", "[", "do_batch_rep", "(", "v_", ",", "n", ")", "for", "v_", "in", "v", "]", "\n", "", "elif", "isinstance", "(", "v", ",", "tuple", ")", ":", "\n", "        ", "return", "tuple", "(", "do_batch_rep", "(", "v_", ",", "n", ")", "for", "v_", "in", "v", ")", "\n", "\n", "", "return", "v", "[", "None", ",", "...", "]", ".", "expand", "(", "n", ",", "*", "v", ".", "size", "(", ")", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "*", "v", ".", "size", "(", ")", "[", "1", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.decomposition": [[236, 249], ["torch.cat", "torch.cat", "decomposed_seeds.reshape.reshape"], "function", ["None"], ["", "def", "decomposition", "(", "seeds", ",", "coordinate_dim", ",", "revision_len", ",", "offset", ",", "shift_len", "=", "1", ")", ":", "\n", "# change decomposition point", "\n", "    ", "seeds", "=", "torch", ".", "cat", "(", "[", "seeds", "[", ":", ",", "shift_len", ":", "]", ",", "seeds", "[", ":", ",", ":", "shift_len", "]", "]", ",", "1", ")", "\n", "\n", "if", "offset", "!=", "0", ":", "\n", "        ", "decomposed_seeds", "=", "seeds", "[", ":", ",", ":", "-", "offset", "]", "\n", "offset_seeds", "=", "seeds", "[", ":", ",", "-", "offset", ":", "]", "\n", "", "else", ":", "\n", "        ", "decomposed_seeds", "=", "seeds", "\n", "offset_seeds", "=", "None", "\n", "# decompose original seeds", "\n", "", "decomposed_seeds", "=", "decomposed_seeds", ".", "reshape", "(", "-", "1", ",", "revision_len", ",", "coordinate_dim", ")", "\n", "return", "decomposed_seeds", ",", "offset_seeds", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.revision": [[250, 262], ["revision_cost_func", "reviser", "decomposed_seeds.gather.gather", "sub_tour.unsqueeze().expand_as", "sub_tour.unsqueeze"], "function", ["None"], ["", "def", "revision", "(", "revision_cost_func", ",", "reviser", ",", "decomposed_seeds", ",", "original_subtour", ")", ":", "\n", "\n", "# tour length of segment TSPs", "\n", "    ", "init_cost", "=", "revision_cost_func", "(", "decomposed_seeds", ",", "original_subtour", ")", "\n", "cost_revised", ",", "sub_tour", "=", "reviser", "(", "decomposed_seeds", ",", "return_pi", "=", "True", ")", "\n", "reduced_cost", "=", "init_cost", "-", "cost_revised", "\n", "\n", "# preserve previous tour if reduced cost is negative", "\n", "sub_tour", "[", "reduced_cost", "<", "0", "]", "=", "original_subtour", "\n", "decomposed_seeds", "=", "decomposed_seeds", ".", "gather", "(", "1", ",", "sub_tour", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand_as", "(", "decomposed_seeds", ")", ")", "\n", "\n", "return", "decomposed_seeds", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.LCP_TSP": [[263, 281], ["torch.range().cuda", "torch.range().cuda", "range", "functions.decomposition", "functions.revision", "revision.reshape", "torch.range", "torch.range", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.decomposition", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.revision"], ["", "def", "LCP_TSP", "(", "seeds", ",", "cost_func", ",", "reviser", ",", "revision_len", ",", "revision_iter", ")", ":", "\n", "        ", "batch_size", ",", "num_nodes", ",", "coordinate_dim", "=", "seeds", ".", "shape", "\n", "\n", "\n", "offset", "=", "num_nodes", "%", "revision_len", "\n", "original_subtour", "=", "torch", ".", "range", "(", "0", ",", "revision_len", "-", "1", ",", "dtype", "=", "torch", ".", "long", ")", ".", "cuda", "(", ")", "\n", "for", "_", "in", "range", "(", "revision_iter", ")", ":", "\n", "            ", "decomposed_seeds", ",", "offset_seed", "=", "decomposition", "(", "seeds", ",", "coordinate_dim", "\n", ",", "revision_len", ",", "offset", ")", "\n", "decomposed_seeds_revised", "=", "revision", "(", "cost_func", ",", "reviser", ",", "decomposed_seeds", ",", "original_subtour", ")", "\n", "\n", "seeds", "=", "decomposed_seeds_revised", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "coordinate_dim", ")", "\n", "\n", "if", "offset_seed", "is", "not", "None", ":", "\n", "                ", "seeds", "=", "torch", ".", "cat", "(", "[", "seeds", ",", "offset_seed", "]", ",", "dim", "=", "1", ")", "\n", "\n", "\n", "", "", "return", "seeds", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.sample_many": [[284, 323], ["functions.do_batch_rep", "inner_func", "get_cost_func", "problem.gather", "functions.LCP_TSP", "cost.min", "cost_revised.min", "cost.min", "pi.unsqueeze().expand_as", "functions.LCP_TSP", "pi.unsqueeze"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.do_batch_rep", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.LCP_TSP", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.LCP_TSP"], ["", "def", "sample_many", "(", "inner_func", ",", "get_cost_func", ",", "get_cost_func2", ",", "input", ",", "opts", ",", "batch_rep", "=", "1", ",", "iter_rep", "=", "1", ",", "reviser", "=", "None", ",", "reviser_2", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    :param input: (batch_size, graph_size, node_dim) input node features\n    :return:\n    \"\"\"", "\n", "\n", "input", "=", "do_batch_rep", "(", "input", ",", "batch_rep", ")", "\n", "_log_p", ",", "pi", ",", "_", ",", "_", "=", "inner_func", "(", "input", ")", "\n", "# input[0] is problem: s, input[1] is encoded problem: h", "\n", "problem", "=", "input", "[", "0", "]", "\n", "cost", ",", "_", "=", "get_cost_func", "(", "problem", ",", "pi", ")", "\n", "\n", "\n", "if", "opts", ".", "problem", "==", "'tsp'", ":", "\n", "\n", "######## LCP-TSP ##########", "\n", "# seeds are initial solution from seeder", "\n", "        ", "seeds", "=", "problem", ".", "gather", "(", "1", ",", "pi", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand_as", "(", "problem", ")", ")", "\n", "seeds", "=", "LCP_TSP", "(", "seeds", ",", "get_cost_func2", ",", "reviser", ",", "opts", ".", "revision_len1", ",", "opts", ".", "revision_iter1", ")", "\n", "\n", "#LCP*", "\n", "if", "reviser_2", "is", "not", "None", ":", "\n", "            ", "seeds", "=", "LCP_TSP", "(", "seeds", ",", "get_cost_func2", ",", "reviser_2", ",", "opts", ".", "revision_len2", ",", "opts", ".", "revision_iter2", ")", "\n", "######## LCP-TSP ##########", "\n", "\n", "", "cost_revised", "=", "(", "seeds", "[", ":", ",", "1", ":", "]", "-", "seeds", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "2", ")", ".", "sum", "(", "1", ")", "+", "(", "seeds", "[", ":", ",", "0", "]", "-", "seeds", "[", ":", ",", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", "\n", "\n", "mincosts", ",", "argmincosts", "=", "cost", ".", "min", "(", "0", ")", "\n", "mincosts_revised", ",", "argmincosts_revised", "=", "cost_revised", ".", "min", "(", "0", ")", "\n", "\n", "min_tour", "=", "seeds", "[", "argmincosts_revised", "]", "\n", "\n", "return", "min_tour", ",", "mincosts", ",", "mincosts_revised", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "mincosts", ",", "argmincosts", "=", "cost", ".", "min", "(", "0", ")", "\n", "min_tour", "=", "pi", "[", "argmincosts", "]", "\n", "return", "pi", ",", "mincosts", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.utils.tensor_functions.compute_in_batches": [[4, 35], ["isinstance", "tensor_functions.compute_in_batches.safe_cat"], "function", ["None"], ["def", "compute_in_batches", "(", "f", ",", "calc_batch_size", ",", "*", "args", ",", "n", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Computes memory heavy function f(*args) in batches\n    :param n: the total number of elements, optional if it cannot be determined as args[0].size(0)\n    :param f: The function that is computed, should take only tensors as arguments and return tensor or tuple of tensors\n    :param calc_batch_size: The batch size to use when computing this function\n    :param args: Tensor arguments with equally sized first batch dimension\n    :return: f(*args), this should be one or multiple tensors with equally sized first batch dimension\n    \"\"\"", "\n", "if", "n", "is", "None", ":", "\n", "        ", "n", "=", "args", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "", "n_batches", "=", "(", "n", "+", "calc_batch_size", "-", "1", ")", "//", "calc_batch_size", "# ceil", "\n", "if", "n_batches", "==", "1", ":", "\n", "        ", "return", "f", "(", "*", "args", ")", "\n", "\n", "# Run all batches", "\n", "# all_res = [f(*batch_args) for batch_args in zip(*[torch.chunk(arg, n_batches) for arg in args])]", "\n", "# We do not use torch.chunk such that it also works for other classes that support slicing", "\n", "", "all_res", "=", "[", "f", "(", "*", "(", "arg", "[", "i", "*", "calc_batch_size", ":", "(", "i", "+", "1", ")", "*", "calc_batch_size", "]", "for", "arg", "in", "args", ")", ")", "for", "i", "in", "range", "(", "n_batches", ")", "]", "\n", "\n", "# Allow for functions that return None", "\n", "def", "safe_cat", "(", "chunks", ",", "dim", "=", "0", ")", ":", "\n", "        ", "if", "chunks", "[", "0", "]", "is", "None", ":", "\n", "            ", "assert", "all", "(", "chunk", "is", "None", "for", "chunk", "in", "chunks", ")", "\n", "return", "None", "\n", "", "return", "torch", ".", "cat", "(", "chunks", ",", "dim", ")", "\n", "\n", "# Depending on whether the function returned a tuple we need to concatenate each element or only the result", "\n", "", "if", "isinstance", "(", "all_res", "[", "0", "]", ",", "tuple", ")", ":", "\n", "        ", "return", "tuple", "(", "safe_cat", "(", "res_chunks", ",", "0", ")", "for", "res_chunks", "in", "zip", "(", "*", "all_res", ")", ")", "\n", "", "return", "safe_cat", "(", "all_res", ",", "0", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_gurobi.solve_euclidian_tsp": [[18, 113], ["len", "Model", "Model.addVars", "m.addVars.keys", "Model.addConstrs", "Model.optimize", "Model.getAttr", "tuplelist", "tsp_gurobi.solve_euclidian_tsp.subtour"], "function", ["None"], ["def", "solve_euclidian_tsp", "(", "points", ",", "threads", "=", "0", ",", "timeout", "=", "None", ",", "gap", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Solves the Euclidan TSP problem to optimality using the MIP formulation \n    with lazy subtour elimination constraint generation.\n    :param points: list of (x, y) coordinate \n    :return: \n    \"\"\"", "\n", "\n", "n", "=", "len", "(", "points", ")", "\n", "\n", "# Callback - use lazy constraints to eliminate sub-tours", "\n", "\n", "def", "subtourelim", "(", "model", ",", "where", ")", ":", "\n", "        ", "if", "where", "==", "GRB", ".", "Callback", ".", "MIPSOL", ":", "\n", "# make a list of edges selected in the solution", "\n", "            ", "vals", "=", "model", ".", "cbGetSolution", "(", "model", ".", "_vars", ")", "\n", "selected", "=", "tuplelist", "(", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "model", ".", "_vars", ".", "keys", "(", ")", "if", "vals", "[", "i", ",", "j", "]", ">", "0.5", ")", "\n", "# find the shortest cycle in the selected edge list", "\n", "tour", "=", "subtour", "(", "selected", ")", "\n", "if", "len", "(", "tour", ")", "<", "n", ":", "\n", "# add subtour elimination constraint for every pair of cities in tour", "\n", "                ", "model", ".", "cbLazy", "(", "quicksum", "(", "model", ".", "_vars", "[", "i", ",", "j", "]", "\n", "for", "i", ",", "j", "in", "itertools", ".", "combinations", "(", "tour", ",", "2", ")", ")", "\n", "<=", "len", "(", "tour", ")", "-", "1", ")", "\n", "\n", "# Given a tuplelist of edges, find the shortest subtour", "\n", "\n", "", "", "", "def", "subtour", "(", "edges", ")", ":", "\n", "        ", "unvisited", "=", "list", "(", "range", "(", "n", ")", ")", "\n", "cycle", "=", "range", "(", "n", "+", "1", ")", "# initial length has 1 more city", "\n", "while", "unvisited", ":", "# true if list is non-empty", "\n", "            ", "thiscycle", "=", "[", "]", "\n", "neighbors", "=", "unvisited", "\n", "while", "neighbors", ":", "\n", "                ", "current", "=", "neighbors", "[", "0", "]", "\n", "thiscycle", ".", "append", "(", "current", ")", "\n", "unvisited", ".", "remove", "(", "current", ")", "\n", "neighbors", "=", "[", "j", "for", "i", ",", "j", "in", "edges", ".", "select", "(", "current", ",", "'*'", ")", "if", "j", "in", "unvisited", "]", "\n", "", "if", "len", "(", "cycle", ")", ">", "len", "(", "thiscycle", ")", ":", "\n", "                ", "cycle", "=", "thiscycle", "\n", "", "", "return", "cycle", "\n", "\n", "# Dictionary of Euclidean distance between each pair of points", "\n", "\n", "", "dist", "=", "{", "(", "i", ",", "j", ")", ":", "\n", "math", ".", "sqrt", "(", "sum", "(", "(", "points", "[", "i", "]", "[", "k", "]", "-", "points", "[", "j", "]", "[", "k", "]", ")", "**", "2", "for", "k", "in", "range", "(", "2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", "for", "j", "in", "range", "(", "i", ")", "}", "\n", "\n", "m", "=", "Model", "(", ")", "\n", "m", ".", "Params", ".", "outputFlag", "=", "False", "\n", "\n", "# Create variables", "\n", "\n", "vars", "=", "m", ".", "addVars", "(", "dist", ".", "keys", "(", ")", ",", "obj", "=", "dist", ",", "vtype", "=", "GRB", ".", "BINARY", ",", "name", "=", "'e'", ")", "\n", "for", "i", ",", "j", "in", "vars", ".", "keys", "(", ")", ":", "\n", "        ", "vars", "[", "j", ",", "i", "]", "=", "vars", "[", "i", ",", "j", "]", "# edge in opposite direction", "\n", "\n", "# You could use Python looping constructs and m.addVar() to create", "\n", "# these decision variables instead.  The following would be equivalent", "\n", "# to the preceding m.addVars() call...", "\n", "#", "\n", "# vars = tupledict()", "\n", "# for i,j in dist.keys():", "\n", "#   vars[i,j] = m.addVar(obj=dist[i,j], vtype=GRB.BINARY,", "\n", "#                        name='e[%d,%d]'%(i,j))", "\n", "\n", "\n", "# Add degree-2 constraint", "\n", "\n", "", "m", ".", "addConstrs", "(", "vars", ".", "sum", "(", "i", ",", "'*'", ")", "==", "2", "for", "i", "in", "range", "(", "n", ")", ")", "\n", "\n", "# Using Python looping constructs, the preceding would be...", "\n", "#", "\n", "# for i in range(n):", "\n", "#   m.addConstr(sum(vars[i,j] for j in range(n)) == 2)", "\n", "\n", "\n", "# Optimize model", "\n", "\n", "m", ".", "_vars", "=", "vars", "\n", "m", ".", "Params", ".", "lazyConstraints", "=", "1", "\n", "m", ".", "Params", ".", "threads", "=", "threads", "\n", "if", "timeout", ":", "\n", "        ", "m", ".", "Params", ".", "timeLimit", "=", "timeout", "\n", "", "if", "gap", ":", "\n", "        ", "m", ".", "Params", ".", "mipGap", "=", "gap", "*", "0.01", "# Percentage", "\n", "", "m", ".", "optimize", "(", "subtourelim", ")", "\n", "\n", "vals", "=", "m", ".", "getAttr", "(", "'x'", ",", "vars", ")", "\n", "selected", "=", "tuplelist", "(", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "vals", ".", "keys", "(", ")", "if", "vals", "[", "i", ",", "j", "]", ">", "0.5", ")", "\n", "\n", "tour", "=", "subtour", "(", "selected", ")", "\n", "assert", "len", "(", "tour", ")", "==", "n", "\n", "\n", "return", "m", ".", "objVal", ",", "tour", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_gurobi.solve_all_gurobi": [[115, 122], ["enumerate", "print", "tsp_gurobi.solve_euclidian_tsp", "results.append"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_gurobi.solve_euclidian_tsp"], ["", "def", "solve_all_gurobi", "(", "dataset", ")", ":", "\n", "    ", "results", "=", "[", "]", "\n", "for", "i", ",", "instance", "in", "enumerate", "(", "dataset", ")", ":", "\n", "        ", "print", "(", "\"Solving instance {}\"", ".", "format", "(", "i", ")", ")", "\n", "result", "=", "solve_euclidian_tsp", "(", "instance", ")", "\n", "results", ".", "append", "(", "result", ")", "\n", "", "return", "results", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.visited": [[23, 29], ["utils.boolmask.mask_long2bool", "state_local.StateLOCAL.loc.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long2bool", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["@", "property", "\n", "def", "visited", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "            ", "return", "self", ".", "visited_", "\n", "", "else", ":", "\n", "            ", "return", "mask_long2bool", "(", "self", ".", "visited_", ",", "n", "=", "self", ".", "loc", ".", "size", "(", "-", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.__getitem__": [[30, 39], ["state_local.StateLOCAL._replace", "torch.is_tensor", "isinstance"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "# If tensor, idx all tensors by this tensor:", "\n", "return", "self", ".", "_replace", "(", "\n", "ids", "=", "self", ".", "ids", "[", "key", "]", ",", "\n", "first_a", "=", "self", ".", "first_a", "[", "key", "]", ",", "\n", "prev_a", "=", "self", ".", "prev_a", "[", "key", "]", ",", "\n", "visited_", "=", "self", ".", "visited_", "[", "key", "]", ",", "\n", "lengths", "=", "self", ".", "lengths", "[", "key", "]", ",", "\n", "cur_coord", "=", "self", ".", "cur_coord", "[", "key", "]", "if", "self", ".", "cur_coord", "is", "not", "None", "else", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.initialize": [[42, 68], ["loc.size", "torch.zeros", "torch.zeros", "state_local.StateLOCAL", "torch.zeros", "torch.zeros", "torch.arange", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "@", "staticmethod", "\n", "def", "initialize", "(", "loc", ",", "visited_dtype", "=", "torch", ".", "uint8", ")", ":", "\n", "\n", "        ", "batch_size", ",", "n_loc", ",", "_", "=", "loc", ".", "size", "(", ")", "\n", "prev_a", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "loc", ".", "device", ")", "\n", "last_a", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "loc", ".", "device", ")", "\n", "last_a", "=", "last_a", "+", "9", "\n", "return", "StateLOCAL", "(", "\n", "loc", "=", "loc", ",", "\n", "dist", "=", "(", "loc", "[", ":", ",", ":", ",", "None", ",", ":", "]", "-", "loc", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", ",", "\n", "ids", "=", "torch", ".", "arange", "(", "batch_size", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "[", ":", ",", "None", "]", ",", "# Add steps dimension", "\n", "first_a", "=", "prev_a", ",", "\n", "last_a", "=", "prev_a", ",", "\n", "prev_a", "=", "prev_a", ",", "\n", "# Keep visited with depot so we can scatter efficiently (if there is an action for depot)", "\n", "visited_", "=", "(", "# Visited as mask is easier to understand, as long more memory efficient", "\n", "torch", ".", "zeros", "(", "\n", "batch_size", ",", "1", ",", "n_loc", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "loc", ".", "device", "\n", ")", "\n", "if", "visited_dtype", "==", "torch", ".", "uint8", "\n", "else", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "(", "n_loc", "+", "63", ")", "//", "64", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Ceil", "\n", ")", ",", "\n", "lengths", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "cur_coord", "=", "None", ",", "\n", "i", "=", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Vector with length num_steps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.get_final_cost": [[70, 76], ["state_local.StateLOCAL.all_finished"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished"], ["", "def", "get_final_cost", "(", "self", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "all_finished", "(", ")", "\n", "# assert self.visited_.", "\n", "\n", "return", "self", ".", "lengths", "+", "(", "self", ".", "loc", "[", "self", ".", "ids", ",", "self", ".", "first_a", ",", ":", "]", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.update": [[77, 103], ["state_local.StateLOCAL._replace", "state_local.StateLOCAL.visited_.scatter", "utils.boolmask.mask_long_scatter", "state_local.StateLOCAL.i.item"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long_scatter"], ["", "def", "update", "(", "self", ",", "selected", ")", ":", "\n", "\n", "# Update the state", "\n", "        ", "prev_a", "=", "selected", "[", ":", ",", "None", "]", "# Add dimension for step", "\n", "\n", "# Add the length", "\n", "# cur_coord = self.loc.gather(", "\n", "#     1,", "\n", "#     selected[:, None, None].expand(selected.size(0), 1, self.loc.size(-1))", "\n", "# )[:, 0, :]", "\n", "cur_coord", "=", "self", ".", "loc", "[", "self", ".", "ids", ",", "prev_a", "]", "\n", "lengths", "=", "self", ".", "lengths", "\n", "if", "self", ".", "cur_coord", "is", "not", "None", ":", "# Don't add length for first action (selection of start node)", "\n", "            ", "lengths", "=", "self", ".", "lengths", "+", "(", "cur_coord", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# (batch_dim, 1)", "\n", "\n", "# Update should only be called with just 1 parallel step, in which case we can check this way if we should update", "\n", "", "first_a", "=", "prev_a", "if", "self", ".", "i", ".", "item", "(", ")", "==", "0", "else", "self", ".", "first_a", "\n", "\n", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "# Add one dimension since we write a single value", "\n", "            ", "visited_", "=", "self", ".", "visited_", ".", "scatter", "(", "-", "1", ",", "prev_a", "[", ":", ",", ":", ",", "None", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "visited_", "=", "mask_long_scatter", "(", "self", ".", "visited_", ",", "prev_a", ")", "\n", "\n", "", "return", "self", ".", "_replace", "(", "first_a", "=", "first_a", ",", "prev_a", "=", "prev_a", ",", "visited_", "=", "visited_", ",", "\n", "lengths", "=", "lengths", ",", "cur_coord", "=", "cur_coord", ",", "i", "=", "self", ".", "i", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.all_finished": [[104, 107], ["state_local.StateLOCAL.i.item", "state_local.StateLOCAL.loc.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "all_finished", "(", "self", ")", ":", "\n", "# Exactly n steps", "\n", "        ", "return", "self", ".", "i", ".", "item", "(", ")", ">=", "self", ".", "loc", ".", "size", "(", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.get_current_node": [[108, 110], ["None"], "methods", ["None"], ["", "def", "get_current_node", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "prev_a", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.get_mask": [[111, 113], ["None"], "methods", ["None"], ["", "def", "get_mask", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "visited", ">", "0", "# Hacky way to return bool or uint8 depending on pytorch version", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.get_nn": [[114, 120], ["state_local.StateLOCAL.loc.size", "state_local.StateLOCAL.i.item", "state_local.StateLOCAL.visited.float"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "get_nn", "(", "self", ",", "k", "=", "None", ")", ":", "\n", "# Insert step dimension", "\n", "# Nodes already visited get inf so they do not make it", "\n", "        ", "if", "k", "is", "None", ":", "\n", "            ", "k", "=", "self", ".", "loc", ".", "size", "(", "-", "2", ")", "-", "self", ".", "i", ".", "item", "(", ")", "# Number of remaining", "\n", "", "return", "(", "self", ".", "dist", "[", "self", ".", "ids", ",", ":", ",", ":", "]", "+", "self", ".", "visited", ".", "float", "(", ")", "[", ":", ",", ":", ",", "None", ",", ":", "]", "*", "1e6", ")", ".", "topk", "(", "k", ",", "dim", "=", "-", "1", ",", "largest", "=", "False", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.get_nn_current": [[121, 135], ["min", "state_local.StateLOCAL.loc.size", "state_local.StateLOCAL.loc.size", "state_local.StateLOCAL.i.item", "state_local.StateLOCAL.visited.float"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "get_nn_current", "(", "self", ",", "k", "=", "None", ")", ":", "\n", "        ", "assert", "False", ",", "\"Currently not implemented, look into which neighbours to use in step 0?\"", "\n", "# Note: if this is called in step 0, it will have k nearest neighbours to node 0, which may not be desired", "\n", "# so it is probably better to use k = None in the first iteration", "\n", "if", "k", "is", "None", ":", "\n", "            ", "k", "=", "self", ".", "loc", ".", "size", "(", "-", "2", ")", "\n", "", "k", "=", "min", "(", "k", ",", "self", ".", "loc", ".", "size", "(", "-", "2", ")", "-", "self", ".", "i", ".", "item", "(", ")", ")", "# Number of remaining", "\n", "return", "(", "\n", "self", ".", "dist", "[", "\n", "self", ".", "ids", ",", "\n", "self", ".", "prev_a", "\n", "]", "+", "\n", "self", ".", "visited", ".", "float", "(", ")", "*", "1e6", "\n", ")", ".", "topk", "(", "k", ",", "dim", "=", "-", "1", ",", "largest", "=", "False", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.state_local.StateLOCAL.construct_solutions": [[136, 138], ["None"], "methods", ["None"], ["", "def", "construct_solutions", "(", "self", ",", "actions", ")", ":", "\n", "        ", "return", "actions", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.solve_gurobi": [[16, 45], ["os.path.join", "tsp_baseline.calc_tsp_length", "os.path.isfile", "utils.data_utils.load_dataset", "time.time", "solve_euclidian_tsp_gurobi", "utils.data_utils.save_dataset", "abs", "print", "print", "time.time"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset"], ["def", "solve_gurobi", "(", "directory", ",", "name", ",", "loc", ",", "disable_cache", "=", "False", ",", "timeout", "=", "None", ",", "gap", "=", "None", ")", ":", "\n", "# Lazy import so we do not need to have gurobi installed to run this script", "\n", "    ", "from", "problems", ".", "tsp", ".", "tsp_gurobi", "import", "solve_euclidian_tsp", "as", "solve_euclidian_tsp_gurobi", "\n", "\n", "try", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.gurobi{}{}.pkl\"", ".", "format", "(", "\n", "name", ",", "\"\"", "if", "timeout", "is", "None", "else", "\"t{}\"", ".", "format", "(", "timeout", ")", ",", "\"\"", "if", "gap", "is", "None", "else", "\"gap{}\"", ".", "format", "(", "gap", ")", ")", ")", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "problem_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "(", "cost", ",", "tour", ",", "duration", ")", "=", "load_dataset", "(", "problem_filename", ")", "\n", "", "else", ":", "\n", "# 0 = start, 1 = end so add depot twice", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "cost", ",", "tour", "=", "solve_euclidian_tsp_gurobi", "(", "loc", ",", "threads", "=", "1", ",", "timeout", "=", "timeout", ",", "gap", "=", "gap", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "# Measure clock time", "\n", "save_dataset", "(", "(", "cost", ",", "tour", ",", "duration", ")", ",", "problem_filename", ")", "\n", "\n", "# First and last node are depot(s), so first node is 2 but should be 1 (as depot is 0) so subtract 1", "\n", "", "total_cost", "=", "calc_tsp_length", "(", "loc", ",", "tour", ")", "\n", "assert", "abs", "(", "total_cost", "-", "cost", ")", "<=", "1e-5", ",", "\"Cost is incorrect\"", "\n", "return", "total_cost", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "# For some stupid reason, sometimes OR tools cannot find a feasible solution?", "\n", "# By letting it fail we do not get total results, but we dcan retry by the caching mechanism", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.solve_concorde_log": [[47, 83], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.isfile", "utils.data_utils.load_dataset", "tsp_baseline.write_tsplib", "tsp_baseline.read_concorde_tour", "utils.data_utils.save_dataset", "tsp_baseline.calc_tsp_length", "print", "print", "open", "time.time", "subprocess.check_call", "time.time", "os.path.abspath", "os.path.abspath"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_tsplib", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.read_concorde_tour", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length"], ["", "", "def", "solve_concorde_log", "(", "executable", ",", "directory", ",", "name", ",", "loc", ",", "disable_cache", "=", "False", ")", ":", "\n", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.tsp\"", ".", "format", "(", "name", ")", ")", "\n", "tour_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.tour\"", ".", "format", "(", "name", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.concorde.pkl\"", ".", "format", "(", "name", ")", ")", "\n", "log_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.log\"", ".", "format", "(", "name", ")", ")", "\n", "\n", "# if True:", "\n", "try", ":", "\n", "# May have already been run", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "tour", ",", "duration", "=", "load_dataset", "(", "output_filename", ")", "\n", "", "else", ":", "\n", "            ", "write_tsplib", "(", "problem_filename", ",", "loc", ",", "name", "=", "name", ")", "\n", "\n", "with", "open", "(", "log_filename", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "start", "=", "time", ".", "time", "(", ")", "\n", "try", ":", "\n", "# Concorde is weird, will leave traces of solution in current directory so call from target dir", "\n", "                    ", "check_call", "(", "[", "executable", ",", "'-s'", ",", "'1234'", ",", "'-x'", ",", "'-o'", ",", "\n", "os", ".", "path", ".", "abspath", "(", "tour_filename", ")", ",", "os", ".", "path", ".", "abspath", "(", "problem_filename", ")", "]", ",", "\n", "stdout", "=", "f", ",", "stderr", "=", "f", ",", "cwd", "=", "directory", ")", "\n", "", "except", "CalledProcessError", "as", "e", ":", "\n", "# Somehow Concorde returns 255", "\n", "                    ", "assert", "e", ".", "returncode", "==", "255", "\n", "", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "", "tour", "=", "read_concorde_tour", "(", "tour_filename", ")", "\n", "save_dataset", "(", "(", "tour", ",", "duration", ")", ",", "output_filename", ")", "\n", "\n", "", "return", "calc_tsp_length", "(", "loc", ",", "tour", ")", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.solve_lkh_log": [[85, 117], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.isfile", "utils.data_utils.load_dataset", "tsp_baseline.write_tsplib", "tsp_baseline.write_lkh_par", "tsp_baseline.read_tsplib", "utils.data_utils.save_dataset", "tsp_baseline.calc_tsp_length", "print", "print", "open", "time.time", "subprocess.check_call", "time.time"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_tsplib", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_lkh_par", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.read_tsplib", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length"], ["", "", "def", "solve_lkh_log", "(", "executable", ",", "directory", ",", "name", ",", "loc", ",", "runs", "=", "1", ",", "disable_cache", "=", "False", ")", ":", "\n", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.vrp\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "tour_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.tour\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.pkl\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "param_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.par\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "log_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.log\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "\n", "try", ":", "\n", "# May have already been run", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "tour", ",", "duration", "=", "load_dataset", "(", "output_filename", ")", "\n", "", "else", ":", "\n", "            ", "write_tsplib", "(", "problem_filename", ",", "loc", ",", "name", "=", "name", ")", "\n", "\n", "params", "=", "{", "\"PROBLEM_FILE\"", ":", "problem_filename", ",", "\"OUTPUT_TOUR_FILE\"", ":", "tour_filename", ",", "\"RUNS\"", ":", "runs", ",", "\"SEED\"", ":", "1234", "}", "\n", "write_lkh_par", "(", "param_filename", ",", "params", ")", "\n", "\n", "with", "open", "(", "log_filename", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "start", "=", "time", ".", "time", "(", ")", "\n", "check_call", "(", "[", "executable", ",", "param_filename", "]", ",", "stdout", "=", "f", ",", "stderr", "=", "f", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "", "tour", "=", "read_tsplib", "(", "tour_filename", ")", "\n", "save_dataset", "(", "(", "tour", ",", "duration", ")", ",", "output_filename", ")", "\n", "\n", "", "return", "calc_tsp_length", "(", "loc", ",", "tour", ")", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.write_lkh_par": [[119, 132], ["open", "f.write", "f.write"], "function", ["None"], ["", "", "def", "write_lkh_par", "(", "filename", ",", "parameters", ")", ":", "\n", "    ", "default_parameters", "=", "{", "# Use none to include as flag instead of kv", "\n", "\"MAX_TRIALS\"", ":", "10000", ",", "\n", "\"RUNS\"", ":", "10", ",", "\n", "\"TRACE_LEVEL\"", ":", "1", ",", "\n", "\"SEED\"", ":", "0", "\n", "}", "\n", "with", "open", "(", "filename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "for", "k", ",", "v", "in", "{", "**", "default_parameters", ",", "**", "parameters", "}", ".", "items", "(", ")", ":", "\n", "            ", "if", "v", "is", "None", ":", "\n", "                ", "f", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "k", ")", ")", "\n", "", "else", ":", "\n", "                ", "f", ".", "write", "(", "\"{} = {}\\n\"", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.write_tsplib": [[134, 154], ["open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "int", "int", "enumerate", "len"], "function", ["None"], ["", "", "", "", "def", "write_tsplib", "(", "filename", ",", "loc", ",", "name", "=", "\"problem\"", ")", ":", "\n", "\n", "    ", "with", "open", "(", "filename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{} : {}\"", ".", "format", "(", "k", ",", "v", ")", "\n", "for", "k", ",", "v", "in", "(", "\n", "(", "\"NAME\"", ",", "name", ")", ",", "\n", "(", "\"TYPE\"", ",", "\"TSP\"", ")", ",", "\n", "(", "\"DIMENSION\"", ",", "len", "(", "loc", ")", ")", ",", "\n", "(", "\"EDGE_WEIGHT_TYPE\"", ",", "\"EUC_2D\"", ")", ",", "\n", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"NODE_COORD_SECTION\\n\"", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{}\\t{}\\t{}\"", ".", "format", "(", "i", "+", "1", ",", "int", "(", "x", "*", "10000000", "+", "0.5", ")", ",", "int", "(", "y", "*", "10000000", "+", "0.5", ")", ")", "# tsplib does not take floats", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "loc", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"EOF\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.read_concorde_tour": [[156, 167], ["open", "len", "int", "tour.extend", "int", "line.rstrip().split", "line.rstrip"], "function", ["None"], ["", "", "def", "read_concorde_tour", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "n", "=", "None", "\n", "tour", "=", "[", "]", "\n", "for", "line", "in", "f", ":", "\n", "            ", "if", "n", "is", "None", ":", "\n", "                ", "n", "=", "int", "(", "line", ")", "\n", "", "else", ":", "\n", "                ", "tour", ".", "extend", "(", "[", "int", "(", "node", ")", "for", "node", "in", "line", ".", "rstrip", "(", ")", ".", "split", "(", "\" \"", ")", "]", ")", "\n", "", "", "", "assert", "len", "(", "tour", ")", "==", "n", ",", "\"Unexpected tour length\"", "\n", "return", "tour", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.read_tsplib": [[169, 189], ["tour.tolist", "open", "len", "numpy.array().astype", "line.startswith", "line.startswith", "int", "tour.append", "int", "numpy.array", "line.split"], "function", ["None"], ["", "def", "read_tsplib", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "tour", "=", "[", "]", "\n", "dimension", "=", "0", "\n", "started", "=", "False", "\n", "for", "line", "in", "f", ":", "\n", "            ", "if", "started", ":", "\n", "                ", "loc", "=", "int", "(", "line", ")", "\n", "if", "loc", "==", "-", "1", ":", "\n", "                    ", "break", "\n", "", "tour", ".", "append", "(", "loc", ")", "\n", "", "if", "line", ".", "startswith", "(", "\"DIMENSION\"", ")", ":", "\n", "                ", "dimension", "=", "int", "(", "line", ".", "split", "(", "\" \"", ")", "[", "-", "1", "]", ")", "\n", "\n", "", "if", "line", ".", "startswith", "(", "\"TOUR_SECTION\"", ")", ":", "\n", "                ", "started", "=", "True", "\n", "\n", "", "", "", "assert", "len", "(", "tour", ")", "==", "dimension", "\n", "tour", "=", "np", ".", "array", "(", "tour", ")", ".", "astype", "(", "int", ")", "-", "1", "# Subtract 1 as depot is 1 and should be 0", "\n", "return", "tour", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.calc_tsp_length": [[191, 196], ["numpy.linalg.norm().sum", "len", "len", "len", "len", "numpy.array", "numpy.unique", "numpy.concatenate", "numpy.linalg.norm"], "function", ["None"], ["", "def", "calc_tsp_length", "(", "loc", ",", "tour", ")", ":", "\n", "    ", "assert", "len", "(", "np", ".", "unique", "(", "tour", ")", ")", "==", "len", "(", "tour", ")", ",", "\"Tour cannot contain duplicates\"", "\n", "assert", "len", "(", "tour", ")", "==", "len", "(", "loc", ")", "\n", "sorted_locs", "=", "np", ".", "array", "(", "loc", ")", "[", "np", ".", "concatenate", "(", "(", "tour", ",", "[", "tour", "[", "0", "]", "]", ")", ")", "]", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "sorted_locs", "[", "1", ":", "]", "-", "sorted_locs", "[", ":", "-", "1", "]", ",", "axis", "=", "-", "1", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline._calc_insert_cost": [[198, 211], ["None"], "function", ["None"], ["", "def", "_calc_insert_cost", "(", "D", ",", "prv", ",", "nxt", ",", "ins", ")", ":", "\n", "    ", "\"\"\"\n    Calculates insertion costs of inserting ins between prv and nxt\n    :param D: distance matrix\n    :param prv: node before inserted node, can be vector\n    :param nxt: node after inserted node, can be vector\n    :param ins: node to insert\n    :return:\n    \"\"\"", "\n", "return", "(", "\n", "D", "[", "prv", ",", "ins", "]", "\n", "+", "D", "[", "ins", ",", "nxt", "]", "\n", "-", "D", "[", "prv", ",", "nxt", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.run_insertion": [[214, 257], ["len", "scipy.spatial.distance_matrix", "numpy.zeros", "range", "D[].sum", "numpy.flatnonzero", "len", "numpy.argmin", "tour.insert", "tsp_baseline._calc_insert_cost", "numpy.roll", "numpy.roll", "D[].min().argmin", "scipy.spatial.distance_matrix.max().argmax", "D[].min", "scipy.spatial.distance_matrix.max", "D[].min().argmax", "D[].min", "numpy.ix_", "numpy.ix_"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline._calc_insert_cost"], ["", "def", "run_insertion", "(", "loc", ",", "method", ")", ":", "\n", "    ", "n", "=", "len", "(", "loc", ")", "\n", "D", "=", "distance_matrix", "(", "loc", ",", "loc", ")", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "n", ",", "dtype", "=", "bool", ")", "\n", "tour", "=", "[", "]", "# np.empty((0, ), dtype=int)", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "feas", "=", "mask", "==", "0", "\n", "feas_ind", "=", "np", ".", "flatnonzero", "(", "mask", "==", "0", ")", "\n", "if", "method", "==", "'random'", ":", "\n", "# Order of instance is random so do in order for deterministic results", "\n", "            ", "a", "=", "i", "\n", "", "elif", "method", "==", "'nearest'", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "a", "=", "0", "# order does not matter so first is random", "\n", "", "else", ":", "\n", "                ", "a", "=", "feas_ind", "[", "D", "[", "np", ".", "ix_", "(", "feas", ",", "~", "feas", ")", "]", ".", "min", "(", "1", ")", ".", "argmin", "(", ")", "]", "# node nearest to any in tour", "\n", "", "", "elif", "method", "==", "'cheapest'", ":", "\n", "            ", "assert", "False", ",", "\"Not yet implemented\"", "# try all and find cheapest insertion cost", "\n", "\n", "", "elif", "method", "==", "'farthest'", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "a", "=", "D", ".", "max", "(", "1", ")", ".", "argmax", "(", ")", "# Node with farthest distance to any other node", "\n", "", "else", ":", "\n", "                ", "a", "=", "feas_ind", "[", "D", "[", "np", ".", "ix_", "(", "feas", ",", "~", "feas", ")", "]", ".", "min", "(", "1", ")", ".", "argmax", "(", ")", "]", "# node which has closest node in tour farthest", "\n", "", "", "mask", "[", "a", "]", "=", "True", "\n", "\n", "if", "len", "(", "tour", ")", "==", "0", ":", "\n", "            ", "tour", "=", "[", "a", "]", "\n", "", "else", ":", "\n", "# Find index with least insert cost", "\n", "            ", "ind_insert", "=", "np", ".", "argmin", "(", "\n", "_calc_insert_cost", "(", "\n", "D", ",", "\n", "tour", ",", "\n", "np", ".", "roll", "(", "tour", ",", "-", "1", ")", ",", "\n", "a", "\n", ")", "\n", ")", "\n", "tour", ".", "insert", "(", "ind_insert", "+", "1", ",", "a", ")", "\n", "\n", "", "", "cost", "=", "D", "[", "tour", ",", "np", ".", "roll", "(", "tour", ",", "-", "1", ")", "]", ".", "sum", "(", ")", "\n", "return", "cost", ",", "tour", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.solve_insertion": [[259, 264], ["time.time", "tsp_baseline.run_insertion", "time.time"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.run_insertion"], ["", "def", "solve_insertion", "(", "directory", ",", "name", ",", "loc", ",", "method", "=", "'random'", ")", ":", "\n", "    ", "start", "=", "time", ".", "time", "(", ")", "\n", "cost", ",", "tour", "=", "run_insertion", "(", "loc", ",", "method", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "return", "cost", ",", "tour", ",", "duration", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.calc_batch_pdist": [[266, 269], ["torch.matmul().squeeze().squeeze().sqrt", "torch.matmul().squeeze().squeeze", "torch.matmul().squeeze", "torch.matmul", "numpy.np.inf"], "function", ["None"], ["", "def", "calc_batch_pdist", "(", "dataset", ")", ":", "\n", "    ", "diff", "=", "(", "dataset", "[", ":", ",", ":", ",", "None", ",", ":", "]", "-", "dataset", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", "\n", "return", "torch", ".", "matmul", "(", "diff", "[", ":", ",", ":", ",", ":", ",", "None", ",", ":", "]", ",", "diff", "[", ":", ",", ":", ",", ":", ",", ":", ",", "None", "]", ")", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", ".", "sqrt", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.nearest_neighbour": [[271, 304], ["tsp_baseline.calc_batch_pdist", "dataset.size", "dataset.new().zero_", "torch.gather().squeeze", "range", "torch.gather().squeeze", "isinstance", "calc_batch_pdist.scatter_", "torch.gather().squeeze", "torch.gather().squeeze.min", "tour.append", "torch.stack", "dataset.new", "dataset.new().long().new().zero_().random_", "torch.gather", "current.view().expand", "torch.gather", "dataset.new().long().new().zero_", "current.view().expand", "torch.gather", "current.view", "dataset.new().long().new().zero_", "calc_batch_pdist.mean().min", "current.view", "current.view().expand", "dataset.new().long().new", "current.view", "dataset.new().long().new", "calc_batch_pdist.mean", "current.view", "dataset.new().long", "dataset.new().long", "dataset.new", "dataset.new"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_batch_pdist", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand"], ["", "def", "nearest_neighbour", "(", "dataset", ",", "start", "=", "'first'", ")", ":", "\n", "    ", "dist", "=", "calc_batch_pdist", "(", "dataset", ")", "\n", "\n", "batch_size", ",", "graph_size", ",", "_", "=", "dataset", ".", "size", "(", ")", "\n", "\n", "total_dist", "=", "dataset", ".", "new", "(", "batch_size", ")", ".", "zero_", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "start", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "if", "start", "==", "'random'", ":", "\n", "            ", "start", "=", "dataset", ".", "new", "(", ")", ".", "long", "(", ")", ".", "new", "(", "batch_size", ")", ".", "zero_", "(", ")", ".", "random_", "(", "0", ",", "graph_size", ")", "\n", "", "elif", "start", "==", "'first'", ":", "\n", "            ", "start", "=", "dataset", ".", "new", "(", ")", ".", "long", "(", ")", ".", "new", "(", "batch_size", ")", ".", "zero_", "(", ")", "\n", "", "elif", "start", "==", "'center'", ":", "\n", "            ", "_", ",", "start", "=", "dist", ".", "mean", "(", "2", ")", ".", "min", "(", "1", ")", "# Minimum total distance to others", "\n", "", "else", ":", "\n", "            ", "assert", "False", ",", "\"Unknown start: {}\"", ".", "format", "(", "start", ")", "\n", "\n", "", "", "current", "=", "start", "\n", "dist_to_startnode", "=", "torch", ".", "gather", "(", "dist", ",", "2", ",", "current", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "batch_size", ",", "graph_size", ",", "1", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "tour", "=", "[", "current", "]", "\n", "\n", "for", "i", "in", "range", "(", "graph_size", "-", "1", ")", ":", "\n", "# Mark out current node as option", "\n", "        ", "dist", ".", "scatter_", "(", "2", ",", "current", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "batch_size", ",", "graph_size", ",", "1", ")", ",", "np", ".", "inf", ")", "\n", "nn_dist", "=", "torch", ".", "gather", "(", "dist", ",", "1", ",", "current", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "batch_size", ",", "1", ",", "graph_size", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "min_nn_dist", ",", "current", "=", "nn_dist", ".", "min", "(", "1", ")", "\n", "total_dist", "+=", "min_nn_dist", "\n", "tour", ".", "append", "(", "current", ")", "\n", "\n", "", "total_dist", "+=", "torch", ".", "gather", "(", "dist_to_startnode", ",", "1", ",", "current", ".", "view", "(", "-", "1", ",", "1", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "return", "total_dist", ",", "torch", ".", "stack", "(", "tour", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.tsp_baseline.solve_all_nn": [[306, 332], ["DataLoader", "torch.device", "tqdm.tqdm", "TSP.make_dataset", "time.time", "move_to", "tsp_baseline.nearest_neighbour", "TSP.get_costs", "results.extend", "time.time", "torch.cuda.is_available", "torch.abs", "cost.item", "numpy.trim_zeros", "zip", "pi.cpu().numpy", "pi.cpu"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.move_to", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.nearest_neighbour", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.cpu"], ["", "def", "solve_all_nn", "(", "dataset_path", ",", "eval_batch_size", "=", "1024", ",", "no_cuda", "=", "False", ",", "dataset_n", "=", "None", ",", "progress_bar_mininterval", "=", "0.1", ")", ":", "\n", "    ", "import", "torch", "\n", "from", "torch", ".", "utils", ".", "data", "import", "DataLoader", "\n", "from", "problems", "import", "TSP", "\n", "from", "utils", "import", "move_to", "\n", "\n", "dataloader", "=", "DataLoader", "(", "\n", "TSP", ".", "make_dataset", "(", "filename", "=", "dataset_path", ",", "num_samples", "=", "dataset_n", "if", "dataset_n", "is", "not", "None", "else", "1000000", ")", ",", "\n", "batch_size", "=", "eval_batch_size", "\n", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "not", "no_cuda", "else", "\"cpu\"", ")", "\n", "results", "=", "[", "]", "\n", "for", "batch", "in", "tqdm", "(", "dataloader", ",", "mininterval", "=", "progress_bar_mininterval", ")", ":", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "batch", "=", "move_to", "(", "batch", ",", "device", ")", "\n", "\n", "lengths", ",", "tours", "=", "nearest_neighbour", "(", "batch", ")", "\n", "lengths_check", ",", "_", "=", "TSP", ".", "get_costs", "(", "batch", ",", "tours", ")", "\n", "\n", "assert", "(", "torch", ".", "abs", "(", "lengths", "-", "lengths_check", ".", "data", ")", "<", "1e-5", ")", ".", "all", "(", ")", "\n", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "results", ".", "extend", "(", "\n", "[", "(", "cost", ".", "item", "(", ")", ",", "np", ".", "trim_zeros", "(", "pi", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "'b'", ")", ",", "duration", ")", "for", "cost", ",", "pi", "in", "zip", "(", "lengths", ",", "tours", ")", "]", ")", "\n", "\n", "", "return", "results", ",", "eval_batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.problem_local.LOCAL.get_costs": [[13, 23], ["dataset.gather", "pi.unsqueeze().expand_as", "pi.unsqueeze"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "get_costs", "(", "dataset", ",", "pi", ")", ":", "\n", "# Check that tours are valid, i.e. contain 0 to n -1", "\n", "\n", "\n", "# Gather dataset in order of tour", "\n", "        ", "d", "=", "dataset", ".", "gather", "(", "1", ",", "pi", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand_as", "(", "dataset", ")", ")", "\n", "\n", "# Length is distance (L2-norm of difference) from each next location from its prev and of last from first", "\n", "return", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "2", ")", ".", "sum", "(", "1", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.problem_local.LOCAL.make_dataset": [[24, 27], ["problem_local.LOCALDataset"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_dataset", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "LOCALDataset", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.problem_local.LOCAL.make_state": [[28, 31], ["problems.local.state_local.StateLOCAL.initialize"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize"], ["", "@", "staticmethod", "\n", "def", "make_state", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "StateLOCAL", ".", "initialize", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.problem_local.LOCAL.beam_search": [[32, 50], ["model.precompute_fixed", "problem_local.LOCAL.make_state", "utils.beam_search.beam_search", "model.propose_expansions"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.precompute_fixed", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions"], ["", "@", "staticmethod", "\n", "def", "beam_search", "(", "input", ",", "beam_size", ",", "expand_size", "=", "None", ",", "\n", "compress_mask", "=", "False", ",", "model", "=", "None", ",", "max_calc_batch_size", "=", "4096", ")", ":", "\n", "\n", "        ", "assert", "model", "is", "not", "None", ",", "\"Provide model\"", "\n", "\n", "fixed", "=", "model", ".", "precompute_fixed", "(", "input", ")", "\n", "\n", "def", "propose_expansions", "(", "beam", ")", ":", "\n", "            ", "return", "model", ".", "propose_expansions", "(", "\n", "beam", ",", "fixed", ",", "expand_size", ",", "normalize", "=", "True", ",", "max_calc_batch_size", "=", "max_calc_batch_size", "\n", ")", "\n", "\n", "", "state", "=", "LOCAL", ".", "make_state", "(", "\n", "input", ",", "visited_dtype", "=", "torch", ".", "int64", "if", "compress_mask", "else", "torch", ".", "uint8", "\n", ")", "\n", "\n", "return", "beam_search", "(", "state", ",", "beam_size", ",", "propose_expansions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.problem_local.LOCALDataset.__init__": [[54, 69], ["torch.utils.data.Dataset.__init__", "len", "open", "pickle.load", "torch.FloatTensor().uniform_", "os.path.splitext", "torch.FloatTensor", "range", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load"], ["    ", "def", "__init__", "(", "self", ",", "filename", "=", "None", ",", "size", "=", "50", ",", "num_samples", "=", "1000000", ",", "offset", "=", "0", ",", "distribution", "=", "None", ")", ":", "\n", "        ", "super", "(", "LOCALDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "data_set", "=", "[", "]", "\n", "if", "filename", "is", "not", "None", ":", "\n", "            ", "assert", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "==", "'.pkl'", "\n", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "self", ".", "data", "=", "[", "torch", ".", "FloatTensor", "(", "row", ")", "for", "row", "in", "(", "data", "[", "offset", ":", "offset", "+", "num_samples", "]", ")", "]", "\n", "", "", "else", ":", "\n", "# Sample points randomly in [0, 1] square", "\n", "            ", "self", ".", "data", "=", "[", "torch", ".", "FloatTensor", "(", "size", ",", "2", ")", ".", "uniform_", "(", "0", ",", "1", ")", "for", "i", "in", "range", "(", "num_samples", ")", "]", "\n", "\n", "", "self", ".", "size", "=", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.problem_local.LOCALDataset.__len__": [[70, 72], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.local.problem_local.LOCALDataset.__getitem__": [[73, 75], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "data", "[", "idx", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.get_pctsp_executable": [[19, 29], ["os.path.join", "os.path.join", "os.path.join", "os.path.isfile", "os.path.abspath", "os.path.isfile", "print", "subprocess.check_call", "print"], "function", ["None"], ["def", "get_pctsp_executable", "(", ")", ":", "\n", "    ", "path", "=", "os", ".", "path", ".", "join", "(", "\"pctsp\"", ",", "\"PCTSP\"", ",", "\"PCPTSP\"", ")", "\n", "sourcefile", "=", "os", ".", "path", ".", "join", "(", "path", ",", "\"main.cpp\"", ")", "\n", "execfile", "=", "os", ".", "path", ".", "join", "(", "path", ",", "\"main.out\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "execfile", ")", ":", "\n", "        ", "print", "(", "\"Compiling...\"", ")", "\n", "check_call", "(", "[", "\"g++\"", ",", "\"-g\"", ",", "\"-Wall\"", ",", "sourcefile", ",", "\"-std=c++11\"", ",", "\"-o\"", ",", "execfile", "]", ")", "\n", "print", "(", "\"Done!\"", ")", "\n", "", "assert", "os", ".", "path", ".", "isfile", "(", "execfile", ")", ",", "\"{} does not exist! Compilation failed?\"", ".", "format", "(", "execfile", ")", "\n", "return", "os", ".", "path", ".", "abspath", "(", "execfile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.solve_pctsp_log": [[31, 73], ["os.path.join", "os.path.join", "os.path.join", "check_output().decode.splitlines", "os.path.isfile", "pctsp_baseline.write_pctsp", "utils.data_utils.save_dataset", "utils.data_utils.load_dataset", "pctsp_baseline.calc_pctsp_cost", "np.array().astype.tolist", "print", "print", "open", "time.time", "subprocess.check_output().decode", "f.write", "numpy.array().astype", "time.time", "subprocess.check_output", "len", "numpy.array", "line[].split", "pctsp_baseline.float_to_scaled_int_str", "str", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.write_pctsp", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_cost", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.decode", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.float_to_scaled_int_str"], ["", "def", "solve_pctsp_log", "(", "executable", ",", "directory", ",", "name", ",", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "stochastic_prize", ",", "runs", "=", "10", ")", ":", "\n", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.pctsp{}.pctsp\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.pctsp{}.pkl\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "log_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.pctsp{}.log\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "\n", "try", ":", "\n", "# May have already been run", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", ":", "\n", "            ", "write_pctsp", "(", "problem_filename", ",", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "name", "=", "name", ")", "\n", "with", "open", "(", "log_filename", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "start", "=", "time", ".", "time", "(", ")", "\n", "output", "=", "check_output", "(", "\n", "# exe, filename, min_total_prize (=1), num_runs", "\n", "[", "executable", ",", "problem_filename", ",", "float_to_scaled_int_str", "(", "1.", ")", ",", "str", "(", "runs", ")", "]", ",", "\n", "stderr", "=", "f", "\n", ")", ".", "decode", "(", "'utf-8'", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "f", ".", "write", "(", "output", ")", "\n", "\n", "", "save_dataset", "(", "(", "output", ",", "duration", ")", ",", "output_filename", ")", "\n", "", "else", ":", "\n", "            ", "output", ",", "duration", "=", "load_dataset", "(", "output_filename", ")", "\n", "\n", "# Now parse output", "\n", "", "tour", "=", "None", "\n", "for", "line", "in", "output", ".", "splitlines", "(", ")", ":", "\n", "            ", "heading", "=", "\"Best Result Route: \"", "\n", "if", "line", "[", ":", "len", "(", "heading", ")", "]", "==", "heading", ":", "\n", "                ", "tour", "=", "np", ".", "array", "(", "line", "[", "len", "(", "heading", ")", ":", "]", ".", "split", "(", "\" \"", ")", ")", ".", "astype", "(", "int", ")", "\n", "break", "\n", "", "", "assert", "tour", "is", "not", "None", ",", "\"Could not find tour in output!\"", "\n", "\n", "assert", "tour", "[", "0", "]", "==", "0", ",", "\"Tour should start with depot\"", "\n", "assert", "tour", "[", "-", "1", "]", "==", "0", ",", "\"Tour should end with depot\"", "\n", "tour", "=", "tour", "[", "1", ":", "-", "1", "]", "# Strip off depot", "\n", "\n", "return", "calc_pctsp_cost", "(", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "tour", ")", ",", "tour", ".", "tolist", "(", ")", ",", "duration", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.solve_stochastic_pctsp_log": [[75, 185], ["os.path.join", "os.path.join", "os.path.join", "os.path.isfile", "time.time", "numpy.zeros", "scipy.spatial.distance_matrix", "numpy.array", "numpy.array", "os.remove", "pctsp_baseline.calc_pctsp_cost", "utils.data_utils.save_dataset", "utils.data_utils.load_dataset", "print", "print", "len", "len", "len", "pctsp_baseline.write_pctsp_dist", "max", "check_output().decode.splitlines", "pctsp_baseline.calc_pctsp_total", "time.time", "len", "min", "open", "time.time", "subprocess.check_output().decode", "durations.append", "outputs.append", "len", "final_tour.append", "pctsp_baseline.float_to_scaled_int", "sum", "numpy.array().astype", "numpy.arange", "final_tour.extend", "final_tour.extend", "numpy.ix_", "subprocess.check_output", "time.time", "len", "pctsp_baseline.float_to_scaled_int", "len", "numpy.array", "str", "str", "line[].split", "max", "len", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_cost", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.write_pctsp_dist", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_total", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.decode", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int"], ["", "", "def", "solve_stochastic_pctsp_log", "(", "\n", "executable", ",", "directory", ",", "name", ",", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "stochastic_prize", ",", "runs", "=", "10", ",", "append", "=", "'all'", ")", ":", "\n", "\n", "    ", "try", ":", "\n", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.stochpctsp{}{}.pctsp\"", ".", "format", "(", "name", ",", "append", ",", "runs", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.stochpctsp{}{}.pkl\"", ".", "format", "(", "name", ",", "append", ",", "runs", ")", ")", "\n", "log_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.stochpctsp{}{}.log\"", ".", "format", "(", "name", ",", "append", ",", "runs", ")", ")", "\n", "\n", "# May have already been run", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", ":", "\n", "\n", "            ", "total_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "outputs", "=", "[", "]", "\n", "durations", "=", "[", "]", "\n", "final_tour", "=", "[", "]", "\n", "\n", "coord", "=", "[", "depot", "]", "+", "loc", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "len", "(", "coord", ")", ",", "dtype", "=", "bool", ")", "\n", "dist", "=", "distance_matrix", "(", "coord", ",", "coord", ")", "\n", "penalty", "=", "np", ".", "array", "(", "penalty", ")", "\n", "deterministic_prize", "=", "np", ".", "array", "(", "deterministic_prize", ")", "\n", "\n", "it", "=", "0", "\n", "total_collected_prize", "=", "0.", "\n", "# As long as we have not visited all nodes we repeat", "\n", "# even though we have already satisfied the total prize collected constraint", "\n", "# since the algorithm may decide to include more nodes to avoid further penalties", "\n", "while", "len", "(", "final_tour", ")", "<", "len", "(", "stochastic_prize", ")", ":", "\n", "\n", "# Mask all nodes already visited (not the depot)", "\n", "                ", "mask", "[", "final_tour", "]", "=", "True", "\n", "\n", "# The distance from the 'start' or 'depot' is the distance from the 'current node'", "\n", "# this way we mimic as if we have a separate start and end by the assymetric distance matrix", "\n", "# Note: this violates the triangle inequality and the distance from 'depot to depot' becomes nonzero", "\n", "# but the program seems to deal with this well", "\n", "if", "len", "(", "final_tour", ")", ">", "0", ":", "# in the first iteration we are at depot and distance matrix is ok", "\n", "                    ", "dist", "[", "0", ",", ":", "]", "=", "dist", "[", "final_tour", "[", "-", "1", "]", ",", ":", "]", "\n", "\n", "", "remaining_deterministic_prize", "=", "deterministic_prize", "[", "~", "mask", "[", "1", ":", "]", "]", "\n", "write_pctsp_dist", "(", "problem_filename", ",", "\n", "dist", "[", "np", ".", "ix_", "(", "~", "mask", ",", "~", "mask", ")", "]", ",", "penalty", "[", "~", "mask", "[", "1", ":", "]", "]", ",", "remaining_deterministic_prize", ")", "\n", "# If the remaining deterministic prize is less than the prize we should still collect", "\n", "# set this lower value as constraint since otherwise problem is infeasible", "\n", "# compute total remaining deterministic prize after converting to ints", "\n", "# otherwise we may still have problems with rounding", "\n", "# Note we need to clip 1 - total_collected_prize between 0 (constraint can already be satisfied)", "\n", "# and the maximum achievable with the remaining_deterministic_prize", "\n", "min_prize_int", "=", "max", "(", "0", ",", "min", "(", "\n", "float_to_scaled_int", "(", "1.", "-", "total_collected_prize", ")", ",", "\n", "sum", "(", "[", "float_to_scaled_int", "(", "v", ")", "for", "v", "in", "remaining_deterministic_prize", "]", ")", "\n", ")", ")", "\n", "with", "open", "(", "log_filename", ",", "'a'", ")", "as", "f", ":", "\n", "                    ", "start", "=", "time", ".", "time", "(", ")", "\n", "output", "=", "check_output", "(", "\n", "# exe, filename, min_total_prize (=1), num_runs", "\n", "[", "executable", ",", "problem_filename", ",", "str", "(", "min_prize_int", ")", ",", "str", "(", "runs", ")", "]", ",", "\n", "stderr", "=", "f", "\n", ")", ".", "decode", "(", "'utf-8'", ")", "\n", "durations", ".", "append", "(", "time", ".", "time", "(", ")", "-", "start", ")", "\n", "outputs", ".", "append", "(", "output", ")", "\n", "\n", "# Now parse output", "\n", "", "tour", "=", "None", "\n", "for", "line", "in", "output", ".", "splitlines", "(", ")", ":", "\n", "                    ", "heading", "=", "\"Best Result Route: \"", "\n", "if", "line", "[", ":", "len", "(", "heading", ")", "]", "==", "heading", ":", "\n", "                        ", "tour", "=", "np", ".", "array", "(", "line", "[", "len", "(", "heading", ")", ":", "]", ".", "split", "(", "\" \"", ")", ")", ".", "astype", "(", "int", ")", "\n", "break", "\n", "", "", "assert", "tour", "is", "not", "None", ",", "\"Could not find tour in output!\"", "\n", "\n", "assert", "tour", "[", "0", "]", "==", "0", ",", "\"Tour should start with depot\"", "\n", "assert", "tour", "[", "-", "1", "]", "==", "0", ",", "\"Tour should end with depot\"", "\n", "tour", "=", "tour", "[", "1", ":", "-", "1", "]", "# Strip off depot", "\n", "\n", "# Now find to which nodes these correspond", "\n", "tour_node_ids", "=", "np", ".", "arange", "(", "len", "(", "coord", ")", ",", "dtype", "=", "int", ")", "[", "~", "mask", "]", "[", "tour", "]", "\n", "\n", "if", "len", "(", "tour_node_ids", ")", "==", "0", ":", "\n", "# The inner algorithm can decide to stop, but does not have to", "\n", "                    ", "assert", "total_collected_prize", ">", "1", "-", "1e-5", ",", "\"Collected prize should be one\"", "\n", "break", "\n", "\n", "", "if", "append", "==", "'first'", ":", "\n", "                    ", "final_tour", ".", "append", "(", "tour_node_ids", "[", "0", "]", ")", "\n", "", "elif", "append", "==", "'half'", ":", "\n", "                    ", "final_tour", ".", "extend", "(", "tour_node_ids", "[", ":", "max", "(", "len", "(", "tour_node_ids", ")", "//", "2", ",", "1", ")", "]", ")", "\n", "", "else", ":", "\n", "                    ", "assert", "append", "==", "'all'", "\n", "final_tour", ".", "extend", "(", "tour_node_ids", ")", "\n", "\n", "", "total_collected_prize", "=", "calc_pctsp_total", "(", "stochastic_prize", ",", "final_tour", ")", "\n", "it", "=", "it", "+", "1", "\n", "\n", "", "os", ".", "remove", "(", "problem_filename", ")", "\n", "final_cost", "=", "calc_pctsp_cost", "(", "depot", ",", "loc", ",", "penalty", ",", "stochastic_prize", ",", "final_tour", ")", "\n", "total_duration", "=", "time", ".", "time", "(", ")", "-", "total_start", "\n", "save_dataset", "(", "(", "final_cost", ",", "final_tour", ",", "total_duration", ",", "outputs", ",", "durations", ")", ",", "output_filename", ")", "\n", "\n", "", "else", ":", "\n", "            ", "final_cost", ",", "final_tour", ",", "total_duration", ",", "outputs", ",", "durations", "=", "load_dataset", "(", "output_filename", ")", "\n", "\n", "", "return", "final_cost", ",", "final_tour", ",", "total_duration", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.solve_salesman": [[187, 226], ["os.path.join", "os.path.join", "pctsp_baseline.calc_pctsp_cost", "os.path.isfile", "pctsp_baseline.write_pctsp", "time.time", "random.seed", "salesman.pctsp.model.pctsp.Pctsp", "salesman.pctsp.model.pctsp.Pctsp.load", "salesman.pctsp.model.solution.random", "salesman.pctsp.algo.ilocal_search.ilocal_search", "utils.data_utils.save_dataset", "utils.data_utils.load_dataset", "print", "print", "pctsp_baseline.float_to_scaled_int", "time.time", "float", "int", "pctsp_baseline.float_to_scaled_int", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_cost", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.write_pctsp", "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.random", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.ilocal_search", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int"], ["", "", "def", "solve_salesman", "(", "directory", ",", "name", ",", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "stochastic_prize", ",", "runs", "=", "10", ")", ":", "\n", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.salesman{}.pctsp\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.salesman{}.pkl\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "\n", "try", ":", "\n", "# May have already been run", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", ":", "\n", "            ", "write_pctsp", "(", "problem_filename", ",", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "name", "=", "name", ")", "\n", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "random", ".", "seed", "(", "1234", ")", "\n", "pctsp", "=", "Pctsp", "(", ")", "\n", "pctsp", ".", "load", "(", "problem_filename", ",", "float_to_scaled_int", "(", "1.", ")", ")", "\n", "s", "=", "solution", ".", "random", "(", "pctsp", ",", "start_size", "=", "int", "(", "len", "(", "pctsp", ".", "prize", ")", "*", "0.7", ")", ")", "\n", "s", "=", "ilocal_search", "(", "s", ",", "n_runs", "=", "runs", ")", "\n", "\n", "output", "=", "(", "s", ".", "route", "[", ":", "s", ".", "size", "]", ",", "s", ".", "quality", ")", "\n", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "save_dataset", "(", "(", "output", ",", "duration", ")", ",", "output_filename", ")", "\n", "", "else", ":", "\n", "            ", "output", ",", "duration", "=", "load_dataset", "(", "output_filename", ")", "\n", "\n", "# Now parse output", "\n", "", "tour", "=", "output", "[", "0", "]", "[", ":", "]", "\n", "assert", "tour", "[", "0", "]", "==", "0", ",", "\"Tour should start with depot\"", "\n", "assert", "tour", "[", "-", "1", "]", "!=", "0", ",", "\"Tour should not end with depot\"", "\n", "tour", "=", "tour", "[", "1", ":", "]", "# Strip off depot", "\n", "\n", "total_cost", "=", "calc_pctsp_cost", "(", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "tour", ")", "\n", "assert", "(", "float_to_scaled_int", "(", "total_cost", ")", "-", "output", "[", "1", "]", ")", "/", "float", "(", "output", "[", "1", "]", ")", "<", "1e-5", "\n", "return", "total_cost", ",", "tour", ",", "duration", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.solve_gurobi": [[228, 265], ["os.path.join", "pctsp_baseline.calc_pctsp_cost", "os.path.isfile", "utils.data_utils.load_dataset", "time.time", "solve_euclidian_pctsp_gurobi", "utils.data_utils.save_dataset", "abs", "print", "print", "min", "time.time", "sum"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_cost", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset"], ["", "", "def", "solve_gurobi", "(", "directory", ",", "name", ",", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "stochastic_prize", ",", "\n", "disable_cache", "=", "False", ",", "timeout", "=", "None", ",", "gap", "=", "None", ")", ":", "\n", "# Lazy import so we do not need to have gurobi installed to run this script", "\n", "    ", "from", ".", "pctsp_gurobi", "import", "solve_euclidian_pctsp", "as", "solve_euclidian_pctsp_gurobi", "\n", "\n", "try", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.gurobi{}{}.pkl\"", ".", "format", "(", "\n", "name", ",", "\"\"", "if", "timeout", "is", "None", "else", "\"t{}\"", ".", "format", "(", "timeout", ")", ",", "\"\"", "if", "gap", "is", "None", "else", "\"gap{}\"", ".", "format", "(", "gap", ")", ")", ")", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "problem_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "(", "cost", ",", "tour", ",", "duration", ")", "=", "load_dataset", "(", "problem_filename", ")", "\n", "", "else", ":", "\n", "# 0 = start, 1 = end so add depot twice", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Must collect 1 or the sum of the prices if it is less then 1.", "\n", "cost", ",", "tour", "=", "solve_euclidian_pctsp_gurobi", "(", "\n", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "min", "(", "sum", "(", "deterministic_prize", ")", ",", "1.", ")", ",", "\n", "threads", "=", "1", ",", "timeout", "=", "timeout", ",", "gap", "=", "gap", "\n", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "# Measure clock time", "\n", "save_dataset", "(", "(", "cost", ",", "tour", ",", "duration", ")", ",", "problem_filename", ")", "\n", "\n", "# First and last node are depot(s), so first node is 2 but should be 1 (as depot is 0) so subtract 1", "\n", "", "assert", "tour", "[", "0", "]", "==", "0", "\n", "tour", "=", "tour", "[", "1", ":", "]", "\n", "\n", "total_cost", "=", "calc_pctsp_cost", "(", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "tour", ")", "\n", "assert", "abs", "(", "total_cost", "-", "cost", ")", "<=", "1e-5", ",", "\"Cost is incorrect\"", "\n", "return", "total_cost", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "# For some stupid reason, sometimes OR tools cannot find a feasible solution?", "\n", "# By letting it fail we do not get total results, but we can retry by the caching mechanism", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.solve_ortools": [[267, 295], ["os.path.join", "pctsp_baseline.calc_pctsp_cost", "os.path.isfile", "utils.data_utils.load_dataset", "time.time", "solve_pctsp_ortools", "utils.data_utils.save_dataset", "abs", "print", "print", "min", "time.time", "sum"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_cost", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.solve_pctsp_ortools", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset"], ["", "", "def", "solve_ortools", "(", "directory", ",", "name", ",", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "stochastic_prize", ",", "\n", "sec_local_search", "=", "0", ",", "disable_cache", "=", "False", ")", ":", "\n", "# Lazy import so we do not require ortools by default", "\n", "    ", "from", ".", "pctsp_ortools", "import", "solve_pctsp_ortools", "\n", "\n", "try", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.ortools{}.pkl\"", ".", "format", "(", "name", ",", "sec_local_search", ")", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "problem_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "objval", ",", "tour", ",", "duration", "=", "load_dataset", "(", "problem_filename", ")", "\n", "", "else", ":", "\n", "# 0 = start, 1 = end so add depot twice", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "objval", ",", "tour", "=", "solve_pctsp_ortools", "(", "depot", ",", "loc", ",", "deterministic_prize", ",", "penalty", ",", "\n", "min", "(", "sum", "(", "deterministic_prize", ")", ",", "1.", ")", ",", "sec_local_search", "=", "sec_local_search", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "save_dataset", "(", "(", "objval", ",", "tour", ",", "duration", ")", ",", "problem_filename", ")", "\n", "", "assert", "tour", "[", "0", "]", "==", "0", ",", "\"Tour must start with depot\"", "\n", "tour", "=", "tour", "[", "1", ":", "]", "\n", "total_cost", "=", "calc_pctsp_cost", "(", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "tour", ")", "\n", "assert", "abs", "(", "total_cost", "-", "objval", ")", "<=", "1e-5", ",", "\"Cost is incorrect\"", "\n", "return", "total_cost", ",", "tour", ",", "duration", "\n", "", "except", "Exception", "as", "e", ":", "\n", "# For some stupid reason, sometimes OR tools cannot find a feasible solution?", "\n", "# By letting it fail we do not get total results, but we dcan retry by the caching mechanism", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_total": [[297, 301], ["[].sum", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["", "", "def", "calc_pctsp_total", "(", "vals", ",", "tour", ")", ":", "\n", "# Subtract 1 since vals index start with 0 while tour indexing starts with 1 as depot is 0", "\n", "    ", "assert", "(", "np", ".", "array", "(", "tour", ")", ">", "0", ")", ".", "all", "(", ")", ",", "\"Depot cannot be in tour\"", "\n", "return", "np", ".", "array", "(", "vals", ")", "[", "np", ".", "array", "(", "tour", ")", "-", "1", "]", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_length": [[303, 307], ["numpy.vstack", "numpy.linalg.norm().sum", "numpy.array", "numpy.concatenate", "numpy.linalg.norm", "numpy.array"], "function", ["None"], ["", "def", "calc_pctsp_length", "(", "depot", ",", "loc", ",", "tour", ")", ":", "\n", "    ", "loc_with_depot", "=", "np", ".", "vstack", "(", "(", "np", ".", "array", "(", "depot", ")", "[", "None", ",", ":", "]", ",", "np", ".", "array", "(", "loc", ")", ")", ")", "\n", "sorted_locs", "=", "loc_with_depot", "[", "np", ".", "concatenate", "(", "(", "[", "0", "]", ",", "tour", ",", "[", "0", "]", ")", ")", "]", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "sorted_locs", "[", "1", ":", "]", "-", "sorted_locs", "[", ":", "-", "1", "]", ",", "axis", "=", "-", "1", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_cost": [[309, 316], ["len", "len", "pctsp_baseline.calc_pctsp_total", "numpy.unique", "pctsp_baseline.calc_pctsp_total", "len", "len", "pctsp_baseline.calc_pctsp_length", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_total", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_total", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.calc_pctsp_length"], ["", "def", "calc_pctsp_cost", "(", "depot", ",", "loc", ",", "penalty", ",", "prize", ",", "tour", ")", ":", "\n", "# With some tolerance we should satisfy minimum prize", "\n", "    ", "assert", "len", "(", "np", ".", "unique", "(", "tour", ")", ")", "==", "len", "(", "tour", ")", ",", "\"Tour cannot contain duplicates\"", "\n", "assert", "calc_pctsp_total", "(", "prize", ",", "tour", ")", ">=", "1", "-", "1e-5", "or", "len", "(", "tour", ")", "==", "len", "(", "prize", ")", ",", "\"Tour should collect at least 1 as total prize or visit all nodes\"", "\n", "# Penalty is only incurred for locations not visited, so charge total penalty minus penalty of locations visited", "\n", "return", "calc_pctsp_length", "(", "depot", ",", "loc", ",", "tour", ")", "+", "np", ".", "sum", "(", "penalty", ")", "-", "calc_pctsp_total", "(", "penalty", ",", "tour", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.write_pctsp": [[318, 321], ["pctsp_baseline.write_pctsp_dist", "scipy.spatial.distance_matrix"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.write_pctsp_dist"], ["", "def", "write_pctsp", "(", "filename", ",", "depot", ",", "loc", ",", "penalty", ",", "prize", ",", "name", "=", "\"problem\"", ")", ":", "\n", "    ", "coord", "=", "[", "depot", "]", "+", "loc", "\n", "return", "write_pctsp_dist", "(", "filename", ",", "distance_matrix", "(", "coord", ",", "coord", ")", ",", "penalty", ",", "prize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.float_to_scaled_int_str": [[323, 325], ["str", "pctsp_baseline.float_to_scaled_int"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int"], ["", "def", "float_to_scaled_int_str", "(", "v", ")", ":", "# Program only accepts ints so scale everything by 10^7", "\n", "    ", "return", "str", "(", "float_to_scaled_int", "(", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.float_to_scaled_int": [[327, 329], ["int"], "function", ["None"], ["", "def", "float_to_scaled_int", "(", "v", ")", ":", "\n", "    ", "return", "int", "(", "v", "*", "10000000", "+", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.write_pctsp_dist": [[331, 345], ["open", "f.write", "pctsp_baseline.float_to_scaled_int_str", "pctsp_baseline.float_to_scaled_int_str", "list", "list", "pctsp_baseline.float_to_scaled_int_str"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.float_to_scaled_int_str", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.float_to_scaled_int_str", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_baseline.float_to_scaled_int_str"], ["", "def", "write_pctsp_dist", "(", "filename", ",", "dist", ",", "penalty", ",", "prize", ")", ":", "\n", "\n", "    ", "with", "open", "(", "filename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"\"", ",", "\n", "\" \"", ".", "join", "(", "[", "float_to_scaled_int_str", "(", "p", ")", "for", "p", "in", "[", "0", "]", "+", "list", "(", "prize", ")", "]", ")", ",", "\n", "\"\"", ",", "\n", "\"\"", ",", "\n", "\" \"", ".", "join", "(", "[", "float_to_scaled_int_str", "(", "p", ")", "for", "p", "in", "[", "0", "]", "+", "list", "(", "penalty", ")", "]", ")", ",", "\n", "\"\"", ",", "\n", "\"\"", ",", "\n", "*", "(", "\n", "\" \"", ".", "join", "(", "float_to_scaled_int_str", "(", "d", ")", "for", "d", "in", "d_row", ")", "\n", "for", "d_row", "in", "dist", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_gurobi.solve_euclidian_pctsp": [[15, 125], ["len", "Model", "Model.addVars", "m.addVars.keys", "m.addVars.keys", "Model.addVars", "Model.addConstrs", "Model.addConstr", "sum", "Model.optimize", "Model.getAttr", "tuplelist", "pctsp_gurobi.solve_euclidian_pctsp.subtour"], "function", ["None"], ["def", "solve_euclidian_pctsp", "(", "depot", ",", "loc", ",", "penalty", ",", "prize", ",", "min_prize", ",", "threads", "=", "0", ",", "timeout", "=", "None", ",", "gap", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Solves the Euclidan pctsp problem to pctsptimality using the MIP formulation \n    with lazy subtour elimination constraint generation.\n    :param points: list of (x, y) coordinate \n    :return: \n    \"\"\"", "\n", "\n", "points", "=", "[", "depot", "]", "+", "loc", "\n", "n", "=", "len", "(", "points", ")", "\n", "\n", "# Callback - use lazy constraints to eliminate sub-tours", "\n", "\n", "def", "subtourelim", "(", "model", ",", "where", ")", ":", "\n", "        ", "if", "where", "==", "GRB", ".", "Callback", ".", "MIPSOL", ":", "\n", "# make a list of edges selected in the solution", "\n", "            ", "vals", "=", "model", ".", "cbGetSolution", "(", "model", ".", "_vars", ")", "\n", "selected", "=", "tuplelist", "(", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "model", ".", "_vars", ".", "keys", "(", ")", "if", "vals", "[", "i", ",", "j", "]", ">", "0.5", ")", "\n", "# find the shortest cycle in the selected edge list", "\n", "tour", "=", "subtour", "(", "selected", ")", "\n", "if", "tour", "is", "not", "None", ":", "\n", "# add subtour elimination constraint for every pair of cities in tour", "\n", "# model.cbLazy(quicksum(model._vars[i, j]", "\n", "#                       for i, j in itertools.combinations(tour, 2))", "\n", "#              <= len(tour) - 1)", "\n", "\n", "                ", "model", ".", "cbLazy", "(", "quicksum", "(", "model", ".", "_vars", "[", "i", ",", "j", "]", "\n", "for", "i", ",", "j", "in", "itertools", ".", "combinations", "(", "tour", ",", "2", ")", ")", "\n", "<=", "quicksum", "(", "model", ".", "_dvars", "[", "i", "]", "for", "i", "in", "tour", ")", "*", "(", "len", "(", "tour", ")", "-", "1", ")", "/", "float", "(", "len", "(", "tour", ")", ")", ")", "\n", "\n", "# Given a tuplelist of edges, find the shortest subtour", "\n", "\n", "", "", "", "def", "subtour", "(", "edges", ",", "exclude_depot", "=", "True", ")", ":", "\n", "        ", "unvisited", "=", "list", "(", "range", "(", "n", ")", ")", "\n", "#cycle = range(n + 1)  # initial length has 1 more city", "\n", "cycle", "=", "None", "\n", "while", "unvisited", ":", "# true if list is non-empty", "\n", "            ", "thiscycle", "=", "[", "]", "\n", "neighbors", "=", "unvisited", "\n", "while", "neighbors", ":", "\n", "                ", "current", "=", "neighbors", "[", "0", "]", "\n", "thiscycle", ".", "append", "(", "current", ")", "\n", "unvisited", ".", "remove", "(", "current", ")", "\n", "neighbors", "=", "[", "j", "for", "i", ",", "j", "in", "edges", ".", "select", "(", "current", ",", "'*'", ")", "if", "j", "in", "unvisited", "]", "\n", "# If we do not yet have a cycle or this is the shorter cycle, keep this cycle", "\n", "# Unless it contains the depot while we do not want the depot", "\n", "", "if", "(", "\n", "(", "cycle", "is", "None", "or", "len", "(", "cycle", ")", ">", "len", "(", "thiscycle", ")", ")", "\n", "and", "len", "(", "thiscycle", ")", ">", "1", "and", "not", "(", "0", "in", "thiscycle", "and", "exclude_depot", ")", "\n", ")", ":", "\n", "                ", "cycle", "=", "thiscycle", "\n", "", "", "return", "cycle", "\n", "\n", "# Dictionary of Euclidean distance between each pair of points", "\n", "\n", "", "dist", "=", "{", "(", "i", ",", "j", ")", ":", "\n", "math", ".", "sqrt", "(", "sum", "(", "(", "points", "[", "i", "]", "[", "k", "]", "-", "points", "[", "j", "]", "[", "k", "]", ")", "**", "2", "for", "k", "in", "range", "(", "2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", "for", "j", "in", "range", "(", "i", ")", "}", "\n", "\n", "m", "=", "Model", "(", ")", "\n", "m", ".", "Params", ".", "outputFlag", "=", "False", "\n", "\n", "# Create variables", "\n", "vars", "=", "m", ".", "addVars", "(", "dist", ".", "keys", "(", ")", ",", "obj", "=", "dist", ",", "vtype", "=", "GRB", ".", "BINARY", ",", "name", "=", "'e'", ")", "\n", "for", "i", ",", "j", "in", "vars", ".", "keys", "(", ")", ":", "\n", "        ", "vars", "[", "j", ",", "i", "]", "=", "vars", "[", "i", ",", "j", "]", "# edge in pctspposite direction", "\n", "\n", "# Depot vars can be 2", "\n", "", "for", "i", ",", "j", "in", "vars", ".", "keys", "(", ")", ":", "\n", "        ", "if", "i", "==", "0", "or", "j", "==", "0", ":", "\n", "            ", "vars", "[", "i", ",", "j", "]", ".", "vtype", "=", "GRB", ".", "INTEGER", "\n", "vars", "[", "i", ",", "j", "]", ".", "ub", "=", "2", "\n", "\n", "", "", "penalty_dict", "=", "{", "\n", "i", "+", "1", ":", "-", "p", "# We get penalties for the nodes not visited so we 'save the penalties' for the nodes visited", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "penalty", ")", "\n", "}", "\n", "delta", "=", "m", ".", "addVars", "(", "range", "(", "1", ",", "n", ")", ",", "obj", "=", "penalty_dict", ",", "vtype", "=", "GRB", ".", "BINARY", ",", "name", "=", "'delta'", ")", "\n", "\n", "# Add degree-2 constraint (2 * delta for nodes which are not the depot)", "\n", "m", ".", "addConstrs", "(", "vars", ".", "sum", "(", "i", ",", "'*'", ")", "==", "(", "2", "if", "i", "==", "0", "else", "2", "*", "delta", "[", "i", "]", ")", "for", "i", "in", "range", "(", "n", ")", ")", "\n", "\n", "\n", "# Minimum prize constraint", "\n", "assert", "min_prize", "<=", "sum", "(", "prize", ")", "\n", "# Subtract 1 from i since prizes are 0 indexed while delta vars start with 1 (0 is depot)", "\n", "m", ".", "addConstr", "(", "quicksum", "(", "var", "*", "prize", "[", "i", "-", "1", "]", "for", "i", ",", "var", "in", "delta", ".", "items", "(", ")", ")", ">=", "min_prize", ")", "\n", "\n", "# optimize model", "\n", "\n", "m", ".", "_vars", "=", "vars", "\n", "m", ".", "_dvars", "=", "delta", "\n", "m", ".", "Params", ".", "lazyConstraints", "=", "1", "\n", "m", ".", "Params", ".", "threads", "=", "threads", "\n", "if", "timeout", ":", "\n", "        ", "m", ".", "Params", ".", "timeLimit", "=", "timeout", "\n", "", "if", "gap", ":", "\n", "        ", "m", ".", "Params", ".", "mipGap", "=", "gap", "*", "0.01", "# Percentage", "\n", "# For the correct objective, we need to add the sum of the penalties, which are subtracted when nodes are visited", "\n", "# this is important for the relative gap termination criterion", "\n", "", "m", ".", "objcon", "=", "sum", "(", "penalty", ")", "\n", "m", ".", "optimize", "(", "subtourelim", ")", "\n", "\n", "vals", "=", "m", ".", "getAttr", "(", "'x'", ",", "vars", ")", "\n", "selected", "=", "tuplelist", "(", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "vals", ".", "keys", "(", ")", "if", "vals", "[", "i", ",", "j", "]", ">", "0.5", ")", "\n", "\n", "tour", "=", "subtour", "(", "selected", ",", "exclude_depot", "=", "False", ")", "\n", "assert", "tour", "[", "0", "]", "==", "0", ",", "\"Tour should start with depot\"", "\n", "\n", "return", "m", ".", "objVal", ",", "tour", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.visited": [[27, 33], ["utils.boolmask.mask_long2bool", "state_pctsp.StatePCTSP.coords.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long2bool", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["@", "property", "\n", "def", "visited", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "            ", "return", "self", ".", "visited_", "\n", "", "else", ":", "\n", "            ", "return", "mask_long2bool", "(", "self", ".", "visited_", ",", "n", "=", "self", ".", "coords", ".", "size", "(", "-", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.dist": [[34, 37], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "dist", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "coords", "[", ":", ",", ":", ",", "None", ",", ":", "]", "-", "self", ".", "coords", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.__getitem__": [[38, 48], ["state_pctsp.StatePCTSP._replace", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "isinstance"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "# If tensor, idx all tensors by this tensor:", "\n", "return", "self", ".", "_replace", "(", "\n", "ids", "=", "self", ".", "ids", "[", "key", "]", ",", "\n", "prev_a", "=", "self", ".", "prev_a", "[", "key", "]", ",", "\n", "visited_", "=", "self", ".", "visited_", "[", "key", "]", ",", "\n", "lengths", "=", "self", ".", "lengths", "[", "key", "]", ",", "\n", "cur_total_prize", "=", "self", ".", "cur_total_prize", "[", "key", "]", ",", "\n", "cur_total_penalty", "=", "self", ".", "cur_total_penalty", "[", "key", "]", ",", "\n", "cur_coord", "=", "self", ".", "cur_coord", "[", "key", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.initialize": [[54, 92], ["loc.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.pad", "torch.pad", "state_pctsp.StatePCTSP", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "penalty.sum"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "@", "staticmethod", "\n", "def", "initialize", "(", "input", ",", "visited_dtype", "=", "torch", ".", "uint8", ",", "stochastic", "=", "False", ")", ":", "\n", "        ", "depot", "=", "input", "[", "'depot'", "]", "\n", "loc", "=", "input", "[", "'loc'", "]", "\n", "# For both deterministic and stochastic variant, model sees only deterministic (expected) prize", "\n", "expected_prize", "=", "input", "[", "'deterministic_prize'", "]", "\n", "# This is the prize that is actually obtained at each node", "\n", "real_prize", "=", "input", "[", "'stochastic_prize'", "if", "stochastic", "else", "'deterministic_prize'", "]", "\n", "penalty", "=", "input", "[", "'penalty'", "]", "\n", "\n", "batch_size", ",", "n_loc", ",", "_", "=", "loc", ".", "size", "(", ")", "\n", "coords", "=", "torch", ".", "cat", "(", "(", "depot", "[", ":", ",", "None", ",", ":", "]", ",", "loc", ")", ",", "-", "2", ")", "\n", "# For prize, prepend 0 (corresponding to depot) so we can gather efficiently", "\n", "\n", "real_prize_with_depot", "=", "torch", ".", "cat", "(", "(", "torch", ".", "zeros_like", "(", "real_prize", "[", ":", ",", ":", "1", "]", ")", ",", "real_prize", ")", ",", "-", "1", ")", "\n", "penalty_with_depot", "=", "F", ".", "pad", "(", "penalty", ",", "(", "1", ",", "0", ")", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "\n", "return", "StatePCTSP", "(", "\n", "coords", "=", "coords", ",", "\n", "expected_prize", "=", "expected_prize", ",", "\n", "real_prize", "=", "real_prize_with_depot", ",", "\n", "penalty", "=", "penalty_with_depot", ",", "\n", "ids", "=", "torch", ".", "arange", "(", "batch_size", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "[", ":", ",", "None", "]", ",", "# Add steps dimension", "\n", "prev_a", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "visited_", "=", "(", "# Visited as mask is easier to understand, as long more memory efficient", "\n", "# Keep visited_ with depot so we can scatter efficiently (if there is an action for depot)", "\n", "torch", ".", "zeros", "(", "\n", "batch_size", ",", "1", ",", "n_loc", "+", "1", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "loc", ".", "device", "\n", ")", "\n", "if", "visited_dtype", "==", "torch", ".", "uint8", "\n", "else", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "(", "n_loc", "+", "63", ")", "//", "64", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Ceil", "\n", ")", ",", "\n", "lengths", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "cur_total_prize", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "cur_total_penalty", "=", "penalty", ".", "sum", "(", "-", "1", ")", "[", ":", ",", "None", "]", ",", "# Sum penalties (all when nothing is visited), add step dim", "\n", "cur_coord", "=", "input", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "# Add step dimension", "\n", "i", "=", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Vector with length num_steps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.get_remaining_prize_to_collect": [[94, 97], ["torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["None"], ["", "def", "get_remaining_prize_to_collect", "(", "self", ")", ":", "\n", "# returns the remaining prize to collect, or 0 if already collected the minimum (1.0)", "\n", "        ", "return", "torch", ".", "clamp", "(", "1", "-", "self", ".", "cur_total_prize", ",", "min", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.get_final_cost": [[98, 104], ["state_pctsp.StatePCTSP.all_finished"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished"], ["", "def", "get_final_cost", "(", "self", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "all_finished", "(", ")", "\n", "# assert self.visited_.", "\n", "# We are at the depot so no need to add remaining distance", "\n", "return", "self", ".", "lengths", "+", "self", ".", "cur_total_penalty", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.update": [[105, 132], ["state_pctsp.StatePCTSP._replace", "state_pctsp.StatePCTSP.i.size", "state_pctsp.StatePCTSP.visited_.scatter", "utils.boolmask.mask_long_scatter"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long_scatter"], ["", "def", "update", "(", "self", ",", "selected", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "i", ".", "size", "(", "0", ")", "==", "1", ",", "\"Can only update if state represents single step\"", "\n", "\n", "# Update the state", "\n", "selected", "=", "selected", "[", ":", ",", "None", "]", "# Add dimension for step", "\n", "prev_a", "=", "selected", "\n", "\n", "# Add the length", "\n", "cur_coord", "=", "self", ".", "coords", "[", "self", ".", "ids", ",", "selected", "]", "\n", "lengths", "=", "self", ".", "lengths", "+", "(", "cur_coord", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# (batch_dim, 1)", "\n", "# Add current total prize", "\n", "cur_total_prize", "=", "self", ".", "cur_total_prize", "+", "self", ".", "real_prize", "[", "self", ".", "ids", ",", "selected", "]", "\n", "cur_total_penalty", "=", "self", ".", "cur_total_penalty", "+", "self", ".", "penalty", "[", "self", ".", "ids", ",", "selected", "]", "\n", "\n", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "# Note: here we do not subtract one as we have to scatter so the first column allows scattering depot", "\n", "# Add one dimension since we write a single value", "\n", "            ", "visited_", "=", "self", ".", "visited_", ".", "scatter", "(", "-", "1", ",", "prev_a", "[", ":", ",", ":", ",", "None", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "# This works, by check_unset=False it is allowed to set the depot visited a second a time", "\n", "            ", "visited_", "=", "mask_long_scatter", "(", "self", ".", "visited_", ",", "prev_a", ",", "check_unset", "=", "False", ")", "\n", "\n", "", "return", "self", ".", "_replace", "(", "\n", "prev_a", "=", "prev_a", ",", "visited_", "=", "visited_", ",", "\n", "lengths", "=", "lengths", ",", "cur_total_prize", "=", "cur_total_prize", ",", "cur_total_penalty", "=", "cur_total_penalty", ",", "cur_coord", "=", "cur_coord", ",", "\n", "i", "=", "self", ".", "i", "+", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.all_finished": [[134, 138], ["state_pctsp.StatePCTSP.i.item"], "methods", ["None"], ["", "def", "all_finished", "(", "self", ")", ":", "\n", "# All must be returned to depot (and at least 1 step since at start also prev_a == 0)", "\n", "# This is more efficient than checking the mask", "\n", "        ", "return", "self", ".", "i", ".", "item", "(", ")", ">", "0", "and", "(", "self", ".", "prev_a", "==", "0", ")", ".", "all", "(", ")", "\n", "# return self.visited[:, :, 0].all()  # If we have visited the depot we're done", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.get_current_node": [[140, 146], ["None"], "methods", ["None"], ["", "def", "get_current_node", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the current node where 0 is depot, 1...n are nodes\n        :return: (batch_size, num_steps) tensor with current nodes\n        \"\"\"", "\n", "return", "self", ".", "prev_a", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.get_mask": [[147, 165], ["visited_[].int().sum", "visited_[].size", "visited_[].int"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "get_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Gets a (batch_size, n_loc + 1) mask with the feasible actions (0 = depot), depends on already visited and\n        remaining capacity. 0 = feasible, 1 = infeasible\n        Forbids to visit depot twice in a row, unless all nodes have been visited\n        :return:\n        \"\"\"", "\n", "\n", "# Note: this always allows going to the depot, but that should always be suboptimal so be ok", "\n", "# Cannot visit if already visited or if the depot has already been visited then we cannot visit anymore", "\n", "visited_", "=", "self", ".", "visited", "\n", "mask", "=", "(", "\n", "visited_", "|", "visited_", "[", ":", ",", ":", ",", "0", ":", "1", "]", "\n", ")", "\n", "# Cannot visit depot if not yet collected 1 total prize and there are unvisited nodes", "\n", "mask", "[", ":", ",", ":", ",", "0", "]", "=", "(", "self", ".", "cur_total_prize", "<", "1.", ")", "&", "(", "visited_", "[", ":", ",", ":", ",", "1", ":", "]", ".", "int", "(", ")", ".", "sum", "(", "-", "1", ")", "<", "visited_", "[", ":", ",", ":", ",", "1", ":", "]", ".", "size", "(", "-", "1", ")", ")", "\n", "\n", "return", "mask", ">", "0", "# Hacky way to return bool or uint8 depending on pytorch version", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.construct_solutions": [[166, 168], ["None"], "methods", ["None"], ["", "def", "construct_solutions", "(", "self", ",", "actions", ")", ":", "\n", "        ", "return", "actions", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSP._get_costs": [[13, 61], ["torch.cat", "torch.cat.gather", "torch.cat", "torch.cat.gather", "torch.cat", "torch.cat.gather", "pi.size", "pi.data.sort", "pi[].expand", "torch.zeros", "torch.zeros_like", "torch.zeros_like", "torch.cat.size", "torch.cat.gather.sum", "pi.size", "pi.size", "dataset[].sum", "torch.cat.gather.sum", "dataset[].size", "sorted_pi.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["@", "staticmethod", "\n", "def", "_get_costs", "(", "dataset", ",", "pi", ",", "stochastic", "=", "False", ")", ":", "\n", "        ", "if", "pi", ".", "size", "(", "-", "1", ")", "==", "1", ":", "# In case all tours directly return to depot, prevent further problems", "\n", "            ", "assert", "(", "pi", "==", "0", ")", ".", "all", "(", ")", ",", "\"If all length 1 tours, they should be zero\"", "\n", "# Return", "\n", "return", "torch", ".", "zeros", "(", "pi", ".", "size", "(", "0", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "pi", ".", "device", ")", ",", "None", "\n", "\n", "# Check that tours are valid, i.e. contain 0 to n -1", "\n", "", "sorted_pi", "=", "pi", ".", "data", ".", "sort", "(", "1", ")", "[", "0", "]", "\n", "# Make sure each node visited once at most (except for depot)", "\n", "assert", "(", "(", "sorted_pi", "[", ":", ",", "1", ":", "]", "==", "0", ")", "|", "(", "sorted_pi", "[", ":", ",", "1", ":", "]", ">", "sorted_pi", "[", ":", ",", ":", "-", "1", "]", ")", ")", ".", "all", "(", ")", ",", "\"Duplicates\"", "\n", "\n", "prize", "=", "dataset", "[", "'stochastic_prize'", "]", "if", "stochastic", "else", "dataset", "[", "'deterministic_prize'", "]", "\n", "prize_with_depot", "=", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "zeros_like", "(", "prize", "[", ":", ",", ":", "1", "]", ")", ",", "\n", "prize", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "p", "=", "prize_with_depot", ".", "gather", "(", "1", ",", "pi", ")", "\n", "\n", "# Either prize constraint should be satisfied or all prizes should be visited", "\n", "assert", "(", "\n", "(", "p", ".", "sum", "(", "-", "1", ")", ">=", "1", "-", "1e-5", ")", "|", "\n", "(", "sorted_pi", ".", "size", "(", "-", "1", ")", "-", "(", "sorted_pi", "==", "0", ")", ".", "int", "(", ")", ".", "sum", "(", "-", "1", ")", "==", "dataset", "[", "'loc'", "]", ".", "size", "(", "-", "2", ")", ")", "\n", ")", ".", "all", "(", ")", ",", "\"Total prize does not satisfy min total prize\"", "\n", "penalty_with_depot", "=", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "zeros_like", "(", "dataset", "[", "'penalty'", "]", "[", ":", ",", ":", "1", "]", ")", ",", "\n", "dataset", "[", "'penalty'", "]", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "pen", "=", "penalty_with_depot", ".", "gather", "(", "1", ",", "pi", ")", "\n", "\n", "# Gather dataset in order of tour", "\n", "loc_with_depot", "=", "torch", ".", "cat", "(", "(", "dataset", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "dataset", "[", "'loc'", "]", ")", ",", "1", ")", "\n", "d", "=", "loc_with_depot", ".", "gather", "(", "1", ",", "pi", "[", "...", ",", "None", "]", ".", "expand", "(", "*", "pi", ".", "size", "(", ")", ",", "loc_with_depot", ".", "size", "(", "-", "1", ")", ")", ")", "\n", "\n", "length", "=", "(", "\n", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", ".", "sum", "(", "1", ")", "# Prevent error if len 1 seq", "\n", "+", "(", "d", "[", ":", ",", "0", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# Depot to first", "\n", "+", "(", "d", "[", ":", ",", "-", "1", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# Last to depot, will be 0 if depot is last", "\n", ")", "\n", "# We want to maximize total prize but code minimizes so return negative", "\n", "# Incurred penalty cost is total penalty cost - saved penalty costs of nodes visited", "\n", "return", "length", "+", "dataset", "[", "'penalty'", "]", ".", "sum", "(", "-", "1", ")", "-", "pen", ".", "sum", "(", "-", "1", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSP.get_costs_local": [[63, 110], ["torch.cat", "torch.cat.gather", "torch.cat", "torch.cat.gather", "torch.cat", "torch.cat.gather", "pi.size", "pi.data.sort", "pi[].expand", "torch.zeros", "torch.zeros_like", "torch.zeros_like", "torch.cat.size", "torch.cat.gather.sum", "pi.size", "pi.size", "dataset[].sum", "torch.cat.gather.sum", "dataset[].size", "sorted_pi.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "get_costs_local", "(", "dataset", ",", "pi", ",", "stochastic", "=", "False", ")", ":", "\n", "        ", "if", "pi", ".", "size", "(", "-", "1", ")", "==", "1", ":", "# In case all tours directly return to depot, prevent further problems", "\n", "            ", "assert", "(", "pi", "==", "0", ")", ".", "all", "(", ")", ",", "\"If all length 1 tours, they should be zero\"", "\n", "# Return", "\n", "return", "torch", ".", "zeros", "(", "pi", ".", "size", "(", "0", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "pi", ".", "device", ")", ",", "None", "\n", "\n", "# Check that tours are valid, i.e. contain 0 to n -1", "\n", "", "sorted_pi", "=", "pi", ".", "data", ".", "sort", "(", "1", ")", "[", "0", "]", "\n", "# Make sure each node visited once at most (except for depot)", "\n", "assert", "(", "(", "sorted_pi", "[", ":", ",", "1", ":", "]", "==", "0", ")", "|", "(", "sorted_pi", "[", ":", ",", "1", ":", "]", ">", "sorted_pi", "[", ":", ",", ":", "-", "1", "]", ")", ")", ".", "all", "(", ")", ",", "\"Duplicates\"", "\n", "\n", "prize", "=", "dataset", "[", "'stochastic_prize'", "]", "if", "stochastic", "else", "dataset", "[", "'deterministic_prize'", "]", "\n", "prize_with_depot", "=", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "zeros_like", "(", "prize", "[", ":", ",", ":", "1", "]", ")", ",", "\n", "prize", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "p", "=", "prize_with_depot", ".", "gather", "(", "1", ",", "pi", ")", "\n", "\n", "# Either prize constraint should be satisfied or all prizes should be visited", "\n", "assert", "(", "\n", "(", "p", ".", "sum", "(", "-", "1", ")", ">=", "1", "-", "1e-5", ")", "|", "\n", "(", "sorted_pi", ".", "size", "(", "-", "1", ")", "-", "(", "sorted_pi", "==", "0", ")", ".", "int", "(", ")", ".", "sum", "(", "-", "1", ")", "==", "dataset", "[", "'loc'", "]", ".", "size", "(", "-", "2", ")", ")", "\n", ")", ".", "all", "(", ")", ",", "\"Total prize does not satisfy min total prize\"", "\n", "penalty_with_depot", "=", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "zeros_like", "(", "dataset", "[", "'penalty'", "]", "[", ":", ",", ":", "1", "]", ")", ",", "\n", "dataset", "[", "'penalty'", "]", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "pen", "=", "penalty_with_depot", ".", "gather", "(", "1", ",", "pi", ")", "\n", "\n", "# Gather dataset in order of tour", "\n", "loc_with_depot", "=", "torch", ".", "cat", "(", "(", "dataset", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "dataset", "[", "'loc'", "]", ")", ",", "1", ")", "\n", "d", "=", "loc_with_depot", ".", "gather", "(", "1", ",", "pi", "[", "...", ",", "None", "]", ".", "expand", "(", "*", "pi", ".", "size", "(", ")", ",", "loc_with_depot", ".", "size", "(", "-", "1", ")", ")", ")", "\n", "\n", "length", "=", "(", "\n", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", ".", "sum", "(", "1", ")", "# Prevent error if len 1 seq", "\n", "+", "(", "d", "[", ":", ",", "0", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# Depot to first", "\n", "+", "(", "d", "[", ":", ",", "-", "1", "]", "-", "dataset", "[", "'despot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# Last to depot, will be 0 if depot is last", "\n", ")", "\n", "# We want to maximize total prize but code minimizes so return negative", "\n", "# Incurred penalty cost is total penalty cost - saved penalty costs of nodes visited", "\n", "return", "length", "+", "dataset", "[", "'penalty'", "]", ".", "sum", "(", "-", "1", ")", "-", "pen", ".", "sum", "(", "-", "1", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSP.make_dataset": [[111, 114], ["problem_pctsp.PCTSPDataset"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_dataset", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "PCTSPDataset", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSP.beam_search": [[115, 134], ["model.precompute_fixed", "problem_pctsp.PCTSPDet.make_state", "utils.beam_search.beam_search", "model.propose_expansions"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.precompute_fixed", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions"], ["", "@", "staticmethod", "\n", "def", "beam_search", "(", "input", ",", "beam_size", ",", "expand_size", "=", "None", ",", "\n", "compress_mask", "=", "False", ",", "model", "=", "None", ",", "max_calc_batch_size", "=", "4096", ")", ":", "\n", "\n", "        ", "assert", "model", "is", "not", "None", ",", "\"Provide model\"", "\n", "\n", "fixed", "=", "model", ".", "precompute_fixed", "(", "input", ")", "\n", "\n", "def", "propose_expansions", "(", "beam", ")", ":", "\n", "            ", "return", "model", ".", "propose_expansions", "(", "\n", "beam", ",", "fixed", ",", "expand_size", ",", "normalize", "=", "True", ",", "max_calc_batch_size", "=", "max_calc_batch_size", "\n", ")", "\n", "\n", "# With beam search we always consider the deterministic case", "\n", "", "state", "=", "PCTSPDet", ".", "make_state", "(", "\n", "input", ",", "visited_dtype", "=", "torch", ".", "int64", "if", "compress_mask", "else", "torch", ".", "uint8", "\n", ")", "\n", "\n", "return", "beam_search", "(", "state", ",", "beam_size", ",", "propose_expansions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSPDet.get_costs": [[138, 141], ["problem_pctsp.PCTSP._get_costs"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSP._get_costs"], ["    ", "@", "staticmethod", "\n", "def", "get_costs", "(", "dataset", ",", "pi", ")", ":", "\n", "        ", "return", "PCTSP", ".", "_get_costs", "(", "dataset", ",", "pi", ",", "stochastic", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSPDet.make_state": [[142, 145], ["problems.pctsp.state_pctsp.StatePCTSP.initialize"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize"], ["", "@", "staticmethod", "\n", "def", "make_state", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "StatePCTSP", ".", "initialize", "(", "*", "args", ",", "**", "kwargs", ",", "stochastic", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSPStoch.get_costs": [[151, 154], ["problem_pctsp.PCTSP._get_costs"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSP._get_costs"], ["    ", "@", "staticmethod", "\n", "def", "get_costs", "(", "dataset", ",", "pi", ")", ":", "\n", "        ", "return", "PCTSP", ".", "_get_costs", "(", "dataset", ",", "pi", ",", "stochastic", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSPStoch.make_state": [[155, 158], ["problems.pctsp.state_pctsp.StatePCTSP.initialize"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize"], ["", "@", "staticmethod", "\n", "def", "make_state", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "StatePCTSP", ".", "initialize", "(", "*", "args", ",", "**", "kwargs", ",", "stochastic", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSPDataset.__init__": [[204, 230], ["torch.utils.data.Dataset.__init__", "len", "open", "pickle.load", "problem_pctsp.generate_instance", "os.path.splitext", "range", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.generate_instance"], ["    ", "def", "__init__", "(", "self", ",", "filename", "=", "None", ",", "size", "=", "50", ",", "num_samples", "=", "1000000", ",", "offset", "=", "0", ",", "distribution", "=", "None", ")", ":", "\n", "        ", "super", "(", "PCTSPDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "data_set", "=", "[", "]", "\n", "if", "filename", "is", "not", "None", ":", "\n", "            ", "assert", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "==", "'.pkl'", "\n", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "self", ".", "data", "=", "[", "\n", "{", "\n", "'depot'", ":", "torch", ".", "FloatTensor", "(", "depot", ")", ",", "\n", "'loc'", ":", "torch", ".", "FloatTensor", "(", "loc", ")", ",", "\n", "'penalty'", ":", "torch", ".", "FloatTensor", "(", "penalty", ")", ",", "\n", "'deterministic_prize'", ":", "torch", ".", "FloatTensor", "(", "deterministic_prize", ")", ",", "\n", "'stochastic_prize'", ":", "torch", ".", "tensor", "(", "stochastic_prize", ")", "\n", "}", "\n", "for", "depot", ",", "loc", ",", "penalty", ",", "deterministic_prize", ",", "stochastic_prize", "in", "(", "data", "[", "offset", ":", "offset", "+", "num_samples", "]", ")", "\n", "]", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "data", "=", "[", "\n", "generate_instance", "(", "size", ")", "\n", "for", "i", "in", "range", "(", "num_samples", ")", "\n", "]", "\n", "\n", "", "self", ".", "size", "=", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSPDataset.__len__": [[231, 233], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.PCTSPDataset.__getitem__": [[234, 236], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "data", "[", "idx", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.problem_pctsp.generate_instance": [[160, 199], ["torch.rand", "torch.rand", "torch.rand", "float", "torch.rand", "float", "torch.rand", "torch.rand"], "function", ["None"], ["", "", "def", "generate_instance", "(", "size", ",", "penalty_factor", "=", "3", ")", ":", "\n", "    ", "first", "=", "torch", ".", "rand", "(", "2", ")", "\n", "depot", "=", "torch", ".", "rand", "(", "2", ")", "\n", "loc", "=", "torch", ".", "rand", "(", "size", ",", "2", ")", "\n", "\n", "# For the penalty to make sense it should be not too large (in which case all nodes will be visited) nor too small", "\n", "# so we want the objective term to be approximately equal to the length of the tour, which we estimate with half", "\n", "# of the nodes by half of the tour length (which is very rough but similar to op)", "\n", "# This means that the sum of penalties for all nodes will be approximately equal to the tour length (on average)", "\n", "# The expected total (uniform) penalty of half of the nodes (since approx half will be visited by the constraint)", "\n", "# is (n / 2) / 2 = n / 4 so divide by this means multiply by 4 / n,", "\n", "# However instead of 4 we use penalty_factor (3 works well) so we can make them larger or smaller", "\n", "MAX_LENGTHS", "=", "{", "\n", "10", ":", "3.", ",", "\n", "20", ":", "2.", ",", "\n", "50", ":", "3.", ",", "\n", "100", ":", "4.", "\n", "}", "\n", "penalty_max", "=", "MAX_LENGTHS", "[", "size", "]", "*", "(", "penalty_factor", ")", "/", "float", "(", "size", ")", "\n", "penalty", "=", "torch", ".", "rand", "(", "size", ")", "*", "penalty_max", "\n", "\n", "# Take uniform prizes", "\n", "# Now expectation is 0.5 so expected total prize is n / 2, we want to force to visit approximately half of the nodes", "\n", "# so the constraint will be that total prize >= (n / 2) / 2 = n / 4", "\n", "# equivalently, we divide all prizes by n / 4 and the total prize should be >= 1", "\n", "deterministic_prize", "=", "torch", ".", "rand", "(", "size", ")", "*", "4", "/", "float", "(", "size", ")", "\n", "\n", "# In the deterministic setting, the stochastic_prize is not used and the deterministic prize is known", "\n", "# In the stochastic setting, the deterministic prize is the expected prize and is known up front but the", "\n", "# stochastic prize is only revealed once the node is visited", "\n", "# Stochastic prize is between (0, 2 * expected_prize) such that E(stochastic prize) = E(deterministic_prize)", "\n", "stochastic_prize", "=", "torch", ".", "rand", "(", "size", ")", "*", "deterministic_prize", "*", "2", "\n", "\n", "return", "{", "\n", "'depot'", ":", "depot", ",", "\n", "'loc'", ":", "loc", ",", "\n", "'penalty'", ":", "penalty", ",", "\n", "'deterministic_prize'", ":", "deterministic_prize", ",", "\n", "'stochastic_prize'", ":", "stochastic_prize", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.__init__": [[47, 60], ["min", "pctsp_ortools.float_to_scaled_int", "pctsp_ortools.float_to_scaled_int", "sum", "pctsp_ortools.float_to_scaled_int", "sum", "pctsp_ortools.float_to_scaled_int", "pctsp_ortools.float_to_scaled_int"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int"], ["def", "__init__", "(", "self", ",", "depot", ",", "loc", ",", "prize", ",", "penalty", ",", "min_prize", ")", ":", "\n", "    ", "\"\"\"Initializes the data for the problem\"\"\"", "\n", "# Locations in block unit", "\n", "self", ".", "_locations", "=", "[", "(", "float_to_scaled_int", "(", "l", "[", "0", "]", ")", ",", "float_to_scaled_int", "(", "l", "[", "1", "]", ")", ")", "for", "l", "in", "[", "depot", "]", "+", "loc", "]", "\n", "\n", "self", ".", "_prizes", "=", "[", "float_to_scaled_int", "(", "v", ")", "for", "v", "in", "prize", "]", "\n", "\n", "self", ".", "_penalties", "=", "[", "float_to_scaled_int", "(", "v", ")", "for", "v", "in", "penalty", "]", "\n", "\n", "# Check that min_prize is feasible", "\n", "assert", "sum", "(", "prize", ")", ">=", "min_prize", "\n", "# After scaling and rounding, however, it can possible not be feasible so relax constraint", "\n", "self", ".", "_min_prize", "=", "min", "(", "float_to_scaled_int", "(", "min_prize", ")", ",", "sum", "(", "self", ".", "prizes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.vehicle": [[61, 65], ["Vehicle"], "methods", ["None"], ["", "@", "property", "\n", "def", "vehicle", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets a vehicle\"\"\"", "\n", "return", "Vehicle", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.num_vehicles": [[66, 70], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_vehicles", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets number of vehicles\"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.locations": [[71, 75], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "locations", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets locations\"\"\"", "\n", "return", "self", ".", "_locations", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.num_locations": [[76, 80], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_locations", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets number of locations\"\"\"", "\n", "return", "len", "(", "self", ".", "locations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.depot": [[81, 85], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "depot", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets depot location index\"\"\"", "\n", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.prizes": [[86, 90], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "prizes", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets prizes at each location\"\"\"", "\n", "return", "self", ".", "_prizes", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.penalties": [[91, 95], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "penalties", "(", "self", ")", ":", "\n", "      ", "\"\"\"Gets penalties at each location\"\"\"", "\n", "return", "self", ".", "_penalties", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.min_prize": [[96, 100], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "min_prize", "(", "self", ")", ":", "\n", "      ", "\"\"\"Gets penalties at each location\"\"\"", "\n", "return", "self", ".", "_min_prize", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.CreateDistanceEvaluator.__init__": [[113, 127], ["six.moves.xrange", "six.moves.xrange", "pctsp_ortools.euclidian_distance"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.euclidian_distance"], ["def", "__init__", "(", "self", ",", "data", ")", ":", "\n", "    ", "\"\"\"Initializes the distance matrix.\"\"\"", "\n", "self", ".", "_distances", "=", "{", "}", "\n", "\n", "# precompute distance between location to have distance callback in O(1)", "\n", "for", "from_node", "in", "xrange", "(", "data", ".", "num_locations", ")", ":", "\n", "      ", "self", ".", "_distances", "[", "from_node", "]", "=", "{", "}", "\n", "for", "to_node", "in", "xrange", "(", "data", ".", "num_locations", ")", ":", "\n", "        ", "if", "from_node", "==", "to_node", ":", "\n", "          ", "self", ".", "_distances", "[", "from_node", "]", "[", "to_node", "]", "=", "0", "\n", "", "else", ":", "\n", "          ", "self", ".", "_distances", "[", "from_node", "]", "[", "to_node", "]", "=", "(", "\n", "euclidian_distance", "(", "data", ".", "locations", "[", "from_node", "]", ",", "\n", "data", ".", "locations", "[", "to_node", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.CreateDistanceEvaluator.distance_evaluator": [[128, 131], ["None"], "methods", ["None"], ["", "", "", "", "def", "distance_evaluator", "(", "self", ",", "from_node", ",", "to_node", ")", ":", "\n", "    ", "\"\"\"Returns the manhattan distance between the two nodes\"\"\"", "\n", "return", "self", ".", "_distances", "[", "from_node", "]", "[", "to_node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.CreatePrizeEvaluator.__init__": [[136, 139], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data", ")", ":", "\n", "    ", "\"\"\"Initializes the prize array.\"\"\"", "\n", "self", ".", "_prizes", "=", "data", ".", "prizes", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.CreatePrizeEvaluator.prize_evaluator": [[140, 144], ["None"], "methods", ["None"], ["", "def", "prize_evaluator", "(", "self", ",", "from_node", ",", "to_node", ")", ":", "\n", "    ", "\"\"\"Returns the prize of the current node\"\"\"", "\n", "del", "to_node", "\n", "return", "0", "if", "from_node", "==", "0", "else", "self", ".", "_prizes", "[", "from_node", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.float_to_scaled_int": [[40, 42], ["int"], "function", ["None"], ["def", "float_to_scaled_int", "(", "v", ")", ":", "\n", "    ", "return", "int", "(", "v", "*", "10000000", "+", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.euclidian_distance": [[105, 108], ["int", "math.sqrt"], "function", ["None"], ["", "", "def", "euclidian_distance", "(", "position_1", ",", "position_2", ")", ":", "\n", "  ", "\"\"\"Computes the Euclidian distance between two points\"\"\"", "\n", "return", "int", "(", "math", ".", "sqrt", "(", "(", "position_1", "[", "0", "]", "-", "position_2", "[", "0", "]", ")", "**", "2", "+", "(", "position_1", "[", "1", "]", "-", "position_2", "[", "1", "]", ")", "**", "2", ")", "+", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.add_min_prize_constraints": [[146, 158], ["routing.AddDimension", "routing.GetDimensionOrDie", "six.moves.xrange", "sum", "routing.GetDimensionOrDie.CumulVar().RemoveInterval", "routing.GetDimensionOrDie.CumulVar", "routing.End", "pctsp_ortools.DataProblem.min_prize"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.DataProblem.min_prize"], ["", "", "def", "add_min_prize_constraints", "(", "routing", ",", "data", ",", "prize_evaluator", ",", "min_prize", ")", ":", "\n", "  ", "\"\"\"Adds capacity constraint\"\"\"", "\n", "prize", "=", "'Prize'", "\n", "routing", ".", "AddDimension", "(", "\n", "prize_evaluator", ",", "\n", "0", ",", "# null capacity slack", "\n", "sum", "(", "data", ".", "prizes", ")", ",", "# No upper bound", "\n", "True", ",", "# start cumul to zero", "\n", "prize", ")", "\n", "capacity_dimension", "=", "routing", ".", "GetDimensionOrDie", "(", "prize", ")", "\n", "for", "vehicle", "in", "xrange", "(", "data", ".", "num_vehicles", ")", ":", "# only single vehicle", "\n", "      ", "capacity_dimension", ".", "CumulVar", "(", "routing", ".", "End", "(", "vehicle", ")", ")", ".", "RemoveInterval", "(", "0", ",", "min_prize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.add_distance_constraint": [[160, 169], ["routing.AddDimension"], "function", ["None"], ["", "", "def", "add_distance_constraint", "(", "routing", ",", "distance_evaluator", ",", "maximum_distance", ")", ":", "\n", "    ", "\"\"\"Add Global Span constraint\"\"\"", "\n", "distance", "=", "\"Distance\"", "\n", "routing", ".", "AddDimension", "(", "\n", "distance_evaluator", ",", "\n", "0", ",", "# null slack", "\n", "maximum_distance", ",", "# maximum distance per vehicle", "\n", "True", ",", "# start cumul to zero", "\n", "distance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.print_solution": [[174, 202], ["print", "routing.GetDimensionOrDie", "six.moves.xrange", "print", "print", "routing.Start", "routing.GetDimensionOrDie.CumulVar", "print", "assignment.Value", "assignment.ObjectiveValue", "routing.IsEnd", "routing.GetDimensionOrDie.CumulVar", "assignment.Value", "routing.GetArcCostForVehicle", "routing.IndexToNode", "assignment.Value", "assignment.Value", "routing.IndexToNode", "assignment.Value", "routing.NextVar"], "function", ["None"], ["", "def", "print_solution", "(", "data", ",", "routing", ",", "assignment", ")", ":", "\n", "  ", "\"\"\"Prints assignment on console\"\"\"", "\n", "print", "(", "'Objective: {}'", ".", "format", "(", "assignment", ".", "ObjectiveValue", "(", ")", ")", ")", "\n", "total_distance", "=", "0", "\n", "total_load", "=", "0", "\n", "capacity_dimension", "=", "routing", ".", "GetDimensionOrDie", "(", "'Capacity'", ")", "\n", "for", "vehicle_id", "in", "xrange", "(", "data", ".", "num_vehicles", ")", ":", "\n", "    ", "index", "=", "routing", ".", "Start", "(", "vehicle_id", ")", "\n", "plan_output", "=", "'Route for vehicle {}:\\n'", ".", "format", "(", "vehicle_id", ")", "\n", "distance", "=", "0", "\n", "while", "not", "routing", ".", "IsEnd", "(", "index", ")", ":", "\n", "      ", "load_var", "=", "capacity_dimension", ".", "CumulVar", "(", "index", ")", "\n", "plan_output", "+=", "' {} Load({}) -> '", ".", "format", "(", "\n", "routing", ".", "IndexToNode", "(", "index", ")", ",", "assignment", ".", "Value", "(", "load_var", ")", ")", "\n", "previous_index", "=", "index", "\n", "index", "=", "assignment", ".", "Value", "(", "routing", ".", "NextVar", "(", "index", ")", ")", "\n", "distance", "+=", "routing", ".", "GetArcCostForVehicle", "(", "previous_index", ",", "index", ",", "\n", "vehicle_id", ")", "\n", "", "load_var", "=", "capacity_dimension", ".", "CumulVar", "(", "index", ")", "\n", "plan_output", "+=", "' {0} Load({1})\\n'", ".", "format", "(", "\n", "routing", ".", "IndexToNode", "(", "index", ")", ",", "assignment", ".", "Value", "(", "load_var", ")", ")", "\n", "plan_output", "+=", "'Distance of the route: {}m\\n'", ".", "format", "(", "distance", ")", "\n", "plan_output", "+=", "'Load of the route: {}\\n'", ".", "format", "(", "assignment", ".", "Value", "(", "load_var", ")", ")", "\n", "print", "(", "plan_output", ")", "\n", "total_distance", "+=", "distance", "\n", "total_load", "+=", "assignment", ".", "Value", "(", "load_var", ")", "\n", "", "print", "(", "'Total Distance of all routes: {}m'", ".", "format", "(", "total_distance", ")", ")", "\n", "print", "(", "'Total Load of all routes: {}'", ".", "format", "(", "total_load", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.solve_pctsp_ortools": [[204, 243], ["pctsp_ortools.DataProblem", "ortools.constraint_solver.pywrapcp.RoutingModel", "pywrapcp.RoutingModel.SetArcCostEvaluatorOfAllVehicles", "pctsp_ortools.add_min_prize_constraints", "ortools.constraint_solver.pywrapcp.RoutingModel.DefaultSearchParameters", "pywrapcp.RoutingModel.SolveWithParameters", "pywrapcp.RoutingModel.Start", "pctsp_ortools.CreateDistanceEvaluator", "pctsp_ortools.CreatePrizeEvaluator", "pywrapcp.RoutingModel.AddDisjunction", "pywrapcp.RoutingModel.IsEnd", "pywrapcp.RoutingModel.IndexToNode", "route.append", "routing.SolveWithParameters.Value", "enumerate", "pywrapcp.RoutingModel.NextVar", "routing.SolveWithParameters.ObjectiveValue", "int"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.pctsp_ortools.add_min_prize_constraints"], ["", "def", "solve_pctsp_ortools", "(", "depot", ",", "loc", ",", "prize", ",", "penalty", ",", "min_prize", ",", "sec_local_search", "=", "0", ")", ":", "\n", "    ", "data", "=", "DataProblem", "(", "depot", ",", "loc", ",", "prize", ",", "penalty", ",", "min_prize", ")", "\n", "\n", "# Create Routing Model", "\n", "routing", "=", "pywrapcp", ".", "RoutingModel", "(", "data", ".", "num_locations", ",", "data", ".", "num_vehicles", ",", "\n", "data", ".", "depot", ")", "\n", "\n", "# Define weight of each edge", "\n", "distance_evaluator", "=", "CreateDistanceEvaluator", "(", "data", ")", ".", "distance_evaluator", "\n", "routing", ".", "SetArcCostEvaluatorOfAllVehicles", "(", "distance_evaluator", ")", "\n", "\n", "# Add minimum total prize constraint", "\n", "prize_evaluator", "=", "CreatePrizeEvaluator", "(", "data", ")", ".", "prize_evaluator", "\n", "add_min_prize_constraints", "(", "routing", ",", "data", ",", "prize_evaluator", ",", "data", ".", "min_prize", ")", "\n", "\n", "# Add penalties for missed nodes", "\n", "nodes", "=", "[", "routing", ".", "AddDisjunction", "(", "[", "int", "(", "c", "+", "1", ")", "]", ",", "p", ")", "for", "c", ",", "p", "in", "enumerate", "(", "data", ".", "penalties", ")", "]", "\n", "\n", "# Setting first solution heuristic (cheapest addition).", "\n", "search_parameters", "=", "pywrapcp", ".", "RoutingModel", ".", "DefaultSearchParameters", "(", ")", "\n", "search_parameters", ".", "first_solution_strategy", "=", "(", "\n", "routing_enums_pb2", ".", "FirstSolutionStrategy", ".", "PATH_CHEAPEST_ARC", ")", "\n", "if", "sec_local_search", ">", "0", ":", "\n", "# Additionally do local search", "\n", "        ", "search_parameters", ".", "local_search_metaheuristic", "=", "(", "\n", "routing_enums_pb2", ".", "LocalSearchMetaheuristic", ".", "GUIDED_LOCAL_SEARCH", ")", "\n", "search_parameters", ".", "time_limit_ms", "=", "1000", "*", "sec_local_search", "\n", "# Solve the problem.", "\n", "", "assignment", "=", "routing", ".", "SolveWithParameters", "(", "search_parameters", ")", "\n", "\n", "assert", "assignment", "is", "not", "None", ",", "\"ORTools was unable to find a feasible solution\"", "\n", "\n", "index", "=", "routing", ".", "Start", "(", "0", ")", "\n", "route", "=", "[", "]", "\n", "while", "not", "routing", ".", "IsEnd", "(", "index", ")", ":", "\n", "        ", "node_index", "=", "routing", ".", "IndexToNode", "(", "index", ")", "\n", "route", ".", "append", "(", "node_index", ")", "\n", "index", "=", "assignment", ".", "Value", "(", "routing", ".", "NextVar", "(", "index", ")", ")", "\n", "", "return", "assignment", ".", "ObjectiveValue", "(", ")", "/", "10000000.", ",", "route", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.application.solve_instance": [[19, 27], ["random.seed", "Pctsp", "Pctsp.load", "pctsp.model.solution.random", "pctsp.algo.ilocal_search.ilocal_search", "int", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.random", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.ilocal_search"], ["def", "solve_instance", "(", "filename", ",", "min_prize", ",", "runs", "=", "10", ",", "seed", "=", "1234", ")", ":", "\n", "    ", "random", ".", "seed", "(", "seed", ")", "\n", "pctsp", "=", "Pctsp", "(", ")", "\n", "pctsp", ".", "load", "(", "filename", ",", "min_prize", ")", "\n", "s", "=", "solution", ".", "random", "(", "pctsp", ",", "size", "=", "int", "(", "len", "(", "pctsp", ".", "prize", ")", "*", "0.7", ")", ")", "\n", "s", "=", "ils", ".", "ilocal_search", "(", "s", ",", "n_runs", "=", "runs", ")", "\n", "\n", "return", "(", "s", ".", "route", "[", "1", ":", "]", ",", "s", ".", "quality", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.application.main": [[28, 58], ["Pctsp", "Pctsp.load", "int", "pctsp.model.solution.random", "print", "print", "print", "print", "print", "pctsp.algo.ilocal_search.ilocal_search", "print", "print", "print", "print", "ils.ilocal_search.is_valid", "ils.ilocal_search.is_valid", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.random", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.ilocal_search", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Main function, that solves the PCTSP.\n\n    \"\"\"", "\n", "pctsp", "=", "Pctsp", "(", ")", "\n", "pctsp", ".", "load", "(", "INPUT_INSTANCE_FILE", ",", "386", ")", "\n", "#pctsp.prize = np.array([0, 4, 8, 3])", "\n", "#pctsp.penal = np.array([1000, 7, 11, 17])", "\n", "#pctsp.cost = np.array([[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]])", "\n", "# print(pctsp.type)", "\n", "\n", "size", "=", "int", "(", "len", "(", "pctsp", ".", "prize", ")", "*", "0.7", ")", "\n", "\n", "s", "=", "solution", ".", "random", "(", "pctsp", ",", "size", "=", "size", ")", "\n", "print", "(", "s", ".", "route", ")", "\n", "print", "(", "s", ".", "size", ")", "\n", "print", "(", "s", ".", "quality", ")", "\n", "print", "(", "s", ".", "is_valid", "(", ")", ")", "\n", "\n", "print", "(", "\"\\n\"", ")", "\n", "\n", "# s = genius(pctsp)", "\n", "# print(s.route)", "\n", "# print(s.quality)", "\n", "\n", "s", "=", "ils", ".", "ilocal_search", "(", "s", ")", "\n", "print", "(", "s", ".", "route", ")", "\n", "print", "(", "s", ".", "size", ")", "\n", "print", "(", "s", ".", "quality", ")", "\n", "print", "(", "s", ".", "is_valid", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.__init__": [[54, 65], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pctsp", ",", "size", "=", "None", ")", ":", "\n", "        ", "self", ".", "_route", "=", "[", "]", "\n", "\n", "if", "size", ":", "\n", "            ", "self", ".", "size", "=", "size", "\n", "", "else", ":", "\n", "            ", "self", ".", "size", "=", "len", "(", "pctsp", ".", "prize", ")", "# Default size value is the total of cities", "\n", "\n", "", "self", ".", "quality", "=", "sys", ".", "maxsize", "\n", "self", ".", "pctsp", "=", "pctsp", "\n", "self", ".", "prize", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.compute": [[69, 83], ["enumerate"], "methods", ["None"], ["def", "compute", "(", "self", ")", ":", "\n", "        ", "self", ".", "prize", "=", "0", "\n", "self", ".", "quality", "=", "0", "\n", "\n", "for", "i", ",", "city", "in", "enumerate", "(", "self", ".", "_route", ")", ":", "\n", "            ", "if", "i", "<", "self", ".", "size", ":", "\n", "                ", "self", ".", "prize", "+=", "self", ".", "pctsp", ".", "prize", "[", "city", "]", "\n", "if", "i", ">", "0", ":", "\n", "                    ", "previousCity", "=", "self", ".", "_route", "[", "i", "-", "1", "]", "\n", "self", ".", "quality", "+=", "self", ".", "pctsp", ".", "cost", "[", "previousCity", "]", "[", "city", "]", "\n", "", "if", "i", "+", "1", "==", "self", ".", "size", ":", "\n", "                    ", "self", ".", "quality", "+=", "self", ".", "pctsp", ".", "cost", "[", "city", "]", "[", "0", "]", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "quality", "+=", "self", ".", "pctsp", ".", "penal", "[", "city", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy": [[84, 89], ["copy.copy", "list"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy"], ["", "", "", "def", "copy", "(", "self", ")", ":", "\n", "        ", "cp", "=", "copy", ".", "copy", "(", "self", ")", "\n", "cp", ".", "_route", "=", "list", "(", "self", ".", "_route", ")", "\n", "\n", "return", "cp", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.swap": [[90, 104], ["None"], "methods", ["None"], ["", "def", "swap", "(", "self", ",", "i", ",", "j", ")", ":", "\n", "        ", "city_i", "=", "self", ".", "_route", "[", "i", "]", "\n", "city_i_prev", "=", "self", ".", "_route", "[", "i", "-", "1", "]", "\n", "city_i_next", "=", "self", ".", "_route", "[", "(", "i", "+", "1", ")", "%", "self", ".", "size", "]", "\n", "\n", "city_j", "=", "self", ".", "_route", "[", "j", "]", "\n", "\n", "self", ".", "quality", "=", "(", "self", ".", "quality", "\n", "-", "self", ".", "pctsp", ".", "cost", "[", "city_i_prev", "]", "[", "city_i", "]", "-", "self", ".", "pctsp", ".", "cost", "[", "city_i", "]", "[", "city_i_next", "]", "\n", "+", "self", ".", "pctsp", ".", "cost", "[", "city_i_prev", "]", "[", "city_j", "]", "+", "self", ".", "pctsp", ".", "cost", "[", "city_j", "]", "[", "city_i_next", "]", "\n", "-", "self", ".", "pctsp", ".", "penal", "[", "city_j", "]", "+", "self", ".", "pctsp", ".", "penal", "[", "city_i", "]", ")", "\n", "self", ".", "prize", "=", "self", ".", "prize", "-", "self", ".", "pctsp", ".", "prize", "[", "city_i", "]", "+", "self", ".", "pctsp", ".", "prize", "[", "city_j", "]", "\n", "\n", "self", ".", "_route", "[", "j", "]", ",", "self", ".", "_route", "[", "i", "]", "=", "self", ".", "_route", "[", "i", "]", ",", "self", ".", "_route", "[", "j", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid": [[105, 107], ["None"], "methods", ["None"], ["", "def", "is_valid", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "prize", ">=", "self", ".", "pctsp", ".", "prize_min", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.add_city": [[108, 120], ["None"], "methods", ["None"], ["", "def", "add_city", "(", "self", ")", ":", "\n", "        ", "city_l", "=", "self", ".", "_route", "[", "self", ".", "size", "-", "1", "]", "\n", "city_add", "=", "self", ".", "_route", "[", "self", ".", "size", "]", "\n", "\n", "self", ".", "quality", "=", "(", "self", ".", "quality", "\n", "-", "self", ".", "pctsp", ".", "cost", "[", "city_l", "]", "[", "0", "]", "\n", "-", "self", ".", "pctsp", ".", "penal", "[", "city_add", "]", "\n", "+", "self", ".", "pctsp", ".", "cost", "[", "city_l", "]", "[", "city_add", "]", "\n", "+", "self", ".", "pctsp", ".", "cost", "[", "city_add", "]", "[", "0", "]", ")", "\n", "\n", "self", ".", "size", "+=", "1", "\n", "self", ".", "prize", "+=", "self", ".", "pctsp", ".", "prize", "[", "city_add", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.remove_city": [[121, 136], ["solution.Solution._route.append"], "methods", ["None"], ["", "def", "remove_city", "(", "self", ",", "index", ")", ":", "\n", "        ", "city_rem", "=", "self", ".", "_route", "[", "index", "]", "\n", "city_rem_prev", "=", "self", ".", "_route", "[", "index", "-", "1", "]", "\n", "city_rem_next", "=", "self", ".", "_route", "[", "(", "index", "+", "1", ")", "%", "self", ".", "size", "]", "\n", "\n", "self", ".", "quality", "=", "(", "self", ".", "quality", "\n", "-", "self", ".", "pctsp", ".", "cost", "[", "city_rem_prev", "]", "[", "city_rem", "]", "-", "self", ".", "pctsp", ".", "cost", "[", "city_rem", "]", "[", "city_rem_next", "]", "\n", "+", "self", ".", "pctsp", ".", "penal", "[", "city_rem", "]", "\n", "+", "self", ".", "pctsp", ".", "cost", "[", "city_rem_prev", "]", "[", "city_rem_next", "]", ")", "\n", "self", ".", "prize", "-=", "self", ".", "pctsp", ".", "prize", "[", "city_rem", "]", "\n", "\n", "del", "self", ".", "_route", "[", "index", "]", "\n", "self", ".", "_route", ".", "append", "(", "city_rem", ")", "\n", "\n", "self", ".", "size", "-=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.remove_cities": [[137, 153], ["range"], "methods", ["None"], ["", "def", "remove_cities", "(", "self", ",", "quant", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "size", "-", "quant", ",", "self", ".", "size", ")", ":", "\n", "            ", "city_rem", "=", "self", ".", "_route", "[", "i", "]", "\n", "city_rem_prev", "=", "self", ".", "_route", "[", "i", "-", "1", "]", "\n", "\n", "self", ".", "quality", "=", "(", "self", ".", "quality", "\n", "-", "self", ".", "pctsp", ".", "cost", "[", "city_rem_prev", "]", "[", "city_rem", "]", "\n", "+", "self", ".", "pctsp", ".", "penal", "[", "city_rem", "]", ")", "\n", "self", ".", "prize", "-=", "self", ".", "pctsp", ".", "prize", "[", "city_rem", "]", "\n", "\n", "", "city_rem", "=", "self", ".", "_route", "[", "self", ".", "size", "-", "1", "]", "\n", "city_l", "=", "self", ".", "_route", "[", "self", ".", "size", "-", "quant", "-", "1", "]", "\n", "self", ".", "quality", "=", "(", "self", ".", "quality", "-", "self", ".", "pctsp", ".", "cost", "[", "city_rem", "]", "[", "0", "]", "\n", "+", "self", ".", "pctsp", ".", "cost", "[", "city_l", "]", "[", "0", "]", ")", "\n", "\n", "self", ".", "size", "-=", "quant", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.print_route": [[154, 156], ["print"], "methods", ["None"], ["", "def", "print_route", "(", "self", ")", ":", "\n", "        ", "print", "(", "self", ".", "_route", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.route": [[161, 165], ["solution.Solution.compute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.compute"], ["", "@", "route", ".", "setter", "\n", "def", "route", "(", "self", ",", "r", ")", ":", "\n", "        ", "self", ".", "_route", "=", "r", "\n", "self", ".", "compute", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.random": [[16, 44], ["solution.Solution", "len", "range", "solution.Solution.is_valid", "solution.Solution.is_valid", "solution.Solution", "list", "random.shuffle", "range", "solution.Solution.is_valid", "solution.Solution.is_valid"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid"], ["def", "random", "(", "pctsp", ",", "start_size", ")", ":", "\n", "    ", "s", "=", "Solution", "(", "pctsp", ")", "\n", "length", "=", "len", "(", "pctsp", ".", "prize", ")", "\n", "\n", "# Modification: start from start_size but increase after maximum number of iterations in case no feasible solution", "\n", "# is found. When the full length is used, there should always be a feasible solution", "\n", "for", "size", "in", "range", "(", "start_size", ",", "length", "+", "1", ")", ":", "\n", "        ", "if", "size", ":", "s", ".", "size", "=", "size", "\n", "\n", "i", "=", "0", "\n", "min_solutions", "=", "30", "\n", "max_solutions", "=", "1000", "\n", "\n", "while", "i", "<", "min_solutions", "or", "(", "i", "<", "max_solutions", "and", "not", "s", ".", "is_valid", "(", ")", ")", ":", "\n", "            ", "r", "=", "Solution", "(", "pctsp", ")", "\n", "if", "size", ":", "r", ".", "size", "=", "size", "\n", "cities", "=", "list", "(", "range", "(", "1", ",", "length", ",", "1", ")", ")", "\n", "shuffle", "(", "cities", ")", "# Shuffle in place", "\n", "r", ".", "route", "=", "[", "0", "]", "+", "cities", "# The city 0 is always the first", "\n", "\n", "if", "r", ".", "quality", "<", "s", ".", "quality", "and", "r", ".", "is_valid", "(", ")", ":", "\n", "                ", "s", "=", "r", "\n", "\n", "", "i", "+=", "1", "\n", "", "if", "s", ".", "is_valid", "(", ")", ":", "\n", "            ", "break", "\n", "", "", "assert", "s", ".", "is_valid", "(", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.__init__": [[21, 26], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "prize", "=", "[", "]", "\n", "self", ".", "penal", "=", "[", "]", "\n", "self", ".", "cost", "=", "[", "]", "\n", "self", ".", "prize_min", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load": [[27, 41], ["open", "enumerate", "open.close", "numpy.loadtxt", "sum", "numpy.fromstring", "numpy.fromstring"], "methods", ["None"], ["", "def", "load", "(", "self", ",", "file_name", ",", "prize_min", ")", ":", "\n", "\n", "        ", "f", "=", "open", "(", "file_name", ",", "'r'", ")", "\n", "for", "i", ",", "line", "in", "enumerate", "(", "f", ")", ":", "\n", "            ", "if", "i", "is", "5", ":", "break", "\n", "if", "i", "is", "1", ":", "self", ".", "prize", "=", "np", ".", "fromstring", "(", "line", ",", "dtype", "=", "int", ",", "sep", "=", "' '", ")", "\n", "if", "i", "is", "4", ":", "self", ".", "penal", "=", "np", ".", "fromstring", "(", "line", ",", "dtype", "=", "int", ",", "sep", "=", "' '", ")", "\n", "\n", "", "f", ".", "close", "(", ")", "\n", "\n", "self", ".", "cost", "=", "np", ".", "loadtxt", "(", "file_name", ",", "dtype", "=", "int", ",", "skiprows", "=", "7", ")", "\n", "self", ".", "prize_min", "=", "prize_min", "\n", "\n", "assert", "sum", "(", "self", ".", "prize", ")", ">=", "prize_min", ",", "\"Infeasible\"", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tests.test_solution.TestTrain.setUp": [[9, 14], ["pctsp.model.pctsp.model.pctsp.Pctsp", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "p", "=", "pctsp", ".", "Pctsp", "(", ")", "\n", "self", ".", "p", ".", "prize", "=", "np", ".", "array", "(", "[", "0", ",", "4", ",", "8", ",", "3", "]", ")", "\n", "self", ".", "p", ".", "penal", "=", "np", ".", "array", "(", "[", "1000", ",", "7", ",", "11", ",", "17", "]", ")", "\n", "self", ".", "p", ".", "cost", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "1", ",", "1", "]", ",", "[", "1", ",", "0", ",", "1", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "1", ",", "0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tests.test_solution.TestTrain.test_quality": [[15, 20], ["pctsp.model.pctsp.model.solution.Solution", "print", "test_solution.TestTrain.assertEqual"], "methods", ["None"], ["", "def", "test_quality", "(", "self", ")", ":", "\n", "        ", "s", "=", "solution", ".", "Solution", "(", "self", ".", "p", ")", "\n", "s", ".", "route", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", "\n", "print", "(", "\"Quality: \"", ",", "s", ".", "quality", ")", "\n", "self", ".", "assertEqual", "(", "s", ".", "quality", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tests.test_solution.TestTrain.test_quality_2": [[21, 26], ["pctsp.model.pctsp.model.solution.Solution", "print", "test_solution.TestTrain.assertEqual"], "methods", ["None"], ["", "def", "test_quality_2", "(", "self", ")", ":", "\n", "        ", "s", "=", "solution", ".", "Solution", "(", "self", ".", "p", ",", "size", "=", "2", ")", "\n", "s", ".", "route", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", "\n", "print", "(", "\"Quality: \"", ",", "s", ".", "quality", ")", "\n", "self", ".", "assertEqual", "(", "s", ".", "quality", ",", "30", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tests.test_solution.TestTrain.test_swap": [[27, 35], ["pctsp.model.pctsp.model.solution.Solution", "pctsp.model.solution.Solution.swap", "print", "print", "test_solution.TestTrain.assertEqual"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.swap"], ["", "def", "test_swap", "(", "self", ")", ":", "\n", "        ", "s", "=", "solution", ".", "Solution", "(", "self", ".", "p", ",", "size", "=", "3", ")", "\n", "s", ".", "route", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", "\n", "\n", "s", ".", "swap", "(", "1", ",", "3", ")", "\n", "print", "(", "\"Quality: \"", ",", "s", ".", "quality", ")", "\n", "print", "(", "\"route:\"", ",", "s", ".", "route", ")", "\n", "self", ".", "assertEqual", "(", "s", ".", "quality", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tests.test_solution.TestTrain.test_add_city": [[36, 43], ["pctsp.model.pctsp.model.solution.Solution", "pctsp.model.solution.Solution.add_city", "print", "test_solution.TestTrain.assertEqual"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.add_city"], ["", "def", "test_add_city", "(", "self", ")", ":", "\n", "        ", "s", "=", "solution", ".", "Solution", "(", "self", ".", "p", ",", "size", "=", "3", ")", "\n", "s", ".", "route", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", "\n", "\n", "s", ".", "add_city", "(", ")", "\n", "print", "(", "\"Quality: \"", ",", "s", ".", "quality", ")", "\n", "self", ".", "assertEqual", "(", "s", ".", "quality", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tests.test_solution.TestTrain.test_remove_city": [[44, 51], ["pctsp.model.pctsp.model.solution.Solution", "pctsp.model.solution.Solution.remove_city", "print", "test_solution.TestTrain.assertEqual"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.remove_city"], ["", "def", "test_remove_city", "(", "self", ")", ":", "\n", "        ", "s", "=", "solution", ".", "Solution", "(", "self", ".", "p", ")", "\n", "s", ".", "route", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", "\n", "\n", "s", ".", "remove_city", "(", "3", ")", "\n", "print", "(", "\"Quality: \"", ",", "s", ".", "quality", ")", "\n", "self", ".", "assertEqual", "(", "s", ".", "quality", ",", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tests.test_solution.TestTrain.test_remove_cities": [[52, 58], ["pctsp.model.pctsp.model.solution.Solution", "pctsp.model.solution.Solution.remove_cities", "test_solution.TestTrain.assertEqual"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.remove_cities"], ["", "def", "test_remove_cities", "(", "self", ")", ":", "\n", "        ", "s", "=", "solution", ".", "Solution", "(", "self", ".", "p", ")", "\n", "s", ".", "route", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", "\n", "\n", "s", ".", "remove_cities", "(", "quant", "=", "3", ")", "\n", "self", ".", "assertEqual", "(", "s", ".", "quality", ",", "35", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.genius.genius": [[16, 22], ["pctsp.model.solution.random", "genius.geni", "genius.us"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.random", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.geni.geni", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.genius.us"], ["def", "genius", "(", "pctsp", ")", ":", "\n", "    ", "s", "=", "solution", ".", "random", "(", "pctsp", ",", "size", "=", "3", ")", "\n", "s", "=", "geni", "(", "pstsp", ",", "s", ")", "\n", "s", "=", "us", "(", "pctsp", ",", "s", ")", "\n", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.genius.geni": [[23, 25], ["None"], "function", ["None"], ["", "def", "geni", "(", "pctsp", ",", "s", ")", ":", "\n", "    ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.genius.us": [[26, 28], ["None"], "function", ["None"], ["", "def", "us", "(", "pctsp", ",", "s", ")", ":", "\n", "    ", "return", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.ilocal_search": [[14, 39], ["perturb.copy", "perturb.copy", "len", "times.pop", "perturb.copy", "ilocal_search.newHomeBase", "ilocal_search.perturb", "ilocal_search.tweak", "perturb.is_valid", "s.copy.copy", "s.copy.is_valid"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.newHomeBase", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.perturb", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.tweak", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.is_valid"], ["def", "ilocal_search", "(", "s", ",", "n_runs", "=", "10", ")", ":", "\n", "    ", "h", "=", "s", ".", "copy", "(", ")", "\n", "best", "=", "s", ".", "copy", "(", ")", "\n", "times", "=", "[", "1000", "]", "*", "n_runs", "# random.sample(range(1000, 2000), n_runs)", "\n", "\n", "while", "len", "(", "times", ")", ">", "0", ":", "\n", "        ", "time", "=", "times", ".", "pop", "(", ")", "\n", "t", "=", "0", "\n", "s_tabu", "=", "s", ".", "copy", "(", ")", "\n", "while", "t", "<", "time", ":", "\n", "            ", "r", "=", "tweak", "(", "s_tabu", ".", "copy", "(", ")", ")", "\n", "if", "r", ".", "quality", "<", "s_tabu", ".", "quality", ":", "\n", "                ", "s_tabu", "=", "r", "\n", "\n", "if", "s_tabu", ".", "is_valid", "(", ")", ":", "\n", "                    ", "s", "=", "s_tabu", "\n", "", "", "t", "+=", "1", "\n", "\n", "", "if", "s", ".", "quality", "<", "best", ".", "quality", "and", "s", ".", "is_valid", "(", ")", ":", "\n", "            ", "best", "=", "s", "\n", "\n", "", "h", "=", "newHomeBase", "(", "h", ",", "s", ")", "\n", "s", "=", "perturb", "(", "h", ")", "\n", "\n", "", "return", "best", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.tweak": [[40, 61], ["ilocal_search.m1", "ilocal_search.m2", "solution.copy", "solution.copy", "ilocal_search.m3", "solution.copy"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.m1", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.m2", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy", "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.m3", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy"], ["", "def", "tweak", "(", "solution", ")", ":", "\n", "    ", "s", "=", "solution", "\n", "\n", "s_1", "=", "m1", "(", "solution", ".", "copy", "(", ")", ")", "\n", "s_2", "=", "m2", "(", "solution", ".", "copy", "(", ")", ")", "\n", "\n", "if", "(", "s_1", "and", "s_1", ".", "quality", "<", "solution", ".", "quality", "\n", "and", "(", "not", "s_2", "or", "s_1", ".", "quality", "<", "s_2", ".", "quality", ")", "\n", ")", ":", "#and s_1.is_valid()):", "\n", "        ", "s", "=", "s_1", "\n", "", "elif", "(", "s_2", "and", "s_2", ".", "quality", "<", "solution", ".", "quality", "\n", "and", "(", "not", "s_1", "or", "s_2", ".", "quality", "<", "s_1", ".", "quality", ")", "\n", ")", ":", "#and s_2.is_valid()):", "\n", "        ", "s", "=", "s_2", "\n", "", "else", ":", "\n", "        ", "s_3", "=", "m3", "(", "solution", ".", "copy", "(", ")", ")", "\n", "if", "(", "s_3", "and", "s_3", ".", "quality", "<", "solution", ".", "quality", "\n", ")", ":", "#and s_3.is_valid()):", "\n", "            ", "s", "=", "s_3", "\n", "\n", "", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.newHomeBase": [[62, 67], ["None"], "function", ["None"], ["", "def", "newHomeBase", "(", "h", ",", "s", ")", ":", "\n", "    ", "if", "s", ".", "quality", "<=", "h", ".", "quality", ":", "\n", "        ", "return", "s", "\n", "", "else", ":", "\n", "        ", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.perturb": [[68, 75], ["solution.copy", "int", "solution.copy.remove_cities"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.remove_cities"], ["", "", "def", "perturb", "(", "solution", ")", ":", "\n", "    ", "s", "=", "solution", ".", "copy", "(", ")", "\n", "if", "s", ".", "size", ">", "5", ":", "\n", "        ", "quant", "=", "int", "(", "s", ".", "size", "/", "5", ")", "\n", "s", ".", "remove_cities", "(", "quant", "=", "quant", ")", "\n", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.m1": [[76, 86], ["len", "random.randrange", "random.randrange", "solution.swap"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.swap"], ["", "def", "m1", "(", "solution", ")", ":", "\n", "    ", "size", "=", "solution", ".", "size", "\n", "length", "=", "len", "(", "solution", ".", "route", ")", "\n", "\n", "if", "size", ">", "1", "and", "size", "<", "length", ":", "\n", "        ", "i", "=", "random", ".", "randrange", "(", "1", ",", "size", ")", "\n", "j", "=", "random", ".", "randrange", "(", "size", ",", "length", ")", "\n", "solution", ".", "swap", "(", "i", ",", "j", ")", "\n", "\n", "", "return", "solution", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.m2": [[87, 93], ["random.randrange", "solution.remove_city"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.remove_city"], ["", "def", "m2", "(", "solution", ")", ":", "\n", "    ", "if", "solution", ".", "size", ">", "1", ":", "\n", "        ", "i", "=", "random", ".", "randrange", "(", "1", ",", "solution", ".", "size", ")", "\n", "solution", ".", "remove_city", "(", "index", "=", "i", ")", "\n", "\n", "", "return", "solution", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.ilocal_search.m3": [[94, 99], ["len", "solution.add_city"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.add_city"], ["", "def", "m3", "(", "solution", ")", ":", "\n", "    ", "if", "solution", ".", "size", "<", "len", "(", "solution", ".", "route", ")", ":", "\n", "        ", "solution", ".", "add_city", "(", ")", "\n", "\n", "", "return", "solution", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.algo.geni.geni": [[14, 31], ["Solution", "range", "quality_after_insertion_1", "quality_after_insertion_2", "insertion_1", "insertion_2"], "function", ["None"], ["def", "geni", "(", "v", ",", "s", ",", "max_i", ")", ":", "\n", "    ", "quality_1", "=", "0", "\n", "quality_2", "=", "0", "\n", "\n", "s_star", "=", "Solution", "(", ")", "\n", "s_start", ".", "quality", "=", "sys", ".", "maxint", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "max_i", ")", ":", "\n", "        ", "quality_1", "=", "quality_after_insertion_1", "(", "v", ",", "i", ",", ")", "\n", "quality_2", "=", "quality_after_insertion_2", "(", ")", "\n", "\n", "if", "quality_1", "<", "quality_2", "and", "quality_1", "<", "s_star", ".", "quality", ":", "\n", "            ", "s_star", "=", "insertion_1", "(", "s", ")", "\n", "", "elif", "quality_2", "<", "quality_1", "and", "quality_2", "<", "s_star", ".", "quality", ":", "\n", "            ", "s_star", "=", "insertion_2", "(", "s", ")", "\n", "\n", "", "", "return", "s_star", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.get_lkh_executable": [[14, 36], ["os.path.abspath", "os.makedirs", "os.path.join", "os.path.join", "os.path.isfile", "os.path.abspath", "os.path.join", "os.path.splitext", "os.path.isdir", "print", "subprocess.check_call", "os.path.isfile", "subprocess.check_call", "os.path.isdir", "subprocess.check_call", "os.remove", "os.path.split", "urllib.parse.urlparse"], "function", ["None"], ["def", "get_lkh_executable", "(", "url", "=", "\"http://www.akira.ruc.dk/~keld/research/LKH-3/LKH-3.0.4.tgz\"", ")", ":", "\n", "\n", "    ", "cwd", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "\"problems\"", ",", "\"vrp\"", ",", "\"lkh\"", ")", ")", "\n", "os", ".", "makedirs", "(", "cwd", ",", "exist_ok", "=", "True", ")", "\n", "\n", "file", "=", "os", ".", "path", ".", "join", "(", "cwd", ",", "os", ".", "path", ".", "split", "(", "urlparse", "(", "url", ")", ".", "path", ")", "[", "-", "1", "]", ")", "\n", "filedir", "=", "os", ".", "path", ".", "splitext", "(", "file", ")", "[", "0", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "filedir", ")", ":", "\n", "        ", "print", "(", "\"{} not found, downloading and compiling\"", ".", "format", "(", "filedir", ")", ")", "\n", "\n", "check_call", "(", "[", "\"wget\"", ",", "url", "]", ",", "cwd", "=", "cwd", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "file", ")", ",", "\"Download failed, {} does not exist\"", ".", "format", "(", "file", ")", "\n", "check_call", "(", "[", "\"tar\"", ",", "\"xvfz\"", ",", "file", "]", ",", "cwd", "=", "cwd", ")", "\n", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "filedir", ")", ",", "\"Extracting failed, dir {} does not exist\"", ".", "format", "(", "filedir", ")", "\n", "check_call", "(", "\"make\"", ",", "cwd", "=", "filedir", ")", "\n", "os", ".", "remove", "(", "file", ")", "\n", "\n", "", "executable", "=", "os", ".", "path", ".", "join", "(", "filedir", ",", "\"LKH\"", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "executable", ")", "\n", "return", "os", ".", "path", ".", "abspath", "(", "executable", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.solve_lkh": [[38, 52], ["tempfile.TemporaryDirectory", "os.path.join", "os.path.join", "os.path.join", "time.time", "vrp_baseline.write_vrplib", "vrp_baseline.write_lkh_par", "subprocess.check_output", "vrp_baseline.read_vrplib", "time.time", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.write_vrplib", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_lkh_par", "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.read_vrplib"], ["", "def", "solve_lkh", "(", "executable", ",", "depot", ",", "loc", ",", "demand", ",", "capacity", ")", ":", "\n", "    ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "tempdir", ",", "\"problem.vrp\"", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "tempdir", ",", "\"output.tour\"", ")", "\n", "param_filename", "=", "os", ".", "path", ".", "join", "(", "tempdir", ",", "\"params.par\"", ")", "\n", "\n", "starttime", "=", "time", ".", "time", "(", ")", "\n", "write_vrplib", "(", "problem_filename", ",", "depot", ",", "loc", ",", "demand", ",", "capacity", ")", "\n", "params", "=", "{", "\"PROBLEM_FILE\"", ":", "problem_filename", ",", "\"OUTPUT_TOUR_FILE\"", ":", "output_filename", "}", "\n", "write_lkh_par", "(", "param_filename", ",", "params", ")", "\n", "output", "=", "check_output", "(", "[", "executable", ",", "param_filename", "]", ")", "\n", "result", "=", "read_vrplib", "(", "output_filename", ",", "n", "=", "len", "(", "demand", ")", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "starttime", "\n", "return", "result", ",", "output", ",", "duration", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.solve_lkh_log": [[54, 88], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.isfile", "utils.data_utils.load_dataset", "vrp_baseline.write_vrplib", "vrp_baseline.write_lkh_par", "vrp_baseline.read_vrplib", "utils.data_utils.save_dataset", "vrp_baseline.calc_vrp_cost", "print", "print", "open", "time.time", "subprocess.check_call", "time.time", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.write_vrplib", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_lkh_par", "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.read_vrplib", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.calc_vrp_cost"], ["", "", "def", "solve_lkh_log", "(", "executable", ",", "directory", ",", "name", ",", "depot", ",", "loc", ",", "demand", ",", "capacity", ",", "grid_size", "=", "1", ",", "runs", "=", "1", ",", "disable_cache", "=", "False", ")", ":", "\n", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.vrp\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "tour_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.tour\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.pkl\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "param_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.par\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "log_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.log\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "\n", "try", ":", "\n", "# May have already been run", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "tour", ",", "duration", "=", "load_dataset", "(", "output_filename", ")", "\n", "", "else", ":", "\n", "            ", "write_vrplib", "(", "problem_filename", ",", "depot", ",", "loc", ",", "demand", ",", "capacity", ",", "grid_size", ",", "name", "=", "name", ")", "\n", "\n", "params", "=", "{", "\"PROBLEM_FILE\"", ":", "problem_filename", ",", "\"OUTPUT_TOUR_FILE\"", ":", "tour_filename", ",", "\"RUNS\"", ":", "runs", ",", "\"SEED\"", ":", "1234", "}", "\n", "write_lkh_par", "(", "param_filename", ",", "params", ")", "\n", "\n", "with", "open", "(", "log_filename", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "start", "=", "time", ".", "time", "(", ")", "\n", "check_call", "(", "[", "executable", ",", "param_filename", "]", ",", "stdout", "=", "f", ",", "stderr", "=", "f", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "", "tour", "=", "read_vrplib", "(", "tour_filename", ",", "n", "=", "len", "(", "demand", ")", ")", "\n", "\n", "save_dataset", "(", "(", "tour", ",", "duration", ")", ",", "output_filename", ")", "\n", "\n", "", "return", "calc_vrp_cost", "(", "depot", ",", "loc", ",", "tour", ")", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "raise", "\n", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.calc_vrp_cost": [[90, 96], ["numpy.vstack", "numpy.linalg.norm().sum", "numpy.array", "numpy.concatenate", "numpy.linalg.norm", "numpy.array", "numpy.sort", "numpy.arange", "len", "len"], "function", ["None"], ["", "", "def", "calc_vrp_cost", "(", "depot", ",", "loc", ",", "tour", ")", ":", "\n", "    ", "assert", "(", "np", ".", "sort", "(", "tour", ")", "[", "-", "len", "(", "loc", ")", ":", "]", "==", "np", ".", "arange", "(", "len", "(", "loc", ")", ")", "+", "1", ")", ".", "all", "(", ")", ",", "\"All nodes must be visited once!\"", "\n", "# TODO validate capacity constraints", "\n", "loc_with_depot", "=", "np", ".", "vstack", "(", "(", "np", ".", "array", "(", "depot", ")", "[", "None", ",", ":", "]", ",", "np", ".", "array", "(", "loc", ")", ")", ")", "\n", "sorted_locs", "=", "loc_with_depot", "[", "np", ".", "concatenate", "(", "(", "[", "0", "]", ",", "tour", ",", "[", "0", "]", ")", ")", "]", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "sorted_locs", "[", "1", ":", "]", "-", "sorted_locs", "[", ":", "-", "1", "]", ",", "axis", "=", "-", "1", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.write_lkh_par": [[98, 112], ["open", "f.write", "f.write"], "function", ["None"], ["", "def", "write_lkh_par", "(", "filename", ",", "parameters", ")", ":", "\n", "    ", "default_parameters", "=", "{", "# Use none to include as flag instead of kv", "\n", "\"SPECIAL\"", ":", "None", ",", "\n", "\"MAX_TRIALS\"", ":", "10000", ",", "\n", "\"RUNS\"", ":", "10", ",", "\n", "\"TRACE_LEVEL\"", ":", "1", ",", "\n", "\"SEED\"", ":", "0", "\n", "}", "\n", "with", "open", "(", "filename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "for", "k", ",", "v", "in", "{", "**", "default_parameters", ",", "**", "parameters", "}", ".", "items", "(", ")", ":", "\n", "            ", "if", "v", "is", "None", ":", "\n", "                ", "f", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "k", ")", ")", "\n", "", "else", ":", "\n", "                ", "f", ".", "write", "(", "\"{} = {}\\n\"", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.read_vrplib": [[114, 137], ["tour[].tolist", "open", "len", "numpy.array().astype", "line.startswith", "line.startswith", "int", "tour.append", "int", "numpy.array", "line.split"], "function", ["None"], ["", "", "", "", "def", "read_vrplib", "(", "filename", ",", "n", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "tour", "=", "[", "]", "\n", "dimension", "=", "0", "\n", "started", "=", "False", "\n", "for", "line", "in", "f", ":", "\n", "            ", "if", "started", ":", "\n", "                ", "loc", "=", "int", "(", "line", ")", "\n", "if", "loc", "==", "-", "1", ":", "\n", "                    ", "break", "\n", "", "tour", ".", "append", "(", "loc", ")", "\n", "", "if", "line", ".", "startswith", "(", "\"DIMENSION\"", ")", ":", "\n", "                ", "dimension", "=", "int", "(", "line", ".", "split", "(", "\" \"", ")", "[", "-", "1", "]", ")", "\n", "\n", "", "if", "line", ".", "startswith", "(", "\"TOUR_SECTION\"", ")", ":", "\n", "                ", "started", "=", "True", "\n", "\n", "", "", "", "assert", "len", "(", "tour", ")", "==", "dimension", "\n", "tour", "=", "np", ".", "array", "(", "tour", ")", ".", "astype", "(", "int", ")", "-", "1", "# Subtract 1 as depot is 1 and should be 0", "\n", "tour", "[", "tour", ">", "n", "]", "=", "0", "# Any nodes above the number of nodes there are is also depot", "\n", "assert", "tour", "[", "0", "]", "==", "0", "# Tour should start with depot", "\n", "assert", "tour", "[", "-", "1", "]", "!=", "0", "# Tour should not end with depot", "\n", "return", "tour", "[", "1", ":", "]", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.vrp_baseline.write_vrplib": [[139, 170], ["open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "int", "int", "enumerate", "enumerate", "len"], "function", ["None"], ["", "def", "write_vrplib", "(", "filename", ",", "depot", ",", "loc", ",", "demand", ",", "capacity", ",", "grid_size", ",", "name", "=", "\"problem\"", ")", ":", "\n", "\n", "    ", "with", "open", "(", "filename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{} : {}\"", ".", "format", "(", "k", ",", "v", ")", "\n", "for", "k", ",", "v", "in", "(", "\n", "(", "\"NAME\"", ",", "name", ")", ",", "\n", "(", "\"TYPE\"", ",", "\"CVRP\"", ")", ",", "\n", "(", "\"DIMENSION\"", ",", "len", "(", "loc", ")", "+", "1", ")", ",", "\n", "(", "\"EDGE_WEIGHT_TYPE\"", ",", "\"EUC_2D\"", ")", ",", "\n", "(", "\"CAPACITY\"", ",", "capacity", ")", "\n", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"NODE_COORD_SECTION\\n\"", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{}\\t{}\\t{}\"", ".", "format", "(", "i", "+", "1", ",", "int", "(", "x", "/", "grid_size", "*", "100000", "+", "0.5", ")", ",", "int", "(", "y", "/", "grid_size", "*", "100000", "+", "0.5", ")", ")", "# VRPlib does not take floats", "\n", "#\"{}\\t{}\\t{}\".format(i + 1, x, y)", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "[", "depot", "]", "+", "loc", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"DEMAND_SECTION\\n\"", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{}\\t{}\"", ".", "format", "(", "i", "+", "1", ",", "d", ")", "\n", "for", "i", ",", "d", "in", "enumerate", "(", "[", "0", "]", "+", "demand", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"DEPOT_SECTION\\n\"", ")", "\n", "f", ".", "write", "(", "\"1\\n\"", ")", "\n", "f", ".", "write", "(", "\"-1\\n\"", ")", "\n", "f", ".", "write", "(", "\"EOF\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_sdvrp.StateSDVRP.__getitem__": [[24, 33], ["state_sdvrp.StateSDVRP._replace", "torch.is_tensor", "isinstance"], "methods", ["None"], ["def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "# If tensor, idx all tensors by this tensor:", "\n", "return", "self", ".", "_replace", "(", "\n", "ids", "=", "self", ".", "ids", "[", "key", "]", ",", "\n", "prev_a", "=", "self", ".", "prev_a", "[", "key", "]", ",", "\n", "used_capacity", "=", "self", ".", "used_capacity", "[", "key", "]", ",", "\n", "demands_with_depot", "=", "self", ".", "demands_with_depot", "[", "key", "]", ",", "\n", "lengths", "=", "self", ".", "lengths", "[", "key", "]", ",", "\n", "cur_coord", "=", "self", ".", "cur_coord", "[", "key", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_sdvrp.StateSDVRP.initialize": [[36, 57], ["loc.size", "state_sdvrp.StateSDVRP", "torch.cat", "torch.zeros", "demand.new_zeros", "torch.zeros", "torch.zeros", "torch.arange", "torch.cat", "demand.new_zeros"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "@", "staticmethod", "\n", "def", "initialize", "(", "input", ")", ":", "\n", "\n", "        ", "depot", "=", "input", "[", "'depot'", "]", "\n", "loc", "=", "input", "[", "'loc'", "]", "\n", "demand", "=", "input", "[", "'demand'", "]", "\n", "\n", "batch_size", ",", "n_loc", ",", "_", "=", "loc", ".", "size", "(", ")", "\n", "return", "StateSDVRP", "(", "\n", "coords", "=", "torch", ".", "cat", "(", "(", "depot", "[", ":", ",", "None", ",", ":", "]", ",", "loc", ")", ",", "-", "2", ")", ",", "\n", "demand", "=", "demand", ",", "\n", "ids", "=", "torch", ".", "arange", "(", "batch_size", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "[", ":", ",", "None", "]", ",", "# Add steps dimension", "\n", "prev_a", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "used_capacity", "=", "demand", ".", "new_zeros", "(", "batch_size", ",", "1", ")", ",", "\n", "demands_with_depot", "=", "torch", ".", "cat", "(", "(", "\n", "demand", ".", "new_zeros", "(", "batch_size", ",", "1", ")", ",", "\n", "demand", "[", ":", ",", ":", "]", "\n", ")", ",", "1", ")", "[", ":", ",", "None", ",", ":", "]", ",", "\n", "lengths", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "cur_coord", "=", "input", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "# Add step dimension", "\n", "i", "=", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Vector with length num_steps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_sdvrp.StateSDVRP.get_final_cost": [[59, 64], ["state_sdvrp.StateSDVRP.all_finished"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished"], ["", "def", "get_final_cost", "(", "self", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "all_finished", "(", ")", "\n", "\n", "return", "self", ".", "lengths", "+", "(", "self", ".", "coords", "[", "self", ".", "ids", ",", "0", ",", ":", "]", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_sdvrp.StateSDVRP.update": [[65, 96], ["torch.min", "state_sdvrp.StateSDVRP.demands_with_depot.scatter", "state_sdvrp.StateSDVRP._replace", "state_sdvrp.StateSDVRP.i.size", "state_sdvrp.StateSDVRP.demands_with_depot.gather", "state_sdvrp.StateSDVRP.demands_with_depot.gather"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "update", "(", "self", ",", "selected", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "i", ".", "size", "(", "0", ")", "==", "1", ",", "\"Can only update if state represents single step\"", "\n", "\n", "# Update the state", "\n", "selected", "=", "selected", "[", ":", ",", "None", "]", "# Add dimension for step", "\n", "prev_a", "=", "selected", "\n", "\n", "# Add the length", "\n", "cur_coord", "=", "self", ".", "coords", "[", "self", ".", "ids", ",", "selected", "]", "\n", "lengths", "=", "self", ".", "lengths", "+", "(", "cur_coord", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# (batch_dim, 1)", "\n", "\n", "# Not selected_demand is demand of first node (by clamp) so incorrect for nodes that visit depot!", "\n", "selected_demand", "=", "self", ".", "demands_with_depot", ".", "gather", "(", "-", "1", ",", "prev_a", "[", ":", ",", ":", ",", "None", "]", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "delivered_demand", "=", "torch", ".", "min", "(", "selected_demand", ",", "self", ".", "VEHICLE_CAPACITY", "-", "self", ".", "used_capacity", ")", "\n", "\n", "# Increase capacity if depot is not visited, otherwise set to 0", "\n", "#used_capacity = torch.where(selected == 0, 0, self.used_capacity + delivered_demand)", "\n", "used_capacity", "=", "(", "self", ".", "used_capacity", "+", "delivered_demand", ")", "*", "(", "prev_a", "!=", "0", ")", ".", "float", "(", ")", "\n", "\n", "# demands_with_depot = demands_with_depot.clone()[:, 0, :]", "\n", "# Add one dimension since we write a single value", "\n", "demands_with_depot", "=", "self", ".", "demands_with_depot", ".", "scatter", "(", "\n", "-", "1", ",", "\n", "prev_a", "[", ":", ",", ":", ",", "None", "]", ",", "\n", "self", ".", "demands_with_depot", ".", "gather", "(", "-", "1", ",", "prev_a", "[", ":", ",", ":", ",", "None", "]", ")", "-", "delivered_demand", "[", ":", ",", ":", ",", "None", "]", "\n", ")", "\n", "\n", "return", "self", ".", "_replace", "(", "\n", "prev_a", "=", "prev_a", ",", "used_capacity", "=", "used_capacity", ",", "demands_with_depot", "=", "demands_with_depot", ",", "\n", "lengths", "=", "lengths", ",", "cur_coord", "=", "cur_coord", ",", "i", "=", "self", ".", "i", "+", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_sdvrp.StateSDVRP.all_finished": [[98, 100], ["state_sdvrp.StateSDVRP.i.item", "state_sdvrp.StateSDVRP.demands_with_depot.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "all_finished", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "i", ".", "item", "(", ")", ">=", "self", ".", "demands_with_depot", ".", "size", "(", "-", "1", ")", "and", "not", "(", "self", ".", "demands_with_depot", ">", "0", ")", ".", "any", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_sdvrp.StateSDVRP.get_current_node": [[101, 103], ["None"], "methods", ["None"], ["", "def", "get_current_node", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "prev_a", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_sdvrp.StateSDVRP.get_mask": [[104, 118], ["torch.cat"], "methods", ["None"], ["", "def", "get_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Gets a (batch_size, n_loc + 1) mask with the feasible actions (0 = depot), depends on already visited and\n        remaining capacity. 0 = feasible, 1 = infeasible\n        Forbids to visit depot twice in a row, unless all nodes have been visited\n        :return:\n        \"\"\"", "\n", "\n", "# Nodes that cannot be visited are already visited or too much demand to be served now", "\n", "mask_loc", "=", "(", "self", ".", "demands_with_depot", "[", ":", ",", ":", ",", "1", ":", "]", "==", "0", ")", "|", "(", "self", ".", "used_capacity", "[", ":", ",", ":", ",", "None", "]", ">=", "self", ".", "VEHICLE_CAPACITY", ")", "\n", "\n", "# Cannot visit the depot if just visited and still unserved nodes", "\n", "mask_depot", "=", "(", "self", ".", "prev_a", "==", "0", ")", "&", "(", "(", "mask_loc", "==", "0", ")", ".", "int", "(", ")", ".", "sum", "(", "-", "1", ")", ">", "0", ")", "\n", "return", "torch", ".", "cat", "(", "(", "mask_depot", "[", ":", ",", ":", ",", "None", "]", ",", "mask_loc", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_sdvrp.StateSDVRP.construct_solutions": [[119, 121], ["None"], "methods", ["None"], ["", "def", "construct_solutions", "(", "self", ",", "actions", ")", ":", "\n", "        ", "return", "actions", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.CVRP.get_costs": [[17, 58], ["dataset[].size", "torch.cat", "torch.cat.gather", "torch.zeros_like", "range", "torch.cat", "torch.cat.gather", "pi.data.sort", "pi.size", "pi[].expand", "torch.full_like", "torch.cat.size", "pi.size", "torch.arange().view().expand", "torch.arange().view", "torch.arange", "pi.data.new"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand"], ["@", "staticmethod", "\n", "def", "get_costs", "(", "dataset", ",", "pi", ",", "return_local", "=", "False", ")", ":", "\n", "\n", "\n", "        ", "batch_size", ",", "graph_size", "=", "dataset", "[", "'demand'", "]", ".", "size", "(", ")", "\n", "# Check that tours are valid, i.e. contain 0 to n -1", "\n", "sorted_pi", "=", "pi", ".", "data", ".", "sort", "(", "1", ")", "[", "0", "]", "\n", "\n", "# Sorting it should give all zeros at front and then 1...n", "\n", "assert", "(", "\n", "torch", ".", "arange", "(", "1", ",", "graph_size", "+", "1", ",", "out", "=", "pi", ".", "data", ".", "new", "(", ")", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand", "(", "batch_size", ",", "graph_size", ")", "==", "\n", "sorted_pi", "[", ":", ",", "-", "graph_size", ":", "]", "\n", ")", ".", "all", "(", ")", "and", "(", "sorted_pi", "[", ":", ",", ":", "-", "graph_size", "]", "==", "0", ")", ".", "all", "(", ")", ",", "\"Invalid tour\"", "\n", "\n", "# Visiting depot resets capacity so we add demand = -capacity (we make sure it does not become negative)", "\n", "demand_with_depot", "=", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "full_like", "(", "dataset", "[", "'demand'", "]", "[", ":", ",", ":", "1", "]", ",", "-", "CVRP", ".", "VEHICLE_CAPACITY", ")", ",", "\n", "dataset", "[", "'demand'", "]", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "d", "=", "demand_with_depot", ".", "gather", "(", "1", ",", "pi", ")", "\n", "\n", "used_cap", "=", "torch", ".", "zeros_like", "(", "dataset", "[", "'demand'", "]", "[", ":", ",", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "pi", ".", "size", "(", "1", ")", ")", ":", "\n", "            ", "used_cap", "+=", "d", "[", ":", ",", "i", "]", "# This will reset/make capacity negative if i == 0, e.g. depot visited", "\n", "# Cannot use less than 0", "\n", "used_cap", "[", "used_cap", "<", "0", "]", "=", "0", "\n", "assert", "(", "used_cap", "<=", "CVRP", ".", "VEHICLE_CAPACITY", "+", "1e-5", ")", ".", "all", "(", ")", ",", "\"Used more than capacity\"", "\n", "\n", "# Gather dataset in order of tour", "\n", "", "loc_with_depot", "=", "torch", ".", "cat", "(", "(", "dataset", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "dataset", "[", "'loc'", "]", ")", ",", "1", ")", "\n", "d", "=", "loc_with_depot", ".", "gather", "(", "1", ",", "pi", "[", "...", ",", "None", "]", ".", "expand", "(", "*", "pi", ".", "size", "(", ")", ",", "loc_with_depot", ".", "size", "(", "-", "1", ")", ")", ")", "\n", "\n", "# Length is distance (L2-norm of difference) of each next location to its prev and of first and last to depot", "\n", "return", "(", "\n", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "2", ")", ".", "sum", "(", "1", ")", "\n", "+", "(", "d", "[", ":", ",", "0", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", "# Depot to first", "\n", "+", "(", "d", "[", ":", ",", "-", "1", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", "# Last to depot, will be 0 if depot is last", "\n", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.CVRP.make_dataset": [[59, 62], ["problem_vrp.VRPDataset"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_dataset", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "VRPDataset", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.CVRP.make_state": [[63, 66], ["problems.vrp.state_cvrp.StateCVRP.initialize"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize"], ["", "@", "staticmethod", "\n", "def", "make_state", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "StateCVRP", ".", "initialize", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.CVRP.beam_search": [[67, 85], ["model.precompute_fixed", "problem_vrp.CVRP.make_state", "utils.beam_search.beam_search", "model.propose_expansions"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.precompute_fixed", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions"], ["", "@", "staticmethod", "\n", "def", "beam_search", "(", "input", ",", "beam_size", ",", "expand_size", "=", "None", ",", "\n", "compress_mask", "=", "False", ",", "model", "=", "None", ",", "max_calc_batch_size", "=", "4096", ")", ":", "\n", "\n", "        ", "assert", "model", "is", "not", "None", ",", "\"Provide model\"", "\n", "\n", "fixed", "=", "model", ".", "precompute_fixed", "(", "input", ")", "\n", "\n", "def", "propose_expansions", "(", "beam", ")", ":", "\n", "            ", "return", "model", ".", "propose_expansions", "(", "\n", "beam", ",", "fixed", ",", "expand_size", ",", "normalize", "=", "True", ",", "max_calc_batch_size", "=", "max_calc_batch_size", "\n", ")", "\n", "\n", "", "state", "=", "CVRP", ".", "make_state", "(", "\n", "input", ",", "visited_dtype", "=", "torch", ".", "int64", "if", "compress_mask", "else", "torch", ".", "uint8", "\n", ")", "\n", "\n", "return", "beam_search", "(", "state", ",", "beam_size", ",", "propose_expansions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.SDVRP.get_costs": [[93, 129], ["dataset[].size", "torch.cat", "torch.arange", "torch.zeros_like", "pi.transpose", "torch.cat", "torch.cat.gather", "torch.min", "pi[].expand", "torch.full_like", "torch.cat.data.new().long", "torch.cat.size", "pi.size", "torch.cat.data.new"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["@", "staticmethod", "\n", "def", "get_costs", "(", "dataset", ",", "pi", ")", ":", "\n", "        ", "batch_size", ",", "graph_size", "=", "dataset", "[", "'demand'", "]", ".", "size", "(", ")", "\n", "\n", "# Each node can be visited multiple times, but we always deliver as much demand as possible", "\n", "# We check that at the end all demand has been satisfied", "\n", "demands", "=", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "full_like", "(", "dataset", "[", "'demand'", "]", "[", ":", ",", ":", "1", "]", ",", "-", "SDVRP", ".", "VEHICLE_CAPACITY", ")", ",", "\n", "dataset", "[", "'demand'", "]", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "rng", "=", "torch", ".", "arange", "(", "batch_size", ",", "out", "=", "demands", ".", "data", ".", "new", "(", ")", ".", "long", "(", ")", ")", "\n", "used_cap", "=", "torch", ".", "zeros_like", "(", "dataset", "[", "'demand'", "]", "[", ":", ",", "0", "]", ")", "\n", "a_prev", "=", "None", "\n", "for", "a", "in", "pi", ".", "transpose", "(", "0", ",", "1", ")", ":", "\n", "            ", "assert", "a_prev", "is", "None", "or", "(", "demands", "[", "(", "(", "a_prev", "==", "0", ")", "&", "(", "a", "==", "0", ")", ")", ",", ":", "]", "==", "0", ")", ".", "all", "(", ")", ",", "\"Cannot visit depot twice if any nonzero demand\"", "\n", "d", "=", "torch", ".", "min", "(", "demands", "[", "rng", ",", "a", "]", ",", "SDVRP", ".", "VEHICLE_CAPACITY", "-", "used_cap", ")", "\n", "demands", "[", "rng", ",", "a", "]", "-=", "d", "\n", "used_cap", "+=", "d", "\n", "used_cap", "[", "a", "==", "0", "]", "=", "0", "\n", "a_prev", "=", "a", "\n", "", "assert", "(", "demands", "==", "0", ")", ".", "all", "(", ")", ",", "\"All demand must be satisfied\"", "\n", "\n", "# Gather dataset in order of tour", "\n", "loc_with_depot", "=", "torch", ".", "cat", "(", "(", "dataset", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "dataset", "[", "'loc'", "]", ")", ",", "1", ")", "\n", "d", "=", "loc_with_depot", ".", "gather", "(", "1", ",", "pi", "[", "...", ",", "None", "]", ".", "expand", "(", "*", "pi", ".", "size", "(", ")", ",", "loc_with_depot", ".", "size", "(", "-", "1", ")", ")", ")", "\n", "\n", "# Length is distance (L2-norm of difference) of each next location to its prev and of first and last to depot", "\n", "return", "(", "\n", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "2", ")", ".", "sum", "(", "1", ")", "\n", "+", "(", "d", "[", ":", ",", "0", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", "# Depot to first", "\n", "+", "(", "d", "[", ":", ",", "-", "1", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", "# Last to depot, will be 0 if depot is last", "\n", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.SDVRP.make_dataset": [[130, 133], ["problem_vrp.VRPDataset"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_dataset", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "VRPDataset", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.SDVRP.make_state": [[134, 137], ["problems.vrp.state_sdvrp.StateSDVRP.initialize"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize"], ["", "@", "staticmethod", "\n", "def", "make_state", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "StateSDVRP", ".", "initialize", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.SDVRP.beam_search": [[138, 154], ["model.precompute_fixed", "problem_vrp.SDVRP.make_state", "utils.beam_search.beam_search", "model.propose_expansions"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.precompute_fixed", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions"], ["", "@", "staticmethod", "\n", "def", "beam_search", "(", "input", ",", "beam_size", ",", "expand_size", "=", "None", ",", "\n", "compress_mask", "=", "False", ",", "model", "=", "None", ",", "max_calc_batch_size", "=", "4096", ")", ":", "\n", "        ", "assert", "model", "is", "not", "None", ",", "\"Provide model\"", "\n", "assert", "not", "compress_mask", ",", "\"SDVRP does not support compression of the mask\"", "\n", "\n", "fixed", "=", "model", ".", "precompute_fixed", "(", "input", ")", "\n", "\n", "def", "propose_expansions", "(", "beam", ")", ":", "\n", "            ", "return", "model", ".", "propose_expansions", "(", "\n", "beam", ",", "fixed", ",", "expand_size", ",", "normalize", "=", "True", ",", "max_calc_batch_size", "=", "max_calc_batch_size", "\n", ")", "\n", "\n", "", "state", "=", "SDVRP", ".", "make_state", "(", "input", ")", "\n", "\n", "return", "beam_search", "(", "state", ",", "beam_size", ",", "propose_expansions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.VRPDataset.__init__": [[170, 202], ["torch.utils.data.Dataset.__init__", "len", "open", "pickle.load", "problem_vrp.make_instance", "os.path.splitext", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "range", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor().uniform_().int", "torch.FloatTensor().uniform_", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.make_instance"], ["    ", "def", "__init__", "(", "self", ",", "filename", "=", "None", ",", "size", "=", "50", ",", "num_samples", "=", "1000000", ",", "offset", "=", "0", ",", "distribution", "=", "None", ")", ":", "\n", "        ", "super", "(", "VRPDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "data_set", "=", "[", "]", "\n", "if", "filename", "is", "not", "None", ":", "\n", "            ", "assert", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "==", "'.pkl'", "\n", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "self", ".", "data", "=", "[", "make_instance", "(", "args", ")", "for", "args", "in", "data", "[", "offset", ":", "offset", "+", "num_samples", "]", "]", "\n", "\n", "", "else", ":", "\n", "\n", "# From VRP with RL paper https://arxiv.org/abs/1802.04240", "\n", "            ", "CAPACITIES", "=", "{", "\n", "10", ":", "20.", ",", "\n", "20", ":", "30.", ",", "\n", "50", ":", "40.", ",", "\n", "100", ":", "50.", "\n", "}", "\n", "\n", "self", ".", "data", "=", "[", "\n", "{", "\n", "'loc'", ":", "torch", ".", "FloatTensor", "(", "size", ",", "2", ")", ".", "uniform_", "(", "0", ",", "1", ")", ",", "\n", "# Uniform 1 - 9, scaled by capacities", "\n", "'demand'", ":", "(", "torch", ".", "FloatTensor", "(", "size", ")", ".", "uniform_", "(", "0", ",", "9", ")", ".", "int", "(", ")", "+", "1", ")", ".", "float", "(", ")", "/", "CAPACITIES", "[", "size", "]", ",", "\n", "'depot'", ":", "torch", ".", "FloatTensor", "(", "2", ")", ".", "uniform_", "(", "0", ",", "1", ")", "\n", "}", "\n", "for", "i", "in", "range", "(", "num_samples", ")", "\n", "]", "\n", "\n", "", "self", ".", "size", "=", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.VRPDataset.__len__": [[203, 205], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.VRPDataset.__getitem__": [[206, 208], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "data", "[", "idx", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.problem_vrp.make_instance": [[156, 165], ["len", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "", "def", "make_instance", "(", "args", ")", ":", "\n", "    ", "depot", ",", "loc", ",", "demand", ",", "capacity", ",", "*", "args", "=", "args", "\n", "grid_size", "=", "1", "\n", "if", "len", "(", "args", ")", ">", "0", ":", "\n", "        ", "depot_types", ",", "customer_types", ",", "grid_size", "=", "args", "\n", "", "return", "{", "\n", "'loc'", ":", "torch", ".", "tensor", "(", "loc", ",", "dtype", "=", "torch", ".", "float", ")", "/", "grid_size", ",", "\n", "'demand'", ":", "torch", ".", "tensor", "(", "demand", ",", "dtype", "=", "torch", ".", "float", ")", "/", "capacity", ",", "\n", "'depot'", ":", "torch", ".", "tensor", "(", "depot", ",", "dtype", "=", "torch", ".", "float", ")", "/", "grid_size", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.visited": [[25, 31], ["utils.boolmask.mask_long2bool", "state_cvrp.StateCVRP.demand.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long2bool", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["@", "property", "\n", "def", "visited", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "            ", "return", "self", ".", "visited_", "\n", "", "else", ":", "\n", "            ", "return", "mask_long2bool", "(", "self", ".", "visited_", ",", "n", "=", "self", ".", "demand", ".", "size", "(", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.dist": [[32, 35], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "dist", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "coords", "[", ":", ",", ":", ",", "None", ",", ":", "]", "-", "self", ".", "coords", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.__getitem__": [[36, 45], ["state_cvrp.StateCVRP._replace", "torch.is_tensor", "isinstance"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "# If tensor, idx all tensors by this tensor:", "\n", "return", "self", ".", "_replace", "(", "\n", "ids", "=", "self", ".", "ids", "[", "key", "]", ",", "\n", "prev_a", "=", "self", ".", "prev_a", "[", "key", "]", ",", "\n", "used_capacity", "=", "self", ".", "used_capacity", "[", "key", "]", ",", "\n", "visited_", "=", "self", ".", "visited_", "[", "key", "]", ",", "\n", "lengths", "=", "self", ".", "lengths", "[", "key", "]", ",", "\n", "cur_coord", "=", "self", ".", "cur_coord", "[", "key", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.initialize": [[51, 77], ["loc.size", "state_cvrp.StateCVRP", "torch.cat", "torch.zeros", "demand.new_zeros", "torch.zeros", "torch.zeros", "torch.arange", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "@", "staticmethod", "\n", "def", "initialize", "(", "input", ",", "visited_dtype", "=", "torch", ".", "uint8", ")", ":", "\n", "\n", "        ", "depot", "=", "input", "[", "'depot'", "]", "\n", "loc", "=", "input", "[", "'loc'", "]", "\n", "demand", "=", "input", "[", "'demand'", "]", "\n", "\n", "batch_size", ",", "n_loc", ",", "_", "=", "loc", ".", "size", "(", ")", "\n", "return", "StateCVRP", "(", "\n", "coords", "=", "torch", ".", "cat", "(", "(", "depot", "[", ":", ",", "None", ",", ":", "]", ",", "loc", ")", ",", "-", "2", ")", ",", "\n", "demand", "=", "demand", ",", "\n", "ids", "=", "torch", ".", "arange", "(", "batch_size", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "[", ":", ",", "None", "]", ",", "# Add steps dimension", "\n", "prev_a", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "used_capacity", "=", "demand", ".", "new_zeros", "(", "batch_size", ",", "1", ")", ",", "\n", "visited_", "=", "(", "# Visited as mask is easier to understand, as long more memory efficient", "\n", "# Keep visited_ with depot so we can scatter efficiently", "\n", "torch", ".", "zeros", "(", "\n", "batch_size", ",", "1", ",", "n_loc", "+", "1", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "loc", ".", "device", "\n", ")", "\n", "if", "visited_dtype", "==", "torch", ".", "uint8", "\n", "else", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "(", "n_loc", "+", "63", ")", "//", "64", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Ceil", "\n", ")", ",", "\n", "lengths", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "cur_coord", "=", "input", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "# Add step dimension", "\n", "i", "=", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Vector with length num_steps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.get_final_cost": [[79, 84], ["state_cvrp.StateCVRP.all_finished"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished"], ["", "def", "get_final_cost", "(", "self", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "all_finished", "(", ")", "\n", "\n", "return", "self", ".", "lengths", "+", "(", "self", ".", "coords", "[", "self", ".", "ids", ",", "0", ",", ":", "]", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.update": [[85, 121], ["state_cvrp.StateCVRP.demand.size", "state_cvrp.StateCVRP._replace", "state_cvrp.StateCVRP.i.size", "state_cvrp.StateCVRP.visited_.scatter", "utils.boolmask.mask_long_scatter", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long_scatter"], ["", "def", "update", "(", "self", ",", "selected", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "i", ".", "size", "(", "0", ")", "==", "1", ",", "\"Can only update if state represents single step\"", "\n", "\n", "# Update the state", "\n", "selected", "=", "selected", "[", ":", ",", "None", "]", "# Add dimension for step", "\n", "prev_a", "=", "selected", "\n", "n_loc", "=", "self", ".", "demand", ".", "size", "(", "-", "1", ")", "# Excludes depot", "\n", "\n", "# Add the length", "\n", "cur_coord", "=", "self", ".", "coords", "[", "self", ".", "ids", ",", "selected", "]", "\n", "# cur_coord = self.coords.gather(", "\n", "#     1,", "\n", "#     selected[:, None].expand(selected.size(0), 1, self.coords.size(-1))", "\n", "# )[:, 0, :]", "\n", "lengths", "=", "self", ".", "lengths", "+", "(", "cur_coord", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# (batch_dim, 1)", "\n", "\n", "# Not selected_demand is demand of first node (by clamp) so incorrect for nodes that visit depot!", "\n", "#selected_demand = self.demand.gather(-1, torch.clamp(prev_a - 1, 0, n_loc - 1))", "\n", "selected_demand", "=", "self", ".", "demand", "[", "self", ".", "ids", ",", "torch", ".", "clamp", "(", "prev_a", "-", "1", ",", "0", ",", "n_loc", "-", "1", ")", "]", "\n", "\n", "# Increase capacity if depot is not visited, otherwise set to 0", "\n", "#used_capacity = torch.where(selected == 0, 0, self.used_capacity + selected_demand)", "\n", "used_capacity", "=", "(", "self", ".", "used_capacity", "+", "selected_demand", ")", "*", "(", "prev_a", "!=", "0", ")", ".", "float", "(", ")", "\n", "\n", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "# Note: here we do not subtract one as we have to scatter so the first column allows scattering depot", "\n", "# Add one dimension since we write a single value", "\n", "            ", "visited_", "=", "self", ".", "visited_", ".", "scatter", "(", "-", "1", ",", "prev_a", "[", ":", ",", ":", ",", "None", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "# This works, will not set anything if prev_a -1 == -1 (depot)", "\n", "            ", "visited_", "=", "mask_long_scatter", "(", "self", ".", "visited_", ",", "prev_a", "-", "1", ")", "\n", "\n", "", "return", "self", ".", "_replace", "(", "\n", "prev_a", "=", "prev_a", ",", "used_capacity", "=", "used_capacity", ",", "visited_", "=", "visited_", ",", "\n", "lengths", "=", "lengths", ",", "cur_coord", "=", "cur_coord", ",", "i", "=", "self", ".", "i", "+", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.all_finished": [[123, 125], ["state_cvrp.StateCVRP.visited.all", "state_cvrp.StateCVRP.i.item", "state_cvrp.StateCVRP.demand.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "all_finished", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "i", ".", "item", "(", ")", ">=", "self", ".", "demand", ".", "size", "(", "-", "1", ")", "and", "self", ".", "visited", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.get_finished": [[126, 128], ["state_cvrp.StateCVRP.visited.sum", "state_cvrp.StateCVRP.visited.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "get_finished", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "visited", ".", "sum", "(", "-", "1", ")", "==", "self", ".", "visited", ".", "size", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.get_current_node": [[129, 131], ["None"], "methods", ["None"], ["", "def", "get_current_node", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "prev_a", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.get_mask": [[132, 153], ["torch.cat", "utils.boolmask.mask_long2bool", "utils.boolmask.mask_long2bool.to", "state_cvrp.StateCVRP.demand.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long2bool", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "get_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Gets a (batch_size, n_loc + 1) mask with the feasible actions (0 = depot), depends on already visited and\n        remaining capacity. 0 = feasible, 1 = infeasible\n        Forbids to visit depot twice in a row, unless all nodes have been visited\n        :return:\n        \"\"\"", "\n", "\n", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "            ", "visited_loc", "=", "self", ".", "visited_", "[", ":", ",", ":", ",", "1", ":", "]", "\n", "", "else", ":", "\n", "            ", "visited_loc", "=", "mask_long2bool", "(", "self", ".", "visited_", ",", "n", "=", "self", ".", "demand", ".", "size", "(", "-", "1", ")", ")", "\n", "\n", "# For demand steps_dim is inserted by indexing with id, for used_capacity insert node dim for broadcasting", "\n", "", "exceeds_cap", "=", "(", "self", ".", "demand", "[", "self", ".", "ids", ",", ":", "]", "+", "self", ".", "used_capacity", "[", ":", ",", ":", ",", "None", "]", ">", "self", ".", "VEHICLE_CAPACITY", ")", "\n", "# Nodes that cannot be visited are already visited or too much demand to be served now", "\n", "mask_loc", "=", "visited_loc", ".", "to", "(", "exceeds_cap", ".", "dtype", ")", "|", "exceeds_cap", "\n", "\n", "# Cannot visit the depot if just visited and still unserved nodes", "\n", "mask_depot", "=", "(", "self", ".", "prev_a", "==", "0", ")", "&", "(", "(", "mask_loc", "==", "0", ")", ".", "int", "(", ")", ".", "sum", "(", "-", "1", ")", ">", "0", ")", "\n", "return", "torch", ".", "cat", "(", "(", "mask_depot", "[", ":", ",", ":", ",", "None", "]", ",", "mask_loc", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.construct_solutions": [[154, 156], ["None"], "methods", ["None"], ["", "def", "construct_solutions", "(", "self", ",", "actions", ")", ":", "\n", "        ", "return", "actions", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.__init__": [[105, 140], ["tensorflow.contrib.layers.xavier_initializer", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.placeholder", "tensorflow.summary.merge_all", "tensorflow.variable_scope", "Neural_Reinforce.Actor.encode_decode", "tensorflow.variable_scope", "Neural_Reinforce.Actor.build_critic", "tensorflow.variable_scope", "Neural_Reinforce.Actor.build_reward", "tensorflow.variable_scope", "Neural_Reinforce.Actor.build_optim"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.encode_decode", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.build_critic", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.build_reward", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.build_optim"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "\n", "# Data config", "\n", "        ", "self", ".", "batch_size", "=", "config", ".", "batch_size", "# batch size", "\n", "self", ".", "max_length", "=", "config", ".", "max_length", "# input sequence length (number of cities)", "\n", "self", ".", "dimension", "=", "config", ".", "dimension", "# dimension of a city (coordinates)", "\n", "self", ".", "greedy", "=", "config", ".", "greedy", "# whether to use greedy decoding", "\n", "\n", "# Network config", "\n", "self", ".", "input_embed", "=", "config", ".", "input_embed", "# dimension of embedding space", "\n", "self", ".", "num_neurons", "=", "config", ".", "num_neurons", "# dimension of hidden states (encoder)", "\n", "self", ".", "num_stacks", "=", "config", ".", "num_stacks", "# encoder num stacks", "\n", "self", ".", "num_heads", "=", "config", ".", "num_heads", "# encoder num heads", "\n", "self", ".", "query_dim", "=", "config", ".", "query_dim", "# decoder query space dimension", "\n", "self", ".", "num_units", "=", "config", ".", "num_units", "# dimension of attention product space (decoder and critic)", "\n", "self", ".", "num_neurons_critic", "=", "config", ".", "num_neurons_critic", "# critic n-1 layer num neurons", "\n", "self", ".", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", "# variables initializer", "\n", "\n", "# Training config (actor and critic)", "\n", "self", ".", "global_step", "=", "tf", ".", "Variable", "(", "0", ",", "trainable", "=", "False", ",", "name", "=", "\"global_step\"", ")", "# actor global step", "\n", "self", ".", "global_step2", "=", "tf", ".", "Variable", "(", "0", ",", "trainable", "=", "False", ",", "name", "=", "\"global_step2\"", ")", "# critic global step", "\n", "self", ".", "init_B", "=", "config", ".", "init_B", "# critic initial baseline", "\n", "self", ".", "lr_start", "=", "config", ".", "lr_start", "# initial learning rate", "\n", "self", ".", "lr_decay_step", "=", "config", ".", "lr_decay_step", "# learning rate decay step", "\n", "self", ".", "lr_decay_rate", "=", "config", ".", "lr_decay_rate", "# learning rate decay rate", "\n", "self", ".", "is_training", "=", "config", ".", "is_training", "# swith to False if test mode", "\n", "\n", "# Tensor block holding the input sequences [Batch Size, Sequence Length, Features]", "\n", "self", ".", "input_", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "None", ",", "self", ".", "max_length", ",", "self", ".", "dimension", "]", ",", "name", "=", "\"input_coordinates\"", ")", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "\"actor\"", ")", ":", "self", ".", "encode_decode", "(", ")", "\n", "with", "tf", ".", "variable_scope", "(", "\"critic\"", ")", ":", "self", ".", "build_critic", "(", ")", "\n", "with", "tf", ".", "variable_scope", "(", "\"environment\"", ")", ":", "self", ".", "build_reward", "(", ")", "\n", "with", "tf", ".", "variable_scope", "(", "\"optimizer\"", ")", ":", "self", ".", "build_optim", "(", ")", "\n", "self", ".", "merged", "=", "tf", ".", "summary", ".", "merge_all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.encode_decode": [[142, 187], ["utils.embed_seq", "utils.encode_seq", "tensorflow.zeros", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.nn.conv1d", "tensorflow.zeros", "tensorflow.zeros", "tensorflow.zeros", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "range", "idx_list.append", "tensorflow.stack", "tensorflow.add_n", "tensorflow.add_n", "tensorflow.summary.scalar", "tensorflow.summary.scalar", "tensorflow.tile", "tensorflow.tile.get_shape().as_list", "tensorflow.nn.relu", "utils.pointer", "distr.Categorical", "idx_list.append", "log_probs.append", "entropies.append", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "distr.Categorical.mode", "distr.Categorical.sample", "distr.Categorical.log_prob", "distr.Categorical.entropy", "tensorflow.one_hot", "tensorflow.tile.get_shape", "tensorflow.matmul", "tensorflow.range", "tensorflow.matmul", "tensorflow.matmul"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.embed_seq", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.encode_seq", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.pointer"], ["", "def", "encode_decode", "(", "self", ")", ":", "\n", "        ", "actor_embedding", "=", "embed_seq", "(", "input_seq", "=", "self", ".", "input_", ",", "from_", "=", "self", ".", "dimension", ",", "to_", "=", "self", ".", "input_embed", ",", "is_training", "=", "self", ".", "is_training", ",", "BN", "=", "True", ",", "initializer", "=", "self", ".", "initializer", ")", "\n", "actor_encoding", "=", "encode_seq", "(", "input_seq", "=", "actor_embedding", ",", "input_dim", "=", "self", ".", "input_embed", ",", "num_stacks", "=", "self", ".", "num_stacks", ",", "num_heads", "=", "self", ".", "num_heads", ",", "num_neurons", "=", "self", ".", "num_neurons", ",", "is_training", "=", "self", ".", "is_training", ")", "\n", "if", "self", ".", "is_training", "==", "False", ":", "\n", "            ", "actor_encoding", "=", "tf", ".", "tile", "(", "actor_encoding", ",", "[", "self", ".", "batch_size", ",", "1", ",", "1", "]", ")", "\n", "\n", "", "idx_list", ",", "log_probs", ",", "entropies", "=", "[", "]", ",", "[", "]", ",", "[", "]", "# tours index, log_probs, entropies", "\n", "mask", "=", "tf", ".", "zeros", "(", "(", "self", ".", "batch_size", ",", "self", ".", "max_length", ")", ")", "# mask for actions", "\n", "\n", "n_hidden", "=", "actor_encoding", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "2", "]", "# input_embed", "\n", "W_ref", "=", "tf", ".", "get_variable", "(", "\"W_ref\"", ",", "[", "1", ",", "n_hidden", ",", "self", ".", "num_units", "]", ",", "initializer", "=", "self", ".", "initializer", ")", "\n", "W_q", "=", "tf", ".", "get_variable", "(", "\"W_q\"", ",", "[", "self", ".", "query_dim", ",", "self", ".", "num_units", "]", ",", "initializer", "=", "self", ".", "initializer", ")", "\n", "v", "=", "tf", ".", "get_variable", "(", "\"v\"", ",", "[", "self", ".", "num_units", "]", ",", "initializer", "=", "self", ".", "initializer", ")", "\n", "\n", "encoded_ref", "=", "tf", ".", "nn", ".", "conv1d", "(", "actor_encoding", ",", "W_ref", ",", "1", ",", "\"VALID\"", ")", "# actor_encoding is the ref for actions [Batch size, seq_length, n_hidden]", "\n", "query1", "=", "tf", ".", "zeros", "(", "(", "self", ".", "batch_size", ",", "n_hidden", ")", ")", "# initial state", "\n", "query2", "=", "tf", ".", "zeros", "(", "(", "self", ".", "batch_size", ",", "n_hidden", ")", ")", "# previous state", "\n", "query3", "=", "tf", ".", "zeros", "(", "(", "self", ".", "batch_size", ",", "n_hidden", ")", ")", "# previous previous state", "\n", "\n", "W_1", "=", "tf", ".", "get_variable", "(", "\"W_1\"", ",", "[", "n_hidden", ",", "self", ".", "query_dim", "]", ",", "initializer", "=", "self", ".", "initializer", ")", "# update trajectory (state)", "\n", "W_2", "=", "tf", ".", "get_variable", "(", "\"W_2\"", ",", "[", "n_hidden", ",", "self", ".", "query_dim", "]", ",", "initializer", "=", "self", ".", "initializer", ")", "\n", "W_3", "=", "tf", ".", "get_variable", "(", "\"W_3\"", ",", "[", "n_hidden", ",", "self", ".", "query_dim", "]", ",", "initializer", "=", "self", ".", "initializer", ")", "\n", "\n", "for", "step", "in", "range", "(", "self", ".", "max_length", ")", ":", "# sample from POINTER      ", "\n", "            ", "query", "=", "tf", ".", "nn", ".", "relu", "(", "tf", ".", "matmul", "(", "query1", ",", "W_1", ")", "+", "tf", ".", "matmul", "(", "query2", ",", "W_2", ")", "+", "tf", ".", "matmul", "(", "query3", ",", "W_3", ")", ")", "\n", "logits", "=", "pointer", "(", "encoded_ref", "=", "encoded_ref", ",", "query", "=", "query", ",", "mask", "=", "mask", ",", "W_ref", "=", "W_ref", ",", "W_q", "=", "W_q", ",", "v", "=", "v", ",", "C", "=", "config", ".", "C", ",", "temperature", "=", "config", ".", "temperature", ")", "\n", "prob", "=", "distr", ".", "Categorical", "(", "logits", ")", "# logits = masked_scores", "\n", "idx", "=", "prob", ".", "mode", "(", ")", "if", "self", ".", "greedy", "else", "prob", ".", "sample", "(", ")", "\n", "\n", "idx_list", ".", "append", "(", "idx", ")", "# tour index", "\n", "log_probs", ".", "append", "(", "prob", ".", "log_prob", "(", "idx", ")", ")", "# log prob", "\n", "entropies", ".", "append", "(", "prob", ".", "entropy", "(", ")", ")", "# entropies", "\n", "mask", "=", "mask", "+", "tf", ".", "one_hot", "(", "idx", ",", "self", ".", "max_length", ")", "# mask", "\n", "\n", "idx_", "=", "tf", ".", "stack", "(", "[", "tf", ".", "range", "(", "self", ".", "batch_size", ",", "dtype", "=", "tf", ".", "int32", ")", ",", "idx", "]", ",", "1", ")", "# idx with batch   ", "\n", "query3", "=", "query2", "\n", "query2", "=", "query1", "\n", "query1", "=", "tf", ".", "gather_nd", "(", "actor_encoding", ",", "idx_", ")", "# update trajectory (state)", "\n", "\n", "", "idx_list", ".", "append", "(", "idx_list", "[", "0", "]", ")", "# return to start", "\n", "self", ".", "tour", "=", "tf", ".", "stack", "(", "idx_list", ",", "axis", "=", "1", ")", "# permutations", "\n", "self", ".", "log_prob", "=", "tf", ".", "add_n", "(", "log_probs", ")", "# corresponding log-probability for backprop", "\n", "self", ".", "entropies", "=", "tf", ".", "add_n", "(", "entropies", ")", "\n", "tf", ".", "summary", ".", "scalar", "(", "'log_prob_mean'", ",", "tf", ".", "reduce_mean", "(", "self", ".", "log_prob", ")", ")", "\n", "tf", ".", "summary", ".", "scalar", "(", "'entropies_mean'", ",", "tf", ".", "reduce_mean", "(", "self", ".", "entropies", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.build_reward": [[189, 206], ["tensorflow.stack", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.sqrt", "tensorflow.reduce_sum", "tensorflow.cast", "tensorflow.summary.scalar", "tensorflow.gather_nd", "tensorflow.gather_nd", "tensorflow.square", "tensorflow.square", "tensorflow.reduce_mean", "tensorflow.tile", "tensorflow.tile", "tensorflow.expand_dims", "tensorflow.range"], "methods", ["None"], ["", "def", "build_reward", "(", "self", ")", ":", "# reorder input % tour and return tour length (euclidean distance)", "\n", "        ", "self", ".", "permutations", "=", "tf", ".", "stack", "(", "[", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "tf", ".", "range", "(", "self", ".", "batch_size", ",", "dtype", "=", "tf", ".", "int32", ")", ",", "1", ")", ",", "[", "1", ",", "self", ".", "max_length", "+", "1", "]", ")", ",", "self", ".", "tour", "]", ",", "2", ")", "\n", "if", "self", ".", "is_training", "==", "True", ":", "\n", "            ", "self", ".", "ordered_input_", "=", "tf", ".", "gather_nd", "(", "self", ".", "input_", ",", "self", ".", "permutations", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "ordered_input_", "=", "tf", ".", "gather_nd", "(", "tf", ".", "tile", "(", "self", ".", "input_", ",", "[", "self", ".", "batch_size", ",", "1", ",", "1", "]", ")", ",", "self", ".", "permutations", ")", "\n", "", "self", ".", "ordered_input_", "=", "tf", ".", "transpose", "(", "self", ".", "ordered_input_", ",", "[", "2", ",", "1", ",", "0", "]", ")", "# [features, seq length +1, batch_size]   Rq: +1 because end = start    ", "\n", "\n", "ordered_x_", "=", "self", ".", "ordered_input_", "[", "0", "]", "# ordered x, y coordinates [seq length +1, batch_size]", "\n", "ordered_y_", "=", "self", ".", "ordered_input_", "[", "1", "]", "# ordered y coordinates [seq length +1, batch_size]          ", "\n", "delta_x2", "=", "tf", ".", "transpose", "(", "tf", ".", "square", "(", "ordered_x_", "[", "1", ":", "]", "-", "ordered_x_", "[", ":", "-", "1", "]", ")", ",", "[", "1", ",", "0", "]", ")", "# [batch_size, seq length]        delta_x**2", "\n", "delta_y2", "=", "tf", ".", "transpose", "(", "tf", ".", "square", "(", "ordered_y_", "[", "1", ":", "]", "-", "ordered_y_", "[", ":", "-", "1", "]", ")", ",", "[", "1", ",", "0", "]", ")", "# [batch_size, seq length]        delta_y**2", "\n", "\n", "inter_city_distances", "=", "tf", ".", "sqrt", "(", "delta_x2", "+", "delta_y2", ")", "# sqrt(delta_x**2 + delta_y**2) this is the euclidean distance between each city: depot --> ... ---> depot      [batch_size, seq length]", "\n", "self", ".", "distances", "=", "tf", ".", "reduce_sum", "(", "inter_city_distances", ",", "axis", "=", "1", ")", "# [batch_size]", "\n", "self", ".", "reward", "=", "tf", ".", "cast", "(", "self", ".", "distances", ",", "tf", ".", "float32", ")", "# define reward from tour length  ", "\n", "tf", ".", "summary", ".", "scalar", "(", "'reward_mean'", ",", "tf", ".", "reduce_mean", "(", "self", ".", "reward", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.build_critic": [[208, 219], ["utils.embed_seq", "utils.encode_seq", "utils.full_glimpse", "tensorflow.variable_scope", "tensorflow.layers.dense", "tensorflow.get_variable", "tensorflow.Variable", "tensorflow.squeeze", "tensorflow.summary.scalar", "tensorflow.contrib.layers.xavier_initializer", "tensorflow.reduce_mean", "tensorflow.matmul"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.embed_seq", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.encode_seq", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.full_glimpse"], ["", "def", "build_critic", "(", "self", ")", ":", "\n", "        ", "critic_embedding", "=", "embed_seq", "(", "input_seq", "=", "self", ".", "input_", ",", "from_", "=", "self", ".", "dimension", ",", "to_", "=", "self", ".", "input_embed", ",", "is_training", "=", "self", ".", "is_training", ",", "BN", "=", "True", ",", "initializer", "=", "self", ".", "initializer", ")", "\n", "critic_encoding", "=", "encode_seq", "(", "input_seq", "=", "critic_embedding", ",", "input_dim", "=", "self", ".", "input_embed", ",", "num_stacks", "=", "self", ".", "num_stacks", ",", "num_heads", "=", "self", ".", "num_heads", ",", "num_neurons", "=", "self", ".", "num_neurons", ",", "is_training", "=", "self", ".", "is_training", ")", "\n", "frame", "=", "full_glimpse", "(", "ref", "=", "critic_encoding", ",", "from_", "=", "self", ".", "input_embed", ",", "to_", "=", "self", ".", "num_units", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ")", "# Glimpse on critic_encoding [Batch_size, input_embed]", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "\"ffn\"", ")", ":", "#  2 dense layers for predictions", "\n", "            ", "h0", "=", "tf", ".", "layers", ".", "dense", "(", "frame", ",", "self", ".", "num_neurons_critic", ",", "activation", "=", "tf", ".", "nn", ".", "relu", ",", "kernel_initializer", "=", "self", ".", "initializer", ")", "\n", "w1", "=", "tf", ".", "get_variable", "(", "\"w1\"", ",", "[", "self", ".", "num_neurons_critic", ",", "1", "]", ",", "initializer", "=", "self", ".", "initializer", ")", "\n", "b1", "=", "tf", ".", "Variable", "(", "self", ".", "init_B", ",", "name", "=", "\"b1\"", ")", "\n", "self", ".", "predictions", "=", "tf", ".", "squeeze", "(", "tf", ".", "matmul", "(", "h0", ",", "w1", ")", "+", "b1", ")", "\n", "tf", ".", "summary", ".", "scalar", "(", "'predictions_mean'", ",", "tf", ".", "reduce_mean", "(", "self", ".", "predictions", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.Actor.build_optim": [[220, 240], ["tensorflow.get_collection", "tensorflow.control_dependencies", "tensorflow.name_scope", "tensorflow.train.natural_exp_decay", "tensorflow.summary.scalar", "tensorflow.train.AdamOptimizer", "tensorflow.reduce_mean", "tensorflow.train.AdamOptimizer.compute_gradients", "tensorflow.train.AdamOptimizer.apply_gradients", "tensorflow.name_scope", "tensorflow.train.natural_exp_decay", "tensorflow.train.AdamOptimizer", "tensorflow.losses.mean_squared_error", "tensorflow.train.AdamOptimizer.compute_gradients", "tensorflow.train.AdamOptimizer.apply_gradients", "tensorflow.stop_gradient", "tensorflow.clip_by_norm", "tensorflow.clip_by_norm"], "methods", ["None"], ["", "", "def", "build_optim", "(", "self", ")", ":", "\n", "        ", "update_ops", "=", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "UPDATE_OPS", ")", "\n", "with", "tf", ".", "control_dependencies", "(", "update_ops", ")", ":", "# Update moving_mean and moving_variance for BN", "\n", "\n", "            ", "with", "tf", ".", "name_scope", "(", "'reinforce'", ")", ":", "\n", "                ", "lr1", "=", "tf", ".", "train", ".", "natural_exp_decay", "(", "learning_rate", "=", "self", ".", "lr_start", ",", "global_step", "=", "self", ".", "global_step", ",", "decay_steps", "=", "self", ".", "lr_decay_step", ",", "decay_rate", "=", "self", ".", "lr_decay_rate", ",", "staircase", "=", "False", ",", "name", "=", "\"learning_rate1\"", ")", "# learning rate actor", "\n", "tf", ".", "summary", ".", "scalar", "(", "'lr'", ",", "lr1", ")", "\n", "opt1", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "lr1", ")", "# Optimizer", "\n", "self", ".", "loss", "=", "tf", ".", "reduce_mean", "(", "tf", ".", "stop_gradient", "(", "self", ".", "reward", "-", "self", ".", "predictions", ")", "*", "self", ".", "log_prob", ",", "axis", "=", "0", ")", "# loss actor", "\n", "gvs1", "=", "opt1", ".", "compute_gradients", "(", "self", ".", "loss", ")", "# gradients", "\n", "capped_gvs1", "=", "[", "(", "tf", ".", "clip_by_norm", "(", "grad", ",", "1.", ")", ",", "var", ")", "for", "grad", ",", "var", "in", "gvs1", "if", "grad", "is", "not", "None", "]", "# L2 clip", "\n", "self", ".", "trn_op1", "=", "opt1", ".", "apply_gradients", "(", "grads_and_vars", "=", "capped_gvs1", ",", "global_step", "=", "self", ".", "global_step", ")", "# minimize op actor", "\n", "\n", "", "with", "tf", ".", "name_scope", "(", "'state_value'", ")", ":", "\n", "                ", "lr2", "=", "tf", ".", "train", ".", "natural_exp_decay", "(", "learning_rate", "=", "self", ".", "lr_start", ",", "global_step", "=", "self", ".", "global_step2", ",", "decay_steps", "=", "self", ".", "lr_decay_step", ",", "decay_rate", "=", "self", ".", "lr_decay_rate", ",", "staircase", "=", "False", ",", "name", "=", "\"learning_rate2\"", ")", "# learning rate critic", "\n", "opt2", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "lr2", ")", "# Optimizer", "\n", "loss2", "=", "tf", ".", "losses", ".", "mean_squared_error", "(", "self", ".", "reward", ",", "self", ".", "predictions", ")", "# loss critic", "\n", "gvs2", "=", "opt2", ".", "compute_gradients", "(", "loss2", ")", "# gradients", "\n", "capped_gvs2", "=", "[", "(", "tf", ".", "clip_by_norm", "(", "grad", ",", "1.", ")", ",", "var", ")", "for", "grad", ",", "var", "in", "gvs2", "if", "grad", "is", "not", "None", "]", "# L2 clip", "\n", "self", ".", "trn_op2", "=", "opt2", ".", "apply_gradients", "(", "grads_and_vars", "=", "capped_gvs2", ",", "global_step", "=", "self", ".", "global_step2", ")", "# minimize op critic", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.add_argument_group": [[46, 50], ["parser.add_argument_group", "arg_lists.append"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.add_argument_group"], ["def", "add_argument_group", "(", "name", ")", ":", "\n", "  ", "arg", "=", "parser", ".", "add_argument_group", "(", "name", ")", "\n", "arg_lists", ".", "append", "(", "arg", ")", "\n", "return", "arg", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.str2bool": [[51, 53], ["v.lower"], "function", ["None"], ["", "def", "str2bool", "(", "v", ")", ":", "\n", "  ", "return", "v", ".", "lower", "(", ")", "in", "(", "'true'", ",", "'1'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.get_config": [[84, 87], ["parser.parse_known_args"], "function", ["None"], ["def", "get_config", "(", ")", ":", "\n", "  ", "config", ",", "unparsed", "=", "parser", ".", "parse_known_args", "(", ")", "\n", "return", "config", ",", "unparsed", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.preprocess_instance": [[314, 319], ["numpy.array", "sklearn.decomposition.PCA", "sklearn.decomposition.PCA.fit_transform"], "function", ["None"], ["def", "preprocess_instance", "(", "sequence", ")", ":", "# Generate random TSP instance", "\n", "    ", "sequence", "=", "np", ".", "array", "(", "sequence", ")", "\n", "pca", "=", "PCA", "(", "n_components", "=", "sequence", ".", "shape", "[", "-", "1", "]", ")", "# center & rotate coordinates", "\n", "sequence", "=", "pca", ".", "fit_transform", "(", "sequence", ")", "\n", "return", "sequence", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset": [[320, 323], ["open", "numpy.array", "pickle.load"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load"], ["", "def", "load_dataset", "(", "size", ")", ":", "\n", "    ", "with", "open", "(", "f\"tsp{size}_test_seed1234.pkl\"", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "return", "[", "np", ".", "array", "(", "inst", ")", "for", "inst", "in", "pickle", ".", "load", "(", "f", ")", "]", "\n", "#     return [", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.calc_tsp_length": [[328, 333], ["numpy.linalg.norm().sum", "len", "len", "len", "len", "numpy.array", "numpy.unique", "numpy.concatenate", "numpy.linalg.norm"], "function", ["None"], ["", "", "def", "calc_tsp_length", "(", "loc", ",", "tour", ")", ":", "\n", "    ", "assert", "len", "(", "np", ".", "unique", "(", "tour", ")", ")", "==", "len", "(", "tour", ")", ",", "\"Tour cannot contain duplicates\"", "\n", "assert", "len", "(", "tour", ")", "==", "len", "(", "loc", ")", "\n", "sorted_locs", "=", "np", ".", "array", "(", "loc", ")", "[", "np", ".", "concatenate", "(", "(", "tour", ",", "[", "tour", "[", "0", "]", "]", ")", ")", "]", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "sorted_locs", "[", "1", ":", "]", "-", "sorted_locs", "[", ":", "-", "1", "]", ",", "axis", "=", "-", "1", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.eval_dataset": [[348, 408], ["numpy.random.seed", "tensorflow.set_random_seed", "tensorflow.reset_default_graph", "Neural_Reinforce.Actor", "tensorflow.train.Saver", "tensorflow.Session", "sess.run", "tf.train.Saver.restore", "enumerate", "numpy.asarray", "numpy.asarray", "print", "tensorflow.global_variables", "tensorflow.global_variables_initializer", "tqdm.tqdm", "time.time", "sess.run", "numpy.argmin", "np.asarray.append", "results.append", "dataset.loop2opt", "np.asarray.append", "numpy.linalg.norm().argmin", "results_w2opt.append", "numpy.mean", "numpy.mean", "Neural_Reinforce.preprocess_instance", "Neural_Reinforce.calc_tsp_length", "numpy.linalg.norm", "Neural_Reinforce.calc_tsp_length", "time.time", "time.time"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.None.run.run", "home.repos.pwc.inspect_result.alstn12088_lcp.None.run.run", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.loop2opt", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.preprocess_instance", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length"], ["def", "eval_dataset", "(", "ds", ",", "greedy", ",", "num_samples", ",", "save_path", ",", "max_length", ",", "seed", "=", "123", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "seed", ")", "# reproducibility", "\n", "tf", ".", "set_random_seed", "(", "seed", ")", "\n", "\n", "config", ".", "is_training", "=", "False", "\n", "config", ".", "greedy", "=", "greedy", "\n", "config", ".", "batch_size", "=", "num_samples", "##### #####", "\n", "config", ".", "max_length", "=", "max_length", "##### #####", "\n", "config", ".", "temperature", "=", "1.2", "##### #####", "\n", "\n", "tf", ".", "reset_default_graph", "(", ")", "\n", "actor", "=", "Actor", "(", ")", "# Build graph", "\n", "\n", "variables_to_save", "=", "[", "v", "for", "v", "in", "tf", ".", "global_variables", "(", ")", "if", "'Adam'", "not", "in", "v", ".", "name", "]", "# Save & restore all the variables.", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", "var_list", "=", "variables_to_save", ",", "keep_checkpoint_every_n_hours", "=", "1.0", ")", "\n", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "# start session", "\n", "        ", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "# Run initialize op", "\n", "\n", "# save_path = \"save/\"+dir_", "\n", "saver", ".", "restore", "(", "sess", ",", "save_path", "+", "\"/actor.ckpt\"", ")", "# Restore variables from disk.", "\n", "\n", "predictions_length", ",", "predictions_length_w2opt", "=", "[", "]", ",", "[", "]", "\n", "results", ",", "results_w2opt", "=", "[", "]", ",", "[", "]", "\n", "#     for i in tqdm(range(1000)): # test instance", "\n", "#         seed_ = 1+i", "\n", "#         input_batch = dataset.test_batch(1, actor.max_length, actor.dimension, seed=seed_, shuffle=False)", "\n", "for", "i", ",", "coords", "in", "enumerate", "(", "tqdm", "(", "ds", ",", "mininterval", "=", "30", ")", ")", ":", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "input_batch", "=", "[", "preprocess_instance", "(", "coords", ")", "]", "# Add batch dimension", "\n", "feed", "=", "{", "actor", ".", "input_", ":", "input_batch", "}", "# Get feed dict", "\n", "tour", ",", "reward", "=", "sess", ".", "run", "(", "[", "actor", ".", "tour", ",", "actor", ".", "reward", "]", ",", "feed_dict", "=", "feed", ")", "# sample tours", "\n", "j", "=", "np", ".", "argmin", "(", "reward", ")", "# find best solution", "\n", "best_permutation", "=", "tour", "[", "j", "]", "[", ":", "-", "1", "]", "\n", "predictions_length", ".", "append", "(", "reward", "[", "j", "]", ")", "\n", "\n", "#             print('reward (before 2 opt)',reward[j])", "\n", "#             dataset.visualize_2D_trip(input_batch[0][best_permutation])", "\n", "#             dataset.visualize_sampling(tour)", "\n", "\n", "results", ".", "append", "(", "(", "calc_tsp_length", "(", "coords", ",", "best_permutation", ")", ",", "best_permutation", ",", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n", "\n", "opt_tour", ",", "opt_length", "=", "dataset", ".", "loop2opt", "(", "input_batch", "[", "0", "]", "[", "best_permutation", "]", ")", "\n", "predictions_length_w2opt", ".", "append", "(", "opt_length", ")", "\n", "\n", "#             print('reward (with 2 opt)', opt_length)", "\n", "#             dataset.visualize_2D_trip(opt_tour)", "\n", "\n", "# Find permutation corresponding to opt_tour", "\n", "opt_tour_ind", "=", "np", ".", "linalg", ".", "norm", "(", "opt_tour", "[", ":", ",", "None", ",", ":", "]", "-", "input_batch", "[", "0", "]", "[", "None", ",", ":", ",", ":", "]", ",", "axis", "=", "-", "1", ")", ".", "argmin", "(", "-", "1", ")", "\n", "\n", "results_w2opt", ".", "append", "(", "(", "calc_tsp_length", "(", "coords", ",", "opt_tour_ind", ")", ",", "opt_tour_ind", ",", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n", "\n", "", "predictions_length", "=", "np", ".", "asarray", "(", "predictions_length", ")", "# average tour length", "\n", "predictions_length_w2opt", "=", "np", ".", "asarray", "(", "predictions_length_w2opt", ")", "\n", "print", "(", "\"Testing COMPLETED ! Mean length1:\"", ",", "np", ".", "mean", "(", "predictions_length", ")", ",", "\"Mean length2:\"", ",", "np", ".", "mean", "(", "predictions_length_w2opt", ")", ")", "\n", "\n", "return", "results", ",", "results_w2opt", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.print_summary": [[421, 429], ["zip", "print", "print", "print", "print", "print", "len", "numpy.mean", "numpy.mean", "datetime.timedelta", "numpy.sqrt", "numpy.sqrt", "numpy.mean", "numpy.std", "len", "numpy.std", "len", "int", "numpy.sum"], "function", ["None"], ["", "", "def", "print_summary", "(", "results", ",", "parallelism", "=", "1", ")", ":", "\n", "    ", "costs", ",", "tours", ",", "durations", "=", "zip", "(", "*", "results", ")", "# Not really costs since they should be negative", "\n", "print", "(", "\"Number of instances: {}\"", ".", "format", "(", "len", "(", "costs", ")", ")", ")", "\n", "print", "(", "\"Average cost: {} +- {}\"", ".", "format", "(", "np", ".", "mean", "(", "costs", ")", ",", "2", "*", "np", ".", "std", "(", "costs", ")", "/", "np", ".", "sqrt", "(", "len", "(", "costs", ")", ")", ")", ")", "\n", "print", "(", "\"Average serial duration: {} +- {}\"", ".", "format", "(", "\n", "np", ".", "mean", "(", "durations", ")", ",", "2", "*", "np", ".", "std", "(", "durations", ")", "/", "np", ".", "sqrt", "(", "len", "(", "durations", ")", ")", ")", ")", "\n", "print", "(", "\"Average parallel duration: {}\"", ".", "format", "(", "np", ".", "mean", "(", "durations", ")", "/", "parallelism", ")", ")", "\n", "print", "(", "\"Calculated total duration: {}\"", ".", "format", "(", "timedelta", "(", "seconds", "=", "int", "(", "np", ".", "sum", "(", "durations", ")", "/", "parallelism", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.save_results": [[430, 442], ["print", "Neural_Reinforce.print_summary", "os.makedirs", "os.path.join", "open", "pickle.dump"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.print_summary"], ["", "def", "save_results", "(", "size", ",", "method", ",", "results", ",", "parallelism", "=", "1", ")", ":", "\n", "    ", "print", "(", "f\"----- results for {method}\"", ")", "\n", "print_summary", "(", "results", ")", "\n", "results_dir", "=", "'results'", "\n", "os", ".", "makedirs", "(", "results_dir", ",", "exist_ok", "=", "True", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "results_dir", ",", "\"tsp{}_test_seed1234-{}.pkl\"", ".", "format", "(", "\n", "size", ",", "\n", "method", "\n", ")", ")", "\n", "\n", "with", "open", "(", "out_file", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "pickle", ".", "dump", "(", "(", "results", ",", "parallelism", ")", ",", "f", ",", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.__init__": [[35, 37], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.gen_instance": [[38, 44], ["numpy.random.rand", "sklearn.decomposition.PCA", "sklearn.decomposition.PCA.fit_transform", "numpy.random.seed"], "methods", ["None"], ["", "def", "gen_instance", "(", "self", ",", "max_length", ",", "dimension", ",", "seed", "=", "0", ")", ":", "# Generate random TSP instance", "\n", "        ", "if", "seed", "!=", "0", ":", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "sequence", "=", "np", ".", "random", ".", "rand", "(", "max_length", ",", "dimension", ")", "# (max_length) cities with (dimension) coordinates in [0,1]", "\n", "pca", "=", "PCA", "(", "n_components", "=", "dimension", ")", "# center & rotate coordinates", "\n", "sequence", "=", "pca", ".", "fit_transform", "(", "sequence", ")", "\n", "return", "sequence", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.train_batch": [[45, 51], ["range", "data_generator.DataGenerator.gen_instance", "input_batch.append"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.gen_instance"], ["", "def", "train_batch", "(", "self", ",", "batch_size", ",", "max_length", ",", "dimension", ")", ":", "# Generate random batch for training procedure", "\n", "        ", "input_batch", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "input_", "=", "self", ".", "gen_instance", "(", "max_length", ",", "dimension", ")", "# Generate random TSP instance", "\n", "input_batch", ".", "append", "(", "input_", ")", "# Store batch", "\n", "", "return", "input_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.test_batch": [[52, 61], ["data_generator.DataGenerator.gen_instance", "range", "numpy.copy", "input_batch.append", "numpy.random.shuffle"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.gen_instance", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy"], ["", "def", "test_batch", "(", "self", ",", "batch_size", ",", "max_length", ",", "dimension", ",", "seed", "=", "0", ",", "shuffle", "=", "False", ")", ":", "# Generate random batch for testing procedure", "\n", "        ", "input_batch", "=", "[", "]", "\n", "input_", "=", "self", ".", "gen_instance", "(", "max_length", ",", "dimension", ",", "seed", "=", "seed", ")", "# Generate random TSP instance", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "sequence", "=", "np", ".", "copy", "(", "input_", ")", "\n", "if", "shuffle", "==", "True", ":", "\n", "                ", "np", ".", "random", ".", "shuffle", "(", "sequence", ")", "# Shuffle sequence", "\n", "", "input_batch", ".", "append", "(", "sequence", ")", "# Store batch", "\n", "", "return", "input_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.loop2opt": [[62, 72], ["data_generator.reward", "numpy.copy", "range", "data_generator.step2opt"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.reward", "home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.step2opt"], ["", "def", "loop2opt", "(", "self", ",", "tsp_sequence", ",", "max_iter", "=", "2000", ")", ":", "# Iterate step2opt max_iter times (2-opt local search)", "\n", "        ", "best_reward", "=", "reward", "(", "tsp_sequence", ")", "\n", "new_tsp_sequence", "=", "np", ".", "copy", "(", "tsp_sequence", ")", "\n", "for", "_", "in", "range", "(", "max_iter", ")", ":", "\n", "            ", "new_tsp_sequence", ",", "new_reward", "=", "step2opt", "(", "new_tsp_sequence", ")", "\n", "if", "new_reward", "<", "best_reward", ":", "\n", "                ", "best_reward", "=", "new_reward", "\n", "", "else", ":", "\n", "                ", "break", "\n", "", "", "return", "new_tsp_sequence", ",", "best_reward", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.visualize_2D_trip": [[73, 90], ["matplotlib.figure", "range", "matplotlib.scatter", "numpy.array", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show", "colors.append", "len", "list", "range", "len"], "methods", ["None"], ["", "def", "visualize_2D_trip", "(", "self", ",", "trip", ")", ":", "# Plot tour", "\n", "        ", "plt", ".", "figure", "(", "1", ")", "\n", "colors", "=", "[", "'red'", "]", "# First city red", "\n", "for", "i", "in", "range", "(", "len", "(", "trip", ")", "-", "1", ")", ":", "\n", "            ", "colors", ".", "append", "(", "'blue'", ")", "\n", "\n", "", "plt", ".", "scatter", "(", "trip", "[", ":", ",", "0", "]", ",", "trip", "[", ":", ",", "1", "]", ",", "color", "=", "colors", ")", "# Plot cities", "\n", "tour", "=", "np", ".", "array", "(", "list", "(", "range", "(", "len", "(", "trip", ")", ")", ")", "+", "[", "0", "]", ")", "# Plot tour", "\n", "X", "=", "trip", "[", "tour", ",", "0", "]", "\n", "Y", "=", "trip", "[", "tour", ",", "1", "]", "\n", "plt", ".", "plot", "(", "X", ",", "Y", ",", "\"--\"", ")", "\n", "\n", "plt", ".", "xlim", "(", "-", "0.75", ",", "0.75", ")", "\n", "plt", ".", "ylim", "(", "-", "0.75", ",", "0.75", ")", "\n", "plt", ".", "xlabel", "(", "'X'", ")", "\n", "plt", ".", "ylabel", "(", "'Y'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.DataGenerator.visualize_sampling": [[91, 110], ["len", "numpy.zeros", "numpy.transpose", "enumerate", "matplotlib.figure", "matplotlib.figure.add_subplot", "plt.figure.add_subplot.set_aspect", "matplotlib.imshow", "matplotlib.colorbar", "matplotlib.title", "matplotlib.ylabel", "matplotlib.xlabel", "matplotlib.show", "numpy.unique", "zip"], "methods", ["None"], ["", "def", "visualize_sampling", "(", "self", ",", "permutations", ")", ":", "# Heatmap of permutations (x=cities; y=steps)", "\n", "        ", "max_length", "=", "len", "(", "permutations", "[", "0", "]", ")", "\n", "grid", "=", "np", ".", "zeros", "(", "[", "max_length", ",", "max_length", "]", ")", "# initialize heatmap grid to 0", "\n", "\n", "transposed_permutations", "=", "np", ".", "transpose", "(", "permutations", ")", "\n", "for", "t", ",", "cities_t", "in", "enumerate", "(", "transposed_permutations", ")", ":", "# step t, cities chosen at step t", "\n", "            ", "city_indices", ",", "counts", "=", "np", ".", "unique", "(", "cities_t", ",", "return_counts", "=", "True", ",", "axis", "=", "0", ")", "\n", "for", "u", ",", "v", "in", "zip", "(", "city_indices", ",", "counts", ")", ":", "\n", "                ", "grid", "[", "t", "]", "[", "u", "]", "+=", "v", "# update grid with counts from the batch of permutations", "\n", "\n", "", "", "fig", "=", "plt", ".", "figure", "(", "1", ")", "# plot heatmap", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "1", ",", "1", ",", "1", ")", "\n", "ax", ".", "set_aspect", "(", "'equal'", ")", "\n", "plt", ".", "imshow", "(", "grid", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "'gray'", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "plt", ".", "title", "(", "'Sampled permutations'", ")", "\n", "plt", ".", "ylabel", "(", "'Time t'", ")", "\n", "plt", ".", "xlabel", "(", "'City i'", ")", "\n", "plt", ".", "show", "(", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.reward": [[9, 13], ["numpy.concatenate", "numpy.sqrt", "numpy.sum", "numpy.sum", "numpy.expand_dims", "numpy.square"], "function", ["None"], ["def", "reward", "(", "tsp_sequence", ")", ":", "\n", "    ", "tour", "=", "np", ".", "concatenate", "(", "(", "tsp_sequence", ",", "np", ".", "expand_dims", "(", "tsp_sequence", "[", "0", "]", ",", "0", ")", ")", ")", "# sequence to tour (end=start)", "\n", "inter_city_distances", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "tour", "[", ":", "-", "1", ",", ":", "2", "]", "-", "tour", "[", "1", ":", ",", ":", "2", "]", ")", ",", "axis", "=", "1", ")", ")", "# tour length", "\n", "return", "np", ".", "sum", "(", "inter_city_distances", ")", "# reward", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.swap2opt": [[15, 19], ["numpy.copy", "numpy.flip"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.model.solution.Solution.copy"], ["", "def", "swap2opt", "(", "tsp_sequence", ",", "i", ",", "j", ")", ":", "\n", "    ", "new_tsp_sequence", "=", "np", ".", "copy", "(", "tsp_sequence", ")", "\n", "new_tsp_sequence", "[", "i", ":", "j", "+", "1", "]", "=", "np", ".", "flip", "(", "tsp_sequence", "[", "i", ":", "j", "+", "1", "]", ",", "axis", "=", "0", ")", "# flip or swap ?", "\n", "return", "new_tsp_sequence", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.step2opt": [[21, 31], ["data_generator.reward", "range", "range", "data_generator.swap2opt", "data_generator.reward"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.reward", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.swap2opt", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.data_generator.reward"], ["", "def", "step2opt", "(", "tsp_sequence", ")", ":", "\n", "    ", "seq_length", "=", "tsp_sequence", ".", "shape", "[", "0", "]", "\n", "distance", "=", "reward", "(", "tsp_sequence", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "seq_length", "-", "1", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "seq_length", ")", ":", "\n", "            ", "new_tsp_sequence", "=", "swap2opt", "(", "tsp_sequence", ",", "i", ",", "j", ")", "\n", "new_distance", "=", "reward", "(", "new_tsp_sequence", ")", "\n", "if", "new_distance", "<", "distance", ":", "\n", "                ", "return", "new_tsp_sequence", ",", "new_distance", "\n", "", "", "", "return", "tsp_sequence", ",", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.embed_seq": [[9, 15], ["tensorflow.contrib.layers.xavier_initializer", "tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.nn.conv1d", "tensorflow.layers.batch_normalization"], "function", ["None"], ["def", "embed_seq", "(", "input_seq", ",", "from_", ",", "to_", ",", "is_training", ",", "BN", "=", "True", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "\"embedding\"", ")", ":", "# embed + BN input set", "\n", "        ", "W_embed", "=", "tf", ".", "get_variable", "(", "\"weights\"", ",", "[", "1", ",", "from_", ",", "to_", "]", ",", "initializer", "=", "initializer", ")", "\n", "embedded_input", "=", "tf", ".", "nn", ".", "conv1d", "(", "input_seq", ",", "W_embed", ",", "1", ",", "\"VALID\"", ",", "name", "=", "\"embedded_input\"", ")", "\n", "if", "BN", "==", "True", ":", "embedded_input", "=", "tf", ".", "layers", ".", "batch_normalization", "(", "embedded_input", ",", "axis", "=", "2", ",", "training", "=", "is_training", ",", "name", "=", "'layer_norm'", ",", "reuse", "=", "None", ")", "\n", "return", "embedded_input", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.multihead_attention": [[20, 48], ["tensorflow.variable_scope", "tensorflow.layers.dense", "tensorflow.layers.dense", "tensorflow.layers.dense", "tensorflow.concat", "tensorflow.concat", "tensorflow.concat", "tensorflow.matmul", "tensorflow.nn.softmax", "tensorflow.layers.dropout", "tensorflow.matmul", "tensorflow.concat", "tensorflow.layers.batch_normalization", "tensorflow.split", "tensorflow.split", "tensorflow.split", "tensorflow.transpose", "tensorflow.split", "tensorflow.convert_to_tensor", "tf.concat.get_shape().as_list", "tf.concat.get_shape"], "function", ["None"], ["", "", "def", "multihead_attention", "(", "inputs", ",", "num_units", "=", "None", ",", "num_heads", "=", "16", ",", "dropout_rate", "=", "0.1", ",", "is_training", "=", "True", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "\"multihead_attention\"", ",", "reuse", "=", "None", ")", ":", "\n", "# Linear projections", "\n", "        ", "Q", "=", "tf", ".", "layers", ".", "dense", "(", "inputs", ",", "num_units", ",", "activation", "=", "tf", ".", "nn", ".", "relu", ")", "# [batch_size, seq_length, n_hidden]", "\n", "K", "=", "tf", ".", "layers", ".", "dense", "(", "inputs", ",", "num_units", ",", "activation", "=", "tf", ".", "nn", ".", "relu", ")", "# [batch_size, seq_length, n_hidden]", "\n", "V", "=", "tf", ".", "layers", ".", "dense", "(", "inputs", ",", "num_units", ",", "activation", "=", "tf", ".", "nn", ".", "relu", ")", "# [batch_size, seq_length, n_hidden]", "\n", "# Split and concat", "\n", "Q_", "=", "tf", ".", "concat", "(", "tf", ".", "split", "(", "Q", ",", "num_heads", ",", "axis", "=", "2", ")", ",", "axis", "=", "0", ")", "# [batch_size, seq_length, n_hidden/num_heads]", "\n", "K_", "=", "tf", ".", "concat", "(", "tf", ".", "split", "(", "K", ",", "num_heads", ",", "axis", "=", "2", ")", ",", "axis", "=", "0", ")", "# [batch_size, seq_length, n_hidden/num_heads]", "\n", "V_", "=", "tf", ".", "concat", "(", "tf", ".", "split", "(", "V", ",", "num_heads", ",", "axis", "=", "2", ")", ",", "axis", "=", "0", ")", "# [batch_size, seq_length, n_hidden/num_heads]", "\n", "# Multiplication", "\n", "outputs", "=", "tf", ".", "matmul", "(", "Q_", ",", "tf", ".", "transpose", "(", "K_", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "# num_heads*[batch_size, seq_length, seq_length]", "\n", "# Scale", "\n", "outputs", "=", "outputs", "/", "(", "K_", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "**", "0.5", ")", "\n", "# Activation", "\n", "outputs", "=", "tf", ".", "nn", ".", "softmax", "(", "outputs", ")", "# num_heads*[batch_size, seq_length, seq_length]", "\n", "# Dropouts", "\n", "outputs", "=", "tf", ".", "layers", ".", "dropout", "(", "outputs", ",", "rate", "=", "dropout_rate", ",", "training", "=", "tf", ".", "convert_to_tensor", "(", "is_training", ")", ")", "\n", "# Weighted sum", "\n", "outputs", "=", "tf", ".", "matmul", "(", "outputs", ",", "V_", ")", "# num_heads*[batch_size, seq_length, n_hidden/num_heads]", "\n", "# Restore shape", "\n", "outputs", "=", "tf", ".", "concat", "(", "tf", ".", "split", "(", "outputs", ",", "num_heads", ",", "axis", "=", "0", ")", ",", "axis", "=", "2", ")", "# [batch_size, seq_length, n_hidden]   ", "\n", "# Residual connection", "\n", "outputs", "+=", "inputs", "# [batch_size, seq_length, n_hidden]", "\n", "# Normalize", "\n", "outputs", "=", "tf", ".", "layers", ".", "batch_normalization", "(", "outputs", ",", "axis", "=", "2", ",", "training", "=", "is_training", ",", "name", "=", "'ln'", ",", "reuse", "=", "None", ")", "# [batch_size, seq_length, n_hidden]", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.feedforward": [[52, 65], ["tensorflow.variable_scope", "tensorflow.layers.conv1d", "tensorflow.layers.conv1d", "tensorflow.layers.batch_normalization"], "function", ["None"], ["", "def", "feedforward", "(", "inputs", ",", "num_units", "=", "[", "2048", ",", "512", "]", ",", "is_training", "=", "True", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "\"ffn\"", ",", "reuse", "=", "None", ")", ":", "\n", "# Inner layer", "\n", "        ", "params", "=", "{", "\"inputs\"", ":", "inputs", ",", "\"filters\"", ":", "num_units", "[", "0", "]", ",", "\"kernel_size\"", ":", "1", ",", "\"activation\"", ":", "tf", ".", "nn", ".", "relu", ",", "\"use_bias\"", ":", "True", "}", "\n", "outputs", "=", "tf", ".", "layers", ".", "conv1d", "(", "**", "params", ")", "\n", "# Readout layer", "\n", "params", "=", "{", "\"inputs\"", ":", "outputs", ",", "\"filters\"", ":", "num_units", "[", "1", "]", ",", "\"kernel_size\"", ":", "1", ",", "\"activation\"", ":", "None", ",", "\"use_bias\"", ":", "True", "}", "\n", "outputs", "=", "tf", ".", "layers", ".", "conv1d", "(", "**", "params", ")", "\n", "# Residual connection", "\n", "outputs", "+=", "inputs", "\n", "# Normalize", "\n", "outputs", "=", "tf", ".", "layers", ".", "batch_normalization", "(", "outputs", ",", "axis", "=", "2", ",", "training", "=", "is_training", ",", "name", "=", "'ln'", ",", "reuse", "=", "None", ")", "# [batch_size, seq_length, n_hidden]   ", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.encode_seq": [[68, 75], ["tensorflow.variable_scope", "range", "tensorflow.variable_scope", "utils.multihead_attention", "utils.feedforward"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.multihead_attention", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.feedforward"], ["", "def", "encode_seq", "(", "input_seq", ",", "input_dim", ",", "num_stacks", ",", "num_heads", ",", "num_neurons", ",", "is_training", ",", "dropout_rate", "=", "0.", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "\"stack\"", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "num_stacks", ")", ":", "# block i", "\n", "            ", "with", "tf", ".", "variable_scope", "(", "\"block_{}\"", ".", "format", "(", "i", ")", ")", ":", "# Multihead Attention + Feed Forward", "\n", "                ", "input_seq", "=", "multihead_attention", "(", "input_seq", ",", "num_units", "=", "input_dim", ",", "num_heads", "=", "num_heads", ",", "dropout_rate", "=", "dropout_rate", ",", "is_training", "=", "is_training", ")", "\n", "input_seq", "=", "feedforward", "(", "input_seq", ",", "num_units", "=", "[", "num_neurons", ",", "input_dim", "]", ",", "is_training", "=", "is_training", ")", "\n", "", "", "return", "input_seq", "# encoder_output is the ref for actions [Batch size, Sequence Length, Num_neurons]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.pointer": [[79, 85], ["tensorflow.expand_dims", "tensorflow.reduce_sum", "tensorflow.clip_by_value", "tensorflow.matmul", "tensorflow.tanh", "tensorflow.tanh"], "function", ["None"], ["", "", "def", "pointer", "(", "encoded_ref", ",", "query", ",", "mask", ",", "W_ref", ",", "W_q", ",", "v", ",", "C", "=", "10.", ",", "temperature", "=", "1.0", ")", ":", "\n", "    ", "encoded_query", "=", "tf", ".", "expand_dims", "(", "tf", ".", "matmul", "(", "query", ",", "W_q", ")", ",", "1", ")", "# [Batch size, 1, n_hidden]", "\n", "scores", "=", "tf", ".", "reduce_sum", "(", "v", "*", "tf", ".", "tanh", "(", "encoded_ref", "+", "encoded_query", ")", ",", "[", "-", "1", "]", ")", "# [Batch size, seq_length]", "\n", "scores", "=", "C", "*", "tf", ".", "tanh", "(", "scores", "/", "temperature", ")", "# control entropy", "\n", "masked_scores", "=", "tf", ".", "clip_by_value", "(", "scores", "-", "100000000.", "*", "mask", ",", "-", "100000000.", ",", "100000000.", ")", "# [Batch size, seq_length]", "\n", "return", "masked_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.full_glimpse": [[88, 101], ["tensorflow.contrib.layers.xavier_initializer", "tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.nn.conv1d", "tensorflow.reduce_sum", "tensorflow.nn.softmax", "tensorflow.multiply", "tensorflow.reduce_sum", "tensorflow.expand_dims", "tensorflow.tanh"], "function", ["None"], ["", "def", "full_glimpse", "(", "ref", ",", "from_", ",", "to_", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "\"glimpse\"", ")", ":", "\n", "        ", "W_ref_g", "=", "tf", ".", "get_variable", "(", "\"W_ref_g\"", ",", "[", "1", ",", "from_", ",", "to_", "]", ",", "initializer", "=", "initializer", ")", "\n", "W_q_g", "=", "tf", ".", "get_variable", "(", "\"W_q_g\"", ",", "[", "from_", ",", "to_", "]", ",", "initializer", "=", "initializer", ")", "\n", "v_g", "=", "tf", ".", "get_variable", "(", "\"v_g\"", ",", "[", "to_", "]", ",", "initializer", "=", "initializer", ")", "\n", "# Attending mechanism", "\n", "encoded_ref_g", "=", "tf", ".", "nn", ".", "conv1d", "(", "ref", ",", "W_ref_g", ",", "1", ",", "\"VALID\"", ",", "name", "=", "\"encoded_ref_g\"", ")", "# [Batch size, seq_length, n_hidden]", "\n", "scores_g", "=", "tf", ".", "reduce_sum", "(", "v_g", "*", "tf", ".", "tanh", "(", "encoded_ref_g", ")", ",", "[", "-", "1", "]", ",", "name", "=", "\"scores_g\"", ")", "# [Batch size, seq_length]", "\n", "attention_g", "=", "tf", ".", "nn", ".", "softmax", "(", "scores_g", ",", "name", "=", "\"attention_g\"", ")", "\n", "# 1 glimpse = Linear combination of reference vectors (defines new query vector)", "\n", "glimpse", "=", "tf", ".", "multiply", "(", "ref", ",", "tf", ".", "expand_dims", "(", "attention_g", ",", "2", ")", ")", "\n", "glimpse", "=", "tf", ".", "reduce_sum", "(", "glimpse", ",", "1", ")", "\n", "return", "glimpse", "", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_gurobi.solve_euclidian_tsp": [[18, 137], ["len", "Model", "Model.addVars", "m.addVars.keys", "Model.addConstrs", "Model.optimize", "Model.getAttr", "tuplelist", "tsp_gurobi.solve_euclidian_tsp.subtour"], "function", ["None"], ["def", "solve_euclidian_tsp", "(", "points", ",", "threads", "=", "0", ",", "timeout", "=", "None", ",", "gap", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Solves the Euclidan TSP problem to optimality using the MIP formulation \n    with lazy subtour elimination constraint generation.\n    :param points: list of (x, y) coordinate \n    :return: \n    \"\"\"", "\n", "\n", "n", "=", "len", "(", "points", ")", "\n", "\n", "# Callback - use lazy constraints to eliminate sub-tours", "\n", "\n", "def", "subtourelim", "(", "model", ",", "where", ")", ":", "\n", "        ", "if", "where", "==", "GRB", ".", "Callback", ".", "MIPSOL", ":", "\n", "# make a list of edges selected in the solution", "\n", "            ", "vals", "=", "model", ".", "cbGetSolution", "(", "model", ".", "_vars", ")", "\n", "selected", "=", "tuplelist", "(", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "model", ".", "_vars", ".", "keys", "(", ")", "if", "vals", "[", "i", ",", "j", "]", ">", "0.5", ")", "\n", "# find the shortest cycle in the selected edge list", "\n", "tour", "=", "subtour", "(", "selected", ")", "\n", "if", "len", "(", "tour", ")", "<", "n", ":", "\n", "# add subtour elimination constraint for every pair of cities in tour", "\n", "                ", "model", ".", "cbLazy", "(", "quicksum", "(", "model", ".", "_vars", "[", "i", ",", "j", "]", "\n", "for", "i", ",", "j", "in", "itertools", ".", "combinations", "(", "tour", ",", "2", ")", ")", "\n", "<=", "len", "(", "tour", ")", "-", "1", ")", "\n", "\n", "# Given a tuplelist of edges, find the shortest subtour", "\n", "\n", "", "", "", "def", "subtour", "(", "edges", ")", ":", "\n", "        ", "unvisited", "=", "list", "(", "range", "(", "n", ")", ")", "\n", "cycle", "=", "range", "(", "n", "+", "1", ")", "# initial length has 1 more city", "\n", "while", "unvisited", ":", "# true if list is non-empty", "\n", "            ", "thiscycle", "=", "[", "]", "\n", "neighbors", "=", "unvisited", "\n", "while", "neighbors", ":", "\n", "                ", "current", "=", "neighbors", "[", "0", "]", "\n", "thiscycle", ".", "append", "(", "current", ")", "\n", "unvisited", ".", "remove", "(", "current", ")", "\n", "neighbors", "=", "[", "j", "for", "i", ",", "j", "in", "edges", ".", "select", "(", "current", ",", "'*'", ")", "if", "j", "in", "unvisited", "]", "\n", "", "if", "len", "(", "cycle", ")", ">", "len", "(", "thiscycle", ")", ":", "\n", "                ", "cycle", "=", "thiscycle", "\n", "", "", "return", "cycle", "\n", "\n", "# Dictionary of Euclidean distance between each pair of points", "\n", "\n", "", "dist", "=", "{", "(", "i", ",", "j", ")", ":", "\n", "math", ".", "sqrt", "(", "sum", "(", "(", "points", "[", "i", "]", "[", "k", "]", "-", "points", "[", "j", "]", "[", "k", "]", ")", "**", "2", "for", "k", "in", "range", "(", "2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", "for", "j", "in", "range", "(", "i", ")", "}", "\n", "\n", "m", "=", "Model", "(", ")", "\n", "m", ".", "Params", ".", "outputFlag", "=", "False", "\n", "\n", "# Create variables", "\n", "\n", "vars", "=", "m", ".", "addVars", "(", "dist", ".", "keys", "(", ")", ",", "obj", "=", "dist", ",", "vtype", "=", "GRB", ".", "BINARY", ",", "name", "=", "'e'", ")", "\n", "for", "i", ",", "j", "in", "vars", ".", "keys", "(", ")", ":", "\n", "        ", "vars", "[", "j", ",", "i", "]", "=", "vars", "[", "i", ",", "j", "]", "# edge in opposite direction", "\n", "\n", "# You could use Python looping constructs and m.addVar() to create", "\n", "# these decision variables instead.  The following would be equivalent", "\n", "# to the preceding m.addVars() call...", "\n", "#", "\n", "# vars = tupledict()", "\n", "# for i,j in dist.keys():", "\n", "#   vars[i,j] = m.addVar(obj=dist[i,j], vtype=GRB.BINARY,", "\n", "#                        name='e[%d,%d]'%(i,j))", "\n", "\n", "\n", "# Add degree-2 constraint", "\n", "\n", "", "m", ".", "addConstrs", "(", "vars", ".", "sum", "(", "i", ",", "'*'", ")", "==", "2", "for", "i", "in", "range", "(", "n", ")", ")", "\n", "\n", "# Using Python looping constructs, the preceding would be...", "\n", "#", "\n", "# for i in range(n):", "\n", "#   m.addConstr(sum(vars[i,j] for j in range(n)) == 2)", "\n", "\n", "\n", "# Optimize model", "\n", "\n", "m", ".", "_vars", "=", "vars", "\n", "m", ".", "Params", ".", "lazyConstraints", "=", "1", "\n", "m", ".", "Params", ".", "threads", "=", "threads", "\n", "if", "timeout", ":", "\n", "        ", "m", ".", "Params", ".", "timeLimit", "=", "timeout", "\n", "", "if", "gap", ":", "\n", "        ", "m", ".", "Params", ".", "mipGap", "=", "gap", "*", "0.01", "# Percentage", "\n", "", "m", ".", "optimize", "(", "subtourelim", ")", "\n", "\n", "vals", "=", "m", ".", "getAttr", "(", "'x'", ",", "vars", ")", "\n", "selected", "=", "tuplelist", "(", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "vals", ".", "keys", "(", ")", "if", "vals", "[", "i", ",", "j", "]", ">", "0.5", ")", "\n", "\n", "tour", "=", "subtour", "(", "selected", ")", "\n", "assert", "len", "(", "tour", ")", "==", "n", "\n", "\n", "return", "m", ".", "objVal", ",", "tour", "\n", "\n", "\n", "", "def", "solve_all_gurobi", "(", "dataset", ")", ":", "\n", "    ", "results", "=", "[", "]", "\n", "for", "i", ",", "instance", "in", "enumerate", "(", "dataset", ")", ":", "\n", "        ", "print", "(", "\"Solving instance {}\"", ".", "format", "(", "i", ")", ")", "\n", "result", "=", "solve_euclidian_tsp", "(", "instance", ")", "\n", "results", ".", "append", "(", "result", ")", "\n", "", "return", "results", "\n", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_gurobi.solve_all_gurobi": [[139, 146], ["enumerate", "print", "tsp_gurobi.solve_euclidian_tsp", "results.append"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_gurobi.solve_euclidian_tsp"], []], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.solve_gurobi": [[17, 51], ["os.path.join", "tsp_baseline.calc_tsp_length", "os.path.isfile", "utils.data_utils.load_dataset", "time.time", "solve_euclidian_tsp_gurobi", "print", "print", "time.time", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length", "home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset"], ["# Lazy import so we do not need to have gurobi installed to run this script", "\n", "    ", "from", "problems", ".", "tsp", ".", "tsp_gurobi", "import", "solve_euclidian_tsp", "as", "solve_euclidian_tsp_gurobi", "\n", "\n", "try", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.gurobi{}{}.pkl\"", ".", "format", "(", "\n", "name", ",", "\"\"", "if", "timeout", "is", "None", "else", "\"t{}\"", ".", "format", "(", "timeout", ")", ",", "\"\"", "if", "gap", "is", "None", "else", "\"gap{}\"", ".", "format", "(", "gap", ")", ")", ")", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "problem_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "(", "cost", ",", "tour", ",", "duration", ")", "=", "load_dataset", "(", "problem_filename", ")", "\n", "", "else", ":", "\n", "# 0 = start, 1 = end so add depot twice", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "cost", ",", "tour", "=", "solve_euclidian_tsp_gurobi", "(", "loc", ",", "threads", "=", "1", ",", "timeout", "=", "timeout", ",", "gap", "=", "gap", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "# Measure clock time", "\n", "save_dataset", "(", "(", "cost", ",", "tour", ",", "duration", ")", ",", "problem_filename", ")", "\n", "\n", "# First and last node are depot(s), so first node is 2 but should be 1 (as depot is 0) so subtract 1", "\n", "", "total_cost", "=", "calc_tsp_length", "(", "loc", ",", "tour", ")", "\n", "assert", "abs", "(", "total_cost", "-", "cost", ")", "<=", "1e-5", ",", "\"Cost is incorrect\"", "\n", "return", "total_cost", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "# For some stupid reason, sometimes OR tools cannot find a feasible solution?", "\n", "# By letting it fail we do not get total results, but we dcan retry by the caching mechanism", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n", "\n", "", "", "def", "solve_concorde_log", "(", "executable", ",", "directory", ",", "name", ",", "loc", ",", "disable_cache", "=", "False", ")", ":", "\n", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.tsp\"", ".", "format", "(", "name", ")", ")", "\n", "tour_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.tour\"", ".", "format", "(", "name", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.concorde.pkl\"", ".", "format", "(", "name", ")", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.solve_concorde_log": [[53, 135], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "tsp_baseline.read_concorde_tour", "tsp_baseline.calc_tsp_length", "print", "print", "loc.append", "len", "numpy.array", "tsp_baseline.write_shpplib", "tsp_baseline.write_tsplib", "open", "time.time", "numpy.array", "numpy.array", "subprocess.check_call", "time.time", "np.array.reverse", "numpy.array", "numpy.concatenate", "numpy.array", "tsp_baseline.calc_shpp_length", "int", "os.path.abspath", "os.path.abspath", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.read_concorde_tour", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_shpplib", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_tsplib", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_shpp_length"], ["\n", "# if True:", "\n", "try", ":", "\n", "# May have already been run", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "tour", ",", "duration", "=", "load_dataset", "(", "output_filename", ")", "\n", "", "else", ":", "\n", "            ", "write_tsplib", "(", "problem_filename", ",", "loc", ",", "name", "=", "name", ")", "\n", "\n", "with", "open", "(", "log_filename", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "start", "=", "time", ".", "time", "(", ")", "\n", "try", ":", "\n", "# Concorde is weird, will leave traces of solution in current directory so call from target dir", "\n", "                    ", "check_call", "(", "[", "executable", ",", "'-s'", ",", "'1234'", ",", "'-x'", ",", "'-o'", ",", "\n", "os", ".", "path", ".", "abspath", "(", "tour_filename", ")", ",", "os", ".", "path", ".", "abspath", "(", "problem_filename", ")", "]", ",", "\n", "stdout", "=", "f", ",", "stderr", "=", "f", ",", "cwd", "=", "directory", ")", "\n", "", "except", "CalledProcessError", "as", "e", ":", "\n", "# Somehow Concorde returns 255", "\n", "                    ", "assert", "e", ".", "returncode", "==", "255", "\n", "", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "", "tour", "=", "read_concorde_tour", "(", "tour_filename", ")", "\n", "save_dataset", "(", "(", "tour", ",", "duration", ")", ",", "output_filename", ")", "\n", "\n", "", "return", "calc_tsp_length", "(", "loc", ",", "tour", ")", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n", "\n", "", "", "def", "solve_lkh_log", "(", "executable", ",", "directory", ",", "name", ",", "loc", ",", "runs", "=", "1", ",", "disable_cache", "=", "False", ")", ":", "\n", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.vrp\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "tour_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.tour\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.pkl\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "param_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.par\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "log_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.lkh{}.log\"", ".", "format", "(", "name", ",", "runs", ")", ")", "\n", "\n", "try", ":", "\n", "# May have already been run", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "tour", ",", "duration", "=", "load_dataset", "(", "output_filename", ")", "\n", "", "else", ":", "\n", "            ", "write_tsplib", "(", "problem_filename", ",", "loc", ",", "name", "=", "name", ")", "\n", "\n", "params", "=", "{", "\"PROBLEM_FILE\"", ":", "problem_filename", ",", "\"OUTPUT_TOUR_FILE\"", ":", "tour_filename", ",", "\"RUNS\"", ":", "runs", ",", "\"SEED\"", ":", "1234", "}", "\n", "write_lkh_par", "(", "param_filename", ",", "params", ")", "\n", "\n", "with", "open", "(", "log_filename", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "start", "=", "time", ".", "time", "(", ")", "\n", "check_call", "(", "[", "executable", ",", "param_filename", "]", ",", "stdout", "=", "f", ",", "stderr", "=", "f", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "", "tour", "=", "read_tsplib", "(", "tour_filename", ")", "\n", "save_dataset", "(", "(", "tour", ",", "duration", ")", ",", "output_filename", ")", "\n", "\n", "", "return", "calc_tsp_length", "(", "loc", ",", "tour", ")", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n", "\n", "", "", "def", "write_lkh_par", "(", "filename", ",", "parameters", ")", ":", "\n", "    ", "default_parameters", "=", "{", "# Use none to include as flag instead of kv", "\n", "\"MAX_TRIALS\"", ":", "10000", ",", "\n", "\"RUNS\"", ":", "10", ",", "\n", "\"TRACE_LEVEL\"", ":", "1", ",", "\n", "\"SEED\"", ":", "0", "\n", "}", "\n", "with", "open", "(", "filename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "for", "k", ",", "v", "in", "{", "**", "default_parameters", ",", "**", "parameters", "}", ".", "items", "(", ")", ":", "\n", "            ", "if", "v", "is", "None", ":", "\n", "                ", "f", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "k", ")", ")", "\n", "", "else", ":", "\n", "                ", "f", ".", "write", "(", "\"{} = {}\\n\"", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "\n", "\n", "", "", "", "", "def", "write_tsplib", "(", "filename", ",", "loc", ",", "name", "=", "\"problem\"", ")", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.solve_lkh_log": [[137, 169], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.isfile", "utils.data_utils.load_dataset", "tsp_baseline.write_tsplib", "tsp_baseline.write_lkh_par", "tsp_baseline.read_tsplib", "utils.data_utils.save_dataset", "tsp_baseline.calc_tsp_length", "print", "print", "open", "time.time", "subprocess.check_call", "time.time"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_tsplib", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_lkh_par", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.read_tsplib", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length"], ["        ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{} : {}\"", ".", "format", "(", "k", ",", "v", ")", "\n", "for", "k", ",", "v", "in", "(", "\n", "(", "\"NAME\"", ",", "name", ")", ",", "\n", "(", "\"TYPE\"", ",", "\"TSP\"", ")", ",", "\n", "(", "\"DIMENSION\"", ",", "len", "(", "loc", ")", ")", ",", "\n", "(", "\"EDGE_WEIGHT_TYPE\"", ",", "\"EUC_2D\"", ")", ",", "\n", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"NODE_COORD_SECTION\\n\"", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{}\\t{}\\t{}\"", ".", "format", "(", "i", "+", "1", ",", "int", "(", "x", "*", "10000000", "+", "0.5", ")", ",", "int", "(", "y", "*", "10000000", "+", "0.5", ")", ")", "# tsplib does not take floats", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "loc", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"EOF\\n\"", ")", "\n", "\n", "\n", "", "", "def", "read_concorde_tour", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "n", "=", "None", "\n", "tour", "=", "[", "]", "\n", "for", "line", "in", "f", ":", "\n", "            ", "if", "n", "is", "None", ":", "\n", "                ", "n", "=", "int", "(", "line", ")", "\n", "", "else", ":", "\n", "                ", "tour", ".", "extend", "(", "[", "int", "(", "node", ")", "for", "node", "in", "line", ".", "rstrip", "(", ")", ".", "split", "(", "\" \"", ")", "]", ")", "\n", "", "", "", "assert", "len", "(", "tour", ")", "==", "n", ",", "\"Unexpected tour length\"", "\n", "return", "tour", "\n", "\n", "\n", "", "def", "read_tsplib", "(", "filename", ")", ":", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_lkh_par": [[171, 184], ["open", "f.write", "f.write"], "function", ["None"], ["        ", "tour", "=", "[", "]", "\n", "dimension", "=", "0", "\n", "started", "=", "False", "\n", "for", "line", "in", "f", ":", "\n", "            ", "if", "started", ":", "\n", "                ", "loc", "=", "int", "(", "line", ")", "\n", "if", "loc", "==", "-", "1", ":", "\n", "                    ", "break", "\n", "", "tour", ".", "append", "(", "loc", ")", "\n", "", "if", "line", ".", "startswith", "(", "\"DIMENSION\"", ")", ":", "\n", "                ", "dimension", "=", "int", "(", "line", ".", "split", "(", "\" \"", ")", "[", "-", "1", "]", ")", "\n", "\n", "", "if", "line", ".", "startswith", "(", "\"TOUR_SECTION\"", ")", ":", "\n", "                ", "started", "=", "True", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_tsplib": [[186, 206], ["open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "int", "int", "enumerate", "len"], "function", ["None"], ["", "", "", "assert", "len", "(", "tour", ")", "==", "dimension", "\n", "tour", "=", "np", ".", "array", "(", "tour", ")", ".", "astype", "(", "int", ")", "-", "1", "# Subtract 1 as depot is 1 and should be 0", "\n", "return", "tour", ".", "tolist", "(", ")", "\n", "\n", "\n", "", "def", "calc_tsp_length", "(", "loc", ",", "tour", ")", ":", "\n", "    ", "assert", "len", "(", "np", ".", "unique", "(", "tour", ")", ")", "==", "len", "(", "tour", ")", ",", "\"Tour cannot contain duplicates\"", "\n", "assert", "len", "(", "tour", ")", "==", "len", "(", "loc", ")", "\n", "sorted_locs", "=", "np", ".", "array", "(", "loc", ")", "[", "np", ".", "concatenate", "(", "(", "tour", ",", "[", "tour", "[", "0", "]", "]", ")", ")", "]", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "sorted_locs", "[", "1", ":", "]", "-", "sorted_locs", "[", ":", "-", "1", "]", ",", "axis", "=", "-", "1", ")", ".", "sum", "(", ")", "\n", "\n", "\n", "", "def", "_calc_insert_cost", "(", "D", ",", "prv", ",", "nxt", ",", "ins", ")", ":", "\n", "    ", "\"\"\"\n    Calculates insertion costs of inserting ins between prv and nxt\n    :param D: distance matrix\n    :param prv: node before inserted node, can be vector\n    :param nxt: node after inserted node, can be vector\n    :param ins: node to insert\n    :return:\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.write_shpplib": [[209, 240], ["open", "f.write", "f.write", "f.write", "range", "f.write", "f.write", "f.write", "range", "f.write", "int"], "function", ["None"], ["+", "D", "[", "ins", ",", "nxt", "]", "\n", "-", "D", "[", "prv", ",", "nxt", "]", "\n", ")", "\n", "\n", "\n", "", "def", "run_insertion", "(", "loc", ",", "method", ")", ":", "\n", "    ", "n", "=", "len", "(", "loc", ")", "\n", "D", "=", "distance_matrix", "(", "loc", ",", "loc", ")", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "n", ",", "dtype", "=", "bool", ")", "\n", "tour", "=", "[", "]", "# np.empty((0, ), dtype=int)", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "feas", "=", "mask", "==", "0", "\n", "feas_ind", "=", "np", ".", "flatnonzero", "(", "mask", "==", "0", ")", "\n", "if", "method", "==", "'random'", ":", "\n", "# Order of instance is random so do in order for deterministic results", "\n", "            ", "a", "=", "i", "\n", "", "elif", "method", "==", "'nearest'", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "a", "=", "0", "# order does not matter so first is random", "\n", "", "else", ":", "\n", "                ", "a", "=", "feas_ind", "[", "D", "[", "np", ".", "ix_", "(", "feas", ",", "~", "feas", ")", "]", ".", "min", "(", "1", ")", ".", "argmin", "(", ")", "]", "# node nearest to any in tour", "\n", "", "", "elif", "method", "==", "'cheapest'", ":", "\n", "            ", "assert", "False", ",", "\"Not yet implemented\"", "# try all and find cheapest insertion cost", "\n", "\n", "", "elif", "method", "==", "'farthest'", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "a", "=", "D", ".", "max", "(", "1", ")", ".", "argmax", "(", ")", "# Node with farthest distance to any other node", "\n", "", "else", ":", "\n", "                ", "a", "=", "feas_ind", "[", "D", "[", "np", ".", "ix_", "(", "feas", ",", "~", "feas", ")", "]", ".", "min", "(", "1", ")", ".", "argmax", "(", ")", "]", "# node which has closest node in tour farthest", "\n", "", "", "mask", "[", "a", "]", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.read_concorde_tour": [[242, 253], ["open", "len", "int", "tour.extend", "int", "line.rstrip().split", "line.rstrip"], "function", ["None"], ["            ", "tour", "=", "[", "a", "]", "\n", "", "else", ":", "\n", "# Find index with least insert cost", "\n", "            ", "ind_insert", "=", "np", ".", "argmin", "(", "\n", "_calc_insert_cost", "(", "\n", "D", ",", "\n", "tour", ",", "\n", "np", ".", "roll", "(", "tour", ",", "-", "1", ")", ",", "\n", "a", "\n", ")", "\n", ")", "\n", "tour", ".", "insert", "(", "ind_insert", "+", "1", ",", "a", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.read_tsplib": [[255, 275], ["tour.tolist", "open", "len", "numpy.array().astype", "line.startswith", "line.startswith", "int", "tour.append", "int", "numpy.array", "line.split"], "function", ["None"], ["", "", "cost", "=", "D", "[", "tour", ",", "np", ".", "roll", "(", "tour", ",", "-", "1", ")", "]", ".", "sum", "(", ")", "\n", "return", "cost", ",", "tour", "\n", "\n", "\n", "", "def", "solve_insertion", "(", "directory", ",", "name", ",", "loc", ",", "method", "=", "'random'", ")", ":", "\n", "    ", "start", "=", "time", ".", "time", "(", ")", "\n", "cost", ",", "tour", "=", "run_insertion", "(", "loc", ",", "method", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "return", "cost", ",", "tour", ",", "duration", "\n", "\n", "\n", "", "def", "calc_batch_pdist", "(", "dataset", ")", ":", "\n", "    ", "diff", "=", "(", "dataset", "[", ":", ",", ":", ",", "None", ",", ":", "]", "-", "dataset", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", "\n", "return", "torch", ".", "matmul", "(", "diff", "[", ":", ",", ":", ",", ":", ",", "None", ",", ":", "]", ",", "diff", "[", ":", ",", ":", ",", ":", ",", ":", ",", "None", "]", ")", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", ".", "sqrt", "(", ")", "\n", "\n", "\n", "", "def", "nearest_neighbour", "(", "dataset", ",", "start", "=", "'first'", ")", ":", "\n", "    ", "dist", "=", "calc_batch_pdist", "(", "dataset", ")", "\n", "\n", "batch_size", ",", "graph_size", ",", "_", "=", "dataset", ".", "size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_tsp_length": [[277, 282], ["numpy.linalg.norm().sum", "len", "len", "len", "len", "numpy.array", "numpy.unique", "numpy.concatenate", "numpy.linalg.norm"], "function", ["None"], ["\n", "if", "not", "isinstance", "(", "start", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "if", "start", "==", "'random'", ":", "\n", "            ", "start", "=", "dataset", ".", "new", "(", ")", ".", "long", "(", ")", ".", "new", "(", "batch_size", ")", ".", "zero_", "(", ")", ".", "random_", "(", "0", ",", "graph_size", ")", "\n", "", "elif", "start", "==", "'first'", ":", "\n", "            ", "start", "=", "dataset", ".", "new", "(", ")", ".", "long", "(", ")", ".", "new", "(", "batch_size", ")", ".", "zero_", "(", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_shpp_length": [[283, 286], ["numpy.linalg.norm().sum", "numpy.array", "numpy.linalg.norm"], "function", ["None"], ["", "elif", "start", "==", "'center'", ":", "\n", "            ", "_", ",", "start", "=", "dist", ".", "mean", "(", "2", ")", ".", "min", "(", "1", ")", "# Minimum total distance to others", "\n", "", "else", ":", "\n", "            ", "assert", "False", ",", "\"Unknown start: {}\"", ".", "format", "(", "start", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline._calc_insert_cost": [[288, 301], ["None"], "function", ["None"], ["", "", "current", "=", "start", "\n", "dist_to_startnode", "=", "torch", ".", "gather", "(", "dist", ",", "2", ",", "current", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "batch_size", ",", "graph_size", ",", "1", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "tour", "=", "[", "current", "]", "\n", "\n", "for", "i", "in", "range", "(", "graph_size", "-", "1", ")", ":", "\n", "# Mark out current node as option", "\n", "        ", "dist", ".", "scatter_", "(", "2", ",", "current", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "batch_size", ",", "graph_size", ",", "1", ")", ",", "np", ".", "inf", ")", "\n", "nn_dist", "=", "torch", ".", "gather", "(", "dist", ",", "1", ",", "current", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "batch_size", ",", "1", ",", "graph_size", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "min_nn_dist", ",", "current", "=", "nn_dist", ".", "min", "(", "1", ")", "\n", "total_dist", "+=", "min_nn_dist", "\n", "tour", ".", "append", "(", "current", ")", "\n", "\n", "", "total_dist", "+=", "torch", ".", "gather", "(", "dist_to_startnode", ",", "1", ",", "current", ".", "view", "(", "-", "1", ",", "1", ")", ")", ".", "squeeze", "(", "1", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.run_insertion": [[304, 347], ["len", "scipy.spatial.distance_matrix", "numpy.zeros", "range", "D[].sum", "numpy.flatnonzero", "len", "numpy.argmin", "tour.insert", "tsp_baseline._calc_insert_cost", "numpy.roll", "numpy.roll", "D[].min().argmin", "scipy.spatial.distance_matrix.max().argmax", "D[].min", "scipy.spatial.distance_matrix.max", "D[].min().argmax", "D[].min", "numpy.ix_", "numpy.ix_"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline._calc_insert_cost"], ["\n", "\n", "", "def", "solve_all_nn", "(", "dataset_path", ",", "eval_batch_size", "=", "1024", ",", "no_cuda", "=", "False", ",", "dataset_n", "=", "None", ",", "progress_bar_mininterval", "=", "0.1", ")", ":", "\n", "    ", "import", "torch", "\n", "from", "torch", ".", "utils", ".", "data", "import", "DataLoader", "\n", "from", "problems", "import", "TSP", "\n", "from", "utils", "import", "move_to", "\n", "\n", "dataloader", "=", "DataLoader", "(", "\n", "TSP", ".", "make_dataset", "(", "filename", "=", "dataset_path", ",", "num_samples", "=", "dataset_n", "if", "dataset_n", "is", "not", "None", "else", "1000000", ")", ",", "\n", "batch_size", "=", "eval_batch_size", "\n", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "not", "no_cuda", "else", "\"cpu\"", ")", "\n", "results", "=", "[", "]", "\n", "for", "batch", "in", "tqdm", "(", "dataloader", ",", "mininterval", "=", "progress_bar_mininterval", ")", ":", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "batch", "=", "move_to", "(", "batch", ",", "device", ")", "\n", "\n", "lengths", ",", "tours", "=", "nearest_neighbour", "(", "batch", ")", "\n", "lengths_check", ",", "_", "=", "TSP", ".", "get_costs", "(", "batch", ",", "tours", ")", "\n", "\n", "assert", "(", "torch", ".", "abs", "(", "lengths", "-", "lengths_check", ".", "data", ")", "<", "1e-5", ")", ".", "all", "(", ")", "\n", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "results", ".", "extend", "(", "\n", "[", "(", "cost", ".", "item", "(", ")", ",", "np", ".", "trim_zeros", "(", "pi", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "'b'", ")", ",", "duration", ")", "for", "cost", ",", "pi", "in", "zip", "(", "lengths", ",", "tours", ")", "]", ")", "\n", "\n", "", "return", "results", ",", "eval_batch_size", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"method\"", ",", "\n", "help", "=", "\"Name of the method to evaluate, 'nn', 'gurobi' or '(nearest|random|farthest)_insertion'\"", ")", "\n", "parser", ".", "add_argument", "(", "\"datasets\"", ",", "nargs", "=", "'+'", ",", "help", "=", "\"Filename of the dataset(s) to evaluate\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "action", "=", "'store_true'", ",", "help", "=", "\"Set true to overwrite\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "default", "=", "None", ",", "help", "=", "\"Name of the results file to write\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--cpus\"", ",", "type", "=", "int", ",", "help", "=", "\"Number of CPUs to use, defaults to all cores\"", ")", "\n", "parser", ".", "add_argument", "(", "'--no_cuda'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Disable CUDA (only for Tsiligirides)'", ")", "\n", "parser", ".", "add_argument", "(", "'--disable_cache'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Disable caching'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_calc_batch_size'", ",", "type", "=", "int", ",", "default", "=", "1000", ",", "help", "=", "'Size for subbatches'", ")", "\n", "parser", ".", "add_argument", "(", "'--progress_bar_mininterval'", ",", "type", "=", "float", ",", "default", "=", "0.1", ",", "help", "=", "'Minimum interval'", ")", "\n", "parser", ".", "add_argument", "(", "'-n'", ",", "type", "=", "int", ",", "help", "=", "\"Number of instances to process\"", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.solve_insertion": [[349, 354], ["time.time", "tsp_baseline.run_insertion", "time.time"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.run_insertion"], ["parser", ".", "add_argument", "(", "'--results_dir'", ",", "default", "=", "'results'", ",", "help", "=", "\"Name of results directory\"", ")", "\n", "\n", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "assert", "opts", ".", "o", "is", "None", "or", "len", "(", "opts", ".", "datasets", ")", "==", "1", ",", "\"Cannot specify result filename with more than one dataset\"", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_batch_pdist": [[356, 359], ["torch.matmul().squeeze().squeeze().sqrt", "torch.matmul().squeeze().squeeze", "torch.matmul().squeeze", "torch.matmul", "numpy.np.inf"], "function", ["None"], ["\n", "        ", "assert", "os", ".", "path", ".", "isfile", "(", "check_extension", "(", "dataset_path", ")", ")", ",", "\"File does not exist!\"", "\n", "\n", "dataset_basename", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "split", "(", "dataset_path", ")", "[", "-", "1", "]", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.nearest_neighbour": [[361, 394], ["tsp_baseline.calc_batch_pdist", "dataset.size", "dataset.new().zero_", "torch.gather().squeeze", "range", "torch.gather().squeeze", "isinstance", "calc_batch_pdist.scatter_", "torch.gather().squeeze", "torch.gather().squeeze.min", "tour.append", "torch.stack", "dataset.new", "dataset.new().long().new().zero_().random_", "torch.gather", "current.view().expand", "torch.gather", "dataset.new().long().new().zero_", "current.view().expand", "torch.gather", "current.view", "dataset.new().long().new().zero_", "calc_batch_pdist.mean().min", "current.view", "current.view().expand", "dataset.new().long().new", "current.view", "dataset.new().long().new", "calc_batch_pdist.mean", "current.view", "dataset.new().long", "dataset.new().long", "dataset.new", "dataset.new"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.calc_batch_pdist", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand"], ["if", "opts", ".", "o", "is", "None", ":", "\n", "            ", "results_dir", "=", "os", ".", "path", ".", "join", "(", "opts", ".", "results_dir", ",", "\"tsp\"", ",", "dataset_basename", ")", "\n", "os", ".", "makedirs", "(", "results_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "results_dir", ",", "\"{}{}{}-{}{}\"", ".", "format", "(", "\n", "dataset_basename", ",", "\n", "\"offs{}\"", ".", "format", "(", "opts", ".", "offset", ")", "if", "opts", ".", "offset", "is", "not", "None", "else", "\"\"", ",", "\n", "\"n{}\"", ".", "format", "(", "opts", ".", "n", ")", "if", "opts", ".", "n", "is", "not", "None", "else", "\"\"", ",", "\n", "opts", ".", "method", ",", "ext", "\n", ")", ")", "\n", "", "else", ":", "\n", "            ", "out_file", "=", "opts", ".", "o", "\n", "\n", "", "assert", "opts", ".", "f", "or", "not", "os", ".", "path", ".", "isfile", "(", "\n", "out_file", ")", ",", "\"File already exists! Try running with -f option to overwrite.\"", "\n", "\n", "match", "=", "re", ".", "match", "(", "r'^([a-z_]+)(\\d*)$'", ",", "opts", ".", "method", ")", "\n", "assert", "match", "\n", "method", "=", "match", "[", "1", "]", "\n", "runs", "=", "1", "if", "match", "[", "2", "]", "==", "''", "else", "int", "(", "match", "[", "2", "]", ")", "\n", "\n", "if", "method", "==", "\"nn\"", ":", "\n", "            ", "assert", "opts", ".", "offset", "is", "None", ",", "\"Offset not supported for nearest neighbor\"", "\n", "\n", "eval_batch_size", "=", "opts", ".", "max_calc_batch_size", "\n", "\n", "results", ",", "parallelism", "=", "solve_all_nn", "(", "\n", "dataset_path", ",", "eval_batch_size", ",", "opts", ".", "no_cuda", ",", "opts", ".", "n", ",", "\n", "opts", ".", "progress_bar_mininterval", "\n", ")", "\n", "", "elif", "method", "in", "(", "\"gurobi\"", ",", "\"gurobigap\"", ",", "\"gurobit\"", ",", "\"concorde\"", ",", "\"lkh\"", ")", "or", "method", "[", "-", "9", ":", "]", "==", "'insertion'", ":", "\n", "\n", "            ", "target_dir", "=", "os", ".", "path", ".", "join", "(", "results_dir", ",", "\"{}-{}\"", ".", "format", "(", "\n", "dataset_basename", ",", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.solve_all_nn": [[396, 422], ["DataLoader", "torch.device", "tqdm.tqdm", "TSP.make_dataset", "time.time", "move_to", "tsp_baseline.nearest_neighbour", "TSP.get_costs", "results.extend", "time.time", "torch.cuda.is_available", "torch.abs", "cost.item", "numpy.trim_zeros", "zip", "pi.cpu().numpy", "pi.cpu"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.move_to", "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.tsp_baseline.nearest_neighbour", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.cpu"], [")", ")", "\n", "assert", "opts", ".", "f", "or", "not", "os", ".", "path", ".", "isdir", "(", "target_dir", ")", ",", "\"Target dir already exists! Try running with -f option to overwrite.\"", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "target_dir", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "target_dir", ")", "\n", "\n", "# TSP contains single loc array rather than tuple", "\n", "", "dataset", "=", "[", "(", "instance", ",", ")", "for", "instance", "in", "load_dataset", "(", "dataset_path", ")", "]", "\n", "\n", "if", "method", "==", "\"concorde\"", ":", "\n", "                ", "use_multiprocessing", "=", "False", "\n", "executable", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "'problems'", ",", "'tsp'", ",", "'concorde'", ",", "'concorde'", ",", "'TSP'", ",", "'concorde'", ")", ")", "\n", "\n", "def", "run_func", "(", "args", ")", ":", "\n", "                    ", "return", "solve_concorde_log", "(", "executable", ",", "*", "args", ",", "disable_cache", "=", "opts", ".", "disable_cache", ")", "\n", "\n", "", "", "elif", "method", "==", "\"lkh\"", ":", "\n", "                ", "use_multiprocessing", "=", "False", "\n", "executable", "=", "get_lkh_executable", "(", ")", "\n", "\n", "def", "run_func", "(", "args", ")", ":", "\n", "                    ", "return", "solve_lkh_log", "(", "executable", ",", "*", "args", ",", "runs", "=", "runs", ",", "disable_cache", "=", "opts", ".", "disable_cache", ")", "\n", "\n", "", "", "elif", "method", "[", ":", "6", "]", "==", "\"gurobi\"", ":", "\n", "                ", "use_multiprocessing", "=", "True", "# We run one thread per instance", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.problem_tsp.TSP.get_costs": [[13, 25], ["dataset.gather", "pi.unsqueeze().expand_as", "pi.unsqueeze"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "get_costs", "(", "dataset", ",", "pi", ",", "return_local", "=", "False", ")", ":", "\n", "# Check that tours are valid, i.e. contain 0 to n -1", "\n", "\n", "        ", "if", "(", "return_local", ")", ":", "\n", "            ", "d", "=", "dataset", "\n", "return", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "2", ")", ".", "sum", "(", "1", ")", "\n", "# Gather dataset in order of tour", "\n", "", "d", "=", "dataset", ".", "gather", "(", "1", ",", "pi", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand_as", "(", "dataset", ")", ")", "\n", "\n", "# Length is distance (L2-norm of difference) from each next location from its prev and of last from first", "\n", "return", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "2", ")", ".", "sum", "(", "1", ")", "+", "(", "d", "[", ":", ",", "0", "]", "-", "d", "[", ":", ",", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", ",", "None", "\n", "", "def", "get_costs_local", "(", "dataset", ",", "pi", ",", "return_two", "=", "False", ")", ":", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.problem_tsp.TSP.get_costs_local": [[25, 34], ["dataset.gather", "pi.unsqueeze().expand_as", "pi.unsqueeze"], "methods", ["None"], ["", "def", "get_costs_local", "(", "dataset", ",", "pi", ",", "return_two", "=", "False", ")", ":", "\n", "# Check that tours are valid, i.e. contain 0 to n -1", "\n", "\n", "\n", "# Gather dataset in order of tour", "\n", "        ", "d", "=", "dataset", ".", "gather", "(", "1", ",", "pi", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand_as", "(", "dataset", ")", ")", "\n", "\n", "# Length is distance (L2-norm of difference) from each next location from its prev and of last from first", "\n", "return", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "2", ")", ".", "sum", "(", "1", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.problem_tsp.TSP.make_dataset": [[35, 38], ["problem_tsp.TSPDataset"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_dataset", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "TSPDataset", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.problem_tsp.TSP.make_state": [[39, 42], ["problems.tsp.state_tsp.StateTSP.initialize"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize"], ["", "@", "staticmethod", "\n", "def", "make_state", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "StateTSP", ".", "initialize", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.problem_tsp.TSP.beam_search": [[43, 61], ["model.precompute_fixed", "problem_tsp.TSP.make_state", "utils.beam_search.beam_search", "model.propose_expansions"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.precompute_fixed", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions"], ["", "@", "staticmethod", "\n", "def", "beam_search", "(", "input", ",", "beam_size", ",", "expand_size", "=", "None", ",", "\n", "compress_mask", "=", "False", ",", "model", "=", "None", ",", "max_calc_batch_size", "=", "4096", ")", ":", "\n", "\n", "        ", "assert", "model", "is", "not", "None", ",", "\"Provide model\"", "\n", "\n", "fixed", "=", "model", ".", "precompute_fixed", "(", "input", ")", "\n", "\n", "def", "propose_expansions", "(", "beam", ")", ":", "\n", "            ", "return", "model", ".", "propose_expansions", "(", "\n", "beam", ",", "fixed", ",", "expand_size", ",", "normalize", "=", "True", ",", "max_calc_batch_size", "=", "max_calc_batch_size", "\n", ")", "\n", "\n", "", "state", "=", "TSP", ".", "make_state", "(", "\n", "input", ",", "visited_dtype", "=", "torch", ".", "int64", "if", "compress_mask", "else", "torch", ".", "uint8", "\n", ")", "\n", "\n", "return", "beam_search", "(", "state", ",", "beam_size", ",", "propose_expansions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.problem_tsp.TSPDataset.__init__": [[65, 80], ["torch.utils.data.Dataset.__init__", "len", "open", "pickle.load", "torch.FloatTensor().uniform_", "os.path.splitext", "torch.FloatTensor", "range", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load"], ["    ", "def", "__init__", "(", "self", ",", "filename", "=", "None", ",", "size", "=", "50", ",", "num_samples", "=", "1000000", ",", "offset", "=", "0", ",", "distribution", "=", "None", ")", ":", "\n", "        ", "super", "(", "TSPDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "data_set", "=", "[", "]", "\n", "if", "filename", "is", "not", "None", ":", "\n", "            ", "assert", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "==", "'.pkl'", "\n", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "self", ".", "data", "=", "[", "torch", ".", "FloatTensor", "(", "row", ")", "for", "row", "in", "(", "data", "[", "offset", ":", "offset", "+", "num_samples", "]", ")", "]", "\n", "", "", "else", ":", "\n", "# Sample points randomly in [0, 1] square", "\n", "            ", "self", ".", "data", "=", "[", "torch", ".", "FloatTensor", "(", "size", ",", "2", ")", ".", "uniform_", "(", "0", ",", "1", ")", "for", "i", "in", "range", "(", "num_samples", ")", "]", "\n", "\n", "", "self", ".", "size", "=", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.problem_tsp.TSPDataset.__len__": [[81, 83], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.problem_tsp.TSPDataset.__getitem__": [[84, 86], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "data", "[", "idx", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.visited": [[23, 29], ["utils.boolmask.mask_long2bool", "state_tsp.StateTSP.loc.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long2bool", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["@", "property", "\n", "def", "visited", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "            ", "return", "self", ".", "visited_", "\n", "", "else", ":", "\n", "            ", "return", "mask_long2bool", "(", "self", ".", "visited_", ",", "n", "=", "self", ".", "loc", ".", "size", "(", "-", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.__getitem__": [[30, 39], ["state_tsp.StateTSP._replace", "torch.is_tensor", "isinstance"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "# If tensor, idx all tensors by this tensor:", "\n", "return", "self", ".", "_replace", "(", "\n", "ids", "=", "self", ".", "ids", "[", "key", "]", ",", "\n", "first_a", "=", "self", ".", "first_a", "[", "key", "]", ",", "\n", "prev_a", "=", "self", ".", "prev_a", "[", "key", "]", ",", "\n", "visited_", "=", "self", ".", "visited_", "[", "key", "]", ",", "\n", "lengths", "=", "self", ".", "lengths", "[", "key", "]", ",", "\n", "cur_coord", "=", "self", ".", "cur_coord", "[", "key", "]", "if", "self", ".", "cur_coord", "is", "not", "None", "else", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.initialize": [[41, 64], ["loc.size", "torch.zeros", "state_tsp.StateTSP", "torch.zeros", "torch.zeros", "torch.arange", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "@", "staticmethod", "\n", "def", "initialize", "(", "loc", ",", "visited_dtype", "=", "torch", ".", "uint8", ")", ":", "\n", "\n", "        ", "batch_size", ",", "n_loc", ",", "_", "=", "loc", ".", "size", "(", ")", "\n", "prev_a", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "loc", ".", "device", ")", "\n", "return", "StateTSP", "(", "\n", "loc", "=", "loc", ",", "\n", "dist", "=", "(", "loc", "[", ":", ",", ":", ",", "None", ",", ":", "]", "-", "loc", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", ",", "\n", "ids", "=", "torch", ".", "arange", "(", "batch_size", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "[", ":", ",", "None", "]", ",", "# Add steps dimension", "\n", "first_a", "=", "prev_a", ",", "\n", "prev_a", "=", "prev_a", ",", "\n", "# Keep visited with depot so we can scatter efficiently (if there is an action for depot)", "\n", "visited_", "=", "(", "# Visited as mask is easier to understand, as long more memory efficient", "\n", "torch", ".", "zeros", "(", "\n", "batch_size", ",", "1", ",", "n_loc", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "loc", ".", "device", "\n", ")", "\n", "if", "visited_dtype", "==", "torch", ".", "uint8", "\n", "else", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "(", "n_loc", "+", "63", ")", "//", "64", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Ceil", "\n", ")", ",", "\n", "lengths", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "cur_coord", "=", "None", ",", "\n", "i", "=", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Vector with length num_steps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.get_final_cost": [[66, 72], ["state_tsp.StateTSP.all_finished"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished"], ["", "def", "get_final_cost", "(", "self", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "all_finished", "(", ")", "\n", "# assert self.visited_.", "\n", "\n", "return", "self", ".", "lengths", "+", "(", "self", ".", "loc", "[", "self", ".", "ids", ",", "self", ".", "first_a", ",", ":", "]", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.update": [[73, 99], ["state_tsp.StateTSP._replace", "state_tsp.StateTSP.visited_.scatter", "utils.boolmask.mask_long_scatter", "state_tsp.StateTSP.i.item"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long_scatter"], ["", "def", "update", "(", "self", ",", "selected", ")", ":", "\n", "\n", "# Update the state", "\n", "        ", "prev_a", "=", "selected", "[", ":", ",", "None", "]", "# Add dimension for step", "\n", "\n", "# Add the length", "\n", "# cur_coord = self.loc.gather(", "\n", "#     1,", "\n", "#     selected[:, None, None].expand(selected.size(0), 1, self.loc.size(-1))", "\n", "# )[:, 0, :]", "\n", "cur_coord", "=", "self", ".", "loc", "[", "self", ".", "ids", ",", "prev_a", "]", "\n", "lengths", "=", "self", ".", "lengths", "\n", "if", "self", ".", "cur_coord", "is", "not", "None", ":", "# Don't add length for first action (selection of start node)", "\n", "            ", "lengths", "=", "self", ".", "lengths", "+", "(", "cur_coord", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# (batch_dim, 1)", "\n", "\n", "# Update should only be called with just 1 parallel step, in which case we can check this way if we should update", "\n", "", "first_a", "=", "prev_a", "if", "self", ".", "i", ".", "item", "(", ")", "==", "0", "else", "self", ".", "first_a", "\n", "\n", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "# Add one dimension since we write a single value", "\n", "            ", "visited_", "=", "self", ".", "visited_", ".", "scatter", "(", "-", "1", ",", "prev_a", "[", ":", ",", ":", ",", "None", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "visited_", "=", "mask_long_scatter", "(", "self", ".", "visited_", ",", "prev_a", ")", "\n", "\n", "", "return", "self", ".", "_replace", "(", "first_a", "=", "first_a", ",", "prev_a", "=", "prev_a", ",", "visited_", "=", "visited_", ",", "\n", "lengths", "=", "lengths", ",", "cur_coord", "=", "cur_coord", ",", "i", "=", "self", ".", "i", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.all_finished": [[100, 103], ["state_tsp.StateTSP.i.item", "state_tsp.StateTSP.loc.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "all_finished", "(", "self", ")", ":", "\n", "# Exactly n steps", "\n", "        ", "return", "self", ".", "i", ".", "item", "(", ")", ">=", "self", ".", "loc", ".", "size", "(", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.get_current_node": [[104, 106], ["None"], "methods", ["None"], ["", "def", "get_current_node", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "prev_a", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.get_mask": [[107, 109], ["None"], "methods", ["None"], ["", "def", "get_mask", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "visited", ">", "0", "# Hacky way to return bool or uint8 depending on pytorch version", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.get_nn": [[110, 116], ["state_tsp.StateTSP.loc.size", "state_tsp.StateTSP.i.item", "state_tsp.StateTSP.visited.float"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "get_nn", "(", "self", ",", "k", "=", "None", ")", ":", "\n", "# Insert step dimension", "\n", "# Nodes already visited get inf so they do not make it", "\n", "        ", "if", "k", "is", "None", ":", "\n", "            ", "k", "=", "self", ".", "loc", ".", "size", "(", "-", "2", ")", "-", "self", ".", "i", ".", "item", "(", ")", "# Number of remaining", "\n", "", "return", "(", "self", ".", "dist", "[", "self", ".", "ids", ",", ":", ",", ":", "]", "+", "self", ".", "visited", ".", "float", "(", ")", "[", ":", ",", ":", ",", "None", ",", ":", "]", "*", "1e6", ")", ".", "topk", "(", "k", ",", "dim", "=", "-", "1", ",", "largest", "=", "False", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.get_nn_current": [[117, 131], ["min", "state_tsp.StateTSP.loc.size", "state_tsp.StateTSP.loc.size", "state_tsp.StateTSP.i.item", "state_tsp.StateTSP.visited.float"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "get_nn_current", "(", "self", ",", "k", "=", "None", ")", ":", "\n", "        ", "assert", "False", ",", "\"Currently not implemented, look into which neighbours to use in step 0?\"", "\n", "# Note: if this is called in step 0, it will have k nearest neighbours to node 0, which may not be desired", "\n", "# so it is probably better to use k = None in the first iteration", "\n", "if", "k", "is", "None", ":", "\n", "            ", "k", "=", "self", ".", "loc", ".", "size", "(", "-", "2", ")", "\n", "", "k", "=", "min", "(", "k", ",", "self", ".", "loc", ".", "size", "(", "-", "2", ")", "-", "self", ".", "i", ".", "item", "(", ")", ")", "# Number of remaining", "\n", "return", "(", "\n", "self", ".", "dist", "[", "\n", "self", ".", "ids", ",", "\n", "self", ".", "prev_a", "\n", "]", "+", "\n", "self", ".", "visited", ".", "float", "(", ")", "*", "1e6", "\n", ")", ".", "topk", "(", "k", ",", "dim", "=", "-", "1", ",", "largest", "=", "False", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.tsp.state_tsp.StateTSP.construct_solutions": [[132, 134], ["None"], "methods", ["None"], ["", "def", "construct_solutions", "(", "self", ",", "actions", ")", ":", "\n", "        ", "return", "actions", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_gurobi.solve_euclidian_op": [[15, 120], ["len", "Model", "Model.addVars", "m.addVars.keys", "m.addVars.keys", "Model.addVars", "Model.addConstrs", "Model.addConstr", "Model.optimize", "Model.getAttr", "tuplelist", "op_gurobi.solve_euclidian_op.subtour"], "function", ["None"], ["def", "solve_euclidian_op", "(", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "threads", "=", "0", ",", "timeout", "=", "None", ",", "gap", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Solves the Euclidan op problem to optimality using the MIP formulation \n    with lazy subtour elimination constraint generation.\n    :param points: list of (x, y) coordinate \n    :return: \n    \"\"\"", "\n", "\n", "points", "=", "[", "depot", "]", "+", "loc", "\n", "n", "=", "len", "(", "points", ")", "\n", "\n", "# Callback - use lazy constraints to eliminate sub-tours", "\n", "\n", "def", "subtourelim", "(", "model", ",", "where", ")", ":", "\n", "        ", "if", "where", "==", "GRB", ".", "Callback", ".", "MIPSOL", ":", "\n", "# make a list of edges selected in the solution", "\n", "            ", "vals", "=", "model", ".", "cbGetSolution", "(", "model", ".", "_vars", ")", "\n", "selected", "=", "tuplelist", "(", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "model", ".", "_vars", ".", "keys", "(", ")", "if", "vals", "[", "i", ",", "j", "]", ">", "0.5", ")", "\n", "# find the shortest cycle in the selected edge list", "\n", "tour", "=", "subtour", "(", "selected", ")", "\n", "if", "tour", "is", "not", "None", ":", "\n", "# add subtour elimination constraint for every pair of cities in tour", "\n", "# model.cbLazy(quicksum(model._vars[i, j]", "\n", "#                       for i, j in itertools.combinations(tour, 2))", "\n", "#              <= len(tour) - 1)", "\n", "\n", "                ", "model", ".", "cbLazy", "(", "quicksum", "(", "model", ".", "_vars", "[", "i", ",", "j", "]", "\n", "for", "i", ",", "j", "in", "itertools", ".", "combinations", "(", "tour", ",", "2", ")", ")", "\n", "<=", "quicksum", "(", "model", ".", "_dvars", "[", "i", "]", "for", "i", "in", "tour", ")", "*", "(", "len", "(", "tour", ")", "-", "1", ")", "/", "float", "(", "len", "(", "tour", ")", ")", ")", "\n", "\n", "# Given a tuplelist of edges, find the shortest subtour", "\n", "\n", "", "", "", "def", "subtour", "(", "edges", ",", "exclude_depot", "=", "True", ")", ":", "\n", "        ", "unvisited", "=", "list", "(", "range", "(", "n", ")", ")", "\n", "#cycle = range(n + 1)  # initial length has 1 more city", "\n", "cycle", "=", "None", "\n", "while", "unvisited", ":", "# true if list is non-empty", "\n", "            ", "thiscycle", "=", "[", "]", "\n", "neighbors", "=", "unvisited", "\n", "while", "neighbors", ":", "\n", "                ", "current", "=", "neighbors", "[", "0", "]", "\n", "thiscycle", ".", "append", "(", "current", ")", "\n", "unvisited", ".", "remove", "(", "current", ")", "\n", "neighbors", "=", "[", "j", "for", "i", ",", "j", "in", "edges", ".", "select", "(", "current", ",", "'*'", ")", "if", "j", "in", "unvisited", "]", "\n", "# If we do not yet have a cycle or this is the shorter cycle, keep this cycle", "\n", "# Unless it contains the depot while we do not want the depot", "\n", "", "if", "(", "\n", "(", "cycle", "is", "None", "or", "len", "(", "cycle", ")", ">", "len", "(", "thiscycle", ")", ")", "\n", "and", "len", "(", "thiscycle", ")", ">", "1", "and", "not", "(", "0", "in", "thiscycle", "and", "exclude_depot", ")", "\n", ")", ":", "\n", "                ", "cycle", "=", "thiscycle", "\n", "", "", "return", "cycle", "\n", "\n", "# Dictionary of Euclidean distance between each pair of points", "\n", "\n", "", "dist", "=", "{", "(", "i", ",", "j", ")", ":", "\n", "math", ".", "sqrt", "(", "sum", "(", "(", "points", "[", "i", "]", "[", "k", "]", "-", "points", "[", "j", "]", "[", "k", "]", ")", "**", "2", "for", "k", "in", "range", "(", "2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", "for", "j", "in", "range", "(", "i", ")", "}", "\n", "\n", "m", "=", "Model", "(", ")", "\n", "m", ".", "Params", ".", "outputFlag", "=", "False", "\n", "\n", "# Create variables", "\n", "\n", "vars", "=", "m", ".", "addVars", "(", "dist", ".", "keys", "(", ")", ",", "vtype", "=", "GRB", ".", "BINARY", ",", "name", "=", "'e'", ")", "\n", "for", "i", ",", "j", "in", "vars", ".", "keys", "(", ")", ":", "\n", "        ", "vars", "[", "j", ",", "i", "]", "=", "vars", "[", "i", ",", "j", "]", "# edge in opposite direction", "\n", "\n", "# Depot vars can be 2", "\n", "", "for", "i", ",", "j", "in", "vars", ".", "keys", "(", ")", ":", "\n", "        ", "if", "i", "==", "0", "or", "j", "==", "0", ":", "\n", "            ", "vars", "[", "i", ",", "j", "]", ".", "vtype", "=", "GRB", ".", "INTEGER", "\n", "vars", "[", "i", ",", "j", "]", ".", "ub", "=", "2", "\n", "\n", "", "", "prize_dict", "=", "{", "\n", "i", "+", "1", ":", "-", "p", "# We need to maximize so negate", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "prize", ")", "\n", "}", "\n", "delta", "=", "m", ".", "addVars", "(", "range", "(", "1", ",", "n", ")", ",", "obj", "=", "prize_dict", ",", "vtype", "=", "GRB", ".", "BINARY", ",", "name", "=", "'delta'", ")", "\n", "\n", "# Add degree-2 constraint (2 * delta for nodes which are not the depot)", "\n", "m", ".", "addConstrs", "(", "vars", ".", "sum", "(", "i", ",", "'*'", ")", "==", "(", "2", "if", "i", "==", "0", "else", "2", "*", "delta", "[", "i", "]", ")", "for", "i", "in", "range", "(", "n", ")", ")", "\n", "\n", "# Length of tour constraint", "\n", "m", ".", "addConstr", "(", "quicksum", "(", "var", "*", "dist", "[", "i", ",", "j", "]", "for", "(", "i", ",", "j", ")", ",", "var", "in", "vars", ".", "items", "(", ")", "if", "j", "<", "i", ")", "<=", "max_length", ")", "\n", "\n", "# Optimize model", "\n", "\n", "m", ".", "_vars", "=", "vars", "\n", "m", ".", "_dvars", "=", "delta", "\n", "m", ".", "Params", ".", "lazyConstraints", "=", "1", "\n", "m", ".", "Params", ".", "threads", "=", "threads", "\n", "if", "timeout", ":", "\n", "        ", "m", ".", "Params", ".", "timeLimit", "=", "timeout", "\n", "", "if", "gap", ":", "\n", "        ", "m", ".", "Params", ".", "mipGap", "=", "gap", "*", "0.01", "# Percentage", "\n", "", "m", ".", "optimize", "(", "subtourelim", ")", "\n", "\n", "vals", "=", "m", ".", "getAttr", "(", "'x'", ",", "vars", ")", "\n", "selected", "=", "tuplelist", "(", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "vals", ".", "keys", "(", ")", "if", "vals", "[", "i", ",", "j", "]", ">", "0.5", ")", "\n", "\n", "tour", "=", "subtour", "(", "selected", ",", "exclude_depot", "=", "False", ")", "\n", "assert", "tour", "[", "0", "]", "==", "0", ",", "\"Tour should start with depot\"", "\n", "\n", "return", "m", ".", "objVal", ",", "tour", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.visited": [[27, 33], ["utils.boolmask.mask_long2bool", "state_op.StateOP.coords.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long2bool", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["@", "property", "\n", "def", "visited", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "            ", "return", "self", ".", "visited_", "\n", "", "else", ":", "\n", "            ", "return", "mask_long2bool", "(", "self", ".", "visited_", ",", "n", "=", "self", ".", "coords", ".", "size", "(", "-", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.dist": [[34, 37], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "dist", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "coords", "[", ":", ",", ":", ",", "None", ",", ":", "]", "-", "self", ".", "coords", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.__getitem__": [[38, 47], ["state_op.StateOP._replace", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "isinstance"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "# If tensor, idx all tensors by this tensor:", "\n", "return", "self", ".", "_replace", "(", "\n", "ids", "=", "self", ".", "ids", "[", "key", "]", ",", "\n", "prev_a", "=", "self", ".", "prev_a", "[", "key", "]", ",", "\n", "visited_", "=", "self", ".", "visited_", "[", "key", "]", ",", "\n", "lengths", "=", "self", ".", "lengths", "[", "key", "]", ",", "\n", "cur_coord", "=", "self", ".", "cur_coord", "[", "key", "]", ",", "\n", "cur_total_prize", "=", "self", ".", "cur_total_prize", "[", "key", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.initialize": [[54, 84], ["loc.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "state_op.StateOP", "torch.pad", "torch.pad", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "@", "staticmethod", "\n", "def", "initialize", "(", "input", ",", "visited_dtype", "=", "torch", ".", "uint8", ")", ":", "\n", "        ", "depot", "=", "input", "[", "'depot'", "]", "\n", "loc", "=", "input", "[", "'loc'", "]", "\n", "prize", "=", "input", "[", "'prize'", "]", "\n", "max_length", "=", "input", "[", "'max_length'", "]", "\n", "\n", "batch_size", ",", "n_loc", ",", "_", "=", "loc", ".", "size", "(", ")", "\n", "coords", "=", "torch", ".", "cat", "(", "(", "depot", "[", ":", ",", "None", ",", ":", "]", ",", "loc", ")", ",", "-", "2", ")", "\n", "return", "StateOP", "(", "\n", "coords", "=", "coords", ",", "\n", "prize", "=", "F", ".", "pad", "(", "prize", ",", "(", "1", ",", "0", ")", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", ",", "# add 0 for depot", "\n", "# max_length is max length allowed when arriving at node, so subtract distance to return to depot", "\n", "# Additionally, substract epsilon margin for numeric stability", "\n", "max_length", "=", "max_length", "[", ":", ",", "None", "]", "-", "(", "depot", "[", ":", ",", "None", ",", ":", "]", "-", "coords", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "-", "1e-6", ",", "\n", "ids", "=", "torch", ".", "arange", "(", "batch_size", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "[", ":", ",", "None", "]", ",", "# Add steps dimension", "\n", "prev_a", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "visited_", "=", "(", "# Visited as mask is easier to understand, as long more memory efficient", "\n", "# Keep visited_ with depot so we can scatter efficiently (if there is an action for depot)", "\n", "torch", ".", "zeros", "(", "\n", "batch_size", ",", "1", ",", "n_loc", "+", "1", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "loc", ".", "device", "\n", ")", "\n", "if", "visited_dtype", "==", "torch", ".", "uint8", "\n", "else", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "(", "n_loc", "+", "1", "+", "63", ")", "//", "64", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Ceil", "\n", ")", ",", "\n", "lengths", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "cur_coord", "=", "input", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "# Add step dimension", "\n", "cur_total_prize", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "device", "=", "loc", ".", "device", ")", ",", "\n", "i", "=", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "loc", ".", "device", ")", "# Vector with length num_steps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_remaining_length": [[86, 89], ["None"], "methods", ["None"], ["", "def", "get_remaining_length", "(", "self", ")", ":", "\n", "# max_length[:, 0] is max length arriving at depot so original max_length", "\n", "        ", "return", "self", ".", "max_length", "[", "self", ".", "ids", ",", "0", "]", "-", "self", ".", "lengths", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_final_cost": [[90, 95], ["state_op.StateOP.all_finished"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished"], ["", "def", "get_final_cost", "(", "self", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "all_finished", "(", ")", "\n", "# The cost is the negative of the collected prize since we want to maximize collected prize", "\n", "return", "-", "self", ".", "cur_total_prize", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.update": [[96, 122], ["state_op.StateOP._replace", "state_op.StateOP.i.size", "state_op.StateOP.visited_.scatter", "utils.boolmask.mask_long_scatter"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.boolmask.mask_long_scatter"], ["", "def", "update", "(", "self", ",", "selected", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "i", ".", "size", "(", "0", ")", "==", "1", ",", "\"Can only update if state represents single step\"", "\n", "\n", "# Update the state", "\n", "selected", "=", "selected", "[", ":", ",", "None", "]", "# Add dimension for step", "\n", "prev_a", "=", "selected", "\n", "\n", "# Add the length", "\n", "cur_coord", "=", "self", ".", "coords", "[", "self", ".", "ids", ",", "selected", "]", "\n", "lengths", "=", "self", ".", "lengths", "+", "(", "cur_coord", "-", "self", ".", "cur_coord", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# (batch_dim, 1)", "\n", "\n", "# Add the collected prize", "\n", "cur_total_prize", "=", "self", ".", "cur_total_prize", "+", "self", ".", "prize", "[", "self", ".", "ids", ",", "selected", "]", "\n", "\n", "if", "self", ".", "visited_", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "# Note: here we do not subtract one as we have to scatter so the first column allows scattering depot", "\n", "# Add one dimension since we write a single value", "\n", "            ", "visited_", "=", "self", ".", "visited_", ".", "scatter", "(", "-", "1", ",", "prev_a", "[", ":", ",", ":", ",", "None", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "# This works, by check_unset=False it is allowed to set the depot visited a second a time", "\n", "            ", "visited_", "=", "mask_long_scatter", "(", "self", ".", "visited_", ",", "prev_a", ",", "check_unset", "=", "False", ")", "\n", "\n", "", "return", "self", ".", "_replace", "(", "\n", "prev_a", "=", "prev_a", ",", "visited_", "=", "visited_", ",", "\n", "lengths", "=", "lengths", ",", "cur_coord", "=", "cur_coord", ",", "cur_total_prize", "=", "cur_total_prize", ",", "i", "=", "self", ".", "i", "+", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished": [[124, 128], ["state_op.StateOP.i.item"], "methods", ["None"], ["", "def", "all_finished", "(", "self", ")", ":", "\n", "# All must be returned to depot (and at least 1 step since at start also prev_a == 0)", "\n", "# This is more efficient than checking the mask", "\n", "        ", "return", "self", ".", "i", ".", "item", "(", ")", ">", "0", "and", "(", "self", ".", "prev_a", "==", "0", ")", ".", "all", "(", ")", "\n", "# return self.visited[:, :, 0].all()  # If we have visited the depot we're done", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_current_node": [[130, 136], ["None"], "methods", ["None"], ["", "def", "get_current_node", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the current node where 0 is depot, 1...n are nodes\n        :return: (batch_size, num_steps) tensor with current nodes\n        \"\"\"", "\n", "return", "self", ".", "prev_a", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_mask": [[137, 158], ["state_op.StateOP.visited.to"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.to"], ["", "def", "get_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Gets a (batch_size, n_loc + 1) mask with the feasible actions (0 = depot), depends on already visited and\n        remaining capacity. 0 = feasible, 1 = infeasible\n        Forbids to visit depot twice in a row, unless all nodes have been visited\n        :return:\n        \"\"\"", "\n", "\n", "exceeds_length", "=", "(", "\n", "self", ".", "lengths", "[", ":", ",", ":", ",", "None", "]", "+", "(", "self", ".", "coords", "[", "self", ".", "ids", ",", ":", ",", ":", "]", "-", "self", ".", "cur_coord", "[", ":", ",", ":", ",", "None", ",", ":", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", ">", "self", ".", "max_length", "[", "self", ".", "ids", ",", ":", "]", "\n", ")", "\n", "# Note: this always allows going to the depot, but that should always be suboptimal so be ok", "\n", "# Cannot visit if already visited or if length that would be upon arrival is too large to return to depot", "\n", "# If the depot has already been visited then we cannot visit anymore", "\n", "visited_", "=", "self", ".", "visited", ".", "to", "(", "exceeds_length", ".", "dtype", ")", "\n", "mask", "=", "visited_", "|", "visited_", "[", ":", ",", ":", ",", "0", ":", "1", "]", "|", "exceeds_length", "\n", "# Depot can always be visited", "\n", "# (so we do not hardcode knowledge that this is strictly suboptimal if other options are available)", "\n", "mask", "[", ":", ",", ":", ",", "0", "]", "=", "0", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.construct_solutions": [[159, 161], ["None"], "methods", ["None"], ["", "def", "construct_solutions", "(", "self", ",", "actions", ")", ":", "\n", "        ", "return", "actions", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.solve_compass": [[18, 32], ["tempfile.TemporaryDirectory", "os.path.join", "os.path.join", "os.path.join", "time.time", "op_baseline.write_oplib", "op_baseline.write_compass_par", "subprocess.check_output", "op_baseline.read_oplib", "time.time", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.write_oplib", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.write_compass_par", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.read_oplib"], ["def", "solve_compass", "(", "executable", ",", "depot", ",", "loc", ",", "demand", ",", "capacity", ")", ":", "\n", "    ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "tempdir", ",", "\"problem.oplib\"", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "tempdir", ",", "\"output.tour\"", ")", "\n", "param_filename", "=", "os", ".", "path", ".", "join", "(", "tempdir", ",", "\"params.par\"", ")", "\n", "\n", "starttime", "=", "time", ".", "time", "(", ")", "\n", "write_oplib", "(", "problem_filename", ",", "depot", ",", "loc", ",", "demand", ",", "capacity", ")", "\n", "params", "=", "{", "\"PROBLEM_FILE\"", ":", "problem_filename", ",", "\"OUTPUT_TOUR_FILE\"", ":", "output_filename", "}", "\n", "write_compass_par", "(", "param_filename", ",", "params", ")", "\n", "output", "=", "check_output", "(", "[", "executable", ",", "param_filename", "]", ")", "\n", "result", "=", "read_oplib", "(", "output_filename", ",", "n", "=", "len", "(", "demand", ")", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "starttime", "\n", "return", "result", ",", "output", ",", "duration", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.solve_compass_log": [[34, 66], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.isfile", "utils.data_utils.load_dataset", "op_baseline.write_oplib", "op_baseline.read_oplib", "utils.data_utils.save_dataset", "print", "print", "open", "time.time", "subprocess.check_call", "print", "op_baseline.calc_op_length", "op_baseline.calc_op_total", "time.time", "len", "op_baseline.calc_op_length", "op_baseline.calc_op_length"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.write_oplib", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.read_oplib", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_length", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_total", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_length", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_length"], ["", "", "def", "solve_compass_log", "(", "executable", ",", "directory", ",", "name", ",", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "disable_cache", "=", "False", ")", ":", "\n", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.oplib\"", ".", "format", "(", "name", ")", ")", "\n", "tour_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.tour\"", ".", "format", "(", "name", ")", ")", "\n", "output_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.compass.pkl\"", ".", "format", "(", "name", ")", ")", "\n", "log_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.log\"", ".", "format", "(", "name", ")", ")", "\n", "\n", "try", ":", "\n", "# May have already been run", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "output_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "tour", ",", "duration", "=", "load_dataset", "(", "output_filename", ")", "\n", "", "else", ":", "\n", "            ", "write_oplib", "(", "problem_filename", ",", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "name", "=", "name", ")", "\n", "\n", "with", "open", "(", "log_filename", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "start", "=", "time", ".", "time", "(", ")", "\n", "check_call", "(", "[", "executable", ",", "'--op'", ",", "'--op-ea4op'", ",", "problem_filename", ",", "'-o'", ",", "tour_filename", "]", ",", "\n", "stdout", "=", "f", ",", "stderr", "=", "f", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "", "tour", "=", "read_oplib", "(", "tour_filename", ",", "n", "=", "len", "(", "prize", ")", ")", "\n", "if", "not", "calc_op_length", "(", "depot", ",", "loc", ",", "tour", ")", "<=", "max_length", ":", "\n", "                ", "print", "(", "\"Warning: length exceeds max length:\"", ",", "calc_op_length", "(", "depot", ",", "loc", ",", "tour", ")", ",", "max_length", ")", "\n", "", "assert", "calc_op_length", "(", "depot", ",", "loc", ",", "tour", ")", "<=", "max_length", "+", "MAX_LENGTH_TOL", ",", "\"Tour exceeds max_length!\"", "\n", "save_dataset", "(", "(", "tour", ",", "duration", ")", ",", "output_filename", ")", "\n", "\n", "", "return", "-", "calc_op_total", "(", "prize", ",", "tour", ")", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_total": [[68, 73], ["[].sum", "len", "len", "numpy.unique", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["", "", "def", "calc_op_total", "(", "prize", ",", "tour", ")", ":", "\n", "# Subtract 1 since vals index start with 0 while tour indexing starts with 1 as depot is 0", "\n", "    ", "assert", "(", "np", ".", "array", "(", "tour", ")", ">", "0", ")", ".", "all", "(", ")", ",", "\"Depot cannot be in tour\"", "\n", "assert", "len", "(", "np", ".", "unique", "(", "tour", ")", ")", "==", "len", "(", "tour", ")", ",", "\"Tour cannot contain duplicates\"", "\n", "return", "np", ".", "array", "(", "prize", ")", "[", "np", ".", "array", "(", "tour", ")", "-", "1", "]", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_length": [[75, 80], ["numpy.vstack", "numpy.linalg.norm().sum", "len", "len", "numpy.unique", "numpy.array", "numpy.concatenate", "numpy.linalg.norm", "numpy.array"], "function", ["None"], ["", "def", "calc_op_length", "(", "depot", ",", "loc", ",", "tour", ")", ":", "\n", "    ", "assert", "len", "(", "np", ".", "unique", "(", "tour", ")", ")", "==", "len", "(", "tour", ")", ",", "\"Tour cannot contain duplicates\"", "\n", "loc_with_depot", "=", "np", ".", "vstack", "(", "(", "np", ".", "array", "(", "depot", ")", "[", "None", ",", ":", "]", ",", "np", ".", "array", "(", "loc", ")", ")", ")", "\n", "sorted_locs", "=", "loc_with_depot", "[", "np", ".", "concatenate", "(", "(", "[", "0", "]", ",", "tour", ",", "[", "0", "]", ")", ")", "]", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "sorted_locs", "[", "1", ":", "]", "-", "sorted_locs", "[", ":", "-", "1", "]", ",", "axis", "=", "-", "1", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.write_compass_par": [[82, 96], ["open", "f.write", "f.write"], "function", ["None"], ["", "def", "write_compass_par", "(", "filename", ",", "parameters", ")", ":", "\n", "    ", "default_parameters", "=", "{", "# Use none to include as flag instead of kv", "\n", "\"SPECIAL\"", ":", "None", ",", "\n", "\"MAX_TRIALS\"", ":", "10000", ",", "\n", "\"RUNS\"", ":", "10", ",", "\n", "\"TRACE_LEVEL\"", ":", "1", ",", "\n", "\"SEED\"", ":", "0", "\n", "}", "\n", "with", "open", "(", "filename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "for", "k", ",", "v", "in", "{", "**", "default_parameters", ",", "**", "parameters", "}", ".", "items", "(", ")", ":", "\n", "            ", "if", "v", "is", "None", ":", "\n", "                ", "f", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "k", ")", ")", "\n", "", "else", ":", "\n", "                ", "f", ".", "write", "(", "\"{} = {}\\n\"", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.read_oplib": [[98, 120], ["tour[].tolist", "open", "len", "numpy.array().astype", "line.startswith", "line.startswith", "int", "tour.append", "int", "numpy.array", "line.split"], "function", ["None"], ["", "", "", "", "def", "read_oplib", "(", "filename", ",", "n", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "tour", "=", "[", "]", "\n", "dimension", "=", "0", "\n", "started", "=", "False", "\n", "for", "line", "in", "f", ":", "\n", "            ", "if", "started", ":", "\n", "                ", "loc", "=", "int", "(", "line", ")", "\n", "if", "loc", "==", "-", "1", ":", "\n", "                    ", "break", "\n", "", "tour", ".", "append", "(", "loc", ")", "\n", "", "if", "line", ".", "startswith", "(", "\"DIMENSION\"", ")", ":", "\n", "                ", "dimension", "=", "int", "(", "line", ".", "split", "(", "\" \"", ")", "[", "-", "1", "]", ")", "\n", "\n", "", "if", "line", ".", "startswith", "(", "\"NODE_SEQUENCE_SECTION\"", ")", ":", "\n", "                ", "started", "=", "True", "\n", "\n", "", "", "", "assert", "len", "(", "tour", ")", ">", "0", ",", "\"Unexpected length\"", "\n", "tour", "=", "np", ".", "array", "(", "tour", ")", ".", "astype", "(", "int", ")", "-", "1", "# Subtract 1 as depot is 1 and should be 0", "\n", "assert", "tour", "[", "0", "]", "==", "0", "# Tour should start with depot", "\n", "assert", "tour", "[", "-", "1", "]", "!=", "0", "# Tour should not end with depot", "\n", "return", "tour", "[", "1", ":", "]", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.write_oplib": [[122, 153], ["open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "int", "int", "enumerate", "enumerate", "int", "len"], "function", ["None"], ["", "def", "write_oplib", "(", "filename", ",", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "name", "=", "\"problem\"", ")", ":", "\n", "\n", "    ", "with", "open", "(", "filename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{} : {}\"", ".", "format", "(", "k", ",", "v", ")", "\n", "for", "k", ",", "v", "in", "(", "\n", "(", "\"NAME\"", ",", "name", ")", ",", "\n", "(", "\"TYPE\"", ",", "\"OP\"", ")", ",", "\n", "(", "\"DIMENSION\"", ",", "len", "(", "loc", ")", "+", "1", ")", ",", "\n", "(", "\"COST_LIMIT\"", ",", "int", "(", "max_length", "*", "10000000", "+", "0.5", ")", ")", ",", "\n", "(", "\"EDGE_WEIGHT_TYPE\"", ",", "\"EUC_2D\"", ")", ",", "\n", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"NODE_COORD_SECTION\\n\"", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{}\\t{}\\t{}\"", ".", "format", "(", "i", "+", "1", ",", "int", "(", "x", "*", "10000000", "+", "0.5", ")", ",", "int", "(", "y", "*", "10000000", "+", "0.5", ")", ")", "# oplib does not take floats", "\n", "#\"{}\\t{}\\t{}\".format(i + 1, x, y)", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "[", "depot", "]", "+", "loc", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"NODE_SCORE_SECTION\\n\"", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "[", "\n", "\"{}\\t{}\"", ".", "format", "(", "i", "+", "1", ",", "d", ")", "\n", "for", "i", ",", "d", "in", "enumerate", "(", "[", "0", "]", "+", "prize", ")", "\n", "]", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"DEPOT_SECTION\\n\"", ")", "\n", "f", ".", "write", "(", "\"1\\n\"", ")", "\n", "f", ".", "write", "(", "\"-1\\n\"", ")", "\n", "f", ".", "write", "(", "\"EOF\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.solve_opga": [[155, 173], ["os.path.join", "os.path.isfile", "utils.data_utils.load_dataset", "time.time", "problems.op.opga.opevo.run_alg", "utils.data_utils.save_dataset", "time.time", "zip"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.run_alg", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset"], ["", "", "def", "solve_opga", "(", "directory", ",", "name", ",", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "disable_cache", "=", "False", ")", ":", "\n", "    ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.opga.pkl\"", ".", "format", "(", "name", ")", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "problem_filename", ")", "and", "not", "disable_cache", ":", "\n", "        ", "(", "prize", ",", "tour", ",", "duration", ")", "=", "load_dataset", "(", "problem_filename", ")", "\n", "", "else", ":", "\n", "# 0 = start, 1 = end so add depot twice", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "prize", ",", "tour", ",", "duration", "=", "run_opga_alg", "(", "\n", "[", "(", "*", "pos", ",", "p", ")", "for", "p", ",", "pos", "in", "zip", "(", "[", "0", ",", "0", "]", "+", "prize", ",", "[", "depot", ",", "depot", "]", "+", "loc", ")", "]", ",", "\n", "max_length", ",", "return_sol", "=", "True", ",", "verbose", "=", "False", "\n", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "# Measure clock time", "\n", "save_dataset", "(", "(", "prize", ",", "tour", ",", "duration", ")", ",", "problem_filename", ")", "\n", "\n", "# First and last node are depot(s), so first node is 2 but should be 1 (as depot is 0) so subtract 1", "\n", "", "assert", "tour", "[", "0", "]", "[", "3", "]", "==", "0", "\n", "assert", "tour", "[", "-", "1", "]", "[", "3", "]", "==", "1", "\n", "return", "-", "prize", ",", "[", "i", "-", "1", "for", "x", ",", "y", ",", "p", ",", "i", ",", "t", "in", "tour", "[", "1", ":", "-", "1", "]", "]", ",", "duration", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.solve_gurobi": [[175, 209], ["os.path.join", "os.path.isfile", "utils.data_utils.load_dataset", "time.time", "solve_euclidian_op_gurobi", "utils.data_utils.save_dataset", "op_baseline.calc_op_length", "op_baseline.calc_op_total", "abs", "print", "print", "time.time"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_length", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_total"], ["", "def", "solve_gurobi", "(", "directory", ",", "name", ",", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "disable_cache", "=", "False", ",", "timeout", "=", "None", ",", "gap", "=", "None", ")", ":", "\n", "# Lazy import so we do not need to have gurobi installed to run this script", "\n", "    ", "from", "problems", ".", "op", ".", "op_gurobi", "import", "solve_euclidian_op", "as", "solve_euclidian_op_gurobi", "\n", "\n", "try", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.gurobi{}{}.pkl\"", ".", "format", "(", "\n", "name", ",", "\"\"", "if", "timeout", "is", "None", "else", "\"t{}\"", ".", "format", "(", "timeout", ")", ",", "\"\"", "if", "gap", "is", "None", "else", "\"gap{}\"", ".", "format", "(", "gap", ")", ")", ")", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "problem_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "(", "cost", ",", "tour", ",", "duration", ")", "=", "load_dataset", "(", "problem_filename", ")", "\n", "", "else", ":", "\n", "# 0 = start, 1 = end so add depot twice", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "cost", ",", "tour", "=", "solve_euclidian_op_gurobi", "(", "\n", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "threads", "=", "1", ",", "timeout", "=", "timeout", ",", "gap", "=", "gap", "\n", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "# Measure clock time", "\n", "save_dataset", "(", "(", "cost", ",", "tour", ",", "duration", ")", ",", "problem_filename", ")", "\n", "\n", "# First and last node are depot(s), so first node is 2 but should be 1 (as depot is 0) so subtract 1", "\n", "", "assert", "tour", "[", "0", "]", "==", "0", "\n", "tour", "=", "tour", "[", "1", ":", "]", "\n", "assert", "calc_op_length", "(", "depot", ",", "loc", ",", "tour", ")", "<=", "max_length", "+", "MAX_LENGTH_TOL", ",", "\"Tour exceeds max_length!\"", "\n", "total_cost", "=", "-", "calc_op_total", "(", "prize", ",", "tour", ")", "\n", "assert", "abs", "(", "total_cost", "-", "cost", ")", "<=", "1e-4", ",", "\"Cost is incorrect\"", "\n", "return", "total_cost", ",", "tour", ",", "duration", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "# For some stupid reason, sometimes OR tools cannot find a feasible solution?", "\n", "# By letting it fail we do not get total results, but we dcan retry by the caching mechanism", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.solve_ortools": [[211, 236], ["os.path.join", "os.path.isfile", "utils.data_utils.load_dataset", "time.time", "solve_op_ortools", "utils.data_utils.save_dataset", "op_baseline.calc_op_length", "abs", "print", "print", "time.time", "op_baseline.calc_op_total", "op_baseline.calc_op_total"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.Neural_Reinforce.load_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.solve_op_ortools", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.data_utils.save_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_length", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_total", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.calc_op_total"], ["", "", "def", "solve_ortools", "(", "directory", ",", "name", ",", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "sec_local_search", "=", "0", ",", "disable_cache", "=", "False", ")", ":", "\n", "# Lazy import so we do not require ortools by default", "\n", "    ", "from", "problems", ".", "op", ".", "op_ortools", "import", "solve_op_ortools", "\n", "\n", "try", ":", "\n", "        ", "problem_filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"{}.ortools{}.pkl\"", ".", "format", "(", "name", ",", "sec_local_search", ")", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "problem_filename", ")", "and", "not", "disable_cache", ":", "\n", "            ", "objval", ",", "tour", ",", "duration", "=", "load_dataset", "(", "problem_filename", ")", "\n", "", "else", ":", "\n", "# 0 = start, 1 = end so add depot twice", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "objval", ",", "tour", "=", "solve_op_ortools", "(", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "sec_local_search", "=", "sec_local_search", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "save_dataset", "(", "(", "objval", ",", "tour", ",", "duration", ")", ",", "problem_filename", ")", "\n", "", "assert", "tour", "[", "0", "]", "==", "0", ",", "\"Tour must start with depot\"", "\n", "tour", "=", "tour", "[", "1", ":", "]", "\n", "assert", "calc_op_length", "(", "depot", ",", "loc", ",", "tour", ")", "<=", "max_length", "+", "MAX_LENGTH_TOL", ",", "\"Tour exceeds max_length!\"", "\n", "assert", "abs", "(", "-", "calc_op_total", "(", "prize", ",", "tour", ")", "-", "objval", ")", "<=", "1e-5", ",", "\"Cost is incorrect\"", "\n", "return", "-", "calc_op_total", "(", "prize", ",", "tour", ")", ",", "tour", ",", "duration", "\n", "", "except", "Exception", "as", "e", ":", "\n", "# For some stupid reason, sometimes OR tools cannot find a feasible solution?", "\n", "# By letting it fail we do not get total results, but we dcan retry by the caching mechanism", "\n", "        ", "print", "(", "\"Exception occured\"", ")", "\n", "print", "(", "e", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_baseline.run_all_tsiligirides": [[238, 275], ["torch.manual_seed", "DataLoader", "torch.device", "tqdm.tqdm", "OP.make_dataset", "time.time", "move_to", "torch.no_grad", "sample_many", "results.extend", "torch.cuda.is_available", "time.time", "op_tsiligirides", "cost.item", "numpy.trim_zeros", "zip", "pi.cpu().numpy", "pi.cpu"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.functions.move_to", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.sample_many", "home.repos.pwc.inspect_result.alstn12088_lcp.op.tsiligirides.op_tsiligirides", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.cpu"], ["", "", "def", "run_all_tsiligirides", "(", "\n", "dataset_path", ",", "sample", ",", "num_samples", ",", "eval_batch_size", ",", "max_calc_batch_size", ",", "no_cuda", "=", "False", ",", "dataset_n", "=", "None", ",", "\n", "progress_bar_mininterval", "=", "0.1", ",", "seed", "=", "1234", ")", ":", "\n", "    ", "import", "torch", "\n", "from", "torch", ".", "utils", ".", "data", "import", "DataLoader", "\n", "from", "utils", "import", "move_to", ",", "sample_many", "\n", "from", "problems", ".", "op", ".", "tsiligirides", "import", "op_tsiligirides", "\n", "from", "problems", ".", "op", ".", "problem_op", "import", "OP", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "\n", "dataloader", "=", "DataLoader", "(", "\n", "OP", ".", "make_dataset", "(", "filename", "=", "dataset_path", ",", "num_samples", "=", "dataset_n", "if", "dataset_n", "is", "not", "None", "else", "1000000", ")", ",", "\n", "batch_size", "=", "eval_batch_size", "\n", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "not", "no_cuda", "else", "\"cpu\"", ")", "\n", "results", "=", "[", "]", "\n", "for", "batch", "in", "tqdm", "(", "dataloader", ",", "mininterval", "=", "progress_bar_mininterval", ")", ":", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "batch", "=", "move_to", "(", "batch", ",", "device", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "num_samples", "*", "eval_batch_size", ">", "max_calc_batch_size", ":", "\n", "                ", "assert", "eval_batch_size", "==", "1", "\n", "assert", "num_samples", "%", "max_calc_batch_size", "==", "0", "\n", "batch_rep", "=", "max_calc_batch_size", "\n", "iter_rep", "=", "num_samples", "//", "max_calc_batch_size", "\n", "", "else", ":", "\n", "                ", "batch_rep", "=", "num_samples", "\n", "iter_rep", "=", "1", "\n", "", "sequences", ",", "costs", "=", "sample_many", "(", "\n", "lambda", "inp", ":", "(", "None", ",", "op_tsiligirides", "(", "inp", ",", "sample", ")", ")", ",", "\n", "OP", ".", "get_costs", ",", "\n", "batch", ",", "batch_rep", "=", "batch_rep", ",", "iter_rep", "=", "iter_rep", ")", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "results", ".", "extend", "(", "\n", "[", "(", "cost", ".", "item", "(", ")", ",", "np", ".", "trim_zeros", "(", "pi", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "'b'", ")", ",", "duration", ")", "for", "cost", ",", "pi", "in", "zip", "(", "costs", ",", "sequences", ")", "]", ")", "\n", "", "", "return", "results", ",", "eval_batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs": [[13, 48], ["torch.cat", "torch.cat.gather", "torch.cat", "torch.cat.gather", "pi.size", "pi.data.sort", "pi[].expand", "torch.zeros", "torch.zeros_like", "torch.cat.size", "torch.cat.gather.sum", "pi.size", "pi.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["@", "staticmethod", "\n", "def", "get_costs", "(", "dataset", ",", "pi", ")", ":", "\n", "        ", "if", "pi", ".", "size", "(", "-", "1", ")", "==", "1", ":", "# In case all tours directly return to depot, prevent further problems", "\n", "            ", "assert", "(", "pi", "==", "0", ")", ".", "all", "(", ")", ",", "\"If all length 1 tours, they should be zero\"", "\n", "# Return", "\n", "return", "torch", ".", "zeros", "(", "pi", ".", "size", "(", "0", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "pi", ".", "device", ")", ",", "None", "\n", "\n", "# Check that tours are valid, i.e. contain 0 to n -1", "\n", "", "sorted_pi", "=", "pi", ".", "data", ".", "sort", "(", "1", ")", "[", "0", "]", "\n", "# Make sure each node visited once at most (except for depot)", "\n", "assert", "(", "(", "sorted_pi", "[", ":", ",", "1", ":", "]", "==", "0", ")", "|", "(", "sorted_pi", "[", ":", ",", "1", ":", "]", ">", "sorted_pi", "[", ":", ",", ":", "-", "1", "]", ")", ")", ".", "all", "(", ")", ",", "\"Duplicates\"", "\n", "\n", "prize_with_depot", "=", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "zeros_like", "(", "dataset", "[", "'prize'", "]", "[", ":", ",", ":", "1", "]", ")", ",", "\n", "dataset", "[", "'prize'", "]", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "p", "=", "prize_with_depot", ".", "gather", "(", "1", ",", "pi", ")", "\n", "\n", "# Gather dataset in order of tour", "\n", "loc_with_depot", "=", "torch", ".", "cat", "(", "(", "dataset", "[", "'depot'", "]", "[", ":", ",", "None", ",", ":", "]", ",", "dataset", "[", "'loc'", "]", ")", ",", "1", ")", "\n", "d", "=", "loc_with_depot", ".", "gather", "(", "1", ",", "pi", "[", "...", ",", "None", "]", ".", "expand", "(", "*", "pi", ".", "size", "(", ")", ",", "loc_with_depot", ".", "size", "(", "-", "1", ")", ")", ")", "\n", "\n", "length", "=", "(", "\n", "(", "d", "[", ":", ",", "1", ":", "]", "-", "d", "[", ":", ",", ":", "-", "1", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", ".", "sum", "(", "1", ")", "# Prevent error if len 1 seq", "\n", "+", "(", "d", "[", ":", ",", "0", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# Depot to first", "\n", "+", "(", "d", "[", ":", ",", "-", "1", "]", "-", "dataset", "[", "'depot'", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "# Last to depot, will be 0 if depot is last", "\n", ")", "\n", "assert", "(", "length", "<=", "dataset", "[", "'max_length'", "]", "+", "1e-5", ")", ".", "all", "(", ")", ",", "\"Max length exceeded by {}\"", ".", "format", "(", "(", "length", "-", "dataset", "[", "'max_length'", "]", ")", ".", "max", "(", ")", ")", "\n", "\n", "# We want to maximize total prize but code minimizes so return negative", "\n", "return", "-", "p", ".", "sum", "(", "-", "1", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_dataset": [[49, 52], ["problem_op.OPDataset"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_dataset", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "OPDataset", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state": [[53, 56], ["problems.op.state_op.StateOP.initialize"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize"], ["", "@", "staticmethod", "\n", "def", "make_state", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "StateOP", ".", "initialize", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.beam_search": [[57, 75], ["model.precompute_fixed", "problem_op.OP.make_state", "utils.beam_search.beam_search", "model.propose_expansions"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.precompute_fixed", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions"], ["", "@", "staticmethod", "\n", "def", "beam_search", "(", "input", ",", "beam_size", ",", "expand_size", "=", "None", ",", "\n", "compress_mask", "=", "False", ",", "model", "=", "None", ",", "max_calc_batch_size", "=", "4096", ")", ":", "\n", "\n", "        ", "assert", "model", "is", "not", "None", ",", "\"Provide model\"", "\n", "\n", "fixed", "=", "model", ".", "precompute_fixed", "(", "input", ")", "\n", "\n", "def", "propose_expansions", "(", "beam", ")", ":", "\n", "            ", "return", "model", ".", "propose_expansions", "(", "\n", "beam", ",", "fixed", ",", "expand_size", ",", "normalize", "=", "True", ",", "max_calc_batch_size", "=", "max_calc_batch_size", "\n", ")", "\n", "\n", "", "state", "=", "OP", ".", "make_state", "(", "\n", "input", ",", "visited_dtype", "=", "torch", ".", "int64", "if", "compress_mask", "else", "torch", ".", "uint8", "\n", ")", "\n", "\n", "return", "beam_search", "(", "state", ",", "beam_size", ",", "propose_expansions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OPDataset.__init__": [[108, 136], ["torch.utils.data.Dataset.__init__", "len", "open", "pickle.load", "problem_op.generate_instance", "os.path.splitext", "range", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.model.pctsp.Pctsp.load", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.generate_instance"], ["    ", "def", "__init__", "(", "self", ",", "filename", "=", "None", ",", "size", "=", "50", ",", "num_samples", "=", "1000000", ",", "offset", "=", "0", ",", "distribution", "=", "'const'", ")", ":", "\n", "        ", "super", "(", "OPDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "distribution", "is", "not", "None", ",", "\"Data distribution must be specified for OP\"", "\n", "# Currently the distribution can only vary in the type of the prize", "\n", "prize_type", "=", "distribution", "\n", "\n", "self", ".", "data_set", "=", "[", "]", "\n", "if", "filename", "is", "not", "None", ":", "\n", "            ", "assert", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "==", "'.pkl'", "\n", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "self", ".", "data", "=", "[", "\n", "{", "\n", "'loc'", ":", "torch", ".", "FloatTensor", "(", "loc", ")", ",", "\n", "'prize'", ":", "torch", ".", "FloatTensor", "(", "prize", ")", ",", "\n", "'depot'", ":", "torch", ".", "FloatTensor", "(", "depot", ")", ",", "\n", "'max_length'", ":", "torch", ".", "tensor", "(", "max_length", ")", "\n", "}", "\n", "for", "depot", ",", "loc", ",", "prize", ",", "max_length", "in", "(", "data", "[", "offset", ":", "offset", "+", "num_samples", "]", ")", "\n", "]", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "data", "=", "[", "\n", "generate_instance", "(", "size", ",", "prize_type", ")", "\n", "for", "i", "in", "range", "(", "num_samples", ")", "\n", "]", "\n", "\n", "", "self", ".", "size", "=", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OPDataset.__len__": [[137, 139], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OPDataset.__getitem__": [[140, 142], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "data", "[", "idx", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.generate_instance": [[77, 103], ["torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.ones", "torch.tensor", "torch.FloatTensor", "torch.FloatTensor", "torch.randint", "prize_.max"], "function", ["None"], ["", "", "def", "generate_instance", "(", "size", ",", "prize_type", ")", ":", "\n", "# Details see paper", "\n", "    ", "MAX_LENGTHS", "=", "{", "\n", "20", ":", "2.", ",", "\n", "50", ":", "3.", ",", "\n", "100", ":", "4.", "\n", "}", "\n", "\n", "loc", "=", "torch", ".", "FloatTensor", "(", "size", ",", "2", ")", ".", "uniform_", "(", "0", ",", "1", ")", "\n", "depot", "=", "torch", ".", "FloatTensor", "(", "2", ")", ".", "uniform_", "(", "0", ",", "1", ")", "\n", "# Methods taken from Fischetti et al. 1998", "\n", "if", "prize_type", "==", "'const'", ":", "\n", "        ", "prize", "=", "torch", ".", "ones", "(", "size", ")", "\n", "", "elif", "prize_type", "==", "'unif'", ":", "\n", "        ", "prize", "=", "(", "1", "+", "torch", ".", "randint", "(", "0", ",", "100", ",", "size", "=", "(", "size", ",", ")", ")", ")", "/", "100.", "\n", "", "else", ":", "# Based on distance to depot", "\n", "        ", "assert", "prize_type", "==", "'dist'", "\n", "prize_", "=", "(", "depot", "[", "None", ",", ":", "]", "-", "loc", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "prize", "=", "(", "1", "+", "(", "prize_", "/", "prize_", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "*", "99", ")", ".", "int", "(", ")", ")", ".", "float", "(", ")", "/", "100.", "\n", "\n", "", "return", "{", "\n", "'loc'", ":", "loc", ",", "\n", "# Uniform 1 - 9, scaled by capacities", "\n", "'prize'", ":", "prize", ",", "\n", "'depot'", ":", "depot", ",", "\n", "'max_length'", ":", "torch", ".", "tensor", "(", "MAX_LENGTHS", "[", "size", "]", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.__init__": [[47, 55], ["op_ortools.float_to_scaled_int", "op_ortools.float_to_scaled_int", "op_ortools.float_to_scaled_int", "op_ortools.float_to_scaled_int"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int", "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int"], ["def", "__init__", "(", "self", ",", "depot", ",", "loc", ",", "prize", ",", "max_length", ")", ":", "\n", "    ", "\"\"\"Initializes the data for the problem\"\"\"", "\n", "# Locations in block unit", "\n", "self", ".", "_locations", "=", "[", "(", "float_to_scaled_int", "(", "l", "[", "0", "]", ")", ",", "float_to_scaled_int", "(", "l", "[", "1", "]", ")", ")", "for", "l", "in", "[", "depot", "]", "+", "loc", "]", "\n", "\n", "self", ".", "_prizes", "=", "[", "float_to_scaled_int", "(", "v", ")", "for", "v", "in", "prize", "]", "\n", "\n", "self", ".", "_max_length", "=", "float_to_scaled_int", "(", "max_length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.vehicle": [[56, 60], ["Vehicle"], "methods", ["None"], ["", "@", "property", "\n", "def", "vehicle", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets a vehicle\"\"\"", "\n", "return", "Vehicle", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.num_vehicles": [[61, 65], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_vehicles", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets number of vehicles\"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.locations": [[66, 70], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "locations", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets locations\"\"\"", "\n", "return", "self", ".", "_locations", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.num_locations": [[71, 75], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_locations", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets number of locations\"\"\"", "\n", "return", "len", "(", "self", ".", "locations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.depot": [[76, 80], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "depot", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets depot location index\"\"\"", "\n", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.prizes": [[81, 85], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "prizes", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets prizes at each location\"\"\"", "\n", "return", "self", ".", "_prizes", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.max_length": [[86, 90], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "max_length", "(", "self", ")", ":", "\n", "      ", "\"\"\"Gets prizes at each location\"\"\"", "\n", "return", "self", ".", "_max_length", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.CreateDistanceEvaluator.__init__": [[103, 117], ["six.moves.xrange", "six.moves.xrange", "op_ortools.euclidian_distance"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.euclidian_distance"], ["def", "__init__", "(", "self", ",", "data", ")", ":", "\n", "    ", "\"\"\"Initializes the distance matrix.\"\"\"", "\n", "self", ".", "_distances", "=", "{", "}", "\n", "\n", "# precompute distance between location to have distance callback in O(1)", "\n", "for", "from_node", "in", "xrange", "(", "data", ".", "num_locations", ")", ":", "\n", "      ", "self", ".", "_distances", "[", "from_node", "]", "=", "{", "}", "\n", "for", "to_node", "in", "xrange", "(", "data", ".", "num_locations", ")", ":", "\n", "        ", "if", "from_node", "==", "to_node", ":", "\n", "          ", "self", ".", "_distances", "[", "from_node", "]", "[", "to_node", "]", "=", "0", "\n", "", "else", ":", "\n", "          ", "self", ".", "_distances", "[", "from_node", "]", "[", "to_node", "]", "=", "(", "\n", "euclidian_distance", "(", "data", ".", "locations", "[", "from_node", "]", ",", "\n", "data", ".", "locations", "[", "to_node", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.CreateDistanceEvaluator.distance_evaluator": [[118, 121], ["None"], "methods", ["None"], ["", "", "", "", "def", "distance_evaluator", "(", "self", ",", "from_node", ",", "to_node", ")", ":", "\n", "    ", "\"\"\"Returns the manhattan distance between the two nodes\"\"\"", "\n", "return", "self", ".", "_distances", "[", "from_node", "]", "[", "to_node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.CreatePrizeEvaluator.__init__": [[126, 129], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data", ")", ":", "\n", "    ", "\"\"\"Initializes the prize array.\"\"\"", "\n", "self", ".", "_prizes", "=", "data", ".", "prizes", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.CreatePrizeEvaluator.prize_evaluator": [[130, 134], ["None"], "methods", ["None"], ["", "def", "prize_evaluator", "(", "self", ",", "from_node", ",", "to_node", ")", ":", "\n", "    ", "\"\"\"Returns the prize of the current node\"\"\"", "\n", "del", "to_node", "\n", "return", "self", ".", "_prizes", "[", "from_node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.float_to_scaled_int": [[40, 42], ["int"], "function", ["None"], ["def", "float_to_scaled_int", "(", "v", ")", ":", "\n", "    ", "return", "int", "(", "v", "*", "10000000", "+", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.euclidian_distance": [[95, 98], ["int", "math.sqrt"], "function", ["None"], ["", "", "def", "euclidian_distance", "(", "position_1", ",", "position_2", ")", ":", "\n", "  ", "\"\"\"Computes the Euclidian distance between two points\"\"\"", "\n", "return", "int", "(", "math", ".", "sqrt", "(", "(", "position_1", "[", "0", "]", "-", "position_2", "[", "0", "]", ")", "**", "2", "+", "(", "position_1", "[", "1", "]", "-", "position_2", "[", "1", "]", ")", "**", "2", ")", "+", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.add_capacity_constraints": [[136, 145], ["routing.AddDimension"], "function", ["None"], ["", "", "def", "add_capacity_constraints", "(", "routing", ",", "data", ",", "prize_evaluator", ")", ":", "\n", "  ", "\"\"\"Adds capacity constraint\"\"\"", "\n", "capacity", "=", "'Capacity'", "\n", "routing", ".", "AddDimension", "(", "\n", "prize_evaluator", ",", "\n", "0", ",", "# null capacity slack", "\n", "data", ".", "vehicle", ".", "capacity", ",", "\n", "True", ",", "# start cumul to zero", "\n", "capacity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.add_distance_constraint": [[147, 156], ["routing.AddDimension", "op_ortools.DataProblem.max_length"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.DataProblem.max_length"], ["", "def", "add_distance_constraint", "(", "routing", ",", "distance_evaluator", ",", "maximum_distance", ")", ":", "\n", "    ", "\"\"\"Add Global Span constraint\"\"\"", "\n", "distance", "=", "\"Distance\"", "\n", "routing", ".", "AddDimension", "(", "\n", "distance_evaluator", ",", "\n", "0", ",", "# null slack", "\n", "maximum_distance", ",", "# maximum distance per vehicle", "\n", "True", ",", "# start cumul to zero", "\n", "distance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.print_solution": [[161, 189], ["print", "routing.GetDimensionOrDie", "six.moves.xrange", "print", "print", "routing.Start", "routing.GetDimensionOrDie.CumulVar", "print", "assignment.Value", "assignment.ObjectiveValue", "routing.IsEnd", "routing.GetDimensionOrDie.CumulVar", "assignment.Value", "routing.GetArcCostForVehicle", "routing.IndexToNode", "assignment.Value", "assignment.Value", "routing.IndexToNode", "assignment.Value", "routing.NextVar"], "function", ["None"], ["", "def", "print_solution", "(", "data", ",", "routing", ",", "assignment", ")", ":", "\n", "  ", "\"\"\"Prints assignment on console\"\"\"", "\n", "print", "(", "'Objective: {}'", ".", "format", "(", "assignment", ".", "ObjectiveValue", "(", ")", ")", ")", "\n", "total_distance", "=", "0", "\n", "total_load", "=", "0", "\n", "capacity_dimension", "=", "routing", ".", "GetDimensionOrDie", "(", "'Capacity'", ")", "\n", "for", "vehicle_id", "in", "xrange", "(", "data", ".", "num_vehicles", ")", ":", "\n", "    ", "index", "=", "routing", ".", "Start", "(", "vehicle_id", ")", "\n", "plan_output", "=", "'Route for vehicle {}:\\n'", ".", "format", "(", "vehicle_id", ")", "\n", "distance", "=", "0", "\n", "while", "not", "routing", ".", "IsEnd", "(", "index", ")", ":", "\n", "      ", "load_var", "=", "capacity_dimension", ".", "CumulVar", "(", "index", ")", "\n", "plan_output", "+=", "' {} Load({}) -> '", ".", "format", "(", "\n", "routing", ".", "IndexToNode", "(", "index", ")", ",", "assignment", ".", "Value", "(", "load_var", ")", ")", "\n", "previous_index", "=", "index", "\n", "index", "=", "assignment", ".", "Value", "(", "routing", ".", "NextVar", "(", "index", ")", ")", "\n", "distance", "+=", "routing", ".", "GetArcCostForVehicle", "(", "previous_index", ",", "index", ",", "\n", "vehicle_id", ")", "\n", "", "load_var", "=", "capacity_dimension", ".", "CumulVar", "(", "index", ")", "\n", "plan_output", "+=", "' {0} Load({1})\\n'", ".", "format", "(", "\n", "routing", ".", "IndexToNode", "(", "index", ")", ",", "assignment", ".", "Value", "(", "load_var", ")", ")", "\n", "plan_output", "+=", "'Distance of the route: {}m\\n'", ".", "format", "(", "distance", ")", "\n", "plan_output", "+=", "'Load of the route: {}\\n'", ".", "format", "(", "assignment", ".", "Value", "(", "load_var", ")", ")", "\n", "print", "(", "plan_output", ")", "\n", "total_distance", "+=", "distance", "\n", "total_load", "+=", "assignment", ".", "Value", "(", "load_var", ")", "\n", "", "print", "(", "'Total Distance of all routes: {}m'", ".", "format", "(", "total_distance", ")", ")", "\n", "print", "(", "'Total Load of all routes: {}'", ".", "format", "(", "total_load", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.solve_op_ortools": [[191, 231], ["op_ortools.DataProblem", "ortools.constraint_solver.pywrapcp.RoutingModel", "op_ortools.add_distance_constraint", "ortools.constraint_solver.pywrapcp.RoutingModel.DefaultSearchParameters", "pywrapcp.RoutingModel.SolveWithParameters", "pywrapcp.RoutingModel.Start", "op_ortools.CreateDistanceEvaluator", "pywrapcp.RoutingModel.AddDisjunction", "pywrapcp.RoutingModel.IsEnd", "pywrapcp.RoutingModel.IndexToNode", "route.append", "routing.SolveWithParameters.Value", "enumerate", "pywrapcp.RoutingModel.NextVar", "sum", "int", "routing.SolveWithParameters.ObjectiveValue"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.add_distance_constraint"], ["", "def", "solve_op_ortools", "(", "depot", ",", "loc", ",", "prize", ",", "max_length", ",", "sec_local_search", "=", "0", ")", ":", "\n", "    ", "data", "=", "DataProblem", "(", "depot", ",", "loc", ",", "prize", ",", "max_length", ")", "\n", "\n", "# Create Routing Model", "\n", "routing", "=", "pywrapcp", ".", "RoutingModel", "(", "data", ".", "num_locations", ",", "data", ".", "num_vehicles", ",", "\n", "data", ".", "depot", ")", "\n", "\n", "# Define weight of each edge", "\n", "distance_evaluator", "=", "CreateDistanceEvaluator", "(", "data", ")", ".", "distance_evaluator", "\n", "# routing.SetArcCostEvaluatorOfAllVehicles(distance_evaluator)", "\n", "add_distance_constraint", "(", "routing", ",", "distance_evaluator", ",", "data", ".", "max_length", ")", "\n", "# Add Capacity constraint", "\n", "# prize_evaluator = CreatePrizeEvaluator(data).prize_evaluator", "\n", "# add_capacity_constraints(routing, data, prize_evaluator)", "\n", "# Add penalties for missed prizes", "\n", "nodes", "=", "[", "routing", ".", "AddDisjunction", "(", "[", "int", "(", "c", "+", "1", ")", "]", ",", "p", ")", "for", "c", ",", "p", "in", "enumerate", "(", "data", ".", "prizes", ")", "]", "\n", "\n", "# Setting first solution heuristic (cheapest addition).", "\n", "search_parameters", "=", "pywrapcp", ".", "RoutingModel", ".", "DefaultSearchParameters", "(", ")", "\n", "search_parameters", ".", "first_solution_strategy", "=", "(", "\n", "routing_enums_pb2", ".", "FirstSolutionStrategy", ".", "PATH_CHEAPEST_ARC", ")", "\n", "if", "sec_local_search", ">", "0", ":", "\n", "# Additionally do local search", "\n", "        ", "search_parameters", ".", "local_search_metaheuristic", "=", "(", "\n", "routing_enums_pb2", ".", "LocalSearchMetaheuristic", ".", "GUIDED_LOCAL_SEARCH", ")", "\n", "search_parameters", ".", "time_limit_ms", "=", "1000", "*", "sec_local_search", "\n", "# Solve the problem.", "\n", "", "assignment", "=", "routing", ".", "SolveWithParameters", "(", "search_parameters", ")", "\n", "\n", "assert", "assignment", "is", "not", "None", ",", "\"ORTools was unable to find a feasible solution\"", "\n", "\n", "index", "=", "routing", ".", "Start", "(", "0", ")", "\n", "route", "=", "[", "]", "\n", "while", "not", "routing", ".", "IsEnd", "(", "index", ")", ":", "\n", "        ", "node_index", "=", "routing", ".", "IndexToNode", "(", "index", ")", "\n", "route", ".", "append", "(", "node_index", ")", "\n", "index", "=", "assignment", ".", "Value", "(", "routing", ".", "NextVar", "(", "index", ")", ")", "\n", "# The constant total of prizes is not taken into account by ORTOOLS", "\n", "# This returns - total prize collected = total prize not collected - total prize", "\n", "", "return", "assignment", ".", "ObjectiveValue", "(", ")", "/", "10000000.", "-", "sum", "(", "prize", ")", ",", "route", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.main": [[237, 260], ["op_ortools.DataProblem", "ortools.constraint_solver.pywrapcp.RoutingModel", "pywrapcp.RoutingModel.SetArcCostEvaluatorOfAllVehicles", "ortools.constraint_solver.pywrapcp.RoutingModel.DefaultSearchParameters", "pywrapcp.RoutingModel.SolveWithParameters", "op_ortools.print_solution", "op_ortools.CreateDistanceEvaluator"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.op_ortools.print_solution"], ["", "def", "main", "(", ")", ":", "\n", "  ", "\"\"\"Entry point of the program\"\"\"", "\n", "# Instantiate the data problem.", "\n", "data", "=", "DataProblem", "(", ")", "\n", "\n", "# Create Routing Model", "\n", "routing", "=", "pywrapcp", ".", "RoutingModel", "(", "data", ".", "num_locations", ",", "data", ".", "num_vehicles", ",", "\n", "data", ".", "depot", ")", "\n", "\n", "# Define weight of each edge", "\n", "distance_evaluator", "=", "CreateDistanceEvaluator", "(", "data", ")", ".", "distance_evaluator", "\n", "routing", ".", "SetArcCostEvaluatorOfAllVehicles", "(", "distance_evaluator", ")", "\n", "# Add Capacity constraint", "\n", "# prize_evaluator = CreatePrizeEvaluator(data).prize_evaluator", "\n", "# add_capacity_constraints(routing, data, prize_evaluator)", "\n", "\n", "# Setting first solution heuristic (cheapest addition).", "\n", "search_parameters", "=", "pywrapcp", ".", "RoutingModel", ".", "DefaultSearchParameters", "(", ")", "\n", "search_parameters", ".", "first_solution_strategy", "=", "(", "\n", "routing_enums_pb2", ".", "FirstSolutionStrategy", ".", "PATH_CHEAPEST_ARC", ")", "# pylint: disable=no-member", "\n", "# Solve the problem.", "\n", "assignment", "=", "routing", ".", "SolveWithParameters", "(", "search_parameters", ")", "\n", "print_solution", "(", "data", ",", "routing", ",", "assignment", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.op.tsiligirides.op_tsiligirides": [[5, 42], ["problems.op.state_op.StateOP.initialize", "torch.stack", "state.update.all_finished", "state.update.get_mask", "p.topk", "mask[].gather", "torch.cat", "[].gather", "state.update.update", "all_a.append", "torch.cat.sum", "pnorm[].multinomial", "[].unsqueeze", "torch.cat", "pnorm[].max", "torch.zeros_like"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_mask", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.topk", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.update"], ["def", "op_tsiligirides", "(", "batch", ",", "sample", "=", "False", ",", "power", "=", "4.0", ")", ":", "\n", "    ", "state", "=", "StateOP", ".", "initialize", "(", "batch", ")", "\n", "\n", "all_a", "=", "[", "]", "\n", "while", "not", "state", ".", "all_finished", "(", ")", ":", "\n", "# Compute scores", "\n", "        ", "mask", "=", "state", ".", "get_mask", "(", ")", "\n", "p", "=", "(", "\n", "(", "mask", "[", "...", ",", "1", ":", "]", "==", "0", ")", ".", "float", "(", ")", "*", "\n", "state", ".", "prize", "[", "state", ".", "ids", ",", "1", ":", "]", "/", "\n", "(", "(", "state", ".", "coords", "[", "state", ".", "ids", ",", "1", ":", ",", ":", "]", "-", "state", ".", "cur_coord", "[", ":", ",", ":", ",", "None", ",", ":", "]", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "+", "1e-6", ")", "\n", ")", "**", "power", "\n", "bestp", ",", "besta", "=", "p", ".", "topk", "(", "4", ",", "dim", "=", "-", "1", ")", "\n", "bestmask", "=", "mask", "[", "...", ",", "1", ":", "]", ".", "gather", "(", "-", "1", ",", "besta", ")", "\n", "\n", "# If no feasible actions, must go to depot", "\n", "# mask == 0 means feasible, so if mask == 0 sums to 0 there are no feasible and", "\n", "# all corresponding ps should be 0, so we need to add a column with a 1 that corresponds", "\n", "# to selecting the end destination", "\n", "to_depot", "=", "(", "(", "bestmask", "==", "0", ")", ".", "sum", "(", "-", "1", ",", "keepdim", "=", "True", ")", "==", "0", ")", ".", "float", "(", ")", "\n", "# best_p should be zero if we have to go to depot, but because of numeric stabilities, it isn't", "\n", "p_", "=", "torch", ".", "cat", "(", "(", "to_depot", ",", "bestp", ")", ",", "-", "1", ")", "\n", "pnorm", "=", "p_", "/", "p_", ".", "sum", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "if", "sample", ":", "\n", "            ", "a", "=", "pnorm", "[", ":", ",", "0", ",", ":", "]", ".", "multinomial", "(", "1", ")", "# Sample action", "\n", "", "else", ":", "\n", "# greedy", "\n", "            ", "a", "=", "pnorm", "[", ":", ",", "0", ",", ":", "]", ".", "max", "(", "-", "1", ")", "[", "1", "]", ".", "unsqueeze", "(", "-", "1", ")", "# Add 'sampling dimension'", "\n", "\n", "# a == 0 means depot, otherwise subtract one", "\n", "", "final_a", "=", "torch", ".", "cat", "(", "(", "torch", ".", "zeros_like", "(", "besta", "[", "...", ",", "0", ":", "1", "]", ")", ",", "besta", "+", "1", ")", ",", "-", "1", ")", "[", ":", ",", "0", ",", ":", "]", ".", "gather", "(", "-", "1", ",", "a", ")", "\n", "\n", "selected", "=", "final_a", "[", "...", ",", "0", "]", "# Squeeze unnecessary sampling dimension", "\n", "state", "=", "state", ".", "update", "(", "selected", ")", "\n", "all_a", ".", "append", "(", "selected", ")", "\n", "", "return", "torch", ".", "stack", "(", "all_a", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.fitness": [[7, 33], ["range", "oph.ell_sub", "len", "augs.append", "print", "print", "print", "oph.init_replacement", "print", "print", "print", "print", "print", "print", "print", "print", "sum", "len", "sum", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.ell_sub", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.init_replacement"], ["def", "fitness", "(", "chrom", ",", "s", ",", "start_point", ",", "end_point", ",", "tmax", ")", ":", "\n", "    ", "augs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "s", ")", ")", ":", "\n", "        ", "augs", ".", "append", "(", "(", "s", "[", "i", "]", "[", "0", "]", ",", "\n", "s", "[", "i", "]", "[", "1", "]", ",", "\n", "s", "[", "i", "]", "[", "2", "]", ",", "\n", "s", "[", "i", "]", "[", "3", "]", ",", "\n", "s", "[", "i", "]", "[", "4", "]", "+", "chrom", "[", "i", "]", ")", ")", "\n", "", "if", "debug", ":", "\n", "        ", "print", "(", "'fitness---------------------------------'", ")", "\n", "print", "(", "'augs:'", ")", "\n", "print", "(", "augs", ")", "\n", "#best = oph.ellinit_replacement( augs, start_point, end_point, tmax )", "\n", "", "ellset", "=", "oph", ".", "ell_sub", "(", "tmax", ",", "start_point", ",", "end_point", ",", "augs", ")", "\n", "#best = oph.initialize( ellset, start_point, end_point, tmax )[0]", "\n", "best", "=", "oph", ".", "init_replacement", "(", "ellset", ",", "start_point", ",", "end_point", ",", "tmax", ")", "[", "0", "]", "\n", "if", "debug", ":", "\n", "        ", "print", "(", "'best:'", ")", "\n", "print", "(", "best", ")", "\n", "print", "(", "'best real reward:'", ")", "\n", "print", "(", "[", "x", "[", "3", "]", "for", "x", "in", "best", "]", ")", "\n", "print", "(", "len", "(", "s", ")", ")", "\n", "print", "(", "[", "s", "[", "x", "[", "3", "]", "-", "2", "]", "for", "x", "in", "best", "[", "1", ":", "len", "(", "best", ")", "-", "1", "]", "]", ")", "\n", "print", "(", "[", "s", "[", "x", "[", "3", "]", "-", "2", "]", "[", "2", "]", "for", "x", "in", "best", "[", "1", ":", "len", "(", "best", ")", "-", "1", "]", "]", ")", "\n", "print", "(", "(", "sum", "(", "[", "s", "[", "x", "[", "3", "]", "-", "2", "]", "[", "2", "]", "for", "x", "in", "best", "[", "1", ":", "len", "(", "best", ")", "-", "1", "]", "]", ")", ",", "best", ")", ")", "\n", "", "return", "(", "sum", "(", "[", "s", "[", "x", "[", "3", "]", "-", "2", "]", "[", "2", "]", "for", "x", "in", "best", "[", "1", ":", "len", "(", "best", ")", "-", "1", "]", "]", ")", ",", "best", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.crossover": [[34, 42], ["random.randrange", "random.randrange", "len", "len", "len"], "function", ["None"], ["", "def", "crossover", "(", "c1", ",", "c2", ")", ":", "\n", "    ", "assert", "(", "len", "(", "c1", ")", "==", "len", "(", "c2", ")", ")", "\n", "point", "=", "random", ".", "randrange", "(", "len", "(", "c1", ")", ")", "\n", "first", "=", "random", ".", "randrange", "(", "2", ")", "\n", "if", "(", "first", ")", ":", "\n", "        ", "return", "c1", "[", ":", "point", "]", "+", "c2", "[", "point", ":", "]", "\n", "", "else", ":", "\n", "        ", "return", "c2", "[", ":", "point", "]", "+", "c1", "[", "point", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.mutate": [[43, 46], ["random.randrange", "random.gauss"], "function", ["None"], ["", "", "def", "mutate", "(", "chrom", ",", "mchance", ",", "msigma", ")", ":", "\n", "    ", "return", "[", "x", "+", "random", ".", "gauss", "(", "0", ",", "msigma", ")", "if", "random", ".", "randrange", "(", "mchance", ")", "==", "0", "else", "\n", "x", "for", "x", "in", "chrom", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.run_alg_f": [[47, 56], ["random.seed", "f.readline", "range", "opevo.run_alg", "cpoints.append", "print", "tuple", "float", "f.readline().split", "f.readline"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.run_alg"], ["", "def", "run_alg_f", "(", "f", ",", "tmax", ",", "N", ")", ":", "\n", "    ", "random", ".", "seed", "(", ")", "\n", "cpoints", "=", "[", "]", "\n", "an_unused_value", "=", "f", ".", "readline", "(", ")", "# ignore first line of file", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "        ", "cpoints", ".", "append", "(", "tuple", "(", "[", "float", "(", "x", ")", "for", "x", "in", "f", ".", "readline", "(", ")", ".", "split", "(", ")", "]", ")", ")", "\n", "", "if", "debug", ":", "\n", "        ", "print", "(", "'N:            '", ",", "N", ")", "\n", "", "return", "run_alg", "(", "cpoints", ",", "tmax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.run_alg": [[57, 149], ["cpoints.pop", "cpoints.pop", "time.clock", "range", "range", "time.clock", "oph.ellinit_replacement", "range", "oph.distance", "print", "print", "print", "print", "print", "print", "print", "print", "range", "pop.insert", "range", "sorted", "print", "print", "print", "print", "print", "opevo.fitness", "print", "print", "oph.initialize", "print", "print", "print", "print", "oph.distance", "oph.distance", "oph.distance", "print", "print", "print", "tuple", "enumerate", "len", "chrom.append", "opevo.mutate", "oph.ell_sub", "sum", "sum", "len", "len", "str", "random.gauss", "opevo.fitness", "sorted", "opevo.crossover", "pop.insert", "nextgen.append", "nextgen.append", "random.sample", "opevo.fitness", "print", "pop.pop", "len"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.ellinit_replacement", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.fitness", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.mutate", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.ell_sub", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.fitness", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.crossover", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.opevo.fitness"], ["", "def", "run_alg", "(", "points", ",", "tmax", ",", "return_sol", "=", "False", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "cpoints", "=", "[", "tuple", "(", "p", ")", "+", "(", "i", ",", "0", ")", "for", "i", ",", "p", "in", "enumerate", "(", "points", ")", "]", "\n", "start_point", "=", "cpoints", ".", "pop", "(", "0", ")", "\n", "end_point", "=", "cpoints", ".", "pop", "(", "0", ")", "\n", "assert", "(", "oph", ".", "distance", "(", "start_point", ",", "end_point", ")", "<", "tmax", ")", "\n", "popsize", "=", "10", "\n", "genlimit", "=", "10", "\n", "kt", "=", "5", "\n", "isigma", "=", "10", "\n", "msigma", "=", "7", "\n", "mchance", "=", "2", "\n", "elitismn", "=", "2", "\n", "if", "(", "debug", ")", ":", "\n", "        ", "print", "(", "'data set size:'", ",", "len", "(", "cpoints", ")", "+", "2", ")", "\n", "print", "(", "'tmax:         '", ",", "tmax", ")", "\n", "print", "(", "'parameters:'", ")", "\n", "print", "(", "'generations:     '", ",", "genlimit", ")", "\n", "print", "(", "'population size: '", ",", "popsize", ")", "\n", "print", "(", "'ktournament size:'", ",", "kt", ")", "\n", "print", "(", "'mutation chance: '", ",", "mchance", ")", "\n", "print", "(", "str", "(", "elitismn", ")", "+", "'-elitism'", ")", "\n", "\n", "", "start_time", "=", "time", ".", "clock", "(", ")", "\n", "#generate initial random population", "\n", "pop", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "popsize", "+", "elitismn", ")", ":", "\n", "        ", "chrom", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "cpoints", ")", ")", ":", "\n", "            ", "chrom", ".", "append", "(", "random", ".", "gauss", "(", "0", ",", "isigma", ")", ")", "\n", "", "chrom", "=", "(", "fitness", "(", "chrom", ",", "cpoints", ",", "start_point", ",", "end_point", ",", "tmax", ")", "[", "0", "]", ",", "chrom", ")", "\n", "while", "(", "i", "-", "j", ">", "0", "and", "j", "<", "elitismn", "and", "chrom", ">", "pop", "[", "i", "-", "1", "-", "j", "]", ")", ":", "\n", "            ", "j", "+=", "1", "\n", "", "pop", ".", "insert", "(", "i", "-", "j", ",", "chrom", ")", "\n", "\n", "", "bestfit", "=", "0", "\n", "for", "i", "in", "range", "(", "genlimit", ")", ":", "\n", "        ", "nextgen", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "popsize", ")", ":", "\n", "#select parents in k tournaments", "\n", "            ", "parents", "=", "sorted", "(", "random", ".", "sample", "(", "pop", ",", "kt", ")", ")", "[", "kt", "-", "2", ":", "]", "#optimize later", "\n", "#crossover and mutate", "\n", "offspring", "=", "mutate", "(", "crossover", "(", "parents", "[", "0", "]", "[", "1", "]", ",", "parents", "[", "1", "]", "[", "1", "]", ")", ",", "mchance", ",", "msigma", ")", "\n", "offspring", "=", "(", "fitness", "(", "offspring", ",", "cpoints", ",", "start_point", ",", "end_point", ",", "tmax", ")", "[", "0", "]", ",", "offspring", ")", "\n", "if", "(", "offspring", "[", "0", "]", ">", "bestfit", ")", ":", "\n", "                ", "bestfit", "=", "offspring", "[", "0", "]", "\n", "if", "verbose", ":", "\n", "                    ", "print", "(", "bestfit", ")", "\n", "", "", "if", "(", "elitismn", ">", "0", "and", "offspring", ">", "pop", "[", "popsize", "]", ")", ":", "\n", "                ", "l", "=", "0", "\n", "while", "(", "l", "<", "elitismn", "and", "offspring", ">", "pop", "[", "popsize", "+", "l", "]", ")", ":", "\n", "                    ", "l", "+=", "1", "\n", "", "pop", ".", "insert", "(", "popsize", "+", "l", ",", "offspring", ")", "\n", "nextgen", ".", "append", "(", "pop", ".", "pop", "(", "popsize", ")", ")", "\n", "", "else", ":", "\n", "                ", "nextgen", ".", "append", "(", "offspring", ")", "\n", "", "", "pop", "=", "nextgen", "+", "pop", "[", "popsize", ":", "]", "\n", "\n", "", "bestchrom", "=", "sorted", "(", "pop", ")", "[", "popsize", "+", "elitismn", "-", "1", "]", "\n", "end_time", "=", "time", ".", "clock", "(", ")", "\n", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'time:'", ")", "\n", "print", "(", "end_time", "-", "start_time", ")", "\n", "print", "(", "'best fitness:'", ")", "\n", "print", "(", "bestchrom", "[", "0", "]", ")", "\n", "print", "(", "'best path:'", ")", "\n", "", "best_path", "=", "fitness", "(", "bestchrom", "[", "1", "]", ",", "cpoints", ",", "start_point", ",", "end_point", ",", "tmax", ")", "[", "1", "]", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "[", "x", "[", "3", "]", "for", "x", "in", "best_path", "]", ")", "\n", "\n", "print", "(", "'their stuff:'", ")", "\n", "", "stuff", "=", "oph", ".", "initialize", "(", "oph", ".", "ell_sub", "(", "tmax", ",", "start_point", ",", "end_point", ",", "cpoints", ")", "\n", ",", "start_point", ",", "end_point", ",", "tmax", ")", "[", "0", "]", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'fitness:'", ",", "sum", "(", "[", "x", "[", "2", "]", "for", "x", "in", "stuff", "]", ")", ")", "\n", "print", "(", "'my stuff:'", ")", "\n", "", "stuff2", "=", "oph", ".", "ellinit_replacement", "(", "cpoints", ",", "start_point", ",", "end_point", ",", "tmax", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'fitness:'", ",", "sum", "(", "[", "x", "[", "2", "]", "for", "x", "in", "stuff2", "]", ")", ")", "\n", "print", "(", "'checking correctness...'", ")", "\n", "", "total_distance", "=", "(", "oph", ".", "distance", "(", "start_point", ",", "cpoints", "[", "best_path", "[", "1", "]", "[", "3", "]", "-", "2", "]", ")", "+", "\n", "oph", ".", "distance", "(", "end_point", ",", "cpoints", "[", "best_path", "[", "len", "(", "best_path", ")", "-", "2", "]", "[", "3", "]", "-", "2", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "best_path", ")", "-", "3", ")", ":", "\n", "        ", "total_distance", "+=", "oph", ".", "distance", "(", "cpoints", "[", "best_path", "[", "i", "]", "[", "3", "]", "-", "2", "]", ",", "\n", "cpoints", "[", "best_path", "[", "i", "+", "1", "]", "[", "3", "]", "-", "2", "]", ")", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'OK'", "if", "total_distance", "<=", "tmax", "else", "'not OK'", ")", "\n", "print", "(", "'tmax:          '", ",", "tmax", ")", "\n", "print", "(", "'total distance:'", ",", "total_distance", ")", "\n", "", "if", "return_sol", ":", "\n", "        ", "return", "(", "bestchrom", "[", "0", "]", ",", "best_path", ",", "end_time", "-", "start_time", ")", "\n", "", "return", "(", "bestchrom", "[", "0", "]", ",", "end_time", "-", "start_time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance": [[3, 5], ["math.sqrt"], "function", ["None"], ["def", "distance", "(", "p1", ",", "p2", ")", ":", "\n", "    ", "return", "math", ".", "sqrt", "(", "(", "p1", "[", "0", "]", "-", "p2", "[", "0", "]", ")", "**", "2", "+", "(", "p1", "[", "1", "]", "-", "p2", "[", "1", "]", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.ellinit_replacement": [[7, 32], ["list", "oph.distance", "range", "len", "len", "range", "path.insert", "list.pop", "len", "oph.distance", "oph.distance", "oph.distance"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance"], ["", "def", "ellinit_replacement", "(", "s1", ",", "start_point", ",", "end_point", ",", "tmax", ")", ":", "\n", "    ", "s", "=", "list", "(", "s1", ")", "\n", "path", "=", "[", "start_point", ",", "end_point", "]", "\n", "length", "=", "distance", "(", "start_point", ",", "end_point", ")", "\n", "found", "=", "True", "\n", "while", "(", "found", "==", "True", "and", "len", "(", "s", ")", ">", "0", ")", ":", "\n", "        ", "min_added_length", "=", "-", "1", "\n", "max_added_reward", "=", "0", "\n", "for", "j", "in", "range", "(", "len", "(", "s", ")", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "                ", "added_length", "=", "(", "distance", "(", "path", "[", "k", "]", ",", "s", "[", "j", "]", ")", "+", "\n", "distance", "(", "path", "[", "k", "+", "1", "]", ",", "s", "[", "j", "]", ")", "-", "\n", "distance", "(", "path", "[", "k", "]", ",", "path", "[", "k", "+", "1", "]", ")", ")", "# optimize later", "\n", "if", "(", "length", "+", "added_length", "<", "tmax", "and", "s", "[", "j", "]", "[", "2", "]", ">", "max_added_reward", ")", ":", "\n", "                    ", "min_added_length", "=", "added_length", "\n", "max_added_reward", "=", "s", "[", "j", "]", "[", "2", "]", "\n", "minpoint", "=", "j", "\n", "pathpoint", "=", "k", "+", "1", "\n", "", "", "", "if", "(", "min_added_length", ">", "0", ")", ":", "\n", "#add to path", "\n", "            ", "path", ".", "insert", "(", "pathpoint", ",", "s", ".", "pop", "(", "minpoint", ")", ")", "\n", "length", "=", "length", "+", "min_added_length", "\n", "", "else", ":", "\n", "            ", "found", "=", "False", "\n", "", "", "return", "path", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.init_replacement": [[35, 80], ["list", "range", "len", "sorted", "len", "len", "oph.distance", "oph.distance", "range", "paths.append", "len", "len", "len", "len", "len", "range", "path.insert", "sorted", "arest.pop", "len", "oph.distance", "oph.distance", "oph.distance", "sum"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance"], ["", "def", "init_replacement", "(", "s1", ",", "start_point", ",", "end_point", ",", "tmax", ")", ":", "\n", "    ", "s", "=", "list", "(", "s1", ")", "\n", "L", "=", "len", "(", "s", ")", "if", "len", "(", "s", ")", "<=", "10", "else", "10", "\n", "if", "(", "L", "==", "0", ")", ":", "\n", "#print 'something is probably wrong'", "\n", "#actually maybe not", "\n", "        ", "return", "[", "[", "start_point", ",", "end_point", "]", "]", "\n", "\n", "#decorate and sort by weight", "\n", "", "dsub", "=", "sorted", "(", "[", "(", "x", "[", "4", "]", ",", "x", ")", "for", "x", "in", "s", "]", ")", "[", ":", ":", "-", "1", "]", "#this is different", "\n", "ls", "=", "dsub", "[", ":", "L", "]", "\n", "rest", "=", "dsub", "[", "L", ":", "]", "\n", "paths", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "L", ")", ":", "\n", "        ", "path", "=", "[", "start_point", ",", "ls", "[", "i", "]", "[", "1", "]", ",", "end_point", "]", "\n", "length", "=", "distance", "(", "path", "[", "0", "]", ",", "path", "[", "1", "]", ")", "+", "distance", "(", "path", "[", "1", "]", ",", "path", "[", "2", "]", ")", "\n", "assert", "(", "length", "<", "tmax", ")", "\n", "arest", "=", "ls", "[", ":", "i", "]", "+", "ls", "[", "i", "+", "1", ":", "]", "+", "rest", "\n", "arest", "=", "[", "x", "[", "1", "]", "for", "x", "in", "arest", "]", "#undecorate", "\n", "assert", "(", "len", "(", "arest", ")", "+", "len", "(", "path", ")", "==", "len", "(", "s", ")", "+", "2", ")", "\n", "found", "=", "True", "\n", "while", "(", "found", "==", "True", "and", "len", "(", "arest", ")", ">", "0", ")", ":", "\n", "            ", "min_added_length", "=", "-", "1", "\n", "max_weight", "=", "0", "\n", "for", "j", "in", "range", "(", "len", "(", "arest", ")", ")", ":", "\n", "                ", "for", "k", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "                    ", "added_length", "=", "(", "distance", "(", "path", "[", "k", "]", ",", "arest", "[", "j", "]", ")", "+", "\n", "distance", "(", "path", "[", "k", "+", "1", "]", ",", "arest", "[", "j", "]", ")", "-", "\n", "distance", "(", "path", "[", "k", "]", ",", "path", "[", "k", "+", "1", "]", ")", ")", "# optimize later", "\n", "if", "(", "length", "+", "added_length", "<", "tmax", "and", "arest", "[", "j", "]", "[", "4", "]", "<", "max_weight", ")", ":", "\n", "                        ", "min_added_length", "=", "added_length", "\n", "max_weight", "=", "arest", "[", "j", "]", "[", "4", "]", "\n", "minpoint", "=", "j", "\n", "pathpoint", "=", "k", "+", "1", "\n", "", "", "", "if", "(", "min_added_length", ">", "0", ")", ":", "\n", "#add to path", "\n", "                ", "path", ".", "insert", "(", "pathpoint", ",", "arest", ".", "pop", "(", "minpoint", ")", ")", "\n", "length", "=", "length", "+", "min_added_length", "\n", "", "else", ":", "\n", "                ", "found", "=", "False", "\n", "", "", "if", "(", "length", "<", "tmax", ")", ":", "\n", "            ", "paths", ".", "append", "(", "path", ")", "\n", "\n", "", "", "assert", "(", "len", "(", "paths", ")", ">", "0", ")", "\n", "return", "[", "x", "[", "1", "]", "for", "x", "in", "sorted", "(", "[", "(", "sum", "(", "[", "y", "[", "2", "]", "for", "y", "in", "z", "]", ")", ",", "z", ")", "for", "z", "in", "paths", "]", ")", "[", ":", ":", "-", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.ell_sub": [[83, 89], ["result.append", "oph.distance", "oph.distance"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance"], ["", "def", "ell_sub", "(", "axis", ",", "f1", ",", "f2", ",", "s", ")", ":", "\n", "    ", "result", "=", "[", "]", "\n", "for", "item", "in", "s", ":", "\n", "        ", "if", "(", "distance", "(", "item", ",", "f1", ")", "+", "distance", "(", "item", ",", "f2", ")", "<=", "axis", ")", ":", "\n", "            ", "result", ".", "append", "(", "item", ")", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.initialize": [[91, 131], ["range", "len", "sorted", "paths.append", "len", "len", "range", "oph.distance", "oph.distance", "len", "len", "len", "len", "len", "range", "path.insert", "sorted", "arest.pop", "oph.distance", "oph.distance", "len", "oph.distance", "sorted", "oph.distance", "oph.distance", "sum", "sum"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance", "home.repos.pwc.inspect_result.alstn12088_lcp.opga.oph.distance"], ["", "def", "initialize", "(", "s", ",", "start_point", ",", "end_point", ",", "tmax", ")", ":", "\n", "    ", "L", "=", "len", "(", "s", ")", "if", "len", "(", "s", ")", "<=", "10", "else", "10", "\n", "if", "(", "L", "==", "0", ")", ":", "\n", "        ", "return", "[", "[", "start_point", ",", "end_point", "]", "]", "\n", "\n", "", "dsub", "=", "sorted", "(", "[", "(", "distance", "(", "x", ",", "start_point", ")", "+", "distance", "(", "x", ",", "end_point", ")", ",", "x", ")", "for", "x", "in", "s", "]", "\n", ")", "[", ":", ":", "-", "1", "]", "#optimize later", "\n", "ls", "=", "dsub", "[", ":", "L", "]", "\n", "rest", "=", "dsub", "[", "L", ":", "]", "\n", "paths", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "L", ")", ":", "\n", "        ", "path", "=", "[", "start_point", ",", "ls", "[", "i", "]", "[", "1", "]", ",", "end_point", "]", "\n", "length", "=", "ls", "[", "i", "]", "[", "0", "]", "\n", "assert", "(", "length", "==", "distance", "(", "path", "[", "0", "]", ",", "path", "[", "1", "]", ")", "+", "distance", "(", "path", "[", "1", "]", ",", "path", "[", "2", "]", ")", ")", "\n", "arest", "=", "ls", "[", ":", "i", "]", "+", "ls", "[", "i", "+", "1", ":", "]", "+", "rest", "\n", "arest", "=", "[", "x", "[", "1", "]", "for", "x", "in", "arest", "]", "#undecorate", "\n", "assert", "(", "len", "(", "arest", ")", "+", "len", "(", "path", ")", "==", "len", "(", "s", ")", "+", "2", ")", "\n", "found", "=", "True", "\n", "while", "(", "found", "==", "True", "and", "len", "(", "arest", ")", ">", "0", ")", ":", "\n", "            ", "min_added", "=", "-", "1", "\n", "for", "j", "in", "range", "(", "len", "(", "arest", ")", ")", ":", "\n", "                ", "for", "k", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "                    ", "added_length", "=", "(", "distance", "(", "path", "[", "k", "]", ",", "arest", "[", "j", "]", ")", "+", "\n", "distance", "(", "path", "[", "k", "+", "1", "]", ",", "arest", "[", "j", "]", ")", "-", "\n", "distance", "(", "path", "[", "k", "]", ",", "path", "[", "k", "+", "1", "]", ")", ")", "# optimize later", "\n", "if", "(", "length", "+", "added_length", "<", "tmax", "and", "(", "added_length", "<", "min_added", "or", "min_added", "<", "0", ")", ")", ":", "\n", "                        ", "min_added", "=", "added_length", "\n", "minpoint", "=", "j", "\n", "pathpoint", "=", "k", "+", "1", "\n", "", "", "", "if", "(", "min_added", ">", "0", ")", ":", "\n", "#add to path", "\n", "                ", "path", ".", "insert", "(", "pathpoint", ",", "arest", ".", "pop", "(", "minpoint", ")", ")", "\n", "length", "=", "length", "+", "min_added", "\n", "", "else", ":", "\n", "                ", "found", "=", "False", "\n", "", "", "paths", ".", "append", "(", "path", ")", "\n", "\n", "", "assert", "(", "len", "(", "[", "x", "[", "1", "]", "for", "x", "in", "sorted", "(", "[", "(", "sum", "(", "[", "y", "[", "2", "]", "for", "y", "in", "z", "]", ")", ",", "z", ")", "for", "z", "in", "paths", "]", "\n", ")", "[", ":", ":", "-", "1", "]", "]", ")", ">", "0", ")", "\n", "return", "[", "x", "[", "1", "]", "for", "x", "in", "sorted", "(", "[", "(", "sum", "(", "[", "y", "[", "2", "]", "for", "y", "in", "z", "]", ")", ",", "z", ")", "for", "z", "in", "paths", "]", ")", "[", ":", ":", "-", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.SkipConnection.__init__": [[9, 12], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "module", ")", ":", "\n", "        ", "super", "(", "SkipConnection", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.SkipConnection.forward": [[13, 15], ["graph_encoder.SkipConnection.module"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "input", "+", "self", ".", "module", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.MultiHeadAttention.__init__": [[18, 50], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "graph_encoder.MultiHeadAttention.init_parameters", "math.sqrt", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.nn.Parameter", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.Normalization.init_parameters"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_heads", ",", "\n", "input_dim", ",", "\n", "embed_dim", "=", "None", ",", "\n", "val_dim", "=", "None", ",", "\n", "key_dim", "=", "None", "\n", ")", ":", "\n", "        ", "super", "(", "MultiHeadAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "val_dim", "is", "None", ":", "\n", "            ", "assert", "embed_dim", "is", "not", "None", ",", "\"Provide either embed_dim or val_dim\"", "\n", "val_dim", "=", "embed_dim", "//", "n_heads", "\n", "", "if", "key_dim", "is", "None", ":", "\n", "            ", "key_dim", "=", "val_dim", "\n", "\n", "", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "self", ".", "val_dim", "=", "val_dim", "\n", "self", ".", "key_dim", "=", "key_dim", "\n", "\n", "self", ".", "norm_factor", "=", "1", "/", "math", ".", "sqrt", "(", "key_dim", ")", "# See Attention is all you need", "\n", "\n", "self", ".", "W_query", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "n_heads", ",", "input_dim", ",", "key_dim", ")", ")", "\n", "self", ".", "W_key", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "n_heads", ",", "input_dim", ",", "key_dim", ")", ")", "\n", "self", ".", "W_val", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "n_heads", ",", "input_dim", ",", "val_dim", ")", ")", "\n", "\n", "if", "embed_dim", "is", "not", "None", ":", "\n", "            ", "self", ".", "W_out", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "n_heads", ",", "key_dim", ",", "embed_dim", ")", ")", "\n", "\n", "", "self", ".", "init_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.MultiHeadAttention.init_parameters": [[51, 56], ["graph_encoder.MultiHeadAttention.parameters", "param.data.uniform_", "math.sqrt", "param.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "init_parameters", "(", "self", ")", ":", "\n", "\n", "        ", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "param", ".", "size", "(", "-", "1", ")", ")", "\n", "param", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.MultiHeadAttention.forward": [[57, 113], ["h.size", "q.size", "h.contiguous().view", "q.contiguous().view", "torch.matmul().view", "torch.matmul().view", "torch.matmul().view", "torch.softmax", "torch.matmul", "torch.mm().view", "q.size", "q.size", "torch.matmul", "mask.view().expand_as.view().expand_as.view().expand_as", "torch.softmax.clone", "h.contiguous", "q.contiguous", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul().view.transpose", "torch.mm", "mask.view().expand_as.view().expand_as.view", "torch.matmul.permute().contiguous().view", "graph_encoder.MultiHeadAttention.W_out.view", "torch.matmul.permute().contiguous", "torch.matmul.permute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "", "def", "forward", "(", "self", ",", "q", ",", "h", "=", "None", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\n        :param q: queries (batch_size, n_query, input_dim)\n        :param h: data (batch_size, graph_size, input_dim)\n        :param mask: mask (batch_size, n_query, graph_size) or viewable as that (i.e. can be 2 dim if n_query == 1)\n        Mask should contain 1 if attention is not possible (i.e. mask is negative adjacency)\n        :return:\n        \"\"\"", "\n", "if", "h", "is", "None", ":", "\n", "            ", "h", "=", "q", "# compute self-attention", "\n", "\n", "# h should be (batch_size, graph_size, input_dim)", "\n", "", "batch_size", ",", "graph_size", ",", "input_dim", "=", "h", ".", "size", "(", ")", "\n", "n_query", "=", "q", ".", "size", "(", "1", ")", "\n", "assert", "q", ".", "size", "(", "0", ")", "==", "batch_size", "\n", "assert", "q", ".", "size", "(", "2", ")", "==", "input_dim", "\n", "assert", "input_dim", "==", "self", ".", "input_dim", ",", "\"Wrong embedding dimension of input\"", "\n", "\n", "hflat", "=", "h", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "input_dim", ")", "\n", "qflat", "=", "q", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "input_dim", ")", "\n", "\n", "# last dimension can be different for keys and values", "\n", "shp", "=", "(", "self", ".", "n_heads", ",", "batch_size", ",", "graph_size", ",", "-", "1", ")", "\n", "shp_q", "=", "(", "self", ".", "n_heads", ",", "batch_size", ",", "n_query", ",", "-", "1", ")", "\n", "\n", "# Calculate queries, (n_heads, n_query, graph_size, key/val_size)", "\n", "Q", "=", "torch", ".", "matmul", "(", "qflat", ",", "self", ".", "W_query", ")", ".", "view", "(", "shp_q", ")", "\n", "# Calculate keys and values (n_heads, batch_size, graph_size, key/val_size)", "\n", "K", "=", "torch", ".", "matmul", "(", "hflat", ",", "self", ".", "W_key", ")", ".", "view", "(", "shp", ")", "\n", "V", "=", "torch", ".", "matmul", "(", "hflat", ",", "self", ".", "W_val", ")", ".", "view", "(", "shp", ")", "\n", "\n", "# Calculate compatibility (n_heads, batch_size, n_query, graph_size)", "\n", "compatibility", "=", "self", ".", "norm_factor", "*", "torch", ".", "matmul", "(", "Q", ",", "K", ".", "transpose", "(", "2", ",", "3", ")", ")", "\n", "\n", "# Optionally apply mask to prevent attention", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "mask", ".", "view", "(", "1", ",", "batch_size", ",", "n_query", ",", "graph_size", ")", ".", "expand_as", "(", "compatibility", ")", "\n", "compatibility", "[", "mask", "]", "=", "-", "np", ".", "inf", "\n", "\n", "", "attn", "=", "torch", ".", "softmax", "(", "compatibility", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# If there are nodes with no neighbours then softmax returns nan so we fix them to 0", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "attnc", "=", "attn", ".", "clone", "(", ")", "\n", "attnc", "[", "mask", "]", "=", "0", "\n", "attn", "=", "attnc", "\n", "\n", "", "heads", "=", "torch", ".", "matmul", "(", "attn", ",", "V", ")", "\n", "\n", "out", "=", "torch", ".", "mm", "(", "\n", "heads", ".", "permute", "(", "1", ",", "2", ",", "0", ",", "3", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", "*", "self", ".", "val_dim", ")", ",", "\n", "self", ".", "W_out", ".", "view", "(", "-", "1", ",", "self", ".", "embed_dim", ")", "\n", ")", ".", "view", "(", "batch_size", ",", "n_query", ",", "self", ".", "embed_dim", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.Normalization.__init__": [[117, 126], ["torch.nn.Module.__init__", "normalizer_class"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embed_dim", ",", "normalization", "=", "'batch'", ")", ":", "\n", "        ", "super", "(", "Normalization", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "normalizer_class", "=", "{", "\n", "'batch'", ":", "nn", ".", "BatchNorm1d", ",", "\n", "'instance'", ":", "nn", ".", "InstanceNorm1d", "\n", "}", ".", "get", "(", "normalization", ",", "None", ")", "\n", "\n", "self", ".", "normalizer", "=", "normalizer_class", "(", "embed_dim", ",", "affine", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.Normalization.init_parameters": [[130, 135], ["graph_encoder.Normalization.named_parameters", "param.data.uniform_", "math.sqrt", "param.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "init_parameters", "(", "self", ")", ":", "\n", "\n", "        ", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "param", ".", "size", "(", "-", "1", ")", ")", "\n", "param", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.Normalization.forward": [[136, 145], ["isinstance", "graph_encoder.Normalization.normalizer().view", "isinstance", "graph_encoder.Normalization.normalizer().permute", "graph_encoder.Normalization.normalizer", "input.size", "input.view", "graph_encoder.Normalization.normalizer", "input.size", "input.permute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "\n", "        ", "if", "isinstance", "(", "self", ".", "normalizer", ",", "nn", ".", "BatchNorm1d", ")", ":", "\n", "            ", "return", "self", ".", "normalizer", "(", "input", ".", "view", "(", "-", "1", ",", "input", ".", "size", "(", "-", "1", ")", ")", ")", ".", "view", "(", "*", "input", ".", "size", "(", ")", ")", "\n", "", "elif", "isinstance", "(", "self", ".", "normalizer", ",", "nn", ".", "InstanceNorm1d", ")", ":", "\n", "            ", "return", "self", ".", "normalizer", "(", "input", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "normalizer", "is", "None", ",", "\"Unknown normalizer type\"", "\n", "return", "input", "\n", "", "", "", "class", "PositionalEncoding", "(", "nn", ".", "Module", ")", ":", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.PositionalEncoding.__init__": [[147, 158], ["torch.nn.Module.__init__", "torch.nn.Dropout", "torch.zeros", "torch.arange().unsqueeze", "torch.exp", "torch.sin", "torch.cos", "pe.unsqueeze().transpose.unsqueeze().transpose.unsqueeze().transpose", "graph_encoder.PositionalEncoding.register_buffer", "torch.arange", "torch.arange().float", "pe.unsqueeze().transpose.unsqueeze().transpose.unsqueeze", "torch.arange", "math.log"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "dropout", "=", "0.1", ",", "max_len", "=", "20", ")", ":", "\n", "        ", "super", "(", "PositionalEncoding", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "\n", "pe", "=", "torch", ".", "zeros", "(", "max_len", ",", "d_model", ")", "\n", "position", "=", "torch", ".", "arange", "(", "0", ",", "max_len", ",", "dtype", "=", "torch", ".", "float", ")", ".", "unsqueeze", "(", "1", ")", "\n", "div_term", "=", "torch", ".", "exp", "(", "torch", ".", "arange", "(", "0", ",", "d_model", ",", "2", ")", ".", "float", "(", ")", "*", "(", "-", "math", ".", "log", "(", "10000.0", ")", "/", "d_model", ")", ")", "\n", "pe", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "position", "*", "div_term", ")", "\n", "pe", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "position", "*", "div_term", ")", "\n", "pe", "=", "pe", ".", "unsqueeze", "(", "0", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "self", ".", "register_buffer", "(", "'pe'", ",", "pe", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.PositionalEncoding.forward": [[159, 162], ["graph_encoder.PositionalEncoding.dropout", "x.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", "+", "self", ".", "pe", "[", ":", "x", ".", "size", "(", "0", ")", ",", ":", "]", "\n", "return", "self", ".", "dropout", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.MultiHeadAttentionLayer.__init__": [[166, 190], ["torch.nn.Sequential.__init__", "graph_encoder.SkipConnection", "graph_encoder.Normalization", "graph_encoder.SkipConnection", "graph_encoder.Normalization", "graph_encoder.MultiHeadAttention", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_heads", ",", "\n", "embed_dim", ",", "\n", "feed_forward_hidden", "=", "512", ",", "\n", "normalization", "=", "'batch'", ",", "\n", ")", ":", "\n", "        ", "super", "(", "MultiHeadAttentionLayer", ",", "self", ")", ".", "__init__", "(", "\n", "SkipConnection", "(", "\n", "MultiHeadAttention", "(", "\n", "n_heads", ",", "\n", "input_dim", "=", "embed_dim", ",", "\n", "embed_dim", "=", "embed_dim", "\n", ")", "\n", ")", ",", "\n", "Normalization", "(", "embed_dim", ",", "normalization", ")", ",", "\n", "SkipConnection", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "embed_dim", ",", "feed_forward_hidden", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "feed_forward_hidden", ",", "embed_dim", ")", "\n", ")", "if", "feed_forward_hidden", ">", "0", "else", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", ")", ",", "\n", "Normalization", "(", "embed_dim", ",", "normalization", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.GraphAttentionEncoder.__init__": [[197, 214], ["torch.nn.Module.__init__", "graph_encoder.PositionalEncoding", "torch.nn.Sequential", "torch.nn.Linear", "graph_encoder.MultiHeadAttentionLayer", "range"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_heads", ",", "\n", "embed_dim", ",", "\n", "n_layers", ",", "\n", "node_dim", "=", "None", ",", "\n", "normalization", "=", "'batch'", ",", "\n", "feed_forward_hidden", "=", "512", "\n", ")", ":", "\n", "        ", "super", "(", "GraphAttentionEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# To map input to embedding space", "\n", "self", ".", "init_embed", "=", "nn", ".", "Linear", "(", "node_dim", ",", "embed_dim", ")", "if", "node_dim", "is", "not", "None", "else", "None", "\n", "self", ".", "pe", "=", "PositionalEncoding", "(", "embed_dim", ")", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "*", "(", "\n", "MultiHeadAttentionLayer", "(", "n_heads", ",", "embed_dim", ",", "feed_forward_hidden", ",", "normalization", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_encoder.GraphAttentionEncoder.forward": [[216, 227], ["graph_encoder.GraphAttentionEncoder.layers", "graph_encoder.GraphAttentionEncoder.init_embed().view", "graph_encoder.GraphAttentionEncoder.mean", "graph_encoder.GraphAttentionEncoder.init_embed", "x.view", "x.size", "x.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "\n", "        ", "assert", "mask", "is", "None", ",", "\"TODO mask not yet supported!\"", "\n", "\n", "# Batch multiply to get initial embeddings of nodes", "\n", "h", "=", "self", ".", "init_embed", "(", "x", ".", "view", "(", "-", "1", ",", "x", ".", "size", "(", "-", "1", ")", ")", ")", ".", "view", "(", "*", "x", ".", "size", "(", ")", "[", ":", "2", "]", ",", "-", "1", ")", "if", "self", ".", "init_embed", "is", "not", "None", "else", "x", "\n", "h", "=", "self", ".", "layers", "(", "h", ")", "\n", "\n", "return", "(", "\n", "h", ",", "# (batch_size, graph_size, embed_dim)", "\n", "h", ".", "mean", "(", "dim", "=", "1", ")", ",", "# average to get embedding of graph, (batch_size, embed_dim)", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.SkipConnection.__init__": [[8, 11], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "module", ")", ":", "\n", "        ", "super", "(", "SkipConnection", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.SkipConnection.forward": [[12, 14], ["graph_local.SkipConnection.module"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "input", "+", "self", ".", "module", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.MultiHeadAttention.__init__": [[17, 49], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "graph_local.MultiHeadAttention.init_parameters", "math.sqrt", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.nn.Parameter", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.Normalization.init_parameters"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_heads", ",", "\n", "input_dim", ",", "\n", "embed_dim", "=", "None", ",", "\n", "val_dim", "=", "None", ",", "\n", "key_dim", "=", "None", "\n", ")", ":", "\n", "        ", "super", "(", "MultiHeadAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "val_dim", "is", "None", ":", "\n", "            ", "assert", "embed_dim", "is", "not", "None", ",", "\"Provide either embed_dim or val_dim\"", "\n", "val_dim", "=", "embed_dim", "//", "n_heads", "\n", "", "if", "key_dim", "is", "None", ":", "\n", "            ", "key_dim", "=", "val_dim", "\n", "\n", "", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "self", ".", "val_dim", "=", "val_dim", "\n", "self", ".", "key_dim", "=", "key_dim", "\n", "\n", "self", ".", "norm_factor", "=", "1", "/", "math", ".", "sqrt", "(", "key_dim", ")", "# See Attention is all you need", "\n", "\n", "self", ".", "W_query", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "n_heads", ",", "input_dim", ",", "key_dim", ")", ")", "\n", "self", ".", "W_key", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "n_heads", ",", "input_dim", ",", "key_dim", ")", ")", "\n", "self", ".", "W_val", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "n_heads", ",", "input_dim", ",", "val_dim", ")", ")", "\n", "\n", "if", "embed_dim", "is", "not", "None", ":", "\n", "            ", "self", ".", "W_out", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "n_heads", ",", "key_dim", ",", "embed_dim", ")", ")", "\n", "\n", "", "self", ".", "init_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.MultiHeadAttention.init_parameters": [[50, 55], ["graph_local.MultiHeadAttention.parameters", "param.data.uniform_", "math.sqrt", "param.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "init_parameters", "(", "self", ")", ":", "\n", "\n", "        ", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "param", ".", "size", "(", "-", "1", ")", ")", "\n", "param", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.MultiHeadAttention.forward": [[56, 112], ["h.size", "q.size", "h.contiguous().view", "q.contiguous().view", "torch.matmul().view", "torch.matmul().view", "torch.matmul().view", "torch.softmax", "torch.matmul", "torch.mm().view", "q.size", "q.size", "torch.matmul", "mask.view().expand_as.view().expand_as.view().expand_as", "torch.softmax.clone", "h.contiguous", "q.contiguous", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul().view.transpose", "torch.mm", "mask.view().expand_as.view().expand_as.view", "torch.matmul.permute().contiguous().view", "graph_local.MultiHeadAttention.W_out.view", "torch.matmul.permute().contiguous", "torch.matmul.permute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "", "def", "forward", "(", "self", ",", "q", ",", "h", "=", "None", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\n        :param q: queries (batch_size, n_query, input_dim)\n        :param h: data (batch_size, graph_size, input_dim)\n        :param mask: mask (batch_size, n_query, graph_size) or viewable as that (i.e. can be 2 dim if n_query == 1)\n        Mask should contain 1 if attention is not possible (i.e. mask is negative adjacency)\n        :return:\n        \"\"\"", "\n", "if", "h", "is", "None", ":", "\n", "            ", "h", "=", "q", "# compute self-attention", "\n", "\n", "# h should be (batch_size, graph_size, input_dim)", "\n", "", "batch_size", ",", "graph_size", ",", "input_dim", "=", "h", ".", "size", "(", ")", "\n", "n_query", "=", "q", ".", "size", "(", "1", ")", "\n", "assert", "q", ".", "size", "(", "0", ")", "==", "batch_size", "\n", "assert", "q", ".", "size", "(", "2", ")", "==", "input_dim", "\n", "assert", "input_dim", "==", "self", ".", "input_dim", ",", "\"Wrong embedding dimension of input\"", "\n", "\n", "hflat", "=", "h", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "input_dim", ")", "\n", "qflat", "=", "q", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "input_dim", ")", "\n", "\n", "# last dimension can be different for keys and values", "\n", "shp", "=", "(", "self", ".", "n_heads", ",", "batch_size", ",", "graph_size", ",", "-", "1", ")", "\n", "shp_q", "=", "(", "self", ".", "n_heads", ",", "batch_size", ",", "n_query", ",", "-", "1", ")", "\n", "\n", "# Calculate queries, (n_heads, n_query, graph_size, key/val_size)", "\n", "Q", "=", "torch", ".", "matmul", "(", "qflat", ",", "self", ".", "W_query", ")", ".", "view", "(", "shp_q", ")", "\n", "# Calculate keys and values (n_heads, batch_size, graph_size, key/val_size)", "\n", "K", "=", "torch", ".", "matmul", "(", "hflat", ",", "self", ".", "W_key", ")", ".", "view", "(", "shp", ")", "\n", "V", "=", "torch", ".", "matmul", "(", "hflat", ",", "self", ".", "W_val", ")", ".", "view", "(", "shp", ")", "\n", "\n", "# Calculate compatibility (n_heads, batch_size, n_query, graph_size)", "\n", "compatibility", "=", "self", ".", "norm_factor", "*", "torch", ".", "matmul", "(", "Q", ",", "K", ".", "transpose", "(", "2", ",", "3", ")", ")", "\n", "\n", "# Optionally apply mask to prevent attention", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "mask", ".", "view", "(", "1", ",", "batch_size", ",", "n_query", ",", "graph_size", ")", ".", "expand_as", "(", "compatibility", ")", "\n", "compatibility", "[", "mask", "]", "=", "-", "np", ".", "inf", "\n", "\n", "", "attn", "=", "torch", ".", "softmax", "(", "compatibility", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# If there are nodes with no neighbours then softmax returns nan so we fix them to 0", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "attnc", "=", "attn", ".", "clone", "(", ")", "\n", "attnc", "[", "mask", "]", "=", "0", "\n", "attn", "=", "attnc", "\n", "\n", "", "heads", "=", "torch", ".", "matmul", "(", "attn", ",", "V", ")", "\n", "\n", "out", "=", "torch", ".", "mm", "(", "\n", "heads", ".", "permute", "(", "1", ",", "2", ",", "0", ",", "3", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", "*", "self", ".", "val_dim", ")", ",", "\n", "self", ".", "W_out", ".", "view", "(", "-", "1", ",", "self", ".", "embed_dim", ")", "\n", ")", ".", "view", "(", "batch_size", ",", "n_query", ",", "self", ".", "embed_dim", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.Normalization.__init__": [[116, 125], ["torch.nn.Module.__init__", "normalizer_class"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embed_dim", ",", "normalization", "=", "'batch'", ")", ":", "\n", "        ", "super", "(", "Normalization", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "normalizer_class", "=", "{", "\n", "'batch'", ":", "nn", ".", "BatchNorm1d", ",", "\n", "'instance'", ":", "nn", ".", "InstanceNorm1d", "\n", "}", ".", "get", "(", "normalization", ",", "None", ")", "\n", "\n", "self", ".", "normalizer", "=", "normalizer_class", "(", "embed_dim", ",", "affine", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.Normalization.init_parameters": [[129, 134], ["graph_local.Normalization.named_parameters", "param.data.uniform_", "math.sqrt", "param.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "init_parameters", "(", "self", ")", ":", "\n", "\n", "        ", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "param", ".", "size", "(", "-", "1", ")", ")", "\n", "param", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.Normalization.forward": [[135, 144], ["isinstance", "graph_local.Normalization.normalizer().view", "isinstance", "graph_local.Normalization.normalizer().permute", "graph_local.Normalization.normalizer", "input.size", "input.view", "graph_local.Normalization.normalizer", "input.size", "input.permute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "\n", "        ", "if", "isinstance", "(", "self", ".", "normalizer", ",", "nn", ".", "BatchNorm1d", ")", ":", "\n", "            ", "return", "self", ".", "normalizer", "(", "input", ".", "view", "(", "-", "1", ",", "input", ".", "size", "(", "-", "1", ")", ")", ")", ".", "view", "(", "*", "input", ".", "size", "(", ")", ")", "\n", "", "elif", "isinstance", "(", "self", ".", "normalizer", ",", "nn", ".", "InstanceNorm1d", ")", ":", "\n", "            ", "return", "self", ".", "normalizer", "(", "input", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "normalizer", "is", "None", ",", "\"Unknown normalizer type\"", "\n", "return", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.MultiHeadAttentionLayer.__init__": [[148, 172], ["torch.nn.Sequential.__init__", "graph_local.SkipConnection", "graph_local.Normalization", "graph_local.SkipConnection", "graph_local.Normalization", "graph_local.MultiHeadAttention", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_heads", ",", "\n", "embed_dim", ",", "\n", "feed_forward_hidden", "=", "512", ",", "\n", "normalization", "=", "'batch'", ",", "\n", ")", ":", "\n", "        ", "super", "(", "MultiHeadAttentionLayer", ",", "self", ")", ".", "__init__", "(", "\n", "SkipConnection", "(", "\n", "MultiHeadAttention", "(", "\n", "n_heads", ",", "\n", "input_dim", "=", "embed_dim", ",", "\n", "embed_dim", "=", "embed_dim", "\n", ")", "\n", ")", ",", "\n", "Normalization", "(", "embed_dim", ",", "normalization", ")", ",", "\n", "SkipConnection", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "embed_dim", ",", "feed_forward_hidden", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "feed_forward_hidden", ",", "embed_dim", ")", "\n", ")", "if", "feed_forward_hidden", ">", "0", "else", "nn", ".", "Linear", "(", "embed_dim", ",", "embed_dim", ")", "\n", ")", ",", "\n", "Normalization", "(", "embed_dim", ",", "normalization", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.GraphAttentionEncoder.__init__": [[176, 192], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Linear", "graph_local.MultiHeadAttentionLayer", "range"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_heads", ",", "\n", "embed_dim", ",", "\n", "n_layers", ",", "\n", "node_dim", "=", "None", ",", "\n", "normalization", "=", "'batch'", ",", "\n", "feed_forward_hidden", "=", "512", "\n", ")", ":", "\n", "        ", "super", "(", "GraphAttentionEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# To map input to embedding space", "\n", "self", ".", "init_embed", "=", "nn", ".", "Linear", "(", "node_dim", ",", "embed_dim", ")", "if", "node_dim", "is", "not", "None", "else", "None", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "*", "(", "\n", "MultiHeadAttentionLayer", "(", "n_heads", ",", "embed_dim", ",", "feed_forward_hidden", ",", "normalization", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.graph_local.GraphAttentionEncoder.forward": [[194, 205], ["graph_local.GraphAttentionEncoder.layers", "graph_local.GraphAttentionEncoder.init_embed().view", "graph_local.GraphAttentionEncoder.mean", "graph_local.GraphAttentionEncoder.init_embed", "x.view", "x.size", "x.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "\n", "        ", "assert", "mask", "is", "None", ",", "\"TODO mask not yet supported!\"", "\n", "\n", "# Batch multiply to get initial embeddings of nodes", "\n", "h", "=", "self", ".", "init_embed", "(", "x", ".", "view", "(", "-", "1", ",", "x", ".", "size", "(", "-", "1", ")", ")", ")", ".", "view", "(", "*", "x", ".", "size", "(", ")", "[", ":", "2", "]", ",", "-", "1", ")", "if", "self", ".", "init_embed", "is", "not", "None", "else", "x", "\n", "h", "=", "self", ".", "layers", "(", "h", ")", "\n", "\n", "return", "(", "\n", "h", ",", "# (batch_size, graph_size, embed_dim)", "\n", "h", ".", "mean", "(", "dim", "=", "1", ")", ",", "# average to get embedding of graph, (batch_size, embed_dim)", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModelFixed.__getitem__": [[33, 41], ["attention_local.AttentionModelFixed", "torch.is_tensor", "isinstance"], "methods", ["None"], ["def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "\n", "return", "AttentionModelFixed", "(", "\n", "node_embeddings", "=", "self", ".", "node_embeddings", "[", "key", "]", ",", "\n", "context_node_projected", "=", "self", ".", "context_node_projected", "[", "key", "]", ",", "\n", "glimpse_key", "=", "self", ".", "glimpse_key", "[", ":", ",", "key", "]", ",", "# dim 0 are the heads", "\n", "glimpse_val", "=", "self", ".", "glimpse_val", "[", ":", ",", "key", "]", ",", "# dim 0 are the heads", "\n", "logit_key", "=", "self", ".", "logit_key", "[", "key", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel.__init__": [[47, 128], ["torch.nn.Module.__init__", "torch.nn.Linear", "nets.graph_encoder.GraphAttentionEncoder", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Parameter", "attention_local.AttentionModel.W_placeholder.data.uniform_", "torch.nn.Linear", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "problem", ",", "\n", "n_encode_layers", "=", "2", ",", "\n", "tanh_clipping", "=", "10.", ",", "\n", "mask_inner", "=", "True", ",", "\n", "mask_logits", "=", "True", ",", "\n", "normalization", "=", "'batch'", ",", "\n", "n_heads", "=", "8", ",", "\n", "checkpoint_encoder", "=", "False", ",", "\n", "shrink_size", "=", "None", ")", ":", "\n", "        ", "super", "(", "AttentionModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "n_encode_layers", "=", "n_encode_layers", "\n", "self", ".", "decode_type", "=", "None", "\n", "self", ".", "temp", "=", "1.0", "\n", "self", ".", "allow_partial", "=", "problem", ".", "NAME", "==", "'sdvrp'", "\n", "self", ".", "is_vrp", "=", "problem", ".", "NAME", "==", "'cvrp'", "or", "problem", ".", "NAME", "==", "'sdvrp'", "\n", "self", ".", "is_orienteering", "=", "problem", ".", "NAME", "==", "'op'", "\n", "self", ".", "is_pctsp", "=", "problem", ".", "NAME", "==", "'pctsp'", "\n", "\n", "self", ".", "tanh_clipping", "=", "tanh_clipping", "\n", "\n", "self", ".", "mask_inner", "=", "mask_inner", "\n", "self", ".", "mask_logits", "=", "mask_logits", "\n", "#         self.attn = LSHAttention(bucket_size=0,n_hashes=4,causal = True)", "\n", "self", ".", "problem", "=", "problem", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "checkpoint_encoder", "=", "checkpoint_encoder", "\n", "self", ".", "shrink_size", "=", "shrink_size", "\n", "\n", "# Problem specific context parameters (placeholder and step context dimension)", "\n", "if", "self", ".", "is_vrp", "or", "self", ".", "is_orienteering", "or", "self", ".", "is_pctsp", ":", "\n", "# Embedding of last node + remaining_capacity / remaining length / remaining prize to collect", "\n", "            ", "step_context_dim", "=", "embedding_dim", "+", "1", "\n", "\n", "if", "self", ".", "is_pctsp", ":", "\n", "                ", "node_dim", "=", "4", "# x, y, expected_prize, penalty", "\n", "", "else", ":", "\n", "                ", "node_dim", "=", "3", "# x, y, demand / prize", "\n", "\n", "# Special embedding projection for depot node", "\n", "", "self", ".", "init_embed_depot", "=", "nn", ".", "Linear", "(", "2", ",", "embedding_dim", ")", "\n", "\n", "if", "self", ".", "is_vrp", "and", "self", ".", "allow_partial", ":", "# Need to include the demand if split delivery allowed", "\n", "                ", "self", ".", "project_node_step", "=", "nn", ".", "Linear", "(", "1", ",", "3", "*", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "", "", "else", ":", "# TSP", "\n", "#             assert problem.NAME == \"tsp\", \"Unsupported problem: {}\".format(problem.NAME)", "\n", "            ", "step_context_dim", "=", "2", "*", "embedding_dim", "# Embedding of first and last node", "\n", "node_dim", "=", "2", "# x, y", "\n", "\n", "# Learned input symbols for first action", "\n", "self", ".", "W_placeholder", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "2", "*", "embedding_dim", ")", ")", "\n", "self", ".", "W_placeholder", ".", "data", ".", "uniform_", "(", "-", "1", ",", "1", ")", "# Placeholder should be in range of activations", "\n", "\n", "", "self", ".", "init_embed", "=", "nn", ".", "Linear", "(", "node_dim", ",", "embedding_dim", ")", "\n", "\n", "self", ".", "embedder", "=", "GraphAttentionEncoder", "(", "\n", "n_heads", "=", "n_heads", ",", "\n", "embed_dim", "=", "embedding_dim", ",", "\n", "n_layers", "=", "self", ".", "n_encode_layers", ",", "\n", "normalization", "=", "normalization", "\n", ")", "\n", "\n", "#         self.embedder = Reformer_Encoder(", "\n", "#             n_heads=n_heads,", "\n", "#             embed_dim=embedding_dim,", "\n", "#             n_layers=self.n_encode_layers,", "\n", "#             normalization=normalization", "\n", "#         )", "\n", "\n", "# For each node we compute (glimpse key, glimpse value, logit key) so 3 * embedding_dim", "\n", "self", ".", "project_node_embeddings", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "3", "*", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "project_fixed_context", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "project_step_context", "=", "nn", ".", "Linear", "(", "step_context_dim", ",", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "assert", "embedding_dim", "%", "n_heads", "==", "0", "\n", "# Note n_heads * val_dim == embedding_dim so input to project_out is embedding_dim", "\n", "self", ".", "project_out", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel.set_decode_type": [[129, 133], ["None"], "methods", ["None"], ["", "def", "set_decode_type", "(", "self", ",", "decode_type", ",", "temp", "=", "None", ")", ":", "\n", "        ", "self", ".", "decode_type", "=", "decode_type", "\n", "if", "temp", "is", "not", "None", ":", "# Do not change temperature if not provided", "\n", "            ", "self", ".", "temp", "=", "temp", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel.forward": [[134, 158], ["attention_local.AttentionModel._inner", "entropies.mean.mean.mean", "attention_local.AttentionModel.problem.get_costs", "attention_local.AttentionModel._calc_log_likelihood", "torch.utils.checkpoint.checkpoint", "attention_local.AttentionModel.embedder", "attention_local.AttentionModel._init_embed", "attention_local.AttentionModel._init_embed"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._inner", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._calc_log_likelihood", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "return_pi", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        :param input: (batch_size, graph_size, node_dim) input node features or dictionary with multiple tensors\n        :param return_pi: whether to return the output sequences, this is optional as it is not compatible with\n        using DataParallel as the results may be of different lengths on different GPUs\n        :return:\n        \"\"\"", "\n", "\n", "if", "self", ".", "checkpoint_encoder", "and", "self", ".", "training", ":", "# Only checkpoint if we need gradients", "\n", "            ", "embeddings", ",", "_", "=", "checkpoint", "(", "self", ".", "embedder", ",", "self", ".", "_init_embed", "(", "input", ")", ")", "\n", "", "else", ":", "\n", "            ", "embeddings", ",", "_", "=", "self", ".", "embedder", "(", "self", ".", "_init_embed", "(", "input", ")", ")", "\n", "\n", "\n", "\n", "", "_log_p", ",", "pi", ",", "entropies", "=", "self", ".", "_inner", "(", "input", ",", "embeddings", ")", "\n", "entropies", "=", "entropies", ".", "mean", "(", "1", ")", "\n", "\n", "\n", "cost", ",", "mask", "=", "self", ".", "problem", ".", "get_costs", "(", "input", ",", "pi", ")", "\n", "if", "return_pi", ":", "\n", "            ", "return", "cost", ",", "pi", "\n", "", "ll", "=", "self", ".", "_calc_log_likelihood", "(", "_log_p", ",", "pi", ",", "mask", ")", "\n", "return", "cost", ",", "ll", ",", "entropies", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel.beam_search": [[159, 161], ["attention_local.AttentionModel.problem.beam_search"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search"], ["", "def", "beam_search", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "problem", ".", "beam_search", "(", "*", "args", ",", "**", "kwargs", ",", "model", "=", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel.precompute_fixed": [[162, 167], ["attention_local.AttentionModel.embedder", "utils.beam_search.CachedLookup", "attention_local.AttentionModel._init_embed", "attention_local.AttentionModel._precompute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._precompute"], ["", "def", "precompute_fixed", "(", "self", ",", "input", ")", ":", "\n", "        ", "embeddings", ",", "_", "=", "self", ".", "embedder", "(", "self", ".", "_init_embed", "(", "input", ")", ")", "\n", "# Use a CachedLookup such that if we repeatedly index this object with the same index we only need to do", "\n", "# the lookup once... this is the case if all elements in the batch have maximum batch size", "\n", "return", "CachedLookup", "(", "self", ".", "_precompute", "(", "embeddings", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel.propose_expansions": [[168, 197], ["utils.tensor_functions.compute_in_batches", "ind_topk.view", "score_expand.view", "torch.nonzero", "log_p_topk.size", "torch.arange", "ind_topk.size", "len", "attention_local.AttentionModel._get_log_p_topk", "beam.size", "ind_topk.view.size", "ind_topk.view.new"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.tensor_functions.compute_in_batches", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_log_p_topk", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "propose_expansions", "(", "self", ",", "beam", ",", "fixed", ",", "expand_size", "=", "None", ",", "normalize", "=", "False", ",", "max_calc_batch_size", "=", "4096", ")", ":", "\n", "# First dim = batch_size * cur_beam_size", "\n", "        ", "log_p_topk", ",", "ind_topk", "=", "compute_in_batches", "(", "\n", "lambda", "b", ":", "self", ".", "_get_log_p_topk", "(", "fixed", "[", "b", ".", "ids", "]", ",", "b", ".", "state", ",", "k", "=", "expand_size", ",", "normalize", "=", "normalize", ")", ",", "\n", "max_calc_batch_size", ",", "beam", ",", "n", "=", "beam", ".", "size", "(", ")", "\n", ")", "\n", "\n", "assert", "log_p_topk", ".", "size", "(", "1", ")", "==", "1", ",", "\"Can only have single step\"", "\n", "# This will broadcast, calculate log_p (score) of expansions", "\n", "score_expand", "=", "beam", ".", "score", "[", ":", ",", "None", "]", "+", "log_p_topk", "[", ":", ",", "0", ",", ":", "]", "\n", "\n", "# We flatten the action as we need to filter and this cannot be done in 2d", "\n", "flat_action", "=", "ind_topk", ".", "view", "(", "-", "1", ")", "\n", "flat_score", "=", "score_expand", ".", "view", "(", "-", "1", ")", "\n", "flat_feas", "=", "flat_score", ">", "-", "1e10", "# != -math.inf triggers", "\n", "\n", "# Parent is row idx of ind_topk, can be found by enumerating elements and dividing by number of columns", "\n", "flat_parent", "=", "torch", ".", "arange", "(", "flat_action", ".", "size", "(", "-", "1", ")", ",", "out", "=", "flat_action", ".", "new", "(", ")", ")", "/", "ind_topk", ".", "size", "(", "-", "1", ")", "\n", "\n", "# Filter infeasible", "\n", "feas_ind_2d", "=", "torch", ".", "nonzero", "(", "flat_feas", ")", "\n", "\n", "if", "len", "(", "feas_ind_2d", ")", "==", "0", ":", "\n", "# Too bad, no feasible expansions at all :(", "\n", "            ", "return", "None", ",", "None", ",", "None", "\n", "\n", "", "feas_ind", "=", "feas_ind_2d", "[", ":", ",", "0", "]", "\n", "\n", "return", "flat_parent", "[", "feas_ind", "]", ",", "flat_action", "[", "feas_ind", "]", ",", "flat_score", "[", "feas_ind", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._calc_log_likelihood": [[198, 211], ["_log_p.gather().squeeze", "_log_p.gather().squeeze.sum", "_log_p.gather", "a.unsqueeze"], "methods", ["None"], ["", "def", "_calc_log_likelihood", "(", "self", ",", "_log_p", ",", "a", ",", "mask", ")", ":", "\n", "\n", "# Get log_p corresponding to selected actions", "\n", "        ", "log_p", "=", "_log_p", ".", "gather", "(", "2", ",", "a", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "# Optional: mask out actions irrelevant to objective so they do not get reinforced", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "log_p", "[", "mask", "]", "=", "0", "\n", "\n", "", "assert", "(", "log_p", ">", "-", "1000", ")", ".", "data", ".", "all", "(", ")", ",", "\"Logprobs should not be -inf, check sampling procedure!\"", "\n", "\n", "# Calculate log_likelihood", "\n", "return", "log_p", ".", "sum", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._init_embed": [[212, 234], ["attention_local.AttentionModel.init_embed", "torch.cat", "attention_local.AttentionModel.init_embed", "attention_local.AttentionModel.init_embed_depot", "torch.cat"], "methods", ["None"], ["", "def", "_init_embed", "(", "self", ",", "input", ")", ":", "\n", "\n", "        ", "if", "self", ".", "is_vrp", "or", "self", ".", "is_orienteering", "or", "self", ".", "is_pctsp", ":", "\n", "            ", "if", "self", ".", "is_vrp", ":", "\n", "                ", "features", "=", "(", "'demand'", ",", ")", "\n", "", "elif", "self", ".", "is_orienteering", ":", "\n", "                ", "features", "=", "(", "'prize'", ",", ")", "\n", "", "else", ":", "\n", "                ", "assert", "self", ".", "is_pctsp", "\n", "features", "=", "(", "'deterministic_prize'", ",", "'penalty'", ")", "\n", "", "return", "torch", ".", "cat", "(", "\n", "(", "\n", "self", ".", "init_embed_depot", "(", "input", "[", "'depot'", "]", ")", "[", ":", ",", "None", ",", ":", "]", ",", "\n", "self", ".", "init_embed", "(", "torch", ".", "cat", "(", "(", "\n", "input", "[", "'loc'", "]", ",", "\n", "*", "(", "input", "[", "feat", "]", "[", ":", ",", ":", ",", "None", "]", "for", "feat", "in", "features", ")", "\n", ")", ",", "-", "1", ")", ")", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "# TSP", "\n", "", "return", "self", ".", "init_embed", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._inner": [[235, 287], ["attention_local.AttentionModel.problem.make_state", "attention_local.AttentionModel._precompute", "state.update.update.ids.size", "attention_local.AttentionModel._get_log_p", "attention_local.AttentionModel._select_node", "state.update.update.update", "outputs.append", "sequences.append", "entropies.append", "torch.stack", "torch.stack", "torch.stack", "state.update.update.all_finished", "torch.nonzero", "log_p_.new_zeros", "selected_.new_zeros", "len", "len", "log_p_.new_zeros.exp", "state.update.update.ids.size", "state.update.update.get_finished", "state.update.update.ids.size", "log_p_.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._precompute", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_log_p", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._select_node", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.update", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.get_finished", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_inner", "(", "self", ",", "input", ",", "embeddings", ")", ":", "\n", "\n", "        ", "outputs", "=", "[", "]", "\n", "sequences", "=", "[", "]", "\n", "entropies", "=", "[", "]", "\n", "state", "=", "self", ".", "problem", ".", "make_state", "(", "input", ")", "\n", "\n", "# Compute keys, values for the glimpse and keys for the logits once as they can be reused in every step", "\n", "fixed", "=", "self", ".", "_precompute", "(", "embeddings", ")", "\n", "\n", "batch_size", "=", "state", ".", "ids", ".", "size", "(", "0", ")", "\n", "\n", "# Perform decoding steps", "\n", "i", "=", "0", "\n", "while", "not", "(", "self", ".", "shrink_size", "is", "None", "and", "state", ".", "all_finished", "(", ")", ")", ":", "\n", "\n", "            ", "if", "self", ".", "shrink_size", "is", "not", "None", ":", "\n", "                ", "unfinished", "=", "torch", ".", "nonzero", "(", "state", ".", "get_finished", "(", ")", "==", "0", ")", "\n", "if", "len", "(", "unfinished", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "", "unfinished", "=", "unfinished", "[", ":", ",", "0", "]", "\n", "# Check if we can shrink by at least shrink_size and if this leaves at least 16", "\n", "# (otherwise batch norm will not work well and it is inefficient anyway)", "\n", "if", "16", "<=", "len", "(", "unfinished", ")", "<=", "state", ".", "ids", ".", "size", "(", "0", ")", "-", "self", ".", "shrink_size", ":", "\n", "# Filter states", "\n", "                    ", "state", "=", "state", "[", "unfinished", "]", "\n", "fixed", "=", "fixed", "[", "unfinished", "]", "\n", "\n", "", "", "log_p", ",", "mask", ",", "A", "=", "self", ".", "_get_log_p", "(", "fixed", ",", "state", ",", "i", "=", "i", ")", "\n", "\n", "# Select the indices of the next nodes in the sequences, result (batch_size) long", "\n", "selected", "=", "self", ".", "_select_node", "(", "log_p", ".", "exp", "(", ")", "[", ":", ",", "0", ",", ":", "]", ",", "mask", "[", ":", ",", "0", ",", ":", "]", ")", "# Squeeze out steps dimension", "\n", "\n", "state", "=", "state", ".", "update", "(", "selected", ")", "\n", "\n", "# Now make log_p, selected desired output size by 'unshrinking'", "\n", "if", "self", ".", "shrink_size", "is", "not", "None", "and", "state", ".", "ids", ".", "size", "(", "0", ")", "<", "batch_size", ":", "\n", "                ", "log_p_", ",", "selected_", "=", "log_p", ",", "selected", "\n", "log_p", "=", "log_p_", ".", "new_zeros", "(", "batch_size", ",", "*", "log_p_", ".", "size", "(", ")", "[", "1", ":", "]", ")", "\n", "selected", "=", "selected_", ".", "new_zeros", "(", "batch_size", ")", "\n", "\n", "log_p", "[", "state", ".", "ids", "[", ":", ",", "0", "]", "]", "=", "log_p_", "\n", "selected", "[", "state", ".", "ids", "[", ":", ",", "0", "]", "]", "=", "selected_", "\n", "\n", "# Collect output of step", "\n", "", "outputs", ".", "append", "(", "log_p", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "sequences", ".", "append", "(", "selected", ")", "\n", "entropies", ".", "append", "(", "A", ")", "\n", "i", "+=", "1", "\n", "\n", "# Collected lists, return Tensor", "\n", "", "return", "torch", ".", "stack", "(", "outputs", ",", "1", ")", ",", "torch", ".", "stack", "(", "sequences", ",", "1", ")", ",", "torch", ".", "stack", "(", "entropies", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel.sample_many": [[288, 300], ["utils.functions.sample_many", "attention_local.AttentionModel._inner", "attention_local.AttentionModel.problem.get_costs", "attention_local.AttentionModel.embedder", "attention_local.AttentionModel._init_embed"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.sample_many", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._inner", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed"], ["", "def", "sample_many", "(", "self", ",", "input", ",", "batch_rep", "=", "1", ",", "iter_rep", "=", "1", ",", "model_local", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param input: (batch_size, graph_size, node_dim) input node features\n        :return:\n        \"\"\"", "\n", "# Bit ugly but we need to pass the embeddings as well.", "\n", "# Making a tuple will not work with the problem.get_cost function", "\n", "return", "sample_many", "(", "\n", "lambda", "input", ":", "self", ".", "_inner", "(", "*", "input", ")", ",", "# Need to unpack tuple into arguments", "\n", "lambda", "input", ",", "pi", ":", "self", ".", "problem", ".", "get_costs", "(", "input", "[", "0", "]", ",", "pi", ",", "return_two", "=", "True", ")", ",", "# Don't need embeddings as input to get_costs", "\n", "(", "input", ",", "self", ".", "embedder", "(", "self", ".", "_init_embed", "(", "input", ")", ")", "[", "0", "]", ")", ",", "# Pack input with embeddings (additional input)", "\n", "batch_rep", ",", "iter_rep", ",", "model_local", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._select_node": [[302, 323], ["probs.max", "mask.gather().data.any", "probs.multinomial().squeeze", "mask.gather().data.any", "print", "probs.multinomial().squeeze", "probs.multinomial", "mask.gather", "mask.gather", "probs.multinomial", "probs.multinomial().squeeze.unsqueeze", "probs.multinomial().squeeze.unsqueeze"], "methods", ["None"], ["", "def", "_select_node", "(", "self", ",", "probs", ",", "mask", ")", ":", "\n", "\n", "        ", "assert", "(", "probs", "==", "probs", ")", ".", "all", "(", ")", ",", "\"Probs should not contain any nans\"", "\n", "\n", "if", "self", ".", "decode_type", "==", "\"greedy\"", ":", "\n", "            ", "_", ",", "selected", "=", "probs", ".", "max", "(", "1", ")", "\n", "assert", "not", "mask", ".", "gather", "(", "1", ",", "selected", ".", "unsqueeze", "(", "\n", "-", "1", ")", ")", ".", "data", ".", "any", "(", ")", ",", "\"Decode greedy: infeasible action has maximum probability\"", "\n", "\n", "", "elif", "self", ".", "decode_type", "==", "\"sampling\"", ":", "\n", "            ", "selected", "=", "probs", ".", "multinomial", "(", "1", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "# Check if sampling went OK, can go wrong due to bug on GPU", "\n", "# See https://discuss.pytorch.org/t/bad-behavior-of-multinomial-function/10232", "\n", "while", "mask", ".", "gather", "(", "1", ",", "selected", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "data", ".", "any", "(", ")", ":", "\n", "                ", "print", "(", "'Sampled bad values, resampling!'", ")", "\n", "selected", "=", "probs", ".", "multinomial", "(", "1", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "assert", "False", ",", "\"Unknown decode type\"", "\n", "", "return", "selected", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._precompute": [[324, 342], ["embeddings.mean", "attention_local.AttentionModel.project_node_embeddings().chunk", "attention_local.AttentionModelFixed", "attention_local.AttentionModel.project_fixed_context", "attention_local.AttentionModel._make_heads", "attention_local.AttentionModel._make_heads", "logit_key_fixed.contiguous", "attention_local.AttentionModel.project_node_embeddings"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads"], ["", "def", "_precompute", "(", "self", ",", "embeddings", ",", "num_steps", "=", "1", ")", ":", "\n", "\n", "# The fixed context projection of the graph embedding is calculated only once for efficiency", "\n", "        ", "graph_embed", "=", "embeddings", ".", "mean", "(", "1", ")", "\n", "# fixed context = (batch_size, 1, embed_dim) to make broadcastable with parallel timesteps", "\n", "fixed_context", "=", "self", ".", "project_fixed_context", "(", "graph_embed", ")", "[", ":", ",", "None", ",", ":", "]", "\n", "\n", "# The projection of the node embeddings for the attention is calculated once up front", "\n", "glimpse_key_fixed", ",", "glimpse_val_fixed", ",", "logit_key_fixed", "=", "self", ".", "project_node_embeddings", "(", "embeddings", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", ".", "chunk", "(", "3", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# No need to rearrange key for logit as there is a single head", "\n", "fixed_attention_node_data", "=", "(", "\n", "self", ".", "_make_heads", "(", "glimpse_key_fixed", ",", "num_steps", ")", ",", "\n", "self", ".", "_make_heads", "(", "glimpse_val_fixed", ",", "num_steps", ")", ",", "\n", "logit_key_fixed", ".", "contiguous", "(", ")", "\n", ")", "\n", "return", "AttentionModelFixed", "(", "embeddings", ",", "fixed_context", ",", "*", "fixed_attention_node_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._get_log_p_topk": [[343, 354], ["attention_local.AttentionModel._get_log_p", "log_p.topk", "log_p.size", "torch.arange().repeat", "log_p.size", "torch.arange", "log_p.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_log_p", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.topk", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_get_log_p_topk", "(", "self", ",", "fixed", ",", "state", ",", "k", "=", "None", ",", "normalize", "=", "True", ")", ":", "\n", "        ", "log_p", ",", "_", "=", "self", ".", "_get_log_p", "(", "fixed", ",", "state", ",", "normalize", "=", "normalize", ")", "\n", "\n", "# Return topk", "\n", "if", "k", "is", "not", "None", "and", "k", "<", "log_p", ".", "size", "(", "-", "1", ")", ":", "\n", "            ", "return", "log_p", ".", "topk", "(", "k", ",", "-", "1", ")", "\n", "\n", "# Return all, note different from torch.topk this does not give error if less than k elements along dim", "\n", "", "return", "(", "\n", "log_p", ",", "\n", "torch", ".", "arange", "(", "log_p", ".", "size", "(", "-", "1", ")", ",", "device", "=", "log_p", ".", "device", ",", "dtype", "=", "torch", ".", "int64", ")", ".", "repeat", "(", "log_p", ".", "size", "(", "0", ")", ",", "1", ")", "[", ":", ",", "None", ",", ":", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._get_log_p": [[356, 386], ["attention_local.AttentionModel._get_attention_node_data", "state.get_mask", "attention_local.AttentionModel._one_to_many_logits", "torch.sum", "attention_local.AttentionModel.project_step_context", "torch.log_softmax", "torch.exp", "torch.isnan().any", "torch.sum.view", "attention_local.AttentionModel._get_parallel_step_context", "torch.isnan", "torch.isnan"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_attention_node_data", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_mask", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._one_to_many_logits", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_parallel_step_context"], ["", "def", "_get_log_p", "(", "self", ",", "fixed", ",", "state", ",", "normalize", "=", "True", ",", "i", "=", "0", ",", "is_local", "=", "False", ")", ":", "\n", "\n", "# Compute query = context node embedding", "\n", "        ", "query", "=", "fixed", ".", "context_node_projected", "+", "self", ".", "project_step_context", "(", "self", ".", "_get_parallel_step_context", "(", "fixed", ".", "node_embeddings", ",", "state", ")", ")", "\n", "\n", "# Compute keys and values for the nodes", "\n", "glimpse_K", ",", "glimpse_V", ",", "logit_K", "=", "self", ".", "_get_attention_node_data", "(", "fixed", ",", "state", ")", "\n", "\n", "# Compute the mask", "\n", "mask", "=", "state", ".", "get_mask", "(", ")", "\n", "\n", "if", "(", "i", "==", "0", ")", ":", "\n", "            ", "mask", "[", ":", ",", ":", ",", ":", "]", "=", "True", "\n", "mask", "[", ":", ",", ":", ",", "0", "]", "=", "False", "\n", "", "mask", "[", ":", ",", ":", ",", "mask", ".", "shape", "[", "2", "]", "-", "1", "]", "=", "True", "\n", "if", "(", "i", "==", "mask", ".", "shape", "[", "2", "]", "-", "1", ")", ":", "\n", "            ", "mask", "[", ":", ",", ":", ",", "mask", ".", "shape", "[", "2", "]", "-", "1", "]", "=", "False", "\n", "# Compute logits (unnormalized log_p)", "\n", "", "log_p", ",", "glimpse", "=", "self", ".", "_one_to_many_logits", "(", "query", ",", "glimpse_K", ",", "glimpse_V", ",", "logit_K", ",", "mask", ")", "\n", "\n", "if", "normalize", ":", "\n", "            ", "log_p", "=", "torch", ".", "log_softmax", "(", "log_p", "/", "self", ".", "temp", ",", "dim", "=", "-", "1", ")", "\n", "", "A", "=", "-", "log_p", "*", "torch", ".", "exp", "(", "log_p", ")", "\n", "\n", "A", "[", "torch", ".", "isnan", "(", "A", ")", "]", "=", "0", "\n", "A", "=", "torch", ".", "sum", "(", "A", ",", "dim", "=", "-", "1", ")", "\n", "assert", "not", "torch", ".", "isnan", "(", "log_p", ")", ".", "any", "(", ")", "\n", "\n", "return", "log_p", ",", "mask", ",", "A", ".", "view", "(", "-", "1", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._get_parallel_step_context": [[387, 444], ["state.get_current_node", "state.get_current_node.size", "embeddings.gather", "torch.cat", "torch.cat", "current_node[].expand", "state.i.item", "attention_local.AttentionModel.W_placeholder[].expand", "embeddings.gather().view", "embeddings.size", "attention_local.AttentionModel.W_placeholder[].expand", "torch.cat", "embeddings[].expand", "attention_local.AttentionModel.W_placeholder.size", "attention_local.AttentionModel.W_placeholder.size", "embeddings.size", "embeddings.gather", "embeddings_per_step[].expand", "torch.zeros_like", "[].expand", "embeddings.size", "embeddings.size", "state.get_remaining_length", "state.get_remaining_prize_to_collect", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_current_node", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_remaining_length", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.get_remaining_prize_to_collect"], ["", "def", "_get_parallel_step_context", "(", "self", ",", "embeddings", ",", "state", ",", "from_depot", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns the context per step, optionally for multiple steps at once (for efficient evaluation of the model)\n        \n        :param embeddings: (batch_size, graph_size, embed_dim)\n        :param prev_a: (batch_size, num_steps)\n        :param first_a: Only used when num_steps = 1, action of first step or None if first step\n        :return: (batch_size, num_steps, context_dim)\n        \"\"\"", "\n", "\n", "current_node", "=", "state", ".", "get_current_node", "(", ")", "\n", "batch_size", ",", "num_steps", "=", "current_node", ".", "size", "(", ")", "\n", "\n", "if", "self", ".", "is_vrp", ":", "\n", "# Embedding of previous node + remaining capacity", "\n", "            ", "if", "from_depot", ":", "\n", "# 1st dimension is node idx, but we do not squeeze it since we want to insert step dimension", "\n", "# i.e. we actually want embeddings[:, 0, :][:, None, :] which is equivalent", "\n", "                ", "return", "torch", ".", "cat", "(", "\n", "(", "\n", "embeddings", "[", ":", ",", "0", ":", "1", ",", ":", "]", ".", "expand", "(", "batch_size", ",", "num_steps", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "# used capacity is 0 after visiting depot", "\n", "self", ".", "problem", ".", "VEHICLE_CAPACITY", "-", "torch", ".", "zeros_like", "(", "state", ".", "used_capacity", "[", ":", ",", ":", ",", "None", "]", ")", "\n", "(", "\n", "state", ".", "get_remaining_length", "(", ")", "[", ":", ",", ":", ",", "None", "]", "\n", "if", "self", ".", "is_orienteering", "\n", "else", "state", ".", "get_remaining_prize_to_collect", "(", ")", "[", ":", ",", ":", ",", "None", "]", "\n", ")", "\n", ")", ",", "\n", "-", "1", "\n", ")", "\n", "", "", "else", ":", "# TSP", "\n", "\n", "            ", "if", "num_steps", "==", "1", ":", "# We need to special case if we have only 1 step, may be the first or not", "\n", "                ", "if", "state", ".", "i", ".", "item", "(", ")", "==", "0", ":", "\n", "# First and only step, ignore prev_a (this is a placeholder)", "\n", "                    ", "return", "self", ".", "W_placeholder", "[", "None", ",", "None", ",", ":", "]", ".", "expand", "(", "batch_size", ",", "1", ",", "self", ".", "W_placeholder", ".", "size", "(", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "# state.last_a for TSP reviser", "\n", "                    ", "return", "embeddings", ".", "gather", "(", "\n", "1", ",", "\n", "torch", ".", "cat", "(", "(", "state", ".", "last_a", ",", "current_node", ")", ",", "1", ")", "[", ":", ",", ":", ",", "None", "]", ".", "expand", "(", "batch_size", ",", "2", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", "\n", ")", ".", "view", "(", "batch_size", ",", "1", ",", "-", "1", ")", "\n", "# More than one step, assume always starting with first", "\n", "", "", "embeddings_per_step", "=", "embeddings", ".", "gather", "(", "\n", "1", ",", "\n", "current_node", "[", ":", ",", "1", ":", ",", "None", "]", ".", "expand", "(", "batch_size", ",", "num_steps", "-", "1", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", "\n", ")", "\n", "return", "torch", ".", "cat", "(", "(", "\n", "# First step placeholder, cat in dim 1 (time steps)", "\n", "self", ".", "W_placeholder", "[", "None", ",", "None", ",", ":", "]", ".", "expand", "(", "batch_size", ",", "1", ",", "self", ".", "W_placeholder", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "# Second step, concatenate embedding of first with embedding of current/previous (in dim 2, context dim)", "\n", "torch", ".", "cat", "(", "(", "\n", "embeddings_per_step", "[", ":", ",", "0", ":", "1", ",", ":", "]", ".", "expand", "(", "batch_size", ",", "num_steps", "-", "1", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "embeddings_per_step", "\n", ")", ",", "2", ")", "\n", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._one_to_many_logits": [[445, 482], ["query.size", "query.view().permute", "torch.matmul", "attention_local.AttentionModel.project_out", "torch.matmul", "math.sqrt", "torch.softmax", "torch.matmul.permute().contiguous().view", "torch.matmul().squeeze", "math.sqrt", "attention_local.AttentionModel.squeeze", "query.view", "glimpse_K.transpose", "query.view().permute.size", "final_Q.size", "torch.tanh", "mask[].expand_as", "torch.matmul.permute().contiguous", "torch.matmul", "logit_K.transpose", "torch.matmul.permute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "", "def", "_one_to_many_logits", "(", "self", ",", "query", ",", "glimpse_K", ",", "glimpse_V", ",", "logit_K", ",", "mask", ")", ":", "\n", "\n", "        ", "batch_size", ",", "num_steps", ",", "embed_dim", "=", "query", ".", "size", "(", ")", "\n", "key_size", "=", "val_size", "=", "embed_dim", "//", "self", ".", "n_heads", "\n", "\n", "# Compute the glimpse, rearrange dimensions so the dimensions are (n_heads, batch_size, num_steps, 1, key_size)", "\n", "glimpse_Q", "=", "query", ".", "view", "(", "batch_size", ",", "num_steps", ",", "self", ".", "n_heads", ",", "1", ",", "key_size", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ",", "3", ",", "4", ")", "\n", "\n", "# Batch matrix multiplication to compute compatibilities (n_heads, batch_size, num_steps, graph_size)", "\n", "compatibility", "=", "torch", ".", "matmul", "(", "glimpse_Q", ",", "glimpse_K", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", "/", "math", ".", "sqrt", "(", "glimpse_Q", ".", "size", "(", "-", "1", ")", ")", "\n", "if", "self", ".", "mask_inner", ":", "\n", "            ", "assert", "self", ".", "mask_logits", ",", "\"Cannot mask inner without masking logits\"", "\n", "compatibility", "[", "mask", "[", "None", ",", ":", ",", ":", ",", "None", ",", ":", "]", ".", "expand_as", "(", "compatibility", ")", "]", "=", "-", "math", ".", "inf", "\n", "\n", "# Batch matrix multiplication to compute heads (n_heads, batch_size, num_steps, val_size)", "\n", "", "heads", "=", "torch", ".", "matmul", "(", "torch", ".", "softmax", "(", "compatibility", ",", "dim", "=", "-", "1", ")", ",", "glimpse_V", ")", "\n", "\n", "# Project to get glimpse/updated context node embedding (batch_size, num_steps, embedding_dim)", "\n", "\n", "glimpse", "=", "self", ".", "project_out", "(", "\n", "heads", ".", "permute", "(", "1", ",", "2", ",", "3", ",", "0", ",", "4", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "num_steps", ",", "1", ",", "self", ".", "n_heads", "*", "val_size", ")", ")", "\n", "\n", "# Now projecting the glimpse is not needed since this can be absorbed into project_out", "\n", "# final_Q = self.project_glimpse(glimpse)", "\n", "final_Q", "=", "glimpse", "\n", "# Batch matrix multiplication to compute logits (batch_size, num_steps, graph_size)", "\n", "\n", "logits", "=", "torch", ".", "matmul", "(", "final_Q", ",", "logit_K", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", ".", "squeeze", "(", "-", "2", ")", "/", "math", ".", "sqrt", "(", "final_Q", ".", "size", "(", "-", "1", ")", ")", "\n", "\n", "\n", "# From the logits compute the probabilities by clipping, masking and softmax", "\n", "if", "self", ".", "tanh_clipping", ">", "0", ":", "\n", "            ", "logits", "=", "torch", ".", "tanh", "(", "logits", ")", "*", "self", ".", "tanh_clipping", "\n", "", "if", "self", ".", "mask_logits", ":", "\n", "            ", "logits", "[", "mask", "]", "=", "-", "math", ".", "inf", "\n", "\n", "", "return", "logits", ",", "glimpse", ".", "squeeze", "(", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._get_attention_node_data": [[483, 501], ["attention_local.AttentionModel.project_node_step().chunk", "attention_local.AttentionModel.project_node_step", "attention_local.AttentionModel._make_heads", "attention_local.AttentionModel._make_heads", "state.demands_with_depot[].clone"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads"], ["", "def", "_get_attention_node_data", "(", "self", ",", "fixed", ",", "state", ")", ":", "\n", "\n", "        ", "if", "self", ".", "is_vrp", "and", "self", ".", "allow_partial", ":", "\n", "\n", "# Need to provide information of how much each node has already been served", "\n", "# Clone demands as they are needed by the backprop whereas they are updated later", "\n", "            ", "glimpse_key_step", ",", "glimpse_val_step", ",", "logit_key_step", "=", "self", ".", "project_node_step", "(", "state", ".", "demands_with_depot", "[", ":", ",", ":", ",", ":", ",", "None", "]", ".", "clone", "(", ")", ")", ".", "chunk", "(", "3", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Projection of concatenation is equivalent to addition of projections but this is more efficient", "\n", "return", "(", "\n", "fixed", ".", "glimpse_key", "+", "self", ".", "_make_heads", "(", "glimpse_key_step", ")", ",", "\n", "fixed", ".", "glimpse_val", "+", "self", ".", "_make_heads", "(", "glimpse_val_step", ")", ",", "\n", "fixed", ".", "logit_key", "+", "logit_key_step", ",", "\n", ")", "\n", "\n", "# TSP or VRP without split delivery", "\n", "", "return", "fixed", ".", "glimpse_key", ",", "fixed", ".", "glimpse_val", ",", "fixed", ".", "logit_key", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.AttentionModel._make_heads": [[502, 509], ["v.contiguous().view().expand().permute", "v.size", "v.size", "v.contiguous().view().expand", "v.size", "v.size", "v.contiguous().view", "v.size", "v.size", "v.size", "v.size", "v.contiguous"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_make_heads", "(", "self", ",", "v", ",", "num_steps", "=", "None", ")", ":", "\n", "        ", "assert", "num_steps", "is", "None", "or", "v", ".", "size", "(", "1", ")", "==", "1", "or", "v", ".", "size", "(", "1", ")", "==", "num_steps", "\n", "\n", "return", "(", "\n", "v", ".", "contiguous", "(", ")", ".", "view", "(", "v", ".", "size", "(", "0", ")", ",", "v", ".", "size", "(", "1", ")", ",", "v", ".", "size", "(", "2", ")", ",", "self", ".", "n_heads", ",", "-", "1", ")", "\n", ".", "expand", "(", "v", ".", "size", "(", "0", ")", ",", "v", ".", "size", "(", "1", ")", "if", "num_steps", "is", "None", "else", "num_steps", ",", "v", ".", "size", "(", "2", ")", ",", "self", ".", "n_heads", ",", "-", "1", ")", "\n", ".", "permute", "(", "3", ",", "0", ",", "1", ",", "2", ",", "4", ")", "# (n_heads, batch_size, num_steps, graph_size, head_dim)", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_local.set_decode_type": [[16, 20], ["isinstance", "model.set_decode_type"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.set_decode_type"], ["def", "set_decode_type", "(", "model", ",", "decode_type", ")", ":", "\n", "    ", "if", "isinstance", "(", "model", ",", "DataParallel", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "", "model", ".", "set_decode_type", "(", "decode_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Encoder.__init__": [[11, 16], ["torch.Module.__init__", "torch.LSTM", "torch.LSTM", "pointer_network.Encoder.init_hidden"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Encoder.init_hidden"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "hidden_dim", ")", ":", "\n", "        ", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "lstm", "=", "nn", ".", "LSTM", "(", "input_dim", ",", "hidden_dim", ")", "\n", "self", ".", "init_hx", ",", "self", ".", "init_cx", "=", "self", ".", "init_hidden", "(", "hidden_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Encoder.forward": [[17, 20], ["pointer_network.Encoder.lstm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "hidden", ")", ":", "\n", "        ", "output", ",", "hidden", "=", "self", ".", "lstm", "(", "x", ",", "hidden", ")", "\n", "return", "output", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Encoder.init_hidden": [[21, 30], ["torch.Parameter", "torch.Parameter", "torch.Parameter.data.uniform_", "torch.Parameter", "torch.Parameter", "torch.Parameter.data.uniform_", "math.sqrt", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["None"], ["", "def", "init_hidden", "(", "self", ",", "hidden_dim", ")", ":", "\n", "        ", "\"\"\"Trainable initial hidden state\"\"\"", "\n", "std", "=", "1.", "/", "math", ".", "sqrt", "(", "hidden_dim", ")", "\n", "enc_init_hx", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "hidden_dim", ")", ")", "\n", "enc_init_hx", ".", "data", ".", "uniform_", "(", "-", "std", ",", "std", ")", "\n", "\n", "enc_init_cx", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "hidden_dim", ")", ")", "\n", "enc_init_cx", ".", "data", ".", "uniform_", "(", "-", "std", ",", "std", ")", "\n", "return", "enc_init_hx", ",", "enc_init_cx", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Attention.__init__": [[34, 44], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Conv1d", "torch.Conv1d", "torch.Tanh", "torch.Tanh", "torch.Parameter", "torch.Parameter", "pointer_network.Attention.v.data.uniform_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["def", "__init__", "(", "self", ",", "dim", ",", "use_tanh", "=", "False", ",", "C", "=", "10", ")", ":", "\n", "        ", "super", "(", "Attention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_tanh", "=", "use_tanh", "\n", "self", ".", "project_query", "=", "nn", ".", "Linear", "(", "dim", ",", "dim", ")", "\n", "self", ".", "project_ref", "=", "nn", ".", "Conv1d", "(", "dim", ",", "dim", ",", "1", ",", "1", ")", "\n", "self", ".", "C", "=", "C", "# tanh exploration", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n", "self", ".", "v", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "dim", ")", ")", "\n", "self", ".", "v", ".", "data", ".", "uniform_", "(", "-", "(", "1.", "/", "math", ".", "sqrt", "(", "dim", ")", ")", ",", "1.", "/", "math", ".", "sqrt", "(", "dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Attention.forward": [[45, 70], ["ref.permute.permute.permute", "pointer_network.Attention.project_query().unsqueeze", "pointer_network.Attention.project_ref", "pointer_network.Attention.repeat", "pointer_network.Attention.v.unsqueeze().expand().unsqueeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "pointer_network.Attention.size", "pointer_network.Attention.project_query", "pointer_network.Attention.v.unsqueeze().expand", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "pointer_network.Attention.tanh", "pointer_network.Attention.repeat.size", "len", "pointer_network.Attention.tanh", "pointer_network.Attention.v.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "forward", "(", "self", ",", "query", ",", "ref", ")", ":", "\n", "        ", "\"\"\"\n        Args: \n            query: is the hidden state of the decoder at the current\n                time step. batch x dim\n            ref: the set of hidden states from the encoder. \n                sourceL x batch x hidden_dim\n        \"\"\"", "\n", "# ref is now [batch_size x hidden_dim x sourceL]", "\n", "ref", "=", "ref", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "q", "=", "self", ".", "project_query", "(", "query", ")", ".", "unsqueeze", "(", "2", ")", "# batch x dim x 1", "\n", "e", "=", "self", ".", "project_ref", "(", "ref", ")", "# batch_size x hidden_dim x sourceL ", "\n", "# expand the query by sourceL", "\n", "# batch x dim x sourceL", "\n", "expanded_q", "=", "q", ".", "repeat", "(", "1", ",", "1", ",", "e", ".", "size", "(", "2", ")", ")", "\n", "# batch x 1 x hidden_dim", "\n", "v_view", "=", "self", ".", "v", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "expanded_q", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "v", ")", ")", ".", "unsqueeze", "(", "1", ")", "\n", "# [batch_size x 1 x hidden_dim] * [batch_size x hidden_dim x sourceL]", "\n", "u", "=", "torch", ".", "bmm", "(", "v_view", ",", "self", ".", "tanh", "(", "expanded_q", "+", "e", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "if", "self", ".", "use_tanh", ":", "\n", "            ", "logits", "=", "self", ".", "C", "*", "self", ".", "tanh", "(", "u", ")", "\n", "", "else", ":", "\n", "            ", "logits", "=", "u", "\n", "", "return", "e", ",", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.__init__": [[73, 96], ["torch.Module.__init__", "torch.LSTMCell", "torch.LSTMCell", "pointer_network.Attention", "pointer_network.Attention", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "tanh_exploration", ",", "\n", "use_tanh", ",", "\n", "n_glimpses", "=", "1", ",", "\n", "mask_glimpses", "=", "True", ",", "\n", "mask_logits", "=", "True", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "n_glimpses", "=", "n_glimpses", "\n", "self", ".", "mask_glimpses", "=", "mask_glimpses", "\n", "self", ".", "mask_logits", "=", "mask_logits", "\n", "self", ".", "use_tanh", "=", "use_tanh", "\n", "self", ".", "tanh_exploration", "=", "tanh_exploration", "\n", "self", ".", "decode_type", "=", "None", "# Needs to be set explicitly before use", "\n", "\n", "self", ".", "lstm", "=", "nn", ".", "LSTMCell", "(", "embedding_dim", ",", "hidden_dim", ")", "\n", "self", ".", "pointer", "=", "Attention", "(", "hidden_dim", ",", "use_tanh", "=", "use_tanh", ",", "C", "=", "tanh_exploration", ")", "\n", "self", ".", "glimpse", "=", "Attention", "(", "hidden_dim", ",", "use_tanh", "=", "False", ")", "\n", "self", ".", "sm", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.update_mask": [[97, 99], ["mask.clone().scatter_", "selected.unsqueeze", "mask.clone"], "methods", ["None"], ["", "def", "update_mask", "(", "self", ",", "mask", ",", "selected", ")", ":", "\n", "        ", "return", "mask", ".", "clone", "(", ")", ".", "scatter_", "(", "1", ",", "selected", ".", "unsqueeze", "(", "-", "1", ")", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.recurrence": [[100, 120], ["pointer_network.Decoder.calc_logits", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax.exp", "torch.log_softmax.exp", "pointer_network.Decoder.update_mask"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.calc_logits", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.update_mask"], ["", "def", "recurrence", "(", "self", ",", "x", ",", "h_in", ",", "prev_mask", ",", "prev_idxs", ",", "step", ",", "context", ")", ":", "\n", "\n", "        ", "logit_mask", "=", "self", ".", "update_mask", "(", "prev_mask", ",", "prev_idxs", ")", "if", "prev_idxs", "is", "not", "None", "else", "prev_mask", "\n", "\n", "logits", ",", "h_out", "=", "self", ".", "calc_logits", "(", "x", ",", "h_in", ",", "logit_mask", ",", "context", ",", "self", ".", "mask_glimpses", ",", "self", ".", "mask_logits", ")", "\n", "\n", "# Calculate log_softmax for better numerical stability", "\n", "log_p", "=", "torch", ".", "log_softmax", "(", "logits", ",", "dim", "=", "1", ")", "\n", "probs", "=", "log_p", ".", "exp", "(", ")", "\n", "\n", "if", "not", "self", ".", "mask_logits", ":", "\n", "# If self.mask_logits, this would be redundant, otherwise we must mask to make sure we don't resample", "\n", "# Note that as a result the vector of probs may not sum to one (this is OK for .multinomial sampling)", "\n", "# But practically by not masking the logits, a model is learned over all sequences (also infeasible)", "\n", "# while only during sampling feasibility is enforced (a.k.a. by setting to 0. here)", "\n", "            ", "probs", "[", "logit_mask", "]", "=", "0.", "\n", "# For consistency we should also mask out in log_p, but the values set to 0 will not be sampled and", "\n", "# Therefore not be used by the reinforce estimator", "\n", "\n", "", "return", "h_out", ",", "log_p", ",", "probs", ",", "logit_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.calc_logits": [[121, 147], ["pointer_network.Decoder.lstm", "range", "pointer_network.Decoder.pointer", "pointer_network.Decoder.glimpse", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "pointer_network.Decoder.sm().unsqueeze", "pointer_network.Decoder.sm"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.encode-attend-navigate.utils.pointer"], ["", "def", "calc_logits", "(", "self", ",", "x", ",", "h_in", ",", "logit_mask", ",", "context", ",", "mask_glimpses", "=", "None", ",", "mask_logits", "=", "None", ")", ":", "\n", "\n", "        ", "if", "mask_glimpses", "is", "None", ":", "\n", "            ", "mask_glimpses", "=", "self", ".", "mask_glimpses", "\n", "\n", "", "if", "mask_logits", "is", "None", ":", "\n", "            ", "mask_logits", "=", "self", ".", "mask_logits", "\n", "\n", "", "hy", ",", "cy", "=", "self", ".", "lstm", "(", "x", ",", "h_in", ")", "\n", "g_l", ",", "h_out", "=", "hy", ",", "(", "hy", ",", "cy", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "n_glimpses", ")", ":", "\n", "            ", "ref", ",", "logits", "=", "self", ".", "glimpse", "(", "g_l", ",", "context", ")", "\n", "# For the glimpses, only mask before softmax so we have always an L1 norm 1 readout vector", "\n", "if", "mask_glimpses", ":", "\n", "                ", "logits", "[", "logit_mask", "]", "=", "-", "np", ".", "inf", "\n", "# [batch_size x h_dim x sourceL] * [batch_size x sourceL x 1] =", "\n", "# [batch_size x h_dim x 1]", "\n", "", "g_l", "=", "torch", ".", "bmm", "(", "ref", ",", "self", ".", "sm", "(", "logits", ")", ".", "unsqueeze", "(", "2", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "", "_", ",", "logits", "=", "self", ".", "pointer", "(", "g_l", ",", "context", ")", "\n", "\n", "# Masking before softmax makes probs sum to one", "\n", "if", "mask_logits", ":", "\n", "            ", "logits", "[", "logit_mask", "]", "=", "-", "np", ".", "inf", "\n", "\n", "", "return", "logits", ",", "h_out", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.forward": [[148, 190], ["context.size", "range", "torch.autograd.Variable", "torch.autograd.Variable", "embedded_inputs.size", "embedded_inputs.data.new().byte().new().zero_", "pointer_network.Decoder.recurrence", "idxs.detach.detach.detach", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "outputs.append", "selections.append", "pointer_network.Decoder.decode", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "embedded_inputs.data.new().byte().new", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "embedded_inputs.size", "embedded_inputs.size", "idxs.detach.detach.contiguous().view().expand", "embedded_inputs.data.new().byte", "idxs.detach.detach.contiguous().view", "embedded_inputs.data.new", "embedded_inputs.size", "idxs.detach.detach.contiguous"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.recurrence", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.decode", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "forward", "(", "self", ",", "decoder_input", ",", "embedded_inputs", ",", "hidden", ",", "context", ",", "eval_tours", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            decoder_input: The initial input to the decoder\n                size is [batch_size x embedding_dim]. Trainable parameter.\n            embedded_inputs: [sourceL x batch_size x embedding_dim]\n            hidden: the prev hidden state, size is [batch_size x hidden_dim]. \n                Initially this is set to (enc_h[-1], enc_c[-1])\n            context: encoder outputs, [sourceL x batch_size x hidden_dim] \n        \"\"\"", "\n", "\n", "batch_size", "=", "context", ".", "size", "(", "1", ")", "\n", "outputs", "=", "[", "]", "\n", "selections", "=", "[", "]", "\n", "steps", "=", "range", "(", "embedded_inputs", ".", "size", "(", "0", ")", ")", "\n", "idxs", "=", "None", "\n", "mask", "=", "Variable", "(", "\n", "embedded_inputs", ".", "data", ".", "new", "(", ")", ".", "byte", "(", ")", ".", "new", "(", "embedded_inputs", ".", "size", "(", "1", ")", ",", "embedded_inputs", ".", "size", "(", "0", ")", ")", ".", "zero_", "(", ")", ",", "\n", "requires_grad", "=", "False", "\n", ")", "\n", "\n", "for", "i", "in", "steps", ":", "\n", "            ", "hidden", ",", "log_p", ",", "probs", ",", "mask", "=", "self", ".", "recurrence", "(", "decoder_input", ",", "hidden", ",", "mask", ",", "idxs", ",", "i", ",", "context", ")", "\n", "# select the next inputs for the decoder [batch_size x hidden_dim]", "\n", "idxs", "=", "self", ".", "decode", "(", "\n", "probs", ",", "\n", "mask", "\n", ")", "if", "eval_tours", "is", "None", "else", "eval_tours", "[", ":", ",", "i", "]", "\n", "\n", "idxs", "=", "idxs", ".", "detach", "(", ")", "# Otherwise pytorch complains it want's a reward, todo implement this more properly?", "\n", "\n", "# Gather input embedding of selected", "\n", "decoder_input", "=", "torch", ".", "gather", "(", "\n", "embedded_inputs", ",", "\n", "0", ",", "\n", "idxs", ".", "contiguous", "(", ")", ".", "view", "(", "1", ",", "batch_size", ",", "1", ")", ".", "expand", "(", "1", ",", "batch_size", ",", "*", "embedded_inputs", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# use outs to point to next object", "\n", "outputs", ".", "append", "(", "log_p", ")", "\n", "selections", ".", "append", "(", "idxs", ")", "\n", "", "return", "(", "torch", ".", "stack", "(", "outputs", ",", "1", ")", ",", "torch", ".", "stack", "(", "selections", ",", "1", ")", ")", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.Decoder.decode": [[191, 206], ["probs.max", "mask.gather().data.any", "probs.multinomial().squeeze", "mask.gather().data.any", "print", "probs.multinomial().squeeze", "probs.multinomial", "mask.gather", "mask.gather", "probs.multinomial", "probs.multinomial().squeeze.unsqueeze", "probs.multinomial().squeeze.unsqueeze"], "methods", ["None"], ["", "def", "decode", "(", "self", ",", "probs", ",", "mask", ")", ":", "\n", "        ", "if", "self", ".", "decode_type", "==", "\"greedy\"", ":", "\n", "            ", "_", ",", "idxs", "=", "probs", ".", "max", "(", "1", ")", "\n", "assert", "not", "mask", ".", "gather", "(", "1", ",", "idxs", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "data", ".", "any", "(", ")", ",", "\"Decode greedy: infeasible action has maximum probability\"", "\n", "", "elif", "self", ".", "decode_type", "==", "\"sampling\"", ":", "\n", "            ", "idxs", "=", "probs", ".", "multinomial", "(", "1", ")", ".", "squeeze", "(", "1", ")", "\n", "# Check if sampling went OK, can go wrong due to bug on GPU", "\n", "while", "mask", ".", "gather", "(", "1", ",", "idxs", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "data", ".", "any", "(", ")", ":", "\n", "                ", "print", "(", "' [!] resampling due to race condition'", ")", "\n", "idxs", "=", "probs", ".", "multinomial", "(", "1", ")", ".", "squeeze", "(", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "assert", "False", ",", "\"Unknown decode type\"", "\n", "\n", "", "return", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.CriticNetworkLSTM.__init__": [[210, 229], ["torch.Module.__init__", "pointer_network.Encoder", "pointer_network.Attention", "torch.Softmax", "torch.Softmax", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["def", "__init__", "(", "self", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "n_process_block_iters", ",", "\n", "tanh_exploration", ",", "\n", "use_tanh", ")", ":", "\n", "        ", "super", "(", "CriticNetworkLSTM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "n_process_block_iters", "=", "n_process_block_iters", "\n", "\n", "self", ".", "encoder", "=", "Encoder", "(", "embedding_dim", ",", "hidden_dim", ")", "\n", "\n", "self", ".", "process_block", "=", "Attention", "(", "hidden_dim", ",", "use_tanh", "=", "use_tanh", ",", "C", "=", "tanh_exploration", ")", "\n", "self", ".", "sm", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "self", ".", "decoder", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "hidden_dim", ",", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.CriticNetworkLSTM.forward": [[231, 252], ["inputs.transpose().contiguous.transpose().contiguous.transpose().contiguous", "pointer_network.CriticNetworkLSTM.encoder.init_hx.unsqueeze().repeat().unsqueeze", "pointer_network.CriticNetworkLSTM.encoder.init_cx.unsqueeze().repeat().unsqueeze", "pointer_network.CriticNetworkLSTM.encoder", "range", "pointer_network.CriticNetworkLSTM.decoder", "pointer_network.CriticNetworkLSTM.process_block", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "inputs.transpose().contiguous.transpose().contiguous.transpose", "pointer_network.CriticNetworkLSTM.encoder.init_hx.unsqueeze().repeat", "pointer_network.CriticNetworkLSTM.encoder.init_cx.unsqueeze().repeat", "inputs.transpose().contiguous.transpose().contiguous.size", "inputs.transpose().contiguous.transpose().contiguous.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "pointer_network.CriticNetworkLSTM.encoder.init_hx.unsqueeze", "pointer_network.CriticNetworkLSTM.encoder.init_cx.unsqueeze", "pointer_network.CriticNetworkLSTM.sm().unsqueeze", "pointer_network.CriticNetworkLSTM.sm"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: [embedding_dim x batch_size x sourceL] of embedded inputs\n        \"\"\"", "\n", "inputs", "=", "inputs", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "encoder_hx", "=", "self", ".", "encoder", ".", "init_hx", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "inputs", ".", "size", "(", "1", ")", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "encoder_cx", "=", "self", ".", "encoder", ".", "init_cx", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "inputs", ".", "size", "(", "1", ")", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "# encoder forward pass", "\n", "enc_outputs", ",", "(", "enc_h_t", ",", "enc_c_t", ")", "=", "self", ".", "encoder", "(", "inputs", ",", "(", "encoder_hx", ",", "encoder_cx", ")", ")", "\n", "\n", "# grab the hidden state and process it via the process block ", "\n", "process_block_state", "=", "enc_h_t", "[", "-", "1", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_process_block_iters", ")", ":", "\n", "            ", "ref", ",", "logits", "=", "self", ".", "process_block", "(", "process_block_state", ",", "enc_outputs", ")", "\n", "process_block_state", "=", "torch", ".", "bmm", "(", "ref", ",", "self", ".", "sm", "(", "logits", ")", ".", "unsqueeze", "(", "2", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "# produce the final scalar output", "\n", "", "out", "=", "self", ".", "decoder", "(", "process_block_state", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.PointerNetwork.__init__": [[256, 293], ["torch.Module.__init__", "pointer_network.Encoder", "pointer_network.Decoder", "torch.Parameter", "torch.Parameter", "pointer_network.PointerNetwork.decoder_in_0.data.uniform_", "torch.Parameter", "torch.Parameter", "pointer_network.PointerNetwork.embedding.data.uniform_", "math.sqrt", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "problem", ",", "\n", "n_encode_layers", "=", "None", ",", "\n", "tanh_clipping", "=", "10.", ",", "\n", "mask_inner", "=", "True", ",", "\n", "mask_logits", "=", "True", ",", "\n", "normalization", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "PointerNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "problem", "=", "problem", "\n", "assert", "problem", ".", "NAME", "==", "\"tsp\"", ",", "\"Pointer Network only supported for TSP\"", "\n", "self", ".", "input_dim", "=", "2", "\n", "\n", "self", ".", "encoder", "=", "Encoder", "(", "\n", "embedding_dim", ",", "\n", "hidden_dim", ")", "\n", "\n", "self", ".", "decoder", "=", "Decoder", "(", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "tanh_exploration", "=", "tanh_clipping", ",", "\n", "use_tanh", "=", "tanh_clipping", ">", "0", ",", "\n", "n_glimpses", "=", "1", ",", "\n", "mask_glimpses", "=", "mask_inner", ",", "\n", "mask_logits", "=", "mask_logits", "\n", ")", "\n", "\n", "# Trainable initial hidden states", "\n", "std", "=", "1.", "/", "math", ".", "sqrt", "(", "embedding_dim", ")", "\n", "self", ".", "decoder_in_0", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "embedding_dim", ")", ")", "\n", "self", ".", "decoder_in_0", ".", "data", ".", "uniform_", "(", "-", "std", ",", "std", ")", "\n", "\n", "self", ".", "embedding", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "self", ".", "input_dim", ",", "embedding_dim", ")", ")", "\n", "self", ".", "embedding", ".", "data", ".", "uniform_", "(", "-", "std", ",", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.PointerNetwork.set_decode_type": [[294, 296], ["None"], "methods", ["None"], ["", "def", "set_decode_type", "(", "self", ",", "decode_type", ")", ":", "\n", "        ", "self", ".", "decoder", ".", "decode_type", "=", "decode_type", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.PointerNetwork.forward": [[297, 317], ["inputs.size", "torch.mm().view", "torch.mm().view", "torch.mm().view", "torch.mm().view", "pointer_network.PointerNetwork._inner", "pointer_network.PointerNetwork.problem.get_costs", "pointer_network.PointerNetwork._calc_log_likelihood", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "inputs.transpose().contiguous().view", "inputs.transpose().contiguous", "inputs.transpose"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._inner", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._calc_log_likelihood"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "eval_tours", "=", "None", ",", "return_pi", "=", "False", ")", ":", "\n", "        ", "batch_size", ",", "graph_size", ",", "input_dim", "=", "inputs", ".", "size", "(", ")", "\n", "\n", "embedded_inputs", "=", "torch", ".", "mm", "(", "\n", "inputs", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "input_dim", ")", ",", "\n", "self", ".", "embedding", "\n", ")", ".", "view", "(", "graph_size", ",", "batch_size", ",", "-", "1", ")", "\n", "\n", "# query the actor net for the input indices ", "\n", "# making up the output, and the pointer attn ", "\n", "_log_p", ",", "pi", "=", "self", ".", "_inner", "(", "embedded_inputs", ",", "eval_tours", ")", "\n", "\n", "cost", ",", "mask", "=", "self", ".", "problem", ".", "get_costs", "(", "inputs", ",", "pi", ")", "\n", "# Log likelyhood is calculated within the model since returning it per action does not work well with", "\n", "# DataParallel since sequences can be of different lengths", "\n", "ll", "=", "self", ".", "_calc_log_likelihood", "(", "_log_p", ",", "pi", ",", "mask", ")", "\n", "if", "return_pi", ":", "\n", "            ", "return", "cost", ",", "ll", ",", "pi", "\n", "\n", "", "return", "cost", ",", "ll", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.PointerNetwork._calc_log_likelihood": [[318, 331], ["_log_p.gather().squeeze", "_log_p.gather().squeeze.sum", "_log_p.gather", "a.unsqueeze"], "methods", ["None"], ["", "def", "_calc_log_likelihood", "(", "self", ",", "_log_p", ",", "a", ",", "mask", ")", ":", "\n", "\n", "# Get log_p corresponding to selected actions", "\n", "        ", "log_p", "=", "_log_p", ".", "gather", "(", "2", ",", "a", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "# Optional: mask out actions irrelevant to objective so they do not get reinforced", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "log_p", "[", "mask", "]", "=", "0", "\n", "\n", "", "assert", "(", "log_p", ">", "-", "1000", ")", ".", "data", ".", "all", "(", ")", ",", "\"Logprobs should not be -inf, check sampling procedure!\"", "\n", "\n", "# Calculate log_likelihood", "\n", "return", "log_p", ".", "sum", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.PointerNetwork.sample_many": [[332, 350], ["input.size", "utils.functions.sample_many", "pointer_network.PointerNetwork._inner", "pointer_network.PointerNetwork.problem.get_costs", "pointer_network.PointerNetwork.problem.get_costs", "torch.mm().view", "torch.mm().view", "torch.mm().view", "torch.mm().view", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "input.transpose().contiguous().view", "input.transpose().contiguous", "input.transpose"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.sample_many", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._inner", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs"], ["", "def", "sample_many", "(", "self", ",", "input", ",", "batch_rep", "=", "1", ",", "iter_rep", "=", "1", ",", "model_local", "=", "None", ",", "model_local2", "=", "None", ",", "target_problem", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param input: (batch_size, graph_size, node_dim) input node features\n        :return:\n        \"\"\"", "\n", "# Bit ugly but we need to pass the embeddings as well.", "\n", "# Making a tuple will not work with the problem.get_cost function", "\n", "batch_size", ",", "graph_size", ",", "input_dim", "=", "input", ".", "size", "(", ")", "\n", "\n", "return", "sample_many", "(", "\n", "lambda", "input", ":", "self", ".", "_inner", "(", "*", "input", ")", ",", "# Need to unpack tuple into arguments", "\n", "lambda", "input", ",", "pi", ":", "self", ".", "problem", ".", "get_costs", "(", "input", ",", "pi", ")", ",", "\n", "lambda", "input", ",", "pi", ":", "self", ".", "problem", ".", "get_costs", "(", "input", ",", "pi", ",", "return_local", "=", "True", ")", ",", "# Don't need embeddings as input to get_costs", "\n", "(", "input", ",", "torch", ".", "mm", "(", "\n", "input", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "input_dim", ")", ",", "\n", "self", ".", "embedding", "\n", ")", ".", "view", "(", "batch_size", ",", "graph_size", ",", "-", "1", ")", ")", ",", "# Pack input with embeddings (additional input)", "\n", "batch_rep", ",", "iter_rep", ",", "model_local", ",", "model_local2", ",", "target_problem", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.pointer_network.PointerNetwork._inner": [[351, 375], ["inputs.view.view.view", "torch.autograd.Variable", "torch.autograd.Variable", "pointer_network.PointerNetwork.encoder", "pointer_network.PointerNetwork.decoder_in_0.unsqueeze().repeat", "pointer_network.PointerNetwork.decoder", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "inputs.view.view.size", "inputs.view.view.size", "pointer_network.PointerNetwork.decoder_in_0.unsqueeze", "inputs.view.view.data.new"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_inner", "(", "self", ",", "input", ",", "inputs", ",", "eval_tours", "=", "None", ")", ":", "\n", "\n", "        ", "inputs", "=", "inputs", ".", "view", "(", "inputs", ".", "shape", "[", "1", "]", ",", "inputs", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "encoder_hx", "=", "encoder_cx", "=", "Variable", "(", "\n", "torch", ".", "zeros", "(", "1", ",", "inputs", ".", "size", "(", "1", ")", ",", "self", ".", "encoder", ".", "hidden_dim", ",", "out", "=", "inputs", ".", "data", ".", "new", "(", ")", ")", ",", "\n", "requires_grad", "=", "False", "\n", ")", "\n", "\n", "# encoder forward pass", "\n", "enc_h", ",", "(", "enc_h_t", ",", "enc_c_t", ")", "=", "self", ".", "encoder", "(", "inputs", ",", "(", "encoder_hx", ",", "encoder_cx", ")", ")", "\n", "\n", "dec_init_state", "=", "(", "enc_h_t", "[", "-", "1", "]", ",", "enc_c_t", "[", "-", "1", "]", ")", "\n", "\n", "# repeat decoder_in_0 across batch", "\n", "decoder_input", "=", "self", ".", "decoder_in_0", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "inputs", ".", "size", "(", "1", ")", ",", "1", ")", "\n", "\n", "(", "pointer_probs", ",", "input_idxs", ")", ",", "dec_hidden_t", "=", "self", ".", "decoder", "(", "decoder_input", ",", "\n", "inputs", ",", "\n", "dec_init_state", ",", "\n", "enc_h", ",", "\n", "eval_tours", ")", "\n", "\n", "return", "pointer_probs", ",", "input_idxs", "", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.critic_network.CriticNetwork.__init__": [[7, 31], ["torch.nn.Module.__init__", "nets.graph_encoder.GraphAttentionEncoder", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "n_layers", ",", "\n", "encoder_normalization", "\n", ")", ":", "\n", "        ", "super", "(", "CriticNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "\n", "self", ".", "encoder", "=", "GraphAttentionEncoder", "(", "\n", "node_dim", "=", "input_dim", ",", "\n", "n_heads", "=", "8", ",", "\n", "embed_dim", "=", "embedding_dim", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "normalization", "=", "encoder_normalization", "\n", ")", "\n", "\n", "self", ".", "value_head", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "embedding_dim", ",", "hidden_dim", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "hidden_dim", ",", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.critic_network.CriticNetwork.forward": [[33, 41], ["critic_network.CriticNetwork.encoder", "critic_network.CriticNetwork.value_head"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n\n        :param inputs: (batch_size, graph_size, input_dim)\n        :return:\n        \"\"\"", "\n", "_", ",", "graph_embeddings", "=", "self", ".", "encoder", "(", "inputs", ")", "\n", "return", "self", ".", "value_head", "(", "graph_embeddings", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModelFixed.__getitem__": [[31, 39], ["attention_model.AttentionModelFixed", "torch.is_tensor", "isinstance"], "methods", ["None"], ["def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "key", ")", "or", "isinstance", "(", "key", ",", "slice", ")", "\n", "return", "AttentionModelFixed", "(", "\n", "node_embeddings", "=", "self", ".", "node_embeddings", "[", "key", "]", ",", "\n", "context_node_projected", "=", "self", ".", "context_node_projected", "[", "key", "]", ",", "\n", "glimpse_key", "=", "self", ".", "glimpse_key", "[", ":", ",", "key", "]", ",", "# dim 0 are the heads", "\n", "glimpse_val", "=", "self", ".", "glimpse_val", "[", ":", ",", "key", "]", ",", "# dim 0 are the heads", "\n", "logit_key", "=", "self", ".", "logit_key", "[", "key", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__": [[44, 118], ["torch.nn.Module.__init__", "torch.nn.Linear", "nets.graph_encoder.GraphAttentionEncoder", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Parameter", "attention_model.AttentionModel.W_placeholder.data.uniform_", "torch.nn.Linear", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "problem", ",", "\n", "n_encode_layers", "=", "2", ",", "\n", "tanh_clipping", "=", "10.", ",", "\n", "mask_inner", "=", "True", ",", "\n", "mask_logits", "=", "True", ",", "\n", "normalization", "=", "'batch'", ",", "\n", "n_heads", "=", "8", ",", "\n", "checkpoint_encoder", "=", "False", ",", "\n", "shrink_size", "=", "None", ")", ":", "\n", "        ", "super", "(", "AttentionModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "n_encode_layers", "=", "n_encode_layers", "\n", "self", ".", "decode_type", "=", "None", "\n", "self", ".", "temp", "=", "1.0", "\n", "self", ".", "allow_partial", "=", "problem", ".", "NAME", "==", "'sdvrp'", "\n", "self", ".", "is_vrp", "=", "problem", ".", "NAME", "==", "'cvrp'", "or", "problem", ".", "NAME", "==", "'sdvrp'", "\n", "self", ".", "is_orienteering", "=", "problem", ".", "NAME", "==", "'op'", "\n", "self", ".", "is_pctsp", "=", "problem", ".", "NAME", "==", "'pctsp'", "\n", "\n", "self", ".", "tanh_clipping", "=", "tanh_clipping", "\n", "\n", "self", ".", "mask_inner", "=", "mask_inner", "\n", "self", ".", "mask_logits", "=", "mask_logits", "\n", "#         self.attn = LSHAttention(bucket_size=0,n_hashes=4,causal = True)", "\n", "self", ".", "problem", "=", "problem", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "checkpoint_encoder", "=", "checkpoint_encoder", "\n", "self", ".", "shrink_size", "=", "shrink_size", "\n", "\n", "# Problem specific context parameters (placeholder and step context dimension)", "\n", "if", "self", ".", "is_vrp", "or", "self", ".", "is_orienteering", "or", "self", ".", "is_pctsp", ":", "\n", "# Embedding of last node + remaining_capacity / remaining length / remaining prize to collect", "\n", "            ", "step_context_dim", "=", "embedding_dim", "+", "1", "\n", "\n", "if", "self", ".", "is_pctsp", ":", "\n", "                ", "node_dim", "=", "4", "# x, y, expected_prize, penalty", "\n", "", "else", ":", "\n", "                ", "node_dim", "=", "3", "# x, y, demand / prize", "\n", "\n", "# Special embedding projection for depot node", "\n", "", "self", ".", "init_embed_depot", "=", "nn", ".", "Linear", "(", "2", ",", "embedding_dim", ")", "\n", "\n", "if", "self", ".", "is_vrp", "and", "self", ".", "allow_partial", ":", "# Need to include the demand if split delivery allowed", "\n", "                ", "self", ".", "project_node_step", "=", "nn", ".", "Linear", "(", "1", ",", "3", "*", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "", "", "else", ":", "# TSP", "\n", "            ", "assert", "problem", ".", "NAME", "==", "\"tsp\"", ",", "\"Unsupported problem: {}\"", ".", "format", "(", "problem", ".", "NAME", ")", "\n", "step_context_dim", "=", "2", "*", "embedding_dim", "# Embedding of first and last node", "\n", "node_dim", "=", "2", "# x, y", "\n", "\n", "# Learned input symbols for first action", "\n", "self", ".", "W_placeholder", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "2", "*", "embedding_dim", ")", ")", "\n", "self", ".", "W_placeholder", ".", "data", ".", "uniform_", "(", "-", "1", ",", "1", ")", "# Placeholder should be in range of activations", "\n", "\n", "", "self", ".", "init_embed", "=", "nn", ".", "Linear", "(", "node_dim", ",", "embedding_dim", ")", "\n", "\n", "self", ".", "embedder", "=", "GraphAttentionEncoder", "(", "\n", "n_heads", "=", "n_heads", ",", "\n", "embed_dim", "=", "embedding_dim", ",", "\n", "n_layers", "=", "self", ".", "n_encode_layers", ",", "\n", "normalization", "=", "normalization", "\n", ")", "\n", "\n", "# For each node we compute (glimpse key, glimpse value, logit key) so 3 * embedding_dim", "\n", "self", ".", "project_node_embeddings", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "3", "*", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "project_fixed_context", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "project_step_context", "=", "nn", ".", "Linear", "(", "step_context_dim", ",", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "assert", "embedding_dim", "%", "n_heads", "==", "0", "\n", "# Note n_heads * val_dim == embedding_dim so input to project_out is embedding_dim", "\n", "self", ".", "project_out", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "embedding_dim", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.set_decode_type": [[119, 123], ["None"], "methods", ["None"], ["", "def", "set_decode_type", "(", "self", ",", "decode_type", ",", "temp", "=", "None", ")", ":", "\n", "        ", "self", ".", "decode_type", "=", "decode_type", "\n", "if", "temp", "is", "not", "None", ":", "# Do not change temperature if not provided", "\n", "            ", "self", ".", "temp", "=", "temp", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.forward": [[124, 155], ["attention_model.AttentionModel._inner", "entropies.mean.mean.mean", "attention_model.AttentionModel.problem.get_costs", "attention_model.AttentionModel._calc_log_likelihood", "torch.utils.checkpoint.checkpoint", "attention_model.AttentionModel.embedder", "attention_model.AttentionModel._init_embed", "attention_model.AttentionModel._init_embed"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._inner", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._calc_log_likelihood", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "return_pi", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        :param input: (batch_size, graph_size, node_dim) input node features or dictionary with multiple tensors\n        :param return_pi: whether to return the output sequences, this is optional as it is not compatible with\n        using DataParallel as the results may be of different lengths on different GPUs\n        :return:\n        \"\"\"", "\n", "\n", "if", "self", ".", "checkpoint_encoder", "and", "self", ".", "training", ":", "# Only checkpoint if we need gradients", "\n", "            ", "embeddings", ",", "_", "=", "checkpoint", "(", "self", ".", "embedder", ",", "self", ".", "_init_embed", "(", "input", ")", ")", "\n", "", "else", ":", "\n", "\n", "            ", "embeddings", ",", "_", "=", "self", ".", "embedder", "(", "self", ".", "_init_embed", "(", "input", ")", ")", "\n", "\n", "\n", "\n", "", "_log_p", ",", "pi", ",", "entropies", ",", "w_ent", "=", "self", ".", "_inner", "(", "input", ",", "embeddings", ")", "\n", "entropies", "=", "entropies", ".", "mean", "(", "1", ")", "\n", "\n", "# scaling entropy", "\n", "entropies", "=", "entropies", "*", "pi", ".", "shape", "[", "1", "]", "/", "w_ent", "\n", "\n", "\n", "\n", "cost", ",", "mask", "=", "self", ".", "problem", ".", "get_costs", "(", "input", ",", "pi", ")", "\n", "ll", "=", "self", ".", "_calc_log_likelihood", "(", "_log_p", ",", "pi", ",", "mask", ")", "\n", "\n", "if", "return_pi", ":", "\n", "            ", "return", "cost", ",", "pi", "\n", "\n", "", "return", "cost", ",", "ll", ",", "entropies", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search": [[156, 158], ["attention_model.AttentionModel.problem.beam_search"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.beam_search"], ["", "def", "beam_search", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "problem", ".", "beam_search", "(", "*", "args", ",", "**", "kwargs", ",", "model", "=", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.precompute_fixed": [[159, 164], ["attention_model.AttentionModel.embedder", "utils.beam_search.CachedLookup", "attention_model.AttentionModel._init_embed", "attention_model.AttentionModel._precompute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._precompute"], ["", "def", "precompute_fixed", "(", "self", ",", "input", ")", ":", "\n", "        ", "embeddings", ",", "_", "=", "self", ".", "embedder", "(", "self", ".", "_init_embed", "(", "input", ")", ")", "\n", "# Use a CachedLookup such that if we repeatedly index this object with the same index we only need to do", "\n", "# the lookup once... this is the case if all elements in the batch have maximum batch size", "\n", "return", "CachedLookup", "(", "self", ".", "_precompute", "(", "embeddings", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.propose_expansions": [[165, 194], ["utils.tensor_functions.compute_in_batches", "ind_topk.view", "score_expand.view", "torch.nonzero", "log_p_topk.size", "torch.arange", "ind_topk.size", "len", "attention_model.AttentionModel._get_log_p_topk", "beam.size", "ind_topk.view.size", "ind_topk.view.new"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.tensor_functions.compute_in_batches", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_log_p_topk", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "propose_expansions", "(", "self", ",", "beam", ",", "fixed", ",", "expand_size", "=", "None", ",", "normalize", "=", "False", ",", "max_calc_batch_size", "=", "4096", ")", ":", "\n", "# First dim = batch_size * cur_beam_size", "\n", "        ", "log_p_topk", ",", "ind_topk", "=", "compute_in_batches", "(", "\n", "lambda", "b", ":", "self", ".", "_get_log_p_topk", "(", "fixed", "[", "b", ".", "ids", "]", ",", "b", ".", "state", ",", "k", "=", "expand_size", ",", "normalize", "=", "normalize", ")", ",", "\n", "max_calc_batch_size", ",", "beam", ",", "n", "=", "beam", ".", "size", "(", ")", "\n", ")", "\n", "\n", "assert", "log_p_topk", ".", "size", "(", "1", ")", "==", "1", ",", "\"Can only have single step\"", "\n", "# This will broadcast, calculate log_p (score) of expansions", "\n", "score_expand", "=", "beam", ".", "score", "[", ":", ",", "None", "]", "+", "log_p_topk", "[", ":", ",", "0", ",", ":", "]", "\n", "\n", "# We flatten the action as we need to filter and this cannot be done in 2d", "\n", "flat_action", "=", "ind_topk", ".", "view", "(", "-", "1", ")", "\n", "flat_score", "=", "score_expand", ".", "view", "(", "-", "1", ")", "\n", "flat_feas", "=", "flat_score", ">", "-", "1e10", "# != -math.inf triggers", "\n", "\n", "# Parent is row idx of ind_topk, can be found by enumerating elements and dividing by number of columns", "\n", "flat_parent", "=", "torch", ".", "arange", "(", "flat_action", ".", "size", "(", "-", "1", ")", ",", "out", "=", "flat_action", ".", "new", "(", ")", ")", "/", "ind_topk", ".", "size", "(", "-", "1", ")", "\n", "\n", "# Filter infeasible", "\n", "feas_ind_2d", "=", "torch", ".", "nonzero", "(", "flat_feas", ")", "\n", "\n", "if", "len", "(", "feas_ind_2d", ")", "==", "0", ":", "\n", "# Too bad, no feasible expansions at all :(", "\n", "            ", "return", "None", ",", "None", ",", "None", "\n", "\n", "", "feas_ind", "=", "feas_ind_2d", "[", ":", ",", "0", "]", "\n", "\n", "return", "flat_parent", "[", "feas_ind", "]", ",", "flat_action", "[", "feas_ind", "]", ",", "flat_score", "[", "feas_ind", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._calc_log_likelihood": [[195, 208], ["_log_p.gather().squeeze", "_log_p.gather().squeeze.sum", "_log_p.gather", "a.unsqueeze"], "methods", ["None"], ["", "def", "_calc_log_likelihood", "(", "self", ",", "_log_p", ",", "a", ",", "mask", ")", ":", "\n", "\n", "# Get log_p corresponding to selected actions", "\n", "        ", "log_p", "=", "_log_p", ".", "gather", "(", "2", ",", "a", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "# Optional: mask out actions irrelevant to objective so they do not get reinforced", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "log_p", "[", "mask", "]", "=", "0", "\n", "\n", "", "assert", "(", "log_p", ">", "-", "1000", ")", ".", "data", ".", "all", "(", ")", ",", "\"Logprobs should not be -inf, check sampling procedure!\"", "\n", "\n", "# Calculate log_likelihood", "\n", "return", "log_p", ".", "sum", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed": [[209, 234], ["attention_model.AttentionModel.init_embed", "torch.cat", "attention_model.AttentionModel.init_embed", "attention_model.AttentionModel.init_embed_depot", "torch.cat"], "methods", ["None"], ["", "def", "_init_embed", "(", "self", ",", "input", ")", ":", "\n", "\n", "        ", "if", "self", ".", "is_vrp", "or", "self", ".", "is_orienteering", "or", "self", ".", "is_pctsp", ":", "\n", "            ", "if", "self", ".", "is_vrp", ":", "\n", "\n", "                ", "features", "=", "(", "'demand'", ",", ")", "\n", "", "elif", "self", ".", "is_orienteering", ":", "\n", "                ", "features", "=", "(", "'prize'", ",", ")", "\n", "", "else", ":", "\n", "                ", "assert", "self", ".", "is_pctsp", "\n", "features", "=", "(", "'deterministic_prize'", ",", "'penalty'", ")", "\n", "\n", "\n", "", "return", "torch", ".", "cat", "(", "\n", "(", "\n", "self", ".", "init_embed_depot", "(", "input", "[", "'depot'", "]", ")", "[", ":", ",", "None", ",", ":", "]", ",", "\n", "self", ".", "init_embed", "(", "torch", ".", "cat", "(", "(", "\n", "input", "[", "'loc'", "]", ",", "\n", "*", "(", "input", "[", "feat", "]", "[", ":", ",", ":", ",", "None", "]", "for", "feat", "in", "features", ")", "\n", ")", ",", "-", "1", ")", ")", "\n", ")", ",", "\n", "1", "\n", ")", "\n", "# TSP", "\n", "", "return", "self", ".", "init_embed", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._inner": [[235, 299], ["attention_model.AttentionModel.problem.make_state", "attention_model.AttentionModel._precompute", "state.update.update.ids.size", "attention_model.AttentionModel._get_log_p", "attention_model.AttentionModel._select_node", "state.update.update.update", "outputs.append", "sequences.append", "entropies.append", "torch.stack", "torch.stack", "torch.stack", "state.update.update.all_finished", "torch.nonzero", "log_p_.new_zeros", "selected_.new_zeros", "len", "len", "log_p_.new_zeros.exp", "state.update.update.ids.size", "state.update.update.get_finished", "state.update.update.ids.size", "log_p_.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.make_state", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._precompute", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_log_p", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._select_node", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.update", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.all_finished", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.vrp.state_cvrp.StateCVRP.get_finished", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_inner", "(", "self", ",", "input", ",", "embeddings", ")", ":", "\n", "\n", "        ", "outputs", "=", "[", "]", "\n", "sequences", "=", "[", "]", "\n", "entropies", "=", "[", "]", "\n", "state", "=", "self", ".", "problem", ".", "make_state", "(", "input", ")", "\n", "\n", "# Compute keys, values for the glimpse and keys for the logits once as they can be reused in every step", "\n", "fixed", "=", "self", ".", "_precompute", "(", "embeddings", ")", "\n", "\n", "batch_size", "=", "state", ".", "ids", ".", "size", "(", "0", ")", "\n", "\n", "# Perform decoding steps", "\n", "i", "=", "0", "\n", "w_ent", "=", "0", "\n", "while", "not", "(", "self", ".", "shrink_size", "is", "None", "and", "state", ".", "all_finished", "(", ")", ")", ":", "\n", "\n", "            ", "if", "self", ".", "shrink_size", "is", "not", "None", ":", "\n", "                ", "unfinished", "=", "torch", ".", "nonzero", "(", "state", ".", "get_finished", "(", ")", "==", "0", ")", "\n", "if", "len", "(", "unfinished", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "", "unfinished", "=", "unfinished", "[", ":", ",", "0", "]", "\n", "# Check if we can shrink by at least shrink_size and if this leaves at least 16", "\n", "# (otherwise batch norm will not work well and it is inefficient anyway)", "\n", "if", "16", "<=", "len", "(", "unfinished", ")", "<=", "state", ".", "ids", ".", "size", "(", "0", ")", "-", "self", ".", "shrink_size", ":", "\n", "# Filter states", "\n", "                    ", "state", "=", "state", "[", "unfinished", "]", "\n", "fixed", "=", "fixed", "[", "unfinished", "]", "\n", "\n", "", "", "log_p", ",", "mask", ",", "ent", "=", "self", ".", "_get_log_p", "(", "fixed", ",", "state", ",", "i", "=", "i", ")", "\n", "# linear scheduler", "\n", "####################################################", "\n", "w_ent", "=", "w_ent", "+", "(", "mask", ".", "shape", "[", "2", "]", "-", "i", ")", "\n", "ent", "=", "ent", "*", "(", "mask", ".", "shape", "[", "2", "]", "-", "i", ")", "\n", "####################################################", "\n", "\n", "# Uniform scheduler", "\n", "####################################################", "\n", "#S = 1", "\n", "#A = A", "\n", "\n", "####################################################", "\n", "# Select the indices of the next nodes in the sequences, result (batch_size) long", "\n", "selected", "=", "self", ".", "_select_node", "(", "log_p", ".", "exp", "(", ")", "[", ":", ",", "0", ",", ":", "]", ",", "mask", "[", ":", ",", "0", ",", ":", "]", ")", "# Squeeze out steps dimension", "\n", "\n", "state", "=", "state", ".", "update", "(", "selected", ")", "\n", "\n", "# Now make log_p, selected desired output size by 'unshrinking'", "\n", "if", "self", ".", "shrink_size", "is", "not", "None", "and", "state", ".", "ids", ".", "size", "(", "0", ")", "<", "batch_size", ":", "\n", "                ", "log_p_", ",", "selected_", "=", "log_p", ",", "selected", "\n", "log_p", "=", "log_p_", ".", "new_zeros", "(", "batch_size", ",", "*", "log_p_", ".", "size", "(", ")", "[", "1", ":", "]", ")", "\n", "selected", "=", "selected_", ".", "new_zeros", "(", "batch_size", ")", "\n", "\n", "log_p", "[", "state", ".", "ids", "[", ":", ",", "0", "]", "]", "=", "log_p_", "\n", "selected", "[", "state", ".", "ids", "[", ":", ",", "0", "]", "]", "=", "selected_", "\n", "\n", "# Collect output of step", "\n", "", "outputs", ".", "append", "(", "log_p", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "sequences", ".", "append", "(", "selected", ")", "\n", "entropies", ".", "append", "(", "ent", ")", "\n", "i", "+=", "1", "\n", "\n", "# Collected lists, return Tensor", "\n", "", "return", "torch", ".", "stack", "(", "outputs", ",", "1", ")", ",", "torch", ".", "stack", "(", "sequences", ",", "1", ")", ",", "torch", ".", "stack", "(", "entropies", ",", "1", ")", ",", "w_ent", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.sample_many": [[300, 314], ["utils.functions.sample_many", "attention_model.AttentionModel._inner", "attention_model.AttentionModel.problem.get_costs", "attention_model.AttentionModel.problem.get_costs", "attention_model.AttentionModel.embedder", "attention_model.AttentionModel._init_embed"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel.sample_many", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._inner", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.op.problem_op.OP.get_costs", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._init_embed"], ["", "def", "sample_many", "(", "self", ",", "input", ",", "opts", ",", "batch_rep", "=", "1", ",", "iter_rep", "=", "1", ",", "reviser", "=", "None", ",", "reviser_2", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param input: (batch_size, graph_size, node_dim) input node features\n        :return:\n        \"\"\"", "\n", "# Bit ugly but we need to pass the embeddings as well.", "\n", "# Making a tuple will not work with the problem.get_cost function", "\n", "\n", "return", "sample_many", "(", "\n", "lambda", "input", ":", "self", ".", "_inner", "(", "*", "input", ")", ",", "# Need to unpack tuple into arguments", "\n", "lambda", "input", ",", "pi", ":", "self", ".", "problem", ".", "get_costs", "(", "input", ",", "pi", ")", ",", "\n", "lambda", "input", ",", "pi", ":", "self", ".", "problem", ".", "get_costs", "(", "input", ",", "pi", ",", "return_local", "=", "True", ")", ",", "# Don't need embeddings as input to get_costs", "\n", "(", "input", ",", "self", ".", "embedder", "(", "self", ".", "_init_embed", "(", "input", ")", ")", "[", "0", "]", ")", ",", "# Pack input with embeddings (additional input)", "\n", "opts", ",", "batch_rep", ",", "iter_rep", ",", "reviser", ",", "reviser_2", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._select_node": [[316, 337], ["probs.max", "mask.gather().data.any", "probs.multinomial().squeeze", "mask.gather().data.any", "print", "probs.multinomial().squeeze", "probs.multinomial", "mask.gather", "mask.gather", "probs.multinomial", "probs.multinomial().squeeze.unsqueeze", "probs.multinomial().squeeze.unsqueeze"], "methods", ["None"], ["", "def", "_select_node", "(", "self", ",", "probs", ",", "mask", ")", ":", "\n", "\n", "        ", "assert", "(", "probs", "==", "probs", ")", ".", "all", "(", ")", ",", "\"Probs should not contain any nans\"", "\n", "\n", "if", "self", ".", "decode_type", "==", "\"greedy\"", ":", "\n", "            ", "_", ",", "selected", "=", "probs", ".", "max", "(", "1", ")", "\n", "assert", "not", "mask", ".", "gather", "(", "1", ",", "selected", ".", "unsqueeze", "(", "\n", "-", "1", ")", ")", ".", "data", ".", "any", "(", ")", ",", "\"Decode greedy: infeasible action has maximum probability\"", "\n", "\n", "", "elif", "self", ".", "decode_type", "==", "\"sampling\"", ":", "\n", "            ", "selected", "=", "probs", ".", "multinomial", "(", "1", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "# Check if sampling went OK, can go wrong due to bug on GPU", "\n", "# See https://discuss.pytorch.org/t/bad-behavior-of-multinomial-function/10232", "\n", "while", "mask", ".", "gather", "(", "1", ",", "selected", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "data", ".", "any", "(", ")", ":", "\n", "                ", "print", "(", "'Sampled bad values, resampling!'", ")", "\n", "selected", "=", "probs", ".", "multinomial", "(", "1", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "assert", "False", ",", "\"Unknown decode type\"", "\n", "", "return", "selected", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._precompute": [[338, 356], ["embeddings.mean", "attention_model.AttentionModel.project_node_embeddings().chunk", "attention_model.AttentionModelFixed", "attention_model.AttentionModel.project_fixed_context", "attention_model.AttentionModel._make_heads", "attention_model.AttentionModel._make_heads", "logit_key_fixed.contiguous", "attention_model.AttentionModel.project_node_embeddings"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads"], ["", "def", "_precompute", "(", "self", ",", "embeddings", ",", "num_steps", "=", "1", ")", ":", "\n", "\n", "# The fixed context projection of the graph embedding is calculated only once for efficiency", "\n", "        ", "graph_embed", "=", "embeddings", ".", "mean", "(", "1", ")", "\n", "# fixed context = (batch_size, 1, embed_dim) to make broadcastable with parallel timesteps", "\n", "fixed_context", "=", "self", ".", "project_fixed_context", "(", "graph_embed", ")", "[", ":", ",", "None", ",", ":", "]", "\n", "\n", "# The projection of the node embeddings for the attention is calculated once up front", "\n", "glimpse_key_fixed", ",", "glimpse_val_fixed", ",", "logit_key_fixed", "=", "self", ".", "project_node_embeddings", "(", "embeddings", "[", ":", ",", "None", ",", ":", ",", ":", "]", ")", ".", "chunk", "(", "3", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# No need to rearrange key for logit as there is a single head", "\n", "fixed_attention_node_data", "=", "(", "\n", "self", ".", "_make_heads", "(", "glimpse_key_fixed", ",", "num_steps", ")", ",", "\n", "self", ".", "_make_heads", "(", "glimpse_val_fixed", ",", "num_steps", ")", ",", "\n", "logit_key_fixed", ".", "contiguous", "(", ")", "\n", ")", "\n", "return", "AttentionModelFixed", "(", "embeddings", ",", "fixed_context", ",", "*", "fixed_attention_node_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_log_p_topk": [[357, 368], ["attention_model.AttentionModel._get_log_p", "log_p.topk", "log_p.size", "torch.arange().repeat", "log_p.size", "torch.arange", "log_p.size"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_log_p", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.topk", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_get_log_p_topk", "(", "self", ",", "fixed", ",", "state", ",", "k", "=", "None", ",", "normalize", "=", "True", ")", ":", "\n", "        ", "log_p", ",", "_", ",", "_", "=", "self", ".", "_get_log_p", "(", "fixed", ",", "state", ",", "normalize", "=", "normalize", ")", "\n", "\n", "# Return topk", "\n", "if", "k", "is", "not", "None", "and", "k", "<", "log_p", ".", "size", "(", "-", "1", ")", ":", "\n", "            ", "return", "log_p", ".", "topk", "(", "k", ",", "-", "1", ")", "\n", "\n", "# Return all, note different from torch.topk this does not give error if less than k elements along dim", "\n", "", "return", "(", "\n", "log_p", ",", "\n", "torch", ".", "arange", "(", "log_p", ".", "size", "(", "-", "1", ")", ",", "device", "=", "log_p", ".", "device", ",", "dtype", "=", "torch", ".", "int64", ")", ".", "repeat", "(", "log_p", ".", "size", "(", "0", ")", ",", "1", ")", "[", ":", ",", "None", ",", ":", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_log_p": [[370, 396], ["attention_model.AttentionModel._get_attention_node_data", "state.get_mask", "attention_model.AttentionModel._one_to_many_logits", "torch.sum", "attention_model.AttentionModel.project_step_context", "torch.log_softmax", "torch.exp", "torch.isnan().any", "torch.sum.view", "attention_model.AttentionModel._get_parallel_step_context", "torch.isnan", "torch.isnan"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_attention_node_data", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_mask", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._one_to_many_logits", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_parallel_step_context"], ["", "def", "_get_log_p", "(", "self", ",", "fixed", ",", "state", ",", "normalize", "=", "True", ",", "i", "=", "0", ",", "is_local", "=", "False", ")", ":", "\n", "\n", "# Compute query = context node embedding", "\n", "        ", "query", "=", "fixed", ".", "context_node_projected", "+", "self", ".", "project_step_context", "(", "self", ".", "_get_parallel_step_context", "(", "fixed", ".", "node_embeddings", ",", "state", ")", ")", "\n", "\n", "# Compute keys and values for the nodes", "\n", "glimpse_K", ",", "glimpse_V", ",", "logit_K", "=", "self", ".", "_get_attention_node_data", "(", "fixed", ",", "state", ")", "\n", "\n", "# Compute the mask", "\n", "mask", "=", "state", ".", "get_mask", "(", ")", "\n", "\n", "# Compute logits (unnormalized log_p)", "\n", "log_p", ",", "glimpse", "=", "self", ".", "_one_to_many_logits", "(", "query", ",", "glimpse_K", ",", "glimpse_V", ",", "logit_K", ",", "mask", ")", "\n", "\n", "if", "normalize", ":", "\n", "            ", "log_p", "=", "torch", ".", "log_softmax", "(", "log_p", "/", "self", ".", "temp", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Evaluate Entropy", "\n", "", "A", "=", "-", "log_p", "*", "torch", ".", "exp", "(", "log_p", ")", "\n", "\n", "A", "[", "torch", ".", "isnan", "(", "A", ")", "]", "=", "0", "\n", "A", "=", "torch", ".", "sum", "(", "A", ",", "dim", "=", "-", "1", ")", "\n", "assert", "not", "torch", ".", "isnan", "(", "log_p", ")", ".", "any", "(", ")", "\n", "\n", "return", "log_p", ",", "mask", ",", "A", ".", "view", "(", "-", "1", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_parallel_step_context": [[397, 480], ["state.get_current_node", "state.get_current_node.size", "torch.cat", "torch.cat", "torch.cat", "embeddings.gather", "torch.cat", "current_node[].expand", "embeddings[].expand", "torch.gather().view", "torch.gather().view", "state.i.item", "attention_model.AttentionModel.W_placeholder[].expand", "embeddings.gather().view", "embeddings.size", "attention_model.AttentionModel.W_placeholder[].expand", "torch.cat", "embeddings.size", "torch.zeros_like", "embeddings.size", "embeddings.size", "attention_model.AttentionModel.W_placeholder.size", "attention_model.AttentionModel.W_placeholder.size", "torch.gather", "torch.gather", "state.get_remaining_length", "state.get_remaining_prize_to_collect", "embeddings.gather", "embeddings_per_step[].expand", "state.get_current_node.contiguous().view().expand", "state.get_current_node.contiguous().view().expand", "[].expand", "embeddings.size", "embeddings.size", "embeddings.size", "embeddings.size", "state.get_current_node.contiguous().view", "state.get_current_node.contiguous().view", "torch.cat", "state.get_current_node.contiguous", "state.get_current_node.contiguous"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_current_node", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.op.state_op.StateOP.get_remaining_length", "home.repos.pwc.inspect_result.alstn12088_lcp.pctsp.state_pctsp.StatePCTSP.get_remaining_prize_to_collect", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_get_parallel_step_context", "(", "self", ",", "embeddings", ",", "state", ",", "from_depot", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Returns the context per step, optionally for multiple steps at once (for efficient evaluation of the model)\n        \n        :param embeddings: (batch_size, graph_size, embed_dim)\n        :param prev_a: (batch_size, num_steps)\n        :param first_a: Only used when num_steps = 1, action of first step or None if first step\n        :return: (batch_size, num_steps, context_dim)\n        \"\"\"", "\n", "\n", "current_node", "=", "state", ".", "get_current_node", "(", ")", "\n", "batch_size", ",", "num_steps", "=", "current_node", ".", "size", "(", ")", "\n", "\n", "if", "self", ".", "is_vrp", ":", "\n", "# Embedding of previous node + remaining capacity", "\n", "            ", "if", "from_depot", ":", "\n", "# 1st dimension is node idx, but we do not squeeze it since we want to insert step dimension", "\n", "# i.e. we actually want embeddings[:, 0, :][:, None, :] which is equivalent", "\n", "                ", "return", "torch", ".", "cat", "(", "\n", "(", "\n", "embeddings", "[", ":", ",", "0", ":", "1", ",", ":", "]", ".", "expand", "(", "batch_size", ",", "num_steps", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "# used capacity is 0 after visiting depot", "\n", "self", ".", "problem", ".", "VEHICLE_CAPACITY", "-", "torch", ".", "zeros_like", "(", "state", ".", "used_capacity", "[", ":", ",", ":", ",", "None", "]", ")", "\n", ")", ",", "\n", "-", "1", "\n", ")", "\n", "", "else", ":", "\n", "                ", "return", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "gather", "(", "\n", "embeddings", ",", "\n", "1", ",", "\n", "current_node", ".", "contiguous", "(", ")", "\n", ".", "view", "(", "batch_size", ",", "num_steps", ",", "1", ")", "\n", ".", "expand", "(", "batch_size", ",", "num_steps", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", "\n", ")", ".", "view", "(", "batch_size", ",", "num_steps", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "self", ".", "problem", ".", "VEHICLE_CAPACITY", "-", "state", ".", "used_capacity", "[", ":", ",", ":", ",", "None", "]", "\n", ")", ",", "\n", "-", "1", "\n", ")", "\n", "", "", "elif", "self", ".", "is_orienteering", "or", "self", ".", "is_pctsp", ":", "\n", "            ", "return", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "gather", "(", "\n", "embeddings", ",", "\n", "1", ",", "\n", "current_node", ".", "contiguous", "(", ")", "\n", ".", "view", "(", "batch_size", ",", "num_steps", ",", "1", ")", "\n", ".", "expand", "(", "batch_size", ",", "num_steps", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", "\n", ")", ".", "view", "(", "batch_size", ",", "num_steps", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "(", "\n", "state", ".", "get_remaining_length", "(", ")", "[", ":", ",", ":", ",", "None", "]", "\n", "if", "self", ".", "is_orienteering", "\n", "else", "state", ".", "get_remaining_prize_to_collect", "(", ")", "[", ":", ",", ":", ",", "None", "]", "\n", ")", "\n", ")", ",", "\n", "-", "1", "\n", ")", "\n", "", "else", ":", "# TSP", "\n", "\n", "            ", "if", "num_steps", "==", "1", ":", "# We need to special case if we have only 1 step, may be the first or not", "\n", "                ", "if", "state", ".", "i", ".", "item", "(", ")", "==", "0", ":", "\n", "# First and only step, ignore prev_a (this is a placeholder)", "\n", "                    ", "return", "self", ".", "W_placeholder", "[", "None", ",", "None", ",", ":", "]", ".", "expand", "(", "batch_size", ",", "1", ",", "self", ".", "W_placeholder", ".", "size", "(", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "                    ", "return", "embeddings", ".", "gather", "(", "\n", "1", ",", "\n", "torch", ".", "cat", "(", "(", "state", ".", "first_a", ",", "current_node", ")", ",", "1", ")", "[", ":", ",", ":", ",", "None", "]", ".", "expand", "(", "batch_size", ",", "2", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", "\n", ")", ".", "view", "(", "batch_size", ",", "1", ",", "-", "1", ")", "\n", "# More than one step, assume always starting with first", "\n", "", "", "embeddings_per_step", "=", "embeddings", ".", "gather", "(", "\n", "1", ",", "\n", "current_node", "[", ":", ",", "1", ":", ",", "None", "]", ".", "expand", "(", "batch_size", ",", "num_steps", "-", "1", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", "\n", ")", "\n", "return", "torch", ".", "cat", "(", "(", "\n", "# First step placeholder, cat in dim 1 (time steps)", "\n", "self", ".", "W_placeholder", "[", "None", ",", "None", ",", ":", "]", ".", "expand", "(", "batch_size", ",", "1", ",", "self", ".", "W_placeholder", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "# Second step, concatenate embedding of first with embedding of current/previous (in dim 2, context dim)", "\n", "torch", ".", "cat", "(", "(", "\n", "embeddings_per_step", "[", ":", ",", "0", ":", "1", ",", ":", "]", ".", "expand", "(", "batch_size", ",", "num_steps", "-", "1", ",", "embeddings", ".", "size", "(", "-", "1", ")", ")", ",", "\n", "embeddings_per_step", "\n", ")", ",", "2", ")", "\n", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._one_to_many_logits": [[481, 525], ["query.size", "query.view().permute", "torch.matmul", "attention_model.AttentionModel.project_out", "torch.matmul", "math.sqrt", "torch.softmax", "torch.matmul.permute().contiguous().view", "torch.matmul().squeeze", "math.sqrt", "attention_model.AttentionModel.squeeze", "query.view", "glimpse_K.transpose", "query.view().permute.size", "final_Q.size", "torch.tanh", "mask[].expand_as", "torch.matmul.permute().contiguous", "torch.matmul", "logit_K.transpose", "torch.matmul.permute"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "", "def", "_one_to_many_logits", "(", "self", ",", "query", ",", "glimpse_K", ",", "glimpse_V", ",", "logit_K", ",", "mask", ")", ":", "\n", "\n", "        ", "batch_size", ",", "num_steps", ",", "embed_dim", "=", "query", ".", "size", "(", ")", "\n", "key_size", "=", "val_size", "=", "embed_dim", "//", "self", ".", "n_heads", "\n", "\n", "# Compute the glimpse, rearrange dimensions so the dimensions are (n_heads, batch_size, num_steps, 1, key_size)", "\n", "glimpse_Q", "=", "query", ".", "view", "(", "batch_size", ",", "num_steps", ",", "self", ".", "n_heads", ",", "1", ",", "key_size", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ",", "3", ",", "4", ")", "\n", "\n", "# Batch matrix multiplication to compute compatibilities (n_heads, batch_size, num_steps, graph_size)", "\n", "compatibility", "=", "torch", ".", "matmul", "(", "glimpse_Q", ",", "glimpse_K", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", "/", "math", ".", "sqrt", "(", "glimpse_Q", ".", "size", "(", "-", "1", ")", ")", "\n", "if", "self", ".", "mask_inner", ":", "\n", "            ", "assert", "self", ".", "mask_logits", ",", "\"Cannot mask inner without masking logits\"", "\n", "compatibility", "[", "mask", "[", "None", ",", ":", ",", ":", ",", "None", ",", ":", "]", ".", "expand_as", "(", "compatibility", ")", "]", "=", "-", "math", ".", "inf", "\n", "\n", "# Batch matrix multiplication to compute heads (n_heads, batch_size, num_steps, val_size)", "\n", "", "heads", "=", "torch", ".", "matmul", "(", "torch", ".", "softmax", "(", "compatibility", ",", "dim", "=", "-", "1", ")", ",", "glimpse_V", ")", "\n", "\n", "# Project to get glimpse/updated context node embedding (batch_size, num_steps, embedding_dim)", "\n", "\n", "glimpse", "=", "self", ".", "project_out", "(", "\n", "heads", ".", "permute", "(", "1", ",", "2", ",", "3", ",", "0", ",", "4", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "num_steps", ",", "1", ",", "self", ".", "n_heads", "*", "val_size", ")", ")", "\n", "\n", "# Now projecting the glimpse is not needed since this can be absorbed into project_out", "\n", "# final_Q = self.project_glimpse(glimpse)", "\n", "final_Q", "=", "glimpse", "\n", "# Batch matrix multiplication to compute logits (batch_size, num_steps, graph_size)", "\n", "# logits = 'compatibility'", "\n", "\n", "\n", "\n", "#         logits2 = self.attn(final_Q.view(final_Q.shape[0],final_Q.shape[2],final_Q.shape[3]),logit_K.transpose(-2, -1))", "\n", "\n", "logits", "=", "torch", ".", "matmul", "(", "final_Q", ",", "logit_K", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", ".", "squeeze", "(", "-", "2", ")", "/", "math", ".", "sqrt", "(", "final_Q", ".", "size", "(", "-", "1", ")", ")", "\n", "#         print(logits2.shape)", "\n", "#         print(logits.shape)", "\n", "#         assert(False)", "\n", "\n", "# From the logits compute the probabilities by clipping, masking and softmax", "\n", "if", "self", ".", "tanh_clipping", ">", "0", ":", "\n", "            ", "logits", "=", "torch", ".", "tanh", "(", "logits", ")", "*", "self", ".", "tanh_clipping", "\n", "", "if", "self", ".", "mask_logits", ":", "\n", "            ", "logits", "[", "mask", "]", "=", "-", "math", ".", "inf", "\n", "\n", "", "return", "logits", ",", "glimpse", ".", "squeeze", "(", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._get_attention_node_data": [[526, 544], ["attention_model.AttentionModel.project_node_step().chunk", "attention_model.AttentionModel.project_node_step", "attention_model.AttentionModel._make_heads", "attention_model.AttentionModel._make_heads", "state.demands_with_depot[].clone"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads", "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads"], ["", "def", "_get_attention_node_data", "(", "self", ",", "fixed", ",", "state", ")", ":", "\n", "\n", "        ", "if", "self", ".", "is_vrp", "and", "self", ".", "allow_partial", ":", "\n", "\n", "# Need to provide information of how much each node has already been served", "\n", "# Clone demands as they are needed by the backprop whereas they are updated later", "\n", "            ", "glimpse_key_step", ",", "glimpse_val_step", ",", "logit_key_step", "=", "self", ".", "project_node_step", "(", "state", ".", "demands_with_depot", "[", ":", ",", ":", ",", ":", ",", "None", "]", ".", "clone", "(", ")", ")", ".", "chunk", "(", "3", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Projection of concatenation is equivalent to addition of projections but this is more efficient", "\n", "return", "(", "\n", "fixed", ".", "glimpse_key", "+", "self", ".", "_make_heads", "(", "glimpse_key_step", ")", ",", "\n", "fixed", ".", "glimpse_val", "+", "self", ".", "_make_heads", "(", "glimpse_val_step", ")", ",", "\n", "fixed", ".", "logit_key", "+", "logit_key_step", ",", "\n", ")", "\n", "\n", "# TSP or VRP without split delivery", "\n", "", "return", "fixed", ".", "glimpse_key", ",", "fixed", ".", "glimpse_val", ",", "fixed", ".", "logit_key", "\n", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.AttentionModel._make_heads": [[545, 552], ["v.contiguous().view().expand().permute", "v.size", "v.size", "v.contiguous().view().expand", "v.size", "v.size", "v.contiguous().view", "v.size", "v.size", "v.size", "v.size", "v.contiguous"], "methods", ["home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.expand", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size", "home.repos.pwc.inspect_result.alstn12088_lcp.utils.beam_search.BatchBeam.size"], ["", "def", "_make_heads", "(", "self", ",", "v", ",", "num_steps", "=", "None", ")", ":", "\n", "        ", "assert", "num_steps", "is", "None", "or", "v", ".", "size", "(", "1", ")", "==", "1", "or", "v", ".", "size", "(", "1", ")", "==", "num_steps", "\n", "\n", "return", "(", "\n", "v", ".", "contiguous", "(", ")", ".", "view", "(", "v", ".", "size", "(", "0", ")", ",", "v", ".", "size", "(", "1", ")", ",", "v", ".", "size", "(", "2", ")", ",", "self", ".", "n_heads", ",", "-", "1", ")", "\n", ".", "expand", "(", "v", ".", "size", "(", "0", ")", ",", "v", ".", "size", "(", "1", ")", "if", "num_steps", "is", "None", "else", "num_steps", ",", "v", ".", "size", "(", "2", ")", ",", "self", ".", "n_heads", ",", "-", "1", ")", "\n", ".", "permute", "(", "3", ",", "0", ",", "1", ",", "2", ",", "4", ")", "# (n_heads, batch_size, num_steps, graph_size, head_dim)", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.set_decode_type": [[14, 18], ["isinstance", "model.set_decode_type"], "function", ["home.repos.pwc.inspect_result.alstn12088_lcp.nets.attention_model.set_decode_type"], ["def", "set_decode_type", "(", "model", ",", "decode_type", ")", ":", "\n", "    ", "if", "isinstance", "(", "model", ",", "DataParallel", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "", "model", ".", "set_decode_type", "(", "decode_type", ")", "\n", "\n"]]}