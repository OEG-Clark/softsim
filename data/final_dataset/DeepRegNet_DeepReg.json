{"home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.TestDemo.test_single_config_demo": [[87, 116], ["pytest.mark.parametrize", "test_demos.remove_files", "test_demos.execute_commands", "test_demos.check_files", "test_demos.execute_commands", "test_demos.check_vis_single_config_demo"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.remove_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_vis_single_config_demo"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name\"", ",", "\n", "[", "\n", "\"grouped_mask_prostate_longitudinal\"", ",", "\n", "\"grouped_mr_heart\"", ",", "\n", "\"paired_ct_lung\"", ",", "\n", "\"paired_mrus_brain\"", ",", "\n", "\"paired_mrus_prostate\"", ",", "\n", "\"unpaired_ct_lung\"", ",", "\n", "\"unpaired_mr_brain\"", ",", "\n", "\"unpaired_us_prostate_cv\"", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_single_config_demo", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"each demo has one single configuration file\"\"\"", "\n", "remove_files", "(", "name", ")", "\n", "\n", "# execute data", "\n", "cmds", "=", "[", "f\"python demos/{name}/demo_data.py\"", "]", "\n", "execute_commands", "(", "cmds", ")", "\n", "\n", "# check temporary files are removed", "\n", "check_files", "(", "name", ")", "\n", "\n", "# execute train, predict sequentially", "\n", "cmds", "=", "[", "f\"python demos/{name}/demo_{x}.py --test\"", "for", "x", "in", "[", "\"train\"", ",", "\"predict\"", "]", "]", "\n", "\n", "execute_commands", "(", "cmds", ")", "\n", "check_vis_single_config_demo", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.TestDemo.test_unpaired_ct_abdomen": [[117, 141], ["pytest.mark.parametrize", "test_demos.remove_files", "test_demos.execute_commands", "test_demos.check_files", "test_demos.execute_commands", "test_demos.check_vis_unpaired_ct_abdomen"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.remove_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_vis_unpaired_ct_abdomen"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"method\"", ",", "\n", "[", "\"comb\"", ",", "\"unsup\"", ",", "\"weakly\"", "]", ",", "\n", ")", "\n", "def", "test_unpaired_ct_abdomen", "(", "self", ",", "method", ")", ":", "\n", "        ", "\"\"\"this demo has multiple configuration file\"\"\"", "\n", "name", "=", "\"unpaired_ct_abdomen\"", "\n", "remove_files", "(", "name", ")", "\n", "\n", "# execute data", "\n", "cmds", "=", "[", "f\"python demos/{name}/demo_data.py\"", "]", "\n", "execute_commands", "(", "cmds", ")", "\n", "\n", "# check temporary files are removed", "\n", "check_files", "(", "name", ")", "\n", "\n", "# execute train, predict sequentially", "\n", "cmds", "=", "[", "\n", "f\"python demos/{name}/demo_{x}.py --method {method} --test\"", "\n", "for", "x", "in", "[", "\"train\"", ",", "\"predict\"", "]", "\n", "]", "\n", "\n", "execute_commands", "(", "cmds", ")", "\n", "check_vis_unpaired_ct_abdomen", "(", "name", ",", "method", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.TestDemo.test_classical_demo": [[142, 164], ["pytest.mark.parametrize", "test_demos.remove_files", "test_demos.execute_commands", "test_demos.check_files", "test_demos.execute_commands", "test_demos.check_vis_classical_demo"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.remove_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_vis_classical_demo"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name\"", ",", "\n", "[", "\n", "\"classical_ct_headneck_affine\"", ",", "\n", "\"classical_mr_prostate_nonrigid\"", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_classical_demo", "(", "self", ",", "name", ")", ":", "\n", "        ", "remove_files", "(", "name", ")", "\n", "\n", "# execute data", "\n", "cmds", "=", "[", "f\"python demos/{name}/demo_data.py\"", "]", "\n", "execute_commands", "(", "cmds", ")", "\n", "\n", "# check temporary files are removed", "\n", "check_files", "(", "name", ")", "\n", "\n", "# execute data, register", "\n", "cmds", "=", "[", "f\"python demos/{name}/demo_register.py --test\"", "]", "\n", "\n", "execute_commands", "(", "cmds", ")", "\n", "check_vis_classical_demo", "(", "name", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.remove_files": [[12, 29], ["os.path.join", "os.listdir", "file.endswith", "os.path.join", "os.path.exists", "os.remove", "shutil.rmtree", "os.path.join"], "function", ["None"], ["def", "remove_files", "(", "name", ")", ":", "\n", "    ", "dir_name", "=", "os", ".", "path", ".", "join", "(", "\"demos\"", ",", "name", ")", "\n", "\n", "# remove zip files", "\n", "files", "=", "os", ".", "listdir", "(", "dir_name", ")", "\n", "for", "file", "in", "files", ":", "\n", "        ", "if", "file", ".", "endswith", "(", "\".zip\"", ")", ":", "\n", "            ", "os", ".", "remove", "(", "os", ".", "path", ".", "join", "(", "dir_name", ",", "file", ")", ")", "\n", "\n", "# remove output folders", "\n", "", "", "paths", "=", "[", "\n", "os", ".", "path", ".", "join", "(", "dir_name", ",", "x", ")", "\n", "for", "x", "in", "[", "\"dataset\"", ",", "\"logs_train\"", ",", "\"logs_predict\"", ",", "\"logs_reg\"", "]", "\n", "]", "\n", "for", "path", "in", "paths", ":", "\n", "        ", "if", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_files": [[31, 42], ["os.path.join", "os.path.exists", "os.listdir", "os.path.join", "len", "x.endswith"], "function", ["None"], ["", "", "", "def", "check_files", "(", "name", ")", ":", "\n", "    ", "\"\"\"make sure dataset folder exist but there is no zip files\"\"\"", "\n", "dir_name", "=", "os", ".", "path", ".", "join", "(", "\"demos\"", ",", "name", ")", "\n", "\n", "# assert dataset folder exists", "\n", "assert", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "dir_name", ",", "\"dataset\"", ")", ")", "\n", "\n", "# assert no zip files", "\n", "files", "=", "os", ".", "listdir", "(", "dir_name", ")", "\n", "files", "=", "[", "x", "for", "x", "in", "files", "if", "x", ".", "endswith", "(", "\".zip\"", ")", "]", "\n", "assert", "len", "(", "files", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_vis_single_config_demo": [[44, 52], ["test_demos.execute_commands", "os.path.exists", "sorted", "sorted", "os.listdir", "os.listdir"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands"], ["", "def", "check_vis_single_config_demo", "(", "name", ")", ":", "\n", "    ", "time_stamp", "=", "sorted", "(", "os", ".", "listdir", "(", "f\"demos/{name}/logs_predict\"", ")", ")", "[", "0", "]", "\n", "pair_number", "=", "sorted", "(", "os", ".", "listdir", "(", "f\"demos/{name}/logs_predict/{time_stamp}/test\"", ")", ")", "[", "-", "1", "]", "\n", "cmd", "=", "[", "\n", "f\"deepreg_vis -m 2 -i 'demos/{name}/logs_predict/{time_stamp}/test/{pair_number}/moving_image.nii.gz, demos/{name}/logs_predict/{time_stamp}/test/{pair_number}/pred_fixed_image.nii.gz, demos/{name}/logs_predict/{time_stamp}/test/{pair_number}/fixed_image.nii.gz' --slice-inds '0,1,2' -s demos/{name}/logs_predict\"", "\n", "]", "\n", "execute_commands", "(", "[", "cmd", "]", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "f\"demos/{name}/logs_predict/visualisation.png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_vis_unpaired_ct_abdomen": [[54, 64], ["test_demos.execute_commands", "os.path.exists", "sorted", "sorted", "os.listdir", "os.listdir"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands"], ["", "def", "check_vis_unpaired_ct_abdomen", "(", "name", ",", "method", ")", ":", "\n", "    ", "time_stamp", "=", "sorted", "(", "os", ".", "listdir", "(", "f\"demos/{name}/logs_predict/{method}\"", ")", ")", "[", "0", "]", "\n", "pair_number", "=", "sorted", "(", "\n", "os", ".", "listdir", "(", "f\"demos/{name}/logs_predict/{method}/{time_stamp}/test\"", ")", "\n", ")", "[", "-", "1", "]", "\n", "cmd", "=", "[", "\n", "f\"deepreg_vis -m 2 -i 'demos/{name}/logs_predict/{method}/{time_stamp}/test/{pair_number}/moving_image.nii.gz, demos/{name}/logs_predict/{method}/{time_stamp}/test/{pair_number}/pred_fixed_image.nii.gz, demos/{name}/logs_predict/{method}/{time_stamp}/test/{pair_number}/fixed_image.nii.gz' --slice-inds '0,1,2' -s demos/{name}/logs_predict\"", "\n", "]", "\n", "execute_commands", "(", "[", "cmd", "]", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "f\"demos/{name}/logs_predict/visualisation.png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.check_vis_classical_demo": [[66, 72], ["test_demos.execute_commands", "os.path.exists"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands"], ["", "def", "check_vis_classical_demo", "(", "name", ")", ":", "\n", "    ", "cmd", "=", "[", "\n", "f\"deepreg_vis -m 2 -i 'demos/{name}/logs_reg/moving_image.nii.gz, demos/{name}/logs_reg/warped_moving_image.nii.gz, demos/{name}/logs_reg/fixed_image.nii.gz' --slice-inds '0,1,2' -s demos/{name}/logs_reg\"", "\n", "]", "\n", "execute_commands", "(", "[", "cmd", "]", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "f\"demos/{name}/logs_reg/visualisation.png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_demos.execute_commands": [[74, 83], ["logger.info", "subprocess.check_output().decode", "logger.info", "RuntimeError", "subprocess.check_output"], "function", ["None"], ["", "def", "execute_commands", "(", "cmds", ")", ":", "\n", "    ", "for", "cmd", "in", "cmds", ":", "\n", "        ", "try", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Running {cmd}\"", ")", "\n", "out", "=", "subprocess", ".", "check_output", "(", "cmd", ",", "shell", "=", "True", ")", ".", "decode", "(", "\"utf-8\"", ")", "\n", "logger", ".", "info", "(", "out", ")", "\n", "", "except", "subprocess", ".", "CalledProcessError", "as", "e", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "f\"Command {cmd} return with err {e.returncode} {e.output}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.TestTutorial.test_registry": [[23, 34], ["pytest.mark.parametrize", "test_examples.execute_commands"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name\"", ",", "\n", "[", "\n", "\"custom_backbone\"", ",", "\n", "\"custom_image_label_loss\"", ",", "\n", "\"custom_parameterized_image_label_loss\"", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_registry", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "cmds", "=", "[", "f\"python examples/{name}.py\"", "]", "\n", "execute_commands", "(", "cmds", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.integration.test_examples.execute_commands": [[10, 19], ["logger.info", "subprocess.check_output().decode", "logger.info", "RuntimeError", "subprocess.check_output"], "function", ["None"], ["def", "execute_commands", "(", "cmds", ")", ":", "\n", "    ", "for", "cmd", "in", "cmds", ":", "\n", "        ", "try", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Running {cmd}\"", ")", "\n", "out", "=", "subprocess", ".", "check_output", "(", "cmd", ",", "shell", "=", "True", ")", ".", "decode", "(", "\"utf-8\"", ")", "\n", "logger", ".", "info", "(", "out", ")", "\n", "", "except", "subprocess", ".", "CalledProcessError", "as", "e", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "f\"Command {cmd} return with err {e.returncode} {e.output}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestPyramidCombination.test_1d": [[54, 64], ["tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "deepreg.pyramid_combination", "test.unit.util.is_equal_tf", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.pyramid_combination", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["    ", "def", "test_1d", "(", "self", ")", ":", "\n", "        ", "weights", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "0.2", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "values", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "\n", "# expected = 1 * 0.2 + 2 * 2", "\n", "expected", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "1.8", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "got", "=", "layer_util", ".", "pyramid_combination", "(", "\n", "values", "=", "values", ",", "weight_floor", "=", "weights", ",", "weight_ceil", "=", "1", "-", "weights", "\n", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestPyramidCombination.test_2d": [[65, 87], ["tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "deepreg.pyramid_combination", "test.unit.util.is_equal_tf", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.pyramid_combination", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_2d", "(", "self", ")", ":", "\n", "        ", "weights", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "0.2", "]", ",", "[", "0.3", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "values", "=", "tf", ".", "constant", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "1", "]", ",", "# value at corner (0, 0), weight = 0.2 * 0.3", "\n", "[", "2", "]", ",", "# value at corner (0, 1), weight = 0.2 * 0.7", "\n", "[", "3", "]", ",", "# value at corner (1, 0), weight = 0.8 * 0.3", "\n", "[", "4", "]", ",", "# value at corner (1, 1), weight = 0.8 * 0.7", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", ")", "\n", "# expected = 1 * 0.2 * 0.3", "\n", "#          + 2 * 0.2 * 0.7", "\n", "#          + 3 * 0.8 * 0.3", "\n", "#          + 4 * 0.8 * 0.7", "\n", "expected", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "3.3", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "got", "=", "layer_util", ".", "pyramid_combination", "(", "\n", "values", "=", "values", ",", "weight_floor", "=", "weights", ",", "weight_ceil", "=", "1", "-", "weights", "\n", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestPyramidCombination.test_error_dim": [[88, 98], ["tensorflow.constant", "tensorflow.constant", "numpy.array", "numpy.array", "pytest.raises", "deepreg.pyramid_combination", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.pyramid_combination"], ["", "def", "test_error_dim", "(", "self", ")", ":", "\n", "        ", "weights", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "[", "0.2", "]", "]", ",", "[", "[", "0.2", "]", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "values", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "1", "]", ",", "[", "2", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "layer_util", ".", "pyramid_combination", "(", "\n", "values", "=", "values", ",", "weight_floor", "=", "weights", ",", "weight_ceil", "=", "1", "-", "weights", "\n", ")", "\n", "", "assert", "(", "\n", "\"In pyramid_combination, elements of values, weight_floor, \"", "\n", "\"and weight_ceil should have same dimension\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestPyramidCombination.test_error_len": [[100, 110], ["tensorflow.constant", "tensorflow.constant", "numpy.array", "numpy.array", "pytest.raises", "deepreg.pyramid_combination", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.pyramid_combination"], ["", "def", "test_error_len", "(", "self", ")", ":", "\n", "        ", "weights", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "0.2", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "values", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "1", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "layer_util", ".", "pyramid_combination", "(", "\n", "values", "=", "values", ",", "weight_floor", "=", "weights", ",", "weight_ceil", "=", "1", "-", "weights", "\n", ")", "\n", "", "assert", "(", "\n", "\"In pyramid_combination, num_dim = len(weight_floor), \"", "\n", "\"len(values) must be 2 ** num_dim\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestLinearResample.test_repeat_extrapolation": [[136, 151], ["pytest.mark.parametrize", "tensorflow.clip_by_value", "tensorflow.clip_by_value", "deepreg.resample", "test.unit.util.is_equal_tf", "tensorflow.repeat", "tensorflow.repeat"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"channel\"", ",", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "def", "test_repeat_extrapolation", "(", "self", ",", "channel", ")", ":", "\n", "        ", "x", "=", "self", ".", "loc", "[", "...", ",", "0", "]", "\n", "y", "=", "self", ".", "loc", "[", "...", ",", "1", "]", "\n", "x", "=", "tf", ".", "clip_by_value", "(", "x", ",", "self", ".", "x_min", ",", "self", ".", "x_max", ")", "\n", "y", "=", "tf", ".", "clip_by_value", "(", "y", ",", "self", ".", "y_min", ",", "self", ".", "y_max", ")", "\n", "expected", "=", "3", "*", "x", "+", "y", "\n", "\n", "vol", "=", "self", ".", "vol", "\n", "if", "channel", ">", "0", ":", "\n", "            ", "vol", "=", "tf", ".", "repeat", "(", "vol", "[", "...", ",", "None", "]", ",", "channel", ",", "axis", "=", "-", "1", ")", "\n", "expected", "=", "tf", ".", "repeat", "(", "expected", "[", "...", ",", "None", "]", ",", "channel", ",", "axis", "=", "-", "1", ")", "\n", "\n", "", "got", "=", "layer_util", ".", "resample", "(", "vol", "=", "vol", ",", "loc", "=", "self", ".", "loc", ",", "zero_boundary", "=", "False", ")", "\n", "assert", "is_equal_tf", "(", "expected", ",", "got", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestLinearResample.test_repeat_zero_bound": [[152, 175], ["pytest.mark.parametrize", "deepreg.resample", "test.unit.util.is_equal_tf", "tensorflow.cast", "tensorflow.cast", "tensorflow.repeat", "tensorflow.repeat", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"channel\"", ",", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "def", "test_repeat_zero_bound", "(", "self", ",", "channel", ")", ":", "\n", "        ", "x", "=", "self", ".", "loc", "[", "...", ",", "0", "]", "\n", "y", "=", "self", ".", "loc", "[", "...", ",", "1", "]", "\n", "expected", "=", "3", "*", "x", "+", "y", "\n", "expected", "=", "(", "\n", "expected", "\n", "*", "tf", ".", "cast", "(", "x", ">", "self", ".", "x_min", ",", "tf", ".", "float32", ")", "\n", "*", "tf", ".", "cast", "(", "x", "<=", "self", ".", "x_max", ",", "tf", ".", "float32", ")", "\n", ")", "\n", "expected", "=", "(", "\n", "expected", "\n", "*", "tf", ".", "cast", "(", "y", ">", "self", ".", "y_min", ",", "tf", ".", "float32", ")", "\n", "*", "tf", ".", "cast", "(", "y", "<=", "self", ".", "y_max", ",", "tf", ".", "float32", ")", "\n", ")", "\n", "\n", "vol", "=", "self", ".", "vol", "\n", "if", "channel", ">", "0", ":", "\n", "            ", "vol", "=", "tf", ".", "repeat", "(", "vol", "[", "...", ",", "None", "]", ",", "channel", ",", "axis", "=", "-", "1", ")", "\n", "expected", "=", "tf", ".", "repeat", "(", "expected", "[", "...", ",", "None", "]", ",", "channel", ",", "axis", "=", "-", "1", ")", "\n", "\n", "", "got", "=", "layer_util", ".", "resample", "(", "vol", "=", "vol", ",", "loc", "=", "self", ".", "loc", ",", "zero_boundary", "=", "True", ")", "\n", "assert", "is_equal_tf", "(", "expected", ",", "got", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestLinearResample.test_shape_error": [[176, 182], ["tensorflow.constant", "tensorflow.constant", "numpy.array", "numpy.array", "pytest.raises", "deepreg.resample", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample"], ["", "def", "test_shape_error", "(", "self", ")", ":", "\n", "        ", "vol", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "0", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "# shape = [1,1]", "\n", "loc", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "# shape = [2,2]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "layer_util", ".", "resample", "(", "vol", "=", "vol", ",", "loc", "=", "loc", ")", "\n", "", "assert", "\"vol shape inconsistent with loc\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestLinearResample.test_interpolation_error": [[183, 190], ["tensorflow.constant", "tensorflow.constant", "numpy.array", "numpy.array", "pytest.raises", "deepreg.resample", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample"], ["", "def", "test_interpolation_error", "(", "self", ")", ":", "\n", "        ", "interpolation", "=", "\"nearest\"", "\n", "vol", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "0", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "# shape = [1,1]", "\n", "loc", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "# shape = [2,2]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "layer_util", ".", "resample", "(", "vol", "=", "vol", ",", "loc", "=", "loc", ",", "interpolation", "=", "interpolation", ")", "\n", "", "assert", "\"resample supports only linear interpolation\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestWarpGrid.test_identical": [[205, 210], ["tensorflow.constant", "deepreg.warp_grid", "test.unit.util.is_equal_tf", "numpy.eye().reshape", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.warp_grid", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["def", "test_identical", "(", "self", ")", ":", "\n", "        ", "theta", "=", "tf", ".", "constant", "(", "np", ".", "eye", "(", "4", ",", "3", ")", ".", "reshape", "(", "(", "1", ",", "4", ",", "3", ")", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "expected", "=", "self", ".", "grid", "[", "None", ",", "...", "]", "# shape = (1, 1, 2, 3, 3)", "\n", "got", "=", "layer_util", ".", "warp_grid", "(", "grid", "=", "self", ".", "grid", ",", "theta", "=", "theta", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestWarpGrid.test_non_identical": [[211, 240], ["tensorflow.constant", "tensorflow.constant", "deepreg.warp_grid", "test.unit.util.is_equal_tf", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.warp_grid", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_non_identical", "(", "self", ")", ":", "\n", "        ", "theta", "=", "tf", ".", "constant", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "\n", "[", "0.86", ",", "0.75", ",", "0.48", "]", ",", "\n", "[", "0.07", ",", "0.98", ",", "0.01", "]", ",", "\n", "[", "0.72", ",", "0.52", ",", "0.97", "]", ",", "\n", "[", "0.12", ",", "0.4", ",", "0.04", "]", ",", "\n", "]", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", ")", "# shape = (1, 4, 3)", "\n", "expected", "=", "tf", ".", "constant", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "\n", "[", "\n", "[", "[", "0.12", ",", "0.4", ",", "0.04", "]", ",", "[", "0.84", ",", "0.92", ",", "1.01", "]", ",", "[", "1.56", ",", "1.44", ",", "1.98", "]", "]", ",", "\n", "[", "[", "0.19", ",", "1.38", ",", "0.05", "]", ",", "[", "0.91", ",", "1.9", ",", "1.02", "]", ",", "[", "1.63", ",", "2.42", ",", "1.99", "]", "]", ",", "\n", "]", "\n", "]", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", ")", "# shape = (1, 1, 2, 3, 3)", "\n", "got", "=", "layer_util", ".", "warp_grid", "(", "grid", "=", "self", ".", "grid", ",", "theta", "=", "theta", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestGaussianFilter3D.test_kernel_size": [[243, 257], ["pytest.mark.parametrize", "deepreg.gaussian_filter_3d"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.gaussian_filter_3d"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"kernel_sigma, kernel_size\"", ",", "\n", "[", "\n", "(", "(", "1", ",", "1", ",", "1", ")", ",", "(", "3", ",", "3", ",", "3", ",", "3", ",", "3", ")", ")", ",", "\n", "(", "(", "2", ",", "2", ",", "2", ")", ",", "(", "7", ",", "7", ",", "7", ",", "3", ",", "3", ")", ")", ",", "\n", "(", "(", "5", ",", "5", ",", "5", ")", ",", "(", "15", ",", "15", ",", "15", ",", "3", ",", "3", ")", ")", ",", "\n", "(", "1", ",", "(", "3", ",", "3", ",", "3", ",", "3", ",", "3", ")", ")", ",", "\n", "(", "2", ",", "(", "7", ",", "7", ",", "7", ",", "3", ",", "3", ")", ")", ",", "\n", "(", "5", ",", "(", "15", ",", "15", ",", "15", ",", "3", ",", "3", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_kernel_size", "(", "self", ",", "kernel_sigma", ",", "kernel_size", ")", ":", "\n", "        ", "filter", "=", "layer_util", ".", "gaussian_filter_3d", "(", "kernel_sigma", ")", "\n", "assert", "filter", ".", "shape", "==", "kernel_size", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestGaussianFilter3D.test_sum": [[258, 265], ["pytest.mark.parametrize", "deepreg.gaussian_filter_3d", "numpy.allclose", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.gaussian_filter_3d"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"kernel_sigma\"", ",", "\n", "[", "(", "1", ",", "1", ",", "1", ")", ",", "(", "2", ",", "2", ",", "2", ")", ",", "(", "5", ",", "5", ",", "5", ")", "]", ",", "\n", ")", "\n", "def", "test_sum", "(", "self", ",", "kernel_sigma", ")", ":", "\n", "        ", "filter", "=", "layer_util", ".", "gaussian_filter_3d", "(", "kernel_sigma", ")", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "sum", "(", "filter", ")", ",", "3", ",", "atol", "=", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestDeconvOutputPadding.test_1d": [[268, 305], ["pytest.mark.parametrize", "deepreg._deconv_output_padding"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util._deconv_output_padding"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"input_shape\"", ",", "\"output_shape\"", ",", "\"kernel_size\"", ",", "\"stride\"", ",", "\"padding\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "5", ",", "5", ",", "3", ",", "1", ",", "\"same\"", ",", "0", ")", ",", "\n", "(", "5", ",", "7", ",", "3", ",", "1", ",", "\"valid\"", ",", "0", ")", ",", "\n", "(", "5", ",", "3", ",", "3", ",", "1", ",", "\"full\"", ",", "0", ")", ",", "\n", "(", "5", ",", "6", ",", "3", ",", "1", ",", "\"same\"", ",", "1", ")", ",", "\n", "(", "5", ",", "8", ",", "3", ",", "1", ",", "\"valid\"", ",", "1", ")", ",", "\n", "(", "5", ",", "4", ",", "3", ",", "1", ",", "\"full\"", ",", "1", ")", ",", "\n", "(", "5", ",", "9", ",", "3", ",", "2", ",", "\"same\"", ",", "0", ")", ",", "\n", "(", "5", ",", "11", ",", "3", ",", "2", ",", "\"valid\"", ",", "0", ")", ",", "\n", "(", "5", ",", "7", ",", "3", ",", "2", ",", "\"full\"", ",", "0", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_1d", "(", "\n", "self", ",", "\n", "input_shape", ":", "int", ",", "\n", "output_shape", ":", "int", ",", "\n", "kernel_size", ":", "int", ",", "\n", "stride", ":", "int", ",", "\n", "padding", ":", "str", ",", "\n", "expected", ":", "int", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test _deconv_output_padding by verifying output\n\n        :param input_shape: shape of Conv3DTranspose input tensor\n        :param output_shape: shape of Conv3DTranspose output tensor\n        :param kernel_size: kernel size of Conv3DTranspose layer\n        :param stride: stride of Conv3DTranspose layer\n        :param padding: padding of Conv3DTranspose layer\n        :param expected: expected output padding for Conv3DTranspose layer\n        \"\"\"", "\n", "got", "=", "layer_util", ".", "_deconv_output_padding", "(", "\n", "input_shape", ",", "output_shape", ",", "kernel_size", ",", "stride", ",", "padding", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestDeconvOutputPadding.test_1d_err": [[306, 311], ["pytest.raises", "deepreg._deconv_output_padding", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util._deconv_output_padding"], ["", "def", "test_1d_err", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test _deconv_output_padding err raising.\"\"\"", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "layer_util", ".", "_deconv_output_padding", "(", "5", ",", "5", ",", "3", ",", "1", ",", "\"x\"", ")", "\n", "", "assert", "\"Unknown padding\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.TestDeconvOutputPadding.test_n_dim": [[312, 346], ["pytest.mark.parametrize", "deepreg.deconv_output_padding"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.deconv_output_padding"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"input_shape\"", ",", "\"output_shape\"", ",", "\"kernel_size\"", ",", "\"stride\"", ",", "\"padding\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "5", ",", "9", ",", "3", ",", "2", ",", "\"same\"", ",", "0", ")", ",", "\n", "(", "(", "5", ",", "5", ")", ",", "(", "9", ",", "10", ")", ",", "3", ",", "2", ",", "\"same\"", ",", "(", "0", ",", "1", ")", ")", ",", "\n", "(", "(", "5", ",", "5", ",", "6", ")", ",", "(", "9", ",", "10", ",", "12", ")", ",", "3", ",", "2", ",", "\"same\"", ",", "(", "0", ",", "1", ",", "1", ")", ")", ",", "\n", "(", "(", "5", ",", "5", ")", ",", "(", "9", ",", "10", ")", ",", "(", "3", ",", "3", ")", ",", "2", ",", "\"same\"", ",", "(", "0", ",", "1", ")", ")", ",", "\n", "(", "(", "5", ",", "5", ")", ",", "(", "9", ",", "10", ")", ",", "3", ",", "(", "2", ",", "2", ")", ",", "\"same\"", ",", "(", "0", ",", "1", ")", ")", ",", "\n", "(", "(", "5", ",", "5", ")", ",", "(", "9", ",", "10", ")", ",", "(", "3", ",", "4", ")", ",", "2", ",", "\"same\"", ",", "(", "0", ",", "2", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_n_dim", "(", "\n", "self", ",", "\n", "input_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "output_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "kernel_size", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "stride", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "padding", ":", "str", ",", "\n", "expected", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test deconv_output_padding by verifying output\n\n        :param input_shape: shape of Conv3DTranspose input tensor\n        :param output_shape: shape of Conv3DTranspose output tensor\n        :param kernel_size: kernel size of Conv3DTranspose layer\n        :param stride: stride of Conv3DTranspose layer\n        :param padding: padding of Conv3DTranspose layer\n        :param expected: expected output padding for Conv3DTranspose layer\n        \"\"\"", "\n", "got", "=", "layer_util", ".", "deconv_output_padding", "(", "\n", "input_shape", ",", "output_shape", ",", "kernel_size", ",", "stride", ",", "padding", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.test_get_reference_grid": [[15, 28], ["tensorflow.constant", "deepreg.get_reference_grid", "test.unit.util.is_equal_tf", "numpy.array"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_reference_grid", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["def", "test_get_reference_grid", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test get_reference_grid by confirming that it generates\n    a sample grid test case to is_equal_tf's tolerance level.\n    \"\"\"", "\n", "want", "=", "tf", ".", "constant", "(", "\n", "np", ".", "array", "(", "\n", "[", "[", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", "]", ",", "[", "0", ",", "0", ",", "2", "]", "]", ",", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "0", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "2", "]", "]", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", ")", "\n", "get", "=", "layer_util", ".", "get_reference_grid", "(", "grid_size", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "assert", "is_equal_tf", "(", "want", ",", "get", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer_util.test_get_n_bits_combinations": [[30, 50], ["deepreg.get_n_bits_combinations", "deepreg.get_n_bits_combinations", "deepreg.get_n_bits_combinations"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_n_bits_combinations", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_n_bits_combinations", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_n_bits_combinations"], ["", "def", "test_get_n_bits_combinations", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test get_n_bits_combinations by confirming that it generates\n    appropriate solutions for 1D, 2D, and 3D cases.\n    \"\"\"", "\n", "# Check n=1 - Pass", "\n", "assert", "layer_util", ".", "get_n_bits_combinations", "(", "1", ")", "==", "[", "[", "0", "]", ",", "[", "1", "]", "]", "\n", "# Check n=2 - Pass", "\n", "assert", "layer_util", ".", "get_n_bits_combinations", "(", "2", ")", "==", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "1", "]", ",", "[", "1", ",", "0", "]", ",", "[", "1", ",", "1", "]", "]", "\n", "\n", "# Check n=3 - Pass", "\n", "assert", "layer_util", ".", "get_n_bits_combinations", "(", "3", ")", "==", "[", "\n", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "1", "]", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_deform.TestGradientNorm.test_call": [[60, 70], ["pytest.mark.parametrize", "tensorflow.ones", "tensorflow.zeros", "test.unit.util.is_equal_tf", "deepreg.GradientNorm"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"l1\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_call", "(", "self", ",", "l1", ")", ":", "\n", "        ", "tensor", "=", "tf", ".", "ones", "(", "[", "4", ",", "50", ",", "50", ",", "50", ",", "3", "]", ")", "\n", "got", "=", "deform", ".", "GradientNorm", "(", "l1", "=", "l1", ")", "(", "tensor", ")", "\n", "expected", "=", "tf", ".", "zeros", "(", "\n", "[", "\n", "4", ",", "\n", "]", "\n", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_deform.TestGradientNorm.test_get_config": [[71, 80], ["deepreg.GradientNorm().get_config", "deepreg.GradientNorm"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "got", "=", "deform", ".", "GradientNorm", "(", ")", ".", "get_config", "(", ")", "\n", "expected", "=", "{", "\n", "\"name\"", ":", "\"GradientNorm\"", ",", "\n", "\"l1\"", ":", "False", ",", "\n", "\"dtype\"", ":", "\"float32\"", ",", "\n", "\"trainable\"", ":", "True", ",", "\n", "}", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_deform.test_gradient_dx": [[14, 20], ["tensorflow.ones", "deepreg.gradient_dx", "tensorflow.zeros", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dx", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["def", "test_gradient_dx", "(", ")", ":", "\n", "    ", "\"\"\"test the calculation of gradient of a 3D images along x-axis\"\"\"", "\n", "tensor", "=", "tf", ".", "ones", "(", "[", "4", ",", "50", ",", "50", ",", "50", "]", ")", "\n", "get", "=", "deform", ".", "gradient_dx", "(", "tensor", ")", "\n", "expect", "=", "tf", ".", "zeros", "(", "[", "4", ",", "48", ",", "48", ",", "48", "]", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_deform.test_gradient_dy": [[22, 28], ["tensorflow.ones", "deepreg.gradient_dy", "tensorflow.zeros", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dy", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_gradient_dy", "(", ")", ":", "\n", "    ", "\"\"\"test the calculation of gradient of a 3D images along y-axis\"\"\"", "\n", "tensor", "=", "tf", ".", "ones", "(", "[", "4", ",", "50", ",", "50", ",", "50", "]", ")", "\n", "get", "=", "deform", ".", "gradient_dy", "(", "tensor", ")", "\n", "expect", "=", "tf", ".", "zeros", "(", "[", "4", ",", "48", ",", "48", ",", "48", "]", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_deform.test_gradient_dz": [[30, 36], ["tensorflow.ones", "deepreg.gradient_dz", "tensorflow.zeros", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_gradient_dz", "(", ")", ":", "\n", "    ", "\"\"\"test the calculation of gradient of a 3D images along z-axis\"\"\"", "\n", "tensor", "=", "tf", ".", "ones", "(", "[", "4", ",", "50", ",", "50", ",", "50", "]", ")", "\n", "get", "=", "deform", ".", "gradient_dz", "(", "tensor", ")", "\n", "expect", "=", "tf", ".", "zeros", "(", "[", "4", ",", "48", ",", "48", ",", "48", "]", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_deform.test_gradient_dxyz": [[38, 57], ["tensorflow.ones", "deepreg.gradient_dxyz", "tensorflow.zeros", "test.unit.util.is_equal_tf", "tensorflow.ones", "deepreg.gradient_dxyz", "tensorflow.zeros", "test.unit.util.is_equal_tf", "tensorflow.ones", "deepreg.gradient_dxyz", "tensorflow.zeros", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_gradient_dxyz", "(", ")", ":", "\n", "    ", "\"\"\"test the calculation of gradient of a 3D images along xyz-axis\"\"\"", "\n", "# gradient_dx", "\n", "tensor", "=", "tf", ".", "ones", "(", "[", "4", ",", "50", ",", "50", ",", "50", ",", "3", "]", ")", "\n", "get", "=", "deform", ".", "gradient_dxyz", "(", "tensor", ",", "deform", ".", "gradient_dx", ")", "\n", "expect", "=", "tf", ".", "zeros", "(", "[", "4", ",", "48", ",", "48", ",", "48", ",", "3", "]", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "\n", "# gradient_dy", "\n", "tensor", "=", "tf", ".", "ones", "(", "[", "4", ",", "50", ",", "50", ",", "50", ",", "3", "]", ")", "\n", "get", "=", "deform", ".", "gradient_dxyz", "(", "tensor", ",", "deform", ".", "gradient_dy", ")", "\n", "expect", "=", "tf", ".", "zeros", "(", "[", "4", ",", "48", ",", "48", ",", "48", ",", "3", "]", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "\n", "# gradient_dz", "\n", "tensor", "=", "tf", ".", "ones", "(", "[", "4", ",", "50", ",", "50", ",", "50", ",", "3", "]", ")", "\n", "get", "=", "deform", ".", "gradient_dxyz", "(", "tensor", ",", "deform", ".", "gradient_dz", ")", "\n", "expect", "=", "tf", ".", "zeros", "(", "[", "4", ",", "48", ",", "48", ",", "48", ",", "3", "]", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_deform.test_bending_energy": [[82, 92], ["tensorflow.ones", "tensorflow.zeros", "test.unit.util.is_equal_tf", "deepreg.BendingEnergy"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "", "def", "test_bending_energy", "(", ")", ":", "\n", "    ", "\"\"\"test the calculation of bending energy\"\"\"", "\n", "tensor", "=", "tf", ".", "ones", "(", "[", "4", ",", "50", ",", "50", ",", "50", ",", "3", "]", ")", "\n", "got", "=", "deform", ".", "BendingEnergy", "(", ")", "(", "tensor", ")", "\n", "expected", "=", "tf", ".", "zeros", "(", "\n", "[", "\n", "4", ",", "\n", "]", "\n", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestRegistrationModel.empty_model": [[112, 132], ["unittest.mock.patch.multiple", "deepreg.model.network.RegistrationModel", "unittest.mock.MagicMock", "unittest.mock.MagicMock", "dict"], "methods", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "empty_model", "(", "self", ",", "labeled", ":", "bool", ")", "->", "RegistrationModel", ":", "\n", "        ", "\"\"\"\n        A RegistrationModel with build_model and build_loss mocked/overwritten.\n\n        :param labeled: whether the data is labeled\n        :return: the mocked object\n        \"\"\"", "\n", "with", "patch", ".", "multiple", "(", "\n", "RegistrationModel", ",", "\n", "build_model", "=", "MagicMock", "(", "return_value", "=", "None", ")", ",", "\n", "build_loss", "=", "MagicMock", "(", "return_value", "=", "None", ")", ",", "\n", ")", ":", "\n", "            ", "return", "RegistrationModel", "(", "\n", "moving_image_size", "=", "moving_image_size", ",", "\n", "fixed_image_size", "=", "fixed_image_size", ",", "\n", "index_size", "=", "index_size", ",", "\n", "labeled", "=", "labeled", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "config", "=", "dict", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestRegistrationModel.test_get_config": [[134, 146], ["empty_model.get_config", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "", "def", "test_get_config", "(", "self", ",", "empty_model", ",", "labeled", ")", ":", "\n", "        ", "got", "=", "empty_model", ".", "get_config", "(", ")", "\n", "expected", "=", "dict", "(", "\n", "moving_image_size", "=", "moving_image_size", ",", "\n", "fixed_image_size", "=", "fixed_image_size", ",", "\n", "index_size", "=", "index_size", ",", "\n", "labeled", "=", "labeled", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "config", "=", "dict", "(", ")", ",", "\n", "name", "=", "\"RegistrationModel\"", ",", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestRegistrationModel.test_build_inputs": [[147, 164], ["empty_model.build_inputs", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.build_inputs"], ["", "def", "test_build_inputs", "(", "self", ",", "empty_model", ",", "labeled", ")", ":", "\n", "        ", "inputs", "=", "empty_model", ".", "build_inputs", "(", ")", "\n", "expected_inputs_len", "=", "5", "if", "labeled", "else", "3", "\n", "assert", "len", "(", "inputs", ")", "==", "expected_inputs_len", "\n", "\n", "moving_image", "=", "inputs", "[", "\"moving_image\"", "]", "\n", "fixed_image", "=", "inputs", "[", "\"fixed_image\"", "]", "\n", "indices", "=", "inputs", "[", "\"indices\"", "]", "\n", "assert", "moving_image", ".", "shape", "==", "(", "batch_size", ",", "*", "moving_image_size", ")", "\n", "assert", "fixed_image", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ")", "\n", "assert", "indices", ".", "shape", "==", "(", "batch_size", ",", "index_size", ")", "\n", "\n", "if", "labeled", ":", "\n", "            ", "moving_label", "=", "inputs", "[", "\"moving_label\"", "]", "\n", "fixed_label", "=", "inputs", "[", "\"fixed_label\"", "]", "\n", "assert", "moving_label", ".", "shape", "==", "(", "batch_size", ",", "*", "moving_image_size", ")", "\n", "assert", "fixed_label", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestRegistrationModel.test_concat_images": [[165, 176], ["empty_model.build_inputs", "empty_model.concat_images", "empty_model.concat_images"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.build_inputs", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.concat_images", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.concat_images"], ["", "", "def", "test_concat_images", "(", "self", ",", "empty_model", ",", "labeled", ")", ":", "\n", "        ", "inputs", "=", "empty_model", ".", "build_inputs", "(", ")", "\n", "moving_image", "=", "inputs", "[", "\"moving_image\"", "]", "\n", "fixed_image", "=", "inputs", "[", "\"fixed_image\"", "]", "\n", "if", "labeled", ":", "\n", "            ", "moving_label", "=", "inputs", "[", "\"moving_label\"", "]", "\n", "images", "=", "empty_model", ".", "concat_images", "(", "moving_image", ",", "fixed_image", ",", "moving_label", ")", "\n", "assert", "images", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ",", "3", ")", "\n", "", "else", ":", "\n", "            ", "images", "=", "empty_model", ".", "concat_images", "(", "moving_image", ",", "fixed_image", ")", "\n", "assert", "images", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestBuildLoss.test_image_loss": [[186, 221], ["copy.deepcopy", "deepreg.registry.REGISTRY.build_model", "copied[].pop", "len", "dict", "[].pop"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.build_model"], ["def", "test_image_loss", "(", "self", ",", "config", ":", "dict", ",", "option", ":", "int", ",", "expected", ":", "int", ")", ":", "\n", "        ", "method", "=", "\"ddf\"", "\n", "backbone", "=", "\"local\"", "\n", "labeled", "=", "True", "\n", "copied", "=", "deepcopy", "(", "config", ")", "\n", "copied", "[", "\"method\"", "]", "=", "method", "\n", "copied", "[", "\"backbone\"", "]", "[", "\"name\"", "]", "=", "backbone", "\n", "copied", "[", "\"backbone\"", "]", "=", "{", "\n", "**", "backbone_args", "[", "backbone", "]", ",", "# type: ignore", "\n", "**", "copied", "[", "\"backbone\"", "]", ",", "\n", "}", "\n", "\n", "if", "option", "==", "0", ":", "\n", "# remove image loss config, so loss is not used", "\n", "            ", "copied", "[", "\"loss\"", "]", ".", "pop", "(", "\"image\"", ")", "\n", "", "elif", "option", "==", "1", ":", "\n", "# set image loss weight to zero, so loss is not used", "\n", "            ", "copied", "[", "\"loss\"", "]", "[", "\"image\"", "]", "[", "\"weight\"", "]", "=", "0.0", "\n", "", "elif", "option", "==", "2", ":", "\n", "# remove image loss weight, so loss is used with default weight 1", "\n", "            ", "copied", "[", "\"loss\"", "]", "[", "\"image\"", "]", ".", "pop", "(", "\"weight\"", ")", "\n", "\n", "", "ddf_model", "=", "REGISTRY", ".", "build_model", "(", "\n", "config", "=", "dict", "(", "\n", "name", "=", "method", ",", "# TODO we store method twice", "\n", "moving_image_size", "=", "moving_image_size", ",", "\n", "fixed_image_size", "=", "fixed_image_size", ",", "\n", "index_size", "=", "index_size", ",", "\n", "labeled", "=", "labeled", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "config", "=", "copied", ",", "\n", ")", "\n", ")", "\n", "\n", "assert", "len", "(", "ddf_model", ".", "_model", ".", "losses", ")", "==", "expected", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestDDFModel.test_build_model": [[231, 247], ["len"], "methods", ["None"], ["def", "test_build_model", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "expected_outputs_len", "=", "3", "if", "labeled", "else", "2", "\n", "if", "backbone", "==", "\"global\"", ":", "\n", "            ", "expected_outputs_len", "+=", "1", "\n", "theta", "=", "model", ".", "_outputs", "[", "\"theta\"", "]", "\n", "assert", "theta", ".", "shape", "==", "(", "batch_size", ",", "4", ",", "3", ")", "\n", "", "assert", "len", "(", "model", ".", "_outputs", ")", "==", "expected_outputs_len", "\n", "\n", "ddf", "=", "model", ".", "_outputs", "[", "\"ddf\"", "]", "\n", "pred_fixed_image", "=", "model", ".", "_outputs", "[", "\"pred_fixed_image\"", "]", "\n", "assert", "ddf", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ",", "3", ")", "\n", "assert", "pred_fixed_image", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ")", "\n", "\n", "if", "labeled", ":", "\n", "            ", "pred_fixed_label", "=", "model", ".", "_outputs", "[", "\"pred_fixed_label\"", "]", "\n", "assert", "pred_fixed_label", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestDDFModel.test_build_loss": [[248, 251], ["len"], "methods", ["None"], ["", "", "def", "test_build_loss", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "expected", "=", "3", "if", "labeled", "else", "2", "\n", "assert", "len", "(", "model", ".", "_model", ".", "losses", ")", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestDDFModel.test_postprocess": [[252, 261], ["model.postprocess", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.postprocess"], ["", "def", "test_postprocess", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "indices", ",", "processed", "=", "model", ".", "postprocess", "(", "\n", "inputs", "=", "model", ".", "_inputs", ",", "outputs", "=", "model", ".", "_outputs", "\n", ")", "\n", "assert", "indices", ".", "shape", "==", "(", "batch_size", ",", "index_size", ")", "\n", "expected", "=", "7", "if", "labeled", "else", "4", "\n", "if", "backbone", "==", "\"global\"", ":", "\n", "            ", "expected", "+=", "1", "\n", "", "assert", "len", "(", "processed", ")", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestDVFModel.test_build_model": [[271, 285], ["len"], "methods", ["None"], ["def", "test_build_model", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "expected_outputs_len", "=", "4", "if", "labeled", "else", "3", "\n", "assert", "len", "(", "model", ".", "_outputs", ")", "==", "expected_outputs_len", "\n", "\n", "dvf", "=", "model", ".", "_outputs", "[", "\"dvf\"", "]", "\n", "ddf", "=", "model", ".", "_outputs", "[", "\"ddf\"", "]", "\n", "pred_fixed_image", "=", "model", ".", "_outputs", "[", "\"pred_fixed_image\"", "]", "\n", "assert", "dvf", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ",", "3", ")", "\n", "assert", "ddf", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ",", "3", ")", "\n", "assert", "pred_fixed_image", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ")", "\n", "\n", "if", "labeled", ":", "\n", "            ", "pred_fixed_label", "=", "model", ".", "_outputs", "[", "\"pred_fixed_label\"", "]", "\n", "assert", "pred_fixed_label", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestDVFModel.test_build_loss": [[286, 289], ["len"], "methods", ["None"], ["", "", "def", "test_build_loss", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "expected", "=", "3", "if", "labeled", "else", "2", "\n", "assert", "len", "(", "model", ".", "_model", ".", "losses", ")", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestDVFModel.test_postprocess": [[290, 297], ["model.postprocess", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.postprocess"], ["", "def", "test_postprocess", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "indices", ",", "processed", "=", "model", ".", "postprocess", "(", "\n", "inputs", "=", "model", ".", "_inputs", ",", "outputs", "=", "model", ".", "_outputs", "\n", ")", "\n", "assert", "indices", ".", "shape", "==", "(", "batch_size", ",", "index_size", ")", "\n", "expected", "=", "8", "if", "labeled", "else", "5", "\n", "assert", "len", "(", "processed", ")", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestConditionalModel.test_build_model": [[307, 311], ["len"], "methods", ["None"], ["def", "test_build_model", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "assert", "len", "(", "model", ".", "_outputs", ")", "==", "1", "\n", "pred_fixed_label", "=", "model", ".", "_outputs", "[", "\"pred_fixed_label\"", "]", "\n", "assert", "pred_fixed_label", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestConditionalModel.test_build_loss": [[312, 314], ["len"], "methods", ["None"], ["", "def", "test_build_loss", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "assert", "len", "(", "model", ".", "_model", ".", "losses", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.TestConditionalModel.test_postprocess": [[315, 321], ["model.postprocess", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.postprocess"], ["", "def", "test_postprocess", "(", "self", ",", "model", ",", "labeled", ",", "backbone", ")", ":", "\n", "        ", "indices", ",", "processed", "=", "model", ".", "postprocess", "(", "\n", "inputs", "=", "model", ".", "_inputs", ",", "outputs", "=", "model", ".", "_outputs", "\n", ")", "\n", "assert", "indices", ".", "shape", "==", "(", "batch_size", ",", "index_size", ")", "\n", "assert", "len", "(", "processed", ")", "==", "5", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.model": [[55, 80], ["copy.deepcopy", "copied[].update", "deepreg.registry.REGISTRY.build_model", "copied[].pop", "dict"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.build_model"], ["@", "pytest", ".", "fixture", "\n", "def", "model", "(", "method", ":", "str", ",", "labeled", ":", "bool", ",", "backbone", ":", "str", ")", "->", "RegistrationModel", ":", "\n", "    ", "\"\"\"\n    A specific registration model object.\n\n    :param method: name of method\n    :param labeled: whether the data is labeled\n    :param backbone: name of backbone\n    :return: the built object\n    \"\"\"", "\n", "copied", "=", "deepcopy", "(", "config", ")", "\n", "copied", "[", "\"method\"", "]", "=", "method", "\n", "copied", "[", "\"backbone\"", "]", "[", "\"name\"", "]", "=", "backbone", "# type: ignore", "\n", "if", "method", "==", "\"conditional\"", ":", "\n", "        ", "copied", "[", "\"backbone\"", "]", ".", "pop", "(", "\"control_points\"", ",", "None", ")", "# type: ignore", "\n", "", "copied", "[", "\"backbone\"", "]", ".", "update", "(", "backbone_args", "[", "backbone", "]", ")", "# type: ignore", "\n", "return", "REGISTRY", ".", "build_model", "(", "# type: ignore", "\n", "config", "=", "dict", "(", "\n", "name", "=", "method", ",", "# TODO we store method twice", "\n", "moving_image_size", "=", "moving_image_size", ",", "\n", "fixed_image_size", "=", "fixed_image_size", ",", "\n", "index_size", "=", "index_size", ",", "\n", "labeled", "=", "labeled", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "config", "=", "copied", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_network.pytest_generate_tests": [[84, 106], ["sorted", "metafunc.parametrize"], "function", ["None"], ["", "def", "pytest_generate_tests", "(", "metafunc", ")", ":", "\n", "    ", "\"\"\"\n    Test parameter generator.\n\n    This function is called once per each test function.\n    It takes the attribute `params` from the test class,\n    and then use the same `params` for all tests inside the class.\n    This is specific for test of registration models only.\n\n    This is modified from the pytest documentation,\n    where their version defined the params for each test function separately.\n\n    https://docs.pytest.org/en/stable/example/parametrize.html#parametrizing-test-methods-through-per-class-configuration\n\n    :param metafunc:\n    :return:\n    \"\"\"", "\n", "#", "\n", "funcarglist", "=", "metafunc", ".", "cls", ".", "params", "\n", "argnames", "=", "sorted", "(", "funcarglist", "[", "0", "]", ")", "\n", "metafunc", ".", "parametrize", "(", "\n", "argnames", ",", "[", "[", "funcargs", "[", "name", "]", "for", "name", "in", "argnames", "]", "for", "funcargs", "in", "funcarglist", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestDataLoader.test_init": [[25, 70], ["pytest.mark.parametrize", "deepreg.dataset.loader.interface.DataLoader", "deepreg.dataset.loader.interface.DataLoader", "deepreg.dataset.loader.interface.DataLoader.close", "pytest.raises", "pytest.raises", "pytest.raises", "pytest.raises", "deepreg.dataset.loader.interface.DataLoader.get_dataset"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.get_dataset"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"labeled,num_indices,sample_label,seed\"", ",", "\n", "[", "\n", "(", "True", ",", "1", ",", "\"all\"", ",", "0", ")", ",", "\n", "(", "False", ",", "1", ",", "\"all\"", ",", "0", ")", ",", "\n", "(", "None", ",", "1", ",", "\"all\"", ",", "0", ")", ",", "\n", "(", "True", ",", "1", ",", "\"sample\"", ",", "0", ")", ",", "\n", "(", "True", ",", "1", ",", "\"all\"", ",", "0", ")", ",", "\n", "(", "True", ",", "1", ",", "None", ",", "0", ")", ",", "\n", "(", "True", ",", "1", ",", "\"sample\"", ",", "None", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_init", "(", "self", ",", "labeled", ",", "num_indices", ",", "sample_label", ",", "seed", ")", ":", "\n", "        ", "\"\"\"\n        Test init function of DataLoader class\n        :param labeled: bool\n        :param num_indices: int\n        :param sample_label: str\n        :param seed: float/int/None\n        :return:\n        \"\"\"", "\n", "DataLoader", "(", "\n", "labeled", "=", "labeled", ",", "\n", "num_indices", "=", "num_indices", ",", "\n", "sample_label", "=", "sample_label", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "\n", "data_loader", "=", "DataLoader", "(", "\n", "labeled", "=", "labeled", ",", "\n", "num_indices", "=", "num_indices", ",", "\n", "sample_label", "=", "sample_label", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "            ", "data_loader", ".", "moving_image_shape", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "            ", "data_loader", ".", "fixed_image_shape", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "            ", "data_loader", ".", "num_samples", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "            ", "data_loader", ".", "get_dataset", "(", ")", "\n", "\n", "", "data_loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestDataLoader.test_get_dataset_and_preprocess": [[71, 156], ["pytest.mark.parametrize", "dict", "deepreg.dataset.loader.paired_loader.PairedDataLoader", "deepreg.dataset.loader.paired_loader.PairedDataLoader.get_dataset_and_preprocess", "deepreg.dataset.loader.paired_loader.PairedDataLoader.get_dataset_and_preprocess.take"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.get_dataset_and_preprocess"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"labeled,moving_shape,fixed_shape,batch_size,data_augmentation\"", ",", "\n", "[", "\n", "(", "True", ",", "(", "9", ",", "9", ",", "9", ")", ",", "(", "9", ",", "9", ",", "9", ")", ",", "1", ",", "{", "}", ")", ",", "\n", "(", "\n", "True", ",", "\n", "(", "9", ",", "9", ",", "9", ")", ",", "\n", "(", "15", ",", "15", ",", "15", ")", ",", "\n", "1", ",", "\n", "{", "\"data_augmentation\"", ":", "{", "\"name\"", ":", "\"affine\"", "}", "}", ",", "\n", ")", ",", "\n", "(", "\n", "True", ",", "\n", "(", "9", ",", "9", ",", "9", ")", ",", "\n", "(", "15", ",", "15", ",", "15", ")", ",", "\n", "1", ",", "\n", "{", "\n", "\"data_augmentation\"", ":", "[", "\n", "{", "\"name\"", ":", "\"affine\"", "}", ",", "\n", "{", "\n", "\"name\"", ":", "\"ddf\"", ",", "\n", "\"field_strength\"", ":", "1", ",", "\n", "\"low_res_size\"", ":", "(", "3", ",", "3", ",", "3", ")", ",", "\n", "}", ",", "\n", "]", ",", "\n", "}", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_get_dataset_and_preprocess", "(", "\n", "self", ",", "labeled", ",", "moving_shape", ",", "fixed_shape", ",", "batch_size", ",", "data_augmentation", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test get_transforms() function. For that, an Abstract Data Loader is created\n        only to set the moving  and fixed shapes that are used in get_transforms().\n        Here we test that the get_transform() returns a function and the shape of\n        the output of this function. See test_preprocess.py for more testing regarding\n        the concrete params.\n\n        :param labeled: bool\n        :param moving_shape: tuple\n        :param fixed_shape: tuple\n        :param batch_size: total number of samples consumed per step, over all devices.\n        :param data_augmentation: dict\n        :return:\n        \"\"\"", "\n", "data_dir_path", "=", "[", "\n", "\"data/test/nifti/paired/train\"", ",", "\n", "\"data/test/nifti/paired/test\"", ",", "\n", "]", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "NiftiFileLoader", ",", "labeled", "=", "True", ",", "sample_label", "=", "\"all\"", ",", "seed", "=", "None", "\n", ")", "\n", "\n", "data_loader", "=", "PairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path", ",", "\n", "fixed_image_shape", "=", "fixed_shape", ",", "\n", "moving_image_shape", "=", "moving_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "\n", "dataset", "=", "data_loader", ".", "get_dataset_and_preprocess", "(", "\n", "training", "=", "True", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "repeat", "=", "True", ",", "\n", "shuffle_buffer_num_batch", "=", "1", ",", "\n", "**", "data_augmentation", ",", "\n", ")", "\n", "\n", "for", "outputs", "in", "dataset", ".", "take", "(", "1", ")", ":", "\n", "            ", "assert", "(", "\n", "outputs", "[", "\"moving_image\"", "]", ".", "shape", "\n", "==", "(", "batch_size", ",", ")", "+", "data_loader", ".", "moving_image_shape", "\n", ")", "\n", "assert", "(", "\n", "outputs", "[", "\"fixed_image\"", "]", ".", "shape", "\n", "==", "(", "batch_size", ",", ")", "+", "data_loader", ".", "fixed_image_shape", "\n", ")", "\n", "assert", "(", "\n", "outputs", "[", "\"moving_label\"", "]", ".", "shape", "\n", "==", "(", "batch_size", ",", ")", "+", "data_loader", ".", "moving_image_shape", "\n", ")", "\n", "assert", "(", "\n", "outputs", "[", "\"fixed_label\"", "]", ".", "shape", "\n", "==", "(", "batch_size", ",", ")", "+", "data_loader", ".", "fixed_image_shape", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestGeneratorDataLoader.test_get_labeled_dataset": [[231, 260], ["pytest.mark.parametrize", "deepreg.dataset.loader.interface.GeneratorDataLoader", "deepreg.dataset.loader.interface.GeneratorDataLoader.__setattr__", "deepreg.dataset.loader.interface.GeneratorDataLoader.get_dataset", "deepreg.dataset.loader.interface.GeneratorDataLoader.get_dataset.as_numpy_iterator", "test_interface.get_arr", "test_interface.get_arr", "range", "all", "test_interface.get_arr", "test_interface.get_arr", "test.unit.util.is_equal_np", "sample.keys"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.get_dataset", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"labeled\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_get_labeled_dataset", "(", "self", ",", "labeled", ":", "bool", ")", ":", "\n", "        ", "\"\"\"\n        Test get_dataset with data loader.\n\n        :param labeled: labeled data or not.\n        \"\"\"", "\n", "sample", "=", "{", "\n", "\"moving_image\"", ":", "get_arr", "(", ")", ",", "\n", "\"fixed_image\"", ":", "get_arr", "(", ")", ",", "\n", "\"indices\"", ":", "[", "1", "]", ",", "\n", "}", "\n", "if", "labeled", ":", "\n", "            ", "sample", "=", "{", "\n", "\"moving_label\"", ":", "get_arr", "(", ")", ",", "\n", "\"fixed_label\"", ":", "get_arr", "(", ")", ",", "\n", "**", "sample", ",", "\n", "}", "\n", "\n", "", "def", "mock_gen", "(", ")", ":", "\n", "            ", "\"\"\"Toy data generator.\"\"\"", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "                ", "yield", "sample", "\n", "\n", "", "", "loader", "=", "GeneratorDataLoader", "(", "labeled", "=", "labeled", ",", "num_indices", "=", "1", ",", "sample_label", "=", "\"all\"", ")", "\n", "loader", ".", "__setattr__", "(", "\"data_generator\"", ",", "mock_gen", ")", "\n", "dataset", "=", "loader", ".", "get_dataset", "(", ")", "\n", "for", "got", "in", "dataset", ".", "as_numpy_iterator", "(", ")", ":", "\n", "            ", "assert", "all", "(", "is_equal_np", "(", "got", "[", "key", "]", ",", "sample", "[", "key", "]", ")", "for", "key", "in", "sample", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestGeneratorDataLoader.test_data_generator": [[261, 319], ["pytest.mark.parametrize", "deepreg.dataset.loader.interface.GeneratorDataLoader", "deepreg.dataset.loader.interface.GeneratorDataLoader.__setattr__", "MockDataLoader", "MockDataLoader", "next", "all", "MockDataLoader", "MockDataLoader", "deepreg.dataset.loader.interface.GeneratorDataLoader.data_generator", "deepreg.dataset.loader.util.normalize_array", "deepreg.dataset.loader.util.normalize_array", "numpy.array", "isinstance", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test.unit.util.is_equal_np", "expected.keys"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.data_generator", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"labeled\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_data_generator", "(", "self", ",", "labeled", ":", "bool", ")", ":", "\n", "        ", "\"\"\"\n        Test data_generator()\n\n        :param labeled: labeled data or not.\n        \"\"\"", "\n", "\n", "class", "MockDataLoader", ":", "\n", "            ", "\"\"\"Toy data loader.\"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "seed", ":", "int", ")", ":", "\n", "                ", "\"\"\"\n                Init.\n\n                :param seed: random seed for numpy.\n                :param kwargs: additional arguments.\n                \"\"\"", "\n", "self", ".", "seed", "=", "seed", "\n", "\n", "", "def", "get_data", "(", "self", ",", "index", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "                ", "\"\"\"\n                Return the dummy array despite of the index.\n\n                :param index: not used\n                :return: dummy array.\n                \"\"\"", "\n", "assert", "isinstance", "(", "index", ",", "int", ")", "\n", "return", "get_arr", "(", "seed", "=", "self", ".", "seed", ")", "\n", "\n", "", "", "def", "mock_sample_index_generator", "(", ")", ":", "\n", "            ", "\"\"\"Toy sample index generator.\"\"\"", "\n", "return", "[", "[", "1", ",", "1", ",", "[", "1", "]", "]", "]", "\n", "\n", "", "loader", "=", "GeneratorDataLoader", "(", "labeled", "=", "labeled", ",", "num_indices", "=", "1", ",", "sample_label", "=", "\"all\"", ")", "\n", "loader", ".", "__setattr__", "(", "\"sample_index_generator\"", ",", "mock_sample_index_generator", ")", "\n", "loader", ".", "loader_moving_image", "=", "MockDataLoader", "(", "seed", "=", "0", ")", "\n", "loader", ".", "loader_fixed_image", "=", "MockDataLoader", "(", "seed", "=", "1", ")", "\n", "if", "labeled", ":", "\n", "            ", "loader", ".", "loader_moving_label", "=", "MockDataLoader", "(", "seed", "=", "2", ")", "\n", "loader", ".", "loader_fixed_label", "=", "MockDataLoader", "(", "seed", "=", "3", ")", "\n", "\n", "# check data loader output", "\n", "", "got", "=", "next", "(", "loader", ".", "data_generator", "(", ")", ")", "\n", "\n", "expected", "=", "{", "\n", "\"moving_image\"", ":", "normalize_array", "(", "get_arr", "(", "seed", "=", "0", ")", ")", ",", "\n", "\"fixed_image\"", ":", "normalize_array", "(", "get_arr", "(", "seed", "=", "1", ")", ")", ",", "\n", "# 0 or -1 is the label index", "\n", "\"indices\"", ":", "np", ".", "array", "(", "[", "1", ",", "0", "]", "if", "labeled", "else", "[", "1", ",", "-", "1", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "}", "\n", "if", "labeled", ":", "\n", "            ", "expected", "=", "{", "\n", "\"moving_label\"", ":", "get_arr", "(", "seed", "=", "2", ")", ",", "\n", "\"fixed_label\"", ":", "get_arr", "(", "seed", "=", "3", ")", ",", "\n", "**", "expected", ",", "\n", "}", "\n", "", "assert", "all", "(", "is_equal_np", "(", "got", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "for", "key", "in", "expected", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestGeneratorDataLoader.test_sample_index_generator": [[320, 324], ["deepreg.dataset.loader.interface.GeneratorDataLoader", "pytest.raises", "deepreg.dataset.loader.interface.GeneratorDataLoader.sample_index_generator"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.sample_index_generator"], ["", "def", "test_sample_index_generator", "(", "self", ")", ":", "\n", "        ", "loader", "=", "GeneratorDataLoader", "(", "labeled", "=", "True", ",", "num_indices", "=", "1", ",", "sample_label", "=", "\"all\"", ")", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "            ", "loader", ".", "sample_index_generator", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestGeneratorDataLoader.test_validate_images_and_labels": [[325, 439], ["pytest.mark.parametrize", "deepreg.dataset.loader.interface.GeneratorDataLoader", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "pytest.raises", "deepreg.dataset.loader.interface.GeneratorDataLoader.validate_images_and_labels", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.validate_images_and_labels"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\n", "\"moving_image_shape\"", ",", "\n", "\"fixed_image_shape\"", ",", "\n", "\"moving_label_shape\"", ",", "\n", "\"fixed_label_shape\"", ",", "\n", "\"err_msg\"", ",", "\n", ")", ",", "\n", "[", "\n", "(", "\n", "None", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "\"moving image and fixed image must not be None\"", ",", "\n", ")", ",", "\n", "(", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "None", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "\"moving image and fixed image must not be None\"", ",", "\n", ")", ",", "\n", "(", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "None", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "\"moving label and fixed label must be both None or non-None\"", ",", "\n", ")", ",", "\n", "(", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "None", ",", "\n", "\"moving label and fixed label must be both None or non-None\"", ",", "\n", ")", ",", "\n", "(", "\n", "(", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "\"Sample [1]'s moving_image's shape should be 3D\"", ",", "\n", ")", ",", "\n", "(", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "\"Sample [1]'s fixed_image's shape should be 3D\"", ",", "\n", ")", ",", "\n", "(", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "\"Sample [1]'s moving_label's shape should be 3D or 4D.\"", ",", "\n", ")", ",", "\n", "(", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ")", ",", "\n", "\"Sample [1]'s fixed_label's shape should be 3D or 4D.\"", ",", "\n", ")", ",", "\n", "(", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ",", "2", ")", ",", "\n", "(", "10", ",", "10", ",", "10", ",", "3", ")", ",", "\n", "\"Sample [1]'s moving image and fixed image \"", "\n", "\"have different numbers of labels.\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_validate_images_and_labels", "(", "\n", "self", ",", "\n", "moving_image_shape", ":", "Optional", "[", "Tuple", "]", ",", "\n", "fixed_image_shape", ":", "Optional", "[", "Tuple", "]", ",", "\n", "moving_label_shape", ":", "Optional", "[", "Tuple", "]", ",", "\n", "fixed_label_shape", ":", "Optional", "[", "Tuple", "]", ",", "\n", "err_msg", ":", "str", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test error messages.\n\n        :param moving_image_shape: None or tuple.\n        :param fixed_image_shape: None or tuple.\n        :param moving_label_shape: None or tuple.\n        :param fixed_label_shape: None or tuple.\n        :param err_msg: message.\n        \"\"\"", "\n", "moving_image", "=", "None", "\n", "fixed_image", "=", "None", "\n", "moving_label", "=", "None", "\n", "fixed_label", "=", "None", "\n", "if", "moving_image_shape", ":", "\n", "            ", "moving_image", "=", "get_arr", "(", "shape", "=", "moving_image_shape", ")", "\n", "", "if", "fixed_image_shape", ":", "\n", "            ", "fixed_image", "=", "get_arr", "(", "shape", "=", "fixed_image_shape", ")", "\n", "", "if", "moving_label_shape", ":", "\n", "            ", "moving_label", "=", "get_arr", "(", "shape", "=", "moving_label_shape", ")", "\n", "", "if", "fixed_label_shape", ":", "\n", "            ", "fixed_label", "=", "get_arr", "(", "shape", "=", "fixed_label_shape", ")", "\n", "", "loader", "=", "GeneratorDataLoader", "(", "labeled", "=", "True", ",", "num_indices", "=", "1", ",", "sample_label", "=", "\"all\"", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "loader", ".", "validate_images_and_labels", "(", "\n", "moving_image", "=", "moving_image", ",", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "moving_label", "=", "moving_label", ",", "\n", "fixed_label", "=", "fixed_label", ",", "\n", "image_indices", "=", "[", "1", "]", ",", "\n", ")", "\n", "", "assert", "err_msg", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestGeneratorDataLoader.test_validate_images_and_labels_range": [[440, 470], ["pytest.mark.parametrize", "deepreg.dataset.loader.interface.GeneratorDataLoader", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "pytest.raises", "deepreg.dataset.loader.interface.GeneratorDataLoader.validate_images_and_labels", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.validate_images_and_labels"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"option\"", ",", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", "\n", "def", "test_validate_images_and_labels_range", "(", "self", ",", "option", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Test error messages related to input range.\n\n        :param option: control which image to modify\n        \"\"\"", "\n", "option_to_name", "=", "{", "\n", "0", ":", "\"moving_image\"", ",", "\n", "1", ":", "\"fixed_image\"", ",", "\n", "2", ":", "\"moving_label\"", ",", "\n", "3", ":", "\"fixed_label\"", ",", "\n", "}", "\n", "input", "=", "{", "\n", "\"moving_image\"", ":", "get_arr", "(", ")", ",", "\n", "\"fixed_image\"", ":", "get_arr", "(", ")", ",", "\n", "\"moving_label\"", ":", "get_arr", "(", ")", ",", "\n", "\"fixed_label\"", ":", "get_arr", "(", ")", ",", "\n", "}", "\n", "name", "=", "option_to_name", "[", "option", "]", "\n", "input", "[", "name", "]", "+=", "1", "\n", "err_msg", "=", "f\"Sample [1]'s {name}'s values are not between [0, 1]\"", "\n", "\n", "loader", "=", "GeneratorDataLoader", "(", "labeled", "=", "True", ",", "num_indices", "=", "1", ",", "sample_label", "=", "\"all\"", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "loader", ".", "validate_images_and_labels", "(", "\n", "image_indices", "=", "[", "1", "]", ",", "\n", "**", "input", ",", "\n", ")", "\n", "", "assert", "err_msg", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestGeneratorDataLoader.test_sample_image_label_unlabeled": [[471, 489], ["deepreg.dataset.loader.interface.GeneratorDataLoader", "next", "dict", "all", "deepreg.dataset.loader.interface.GeneratorDataLoader.sample_image_label", "test_interface.get_arr", "test_interface.get_arr", "numpy.asarray", "test.unit.util.is_equal_np", "test_interface.get_arr", "test_interface.get_arr", "dict.keys"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.sample_image_label", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr"], ["", "def", "test_sample_image_label_unlabeled", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test sample_image_label in unlabeled case.\"\"\"", "\n", "loader", "=", "GeneratorDataLoader", "(", "labeled", "=", "False", ",", "num_indices", "=", "1", ",", "sample_label", "=", "\"all\"", ")", "\n", "got", "=", "next", "(", "\n", "loader", ".", "sample_image_label", "(", "\n", "moving_image", "=", "get_arr", "(", "seed", "=", "0", ")", ",", "\n", "fixed_image", "=", "get_arr", "(", "seed", "=", "1", ")", ",", "\n", "moving_label", "=", "None", ",", "\n", "fixed_label", "=", "None", ",", "\n", "image_indices", "=", "[", "1", "]", ",", "\n", ")", "\n", ")", "\n", "expected", "=", "dict", "(", "\n", "moving_image", "=", "get_arr", "(", "seed", "=", "0", ")", ",", "\n", "fixed_image", "=", "get_arr", "(", "seed", "=", "1", ")", ",", "\n", "indices", "=", "np", ".", "asarray", "(", "[", "1", ",", "-", "1", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", ")", "\n", "assert", "all", "(", "is_equal_np", "(", "got", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "for", "key", "in", "expected", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestGeneratorDataLoader.test_sample_image_label_one_label": [[490, 515], ["pytest.mark.parametrize", "deepreg.dataset.loader.interface.GeneratorDataLoader", "next", "dict", "all", "deepreg.dataset.loader.interface.GeneratorDataLoader.sample_image_label", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "numpy.asarray", "test.unit.util.is_equal_np", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "dict.keys"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.sample_image_label", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"shape\"", ",", "[", "(", "2", ",", "3", ",", "4", ")", ",", "(", "2", ",", "3", ",", "4", ",", "1", ")", "]", ")", "\n", "def", "test_sample_image_label_one_label", "(", "self", ",", "shape", ":", "Tuple", ")", ":", "\n", "        ", "\"\"\"\n        Test sample_image_label in labeled case with one label.\n\n        :param shape: shape of the label.\n        \"\"\"", "\n", "loader", "=", "GeneratorDataLoader", "(", "labeled", "=", "True", ",", "num_indices", "=", "1", ",", "sample_label", "=", "\"all\"", ")", "\n", "got", "=", "next", "(", "\n", "loader", ".", "sample_image_label", "(", "\n", "moving_image", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "0", ")", ",", "\n", "fixed_image", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "1", ")", ",", "\n", "moving_label", "=", "get_arr", "(", "shape", "=", "shape", ",", "seed", "=", "2", ")", ",", "\n", "fixed_label", "=", "get_arr", "(", "shape", "=", "shape", ",", "seed", "=", "3", ")", ",", "\n", "image_indices", "=", "[", "1", "]", ",", "\n", ")", "\n", ")", "\n", "expected", "=", "dict", "(", "\n", "moving_image", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "0", ")", ",", "\n", "fixed_image", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "1", ")", ",", "\n", "moving_label", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "2", ")", ",", "\n", "fixed_label", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "3", ")", ",", "\n", "indices", "=", "np", ".", "asarray", "(", "[", "1", ",", "0", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", ")", "\n", "assert", "all", "(", "is_equal_np", "(", "got", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "for", "key", "in", "expected", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.TestGeneratorDataLoader.test_sample_image_label_multiple_labels": [[516, 539], ["deepreg.dataset.loader.interface.GeneratorDataLoader", "deepreg.dataset.loader.interface.GeneratorDataLoader.sample_image_label", "test_interface.get_arr", "test_interface.get_arr", "range", "next", "dict", "all", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "test_interface.get_arr", "numpy.asarray", "test.unit.util.is_equal_np", "dict.keys"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.sample_image_label", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["", "def", "test_sample_image_label_multiple_labels", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test sample_image_label in labeled case with multiple labels.\"\"\"", "\n", "loader", "=", "GeneratorDataLoader", "(", "labeled", "=", "True", ",", "num_indices", "=", "1", ",", "sample_label", "=", "\"all\"", ")", "\n", "shape", "=", "(", "2", ",", "3", ",", "4", ",", "5", ")", "\n", "got_iter", "=", "loader", ".", "sample_image_label", "(", "\n", "moving_image", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "0", ")", ",", "\n", "fixed_image", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "1", ")", ",", "\n", "moving_label", "=", "get_arr", "(", "shape", "=", "shape", ",", "seed", "=", "2", ")", ",", "\n", "fixed_label", "=", "get_arr", "(", "shape", "=", "shape", ",", "seed", "=", "3", ")", ",", "\n", "image_indices", "=", "[", "1", "]", ",", "\n", ")", "\n", "moving_label", "=", "get_arr", "(", "shape", "=", "shape", ",", "seed", "=", "2", ")", "\n", "fixed_label", "=", "get_arr", "(", "shape", "=", "shape", ",", "seed", "=", "3", ")", "\n", "for", "i", "in", "range", "(", "shape", "[", "-", "1", "]", ")", ":", "\n", "            ", "got", "=", "next", "(", "got_iter", ")", "\n", "expected", "=", "dict", "(", "\n", "moving_image", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "0", ")", ",", "\n", "fixed_image", "=", "get_arr", "(", "shape", "=", "shape", "[", ":", "3", "]", ",", "seed", "=", "1", ")", ",", "\n", "moving_label", "=", "moving_label", "[", ":", ",", ":", ",", ":", ",", "i", "]", ",", "\n", "fixed_label", "=", "fixed_label", "[", ":", ",", ":", ",", ":", ",", "i", "]", ",", "\n", "indices", "=", "np", ".", "asarray", "(", "[", "1", ",", "i", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", ")", "\n", "assert", "all", "(", "is_equal_np", "(", "got", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "for", "key", "in", "expected", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.test_abstract_paired_data_loader": [[159, 191], ["deepreg.dataset.loader.interface.AbstractPairedDataLoader", "pytest.raises", "deepreg.dataset.loader.interface.AbstractPairedDataLoader", "str"], "function", ["None"], ["", "", "", "def", "test_abstract_paired_data_loader", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the functions in AbstractPairedDataLoader\n    \"\"\"", "\n", "moving_image_shape", "=", "(", "8", ",", "8", ",", "4", ")", "\n", "fixed_image_shape", "=", "(", "6", ",", "6", ",", "4", ")", "\n", "\n", "# test init invalid shape", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "        ", "AbstractPairedDataLoader", "(", "\n", "moving_image_shape", "=", "(", "2", ",", "2", ")", ",", "\n", "fixed_image_shape", "=", "(", "3", ",", "3", ")", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"sample\"", ",", "\n", ")", "\n", "", "assert", "\"moving_image_shape and fixed_image_shape have length of three\"", "in", "str", "(", "\n", "err_info", ".", "value", "\n", ")", "\n", "\n", "# test init valid shapes", "\n", "data_loader", "=", "AbstractPairedDataLoader", "(", "\n", "moving_image_shape", "=", "moving_image_shape", ",", "\n", "fixed_image_shape", "=", "fixed_image_shape", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"sample\"", ",", "\n", ")", "\n", "\n", "# test properties", "\n", "assert", "data_loader", ".", "num_indices", "==", "2", "\n", "assert", "data_loader", ".", "moving_image_shape", "==", "moving_image_shape", "\n", "assert", "data_loader", ".", "fixed_image_shape", "==", "fixed_image_shape", "\n", "assert", "data_loader", ".", "num_samples", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.test_abstract_unpaired_data_loader": [[193, 216], ["deepreg.dataset.loader.interface.AbstractUnpairedDataLoader", "pytest.raises", "deepreg.dataset.loader.interface.AbstractUnpairedDataLoader", "str"], "function", ["None"], ["", "def", "test_abstract_unpaired_data_loader", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the functions in AbstractUnpairedDataLoader\n    \"\"\"", "\n", "image_shape", "=", "(", "8", ",", "8", ",", "4", ")", "\n", "\n", "# test init invalid shape", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "        ", "AbstractUnpairedDataLoader", "(", "\n", "image_shape", "=", "(", "2", ",", "2", ")", ",", "labeled", "=", "True", ",", "sample_label", "=", "\"sample\"", "\n", ")", "\n", "", "assert", "\"image_shape has to be length of three\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n", "# test init valid shapes", "\n", "data_loader", "=", "AbstractUnpairedDataLoader", "(", "\n", "image_shape", "=", "image_shape", ",", "labeled", "=", "True", ",", "sample_label", "=", "\"sample\"", "\n", ")", "\n", "\n", "# test properties", "\n", "assert", "data_loader", ".", "num_indices", "==", "3", "\n", "assert", "data_loader", ".", "moving_image_shape", "==", "image_shape", "\n", "assert", "data_loader", ".", "fixed_image_shape", "==", "image_shape", "\n", "assert", "data_loader", ".", "num_samples", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.get_arr": [[218, 228], ["numpy.random.seed", "numpy.random.random().astype", "numpy.random.random"], "function", ["None"], ["", "def", "get_arr", "(", "shape", ":", "Tuple", "=", "(", "2", ",", "3", ",", "4", ")", ",", "seed", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Return a random array.\n\n    :param shape: shape of array.\n    :param seed: random seed.\n    :return: random array.\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "return", "np", ".", "random", ".", "random", "(", "size", "=", "shape", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_interface.test_file_loader": [[541, 594], ["deepreg.dataset.loader.interface.FileLoader", "deepreg.dataset.loader.interface.FileLoader", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader", "str", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.set_data_structure", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.set_group_structure", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.get_data", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.get_data_ids", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.get_num_images", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.close", "deepreg.dataset.loader.interface.FileLoader.get_num_groups", "deepreg.dataset.loader.interface.FileLoader.get_num_images_per_group", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.get_num_images_per_group", "str", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.get_num_groups", "pytest.raises", "deepreg.dataset.loader.interface.FileLoader.get_num_images_per_group"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.set_data_structure", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.set_group_structure", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_groups", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images_per_group", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images_per_group", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_groups", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images_per_group"], ["", "", "", "def", "test_file_loader", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the functions in FileLoader\n    \"\"\"", "\n", "# init, no error means passed", "\n", "loader_grouped", "=", "FileLoader", "(", "\n", "dir_paths", "=", "[", "\"/path/grouped_loader/\"", "]", ",", "name", "=", "\"grouped_loader\"", ",", "grouped", "=", "True", "\n", ")", "\n", "loader_ungrouped", "=", "FileLoader", "(", "\n", "dir_paths", "=", "[", "\"/path/ungrouped_loader/\"", "]", ",", "name", "=", "\"ungrouped_loader\"", ",", "grouped", "=", "False", "\n", ")", "\n", "\n", "# init fails with repeated paths", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "        ", "FileLoader", "(", "\n", "dir_paths", "=", "[", "\"/path/ungrouped_loader/\"", ",", "\"/path/ungrouped_loader/\"", "]", ",", "\n", "name", "=", "\"ungrouped_loader\"", ",", "\n", "grouped", "=", "False", ",", "\n", ")", "\n", "", "assert", "\"dir_paths have repeated elements\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n", "# not implemented properties / functions", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "loader_grouped", ".", "set_data_structure", "(", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "loader_grouped", ".", "set_group_structure", "(", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "loader_grouped", ".", "get_data", "(", "1", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "loader_grouped", ".", "get_data_ids", "(", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "loader_grouped", ".", "get_num_images", "(", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "loader_grouped", ".", "close", "(", ")", "\n", "\n", "# test grouped file loader functions", "\n", "", "assert", "loader_grouped", ".", "group_struct", "is", "None", "\n", "\n", "# create mock group structure with nested list", "\n", "loader_grouped", ".", "group_struct", "=", "[", "[", "1", ",", "2", "]", ",", "[", "3", ",", "4", "]", ",", "[", "5", ",", "6", "]", "]", "\n", "assert", "loader_grouped", ".", "get_num_groups", "(", ")", "==", "3", "\n", "assert", "loader_grouped", ".", "get_num_images_per_group", "(", ")", "==", "[", "2", ",", "2", ",", "2", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "        ", "loader_grouped", ".", "group_struct", "=", "[", "[", "]", ",", "[", "3", ",", "4", "]", ",", "[", "5", ",", "6", "]", "]", "\n", "loader_grouped", ".", "get_num_images_per_group", "(", ")", "\n", "", "assert", "\"Groups of ID [0, 2, 2] are empty.\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n", "# test ungrouped file loader", "\n", "assert", "loader_ungrouped", ".", "group_struct", "is", "None", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "loader_ungrouped", ".", "get_num_groups", "(", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "loader_ungrouped", ".", "get_num_images_per_group", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_predict.test_build_pair_output_path": [[14, 39], ["deepreg.predict.build_pair_output_path", "os.path.exists", "os.path.exists", "shutil.rmtree", "deepreg.predict.build_pair_output_path", "os.path.exists", "os.path.exists", "shutil.rmtree"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.build_pair_output_path", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.build_pair_output_path"], ["def", "test_build_pair_output_path", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test build_config for labeled and unlabeled cases\n    \"\"\"", "\n", "\n", "save_dir", "=", "\"logs/save_dir_example\"", "\n", "\n", "# labeled", "\n", "got", "=", "build_pair_output_path", "(", "indices", "=", "[", "1", ",", "2", ",", "0", "]", ",", "save_dir", "=", "save_dir", ")", "\n", "expected", "=", "(", "\n", "\"logs/save_dir_example/pair_1_2\"", ",", "\n", "\"logs/save_dir_example/pair_1_2/label_0\"", ",", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "assert", "os", ".", "path", ".", "exists", "(", "got", "[", "0", "]", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "got", "[", "1", "]", ")", "\n", "shutil", ".", "rmtree", "(", "got", "[", "0", "]", ")", "\n", "\n", "# unlabeled", "\n", "got", "=", "build_pair_output_path", "(", "indices", "=", "[", "1", ",", "2", ",", "-", "1", "]", ",", "save_dir", "=", "save_dir", ")", "\n", "expected", "=", "(", "\"logs/save_dir_example/pair_1_2\"", ",", "\"logs/save_dir_example/pair_1_2\"", ")", "\n", "assert", "got", "==", "expected", "\n", "assert", "os", ".", "path", ".", "exists", "(", "got", "[", "0", "]", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "got", "[", "1", "]", ")", "\n", "shutil", ".", "rmtree", "(", "got", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_predict.test_build_config": [[41, 60], ["deepreg.predict.build_config", "isinstance", "os.path.join"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.build_config"], ["", "def", "test_build_config", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test build_config and check exp_name setting and checkpoint path verification\n    \"\"\"", "\n", "config_path", "=", "\"config/unpaired_labeled_ddf.yaml\"", "\n", "exp_name", "=", "\"test_build_config\"", "\n", "log_dir", "=", "\"logs\"", "\n", "\n", "# TODO checkpoint path empty", "\n", "\n", "# checkpoint path ends with ckpt", "\n", "got_config", ",", "got_log_dir", ",", "_", "=", "build_config", "(", "\n", "config_path", "=", "config_path", ",", "\n", "log_dir", "=", "log_dir", ",", "\n", "exp_name", "=", "exp_name", ",", "\n", "ckpt_path", "=", "\"example.ckpt\"", ",", "\n", ")", "\n", "assert", "isinstance", "(", "got_config", ",", "dict", ")", "\n", "assert", "got_log_dir", "==", "os", ".", "path", ".", "join", "(", "log_dir", ",", "exp_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_predict.test_predict_on_dataset": [[62, 65], ["None"], "function", ["None"], ["", "def", "test_predict_on_dataset", "(", ")", ":", "\n", "# predict_on_dataset is tested in test_train/test_train_and_predict", "\n", "    ", "pass", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_paired_loader.test_init": [[21, 60], ["FileLoaderDict.items", "dict", "deepreg.dataset.loader.paired_loader.PairedDataLoader", "file_loader", "isinstance", "isinstance", "isinstance", "isinstance", "deepreg.dataset.loader.paired_loader.PairedDataLoader.close", "os.path.join", "os.path.join", "type", "type", "type", "type", "pytest.raises", "deepreg.dataset.loader.paired_loader.PairedDataLoader"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["def", "test_init", "(", ")", ":", "\n", "    ", "\"\"\"\n    Check that data loader __init__() method is correct:\n    \"\"\"", "\n", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "data_dir_path", "=", "[", "\n", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "\"train\"", ")", ",", "\n", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "\"test\"", ")", ",", "\n", "]", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "labeled", "=", "True", ",", "sample_label", "=", "\"all\"", ",", "seed", "=", "None", "\n", ")", "\n", "data_loader", "=", "PairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path", ",", "\n", "fixed_image_shape", "=", "fixed_image_shape", ",", "\n", "moving_image_shape", "=", "moving_image_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "\n", "# Check that file loaders are initialized correctly", "\n", "file_loader_method", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_path", ",", "name", "=", "\"moving_images\"", ",", "grouped", "=", "False", "\n", ")", "\n", "assert", "isinstance", "(", "data_loader", ".", "loader_moving_image", ",", "type", "(", "file_loader_method", ")", ")", "\n", "assert", "isinstance", "(", "data_loader", ".", "loader_fixed_image", ",", "type", "(", "file_loader_method", ")", ")", "\n", "assert", "isinstance", "(", "data_loader", ".", "loader_moving_label", ",", "type", "(", "file_loader_method", ")", ")", "\n", "assert", "isinstance", "(", "data_loader", ".", "loader_fixed_label", ",", "type", "(", "file_loader_method", ")", ")", "\n", "\n", "data_loader", ".", "close", "(", ")", "\n", "\n", "# Check the data_dir_path variable assertion error.", "\n", "data_dir_path_int", "=", "[", "0", ",", "\"1\"", ",", "2", ",", "3", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "PairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path_int", ",", "\n", "fixed_image_shape", "=", "fixed_image_shape", ",", "\n", "moving_image_shape", "=", "moving_image_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_paired_loader.test_validate_data_files_label": [[63, 88], ["FileLoaderDict.items", "dict", "deepreg.dataset.loader.paired_loader.PairedDataLoader", "deepreg.dataset.loader.paired_loader.PairedDataLoader.close", "os.path.join", "deepreg.dataset.loader.paired_loader.PairedDataLoader.validate_data_files"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.validate_data_files"], ["", "", "", "def", "test_validate_data_files_label", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the validate_data_files functions\n    that looks for inconsistencies in the fixed/moving image and label lists.\n    If there is any issue it will raise an error, otherwise it returns None.\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "            ", "data_dir_path", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "split", ")", "]", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "seed", "=", "None", "if", "split", "==", "\"train\"", "else", "0", ",", "\n", ")", "\n", "\n", "data_loader", "=", "PairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path", ",", "\n", "fixed_image_shape", "=", "fixed_image_shape", ",", "\n", "moving_image_shape", "=", "moving_image_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "\n", "assert", "data_loader", ".", "validate_data_files", "(", ")", "is", "None", "\n", "data_loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_paired_loader.test_sample_index_generator": [[90, 132], ["FileLoaderDict.items", "os.path.join", "deepreg.dataset.loader.paired_loader.PairedDataLoader", "deepreg.dataset.loader.paired_loader.PairedDataLoader.sample_index_generator", "indices_to_compare.append", "deepreg.dataset.loader.paired_loader.PairedDataLoader.close", "numpy.allclose", "isinstance", "isinstance", "isinstance", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.sample_index_generator", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "", "def", "test_sample_index_generator", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test to check the randomness and deterministic index generator\n    for train/test respectively.\n    \"\"\"", "\n", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "            ", "data_dir_path", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "split", ")", "]", "\n", "indices_to_compare", "=", "[", "]", "\n", "\n", "for", "seed", "in", "[", "0", ",", "1", ",", "0", "]", ":", "\n", "                ", "data_loader", "=", "PairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path", ",", "\n", "fixed_image_shape", "=", "fixed_image_shape", ",", "\n", "moving_image_shape", "=", "moving_image_shape", ",", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "\n", "data_indices", "=", "[", "]", "\n", "for", "(", "\n", "moving_index", ",", "\n", "fixed_index", ",", "\n", "indices", ",", "\n", ")", "in", "data_loader", ".", "sample_index_generator", "(", ")", ":", "\n", "                    ", "assert", "isinstance", "(", "moving_index", ",", "int", ")", "\n", "assert", "isinstance", "(", "fixed_index", ",", "int", ")", "\n", "assert", "isinstance", "(", "indices", ",", "list", ")", "\n", "assert", "moving_index", "==", "fixed_index", "\n", "data_indices", "+=", "indices", "\n", "\n", "", "indices_to_compare", ".", "append", "(", "data_indices", ")", "\n", "data_loader", ".", "close", "(", ")", "\n", "\n", "", "if", "data_loader", ".", "num_images", ">", "1", ":", "\n", "# test different seeds give different indices", "\n", "                ", "assert", "not", "(", "np", ".", "allclose", "(", "indices_to_compare", "[", "0", "]", ",", "indices_to_compare", "[", "1", "]", ")", ")", "\n", "# test same seeds give the same indices", "\n", "assert", "np", ".", "allclose", "(", "indices_to_compare", "[", "0", "]", ",", "indices_to_compare", "[", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_paired_loader.test_close": [[134, 162], ["FileLoaderDict.items", "dict", "deepreg.dataset.loader.paired_loader.PairedDataLoader", "os.path.join", "deepreg.dataset.loader.paired_loader.PairedDataLoader.close", "deepreg.dataset.loader.paired_loader.PairedDataLoader.loader_moving_image.h5_files.values", "f.__bool__"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "", "", "def", "test_close", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the close function. Only needed for H5 data loaders for now.\n    Since fixed/moving loaders are the same for\n    unpaired data loader, only need to test the moving.\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "\n", "            ", "data_dir_path", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "split", ")", "]", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "seed", "=", "None", "if", "split", "==", "\"train\"", "else", "0", ",", "\n", ")", "\n", "\n", "data_loader", "=", "PairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path", ",", "\n", "fixed_image_shape", "=", "fixed_image_shape", ",", "\n", "moving_image_shape", "=", "moving_image_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "\n", "if", "key_file_loader", "==", "\"h5\"", ":", "\n", "                ", "data_loader", ".", "close", "(", ")", "\n", "for", "f", "in", "data_loader", ".", "loader_moving_image", ".", "h5_files", ".", "values", "(", ")", ":", "\n", "                    ", "assert", "not", "f", ".", "__bool__", "(", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_interface.test_backbone_interface": [[9, 22], ["dict", "deepreg.Backbone", "backbone.Backbone.get_config"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["def", "test_backbone_interface", "(", ")", ":", "\n", "    ", "\"\"\"Test the get_config of the interface\"\"\"", "\n", "config", "=", "dict", "(", "\n", "image_size", "=", "(", "5", ",", "5", ",", "5", ")", ",", "\n", "out_channels", "=", "3", ",", "\n", "num_channel_initial", "=", "4", ",", "\n", "out_kernel_initializer", "=", "\"zeros\"", ",", "\n", "out_activation", "=", "\"relu\"", ",", "\n", "name", "=", "\"test\"", ",", "\n", ")", "\n", "model", "=", "backbone", ".", "Backbone", "(", "**", "config", ")", "\n", "got", "=", "model", ".", "get_config", "(", ")", "\n", "assert", "got", "==", "config", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_init": [[55, 170], ["pytest.mark.parametrize", "test_nifti_loader.get_loader", "get_loader.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,expected\"", ",", "\n", "[", "\n", "(", "\n", "\"paired\"", ",", "\n", "[", "\n", "[", "\n", "(", "\"./data/test/nifti/paired/test\"", ",", "\"case000025\"", ",", "\"nii.gz\"", ")", ",", "\n", "(", "\"./data/test/nifti/paired/test\"", ",", "\"case000026\"", ",", "\"nii.gz\"", ")", ",", "\n", "]", ",", "\n", "None", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"unpaired\"", ",", "\n", "[", "\n", "[", "\n", "(", "\"./data/test/nifti/unpaired/test\"", ",", "\"case000025\"", ",", "\"nii.gz\"", ")", ",", "\n", "(", "\"./data/test/nifti/unpaired/test\"", ",", "\"case000026\"", ",", "\"nii\"", ")", ",", "\n", "]", ",", "\n", "None", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"grouped\"", ",", "\n", "[", "\n", "[", "\n", "(", "\n", "\"./data/test/nifti/grouped/test\"", ",", "\n", "\"group1\"", ",", "\n", "\"case000025\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/test\"", ",", "\n", "\"group1\"", ",", "\n", "\"case000026\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", "[", "[", "0", ",", "1", "]", "]", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"multi_dirs_grouped\"", ",", "\n", "[", "\n", "[", "\n", "(", "\n", "\"./data/test/nifti/grouped/test\"", ",", "\n", "\"group1\"", ",", "\n", "\"case000025\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/test\"", ",", "\n", "\"group1\"", ",", "\n", "\"case000026\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/train\"", ",", "\n", "\"group1\"", ",", "\n", "\"case000000\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/train\"", ",", "\n", "\"group1\"", ",", "\n", "\"case000001\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/train\"", ",", "\n", "\"group1\"", ",", "\n", "\"case000003\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/train\"", ",", "\n", "\"group1\"", ",", "\n", "\"case000008\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/train\"", ",", "\n", "\"group2\"", ",", "\n", "\"case000009\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/train\"", ",", "\n", "\"group2\"", ",", "\n", "\"case000011\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"./data/test/nifti/grouped/train\"", ",", "\n", "\"group2\"", ",", "\n", "\"case000012\"", ",", "\n", "\"nii.gz\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", "[", "[", "0", ",", "1", "]", ",", "[", "2", ",", "3", ",", "4", ",", "5", "]", ",", "[", "6", ",", "7", ",", "8", "]", "]", ",", "\n", "]", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_init", "(", "self", ",", "name", ",", "expected", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "got", "=", "[", "\n", "loader", ".", "data_path_splits", ",", "\n", "loader", ".", "group_struct", ",", "\n", "]", "\n", "assert", "got", "==", "expected", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_init_duplicated_dirs": [[171, 189], ["pytest.mark.parametrize", "test_nifti_loader.get_loader", "get_loader.close", "pytest.raises", "deepreg.dataset.loader.nifti_loader.NiftiFileLoader", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name\"", ",", "\n", "[", "\n", "\"paired\"", ",", "\n", "\"unpaired\"", ",", "\n", "\"grouped\"", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_init_duplicated_dirs", "(", "self", ",", "name", ")", ":", "\n", "# duplicated dir_paths", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "dir_paths", "=", "loader", ".", "dir_paths", "*", "2", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "NiftiFileLoader", "(", "\n", "dir_paths", "=", "dir_paths", ",", "name", "=", "loader", ".", "name", ",", "grouped", "=", "loader", ".", "grouped", "\n", ")", "\n", "", "assert", "\"dir_paths have repeated elements\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_set_data_structure_err1": [[190, 204], ["pytest.mark.parametrize", "pytest.raises", "deepreg.dataset.loader.nifti_loader.NiftiFileLoader", "str"], "methods", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,err_msg\"", ",", "\n", "[", "\n", "(", "\n", "\"images\"", ",", "\n", "\"directory ./data/test/h5/paired/test/images does not exist\"", ",", "\n", ")", ",", "# test not existed files", "\n", "]", ",", "\n", ")", "\n", "def", "test_set_data_structure_err1", "(", "self", ",", "name", ",", "err_msg", ")", ":", "\n", "        ", "dir_paths", "=", "[", "\"./data/test/h5/paired/test\"", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", "as", "err_info", ":", "\n", "            ", "NiftiFileLoader", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "name", ",", "grouped", "=", "True", ")", "\n", "", "assert", "err_msg", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_set_data_structure_err2": [[205, 214], ["os.path.join", "os.makedirs", "os.removedirs", "pytest.raises", "deepreg.dataset.loader.nifti_loader.NiftiFileLoader", "str"], "methods", ["None"], ["", "def", "test_set_data_structure_err2", "(", "self", ")", ":", "\n", "        ", "dir_paths", "=", "[", "\"./data/test/nifti/paired/test\"", "]", "\n", "name", "=", "\"error\"", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "dir_paths", "[", "0", "]", ",", "name", ")", "\n", "os", ".", "makedirs", "(", "dir_path", ",", "exist_ok", "=", "True", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "NiftiFileLoader", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "name", ",", "grouped", "=", "False", ")", "\n", "", "assert", "\"No data collected\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "os", ".", "removedirs", "(", "dir_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_get_data": [[215, 238], ["pytest.mark.parametrize", "test_nifti_loader.get_loader", "get_loader.get_data", "test.unit.util.is_equal_np", "get_loader.close", "numpy.shape", "numpy.amax", "numpy.amin", "numpy.mean", "numpy.std"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,index,expected\"", ",", "\n", "[", "\n", "(", "\"paired\"", ",", "0", ",", "[", "(", "44", ",", "59", ",", "41", ")", ",", "[", "255.0", ",", "0.0", ",", "68.359276", ",", "65.84009", "]", "]", ")", ",", "\n", "(", "\"unpaired\"", ",", "0", ",", "[", "(", "64", ",", "64", ",", "60", ")", ",", "[", "255.0", ",", "0.0", ",", "60.073948", ",", "47.27648", "]", "]", ")", ",", "\n", "(", "\"grouped\"", ",", "(", "0", ",", "1", ")", ",", "[", "(", "64", ",", "64", ",", "60", ")", ",", "[", "255.0", ",", "0.0", ",", "85.67942", ",", "49.193127", "]", "]", ")", ",", "\n", "(", "\n", "\"multi_dirs_grouped\"", ",", "\n", "(", "0", ",", "1", ")", ",", "\n", "[", "(", "64", ",", "64", ",", "60", ")", ",", "[", "255.0", ",", "0.0", ",", "85.67942", ",", "49.193127", "]", "]", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_get_data", "(", "self", ",", "name", ",", "index", ",", "expected", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "array", "=", "loader", ".", "get_data", "(", "index", ")", "\n", "got", "=", "[", "\n", "np", ".", "shape", "(", "array", ")", ",", "\n", "[", "np", ".", "amax", "(", "array", ")", ",", "np", ".", "amin", "(", "array", ")", ",", "np", ".", "mean", "(", "array", ")", ",", "np", ".", "std", "(", "array", ")", "]", ",", "\n", "]", "\n", "assert", "got", "[", "0", "]", "==", "expected", "[", "0", "]", "\n", "assert", "is_equal_np", "(", "got", "[", "1", "]", ",", "expected", "[", "1", "]", ")", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_get_data_ids": [[239, 284], ["pytest.mark.parametrize", "test_nifti_loader.get_loader", "get_loader.get_data_ids", "get_loader.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,expected\"", ",", "\n", "[", "\n", "(", "\n", "\"paired\"", ",", "\n", "[", "\n", "(", "\"./data/test/nifti/paired/test\"", ",", "\"case000025\"", ")", ",", "\n", "(", "\"./data/test/nifti/paired/test\"", ",", "\"case000026\"", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"unpaired\"", ",", "\n", "[", "\n", "(", "\"./data/test/nifti/unpaired/test\"", ",", "\"case000025\"", ")", ",", "\n", "(", "\"./data/test/nifti/unpaired/test\"", ",", "\"case000026\"", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"grouped\"", ",", "\n", "[", "\n", "(", "\"./data/test/nifti/grouped/test\"", ",", "\"group1\"", ",", "\"case000025\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/test\"", ",", "\"group1\"", ",", "\"case000026\"", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"multi_dirs_grouped\"", ",", "\n", "[", "\n", "(", "\"./data/test/nifti/grouped/test\"", ",", "\"group1\"", ",", "\"case000025\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/test\"", ",", "\"group1\"", ",", "\"case000026\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/train\"", ",", "\"group1\"", ",", "\"case000000\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/train\"", ",", "\"group1\"", ",", "\"case000001\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/train\"", ",", "\"group1\"", ",", "\"case000003\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/train\"", ",", "\"group1\"", ",", "\"case000008\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/train\"", ",", "\"group2\"", ",", "\"case000009\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/train\"", ",", "\"group2\"", ",", "\"case000011\"", ")", ",", "\n", "(", "\"./data/test/nifti/grouped/train\"", ",", "\"group2\"", ",", "\"case000012\"", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_get_data_ids", "(", "self", ",", "name", ",", "expected", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "got", "=", "loader", ".", "get_data_ids", "(", ")", "\n", "assert", "got", "==", "expected", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_get_data_ids_check_err_with_paired": [[285, 300], ["pytest.mark.parametrize", "test_nifti_loader.get_loader", "get_loader.close", "pytest.raises", "get_loader.get_data"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"index,err_type\"", ",", "\n", "[", "\n", "(", "-", "1", ",", "AssertionError", ")", ",", "\n", "(", "64", ",", "IndexError", ")", ",", "\n", "(", "(", "0", ",", "1", ")", ",", "AssertionError", ")", ",", "\n", "(", "\"wrong\"", ",", "ValueError", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_get_data_ids_check_err_with_paired", "(", "self", ",", "index", ",", "err_type", ")", ":", "\n", "# wrong index for paired", "\n", "        ", "loader", "=", "get_loader", "(", "\"paired\"", ")", "\n", "with", "pytest", ".", "raises", "(", "err_type", ")", ":", "\n", "            ", "loader", ".", "get_data", "(", "index", "=", "index", ")", "\n", "", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_get_data_ids_check_err_with_grouped": [[301, 308], ["test_nifti_loader.get_loader", "get_loader.close", "pytest.raises", "get_loader.get_data"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data"], ["", "def", "test_get_data_ids_check_err_with_grouped", "(", "self", ")", ":", "\n", "# wrong index for paired", "\n", "        ", "loader", "=", "get_loader", "(", "\"grouped\"", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# non-tuple data_index", "\n", "            ", "loader", ".", "get_data", "(", "index", "=", "1", ")", "\n", "", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_get_num_images": [[309, 318], ["pytest.mark.parametrize", "test_nifti_loader.get_loader", "get_loader.get_num_images", "get_loader.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,expected\"", ",", "\n", "[", "(", "\"paired\"", ",", "2", ")", ",", "(", "\"unpaired\"", ",", "2", ")", ",", "(", "\"grouped\"", ",", "2", ")", ",", "(", "\"multi_dirs_grouped\"", ",", "9", ")", "]", ",", "\n", ")", "\n", "def", "test_get_num_images", "(", "self", ",", "name", ",", "expected", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "got", "=", "loader", ".", "get_num_images", "(", ")", "\n", "assert", "got", "==", "expected", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.TestNiftiFileLoader.test_close": [[319, 330], ["pytest.mark.parametrize", "test_nifti_loader.get_loader", "get_loader.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name\"", ",", "\n", "[", "\n", "\"paired\"", ",", "\n", "\"unpaired\"", ",", "\n", "\"grouped\"", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_close", "(", "self", ",", "name", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "loader", ".", "close", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.get_loader": [[13, 33], ["deepreg.dataset.loader.nifti_loader.NiftiFileLoader"], "function", ["None"], ["def", "get_loader", "(", "loader_name", ")", ":", "\n", "    ", "if", "loader_name", "in", "[", "\n", "\"paired\"", ",", "\n", "\"unpaired\"", ",", "\n", "\"grouped\"", ",", "\n", "]", ":", "\n", "        ", "dir_paths", "=", "[", "f\"./data/test/nifti/{loader_name}/test\"", "]", "\n", "name", "=", "\"fixed_images\"", "if", "loader_name", "==", "\"paired\"", "else", "\"images\"", "\n", "grouped", "=", "loader_name", "==", "\"grouped\"", "\n", "", "elif", "loader_name", "==", "\"multi_dirs_grouped\"", ":", "\n", "        ", "dir_paths", "=", "[", "\n", "\"./data/test/nifti/grouped/train\"", ",", "\n", "\"./data/test/nifti/grouped/test\"", ",", "\n", "]", "\n", "name", "=", "\"images\"", "\n", "grouped", "=", "True", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "", "loader", "=", "NiftiFileLoader", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "name", ",", "grouped", "=", "grouped", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.test_load_nifti_file": [[35, 45], ["pytest.mark.parametrize", "deepreg.dataset.loader.nifti_loader.load_nifti_file"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"path,shape\"", ",", "\n", "[", "\n", "(", "\"./data/test/nifti/paired/test/fixed_images/case000026.nii.gz\"", ",", "(", "44", ",", "59", ",", "41", ")", ")", ",", "\n", "(", "\"./data/test/nifti/unit_test/case000026.nii\"", ",", "(", "44", ",", "59", ",", "41", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_load_nifti_file", "(", "path", ",", "shape", ")", ":", "\n", "    ", "arr", "=", "load_nifti_file", "(", "file_path", "=", "path", ")", "\n", "assert", "arr", ".", "shape", "==", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_nifti_loader.test_load_nifti_file_err": [[47, 52], ["pytest.raises", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "str"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file"], ["", "def", "test_load_nifti_file_err", "(", ")", ":", "\n", "    ", "h5_filepath", "=", "\"./data/test/h5/paired/test/fixed_images.h5\"", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "        ", "load_nifti_file", "(", "file_path", "=", "h5_filepath", ")", "\n", "", "assert", "\"Nifti file path must end with .nii or .nii.gz\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.setup_method": [[92, 95], ["os.path.exists", "shutil.rmtree"], "methods", ["None"], ["def", "setup_method", "(", "self", ",", "method", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "save_dir", ")", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "self", ".", "save_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.teardown_method": [[96, 99], ["os.path.exists", "shutil.rmtree"], "methods", ["None"], ["", "", "def", "teardown_method", "(", "self", ",", "method", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "save_dir", ")", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "self", ".", "save_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.get_num_files_in_dir": [[100, 105], ["os.path.exists", "len", "os.listdir", "x.endswith"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "get_num_files_in_dir", "(", "dir_path", ":", "str", ",", "suffix", ":", "str", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "exists", "(", "dir_path", ")", ":", "\n", "            ", "return", "len", "(", "[", "x", "for", "x", "in", "os", ".", "listdir", "(", "dir_path", ")", "if", "x", ".", "endswith", "(", "suffix", ")", "]", ")", "\n", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.test_3d_4d": [[106, 119], ["pytest.mark.parametrize", "deepreg.util.save_array", "test_util.TestSaveArray.get_num_files_in_dir", "test_util.TestSaveArray.get_num_files_in_dir", "tensorflow.random.uniform", "tensorflow.random.uniform", "numpy.random.rand", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.get_num_files_in_dir", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.get_num_files_in_dir"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"arr\"", ",", "\n", "[", "\n", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "2", ",", "3", ",", "4", ")", ")", ",", "\n", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "2", ",", "3", ",", "4", ",", "3", ")", ")", ",", "\n", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ",", "4", ")", ",", "\n", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ",", "4", ",", "3", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_3d_4d", "(", "self", ",", "arr", ":", "Tuple", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", "]", ")", ":", "\n", "        ", "save_array", "(", "save_dir", "=", "self", ".", "save_dir", ",", "arr", "=", "arr", ",", "name", "=", "self", ".", "arr_name", ",", "normalize", "=", "True", ")", "\n", "assert", "self", ".", "get_num_files_in_dir", "(", "self", ".", "png_dir", ",", "suffix", "=", "\".png\"", ")", "==", "4", "\n", "assert", "self", ".", "get_num_files_in_dir", "(", "self", ".", "save_dir", ",", "suffix", "=", "\".nii.gz\"", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.test_wrong_shape": [[120, 135], ["pytest.mark.parametrize", "pytest.raises", "deepreg.util.save_array", "str", "tensorflow.random.uniform", "tensorflow.random.uniform", "numpy.random.rand", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_array"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"arr,err_msg\"", ",", "\n", "[", "\n", "[", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "2", ",", "3", ",", "4", ",", "3", ",", "3", ")", ")", ",", "dim_err_msg", "]", ",", "\n", "[", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "2", ",", "3", ",", "4", ",", "1", ")", ")", ",", "ch_err_msg", "]", ",", "\n", "[", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ",", "4", ",", "3", ",", "3", ")", ",", "dim_err_msg", "]", ",", "\n", "[", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ",", "4", ",", "1", ")", ",", "ch_err_msg", "]", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_wrong_shape", "(", "self", ",", "arr", ":", "Tuple", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", "]", ",", "err_msg", ":", "str", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "save_array", "(", "\n", "save_dir", "=", "self", ".", "save_dir", ",", "arr", "=", "arr", ",", "name", "=", "self", ".", "arr_name", ",", "normalize", "=", "True", "\n", ")", "\n", "", "assert", "err_msg", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.test_save_nifti": [[136, 148], ["pytest.mark.parametrize", "numpy.random.rand", "deepreg.util.save_array", "test_util.TestSaveArray.get_num_files_in_dir", "int"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.get_num_files_in_dir"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"save_nifti\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_save_nifti", "(", "self", ",", "save_nifti", ":", "bool", ")", ":", "\n", "        ", "arr", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ",", "4", ",", "3", ")", "\n", "save_array", "(", "\n", "save_dir", "=", "self", ".", "save_dir", ",", "\n", "arr", "=", "arr", ",", "\n", "name", "=", "self", ".", "arr_name", ",", "\n", "normalize", "=", "True", ",", "\n", "save_nifti", "=", "save_nifti", ",", "\n", ")", "\n", "assert", "self", ".", "get_num_files_in_dir", "(", "self", ".", "save_dir", ",", "suffix", "=", "\".nii.gz\"", ")", "==", "int", "(", "\n", "save_nifti", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.test_save_png": [[150, 162], ["pytest.mark.parametrize", "numpy.random.rand", "deepreg.util.save_array", "test_util.TestSaveArray.get_num_files_in_dir", "int"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.get_num_files_in_dir"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"save_png\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_save_png", "(", "self", ",", "save_png", ":", "bool", ")", ":", "\n", "        ", "arr", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ",", "4", ",", "3", ")", "\n", "save_array", "(", "\n", "save_dir", "=", "self", ".", "save_dir", ",", "\n", "arr", "=", "arr", ",", "\n", "name", "=", "self", ".", "arr_name", ",", "\n", "normalize", "=", "True", ",", "\n", "save_png", "=", "save_png", ",", "\n", ")", "\n", "assert", "(", "\n", "self", ".", "get_num_files_in_dir", "(", "self", ".", "png_dir", ",", "suffix", "=", "\".png\"", ")", "==", "int", "(", "save_png", ")", "*", "4", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.TestSaveArray.test_overwrite": [[164, 182], ["pytest.mark.parametrize", "numpy.random.rand", "os.path.join", "os.makedirs", "nibabel.save", "deepreg.util.save_array", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "test.unit.util.is_equal_np", "nibabel.Nifti1Image", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"overwrite\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_overwrite", "(", "self", ",", "overwrite", ":", "bool", ")", ":", "\n", "        ", "arr1", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ",", "4", ",", "3", ")", "\n", "arr2", "=", "arr1", "+", "1", "\n", "nifti_file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "self", ".", "arr_name", "+", "\".nii.gz\"", ")", "\n", "# save arr1", "\n", "os", ".", "makedirs", "(", "self", ".", "save_dir", ",", "exist_ok", "=", "True", ")", "\n", "nib", ".", "save", "(", "img", "=", "nib", ".", "Nifti1Image", "(", "arr1", ",", "affine", "=", "np", ".", "eye", "(", "4", ")", ")", ",", "filename", "=", "nifti_file_path", ")", "\n", "# save arr2 w/o overwrite", "\n", "save_array", "(", "\n", "save_dir", "=", "self", ".", "save_dir", ",", "\n", "arr", "=", "arr2", ",", "\n", "name", "=", "self", ".", "arr_name", ",", "\n", "normalize", "=", "True", ",", "\n", "overwrite", "=", "overwrite", ",", "\n", ")", "\n", "arr_read", "=", "load_nifti_file", "(", "file_path", "=", "nifti_file_path", ")", "\n", "assert", "is_equal_np", "(", "arr2", "if", "overwrite", "else", "arr1", ",", "arr_read", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.test_build_dataset": [[24, 69], ["deepreg.train.build_config", "deepreg.util.build_dataset", "isinstance", "isinstance", "isinstance", "deepreg.util.build_dataset"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.build_config", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_dataset", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_dataset"], ["def", "test_build_dataset", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test build_dataset by checking the output types\n    \"\"\"", "\n", "\n", "# init arguments", "\n", "config_path", "=", "\"config/unpaired_labeled_ddf.yaml\"", "\n", "log_dir", "=", "\"logs\"", "\n", "exp_name", "=", "\"test_build_dataset\"", "\n", "ckpt_path", "=", "\"\"", "\n", "\n", "# load config", "\n", "config", ",", "_", ",", "_", "=", "build_config", "(", "\n", "config_path", "=", "config_path", ",", "log_dir", "=", "log_dir", ",", "exp_name", "=", "exp_name", ",", "ckpt_path", "=", "ckpt_path", "\n", ")", "\n", "\n", "# build dataset", "\n", "data_loader_train", ",", "dataset_train", ",", "steps_per_epoch_train", "=", "build_dataset", "(", "\n", "dataset_config", "=", "config", "[", "\"dataset\"", "]", ",", "\n", "preprocess_config", "=", "config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", ",", "\n", "split", "=", "\"train\"", ",", "\n", "training", "=", "False", ",", "\n", "repeat", "=", "False", ",", "\n", ")", "\n", "\n", "# check output types", "\n", "assert", "isinstance", "(", "data_loader_train", ",", "DataLoader", ")", "\n", "assert", "isinstance", "(", "dataset_train", ",", "tf", ".", "data", ".", "Dataset", ")", "\n", "assert", "isinstance", "(", "steps_per_epoch_train", ",", "int", ")", "\n", "\n", "# remove valid data", "\n", "config", "[", "\"dataset\"", "]", "[", "\"valid\"", "]", "[", "\"dir\"", "]", "=", "\"\"", "\n", "\n", "# build dataset", "\n", "data_loader_valid", ",", "dataset_valid", ",", "steps_per_epoch_valid", "=", "build_dataset", "(", "\n", "dataset_config", "=", "config", "[", "\"dataset\"", "]", ",", "\n", "preprocess_config", "=", "config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", ",", "\n", "split", "=", "\"valid\"", ",", "\n", "training", "=", "False", ",", "\n", "repeat", "=", "False", ",", "\n", ")", "\n", "\n", "assert", "data_loader_valid", "is", "None", "\n", "assert", "dataset_valid", "is", "None", "\n", "assert", "steps_per_epoch_valid", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.test_build_log_dir": [[71, 83], ["pytest.mark.parametrize", "deepreg.util.build_log_dir", "os.path.split", "re.compile", "re.compile.match"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_log_dir"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"log_dir,exp_name\"", ",", "[", "(", "\"logs\"", ",", "\"\"", ")", ",", "(", "\"logs\"", ",", "\"custom\"", ")", "]", ")", "\n", "def", "test_build_log_dir", "(", "log_dir", ":", "str", ",", "exp_name", ":", "str", ")", ":", "\n", "    ", "built_log_dir", "=", "build_log_dir", "(", "log_dir", "=", "log_dir", ",", "exp_name", "=", "exp_name", ")", "\n", "head", ",", "tail", "=", "os", ".", "path", ".", "split", "(", "built_log_dir", ")", "\n", "assert", "head", "==", "log_dir", "\n", "if", "exp_name", "==", "\"\"", ":", "\n", "# use default timestamp based directory", "\n", "        ", "pattern", "=", "re", ".", "compile", "(", "\"[0-9]{8}-[0-9]{6}\"", ")", "\n", "assert", "pattern", ".", "match", "(", "tail", ")", "\n", "", "else", ":", "\n", "# use custom directory", "\n", "        ", "assert", "tail", "==", "exp_name", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.test_calculate_metrics": [[184, 254], ["tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.random.uniform", "deepreg.util.calculate_metrics", "deepreg.util.calculate_metrics", "deepreg.util.calculate_metrics", "deepreg.util.calculate_metrics", "sorted", "sorted", "list", "deepreg.util.calculate_metrics.keys"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.calculate_metrics", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.calculate_metrics", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.calculate_metrics", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.calculate_metrics"], ["", "", "def", "test_calculate_metrics", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test calculate_metrics by checking output keys.\n    Assuming the metrics functions are correct.\n    \"\"\"", "\n", "\n", "batch_size", "=", "2", "\n", "fixed_image_shape", "=", "(", "4", ",", "4", ",", "4", ")", "# (f_dim1, f_dim2, f_dim3)", "\n", "\n", "fixed_image", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "batch_size", ",", ")", "+", "fixed_image_shape", ")", "\n", "fixed_label", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "batch_size", ",", ")", "+", "fixed_image_shape", ")", "\n", "pred_fixed_image", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "batch_size", ",", ")", "+", "fixed_image_shape", ")", "\n", "pred_fixed_label", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "batch_size", ",", ")", "+", "fixed_image_shape", ")", "\n", "fixed_grid_ref", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "1", ",", ")", "+", "fixed_image_shape", "+", "(", "3", ",", ")", ")", "\n", "sample_index", "=", "0", "\n", "\n", "# labeled and have pred_fixed_image", "\n", "got", "=", "calculate_metrics", "(", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "fixed_label", "=", "fixed_label", ",", "\n", "pred_fixed_image", "=", "pred_fixed_image", ",", "\n", "pred_fixed_label", "=", "pred_fixed_label", ",", "\n", "fixed_grid_ref", "=", "fixed_grid_ref", ",", "\n", "sample_index", "=", "sample_index", ",", "\n", ")", "\n", "assert", "got", "[", "\"image_ssd\"", "]", "is", "not", "None", "\n", "assert", "got", "[", "\"label_binary_dice\"", "]", "is", "not", "None", "\n", "assert", "got", "[", "\"label_tre\"", "]", "is", "not", "None", "\n", "assert", "sorted", "(", "list", "(", "got", ".", "keys", "(", ")", ")", ")", "==", "sorted", "(", "\n", "[", "\"image_ssd\"", ",", "\"label_binary_dice\"", ",", "\"label_tre\"", "]", "\n", ")", "\n", "\n", "# labeled and do not have pred_fixed_image", "\n", "got", "=", "calculate_metrics", "(", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "fixed_label", "=", "fixed_label", ",", "\n", "pred_fixed_image", "=", "None", ",", "\n", "pred_fixed_label", "=", "pred_fixed_label", ",", "\n", "fixed_grid_ref", "=", "fixed_grid_ref", ",", "\n", "sample_index", "=", "sample_index", ",", "\n", ")", "\n", "assert", "got", "[", "\"image_ssd\"", "]", "is", "None", "\n", "assert", "got", "[", "\"label_binary_dice\"", "]", "is", "not", "None", "\n", "assert", "got", "[", "\"label_tre\"", "]", "is", "not", "None", "\n", "\n", "# unlabeled and have pred_fixed_image", "\n", "got", "=", "calculate_metrics", "(", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "fixed_label", "=", "None", ",", "\n", "pred_fixed_image", "=", "pred_fixed_image", ",", "\n", "pred_fixed_label", "=", "None", ",", "\n", "fixed_grid_ref", "=", "fixed_grid_ref", ",", "\n", "sample_index", "=", "sample_index", ",", "\n", ")", "\n", "assert", "got", "[", "\"image_ssd\"", "]", "is", "not", "None", "\n", "assert", "got", "[", "\"label_binary_dice\"", "]", "is", "None", "\n", "assert", "got", "[", "\"label_tre\"", "]", "is", "None", "\n", "\n", "# unlabeled and do not have pred_fixed_image", "\n", "got", "=", "calculate_metrics", "(", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "fixed_label", "=", "None", ",", "\n", "pred_fixed_image", "=", "None", ",", "\n", "pred_fixed_label", "=", "None", ",", "\n", "fixed_grid_ref", "=", "fixed_grid_ref", ",", "\n", "sample_index", "=", "sample_index", ",", "\n", ")", "\n", "assert", "got", "[", "\"image_ssd\"", "]", "is", "None", "\n", "assert", "got", "[", "\"label_binary_dice\"", "]", "is", "None", "\n", "assert", "got", "[", "\"label_tre\"", "]", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_util.test_save_metric_dict": [[256, 270], ["deepreg.util.save_metric_dict", "shutil.rmtree", "dict", "dict", "dict", "len", "os.listdir", "x.endswith"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_metric_dict"], ["", "def", "test_save_metric_dict", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test save_metric_dict by checking output files.\n    \"\"\"", "\n", "\n", "save_dir", "=", "\"logs/test_save_metric_dict\"", "\n", "metrics", "=", "[", "\n", "dict", "(", "image_ssd", "=", "0.1", ",", "label_dice", "=", "0.8", ",", "pair_index", "=", "[", "0", "]", ",", "label_index", "=", "0", ")", ",", "\n", "dict", "(", "image_ssd", "=", "0.2", ",", "label_dice", "=", "0.7", ",", "pair_index", "=", "[", "1", "]", ",", "label_index", "=", "1", ")", ",", "\n", "dict", "(", "image_ssd", "=", "0.3", ",", "label_dice", "=", "0.6", ",", "pair_index", "=", "[", "2", "]", ",", "label_index", "=", "0", ")", ",", "\n", "]", "\n", "save_metric_dict", "(", "save_dir", "=", "save_dir", ",", "metrics", "=", "metrics", ")", "\n", "assert", "len", "(", "[", "x", "for", "x", "in", "os", ".", "listdir", "(", "save_dir", ")", "if", "x", ".", "endswith", "(", "\".csv\"", ")", "]", ")", "==", "3", "\n", "shutil", ".", "rmtree", "(", "save_dir", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_parser.TestLoadConfigs.test_single_config": [[76, 81], ["deepreg.config.parser.load_configs", "open", "yaml.load"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.load_configs"], ["    ", "def", "test_single_config", "(", "self", ")", ":", "\n", "        ", "with", "open", "(", "\"config/unpaired_labeled_ddf.yaml\"", ")", "as", "file", ":", "\n", "            ", "expected", "=", "yaml", ".", "load", "(", "file", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "", "got", "=", "load_configs", "(", "\"config/unpaired_labeled_ddf.yaml\"", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_parser.TestLoadConfigs.test_multiple_configs": [[82, 93], ["deepreg.config.parser.load_configs", "open", "yaml.load"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.load_configs"], ["", "def", "test_multiple_configs", "(", "self", ")", ":", "\n", "        ", "with", "open", "(", "\"config/unpaired_labeled_ddf.yaml\"", ")", "as", "file", ":", "\n", "            ", "expected", "=", "yaml", ".", "load", "(", "file", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "", "got", "=", "load_configs", "(", "\n", "config_path", "=", "[", "\n", "\"config/test/ddf.yaml\"", ",", "\n", "\"config/test/unpaired_nifti.yaml\"", ",", "\n", "\"config/test/labeled.yaml\"", ",", "\n", "]", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_parser.TestLoadConfigs.test_outdated_config": [[94, 102], ["deepreg.config.parser.load_configs", "os.path.isfile", "os.remove", "open", "yaml.load"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.load_configs"], ["", "def", "test_outdated_config", "(", "self", ")", ":", "\n", "        ", "with", "open", "(", "\"demos/grouped_mr_heart/grouped_mr_heart.yaml\"", ")", "as", "file", ":", "\n", "            ", "expected", "=", "yaml", ".", "load", "(", "file", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "", "got", "=", "load_configs", "(", "\"config/test/grouped_mr_heart_v011.yaml\"", ")", "\n", "assert", "got", "==", "expected", "\n", "updated_file_path", "=", "\"config/test/updated_grouped_mr_heart_v011.yaml\"", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "updated_file_path", ")", "\n", "os", ".", "remove", "(", "updated_file_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_parser.TestConfigSanityCheck.test_cond_err": [[123, 146], ["pytest.raises", "deepreg.config.parser.config_sanity_check", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.config_sanity_check"], ["    ", "def", "test_cond_err", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test error message for conditional model.\"\"\"", "\n", "wrong_config", "=", "{", "\n", "\"dataset\"", ":", "{", "\n", "\"train\"", ":", "{", "\n", "\"dir\"", ":", "\"\"", ",", "\n", "\"labeled\"", ":", "False", ",", "\n", "\"format\"", ":", "\"h5\"", ",", "\n", "}", ",", "\n", "\"type\"", ":", "\"paired\"", ",", "\n", "}", ",", "\n", "\"train\"", ":", "{", "\n", "\"method\"", ":", "\"conditional\"", ",", "\n", "\"loss\"", ":", "{", "}", ",", "\n", "\"preprocess\"", ":", "{", "}", ",", "\n", "\"optimizer\"", ":", "{", "\"name\"", ":", "\"Adam\"", "}", ",", "\n", "}", ",", "\n", "}", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "config_sanity_check", "(", "config", "=", "wrong_config", ")", "\n", "", "assert", "(", "\n", "\"For conditional model, data have to be labeled, got unlabeled data.\"", "\n", "in", "str", "(", "err_info", ".", "value", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_parser.test_update_nested_dict": [[19, 73], ["dict", "dict", "deepreg.config.parser.update_nested_dict", "dict", "dict", "dict", "deepreg.config.parser.update_nested_dict", "dict", "dict", "dict", "deepreg.config.parser.update_nested_dict", "dict", "dict", "dict", "dict", "dict", "deepreg.config.parser.update_nested_dict", "dict", "dict", "dict", "deepreg.config.parser.update_nested_dict", "dict", "dict", "dict", "deepreg.config.parser.update_nested_dict", "dict", "pytest.raises", "deepreg.config.parser.update_nested_dict", "str", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict"], ["def", "test_update_nested_dict", "(", ")", ":", "\n", "    ", "\"\"\"test update_nested_dict by checking outputs values\"\"\"", "\n", "# two simple dicts with different keys", "\n", "d", "=", "dict", "(", "d", "=", "1", ")", "\n", "v", "=", "dict", "(", "v", "=", "0", ")", "\n", "got", "=", "update_nested_dict", "(", "d", ",", "v", ")", "\n", "expected", "=", "dict", "(", "d", "=", "1", ",", "v", "=", "0", ")", "\n", "assert", "got", "==", "expected", "\n", "\n", "# two simple dicts with same key", "\n", "d", "=", "dict", "(", "d", "=", "1", ")", "\n", "v", "=", "dict", "(", "d", "=", "0", ")", "\n", "got", "=", "update_nested_dict", "(", "d", ",", "v", ")", "\n", "expected", "=", "dict", "(", "d", "=", "0", ")", "\n", "assert", "got", "==", "expected", "\n", "\n", "# dict with nested dict without common key", "\n", "d", "=", "dict", "(", "d", "=", "1", ")", "\n", "v", "=", "dict", "(", "v", "=", "dict", "(", "x", "=", "0", ")", ")", "\n", "got", "=", "update_nested_dict", "(", "d", ",", "v", ")", "\n", "expected", "=", "dict", "(", "d", "=", "1", ",", "v", "=", "dict", "(", "x", "=", "0", ")", ")", "\n", "assert", "got", "==", "expected", "\n", "\n", "# dict with nested dict with common key", "\n", "# fail because can not use dict to overwrite non dict values", "\n", "d", "=", "dict", "(", "v", "=", "1", ")", "\n", "v", "=", "dict", "(", "v", "=", "dict", "(", "x", "=", "0", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", "as", "err_info", ":", "\n", "        ", "update_nested_dict", "(", "d", ",", "v", ")", "\n", "", "assert", "\"'int' object does not support item assignment\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n", "# dict with nested dict with common key", "\n", "# pass because can use non dict to overwrite dict", "\n", "d", "=", "dict", "(", "v", "=", "dict", "(", "x", "=", "0", ")", ")", "\n", "v", "=", "dict", "(", "v", "=", "1", ")", "\n", "got", "=", "update_nested_dict", "(", "d", ",", "v", ")", "\n", "expected", "=", "dict", "(", "v", "=", "1", ")", "\n", "assert", "got", "==", "expected", "\n", "\n", "# dict with nested dict with common key", "\n", "# overwrite a value", "\n", "d", "=", "dict", "(", "v", "=", "dict", "(", "x", "=", "0", ",", "y", "=", "1", ")", ")", "\n", "v", "=", "dict", "(", "v", "=", "dict", "(", "x", "=", "1", ")", ")", "\n", "got", "=", "update_nested_dict", "(", "d", ",", "v", ")", "\n", "expected", "=", "dict", "(", "v", "=", "dict", "(", "x", "=", "1", ",", "y", "=", "1", ")", ")", "\n", "assert", "got", "==", "expected", "\n", "\n", "# dict with nested dict with common key", "\n", "# add a value", "\n", "d", "=", "dict", "(", "v", "=", "dict", "(", "x", "=", "0", ",", "y", "=", "1", ")", ")", "\n", "v", "=", "dict", "(", "v", "=", "dict", "(", "z", "=", "1", ")", ")", "\n", "got", "=", "update_nested_dict", "(", "d", ",", "v", ")", "\n", "expected", "=", "dict", "(", "v", "=", "dict", "(", "x", "=", "0", ",", "y", "=", "1", ",", "z", "=", "1", ")", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_parser.test_save": [[104, 120], ["testfixtures.TempDirectory", "deepreg.config.parser.save", "os.path.exists", "testfixtures.TempDirectory", "deepreg.config.parser.save", "os.path.exists", "testfixtures.TempDirectory", "os.path.join", "os.path.join", "pytest.raises", "deepreg.config.parser.save", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save"], ["", "", "def", "test_save", "(", ")", ":", "\n", "    ", "\"\"\"test save by check error and existance of file\"\"\"", "\n", "# default file name", "\n", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "save", "(", "config", "=", "dict", "(", "x", "=", "1", ")", ",", "out_dir", "=", "tempdir", ".", "path", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "tempdir", ".", "path", ",", "\"config.yaml\"", ")", ")", "\n", "\n", "# custom file name", "\n", "", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "save", "(", "config", "=", "dict", "(", "x", "=", "1", ")", ",", "out_dir", "=", "tempdir", ".", "path", ",", "filename", "=", "\"test.yaml\"", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "tempdir", ".", "path", ",", "\"test.yaml\"", ")", ")", "\n", "\n", "# non yaml filename", "\n", "", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "save", "(", "config", "=", "dict", "(", "x", "=", "1", ")", ",", "out_dir", "=", "tempdir", ".", "path", ",", "filename", "=", "\"test.txt\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_kernel.test_cauchy_kernel1d": [[16, 28], ["pytest.mark.parametrize", "int", "deepreg.loss.kernel.cauchy_kernel1d", "test.unit.util.is_equal_tf", "numpy.sum", "range"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.cauchy_kernel1d", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"sigma\"", ",", "[", "1", ",", "3", ",", "2.2", "]", ")", "\n", "def", "test_cauchy_kernel1d", "(", "sigma", ")", ":", "\n", "    ", "\"\"\"\n    Testing the 1-D cauchy kernel\n    :param sigma: float\n    :return:\n    \"\"\"", "\n", "tail", "=", "int", "(", "sigma", "*", "5", ")", "\n", "expected", "=", "[", "1", "/", "(", "(", "x", "/", "sigma", ")", "**", "2", "+", "1", ")", "for", "x", "in", "range", "(", "-", "tail", ",", "tail", "+", "1", ")", "]", "\n", "expected", "=", "expected", "/", "np", ".", "sum", "(", "expected", ")", "\n", "got", "=", "cauchy_kernel1d", "(", "sigma", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_kernel.test_gaussian_kernel1d_sigma": [[30, 42], ["pytest.mark.parametrize", "int", "deepreg.loss.kernel.gaussian_kernel1d_sigma", "test.unit.util.is_equal_tf", "numpy.exp", "numpy.sum", "range"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.gaussian_kernel1d_sigma", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"sigma\"", ",", "[", "1", ",", "3", ",", "2.2", "]", ")", "\n", "def", "test_gaussian_kernel1d_sigma", "(", "sigma", ")", ":", "\n", "    ", "\"\"\"\n    Testing the 1-D gaussian kernel given sigma as input\n    :param sigma: float\n    :return:\n    \"\"\"", "\n", "tail", "=", "int", "(", "sigma", "*", "3", ")", "\n", "expected", "=", "[", "np", ".", "exp", "(", "-", "0.5", "*", "x", "**", "2", "/", "sigma", "**", "2", ")", "for", "x", "in", "range", "(", "-", "tail", ",", "tail", "+", "1", ")", "]", "\n", "expected", "=", "expected", "/", "np", ".", "sum", "(", "expected", ")", "\n", "got", "=", "gaussian_kernel1d_sigma", "(", "sigma", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_kernel.test_gaussian_kernel1d_size": [[44, 59], ["pytest.mark.parametrize", "tensorflow.range", "tensorflow.exp", "deepreg.loss.kernel.gaussian_kernel1d_size", "test.unit.util.is_equal_tf", "tensorflow.square"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.gaussian_kernel1d_size", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"kernel_size\"", ",", "[", "3", ",", "7", ",", "11", "]", ")", "\n", "def", "test_gaussian_kernel1d_size", "(", "kernel_size", ")", ":", "\n", "    ", "\"\"\"\n    Testing the 1-D gaussian kernel given size as input\n    :param kernel_size: int\n    :return:\n    \"\"\"", "\n", "mean", "=", "(", "kernel_size", "-", "1", ")", "/", "2.0", "\n", "sigma", "=", "kernel_size", "/", "3", "\n", "\n", "grid", "=", "tf", ".", "range", "(", "0", ",", "kernel_size", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "expected", "=", "tf", ".", "exp", "(", "-", "tf", ".", "square", "(", "grid", "-", "mean", ")", "/", "(", "2", "*", "sigma", "**", "2", ")", ")", "\n", "\n", "got", "=", "gaussian_kernel1d_size", "(", "kernel_size", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_kernel.test_rectangular_kernel1d": [[61, 71], ["pytest.mark.parametrize", "tensorflow.ones", "deepreg.loss.kernel.rectangular_kernel1d", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.rectangular_kernel1d", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"kernel_size\"", ",", "[", "3", ",", "7", ",", "11", "]", ")", "\n", "def", "test_rectangular_kernel1d", "(", "kernel_size", ")", ":", "\n", "    ", "\"\"\"\n    Testing the 1-D rectangular kernel\n    :param kernel_size: int\n    :return:\n    \"\"\"", "\n", "expected", "=", "tf", ".", "ones", "(", "shape", "=", "(", "kernel_size", ",", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "got", "=", "rectangular_kernel1d", "(", "kernel_size", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_kernel.test_triangular_kernel1d": [[73, 88], ["pytest.mark.parametrize", "numpy.zeros", "range", "deepreg.loss.kernel.triangular_kernel1d", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.triangular_kernel1d", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"kernel_size\"", ",", "[", "3", ",", "5", ",", "7", ",", "9", "]", ")", "\n", "def", "test_triangular_kernel1d", "(", "kernel_size", ")", ":", "\n", "    ", "\"\"\"\n    Testing the 1-D triangular kernel\n    :param kernel_size: int (odd number)\n    :return:\n    \"\"\"", "\n", "expected", "=", "np", ".", "zeros", "(", "shape", "=", "(", "kernel_size", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "expected", "[", "kernel_size", "//", "2", "]", "=", "kernel_size", "//", "2", "+", "1", "\n", "for", "it_k", "in", "range", "(", "kernel_size", "//", "2", ")", ":", "\n", "        ", "expected", "[", "it_k", "]", "=", "it_k", "+", "1", "\n", "expected", "[", "-", "it_k", "-", "1", "]", "=", "it_k", "+", "1", "\n", "\n", "", "got", "=", "triangular_kernel1d", "(", "kernel_size", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.build_layer": [[108, 117], ["None"], "methods", ["None"], ["def", "build_layer", "(", "self", ",", "name", ":", "str", ")", "->", "preprocess", ".", "RandomTransformation3D", ":", "\n", "        ", "\"\"\"\n        Build a layer given the layer name.\n\n        :param name: name of the layer\n        :return: built layer object\n        \"\"\"", "\n", "config", "=", "{", "**", "self", ".", "common_config", ",", "**", "self", ".", "extra_config_dict", "[", "name", "]", "}", "# type: ignore", "\n", "return", "self", ".", "layer_cls_dict", "[", "name", "]", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.test_get_config": [[118, 134], ["pytest.mark.parametrize", "test_preprocess.TestRandomTransformation.build_layer", "test_preprocess.TestRandomTransformation.get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.build_layer", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"name\"", ",", "[", "\"affine\"", ",", "\"ddf\"", "]", ")", "\n", "def", "test_get_config", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Check config values.\n\n        :param name: name of the layer\n        \"\"\"", "\n", "layer", "=", "self", ".", "build_layer", "(", "name", ")", "\n", "got", "=", "layer", ".", "get_config", "(", ")", "\n", "expected", "=", "{", "\n", "\"trainable\"", ":", "False", ",", "\n", "\"dtype\"", ":", "\"float32\"", ",", "\n", "**", "self", ".", "common_config", ",", "# type: ignore", "\n", "**", "self", ".", "extra_config_dict", "[", "name", "]", ",", "# type: ignore", "\n", "}", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.test_gen_transform_params": [[135, 157], ["pytest.mark.parametrize", "test_preprocess.TestRandomTransformation.build_layer", "test_preprocess.TestRandomTransformation.gen_transform_params", "test.unit.util.is_equal_np"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.build_layer", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.gen_transform_params", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"name\"", ",", "\"moving_param_shape\"", ",", "\"fixed_param_shape\"", ")", ",", "\n", "[", "\n", "(", "\"affine\"", ",", "(", "4", ",", "3", ")", ",", "(", "4", ",", "3", ")", ")", ",", "\n", "(", "\"ddf\"", ",", "(", "*", "moving_image_size", ",", "3", ")", ",", "(", "*", "fixed_image_size", ",", "3", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_gen_transform_params", "(", "\n", "self", ",", "name", ":", "str", ",", "moving_param_shape", ":", "tuple", ",", "fixed_param_shape", ":", "tuple", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Check return shapes and moving/fixed params should be different.\n\n        :param name: name of the layer\n        :param moving_param_shape: params shape for moving image/label\n        :param fixed_param_shape: params shape for fixed image/label\n        \"\"\"", "\n", "layer", "=", "self", ".", "build_layer", "(", "name", ")", "\n", "moving", ",", "fixed", "=", "layer", ".", "gen_transform_params", "(", ")", "\n", "assert", "moving", ".", "shape", "==", "(", "self", ".", "batch_size", ",", "*", "moving_param_shape", ")", "\n", "assert", "fixed", ".", "shape", "==", "(", "self", ".", "batch_size", ",", "*", "fixed_param_shape", ")", "\n", "assert", "not", "is_equal_np", "(", "moving", ",", "fixed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.test_transform": [[158, 176], ["pytest.mark.parametrize", "test_preprocess.TestRandomTransformation.build_layer", "tensorflow.random.uniform", "test_preprocess.TestRandomTransformation.gen_transform_params", "test_preprocess.TestRandomTransformation.transform"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.build_layer", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.gen_transform_params", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.transform"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"name\"", ",", "[", "\"affine\"", ",", "\"ddf\"", "]", ")", "\n", "def", "test_transform", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Check return shapes.\n\n        :param name: name of the layer\n        \"\"\"", "\n", "layer", "=", "self", ".", "build_layer", "(", "name", ")", "\n", "moving_image", "=", "tf", ".", "random", ".", "uniform", "(", "\n", "shape", "=", "(", "self", ".", "batch_size", ",", "*", "self", ".", "moving_image_size", ")", "\n", ")", "\n", "moving_params", ",", "_", "=", "layer", ".", "gen_transform_params", "(", ")", "\n", "transformed", "=", "layer", ".", "transform", "(", "\n", "image", "=", "moving_image", ",", "\n", "grid_ref", "=", "layer", ".", "moving_grid_ref", ",", "\n", "params", "=", "moving_params", ",", "\n", ")", "\n", "assert", "transformed", ".", "shape", "==", "moving_image", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.test_call": [[177, 205], ["pytest.mark.parametrize", "pytest.mark.parametrize", "test_preprocess.TestRandomTransformation.build_layer", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.ones", "dict", "test_preprocess.TestRandomTransformation.call", "tensorflow.random.uniform", "tensorflow.random.uniform"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.TestRandomTransformation.build_layer", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"name\"", ",", "[", "\"affine\"", ",", "\"ddf\"", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"labeled\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_call", "(", "self", ",", "name", ":", "str", ",", "labeled", ":", "bool", ")", ":", "\n", "        ", "\"\"\"\n        Check return shapes.\n\n        :param name: name of the layer\n        :param labeled: if data is labeled\n        \"\"\"", "\n", "layer", "=", "self", ".", "build_layer", "(", "name", ")", "\n", "\n", "moving_shape", "=", "(", "self", ".", "batch_size", ",", "*", "self", ".", "moving_image_size", ")", "\n", "fixed_shape", "=", "(", "self", ".", "batch_size", ",", "*", "self", ".", "fixed_image_size", ")", "\n", "moving_image", "=", "tf", ".", "random", ".", "uniform", "(", "moving_shape", ")", "\n", "fixed_image", "=", "tf", ".", "random", ".", "uniform", "(", "fixed_shape", ")", "\n", "indices", "=", "tf", ".", "ones", "(", "(", "self", ".", "batch_size", ",", "self", ".", "num_indices", ")", ")", "\n", "inputs", "=", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "fixed_image", "=", "fixed_image", ",", "indices", "=", "indices", "\n", ")", "\n", "if", "labeled", ":", "\n", "            ", "moving_label", "=", "tf", ".", "random", ".", "uniform", "(", "moving_shape", ")", "\n", "fixed_label", "=", "tf", ".", "random", ".", "uniform", "(", "fixed_shape", ")", "\n", "inputs", "[", "\"moving_label\"", "]", "=", "moving_label", "\n", "inputs", "[", "\"fixed_label\"", "]", "=", "fixed_label", "\n", "\n", "", "outputs", "=", "layer", ".", "call", "(", "inputs", ")", "\n", "for", "k", "in", "inputs", ":", "\n", "            ", "assert", "outputs", "[", "k", "]", ".", "shape", "==", "inputs", "[", "k", "]", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.test_resize_inputs": [[23, 68], ["pytest.mark.parametrize", "pytest.mark.parametrize", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.ones", "dict", "deepreg.resize_inputs", "tensorflow.random.uniform", "tensorflow.random.uniform"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.resize_inputs"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"moving_input_size\"", ",", "\"fixed_input_size\"", ",", "\"moving_image_size\"", ",", "\"fixed_image_size\"", ")", ",", "\n", "[", "\n", "(", "(", "1", ",", "2", ",", "3", ")", ",", "(", "2", ",", "3", ",", "4", ")", ",", "(", "3", ",", "4", ",", "5", ")", ",", "(", "4", ",", "5", ",", "6", ")", ")", ",", "\n", "(", "(", "3", ",", "4", ",", "5", ")", ",", "(", "4", ",", "5", ",", "6", ")", ",", "(", "1", ",", "2", ",", "3", ")", ",", "(", "2", ",", "3", ",", "4", ")", ")", ",", "\n", "(", "(", "2", ",", "2", ",", "2", ")", ",", "(", "2", ",", "2", ",", "2", ")", ",", "(", "2", ",", "2", ",", "2", ")", ",", "(", "2", ",", "2", ",", "2", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"labeled\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_resize_inputs", "(", "\n", "moving_input_size", ":", "tuple", ",", "\n", "fixed_input_size", ":", "tuple", ",", "\n", "moving_image_size", ":", "tuple", ",", "\n", "fixed_image_size", ":", "tuple", ",", "\n", "labeled", ":", "bool", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Check return shapes.\n\n    :param moving_input_size: input moving image/label shape\n    :param fixed_input_size: input fixed image/label shape\n    :param moving_image_size: output moving image/label shape\n    :param fixed_image_size: output fixed image/label shape\n    :param labeled: if data is labeled\n    \"\"\"", "\n", "num_indices", "=", "2", "\n", "\n", "moving_image", "=", "tf", ".", "random", ".", "uniform", "(", "moving_input_size", ")", "\n", "fixed_image", "=", "tf", ".", "random", ".", "uniform", "(", "fixed_input_size", ")", "\n", "indices", "=", "tf", ".", "ones", "(", "(", "num_indices", ",", ")", ")", "\n", "inputs", "=", "dict", "(", "moving_image", "=", "moving_image", ",", "fixed_image", "=", "fixed_image", ",", "indices", "=", "indices", ")", "\n", "if", "labeled", ":", "\n", "        ", "moving_label", "=", "tf", ".", "random", ".", "uniform", "(", "moving_input_size", ")", "\n", "fixed_label", "=", "tf", ".", "random", ".", "uniform", "(", "fixed_input_size", ")", "\n", "inputs", "[", "\"moving_label\"", "]", "=", "moving_label", "\n", "inputs", "[", "\"fixed_label\"", "]", "=", "fixed_label", "\n", "\n", "", "outputs", "=", "preprocess", ".", "resize_inputs", "(", "inputs", ",", "moving_image_size", ",", "fixed_image_size", ")", "\n", "assert", "inputs", "[", "\"indices\"", "]", ".", "shape", "==", "outputs", "[", "\"indices\"", "]", ".", "shape", "\n", "for", "k", "in", "inputs", ":", "\n", "        ", "if", "k", "==", "\"indices\"", ":", "\n", "            ", "assert", "outputs", "[", "k", "]", ".", "shape", "==", "inputs", "[", "k", "]", ".", "shape", "\n", "continue", "\n", "", "expected_shape", "=", "moving_image_size", "if", "\"moving\"", "in", "k", "else", "fixed_image_size", "\n", "assert", "outputs", "[", "k", "]", ".", "shape", "==", "expected_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.test_random_transform_3d_get_config": [[70, 83], ["dict", "deepreg.RandomTransformation3D", "preprocess.RandomTransformation3D.get_config"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "", "def", "test_random_transform_3d_get_config", "(", ")", ":", "\n", "    ", "\"\"\"Check config values.\"\"\"", "\n", "config", "=", "dict", "(", "\n", "moving_image_size", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "fixed_image_size", "=", "(", "2", ",", "3", ",", "4", ")", ",", "\n", "batch_size", "=", "3", ",", "\n", "name", "=", "\"TestRandomTransformation3D\"", ",", "\n", ")", "\n", "expected", "=", "{", "\"trainable\"", ":", "False", ",", "\"dtype\"", ":", "\"float32\"", ",", "**", "config", "}", "\n", "transform", "=", "preprocess", ".", "RandomTransformation3D", "(", "**", "config", ")", "\n", "got", "=", "transform", ".", "get_config", "(", ")", "\n", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_preprocess.test_random_transform_generator": [[207, 238], ["deepreg.dataset.preprocess.gen_rand_affine_transform", "deepreg.dataset.preprocess.gen_rand_affine_transform", "tensorflow.constant", "deepreg.dataset.preprocess.gen_rand_affine_transform", "deepreg.dataset.preprocess.gen_rand_affine_transform", "test.unit.util.is_equal_tf", "numpy.array"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_affine_transform", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_affine_transform", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_affine_transform", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_affine_transform", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "", "", "def", "test_random_transform_generator", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test random_transform_generator by confirming that it generates\n    appropriate solutions and output sizes for seeded examples.\n    \"\"\"", "\n", "# Check shapes are correct Batch Size = 1 - Pass", "\n", "batch_size", "=", "1", "\n", "transforms", "=", "deepreg", ".", "dataset", ".", "preprocess", ".", "gen_rand_affine_transform", "(", "batch_size", ",", "0", ")", "\n", "assert", "transforms", ".", "shape", "==", "(", "batch_size", ",", "4", ",", "3", ")", "\n", "\n", "# Check numerical outputs are correct for a given seed - Pass", "\n", "batch_size", "=", "1", "\n", "scale", "=", "0.1", "\n", "seed", "=", "0", "\n", "expected", "=", "tf", ".", "constant", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "[", "\n", "[", "9.4661278e-01", ",", "-", "3.8267835e-03", ",", "3.6934228e-03", "]", ",", "\n", "[", "5.5613145e-03", ",", "9.8034811e-01", ",", "-", "1.8044969e-02", "]", ",", "\n", "[", "1.9651605e-04", ",", "1.4576728e-02", ",", "9.6243286e-01", "]", ",", "\n", "[", "-", "2.5107686e-03", ",", "1.9579126e-02", ",", "-", "1.2195010e-02", "]", ",", "\n", "]", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", ")", "# shape = (1, 4, 3)", "\n", "got", "=", "deepreg", ".", "dataset", ".", "preprocess", ".", "gen_rand_affine_transform", "(", "\n", "batch_size", "=", "batch_size", ",", "scale", "=", "scale", ",", "seed", "=", "seed", "\n", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_download.has_diff_files": [[16, 22], ["dcmp.subdirs.values", "len", "test_download.has_diff_files"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_download.has_diff_files"], ["def", "has_diff_files", "(", "dcmp", ")", ":", "\n", "    ", "if", "len", "(", "dcmp", ".", "diff_files", ")", ">", "0", ":", "\n", "        ", "return", "True", "\n", "", "for", "sub_dcmp", "in", "dcmp", ".", "subdirs", ".", "values", "(", ")", ":", "\n", "        ", "has_diff_files", "(", "sub_dcmp", ")", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_download.test_download": [[24, 27], ["None"], "function", ["None"], ["", "def", "test_download", "(", ")", ":", "\n", "# Covered by test_main", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_download.test_main": [[29, 50], ["deepreg.download.main", "filecmp.dircmp", "filecmp.dircmp", "filecmp.dircmp", "shutil.rmtree", "os.path.join", "test_download.has_diff_files", "os.path.join", "test_download.has_diff_files", "os.path.join", "test_download.has_diff_files", "git.Repo"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_download.has_diff_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_download.has_diff_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_download.has_diff_files"], ["", "def", "test_main", "(", ")", ":", "\n", "    ", "\"\"\"\n    Integration test by checking the output dirs and files exist\n    \"\"\"", "\n", "\n", "temp_dir", "=", "\"./deepreg_download_temp_dir\"", "\n", "branch", "=", "Repo", "(", "\".\"", ")", ".", "head", ".", "object", ".", "hexsha", "\n", "\n", "main", "(", "args", "=", "[", "\"--output_dir\"", ",", "temp_dir", ",", "\"--branch\"", ",", "branch", "]", ")", "\n", "\n", "# Check downloading all req'd folders into temp, verify that they are the same as in main branch.", "\n", "config_dcmp", "=", "dircmp", "(", "\"./config\"", ",", "os", ".", "path", ".", "join", "(", "temp_dir", ",", "\"config\"", ")", ")", "\n", "assert", "not", "has_diff_files", "(", "config_dcmp", ")", "\n", "\n", "data_dcmp", "=", "dircmp", "(", "\"./data\"", ",", "os", ".", "path", ".", "join", "(", "temp_dir", ",", "\"data\"", ")", ")", "\n", "assert", "not", "has_diff_files", "(", "data_dcmp", ")", "\n", "\n", "demos_dcmp", "=", "dircmp", "(", "\"./demos\"", ",", "os", ".", "path", ".", "join", "(", "temp_dir", ",", "\"demos\"", ")", ")", "\n", "assert", "not", "has_diff_files", "(", "demos_dcmp", ")", "\n", "\n", "shutil", ".", "rmtree", "(", "temp_dir", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_registry.TestRegistry.reg": [[10, 13], ["pytest.fixture", "deepreg.registry.REGISTRY.copy"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.copy"], ["    ", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "reg", "(", "self", ")", ":", "\n", "        ", "return", "REGISTRY", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_registry.TestRegistry.test_register_err": [[14, 25], ["pytest.mark.parametrize", "pytest.raises", "reg.register", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"category,key,err_msg\"", ",", "\n", "[", "\n", "(", "\"unknown_category\"", ",", "\"key\"", ",", "\"Unknown category\"", ")", ",", "\n", "(", "BACKBONE_CLASS", ",", "\"unet\"", ",", "\"has been registered\"", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_register_err", "(", "self", ",", "category", ",", "key", ",", "err_msg", ",", "reg", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "reg", ".", "register", "(", "category", "=", "category", ",", "name", "=", "key", ",", "cls", "=", "0", ")", "\n", "", "assert", "err_msg", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_registry.TestRegistry.test_register": [[26, 40], ["pytest.mark.parametrize", "reg.register", "reg.get"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"category,key,force\"", ",", "\n", "[", "\n", "(", "BACKBONE_CLASS", ",", "\"unet\"", ",", "True", ")", ",", "\n", "(", "BACKBONE_CLASS", ",", "\"vnet\"", ",", "False", ")", ",", "\n", "(", "LOSS_CLASS", ",", "\"dice\"", ",", "True", ")", ",", "\n", "(", "LOSS_CLASS", ",", "\"Dice\"", ",", "False", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_register", "(", "self", ",", "category", ",", "key", ",", "force", ",", "reg", ")", ":", "\n", "        ", "value", "=", "0", "\n", "reg", ".", "register", "(", "category", "=", "category", ",", "name", "=", "key", ",", "cls", "=", "value", ",", "force", "=", "force", ")", "\n", "assert", "reg", ".", "_dict", "[", "(", "category", ",", "key", ")", "]", "==", "value", "\n", "assert", "reg", ".", "get", "(", "category", ",", "key", ")", "==", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_registry.TestRegistry.test_get": [[41, 51], ["pytest.mark.parametrize", "reg.get"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"category,key\"", ",", "\n", "[", "\n", "(", "BACKBONE_CLASS", ",", "\"unet\"", ")", ",", "\n", "(", "LOSS_CLASS", ",", "\"dice\"", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_get", "(", "self", ",", "category", ",", "key", ",", "reg", ")", ":", "\n", "# no error means the key has been registered", "\n", "        ", "_", "=", "reg", ".", "get", "(", "category", ",", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_registry.TestRegistry.test_get_err": [[52, 56], ["pytest.raises", "reg.get", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "def", "test_get_err", "(", "self", ",", "reg", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "reg", ".", "get", "(", "BACKBONE_CLASS", ",", "\"wrong_key\"", ")", "\n", "", "assert", "\"has not been registered\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_registry.TestRegistry.test_build_from_config_err": [[57, 73], ["pytest.mark.parametrize", "pytest.raises", "reg.build_from_config", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_from_config"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"category,config,err_msg\"", ",", "\n", "[", "\n", "(", "BACKBONE_CLASS", ",", "[", "]", ",", "\"config must be a dict\"", ")", ",", "\n", "(", "BACKBONE_CLASS", ",", "{", "}", ",", "\"`config` must contain the key `name`\"", ")", ",", "\n", "(", "\n", "BACKBONE_CLASS", ",", "\n", "{", "\"name\"", ":", "\"unet\"", "}", ",", "\n", "\"Configuration is not compatible for Class\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_build_from_config_err", "(", "self", ",", "category", ",", "config", ",", "err_msg", ",", "reg", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "reg", ".", "build_from_config", "(", "category", "=", "category", ",", "config", "=", "config", ")", "\n", "", "assert", "err_msg", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_registry.TestRegistry.test_build_from_config": [[74, 94], ["pytest.mark.parametrize", "reg.build_from_config", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_from_config"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"category,config\"", ",", "\n", "[", "\n", "(", "\n", "BACKBONE_CLASS", ",", "\n", "dict", "(", "\n", "name", "=", "\"unet\"", ",", "\n", "image_size", "=", "[", "1", ",", "2", ",", "3", "]", ",", "\n", "out_channels", "=", "3", ",", "\n", "num_channel_initial", "=", "3", ",", "\n", "depth", "=", "5", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", ")", ",", "\n", ")", ",", "\n", "(", "LOSS_CLASS", ",", "dict", "(", "name", "=", "\"dice\"", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_build_from_config", "(", "self", ",", "category", ",", "config", ",", "reg", ")", ":", "\n", "        ", "_", "=", "reg", ".", "build_from_config", "(", "category", "=", "category", ",", "config", "=", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_registry.TestRegistry.test_doc": [[95, 155], ["dict", "deepreg.registry.REGISTRY._dict.items", "pandas.DataFrame", "df.sort_values.sort_values.sort_values", "name_to_category.items", "df[].append", "df[].append", "df[].append", "df_cat[].to_markdown", "open", "f.readlines", "re.sub", "got.replace.replace.replace", "re.sub", "expected.replace.replace.replace", "name_to_category.values", "open", "f.writelines"], "methods", ["None"], ["", "def", "test_doc", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the doc maintaining the list of registered classes are correct.\"\"\"", "\n", "\n", "filename", "=", "\"docs/source/docs/registered_classes.md\"", "\n", "\n", "# generate dataframe", "\n", "name_to_category", "=", "{", "\n", "\"Backbone\"", ":", "\"backbone_class\"", ",", "\n", "\"Model\"", ":", "\"model_class\"", ",", "\n", "\"Loss\"", ":", "\"loss_class\"", ",", "\n", "\"Data Augmentation\"", ":", "\"da_class\"", ",", "\n", "\"Data Loader\"", ":", "\"data_loader_class\"", ",", "\n", "\"File Loader\"", ":", "\"file_loader_class\"", ",", "\n", "}", "\n", "for", "category", "in", "KNOWN_CATEGORIES", ":", "\n", "            ", "assert", "category", "in", "name_to_category", ".", "values", "(", ")", "\n", "\n", "", "df", "=", "dict", "(", "category", "=", "[", "]", ",", "key", "=", "[", "]", ",", "value", "=", "[", "]", ")", "\n", "for", "(", "category", ",", "key", ")", ",", "value", "in", "REGISTRY", ".", "_dict", ".", "items", "(", ")", ":", "\n", "            ", "df", "[", "\"category\"", "]", ".", "append", "(", "category", ")", "\n", "df", "[", "\"key\"", "]", ".", "append", "(", "f'\"{key}\"'", ")", "\n", "df", "[", "\"value\"", "]", ".", "append", "(", "f\"`{value.__module__}.{value.__name__}`\"", ")", "\n", "", "df", "=", "pd", ".", "DataFrame", "(", "df", ")", "\n", "df", "=", "df", ".", "sort_values", "(", "[", "\"category\"", ",", "\"key\"", "]", ")", "\n", "\n", "# generate lines", "\n", "lines", "=", "(", "\n", "\"# Registered Classes\\n\\n\"", "\n", "\"> This file is generated automatically.\\n\\n\"", "\n", "\"The following tables contain all registered classes \"", "\n", "\"with their categories and keys.\"", "\n", ")", "\n", "\n", "for", "category_name", ",", "category", "in", "name_to_category", ".", "items", "(", ")", ":", "\n", "            ", "df_cat", "=", "df", "[", "df", ".", "category", "==", "category", "]", "\n", "lines", "+=", "f\"\\n\\n## {category_name}\\n\\n\"", "\n", "lines", "+=", "(", "\n", "f\"The category is `{category}`. \"", "\n", "f\"Registered keys and values are as following.\\n\\n\"", "\n", ")", "\n", "lines", "+=", "df_cat", "[", "[", "\"key\"", ",", "\"value\"", "]", "]", ".", "to_markdown", "(", "index", "=", "False", ")", "\n", "\n", "# check file content", "\n", "", "with", "open", "(", "filename", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "got", "=", "f", ".", "readlines", "(", ")", "\n", "got", "=", "\"\"", ".", "join", "(", "got", ")", "\n", "got", "=", "re", ".", "sub", "(", "r\":-+\"", ",", "\"\"", ",", "got", ")", "\n", "got", "=", "got", ".", "replace", "(", "\" \"", ",", "\"\"", ")", "\n", "expected", "=", "re", ".", "sub", "(", "r\":-+\"", ",", "\"\"", ",", "lines", ")", "\n", "expected", "=", "expected", ".", "replace", "(", "\" \"", ",", "\"\"", ")", "\n", "expected", "=", "expected", "+", "\"\\n\"", "\n", "\n", "assert", "got", "==", "expected", "\n", "\n", "# rewrite the file", "\n", "# if test failed, only need to temporarily comment out the assert", "\n", "# then regenerate the file", "\n", "", "if", "got", "!=", "expected", ":", "\n", "            ", "with", "open", "(", "filename", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "writelines", "(", "lines", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.TestMain.test_mode0": [[19, 36], ["deepreg.vis.main", "os.path.exists", "os.remove"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["def", "test_mode0", "(", "self", ")", ":", "\n", "# test mode 0 and check output", "\n", "        ", "out_path", "=", "\"logs/moving_image.gif\"", "\n", "main", "(", "\n", "args", "=", "[", "\n", "\"--mode\"", ",", "\n", "0", ",", "\n", "\"--image-paths\"", ",", "\n", "self", ".", "img_paths", ",", "\n", "\"--save-path\"", ",", "\n", "\"logs\"", ",", "\n", "\"--interval\"", ",", "\n", "\"50\"", ",", "\n", "]", "\n", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "out_path", ")", "\n", "os", ".", "remove", "(", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.TestMain.test_mode1_output": [[37, 66], ["deepreg.vis.main", "os.path.exists", "os.path.exists", "os.path.exists", "os.remove", "os.remove", "os.remove"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["", "def", "test_mode1_output", "(", "self", ")", ":", "\n", "# test mode 1 and check output", "\n", "        ", "out_path_1", "=", "\"logs/moving_image_slice_1.gif\"", "\n", "out_path_2", "=", "\"logs/moving_image_slice_2.gif\"", "\n", "out_path_3", "=", "\"logs/moving_image_slice_3.gif\"", "\n", "main", "(", "\n", "args", "=", "[", "\n", "\"--mode\"", ",", "\n", "\"1\"", ",", "\n", "\"--image-paths\"", ",", "\n", "self", ".", "img_paths", ",", "\n", "\"--save-path\"", ",", "\n", "\"logs\"", ",", "\n", "\"--interval\"", ",", "\n", "\"50\"", ",", "\n", "\"--num-interval\"", ",", "\n", "\"100\"", ",", "\n", "\"--slice-inds\"", ",", "\n", "\"1,2,3\"", ",", "\n", "\"--ddf-path\"", ",", "\n", "self", ".", "ddf_path", ",", "\n", "]", "\n", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "out_path_1", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "out_path_2", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "out_path_3", ")", "\n", "os", ".", "remove", "(", "out_path_1", ")", "\n", "os", ".", "remove", "(", "out_path_2", ")", "\n", "os", ".", "remove", "(", "out_path_3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.TestMain.test_mode1_no_slidce_inds": [[67, 87], ["deepreg.vis.main", "any", "os.listdir"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["", "def", "test_mode1_no_slidce_inds", "(", "self", ")", ":", "\n", "# test mode 1 and check output when no slice_inds", "\n", "        ", "out_path_partial", "=", "\"moving_image_slice\"", "\n", "main", "(", "\n", "args", "=", "[", "\n", "\"--mode\"", ",", "\n", "\"1\"", ",", "\n", "\"--image-paths\"", ",", "\n", "self", ".", "img_paths", ",", "\n", "\"--save-path\"", ",", "\n", "\"logs\"", ",", "\n", "\"--interval\"", ",", "\n", "\"50\"", ",", "\n", "\"--num-interval\"", ",", "\n", "\"100\"", ",", "\n", "\"--ddf-path\"", ",", "\n", "self", ".", "ddf_path", ",", "\n", "]", "\n", ")", "\n", "assert", "any", "(", "[", "out_path_partial", "in", "file", "for", "file", "in", "os", ".", "listdir", "(", "\"logs\"", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.TestMain.test_mode1_err": [[88, 108], ["pytest.raises", "deepreg.vis.main", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["", "def", "test_mode1_err", "(", "self", ")", ":", "\n", "# test mode 1 and check if exception is caught", "\n", "        ", "with", "pytest", ".", "raises", "(", "Exception", ")", "as", "err_info", ":", "\n", "            ", "main", "(", "\n", "args", "=", "[", "\n", "\"--mode\"", ",", "\n", "\"1\"", ",", "\n", "\"--image-paths\"", ",", "\n", "self", ".", "img_paths", ",", "\n", "\"--save-path\"", ",", "\n", "\"logs\"", ",", "\n", "\"--interval\"", ",", "\n", "\"50\"", ",", "\n", "\"--num-interval\"", ",", "\n", "\"100\"", ",", "\n", "\"--slice-inds\"", ",", "\n", "\"1,2,3\"", ",", "\n", "]", "\n", ")", "\n", "", "assert", "\"--ddf-path is required when using --mode 1\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.TestMain.test_mode2_output": [[109, 146], ["pytest.mark.parametrize", "deepreg.vis.main", "os.path.exists", "os.remove"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"extra_args\"", ",", "\n", "[", "\n", "[", "\n", "\"--slice-inds\"", ",", "\n", "\"1,2,3\"", ",", "\n", "\"--fname\"", ",", "\n", "\"visualisation.png\"", ",", "\n", "\"--col-titles\"", ",", "\n", "\"abc\"", ",", "\n", "]", ",", "\n", "[", "\n", "\"--slice-inds\"", ",", "\n", "\"1,2,3\"", ",", "\n", "\"--fname\"", ",", "\n", "\"visualisation.png\"", ",", "\n", "]", ",", "# no col_titles", "\n", "[", "\n", "\"--col-titles\"", ",", "\n", "\"abc\"", ",", "\n", "]", ",", "# no slice_inds and no fname", "\n", "]", ",", "\n", ")", "\n", "def", "test_mode2_output", "(", "self", ",", "extra_args", ")", ":", "\n", "# test mode 2 and check output", "\n", "        ", "common_args", "=", "[", "\n", "\"--mode\"", ",", "\n", "\"2\"", ",", "\n", "\"--image-paths\"", ",", "\n", "self", ".", "img_paths", ",", "\n", "\"--save-path\"", ",", "\n", "\"logs\"", ",", "\n", "]", "\n", "out_path", "=", "\"logs/visualisation.png\"", "\n", "main", "(", "args", "=", "common_args", "+", "extra_args", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "out_path", ")", "\n", "os", ".", "remove", "(", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.TestMain.test_case3": [[147, 178], ["pytest.mark.parametrize", "deepreg.vis.main", "os.path.exists", "os.remove"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"extra_args\"", ",", "\n", "[", "\n", "[", "\n", "\"--fname\"", ",", "\n", "\"visualisation.gif\"", ",", "\n", "]", ",", "\n", "[", "]", ",", "# no fname", "\n", "]", ",", "\n", ")", "\n", "def", "test_case3", "(", "self", ",", "extra_args", ")", ":", "\n", "# test mode 3 and check output", "\n", "        ", "out_path", "=", "\"logs/visualisation.gif\"", "\n", "img_paths_moded", "=", "\",\"", ".", "join", "(", "[", "self", ".", "img_paths", "]", "*", "6", ")", "\n", "common_args", "=", "[", "\n", "\"--mode\"", ",", "\n", "\"3\"", ",", "\n", "\"--image-paths\"", ",", "\n", "img_paths_moded", ",", "\n", "\"--save-path\"", ",", "\n", "\"logs\"", ",", "\n", "\"--interval\"", ",", "\n", "\"50\"", ",", "\n", "\"--size\"", ",", "\n", "\"2,3\"", ",", "\n", "]", "\n", "main", "(", "\n", "args", "=", "common_args", "+", "extra_args", ",", "\n", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "out_path", ")", "\n", "os", ".", "remove", "(", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.TestMain.test_mode3_num_image_err": [[179, 200], ["pytest.raises", "deepreg.vis.main", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["", "def", "test_mode3_num_image_err", "(", "self", ")", ":", "\n", "# test mode 3 and check if exception is caught", "\n", "        ", "img_paths", "=", "\",\"", ".", "join", "(", "[", "self", ".", "img_paths", "]", "*", "6", ")", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", "as", "err_info", ":", "\n", "            ", "main", "(", "\n", "args", "=", "[", "\n", "\"--mode\"", ",", "\n", "\"3\"", ",", "\n", "\"--image-paths\"", ",", "\n", "img_paths", ",", "\n", "\"--save-path\"", ",", "\n", "\"logs\"", ",", "\n", "\"--interval\"", ",", "\n", "\"50\"", ",", "\n", "\"--size\"", ",", "\n", "\"2,1\"", ",", "\n", "\"--fname\"", ",", "\n", "\"visualisation.gif\"", ",", "\n", "]", "\n", ")", "\n", "", "assert", "\"The number of images supplied is \"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.TestMain.test_mode3_shape_err": [[201, 223], ["pytest.raises", "deepreg.vis.main", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["", "def", "test_mode3_shape_err", "(", "self", ")", ":", "\n", "# test mode 3 and check if exception is caught", "\n", "        ", "new_img_path", "=", "\"data/test/nifti/paired/test/fixed_images/case000025.nii.gz\"", "\n", "img_paths_moded", "=", "self", ".", "img_paths", "+", "\",\"", "+", "new_img_path", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", "as", "err_info", ":", "\n", "            ", "main", "(", "\n", "args", "=", "[", "\n", "\"--mode\"", ",", "\n", "\"3\"", ",", "\n", "\"--image-paths\"", ",", "\n", "img_paths_moded", ",", "\n", "\"--save-path\"", ",", "\n", "\"logs\"", ",", "\n", "\"--interval\"", ",", "\n", "\"50\"", ",", "\n", "\"--size\"", ",", "\n", "\"2,1\"", ",", "\n", "\"--fname\"", ",", "\n", "\"visualisation.gif\"", ",", "\n", "]", "\n", ")", "\n", "", "assert", "\"all images do not have equal shapes\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_vis.test_string_to_list": [[8, 13], ["deepreg.vis.string_to_list"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.string_to_list"], ["def", "test_string_to_list", "(", ")", ":", "\n", "    ", "string", "=", "\"abc, 123, def, 456\"", "\n", "got", "=", "string_to_list", "(", "string", ")", "\n", "expected", "=", "[", "\"abc\"", ",", "\"123\"", ",", "\"def\"", ",", "\"456\"", "]", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_callback.test_restore_checkpoint_manager_callback": [[9, 87], ["Net.compile", "deepreg.callback.build_checkpoint_callback", "Net.fit", "Net.compile", "deepreg.callback.build_checkpoint_callback", "new_callback._manager.save", "tensorflow.train.load_checkpoint", "tensorflow.train.load_checkpoint", "tf.train.load_checkpoint.get_variable_to_shape_map().keys", "Net.fit", "shutil.rmtree", "shutil.rmtree", "tensorflow.data.Dataset.from_tensor_slices().repeat().batch", "len", "tensorflow.distribute.MirroredStrategy", "tensorflow.distribute.get_strategy", "tf.distribute.get_strategy.scope", "Net", "tensorflow.keras.optimizers.Adam", "tf.distribute.get_strategy.scope", "Net", "tensorflow.keras.optimizers.Adam", "super().__init__", "tensorflow.keras.layers.Dense", "test_callback..l1", "tensorflow.range", "tensorflow.config.list_physical_devices", "test_callback.test_restore_checkpoint_manager_callback.toy_dataset"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.build_checkpoint_callback", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.build_checkpoint_callback", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "test_restore_checkpoint_manager_callback", "(", ")", ":", "\n", "    ", "\"\"\"\n    testing restore CheckpointManagerCallback\n    \"\"\"", "\n", "\n", "# toy model", "\n", "class", "Net", "(", "tf", ".", "keras", ".", "Model", ")", ":", "\n", "        ", "\"\"\"A simple linear model.\"\"\"", "\n", "\n", "def", "__init__", "(", "self", ")", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "l1", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "5", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "x", ",", "training", "=", "False", ")", ":", "\n", "            ", "return", "self", ".", "l1", "(", "x", ")", "\n", "\n", "# toy dataset", "\n", "", "", "def", "toy_dataset", "(", ")", ":", "\n", "        ", "inputs", "=", "tf", ".", "range", "(", "10.0", ")", "[", ":", ",", "None", "]", "\n", "labels", "=", "inputs", "*", "5.0", "+", "tf", ".", "range", "(", "5.0", ")", "[", "None", ",", ":", "]", "\n", "return", "tf", ".", "data", ".", "Dataset", ".", "from_tensor_slices", "(", "(", "inputs", ",", "labels", ")", ")", ".", "repeat", "(", ")", ".", "batch", "(", "2", ")", "\n", "\n", "# train old_model and save", "\n", "", "if", "len", "(", "tf", ".", "config", ".", "list_physical_devices", "(", "\"gpu\"", ")", ")", ">", "1", ":", "\n", "        ", "strategy", "=", "tf", ".", "distribute", ".", "MirroredStrategy", "(", ")", "\n", "", "else", ":", "# use default strategy", "\n", "        ", "strategy", "=", "tf", ".", "distribute", ".", "get_strategy", "(", ")", "\n", "\n", "", "with", "strategy", ".", "scope", "(", ")", ":", "\n", "        ", "old_model", "=", "Net", "(", ")", "\n", "old_optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "Adam", "(", "0.1", ")", "\n", "", "old_model", ".", "compile", "(", "optimizer", "=", "old_optimizer", ",", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "MSE", ")", "\n", "old_callback", ",", "_", "=", "build_checkpoint_callback", "(", "\n", "model", "=", "old_model", ",", "\n", "dataset", "=", "toy_dataset", "(", ")", ",", "\n", "log_dir", "=", "\"./test/unit/old\"", ",", "\n", "save_period", "=", "5", ",", "\n", "ckpt_path", "=", "\"\"", ",", "\n", ")", "\n", "old_model", ".", "fit", "(", "\n", "x", "=", "toy_dataset", "(", ")", ",", "epochs", "=", "10", ",", "steps_per_epoch", "=", "10", ",", "callbacks", "=", "[", "old_callback", "]", "\n", ")", "\n", "\n", "# create new model and restore old_model checkpoint", "\n", "with", "strategy", ".", "scope", "(", ")", ":", "\n", "        ", "new_model", "=", "Net", "(", ")", "\n", "new_optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "Adam", "(", "0.1", ")", "\n", "", "new_model", ".", "compile", "(", "optimizer", "=", "new_optimizer", ",", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "MSE", ")", "\n", "new_callback", ",", "initial_epoch", "=", "build_checkpoint_callback", "(", "\n", "model", "=", "new_model", ",", "\n", "dataset", "=", "toy_dataset", "(", ")", ",", "\n", "log_dir", "=", "\"./test/unit/new\"", ",", "\n", "save_period", "=", "5", ",", "\n", "ckpt_path", "=", "\"./test/unit/old/save/ckpt-10\"", ",", "\n", ")", "\n", "\n", "# check equal", "\n", "new_callback", ".", "_manager", ".", "save", "(", "0", ")", "\n", "old_reader", "=", "tf", ".", "train", ".", "load_checkpoint", "(", "\"./test/unit/old/save/ckpt-10\"", ")", "\n", "new_reader", "=", "tf", ".", "train", ".", "load_checkpoint", "(", "\"./test/unit/new/save\"", ")", "\n", "for", "k", "in", "old_reader", ".", "get_variable_to_shape_map", "(", ")", ".", "keys", "(", ")", ":", "\n", "        ", "if", "\"save_counter\"", "not", "in", "k", "and", "\"_CHECKPOINTABLE_OBJECT_GRAPH\"", "not", "in", "k", ":", "\n", "            ", "equal", "=", "np", ".", "array", "(", "old_reader", ".", "get_tensor", "(", "k", ")", ")", "==", "np", ".", "array", "(", "\n", "new_reader", ".", "get_tensor", "(", "k", ")", "\n", ")", "\n", "assert", "np", ".", "all", "(", "equal", ")", ",", "\"{} fail to restore !\"", ".", "format", "(", "k", ")", "\n", "\n", "", "", "new_model", ".", "fit", "(", "\n", "x", "=", "toy_dataset", "(", ")", ",", "\n", "initial_epoch", "=", "initial_epoch", ",", "\n", "epochs", "=", "20", ",", "\n", "steps_per_epoch", "=", "10", ",", "\n", "callbacks", "=", "[", "new_callback", "]", ",", "\n", ")", "\n", "\n", "# remove temporary ckpt directories", "\n", "shutil", ".", "rmtree", "(", "\"./test/unit/old\"", ")", "\n", "shutil", ".", "rmtree", "(", "\"./test/unit/new\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_log.log_file_path": [[11, 20], ["pytest.fixture", "tmp_path_factory.mktemp"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", ")", "\n", "def", "log_file_path", "(", "tmp_path_factory", ")", "->", "Path", ":", "\n", "    ", "\"\"\"\n    Fixture for temporary log file.\n\n    :param tmp_path_factory: default fixture.\n    :return: a temporary file path\n    \"\"\"", "\n", "return", "tmp_path_factory", ".", "mktemp", "(", "\"test_log\"", ")", "/", "\"log.txt\"", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_log.test_get": [[22, 49], ["pytest.mark.parametrize", "str", "deepreg.log.get", "logging.FileHandler", "logging.FileHandler.setLevel", "log.get.addHandler", "log.get.debug", "log.get.info", "log.get.warning", "log.get.error", "log.get.critical", "open", "len", "f.readlines", "max"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"log_level\"", ",", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", "\n", "def", "test_get", "(", "log_level", ":", "int", ",", "log_file_path", ":", "Path", ")", ":", "\n", "    ", "\"\"\"\n    Test loggers by count number of logs.\n\n    :param log_level: 0 to 5.\n    :param log_file_path: path of a temporary log file.\n    \"\"\"", "\n", "os", ".", "environ", "[", "\"DEEPREG_LOG_LEVEL\"", "]", "=", "str", "(", "log_level", ")", "\n", "logger", "=", "log", ".", "get", "(", "__name__", ")", "\n", "\n", "# save logs into a file", "\n", "handler", "=", "logging", ".", "FileHandler", "(", "log_file_path", ")", "\n", "handler", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "addHandler", "(", "handler", ")", "\n", "\n", "logger", ".", "debug", "(", "\"DEBUG\"", ")", "\n", "logger", ".", "info", "(", "\"INFO\"", ")", "\n", "logger", ".", "warning", "(", "\"WARNING\"", ")", "\n", "logger", ".", "error", "(", "\"ERROR\"", ")", "\n", "logger", ".", "critical", "(", "\"CRITICAL\"", ")", "\n", "\n", "# count lines in the file", "\n", "with", "open", "(", "log_file_path", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "num_logs", "=", "len", "(", "f", ".", "readlines", "(", ")", ")", "\n", "\n", "", "assert", "num_logs", "==", "6", "-", "max", "(", "1", ",", "log_level", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_unpaired_loader.test_sample_index_generator": [[19, 58], ["FileLoaderDict.items", "numpy.allclose", "os.path.join", "deepreg.dataset.loader.unpaired_loader.UnpairedDataLoader", "deepreg.dataset.loader.unpaired_loader.UnpairedDataLoader.sample_index_generator", "indices_to_compare.append", "numpy.allclose", "isinstance", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.sample_index_generator"], ["def", "test_sample_index_generator", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test to check the randomness and deterministic index generator\n    for train/test respectively.\n    \"\"\"", "\n", "image_shape", "=", "(", "64", ",", "64", ",", "60", ")", "\n", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "            ", "data_dir_path", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "split", ")", "]", "\n", "indices_to_compare", "=", "[", "]", "\n", "\n", "for", "seed", "in", "[", "0", ",", "1", ",", "0", "]", ":", "\n", "                ", "data_loader", "=", "UnpairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "\n", "data_indices", "=", "[", "]", "\n", "for", "(", "\n", "moving_index", ",", "\n", "fixed_index", ",", "\n", "indices", ",", "\n", ")", "in", "data_loader", ".", "sample_index_generator", "(", ")", ":", "\n", "                    ", "assert", "isinstance", "(", "moving_index", ",", "int", ")", "\n", "assert", "isinstance", "(", "fixed_index", ",", "int", ")", "\n", "assert", "isinstance", "(", "indices", ",", "list", ")", "\n", "data_indices", "+=", "indices", "\n", "\n", "", "indices_to_compare", ".", "append", "(", "data_indices", ")", "\n", "\n", "# test different seeds give different indices", "\n", "", "assert", "not", "np", ".", "allclose", "(", "indices_to_compare", "[", "0", "]", ",", "indices_to_compare", "[", "1", "]", ")", "\n", "# test same seeds give the same indices", "\n", "assert", "np", ".", "allclose", "(", "indices_to_compare", "[", "0", "]", ",", "indices_to_compare", "[", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_unpaired_loader.test_validate_data_files": [[60, 82], ["FileLoaderDict.items", "dict", "deepreg.dataset.loader.unpaired_loader.UnpairedDataLoader", "os.path.join", "deepreg.dataset.loader.unpaired_loader.UnpairedDataLoader.validate_data_files"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.validate_data_files"], ["", "", "", "def", "test_validate_data_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the validate_data_files functions that looks for inconsistencies\n    in the fixed/moving image and label lists.\n    If there is any issue it will raise an error, otherwise it returns None.\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "            ", "data_dir_path", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "split", ")", "]", "\n", "image_shape", "=", "(", "64", ",", "64", ",", "60", ")", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "seed", "=", "None", "if", "split", "==", "\"train\"", "else", "0", ",", "\n", ")", "\n", "\n", "data_loader", "=", "UnpairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path", ",", "image_shape", "=", "image_shape", ",", "**", "common_args", "\n", ")", "\n", "\n", "assert", "data_loader", ".", "validate_data_files", "(", ")", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_unpaired_loader.test_close": [[84, 110], ["FileLoaderDict.items", "dict", "deepreg.dataset.loader.unpaired_loader.UnpairedDataLoader", "os.path.join", "deepreg.dataset.loader.unpaired_loader.UnpairedDataLoader.close", "deepreg.dataset.loader.unpaired_loader.UnpairedDataLoader.loader_moving_image.h5_files.values", "f.__bool__"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "", "def", "test_close", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the close function. Only needed for H5 data loaders for now.\n    Since fixed/moving loaders are the same for\n    unpaired data loader, only need to test the moving.\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "\n", "            ", "data_dir_path", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "split", ")", "]", "\n", "image_shape", "=", "(", "64", ",", "64", ",", "60", ")", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "seed", "=", "None", "if", "split", "==", "\"train\"", "else", "0", ",", "\n", ")", "\n", "\n", "data_loader", "=", "UnpairedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_path", ",", "image_shape", "=", "image_shape", ",", "**", "common_args", "\n", ")", "\n", "\n", "if", "key_file_loader", "==", "\"h5\"", ":", "\n", "                ", "data_loader", ".", "close", "(", ")", "\n", "for", "f", "in", "data_loader", ".", "loader_moving_image", ".", "h5_files", ".", "values", "(", ")", ":", "\n", "                    ", "assert", "not", "f", ".", "__bool__", "(", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_train.TestBuildConfig.test_ckpt_path": [[24, 36], ["pytest.mark.parametrize", "deepreg.train.build_config", "isinstance", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.build_config"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"ckpt_path\"", ",", "[", "\"\"", ",", "\"example.ckpt\"", "]", ")", "\n", "def", "test_ckpt_path", "(", "self", ",", "ckpt_path", ")", ":", "\n", "# check the code can pass", "\n", "\n", "        ", "got_config", ",", "got_log_dir", ",", "_", "=", "build_config", "(", "\n", "config_path", "=", "self", ".", "config_path", ",", "\n", "log_dir", "=", "self", ".", "log_dir", ",", "\n", "exp_name", "=", "self", ".", "exp_name", ",", "\n", "ckpt_path", "=", "ckpt_path", ",", "\n", ")", "\n", "assert", "isinstance", "(", "got_config", ",", "dict", ")", "\n", "assert", "got_log_dir", "==", "os", ".", "path", ".", "join", "(", "self", ".", "log_dir", ",", "self", ".", "exp_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_train.TestBuildConfig.test_max_epochs": [[37, 50], ["pytest.mark.parametrize", "deepreg.train.build_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.build_config"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"max_epochs, expected_epochs, expected_save_period\"", ",", "[", "(", "-", "1", ",", "2", ",", "2", ")", ",", "(", "3", ",", "3", ",", "2", ")", "]", "\n", ")", "\n", "def", "test_max_epochs", "(", "self", ",", "max_epochs", ",", "expected_epochs", ",", "expected_save_period", ")", ":", "\n", "        ", "got_config", ",", "_", ",", "_", "=", "build_config", "(", "\n", "config_path", "=", "self", ".", "config_path", ",", "\n", "log_dir", "=", "self", ".", "log_dir", ",", "\n", "exp_name", "=", "self", ".", "exp_name", ",", "\n", "ckpt_path", "=", "\"\"", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", ")", "\n", "assert", "got_config", "[", "\"train\"", "]", "[", "\"epochs\"", "]", "==", "expected_epochs", "\n", "assert", "got_config", "[", "\"train\"", "]", "[", "\"save_period\"", "]", "==", "expected_save_period", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_train.test_train_and_predict_main": [[52, 107], ["pytest.mark.parametrize", "deepreg.train.main", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isfile", "deepreg.predict.main", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isfile", "os.path.isfile", "os.path.isfile", "shutil.rmtree", "shutil.rmtree"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"config_paths\"", ",", "\n", "[", "\n", "[", "\"config/unpaired_labeled_ddf.yaml\"", "]", ",", "\n", "[", "\"config/unpaired_labeled_ddf.yaml\"", ",", "\"config/test/affine.yaml\"", "]", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_train_and_predict_main", "(", "config_paths", ")", ":", "\n", "    ", "\"\"\"\n    Test main in train and predict by checking it can run.\n\n    :param config_paths: list of file paths for configuration.\n    \"\"\"", "\n", "train_main", "(", "\n", "args", "=", "[", "\n", "\"--gpu\"", ",", "\n", "\"\"", ",", "\n", "\"--exp_name\"", ",", "\n", "\"test_train\"", ",", "\n", "\"--config_path\"", ",", "\n", "]", "\n", "+", "config_paths", "\n", ")", "\n", "\n", "# check output folders", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "\"logs/test_train/save\"", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "\"logs/test_train/train\"", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "\"logs/test_train/validation\"", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "\"logs/test_train/config.yaml\"", ")", "\n", "\n", "predict_main", "(", "\n", "args", "=", "[", "\n", "\"--gpu\"", ",", "\n", "\"\"", ",", "\n", "\"--ckpt_path\"", ",", "\n", "\"logs/test_train/save/ckpt-2\"", ",", "\n", "\"--split\"", ",", "\n", "\"test\"", ",", "\n", "\"--exp_name\"", ",", "\n", "\"test_predict\"", ",", "\n", "\"--save_nifti\"", ",", "\n", "\"--save_png\"", ",", "\n", "]", "\n", ")", "\n", "\n", "# check output folders", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "\"logs/test_predict/test/pair_0_1/label_0\"", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "\"logs/test_predict/test/pair_0_1/label_1\"", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "\"logs/test_predict/test/pair_0_1/label_2\"", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "\"logs/test_predict/test/metrics.csv\"", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "\"logs/test_predict/test/metrics_stats_per_label.csv\"", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "\"logs/test_predict/test/metrics_stats_overall.csv\"", ")", "\n", "\n", "shutil", ".", "rmtree", "(", "\"logs/test_train\"", ")", "\n", "shutil", ".", "rmtree", "(", "\"logs/test_predict\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_model_optimizer.TestBuildOptimizer.test_build_optimizer_adam": [[13, 18], ["deepreg.build_optimizer", "isinstance"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.optimizer.build_optimizer"], ["    ", "def", "test_build_optimizer_adam", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build an Adam optimizer\"\"\"", "\n", "opt_config", "=", "{", "\"name\"", ":", "\"Adam\"", ",", "\"learning_rate\"", ":", "1.0e-5", "}", "\n", "opt_get", "=", "optimizer", ".", "build_optimizer", "(", "opt_config", ")", "\n", "assert", "isinstance", "(", "opt_get", ",", "tf", ".", "keras", ".", "optimizers", ".", "Adam", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_model_optimizer.TestBuildOptimizer.test_build_optimizer_sgd": [[19, 24], ["deepreg.build_optimizer", "isinstance"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.optimizer.build_optimizer"], ["", "def", "test_build_optimizer_sgd", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build an SGD optimizer\"\"\"", "\n", "opt_config", "=", "{", "\"name\"", ":", "\"SGD\"", "}", "\n", "opt_get", "=", "optimizer", ".", "build_optimizer", "(", "opt_config", ")", "\n", "assert", "isinstance", "(", "opt_get", ",", "tf", ".", "keras", ".", "optimizers", ".", "SGD", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_util.test_sorted_h5_keys": [[16, 30], ["testfixtures.TempDirectory", "numpy.random.random", "h5py.File", "h5py.File.create_dataset", "h5py.File.close", "deepreg.get_h5_sorted_keys"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_h5_sorted_keys"], ["def", "test_sorted_h5_keys", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test to check a key is returned with one entry\n    \"\"\"", "\n", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "# Creating some dummy data", "\n", "        ", "d1", "=", "np", ".", "random", ".", "random", "(", "size", "=", "(", "1000", ",", "20", ")", ")", "\n", "hf", "=", "h5py", ".", "File", "(", "tempdir", ".", "path", "+", "\"data.h5\"", ",", "\"w\"", ")", "\n", "hf", ".", "create_dataset", "(", "\"dataset_1\"", ",", "data", "=", "d1", ")", "\n", "hf", ".", "close", "(", ")", "\n", "# Checking func returns the same thing", "\n", "expected", "=", "[", "\"dataset_1\"", "]", "\n", "actual", "=", "util", ".", "get_h5_sorted_keys", "(", "tempdir", ".", "path", "+", "\"data.h5\"", ")", "\n", "assert", "expected", "==", "actual", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_util.test_sorted_h5_keys_many": [[32, 49], ["testfixtures.TempDirectory", "numpy.random.random", "h5py.File", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.close", "deepreg.get_h5_sorted_keys"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_h5_sorted_keys"], ["", "", "def", "test_sorted_h5_keys_many", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test to check a key is returned with many entries\n    \"\"\"", "\n", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "# Creating some dummy data", "\n", "        ", "d1", "=", "np", ".", "random", ".", "random", "(", "size", "=", "(", "10", ",", "20", ")", ")", "\n", "hf", "=", "h5py", ".", "File", "(", "tempdir", ".", "path", "+", "\"data.h5\"", ",", "\"w\"", ")", "\n", "# Adding entries in different order", "\n", "hf", ".", "create_dataset", "(", "\"dataset_1\"", ",", "data", "=", "d1", ")", "\n", "hf", ".", "create_dataset", "(", "\"dataset_3\"", ",", "data", "=", "d1", ")", "\n", "hf", ".", "create_dataset", "(", "\"dataset_2\"", ",", "data", "=", "d1", ")", "\n", "hf", ".", "close", "(", ")", "\n", "# Checking func returns the same thing", "\n", "expected", "=", "[", "\"dataset_1\"", ",", "\"dataset_2\"", ",", "\"dataset_3\"", "]", "\n", "actual", "=", "util", ".", "get_h5_sorted_keys", "(", "tempdir", ".", "path", "+", "\"data.h5\"", ")", "\n", "assert", "expected", "==", "actual", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_util.test_get_sorted_file_paths_in_dir_with_suffix": [[51, 115], ["testfixtures.TempDirectory", "tempdir.write", "tempdir.write", "tempdir.write", "deepreg.get_sorted_file_paths_in_dir_with_suffix", "testfixtures.TempDirectory", "tempdir.write", "tempdir.write", "tempdir.write", "deepreg.get_sorted_file_paths_in_dir_with_suffix", "testfixtures.TempDirectory", "tempdir.write", "tempdir.write", "tempdir.write", "tempdir.write", "tempdir.write", "tempdir.write", "deepreg.get_sorted_file_paths_in_dir_with_suffix", "testfixtures.TempDirectory", "tempdir.write", "tempdir.write", "tempdir.write", "tempdir.write", "tempdir.write", "tempdir.write", "deepreg.get_sorted_file_paths_in_dir_with_suffix", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes", "bytes"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_sorted_file_paths_in_dir_with_suffix", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_sorted_file_paths_in_dir_with_suffix", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_sorted_file_paths_in_dir_with_suffix", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_sorted_file_paths_in_dir_with_suffix"], ["", "", "def", "test_get_sorted_file_paths_in_dir_with_suffix", "(", ")", ":", "\n", "    ", "\"\"\"\n    Checking sorted file names returned\n    \"\"\"", "\n", "\n", "# one dir, single suffix", "\n", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/a.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/b.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/c.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "expected", "=", "[", "(", "\"a\"", ",", "\"txt\"", ")", ",", "(", "\"b\"", ",", "\"txt\"", ")", ",", "(", "\"c\"", ",", "\"txt\"", ")", "]", "\n", "actual", "=", "util", ".", "get_sorted_file_paths_in_dir_with_suffix", "(", "tempdir", ".", "path", ",", "\"txt\"", ")", "\n", "assert", "expected", "==", "actual", "\n", "\n", "# one dir, multiple suffixes", "\n", "", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/a.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/b.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/c.md\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "expected", "=", "[", "(", "\"a\"", ",", "\"txt\"", ")", ",", "(", "\"b\"", ",", "\"txt\"", ")", ",", "(", "\"c\"", ",", "\"md\"", ")", "]", "\n", "actual", "=", "util", ".", "get_sorted_file_paths_in_dir_with_suffix", "(", "\n", "tempdir", ".", "path", ",", "[", "\"txt\"", ",", "\"md\"", "]", "\n", ")", "\n", "assert", "expected", "==", "actual", "\n", "\n", "# multiple sub-dirs, single suffix", "\n", "", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/1/a.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/1/b.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/1/c.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/2/a.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/2/b.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/2/c.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "expected", "=", "[", "\n", "(", "\"1/a\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"1/b\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"1/c\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"2/a\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"2/b\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"2/c\"", ",", "\"txt\"", ")", ",", "\n", "]", "\n", "actual", "=", "util", ".", "get_sorted_file_paths_in_dir_with_suffix", "(", "tempdir", ".", "path", ",", "\"txt\"", ")", "\n", "assert", "expected", "==", "actual", "\n", "\n", "# multiple sub-dirs, multiple suffixes", "\n", "", "with", "TempDirectory", "(", ")", "as", "tempdir", ":", "\n", "        ", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/1/a.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/1/b.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/1/c.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/2/a.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/2/b.txt\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "tempdir", ".", "write", "(", "(", "tempdir", ".", "path", "+", "\"/2/c.md\"", ")", ",", "(", "bytes", "(", "1", ")", ")", ")", "\n", "expected", "=", "[", "\n", "(", "\"1/a\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"1/b\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"1/c\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"2/a\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"2/b\"", ",", "\"txt\"", ")", ",", "\n", "(", "\"2/c\"", ",", "\"md\"", ")", ",", "\n", "]", "\n", "actual", "=", "util", ".", "get_sorted_file_paths_in_dir_with_suffix", "(", "\n", "tempdir", ".", "path", ",", "[", "\"txt\"", ",", "\"md\"", "]", "\n", ")", "\n", "assert", "expected", "==", "actual", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_util.test_check_difference_between_two_lists": [[117, 138], ["deepreg.check_difference_between_two_lists", "pytest.raises", "deepreg.check_difference_between_two_lists", "str", "pytest.raises", "deepreg.check_difference_between_two_lists", "str"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists"], ["", "", "def", "test_check_difference_between_two_lists", "(", ")", ":", "\n", "    ", "\"\"\"\n    Check check_difference_between_two_lists by verifying ValueError\n    \"\"\"", "\n", "# same lists, no error", "\n", "list1", "=", "list2", "=", "[", "0", ",", "1", ",", "2", "]", "\n", "util", ".", "check_difference_between_two_lists", "(", "list1", ",", "list2", ",", "name", "=", "\"same case\"", ")", "\n", "\n", "# diff lists with same unique numbers", "\n", "list_1", "=", "[", "0", ",", "1", ",", "2", "]", "\n", "list_2", "=", "[", "1", ",", "2", ",", "0", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "        ", "util", ".", "check_difference_between_two_lists", "(", "list_1", ",", "list_2", ",", "name", "=", "\"diff case\"", ")", "\n", "", "assert", "\"diff case are not identical\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n", "# totally diff lists", "\n", "list_1", "=", "[", "0", ",", "1", ",", "2", "]", "\n", "list_2", "=", "[", "3", ",", "4", ",", "5", "]", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "        ", "util", ".", "check_difference_between_two_lists", "(", "list_1", ",", "list_2", ",", "name", "=", "\"diff case\"", ")", "\n", "", "assert", "\"diff case are not identical\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_util.test_label_indices_sample": [[140, 147], ["deepreg.get_label_indices", "expected.intersection", "set"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_label_indices"], ["", "def", "test_label_indices_sample", "(", ")", ":", "\n", "    ", "\"\"\"\n    Assert random number for passed arg returned\n    \"\"\"", "\n", "expected", "=", "{", "0", ",", "1", ",", "2", ",", "3", "}", "\n", "actual", "=", "util", ".", "get_label_indices", "(", "4", ",", "\"sample\"", ")", "\n", "assert", "expected", ".", "intersection", "(", "set", "(", "actual", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_util.test_label_indices_all": [[149, 156], ["deepreg.get_label_indices"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_label_indices"], ["", "def", "test_label_indices_all", "(", ")", ":", "\n", "    ", "\"\"\"\n    Assert list with all labels returned if all passed\n    \"\"\"", "\n", "expected", "=", "[", "0", ",", "1", ",", "2", "]", "\n", "actual", "=", "util", ".", "get_label_indices", "(", "3", ",", "\"all\"", ")", "\n", "assert", "expected", "==", "actual", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_util.test_label_indices_unknown": [[158, 165], ["pytest.raises", "deepreg.get_label_indices"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_label_indices"], ["", "def", "test_label_indices_unknown", "(", ")", ":", "\n", "    ", "\"\"\"\n    Assert ValueError raised if unknown string passed to sample\n    label\n    \"\"\"", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "util", ".", "get_label_indices", "(", "3", ",", "\"random_str\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_unet.TestUNet.test_channels": [[19, 75], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "tensorflow.ones", "deepreg.model.backbone.u_net.UNet.call", "deepreg.model.backbone.u_net.UNet"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"depth,encode_num_channels,decode_num_channels\"", ",", "\n", "[", "\n", "(", "2", ",", "(", "4", ",", "8", ",", "16", ")", ",", "(", "4", ",", "8", ",", "16", ")", ")", ",", "\n", "(", "2", ",", "(", "4", ",", "8", ",", "8", ")", ",", "(", "4", ",", "8", ",", "8", ")", ")", ",", "\n", "(", "2", ",", "(", "4", ",", "8", ",", "8", ")", ",", "(", "8", ",", "8", ",", "8", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"pooling\"", ",", "[", "True", ",", "False", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"concat_skip\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_channels", "(", "\n", "self", ",", "\n", "depth", ":", "int", ",", "\n", "encode_num_channels", ":", "Tuple", ",", "\n", "decode_num_channels", ":", "Tuple", ",", "\n", "pooling", ":", "bool", ",", "\n", "concat_skip", ":", "bool", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test unet with custom encode/decode channels.\n\n        :param depth: input is at level 0, bottom is at level depth\n        :param encode_num_channels: filters/channels for down-sampling,\n            by default it is doubled at each layer during down-sampling\n        :param decode_num_channels: filters/channels for up-sampling,\n            by default it is the same as encode_num_channels\n        :param pooling: for down-sampling, use non-parameterized\n                        pooling if true, otherwise use conv3d\n        :param concat_skip: if concatenate skip or add it\n        \"\"\"", "\n", "# in case of adding skip tensors, the channels should match", "\n", "expect_err", "=", "(", "not", "concat_skip", ")", "and", "encode_num_channels", "!=", "decode_num_channels", "\n", "\n", "image_size", "=", "(", "5", ",", "6", ",", "7", ")", "\n", "out_ch", "=", "3", "\n", "try", ":", "\n", "            ", "network", "=", "UNet", "(", "\n", "image_size", "=", "image_size", ",", "\n", "out_channels", "=", "out_ch", ",", "\n", "num_channel_initial", "=", "0", ",", "\n", "encode_num_channels", "=", "encode_num_channels", ",", "\n", "decode_num_channels", "=", "decode_num_channels", ",", "\n", "depth", "=", "depth", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", "pooling", "=", "pooling", ",", "\n", "concat_skip", "=", "concat_skip", ",", "\n", ")", "\n", "", "except", "ValueError", "as", "err", ":", "\n", "            ", "if", "expect_err", ":", "\n", "                ", "return", "\n", "", "raise", "err", "\n", "", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "(", "5", ",", "*", "image_size", ",", "out_ch", ")", ")", "\n", "\n", "output", "=", "network", ".", "call", "(", "inputs", ")", "\n", "assert", "inputs", ".", "shape", "==", "output", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_unet.TestUNet.test_call": [[76, 112], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "deepreg.model.backbone.u_net.UNet", "tensorflow.ones", "deepreg.model.backbone.u_net.UNet.call"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"image_size,depth\"", ",", "\n", "[", "(", "(", "11", ",", "12", ",", "13", ")", ",", "5", ")", ",", "(", "(", "8", ",", "8", ",", "8", ")", ",", "3", ")", "]", ",", "\n", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"pooling\"", ",", "[", "True", ",", "False", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"concat_skip\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_call", "(", "\n", "self", ",", "\n", "image_size", ":", "Tuple", ",", "\n", "depth", ":", "int", ",", "\n", "pooling", ":", "bool", ",", "\n", "concat_skip", ":", "bool", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test unet call function.\n\n        :param image_size: (dim1, dim2, dim3), dims of input image.\n        :param depth: input is at level 0, bottom is at level depth\n        :param pooling: for down-sampling, use non-parameterized\n                        pooling if true, otherwise use conv3d\n        :param concat_skip: if concatenate skip or add it\n        \"\"\"", "\n", "out_ch", "=", "3", "\n", "network", "=", "UNet", "(", "\n", "image_size", "=", "image_size", ",", "\n", "out_channels", "=", "out_ch", ",", "\n", "num_channel_initial", "=", "2", ",", "\n", "depth", "=", "depth", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", "pooling", "=", "pooling", ",", "\n", "concat_skip", "=", "concat_skip", ",", "\n", ")", "\n", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "(", "5", ",", "*", "image_size", ",", "out_ch", ")", ")", "\n", "output", "=", "network", ".", "call", "(", "inputs", ")", "\n", "assert", "inputs", ".", "shape", "==", "output", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_unet.TestUNet.test_get_config": [[113, 135], ["dict", "deepreg.model.backbone.u_net.UNet", "deepreg.model.backbone.u_net.UNet.get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "dict", "(", "\n", "image_size", "=", "(", "4", ",", "5", ",", "6", ")", ",", "\n", "out_channels", "=", "3", ",", "\n", "num_channel_initial", "=", "2", ",", "\n", "depth", "=", "2", ",", "\n", "extract_levels", "=", "(", "0", ",", "1", ")", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", "pooling", "=", "False", ",", "\n", "concat_skip", "=", "False", ",", "\n", "encode_kernel_sizes", "=", "3", ",", "\n", "decode_kernel_sizes", "=", "3", ",", "\n", "encode_num_channels", "=", "(", "2", ",", "4", ",", "8", ")", ",", "\n", "decode_num_channels", "=", "(", "2", ",", "4", ",", "8", ")", ",", "\n", "strides", "=", "2", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "name", "=", "\"Test\"", ",", "\n", ")", "\n", "network", "=", "UNet", "(", "**", "config", ")", "\n", "got", "=", "network", ".", "get_config", "(", ")", "\n", "assert", "got", "==", "config", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_global_net.TestGlobalNet.test_call": [[36, 72], ["pytest.mark.parametrize", "deepreg.model.backbone.global_net.GlobalNet", "tensorflow.ones", "deepreg.model.backbone.global_net.GlobalNet.call"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"image_size,extract_levels,depth\"", ",", "\n", "[", "\n", "(", "(", "11", ",", "12", ",", "13", ")", ",", "(", "0", ",", "1", ",", "2", ",", "4", ")", ",", "4", ")", ",", "\n", "(", "(", "11", ",", "12", ",", "13", ")", ",", "None", ",", "4", ")", ",", "\n", "(", "(", "11", ",", "12", ",", "13", ")", ",", "(", "0", ",", "1", ",", "2", ",", "4", ")", ",", "None", ")", ",", "\n", "(", "(", "8", ",", "8", ",", "8", ")", ",", "(", "0", ",", "1", ",", "2", ")", ",", "3", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_call", "(", "\n", "self", ",", "\n", "image_size", ":", "tuple", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "depth", ":", "int", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n\n        :param image_size: (dim1, dim2, dim3), dims of input image.\n        :param extract_levels: from which depths the output will be built.\n        :param depth: input is at level 0, bottom is at level depth\n        \"\"\"", "\n", "batch_size", "=", "5", "\n", "out_ch", "=", "3", "\n", "network", "=", "GlobalNet", "(", "\n", "image_size", "=", "image_size", ",", "\n", "num_channel_initial", "=", "2", ",", "\n", "extract_levels", "=", "extract_levels", ",", "\n", "depth", "=", "depth", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", "out_channels", "=", "out_ch", ",", "\n", ")", "\n", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "(", "batch_size", ",", "*", "image_size", ",", "out_ch", ")", ")", "\n", "ddf", ",", "theta", "=", "network", ".", "call", "(", "inputs", ")", "\n", "assert", "ddf", ".", "shape", "==", "inputs", ".", "shape", "\n", "assert", "theta", ".", "shape", "==", "(", "batch_size", ",", "4", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_global_net.TestGlobalNet.test_err": [[73, 92], ["pytest.raises", "deepreg.model.backbone.global_net.GlobalNet", "str"], "methods", ["None"], ["", "def", "test_err", "(", "self", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "GlobalNet", "(", "\n", "image_size", "=", "(", "4", ",", "5", ",", "6", ")", ",", "\n", "out_channels", "=", "3", ",", "\n", "num_channel_initial", "=", "2", ",", "\n", "depth", "=", "None", ",", "\n", "extract_levels", "=", "None", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", "pooling", "=", "False", ",", "\n", "concat_skip", "=", "False", ",", "\n", "encode_kernel_sizes", "=", "[", "7", ",", "3", ",", "3", "]", ",", "\n", "decode_kernel_sizes", "=", "3", ",", "\n", "strides", "=", "2", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "name", "=", "\"Test\"", ",", "\n", ")", "\n", "", "assert", "\"GlobalNet requires `depth` or `extract_levels`\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_global_net.TestGlobalNet.test_get_config": [[93, 115], ["dict", "deepreg.model.backbone.global_net.GlobalNet", "deepreg.model.backbone.global_net.GlobalNet.get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "dict", "(", "\n", "image_size", "=", "(", "4", ",", "5", ",", "6", ")", ",", "\n", "out_channels", "=", "3", ",", "\n", "num_channel_initial", "=", "2", ",", "\n", "depth", "=", "2", ",", "\n", "extract_levels", "=", "(", "2", ",", ")", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", "pooling", "=", "False", ",", "\n", "concat_skip", "=", "False", ",", "\n", "encode_kernel_sizes", "=", "[", "7", ",", "3", ",", "3", "]", ",", "\n", "decode_kernel_sizes", "=", "3", ",", "\n", "encode_num_channels", "=", "[", "2", ",", "4", ",", "8", "]", ",", "\n", "decode_num_channels", "=", "[", "2", ",", "4", ",", "8", "]", ",", "\n", "strides", "=", "2", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "name", "=", "\"Test\"", ",", "\n", ")", "\n", "network", "=", "GlobalNet", "(", "**", "config", ")", "\n", "got", "=", "network", ".", "get_config", "(", ")", "\n", "assert", "got", "==", "config", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_global_net.test_affine_head": [[14, 29], ["dict", "deepreg.model.backbone.global_net.AffineHead", "tensorflow.ones", "deepreg.model.backbone.global_net.AffineHead.call", "deepreg.model.backbone.global_net.AffineHead.get_config"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["def", "test_affine_head", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test AffineHead.\n    \"\"\"", "\n", "batch", "=", "3", "\n", "input_shape", "=", "(", "4", ",", "5", ",", "6", ")", "\n", "config", "=", "dict", "(", "image_size", "=", "input_shape", ",", "name", "=", "\"TestAffineHead\"", ")", "\n", "layer", "=", "AffineHead", "(", "**", "config", ")", "\n", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "(", "batch", ",", "*", "input_shape", ",", "2", ")", ")", "\n", "ddf", ",", "theta", "=", "layer", ".", "call", "(", "inputs", ")", "\n", "assert", "ddf", ".", "shape", "==", "(", "batch", ",", "*", "input_shape", ",", "3", ")", "\n", "assert", "theta", ".", "shape", "==", "(", "batch", ",", "4", ",", "3", ")", "\n", "\n", "got", "=", "layer", ".", "get_config", "(", ")", "\n", "assert", "got", "==", "{", "\"trainable\"", ":", "True", ",", "\"dtype\"", ":", "\"float32\"", ",", "**", "config", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.TestGetDataLoader.test_data_loader": [[28, 42], ["pytest.mark.parametrize", "pytest.mark.parametrize", "test_dataset_load.load_yaml", "deepreg.get_data_loader", "deepreg.registry.REGISTRY.get", "isinstance"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.load_yaml", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.load.get_data_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"data_type\"", ",", "[", "\"paired\"", ",", "\"unpaired\"", ",", "\"grouped\"", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"format\"", ",", "[", "\"nifti\"", ",", "\"h5\"", "]", ")", "\n", "def", "test_data_loader", "(", "self", ",", "data_type", ":", "str", ",", "format", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Test the data loader can be successfully built.\n\n        :param data_type: name of data loader for registry\n        :param format: name of file loader for registry\n        \"\"\"", "\n", "# single paired data loader", "\n", "config", "=", "load_yaml", "(", "f\"config/test/{data_type}_{format}.yaml\"", ")", "\n", "got", "=", "load", ".", "get_data_loader", "(", "data_config", "=", "config", "[", "\"dataset\"", "]", ",", "split", "=", "\"train\"", ")", "\n", "expected", "=", "REGISTRY", ".", "get", "(", "category", "=", "DATA_LOADER_CLASS", ",", "key", "=", "data_type", ")", "\n", "assert", "isinstance", "(", "got", ",", "expected", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.TestGetDataLoader.test_multi_dir_data_loader": [[43, 48], ["test_dataset_load.load_yaml", "deepreg.get_data_loader", "isinstance"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.load_yaml", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.load.get_data_loader"], ["", "def", "test_multi_dir_data_loader", "(", "self", ")", ":", "\n", "        ", "\"\"\"unpaired data loader with multiple dirs\"\"\"", "\n", "config", "=", "load_yaml", "(", "\"config/test/unpaired_nifti_multi_dirs.yaml\"", ")", "\n", "got", "=", "load", ".", "get_data_loader", "(", "data_config", "=", "config", "[", "\"dataset\"", "]", ",", "split", "=", "\"train\"", ")", "\n", "assert", "isinstance", "(", "got", ",", "UnpairedDataLoader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.TestGetDataLoader.test_empty_path": [[49, 60], ["pytest.mark.parametrize", "test_dataset_load.load_yaml", "deepreg.get_data_loader"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.load_yaml", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.load.get_data_loader"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"path\"", ",", "[", "\"\"", ",", "None", "]", ")", "\n", "def", "test_empty_path", "(", "self", ",", "path", ":", "Optional", "[", "str", "]", ")", ":", "\n", "        ", "\"\"\"\n        Test return without data path.\n\n        :param path: training data path to be used\n        \"\"\"", "\n", "config", "=", "load_yaml", "(", "\"config/test/paired_nifti.yaml\"", ")", "\n", "config", "[", "\"dataset\"", "]", "[", "\"train\"", "]", "[", "\"dir\"", "]", "=", "path", "\n", "got", "=", "load", ".", "get_data_loader", "(", "data_config", "=", "config", "[", "\"dataset\"", "]", ",", "split", "=", "\"train\"", ")", "\n", "assert", "got", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.TestGetDataLoader.test_empty_config": [[61, 72], ["pytest.mark.parametrize", "test_dataset_load.load_yaml", "config[].pop", "deepreg.get_data_loader"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.load_yaml", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.load.get_data_loader"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"split\"", ",", "[", "\"train\"", ",", "\"valid\"", ",", "\"test\"", "]", ")", "\n", "def", "test_empty_config", "(", "self", ",", "split", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Test return without data path for the split.\n\n        :param split: train or valid or test\n        \"\"\"", "\n", "config", "=", "load_yaml", "(", "\"config/test/paired_nifti.yaml\"", ")", "\n", "config", "[", "\"dataset\"", "]", ".", "pop", "(", "split", ")", "\n", "got", "=", "load", ".", "get_data_loader", "(", "data_config", "=", "config", "[", "\"dataset\"", "]", ",", "split", "=", "split", ")", "\n", "assert", "got", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.TestGetDataLoader.test_dir_err": [[73, 87], ["pytest.mark.parametrize", "test_dataset_load.load_yaml", "pytest.raises", "deepreg.get_data_loader", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.load_yaml", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.load.get_data_loader"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"path\"", ",", "[", "\"config/test/paired_nifti.yaml\"", ",", "\"config/test/paired_nifti\"", "]", "\n", ")", "\n", "def", "test_dir_err", "(", "self", ",", "path", ":", "Optional", "[", "str", "]", ")", ":", "\n", "        ", "\"\"\"\n        Check the error is raised when the path is wrong.\n\n        :param path: training data path to be used\n        \"\"\"", "\n", "config", "=", "load_yaml", "(", "\"config/test/paired_nifti.yaml\"", ")", "\n", "config", "[", "\"dataset\"", "]", "[", "\"train\"", "]", "[", "\"dir\"", "]", "=", "path", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "load", ".", "get_data_loader", "(", "data_config", "=", "config", "[", "\"dataset\"", "]", ",", "split", "=", "\"train\"", ")", "\n", "", "assert", "\"is not a directory or does not exist\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.TestGetDataLoader.test_mode_err": [[88, 94], ["test_dataset_load.load_yaml", "pytest.raises", "deepreg.get_data_loader", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.load_yaml", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.load.get_data_loader"], ["", "def", "test_mode_err", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check the error is raised when the split is wrong.\"\"\"", "\n", "config", "=", "load_yaml", "(", "\"config/test/paired_nifti.yaml\"", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "load", ".", "get_data_loader", "(", "data_config", "=", "config", "[", "\"dataset\"", "]", ",", "split", "=", "\"example\"", ")", "\n", "", "assert", "\"split must be one of ['train', 'valid', 'test']\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_load.load_yaml": [[16, 25], ["file_path.endswith", "open", "yaml.load"], "function", ["None"], ["def", "load_yaml", "(", "file_path", ":", "str", ")", "->", "dict", ":", "\n", "    ", "\"\"\"\n    load the yaml file and return a dictionary\n\n    :param file_path: path of the yaml file.\n    \"\"\"", "\n", "assert", "file_path", ".", "endswith", "(", "\".yaml\"", ")", "\n", "with", "open", "(", "file_path", ")", "as", "file", ":", "\n", "        ", "return", "yaml", ".", "load", "(", "file", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_grouped_loader.sample_count": [[20, 34], ["numpy.array", "int", "numpy.sum", "numpy.sum"], "function", ["None"], ["def", "sample_count", "(", "ni", ":", "List", "[", "int", "]", ",", "direction", ":", "str", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Count number of samples.\n\n    :param ni: list, each element correspond to the number of images per group\n    :param direction: unconstrained/forward/backward\n    :return: number of samples in total\n    \"\"\"", "\n", "arr", "=", "np", ".", "array", "(", "ni", ")", "\n", "if", "direction", "==", "\"unconstrained\"", ":", "\n", "        ", "sample_total", "=", "np", ".", "sum", "(", "arr", "*", "(", "arr", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "sample_total", "=", "np", ".", "sum", "(", "arr", "*", "(", "arr", "-", "1", ")", "/", "2", ")", "\n", "", "return", "int", "(", "sample_total", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_grouped_loader.test_init": [[36, 89], ["FileLoaderDict.items", "dict", "os.path.join", "pytest.raises", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.close", "str", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.close", "pytest.raises", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.close", "str"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "def", "test_init", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test exceptions with appropriate messages and counts samples correctly\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "train_split", "in", "[", "\"test\"", ",", "\"train\"", "]", ":", "\n", "            ", "for", "prob", "in", "[", "0", ",", "0.5", ",", "1", "]", ":", "\n", "                ", "for", "sample_in_group", "in", "[", "True", ",", "False", "]", ":", "\n", "                    ", "data_dir_paths", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "train_split", ")", "]", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "intra_group_prob", "=", "prob", ",", "\n", "intra_group_option", "=", "\"forward\"", ",", "\n", "sample_image_in_group", "=", "sample_in_group", ",", "\n", "seed", "=", "None", ",", "\n", ")", "\n", "if", "train_split", "==", "\"test\"", "and", "prob", "<", "1", ":", "\n", "# sample with fewer than 2 groups.", "\n", "# In \"test\" we only have one group", "\n", "                        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "                            ", "data_loader", "=", "GroupedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "data_loader", ".", "close", "(", ")", "\n", "", "assert", "\"we need at least two groups\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n", "", "elif", "train_split", "==", "\"train\"", "and", "sample_in_group", "is", "True", ":", "\n", "# ensure sample count is accurate", "\n", "# (only for train dir, test dir uses same logic)", "\n", "                        ", "data_loader", "=", "GroupedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "assert", "data_loader", ".", "sample_indices", "is", "None", "\n", "assert", "data_loader", ".", "_num_samples", "==", "2", "\n", "data_loader", ".", "close", "(", ")", "\n", "\n", "", "elif", "sample_in_group", "is", "False", "and", "0", "<", "prob", "<", "1", ":", "\n", "# specifying conflicting intra/inter group parameters", "\n", "                        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "                            ", "data_loader", "=", "GroupedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "data_loader", ".", "close", "(", ")", "\n", "", "assert", "\"Mixing intra and inter groups is not supported\"", "in", "str", "(", "\n", "err_info", ".", "value", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_grouped_loader.test_validate_data_files": [[92, 119], ["FileLoaderDict.items", "dict", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "os.path.join", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.validate_data_files"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.validate_data_files"], ["", "", "", "", "", "", "def", "test_validate_data_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test validate_data_files function looks for inconsistencies\n     in the fixed/moving image and label lists.\n    If there is any issue it will raise an error, otherwise it returns None.\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "train_split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "            ", "for", "labeled", "in", "[", "True", ",", "False", "]", ":", "\n", "                ", "data_dir_paths", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "train_split", ")", "]", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "labeled", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "intra_group_prob", "=", "1", ",", "\n", "intra_group_option", "=", "\"forward\"", ",", "\n", "sample_image_in_group", "=", "False", ",", "\n", "seed", "=", "None", "if", "train_split", "==", "\"train\"", "else", "0", ",", "\n", ")", "\n", "\n", "data_loader", "=", "GroupedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "\n", "assert", "data_loader", ".", "validate_data_files", "(", ")", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_grouped_loader.test_get_inter_sample_indices": [[121, 150], ["FileLoaderDict.items", "dict", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "numpy.array", "sample_indices.sort", "list", "list.sort", "os.path.join", "sum", "set", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "", "", "", "def", "test_get_inter_sample_indices", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test all possible intergroup sampling indices are correctly calculated\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "data_dir_paths", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "\"train\"", ")", "]", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "intra_group_prob", "=", "0", ",", "\n", "intra_group_option", "=", "\"forward\"", ",", "\n", "sample_image_in_group", "=", "False", ",", "\n", "seed", "=", "None", ",", "\n", ")", "\n", "data_loader", "=", "GroupedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "image_shape", "=", "image_shape", ",", "**", "common_args", "\n", ")", "\n", "\n", "ni", "=", "np", ".", "array", "(", "data_loader", ".", "num_images_per_group", ")", "\n", "num_samples", "=", "np", ".", "sum", "(", "ni", ")", "*", "(", "np", ".", "sum", "(", "ni", ")", "-", "1", ")", "-", "sum", "(", "ni", "*", "(", "ni", "-", "1", ")", ")", "\n", "\n", "sample_indices", "=", "data_loader", ".", "sample_indices", "\n", "sample_indices", ".", "sort", "(", ")", "\n", "unique_indices", "=", "list", "(", "set", "(", "sample_indices", ")", ")", "\n", "unique_indices", ".", "sort", "(", ")", "\n", "\n", "assert", "data_loader", ".", "_num_samples", "==", "num_samples", "\n", "assert", "sample_indices", "==", "unique_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_grouped_loader.test_get_intra_sample_indices": [[152, 199], ["FileLoaderDict.items", "dict", "os.path.join", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "test_grouped_loader.sample_count", "sample_indices.sort", "list", "list.sort", "pytest.raises", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.close", "str", "set"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_grouped_loader.sample_count", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "def", "test_get_intra_sample_indices", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test all possible intragroup sampling indices are correctly calculated\n    Ensure exception is thrown for unsupported group_option\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "            ", "data_dir_paths", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "split", ")", "]", "\n", "common_args", "=", "dict", "(", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "intra_group_prob", "=", "1", ",", "\n", "sample_image_in_group", "=", "False", ",", "\n", "seed", "=", "None", ",", "\n", ")", "\n", "# test feasible intra_group_option", "\n", "for", "intra_group_option", "in", "[", "\"forward\"", ",", "\"backward\"", ",", "\"unconstrained\"", "]", ":", "\n", "                ", "data_loader", "=", "GroupedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "intra_group_option", "=", "intra_group_option", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "\n", "ni", "=", "data_loader", ".", "num_images_per_group", "\n", "num_samples", "=", "sample_count", "(", "ni", ",", "intra_group_option", ")", "\n", "\n", "sample_indices", "=", "data_loader", ".", "sample_indices", "\n", "sample_indices", ".", "sort", "(", ")", "\n", "unique_indices", "=", "list", "(", "set", "(", "sample_indices", ")", ")", "\n", "unique_indices", ".", "sort", "(", ")", "\n", "\n", "# test all possible indices are generated", "\n", "assert", "data_loader", ".", "_num_samples", "==", "num_samples", "\n", "assert", "sample_indices", "==", "unique_indices", "\n", "\n", "# test exception thrown for unsupported group option", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "                ", "data_loader", "=", "GroupedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "intra_group_option", "=", "\"wrong\"", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "data_loader", ".", "close", "(", ")", "\n", "", "assert", "\"Unknown intra_group_option,\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_grouped_loader.test_sample_index_generator": [[201, 263], ["FileLoaderDict.items", "dict", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.close", "pytest.raises", "next", "str", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.sample_index_generator", "os.path.join", "numpy.allclose", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.sample_index_generator", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.close", "indices_to_compare.append", "numpy.allclose", "isinstance", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.sample_index_generator", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.sample_index_generator", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "", "def", "test_sample_index_generator", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test to check the randomness and deterministic index generator for train\n    Test dir not checked because it contains only a single group of 2 images\n    \"\"\"", "\n", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "common_args", "=", "dict", "(", "\n", "image_shape", "=", "image_shape", ",", "\n", "data_dir_paths", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "\"train\"", ")", "]", ",", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", ")", "\n", "\n", "# test feasible intra_group_option", "\n", "for", "sample_in_group", "in", "[", "False", ",", "True", "]", ":", "\n", "            ", "probs", "=", "[", "0", ",", "0.5", ",", "1", "]", "if", "sample_in_group", "else", "[", "0", ",", "1", "]", "\n", "for", "prob", "in", "probs", ":", "\n", "                ", "for", "direction", "in", "[", "\"forward\"", ",", "\"backward\"", ",", "\"unconstrained\"", "]", ":", "\n", "                    ", "indices_to_compare", "=", "[", "]", "\n", "\n", "for", "seed", "in", "[", "0", ",", "1", ",", "0", "]", ":", "\n", "                        ", "data_loader", "=", "GroupedDataLoader", "(", "\n", "intra_group_prob", "=", "prob", ",", "\n", "intra_group_option", "=", "direction", ",", "\n", "sample_image_in_group", "=", "sample_in_group", ",", "\n", "seed", "=", "seed", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "\n", "data_indices", "=", "[", "]", "\n", "for", "(", "\n", "moving_index", ",", "\n", "fixed_index", ",", "\n", "indices", ",", "\n", ")", "in", "data_loader", ".", "sample_index_generator", "(", ")", ":", "\n", "                            ", "assert", "isinstance", "(", "moving_index", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "fixed_index", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "indices", ",", "list", ")", "\n", "data_indices", "+=", "indices", "\n", "\n", "", "data_loader", ".", "close", "(", ")", "\n", "indices_to_compare", ".", "append", "(", "data_indices", ")", "\n", "\n", "# test different seeds give different indices", "\n", "", "assert", "not", "np", ".", "allclose", "(", "indices_to_compare", "[", "0", "]", ",", "indices_to_compare", "[", "1", "]", ")", "\n", "# test same seeds give the same indices", "\n", "assert", "np", ".", "allclose", "(", "indices_to_compare", "[", "0", "]", ",", "indices_to_compare", "[", "2", "]", ")", "\n", "\n", "# test exception thrown for unsupported intra_group_option option", "\n", "", "", "", "data_loader", "=", "GroupedDataLoader", "(", "\n", "intra_group_prob", "=", "1", ",", "\n", "intra_group_option", "=", "\"wrong\"", ",", "\n", "sample_image_in_group", "=", "True", ",", "\n", "seed", "=", "0", ",", "\n", "**", "common_args", ",", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "next", "(", "data_loader", ".", "sample_index_generator", "(", ")", ")", "\n", "", "data_loader", ".", "close", "(", ")", "\n", "assert", "\"Unknown intra_group_option\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_grouped_loader.test_close": [[265, 290], ["FileLoaderDict.items", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader", "os.path.join", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.close", "deepreg.dataset.loader.grouped_loader.GroupedDataLoader.loader_moving_image.h5_files.values", "f.__bool__"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "def", "test_close", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the close function\n    Since fixed and moving loaders are the same only need to test the moving\n    \"\"\"", "\n", "for", "key_file_loader", ",", "file_loader", "in", "FileLoaderDict", ".", "items", "(", ")", ":", "\n", "        ", "for", "split", "in", "[", "\"train\"", ",", "\"test\"", "]", ":", "\n", "            ", "data_dir_paths", "=", "[", "join", "(", "DataPaths", "[", "key_file_loader", "]", ",", "split", ")", "]", "\n", "\n", "data_loader", "=", "GroupedDataLoader", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "file_loader", "=", "file_loader", ",", "\n", "labeled", "=", "True", ",", "\n", "sample_label", "=", "\"all\"", ",", "\n", "intra_group_prob", "=", "1", ",", "\n", "intra_group_option", "=", "\"forward\"", ",", "\n", "sample_image_in_group", "=", "True", ",", "\n", "seed", "=", "0", ",", "\n", ")", "\n", "\n", "if", "key_file_loader", "==", "\"h5\"", ":", "\n", "                ", "data_loader", ".", "close", "(", ")", "\n", "for", "f", "in", "data_loader", ".", "loader_moving_image", ".", "h5_files", ".", "values", "(", ")", ":", "\n", "                    ", "assert", "not", "f", ".", "__bool__", "(", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestWarping.test_forward": [[53, 66], ["pytest.mark.parametrize", "tensorflow.ones", "tensorflow.ones", "deepreg.Warping"], "methods", ["None"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"moving_image_size\"", ",", "\"fixed_image_size\"", ")", ",", "\n", "[", "\n", "(", "(", "1", ",", "2", ",", "3", ")", ",", "(", "3", ",", "4", ",", "5", ")", ")", ",", "\n", "(", "(", "1", ",", "2", ",", "3", ")", ",", "(", "1", ",", "2", ",", "3", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_forward", "(", "self", ",", "moving_image_size", ",", "fixed_image_size", ")", ":", "\n", "        ", "batch_size", "=", "2", "\n", "image", "=", "tf", ".", "ones", "(", "shape", "=", "(", "batch_size", ",", ")", "+", "moving_image_size", ")", "\n", "ddf", "=", "tf", ".", "ones", "(", "shape", "=", "(", "batch_size", ",", ")", "+", "fixed_image_size", "+", "(", "3", ",", ")", ")", "\n", "outputs", "=", "layer", ".", "Warping", "(", "fixed_image_size", "=", "fixed_image_size", ")", "(", "[", "ddf", ",", "image", "]", ")", "\n", "assert", "outputs", ".", "shape", "==", "(", "batch_size", ",", "*", "fixed_image_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestWarping.test_get_config": [[67, 75], ["deepreg.Warping", "deepreg.Warping.get_config", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "warping", "=", "layer", ".", "Warping", "(", "fixed_image_size", "=", "(", "2", ",", "3", ",", "4", ")", ")", "\n", "config", "=", "warping", ".", "get_config", "(", ")", "\n", "assert", "config", "==", "dict", "(", "\n", "fixed_image_size", "=", "(", "2", ",", "3", ",", "4", ")", ",", "\n", "name", "=", "\"warping\"", ",", "\n", "trainable", "=", "True", ",", "\n", "dtype", "=", "\"float32\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestIntDVF.test_forward": [[122, 143], ["deepreg.IntDVF", "tensorflow.ones", "deepreg.IntDVF.", "deepreg.IntDVF.get_config", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["    ", "def", "test_forward", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Test output shape and config.\n        \"\"\"", "\n", "\n", "fixed_image_size", "=", "(", "8", ",", "9", ",", "10", ")", "\n", "input_shape", "=", "(", "2", ",", "*", "fixed_image_size", ",", "3", ")", "\n", "\n", "int_layer", "=", "layer", ".", "IntDVF", "(", "fixed_image_size", "=", "fixed_image_size", ")", "\n", "\n", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "input_shape", ")", "\n", "outputs", "=", "int_layer", "(", "inputs", ")", "\n", "assert", "outputs", ".", "shape", "==", "input_shape", "\n", "\n", "config", "=", "int_layer", ".", "get_config", "(", ")", "\n", "assert", "config", "==", "dict", "(", "\n", "fixed_image_size", "=", "fixed_image_size", ",", "\n", "num_steps", "=", "7", ",", "\n", "name", "=", "\"int_dvf\"", ",", "\n", "trainable", "=", "True", ",", "\n", "dtype", "=", "\"float32\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestIntDVF.test_err": [[145, 148], ["pytest.raises", "deepreg.IntDVF"], "methods", ["None"], ["", "def", "test_err", "(", "self", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "layer", ".", "IntDVF", "(", "fixed_image_size", "=", "(", "2", ",", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestResizeCPTransform.test_attributes": [[151, 161], ["pytest.mark.parametrize", "deepreg.ResizeCPTransform", "isinstance", "list", "list"], "methods", ["None"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"parameter,cp_spacing\"", ",", "[", "(", "(", "8", ",", "8", ",", "8", ")", ",", "8", ")", ",", "(", "(", "8", ",", "24", ",", "16", ")", ",", "(", "8", ",", "24", ",", "16", ")", ")", "]", "\n", ")", "\n", "def", "test_attributes", "(", "self", ",", "parameter", ",", "cp_spacing", ")", ":", "\n", "        ", "model", "=", "layer", ".", "ResizeCPTransform", "(", "cp_spacing", ")", "\n", "\n", "if", "isinstance", "(", "cp_spacing", ",", "int", ")", ":", "\n", "            ", "cp_spacing", "=", "[", "cp_spacing", "]", "*", "3", "\n", "", "assert", "list", "(", "model", ".", "cp_spacing", ")", "==", "list", "(", "parameter", ")", "\n", "assert", "model", ".", "kernel_sigma", "==", "[", "0.44", "*", "cp", "for", "cp", "in", "cp_spacing", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestResizeCPTransform.test_build": [[162, 174], ["pytest.mark.parametrize", "deepreg.ResizeCPTransform", "deepreg.ResizeCPTransform.build", "zip"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.build"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"input_size,output_size,cp_spacing\"", ",", "\n", "[", "\n", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "12", ",", "8", ",", "12", ")", ",", "(", "8", ",", "16", ",", "8", ")", ")", ",", "\n", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "12", ",", "12", ",", "12", ")", ",", "8", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_build", "(", "self", ",", "input_size", ",", "output_size", ",", "cp_spacing", ")", ":", "\n", "        ", "model", "=", "layer", ".", "ResizeCPTransform", "(", "cp_spacing", ")", "\n", "model", ".", "build", "(", "input_size", ")", "\n", "\n", "assert", "[", "a", "==", "b", "for", "a", ",", "b", ",", "in", "zip", "(", "model", ".", "_output_shape", ",", "output_size", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestResizeCPTransform.test_call": [[175, 190], ["pytest.mark.parametrize", "deepreg.ResizeCPTransform", "deepreg.ResizeCPTransform.build", "tensorflow.random.normal", "deepreg.ResizeCPTransform."], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.build"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"input_size,output_size,cp_spacing\"", ",", "\n", "[", "\n", "(", "(", "1", ",", "68", ",", "68", ",", "68", ",", "3", ")", ",", "(", "1", ",", "12", ",", "8", ",", "12", ",", "3", ")", ",", "(", "8", ",", "16", ",", "8", ")", ")", ",", "\n", "(", "(", "1", ",", "68", ",", "68", ",", "68", ",", "3", ")", ",", "(", "1", ",", "12", ",", "12", ",", "12", ",", "3", ")", ",", "8", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_call", "(", "self", ",", "input_size", ",", "output_size", ",", "cp_spacing", ")", ":", "\n", "        ", "model", "=", "layer", ".", "ResizeCPTransform", "(", "cp_spacing", ")", "\n", "model", ".", "build", "(", "input_size", ")", "\n", "\n", "input", "=", "tf", ".", "random", ".", "normal", "(", "shape", "=", "input_size", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "output", "=", "model", "(", "input", ")", "\n", "\n", "assert", "output", ".", "shape", "==", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestBSplines3DTransform.test_init": [[198, 209], ["pytest.mark.parametrize", "deepreg.BSplines3DTransform", "isinstance"], "methods", ["None"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"input_size,cp\"", ",", "\n", "[", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "8", ")", ",", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "16", ",", "12", ")", ")", "]", ",", "\n", ")", "\n", "def", "test_init", "(", "self", ",", "input_size", ",", "cp", ")", ":", "\n", "        ", "model", "=", "layer", ".", "BSplines3DTransform", "(", "cp", ",", "input_size", "[", "1", ":", "-", "1", "]", ")", "\n", "\n", "if", "isinstance", "(", "cp", ",", "int", ")", ":", "\n", "            ", "cp", "=", "(", "cp", ",", "cp", ",", "cp", ")", "\n", "\n", "", "assert", "model", ".", "cp_spacing", "==", "cp", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestBSplines3DTransform.generate_filter_coefficients": [[210, 254], ["pytest.mark.parametrize", "numpy.zeros", "range", "range", "numpy.float64", "numpy.float64", "numpy.float64", "numpy.float64", "range", "range", "range", "range", "range"], "methods", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"input_size,cp\"", ",", "\n", "[", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "8", ",", "8", ")", ")", ",", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "16", ",", "12", ")", ")", "]", ",", "\n", ")", "\n", "def", "generate_filter_coefficients", "(", "self", ",", "cp_spacing", ")", ":", "\n", "\n", "        ", "b", "=", "{", "\n", "0", ":", "lambda", "u", ":", "np", ".", "float64", "(", "(", "1", "-", "u", ")", "**", "3", "/", "6", ")", ",", "\n", "1", ":", "lambda", "u", ":", "np", ".", "float64", "(", "(", "3", "*", "(", "u", "**", "3", ")", "-", "6", "*", "(", "u", "**", "2", ")", "+", "4", ")", "/", "6", ")", ",", "\n", "2", ":", "lambda", "u", ":", "np", ".", "float64", "(", "(", "-", "3", "*", "(", "u", "**", "3", ")", "+", "3", "*", "(", "u", "**", "2", ")", "+", "3", "*", "u", "+", "1", ")", "/", "6", ")", ",", "\n", "3", ":", "lambda", "u", ":", "np", ".", "float64", "(", "u", "**", "3", "/", "6", ")", ",", "\n", "}", "\n", "\n", "filters", "=", "np", ".", "zeros", "(", "\n", "(", "\n", "4", "*", "cp_spacing", "[", "0", "]", ",", "\n", "4", "*", "cp_spacing", "[", "1", "]", ",", "\n", "4", "*", "cp_spacing", "[", "2", "]", ",", "\n", "3", ",", "\n", "3", ",", "\n", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", "\n", "for", "u", "in", "range", "(", "cp_spacing", "[", "0", "]", ")", ":", "\n", "            ", "for", "v", "in", "range", "(", "cp_spacing", "[", "1", "]", ")", ":", "\n", "                ", "for", "w", "in", "range", "(", "cp_spacing", "[", "2", "]", ")", ":", "\n", "                    ", "for", "x", "in", "range", "(", "4", ")", ":", "\n", "                        ", "for", "y", "in", "range", "(", "4", ")", ":", "\n", "                            ", "for", "z", "in", "range", "(", "4", ")", ":", "\n", "                                ", "for", "it_dim", "in", "range", "(", "3", ")", ":", "\n", "                                    ", "u_norm", "=", "1", "-", "(", "u", "+", "0.5", ")", "/", "cp_spacing", "[", "0", "]", "\n", "v_norm", "=", "1", "-", "(", "v", "+", "0.5", ")", "/", "cp_spacing", "[", "1", "]", "\n", "w_norm", "=", "1", "-", "(", "w", "+", "0.5", ")", "/", "cp_spacing", "[", "2", "]", "\n", "filters", "[", "\n", "x", "*", "cp_spacing", "[", "0", "]", "+", "u", ",", "\n", "y", "*", "cp_spacing", "[", "1", "]", "+", "v", ",", "\n", "z", "*", "cp_spacing", "[", "2", "]", "+", "w", ",", "\n", "it_dim", ",", "\n", "it_dim", ",", "\n", "]", "=", "(", "\n", "b", "[", "x", "]", "(", "u_norm", ")", "*", "b", "[", "y", "]", "(", "v_norm", ")", "*", "b", "[", "z", "]", "(", "w_norm", ")", "\n", ")", "\n", "", "", "", "", "", "", "", "return", "filters", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestBSplines3DTransform.test_build": [[255, 269], ["pytest.mark.parametrize", "deepreg.BSplines3DTransform", "deepreg.BSplines3DTransform.build"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.build"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"input_size,cp\"", ",", "\n", "[", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "8", ",", "8", ")", ")", ",", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "16", ",", "12", ")", ")", "]", ",", "\n", ")", "\n", "def", "test_build", "(", "self", ",", "input_size", ",", "cp", ")", ":", "\n", "        ", "model", "=", "layer", ".", "BSplines3DTransform", "(", "cp", ",", "input_size", "[", "1", ":", "-", "1", "]", ")", "\n", "\n", "model", ".", "build", "(", "input_size", ")", "\n", "assert", "model", ".", "filter", ".", "shape", "==", "(", "\n", "4", "*", "cp", "[", "0", "]", ",", "\n", "4", "*", "cp", "[", "1", "]", ",", "\n", "4", "*", "cp", "[", "2", "]", ",", "\n", "3", ",", "\n", "3", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestBSplines3DTransform.test_coefficients": [[271, 283], ["pytest.mark.parametrize", "test_layer.TestBSplines3DTransform.generate_filter_coefficients", "deepreg.BSplines3DTransform", "deepreg.BSplines3DTransform.build", "numpy.allclose", "deepreg.BSplines3DTransform.filter.numpy"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestBSplines3DTransform.generate_filter_coefficients", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.build"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"input_size,cp\"", ",", "\n", "[", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "8", ",", "8", ")", ")", ",", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "16", ",", "12", ")", ")", "]", ",", "\n", ")", "\n", "def", "test_coefficients", "(", "self", ",", "input_size", ",", "cp", ")", ":", "\n", "\n", "        ", "filters", "=", "self", ".", "generate_filter_coefficients", "(", "cp_spacing", "=", "cp", ")", "\n", "\n", "model", "=", "layer", ".", "BSplines3DTransform", "(", "cp", ",", "input_size", "[", "1", ":", "-", "1", "]", ")", "\n", "model", ".", "build", "(", "input_size", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "filters", ",", "model", ".", "filter", ".", "numpy", "(", ")", ",", "atol", "=", "1e-8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestBSplines3DTransform.test_interpolation": [[284, 303], ["pytest.mark.parametrize", "deepreg.BSplines3DTransform", "deepreg.BSplines3DTransform.build", "tensorflow.random.normal", "deepreg.BSplines3DTransform.call", "int", "zip", "numpy.ceil"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.build", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"input_size,cp\"", ",", "\n", "[", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "8", ",", "8", ")", ")", ",", "(", "(", "1", ",", "8", ",", "8", ",", "8", ",", "3", ")", ",", "(", "8", ",", "16", ",", "12", ")", ")", "]", ",", "\n", ")", "\n", "def", "test_interpolation", "(", "self", ",", "input_size", ",", "cp", ")", ":", "\n", "        ", "model", "=", "layer", ".", "BSplines3DTransform", "(", "cp", ",", "input_size", "[", "1", ":", "-", "1", "]", ")", "\n", "model", ".", "build", "(", "input_size", ")", "\n", "\n", "vol_shape", "=", "input_size", "[", "1", ":", "-", "1", "]", "\n", "num_cp", "=", "(", "\n", "[", "input_size", "[", "0", "]", "]", "\n", "+", "[", "int", "(", "np", ".", "ceil", "(", "isize", "/", "cpsize", ")", "+", "3", ")", "for", "isize", ",", "cpsize", "in", "zip", "(", "vol_shape", ",", "cp", ")", "]", "\n", "+", "[", "input_size", "[", "-", "1", "]", "]", "\n", ")", "\n", "\n", "field", "=", "tf", ".", "random", ".", "normal", "(", "shape", "=", "num_cp", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "ddf", "=", "model", ".", "call", "(", "field", ")", "\n", "assert", "ddf", ".", "shape", "==", "input_size", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestResize3d.test_forward": [[306, 323], ["pytest.mark.parametrize", "tensorflow.ones", "deepreg.Resize3d"], "methods", ["None"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"input_shape\"", ",", "\"resize_shape\"", ",", "\"output_shape\"", ")", ",", "\n", "[", "\n", "(", "(", "1", ",", "2", ",", "3", ")", ",", "(", "3", ",", "4", ",", "5", ")", ",", "(", "3", ",", "4", ",", "5", ")", ")", ",", "\n", "(", "(", "2", ",", "1", ",", "2", ",", "3", ")", ",", "(", "3", ",", "4", ",", "5", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ")", ")", ",", "\n", "(", "(", "2", ",", "1", ",", "2", ",", "3", ",", "1", ")", ",", "(", "3", ",", "4", ",", "5", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ",", "1", ")", ")", ",", "\n", "(", "(", "2", ",", "1", ",", "2", ",", "3", ",", "6", ")", ",", "(", "3", ",", "4", ",", "5", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ",", "6", ")", ")", ",", "\n", "(", "(", "1", ",", "2", ",", "3", ")", ",", "(", "1", ",", "2", ",", "3", ")", ",", "(", "1", ",", "2", ",", "3", ")", ")", ",", "\n", "(", "(", "2", ",", "1", ",", "2", ",", "3", ")", ",", "(", "1", ",", "2", ",", "3", ")", ",", "(", "2", ",", "1", ",", "2", ",", "3", ")", ")", ",", "\n", "(", "(", "2", ",", "1", ",", "2", ",", "3", ",", "1", ")", ",", "(", "1", ",", "2", ",", "3", ")", ",", "(", "2", ",", "1", ",", "2", ",", "3", ",", "1", ")", ")", ",", "\n", "(", "(", "2", ",", "1", ",", "2", ",", "3", ",", "6", ")", ",", "(", "1", ",", "2", ",", "3", ")", ",", "(", "2", ",", "1", ",", "2", ",", "3", ",", "6", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_forward", "(", "self", ",", "input_shape", ",", "resize_shape", ",", "output_shape", ")", ":", "\n", "        ", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "input_shape", ")", "\n", "outputs", "=", "layer", ".", "Resize3d", "(", "shape", "=", "resize_shape", ")", "(", "inputs", ")", "\n", "assert", "outputs", ".", "shape", "==", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestResize3d.test_get_config": [[324, 333], ["deepreg.Resize3d", "deepreg.Resize3d.get_config", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "resize", "=", "layer", ".", "Resize3d", "(", "shape", "=", "(", "2", ",", "3", ",", "4", ")", ")", "\n", "config", "=", "resize", ".", "get_config", "(", ")", "\n", "assert", "config", "==", "dict", "(", "\n", "shape", "=", "(", "2", ",", "3", ",", "4", ")", ",", "\n", "method", "=", "tf", ".", "image", ".", "ResizeMethod", ".", "BILINEAR", ",", "\n", "name", "=", "\"resize3d\"", ",", "\n", "trainable", "=", "True", ",", "\n", "dtype", "=", "\"float32\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestResize3d.test_shape_err": [[335, 338], ["pytest.raises", "deepreg.Resize3d"], "methods", ["None"], ["", "def", "test_shape_err", "(", "self", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "layer", ".", "Resize3d", "(", "shape", "=", "(", "2", ",", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.TestResize3d.test_image_shape_err": [[339, 345], ["pytest.raises", "deepreg.Resize3d", "deepreg.Resize3d.", "str", "tensorflow.ones"], "methods", ["None"], ["", "", "def", "test_image_shape_err", "(", "self", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "resize", "=", "layer", ".", "Resize3d", "(", "shape", "=", "(", "2", ",", "3", ",", "4", ")", ")", "\n", "resize", "(", "tf", ".", "ones", "(", "1", ",", "1", ")", ")", "\n", "", "assert", "\"Resize3d takes input image of dimension 3 or 4 or 5\"", "in", "str", "(", "\n", "err_info", ".", "value", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.test_norm_block": [[14, 49], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "deepreg.NormBlock", "tensorflow.ones", "layer.NormBlock.", "layer.NormBlock.get_config", "dict"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"layer_name\"", ",", "[", "\"conv3d\"", ",", "\"deconv3d\"", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"norm_name\"", ",", "[", "\"batch\"", ",", "\"layer\"", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"activation\"", ",", "[", "\"relu\"", ",", "\"elu\"", "]", ")", "\n", "def", "test_norm_block", "(", "layer_name", ":", "str", ",", "norm_name", ":", "str", ",", "activation", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    Test output shapes and configs.\n\n    :param layer_name: layer_name for layer definition\n    :param norm_name: norm_name for layer definition\n    :param activation: activation for layer definition\n    \"\"\"", "\n", "input_size", "=", "(", "2", ",", "3", ",", "4", ",", "5", ",", "6", ")", "# (batch, *shape, ch)", "\n", "norm_block", "=", "layer", ".", "NormBlock", "(", "\n", "layer_name", "=", "layer_name", ",", "\n", "norm_name", "=", "norm_name", ",", "\n", "activation", "=", "activation", ",", "\n", "filters", "=", "3", ",", "\n", "kernel_size", "=", "1", ",", "\n", "padding", "=", "\"same\"", ",", "\n", ")", "\n", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "input_size", ")", "\n", "outputs", "=", "norm_block", "(", "inputs", ")", "\n", "assert", "outputs", ".", "shape", "==", "input_size", "[", ":", "-", "1", "]", "+", "(", "3", ",", ")", "\n", "\n", "config", "=", "norm_block", ".", "get_config", "(", ")", "\n", "assert", "config", "==", "dict", "(", "\n", "layer_name", "=", "layer_name", ",", "\n", "norm_name", "=", "norm_name", ",", "\n", "activation", "=", "activation", ",", "\n", "filters", "=", "3", ",", "\n", "kernel_size", "=", "1", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "name", "=", "\"norm_block\"", ",", "\n", "trainable", "=", "True", ",", "\n", "dtype", "=", "\"float32\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_layer.test_res_block": [[78, 118], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "deepreg.ResidualBlock", "tensorflow.ones", "layer.ResidualBlock.", "layer.ResidualBlock.get_config", "dict"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"layer_name\"", ",", "[", "\"conv3d\"", ",", "\"deconv3d\"", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"norm_name\"", ",", "[", "\"batch\"", ",", "\"layer\"", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"activation\"", ",", "[", "\"relu\"", ",", "\"elu\"", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"num_layers\"", ",", "[", "2", ",", "3", "]", ")", "\n", "def", "test_res_block", "(", "layer_name", ":", "str", ",", "norm_name", ":", "str", ",", "activation", ":", "str", ",", "num_layers", ":", "int", ")", ":", "\n", "    ", "\"\"\"\n    Test output shapes and configs.\n\n    :param layer_name: layer_name for layer definition\n    :param norm_name: norm_name for layer definition\n    :param activation: activation for layer definition\n    :param num_layers: number of blocks in res block\n    \"\"\"", "\n", "ch", "=", "3", "\n", "input_size", "=", "(", "2", ",", "3", ",", "4", ",", "5", ",", "ch", ")", "# (batch, *shape, ch)", "\n", "res_block", "=", "layer", ".", "ResidualBlock", "(", "\n", "layer_name", "=", "layer_name", ",", "\n", "num_layers", "=", "num_layers", ",", "\n", "norm_name", "=", "norm_name", ",", "\n", "activation", "=", "activation", ",", "\n", "filters", "=", "ch", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "\"same\"", ",", "\n", ")", "\n", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "input_size", ")", "\n", "outputs", "=", "res_block", "(", "inputs", ")", "\n", "assert", "outputs", ".", "shape", "==", "input_size", "[", ":", "-", "1", "]", "+", "(", "3", ",", ")", "\n", "\n", "config", "=", "res_block", ".", "get_config", "(", ")", "\n", "assert", "config", "==", "dict", "(", "\n", "layer_name", "=", "layer_name", ",", "\n", "num_layers", "=", "num_layers", ",", "\n", "norm_name", "=", "norm_name", ",", "\n", "activation", "=", "activation", ",", "\n", "filters", "=", "ch", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "name", "=", "\"res_block\"", ",", "\n", "trainable", "=", "True", ",", "\n", "dtype", "=", "\"float32\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np": [[9, 36], ["numpy.asarray", "numpy.asarray", "numpy.any", "numpy.nan_to_num", "numpy.nan_to_num", "numpy.all", "numpy.isclose", "numpy.isnan", "numpy.isnan"], "function", ["None"], ["def", "is_equal_np", "(", "\n", "x", ":", "Union", "[", "np", ".", "ndarray", ",", "List", "]", ",", "y", ":", "Union", "[", "np", ".", "ndarray", ",", "List", "]", ",", "atol", ":", "float", "=", "EPS", "\n", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n    Check if two numpy arrays are identical within a tolerance.\n\n    :param x:\n    :param y:\n    :param atol: error margin\n    :return: return true if two tf tensors are nearly equal\n    \"\"\"", "\n", "x", "=", "np", ".", "asarray", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "y", "=", "np", ".", "asarray", "(", "y", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# check shape", "\n", "if", "x", ".", "shape", "!=", "y", ".", "shape", ":", "\n", "        ", "return", "False", "\n", "\n", "# check nan values", "\n", "# support case some values are nan", "\n", "", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "x", ")", "!=", "np", ".", "isnan", "(", "y", ")", ")", ":", "\n", "        ", "return", "False", "\n", "", "x", "=", "np", ".", "nan_to_num", "(", "x", ")", "\n", "y", "=", "np", ".", "nan_to_num", "(", "y", ")", "\n", "\n", "# check values", "\n", "return", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "y", ",", "atol", "=", "atol", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf": [[38, 54], ["tensorflow.cast().numpy", "tensorflow.cast().numpy", "util.is_equal_np", "tensorflow.cast", "tensorflow.cast"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["", "def", "is_equal_tf", "(", "\n", "x", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "y", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "atol", ":", "float", "=", "EPS", ",", "\n", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n    Check if two tf tensors are identical within a tolerance.\n\n    :param x:\n    :param y:\n    :param atol: error margin\n    :return: return true if two tf tensors are nearly equal\n    \"\"\"", "\n", "x", "=", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "y", "=", "tf", ".", "cast", "(", "y", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "return", "is_equal_np", "(", "x", "=", "x", ",", "y", "=", "y", ",", "atol", "=", "atol", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestSumSquaredDistance.test_output": [[20, 40], ["pytest.mark.parametrize", "deepreg.SumSquaredDifference().call", "test.unit.util.is_equal_tf", "numpy.ones", "numpy.ones", "numpy.ones", "deepreg.SumSquaredDifference"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"y_true,y_pred,shape,expected\"", ",", "\n", "[", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", ")", ",", "0.09", ")", ",", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", "3", ")", ",", "0.09", ")", ",", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", "3", ",", "3", ")", ",", "0.09", ")", ",", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", "3", ",", "3", ")", ",", "0.09", ")", ",", "\n", "(", "0.5", ",", "0.5", ",", "(", "3", ",", "3", ")", ",", "0.0", ")", ",", "\n", "(", "0.3", ",", "0.6", ",", "(", "3", ",", "3", ")", ",", "0.09", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_output", "(", "self", ",", "y_true", ",", "y_pred", ",", "shape", ",", "expected", ")", ":", "\n", "        ", "y_true", "=", "y_true", "*", "np", ".", "ones", "(", "shape", "=", "shape", ")", "\n", "y_pred", "=", "y_pred", "*", "np", ".", "ones", "(", "shape", "=", "shape", ")", "\n", "expected", "=", "expected", "*", "np", ".", "ones", "(", "shape", "=", "(", "shape", "[", "0", "]", ",", ")", ")", "\n", "got", "=", "label", ".", "SumSquaredDifference", "(", ")", ".", "call", "(", "\n", "y_true", ",", "\n", "y_pred", ",", "\n", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestDiceScore.test_smooth": [[43, 83], ["pytest.mark.parametrize", "deepreg.DiceScore().call", "tensorflow.constant", "test.unit.util.is_equal_tf", "tensorflow.ones", "tensorflow.ones", "deepreg.DiceScore"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"value\"", ",", "\"smooth_nr\"", ",", "\"smooth_dr\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "0", ",", "1e-5", ",", "1e-5", ",", "1", ")", ",", "\n", "(", "0", ",", "0", ",", "1e-5", ",", "0", ")", ",", "\n", "(", "0", ",", "1e-5", ",", "0", ",", "np", ".", "inf", ")", ",", "\n", "(", "0", ",", "0", ",", "0", ",", "np", ".", "nan", ")", ",", "\n", "(", "0", ",", "1e-7", ",", "1e-7", ",", "1", ")", ",", "\n", "(", "1", ",", "1e-5", ",", "1e-5", ",", "1", ")", ",", "\n", "(", "1", ",", "0", ",", "1e-5", ",", "1", ")", ",", "\n", "(", "1", ",", "1e-5", ",", "0", ",", "1", ")", ",", "\n", "(", "1", ",", "0", ",", "0", ",", "1", ")", ",", "\n", "(", "1", ",", "1e-7", ",", "1e-7", ",", "1", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_smooth", "(", "\n", "self", ",", "\n", "value", ":", "float", ",", "\n", "smooth_nr", ":", "float", ",", "\n", "smooth_dr", ":", "float", ",", "\n", "expected", ":", "float", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test values in extreme cases where numerator/denominator are all zero.\n\n        :param value: value for input.\n        :param smooth_nr: constant for numerator.\n        :param smooth_dr: constant for denominator.\n        :param expected: target value.\n        \"\"\"", "\n", "shape", "=", "(", "1", ",", "10", ")", "\n", "y_true", "=", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "*", "value", "\n", "y_pred", "=", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "*", "value", "\n", "\n", "got", "=", "label", ".", "DiceScore", "(", "smooth_nr", "=", "smooth_nr", ",", "smooth_dr", "=", "smooth_dr", ")", ".", "call", "(", "\n", "y_true", ",", "\n", "y_pred", ",", "\n", ")", "\n", "expected", "=", "tf", ".", "constant", "(", "expected", ")", "\n", "assert", "is_equal_tf", "(", "got", "[", "0", "]", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestDiceScore.test_exact_value": [[84, 126], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "tensorflow.random.set_seed", "tensorflow.random.uniform", "tensorflow.random.uniform", "deepreg.DiceScore().call", "tensorflow.keras.layers.Flatten", "tensorflow.keras.layers.Flatten.", "tensorflow.keras.layers.Flatten.", "test.unit.util.is_equal_tf", "tensorflow.cast", "tensorflow.cast", "deepreg.DiceScore", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"binary\"", ",", "[", "True", ",", "False", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"background_weight\"", ",", "[", "0.0", ",", "0.1", ",", "0.5", ",", "1.0", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"shape\"", ",", "[", "(", "1", ",", ")", ",", "(", "10", ",", ")", ",", "(", "100", ",", ")", ",", "(", "2", ",", "3", ")", ",", "(", "2", ",", "3", ",", "4", ")", "]", ")", "\n", "def", "test_exact_value", "(", "self", ",", "binary", ":", "bool", ",", "background_weight", ":", "float", ",", "shape", ":", "Tuple", ")", ":", "\n", "        ", "\"\"\"\n        Test dice score by comparing at ground truth values.\n\n        :param binary: if project labels to binary values.\n        :param background_weight: the weight of background class.\n        :param shape: shape of input.\n        \"\"\"", "\n", "# init", "\n", "shape", "=", "(", "1", ",", ")", "+", "shape", "# add batch axis", "\n", "foreground_weight", "=", "1", "-", "background_weight", "\n", "tf", ".", "random", ".", "set_seed", "(", "0", ")", "\n", "y_true", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ")", "\n", "y_pred", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ")", "\n", "\n", "# obtained value", "\n", "got", "=", "label", ".", "DiceScore", "(", "\n", "binary", "=", "binary", ",", "\n", "background_weight", "=", "background_weight", ",", "\n", ")", ".", "call", "(", "y_true", "=", "y_true", ",", "y_pred", "=", "y_pred", ")", "\n", "\n", "# expected value", "\n", "flatten", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "\n", "y_true", "=", "flatten", "(", "y_true", ")", "\n", "y_pred", "=", "flatten", "(", "y_pred", ")", "\n", "if", "binary", ":", "\n", "            ", "y_true", "=", "tf", ".", "cast", "(", "y_true", ">=", "0.5", ",", "dtype", "=", "y_true", ".", "dtype", ")", "\n", "y_pred", "=", "tf", ".", "cast", "(", "y_pred", ">=", "0.5", ",", "dtype", "=", "y_pred", ".", "dtype", ")", "\n", "\n", "", "num", "=", "foreground_weight", "*", "tf", ".", "reduce_sum", "(", "\n", "y_true", "*", "y_pred", ",", "axis", "=", "1", "\n", ")", "+", "background_weight", "*", "tf", ".", "reduce_sum", "(", "(", "1", "-", "y_true", ")", "*", "(", "1", "-", "y_pred", ")", ",", "axis", "=", "1", ")", "\n", "num", "*=", "2", "\n", "denom", "=", "foreground_weight", "*", "tf", ".", "reduce_sum", "(", "\n", "y_true", "+", "y_pred", ",", "axis", "=", "1", "\n", ")", "+", "background_weight", "*", "tf", ".", "reduce_sum", "(", "(", "1", "-", "y_true", ")", "+", "(", "1", "-", "y_pred", ")", ",", "axis", "=", "1", ")", "\n", "expected", "=", "(", "num", "+", "EPS", ")", "/", "(", "denom", "+", "EPS", ")", "\n", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestDiceScore.test_get_config": [[127, 138], ["deepreg.DiceScore().get_config", "dict", "deepreg.DiceScore"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "got", "=", "label", ".", "DiceScore", "(", ")", ".", "get_config", "(", ")", "\n", "expected", "=", "dict", "(", "\n", "binary", "=", "False", ",", "\n", "background_weight", "=", "0.0", ",", "\n", "smooth_nr", "=", "1e-5", ",", "\n", "smooth_dr", "=", "1e-5", ",", "\n", "reduction", "=", "tf", ".", "keras", ".", "losses", ".", "Reduction", ".", "AUTO", ",", "\n", "name", "=", "\"DiceScore\"", ",", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestDiceScore.test_background_weight_err": [[139, 150], ["pytest.mark.parametrize", "pytest.raises", "deepreg.DiceScore", "str"], "methods", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"background_weight\"", ",", "[", "-", "0.1", ",", "1.1", "]", ")", "\n", "def", "test_background_weight_err", "(", "self", ",", "background_weight", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Test the error message when using wrong background weight.\n\n        :param background_weight: weight for background class.\n        \"\"\"", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "label", ".", "DiceScore", "(", "background_weight", "=", "background_weight", ")", "\n", "", "assert", "\"The background weight for Dice Score must be within [0, 1]\"", "in", "str", "(", "\n", "err_info", ".", "value", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestCrossEntropy.y_true": [[156, 159], ["pytest.fixture", "numpy.ones"], "methods", ["None"], ["@", "pytest", ".", "fixture", "(", ")", "\n", "def", "y_true", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "ones", "(", "shape", "=", "self", ".", "shape", ")", "*", "0.6", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestCrossEntropy.y_pred": [[160, 163], ["pytest.fixture", "numpy.ones"], "methods", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "y_pred", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "ones", "(", "shape", "=", "self", ".", "shape", ")", "*", "0.3", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestCrossEntropy.test_smooth": [[164, 198], ["pytest.mark.parametrize", "deepreg.CrossEntropy().call", "tensorflow.constant", "test.unit.util.is_equal_tf", "tensorflow.ones", "tensorflow.ones", "deepreg.CrossEntropy", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"value\"", ",", "\"smooth\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "0", ",", "1e-5", ",", "0", ")", ",", "\n", "(", "0", ",", "0", ",", "np", ".", "nan", ")", ",", "\n", "(", "0", ",", "1e-7", ",", "0", ")", ",", "\n", "(", "1", ",", "1e-5", ",", "-", "np", ".", "log", "(", "1", "+", "1e-5", ")", ")", ",", "\n", "(", "1", ",", "0", ",", "0", ")", ",", "\n", "(", "1", ",", "1e-7", ",", "-", "np", ".", "log", "(", "1", "+", "1e-7", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_smooth", "(", "\n", "self", ",", "\n", "value", ":", "float", ",", "\n", "smooth", ":", "float", ",", "\n", "expected", ":", "float", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test values in extreme cases where numerator/denominator are all zero.\n\n        :param value: value for input.\n        :param smooth: constant for log.\n        :param expected: target value.\n        \"\"\"", "\n", "shape", "=", "(", "1", ",", "10", ")", "\n", "y_true", "=", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "*", "value", "\n", "y_pred", "=", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "*", "value", "\n", "\n", "got", "=", "label", ".", "CrossEntropy", "(", "smooth", "=", "smooth", ")", ".", "call", "(", "\n", "y_true", ",", "\n", "y_pred", ",", "\n", ")", "\n", "expected", "=", "tf", ".", "constant", "(", "expected", ")", "\n", "assert", "is_equal_tf", "(", "got", "[", "0", "]", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestCrossEntropy.testcall": [[199, 214], ["pytest.mark.parametrize", "numpy.array", "deepreg.CrossEntropy().call", "test.unit.util.is_equal_tf", "deepreg.CrossEntropy", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"binary,background_weight,expected\"", ",", "\n", "[", "\n", "(", "True", ",", "0.0", ",", "-", "np", ".", "log", "(", "EPS", ")", ")", ",", "\n", "(", "False", ",", "0.0", ",", "-", "0.6", "*", "np", ".", "log", "(", "0.3", "+", "EPS", ")", ")", ",", "\n", "(", "False", ",", "0.2", ",", "-", "0.48", "*", "np", ".", "log", "(", "0.3", "+", "EPS", ")", "-", "0.08", "*", "np", ".", "log", "(", "0.7", "+", "EPS", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "testcall", "(", "self", ",", "y_true", ",", "y_pred", ",", "binary", ",", "background_weight", ",", "expected", ")", ":", "\n", "        ", "expected", "=", "np", ".", "array", "(", "[", "expected", "]", "*", "self", ".", "shape", "[", "0", "]", ")", "# call returns (batch, )", "\n", "got", "=", "label", ".", "CrossEntropy", "(", "\n", "binary", "=", "binary", ",", "\n", "background_weight", "=", "background_weight", ",", "\n", ")", ".", "call", "(", "y_true", "=", "y_true", ",", "y_pred", "=", "y_pred", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestCrossEntropy.test_get_config": [[215, 225], ["deepreg.CrossEntropy().get_config", "dict", "deepreg.CrossEntropy"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "got", "=", "label", ".", "CrossEntropy", "(", ")", ".", "get_config", "(", ")", "\n", "expected", "=", "dict", "(", "\n", "binary", "=", "False", ",", "\n", "background_weight", "=", "0.0", ",", "\n", "smooth", "=", "1e-5", ",", "\n", "reduction", "=", "tf", ".", "keras", ".", "losses", ".", "Reduction", ".", "AUTO", ",", "\n", "name", "=", "\"CrossEntropy\"", ",", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestCrossEntropy.test_background_weight_err": [[226, 237], ["pytest.mark.parametrize", "pytest.raises", "deepreg.CrossEntropy", "str"], "methods", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"background_weight\"", ",", "[", "-", "0.1", ",", "1.1", "]", ")", "\n", "def", "test_background_weight_err", "(", "self", ",", "background_weight", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Test the error message when using wrong background weight.\n\n        :param background_weight: weight for background class.\n        \"\"\"", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "label", ".", "CrossEntropy", "(", "background_weight", "=", "background_weight", ")", "\n", "", "assert", "\"The background weight for Cross Entropy must be within [0, 1]\"", "in", "str", "(", "\n", "err_info", ".", "value", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestJaccardIndex.test_smooth": [[241, 281], ["pytest.mark.parametrize", "deepreg.JaccardIndex().call", "tensorflow.constant", "test.unit.util.is_equal_tf", "tensorflow.ones", "tensorflow.ones", "deepreg.JaccardIndex"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"value\"", ",", "\"smooth_nr\"", ",", "\"smooth_dr\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "0", ",", "1e-5", ",", "1e-5", ",", "1", ")", ",", "\n", "(", "0", ",", "0", ",", "1e-5", ",", "0", ")", ",", "\n", "(", "0", ",", "1e-5", ",", "0", ",", "np", ".", "inf", ")", ",", "\n", "(", "0", ",", "0", ",", "0", ",", "np", ".", "nan", ")", ",", "\n", "(", "0", ",", "1e-7", ",", "1e-7", ",", "1", ")", ",", "\n", "(", "1", ",", "1e-5", ",", "1e-5", ",", "1", ")", ",", "\n", "(", "1", ",", "0", ",", "1e-5", ",", "1", ")", ",", "\n", "(", "1", ",", "1e-5", ",", "0", ",", "1", ")", ",", "\n", "(", "1", ",", "0", ",", "0", ",", "1", ")", ",", "\n", "(", "1", ",", "1e-7", ",", "1e-7", ",", "1", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_smooth", "(", "\n", "self", ",", "\n", "value", ":", "float", ",", "\n", "smooth_nr", ":", "float", ",", "\n", "smooth_dr", ":", "float", ",", "\n", "expected", ":", "float", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test values in extreme cases where numerator/denominator are all zero.\n\n        :param value: value for input.\n        :param smooth_nr: constant for numerator.\n        :param smooth_dr: constant for denominator.\n        :param expected: target value.\n        \"\"\"", "\n", "shape", "=", "(", "1", ",", "10", ")", "\n", "y_true", "=", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "*", "value", "\n", "y_pred", "=", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "*", "value", "\n", "\n", "got", "=", "label", ".", "JaccardIndex", "(", "smooth_nr", "=", "smooth_nr", ",", "smooth_dr", "=", "smooth_dr", ")", ".", "call", "(", "\n", "y_true", ",", "\n", "y_pred", ",", "\n", ")", "\n", "expected", "=", "tf", ".", "constant", "(", "expected", ")", "\n", "assert", "is_equal_tf", "(", "got", "[", "0", "]", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestJaccardIndex.test_exact_value": [[282, 324], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "tensorflow.random.set_seed", "tensorflow.random.uniform", "tensorflow.random.uniform", "deepreg.JaccardIndex().call", "tensorflow.keras.layers.Flatten", "tensorflow.keras.layers.Flatten.", "tensorflow.keras.layers.Flatten.", "test.unit.util.is_equal_tf", "tensorflow.cast", "tensorflow.cast", "deepreg.JaccardIndex", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"binary\"", ",", "[", "True", ",", "False", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"background_weight\"", ",", "[", "0.0", ",", "0.1", ",", "0.5", ",", "1.0", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"shape\"", ",", "[", "(", "1", ",", ")", ",", "(", "10", ",", ")", ",", "(", "100", ",", ")", ",", "(", "2", ",", "3", ")", ",", "(", "2", ",", "3", ",", "4", ")", "]", ")", "\n", "def", "test_exact_value", "(", "self", ",", "binary", ":", "bool", ",", "background_weight", ":", "float", ",", "shape", ":", "Tuple", ")", ":", "\n", "        ", "\"\"\"\n        Test Jaccard index by comparing at ground truth values.\n\n        :param binary: if project labels to binary values.\n        :param background_weight: the weight of background class.\n        :param shape: shape of input.\n        \"\"\"", "\n", "# init", "\n", "shape", "=", "(", "1", ",", ")", "+", "shape", "# add batch axis", "\n", "foreground_weight", "=", "1", "-", "background_weight", "\n", "tf", ".", "random", ".", "set_seed", "(", "0", ")", "\n", "y_true", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ")", "\n", "y_pred", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ")", "\n", "\n", "# obtained value", "\n", "got", "=", "label", ".", "JaccardIndex", "(", "\n", "binary", "=", "binary", ",", "\n", "background_weight", "=", "background_weight", ",", "\n", ")", ".", "call", "(", "y_true", "=", "y_true", ",", "y_pred", "=", "y_pred", ")", "\n", "\n", "# expected value", "\n", "flatten", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "\n", "y_true", "=", "flatten", "(", "y_true", ")", "\n", "y_pred", "=", "flatten", "(", "y_pred", ")", "\n", "if", "binary", ":", "\n", "            ", "y_true", "=", "tf", ".", "cast", "(", "y_true", ">=", "0.5", ",", "dtype", "=", "y_true", ".", "dtype", ")", "\n", "y_pred", "=", "tf", ".", "cast", "(", "y_pred", ">=", "0.5", ",", "dtype", "=", "y_pred", ".", "dtype", ")", "\n", "\n", "", "num", "=", "foreground_weight", "*", "tf", ".", "reduce_sum", "(", "\n", "y_true", "*", "y_pred", ",", "axis", "=", "1", "\n", ")", "+", "background_weight", "*", "tf", ".", "reduce_sum", "(", "(", "1", "-", "y_true", ")", "*", "(", "1", "-", "y_pred", ")", ",", "axis", "=", "1", ")", "\n", "denom", "=", "foreground_weight", "*", "tf", ".", "reduce_sum", "(", "\n", "y_true", "+", "y_pred", ",", "axis", "=", "1", "\n", ")", "+", "background_weight", "*", "tf", ".", "reduce_sum", "(", "(", "1", "-", "y_true", ")", "+", "(", "1", "-", "y_pred", ")", ",", "axis", "=", "1", ")", "\n", "denom", "=", "denom", "-", "num", "\n", "expected", "=", "(", "num", "+", "EPS", ")", "/", "(", "denom", "+", "EPS", ")", "\n", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.TestJaccardIndex.test_get_config": [[325, 336], ["deepreg.JaccardIndex().get_config", "dict", "deepreg.JaccardIndex"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "got", "=", "label", ".", "JaccardIndex", "(", ")", ".", "get_config", "(", ")", "\n", "expected", "=", "dict", "(", "\n", "binary", "=", "False", ",", "\n", "background_weight", "=", "0.0", ",", "\n", "smooth_nr", "=", "1e-5", ",", "\n", "smooth_dr", "=", "1e-5", ",", "\n", "reduction", "=", "tf", ".", "keras", ".", "losses", ".", "Reduction", ".", "AUTO", ",", "\n", "name", "=", "\"JaccardIndex\"", ",", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.test_foreground_prop_binary": [[338, 351], ["numpy.identity", "numpy.zeros", "tensorflow.convert_to_tensor", "deepreg.foreground_proportion", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.foreground_proportion", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "", "def", "test_foreground_prop_binary", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test foreground function with a\n    tensor of zeros with some ones, asserting\n    equal to known precomputed tensor.\n    Testing with binary case.\n    \"\"\"", "\n", "array_eye", "=", "np", ".", "identity", "(", "3", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "tensor_eye", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ",", "3", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "tensor_eye", "[", ":", ",", ":", ",", "0", ":", "3", ",", "0", ":", "3", "]", "=", "array_eye", "\n", "expect", "=", "tf", ".", "convert_to_tensor", "(", "[", "1.0", "/", "3", ",", "1.0", "/", "3", ",", "1.0", "/", "3", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "get", "=", "label", ".", "foreground_proportion", "(", "tensor_eye", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.test_foreground_prop_simple": [[353, 368], ["numpy.identity", "numpy.zeros", "tensorflow.convert_to_tensor", "deepreg.foreground_proportion", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.foreground_proportion", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_foreground_prop_simple", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test foreground functions with a tensor\n    of zeros with some ones and some values below\n    one to assert the thresholding works.\n    \"\"\"", "\n", "array_eye", "=", "np", ".", "identity", "(", "3", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "tensor_eye", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ",", "3", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "tensor_eye", "[", ":", ",", "0", ",", ":", ",", ":", "]", "=", "0.4", "*", "array_eye", "# 0", "\n", "tensor_eye", "[", ":", ",", "1", ",", ":", ",", ":", "]", "=", "array_eye", "\n", "tensor_eye", "[", ":", ",", "2", ",", ":", ",", ":", "]", "=", "array_eye", "\n", "tensor_eye", "=", "tf", ".", "convert_to_tensor", "(", "tensor_eye", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "expect", "=", "[", "54", "/", "(", "27", "*", "9", ")", ",", "54", "/", "(", "27", "*", "9", ")", ",", "54", "/", "(", "27", "*", "9", ")", "]", "\n", "get", "=", "label", ".", "foreground_proportion", "(", "tensor_eye", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.test_compute_centroid": [[370, 388], ["numpy.zeros", "numpy.ones", "tensorflow.constant", "numpy.ones", "tensorflow.constant", "numpy.ones", "deepreg.compute_centroid", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.compute_centroid", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_compute_centroid", "(", ")", ":", "\n", "    ", "\"\"\"\n    Testing compute centroid function\n    and comparing to expected values.\n    \"\"\"", "\n", "tensor_mask", "=", "np", ".", "zeros", "(", "(", "3", ",", "2", ",", "2", ",", "2", ")", ")", "\n", "tensor_mask", "[", "0", ",", ":", ",", ":", ",", ":", "]", "=", "np", ".", "ones", "(", "(", "2", ",", "2", ",", "2", ")", ")", "\n", "tensor_mask", "=", "tf", ".", "constant", "(", "tensor_mask", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "tensor_grid", "=", "np", ".", "ones", "(", "(", "1", ",", "2", ",", "2", ",", "2", ",", "3", ")", ")", "\n", "tensor_grid", "[", ":", ",", ":", ",", ":", ",", ":", ",", "1", "]", "*=", "2", "\n", "tensor_grid", "[", ":", ",", ":", ",", ":", ",", ":", ",", "2", "]", "*=", "3", "\n", "tensor_grid", "=", "tf", ".", "constant", "(", "tensor_grid", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "expected", "=", "np", ".", "ones", "(", "(", "3", ",", "3", ")", ")", "# use 1 because 0/0 ~= (0+eps)/(0+eps) = 1", "\n", "expected", "[", "0", ",", ":", "]", "=", "[", "1", ",", "2", ",", "3", "]", "\n", "got", "=", "label", ".", "compute_centroid", "(", "tensor_mask", ",", "tensor_grid", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_label.test_compute_centroid_d": [[390, 407], ["numpy.ones", "numpy.zeros", "tensorflow.convert_to_tensor", "numpy.zeros", "tensorflow.convert_to_tensor", "deepreg.compute_centroid_distance", "numpy.zeros", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.compute_centroid_distance", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_compute_centroid_d", "(", ")", ":", "\n", "    ", "\"\"\"\n    Testing compute centroid distance between equal\n    tensors returns 0s.\n    \"\"\"", "\n", "array_ones", "=", "np", ".", "ones", "(", "(", "2", ",", "2", ")", ")", "\n", "tensor_mask", "=", "np", ".", "zeros", "(", "(", "3", ",", "2", ",", "2", ",", "2", ")", ")", "\n", "tensor_mask", "[", "0", ",", ":", ",", ":", ",", ":", "]", "=", "array_ones", "\n", "tensor_mask", "=", "tf", ".", "convert_to_tensor", "(", "tensor_mask", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "tensor_grid", "=", "np", ".", "zeros", "(", "(", "1", ",", "2", ",", "2", ",", "2", ",", "3", ")", ")", "\n", "tensor_grid", "[", ":", ",", ":", ",", ":", ",", ":", ",", "0", "]", "=", "array_ones", "\n", "tensor_grid", "=", "tf", ".", "convert_to_tensor", "(", "tensor_grid", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "get", "=", "label", ".", "compute_centroid_distance", "(", "tensor_mask", ",", "tensor_mask", ",", "tensor_grid", ")", "\n", "expect", "=", "np", ".", "zeros", "(", "(", "3", ")", ")", "\n", "assert", "is_equal_tf", "(", "get", ",", "expect", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestGlobalMutualInformation.test_zero_info": [[20, 37], ["pytest.mark.parametrize", "deepreg.GlobalMutualInformation().call", "test.unit.util.is_equal_tf", "numpy.ones", "numpy.ones", "numpy.ones", "deepreg.GlobalMutualInformation"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"y_true,y_pred,shape,expected\"", ",", "\n", "[", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", "3", ",", "3", ",", "3", ")", ",", "0.0", ")", ",", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", "3", ",", "3", ",", "3", ",", "3", ")", ",", "0.0", ")", ",", "\n", "(", "0.0", ",", "1.0", ",", "(", "3", ",", "3", ",", "3", ",", "3", ",", "3", ")", ",", "0.0", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_zero_info", "(", "self", ",", "y_true", ",", "y_pred", ",", "shape", ",", "expected", ")", ":", "\n", "        ", "y_true", "=", "y_true", "*", "np", ".", "ones", "(", "shape", "=", "shape", ")", "\n", "y_pred", "=", "y_pred", "*", "np", ".", "ones", "(", "shape", "=", "shape", ")", "\n", "expected", "=", "expected", "*", "np", ".", "ones", "(", "shape", "=", "(", "shape", "[", "0", "]", ",", ")", ")", "\n", "got", "=", "image", ".", "GlobalMutualInformation", "(", ")", ".", "call", "(", "\n", "y_true", ",", "\n", "y_pred", ",", "\n", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestGlobalMutualInformation.test_get_config": [[38, 47], ["deepreg.GlobalMutualInformation().get_config", "dict", "deepreg.GlobalMutualInformation"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "got", "=", "image", ".", "GlobalMutualInformation", "(", ")", ".", "get_config", "(", ")", "\n", "expected", "=", "dict", "(", "\n", "num_bins", "=", "23", ",", "\n", "sigma_ratio", "=", "0.5", ",", "\n", "reduction", "=", "tf", ".", "keras", ".", "losses", ".", "Reduction", ".", "AUTO", ",", "\n", "name", "=", "\"GlobalMutualInformation\"", ",", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestLocalNormalizedCrossCorrelation.test_input_shape": [[58, 81], ["pytest.mark.parametrize", "tensorflow.ones", "tensorflow.ones", "deepreg.LocalNormalizedCrossCorrelation().call", "deepreg.LocalNormalizedCrossCorrelation"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"y_true_shape\"", ",", "\"y_pred_shape\"", ")", ",", "\n", "[", "\n", "(", "(", "2", ",", "3", ",", "4", ",", "5", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ")", ")", ",", "\n", "(", "(", "2", ",", "3", ",", "4", ",", "5", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ",", "1", ")", ")", ",", "\n", "(", "(", "2", ",", "3", ",", "4", ",", "5", ",", "1", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ")", ")", ",", "\n", "(", "(", "2", ",", "3", ",", "4", ",", "5", ",", "1", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ",", "1", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_input_shape", "(", "self", ",", "y_true_shape", ":", "Tuple", ",", "y_pred_shape", ":", "Tuple", ")", ":", "\n", "        ", "\"\"\"\n        Test input with / without channel axis.\n\n        :param y_true_shape: input shape for y_true.\n        :param y_pred_shape: input shape for y_pred.\n        \"\"\"", "\n", "y_true", "=", "tf", ".", "ones", "(", "shape", "=", "y_true_shape", ")", "\n", "y_pred", "=", "tf", ".", "ones", "(", "shape", "=", "y_pred_shape", ")", "\n", "got", "=", "image", ".", "LocalNormalizedCrossCorrelation", "(", ")", ".", "call", "(", "\n", "y_true", ",", "\n", "y_pred", ",", "\n", ")", "\n", "assert", "got", ".", "shape", "==", "y_true_shape", "[", ":", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestLocalNormalizedCrossCorrelation.test_input_shape_err": [[82, 102], ["pytest.mark.parametrize", "tensorflow.ones", "tensorflow.ones", "pytest.raises", "deepreg.LocalNormalizedCrossCorrelation().call", "str", "deepreg.LocalNormalizedCrossCorrelation"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"y_true_shape\"", ",", "\"y_pred_shape\"", ",", "\"name\"", ")", ",", "\n", "[", "\n", "(", "(", "2", ",", "3", ",", "4", ",", "5", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ",", "6", ")", ",", "\"y_pred\"", ")", ",", "\n", "(", "(", "2", ",", "3", ",", "4", ",", "5", ",", "6", ")", ",", "(", "2", ",", "3", ",", "4", ",", "5", ")", ",", "\"y_true\"", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_input_shape_err", "(", "self", ",", "y_true_shape", ":", "Tuple", ",", "y_pred_shape", ":", "Tuple", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Current LNCC does not support image having channel dimension > 1.\n\n        :param y_true_shape: input shape for y_true.\n        :param y_pred_shape: input shape for y_pred.\n        :param name: name of the tensor having error.\n        \"\"\"", "\n", "y_true", "=", "tf", ".", "ones", "(", "shape", "=", "y_true_shape", ")", "\n", "y_pred", "=", "tf", ".", "ones", "(", "shape", "=", "y_pred_shape", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "image", ".", "LocalNormalizedCrossCorrelation", "(", ")", ".", "call", "(", "y_true", ",", "y_pred", ")", "\n", "", "assert", "f\"Last dimension of {name} is not one.\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestLocalNormalizedCrossCorrelation.test_smooth": [[103, 146], ["pytest.mark.parametrize", "pytest.mark.parametrize", "deepreg.LocalNormalizedCrossCorrelation().calc_ncc", "tensorflow.constant", "test.unit.util.is_equal_tf", "tensorflow.ones", "tensorflow.ones", "deepreg.LocalNormalizedCrossCorrelation"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.LocalNormalizedCrossCorrelation.calc_ncc", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"value\"", ",", "[", "0.0", ",", "0.5", ",", "1.0", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"smooth_nr\"", ",", "\"smooth_dr\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "1e-5", ",", "1e-5", ",", "1", ")", ",", "\n", "(", "0", ",", "1e-5", ",", "0", ")", ",", "\n", "(", "1e-5", ",", "0", ",", "np", ".", "inf", ")", ",", "\n", "(", "0", ",", "0", ",", "np", ".", "nan", ")", ",", "\n", "(", "1e-7", ",", "1e-7", ",", "1", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_smooth", "(", "\n", "self", ",", "\n", "value", ":", "float", ",", "\n", "smooth_nr", ":", "float", ",", "\n", "smooth_dr", ":", "float", ",", "\n", "expected", ":", "float", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Test values in extreme cases where variances are all zero.\n\n        :param value: value for input.\n        :param smooth_nr: constant for numerator.\n        :param smooth_dr: constant for denominator.\n        :param expected: target value.\n        \"\"\"", "\n", "kernel_size", "=", "5", "\n", "mid", "=", "kernel_size", "//", "2", "\n", "shape", "=", "(", "1", ",", "kernel_size", ",", "kernel_size", ",", "kernel_size", ",", "1", ")", "\n", "y_true", "=", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "*", "value", "\n", "y_pred", "=", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "*", "value", "\n", "\n", "got", "=", "image", ".", "LocalNormalizedCrossCorrelation", "(", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "smooth_nr", "=", "smooth_nr", ",", "\n", "smooth_dr", "=", "smooth_dr", ",", "\n", ")", ".", "calc_ncc", "(", "\n", "y_true", ",", "\n", "y_pred", ",", "\n", ")", "\n", "got", "=", "got", "[", "0", ",", "mid", ",", "mid", ",", "mid", ",", "0", "]", "\n", "expected", "=", "tf", ".", "constant", "(", "expected", ")", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestLocalNormalizedCrossCorrelation.test_exact_value": [[147, 196], ["pytest.mark.parametrize", "pytest.mark.parametrize", "tensorflow.random.set_seed", "tensorflow.random.uniform", "tensorflow.random.uniform", "deepreg.LocalNormalizedCrossCorrelation", "deepreg.LocalNormalizedCrossCorrelation.calc_ncc", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "test.unit.util.is_equal_tf", "tensorflow.reduce_sum", "tensorflow.reduce_sum"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.LocalNormalizedCrossCorrelation.calc_ncc", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"kernel_type\"", ",", "\n", "[", "\"rectangular\"", ",", "\"gaussian\"", ",", "\"triangular\"", "]", ",", "\n", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"kernel_size\"", ",", "\n", "[", "3", ",", "5", ",", "7", "]", ",", "\n", ")", "\n", "def", "test_exact_value", "(", "self", ",", "kernel_type", ",", "kernel_size", ")", ":", "\n", "        ", "\"\"\"\n        Test the exact value at the center of a cube.\n\n        :param kernel_type: name of kernel.\n        :param kernel_size: size of the kernel and the cube.\n        \"\"\"", "\n", "# init", "\n", "mid", "=", "kernel_size", "//", "2", "\n", "tf", ".", "random", ".", "set_seed", "(", "0", ")", "\n", "y_true", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "1", ",", "kernel_size", ",", "kernel_size", ",", "kernel_size", ",", "1", ")", ")", "\n", "y_pred", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "(", "1", ",", "kernel_size", ",", "kernel_size", ",", "kernel_size", ",", "1", ")", ")", "\n", "loss", "=", "image", ".", "LocalNormalizedCrossCorrelation", "(", "\n", "kernel_type", "=", "kernel_type", ",", "kernel_size", "=", "kernel_size", "\n", ")", "\n", "\n", "# obtained value", "\n", "got", "=", "loss", ".", "calc_ncc", "(", "y_true", "=", "y_true", ",", "y_pred", "=", "y_pred", ")", "\n", "got", "=", "got", "[", "0", ",", "mid", ",", "mid", ",", "mid", ",", "0", "]", "# center voxel", "\n", "\n", "# target value", "\n", "kernel_3d", "=", "(", "\n", "loss", ".", "kernel", "[", ":", ",", "None", ",", "None", "]", "\n", "*", "loss", ".", "kernel", "[", "None", ",", ":", ",", "None", "]", "\n", "*", "loss", ".", "kernel", "[", "None", ",", "None", ",", ":", "]", "\n", ")", "\n", "kernel_3d", "=", "kernel_3d", "[", "None", ",", ":", ",", ":", ",", ":", ",", "None", "]", "\n", "\n", "y_true_mean", "=", "tf", ".", "reduce_sum", "(", "y_true", "*", "kernel_3d", ")", "/", "loss", ".", "kernel_vol", "\n", "y_true_normalized", "=", "y_true", "-", "y_true_mean", "\n", "y_true_var", "=", "tf", ".", "reduce_sum", "(", "y_true_normalized", "**", "2", "*", "kernel_3d", ")", "\n", "\n", "y_pred_mean", "=", "tf", ".", "reduce_sum", "(", "y_pred", "*", "kernel_3d", ")", "/", "loss", ".", "kernel_vol", "\n", "y_pred_normalized", "=", "y_pred", "-", "y_pred_mean", "\n", "y_pred_var", "=", "tf", ".", "reduce_sum", "(", "y_pred_normalized", "**", "2", "*", "kernel_3d", ")", "\n", "\n", "cross", "=", "tf", ".", "reduce_sum", "(", "y_true_normalized", "*", "y_pred_normalized", "*", "kernel_3d", ")", "\n", "expected", "=", "(", "cross", "**", "2", "+", "EPS", ")", "/", "(", "y_pred_var", "*", "y_true_var", "+", "EPS", ")", "\n", "\n", "# check", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestLocalNormalizedCrossCorrelation.test_kernel_error": [[197, 202], ["pytest.raises", "deepreg.LocalNormalizedCrossCorrelation", "str"], "methods", ["None"], ["", "def", "test_kernel_error", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the error message when using wrong kernel.\"\"\"", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "image", ".", "LocalNormalizedCrossCorrelation", "(", "kernel_type", "=", "\"constant\"", ")", "\n", "", "assert", "\"Wrong kernel_type constant for LNCC loss type.\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestLocalNormalizedCrossCorrelation.test_get_config": [[203, 215], ["deepreg.LocalNormalizedCrossCorrelation().get_config", "dict", "deepreg.LocalNormalizedCrossCorrelation"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the config is saved correctly.\"\"\"", "\n", "got", "=", "image", ".", "LocalNormalizedCrossCorrelation", "(", ")", ".", "get_config", "(", ")", "\n", "expected", "=", "dict", "(", "\n", "kernel_size", "=", "9", ",", "\n", "kernel_type", "=", "\"rectangular\"", ",", "\n", "reduction", "=", "tf", ".", "keras", ".", "losses", ".", "Reduction", ".", "AUTO", ",", "\n", "name", "=", "\"LocalNormalizedCrossCorrelation\"", ",", "\n", "smooth_nr", "=", "1e-5", ",", "\n", "smooth_dr", "=", "1e-5", ",", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.TestGlobalNormalizedCrossCorrelation.test_output": [[218, 244], ["pytest.mark.parametrize", "tuple", "numpy.pad", "numpy.pad", "deepreg.GlobalNormalizedCrossCorrelation().call", "test.unit.util.is_equal_tf", "tensorflow.ones", "tensorflow.ones", "tensorflow.ones", "deepreg.GlobalNormalizedCrossCorrelation", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"y_true,y_pred,shape,expected\"", ",", "\n", "[", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", "3", ")", ",", "1", ")", ",", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", "3", ",", "3", ")", ",", "1", ")", ",", "\n", "(", "0.6", ",", "-", "0.3", ",", "(", "3", ",", "3", ",", "3", ")", ",", "1", ")", ",", "\n", "(", "0.6", ",", "0.3", ",", "(", "3", ",", "3", ",", "3", ",", "3", ")", ",", "1", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_output", "(", "self", ",", "y_true", ",", "y_pred", ",", "shape", ",", "expected", ")", ":", "\n", "\n", "        ", "y_true", "=", "y_true", "*", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "\n", "y_pred", "=", "y_pred", "*", "tf", ".", "ones", "(", "shape", "=", "shape", ")", "\n", "\n", "pad_width", "=", "tuple", "(", "[", "(", "0", ",", "0", ")", "]", "+", "[", "(", "1", ",", "1", ")", "]", "*", "(", "len", "(", "shape", ")", "-", "1", ")", ")", "\n", "y_true", "=", "np", ".", "pad", "(", "y_true", ",", "pad_width", "=", "pad_width", ")", "\n", "y_pred", "=", "np", ".", "pad", "(", "y_pred", ",", "pad_width", "=", "pad_width", ")", "\n", "\n", "got", "=", "image", ".", "GlobalNormalizedCrossCorrelation", "(", ")", ".", "call", "(", "\n", "y_true", ",", "\n", "y_pred", ",", "\n", ")", "\n", "\n", "expected", "=", "expected", "*", "tf", ".", "ones", "(", "shape", "=", "(", "shape", "[", "0", "]", ",", ")", ")", "\n", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_image.test_kernel_fn": [[49, 55], ["pytest.mark.parametrize", "pytest.mark.parametrize", "kernel_fn"], "function", ["None"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"kernel_size\"", ",", "[", "3", ",", "5", ",", "7", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"name\"", ",", "[", "\"gaussian\"", ",", "\"triangular\"", ",", "\"rectangular\"", "]", ")", "\n", "def", "test_kernel_fn", "(", "kernel_size", ",", "name", ")", ":", "\n", "    ", "kernel_fn", "=", "image", ".", "LocalNormalizedCrossCorrelation", ".", "kernel_fn_dict", "[", "name", "]", "\n", "filters", "=", "kernel_fn", "(", "kernel_size", ")", "\n", "assert", "filters", ".", "shape", "==", "(", "kernel_size", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseData.test_parse": [[64, 74], ["pytest.mark.parametrize", "deepreg.config.v011.parse_data"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_data"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"data_config\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "config_v011", ",", "config_latest", ")", ",", "\n", "(", "config_latest", ",", "config_latest", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_parse", "(", "self", ",", "data_config", ":", "Dict", ",", "expected", ":", "Dict", ")", ":", "\n", "        ", "got", "=", "parse_data", "(", "data_config", "=", "data_config", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseModel.test_parse": [[89, 100], ["pytest.mark.parametrize", "deepreg.config.v011.parse_model"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_model"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"model_config\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "config_v011", ",", "config_latest", ")", ",", "\n", "(", "config_v011", "[", "\"model\"", "]", ",", "config_latest", ")", ",", "\n", "(", "config_latest", ",", "config_latest", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_parse", "(", "self", ",", "model_config", ":", "Dict", ",", "expected", ":", "Dict", ")", ":", "\n", "        ", "got", "=", "parse_model", "(", "model_config", "=", "model_config", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseLoss.test_parse": [[124, 134], ["pytest.mark.parametrize", "deepreg.config.v011.parse_loss"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_loss"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"loss_config\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "config_v011", ",", "config_latest", ")", ",", "\n", "(", "config_latest", ",", "config_latest", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_parse", "(", "self", ",", "loss_config", ":", "Dict", ",", "expected", ":", "Dict", ")", ":", "\n", "        ", "got", "=", "parse_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseImageLoss.test_parse": [[156, 166], ["pytest.mark.parametrize", "deepreg.config.v011.parse_image_loss"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_image_loss"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"loss_config\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "config_v011", ",", "config_latest", ")", ",", "\n", "(", "config_latest", ",", "config_latest", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_parse", "(", "self", ",", "loss_config", ":", "Dict", ",", "expected", ":", "Dict", ")", ":", "\n", "        ", "got", "=", "parse_image_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseImageLoss.test_parse_multiple_loss": [[167, 185], ["deepreg.config.v011.parse_image_loss"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_image_loss"], ["", "def", "test_parse_multiple_loss", "(", "self", ")", ":", "\n", "        ", "loss_config", "=", "{", "\n", "\"image\"", ":", "[", "\n", "{", "\n", "\"name\"", ":", "\"lncc\"", ",", "\n", "\"weight\"", ":", "0.5", ",", "\n", "\"kernel_size\"", ":", "9", ",", "\n", "\"kernel_type\"", ":", "\"rectangular\"", ",", "\n", "}", ",", "\n", "{", "\n", "\"name\"", ":", "\"ssd\"", ",", "\n", "\"weight\"", ":", "0.5", ",", "\n", "}", ",", "\n", "]", ",", "\n", "}", "\n", "\n", "got", "=", "parse_image_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "assert", "got", "==", "loss_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseLabelLoss.test_parse_outdated_loss": [[188, 231], ["pytest.mark.parametrize", "deepreg.config.v011.parse_label_loss"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_label_loss"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"name_loss\"", ",", "\"expected_config\"", ")", ",", "\n", "[", "\n", "(", "\n", "\"multi_scale\"", ",", "\n", "{", "\n", "\"label\"", ":", "{", "\n", "\"name\"", ":", "\"ssd\"", ",", "\n", "\"weight\"", ":", "2.0", ",", "\n", "\"scales\"", ":", "[", "0", ",", "1", "]", ",", "\n", "}", ",", "\n", "}", ",", "\n", ")", ",", "\n", "(", "\n", "\"single_scale\"", ",", "\n", "{", "\n", "\"label\"", ":", "{", "\n", "\"name\"", ":", "\"dice\"", ",", "\n", "\"weight\"", ":", "1.0", ",", "\n", "}", ",", "\n", "}", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_parse_outdated_loss", "(", "self", ",", "name_loss", ":", "str", ",", "expected_config", ":", "Dict", ")", ":", "\n", "        ", "outdated_config", "=", "{", "\n", "\"label\"", ":", "{", "\n", "\"name\"", ":", "name_loss", ",", "\n", "\"single_scale\"", ":", "{", "\n", "\"loss_type\"", ":", "\"dice_generalized\"", ",", "\n", "}", ",", "\n", "\"multi_scale\"", ":", "{", "\n", "\"loss_type\"", ":", "\"mean-squared\"", ",", "\n", "\"loss_scales\"", ":", "[", "0", ",", "1", "]", ",", "\n", "}", ",", "\n", "}", ",", "\n", "}", "\n", "\n", "if", "name_loss", "==", "\"multi_scale\"", ":", "\n", "            ", "outdated_config", "[", "\"label\"", "]", "[", "\"weight\"", "]", "=", "2.0", "# type: ignore", "\n", "\n", "", "got", "=", "parse_label_loss", "(", "loss_config", "=", "outdated_config", ")", "\n", "assert", "got", "==", "expected_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseLabelLoss.test_parse_background_weight": [[232, 249], ["deepreg.config.v011.parse_label_loss"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_label_loss"], ["", "def", "test_parse_background_weight", "(", "self", ")", ":", "\n", "        ", "outdated_config", "=", "{", "\n", "\"label\"", ":", "{", "\n", "\"name\"", ":", "\"dice\"", ",", "\n", "\"weight\"", ":", "1.0", ",", "\n", "\"neg_weight\"", ":", "2.0", ",", "\n", "}", ",", "\n", "}", "\n", "expected_config", "=", "{", "\n", "\"label\"", ":", "{", "\n", "\"name\"", ":", "\"dice\"", ",", "\n", "\"weight\"", ":", "1.0", ",", "\n", "\"background_weight\"", ":", "2.0", ",", "\n", "}", ",", "\n", "}", "\n", "got", "=", "parse_label_loss", "(", "loss_config", "=", "outdated_config", ")", "\n", "assert", "got", "==", "expected_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseLabelLoss.test_parse_multiple_loss": [[250, 266], ["deepreg.config.v011.parse_label_loss"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_label_loss"], ["", "def", "test_parse_multiple_loss", "(", "self", ")", ":", "\n", "        ", "loss_config", "=", "{", "\n", "\"label\"", ":", "[", "\n", "{", "\n", "\"name\"", ":", "\"dice\"", ",", "\n", "\"weight\"", ":", "1.0", ",", "\n", "}", ",", "\n", "{", "\n", "\"name\"", ":", "\"cross-entropy\"", ",", "\n", "\"weight\"", ":", "1.0", ",", "\n", "}", ",", "\n", "]", ",", "\n", "}", "\n", "\n", "got", "=", "parse_label_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "assert", "got", "==", "loss_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseRegularizationLoss.test_parse_outdated_loss": [[269, 296], ["pytest.mark.parametrize", "deepreg.config.v011.parse_reg_loss"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_reg_loss"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"energy_type\"", ",", "\"loss_name\"", ",", "\"extra_args\"", ")", ",", "\n", "[", "\n", "(", "\"bending\"", ",", "\"bending\"", ",", "{", "}", ")", ",", "\n", "(", "\"gradient-l2\"", ",", "\"gradient\"", ",", "{", "\"l1\"", ":", "False", "}", ")", ",", "\n", "(", "\"gradient-l1\"", ",", "\"gradient\"", ",", "{", "\"l1\"", ":", "True", "}", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_parse_outdated_loss", "(", "\n", "self", ",", "energy_type", ":", "str", ",", "loss_name", ":", "str", ",", "extra_args", ":", "Dict", "\n", ")", ":", "\n", "\n", "        ", "loss_config", "=", "{", "\n", "\"regularization\"", ":", "{", "\n", "\"energy_type\"", ":", "energy_type", ",", "\n", "\"weight\"", ":", "2.0", ",", "\n", "}", "\n", "}", "\n", "expected", "=", "{", "\n", "\"regularization\"", ":", "{", "\n", "\"name\"", ":", "loss_name", ",", "\n", "\"weight\"", ":", "2.0", ",", "\n", "**", "extra_args", ",", "\n", "}", ",", "\n", "}", "\n", "got", "=", "parse_reg_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseRegularizationLoss.test_parse_multiple_reg_loss": [[297, 313], ["deepreg.config.v011.parse_reg_loss"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_reg_loss"], ["", "def", "test_parse_multiple_reg_loss", "(", "self", ")", ":", "\n", "        ", "loss_config", "=", "{", "\n", "\"regularization\"", ":", "[", "\n", "{", "\n", "\"name\"", ":", "\"bending\"", ",", "\n", "\"weight\"", ":", "2.0", ",", "\n", "}", ",", "\n", "{", "\n", "\"name\"", ":", "\"gradient\"", ",", "\n", "\"weight\"", ":", "2.0", ",", "\n", "\"l1\"", ":", "True", ",", "\n", "}", ",", "\n", "]", ",", "\n", "}", "\n", "got", "=", "parse_reg_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "assert", "got", "==", "loss_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.TestParseOptimizer.test_parse": [[331, 341], ["pytest.mark.parametrize", "deepreg.config.v011.parse_optimizer"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_optimizer"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"opt_config\"", ",", "\"expected\"", ")", ",", "\n", "[", "\n", "(", "config_v011", ",", "config_latest", ")", ",", "\n", "(", "config_latest", ",", "config_latest", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_parse", "(", "self", ",", "opt_config", ":", "Dict", ",", "expected", ":", "Dict", ")", ":", "\n", "        ", "got", "=", "parse_optimizer", "(", "opt_config", "=", "opt_config", ")", "\n", "assert", "got", "==", "expected", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_config_v011.test_grouped_mr_heart": [[18, 38], ["pytest.mark.parametrize", "deepreg.config.v011.parse_v011", "open", "yaml.load", "open", "yaml.load"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_v011"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"old_config_path\"", ",", "\"latest_config_path\"", ")", ",", "\n", "[", "\n", "(", "\n", "\"config/test/grouped_mr_heart_v011.yaml\"", ",", "\n", "\"demos/grouped_mr_heart/grouped_mr_heart.yaml\"", ",", "\n", ")", ",", "\n", "(", "\n", "\"demos/grouped_mr_heart/grouped_mr_heart.yaml\"", ",", "\n", "\"demos/grouped_mr_heart/grouped_mr_heart.yaml\"", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_grouped_mr_heart", "(", "old_config_path", ":", "str", ",", "latest_config_path", ":", "str", ")", ":", "\n", "    ", "with", "open", "(", "old_config_path", ")", "as", "file", ":", "\n", "        ", "old_config", "=", "yaml", ".", "load", "(", "file", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "", "with", "open", "(", "latest_config_path", ")", "as", "file", ":", "\n", "        ", "latest_config", "=", "yaml", ".", "load", "(", "file", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "", "updated_config", "=", "parse_v011", "(", "old_config", "=", "old_config", ")", "\n", "assert", "updated_config", "==", "latest_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_warp.TestShapeSanityCheck.test_pass": [[28, 40], ["pytest.mark.parametrize", "numpy.ones", "numpy.ones", "deepreg.warp.shape_sanity_check"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.warp.shape_sanity_check"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"image_shape\"", ",", "\"ddf_shape\"", ")", ",", "\n", "[", "\n", "(", "(", "2", ",", "3", ",", "4", ")", ",", "(", "2", ",", "3", ",", "4", ",", "3", ")", ")", ",", "\n", "(", "(", "2", ",", "3", ",", "4", ",", "1", ")", ",", "(", "2", ",", "3", ",", "4", ",", "3", ")", ")", ",", "\n", "(", "(", "2", ",", "3", ",", "4", ",", "3", ")", ",", "(", "2", ",", "3", ",", "4", ",", "3", ")", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_pass", "(", "self", ",", "image_shape", ":", "tuple", ",", "ddf_shape", ":", "tuple", ")", ":", "\n", "        ", "image", "=", "np", ".", "ones", "(", "image_shape", ")", "\n", "ddf", "=", "np", ".", "ones", "(", "ddf_shape", ")", "\n", "shape_sanity_check", "(", "image", "=", "image", ",", "ddf", "=", "ddf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_warp.TestShapeSanityCheck.test_error": [[41, 61], ["pytest.mark.parametrize", "numpy.ones", "numpy.ones", "pytest.raises", "deepreg.warp.shape_sanity_check", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.warp.shape_sanity_check"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"image_shape\"", ",", "\"ddf_shape\"", ",", "\"err_msg\"", ")", ",", "\n", "[", "\n", "(", "\n", "(", "\n", "2", ",", "\n", "3", ",", "\n", ")", ",", "\n", "(", "2", ",", "3", ",", "4", ",", "3", ")", ",", "\n", "\"image shape must be (m_dim1, m_dim2, m_dim3)\"", ",", "\n", ")", ",", "\n", "(", "(", "2", ",", "3", ",", "4", ")", ",", "(", "2", ",", "3", ",", "4", ",", "4", ")", ",", "\"ddf shape must be (f_dim1, f_dim2, f_dim3, 3)\"", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_error", "(", "self", ",", "image_shape", ":", "tuple", ",", "ddf_shape", ":", "tuple", ",", "err_msg", ")", ":", "\n", "        ", "image", "=", "np", ".", "ones", "(", "image_shape", ")", "\n", "ddf", "=", "np", ".", "ones", "(", "ddf_shape", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "shape_sanity_check", "(", "image", "=", "image", ",", "ddf", "=", "ddf", ")", "\n", "", "assert", "err_msg", "in", "str", "(", "err_info", ".", "value", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_warp.test_main": [[12, 25], ["pytest.mark.parametrize", "deepreg.warp.main", "os.path.isfile", "os.remove"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "\"out_path\"", ",", "\"expected_path\"", ")", ",", "\n", "[", "\n", "(", "\"logs/test_warp/out.nii.gz\"", ",", "\"logs/test_warp/out.nii.gz\"", ")", ",", "\n", "(", "\"logs/test_warp/out.h5\"", ",", "\"logs/test_warp/warped.nii.gz\"", ")", ",", "\n", "(", "\"logs/test_warp/\"", ",", "\"logs/test_warp/warped.nii.gz\"", ")", ",", "\n", "(", "\"\"", ",", "\"warped.nii.gz\"", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_main", "(", "out_path", ":", "str", ",", "expected_path", ":", "str", ")", ":", "\n", "    ", "main", "(", "args", "=", "[", "\"--image\"", ",", "image_path", ",", "\"--ddf\"", ",", "ddf_path", ",", "\"--out\"", ",", "out_path", "]", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "expected_path", ")", "\n", "os", ".", "remove", "(", "expected_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_util.TestMultiScaleMixin.test_err": [[19, 23], ["pytest.raises", "deepreg.loss.util.MultiScaleMixin", "str"], "methods", ["None"], ["    ", "def", "test_err", "(", "self", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "MultiScaleMixin", "(", "kernel", "=", "\"unknown\"", ")", "\n", "", "assert", "\"Kernel unknown is not supported.\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_util.TestMultiScaleMixin.test_get_config": [[24, 34], ["deepreg.loss.util.MultiScaleMixin", "deepreg.loss.util.MultiScaleMixin.get_config", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "loss", "=", "MultiScaleMixin", "(", ")", "\n", "got", "=", "loss", ".", "get_config", "(", ")", "\n", "expected", "=", "dict", "(", "\n", "scales", "=", "None", ",", "\n", "kernel", "=", "\"gaussian\"", ",", "\n", "reduction", "=", "tf", ".", "keras", ".", "losses", ".", "Reduction", ".", "AUTO", ",", "\n", "name", "=", "None", ",", "\n", ")", "\n", "assert", "got", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_util.TestMultiScaleMixin.test_call": [[35, 50], ["pytest.mark.parametrize", "pytest.mark.parametrize", "tensorflow.random.uniform", "tensorflow.random.uniform", "deepreg.loss.label.DiceLoss", "deepreg.loss.label.DiceLoss.call"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"kernel\"", ",", "[", "\"gaussian\"", ",", "\"cauchy\"", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"scales\"", ",", "[", "None", ",", "0", ",", "[", "0", "]", ",", "[", "0", ",", "1", "]", ",", "[", "1", ",", "2", "]", "]", ")", "\n", "def", "test_call", "(", "self", ",", "kernel", ":", "str", ",", "scales", ":", "Optional", "[", "Union", "[", "List", ",", "float", ",", "int", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Test MultiScaleMixin using DiceLoss.\n\n        :param kernel: kernel name.\n        :param scales: scaling parameters.\n        \"\"\"", "\n", "shape", "=", "(", "2", ",", "3", ",", "4", ",", "5", ")", "\n", "y_true", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ")", "\n", "y_pred", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ")", "\n", "\n", "loss", "=", "DiceLoss", "(", "kernel", "=", "kernel", ",", "scales", "=", "scales", ")", "\n", "loss", ".", "call", "(", "y_pred", "=", "y_pred", ",", "y_true", "=", "y_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_util.test_negative_loss_mixin": [[52, 62], ["tensorflow.random.uniform", "tensorflow.random.uniform", "deepreg.loss.label.DiceScore().call", "deepreg.loss.label.DiceLoss().call", "test.unit.util.is_equal_tf", "deepreg.loss.label.DiceScore", "deepreg.loss.label.DiceLoss"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "", "def", "test_negative_loss_mixin", "(", ")", ":", "\n", "    ", "\"\"\"Test DiceScore and DiceLoss have reversed sign.\"\"\"", "\n", "shape", "=", "(", "2", ",", "3", ",", "4", ",", "5", ")", "\n", "y_true", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ")", "\n", "y_pred", "=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ")", "\n", "\n", "dice_score", "=", "DiceScore", "(", ")", ".", "call", "(", "y_pred", "=", "y_pred", ",", "y_true", "=", "y_true", ")", "\n", "dice_loss", "=", "DiceLoss", "(", ")", ".", "call", "(", "y_pred", "=", "y_pred", ",", "y_true", "=", "y_true", ")", "\n", "\n", "assert", "is_equal_tf", "(", "dice_score", ",", "-", "dice_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_loss_util.test_separable_filter": [[64, 77], ["tensorflow.ones", "numpy.identity", "numpy.zeros", "tensorflow.convert_to_tensor", "tensorflow.ones", "deepreg.loss.util.separable_filter", "test.unit.util.is_equal_tf"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_tf"], ["", "def", "test_separable_filter", "(", ")", ":", "\n", "    ", "\"\"\"Testing separable filter case where diagonal ones are propagated.\"\"\"", "\n", "k", "=", "tf", ".", "ones", "(", "shape", "=", "(", "3", ",", "3", ",", "3", ",", "3", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "array_eye", "=", "np", ".", "identity", "(", "3", ")", "\n", "x", "=", "np", ".", "zeros", "(", "(", "3", ",", "3", ",", "3", ",", "3", ",", "1", ")", ")", "\n", "x", "[", ":", ",", ":", ",", "0", ",", "0", ",", "0", "]", "=", "array_eye", "\n", "x", "=", "tf", ".", "convert_to_tensor", "(", "x", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "expected", "=", "tf", ".", "ones", "(", "shape", "=", "(", "3", ",", "3", ",", "3", ",", "3", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "got", "=", "separable_filter", "(", "x", ",", "k", ")", "\n", "\n", "assert", "is_equal_tf", "(", "got", ",", "expected", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_init": [[39, 104], ["pytest.mark.parametrize", "test_h5_loader.get_loader", "get_loader.close", "test_h5_loader.get_loader_h5_file_names"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader_h5_file_names"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,expected\"", ",", "\n", "[", "\n", "(", "\n", "\"paired\"", ",", "\n", "[", "\n", "[", "\"./data/test/h5/paired/test/fixed_images.h5\"", "]", ",", "\n", "[", "(", "\"./data/test/h5/paired/test\"", ",", "\"case000025.nii.gz\"", ")", "]", ",", "\n", "None", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"unpaired\"", ",", "\n", "[", "\n", "[", "\"./data/test/h5/unpaired/test/images.h5\"", "]", ",", "\n", "[", "\n", "(", "\"./data/test/h5/unpaired/test\"", ",", "\"case000025.nii.gz\"", ")", ",", "\n", "(", "\"./data/test/h5/unpaired/test\"", ",", "\"case000026.nii.gz\"", ")", ",", "\n", "]", ",", "\n", "None", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"grouped\"", ",", "\n", "[", "\n", "[", "\"./data/test/h5/grouped/test/images.h5\"", "]", ",", "\n", "[", "\n", "(", "\"./data/test/h5/grouped/test\"", ",", "\"1\"", ",", "\"1\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/test\"", ",", "\"1\"", ",", "\"2\"", ")", ",", "\n", "]", ",", "\n", "[", "[", "0", ",", "1", "]", "]", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"multi_dirs_grouped\"", ",", "\n", "[", "\n", "[", "\n", "\"./data/test/h5/grouped/train/images.h5\"", ",", "\n", "\"./data/test/h5/grouped/test/images.h5\"", ",", "\n", "]", ",", "\n", "[", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"1\"", ",", "\"1\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"1\"", ",", "\"2\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"1\"", ",", "\"3\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"1\"", ",", "\"4\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"2\"", ",", "\"1\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"2\"", ",", "\"2\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"2\"", ",", "\"3\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/test\"", ",", "\"1\"", ",", "\"1\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/test\"", ",", "\"1\"", ",", "\"2\"", ")", ",", "\n", "]", ",", "\n", "[", "[", "7", ",", "8", "]", ",", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "[", "4", ",", "5", ",", "6", "]", "]", ",", "\n", "]", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_init", "(", "self", ",", "name", ",", "expected", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "got", "=", "[", "\n", "get_loader_h5_file_names", "(", "loader", ")", ",", "\n", "loader", ".", "data_path_splits", ",", "\n", "loader", ".", "group_struct", ",", "\n", "]", "\n", "assert", "got", "==", "expected", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_init_duplicated_dirs": [[105, 120], ["pytest.mark.parametrize", "test_h5_loader.get_loader", "pytest.raises", "deepreg.dataset.loader.h5_loader.H5FileLoader", "str"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name\"", ",", "\n", "[", "\n", "\"paired\"", ",", "\n", "\"unpaired\"", ",", "\n", "\"grouped\"", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_init_duplicated_dirs", "(", "self", ",", "name", ")", ":", "\n", "# duplicated dir_paths", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "dir_paths", "=", "loader", ".", "dir_paths", "*", "2", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "H5FileLoader", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "loader", ".", "name", ",", "grouped", "=", "loader", ".", "grouped", ")", "\n", "", "assert", "\"dir_paths have repeated elements\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "# no need to close files as they haven't been opened yet", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_set_data_structure_err1": [[122, 137], ["pytest.mark.parametrize", "pytest.raises", "deepreg.dataset.loader.h5_loader.H5FileLoader", "str"], "methods", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,err_msg\"", ",", "\n", "[", "\n", "(", "\"images.h5 does not exist\"", ",", "\"does not exist\"", ")", ",", "# test not existed files", "\n", "(", "\n", "\"fixed_images\"", ",", "\n", "\"h5_file keys must be of form group-X-Y\"", ",", "\n", ")", ",", "# test wrong keys for grouped data", "\n", "]", ",", "\n", ")", "\n", "def", "test_set_data_structure_err1", "(", "self", ",", "name", ",", "err_msg", ")", ":", "\n", "        ", "dir_paths", "=", "[", "\"./data/test/h5/paired/test\"", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", "as", "err_info", ":", "\n", "            ", "H5FileLoader", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "name", ",", "grouped", "=", "True", ")", "\n", "", "assert", "err_msg", "in", "str", "(", "err_info", ".", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_set_data_structure_err2": [[138, 148], ["os.path.join", "os.remove", "h5py.File", "pytest.raises", "deepreg.dataset.loader.h5_loader.H5FileLoader", "str"], "methods", ["None"], ["", "def", "test_set_data_structure_err2", "(", "self", ")", ":", "\n", "        ", "dir_paths", "=", "[", "\"./data/test/h5/paired/test\"", "]", "\n", "name", "=", "\"error\"", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "dir_paths", "[", "0", "]", ",", "f\"{name}.h5\"", ")", "\n", "with", "h5py", ".", "File", "(", "file_path", ",", "\"w\"", ")", ":", "\n", "            ", "pass", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "err_info", ":", "\n", "            ", "H5FileLoader", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "name", ",", "grouped", "=", "False", ")", "\n", "", "assert", "\"No data collected\"", "in", "str", "(", "err_info", ".", "value", ")", "\n", "os", ".", "remove", "(", "file_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_get_data": [[149, 172], ["pytest.mark.parametrize", "test_h5_loader.get_loader", "get_loader.get_data", "test.unit.util.is_equal_np", "get_loader.close", "numpy.shape", "numpy.amax", "numpy.amin", "numpy.mean", "numpy.std"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,index,expected\"", ",", "\n", "[", "\n", "(", "\"paired\"", ",", "0", ",", "[", "(", "44", ",", "59", ",", "41", ")", ",", "[", "255.0", ",", "0.0", ",", "68.359276", ",", "65.84009", "]", "]", ")", ",", "\n", "(", "\"unpaired\"", ",", "0", ",", "[", "(", "64", ",", "64", ",", "60", ")", ",", "[", "255.0", ",", "0.0", ",", "60.073948", ",", "47.27648", "]", "]", ")", ",", "\n", "(", "\"grouped\"", ",", "(", "0", ",", "1", ")", ",", "[", "(", "64", ",", "64", ",", "60", ")", ",", "[", "255.0", ",", "0.0", ",", "60.073948", ",", "47.27648", "]", "]", ")", ",", "\n", "(", "\n", "\"multi_dirs_grouped\"", ",", "\n", "(", "0", ",", "1", ")", ",", "\n", "[", "(", "64", ",", "64", ",", "60", ")", ",", "[", "255.0", ",", "0.0", ",", "60.073948", ",", "47.27648", "]", "]", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_get_data", "(", "self", ",", "name", ",", "index", ",", "expected", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "array", "=", "loader", ".", "get_data", "(", "index", ")", "\n", "got", "=", "[", "\n", "np", ".", "shape", "(", "array", ")", ",", "\n", "[", "np", ".", "amax", "(", "array", ")", ",", "np", ".", "amin", "(", "array", ")", ",", "np", ".", "mean", "(", "array", ")", ",", "np", ".", "std", "(", "array", ")", "]", ",", "\n", "]", "\n", "assert", "got", "[", "0", "]", "==", "expected", "[", "0", "]", "\n", "assert", "is_equal_np", "(", "got", "[", "1", "]", ",", "expected", "[", "1", "]", ")", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_get_data_ids": [[173, 212], ["pytest.mark.parametrize", "test_h5_loader.get_loader", "get_loader.get_data_ids", "get_loader.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,expected\"", ",", "\n", "[", "\n", "(", "\"paired\"", ",", "[", "(", "\"./data/test/h5/paired/test\"", ",", "\"case000025.nii.gz\"", ")", "]", ")", ",", "\n", "(", "\n", "\"unpaired\"", ",", "\n", "[", "\n", "(", "\"./data/test/h5/unpaired/test\"", ",", "\"case000025.nii.gz\"", ")", ",", "\n", "(", "\"./data/test/h5/unpaired/test\"", ",", "\"case000026.nii.gz\"", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"grouped\"", ",", "\n", "[", "\n", "(", "\"./data/test/h5/grouped/test\"", ",", "\"1\"", ",", "\"1\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/test\"", ",", "\"1\"", ",", "\"2\"", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", "(", "\n", "\"multi_dirs_grouped\"", ",", "\n", "[", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"1\"", ",", "\"1\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"1\"", ",", "\"2\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"1\"", ",", "\"3\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"1\"", ",", "\"4\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"2\"", ",", "\"1\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"2\"", ",", "\"2\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/train\"", ",", "\"2\"", ",", "\"3\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/test\"", ",", "\"1\"", ",", "\"1\"", ")", ",", "\n", "(", "\"./data/test/h5/grouped/test\"", ",", "\"1\"", ",", "\"2\"", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_get_data_ids", "(", "self", ",", "name", ",", "expected", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "got", "=", "loader", ".", "get_data_ids", "(", ")", "\n", "assert", "got", "==", "expected", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_get_data_ids_check_err_with_paired": [[213, 228], ["pytest.mark.parametrize", "test_h5_loader.get_loader", "get_loader.close", "pytest.raises", "get_loader.get_data"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"index,err_type\"", ",", "\n", "[", "\n", "(", "-", "1", ",", "AssertionError", ")", ",", "\n", "(", "64", ",", "IndexError", ")", ",", "\n", "(", "(", "0", ",", "1", ")", ",", "AssertionError", ")", ",", "\n", "(", "\"wrong\"", ",", "ValueError", ")", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_get_data_ids_check_err_with_paired", "(", "self", ",", "index", ",", "err_type", ")", ":", "\n", "# wrong index for paired", "\n", "        ", "loader", "=", "get_loader", "(", "\"paired\"", ")", "\n", "with", "pytest", ".", "raises", "(", "err_type", ")", ":", "\n", "            ", "loader", ".", "get_data", "(", "index", "=", "index", ")", "\n", "", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_get_data_ids_check_err_with_grouped": [[229, 236], ["test_h5_loader.get_loader", "get_loader.close", "pytest.raises", "get_loader.get_data"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data"], ["", "def", "test_get_data_ids_check_err_with_grouped", "(", "self", ")", ":", "\n", "# wrong index for paired", "\n", "        ", "loader", "=", "get_loader", "(", "\"grouped\"", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "# non-tuple data_index", "\n", "            ", "loader", ".", "get_data", "(", "index", "=", "1", ")", "\n", "", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_get_num_images": [[237, 246], ["pytest.mark.parametrize", "test_h5_loader.get_loader", "get_loader.get_num_images", "get_loader.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name,expected\"", ",", "\n", "[", "(", "\"paired\"", ",", "1", ")", ",", "(", "\"unpaired\"", ",", "2", ")", ",", "(", "\"grouped\"", ",", "2", ")", ",", "(", "\"multi_dirs_grouped\"", ",", "9", ")", "]", ",", "\n", ")", "\n", "def", "test_get_num_images", "(", "self", ",", "name", ",", "expected", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "got", "=", "loader", ".", "get_num_images", "(", ")", "\n", "assert", "got", "==", "expected", "\n", "loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.TestH5FileLoader.test_close": [[247, 260], ["pytest.mark.parametrize", "test_h5_loader.get_loader", "get_loader.close", "get_loader.h5_files.values", "f.__bool__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"name\"", ",", "\n", "[", "\n", "\"paired\"", ",", "\n", "\"unpaired\"", ",", "\n", "\"grouped\"", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_close", "(", "self", ",", "name", ")", ":", "\n", "        ", "loader", "=", "get_loader", "(", "name", ")", "\n", "loader", ".", "close", "(", ")", "\n", "for", "f", "in", "loader", ".", "h5_files", ".", "values", "(", ")", ":", "\n", "            ", "assert", "not", "f", ".", "__bool__", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader_h5_file_names": [[15, 17], ["loader.h5_files.values"], "function", ["None"], ["def", "get_loader_h5_file_names", "(", "loader", ":", "H5FileLoader", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "return", "[", "f", ".", "filename", "for", "f", "in", "loader", ".", "h5_files", ".", "values", "(", ")", "]", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_h5_loader.get_loader": [[19, 36], ["deepreg.dataset.loader.h5_loader.H5FileLoader"], "function", ["None"], ["", "def", "get_loader", "(", "loader_name", ")", ":", "\n", "    ", "if", "loader_name", "in", "[", "\n", "\"paired\"", ",", "\n", "\"unpaired\"", ",", "\n", "\"grouped\"", ",", "\n", "]", ":", "\n", "        ", "dir_paths", "=", "[", "f\"./data/test/h5/{loader_name}/test\"", "]", "\n", "name", "=", "\"fixed_images\"", "if", "loader_name", "==", "\"paired\"", "else", "\"images\"", "\n", "grouped", "=", "loader_name", "==", "\"grouped\"", "\n", "", "elif", "loader_name", "==", "\"multi_dirs_grouped\"", ":", "\n", "        ", "dir_paths", "=", "[", "\"./data/test/h5/grouped/train\"", ",", "\"./data/test/h5/grouped/test\"", "]", "\n", "name", "=", "\"images\"", "\n", "grouped", "=", "True", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "", "loader", "=", "H5FileLoader", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "name", ",", "grouped", "=", "grouped", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_loader_util.TestNormalizeArray.test_no_min_no_max": [[16, 27], ["pytest.mark.parametrize", "deepreg.normalize_array", "test.unit.util.is_equal_np", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["    ", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"arr,expected\"", ",", "\n", "[", "\n", "[", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", ",", "np", ".", "array", "(", "[", "0", ",", "0.5", ",", "1", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "-", "2", ",", "0", ",", "1", ",", "2", "]", ")", ",", "np", ".", "array", "(", "[", "0", ",", "0.5", ",", "0.75", ",", "1", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", ",", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "0", "]", ")", "]", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_no_min_no_max", "(", "self", ",", "arr", ",", "expected", ")", ":", "\n", "        ", "got", "=", "util", ".", "normalize_array", "(", "arr", "=", "arr", ")", "\n", "assert", "is_equal_np", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_loader_util.TestNormalizeArray.test_no_min": [[28, 38], ["pytest.mark.parametrize", "deepreg.normalize_array", "test.unit.util.is_equal_np", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"arr,v_max,expected\"", ",", "\n", "[", "\n", "[", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", ",", "1", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "1", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "-", "2", ",", "0", ",", "1", ",", "2", "]", ")", ",", "3", ",", "np", ".", "array", "(", "[", "0", ",", "0.4", ",", "0.6", ",", "0.8", "]", ")", "]", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_no_min", "(", "self", ",", "arr", ",", "v_max", ",", "expected", ")", ":", "\n", "        ", "got", "=", "util", ".", "normalize_array", "(", "arr", "=", "arr", ",", "v_max", "=", "v_max", ")", "\n", "assert", "is_equal_np", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_loader_util.TestNormalizeArray.test_no_max": [[39, 49], ["pytest.mark.parametrize", "deepreg.normalize_array", "test.unit.util.is_equal_np", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.util.is_equal_np"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"arr,v_min,expected\"", ",", "\n", "[", "\n", "[", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", ",", "1", ",", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "-", "2", ",", "0", ",", "1", ",", "2", "]", ")", ",", "-", "3", ",", "np", ".", "array", "(", "[", "0.2", ",", "0.6", ",", "0.8", ",", "1", "]", ")", "]", ",", "\n", "]", ",", "\n", ")", "\n", "def", "test_no_max", "(", "self", ",", "arr", ",", "v_min", ",", "expected", ")", ":", "\n", "        ", "got", "=", "util", ".", "normalize_array", "(", "arr", "=", "arr", ",", "v_min", "=", "v_min", ")", "\n", "assert", "is_equal_np", "(", "got", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_dataset_loader_util.test_remove_prefix_suffix": [[51, 66], ["deepreg.remove_prefix_suffix", "deepreg.remove_prefix_suffix"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.remove_prefix_suffix", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.remove_prefix_suffix"], ["", "", "def", "test_remove_prefix_suffix", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test remove_prefix_suffix by verifying outputs\n    \"\"\"", "\n", "x", "=", "\"sample000.nii\"", "\n", "\n", "# single prefix, suffix", "\n", "got", "=", "util", ".", "remove_prefix_suffix", "(", "x", "=", "x", ",", "prefix", "=", "\"sample\"", ",", "suffix", "=", "\".nii\"", ")", "\n", "expected", "=", "\"000\"", "\n", "assert", "got", "==", "expected", "\n", "\n", "# multiple prefixes, suffixes", "\n", "got", "=", "util", ".", "remove_prefix_suffix", "(", "x", "=", "x", ",", "prefix", "=", "[", "\"sample\"", "]", ",", "suffix", "=", "[", "\".nii.gz\"", ",", "\".nii\"", "]", ")", "\n", "expected", "=", "\"000\"", "\n", "assert", "got", "==", "expected", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_local_net.TestLocalNet.test_call": [[45, 88], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "deepreg.model.backbone.local_net.LocalNet", "tensorflow.ones", "deepreg.model.backbone.local_net.LocalNet.call"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "\"image_size,extract_levels,depth\"", ",", "\n", "[", "(", "(", "11", ",", "12", ",", "13", ")", ",", "(", "0", ",", "1", ",", "2", ",", "4", ")", ",", "4", ")", ",", "(", "(", "8", ",", "8", ",", "8", ")", ",", "(", "0", ",", "1", ",", "2", ")", ",", "3", ")", "]", ",", "\n", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"use_additive_upsampling\"", ",", "[", "True", ",", "False", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"pooling\"", ",", "[", "True", ",", "False", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"concat_skip\"", ",", "[", "True", ",", "False", "]", ")", "\n", "def", "test_call", "(", "\n", "self", ",", "\n", "image_size", ":", "tuple", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "depth", ":", "int", ",", "\n", "use_additive_upsampling", ":", "bool", ",", "\n", "pooling", ":", "bool", ",", "\n", "concat_skip", ":", "bool", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n\n        :param image_size: (dim1, dim2, dim3), dims of input image.\n        :param extract_levels: from which depths the output will be built.\n        :param depth: input is at level 0, bottom is at level depth\n        :param use_additive_upsampling: whether use additive up-sampling layer\n            for decoding.\n        :param pooling: for down-sampling, use non-parameterized\n                        pooling if true, otherwise use conv3d\n        :param concat_skip: if concatenate skip or add it\n        \"\"\"", "\n", "out_ch", "=", "3", "\n", "network", "=", "LocalNet", "(", "\n", "image_size", "=", "image_size", ",", "\n", "num_channel_initial", "=", "2", ",", "\n", "extract_levels", "=", "extract_levels", ",", "\n", "depth", "=", "depth", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", "out_channels", "=", "out_ch", ",", "\n", "use_additive_upsampling", "=", "use_additive_upsampling", ",", "\n", "pooling", "=", "pooling", ",", "\n", "concat_skip", "=", "concat_skip", ",", "\n", ")", "\n", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "(", "5", ",", "*", "image_size", ",", "out_ch", ")", ")", "\n", "output", "=", "network", ".", "call", "(", "inputs", ")", "\n", "assert", "inputs", ".", "shape", "==", "output", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_local_net.TestLocalNet.test_get_config": [[89, 112], ["dict", "deepreg.model.backbone.local_net.LocalNet", "deepreg.model.backbone.local_net.LocalNet.get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "test_get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "dict", "(", "\n", "image_size", "=", "(", "4", ",", "5", ",", "6", ")", ",", "\n", "out_channels", "=", "3", ",", "\n", "num_channel_initial", "=", "2", ",", "\n", "depth", "=", "2", ",", "\n", "extract_levels", "=", "(", "0", ",", "1", ")", ",", "\n", "out_kernel_initializer", "=", "\"he_normal\"", ",", "\n", "out_activation", "=", "\"softmax\"", ",", "\n", "pooling", "=", "False", ",", "\n", "concat_skip", "=", "False", ",", "\n", "use_additive_upsampling", "=", "True", ",", "\n", "encode_kernel_sizes", "=", "[", "7", ",", "3", ",", "3", "]", ",", "\n", "decode_kernel_sizes", "=", "3", ",", "\n", "encode_num_channels", "=", "(", "2", ",", "4", ",", "8", ")", ",", "\n", "decode_num_channels", "=", "(", "2", ",", "4", ",", "8", ")", ",", "\n", "strides", "=", "2", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "name", "=", "\"Test\"", ",", "\n", ")", "\n", "network", "=", "LocalNet", "(", "**", "config", ")", "\n", "got", "=", "network", ".", "get_config", "(", ")", "\n", "assert", "got", "==", "config", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unit.test_backbone_local_net.test_additive_up_sampling": [[14, 38], ["tuple", "dict", "deepreg.model.backbone.local_net.AdditiveUpsampling", "tensorflow.ones", "deepreg.model.backbone.local_net.AdditiveUpsampling.call", "deepreg.model.backbone.local_net.AdditiveUpsampling.get_config"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["def", "test_additive_up_sampling", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test AdditiveUpsampling.\n    \"\"\"", "\n", "batch", "=", "3", "\n", "filters", "=", "4", "\n", "input_shape", "=", "(", "4", ",", "5", ",", "6", ")", "\n", "outputs_shape", "=", "tuple", "(", "x", "*", "2", "for", "x", "in", "input_shape", ")", "\n", "config", "=", "dict", "(", "\n", "filters", "=", "filters", ",", "\n", "output_padding", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "strides", "=", "2", ",", "\n", "output_shape", "=", "outputs_shape", ",", "\n", "name", "=", "\"TestAdditiveUpsampling\"", ",", "\n", ")", "\n", "layer", "=", "AdditiveUpsampling", "(", "**", "config", ")", "\n", "inputs", "=", "tf", ".", "ones", "(", "shape", "=", "(", "batch", ",", "*", "input_shape", ",", "filters", "*", "2", ")", ")", "\n", "output", "=", "layer", ".", "call", "(", "inputs", ")", "\n", "assert", "output", ".", "shape", "==", "(", "batch", ",", "*", "outputs_shape", ",", "filters", ")", "\n", "\n", "got", "=", "layer", ".", "get_config", "(", ")", "\n", "assert", "got", "==", "{", "\"trainable\"", ":", "True", ",", "\"dtype\"", ":", "\"float32\"", ",", "**", "config", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.examples.custom_backbone.CustomBackbone.__init__": [[15, 56], ["deepreg.model.backbone.Backbone.__init__", "tensorflow.keras.layers.Conv3D", "tensorflow.keras.layers.Conv3D"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "image_size", ":", "tuple", ",", "\n", "out_channels", ":", "int", ",", "\n", "num_channel_initial", ":", "int", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", "name", ":", "str", "=", "\"CustomBackbone\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param image_size: (dim1, dim2, dim3), dims of input image.\n        :param out_channels: number of channels for the output\n        :param num_channel_initial: number of initial channels\n        :param depth: input is at level 0, bottom is at level depth\n        :param out_kernel_initializer: kernel initializer for the last layer\n        :param out_activation: activation at the last layer\n        :param name: name of the backbone\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "image_size", "=", "image_size", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "num_channel_initial", "=", "num_channel_initial", ",", "\n", "out_kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "out_activation", "=", "out_activation", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "self", ".", "conv1", "=", "tf", ".", "keras", ".", "layers", ".", "Conv3D", "(", "\n", "filters", "=", "num_channel_initial", ",", "kernel_size", "=", "3", ",", "padding", "=", "\"same\"", "\n", ")", "\n", "self", ".", "conv2", "=", "tf", ".", "keras", ".", "layers", ".", "Conv3D", "(", "\n", "filters", "=", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "activation", "=", "out_activation", ",", "\n", "padding", "=", "\"same\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.examples.custom_backbone.CustomBackbone.call": [[58, 70], ["custom_backbone.CustomBackbone.conv1", "custom_backbone.CustomBackbone.conv2"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ":", "tf", ".", "Tensor", ",", "training", "=", "None", ",", "mask", "=", "None", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Builds graph based on built layers.\n\n        :param inputs: shape = (batch, f_dim1, f_dim2, f_dim3, in_channels)\n        :param training:\n        :param mask:\n        :return: shape = (batch, f_dim1, f_dim2, f_dim3, out_channels)\n        \"\"\"", "\n", "out", "=", "self", ".", "conv1", "(", "inputs", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.examples.custom_parameterized_image_label_loss.LPNorm.__init__": [[16, 34], ["super().__init__", "tensorflow.keras.layers.Flatten", "ValueError"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "int", ",", "\n", "name", ":", "str", "=", "\"LPNorm\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param p: order of the norm, 1 or 2.\n        :param name: name of the loss.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "if", "p", "not", "in", "[", "1", ",", "2", "]", ":", "\n", "            ", "raise", "ValueError", "(", "f\"For LPNorm, p must be 0 or 1, got {p}.\"", ")", "\n", "", "self", ".", "p", "=", "p", "\n", "self", ".", "flatten", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.examples.custom_parameterized_image_label_loss.LPNorm.call": [[35, 47], ["custom_parameterized_image_label_loss.LPNorm.flatten", "tensorflow.norm"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return loss for a batch.\n\n        :param y_true: shape = (batch, ...)\n        :param y_pred: shape = (batch, ...)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "diff", "=", "y_true", "-", "y_pred", "\n", "diff", "=", "self", ".", "flatten", "(", "diff", ")", "\n", "loss", "=", "tf", ".", "norm", "(", "diff", ",", "axis", "=", "-", "1", ",", "ord", "=", "self", ".", "p", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.examples.custom_image_label_loss.RootMeanSquaredDifference.__init__": [[16, 29], ["super().__init__", "tensorflow.keras.layers.Flatten"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", "=", "\"RootMeanSquaredDifference\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param name: name of the loss\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "self", ".", "flatten", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.examples.custom_image_label_loss.RootMeanSquaredDifference.call": [[30, 43], ["tensorflow.math.squared_difference", "custom_image_label_loss.RootMeanSquaredDifference.flatten", "tensorflow.reduce_mean", "tensorflow.math.sqrt"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return loss for a batch.\n\n        :param y_true: shape = (batch, ...)\n        :param y_pred: shape = (batch, ...)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "loss", "=", "tf", ".", "math", ".", "squared_difference", "(", "y_true", ",", "y_pred", ")", "\n", "loss", "=", "self", ".", "flatten", "(", "loss", ")", "\n", "loss", "=", "tf", ".", "reduce_mean", "(", "loss", ",", "axis", "=", "1", ")", "\n", "loss", "=", "tf", ".", "math", ".", "sqrt", "(", "loss", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.classical_ct_headneck_affine.demo_register.train_step": [[78, 99], ["tape.gradient", "optimizer.apply_gradients", "tensorflow.GradientTape", "deepreg.resample", "zip", "deepreg.registry.REGISTRY.build_loss", "deepreg.warp_grid"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.warp_grid"], ["@", "tf", ".", "function", "\n", "def", "train_step", "(", "grid", ",", "weights", ",", "optimizer", ",", "mov", ",", "fix", ")", "->", "object", ":", "\n", "    ", "\"\"\"\n    Train step function for backprop using gradient tape\n\n    :param grid: reference grid return from layer_util.get_reference_grid\n    :param weights: trainable affine parameters [1, 4, 3]\n    :param optimizer: tf.optimizers\n    :param mov: moving image [1, m_dim1, m_dim2, m_dim3]\n    :param fix: fixed image [1, f_dim1, f_dim2, f_dim3]\n    :return loss: image dissimilarity to minimise\n    \"\"\"", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "        ", "pred", "=", "layer_util", ".", "resample", "(", "vol", "=", "mov", ",", "loc", "=", "layer_util", ".", "warp_grid", "(", "grid", ",", "weights", ")", ")", "\n", "loss", "=", "REGISTRY", ".", "build_loss", "(", "config", "=", "image_loss_config", ")", "(", "\n", "y_true", "=", "fix", ",", "\n", "y_pred", "=", "pred", ",", "\n", ")", "\n", "", "gradients", "=", "tape", ".", "gradient", "(", "loss", ",", "[", "weights", "]", ")", "\n", "optimizer", ".", "apply_gradients", "(", "zip", "(", "gradients", ",", "[", "weights", "]", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.unpaired_ct_lung.demo_data.move_files_into_correct_path": [[73, 86], ["os.chdir", "os.path.join", "os.path.join", "shutil.move", "os.path.join", "shutil.move"], "function", ["None"], ["zip_file", "=", "os", ".", "path", ".", "join", "(", "MODEL_PATH", ",", "ZIP_PATH", "+", "\".zip\"", ")", "\n", "get_file", "(", "os", ".", "path", ".", "abspath", "(", "zip_file", ")", ",", "ORIGIN", ")", "\n", "with", "zipfile", ".", "ZipFile", "(", "zip_file", ",", "\"r\"", ")", "as", "zf", ":", "\n", "    ", "zf", ".", "extractall", "(", "path", "=", "MODEL_PATH", ")", "\n", "", "os", ".", "remove", "(", "zip_file", ")", "\n", "\n", "print", "(", "\n", "\"Pre-trained model is downloaded and unzipped in %s.\"", "%", "os", ".", "path", ".", "abspath", "(", "MODEL_PATH", ")", "\n", ")", "\n", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.classical_mr_prostate_nonrigid.demo_register.train_step": [[61, 90], ["tape.gradient", "optimizer.apply_gradients", "tensorflow.GradientTape", "warper", "zip", "deepreg.registry.REGISTRY.build_loss", "deepreg.registry.REGISTRY.build_loss"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_loss"], ["fixed_image_size", "=", "fixed_image", ".", "shape", "\n", "transform_random", "=", "gen_rand_affine_transform", "(", "batch_size", "=", "1", ",", "scale", "=", "0.2", ")", "\n", "grid_ref", "=", "layer_util", ".", "get_reference_grid", "(", "grid_size", "=", "fixed_image_size", "[", "1", ":", "4", "]", ")", "\n", "grid_random", "=", "layer_util", ".", "warp_grid", "(", "grid_ref", ",", "transform_random", ")", "\n", "moving_image", "=", "layer_util", ".", "resample", "(", "vol", "=", "fixed_image", ",", "loc", "=", "grid_random", ")", "\n", "# warp the labels to get ground-truth using the same random affine, for validation", "\n", "fixed_labels", "=", "tf", ".", "cast", "(", "tf", ".", "expand_dims", "(", "fid", "[", "\"label\"", "]", ",", "axis", "=", "0", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "moving_labels", "=", "tf", ".", "stack", "(", "\n", "[", "\n", "layer_util", ".", "resample", "(", "vol", "=", "fixed_labels", "[", "...", ",", "idx", "]", ",", "loc", "=", "grid_random", ")", "\n", "for", "idx", "in", "range", "(", "fixed_labels", ".", "shape", "[", "4", "]", ")", "\n", "]", ",", "\n", "axis", "=", "4", ",", "\n", ")", "\n", "\n", "\n", "# optimisation", "\n", "@", "tf", ".", "function", "\n", "def", "train_step", "(", "grid", ",", "weights", ",", "optimizer", ",", "mov", ",", "fix", ")", "->", "object", ":", "\n", "    ", "\"\"\"\n    Train step function for backprop using gradient tape\n\n    :param grid: reference grid return from layer_util.get_reference_grid\n    :param weights: trainable affine parameters [1, 4, 3]\n    :param optimizer: tf.optimizers\n    :param mov: moving image [1, m_dim1, m_dim2, m_dim3]\n    :param fix: fixed image [1, f_dim1, f_dim2, f_dim3]\n    :return loss: image dissimilarity to minimise\n    \"\"\"", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.paired_ct_lung.demo_data.move_files_into_correct_path": [[69, 82], ["os.chdir", "os.path.join", "os.path.join", "shutil.move", "os.path.join", "shutil.move"], "function", ["None"], ["\n", "ZIP_PATH", "=", "\"checkpoint\"", "\n", "ORIGIN", "=", "\"https://github.com/DeepRegNet/deepreg-model-zoo/raw/master/demo/paired_mrus_prostate/20210110.zip\"", "\n", "\n", "zip_file", "=", "os", ".", "path", ".", "join", "(", "MODEL_PATH", ",", "ZIP_PATH", "+", "\".zip\"", ")", "\n", "get_file", "(", "os", ".", "path", ".", "abspath", "(", "zip_file", ")", ",", "ORIGIN", ")", "\n", "with", "zipfile", ".", "ZipFile", "(", "zip_file", ",", "\"r\"", ")", "as", "zf", ":", "\n", "    ", "zf", ".", "extractall", "(", "path", "=", "MODEL_PATH", ")", "\n", "", "os", ".", "remove", "(", "zip_file", ")", "\n", "\n", "print", "(", "\n", "\"Pre-trained model is downloaded and unzipped in %s.\"", "%", "os", ".", "path", ".", "abspath", "(", "MODEL_PATH", ")", "\n", ")", "\n", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.build_pair_output_path": [[33, 56], ["os.path.join", "os.makedirs", "os.path.join", "os.makedirs", "str"], "function", ["None"], ["def", "build_pair_output_path", "(", "indices", ":", "list", ",", "save_dir", ":", "str", ")", "->", "Tuple", "[", "str", ",", "str", "]", ":", "\n", "    ", "\"\"\"\n    Create directory for saving the paired data\n\n    :param indices: indices of the pair, the last one is for label\n    :param save_dir: directory of output\n    :return: - save_dir, str, directory for saving the moving/fixed image\n             - label_dir, str, directory for saving the rest outputs\n    \"\"\"", "\n", "\n", "# cast indices to string and init directory name", "\n", "pair_index", "=", "\"pair_\"", "+", "\"_\"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "indices", "[", ":", "-", "1", "]", "]", ")", "\n", "pair_dir", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "pair_index", ")", "\n", "os", ".", "makedirs", "(", "pair_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "if", "indices", "[", "-", "1", "]", ">=", "0", ":", "\n", "        ", "label_index", "=", "f\"label_{indices[-1]}\"", "\n", "label_dir", "=", "os", ".", "path", ".", "join", "(", "pair_dir", ",", "label_index", ")", "\n", "os", ".", "makedirs", "(", "label_dir", ",", "exist_ok", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "label_dir", "=", "pair_dir", "\n", "\n", "", "return", "pair_dir", ",", "label_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.predict_on_dataset": [[58, 148], ["os.path.exists", "enumerate", "deepreg.util.save_metric_dict", "shutil.rmtree", "model.predict", "model.postprocess", "indices.numpy.numpy", "range", "indices[].astype().tolist", "predict.build_pair_output_path", "processed.items", "sample_index_strs.append", "deepreg.util.calculate_metrics", "metric_lists.append", "processed.items", "deepreg.util.save_array", "ValueError", "isinstance", "v[].numpy", "indices[].astype", "numpy.savetxt", "str", "list", "os.path.join", "inputs.keys"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_metric_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.predict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.postprocess", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.build_pair_output_path", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.calculate_metrics", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_array"], ["", "def", "predict_on_dataset", "(", "\n", "dataset", ":", "tf", ".", "data", ".", "Dataset", ",", "\n", "fixed_grid_ref", ":", "tf", ".", "Tensor", ",", "\n", "model", ":", "tf", ".", "keras", ".", "Model", ",", "\n", "save_dir", ":", "str", ",", "\n", "save_nifti", ":", "bool", ",", "\n", "save_png", ":", "bool", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Function to predict results from a dataset from some model\n\n    :param dataset: where data is stored\n    :param fixed_grid_ref: shape=(1, f_dim1, f_dim2, f_dim3, 3)\n    :param model: model to be used for prediction\n    :param save_dir: path to store dir\n    :param save_nifti: if true, outputs will be saved in nifti format\n    :param save_png: if true, outputs will be saved in png format\n    \"\"\"", "\n", "# remove the save_dir in case it exists", "\n", "if", "os", ".", "path", ".", "exists", "(", "save_dir", ")", ":", "\n", "        ", "shutil", ".", "rmtree", "(", "save_dir", ")", "# pragma: no cover", "\n", "\n", "", "sample_index_strs", "=", "[", "]", "\n", "metric_lists", "=", "[", "]", "\n", "for", "_", ",", "inputs", "in", "enumerate", "(", "dataset", ")", ":", "\n", "        ", "batch_size", "=", "inputs", "[", "list", "(", "inputs", ".", "keys", "(", ")", ")", "[", "0", "]", "]", ".", "shape", "[", "0", "]", "\n", "outputs", "=", "model", ".", "predict", "(", "x", "=", "inputs", ",", "batch_size", "=", "batch_size", ")", "\n", "indices", ",", "processed", "=", "model", ".", "postprocess", "(", "inputs", "=", "inputs", ",", "outputs", "=", "outputs", ")", "\n", "\n", "# convert to np arrays", "\n", "indices", "=", "indices", ".", "numpy", "(", ")", "\n", "processed", "=", "{", "\n", "k", ":", "(", "v", "[", "0", "]", ".", "numpy", "(", ")", "if", "isinstance", "(", "v", "[", "0", "]", ",", "tf", ".", "Tensor", ")", "else", "v", "[", "0", "]", ",", "v", "[", "1", "]", ",", "v", "[", "2", "]", ")", "\n", "for", "k", ",", "v", "in", "processed", ".", "items", "(", ")", "\n", "}", "\n", "\n", "# save images of inputs and outputs", "\n", "for", "sample_index", "in", "range", "(", "batch_size", ")", ":", "\n", "# save label independent tensors under pair_dir, otherwise under label_dir", "\n", "\n", "# init output path", "\n", "            ", "indices_i", "=", "indices", "[", "sample_index", ",", ":", "]", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "\n", "pair_dir", ",", "label_dir", "=", "build_pair_output_path", "(", "\n", "indices", "=", "indices_i", ",", "save_dir", "=", "save_dir", "\n", ")", "\n", "\n", "for", "name", ",", "(", "arr", ",", "normalize", ",", "on_label", ")", "in", "processed", ".", "items", "(", ")", ":", "\n", "                ", "if", "name", "==", "\"theta\"", ":", "\n", "                    ", "np", ".", "savetxt", "(", "\n", "fname", "=", "os", ".", "path", ".", "join", "(", "pair_dir", ",", "\"affine.txt\"", ")", ",", "\n", "X", "=", "arr", "[", "sample_index", ",", ":", ",", ":", "]", ",", "\n", "delimiter", "=", "\",\"", ",", "\n", ")", "\n", "continue", "\n", "\n", "", "arr_save_dir", "=", "label_dir", "if", "on_label", "else", "pair_dir", "\n", "save_array", "(", "\n", "save_dir", "=", "arr_save_dir", ",", "\n", "arr", "=", "arr", "[", "sample_index", ",", ":", ",", ":", ",", ":", "]", ",", "\n", "name", "=", "name", ",", "\n", "normalize", "=", "normalize", ",", "# label's value is already in [0, 1]", "\n", "save_nifti", "=", "save_nifti", ",", "\n", "save_png", "=", "save_png", ",", "\n", "overwrite", "=", "arr_save_dir", "==", "label_dir", ",", "\n", ")", "\n", "\n", "# calculate metric", "\n", "", "sample_index_str", "=", "\"_\"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "indices_i", "]", ")", "\n", "if", "sample_index_str", "in", "sample_index_strs", ":", "# pragma: no cover", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Sample is repeated, maybe the dataset has been repeated.\"", "\n", ")", "\n", "", "sample_index_strs", ".", "append", "(", "sample_index_str", ")", "\n", "\n", "metric", "=", "calculate_metrics", "(", "\n", "fixed_image", "=", "processed", "[", "\"fixed_image\"", "]", "[", "0", "]", ",", "\n", "fixed_label", "=", "processed", "[", "\"fixed_label\"", "]", "[", "0", "]", "if", "model", ".", "labeled", "else", "None", ",", "\n", "pred_fixed_image", "=", "processed", "[", "\"pred_fixed_image\"", "]", "[", "0", "]", ",", "\n", "pred_fixed_label", "=", "processed", "[", "\"pred_fixed_label\"", "]", "[", "0", "]", "\n", "if", "model", ".", "labeled", "\n", "else", "None", ",", "\n", "fixed_grid_ref", "=", "fixed_grid_ref", ",", "\n", "sample_index", "=", "sample_index", ",", "\n", ")", "\n", "metric", "[", "\"pair_index\"", "]", "=", "indices_i", "[", ":", "-", "1", "]", "\n", "metric", "[", "\"label_index\"", "]", "=", "indices_i", "[", "-", "1", "]", "\n", "metric_lists", ".", "append", "(", "metric", ")", "\n", "\n", "# save metric", "\n", "", "", "save_metric_dict", "(", "save_dir", "=", "save_dir", ",", "metrics", "=", "metric_lists", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.build_config": [[150, 184], ["deepreg.util.build_log_dir", "os.path.expanduser", "deepreg.load_configs", "logger.warning", "deepreg.load_configs", "os.path.expanduser.split"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_log_dir", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.load_configs", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.load_configs"], ["", "def", "build_config", "(", "\n", "config_path", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ",", "log_dir", ":", "str", ",", "exp_name", ":", "str", ",", "ckpt_path", ":", "str", "\n", ")", "->", "Tuple", "[", "Dict", ",", "str", ",", "str", "]", ":", "\n", "    ", "\"\"\"\n    Function to create new directory to log directory to store results.\n\n    :param config_path: path of configuration files.\n    :param log_dir: path of the log directory.\n    :param exp_name: experiment name.\n    :param ckpt_path: path where model is stored.\n    :return: - config, configuration dictionary.\n             - exp_name, path of the directory for saving outputs.\n    \"\"\"", "\n", "\n", "# init log directory", "\n", "log_dir", "=", "build_log_dir", "(", "log_dir", "=", "log_dir", ",", "exp_name", "=", "exp_name", ")", "\n", "\n", "# replace the ~ with user home path", "\n", "ckpt_path", "=", "os", ".", "path", ".", "expanduser", "(", "ckpt_path", ")", "\n", "\n", "# load config", "\n", "if", "config_path", "==", "\"\"", ":", "\n", "# use default config, which should be provided in the log folder", "\n", "        ", "config", "=", "config_parser", ".", "load_configs", "(", "\n", "\"/\"", ".", "join", "(", "ckpt_path", ".", "split", "(", "\"/\"", ")", "[", ":", "-", "2", "]", ")", "+", "\"/config.yaml\"", "\n", ")", "\n", "", "else", ":", "\n", "# use customized config", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"Using customized configuration. \"", "\n", "\"The code might break if the config doesn't match the saved model.\"", "\n", ")", "\n", "config", "=", "config_parser", ".", "load_configs", "(", "config_path", ")", "\n", "", "return", "config", ",", "log_dir", ",", "ckpt_path", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.predict": [[186, 313], ["predict.build_config", "deepreg.util.build_dataset", "max", "ckpt_path.endswith", "tensorflow.expand_dims", "predict.predict_on_dataset", "data_loader.close", "logger.info", "str", "str", "str", "len", "tensorflow.distribute.MirroredStrategy", "tensorflow.distribute.get_strategy", "tf.distribute.get_strategy.scope", "deepreg.registry.REGISTRY.build_model", "deepreg.build_optimizer", "model.compile", "model.plot_model", "model.load_weights().expect_partial", "deepreg.callback.build_checkpoint_callback", "deepreg.get_reference_grid", "tensorflow.config.list_physical_devices", "ValueError", "os.path.join", "dict", "model.load_weights"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.build_config", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_dataset", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.predict_on_dataset", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.build_model", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.optimizer.build_optimizer", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.plot_model", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.build_checkpoint_callback", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_reference_grid"], ["", "def", "predict", "(", "\n", "gpu", ":", "str", ",", "\n", "ckpt_path", ":", "str", ",", "\n", "split", ":", "str", ",", "\n", "batch_size", ":", "int", ",", "\n", "exp_name", ":", "str", ",", "\n", "config_path", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ",", "\n", "num_workers", ":", "int", "=", "1", ",", "\n", "gpu_allow_growth", ":", "bool", "=", "True", ",", "\n", "save_nifti", ":", "bool", "=", "True", ",", "\n", "save_png", ":", "bool", "=", "True", ",", "\n", "log_dir", ":", "str", "=", "\"logs\"", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Function to predict some metrics from the saved model and logging results.\n\n    :param gpu: which env gpu to use.\n    :param ckpt_path: where model is stored, should be like log_folder/save/ckpt-x.\n    :param split: train / valid / test, to define the split to be evaluated.\n    :param batch_size: int, batch size to perform predictions.\n    :param exp_name: name of the experiment.\n    :param config_path: to overwrite the default config.\n    :param num_workers: number of cpu cores to be used, <=0 means not limited.\n    :param gpu_allow_growth: whether to allocate whole GPU memory for training.\n    :param save_nifti: if true, outputs will be saved in nifti format.\n    :param save_png: if true, outputs will be saved in png format.\n    :param log_dir: path of the log directory.\n    \"\"\"", "\n", "\n", "# env vars", "\n", "if", "gpu", "is", "not", "None", ":", "\n", "        ", "os", ".", "environ", "[", "\"CUDA_VISIBLE_DEVICES\"", "]", "=", "gpu", "\n", "os", ".", "environ", "[", "\"TF_FORCE_GPU_ALLOW_GROWTH\"", "]", "=", "(", "\n", "\"false\"", "if", "gpu_allow_growth", "else", "\"true\"", "\n", ")", "\n", "", "if", "num_workers", "<=", "0", ":", "# pragma: no cover", "\n", "        ", "logger", ".", "info", "(", "\n", "\"Limiting CPU usage by setting environment variables \"", "\n", "\"OMP_NUM_THREADS, TF_NUM_INTRAOP_THREADS, TF_NUM_INTEROP_THREADS to %d. \"", "\n", "\"This may slow down the prediction. \"", "\n", "\"Please use --num_workers flag to modify the behavior. \"", "\n", "\"Setting to 0 or negative values will remove the limitation.\"", ",", "\n", "num_workers", ",", "\n", ")", "\n", "# limit CPU usage", "\n", "# https://github.com/tensorflow/tensorflow/issues/29968#issuecomment-789604232", "\n", "os", ".", "environ", "[", "\"OMP_NUM_THREADS\"", "]", "=", "str", "(", "num_workers", ")", "\n", "os", ".", "environ", "[", "\"TF_NUM_INTRAOP_THREADS\"", "]", "=", "str", "(", "num_workers", ")", "\n", "os", ".", "environ", "[", "\"TF_NUM_INTEROP_THREADS\"", "]", "=", "str", "(", "num_workers", ")", "\n", "\n", "# load config", "\n", "", "config", ",", "log_dir", ",", "ckpt_path", "=", "build_config", "(", "\n", "config_path", "=", "config_path", ",", "log_dir", "=", "log_dir", ",", "exp_name", "=", "exp_name", ",", "ckpt_path", "=", "ckpt_path", "\n", ")", "\n", "config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", "[", "\"batch_size\"", "]", "=", "batch_size", "\n", "\n", "# data", "\n", "data_loader", ",", "dataset", ",", "_", "=", "build_dataset", "(", "\n", "dataset_config", "=", "config", "[", "\"dataset\"", "]", ",", "\n", "preprocess_config", "=", "config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", ",", "\n", "split", "=", "split", ",", "\n", "training", "=", "False", ",", "\n", "repeat", "=", "False", ",", "\n", ")", "\n", "assert", "data_loader", "is", "not", "None", "\n", "\n", "# use strategy to support multiple GPUs", "\n", "# the network is mirrored in each GPU so that we can use larger batch size", "\n", "# https://www.tensorflow.org/guide/distributed_training", "\n", "# only model, optimizer and metrics need to be defined inside the strategy", "\n", "num_devices", "=", "max", "(", "len", "(", "tf", ".", "config", ".", "list_physical_devices", "(", "\"GPU\"", ")", ")", ",", "1", ")", "\n", "if", "num_devices", ">", "1", ":", "# pragma: no cover", "\n", "        ", "strategy", "=", "tf", ".", "distribute", ".", "MirroredStrategy", "(", ")", "\n", "if", "batch_size", "%", "num_devices", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"batch size {batch_size} can not be divided evenly \"", "\n", "f\"by the number of devices.\"", "\n", ")", "\n", "", "", "else", ":", "\n", "        ", "strategy", "=", "tf", ".", "distribute", ".", "get_strategy", "(", ")", "\n", "", "with", "strategy", ".", "scope", "(", ")", ":", "\n", "        ", "model", ":", "tf", ".", "keras", ".", "Model", "=", "REGISTRY", ".", "build_model", "(", "\n", "config", "=", "dict", "(", "\n", "name", "=", "config", "[", "\"train\"", "]", "[", "\"method\"", "]", ",", "\n", "moving_image_size", "=", "data_loader", ".", "moving_image_shape", ",", "\n", "fixed_image_size", "=", "data_loader", ".", "fixed_image_shape", ",", "\n", "index_size", "=", "data_loader", ".", "num_indices", ",", "\n", "labeled", "=", "config", "[", "\"dataset\"", "]", "[", "split", "]", "[", "\"labeled\"", "]", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "config", "=", "config", "[", "\"train\"", "]", ",", "\n", ")", "\n", ")", "\n", "optimizer", "=", "opt", ".", "build_optimizer", "(", "optimizer_config", "=", "config", "[", "\"train\"", "]", "[", "\"optimizer\"", "]", ")", "\n", "model", ".", "compile", "(", "optimizer", "=", "optimizer", ")", "\n", "model", ".", "plot_model", "(", "output_dir", "=", "log_dir", ")", "\n", "\n", "# load weights", "\n", "", "if", "ckpt_path", ".", "endswith", "(", "\".ckpt\"", ")", ":", "\n", "# for ckpt from tf.keras.callbacks.ModelCheckpoint", "\n", "# skip warnings because of optimizers", "\n", "# https://stackoverflow.com/questions/58289342/tf2-0-translation-model-error-when-restoring-the-saved-model-unresolved-object", "\n", "        ", "model", ".", "load_weights", "(", "ckpt_path", ")", ".", "expect_partial", "(", ")", "# pragma: no cover", "\n", "", "else", ":", "\n", "# for ckpts from ckpt manager callback", "\n", "        ", "_", ",", "_", "=", "build_checkpoint_callback", "(", "\n", "model", "=", "model", ",", "\n", "dataset", "=", "dataset", ",", "\n", "log_dir", "=", "log_dir", ",", "\n", "save_period", "=", "config", "[", "\"train\"", "]", "[", "\"save_period\"", "]", ",", "\n", "ckpt_path", "=", "ckpt_path", ",", "\n", ")", "\n", "\n", "# predict", "\n", "", "fixed_grid_ref", "=", "tf", ".", "expand_dims", "(", "\n", "layer_util", ".", "get_reference_grid", "(", "grid_size", "=", "data_loader", ".", "fixed_image_shape", ")", ",", "axis", "=", "0", "\n", ")", "# shape = (1, f_dim1, f_dim2, f_dim3, 3)", "\n", "predict_on_dataset", "(", "\n", "dataset", "=", "dataset", ",", "\n", "fixed_grid_ref", "=", "fixed_grid_ref", ",", "\n", "model", "=", "model", ",", "\n", "save_dir", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "\"test\"", ")", ",", "\n", "save_nifti", "=", "save_nifti", ",", "\n", "save_png", "=", "save_png", ",", "\n", ")", "\n", "\n", "# close the opened files in data loaders", "\n", "data_loader", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.main": [[315, 409], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "predict.predict"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.predict.predict"], ["", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Entry point for predict script.\n\n    :param args:\n    \"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--gpu\"", ",", "\n", "\"-g\"", ",", "\n", "help", "=", "\"GPU index for training.\"", "\n", "\"-g for using GPU remotely\"", "\n", "'-g \"\" for using CPU'", "\n", "'-g \"0\" for using GPU 0'", "\n", "'-g \"0,1\" for using GPU 0 and 1.'", ",", "\n", "type", "=", "str", ",", "\n", "required", "=", "False", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--gpu_allow_growth\"", ",", "\n", "\"-gr\"", ",", "\n", "help", "=", "\"Prevent TensorFlow from reserving all available GPU memory\"", ",", "\n", "default", "=", "False", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--num_workers\"", ",", "\n", "help", "=", "\"Number of CPUs to be used, <= 0 means unlimited.\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "1", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--ckpt_path\"", ",", "\n", "\"-k\"", ",", "\n", "help", "=", "\"Path of checkpointed model to load\"", ",", "\n", "default", "=", "\"\"", ",", "\n", "type", "=", "str", ",", "\n", "required", "=", "True", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--split\"", ",", "\n", "help", "=", "\"Define the split of data to be used for prediction: \"", "\n", "\"train or valid or test\"", ",", "\n", "type", "=", "str", ",", "\n", "required", "=", "True", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--batch_size\"", ",", "\"-b\"", ",", "help", "=", "\"Batch size for predictions\"", ",", "default", "=", "1", ",", "type", "=", "int", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--log_dir\"", ",", "help", "=", "\"Path of log directory.\"", ",", "default", "=", "\"logs\"", ",", "type", "=", "str", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--exp_name\"", ",", "\"-n\"", ",", "help", "=", "\"Name of the experiment.\"", ",", "default", "=", "\"\"", ",", "type", "=", "str", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--save_nifti\"", ",", "dest", "=", "\"nifti\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--no_nifti\"", ",", "dest", "=", "\"nifti\"", ",", "action", "=", "\"store_false\"", ")", "\n", "parser", ".", "set_defaults", "(", "nifti", "=", "True", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--save_png\"", ",", "dest", "=", "\"png\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--no_png\"", ",", "dest", "=", "\"png\"", ",", "action", "=", "\"store_false\"", ")", "\n", "parser", ".", "set_defaults", "(", "png", "=", "False", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config_path\"", ",", "\n", "\"-c\"", ",", "\n", "help", "=", "\"Path of config, must end with .yaml. Can pass multiple paths.\"", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "\"*\"", ",", "\n", "default", "=", "\"\"", ",", "\n", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "\n", "predict", "(", "\n", "gpu", "=", "args", ".", "gpu", ",", "\n", "ckpt_path", "=", "args", ".", "ckpt_path", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "gpu_allow_growth", "=", "args", ".", "gpu_allow_growth", ",", "\n", "split", "=", "args", ".", "split", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "log_dir", "=", "args", ".", "log_dir", ",", "\n", "exp_name", "=", "args", ".", "exp_name", ",", "\n", "config_path", "=", "args", ".", "config_path", ",", "\n", "save_nifti", "=", "args", ".", "nifti", ",", "\n", "save_png", "=", "args", ".", "png", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.__init__": [[41, 44], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Init registry with empty dict.\"\"\"", "\n", "self", ".", "_dict", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry._register": [[45, 67], ["ValueError", "registry.Registry.contains", "ValueError"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.contains"], ["", "def", "_register", "(", "self", ",", "category", ":", "str", ",", "key", ":", "str", ",", "value", ":", "Callable", ",", "force", ":", "bool", ")", ":", "\n", "        ", "\"\"\"\n        Registers the value with the registry.\n\n        :param category: name of the class category\n        :param key: unique identity\n        :param value: class to be registered\n        :param force: if True, overwrite the existing value\n            in case the key has been registered.\n        \"\"\"", "\n", "# sanity check", "\n", "if", "category", "not", "in", "KNOWN_CATEGORIES", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Unknown category {category} not among {KNOWN_CATEGORIES}\"", "\n", ")", "\n", "", "if", "not", "force", "and", "self", ".", "contains", "(", "category", "=", "category", ",", "key", "=", "key", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Key {key} in category {category} has been registered\"", "\n", "f\" with {self._dict[(category, key)]}\"", "\n", ")", "\n", "# register value", "\n", "", "self", ".", "_dict", "[", "(", "category", ",", "key", ")", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.contains": [[68, 77], ["None"], "methods", ["None"], ["", "def", "contains", "(", "self", ",", "category", ":", "str", ",", "key", ":", "str", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Verify if the key has been registered for the category.\n\n        :param category: category name.\n        :param key: value name.\n        :return: `True` if registered.\n        \"\"\"", "\n", "return", "(", "category", ",", "key", ")", "in", "self", ".", "_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.get": [[78, 89], ["registry.Registry.contains", "ValueError"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.contains"], ["", "def", "get", "(", "self", ",", "category", ":", "str", ",", "key", ":", "str", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Return the registered class.\n\n        :param category: category name.\n        :param key: value name.\n        :return: registered value.\n        \"\"\"", "\n", "if", "self", ".", "contains", "(", "category", "=", "category", ",", "key", "=", "key", ")", ":", "\n", "            ", "return", "self", ".", "_dict", "[", "(", "category", ",", "key", ")", "]", "\n", "", "raise", "ValueError", "(", "f\"Key {key} in category {category} has not been registered.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register": [[90, 117], ["registry.Registry._register", "registry.Registry._register"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry._register", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry._register"], ["", "def", "register", "(", "\n", "self", ",", "category", ":", "str", ",", "name", ":", "str", ",", "cls", ":", "Callable", "=", "None", ",", "force", ":", "bool", "=", "False", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Register a py class.\n        A record will be added to `self._dict`, whose key is the class\n        name or the specified name, and value is the class itself.\n        It can be used as a decorator or a normal function.\n\n        :param category: The type of the category.\n        :param name: The class name to be registered.\n            If not specified, the class name will be used.\n        :param force: Whether to override an existing class with the same name.\n        :param cls: Class to be registered.\n        :return: The given class or a decorator.\n        \"\"\"", "\n", "# use it as a normal method: x.register_module(module=SomeClass)", "\n", "if", "cls", "is", "not", "None", ":", "\n", "            ", "self", ".", "_register", "(", "category", "=", "category", ",", "key", "=", "name", ",", "value", "=", "cls", ",", "force", "=", "force", ")", "\n", "return", "cls", "\n", "\n", "# use it as a decorator: @x.register(name, category)", "\n", "", "def", "decorator", "(", "c", ":", "Callable", ")", "->", "Callable", ":", "\n", "            ", "self", ".", "_register", "(", "category", "=", "category", ",", "key", "=", "name", ",", "value", "=", "c", ",", "force", "=", "force", ")", "\n", "return", "c", "\n", "\n", "", "return", "decorator", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_from_config": [[118, 147], ["copy.deepcopy", "copy.deepcopy.pop", "registry.Registry.get", "isinstance", "ValueError", "ValueError", "default_args.items", "registry.Registry.", "copy.deepcopy.setdefault", "ValueError", "type"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "def", "build_from_config", "(", "\n", "self", ",", "category", ":", "str", ",", "config", ":", "Dict", ",", "default_args", ":", "Optional", "[", "dict", "]", "=", "None", "\n", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Build a class instance from config dict.\n\n        :param category: category name.\n        :param config: a dict which must contain the key \"name\".\n        :param default_args: optionally some default arguments.\n        :return: the instantiated class.\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "config", ",", "dict", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"config must be a dict, but got {type(config)}\"", ")", "\n", "", "if", "\"name\"", "not", "in", "config", ":", "\n", "            ", "raise", "ValueError", "(", "f\"`config` must contain the key `name`, but got {config}\"", ")", "\n", "", "args", "=", "deepcopy", "(", "config", ")", "\n", "\n", "# insert key, value pairs if key is not in args", "\n", "if", "default_args", "is", "not", "None", ":", "\n", "            ", "for", "name", ",", "value", "in", "default_args", ".", "items", "(", ")", ":", "\n", "                ", "args", ".", "setdefault", "(", "name", ",", "value", ")", "\n", "\n", "", "", "name", "=", "args", ".", "pop", "(", "\"name\"", ")", "\n", "cls", "=", "self", ".", "get", "(", "category", "=", "category", ",", "key", "=", "name", ")", "\n", "try", ":", "\n", "            ", "return", "cls", "(", "**", "args", ")", "\n", "", "except", "TypeError", "as", "err", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Configuration is not compatible \"", "\n", "f\"for Class {cls} of category {category}.\\n\"", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.copy": [[155, 160], ["registry.Registry", "copy.deepcopy"], "methods", ["None"], ["", "", "def", "copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Deep copy the registry.\"\"\"", "\n", "copied", "=", "Registry", "(", ")", "\n", "copied", ".", "_dict", "=", "deepcopy", "(", "self", ".", "_dict", ")", "\n", "return", "copied", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register_model": [[161, 173], ["registry.Registry.register"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register"], ["", "def", "register_model", "(", "\n", "self", ",", "name", ":", "str", ",", "cls", ":", "Callable", "=", "None", ",", "force", ":", "bool", "=", "False", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Register a model class.\n\n        :param name: model name\n        :param cls: model class\n        :param force: whether overwrite if already registered\n        :return: the registered class\n        \"\"\"", "\n", "return", "self", ".", "register", "(", "category", "=", "MODEL_CLASS", ",", "name", "=", "name", ",", "cls", "=", "cls", ",", "force", "=", "force", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_model": [[174, 184], ["registry.Registry.build_from_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_from_config"], ["", "def", "build_model", "(", "self", ",", "config", ":", "Dict", ",", "default_args", ":", "Optional", "[", "dict", "]", "=", "None", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Instantiate a registered model class.\n\n        :param config: config having key `name`.\n        :param default_args: optionally some default arguments.\n        :return: a model instance\n        \"\"\"", "\n", "return", "self", ".", "build_from_config", "(", "\n", "category", "=", "MODEL_CLASS", ",", "config", "=", "config", ",", "default_args", "=", "default_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register_backbone": [[186, 198], ["registry.Registry.register"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register"], ["", "def", "register_backbone", "(", "\n", "self", ",", "name", ":", "str", ",", "cls", ":", "Callable", "=", "None", ",", "force", ":", "bool", "=", "False", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Register a backbone class.\n\n        :param name: backbone name\n        :param cls: backbone class\n        :param force: whether overwrite if already registered\n        :return: the registered class\n        \"\"\"", "\n", "return", "self", ".", "register", "(", "category", "=", "BACKBONE_CLASS", ",", "name", "=", "name", ",", "cls", "=", "cls", ",", "force", "=", "force", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_backbone": [[199, 209], ["registry.Registry.build_from_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_from_config"], ["", "def", "build_backbone", "(", "self", ",", "config", ":", "Dict", ",", "default_args", ":", "Optional", "[", "dict", "]", "=", "None", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Instantiate a registered backbone class.\n\n        :param config: config having key `name`.\n        :param default_args: optionally some default arguments.\n        :return: a backbone instance\n        \"\"\"", "\n", "return", "self", ".", "build_from_config", "(", "\n", "category", "=", "BACKBONE_CLASS", ",", "config", "=", "config", ",", "default_args", "=", "default_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register_loss": [[211, 223], ["registry.Registry.register"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register"], ["", "def", "register_loss", "(", "\n", "self", ",", "name", ":", "str", ",", "cls", ":", "Callable", "=", "None", ",", "force", ":", "bool", "=", "False", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Register a loss class.\n\n        :param name: loss name\n        :param cls: loss class\n        :param force: whether overwrite if already registered\n        :return: the registered class\n        \"\"\"", "\n", "return", "self", ".", "register", "(", "category", "=", "LOSS_CLASS", ",", "name", "=", "name", ",", "cls", "=", "cls", ",", "force", "=", "force", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_loss": [[224, 234], ["registry.Registry.build_from_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_from_config"], ["", "def", "build_loss", "(", "self", ",", "config", ":", "Dict", ",", "default_args", ":", "Optional", "[", "dict", "]", "=", "None", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Instantiate a registered loss class.\n\n        :param config: config having key `name`.\n        :param default_args: optionally some default arguments.\n        :return: a loss instance\n        \"\"\"", "\n", "return", "self", ".", "build_from_config", "(", "\n", "category", "=", "LOSS_CLASS", ",", "config", "=", "config", ",", "default_args", "=", "default_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register_data_loader": [[236, 249], ["registry.Registry.register"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register"], ["", "def", "register_data_loader", "(", "\n", "self", ",", "name", ":", "str", ",", "cls", ":", "Callable", "=", "None", ",", "force", ":", "bool", "=", "False", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Register a data loader class.\n\n        :param name: loss name\n        :param cls: loss class\n        :param force: whether overwrite if already registered\n        :return: the registered class\n        \"\"\"", "\n", "return", "self", ".", "register", "(", "\n", "category", "=", "DATA_LOADER_CLASS", ",", "name", "=", "name", ",", "cls", "=", "cls", ",", "force", "=", "force", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_data_loader": [[251, 263], ["registry.Registry.build_from_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_from_config"], ["", "def", "build_data_loader", "(", "\n", "self", ",", "config", ":", "Dict", ",", "default_args", ":", "Optional", "[", "dict", "]", "=", "None", "\n", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Instantiate a registered data loader class.\n\n        :param config: config having key `name`.\n        :param default_args: optionally some default arguments.\n        :return: a loss instance\n        \"\"\"", "\n", "return", "self", ".", "build_from_config", "(", "\n", "category", "=", "DATA_LOADER_CLASS", ",", "config", "=", "config", ",", "default_args", "=", "default_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register_data_augmentation": [[265, 278], ["registry.Registry.register"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register"], ["", "def", "register_data_augmentation", "(", "\n", "self", ",", "name", ":", "str", ",", "cls", ":", "Callable", "=", "None", ",", "force", ":", "bool", "=", "False", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Register a data augmentation class.\n\n        :param name: data augmentation name\n        :param cls: data augmentation class\n        :param force: whether overwrite if already registered\n        :return: the registered class\n        \"\"\"", "\n", "return", "self", ".", "register", "(", "\n", "category", "=", "DATA_AUGMENTATION_CLASS", ",", "name", "=", "name", ",", "cls", "=", "cls", ",", "force", "=", "force", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register_file_loader": [[280, 293], ["registry.Registry.register"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.register"], ["", "def", "register_file_loader", "(", "\n", "self", ",", "name", ":", "str", ",", "cls", ":", "Callable", "=", "None", ",", "force", ":", "bool", "=", "False", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Register a file loader class.\n\n        :param name: loss name\n        :param cls: loss class\n        :param force: whether overwrite if already registered\n        :return: the registered class\n        \"\"\"", "\n", "return", "self", ".", "register", "(", "\n", "category", "=", "FILE_LOADER_CLASS", ",", "name", "=", "name", ",", "cls", "=", "cls", ",", "force", "=", "force", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_data_augmentation": [[295, 307], ["registry.Registry.build_from_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_from_config"], ["", "def", "build_data_augmentation", "(", "\n", "self", ",", "config", ":", "Dict", ",", "default_args", ":", "Optional", "[", "dict", "]", "=", "None", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        Instantiate a registered data augmentation class.\n\n        :param config: config having key `name`.\n        :param default_args: optionally some default arguments.\n        :return: a data augmentation instance\n        \"\"\"", "\n", "return", "self", ".", "build_from_config", "(", "\n", "category", "=", "DATA_AUGMENTATION_CLASS", ",", "config", "=", "config", ",", "default_args", "=", "default_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.build_config": [[23, 62], ["deepreg.util.build_log_dir", "deepreg.load_configs", "os.path.expanduser", "deepreg.save", "min"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_log_dir", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.load_configs", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save"], ["def", "build_config", "(", "\n", "config_path", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ",", "\n", "log_dir", ":", "str", ",", "\n", "exp_name", ":", "str", ",", "\n", "ckpt_path", ":", "str", ",", "\n", "max_epochs", ":", "int", "=", "-", "1", ",", "\n", ")", "->", "Tuple", "[", "Dict", ",", "str", ",", "str", "]", ":", "\n", "    ", "\"\"\"\n    Function to initialise log directories,\n    assert that checkpointed model is the right\n    type and to parse the configuration for training.\n\n    :param config_path: list of str, path to config file\n    :param log_dir: path of the log directory\n    :param exp_name: name of the experiment\n    :param ckpt_path: path where model is stored.\n    :param max_epochs: if max_epochs > 0, use it to overwrite the configuration\n    :return: - config: a dictionary saving configuration\n             - exp_name: the path of directory to save logs\n    \"\"\"", "\n", "\n", "# init log directory", "\n", "log_dir", "=", "build_log_dir", "(", "log_dir", "=", "log_dir", ",", "exp_name", "=", "exp_name", ")", "\n", "\n", "# load config", "\n", "config", "=", "config_parser", ".", "load_configs", "(", "config_path", ")", "\n", "\n", "# replace the ~ with user home path", "\n", "ckpt_path", "=", "os", ".", "path", ".", "expanduser", "(", "ckpt_path", ")", "\n", "\n", "# overwrite epochs and save_period if necessary", "\n", "if", "max_epochs", ">", "0", ":", "\n", "        ", "config", "[", "\"train\"", "]", "[", "\"epochs\"", "]", "=", "max_epochs", "\n", "config", "[", "\"train\"", "]", "[", "\"save_period\"", "]", "=", "min", "(", "max_epochs", ",", "config", "[", "\"train\"", "]", "[", "\"save_period\"", "]", ")", "\n", "\n", "# backup config", "\n", "", "config_parser", ".", "save", "(", "config", "=", "config", ",", "out_dir", "=", "log_dir", ")", "\n", "\n", "return", "config", ",", "log_dir", ",", "ckpt_path", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.train": [[64, 197], ["train.build_config", "deepreg.util.build_dataset", "deepreg.util.build_dataset", "max", "tensorflow.keras.callbacks.TensorBoard", "deepreg.callback.build_checkpoint_callback", "model.fit", "data_loader_train.close", "logger.info", "str", "str", "str", "len", "tensorflow.distribute.MirroredStrategy", "tensorflow.distribute.get_strategy", "tf.distribute.get_strategy.scope", "deepreg.registry.REGISTRY.build_model", "deepreg.build_optimizer", "model.compile", "model.plot_model", "data_loader_val.close", "tensorflow.config.list_physical_devices", "ValueError", "config[].get", "dict"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.build_config", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_dataset", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_dataset", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.build_checkpoint_callback", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.build_model", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.optimizer.build_optimizer", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.plot_model", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "def", "train", "(", "\n", "gpu", ":", "str", ",", "\n", "config_path", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ",", "\n", "ckpt_path", ":", "str", ",", "\n", "num_workers", ":", "int", "=", "1", ",", "\n", "gpu_allow_growth", ":", "bool", "=", "True", ",", "\n", "exp_name", ":", "str", "=", "\"\"", ",", "\n", "log_dir", ":", "str", "=", "\"logs\"", ",", "\n", "max_epochs", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Function to train a model.\n\n    :param gpu: which local gpu to use to train.\n    :param config_path: path to configuration set up.\n    :param ckpt_path: where to store training checkpoints.\n    :param num_workers: number of cpu cores to be used, <=0 means not limited.\n    :param gpu_allow_growth: whether to allocate whole GPU memory for training.\n    :param log_dir: path of the log directory.\n    :param exp_name: experiment name.\n    :param max_epochs: if max_epochs > 0, will use it to overwrite the configuration.\n    \"\"\"", "\n", "# set env variables", "\n", "if", "gpu", "is", "not", "None", ":", "\n", "        ", "os", ".", "environ", "[", "\"CUDA_VISIBLE_DEVICES\"", "]", "=", "gpu", "\n", "os", ".", "environ", "[", "\"TF_FORCE_GPU_ALLOW_GROWTH\"", "]", "=", "(", "\n", "\"true\"", "if", "gpu_allow_growth", "else", "\"false\"", "\n", ")", "\n", "", "if", "num_workers", "<=", "0", ":", "# pragma: no cover", "\n", "        ", "logger", ".", "info", "(", "\n", "\"Limiting CPU usage by setting environment variables \"", "\n", "\"OMP_NUM_THREADS, TF_NUM_INTRAOP_THREADS, TF_NUM_INTEROP_THREADS to %d. \"", "\n", "\"This may slow down the training. \"", "\n", "\"Please use --num_workers flag to modify the behavior. \"", "\n", "\"Setting to 0 or negative values will remove the limitation.\"", ",", "\n", "num_workers", ",", "\n", ")", "\n", "# limit CPU usage", "\n", "# https://github.com/tensorflow/tensorflow/issues/29968#issuecomment-789604232", "\n", "os", ".", "environ", "[", "\"OMP_NUM_THREADS\"", "]", "=", "str", "(", "num_workers", ")", "\n", "os", ".", "environ", "[", "\"TF_NUM_INTRAOP_THREADS\"", "]", "=", "str", "(", "num_workers", ")", "\n", "os", ".", "environ", "[", "\"TF_NUM_INTEROP_THREADS\"", "]", "=", "str", "(", "num_workers", ")", "\n", "\n", "# load config", "\n", "", "config", ",", "log_dir", ",", "ckpt_path", "=", "build_config", "(", "\n", "config_path", "=", "config_path", ",", "\n", "log_dir", "=", "log_dir", ",", "\n", "exp_name", "=", "exp_name", ",", "\n", "ckpt_path", "=", "ckpt_path", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", ")", "\n", "\n", "# build dataset", "\n", "data_loader_train", ",", "dataset_train", ",", "steps_per_epoch_train", "=", "build_dataset", "(", "\n", "dataset_config", "=", "config", "[", "\"dataset\"", "]", ",", "\n", "preprocess_config", "=", "config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", ",", "\n", "split", "=", "\"train\"", ",", "\n", "training", "=", "True", ",", "\n", "repeat", "=", "True", ",", "\n", ")", "\n", "assert", "data_loader_train", "is", "not", "None", "# train data should not be None", "\n", "data_loader_val", ",", "dataset_val", ",", "steps_per_epoch_val", "=", "build_dataset", "(", "\n", "dataset_config", "=", "config", "[", "\"dataset\"", "]", ",", "\n", "preprocess_config", "=", "config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", ",", "\n", "split", "=", "\"valid\"", ",", "\n", "training", "=", "False", ",", "\n", "repeat", "=", "True", ",", "\n", ")", "\n", "\n", "# use strategy to support multiple GPUs", "\n", "# the network is mirrored in each GPU so that we can use larger batch size", "\n", "# https://www.tensorflow.org/guide/distributed_training", "\n", "# only model, optimizer and metrics need to be defined inside the strategy", "\n", "num_devices", "=", "max", "(", "len", "(", "tf", ".", "config", ".", "list_physical_devices", "(", "\"GPU\"", ")", ")", ",", "1", ")", "\n", "batch_size", "=", "config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", "[", "\"batch_size\"", "]", "\n", "if", "num_devices", ">", "1", ":", "# pragma: no cover", "\n", "        ", "strategy", "=", "tf", ".", "distribute", ".", "MirroredStrategy", "(", ")", "\n", "if", "batch_size", "%", "num_devices", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"batch size {batch_size} can not be divided evenly \"", "\n", "f\"by the number of devices.\"", "\n", ")", "\n", "", "", "else", ":", "\n", "        ", "strategy", "=", "tf", ".", "distribute", ".", "get_strategy", "(", ")", "\n", "", "with", "strategy", ".", "scope", "(", ")", ":", "\n", "        ", "model", ":", "tf", ".", "keras", ".", "Model", "=", "REGISTRY", ".", "build_model", "(", "\n", "config", "=", "dict", "(", "\n", "name", "=", "config", "[", "\"train\"", "]", "[", "\"method\"", "]", ",", "\n", "moving_image_size", "=", "data_loader_train", ".", "moving_image_shape", ",", "\n", "fixed_image_size", "=", "data_loader_train", ".", "fixed_image_shape", ",", "\n", "index_size", "=", "data_loader_train", ".", "num_indices", ",", "\n", "labeled", "=", "config", "[", "\"dataset\"", "]", "[", "\"train\"", "]", "[", "\"labeled\"", "]", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "config", "=", "config", "[", "\"train\"", "]", ",", "\n", ")", "\n", ")", "\n", "optimizer", "=", "opt", ".", "build_optimizer", "(", "optimizer_config", "=", "config", "[", "\"train\"", "]", "[", "\"optimizer\"", "]", ")", "\n", "model", ".", "compile", "(", "optimizer", "=", "optimizer", ")", "\n", "model", ".", "plot_model", "(", "output_dir", "=", "log_dir", ")", "\n", "\n", "# build callbacks", "\n", "", "tensorboard_callback", "=", "tf", ".", "keras", ".", "callbacks", ".", "TensorBoard", "(", "\n", "log_dir", "=", "log_dir", ",", "\n", "histogram_freq", "=", "config", "[", "\"train\"", "]", "[", "\"save_period\"", "]", ",", "\n", "update_freq", "=", "config", "[", "\"train\"", "]", ".", "get", "(", "\"update_freq\"", ",", "\"epoch\"", ")", ",", "\n", ")", "\n", "ckpt_callback", ",", "initial_epoch", "=", "build_checkpoint_callback", "(", "\n", "model", "=", "model", ",", "\n", "dataset", "=", "dataset_train", ",", "\n", "log_dir", "=", "log_dir", ",", "\n", "save_period", "=", "config", "[", "\"train\"", "]", "[", "\"save_period\"", "]", ",", "\n", "ckpt_path", "=", "ckpt_path", ",", "\n", ")", "\n", "callbacks", "=", "[", "tensorboard_callback", ",", "ckpt_callback", "]", "\n", "\n", "# train", "\n", "# it's necessary to define the steps_per_epoch", "\n", "# and validation_steps to prevent errors like", "\n", "# BaseCollectiveExecutor::StartAbort Out of range: End of sequence", "\n", "model", ".", "fit", "(", "\n", "x", "=", "dataset_train", ",", "\n", "steps_per_epoch", "=", "steps_per_epoch_train", ",", "\n", "initial_epoch", "=", "initial_epoch", ",", "\n", "epochs", "=", "config", "[", "\"train\"", "]", "[", "\"epochs\"", "]", ",", "\n", "validation_data", "=", "dataset_val", ",", "\n", "validation_steps", "=", "steps_per_epoch_val", ",", "\n", "callbacks", "=", "callbacks", ",", "\n", ")", "\n", "\n", "# close file loaders in data loaders after training", "\n", "data_loader_train", ".", "close", "(", ")", "\n", "if", "data_loader_val", "is", "not", "None", ":", "\n", "        ", "data_loader_val", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.main": [[199, 284], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "train.train"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.train.train"], ["", "", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Entry point for train script.\n\n    :param args: arguments\n    \"\"\"", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--gpu\"", ",", "\n", "\"-g\"", ",", "\n", "help", "=", "\"GPU index for training.\"", "\n", "\"-g for using GPU remotely\"", "\n", "'-g \"\" for using CPU'", "\n", "'-g \"0\" for using GPU 0'", "\n", "'-g \"0,1\" for using GPU 0 and 1.'", ",", "\n", "type", "=", "str", ",", "\n", "required", "=", "False", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--gpu_allow_growth\"", ",", "\n", "\"-gr\"", ",", "\n", "help", "=", "\"Prevent TensorFlow from reserving all available GPU memory\"", ",", "\n", "default", "=", "False", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--num_workers\"", ",", "\n", "help", "=", "\"Number of CPUs to be used, <= 0 means unlimited.\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "1", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--ckpt_path\"", ",", "\n", "\"-k\"", ",", "\n", "help", "=", "\"Path of the saved model checkpoint to load.\"", "\n", "\"No need to provide if start training from scratch.\"", ",", "\n", "default", "=", "\"\"", ",", "\n", "type", "=", "str", ",", "\n", "required", "=", "False", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--log_dir\"", ",", "help", "=", "\"Path of log directory.\"", ",", "default", "=", "\"logs\"", ",", "type", "=", "str", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--exp_name\"", ",", "\n", "\"-l\"", ",", "\n", "help", "=", "\"Name of log directory.\"", "\n", "\"The directory is under log root, e.g. logs/ by default.\"", "\n", "\"If not provided, a timestamp based folder will be created.\"", ",", "\n", "default", "=", "\"\"", ",", "\n", "type", "=", "str", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config_path\"", ",", "\n", "\"-c\"", ",", "\n", "help", "=", "\"Path of config, must end with .yaml. Can pass multiple paths.\"", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "\"+\"", ",", "\n", "required", "=", "True", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--max_epochs\"", ",", "\n", "help", "=", "\"The maximum number of epochs, -1 means following configuration.\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "-", "1", ",", "\n", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "train", "(", "\n", "gpu", "=", "args", ".", "gpu", ",", "\n", "config_path", "=", "args", ".", "config_path", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "gpu_allow_growth", "=", "args", ".", "gpu_allow_growth", ",", "\n", "ckpt_path", "=", "args", ".", "ckpt_path", ",", "\n", "log_dir", "=", "args", ".", "log_dir", ",", "\n", "exp_name", "=", "args", ".", "exp_name", ",", "\n", "max_epochs", "=", "args", ".", "max_epochs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.download.download": [[19, 60], ["os.path.abspath", "logger.info", "logger.info", "urllib.request.urlopen", "logger.info", "os.path.exists", "os.mkdir", "zipfile.ZipFile", "zf.namelist", "io.BytesIO", "os.path.join", "any", "urllib.request.urlopen.read", "zf.getinfo", "zf.getinfo.filename.replace", "zf.extract", "logger.info"], "function", ["None"], ["def", "download", "(", "dirs", ",", "output_dir", "=", "\"./\"", ",", "branch", "=", "\"main\"", ")", ":", "\n", "    ", "\"\"\"\n    Downloads the files and directories from DeepReg into\n    `output_dir`, keeping only `dirs`.\n\n    :param dirs: the list of directories to save\n    :param output_dir: directory which we use as the root to save output\n    :param branch: The name of the branch from which we download the zip.\n    :return: void\n    \"\"\"", "\n", "\n", "output_dir", "=", "os", ".", "path", ".", "abspath", "(", "output_dir", ")", "# Get the output directory.", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "output_dir", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "output_dir", ")", "\n", "\n", "", "logger", ".", "info", "(", "\"Will download folders: %s into %s.\"", ",", "dirs", ",", "output_dir", ")", "\n", "\n", "zip_url", "=", "f\"https://github.com/DeepRegNet/DeepReg/archive/{branch}.zip\"", "\n", "logger", ".", "info", "(", "\"Downloading archive from DeepReg repository %s.\"", ",", "zip_url", ")", "\n", "response", "=", "urlopen", "(", "zip_url", ")", "# Download the zip.", "\n", "logger", ".", "info", "(", "\"Downloaded archive. Extracting files.\"", ")", "\n", "\n", "with", "ZipFile", "(", "BytesIO", "(", "response", ".", "read", "(", ")", ")", ")", "as", "zf", ":", "\n", "\n", "        ", "pathnames", "=", "zf", ".", "namelist", "(", ")", "\n", "head", "=", "pathnames", "[", "0", "]", "\n", "keepdirs", "=", "[", "\n", "os", ".", "path", ".", "join", "(", "head", ",", "d", ")", "for", "d", "in", "dirs", "\n", "]", "# Find our folders to keep, based on what user specifies.", "\n", "\n", "for", "pathname", "in", "pathnames", ":", "\n", "            ", "if", "any", "(", "d", "in", "pathname", "for", "d", "in", "keepdirs", ")", ":", "\n", "\n", "                ", "info", "=", "zf", ".", "getinfo", "(", "pathname", ")", "\n", "info", ".", "filename", "=", "info", ".", "filename", ".", "replace", "(", "\n", "head", ",", "\"\"", "\n", ")", "# Remove head directory from filepath", "\n", "zf", ".", "extract", "(", "info", ",", "output_dir", ")", "\n", "\n", "logger", ".", "info", "(", "\"Downloaded %s\"", ",", "info", ".", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.download.main": [[62, 96], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "download.download", "logger.info"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.download.download"], ["", "", "", "", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Entry point for downloading data.\n\n    :param args:\n    \"\"\"", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output_dir\"", ",", "\n", "\"-d\"", ",", "\n", "dest", "=", "\"output_dir\"", ",", "\n", "default", "=", "\"./\"", ",", "\n", "help", "=", "\"All directories will be downloaded to the specified directory.\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--branch\"", ",", "\n", "\"-b\"", ",", "\n", "dest", "=", "\"branch\"", ",", "\n", "default", "=", "\"main\"", ",", "\n", "help", "=", "\"The name of the branch to download.\"", ",", "\n", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "\n", "dirs", "=", "[", "\n", "\"config\"", ",", "\n", "\"data\"", ",", "\n", "\"demos\"", ",", "\n", "]", "\n", "\n", "download", "(", "dirs", ",", "args", ".", "output_dir", ",", "args", ".", "branch", ")", "\n", "\n", "logger", ".", "info", "(", "\n", "\"Download complete. \"", "\n", "\"Please refer to the DeepReg Quick Start guide for next steps.\"", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get": [[7, 46], ["logging.getLogger", "os.environ.get", "max", "logging.getLogger.setLevel", "logging.Formatter", "logging.StreamHandler", "logging.StreamHandler.setFormatter", "logging.StreamHandler.setLevel", "logging.getLogger.addHandler", "int"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["def", "get", "(", "name", ":", "str", ")", "->", "logging", ".", "Logger", ":", "\n", "    ", "\"\"\"\n    Configure the logger with formatter and handlers.\n\n    The logger should be used as:\n\n    .. code-block:: python\n\n        from deepreg import log\n\n        logger = log.get(__name__)\n\n    The log level depends on the environment variable `DEEPREG_LOG_LEVEL`.\n\n    - 0: NOTSET, will be set to DEBUG\n    - 1: DEBUG\n    - 2: INFO (default)\n    - 3: WARNING\n    - 4: ERROR\n    - 5: CRITICAL\n\n    https://docs.python.org/3/library/logging.html#levels\n\n    :param name: module name.\n    :return: configured logger.\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "name", "=", "name", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "log_level", "=", "os", ".", "environ", ".", "get", "(", "\"DEEPREG_LOG_LEVEL\"", ",", "\"2\"", ")", "\n", "log_level_int", "=", "max", "(", "int", "(", "log_level", ")", "*", "10", ",", "10", ")", "\n", "logger", ".", "setLevel", "(", "log_level_int", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "\n", "fmt", "=", "\"%(asctime)s | %(levelname)-8s | %(message)s\"", ",", "datefmt", "=", "\"%Y-%m-%d %H:%M:%S\"", "\n", ")", "\n", "stdout_handler", "=", "logging", ".", "StreamHandler", "(", "stream", "=", "sys", ".", "stdout", ")", "\n", "stdout_handler", ".", "setFormatter", "(", "formatter", ")", "\n", "stdout_handler", ".", "setLevel", "(", "log_level_int", ")", "\n", "logger", ".", "addHandler", "(", "stdout_handler", ")", "\n", "return", "logger", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.warp.shape_sanity_check": [[21, 38], ["len", "ValueError", "ValueError", "len"], "function", ["None"], ["def", "shape_sanity_check", "(", "image", ":", "np", ".", "ndarray", ",", "ddf", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "\"\"\"\n    Verify image and ddf shapes are consistent and correct.\n\n    :param image: a numpy array of shape (m_dim1, m_dim2, m_dim3)\n        or (m_dim1, m_dim2, m_dim3, ch)\n    :param ddf: a numpy array of shape (f_dim1, f_dim2, f_dim3, 3)\n    \"\"\"", "\n", "if", "len", "(", "image", ".", "shape", ")", "not", "in", "[", "3", ",", "4", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"image shape must be (m_dim1, m_dim2, m_dim3) \"", "\n", "f\"or (m_dim1, m_dim2, m_dim3, ch),\"", "\n", "f\" got {image.shape}\"", "\n", ")", "\n", "", "if", "not", "(", "len", "(", "ddf", ".", "shape", ")", "==", "4", "and", "ddf", ".", "shape", "[", "-", "1", "]", "==", "3", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"ddf shape must be (f_dim1, f_dim2, f_dim3, 3), got {ddf.shape}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.warp.warp": [[41, 81], ["deepreg.dataset.loader.nifti_loader.load_nifti_file", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "warp.shape_sanity_check", "tensorflow.expand_dims", "tensorflow.expand_dims", "warped_image.numpy.numpy", "nibabel.save", "logger.info", "logger.warning", "os.makedirs", "deepreg.model.layer.Warping", "os.path.join", "logger.warning", "os.path.dirname", "nibabel.Nifti1Image", "os.path.join.endswith", "os.path.join.endswith", "os.path.dirname", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.warp.shape_sanity_check", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save"], ["", "", "def", "warp", "(", "image_path", ":", "str", ",", "ddf_path", ":", "str", ",", "out_path", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    :param image_path: file path of the image file\n    :param ddf_path: file path of the ddf file\n    :param out_path: file path of the output\n    \"\"\"", "\n", "if", "out_path", "==", "\"\"", ":", "\n", "        ", "out_path", "=", "\"warped.nii.gz\"", "\n", "logger", ".", "warning", "(", "\n", "\"Output file path is not provided, will save output in %s.\"", ",", "out_path", "\n", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "(", "out_path", ".", "endswith", "(", "\".nii\"", ")", "or", "out_path", ".", "endswith", "(", "\".nii.gz\"", ")", ")", ":", "\n", "            ", "out_path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "out_path", ")", ",", "\"warped.nii.gz\"", ")", "\n", "logger", ".", "warning", "(", "\n", "\"Output file path should end with .nii or .nii.gz, \"", "\n", "\"will save output in %s.\"", ",", "\n", "out_path", ",", "\n", ")", "\n", "", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "out_path", ")", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# load image and ddf", "\n", "", "image", "=", "load_nifti_file", "(", "image_path", ")", "\n", "ddf", "=", "load_nifti_file", "(", "ddf_path", ")", "\n", "fixed_image_shape", "=", "ddf", ".", "shape", "[", ":", "3", "]", "\n", "shape_sanity_check", "(", "image", "=", "image", ",", "ddf", "=", "ddf", ")", "\n", "\n", "# add batch dimension manually", "\n", "image", "=", "tf", ".", "expand_dims", "(", "image", ",", "axis", "=", "0", ")", "\n", "ddf", "=", "tf", ".", "expand_dims", "(", "ddf", ",", "axis", "=", "0", ")", "\n", "\n", "# warp", "\n", "warped_image", "=", "Warping", "(", "fixed_image_size", "=", "fixed_image_shape", ")", "(", "[", "ddf", ",", "image", "]", ")", "\n", "warped_image", "=", "warped_image", ".", "numpy", "(", ")", "\n", "warped_image", "=", "warped_image", "[", "0", ",", "...", "]", "# removed added batch dimension", "\n", "\n", "# save output", "\n", "nib", ".", "save", "(", "img", "=", "nib", ".", "Nifti1Image", "(", "warped_image", ",", "affine", "=", "np", ".", "eye", "(", "4", ")", ")", ",", "filename", "=", "out_path", ")", "\n", "\n", "logger", ".", "info", "(", "\"Warped image has been saved at %s.\"", ",", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.warp.main": [[83, 104], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "warp.warp"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.warp.warp"], ["", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Entry point for warp script.\n\n    :param args:\n    \"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--image\"", ",", "\"-i\"", ",", "help", "=", "\"File path for image file\"", ",", "type", "=", "str", ",", "required", "=", "True", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--ddf\"", ",", "\"-d\"", ",", "help", "=", "\"File path for ddf file\"", ",", "type", "=", "str", ",", "required", "=", "True", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--out\"", ",", "\"-o\"", ",", "help", "=", "\"Output path for warped image\"", ",", "default", "=", "\"\"", ")", "\n", "\n", "# init arguments", "\n", "args", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "warp", "(", "image_path", "=", "args", ".", "image", ",", "ddf_path", "=", "args", ".", "ddf", ",", "out_path", "=", "args", ".", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback.__init__": [[7, 30], ["super().__init__", "tensorflow.train.Checkpoint", "tensorflow.train.CheckpointManager"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "model", ",", "directory", ",", "period", ":", "int", "=", "1", ",", "save_on_train_end", ":", "bool", "=", "True", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Callback wrapping `tf.train.CheckpointManager`.\n\n        :param model: model\n        :param directory: directory to store the checkpoints\n        :param period: save the checkpoint every X epochs\n        :param save_on_train_end: save the checkpoint as the training ends\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_directory", "=", "directory", "\n", "\n", "self", ".", "_checkpoint", "=", "tf", ".", "train", ".", "Checkpoint", "(", "model", "=", "model", ",", "optimizer", "=", "model", ".", "optimizer", ")", "\n", "self", ".", "_manager", "=", "tf", ".", "train", ".", "CheckpointManager", "(", "\n", "checkpoint", "=", "self", ".", "_checkpoint", ",", "directory", "=", "self", ".", "_directory", ",", "max_to_keep", "=", "None", "\n", ")", "\n", "self", ".", "_period", "=", "period", "\n", "self", ".", "_save_on_train_end", "=", "save_on_train_end", "\n", "self", ".", "_restored", "=", "False", "\n", "self", ".", "_epoch_count", "=", "None", "\n", "self", ".", "_last_save", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback._on_begin": [[31, 34], ["callback.CheckpointManagerCallback.restore"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback.restore"], ["", "def", "_on_begin", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "_restored", ":", "\n", "            ", "self", ".", "restore", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback.restore": [[35, 40], ["callback.CheckpointManagerCallback._checkpoint.restore"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback.restore"], ["", "", "def", "restore", "(", "self", ",", "save_path", "=", "None", ")", ":", "\n", "        ", "if", "save_path", "is", "None", ":", "\n", "            ", "save_path", "=", "self", ".", "_manager", ".", "latest_checkpoint", "\n", "", "self", ".", "_checkpoint", ".", "restore", "(", "save_path", ")", "\n", "self", ".", "_restored", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback.on_train_begin": [[41, 43], ["callback.CheckpointManagerCallback._on_begin"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback._on_begin"], ["", "def", "on_train_begin", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "        ", "self", ".", "_on_begin", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback.on_epoch_end": [[44, 49], ["callback.CheckpointManagerCallback._save"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback._save"], ["", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "epochs_finished", "=", "epoch", "+", "1", "\n", "self", ".", "_epoch_count", "=", "epochs_finished", "\n", "if", "epochs_finished", "%", "self", ".", "_period", "==", "0", ":", "\n", "            ", "self", ".", "_save", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback.on_train_end": [[50, 53], ["callback.CheckpointManagerCallback._save"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback._save"], ["", "", "def", "on_train_end", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "_save_on_train_end", ":", "\n", "            ", "self", ".", "_save", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback._save": [[54, 61], ["callback.CheckpointManagerCallback._manager.save"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save"], ["", "", "def", "_save", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        checkpoint saved as f\"{self._directory}/ckpt-{self._epoch_count}\"\n        \"\"\"", "\n", "if", "self", ".", "_last_save", "!=", "self", ".", "_epoch_count", ":", "\n", "            ", "self", ".", "_manager", ".", "save", "(", "checkpoint_number", "=", "self", ".", "_epoch_count", ")", "\n", "self", ".", "_last_save", "=", "self", ".", "_epoch_count", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.build_checkpoint_callback": [[63, 101], ["model.fit", "callback.CheckpointManagerCallback", "initial_epoch_str.isdigit", "int", "callback.CheckpointManagerCallback.restore", "ckpt_path.split"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.callback.CheckpointManagerCallback.restore"], ["", "", "", "def", "build_checkpoint_callback", "(", "\n", "model", ":", "tf", ".", "keras", ".", "Model", ",", "\n", "dataset", ":", "tf", ".", "data", ".", "Dataset", ",", "\n", "log_dir", ":", "str", ",", "\n", "save_period", ":", "int", ",", "\n", "ckpt_path", ":", "str", ",", "\n", ")", "->", "Tuple", "[", "CheckpointManagerCallback", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Function to prepare callbacks for training.\n\n    :param model: model to train\n    :param dataset: dataset for training\n    :param log_dir: directory of logs\n    :param save_period: save the checkpoint every X epochs\n    :param ckpt_path: path to restore ckpt\n    :return: a list of callbacks\n    \"\"\"", "\n", "# fit the model for 1 step to initialise optimiser arguments as trackable Variables", "\n", "model", ".", "fit", "(", "\n", "x", "=", "dataset", ",", "\n", "steps_per_epoch", "=", "1", ",", "\n", "epochs", "=", "1", ",", "\n", "verbose", "=", "0", ",", "\n", ")", "\n", "checkpoint_manager_callback", "=", "CheckpointManagerCallback", "(", "\n", "model", ",", "log_dir", "+", "\"/save\"", ",", "period", "=", "save_period", "\n", ")", "\n", "if", "ckpt_path", ":", "\n", "        ", "initial_epoch_str", "=", "ckpt_path", ".", "split", "(", "\"-\"", ")", "[", "-", "1", "]", "\n", "assert", "initial_epoch_str", ".", "isdigit", "(", ")", ",", "(", "\n", "f\"Checkpoint path for checkpoint manager \"", "\n", "f\"must be of form ckpt-epoch_count, got {ckpt_path}\"", "\n", ")", "\n", "initial_epoch", "=", "int", "(", "initial_epoch_str", ")", "\n", "checkpoint_manager_callback", ".", "restore", "(", "ckpt_path", ")", "\n", "", "else", ":", "\n", "        ", "initial_epoch", "=", "0", "\n", "", "return", "checkpoint_manager_callback", ",", "initial_epoch", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_dataset": [[20, 54], ["deepreg.dataset.load.get_data_loader", "deepreg.dataset.load.get_data_loader.get_dataset_and_preprocess", "max"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.load.get_data_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.get_dataset_and_preprocess"], ["x", "=", "np", ".", "asarray", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "y", "=", "np", ".", "asarray", "(", "y", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# check shape", "\n", "if", "x", ".", "shape", "!=", "y", ".", "shape", ":", "\n", "        ", "return", "False", "\n", "\n", "# check nan values", "\n", "# support case some values are nan", "\n", "", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "x", ")", "!=", "np", ".", "isnan", "(", "y", ")", ")", ":", "\n", "        ", "return", "False", "\n", "", "x", "=", "np", ".", "nan_to_num", "(", "x", ")", "\n", "y", "=", "np", ".", "nan_to_num", "(", "y", ")", "\n", "\n", "# check values", "\n", "return", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "y", ",", "atol", "=", "atol", ")", ")", "\n", "\n", "\n", "", "def", "is_equal_tf", "(", "\n", "x", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "y", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "atol", ":", "float", "=", "EPS", ",", "\n", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n    Check if two tf tensors are identical within a tolerance.\n\n    :param x:\n    :param y:\n    :param atol: error margin\n    :return: return true if two tf tensors are nearly equal\n    \"\"\"", "\n", "x", "=", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "y", "=", "tf", ".", "cast", "(", "y", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "return", "is_equal_np", "(", "x", "=", "x", ",", "y", "=", "y", ",", "atol", "=", "atol", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.build_log_dir": [[56, 73], ["os.path.join", "os.path.exists", "os.path.expanduser", "logger.warning", "os.makedirs", "datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["None"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_array": [[75, 140], ["isinstance", "deepreg.dataset.loader.util.normalize_array.numpy", "len", "ValueError", "len", "os.path.join", "os.path.join", "os.path.exists", "range", "ValueError", "os.makedirs", "nibabel.save", "deepreg.dataset.loader.util.normalize_array", "os.path.join", "os.path.exists", "matplotlib.imsave", "nibabel.Nifti1Image", "os.path.exists", "os.makedirs", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.calculate_metrics": [[143, 183], ["dict", "tensorflow.expand_dims", "tensorflow.expand_dims", "deepreg.compute_centroid_distance().numpy", "deepreg.SumSquaredDifference", "deepreg.DiceScore", "deepreg.compute_centroid_distance"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.compute_centroid_distance"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.util.save_metric_dict": [[185, 223], ["os.makedirs", "pandas.DataFrame", "pd.DataFrame.to_csv", "pd.DataFrame.drop", "df_per_label.reindex.fillna", "df_per_label.reindex.groupby", "pandas.concat", "df_per_label.reindex.reindex", "df_per_label.reindex.to_csv", "pd.DataFrame.drop", "df.drop.describe().to_csv", "os.path.join", "sorted", "os.path.join", "os.path.join", "df_per_label.reindex.mean().add_suffix", "df_per_label.reindex.median().add_suffix", "df_per_label.reindex.std().add_suffix", "df.drop.describe", "df_per_label.reindex.mean", "df_per_label.reindex.median", "df_per_label.reindex.std"], "function", ["None"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.string_to_list": [[23, 32], ["elem.strip", "string.split"], "function", ["None"], ["def", "string_to_list", "(", "string", ":", "str", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "\"\"\"\n    Converts a comma separated string to a list of strings\n    also removes leading or trailing spaces from each element in list.\n\n    :param string: string which is to be converted to list\n    :return: list of strings\n    \"\"\"", "\n", "return", "[", "elem", ".", "strip", "(", ")", "for", "elem", "in", "string", ".", "split", "(", "\",\"", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.gif_slices": [[34, 69], ["deepreg.dataset.loader.nifti_loader.load_nifti_file", "numpy.shape", "type", "vis.string_to_list", "matplotlib.figure", "matplotlib.Axes", "plt.Axes.set_axis_off", "plt.figure.add_axes", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "range", "matplotlib.ArtistAnimation", "os.path.join", "animation.ArtistAnimation.save", "logger.info", "matplotlib.imshow", "frames.append", "[].split", "os.path.split"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.string_to_list", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save"], ["", "def", "gif_slices", "(", "img_paths", ",", "save_path", "=", "\"\"", ",", "interval", "=", "50", ")", ":", "\n", "    ", "\"\"\"\n    Generates and saves gif of slices of image\n    supports multiple images to generate multiple gif files.\n\n    :param img_paths: list or comma separated string of image paths\n    :param save_path: path to directory where visualisation/s is/are to be saved\n    :param interval: time in miliseconds between frames of gif\n    \"\"\"", "\n", "if", "type", "(", "img_paths", ")", "is", "str", ":", "\n", "        ", "img_paths", "=", "string_to_list", "(", "img_paths", ")", "\n", "", "img", "=", "load_nifti_file", "(", "img_paths", "[", "0", "]", ")", "\n", "img_shape", "=", "np", ".", "shape", "(", "img", ")", "\n", "for", "img_path", "in", "img_paths", ":", "\n", "        ", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "plt", ".", "Axes", "(", "fig", ",", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "ax", ".", "set_axis_off", "(", ")", "\n", "fig", ".", "add_axes", "(", "ax", ")", "\n", "\n", "img", "=", "load_nifti_file", "(", "img_path", ")", "\n", "\n", "frames", "=", "[", "]", "\n", "for", "index", "in", "range", "(", "img_shape", "[", "-", "1", "]", ")", ":", "\n", "            ", "frame", "=", "plt", ".", "imshow", "(", "img", "[", ":", ",", ":", ",", "index", "]", ",", "aspect", "=", "\"auto\"", ",", "animated", "=", "True", ")", "\n", "# plt.axis('off')", "\n", "frames", ".", "append", "(", "[", "frame", "]", ")", "\n", "\n", "", "anim", "=", "animation", ".", "ArtistAnimation", "(", "fig", ",", "frames", ",", "interval", "=", "interval", ")", "\n", "\n", "path_to_anim_save", "=", "os", ".", "path", ".", "join", "(", "\n", "save_path", ",", "os", ".", "path", ".", "split", "(", "img_path", ")", "[", "-", "1", "]", ".", "split", "(", "\".\"", ")", "[", "0", "]", "+", "\".gif\"", "\n", ")", "\n", "\n", "anim", ".", "save", "(", "path_to_anim_save", ")", "\n", "logger", ".", "info", "(", "\"Animation saved to: %s.\"", ",", "path_to_anim_save", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.tile_slices": [[71, 119], ["deepreg.dataset.loader.nifti_loader.load_nifti_file", "numpy.shape", "len", "len", "numpy.array().reshape", "matplotlib.figure", "enumerate", "os.path.join", "matplotlib.savefig", "logger.info", "type", "vis.string_to_list", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "enumerate", "round", "numpy.array", "matplotlib.subplot", "matplotlib.imshow", "matplotlib.axis", "[].split", "matplotlib.title", "numpy.arange", "numpy.random.rand", "os.path.split"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.string_to_list", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file"], ["", "", "def", "tile_slices", "(", "img_paths", ",", "save_path", "=", "\"\"", ",", "fname", "=", "None", ",", "slice_inds", "=", "None", ",", "col_titles", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Generate a tiled plot of multiple images for multiple slices in the image.\n    Rows are different slices, columns are different images.\n\n    :param img_paths: list or comma separated string of image paths\n    :param save_path: path to directory where visualisation/s is/are to be saved\n    :param fname: file name with extension to save visualisation to\n    :param slice_inds: list of slice indices to plot for each image\n    :param col_titles: titles for each column, if None then inferred from file names\n    \"\"\"", "\n", "if", "type", "(", "img_paths", ")", "is", "str", ":", "\n", "        ", "img_paths", "=", "string_to_list", "(", "img_paths", ")", "\n", "", "img", "=", "load_nifti_file", "(", "img_paths", "[", "0", "]", ")", "\n", "img_shape", "=", "np", ".", "shape", "(", "img", ")", "\n", "\n", "if", "slice_inds", "is", "None", ":", "\n", "        ", "slice_inds", "=", "[", "round", "(", "np", ".", "random", ".", "rand", "(", ")", "*", "(", "img_shape", "[", "-", "1", "]", ")", "-", "1", ")", "]", "\n", "\n", "", "if", "col_titles", "is", "None", ":", "\n", "        ", "col_titles", "=", "[", "\n", "os", ".", "path", ".", "split", "(", "img_path", ")", "[", "-", "1", "]", ".", "split", "(", "\".\"", ")", "[", "0", "]", "for", "img_path", "in", "img_paths", "\n", "]", "\n", "\n", "", "num_inds", "=", "len", "(", "slice_inds", ")", "\n", "num_imgs", "=", "len", "(", "img_paths", ")", "\n", "\n", "subplot_mat", "=", "np", ".", "array", "(", "np", ".", "arange", "(", "num_inds", "*", "num_imgs", ")", "+", "1", ")", ".", "reshape", "(", "\n", "num_inds", ",", "num_imgs", "\n", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "num_imgs", "*", "2", ",", "num_inds", "*", "2", ")", ")", "\n", "\n", "imgs", "=", "[", "load_nifti_file", "(", "p", ")", "for", "p", "in", "img_paths", "]", "\n", "\n", "for", "col_num", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "        ", "for", "row_num", ",", "index", "in", "enumerate", "(", "slice_inds", ")", ":", "\n", "            ", "plt", ".", "subplot", "(", "num_inds", ",", "num_imgs", ",", "subplot_mat", "[", "row_num", ",", "col_num", "]", ")", "\n", "plt", ".", "imshow", "(", "img", "[", ":", ",", ":", ",", "index", "]", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "if", "row_num", "-", "0", "<", "1e-3", ":", "\n", "                ", "plt", ".", "title", "(", "col_titles", "[", "col_num", "]", ")", "\n", "\n", "", "", "", "if", "fname", "is", "None", ":", "\n", "        ", "fname", "=", "\"visualisation.png\"", "\n", "", "save_fig_to", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "fname", ")", "\n", "plt", ".", "savefig", "(", "save_fig_to", ")", "\n", "logger", ".", "info", "(", "\"Plot saved to: %s\"", ",", "save_fig_to", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.gif_warp": [[121, 181], ["deepreg.dataset.loader.nifti_loader.load_nifti_file", "numpy.shape", "type", "vis.string_to_list", "round", "matplotlib.figure", "matplotlib.Axes", "plt.Axes.set_axis_off", "plt.figure.add_axes", "numpy.linspace", "matplotlib.ArtistAnimation", "os.path.join", "animation.ArtistAnimation.save", "logger.info", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "numpy.expand_dims", "numpy.squeeze", "matplotlib.imshow", "frames.append", "numpy.expand_dims", "deepreg.model.layer.Warping", "np.squeeze.numpy", "numpy.random.rand", "str", "[].split", "os.path.split"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.string_to_list", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file"], ["", "def", "gif_warp", "(", "\n", "img_paths", ",", "ddf_path", ",", "slice_inds", "=", "None", ",", "num_interval", "=", "100", ",", "interval", "=", "50", ",", "save_path", "=", "\"\"", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Apply ddf to image slice/s to generate gif.\n\n    :param img_paths: list or comma separated string of image paths\n    :param ddf_path: path to ddf to use for warping\n    :param slice_inds: list of slice indices to use for each image\n    :param num_interval: number of intervals in which to apply ddf\n    :param interval: time in miliseconds between frames of gif\n    :param save_path: path to directory where visualisation/s is/are to be saved\n    \"\"\"", "\n", "if", "type", "(", "img_paths", ")", "is", "str", ":", "\n", "        ", "img_paths", "=", "string_to_list", "(", "img_paths", ")", "\n", "\n", "", "image", "=", "load_nifti_file", "(", "img_paths", "[", "0", "]", ")", "\n", "img_shape", "=", "np", ".", "shape", "(", "image", ")", "\n", "\n", "if", "slice_inds", "is", "None", ":", "\n", "        ", "slice_inds", "=", "[", "round", "(", "np", ".", "random", ".", "rand", "(", ")", "*", "(", "img_shape", "[", "-", "1", "]", ")", "-", "1", ")", "]", "\n", "\n", "", "for", "img_path", "in", "img_paths", ":", "\n", "        ", "for", "slice_ind", "in", "slice_inds", ":", "\n", "\n", "            ", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "plt", ".", "Axes", "(", "fig", ",", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "ax", ".", "set_axis_off", "(", ")", "\n", "fig", ".", "add_axes", "(", "ax", ")", "\n", "\n", "ddf_scalers", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "num", "=", "num_interval", ")", "\n", "\n", "frames", "=", "[", "]", "\n", "for", "ddf_scaler", "in", "ddf_scalers", ":", "\n", "                ", "image", "=", "load_nifti_file", "(", "img_path", ")", "\n", "ddf", "=", "load_nifti_file", "(", "ddf_path", ")", "\n", "fixed_image_shape", "=", "ddf", ".", "shape", "[", ":", "3", "]", "\n", "image", "=", "np", ".", "expand_dims", "(", "image", ",", "axis", "=", "0", ")", "\n", "ddf", "=", "np", ".", "expand_dims", "(", "ddf", ",", "axis", "=", "0", ")", "*", "ddf_scaler", "\n", "\n", "warped_image", "=", "Warping", "(", "fixed_image_size", "=", "fixed_image_shape", ")", "(", "[", "ddf", ",", "image", "]", ")", "\n", "warped_image", "=", "np", ".", "squeeze", "(", "warped_image", ".", "numpy", "(", ")", ")", "\n", "\n", "frame", "=", "plt", ".", "imshow", "(", "\n", "warped_image", "[", ":", ",", ":", ",", "slice_ind", "]", ",", "aspect", "=", "\"auto\"", ",", "animated", "=", "True", "\n", ")", "\n", "\n", "frames", ".", "append", "(", "[", "frame", "]", ")", "\n", "\n", "", "anim", "=", "animation", ".", "ArtistAnimation", "(", "fig", ",", "frames", ",", "interval", "=", "interval", ")", "\n", "path_to_anim_save", "=", "os", ".", "path", ".", "join", "(", "\n", "save_path", ",", "\n", "os", ".", "path", ".", "split", "(", "img_path", ")", "[", "-", "1", "]", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "+", "\"_slice_\"", "\n", "+", "str", "(", "slice_ind", ")", "\n", "+", "\".gif\"", ",", "\n", ")", "\n", "\n", "anim", ".", "save", "(", "path_to_anim_save", ")", "\n", "logger", ".", "info", "(", "\"Animation saved to: %s\"", ",", "path_to_anim_save", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.gif_tile_slices": [[183, 259], ["numpy.prod", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "numpy.shape", "matplotlib.figure", "matplotlib.Axes", "plt.Axes.set_axis_off", "plt.figure.add_axes", "range", "matplotlib.ArtistAnimation", "os.path.join", "animation.ArtistAnimation.save", "logger.info", "type", "vis.string_to_list", "int", "int", "ValueError", "deepreg.dataset.loader.nifti_loader.load_nifti_file", "numpy.shape", "imgs.append", "numpy.matlib.repmat", "range", "matplotlib.imshow", "frames.append", "len", "ValueError", "numpy.ones", "temp_tiles.append", "range", "str", "str", "numpy.prod", "str", "len"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.string_to_list", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file"], ["", "", "", "def", "gif_tile_slices", "(", "img_paths", ",", "save_path", "=", "None", ",", "size", "=", "(", "2", ",", "2", ")", ",", "fname", "=", "None", ",", "interval", "=", "50", ")", ":", "\n", "    ", "\"\"\"\n    Creates tiled gif over slices of multiple images.\n\n    :param img_paths: list or comma separated string of image paths\n    :param save_path: path to directory where visualisation/s is/are to be saved\n    :param interval: time in miliseconds between frames of gif\n    :param size: number of columns and rows of images for the tiled gif\n        (tuple e.g. (2,2))\n    :param fname: filename to save visualisation to\n    \"\"\"", "\n", "if", "type", "(", "img_paths", ")", "is", "str", ":", "\n", "        ", "img_paths", "=", "string_to_list", "(", "img_paths", ")", "\n", "\n", "", "num_images", "=", "np", ".", "prod", "(", "size", ")", "\n", "if", "int", "(", "len", "(", "img_paths", ")", ")", "!=", "int", "(", "num_images", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"The number of images supplied is \"", "\n", "+", "str", "(", "len", "(", "img_paths", ")", ")", "\n", "+", "\" whereas the number required is \"", "\n", "+", "str", "(", "np", ".", "prod", "(", "size", ")", ")", "\n", "+", "\" as size specified is \"", "\n", "+", "str", "(", "size", ")", "\n", ")", "\n", "\n", "", "img", "=", "load_nifti_file", "(", "img_paths", "[", "0", "]", ")", "\n", "img_shape", "=", "np", ".", "shape", "(", "img", ")", "\n", "\n", "imgs", "=", "[", "]", "\n", "for", "img_path", "in", "img_paths", ":", "\n", "        ", "img", "=", "load_nifti_file", "(", "img_path", ")", "\n", "shape", "=", "np", ".", "shape", "(", "img", ")", "\n", "if", "shape", "!=", "img_shape", ":", "\n", "            ", "raise", "ValueError", "(", "\"all images do not have equal shapes\"", ")", "\n", "", "imgs", ".", "append", "(", "img", ")", "\n", "\n", "", "frames", "=", "[", "]", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "plt", ".", "Axes", "(", "fig", ",", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "ax", ".", "set_axis_off", "(", ")", "\n", "fig", ".", "add_axes", "(", "ax", ")", "\n", "\n", "for", "index", "in", "range", "(", "img_shape", "[", "-", "1", "]", ")", ":", "\n", "\n", "        ", "temp_tiles", "=", "[", "]", "\n", "frame", "=", "np", ".", "matlib", ".", "repmat", "(", "\n", "np", ".", "ones", "(", "(", "img_shape", "[", "0", "]", ",", "img_shape", "[", "1", "]", ")", ")", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", "\n", ")", "\n", "\n", "for", "img", "in", "imgs", ":", "\n", "            ", "temp_tile", "=", "img", "[", ":", ",", ":", ",", "index", "]", "\n", "temp_tiles", ".", "append", "(", "temp_tile", ")", "\n", "\n", "", "tile_count", "=", "0", "\n", "for", "i", "in", "range", "(", "size", "[", "0", "]", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "size", "[", "1", "]", ")", ":", "\n", "                ", "tile", "=", "temp_tiles", "[", "tile_count", "]", "\n", "tile_count", "+=", "1", "\n", "frame", "[", "\n", "i", "*", "img_shape", "[", "0", "]", ":", "(", "i", "+", "1", ")", "*", "img_shape", "[", "0", "]", ",", "\n", "j", "*", "img_shape", "[", "0", "]", ":", "(", "j", "+", "1", ")", "*", "img_shape", "[", "0", "]", ",", "\n", "]", "=", "tile", "\n", "\n", "", "", "frame", "=", "plt", ".", "imshow", "(", "frame", ",", "aspect", "=", "\"auto\"", ",", "animated", "=", "True", ")", "\n", "\n", "frames", ".", "append", "(", "[", "frame", "]", ")", "\n", "\n", "", "if", "fname", "is", "None", ":", "\n", "        ", "fname", "=", "\"visualisation.gif\"", "\n", "\n", "", "anim", "=", "animation", ".", "ArtistAnimation", "(", "fig", ",", "frames", ",", "interval", "=", "interval", ")", "\n", "path_to_anim_save", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "fname", ")", "\n", "\n", "anim", ".", "save", "(", "path_to_anim_save", ")", "\n", "logger", ".", "info", "(", "\"Animation saved to: %s\"", ",", "path_to_anim_save", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.main": [[261, 386], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "vis.string_to_list", "vis.gif_slices", "int", "vis.gif_warp", "Exception", "vis.tile_slices", "tuple", "vis.gif_tile_slices", "int", "vis.string_to_list"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.string_to_list", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.gif_slices", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.gif_warp", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.tile_slices", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.gif_tile_slices", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.vis.string_to_list"], ["", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    CLI for deepreg_vis tool.\n\n    Requires ffmpeg wirter to write gif files.\n\n    :param args:\n    \"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "\"deepreg_vis\"", ",", "formatter_class", "=", "argparse", ".", "RawTextHelpFormatter", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--mode\"", ",", "\n", "\"-m\"", ",", "\n", "help", "=", "\"Mode of visualisation \\n\"", "\n", "\"0 for animtion over image slices, \\n\"", "\n", "\"1 for warp animation, \\n\"", "\n", "\"2 for tile plot\"", ",", "\n", "type", "=", "int", ",", "\n", "required", "=", "True", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--image-paths\"", ",", "\n", "\"-i\"", ",", "\n", "help", "=", "\"File path for image file \"", "\n", "\"(can specify multiple paths using a comma separated string)\"", ",", "\n", "type", "=", "str", ",", "\n", "required", "=", "True", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--save-path\"", ",", "\n", "\"-s\"", ",", "\n", "help", "=", "\"Path to directory where resulting visualisation is saved\"", ",", "\n", "default", "=", "\"\"", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--interval\"", ",", "\n", "help", "=", "\"Interval between frames of animation (in miliseconds)\\n\"", "\n", "\"Applicable only if --mode 0 or --mode 1 or --mode 3\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "50", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--ddf-path\"", ",", "\n", "help", "=", "\"Path to ddf used for warping images\\n\"", "\n", "\"Applicable only and required if --mode 1\"", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--num-interval\"", ",", "\n", "help", "=", "\"Number of intervals to use for warping\\n\"", "\"Applicable only if --mode 1\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--slice-inds\"", ",", "\n", "help", "=", "\"Comma separated string of indexes of slices\"", "\n", "\" to be used for the visualisation\\n\"", "\n", "\"Applicable only if --mode 1 or --mode 2\"", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--fname\"", ",", "\n", "help", "=", "\"File name (with extension like .png, .jpeg, .gif, ...)\"", "\n", "\" to save visualisation to\\n\"", "\n", "\"Applicable only if --mode 2 or --mode 3\"", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--col-titles\"", ",", "\n", "help", "=", "\"Comma separated string of column titles to use \"", "\n", "\"(inferred from file names if not provided)\\n\"", "\n", "\"Applicable only if --mode 2\"", ",", "\n", "default", "=", "None", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--size\"", ",", "\n", "help", "=", "\"Comma separated string of number of columns and rows (e.g. '2,2')\\n\"", "\n", "\"Applicable only if --mode 3\"", ",", "\n", "default", "=", "\"2,2\"", ",", "\n", ")", "\n", "\n", "# init arguments", "\n", "args", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "\n", "if", "args", ".", "slice_inds", "is", "not", "None", ":", "\n", "        ", "args", ".", "slice_inds", "=", "string_to_list", "(", "args", ".", "slice_inds", ")", "\n", "args", ".", "slice_inds", "=", "[", "int", "(", "elem", ")", "for", "elem", "in", "args", ".", "slice_inds", "]", "\n", "\n", "", "if", "args", ".", "mode", "==", "0", ":", "\n", "        ", "gif_slices", "(", "\n", "img_paths", "=", "args", ".", "image_paths", ",", "save_path", "=", "args", ".", "save_path", ",", "interval", "=", "args", ".", "interval", "\n", ")", "\n", "", "elif", "args", ".", "mode", "==", "1", ":", "\n", "        ", "if", "args", ".", "ddf_path", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\"--ddf-path is required when using --mode 1\"", ")", "\n", "", "gif_warp", "(", "\n", "img_paths", "=", "args", ".", "image_paths", ",", "\n", "ddf_path", "=", "args", ".", "ddf_path", ",", "\n", "slice_inds", "=", "args", ".", "slice_inds", ",", "\n", "num_interval", "=", "args", ".", "num_interval", ",", "\n", "interval", "=", "args", ".", "interval", ",", "\n", "save_path", "=", "args", ".", "save_path", ",", "\n", ")", "\n", "", "elif", "args", ".", "mode", "==", "2", ":", "\n", "        ", "tile_slices", "(", "\n", "img_paths", "=", "args", ".", "image_paths", ",", "\n", "save_path", "=", "args", ".", "save_path", ",", "\n", "fname", "=", "args", ".", "fname", ",", "\n", "slice_inds", "=", "args", ".", "slice_inds", ",", "\n", "col_titles", "=", "args", ".", "col_titles", ",", "\n", ")", "\n", "", "elif", "args", ".", "mode", "==", "3", ":", "\n", "        ", "size", "=", "tuple", "(", "[", "int", "(", "elem", ")", "for", "elem", "in", "string_to_list", "(", "args", ".", "size", ")", "]", ")", "\n", "gif_tile_slices", "(", "\n", "img_paths", "=", "args", ".", "image_paths", ",", "\n", "save_path", "=", "args", ".", "save_path", ",", "\n", "fname", "=", "args", ".", "fname", ",", "\n", "interval", "=", "args", ".", "interval", ",", "\n", "size", "=", "size", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.load.get_data_loader": [[10, 60], ["data_config[].get", "isinstance", "list", "copy.deepcopy", "copy.deepcopy.pop", "dict", "deepreg.registry.REGISTRY.build_data_loader", "ValueError", "map", "os.path.isdir", "ValueError", "copy.deepcopy.items", "deepreg.registry.REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_data_loader", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["def", "get_data_loader", "(", "data_config", ":", "dict", ",", "split", ":", "str", ")", "->", "Optional", "[", "DataLoader", "]", ":", "\n", "    ", "\"\"\"\n    Return the corresponding data loader.\n\n    Can't be placed in the same file of loader interfaces as it causes import cycle.\n\n    :param data_config: a dictionary containing configuration for data\n    :param split: must be train/valid/test\n    :return: DataLoader or None, returns None if the split or dir is empty.\n    \"\"\"", "\n", "if", "split", "not", "in", "KNOWN_DATA_SPLITS", ":", "\n", "        ", "raise", "ValueError", "(", "f\"split must be one of {KNOWN_DATA_SPLITS}, got {split}\"", ")", "\n", "\n", "", "if", "split", "not", "in", "data_config", ":", "\n", "        ", "return", "None", "\n", "", "data_dir_paths", "=", "data_config", "[", "split", "]", ".", "get", "(", "\"dir\"", ",", "None", ")", "\n", "if", "data_dir_paths", "is", "None", "or", "data_dir_paths", "==", "\"\"", ":", "\n", "        ", "return", "None", "\n", "\n", "", "if", "isinstance", "(", "data_dir_paths", ",", "str", ")", ":", "\n", "        ", "data_dir_paths", "=", "[", "data_dir_paths", "]", "\n", "# replace ~ with user home path", "\n", "", "data_dir_paths", "=", "list", "(", "map", "(", "os", ".", "path", ".", "expanduser", ",", "data_dir_paths", ")", ")", "\n", "for", "data_dir_path", "in", "data_dir_paths", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isdir", "(", "data_dir_path", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Data directory path {data_dir_path} for split {split}\"", "\n", "f\" is not a directory or does not exist\"", "\n", ")", "\n", "\n", "# prepare data loader config", "\n", "", "", "data_loader_config", "=", "deepcopy", "(", "data_config", ")", "\n", "data_loader_config", "=", "{", "\n", "k", ":", "v", "for", "k", ",", "v", "in", "data_loader_config", ".", "items", "(", ")", "if", "k", "not", "in", "KNOWN_DATA_SPLITS", "\n", "}", "\n", "data_loader_config", "[", "\"name\"", "]", "=", "data_loader_config", ".", "pop", "(", "\"type\"", ")", "\n", "\n", "default_args", "=", "dict", "(", "\n", "data_dir_paths", "=", "data_dir_paths", ",", "\n", "file_loader", "=", "REGISTRY", ".", "get", "(", "\n", "category", "=", "FILE_LOADER_CLASS", ",", "key", "=", "data_config", "[", "split", "]", "[", "\"format\"", "]", "\n", ")", ",", "\n", "labeled", "=", "data_config", "[", "split", "]", "[", "\"labeled\"", "]", ",", "\n", "sample_label", "=", "\"sample\"", "if", "split", "==", "\"train\"", "else", "\"all\"", ",", "\n", "seed", "=", "None", "if", "split", "==", "\"train\"", "else", "0", ",", "\n", ")", "\n", "data_loader", ":", "DataLoader", "=", "REGISTRY", ".", "build_data_loader", "(", "\n", "config", "=", "data_loader_config", ",", "default_args", "=", "default_args", "\n", ")", "\n", "return", "data_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomTransformation3D.__init__": [[22, 45], ["super().__init__", "deepreg.model.layer_util.get_reference_grid", "deepreg.model.layer_util.get_reference_grid"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_reference_grid", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_reference_grid"], ["def", "__init__", "(", "\n", "self", ",", "\n", "moving_image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "fixed_image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "batch_size", ":", "int", ",", "\n", "name", ":", "str", "=", "\"RandomTransformation3D\"", ",", "\n", "trainable", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Abstract class for image transformation.\n\n        :param moving_image_size: (m_dim1, m_dim2, m_dim3)\n        :param fixed_image_size: (f_dim1, f_dim2, f_dim3)\n        :param batch_size: total number of samples consumed per step, over all devices.\n        :param name: name of layer\n        :param trainable: if this layer is trainable\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "trainable", "=", "trainable", ",", "name", "=", "name", ")", "\n", "self", ".", "moving_image_size", "=", "moving_image_size", "\n", "self", ".", "fixed_image_size", "=", "fixed_image_size", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "moving_grid_ref", "=", "get_reference_grid", "(", "grid_size", "=", "moving_image_size", ")", "\n", "self", ".", "fixed_grid_ref", "=", "get_reference_grid", "(", "grid_size", "=", "fixed_image_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomTransformation3D.gen_transform_params": [[46, 53], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "gen_transform_params", "(", "self", ")", "->", "Tuple", "[", "tf", ".", "Tensor", ",", "tf", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Generates transformation parameters for moving and fixed image.\n\n        :return: two tensors\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomTransformation3D.transform": [[54, 67], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "transform", "(", "\n", "image", ":", "tf", ".", "Tensor", ",", "grid_ref", ":", "tf", ".", "Tensor", ",", "params", ":", "tf", ".", "Tensor", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Transforms the reference grid and then resample the image.\n\n        :param image: shape = (batch, dim1, dim2, dim3)\n        :param grid_ref: shape = (dim1, dim2, dim3, 3)\n        :param params: parameters for transformation\n        :return: shape = (batch, dim1, dim2, dim3)\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomTransformation3D.call": [[68, 112], ["preprocess.RandomTransformation3D.gen_transform_params", "preprocess.RandomTransformation3D.transform", "preprocess.RandomTransformation3D.transform", "preprocess.RandomTransformation3D.transform", "preprocess.RandomTransformation3D.transform", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.gen_transform_params", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.transform", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.transform", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.transform", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.transform"], ["", "def", "call", "(", "self", ",", "inputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "**", "kwargs", ")", "->", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Creates random params for the input images and their labels,\n        and params them based on the resampled reference grids.\n        :param inputs: a dict having multiple tensors\n            if labeled:\n                moving_image, shape = (batch, m_dim1, m_dim2, m_dim3)\n                fixed_image, shape = (batch, f_dim1, f_dim2, f_dim3)\n                moving_label, shape = (batch, m_dim1, m_dim2, m_dim3)\n                fixed_label, shape = (batch, f_dim1, f_dim2, f_dim3)\n                indices, shape = (batch, num_indices)\n            else, unlabeled:\n                moving_image, shape = (batch, m_dim1, m_dim2, m_dim3)\n                fixed_image, shape = (batch, f_dim1, f_dim2, f_dim3)\n                indices, shape = (batch, num_indices)\n        :param kwargs: other arguments\n        :return: dictionary with the same structure as inputs\n        \"\"\"", "\n", "\n", "moving_image", "=", "inputs", "[", "\"moving_image\"", "]", "\n", "fixed_image", "=", "inputs", "[", "\"fixed_image\"", "]", "\n", "indices", "=", "inputs", "[", "\"indices\"", "]", "\n", "\n", "moving_params", ",", "fixed_params", "=", "self", ".", "gen_transform_params", "(", ")", "\n", "\n", "moving_image", "=", "self", ".", "transform", "(", "moving_image", ",", "self", ".", "moving_grid_ref", ",", "moving_params", ")", "\n", "fixed_image", "=", "self", ".", "transform", "(", "fixed_image", ",", "self", ".", "fixed_grid_ref", ",", "fixed_params", ")", "\n", "\n", "if", "\"moving_label\"", "not", "in", "inputs", ":", "# unlabeled", "\n", "            ", "return", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "fixed_image", "=", "fixed_image", ",", "indices", "=", "indices", "\n", ")", "\n", "", "moving_label", "=", "inputs", "[", "\"moving_label\"", "]", "\n", "fixed_label", "=", "inputs", "[", "\"fixed_label\"", "]", "\n", "\n", "moving_label", "=", "self", ".", "transform", "(", "moving_label", ",", "self", ".", "moving_grid_ref", ",", "moving_params", ")", "\n", "fixed_label", "=", "self", ".", "transform", "(", "fixed_label", ",", "self", ".", "fixed_grid_ref", ",", "fixed_params", ")", "\n", "\n", "return", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "moving_label", "=", "moving_label", ",", "\n", "fixed_label", "=", "fixed_label", ",", "\n", "indices", "=", "indices", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomTransformation3D.get_config": [[114, 121], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", "[", "\"moving_image_size\"", "]", "=", "self", ".", "moving_image_size", "\n", "config", "[", "\"fixed_image_size\"", "]", "=", "self", ".", "fixed_image_size", "\n", "config", "[", "\"batch_size\"", "]", "=", "self", ".", "batch_size", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomAffineTransform3D.__init__": [[127, 154], ["preprocess.RandomTransformation3D.__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "moving_image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "fixed_image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "batch_size", ":", "int", ",", "\n", "scale", ":", "float", "=", "0.1", ",", "\n", "name", ":", "str", "=", "\"RandomAffineTransform3D\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param moving_image_size: (m_dim1, m_dim2, m_dim3)\n        :param fixed_image_size: (f_dim1, f_dim2, f_dim3)\n        :param batch_size: total number of samples consumed per step, over all devices.\n        :param scale: a positive float controlling the scale of transformation\n        :param name: name of the layer\n        :param kwargs: additional arguments\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "moving_image_size", "=", "moving_image_size", ",", "\n", "fixed_image_size", "=", "fixed_image_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomAffineTransform3D.get_config": [[155, 160], ["preprocess.RandomTransformation3D.get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", "[", "\"scale\"", "]", "=", "self", ".", "scale", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomAffineTransform3D.gen_transform_params": [[161, 172], ["preprocess.gen_rand_affine_transform"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_affine_transform"], ["", "def", "gen_transform_params", "(", "self", ")", "->", "Tuple", "[", "tf", ".", "Tensor", ",", "tf", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Function that generates the random 3D transformation parameters\n        for a batch of data for moving and fixed image.\n\n        :return: a tuple of tensors, each has shape = (batch, 4, 3)\n        \"\"\"", "\n", "theta", "=", "gen_rand_affine_transform", "(", "\n", "batch_size", "=", "self", ".", "batch_size", "*", "2", ",", "scale", "=", "self", ".", "scale", "\n", ")", "\n", "return", "theta", "[", ":", "self", ".", "batch_size", "]", ",", "theta", "[", "self", ".", "batch_size", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomAffineTransform3D.transform": [[173, 186], ["deepreg.model.layer_util.resample", "deepreg.model.layer_util.warp_grid"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.warp_grid"], ["", "@", "staticmethod", "\n", "def", "transform", "(", "\n", "image", ":", "tf", ".", "Tensor", ",", "grid_ref", ":", "tf", ".", "Tensor", ",", "params", ":", "tf", ".", "Tensor", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Transforms the reference grid and then resample the image.\n\n        :param image: shape = (batch, dim1, dim2, dim3)\n        :param grid_ref: shape = (dim1, dim2, dim3, 3)\n        :param params: shape = (batch, 4, 3)\n        :return: shape = (batch, dim1, dim2, dim3)\n        \"\"\"", "\n", "return", "resample", "(", "vol", "=", "image", ",", "loc", "=", "warp_grid", "(", "grid_ref", ",", "params", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.__init__": [[192, 233], ["preprocess.RandomTransformation3D.__init__", "tuple", "tuple", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "moving_image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "fixed_image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "batch_size", ":", "int", ",", "\n", "field_strength", ":", "int", "=", "1", ",", "\n", "low_res_size", ":", "tuple", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "name", ":", "str", "=", "\"RandomDDFTransform3D\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Creates a DDF transformation for data augmentation.\n\n        To simulate smooth deformation fields, we interpolate from a low resolution\n        field of size low_res_size using linear interpolation. The variance of the\n        deformation field is drawn from a uniform variable\n        between [0, field_strength].\n\n        :param moving_image_size: tuple\n        :param fixed_image_size: tuple\n        :param batch_size: total number of samples consumed per step, over all devices.\n        :param field_strength: int = 1. It is used as the upper bound for the\n        deformation field variance\n        :param low_res_size: tuple = (1, 1, 1).\n        :param name: name of layer\n        :param kwargs: additional arguments\n        \"\"\"", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "moving_image_size", "=", "moving_image_size", ",", "\n", "fixed_image_size", "=", "fixed_image_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "assert", "tuple", "(", "low_res_size", ")", "<=", "tuple", "(", "moving_image_size", ")", "\n", "assert", "tuple", "(", "low_res_size", ")", "<=", "tuple", "(", "fixed_image_size", ")", "\n", "\n", "self", ".", "field_strength", "=", "field_strength", "\n", "self", ".", "low_res_size", "=", "low_res_size", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.get_config": [[234, 240], ["preprocess.RandomTransformation3D.get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", "[", "\"field_strength\"", "]", "=", "self", ".", "field_strength", "\n", "config", "[", "\"low_res_size\"", "]", "=", "self", ".", "low_res_size", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.gen_transform_params": [[241, 261], ["preprocess.gen_rand_ddf", "preprocess.gen_rand_ddf"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_ddf", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_ddf"], ["", "def", "gen_transform_params", "(", "self", ")", "->", "Tuple", "[", "tf", ".", "Tensor", ",", "tf", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Generates two random ddf fields for moving and fixed images.\n\n        :return: tuple, one has shape = (batch, m_dim1, m_dim2, m_dim3, 3)\n            another one has shape = (batch, f_dim1, f_dim2, f_dim3, 3)\n        \"\"\"", "\n", "moving", "=", "gen_rand_ddf", "(", "\n", "image_size", "=", "self", ".", "moving_image_size", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "field_strength", "=", "self", ".", "field_strength", ",", "\n", "low_res_size", "=", "self", ".", "low_res_size", ",", "\n", ")", "\n", "fixed", "=", "gen_rand_ddf", "(", "\n", "image_size", "=", "self", ".", "fixed_image_size", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "field_strength", "=", "self", ".", "field_strength", ",", "\n", "low_res_size", "=", "self", ".", "low_res_size", ",", "\n", ")", "\n", "return", "moving", ",", "fixed", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.RandomDDFTransform3D.transform": [[262, 275], ["deepreg.model.layer_util.resample"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample"], ["", "@", "staticmethod", "\n", "def", "transform", "(", "\n", "image", ":", "tf", ".", "Tensor", ",", "grid_ref", ":", "tf", ".", "Tensor", ",", "params", ":", "tf", ".", "Tensor", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Transforms the reference grid and then resample the image.\n\n        :param image: shape = (batch, dim1, dim2, dim3)\n        :param grid_ref: shape = (dim1, dim2, dim3, 3)\n        :param params: DDF, shape = (batch, dim1, dim2, dim3, 3)\n        :return: shape = (batch, dim1, dim2, dim3)\n        \"\"\"", "\n", "return", "resample", "(", "vol", "=", "image", ",", "loc", "=", "grid_ref", "[", "None", ",", "...", "]", "+", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.resize_inputs": [[277, 333], ["deepreg.model.layer.Resize3d", "deepreg.model.layer.Resize3d", "deepreg.model.layer.Resize3d.", "deepreg.model.layer.Resize3d.", "deepreg.model.layer.Resize3d.", "deepreg.model.layer.Resize3d.", "dict", "dict"], "function", ["None"], ["", "", "def", "resize_inputs", "(", "\n", "inputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", "moving_image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "fixed_image_size", ":", "tuple", ",", "\n", ")", "->", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Resize inputs\n    :param inputs:\n        if labeled:\n            moving_image, shape = (None, None, None)\n            fixed_image, shape = (None, None, None)\n            moving_label, shape = (None, None, None)\n            fixed_label, shape = (None, None, None)\n            indices, shape = (num_indices, )\n        else, unlabeled:\n            moving_image, shape = (None, None, None)\n            fixed_image, shape = (None, None, None)\n            indices, shape = (num_indices, )\n    :param moving_image_size: Tuple[int, ...], (m_dim1, m_dim2, m_dim3)\n    :param fixed_image_size: Tuple[int, ...], (f_dim1, f_dim2, f_dim3)\n    :return:\n        if labeled:\n            moving_image, shape = (m_dim1, m_dim2, m_dim3)\n            fixed_image, shape = (f_dim1, f_dim2, f_dim3)\n            moving_label, shape = (m_dim1, m_dim2, m_dim3)\n            fixed_label, shape = (f_dim1, f_dim2, f_dim3)\n            indices, shape = (num_indices, )\n        else, unlabeled:\n            moving_image, shape = (m_dim1, m_dim2, m_dim3)\n            fixed_image, shape = (f_dim1, f_dim2, f_dim3)\n            indices, shape = (num_indices, )\n    \"\"\"", "\n", "moving_image", "=", "inputs", "[", "\"moving_image\"", "]", "\n", "fixed_image", "=", "inputs", "[", "\"fixed_image\"", "]", "\n", "indices", "=", "inputs", "[", "\"indices\"", "]", "\n", "\n", "moving_resize_layer", "=", "Resize3d", "(", "shape", "=", "moving_image_size", ")", "\n", "fixed_resize_layer", "=", "Resize3d", "(", "shape", "=", "fixed_image_size", ")", "\n", "\n", "moving_image", "=", "moving_resize_layer", "(", "moving_image", ")", "\n", "fixed_image", "=", "fixed_resize_layer", "(", "fixed_image", ")", "\n", "\n", "if", "\"moving_label\"", "not", "in", "inputs", ":", "# unlabeled", "\n", "        ", "return", "dict", "(", "moving_image", "=", "moving_image", ",", "fixed_image", "=", "fixed_image", ",", "indices", "=", "indices", ")", "\n", "", "moving_label", "=", "inputs", "[", "\"moving_label\"", "]", "\n", "fixed_label", "=", "inputs", "[", "\"fixed_label\"", "]", "\n", "\n", "moving_label", "=", "moving_resize_layer", "(", "moving_label", ")", "\n", "fixed_label", "=", "fixed_resize_layer", "(", "fixed_label", ")", "\n", "\n", "return", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "moving_label", "=", "moving_label", ",", "\n", "fixed_label", "=", "fixed_label", ",", "\n", "indices", "=", "indices", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_affine_transform": [[336, 461], ["numpy.random.seed", "numpy.random.uniform", "numpy.tile", "numpy.array", "tensorflow.cast", "numpy.linalg.lstsq", "range"], "function", ["None"], ["", "def", "gen_rand_affine_transform", "(", "\n", "batch_size", ":", "int", ",", "scale", ":", "float", ",", "seed", ":", "Optional", "[", "int", "]", "=", "None", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Function that generates a random 3D transformation parameters for a batch of data.\n\n    for 3D coordinates, affine transformation is\n\n    .. code-block:: text\n\n        [[x' y' z' 1]] = [[x y z 1]] * [[* * * 0]\n                                        [* * * 0]\n                                        [* * * 0]\n                                        [* * * 1]]\n\n    where each * represents a degree of freedom,\n    so there are in total 12 degrees of freedom\n    the equation can be denoted as\n\n        new = old * T\n\n    where\n\n    - new is the transformed coordinates, of shape (1, 4)\n    - old is the original coordinates, of shape (1, 4)\n    - T is the transformation matrix, of shape (4, 4)\n\n    the equation can be simplified to\n\n    .. code-block:: text\n\n        [[x' y' z']] = [[x y z 1]] * [[* * *]\n                                      [* * *]\n                                      [* * *]\n                                      [* * *]]\n\n    so that\n\n        new = old * T\n\n    where\n\n    - new is the transformed coordinates, of shape (1, 3)\n    - old is the original coordinates, of shape (1, 4)\n    - T is the transformation matrix, of shape (4, 3)\n\n    Given original and transformed coordinates,\n    we can calculate the transformation matrix using\n\n        x = np.linalg.lstsq(a, b)\n\n    such that\n\n        a x = b\n\n    In our case,\n\n    - a = old\n    - b = new\n    - x = T\n\n    To generate random transformation,\n    we choose to add random perturbation to corner coordinates as follows:\n    for corner of coordinates (x, y, z), the noise is\n\n        -(x, y, z) .* (r1, r2, r3)\n\n    where ri is a random number between (0, scale).\n    So\n\n        (x', y', z') = (x, y, z) .* (1-r1, 1-r2, 1-r3)\n\n    Thus, we can directly sample between 1-scale and 1 instead\n\n    We choose to calculate the transformation based on\n    four corners in a cube centered at (0, 0, 0).\n    A cube is shown as below, where\n\n    - C = (-1, -1, -1)\n    - G = (-1, -1, 1)\n    - D = (-1, 1, -1)\n    - A = (1, -1, -1)\n\n    .. code-block:: text\n\n                    G \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 H\n                  / |               / |\n                /   |             /   |\n              /     |           /     |\n            /       |         /       |\n          /         |       /         |\n        E \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 F           |\n        |           |     |           |\n        |           |     |           |\n        |           C \u2014 \u2014 | \u2014 \u2014 \u2014 \u2014 \u2014 D\n        |         /       |         /\n        |       /         |       /\n        |     /           |     /\n        |   /             |   /\n        | /               | /\n        A \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 B\n\n    :param batch_size: total number of samples consumed per step, over all devices.\n    :param scale: a float number between 0 and 1\n    :param seed: control the randomness\n    :return: shape = (batch, 4, 3)\n    \"\"\"", "\n", "\n", "assert", "0", "<=", "scale", "<=", "1", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "1", "-", "scale", ",", "1", ",", "[", "batch_size", ",", "4", ",", "3", "]", ")", "# shape = (batch, 4, 3)", "\n", "\n", "# old represents four corners of a cube", "\n", "# corresponding to the corner C G D A as shown above", "\n", "old", "=", "np", ".", "tile", "(", "\n", "[", "[", "[", "-", "1", ",", "-", "1", ",", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", ",", "1", ",", "1", "]", ",", "[", "-", "1", ",", "1", ",", "-", "1", ",", "1", "]", ",", "[", "1", ",", "-", "1", ",", "-", "1", ",", "1", "]", "]", "]", ",", "\n", "[", "batch_size", ",", "1", ",", "1", "]", ",", "\n", ")", "# shape = (batch, 4, 4)", "\n", "new", "=", "old", "[", ":", ",", ":", ",", ":", "3", "]", "*", "noise", "# shape = (batch, 4, 3)", "\n", "\n", "theta", "=", "np", ".", "array", "(", "\n", "[", "np", ".", "linalg", ".", "lstsq", "(", "old", "[", "k", "]", ",", "new", "[", "k", "]", ",", "rcond", "=", "-", "1", ")", "[", "0", "]", "for", "k", "in", "range", "(", "batch_size", ")", "]", "\n", ")", "# shape = (batch, 4, 3)", "\n", "\n", "return", "tf", ".", "cast", "(", "theta", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.gen_rand_ddf": [[463, 489], ["numpy.random.seed", "numpy.random.uniform", "numpy.random.randn", "deepreg.model.layer.Resize3d"], "function", ["None"], ["", "def", "gen_rand_ddf", "(", "\n", "batch_size", ":", "int", ",", "\n", "image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "field_strength", ":", "Union", "[", "Tuple", ",", "List", ",", "int", ",", "float", "]", ",", "\n", "low_res_size", ":", "Union", "[", "Tuple", ",", "List", "]", ",", "\n", "seed", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Function that generates a random 3D DDF for a batch of data.\n\n    :param batch_size: total number of samples consumed per step, over all devices.\n    :param image_size:\n    :param field_strength: maximum field strength, computed as a U[0,field_strength]\n    :param low_res_size: low_resolution deformation field that will be upsampled to\n        the original size in order to get smooth and more realistic fields.\n    :param seed: control the randomness\n    :return:\n    \"\"\"", "\n", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "low_res_strength", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "field_strength", ",", "(", "batch_size", ",", "1", ",", "1", ",", "1", ",", "3", ")", ")", "\n", "low_res_field", "=", "low_res_strength", "*", "np", ".", "random", ".", "randn", "(", "\n", "batch_size", ",", "low_res_size", "[", "0", "]", ",", "low_res_size", "[", "1", "]", ",", "low_res_size", "[", "2", "]", ",", "3", "\n", ")", "\n", "high_res_field", "=", "Resize3d", "(", "shape", "=", "image_size", ")", "(", "low_res_field", ")", "\n", "return", "high_res_field", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_h5_sorted_keys": [[14, 22], ["h5py.File", "sorted", "h5_file.keys"], "function", ["None"], ["\n", "x", "=", "np", ".", "asarray", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "y", "=", "np", ".", "asarray", "(", "y", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_sorted_file_paths_in_dir_with_suffix": [[24, 49], ["isinstance", "sorted", "glob.glob", "os.path.join", "os.path.relpath", "len"], "function", ["None"], ["if", "x", ".", "shape", "!=", "y", ".", "shape", ":", "\n", "        ", "return", "False", "\n", "\n", "# check nan values", "\n", "# support case some values are nan", "\n", "", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "x", ")", "!=", "np", ".", "isnan", "(", "y", ")", ")", ":", "\n", "        ", "return", "False", "\n", "", "x", "=", "np", ".", "nan_to_num", "(", "x", ")", "\n", "y", "=", "np", ".", "nan_to_num", "(", "y", ")", "\n", "\n", "# check values", "\n", "return", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "y", ",", "atol", "=", "atol", ")", ")", "\n", "\n", "\n", "", "def", "is_equal_tf", "(", "\n", "x", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "y", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "atol", ":", "float", "=", "EPS", ",", "\n", ")", "->", "bool", ":", "\n", "    "]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists": [[51, 62], ["len", "ValueError", "itertools.zip_longest"], "function", ["None"], ["x", "=", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "y", "=", "tf", ".", "cast", "(", "y", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "return", "is_equal_np", "(", "x", "=", "x", ",", "y", "=", "y", ",", "atol", "=", "atol", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_label_indices": [[64, 78], ["random.randrange", "list", "ValueError", "range"], "function", ["None"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.paired_loader.PairedDataLoader.__init__": [[25, 78], ["deepreg.dataset.loader.interface.AbstractPairedDataLoader.__init__", "isinstance", "file_loader", "file_loader", "paired_loader.PairedDataLoader.validate_data_files", "paired_loader.PairedDataLoader.loader_moving_image.get_num_images", "isinstance", "file_loader", "file_loader"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.validate_data_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images"], ["def", "__init__", "(", "\n", "self", ",", "\n", "file_loader", ",", "\n", "data_dir_paths", ":", "List", "[", "str", "]", ",", "\n", "labeled", ":", "bool", ",", "\n", "sample_label", ":", "str", ",", "\n", "seed", ",", "\n", "moving_image_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "List", "[", "int", "]", "]", ",", "\n", "fixed_image_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "List", "[", "int", "]", "]", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param file_loader:\n        :param data_dir_paths: path of the directories storing data,\n          the data has to be saved under four different\n          sub-directories: moving_images, fixed_images, moving_labels,\n          fixed_labels\n        :param labeled: true if the data are labeled\n        :param sample_label:\n        :param seed:\n        :param moving_image_shape: (width, height, depth)\n        :param fixed_image_shape: (width, height, depth)\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "moving_image_shape", "=", "moving_image_shape", ",", "\n", "fixed_image_shape", "=", "fixed_image_shape", ",", "\n", "labeled", "=", "labeled", ",", "\n", "sample_label", "=", "sample_label", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "assert", "isinstance", "(", "\n", "data_dir_paths", ",", "list", "\n", ")", ",", "f\"data_dir_paths must be list of strings, got {data_dir_paths}\"", "\n", "\n", "for", "ddp", "in", "data_dir_paths", ":", "\n", "            ", "assert", "isinstance", "(", "\n", "ddp", ",", "str", "\n", ")", ",", "f\"data_dir_paths must be list of strings, got {data_dir_paths}\"", "\n", "\n", "", "self", ".", "loader_moving_image", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_paths", ",", "name", "=", "\"moving_images\"", ",", "grouped", "=", "False", "\n", ")", "\n", "self", ".", "loader_fixed_image", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_paths", ",", "name", "=", "\"fixed_images\"", ",", "grouped", "=", "False", "\n", ")", "\n", "if", "self", ".", "labeled", ":", "\n", "            ", "self", ".", "loader_moving_label", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_paths", ",", "name", "=", "\"moving_labels\"", ",", "grouped", "=", "False", "\n", ")", "\n", "self", ".", "loader_fixed_label", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_paths", ",", "name", "=", "\"fixed_labels\"", ",", "grouped", "=", "False", "\n", ")", "\n", "", "self", ".", "validate_data_files", "(", ")", "\n", "self", ".", "num_images", "=", "self", ".", "loader_moving_image", ".", "get_num_images", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.paired_loader.PairedDataLoader.validate_data_files": [[79, 100], ["paired_loader.PairedDataLoader.loader_moving_image.get_data_ids", "paired_loader.PairedDataLoader.loader_fixed_image.get_data_ids", "deepreg.dataset.util.check_difference_between_two_lists", "paired_loader.PairedDataLoader.loader_moving_label.get_data_ids", "paired_loader.PairedDataLoader.loader_fixed_label.get_data_ids", "deepreg.dataset.util.check_difference_between_two_lists", "deepreg.dataset.util.check_difference_between_two_lists"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists"], ["", "def", "validate_data_files", "(", "self", ")", ":", "\n", "        ", "\"\"\"Verify all loaders have the same files.\"\"\"", "\n", "moving_image_ids", "=", "self", ".", "loader_moving_image", ".", "get_data_ids", "(", ")", "\n", "fixed_image_ids", "=", "self", ".", "loader_fixed_image", ".", "get_data_ids", "(", ")", "\n", "check_difference_between_two_lists", "(", "\n", "list1", "=", "moving_image_ids", ",", "\n", "list2", "=", "fixed_image_ids", ",", "\n", "name", "=", "\"moving and fixed images in paired loader\"", ",", "\n", ")", "\n", "if", "self", ".", "labeled", ":", "\n", "            ", "moving_label_ids", "=", "self", ".", "loader_moving_label", ".", "get_data_ids", "(", ")", "\n", "fixed_label_ids", "=", "self", ".", "loader_fixed_label", ".", "get_data_ids", "(", ")", "\n", "check_difference_between_two_lists", "(", "\n", "list1", "=", "moving_image_ids", ",", "\n", "list2", "=", "moving_label_ids", ",", "\n", "name", "=", "\"moving images and labels in paired loader\"", ",", "\n", ")", "\n", "check_difference_between_two_lists", "(", "\n", "list1", "=", "moving_image_ids", ",", "\n", "list2", "=", "fixed_label_ids", ",", "\n", "name", "=", "\"fixed images and labels in paired loader\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.paired_loader.PairedDataLoader.sample_index_generator": [[102, 111], ["random.Random().shuffle", "range", "random.Random"], "methods", ["None"], ["", "", "def", "sample_index_generator", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Generate indexes in order to load data using the\n        GeneratorDataLoader class.\n        \"\"\"", "\n", "image_indices", "=", "[", "i", "for", "i", "in", "range", "(", "self", ".", "num_images", ")", "]", "\n", "random", ".", "Random", "(", "self", ".", "seed", ")", ".", "shuffle", "(", "image_indices", ")", "\n", "for", "image_index", "in", "image_indices", ":", "\n", "            ", "yield", "image_index", ",", "image_index", ",", "[", "image_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.paired_loader.PairedDataLoader.close": [[112, 118], ["paired_loader.PairedDataLoader.loader_moving_image.close", "paired_loader.PairedDataLoader.loader_fixed_image.close", "paired_loader.PairedDataLoader.loader_moving_label.close", "paired_loader.PairedDataLoader.loader_fixed_label.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "loader_moving_image", ".", "close", "(", ")", "\n", "self", ".", "loader_fixed_image", ".", "close", "(", ")", "\n", "if", "self", ".", "labeled", ":", "\n", "            ", "self", ".", "loader_moving_label", ".", "close", "(", ")", "\n", "self", ".", "loader_fixed_label", ".", "close", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.h5_loader.H5FileLoader.__init__": [[20, 35], ["deepreg.dataset.loader.interface.FileLoader.__init__", "h5_loader.H5FileLoader.set_data_structure", "h5_loader.H5FileLoader.set_group_structure"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.set_data_structure", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.set_group_structure"], ["def", "__init__", "(", "self", ",", "dir_paths", ":", "List", "[", "str", "]", ",", "name", ":", "str", ",", "grouped", ":", "bool", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param dir_paths: path of h5 files.\n        :param name: name is used to identify the file names.\n        :param grouped: whether the data is grouped.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "name", ",", "grouped", "=", "grouped", ")", "\n", "self", ".", "h5_files", "=", "None", "\n", "self", ".", "data_path_splits", "=", "None", "\n", "self", ".", "set_data_structure", "(", ")", "\n", "self", ".", "group_struct", "=", "None", "\n", "if", "self", ".", "grouped", ":", "\n", "            ", "self", ".", "set_group_structure", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.h5_loader.H5FileLoader.set_data_structure": [[36, 78], ["os.path.join", "os.path.exists", "h5py.File", "len", "ValueError", "all", "k.split", "sorted", "sorted", "h5py.File.keys", "h5py.File.keys", "len"], "methods", ["None"], ["", "", "def", "set_data_structure", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Store the data structure in  memory so that\n        we can retrieve data using data_index.\n        This function sets two attributes:\n\n        - h5_files, a dict such that h5_files[dir_path] = opened h5 file handle\n        - data_path_splits, a list of string tuples to identify path of data\n\n          - if grouped, a split is (dir_path, group_name, data_key) such that\n            data = h5_files[dir_path][\"group-{group_name}-{data_key}\"]\n          - if not grouped, a split is (dir_path, data_key) such that\n            data = h5_files[dir_path][data_key]\n        \"\"\"", "\n", "h5_files", "=", "{", "}", "\n", "data_path_splits", "=", "[", "]", "\n", "for", "dir_path", "in", "self", ".", "dir_paths", ":", "\n", "            ", "h5_file_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "self", ".", "name", "+", "\".h5\"", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "\n", "h5_file_path", "\n", ")", ",", "f\"h5 file {h5_file_path} does not exist\"", "\n", "h5_file", "=", "h5py", ".", "File", "(", "h5_file_path", ",", "\"r\"", ")", "\n", "h5_files", "[", "dir_path", "]", "=", "h5_file", "\n", "\n", "if", "self", ".", "grouped", ":", "\n", "# each element is (dir_path, group_name, data_key)", "\n", "# check h5 file keys", "\n", "                ", "key_splits", "=", "[", "k", ".", "split", "(", "\"-\"", ")", "for", "k", "in", "sorted", "(", "h5_file", ".", "keys", "(", ")", ")", "]", "\n", "assert", "all", "(", "\n", "[", "len", "(", "x", ")", "==", "3", "and", "x", "[", "0", "]", "==", "\"group\"", "for", "x", "in", "key_splits", "]", "\n", ")", ",", "f\"h5_file keys must be of form group-X-Y, got {key_splits}\"", "\n", "data_path_splits", "+=", "[", "(", "dir_path", ",", "k", "[", "1", "]", ",", "k", "[", "2", "]", ")", "for", "k", "in", "key_splits", "]", "\n", "", "else", ":", "\n", "# each element is (dir_path, data_key)", "\n", "                ", "data_path_splits", "+=", "[", "(", "dir_path", ",", "k", ")", "for", "k", "in", "sorted", "(", "h5_file", ".", "keys", "(", ")", ")", "]", "\n", "", "", "if", "len", "(", "data_path_splits", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"No data collected from {self.dir_paths} in H5FileLoader, \"", "\n", "f\"please verify the path is correct.\"", "\n", ")", "\n", "", "self", ".", "h5_files", "=", "h5_files", "\n", "self", ".", "data_path_splits", "=", "data_path_splits", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.h5_loader.H5FileLoader.set_group_structure": [[79, 100], ["enumerate", "sorted", "group_struct_dict[].append", "group_struct_dict.keys", "group_struct.append", "group_struct_dict.keys"], "methods", ["None"], ["", "def", "set_group_structure", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Similar to NiftiLoader\n        as the first two tokens of a split forms a group_id.\n        Store the group structure in group_struct so that\n        group_struct[group_index] = list of data_index.\n        Retrieve data using (group_index, in_group_data_index).\n        data_index = group_struct[group_index][in_group_data_index].\n        \"\"\"", "\n", "# group_struct_dict[group_id] = list of data_index", "\n", "group_struct_dict", "=", "{", "}", "\n", "for", "data_index", ",", "split", "in", "enumerate", "(", "self", ".", "data_path_splits", ")", ":", "\n", "            ", "group_id", "=", "split", "[", ":", "2", "]", "\n", "if", "group_id", "not", "in", "group_struct_dict", ".", "keys", "(", ")", ":", "\n", "                ", "group_struct_dict", "[", "group_id", "]", "=", "[", "]", "\n", "", "group_struct_dict", "[", "group_id", "]", ".", "append", "(", "data_index", ")", "\n", "# group_struct[group_index] = list of data_index", "\n", "", "group_struct", "=", "[", "]", "\n", "for", "k", "in", "sorted", "(", "group_struct_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "group_struct", ".", "append", "(", "group_struct_dict", "[", "k", "]", ")", "\n", "", "self", ".", "group_struct", "=", "group_struct", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.h5_loader.H5FileLoader.get_data": [[101, 136], ["isinstance", "numpy.asarray", "isinstance", "DATA_KEY_FORMAT.format", "ValueError", "len"], "methods", ["None"], ["", "def", "get_data", "(", "self", ",", "index", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Get one data array by specifying an index\n\n        :param index: the data index which is required\n\n          - for paired or unpaired, the index is one single int, data_index\n          - for grouped, the index is a tuple of two ints,\n            (group_index, in_group_data_index)\n        :returns arr: the data array at the specified index\n        \"\"\"", "\n", "assert", "self", ".", "data_path_splits", "is", "not", "None", "\n", "if", "isinstance", "(", "index", ",", "int", ")", ":", "# paired or unpaired", "\n", "            ", "assert", "not", "self", ".", "grouped", "\n", "assert", "0", "<=", "index", "\n", "dir_path", ",", "data_key", "=", "self", ".", "data_path_splits", "[", "index", "]", "\n", "", "elif", "isinstance", "(", "index", ",", "tuple", ")", ":", "\n", "            ", "assert", "self", ".", "grouped", "\n", "group_index", ",", "in_group_data_index", "=", "index", "\n", "assert", "0", "<=", "group_index", "\n", "assert", "0", "<=", "in_group_data_index", "\n", "data_index", "=", "self", ".", "group_struct", "[", "group_index", "]", "[", "in_group_data_index", "]", "\n", "dir_path", ",", "group_name", ",", "data_key", "=", "self", ".", "data_path_splits", "[", "data_index", "]", "\n", "data_key", "=", "DATA_KEY_FORMAT", ".", "format", "(", "group_name", ",", "data_key", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"index for H5FileLoader.get_data must be int, \"", "\n", "f\"or tuple of length two, got {index}\"", "\n", ")", "\n", "", "arr", "=", "np", ".", "asarray", "(", "self", ".", "h5_files", "[", "dir_path", "]", "[", "data_key", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "len", "(", "arr", ".", "shape", ")", "==", "4", "and", "arr", ".", "shape", "[", "3", "]", "==", "1", ":", "\n", "# for labels, if there's only one label, remove the last dimension", "\n", "# currently have not encountered", "\n", "            ", "arr", "=", "arr", "[", ":", ",", ":", ",", ":", ",", "0", "]", "# pragma: no cover", "\n", "", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.h5_loader.H5FileLoader.get_data_ids": [[137, 147], ["None"], "methods", ["None"], ["", "def", "get_data_ids", "(", "self", ")", "->", "List", ":", "\n", "        ", "\"\"\"\n        Get the unique IDs of data in this data set to\n        verify consistency between\n        images and label, moving and fixed.\n\n        :return: data_path_splits as the data can be identified\n            using dir_path and data_key\n        \"\"\"", "\n", "return", "self", ".", "data_path_splits", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.h5_loader.H5FileLoader.get_num_images": [[148, 153], ["len"], "methods", ["None"], ["", "def", "get_num_images", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        :return: int, number of images in this data set\n        \"\"\"", "\n", "return", "len", "(", "self", ".", "data_path_splits", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.h5_loader.H5FileLoader.close": [[154, 158], ["h5_loader.H5FileLoader.h5_files.values", "f.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close opened h5 file handles.\"\"\"", "\n", "for", "f", "in", "self", ".", "h5_files", ".", "values", "(", ")", ":", "\n", "            ", "f", ".", "close", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.NiftiFileLoader.__init__": [[30, 44], ["deepreg.dataset.loader.interface.FileLoader.__init__", "nifti_loader.NiftiFileLoader.set_data_structure", "nifti_loader.NiftiFileLoader.set_group_structure"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.set_data_structure", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.set_group_structure"], ["def", "__init__", "(", "self", ",", "dir_paths", ":", "List", "[", "str", "]", ",", "name", ":", "str", ",", "grouped", ":", "bool", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param dir_paths: path of directories having nifti files.\n        :param name: name is used to identify the subdirectories.\n        :param grouped: whether the data is grouped.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "dir_paths", "=", "dir_paths", ",", "name", "=", "name", ",", "grouped", "=", "grouped", ")", "\n", "self", ".", "data_path_splits", "=", "None", "\n", "self", ".", "set_data_structure", "(", ")", "\n", "self", ".", "group_struct", "=", "None", "\n", "if", "self", ".", "grouped", ":", "\n", "            ", "self", ".", "set_group_structure", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.NiftiFileLoader.set_data_structure": [[45, 87], ["sorted", "os.path.join", "os.path.exists", "deepreg.dataset.util.get_sorted_file_paths_in_dir_with_suffix", "len", "ValueError", "os.path.split"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_sorted_file_paths_in_dir_with_suffix"], ["", "", "def", "set_data_structure", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Store the data structure in the memory so that\n        we can retrieve data using data_index\n        this function sets data_path_splits,\n        a list of string tuples to identify path of data\n\n        - if grouped, a split is (dir_path, group_path, file_name, suffix)\n          data is stored in dir_path/name/group_path/file_name.suffix\n\n        - if not grouped, a split is (dir_path, file_name, suffix)\n          data is stored in dir_path/name/file_name.suffix\n\n        \"\"\"", "\n", "data_path_splits", "=", "[", "]", "\n", "for", "dir_path", "in", "self", ".", "dir_paths", ":", "\n", "# dir_path/name", "\n", "            ", "named_dir_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "self", ".", "name", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "\n", "named_dir_path", "\n", ")", ",", "f\"directory {named_dir_path} does not exist\"", "\n", "# each element is (file_path, suffix)", "\n", "data_paths", "=", "get_sorted_file_paths_in_dir_with_suffix", "(", "\n", "dir_path", "=", "named_dir_path", ",", "suffix", "=", "DATA_FILE_SUFFIX", "\n", ")", "\n", "if", "self", ".", "grouped", ":", "\n", "# each element is (dir_path, group_path, file_name, suffix)", "\n", "                ", "data_path_splits", "+=", "[", "\n", "(", "dir_path", ",", ")", "+", "os", ".", "path", ".", "split", "(", "file_path", ")", "+", "(", "suffix", ",", ")", "\n", "for", "file_path", ",", "suffix", "in", "data_paths", "\n", "]", "\n", "", "else", ":", "\n", "# each element is (dir_path, file_name, suffix)", "\n", "                ", "data_path_splits", "+=", "[", "\n", "(", "dir_path", ",", "file_path", ",", "suffix", ")", "for", "file_path", ",", "suffix", "in", "data_paths", "\n", "]", "\n", "", "", "if", "len", "(", "data_path_splits", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"No data collected from {self.dir_paths} in NiftiFileLoader, \"", "\n", "f\"please verify the path is correct.\"", "\n", ")", "\n", "", "self", ".", "data_path_splits", "=", "sorted", "(", "data_path_splits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.NiftiFileLoader.set_group_structure": [[88, 109], ["enumerate", "sorted", "group_struct_dict[].append", "group_struct_dict.keys", "group_struct.append", "group_struct_dict.keys"], "methods", ["None"], ["", "def", "set_group_structure", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        In addition to set_data_structure\n        store the group structure in the group_struct so that\n        group_struct[group_index] = list of data_index\n        we can retrieve data using (group_index, in_group_data_index)\n        data_index = group_struct[group_index][in_group_data_index]\n        \"\"\"", "\n", "# group_struct_dict[group_id] = list of data_index", "\n", "group_struct_dict", "=", "{", "}", "\n", "for", "data_index", ",", "split", "in", "enumerate", "(", "self", ".", "data_path_splits", ")", ":", "\n", "# we use (dir_path, group_path) as group_id", "\n", "            ", "group_id", "=", "split", "[", ":", "2", "]", "\n", "if", "group_id", "not", "in", "group_struct_dict", ".", "keys", "(", ")", ":", "\n", "                ", "group_struct_dict", "[", "group_id", "]", "=", "[", "]", "\n", "", "group_struct_dict", "[", "group_id", "]", ".", "append", "(", "data_index", ")", "\n", "# group_struct[group_index] = list of data_index", "\n", "", "group_struct", "=", "[", "]", "\n", "for", "k", "in", "sorted", "(", "group_struct_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "group_struct", ".", "append", "(", "group_struct_dict", "[", "k", "]", ")", "\n", "", "self", ".", "group_struct", "=", "group_struct", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.NiftiFileLoader.get_data": [[110, 153], ["isinstance", "nifti_loader.load_nifti_file", "isinstance", "ValueError", "os.path.join", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file"], ["", "def", "get_data", "(", "self", ",", "index", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Get one data array by specifying an index\n\n        :param index: the data index which is required\n\n          - for paired or unpaired, the index is one single int, data_index\n          - for grouped, the index is a tuple of two ints,\n            (group_index, in_group_data_index)\n        :returns arr: the data array at the specified index\n        \"\"\"", "\n", "if", "isinstance", "(", "index", ",", "int", ")", ":", "# paired or unpaired", "\n", "            ", "assert", "not", "self", ".", "grouped", "\n", "assert", "0", "<=", "index", "\n", "data_index", "=", "index", "\n", "", "elif", "isinstance", "(", "index", ",", "tuple", ")", ":", "# grouped", "\n", "            ", "assert", "self", ".", "grouped", "\n", "group_index", ",", "in_group_data_index", "=", "index", "\n", "assert", "0", "<=", "group_index", "\n", "assert", "0", "<=", "in_group_data_index", "\n", "data_index", "=", "self", ".", "group_struct", "[", "group_index", "]", "[", "in_group_data_index", "]", "# type: ignore", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"index for NiftiFileLoader.get_data must be int, \"", "\n", "f\"or tuple of length two, got {index}\"", "\n", ")", "\n", "# if not grouped:", "\n", "#   path  = dir_path/name/file_name.suffix", "\n", "#   split = (dir_path, file_name, suffix)", "\n", "# else:", "\n", "#   path  = dir_path/name/group_path/file_name.suffix", "\n", "#   split = (dir_path, group_path, file_name, suffix)", "\n", "", "path_splits", "=", "self", ".", "data_path_splits", "[", "data_index", "]", "# type: ignore", "\n", "path_splits", ",", "suffix", "=", "path_splits", "[", ":", "-", "1", "]", ",", "path_splits", "[", "-", "1", "]", "\n", "path_splits", "=", "path_splits", "[", ":", "1", "]", "+", "(", "self", ".", "name", ",", ")", "+", "path_splits", "[", "1", ":", "]", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "*", "path_splits", ")", "+", "\".\"", "+", "suffix", "\n", "\n", "arr", "=", "load_nifti_file", "(", "file_path", "=", "file_path", ")", "\n", "if", "len", "(", "arr", ".", "shape", ")", "==", "4", "and", "arr", ".", "shape", "[", "3", "]", "==", "1", ":", "\n", "# for labels, if there's only one label, remove the last dimension", "\n", "# currently have not encountered", "\n", "            ", "arr", "=", "arr", "[", ":", ",", ":", ",", ":", ",", "0", "]", "# pragma: no cover", "\n", "", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.NiftiFileLoader.get_data_ids": [[154, 163], ["None"], "methods", ["None"], ["", "def", "get_data_ids", "(", "self", ")", "->", "List", ":", "\n", "        ", "\"\"\"\n        Return the unique IDs of the data in this data set\n        this function is used to verify the consistency between\n        images and label, moving and fixed.\n\n        :return: data_path_splits but without suffix\n        \"\"\"", "\n", "return", "[", "x", "[", ":", "-", "1", "]", "for", "x", "in", "self", ".", "data_path_splits", "]", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.NiftiFileLoader.get_num_images": [[164, 169], ["len"], "methods", ["None"], ["", "def", "get_num_images", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        :return: int, number of images in this data set\n        \"\"\"", "\n", "return", "len", "(", "self", ".", "data_path_splits", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.NiftiFileLoader.close": [[170, 173], ["None"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close opened files.\"\"\"", "\n", "return", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.nifti_loader.load_nifti_file": [[14, 24], ["numpy.asarray", "ValueError", "file_path.endswith", "file_path.endswith", "nibabel.load"], "function", ["None"], ["def", "load_nifti_file", "(", "file_path", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    :param file_path: path of a Nifti file with suffix .nii or .nii.gz\n    :return: return the numpy array\n    \"\"\"", "\n", "if", "not", "(", "file_path", ".", "endswith", "(", "\".nii\"", ")", "or", "file_path", ".", "endswith", "(", "\".nii.gz\"", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Nifti file path must end with .nii or .nii.gz, got {file_path}.\"", "\n", ")", "\n", "", "return", "np", ".", "asarray", "(", "nib", ".", "load", "(", "file_path", ")", ".", "dataobj", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.grouped_loader.GroupedDataLoader.__init__": [[29, 125], ["deepreg.dataset.loader.interface.AbstractUnpairedDataLoader.__init__", "isinstance", "file_loader", "grouped_loader.GroupedDataLoader.validate_data_files", "grouped_loader.GroupedDataLoader.loader_moving_image.get_num_groups", "grouped_loader.GroupedDataLoader.loader_moving_image.get_num_images_per_group", "file_loader", "len", "ValueError", "ValueError", "grouped_loader.GroupedDataLoader.get_inter_sample_indices", "grouped_loader.GroupedDataLoader.get_intra_sample_indices"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.validate_data_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_groups", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images_per_group", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.grouped_loader.GroupedDataLoader.get_inter_sample_indices", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.grouped_loader.GroupedDataLoader.get_intra_sample_indices"], ["def", "__init__", "(", "\n", "self", ",", "\n", "file_loader", ",", "\n", "data_dir_paths", ":", "List", "[", "str", "]", ",", "\n", "labeled", ":", "bool", ",", "\n", "sample_label", ":", "Optional", "[", "str", "]", ",", "\n", "intra_group_prob", ":", "float", ",", "\n", "intra_group_option", ":", "str", ",", "\n", "sample_image_in_group", ":", "bool", ",", "\n", "seed", ":", "Optional", "[", "int", "]", ",", "\n", "image_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "List", "[", "int", "]", "]", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param file_loader: a subclass of FileLoader\n        :param data_dir_paths: paths of the directory storing data,\n          the data has to be saved under two different sub-directories:\n\n          - images\n          - labels\n\n        :param labeled: bool, true if the data is labeled, false if unlabeled\n        :param sample_label: \"sample\" or \"all\", read `get_label_indices`\n            in deepreg/dataset/util.py for more details.\n        :param intra_group_prob: float between 0 and 1,\n\n          - 0 means generating only inter-group samples,\n          - 1 means generating only intra-group samples\n\n        :param intra_group_option: str, \"forward\", \"backward, or \"unconstrained\"\n        :param sample_image_in_group: bool,\n\n          - if true, only one image pair will be yielded for each group,\n            so one epoch has num_groups pairs of data,\n          - if false, iterate through this loader will generate all possible pairs\n\n        :param seed: controls the randomness in sampling,\n            if seed=None, then the randomness is not fixed\n        :param image_shape: list or tuple of length 3,\n            corresponding to (dim1, dim2, dim3) of the 3D image\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "image_shape", "=", "image_shape", ",", "\n", "labeled", "=", "labeled", ",", "\n", "sample_label", "=", "sample_label", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "assert", "isinstance", "(", "\n", "data_dir_paths", ",", "list", "\n", ")", ",", "f\"data_dir_paths must be list of strings, got {data_dir_paths}\"", "\n", "# init", "\n", "# the indices for identifying an image pair is (group1, sample1, group2, sample2, label)", "\n", "self", ".", "num_indices", "=", "5", "\n", "self", ".", "intra_group_option", "=", "intra_group_option", "\n", "self", ".", "intra_group_prob", "=", "intra_group_prob", "\n", "self", ".", "sample_image_in_group", "=", "sample_image_in_group", "\n", "# set file loaders", "\n", "# grouped data are not paired data, so moving/fixed share the same file loader for images/labels", "\n", "loader_image", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_paths", ",", "name", "=", "\"images\"", ",", "grouped", "=", "True", "\n", ")", "\n", "self", ".", "loader_moving_image", "=", "loader_image", "\n", "self", ".", "loader_fixed_image", "=", "loader_image", "\n", "if", "self", ".", "labeled", "is", "True", ":", "\n", "            ", "loader_label", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_paths", ",", "name", "=", "\"labels\"", ",", "grouped", "=", "True", "\n", ")", "\n", "self", ".", "loader_moving_label", "=", "loader_label", "\n", "self", ".", "loader_fixed_label", "=", "loader_label", "\n", "", "self", ".", "validate_data_files", "(", ")", "\n", "# get group related stats", "\n", "self", ".", "num_groups", "=", "self", ".", "loader_moving_image", ".", "get_num_groups", "(", ")", "\n", "self", ".", "num_images_per_group", "=", "self", ".", "loader_moving_image", ".", "get_num_images_per_group", "(", ")", "\n", "if", "self", ".", "intra_group_prob", "<", "1", ":", "\n", "            ", "if", "self", ".", "num_groups", "<", "2", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"There are {self.num_groups} groups, \"", "\n", "f\"we need at least two groups for inter group sampling\"", "\n", ")", "\n", "# calculate number of samples and save pre-calculated sample indices", "\n", "", "", "if", "self", ".", "sample_image_in_group", "is", "True", ":", "\n", "# one image pair in each group (pair) will be yielded", "\n", "            ", "self", ".", "sample_indices", "=", "None", "\n", "self", ".", "_num_samples", "=", "self", ".", "num_groups", "\n", "", "else", ":", "\n", "# all possible pair in each group (pair) will be yielded", "\n", "            ", "if", "intra_group_prob", "not", "in", "[", "0", ",", "1", "]", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Mixing intra and inter groups is not supported\"", "\n", "\" when not sampling pairs.\"", "\n", ")", "\n", "", "if", "intra_group_prob", "==", "0", ":", "# inter group", "\n", "                ", "self", ".", "sample_indices", "=", "self", ".", "get_inter_sample_indices", "(", ")", "\n", "", "else", ":", "# intra group", "\n", "                ", "self", ".", "sample_indices", "=", "self", ".", "get_intra_sample_indices", "(", ")", "\n", "\n", "", "self", ".", "_num_samples", "=", "len", "(", "self", ".", "sample_indices", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.grouped_loader.GroupedDataLoader.validate_data_files": [[126, 135], ["grouped_loader.GroupedDataLoader.loader_moving_image.get_data_ids", "grouped_loader.GroupedDataLoader.loader_moving_label.get_data_ids", "deepreg.dataset.util.check_difference_between_two_lists"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists"], ["", "", "def", "validate_data_files", "(", "self", ")", ":", "\n", "        ", "\"\"\"If the data are labeled, verify image loader and label loader have the same files.\"\"\"", "\n", "if", "self", ".", "labeled", "is", "True", ":", "\n", "            ", "image_ids", "=", "self", ".", "loader_moving_image", ".", "get_data_ids", "(", ")", "\n", "label_ids", "=", "self", ".", "loader_moving_label", ".", "get_data_ids", "(", ")", "\n", "check_difference_between_two_lists", "(", "\n", "list1", "=", "image_ids", ",", "\n", "list2", "=", "label_ids", ",", "\n", "name", "=", "\"images and labels in grouped loader\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.grouped_loader.GroupedDataLoader.get_intra_sample_indices": [[137, 175], ["range", "range", "range", "range", "intra_sample_indices.append", "range", "range", "ValueError", "intra_sample_indices.append", "range", "intra_sample_indices.append", "intra_sample_indices.append"], "methods", ["None"], ["", "", "def", "get_intra_sample_indices", "(", "self", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Calculate the sample indices for intra-group sampling\n        The index to identify a sample is (group1, image1, group2, image2), means\n        - image1 of group1 is moving image\n        - image2 of group2 is fixed image\n\n        Assuming group i has ni images,\n        then in total the number of samples are\n        - sum( ni * (ni-1) / 2 ) for forward/backward\n        - sum( ni * (ni-1) ) for unconstrained\n\n        :return: a list of sample indices\n        \"\"\"", "\n", "intra_sample_indices", "=", "[", "]", "\n", "for", "group_index", "in", "range", "(", "self", ".", "num_groups", ")", ":", "\n", "            ", "num_images_in_group", "=", "self", ".", "num_images_per_group", "[", "group_index", "]", "\n", "if", "self", ".", "intra_group_option", "==", "\"forward\"", ":", "\n", "                ", "for", "i", "in", "range", "(", "num_images_in_group", ")", ":", "\n", "                    ", "for", "j", "in", "range", "(", "i", ")", ":", "\n", "# j < i", "\n", "                        ", "intra_sample_indices", ".", "append", "(", "(", "group_index", ",", "j", ",", "group_index", ",", "i", ")", ")", "\n", "", "", "", "elif", "self", ".", "intra_group_option", "==", "\"backward\"", ":", "\n", "                ", "for", "i", "in", "range", "(", "num_images_in_group", ")", ":", "\n", "                    ", "for", "j", "in", "range", "(", "i", ")", ":", "\n", "# i > j", "\n", "                        ", "intra_sample_indices", ".", "append", "(", "(", "group_index", ",", "i", ",", "group_index", ",", "j", ")", ")", "\n", "", "", "", "elif", "self", ".", "intra_group_option", "==", "\"unconstrained\"", ":", "\n", "                ", "for", "i", "in", "range", "(", "num_images_in_group", ")", ":", "\n", "                    ", "for", "j", "in", "range", "(", "i", ")", ":", "\n", "# j < i, i > j", "\n", "                        ", "intra_sample_indices", ".", "append", "(", "(", "group_index", ",", "j", ",", "group_index", ",", "i", ")", ")", "\n", "intra_sample_indices", ".", "append", "(", "(", "group_index", ",", "i", ",", "group_index", ",", "j", ")", ")", "\n", "", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Unknown intra_group_option, must be forward/backward/unconstrained\"", "\n", ")", "\n", "", "", "return", "intra_sample_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.grouped_loader.GroupedDataLoader.get_inter_sample_indices": [[176, 204], ["range", "range", "range", "range", "inter_sample_indices.append"], "methods", ["None"], ["", "def", "get_inter_sample_indices", "(", "self", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Calculate the sample indices for inter-group sampling\n        The index to identify a sample is (group1, image1, group2, image2), means\n\n          - image1 of group1 is moving image\n          - image2 of group2 is fixed image\n\n        All pairs of images in the dataset are registered.\n        Assuming group i has ni images and that N=[n1, n2, ..., nI],\n        then in total the number of samples are:\n        sum(N) * (sum(N)-1) - sum( N * (N-1) )\n\n        :return: a list of sample indices\n        \"\"\"", "\n", "inter_sample_indices", "=", "[", "]", "\n", "for", "group_index1", "in", "range", "(", "self", ".", "num_groups", ")", ":", "\n", "            ", "for", "group_index2", "in", "range", "(", "self", ".", "num_groups", ")", ":", "\n", "                ", "if", "group_index1", "==", "group_index2", ":", "# do not sample from the same group", "\n", "                    ", "continue", "\n", "", "num_images_in_group1", "=", "self", ".", "num_images_per_group", "[", "group_index1", "]", "\n", "num_images_in_group2", "=", "self", ".", "num_images_per_group", "[", "group_index2", "]", "\n", "for", "image_index1", "in", "range", "(", "num_images_in_group1", ")", ":", "\n", "                    ", "for", "image_index2", "in", "range", "(", "num_images_in_group2", ")", ":", "\n", "                        ", "inter_sample_indices", ".", "append", "(", "\n", "(", "group_index1", ",", "image_index1", ",", "group_index2", ",", "image_index2", ")", "\n", ")", "\n", "", "", "", "", "return", "inter_sample_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.grouped_loader.GroupedDataLoader.sample_index_generator": [[205, 280], ["random.Random", "random.Random.shuffle", "copy.deepcopy", "random.Random.shuffle", "range", "random.Random.random", "random.Random.sample", "random.Random.choice", "random.Random.choice", "random.Random.choice", "min", "max", "range", "max", "min", "ValueError", "range", "range", "range"], "methods", ["None"], ["", "def", "sample_index_generator", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Yield (moving_index, fixed_index, image_indices) sequentially, where\n\n          - moving_index = (group1, image1)\n          - fixed_index = (group2, image2)\n          - image_indices = [group1, image1, group2, image2]\n        \"\"\"", "\n", "rnd", "=", "random", ".", "Random", "(", "self", ".", "seed", ")", "# set random seed", "\n", "if", "self", ".", "sample_image_in_group", "is", "True", ":", "\n", "# for each group sample one image pair only", "\n", "            ", "group_indices", "=", "[", "i", "for", "i", "in", "range", "(", "self", ".", "num_groups", ")", "]", "\n", "rnd", ".", "shuffle", "(", "group_indices", ")", "\n", "for", "group_index", "in", "group_indices", ":", "\n", "                ", "if", "rnd", ".", "random", "(", ")", "<=", "self", ".", "intra_group_prob", ":", "\n", "# intra-group sampling", "\n", "# inside the group_index-th group, we sample two images as moving/fixed", "\n", "                    ", "group_index1", "=", "group_index", "\n", "group_index2", "=", "group_index", "\n", "num_images_in_group", "=", "self", ".", "num_images_per_group", "[", "group_index", "]", "\n", "if", "num_images_in_group", "<", "2", ":", "\n", "# skip groups having <2 images", "\n", "# currently have not encountered", "\n", "                        ", "continue", "# pragma: no cover", "\n", "\n", "", "image_index1", ",", "image_index2", "=", "rnd", ".", "sample", "(", "\n", "[", "i", "for", "i", "in", "range", "(", "num_images_in_group", ")", "]", ",", "2", "\n", ")", "# sample two unique indices", "\n", "if", "self", ".", "intra_group_option", "==", "\"forward\"", ":", "\n", "# image_index1 < image_index2", "\n", "                        ", "image_index1", ",", "image_index2", "=", "(", "\n", "min", "(", "image_index1", ",", "image_index2", ")", ",", "\n", "max", "(", "image_index1", ",", "image_index2", ")", ",", "\n", ")", "\n", "", "elif", "self", ".", "intra_group_option", "==", "\"backward\"", ":", "\n", "# image_index1 > image_index2", "\n", "                        ", "image_index1", ",", "image_index2", "=", "(", "\n", "max", "(", "image_index1", ",", "image_index2", ")", ",", "\n", "min", "(", "image_index1", ",", "image_index2", ")", ",", "\n", ")", "\n", "", "elif", "self", ".", "intra_group_option", "==", "\"unconstrained\"", ":", "\n", "                        ", "pass", "\n", "", "else", ":", "\n", "                        ", "raise", "ValueError", "(", "\n", "f\"Unknown intra_group_option, \"", "\n", "f\"must be forward/backward/unconstrained, \"", "\n", "f\"got {self.intra_group_option}\"", "\n", ")", "\n", "", "", "else", ":", "\n", "# inter-group sampling", "\n", "# we sample another group, then in each group we sample one image", "\n", "                    ", "group_index1", "=", "group_index", "\n", "group_index2", "=", "rnd", ".", "choice", "(", "\n", "[", "i", "for", "i", "in", "range", "(", "self", ".", "num_groups", ")", "if", "i", "!=", "group_index", "]", "\n", ")", "\n", "num_images_in_group1", "=", "self", ".", "num_images_per_group", "[", "group_index1", "]", "\n", "num_images_in_group2", "=", "self", ".", "num_images_per_group", "[", "group_index2", "]", "\n", "image_index1", "=", "rnd", ".", "choice", "(", "[", "i", "for", "i", "in", "range", "(", "num_images_in_group1", ")", "]", ")", "\n", "image_index2", "=", "rnd", ".", "choice", "(", "[", "i", "for", "i", "in", "range", "(", "num_images_in_group2", ")", "]", ")", "\n", "\n", "", "moving_index", "=", "(", "group_index1", ",", "image_index1", ")", "\n", "fixed_index", "=", "(", "group_index2", ",", "image_index2", ")", "\n", "image_indices", "=", "[", "group_index1", ",", "image_index1", ",", "group_index2", ",", "image_index2", "]", "\n", "yield", "moving_index", ",", "fixed_index", ",", "image_indices", "\n", "", "", "else", ":", "\n", "# sample indices are pre-calculated", "\n", "            ", "assert", "self", ".", "sample_indices", "is", "not", "None", "\n", "sample_indices", "=", "deepcopy", "(", "self", ".", "sample_indices", ")", "\n", "rnd", ".", "shuffle", "(", "sample_indices", ")", "# shuffle in place", "\n", "for", "sample_index", "in", "sample_indices", ":", "\n", "                ", "group_index1", ",", "image_index1", ",", "group_index2", ",", "image_index2", "=", "sample_index", "\n", "moving_index", "=", "(", "group_index1", ",", "image_index1", ")", "\n", "fixed_index", "=", "(", "group_index2", ",", "image_index2", ")", "\n", "image_indices", "=", "[", "group_index1", ",", "image_index1", ",", "group_index2", ",", "image_index2", "]", "\n", "yield", "moving_index", ",", "fixed_index", ",", "image_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.grouped_loader.GroupedDataLoader.close": [[281, 286], ["grouped_loader.GroupedDataLoader.loader_moving_image.close", "grouped_loader.GroupedDataLoader.loader_moving_label.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close file loaders\"\"\"", "\n", "self", ".", "loader_moving_image", ".", "close", "(", ")", "\n", "if", "self", ".", "labeled", "is", "True", ":", "\n", "            ", "self", ".", "loader_moving_label", ".", "close", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.__init__": [[25, 59], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "labeled", ":", "Optional", "[", "bool", "]", ",", "\n", "num_indices", ":", "Optional", "[", "int", "]", ",", "\n", "sample_label", ":", "Optional", "[", "str", "]", ",", "\n", "seed", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param labeled: bool corresponding to labels provided or omitted\n        :param num_indices:\n        :param sample_label:\n        :param seed:\n        \"\"\"", "\n", "assert", "labeled", "in", "[", "\n", "True", ",", "\n", "False", ",", "\n", "None", ",", "\n", "]", ",", "f\"labeled must be boolean, True or False or None, got {labeled}\"", "\n", "assert", "sample_label", "in", "[", "\n", "\"sample\"", ",", "\n", "\"all\"", ",", "\n", "None", ",", "\n", "]", ",", "f\"sample_label must be sample, all or None, got {sample_label}\"", "\n", "assert", "(", "\n", "num_indices", "is", "None", "or", "num_indices", ">=", "1", "\n", ")", ",", "f\"num_indices must be int >=1 or None, got {num_indices}\"", "\n", "assert", "seed", "is", "None", "or", "isinstance", "(", "\n", "seed", ",", "int", "\n", ")", ",", "f\"seed must be None or int, got {seed}\"", "\n", "\n", "self", ".", "labeled", "=", "labeled", "\n", "self", ".", "num_indices", "=", "num_indices", "# number of indices to identify a sample", "\n", "self", ".", "sample_label", "=", "sample_label", "\n", "self", ".", "seed", "=", "seed", "# used for sampling", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.moving_image_shape": [[60, 66], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "moving_image_shape", "(", "self", ")", "->", "tuple", ":", "\n", "        ", "\"\"\"\n        needs to be defined by user.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.fixed_image_shape": [[67, 73], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "fixed_image_shape", "(", "self", ")", "->", "tuple", ":", "\n", "        ", "\"\"\"\n        needs to be defined by user.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.num_samples": [[74, 81], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_samples", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Return the number of samples in the dataset for one epoch\n        :return:\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.get_dataset": [[82, 87], ["None"], "methods", ["None"], ["", "def", "get_dataset", "(", "self", ")", "->", "tf", ".", "data", ".", "Dataset", ":", "\n", "        ", "\"\"\"\n        defined in GeneratorDataLoader.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.get_dataset_and_preprocess": [[88, 157], ["interface.DataLoader.get_dataset", "dataset.map.map.map", "dataset.map.map.batch", "dataset.map.map.prefetch", "dataset.map.map.shuffle", "dataset.map.map.repeat", "isinstance", "deepreg.dataset.preprocess.resize_inputs", "deepreg.registry.REGISTRY.build_data_augmentation", "dataset.map.map.map"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.get_dataset", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.preprocess.resize_inputs", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_data_augmentation"], ["", "def", "get_dataset_and_preprocess", "(", "\n", "self", ",", "\n", "training", ":", "bool", ",", "\n", "batch_size", ":", "int", ",", "\n", "repeat", ":", "bool", ",", "\n", "shuffle_buffer_num_batch", ":", "int", ",", "\n", "data_augmentation", ":", "Optional", "[", "Union", "[", "List", ",", "Dict", "]", "]", "=", "None", ",", "\n", "num_parallel_calls", ":", "int", "=", "tf", ".", "data", ".", "experimental", ".", "AUTOTUNE", ",", "\n", ")", "->", "tf", ".", "data", ".", "Dataset", ":", "\n", "        ", "\"\"\"\n        Generate tf.data.dataset.\n\n        Reference:\n\n            - https://www.tensorflow.org/guide/data_performance#parallelizing_data_transformation\n            - https://www.tensorflow.org/api_docs/python/tf/data/Dataset\n\n        :param training: indicating if it's training or not\n        :param batch_size: size of mini batch\n        :param repeat: indicating if we need to repeat the dataset\n        :param shuffle_buffer_num_batch: when shuffling,\n            the shuffle_buffer_size = batch_size * shuffle_buffer_num_batch\n        :param repeat: indicating if we need to repeat the dataset\n        :param data_augmentation: augmentation config, can be a list of dict or dict.\n        :param num_parallel_calls: number elements to process asynchronously in parallel\n            during preprocessing, -1 means unlimited, heuristically it should be set to\n            the number of CPU cores available. AUTOTUNE=-1 means not limited.\n        :returns dataset:\n        \"\"\"", "\n", "\n", "dataset", "=", "self", ".", "get_dataset", "(", ")", "\n", "\n", "# resize", "\n", "dataset", "=", "dataset", ".", "map", "(", "\n", "lambda", "x", ":", "resize_inputs", "(", "\n", "inputs", "=", "x", ",", "\n", "moving_image_size", "=", "self", ".", "moving_image_shape", ",", "\n", "fixed_image_size", "=", "self", ".", "fixed_image_shape", ",", "\n", ")", ",", "\n", "num_parallel_calls", "=", "num_parallel_calls", ",", "\n", ")", "\n", "\n", "# shuffle / repeat / batch / preprocess", "\n", "if", "training", "and", "shuffle_buffer_num_batch", ">", "0", ":", "\n", "            ", "dataset", "=", "dataset", ".", "shuffle", "(", "\n", "buffer_size", "=", "batch_size", "*", "shuffle_buffer_num_batch", ",", "\n", "reshuffle_each_iteration", "=", "True", ",", "\n", ")", "\n", "", "if", "repeat", ":", "\n", "            ", "dataset", "=", "dataset", ".", "repeat", "(", ")", "\n", "\n", "", "dataset", "=", "dataset", ".", "batch", "(", "batch_size", "=", "batch_size", ",", "drop_remainder", "=", "training", ")", "\n", "dataset", "=", "dataset", ".", "prefetch", "(", "tf", ".", "data", ".", "experimental", ".", "AUTOTUNE", ")", "\n", "\n", "if", "training", "and", "data_augmentation", "is", "not", "None", ":", "\n", "            ", "if", "isinstance", "(", "data_augmentation", ",", "dict", ")", ":", "\n", "                ", "data_augmentation", "=", "[", "data_augmentation", "]", "\n", "", "for", "config", "in", "data_augmentation", ":", "\n", "                ", "da_fn", "=", "REGISTRY", ".", "build_data_augmentation", "(", "\n", "config", "=", "config", ",", "\n", "default_args", "=", "{", "\n", "\"moving_image_size\"", ":", "self", ".", "moving_image_shape", ",", "\n", "\"fixed_image_size\"", ":", "self", ".", "fixed_image_shape", ",", "\n", "\"batch_size\"", ":", "batch_size", ",", "\n", "}", ",", "\n", ")", "\n", "dataset", "=", "dataset", ".", "map", "(", "da_fn", ",", "num_parallel_calls", "=", "num_parallel_calls", ")", "\n", "\n", "", "", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.DataLoader.close": [[158, 160], ["None"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.AbstractPairedDataLoader.__init__": [[167, 190], ["interface.DataLoader.__init__", "tuple", "tuple", "ValueError", "len", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "moving_image_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "List", "[", "int", "]", "]", ",", "\n", "fixed_image_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "List", "[", "int", "]", "]", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        num_indices = 2 corresponding to (image_index, label_index)\n        :param moving_image_shape: (width, height, depth)\n        :param fixed_image_shape:  (width, height, depth)\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "num_indices", "=", "2", ",", "**", "kwargs", ")", "\n", "if", "len", "(", "moving_image_shape", ")", "!=", "3", "or", "len", "(", "fixed_image_shape", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"moving_image_shape and fixed_image_shape have length of three, \"", "\n", "f\"corresponding to (width, height, depth), \"", "\n", "f\"got moving_image_shape = {moving_image_shape} \"", "\n", "f\"and fixed_image_shape = {fixed_image_shape}\"", "\n", ")", "\n", "", "self", ".", "_moving_image_shape", "=", "tuple", "(", "moving_image_shape", ")", "\n", "self", ".", "_fixed_image_shape", "=", "tuple", "(", "fixed_image_shape", ")", "\n", "self", ".", "num_images", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.AbstractPairedDataLoader.moving_image_shape": [[191, 198], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "moving_image_shape", "(", "self", ")", "->", "tuple", ":", "\n", "        ", "\"\"\"\n        Return the moving image shape.\n        :return: shape of moving image\n        \"\"\"", "\n", "return", "self", ".", "_moving_image_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.AbstractPairedDataLoader.fixed_image_shape": [[199, 206], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "fixed_image_shape", "(", "self", ")", "->", "tuple", ":", "\n", "        ", "\"\"\"\n        Return the fixed image shape.\n        :return: shape of fixed image\n        \"\"\"", "\n", "return", "self", ".", "_fixed_image_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.AbstractPairedDataLoader.num_samples": [[207, 214], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_samples", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Return the number of samples in the dataset for one epoch.\n        :return: number of images\n        \"\"\"", "\n", "return", "self", ".", "num_images", "# type:ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.AbstractUnpairedDataLoader.__init__": [[221, 238], ["interface.DataLoader.__init__", "tuple", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "self", ",", "image_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "List", "[", "int", "]", "]", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param image_shape: (dim1, dim2, dim3), for unpaired data,\n            moving_image_shape = fixed_image_shape = image_shape\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "num_indices", "=", "3", ",", "**", "kwargs", ")", "\n", "if", "len", "(", "image_shape", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"image_shape has to be length of three, \"", "\n", "f\"corresponding to (width, height, depth), \"", "\n", "f\"got {image_shape}\"", "\n", ")", "\n", "", "self", ".", "image_shape", "=", "tuple", "(", "image_shape", ")", "\n", "self", ".", "_num_samples", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.AbstractUnpairedDataLoader.moving_image_shape": [[239, 242], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "moving_image_shape", "(", "self", ")", "->", "tuple", ":", "\n", "        ", "return", "self", ".", "image_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.AbstractUnpairedDataLoader.fixed_image_shape": [[243, 246], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "fixed_image_shape", "(", "self", ")", "->", "tuple", ":", "\n", "        ", "return", "self", ".", "image_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.AbstractUnpairedDataLoader.num_samples": [[247, 250], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_samples", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "_num_samples", "# type:ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.__init__": [[257, 268], ["interface.DataLoader.__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "loader_moving_image", "=", "None", "\n", "self", ".", "loader_fixed_image", "=", "None", "\n", "self", ".", "loader_moving_label", "=", "None", "\n", "self", ".", "loader_fixed_label", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.get_dataset": [[269, 300], ["tensorflow.data.Dataset.from_generator", "tensorflow.data.Dataset.from_generator", "dict", "dict", "dict", "dict", "tensorflow.TensorShape", "tensorflow.TensorShape", "tensorflow.TensorShape", "tensorflow.TensorShape", "tensorflow.TensorShape", "tensorflow.TensorShape"], "methods", ["None"], ["", "def", "get_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return a dataset from the generator.\n        \"\"\"", "\n", "if", "self", ".", "labeled", ":", "\n", "            ", "return", "tf", ".", "data", ".", "Dataset", ".", "from_generator", "(", "\n", "generator", "=", "self", ".", "data_generator", ",", "\n", "output_types", "=", "dict", "(", "\n", "moving_image", "=", "tf", ".", "float32", ",", "\n", "fixed_image", "=", "tf", ".", "float32", ",", "\n", "moving_label", "=", "tf", ".", "float32", ",", "\n", "fixed_label", "=", "tf", ".", "float32", ",", "\n", "indices", "=", "tf", ".", "float32", ",", "\n", ")", ",", "\n", "output_shapes", "=", "dict", "(", "\n", "moving_image", "=", "tf", ".", "TensorShape", "(", "[", "None", ",", "None", ",", "None", "]", ")", ",", "\n", "fixed_image", "=", "tf", ".", "TensorShape", "(", "[", "None", ",", "None", ",", "None", "]", ")", ",", "\n", "moving_label", "=", "tf", ".", "TensorShape", "(", "[", "None", ",", "None", ",", "None", "]", ")", ",", "\n", "fixed_label", "=", "tf", ".", "TensorShape", "(", "[", "None", ",", "None", ",", "None", "]", ")", ",", "\n", "indices", "=", "self", ".", "num_indices", ",", "\n", ")", ",", "\n", ")", "\n", "", "return", "tf", ".", "data", ".", "Dataset", ".", "from_generator", "(", "\n", "generator", "=", "self", ".", "data_generator", ",", "\n", "output_types", "=", "dict", "(", "\n", "moving_image", "=", "tf", ".", "float32", ",", "fixed_image", "=", "tf", ".", "float32", ",", "indices", "=", "tf", ".", "float32", "\n", ")", ",", "\n", "output_shapes", "=", "dict", "(", "\n", "moving_image", "=", "tf", ".", "TensorShape", "(", "[", "None", ",", "None", ",", "None", "]", ")", ",", "\n", "fixed_image", "=", "tf", ".", "TensorShape", "(", "[", "None", ",", "None", ",", "None", "]", ")", ",", "\n", "indices", "=", "self", ".", "num_indices", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.data_generator": [[303, 331], ["interface.GeneratorDataLoader.sample_index_generator", "interface.GeneratorDataLoader.loader_moving_image.get_data", "deepreg.dataset.loader.util.normalize_array", "interface.GeneratorDataLoader.loader_fixed_image.get_data", "deepreg.dataset.loader.util.normalize_array", "interface.GeneratorDataLoader.sample_image_label", "interface.GeneratorDataLoader.loader_moving_label.get_data", "interface.GeneratorDataLoader.loader_fixed_label.get_data"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.sample_index_generator", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.sample_image_label", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data"], ["", "def", "data_generator", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Yield samples of data to feed model.\n        \"\"\"", "\n", "for", "(", "moving_index", ",", "fixed_index", ",", "image_indices", ")", "in", "self", ".", "sample_index_generator", "(", ")", ":", "\n", "            ", "moving_image", "=", "self", ".", "loader_moving_image", ".", "get_data", "(", "index", "=", "moving_index", ")", "\n", "moving_image", "=", "normalize_array", "(", "moving_image", ")", "\n", "fixed_image", "=", "self", ".", "loader_fixed_image", ".", "get_data", "(", "index", "=", "fixed_index", ")", "\n", "fixed_image", "=", "normalize_array", "(", "fixed_image", ")", "\n", "moving_label", "=", "(", "\n", "self", ".", "loader_moving_label", ".", "get_data", "(", "index", "=", "moving_index", ")", "\n", "if", "self", ".", "labeled", "\n", "else", "None", "\n", ")", "\n", "fixed_label", "=", "(", "\n", "self", ".", "loader_fixed_label", ".", "get_data", "(", "index", "=", "fixed_index", ")", "\n", "if", "self", ".", "labeled", "\n", "else", "None", "\n", ")", "\n", "\n", "for", "sample", "in", "self", ".", "sample_image_label", "(", "\n", "moving_image", "=", "moving_image", ",", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "moving_label", "=", "moving_label", ",", "\n", "fixed_label", "=", "fixed_label", ",", "\n", "image_indices", "=", "image_indices", ",", "\n", ")", ":", "\n", "                ", "yield", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.sample_index_generator": [[332, 338], ["None"], "methods", ["None"], ["", "", "", "def", "sample_index_generator", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Method is defined by the implemented data loaders to yield the sample indexes.\n        Only used in data_generator.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.validate_images_and_labels": [[339, 434], ["zip", "zip", "ValueError", "ValueError", "zip", "ValueError", "ValueError", "logger.warning", "logger.warning", "ValueError", "numpy.min", "numpy.max", "len", "min", "len", "ValueError", "len", "len", "numpy.min", "numpy.max"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "validate_images_and_labels", "(", "\n", "moving_image", ":", "np", ".", "ndarray", ",", "\n", "fixed_image", ":", "np", ".", "ndarray", ",", "\n", "moving_label", ":", "Optional", "[", "np", ".", "ndarray", "]", ",", "\n", "fixed_label", ":", "Optional", "[", "np", ".", "ndarray", "]", ",", "\n", "image_indices", ":", "list", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Check file names match according to naming convention.\n        Only used in sample_image_label.\n        :param moving_image: np.ndarray of shape (m_dim1, m_dim2, m_dim3)\n        :param fixed_image: np.ndarray of shape (f_dim1, f_dim2, f_dim3)\n        :param moving_label: np.ndarray of shape (m_dim1, m_dim2, m_dim3)\n            or (m_dim1, m_dim2, m_dim3, num_labels)\n        :param fixed_label: np.ndarray of shape (f_dim1, f_dim2, f_dim3)\n            or (f_dim1, f_dim2, f_dim3, num_labels)\n        :param image_indices: list\n        \"\"\"", "\n", "# images should never be None, and labels should all be non-None or None", "\n", "if", "moving_image", "is", "None", "or", "fixed_image", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"moving image and fixed image must not be None\"", ")", "\n", "", "if", "(", "moving_label", "is", "None", ")", "!=", "(", "fixed_label", "is", "None", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"moving label and fixed label must be both None or non-None\"", "\n", ")", "\n", "# image and label's values should be between [0, 1]", "\n", "", "for", "arr", ",", "name", "in", "zip", "(", "\n", "[", "moving_image", ",", "fixed_image", ",", "moving_label", ",", "fixed_label", "]", ",", "\n", "[", "\"moving_image\"", ",", "\"fixed_image\"", ",", "\"moving_label\"", ",", "\"fixed_label\"", "]", ",", "\n", ")", ":", "\n", "            ", "if", "arr", "is", "None", ":", "\n", "                ", "continue", "\n", "", "if", "np", ".", "min", "(", "arr", ")", "<", "0", "or", "np", ".", "max", "(", "arr", ")", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Sample {image_indices}'s {name}'s values are not between [0, 1]. \"", "\n", "f\"Its minimum value is {np.min(arr)} \"", "\n", "f\"and its maximum value is {np.max(arr)}.\\n\"", "\n", "f\"The images are automatically normalized on image level: \"", "\n", "f\"x = (x - min(x) + EPS) / (max(x) - min(x) + EPS). \\n\"", "\n", "f\"Labels are assumed to have values between [0,1] \"", "\n", "f\"and they are not normalised. \"", "\n", "f\"This is to prevent accidental use of other encoding methods \"", "\n", "f\"other than one-hot to represent multiple class labels.\\n\"", "\n", "f\"If the label values are intended to represent multiple labels, \"", "\n", "f\"convert them to one hot / binary masks in multiple channels, \"", "\n", "f\"with each channel representing one label only.\\n\"", "\n", "f\"Please read the dataset requirements section \"", "\n", "f\"in docs/doc_data_loader.md for more detailed information.\"", "\n", ")", "\n", "# images should be 3D arrays", "\n", "", "", "for", "arr", ",", "name", "in", "zip", "(", "\n", "[", "moving_image", ",", "fixed_image", "]", ",", "[", "\"moving_image\"", ",", "\"fixed_image\"", "]", "\n", ")", ":", "\n", "            ", "if", "len", "(", "arr", ".", "shape", ")", "!=", "3", "or", "min", "(", "arr", ".", "shape", ")", "<=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Sample {image_indices}'s {name}'s shape should be 3D\"", "\n", "f\" and non-empty, got {arr.shape}.\"", "\n", ")", "\n", "# when data are labeled", "\n", "", "", "if", "moving_label", "is", "not", "None", "and", "fixed_label", "is", "not", "None", ":", "\n", "# labels should be 3D or 4D arrays", "\n", "            ", "for", "arr", ",", "name", "in", "zip", "(", "\n", "[", "moving_label", ",", "fixed_label", "]", ",", "[", "\"moving_label\"", ",", "\"fixed_label\"", "]", "\n", ")", ":", "\n", "                ", "if", "len", "(", "arr", ".", "shape", ")", "not", "in", "[", "3", ",", "4", "]", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "f\"Sample {image_indices}'s {name}'s shape should be 3D or 4D. \"", "\n", "f\"Got {arr.shape}.\"", "\n", ")", "\n", "# image and label is better to have the same shape", "\n", "", "", "if", "moving_image", ".", "shape", "[", ":", "3", "]", "!=", "moving_label", ".", "shape", "[", ":", "3", "]", ":", "# pragma: no cover", "\n", "                ", "logger", ".", "warning", "(", "\n", "f\"Sample {image_indices}'s moving image and label \"", "\n", "f\"have different shapes. \"", "\n", "f\"moving_image.shape = {moving_image.shape}, \"", "\n", "f\"moving_label.shape = {moving_label.shape}\"", "\n", ")", "\n", "", "if", "fixed_image", ".", "shape", "[", ":", "3", "]", "!=", "fixed_label", ".", "shape", "[", ":", "3", "]", ":", "# pragma: no cover", "\n", "                ", "logger", ".", "warning", "(", "\n", "f\"Sample {image_indices}'s fixed image and label \"", "\n", "f\"have different shapes. \"", "\n", "f\"fixed_image.shape = {fixed_image.shape}, \"", "\n", "f\"fixed_label.shape = {fixed_label.shape}\"", "\n", ")", "\n", "# number of labels for fixed and fixed images should be the same", "\n", "", "num_labels_moving", "=", "(", "\n", "1", "if", "len", "(", "moving_label", ".", "shape", ")", "==", "3", "else", "moving_label", ".", "shape", "[", "-", "1", "]", "\n", ")", "\n", "num_labels_fixed", "=", "(", "\n", "1", "if", "len", "(", "fixed_label", ".", "shape", ")", "==", "3", "else", "fixed_label", ".", "shape", "[", "-", "1", "]", "\n", ")", "\n", "if", "num_labels_moving", "!=", "num_labels_fixed", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Sample {image_indices}'s moving image and fixed image \"", "\n", "f\"have different numbers of labels. \"", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.sample_image_label": [[438, 491], ["interface.GeneratorDataLoader.validate_images_and_labels", "numpy.asarray", "dict", "len", "deepreg.dataset.util.get_label_indices", "numpy.asarray", "numpy.asarray", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.GeneratorDataLoader.validate_images_and_labels", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.get_label_indices"], ["", "", "", "def", "sample_image_label", "(", "\n", "self", ",", "\n", "moving_image", ":", "np", ".", "ndarray", ",", "\n", "fixed_image", ":", "np", ".", "ndarray", ",", "\n", "moving_label", ":", "Optional", "[", "np", ".", "ndarray", "]", ",", "\n", "fixed_label", ":", "Optional", "[", "np", ".", "ndarray", "]", ",", "\n", "image_indices", ":", "list", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Sample the image labels, only used in data_generator.\n\n        :param moving_image:\n        :param fixed_image:\n        :param moving_label:\n        :param fixed_label:\n        :param image_indices:\n        \"\"\"", "\n", "self", ".", "validate_images_and_labels", "(", "\n", "moving_image", ",", "fixed_image", ",", "moving_label", ",", "fixed_label", ",", "image_indices", "\n", ")", "\n", "# unlabeled", "\n", "if", "moving_label", "is", "None", "or", "fixed_label", "is", "None", ":", "\n", "            ", "label_index", "=", "-", "1", "# means no label", "\n", "indices", "=", "np", ".", "asarray", "(", "image_indices", "+", "[", "label_index", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "yield", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "fixed_image", "=", "fixed_image", ",", "indices", "=", "indices", "\n", ")", "\n", "", "else", ":", "\n", "# labeled", "\n", "            ", "if", "len", "(", "moving_label", ".", "shape", ")", "==", "4", ":", "# multiple labels", "\n", "                ", "label_indices", "=", "get_label_indices", "(", "\n", "moving_label", ".", "shape", "[", "3", "]", ",", "self", ".", "sample_label", "# type:ignore", "\n", ")", "\n", "for", "label_index", "in", "label_indices", ":", "\n", "                    ", "indices", "=", "np", ".", "asarray", "(", "\n", "image_indices", "+", "[", "label_index", "]", ",", "dtype", "=", "np", ".", "float32", "\n", ")", "\n", "yield", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "indices", "=", "indices", ",", "\n", "moving_label", "=", "moving_label", "[", "...", ",", "label_index", "]", ",", "\n", "fixed_label", "=", "fixed_label", "[", "...", ",", "label_index", "]", ",", "\n", ")", "\n", "", "", "else", ":", "# only one label", "\n", "                ", "label_index", "=", "0", "\n", "indices", "=", "np", ".", "asarray", "(", "image_indices", "+", "[", "label_index", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "yield", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "moving_label", "=", "moving_label", ",", "\n", "fixed_label", "=", "fixed_label", ",", "\n", "indices", "=", "indices", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.__init__": [[499, 515], ["isinstance", "len", "len", "ValueError", "set"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dir_paths", ":", "list", ",", "name", ":", "str", ",", "grouped", ":", "bool", ")", ":", "\n", "        ", "\"\"\"\n        :param dir_paths: path to the directory of the data set\n        :param name: name is used to identify the subdirectories or file names\n        :param grouped: true if the data is grouped\n        \"\"\"", "\n", "assert", "isinstance", "(", "\n", "dir_paths", ",", "list", "\n", ")", ",", "f\"dir_paths must be list of strings, got {dir_paths}\"", "\n", "if", "len", "(", "set", "(", "dir_paths", ")", ")", "!=", "len", "(", "dir_paths", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"dir_paths have repeated elements: {dir_paths}\"", ")", "\n", "", "self", ".", "dir_paths", "=", "dir_paths", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "grouped", "=", "grouped", "\n", "# if grouped, group_struct[group_index] = list of data_index", "\n", "self", ".", "group_struct", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.set_data_structure": [[516, 521], ["None"], "methods", ["None"], ["", "def", "set_data_structure", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Store the data structure in memory to retrieve data using data_index.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.set_group_structure": [[522, 531], ["None"], "methods", ["None"], ["", "def", "set_group_structure", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        In addition to set_data_structure,\n        store the group structure in the group_struct so that\n        group_struct[group_index] = list of data_index\n        and data can be retrieved data by\n        data_index = group_struct[group_index][in_group_data_index]\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data": [[532, 545], ["None"], "methods", ["None"], ["", "def", "get_data", "(", "self", ",", "index", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Get one data array by specifying an index.\n\n        :param index: the data index which is required\n\n          - for paired or unpaired, the index is one single int, data_index\n          - for grouped, the index is a tuple of two ints,\n            (group_index, in_group_data_index)\n\n        :return: the data array at the specified index\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids": [[546, 553], ["None"], "methods", ["None"], ["", "def", "get_data_ids", "(", "self", ")", "->", "List", ":", "\n", "        ", "\"\"\"\n        Return the unique IDs of the data in this data set.\n        This function is used to verify the consistency between\n        moving and fixed images and label.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images": [[554, 561], ["None"], "methods", ["None"], ["", "def", "get_num_images", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Return the number of image in this data set.\n\n        :return: int, number of images in this data set\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_groups": [[562, 570], ["len"], "methods", ["None"], ["", "def", "get_num_groups", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Return the number of groups in grouped data set.\n\n        :return: int, number of groups in this data set, if grouped\n        \"\"\"", "\n", "assert", "self", ".", "group_struct", "is", "not", "None", "\n", "return", "len", "(", "self", ".", "group_struct", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images_per_group": [[571, 586], ["len", "min", "ValueError", "len", "enumerate"], "methods", ["None"], ["", "def", "get_num_images_per_group", "(", "self", ")", "->", "List", "[", "int", "]", ":", "\n", "        ", "\"\"\"\n        Return the number of images in each group.\n        Each group must have at least one image.\n\n        :return: a list of integers, representing the number of images in each group.\n        \"\"\"", "\n", "assert", "self", ".", "group_struct", "is", "not", "None", "\n", "num_images_per_group", "=", "[", "len", "(", "group", ")", "for", "group", "in", "self", ".", "group_struct", "]", "\n", "if", "min", "(", "num_images_per_group", ")", "==", "0", ":", "\n", "            ", "group_ids", "=", "[", "\n", "len", "(", "group", ")", "for", "group_index", ",", "group", "in", "enumerate", "(", "self", ".", "group_struct", ")", "\n", "]", "\n", "raise", "ValueError", "(", "f\"Groups of ID {group_ids} are empty.\"", ")", "\n", "", "return", "num_images_per_group", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.close": [[587, 590], ["None"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"Close opened file handles if exist.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.__init__": [[26, 70], ["deepreg.dataset.loader.interface.AbstractUnpairedDataLoader.__init__", "isinstance", "file_loader", "unpaired_loader.UnpairedDataLoader.validate_data_files", "unpaired_loader.UnpairedDataLoader.loader_moving_image.get_num_images", "file_loader"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.validate_data_files", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_num_images"], ["def", "__init__", "(", "\n", "self", ",", "\n", "file_loader", ",", "\n", "data_dir_paths", ":", "List", "[", "str", "]", ",", "\n", "labeled", ":", "bool", ",", "\n", "sample_label", ":", "str", ",", "\n", "seed", ":", "int", ",", "\n", "image_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "List", "[", "int", "]", "]", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Load data which are unpaired, labeled or unlabeled.\n\n        :param file_loader:\n        :param data_dir_paths: paths of the directories storing data,\n            the data are saved under four different sub-directories: images, labels\n        :param labeled: whether the data is labeled.\n        :param sample_label:\n        :param seed:\n        :param image_shape: (width, height, depth)\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "image_shape", "=", "image_shape", ",", "\n", "labeled", "=", "labeled", ",", "\n", "sample_label", "=", "sample_label", ",", "\n", "seed", "=", "seed", ",", "\n", ")", "\n", "assert", "isinstance", "(", "\n", "data_dir_paths", ",", "list", "\n", ")", ",", "f\"data_dir_paths must be list of strings, got {data_dir_paths}\"", "\n", "loader_image", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_paths", ",", "name", "=", "\"images\"", ",", "grouped", "=", "False", "\n", ")", "\n", "self", ".", "loader_moving_image", "=", "loader_image", "\n", "self", ".", "loader_fixed_image", "=", "loader_image", "\n", "if", "self", ".", "labeled", ":", "\n", "            ", "loader_label", "=", "file_loader", "(", "\n", "dir_paths", "=", "data_dir_paths", ",", "name", "=", "\"labels\"", ",", "grouped", "=", "False", "\n", ")", "\n", "self", ".", "loader_moving_label", "=", "loader_label", "\n", "self", ".", "loader_fixed_label", "=", "loader_label", "\n", "", "self", ".", "validate_data_files", "(", ")", "\n", "\n", "self", ".", "num_images", "=", "self", ".", "loader_moving_image", ".", "get_num_images", "(", ")", "\n", "self", ".", "_num_samples", "=", "self", ".", "num_images", "//", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.validate_data_files": [[71, 84], ["unpaired_loader.UnpairedDataLoader.loader_moving_image.get_data_ids", "unpaired_loader.UnpairedDataLoader.loader_moving_label.get_data_ids", "deepreg.dataset.util.check_difference_between_two_lists"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.interface.FileLoader.get_data_ids", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.dataset.util.check_difference_between_two_lists"], ["", "def", "validate_data_files", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Verify all loader have the same files.\n        Since fixed and moving loaders come from the same file_loader,\n        there is no need to check both (avoid duplicate).\n        \"\"\"", "\n", "if", "self", ".", "labeled", ":", "\n", "            ", "image_ids", "=", "self", ".", "loader_moving_image", ".", "get_data_ids", "(", ")", "\n", "label_ids", "=", "self", ".", "loader_moving_label", ".", "get_data_ids", "(", ")", "\n", "check_difference_between_two_lists", "(", "\n", "list1", "=", "image_ids", ",", "\n", "list2", "=", "label_ids", ",", "\n", "name", "=", "\"images and labels in unpaired loader\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.sample_index_generator": [[86, 99], ["random.Random().shuffle", "range", "range", "random.Random"], "methods", ["None"], ["", "", "def", "sample_index_generator", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Generates sample indexes to load data using the\n        GeneratorDataLoader class.\n        \"\"\"", "\n", "image_indices", "=", "[", "i", "for", "i", "in", "range", "(", "self", ".", "num_images", ")", "]", "\n", "random", ".", "Random", "(", "self", ".", "seed", ")", ".", "shuffle", "(", "image_indices", ")", "\n", "for", "sample_index", "in", "range", "(", "self", ".", "num_samples", ")", ":", "\n", "            ", "moving_index", ",", "fixed_index", "=", "(", "\n", "image_indices", "[", "2", "*", "sample_index", "]", ",", "\n", "image_indices", "[", "2", "*", "sample_index", "+", "1", "]", ",", "\n", ")", "\n", "yield", "moving_index", ",", "fixed_index", ",", "[", "moving_index", ",", "fixed_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close": [[100, 107], ["unpaired_loader.UnpairedDataLoader.loader_moving_image.close", "unpaired_loader.UnpairedDataLoader.loader_moving_label.close"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.unpaired_loader.UnpairedDataLoader.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Close the moving files opened by the file_loaders.\n        \"\"\"", "\n", "self", ".", "loader_moving_image", ".", "close", "(", ")", "\n", "if", "self", ".", "labeled", ":", "\n", "            ", "self", ".", "loader_moving_label", ".", "close", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.normalize_array": [[6, 28], ["numpy.clip", "numpy.min", "numpy.max"], "function", ["None"], ["from", "deepreg", ".", "constant", "import", "EPS", "\n", "\n", "\n", "def", "is_equal_np", "(", "\n", "x", ":", "Union", "[", "np", ".", "ndarray", ",", "List", "]", ",", "y", ":", "Union", "[", "np", ".", "ndarray", ",", "List", "]", ",", "atol", ":", "float", "=", "EPS", "\n", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n    Check if two numpy arrays are identical within a tolerance.\n\n    :param x:\n    :param y:\n    :param atol: error margin\n    :return: return true if two tf tensors are nearly equal\n    \"\"\"", "\n", "x", "=", "np", ".", "asarray", "(", "x", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "y", "=", "np", ".", "asarray", "(", "y", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# check shape", "\n", "if", "x", ".", "shape", "!=", "y", ".", "shape", ":", "\n", "        ", "return", "False", "\n", "\n", "# check nan values", "\n", "# support case some values are nan", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loader.util.remove_prefix_suffix": [[30, 57], ["isinstance", "isinstance", "x.startswith", "x.endswith", "len", "len"], "function", ["None"], ["        ", "return", "False", "\n", "", "x", "=", "np", ".", "nan_to_num", "(", "x", ")", "\n", "y", "=", "np", ".", "nan_to_num", "(", "y", ")", "\n", "\n", "# check values", "\n", "return", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "y", ",", "atol", "=", "atol", ")", ")", "\n", "\n", "\n", "", "def", "is_equal_tf", "(", "\n", "x", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "y", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "atol", ":", "float", "=", "EPS", ",", "\n", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n    Check if two tf tensors are identical within a tolerance.\n\n    :param x:\n    :param y:\n    :param atol: error margin\n    :return: return true if two tf tensors are nearly equal\n    \"\"\"", "\n", "x", "=", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "y", "=", "tf", ".", "cast", "(", "y", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "return", "is_equal_np", "(", "x", "=", "x", ",", "y", "=", "y", ",", "atol", "=", "atol", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_reference_grid": [[11, 51], ["tensorflow.meshgrid", "tensorflow.stack", "tensorflow.cast", "tensorflow.range", "tensorflow.range", "tensorflow.range"], "function", ["None"], ["def", "get_reference_grid", "(", "grid_size", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "List", "[", "int", "]", "]", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Generate a 3D grid with given size.\n\n    Reference:\n\n    - volshape_to_meshgrid of neuron\n      https://github.com/adalca/neurite/blob/legacy/neuron/utils.py\n\n      neuron modifies meshgrid to make it faster, however local\n      benchmark suggests tf.meshgrid is better\n\n    Note:\n\n    for tf.meshgrid, in the 3-D case with inputs of length M, N and P,\n    outputs are of shape (N, M, P) for \u2018xy\u2019 indexing and\n    (M, N, P) for \u2018ij\u2019 indexing.\n\n    :param grid_size: list or tuple of size 3, [dim1, dim2, dim3]\n    :return: shape = (dim1, dim2, dim3, 3),\n             grid[i, j, k, :] = [i j k]\n    \"\"\"", "\n", "\n", "# dim1, dim2, dim3 = grid_size", "\n", "# mesh_grid has three elements, corresponding to i, j, k", "\n", "# for i in range(dim1)", "\n", "#     for j in range(dim2)", "\n", "#         for k in range(dim3)", "\n", "#             mesh_grid[0][i,j,k] = i", "\n", "#             mesh_grid[1][i,j,k] = j", "\n", "#             mesh_grid[2][i,j,k] = k", "\n", "mesh_grid", "=", "tf", ".", "meshgrid", "(", "\n", "tf", ".", "range", "(", "grid_size", "[", "0", "]", ")", ",", "\n", "tf", ".", "range", "(", "grid_size", "[", "1", "]", ")", ",", "\n", "tf", ".", "range", "(", "grid_size", "[", "2", "]", ")", ",", "\n", "indexing", "=", "\"ij\"", ",", "\n", ")", "# has three elements, each shape = (dim1, dim2, dim3)", "\n", "grid", "=", "tf", ".", "stack", "(", "mesh_grid", ",", "axis", "=", "3", ")", "# shape = (dim1, dim2, dim3, 3)", "\n", "grid", "=", "tf", ".", "cast", "(", "grid", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "return", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_n_bits_combinations": [[53, 77], ["list", "itertools.product"], "function", ["None"], ["", "def", "get_n_bits_combinations", "(", "num_bits", ":", "int", ")", "->", "List", "[", "List", "[", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Function returning list containing all combinations of n bits.\n    Given num_bits binary bits, each bit has value 0 or 1,\n    there are in total 2**n_bits combinations.\n\n    :param num_bits: int, number of combinations to evaluate\n    :return: a list of length 2**n_bits,\n      return[i] is the binary representation of the decimal integer.\n\n    :Example:\n        >>> from deepreg.model.layer_util import get_n_bits_combinations\n        >>> get_n_bits_combinations(3)\n        [[0, 0, 0], # 0\n         [0, 0, 1], # 1\n         [0, 1, 0], # 2\n         [0, 1, 1], # 3\n         [1, 0, 0], # 4\n         [1, 0, 1], # 5\n         [1, 1, 0], # 6\n         [1, 1, 1]] # 7\n    \"\"\"", "\n", "assert", "num_bits", ">=", "1", "\n", "return", "[", "list", "(", "i", ")", "for", "i", "in", "itertools", ".", "product", "(", "[", "0", ",", "1", "]", ",", "repeat", "=", "num_bits", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.pyramid_combination": [[79, 215], ["layer_util.pyramid_combination", "layer_util.pyramid_combination", "ValueError", "len", "ValueError", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.pyramid_combination", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.pyramid_combination"], ["", "def", "pyramid_combination", "(", "\n", "values", ":", "list", ",", "weight_floor", ":", "list", ",", "weight_ceil", ":", "list", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Calculates linear interpolation (a weighted sum) using values of\n    hypercube corners in dimension n.\n\n    For example, when num_dimension = len(loc_shape) = num_bits = 3\n    values correspond to values at corners of following coordinates\n\n    .. code-block:: python\n\n        [[0, 0, 0], # even\n         [0, 0, 1], # odd\n         [0, 1, 0], # even\n         [0, 1, 1], # odd\n         [1, 0, 0], # even\n         [1, 0, 1], # odd\n         [1, 1, 0], # even\n         [1, 1, 1]] # odd\n\n    values[::2] correspond to the corners with last coordinate == 0\n\n    .. code-block:: python\n\n        [[0, 0, 0],\n         [0, 1, 0],\n         [1, 0, 0],\n         [1, 1, 0]]\n\n    values[1::2] correspond to the corners with last coordinate == 1\n\n    .. code-block:: python\n\n        [[0, 0, 1],\n         [0, 1, 1],\n         [1, 0, 1],\n         [1, 1, 1]]\n\n    The weights correspond to the floor corners.\n    For example, when num_dimension = len(loc_shape) = num_bits = 3,\n    weight_floor = [f1, f2, f3] (ignoring the batch dimension).\n    weight_ceil = [c1, c2, c3] (ignoring the batch dimension).\n\n    So for corner with coords (x, y, z), x, y, z's values are 0 or 1\n\n    - weight for x = f1 if x = 0 else c1\n    - weight for y = f2 if y = 0 else c2\n    - weight for z = f3 if z = 0 else c3\n\n    so the weight for (x, y, z) is\n\n    .. code-block:: text\n\n        W_xyz = ((1-x) * f1 + x * c1)\n              * ((1-y) * f2 + y * c2)\n              * ((1-z) * f3 + z * c3)\n\n    Let\n\n    .. code-block:: text\n\n        W_xy = ((1-x) * f1 + x * c1)\n             * ((1-y) * f2 + y * c2)\n\n    Then\n\n    - W_xy0 = W_xy * f3\n    - W_xy1 = W_xy * c3\n\n    Similar to W_xyz, denote V_xyz the value at (x, y, z),\n    the final sum V equals\n\n    .. code-block:: text\n\n          sum over x,y,z (V_xyz * W_xyz)\n        = sum over x,y (V_xy0 * W_xy0 + V_xy1 * W_xy1)\n        = sum over x,y (V_xy0 * W_xy * f3 + V_xy1 * W_xy * c3)\n        = sum over x,y (V_xy0 * W_xy) * f3 + sum over x,y (V_xy1 * W_xy) * c3\n\n    That's why we call this pyramid combination.\n    It calculates the linear interpolation gradually, starting from\n    the last dimension.\n    The key is that the weight of each corner is the product of the weights\n    along each dimension.\n\n    :param values: a list having values on the corner,\n                   it has 2**n tensors of shape\n                   (\\*loc_shape) or (batch, \\*loc_shape) or (batch, \\*loc_shape, ch)\n                   the order is consistent with get_n_bits_combinations\n                   loc_shape is independent from n, aka num_dim\n    :param weight_floor: a list having weights of floor points,\n                    it has n tensors of shape\n                    (\\*loc_shape) or (batch, \\*loc_shape) or (batch, \\*loc_shape, 1)\n    :param weight_ceil: a list having weights of ceil points,\n                    it has n tensors of shape\n                    (\\*loc_shape) or (batch, \\*loc_shape) or (batch, \\*loc_shape, 1)\n    :return: one tensor of the same shape as an element in values\n             (\\*loc_shape) or (batch, \\*loc_shape) or (batch, \\*loc_shape, 1)\n    \"\"\"", "\n", "v_shape", "=", "values", "[", "0", "]", ".", "shape", "\n", "wf_shape", "=", "weight_floor", "[", "0", "]", ".", "shape", "\n", "wc_shape", "=", "weight_ceil", "[", "0", "]", ".", "shape", "\n", "if", "len", "(", "v_shape", ")", "!=", "len", "(", "wf_shape", ")", "or", "len", "(", "v_shape", ")", "!=", "len", "(", "wc_shape", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"In pyramid_combination, elements of \"", "\n", "\"values, weight_floor, and weight_ceil should have same dimension. \"", "\n", "f\"value shape = {v_shape}, \"", "\n", "f\"weight_floor = {wf_shape}, \"", "\n", "f\"weight_ceil = {wc_shape}.\"", "\n", ")", "\n", "", "if", "2", "**", "len", "(", "weight_floor", ")", "!=", "len", "(", "values", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"In pyramid_combination, \"", "\n", "\"num_dim = len(weight_floor), \"", "\n", "\"len(values) must be 2 ** num_dim, \"", "\n", "f\"But len(weight_floor) = {len(weight_floor)}, \"", "\n", "f\"len(values) = {len(values)}\"", "\n", ")", "\n", "\n", "", "if", "len", "(", "weight_floor", ")", "==", "1", ":", "# one dimension", "\n", "        ", "return", "values", "[", "0", "]", "*", "weight_floor", "[", "0", "]", "+", "values", "[", "1", "]", "*", "weight_ceil", "[", "0", "]", "\n", "# multi dimension", "\n", "", "values_floor", "=", "pyramid_combination", "(", "\n", "values", "=", "values", "[", ":", ":", "2", "]", ",", "\n", "weight_floor", "=", "weight_floor", "[", ":", "-", "1", "]", ",", "\n", "weight_ceil", "=", "weight_ceil", "[", ":", "-", "1", "]", ",", "\n", ")", "\n", "values_floor", "=", "values_floor", "*", "weight_floor", "[", "-", "1", "]", "\n", "values_ceil", "=", "pyramid_combination", "(", "\n", "values", "=", "values", "[", "1", ":", ":", "2", "]", ",", "\n", "weight_floor", "=", "weight_floor", "[", ":", "-", "1", "]", ",", "\n", "weight_ceil", "=", "weight_ceil", "[", ":", "-", "1", "]", ",", "\n", ")", "\n", "values_ceil", "=", "values_ceil", "*", "weight_ceil", "[", "-", "1", "]", "\n", "return", "values_floor", "+", "values_ceil", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample": [[217, 349], ["tensorflow.math.ceil", "tensorflow.stack", "tensorflow.reshape", "tensorflow.clip_by_value", "range", "layer_util.get_n_bits_combinations", "tensorflow.tile", "layer_util.pyramid_combination", "ValueError", "tensorflow.cast", "loc_floor_ceil.append", "weight_floor.append", "weight_ceil.append", "tensorflow.reshape", "tensorflow.gather_nd", "len", "ValueError", "tensorflow.expand_dims", "tensorflow.expand_dims", "len", "tensorflow.range", "tensorflow.stack", "len", "len", "tensorflow.cast", "tensorflow.cast", "len", "enumerate"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_n_bits_combinations", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.pyramid_combination"], ["", "def", "resample", "(", "\n", "vol", ":", "tf", ".", "Tensor", ",", "\n", "loc", ":", "tf", ".", "Tensor", ",", "\n", "interpolation", ":", "str", "=", "\"linear\"", ",", "\n", "zero_boundary", ":", "bool", "=", "True", ",", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Sample the volume at given locations.\n\n    Input has\n\n    - volume, vol, of shape = (batch, v_dim 1, ..., v_dim n),\n      or (batch, v_dim 1, ..., v_dim n, ch),\n      where n is the dimension of volume,\n      ch is the extra dimension as features.\n\n      Denote vol_shape = (v_dim 1, ..., v_dim n)\n\n    - location, loc, of shape = (batch, l_dim 1, ..., l_dim m, n),\n      where m is the dimension of output.\n\n      Denote loc_shape = (l_dim 1, ..., l_dim m)\n\n    Reference:\n\n    - neuron's interpn\n      https://github.com/adalca/neurite/blob/legacy/neuron/utils.py\n\n      Difference\n\n      1. they dont have batch size\n      2. they support more dimensions in vol\n\n      TODO try not using stack as neuron claims it's slower\n\n    :param vol: shape = (batch, \\*vol_shape) or (batch, \\*vol_shape, ch)\n      with the last channel for features\n    :param loc: shape = (batch, \\*loc_shape, n)\n      such that loc[b, l1, ..., lm, :] = [v1, ..., vn] is of shape (n,),\n      which represents a point in vol, with coordinates (v1, ..., vn)\n    :param interpolation: linear only, TODO support nearest\n    :param zero_boundary: if true, values on or outside boundary will be zeros\n    :return: shape = (batch, \\*loc_shape) or (batch, \\*loc_shape, ch)\n    \"\"\"", "\n", "\n", "if", "interpolation", "!=", "\"linear\"", ":", "\n", "        ", "raise", "ValueError", "(", "\"resample supports only linear interpolation\"", ")", "\n", "\n", "# init", "\n", "", "batch_size", "=", "vol", ".", "shape", "[", "0", "]", "\n", "loc_shape", "=", "loc", ".", "shape", "[", "1", ":", "-", "1", "]", "\n", "dim_vol", "=", "loc", ".", "shape", "[", "-", "1", "]", "# dimension of vol, n", "\n", "if", "dim_vol", "==", "len", "(", "vol", ".", "shape", ")", "-", "1", ":", "\n", "# vol.shape = (batch, *vol_shape)", "\n", "        ", "has_ch", "=", "False", "\n", "", "elif", "dim_vol", "==", "len", "(", "vol", ".", "shape", ")", "-", "2", ":", "\n", "# vol.shape = (batch, *vol_shape, ch)", "\n", "        ", "has_ch", "=", "True", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"vol shape inconsistent with loc \"", "\n", "\"vol.shape = {}, loc.shape = {}\"", ".", "format", "(", "vol", ".", "shape", ",", "loc", ".", "shape", ")", "\n", ")", "\n", "", "vol_shape", "=", "vol", ".", "shape", "[", "1", ":", "dim_vol", "+", "1", "]", "\n", "\n", "# get floor/ceil for loc and stack, then clip together", "\n", "# loc, loc_floor, loc_ceil are have shape (batch, *loc_shape, n)", "\n", "loc_ceil", "=", "tf", ".", "math", ".", "ceil", "(", "loc", ")", "\n", "loc_floor", "=", "loc_ceil", "-", "1", "\n", "# (batch, *loc_shape, n, 3)", "\n", "clipped", "=", "tf", ".", "stack", "(", "[", "loc", ",", "loc_floor", ",", "loc_ceil", "]", ",", "axis", "=", "-", "1", ")", "\n", "clip_value_max", "=", "tf", ".", "cast", "(", "vol_shape", ",", "dtype", "=", "clipped", ".", "dtype", ")", "-", "1", "# (n,)", "\n", "clipped_shape", "=", "[", "1", "]", "*", "(", "len", "(", "loc_shape", ")", "+", "1", ")", "+", "[", "dim_vol", ",", "1", "]", "\n", "clip_value_max", "=", "tf", ".", "reshape", "(", "clip_value_max", ",", "shape", "=", "clipped_shape", ")", "\n", "clipped", "=", "tf", ".", "clip_by_value", "(", "clipped", ",", "clip_value_min", "=", "0", ",", "clip_value_max", "=", "clip_value_max", ")", "\n", "\n", "# loc_floor_ceil has n sublists", "\n", "# each one corresponds to the floor and ceil coordinates for d-th dimension", "\n", "# each tensor is of shape (batch, *loc_shape), dtype int32", "\n", "\n", "# weight_floor has n tensors", "\n", "# each tensor is the weight for the corner of floor coordinates", "\n", "# each tensor's shape is (batch, *loc_shape) if volume has no feature channel", "\n", "#                        (batch, *loc_shape, 1) if volume has feature channel", "\n", "loc_floor_ceil", ",", "weight_floor", ",", "weight_ceil", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "# using for loop is faster than using list comprehension", "\n", "for", "dim", "in", "range", "(", "dim_vol", ")", ":", "\n", "# shape = (batch, *loc_shape)", "\n", "        ", "c_clipped", "=", "clipped", "[", "...", ",", "dim", ",", "0", "]", "\n", "c_floor", "=", "clipped", "[", "...", ",", "dim", ",", "1", "]", "\n", "c_ceil", "=", "clipped", "[", "...", ",", "dim", ",", "2", "]", "\n", "w_floor", "=", "c_ceil", "-", "c_clipped", "# shape = (batch, *loc_shape)", "\n", "w_ceil", "=", "c_clipped", "-", "c_floor", "if", "zero_boundary", "else", "1", "-", "w_floor", "\n", "if", "has_ch", ":", "\n", "            ", "w_floor", "=", "tf", ".", "expand_dims", "(", "w_floor", ",", "-", "1", ")", "# shape = (batch, *loc_shape, 1)", "\n", "w_ceil", "=", "tf", ".", "expand_dims", "(", "w_ceil", ",", "-", "1", ")", "# shape = (batch, *loc_shape, 1)", "\n", "\n", "", "loc_floor_ceil", ".", "append", "(", "[", "tf", ".", "cast", "(", "c_floor", ",", "tf", ".", "int32", ")", ",", "tf", ".", "cast", "(", "c_ceil", ",", "tf", ".", "int32", ")", "]", ")", "\n", "weight_floor", ".", "append", "(", "w_floor", ")", "\n", "weight_ceil", ".", "append", "(", "w_ceil", ")", "\n", "\n", "# 2**n corners, each is a list of n binary values", "\n", "", "corner_indices", "=", "get_n_bits_combinations", "(", "num_bits", "=", "len", "(", "vol_shape", ")", ")", "\n", "\n", "# batch_coords[b, l1, ..., lm] = b", "\n", "# range(batch_size) on axis 0 and repeated on other axes", "\n", "# add batch coords manually is faster than using batch_dims in tf.gather_nd", "\n", "batch_coords", "=", "tf", ".", "tile", "(", "\n", "tf", ".", "reshape", "(", "tf", ".", "range", "(", "batch_size", ")", ",", "[", "batch_size", "]", "+", "[", "1", "]", "*", "len", "(", "loc_shape", ")", ")", ",", "\n", "[", "1", "]", "+", "loc_shape", ",", "\n", ")", "# shape = (batch, *loc_shape)", "\n", "\n", "# get vol values on n-dim hypercube corners", "\n", "# corner_values has 2 ** n elements", "\n", "# each of shape (batch, *loc_shape) or (batch, *loc_shape, ch)", "\n", "corner_values", "=", "[", "\n", "tf", ".", "gather_nd", "(", "\n", "vol", ",", "# shape = (batch, *vol_shape) or (batch, *vol_shape, ch)", "\n", "tf", ".", "stack", "(", "\n", "[", "batch_coords", "]", "\n", "+", "[", "loc_floor_ceil", "[", "axis", "]", "[", "fc_idx", "]", "for", "axis", ",", "fc_idx", "in", "enumerate", "(", "c", ")", "]", ",", "\n", "axis", "=", "-", "1", ",", "\n", ")", ",", "# shape = (batch, *loc_shape, n+1) after stack", "\n", ")", "\n", "for", "c", "in", "corner_indices", "# c is list of len n", "\n", "]", "# each tensor has shape (batch, *loc_shape) or (batch, *loc_shape, ch)", "\n", "\n", "# resample", "\n", "sampled", "=", "pyramid_combination", "(", "\n", "values", "=", "corner_values", ",", "weight_floor", "=", "weight_floor", ",", "weight_ceil", "=", "weight_ceil", "\n", ")", "\n", "return", "sampled", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.warp_grid": [[351, 370], ["tensorflow.concat", "tensorflow.einsum", "tensorflow.ones_like"], "function", ["None"], ["", "def", "warp_grid", "(", "grid", ":", "tf", ".", "Tensor", ",", "theta", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Perform transformation on the grid.\n\n    - grid_padded[i,j,k,:] = [i j k 1]\n    - grid_warped[b,i,j,k,p] = sum_over_q (grid_padded[i,j,k,q] * theta[b,q,p])\n\n    :param grid: shape = (dim1, dim2, dim3, 3), grid[i,j,k,:] = [i j k]\n    :param theta: parameters of transformation, shape = (batch, 4, 3)\n    :return: shape = (batch, dim1, dim2, dim3, 3)\n    \"\"\"", "\n", "\n", "# grid_padded[i,j,k,:] = [i j k 1], shape = (dim1, dim2, dim3, 4)", "\n", "grid_padded", "=", "tf", ".", "concat", "(", "[", "grid", ",", "tf", ".", "ones_like", "(", "grid", "[", "...", ",", ":", "1", "]", ")", "]", ",", "axis", "=", "3", ")", "\n", "\n", "# grid_warped[b,i,j,k,p] = sum_over_q (grid_padded[i,j,k,q] * theta[b,q,p])", "\n", "# shape = (batch, dim1, dim2, dim3, 3)", "\n", "grid_warped", "=", "tf", ".", "einsum", "(", "\"ijkq,bqp->bijkp\"", ",", "grid_padded", ",", "theta", ")", "\n", "return", "grid_warped", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.gaussian_filter_3d": [[372, 427], ["isinstance", "numpy.meshgrid", "numpy.concatenate", "numpy.asarray", "mean.reshape.reshape", "numpy.asarray", "variance.reshape.reshape", "kernel.reshape.reshape", "numpy.zeros", "tensorflow.convert_to_tensor", "int", "numpy.arange", "numpy.exp", "numpy.sum", "numpy.prod", "tuple", "numpy.ceil", "numpy.mod", "numpy.sqrt", "numpy.sum", "numpy.ceil"], "function", ["None"], ["", "def", "gaussian_filter_3d", "(", "kernel_sigma", ":", "Union", "[", "Tuple", ",", "List", "]", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Define a gaussian filter in 3d for smoothing.\n\n    The filter size is defined 3*kernel_sigma\n\n\n    :param kernel_sigma: the deviation at each direction (list)\n        or use an isotropic deviation (int)\n    :return: kernel: tf.Tensor specify a gaussian kernel of shape:\n        [3*k for k in kernel_sigma]\n    \"\"\"", "\n", "if", "isinstance", "(", "kernel_sigma", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "        ", "kernel_sigma", "=", "(", "kernel_sigma", ",", "kernel_sigma", ",", "kernel_sigma", ")", "\n", "\n", "", "kernel_size", "=", "[", "\n", "int", "(", "np", ".", "ceil", "(", "ks", "*", "3", ")", "+", "np", ".", "mod", "(", "np", ".", "ceil", "(", "ks", "*", "3", ")", "+", "1", ",", "2", ")", ")", "for", "ks", "in", "kernel_sigma", "\n", "]", "\n", "\n", "# Create a x, y coordinate grid of shape (kernel_size, kernel_size, 2)", "\n", "coord", "=", "[", "np", ".", "arange", "(", "ks", ")", "for", "ks", "in", "kernel_size", "]", "\n", "\n", "xx", ",", "yy", ",", "zz", "=", "np", ".", "meshgrid", "(", "coord", "[", "0", "]", ",", "coord", "[", "1", "]", ",", "coord", "[", "2", "]", ",", "indexing", "=", "\"ij\"", ")", "\n", "xyz_grid", "=", "np", ".", "concatenate", "(", "\n", "(", "xx", "[", "np", ".", "newaxis", "]", ",", "yy", "[", "np", ".", "newaxis", "]", ",", "zz", "[", "np", ".", "newaxis", "]", ")", ",", "axis", "=", "0", "\n", ")", "# 2, y, x", "\n", "\n", "mean", "=", "np", ".", "asarray", "(", "[", "(", "ks", "-", "1", ")", "/", "2.0", "for", "ks", "in", "kernel_size", "]", ")", "\n", "mean", "=", "mean", ".", "reshape", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "variance", "=", "np", ".", "asarray", "(", "[", "ks", "**", "2.0", "for", "ks", "in", "kernel_sigma", "]", ")", "\n", "variance", "=", "variance", ".", "reshape", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "\n", "# Calculate the 2-dimensional gaussian kernel which is", "\n", "# the product of two gaussian distributions for two different", "\n", "# variables (in this case called x and y)", "\n", "# 2.506628274631 = sqrt(2 * pi)", "\n", "\n", "norm_kernel", "=", "1.0", "/", "(", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", "**", "3", "+", "np", ".", "prod", "(", "kernel_sigma", ")", ")", "\n", "kernel", "=", "norm_kernel", "*", "np", ".", "exp", "(", "\n", "-", "np", ".", "sum", "(", "(", "xyz_grid", "-", "mean", ")", "**", "2.0", "/", "(", "2", "*", "variance", ")", ",", "axis", "=", "0", ")", "\n", ")", "\n", "\n", "# Make sure sum of values in gaussian kernel equals 1.", "\n", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "\n", "# Reshape", "\n", "kernel", "=", "kernel", ".", "reshape", "(", "kernel_size", "[", "0", "]", ",", "kernel_size", "[", "1", "]", ",", "kernel_size", "[", "2", "]", ")", "\n", "\n", "# Total kernel", "\n", "total_kernel", "=", "np", ".", "zeros", "(", "tuple", "(", "kernel_size", ")", "+", "(", "3", ",", "3", ")", ")", "\n", "total_kernel", "[", "...", ",", "0", ",", "0", "]", "=", "kernel", "\n", "total_kernel", "[", "...", ",", "1", ",", "1", "]", "=", "kernel", "\n", "total_kernel", "[", "...", ",", "2", ",", "2", "]", "=", "kernel", "\n", "\n", "return", "tf", ".", "convert_to_tensor", "(", "total_kernel", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util._deconv_output_padding": [[429, 458], ["ValueError"], "function", ["None"], ["", "def", "_deconv_output_padding", "(", "\n", "input_shape", ":", "int", ",", "output_shape", ":", "int", ",", "kernel_size", ":", "int", ",", "stride", ":", "int", ",", "padding", ":", "str", "\n", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Calculate output padding for Conv3DTranspose in 1D.\n\n    - output_shape = (input_shape - 1)*stride + kernel_size - 2*pad + output_padding\n    - output_padding = output_shape - ((input_shape - 1)*stride + kernel_size - 2*pad)\n\n    Reference:\n\n    - https://github.com/tensorflow/tensorflow/blob/r2.3/tensorflow/python/keras/utils/conv_utils.py#L140\n\n    :param input_shape: shape of Conv3DTranspose input tensor\n    :param output_shape: shape of Conv3DTranspose output tensor\n    :param kernel_size: kernel size of Conv3DTranspose layer\n    :param stride: stride of Conv3DTranspose layer\n    :param padding: padding of Conv3DTranspose layer\n    :return: output_padding for Conv3DTranspose layer\n    \"\"\"", "\n", "if", "padding", "==", "\"same\"", ":", "\n", "        ", "pad", "=", "kernel_size", "//", "2", "\n", "", "elif", "padding", "==", "\"valid\"", ":", "\n", "        ", "pad", "=", "0", "\n", "", "elif", "padding", "==", "\"full\"", ":", "\n", "        ", "pad", "=", "kernel_size", "-", "1", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Unknown padding {padding} in deconv_output_padding\"", ")", "\n", "", "return", "output_shape", "-", "(", "(", "input_shape", "-", "1", ")", "*", "stride", "+", "kernel_size", "-", "2", "*", "pad", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.deconv_output_padding": [[460, 500], ["isinstance", "len", "isinstance", "isinstance", "isinstance", "tuple", "layer_util._deconv_output_padding", "range"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util._deconv_output_padding"], ["", "def", "deconv_output_padding", "(", "\n", "input_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "output_shape", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "kernel_size", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "stride", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "padding", ":", "str", ",", "\n", ")", "->", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Calculate output padding for Conv3DTranspose in any dimension.\n\n    :param input_shape: shape of Conv3DTranspose input tensor, without batch or channel\n    :param output_shape: shape of Conv3DTranspose output tensor,\n        without batch or channel\n    :param kernel_size: kernel size of Conv3DTranspose layer\n    :param stride: stride of Conv3DTranspose layer\n    :param padding: padding of Conv3DTranspose layer\n    :return: output_padding for Conv3DTranspose layer\n    \"\"\"", "\n", "if", "isinstance", "(", "input_shape", ",", "int", ")", ":", "\n", "        ", "input_shape", "=", "(", "input_shape", ",", ")", "\n", "", "dim", "=", "len", "(", "input_shape", ")", "\n", "if", "isinstance", "(", "output_shape", ",", "int", ")", ":", "\n", "        ", "output_shape", "=", "(", "output_shape", ",", ")", "\n", "", "if", "isinstance", "(", "kernel_size", ",", "int", ")", ":", "\n", "        ", "kernel_size", "=", "(", "kernel_size", ",", ")", "*", "dim", "\n", "", "if", "isinstance", "(", "stride", ",", "int", ")", ":", "\n", "        ", "stride", "=", "(", "stride", ",", ")", "*", "dim", "\n", "", "output_padding", "=", "tuple", "(", "\n", "_deconv_output_padding", "(", "\n", "input_shape", "=", "input_shape", "[", "d", "]", ",", "\n", "output_shape", "=", "output_shape", "[", "d", "]", ",", "\n", "kernel_size", "=", "kernel_size", "[", "d", "]", ",", "\n", "stride", "=", "stride", "[", "d", "]", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n", "for", "d", "in", "range", "(", "dim", ")", "\n", ")", "\n", "if", "dim", "==", "1", ":", "\n", "        ", "return", "output_padding", "[", "0", "]", "\n", "", "return", "output_padding", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.__init__": [[33, 72], ["super().__init__", "network.RegistrationModel.build_model", "network.RegistrationModel.build_loss", "deepreg.model.layer_util.get_reference_grid"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.build_model", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_reference_grid"], ["def", "__init__", "(", "\n", "self", ",", "\n", "moving_image_size", ":", "Tuple", ",", "\n", "fixed_image_size", ":", "Tuple", ",", "\n", "index_size", ":", "int", ",", "\n", "labeled", ":", "bool", ",", "\n", "batch_size", ":", "int", ",", "\n", "config", ":", "dict", ",", "\n", "name", ":", "str", "=", "\"RegistrationModel\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param moving_image_size: (m_dim1, m_dim2, m_dim3)\n        :param fixed_image_size: (f_dim1, f_dim2, f_dim3)\n        :param index_size: number of indices for identify each sample\n        :param labeled: if the data is labeled\n        :param batch_size: total number of samples consumed per step, over all devices.\n            When using multiple devices, TensorFlow automatically split the tensors.\n            Therefore, input shapes should be defined over batch_size.\n        :param config: config for method, backbone, and loss.\n        :param name: name of the model\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "moving_image_size", "=", "moving_image_size", "\n", "self", ".", "fixed_image_size", "=", "fixed_image_size", "\n", "self", ".", "index_size", "=", "index_size", "\n", "self", ".", "labeled", "=", "labeled", "\n", "self", ".", "config", "=", "config", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "self", ".", "_inputs", "=", "None", "# save inputs of self._model as dict", "\n", "self", ".", "_outputs", "=", "None", "# save outputs of self._model as dict", "\n", "\n", "self", ".", "grid_ref", "=", "layer_util", ".", "get_reference_grid", "(", "grid_size", "=", "fixed_image_size", ")", "[", "\n", "None", ",", "...", "\n", "]", "\n", "self", ".", "_model", ":", "tf", ".", "keras", ".", "Model", "=", "self", ".", "build_model", "(", ")", "\n", "self", ".", "build_loss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.get_config": [[73, 83], ["dict"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "return", "dict", "(", "\n", "moving_image_size", "=", "self", ".", "moving_image_size", ",", "\n", "fixed_image_size", "=", "self", ".", "fixed_image_size", ",", "\n", "index_size", "=", "self", ".", "index_size", ",", "\n", "labeled", "=", "self", ".", "labeled", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "config", "=", "self", ".", "config", ",", "\n", "name", "=", "self", ".", "name", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.build_model": [[85, 88], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "build_model", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build the model to be saved as self._model.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.build_inputs": [[89, 137], ["tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "dict", "dict"], "methods", ["None"], ["", "def", "build_inputs", "(", "self", ")", "->", "Dict", "[", "str", ",", "tf", ".", "keras", ".", "layers", ".", "Input", "]", ":", "\n", "        ", "\"\"\"\n        Build input tensors.\n\n        :return: dict of inputs.\n        \"\"\"", "\n", "# (batch, m_dim1, m_dim2, m_dim3)", "\n", "moving_image", "=", "tf", ".", "keras", ".", "Input", "(", "\n", "shape", "=", "self", ".", "moving_image_size", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "name", "=", "\"moving_image\"", ",", "\n", ")", "\n", "# (batch, f_dim1, f_dim2, f_dim3)", "\n", "fixed_image", "=", "tf", ".", "keras", ".", "Input", "(", "\n", "shape", "=", "self", ".", "fixed_image_size", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "name", "=", "\"fixed_image\"", ",", "\n", ")", "\n", "# (batch, index_size)", "\n", "indices", "=", "tf", ".", "keras", ".", "Input", "(", "\n", "shape", "=", "(", "self", ".", "index_size", ",", ")", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "name", "=", "\"indices\"", ",", "\n", ")", "\n", "\n", "if", "not", "self", ".", "labeled", ":", "\n", "            ", "return", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "fixed_image", "=", "fixed_image", ",", "indices", "=", "indices", "\n", ")", "\n", "\n", "# (batch, m_dim1, m_dim2, m_dim3)", "\n", "", "moving_label", "=", "tf", ".", "keras", ".", "Input", "(", "\n", "shape", "=", "self", ".", "moving_image_size", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "name", "=", "\"moving_label\"", ",", "\n", ")", "\n", "# (batch, m_dim1, m_dim2, m_dim3)", "\n", "fixed_label", "=", "tf", ".", "keras", ".", "Input", "(", "\n", "shape", "=", "self", ".", "fixed_image_size", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "name", "=", "\"fixed_label\"", ",", "\n", ")", "\n", "return", "dict", "(", "\n", "moving_image", "=", "moving_image", ",", "\n", "fixed_image", "=", "fixed_image", ",", "\n", "moving_label", "=", "moving_label", ",", "\n", "fixed_label", "=", "fixed_label", ",", "\n", "indices", "=", "indices", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.concat_images": [[139, 175], ["deepreg.model.layer.Resize3d", "tensorflow.expand_dims", "deepreg.model.layer.Resize3d.", "tensorflow.concat.append", "tensorflow.expand_dims", "tensorflow.concat.append", "tensorflow.concat", "tensorflow.expand_dims", "deepreg.model.layer.Resize3d.", "tensorflow.concat.append"], "methods", ["None"], ["", "def", "concat_images", "(", "\n", "self", ",", "\n", "moving_image", ":", "tf", ".", "Tensor", ",", "\n", "fixed_image", ":", "tf", ".", "Tensor", ",", "\n", "moving_label", ":", "Optional", "[", "tf", ".", "Tensor", "]", "=", "None", ",", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Adjust image shape and concatenate them together.\n\n        :param moving_image: registration source\n        :param fixed_image: registration target\n        :param moving_label: optional, only used for conditional model.\n        :return:\n        \"\"\"", "\n", "images", "=", "[", "]", "\n", "\n", "resize_layer", "=", "layer", ".", "Resize3d", "(", "shape", "=", "self", ".", "fixed_image_size", ")", "\n", "\n", "# (batch, m_dim1, m_dim2, m_dim3, 1)", "\n", "moving_image", "=", "tf", ".", "expand_dims", "(", "moving_image", ",", "axis", "=", "4", ")", "\n", "moving_image", "=", "resize_layer", "(", "moving_image", ")", "\n", "images", ".", "append", "(", "moving_image", ")", "\n", "\n", "# (batch, m_dim1, m_dim2, m_dim3, 1)", "\n", "fixed_image", "=", "tf", ".", "expand_dims", "(", "fixed_image", ",", "axis", "=", "4", ")", "\n", "images", ".", "append", "(", "fixed_image", ")", "\n", "\n", "# (batch, m_dim1, m_dim2, m_dim3, 1)", "\n", "if", "moving_label", "is", "not", "None", ":", "\n", "            ", "moving_label", "=", "tf", ".", "expand_dims", "(", "moving_label", ",", "axis", "=", "4", ")", "\n", "moving_label", "=", "resize_layer", "(", "moving_label", ")", "\n", "images", ".", "append", "(", "moving_label", ")", "\n", "\n", "# (batch, f_dim1, f_dim2, f_dim3, 2 or 3)", "\n", "", "images", "=", "tf", ".", "concat", "(", "images", ",", "axis", "=", "4", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel._build_loss": [[176, 235], ["logger.warning", "isinstance", "deepreg.registry.REGISTRY.build_loss", "loss_layer", "network.RegistrationModel._model.add_loss", "network.RegistrationModel._model.add_metric", "network.RegistrationModel._model.add_metric", "logger.warning", "logger.warning", "network.dict_without"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.dict_without"], ["", "def", "_build_loss", "(", "self", ",", "name", ":", "str", ",", "inputs_dict", ":", "dict", ")", ":", "\n", "        ", "\"\"\"\n        Build and add one weighted loss together with the metrics.\n\n        :param name: name of loss, image / label / regularization.\n        :param inputs_dict: inputs for loss function\n        \"\"\"", "\n", "\n", "if", "name", "not", "in", "self", ".", "config", "[", "\"loss\"", "]", ":", "\n", "# loss config is not defined", "\n", "            ", "logger", ".", "warning", "(", "\n", "f\"The configuration for loss {name} is not defined. \"", "\n", "f\"Therefore it is not used.\"", "\n", ")", "\n", "return", "\n", "\n", "", "loss_configs", "=", "self", ".", "config", "[", "\"loss\"", "]", "[", "name", "]", "\n", "if", "not", "isinstance", "(", "loss_configs", ",", "list", ")", ":", "\n", "            ", "loss_configs", "=", "[", "loss_configs", "]", "\n", "\n", "", "for", "loss_config", "in", "loss_configs", ":", "\n", "\n", "            ", "if", "\"weight\"", "not", "in", "loss_config", ":", "\n", "# default loss weight 1", "\n", "                ", "logger", ".", "warning", "(", "\n", "f\"The weight for loss {name} is not defined.\"", "\n", "f\"Default weight = 1.0 is used.\"", "\n", ")", "\n", "loss_config", "[", "\"weight\"", "]", "=", "1.0", "\n", "\n", "# build loss", "\n", "", "weight", "=", "loss_config", "[", "\"weight\"", "]", "\n", "\n", "if", "weight", "==", "0", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "f\"The weight for loss {name} is zero.\"", "f\"Loss is not used.\"", "\n", ")", "\n", "return", "\n", "\n", "# do not perform reduction over batch axis for supporting multi-device", "\n", "# training, model.fit() will average over global batch size automatically", "\n", "", "loss_layer", ":", "tf", ".", "keras", ".", "layers", ".", "Layer", "=", "REGISTRY", ".", "build_loss", "(", "\n", "config", "=", "dict_without", "(", "d", "=", "loss_config", ",", "key", "=", "\"weight\"", ")", ",", "\n", "default_args", "=", "{", "\"reduction\"", ":", "tf", ".", "keras", ".", "losses", ".", "Reduction", ".", "NONE", "}", ",", "\n", ")", "\n", "loss_value", "=", "loss_layer", "(", "**", "inputs_dict", ")", "\n", "weighted_loss", "=", "loss_value", "*", "weight", "\n", "\n", "# add loss", "\n", "self", ".", "_model", ".", "add_loss", "(", "weighted_loss", ")", "\n", "\n", "# add metric", "\n", "self", ".", "_model", ".", "add_metric", "(", "\n", "loss_value", ",", "name", "=", "f\"loss/{name}_{loss_layer.name}\"", ",", "aggregation", "=", "\"mean\"", "\n", ")", "\n", "self", ".", "_model", ".", "add_metric", "(", "\n", "weighted_loss", ",", "\n", "name", "=", "f\"loss/{name}_{loss_layer.name}_weighted\"", ",", "\n", "aggregation", "=", "\"mean\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.build_loss": [[237, 274], ["network.RegistrationModel.log_tensor_stats", "network.RegistrationModel.log_tensor_stats", "network.RegistrationModel._build_loss", "network.RegistrationModel.log_tensor_stats", "network.RegistrationModel.log_tensor_stats", "network.RegistrationModel._build_loss", "deepreg.loss.label.compute_centroid_distance", "network.RegistrationModel._model.add_metric", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.log_tensor_stats", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.log_tensor_stats", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel._build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.log_tensor_stats", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.log_tensor_stats", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel._build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.compute_centroid_distance"], ["", "", "@", "abstractmethod", "\n", "def", "build_loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build losses according to configs.\"\"\"", "\n", "\n", "# input metrics", "\n", "fixed_image", "=", "self", ".", "_inputs", "[", "\"fixed_image\"", "]", "\n", "moving_image", "=", "self", ".", "_inputs", "[", "\"moving_image\"", "]", "\n", "self", ".", "log_tensor_stats", "(", "tensor", "=", "moving_image", ",", "name", "=", "\"moving_image\"", ")", "\n", "self", ".", "log_tensor_stats", "(", "tensor", "=", "fixed_image", ",", "name", "=", "\"fixed_image\"", ")", "\n", "\n", "# image loss, conditional model does not have this", "\n", "if", "\"pred_fixed_image\"", "in", "self", ".", "_outputs", ":", "\n", "            ", "pred_fixed_image", "=", "self", ".", "_outputs", "[", "\"pred_fixed_image\"", "]", "\n", "self", ".", "_build_loss", "(", "\n", "name", "=", "\"image\"", ",", "\n", "inputs_dict", "=", "dict", "(", "y_true", "=", "fixed_image", ",", "y_pred", "=", "pred_fixed_image", ")", ",", "\n", ")", "\n", "\n", "", "if", "self", ".", "labeled", ":", "\n", "# input metrics", "\n", "            ", "fixed_label", "=", "self", ".", "_inputs", "[", "\"fixed_label\"", "]", "\n", "moving_label", "=", "self", ".", "_inputs", "[", "\"moving_label\"", "]", "\n", "self", ".", "log_tensor_stats", "(", "tensor", "=", "moving_label", ",", "name", "=", "\"moving_label\"", ")", "\n", "self", ".", "log_tensor_stats", "(", "tensor", "=", "fixed_label", ",", "name", "=", "\"fixed_label\"", ")", "\n", "\n", "# label loss", "\n", "pred_fixed_label", "=", "self", ".", "_outputs", "[", "\"pred_fixed_label\"", "]", "\n", "self", ".", "_build_loss", "(", "\n", "name", "=", "\"label\"", ",", "\n", "inputs_dict", "=", "dict", "(", "y_true", "=", "fixed_label", ",", "y_pred", "=", "pred_fixed_label", ")", ",", "\n", ")", "\n", "\n", "# additional label metrics", "\n", "tre", "=", "compute_centroid_distance", "(", "\n", "y_true", "=", "fixed_label", ",", "y_pred", "=", "pred_fixed_label", ",", "grid", "=", "self", ".", "grid_ref", "\n", ")", "\n", "self", ".", "_model", ".", "add_metric", "(", "tre", ",", "name", "=", "\"metric/TRE\"", ",", "aggregation", "=", "\"mean\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.call": [[275, 287], ["network.RegistrationModel._model"], "methods", ["None"], ["", "", "def", "call", "(", "\n", "self", ",", "inputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "training", "=", "None", ",", "mask", "=", "None", "\n", ")", "->", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Call the self._model.\n\n        :param inputs: a dict of tensors.\n        :param training: training or not.\n        :param mask: maks for inputs.\n        :return:\n        \"\"\"", "\n", "return", "self", ".", "_model", "(", "inputs", ",", "training", "=", "training", ",", "mask", "=", "mask", ")", "# pragma: no cover", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.postprocess": [[288, 304], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "postprocess", "(", "\n", "self", ",", "\n", "inputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", "outputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", ")", "->", "Tuple", "[", "tf", ".", "Tensor", ",", "Dict", "]", ":", "\n", "        ", "\"\"\"\n        Return a dict used for saving inputs and outputs.\n\n        :param inputs: dict of model inputs\n        :param outputs: dict of model outputs\n        :return: tuple, indices and a dict.\n            In the dict, each value is (tensor, normalize, on_label), where\n            - normalize = True if the tensor need to be normalized to [0, 1]\n            - on_label = True if the tensor depends on label\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.plot_model": [[305, 327], ["network.RegistrationModel._model.summary", "tensorflow.keras.utils.plot_model", "logger.error", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.plot_model"], ["", "def", "plot_model", "(", "self", ",", "output_dir", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Save model structure in png.\n\n        :param output_dir: path to the output dir.\n        \"\"\"", "\n", "self", ".", "_model", ".", "summary", "(", "print_fn", "=", "logger", ".", "debug", ")", "\n", "try", ":", "\n", "            ", "tf", ".", "keras", ".", "utils", ".", "plot_model", "(", "\n", "self", ".", "_model", ",", "\n", "to_file", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "f\"{self.name}.png\"", ")", ",", "\n", "dpi", "=", "96", ",", "\n", "show_shapes", "=", "True", ",", "\n", "show_layer_names", "=", "True", ",", "\n", "expand_nested", "=", "False", ",", "\n", ")", "\n", "", "except", "ImportError", "as", "err", ":", "# pragma: no cover", "\n", "            ", "logger", ".", "error", "(", "\n", "\"Failed to plot model structure. \"", "\n", "\"Please check if graphviz is installed. \"", "\n", "\"Error message is: %s.\"", ",", "\n", "err", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.log_tensor_stats": [[329, 351], ["tensorflow.reshape", "network.RegistrationModel._model.add_metric", "network.RegistrationModel._model.add_metric", "network.RegistrationModel._model.add_metric", "tensorflow.reduce_mean", "tensorflow.reduce_min", "tensorflow.reduce_max"], "methods", ["None"], ["", "", "def", "log_tensor_stats", "(", "self", ",", "tensor", ":", "tf", ".", "Tensor", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Log statistics of a given tensor.\n\n        :param tensor: tensor to monitor.\n        :param name: name of the tensor.\n        \"\"\"", "\n", "flatten", "=", "tf", ".", "reshape", "(", "tensor", ",", "shape", "=", "(", "self", ".", "batch_size", ",", "-", "1", ")", ")", "\n", "self", ".", "_model", ".", "add_metric", "(", "\n", "tf", ".", "reduce_mean", "(", "flatten", ",", "axis", "=", "1", ")", ",", "\n", "name", "=", "f\"metric/{name}_mean\"", ",", "\n", "aggregation", "=", "\"mean\"", ",", "\n", ")", "\n", "self", ".", "_model", ".", "add_metric", "(", "\n", "tf", ".", "reduce_min", "(", "flatten", ",", "axis", "=", "1", ")", ",", "\n", "name", "=", "f\"metric/{name}_min\"", ",", "\n", "aggregation", "=", "\"min\"", ",", "\n", ")", "\n", "self", ".", "_model", ".", "add_metric", "(", "\n", "tf", ".", "reduce_max", "(", "flatten", ",", "axis", "=", "1", ")", ",", "\n", "name", "=", "f\"metric/{name}_max\"", ",", "\n", "aggregation", "=", "\"max\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DDFModel._resize_interpolate": [[366, 374], ["deepreg.model.layer.ResizeCPTransform", "deepreg.model.layer.ResizeCPTransform.", "deepreg.model.layer.BSplines3DTransform", "deepreg.model.layer.BSplines3DTransform."], "methods", ["None"], ["def", "_resize_interpolate", "(", "self", ",", "field", ",", "control_points", ")", ":", "\n", "        ", "resize", "=", "layer", ".", "ResizeCPTransform", "(", "control_points", ")", "\n", "field", "=", "resize", "(", "field", ")", "\n", "\n", "interpolate", "=", "layer", ".", "BSplines3DTransform", "(", "control_points", ",", "self", ".", "fixed_image_size", ")", "\n", "field", "=", "interpolate", "(", "field", ")", "\n", "\n", "return", "field", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DDFModel.build_model": [[375, 422], ["network.DDFModel.build_inputs", "network.DDFModel.config[].pop", "network.DDFModel.concat_images", "deepreg.registry.REGISTRY.build_backbone", "isinstance", "deepreg.model.layer.Warping", "deepreg.model.layer.Warping.", "deepreg.model.layer.Warping.", "tensorflow.keras.Model", "deepreg.registry.REGISTRY.build_backbone.", "dict", "deepreg.registry.REGISTRY.build_backbone.", "dict", "tensorflow.keras.Model", "dict", "network.DDFModel._resize_interpolate"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.build_inputs", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.concat_images", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_backbone", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DDFModel._resize_interpolate"], ["", "def", "build_model", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build the model to be saved as self._model.\"\"\"", "\n", "# build inputs", "\n", "self", ".", "_inputs", "=", "self", ".", "build_inputs", "(", ")", "\n", "moving_image", "=", "self", ".", "_inputs", "[", "\"moving_image\"", "]", "# (batch, m_dim1, m_dim2, m_dim3)", "\n", "fixed_image", "=", "self", ".", "_inputs", "[", "\"fixed_image\"", "]", "# (batch, f_dim1, f_dim2, f_dim3)", "\n", "\n", "# build ddf", "\n", "control_points", "=", "self", ".", "config", "[", "\"backbone\"", "]", ".", "pop", "(", "\"control_points\"", ",", "False", ")", "\n", "backbone_inputs", "=", "self", ".", "concat_images", "(", "moving_image", ",", "fixed_image", ")", "\n", "backbone", "=", "REGISTRY", ".", "build_backbone", "(", "\n", "config", "=", "self", ".", "config", "[", "\"backbone\"", "]", ",", "\n", "default_args", "=", "dict", "(", "\n", "image_size", "=", "self", ".", "fixed_image_size", ",", "\n", "out_channels", "=", "3", ",", "\n", "out_kernel_initializer", "=", "\"zeros\"", ",", "\n", "out_activation", "=", "None", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "if", "isinstance", "(", "backbone", ",", "GlobalNet", ")", ":", "\n", "# (f_dim1, f_dim2, f_dim3, 3), (4, 3)", "\n", "            ", "ddf", ",", "theta", "=", "backbone", "(", "inputs", "=", "backbone_inputs", ")", "\n", "self", ".", "_outputs", "=", "dict", "(", "ddf", "=", "ddf", ",", "theta", "=", "theta", ")", "\n", "", "else", ":", "\n", "# (f_dim1, f_dim2, f_dim3, 3)", "\n", "            ", "ddf", "=", "backbone", "(", "inputs", "=", "backbone_inputs", ")", "\n", "ddf", "=", "(", "\n", "self", ".", "_resize_interpolate", "(", "ddf", ",", "control_points", ")", "if", "control_points", "else", "ddf", "\n", ")", "\n", "self", ".", "_outputs", "=", "dict", "(", "ddf", "=", "ddf", ")", "\n", "\n", "# build outputs", "\n", "", "warping", "=", "layer", ".", "Warping", "(", "fixed_image_size", "=", "self", ".", "fixed_image_size", ")", "\n", "# (f_dim1, f_dim2, f_dim3)", "\n", "pred_fixed_image", "=", "warping", "(", "inputs", "=", "[", "ddf", ",", "moving_image", "]", ")", "\n", "self", ".", "_outputs", "[", "\"pred_fixed_image\"", "]", "=", "pred_fixed_image", "\n", "\n", "if", "not", "self", ".", "labeled", ":", "\n", "            ", "return", "tf", ".", "keras", ".", "Model", "(", "inputs", "=", "self", ".", "_inputs", ",", "outputs", "=", "self", ".", "_outputs", ")", "\n", "\n", "# (f_dim1, f_dim2, f_dim3)", "\n", "", "moving_label", "=", "self", ".", "_inputs", "[", "\"moving_label\"", "]", "\n", "pred_fixed_label", "=", "warping", "(", "inputs", "=", "[", "ddf", ",", "moving_label", "]", ")", "\n", "\n", "self", ".", "_outputs", "[", "\"pred_fixed_label\"", "]", "=", "pred_fixed_label", "\n", "return", "tf", ".", "keras", ".", "Model", "(", "inputs", "=", "self", ".", "_inputs", ",", "outputs", "=", "self", ".", "_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DDFModel.build_loss": [[423, 431], ["network.RegistrationModel.build_loss", "network.DDFModel._build_loss", "network.DDFModel.log_tensor_stats", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel._build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.log_tensor_stats"], ["", "def", "build_loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build losses according to configs.\"\"\"", "\n", "super", "(", ")", ".", "build_loss", "(", ")", "\n", "\n", "# ddf loss and metrics", "\n", "ddf", "=", "self", ".", "_outputs", "[", "\"ddf\"", "]", "\n", "self", ".", "_build_loss", "(", "name", "=", "\"regularization\"", ",", "inputs_dict", "=", "dict", "(", "inputs", "=", "ddf", ")", ")", "\n", "self", ".", "log_tensor_stats", "(", "tensor", "=", "ddf", ",", "name", "=", "\"ddf\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DDFModel.postprocess": [[432, 472], ["dict", "dict"], "methods", ["None"], ["", "def", "postprocess", "(", "\n", "self", ",", "\n", "inputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", "outputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", ")", "->", "Tuple", "[", "tf", ".", "Tensor", ",", "Dict", "]", ":", "\n", "        ", "\"\"\"\n        Return a dict used for saving inputs and outputs.\n\n        :param inputs: dict of model inputs\n        :param outputs: dict of model outputs\n        :return: tuple, indices and a dict.\n            In the dict, each value is (tensor, normalize, on_label), where\n            - normalize = True if the tensor need to be normalized to [0, 1]\n            - on_label = True if the tensor depends on label\n        \"\"\"", "\n", "indices", "=", "inputs", "[", "\"indices\"", "]", "\n", "processed", "=", "dict", "(", "\n", "moving_image", "=", "(", "inputs", "[", "\"moving_image\"", "]", ",", "True", ",", "False", ")", ",", "\n", "fixed_image", "=", "(", "inputs", "[", "\"fixed_image\"", "]", ",", "True", ",", "False", ")", ",", "\n", "ddf", "=", "(", "outputs", "[", "\"ddf\"", "]", ",", "True", ",", "False", ")", ",", "\n", "pred_fixed_image", "=", "(", "outputs", "[", "\"pred_fixed_image\"", "]", ",", "True", ",", "False", ")", ",", "\n", ")", "\n", "\n", "# save theta for affine model", "\n", "if", "\"theta\"", "in", "outputs", ":", "\n", "            ", "processed", "[", "\"theta\"", "]", "=", "(", "outputs", "[", "\"theta\"", "]", ",", "None", ",", "None", ")", "# type: ignore", "\n", "\n", "", "if", "not", "self", ".", "labeled", ":", "\n", "            ", "return", "indices", ",", "processed", "\n", "\n", "", "processed", "=", "{", "\n", "**", "dict", "(", "\n", "moving_label", "=", "(", "inputs", "[", "\"moving_label\"", "]", ",", "False", ",", "True", ")", ",", "\n", "fixed_label", "=", "(", "inputs", "[", "\"fixed_label\"", "]", ",", "False", ",", "True", ")", ",", "\n", "pred_fixed_label", "=", "(", "outputs", "[", "\"pred_fixed_label\"", "]", ",", "False", ",", "True", ")", ",", "\n", ")", ",", "\n", "**", "processed", ",", "\n", "}", "\n", "\n", "return", "indices", ",", "processed", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_model": [[484, 523], ["network.DVFModel.build_inputs", "network.DVFModel.config[].pop", "network.DVFModel.concat_images", "deepreg.registry.REGISTRY.build_backbone", "deepreg.registry.REGISTRY.build_backbone.", "deepreg.model.layer.Warping", "network.DVFModel._warping", "dict", "network.DVFModel._warping", "tensorflow.keras.Model", "network.DVFModel._resize_interpolate", "deepreg.model.layer.IntDVF", "tensorflow.keras.Model", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.build_inputs", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.concat_images", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_backbone", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DDFModel._resize_interpolate"], ["def", "build_model", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build the model to be saved as self._model.\"\"\"", "\n", "# build inputs", "\n", "self", ".", "_inputs", "=", "self", ".", "build_inputs", "(", ")", "\n", "moving_image", "=", "self", ".", "_inputs", "[", "\"moving_image\"", "]", "\n", "fixed_image", "=", "self", ".", "_inputs", "[", "\"fixed_image\"", "]", "\n", "control_points", "=", "self", ".", "config", "[", "\"backbone\"", "]", ".", "pop", "(", "\"control_points\"", ",", "False", ")", "\n", "\n", "# build ddf", "\n", "backbone_inputs", "=", "self", ".", "concat_images", "(", "moving_image", ",", "fixed_image", ")", "\n", "backbone", "=", "REGISTRY", ".", "build_backbone", "(", "\n", "config", "=", "self", ".", "config", "[", "\"backbone\"", "]", ",", "\n", "default_args", "=", "dict", "(", "\n", "image_size", "=", "self", ".", "fixed_image_size", ",", "\n", "out_channels", "=", "3", ",", "\n", "out_kernel_initializer", "=", "\"zeros\"", ",", "\n", "out_activation", "=", "None", ",", "\n", ")", ",", "\n", ")", "\n", "dvf", "=", "backbone", "(", "inputs", "=", "backbone_inputs", ")", "\n", "dvf", "=", "self", ".", "_resize_interpolate", "(", "dvf", ",", "control_points", ")", "if", "control_points", "else", "dvf", "\n", "ddf", "=", "layer", ".", "IntDVF", "(", "fixed_image_size", "=", "self", ".", "fixed_image_size", ")", "(", "dvf", ")", "\n", "\n", "# build outputs", "\n", "self", ".", "_warping", "=", "layer", ".", "Warping", "(", "fixed_image_size", "=", "self", ".", "fixed_image_size", ")", "\n", "# (f_dim1, f_dim2, f_dim3, 3)", "\n", "pred_fixed_image", "=", "self", ".", "_warping", "(", "inputs", "=", "[", "ddf", ",", "moving_image", "]", ")", "\n", "\n", "self", ".", "_outputs", "=", "dict", "(", "dvf", "=", "dvf", ",", "ddf", "=", "ddf", ",", "pred_fixed_image", "=", "pred_fixed_image", ")", "\n", "\n", "if", "not", "self", ".", "labeled", ":", "\n", "            ", "return", "tf", ".", "keras", ".", "Model", "(", "inputs", "=", "self", ".", "_inputs", ",", "outputs", "=", "self", ".", "_outputs", ")", "\n", "\n", "# (f_dim1, f_dim2, f_dim3, 3)", "\n", "", "moving_label", "=", "self", ".", "_inputs", "[", "\"moving_label\"", "]", "\n", "pred_fixed_label", "=", "self", ".", "_warping", "(", "inputs", "=", "[", "ddf", ",", "moving_label", "]", ")", "\n", "\n", "self", ".", "_outputs", "[", "\"pred_fixed_label\"", "]", "=", "pred_fixed_label", "\n", "return", "tf", ".", "keras", ".", "Model", "(", "inputs", "=", "self", ".", "_inputs", ",", "outputs", "=", "self", ".", "_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_loss": [[524, 531], ["network.DDFModel.build_loss", "network.DVFModel.log_tensor_stats"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.build_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.log_tensor_stats"], ["", "def", "build_loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build losses according to configs.\"\"\"", "\n", "super", "(", ")", ".", "build_loss", "(", ")", "\n", "\n", "# dvf metrics", "\n", "dvf", "=", "self", ".", "_outputs", "[", "\"dvf\"", "]", "\n", "self", ".", "log_tensor_stats", "(", "tensor", "=", "dvf", ",", "name", "=", "\"dvf\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.DVFModel.postprocess": [[532, 550], ["network.DDFModel.postprocess"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.postprocess"], ["", "def", "postprocess", "(", "\n", "self", ",", "\n", "inputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", "outputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", ")", "->", "Tuple", "[", "tf", ".", "Tensor", ",", "Dict", "]", ":", "\n", "        ", "\"\"\"\n        Return a dict used for saving inputs and outputs.\n\n        :param inputs: dict of model inputs\n        :param outputs: dict of model outputs\n        :return: tuple, indices and a dict.\n            In the dict, each value is (tensor, normalize, on_label), where\n            - normalize = True if the tensor need to be normalized to [0, 1]\n            - on_label = True if the tensor depends on label\n        \"\"\"", "\n", "indices", ",", "processed", "=", "super", "(", ")", ".", "postprocess", "(", "inputs", "=", "inputs", ",", "outputs", "=", "outputs", ")", "\n", "processed", "[", "\"dvf\"", "]", "=", "(", "outputs", "[", "\"dvf\"", "]", ",", "True", ",", "False", ")", "\n", "return", "indices", ",", "processed", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.build_model": [[560, 587], ["network.ConditionalModel.build_inputs", "network.ConditionalModel.concat_images", "deepreg.registry.REGISTRY.build_backbone", "deepreg.registry.REGISTRY.build_backbone.", "tensorflow.squeeze", "dict", "tensorflow.keras.Model", "dict"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.build_inputs", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.RegistrationModel.concat_images", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.registry.Registry.build_backbone"], ["def", "build_model", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build the model to be saved as self._model.\"\"\"", "\n", "assert", "self", ".", "labeled", "\n", "\n", "# build inputs", "\n", "self", ".", "_inputs", "=", "self", ".", "build_inputs", "(", ")", "\n", "moving_image", "=", "self", ".", "_inputs", "[", "\"moving_image\"", "]", "\n", "fixed_image", "=", "self", ".", "_inputs", "[", "\"fixed_image\"", "]", "\n", "moving_label", "=", "self", ".", "_inputs", "[", "\"moving_label\"", "]", "\n", "\n", "# build ddf", "\n", "backbone_inputs", "=", "self", ".", "concat_images", "(", "moving_image", ",", "fixed_image", ",", "moving_label", ")", "\n", "backbone", "=", "REGISTRY", ".", "build_backbone", "(", "\n", "config", "=", "self", ".", "config", "[", "\"backbone\"", "]", ",", "\n", "default_args", "=", "dict", "(", "\n", "image_size", "=", "self", ".", "fixed_image_size", ",", "\n", "out_channels", "=", "1", ",", "\n", "out_kernel_initializer", "=", "\"glorot_uniform\"", ",", "\n", "out_activation", "=", "\"sigmoid\"", ",", "\n", ")", ",", "\n", ")", "\n", "# (batch, f_dim1, f_dim2, f_dim3)", "\n", "pred_fixed_label", "=", "backbone", "(", "inputs", "=", "backbone_inputs", ")", "\n", "pred_fixed_label", "=", "tf", ".", "squeeze", "(", "pred_fixed_label", ",", "axis", "=", "4", ")", "\n", "\n", "self", ".", "_outputs", "=", "dict", "(", "pred_fixed_label", "=", "pred_fixed_label", ")", "\n", "return", "tf", ".", "keras", ".", "Model", "(", "inputs", "=", "self", ".", "_inputs", ",", "outputs", "=", "self", ".", "_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.ConditionalModel.postprocess": [[588, 613], ["dict"], "methods", ["None"], ["", "def", "postprocess", "(", "\n", "self", ",", "\n", "inputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", "outputs", ":", "Dict", "[", "str", ",", "tf", ".", "Tensor", "]", ",", "\n", ")", "->", "Tuple", "[", "tf", ".", "Tensor", ",", "Dict", "]", ":", "\n", "        ", "\"\"\"\n        Return a dict used for saving inputs and outputs.\n\n        :param inputs: dict of model inputs\n        :param outputs: dict of model outputs\n        :return: tuple, indices and a dict.\n            In the dict, each value is (tensor, normalize, on_label), where\n            - normalize = True if the tensor need to be normalized to [0, 1]\n            - on_label = True if the tensor depends on label\n        \"\"\"", "\n", "indices", "=", "inputs", "[", "\"indices\"", "]", "\n", "processed", "=", "dict", "(", "\n", "moving_image", "=", "(", "inputs", "[", "\"moving_image\"", "]", ",", "True", ",", "False", ")", ",", "\n", "fixed_image", "=", "(", "inputs", "[", "\"fixed_image\"", "]", ",", "True", ",", "False", ")", ",", "\n", "pred_fixed_label", "=", "(", "outputs", "[", "\"pred_fixed_label\"", "]", ",", "True", ",", "True", ")", ",", "\n", "moving_label", "=", "(", "inputs", "[", "\"moving_label\"", "]", ",", "False", ",", "True", ")", ",", "\n", "fixed_label", "=", "(", "inputs", "[", "\"fixed_label\"", "]", ",", "False", ",", "True", ")", ",", "\n", ")", "\n", "\n", "return", "indices", ",", "processed", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.network.dict_without": [[17, 28], ["copy.deepcopy", "copy.deepcopy.pop"], "function", ["None"], ["def", "dict_without", "(", "d", ":", "dict", ",", "key", ")", "->", "dict", ":", "\n", "    ", "\"\"\"\n    Return a copy of the given dict without a certain key.\n\n    :param d: dict to be copied.\n    :param key: key to be removed.\n    :return: the copy without a key\n    \"\"\"", "\n", "copied", "=", "deepcopy", "(", "d", ")", "\n", "copied", ".", "pop", "(", "key", ")", "\n", "return", "copied", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.NormBlock.__init__": [[20, 48], ["tensorflow.Layer.__init__", "dict", "tensorflow.Activation", "tensorflow.Activation"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "layer_name", ":", "str", ",", "\n", "norm_name", ":", "str", "=", "\"batch\"", ",", "\n", "activation", ":", "str", "=", "\"relu\"", ",", "\n", "name", ":", "str", "=", "\"norm_block\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param layer_name: class of the layer to be wrapped.\n        :param norm_name: class of the normalization layer.\n        :param activation: name of activation.\n        :param name: name of the block layer.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_config", "=", "dict", "(", "\n", "layer_name", "=", "layer_name", ",", "\n", "norm_name", "=", "norm_name", ",", "\n", "activation", "=", "activation", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "_layer", "=", "LAYER_DICT", "[", "layer_name", "]", "(", "use_bias", "=", "False", ",", "**", "kwargs", ")", "\n", "self", ".", "_norm", "=", "NORM_DICT", "[", "norm_name", "]", "(", ")", "\n", "self", ".", "_act", "=", "tfkl", ".", "Activation", "(", "activation", "=", "activation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.NormBlock.call": [[49, 62], ["layer.NormBlock._layer", "layer.NormBlock._norm", "layer.NormBlock._act"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "None", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Forward.\n\n        :param inputs: inputs for the layer\n        :param training: training flag for normalization layers (default: None)\n        :param kwargs: additional arguments.\n        :return:\n        \"\"\"", "\n", "output", "=", "self", ".", "_layer", "(", "inputs", "=", "inputs", ")", "\n", "output", "=", "self", ".", "_norm", "(", "inputs", "=", "output", ",", "training", "=", "training", ")", "\n", "output", "=", "self", ".", "_act", "(", "output", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.NormBlock.get_config": [[63, 68], ["super().get_config", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "self", ".", "_config", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Conv3dBlock.__init__": [[75, 87], ["layer.NormBlock.__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", "=", "\"conv3d_block\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param name: name of the layer\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "layer_name", "=", "\"conv3d\"", ",", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Deconv3dBlock.__init__": [[94, 106], ["layer.NormBlock.__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", "=", "\"deconv3d_block\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param name: name of the layer\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "layer_name", "=", "\"deconv3d\"", ",", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Resize3d.__init__": [[116, 133], ["tensorflow.Layer.__init__", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "shape", ":", "tuple", ",", "\n", "method", ":", "str", "=", "tf", ".", "image", ".", "ResizeMethod", ".", "BILINEAR", ",", "\n", "name", ":", "str", "=", "\"resize3d\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init, save arguments.\n\n        :param shape: (dim1, dim2, dim3)\n        :param method: tf.image.ResizeMethod\n        :param name: name of the layer\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "assert", "len", "(", "shape", ")", "==", "3", "\n", "self", ".", "_shape", "=", "shape", "\n", "self", ".", "_method", "=", "method", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Resize3d.call": [[134, 216], ["len", "tensorflow.shape", "tensorflow.shape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.image.resize", "tensorflow.image.resize", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.image.resize", "tensorflow.image.resize", "tensorflow.reshape", "tensorflow.reshape", "tuple", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "len", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.squeeze", "ValueError"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ":", "tf", ".", "Tensor", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Perform two fold resize.\n\n        :param inputs: shape = (batch, dim1, dim2, dim3, channels)\n                                     or (batch, dim1, dim2, dim3)\n                                     or (dim1, dim2, dim3)\n        :param kwargs: additional arguments\n        :return: shape = (batch, out_dim1, out_dim2, out_dim3, channels)\n                                or (batch, dim1, dim2, dim3)\n                                or (dim1, dim2, dim3)\n        \"\"\"", "\n", "# sanity check", "\n", "image", "=", "inputs", "\n", "image_dim", "=", "len", "(", "image", ".", "shape", ")", "\n", "\n", "# init", "\n", "if", "image_dim", "==", "5", ":", "\n", "            ", "has_channel", "=", "True", "\n", "has_batch", "=", "True", "\n", "input_image_shape", "=", "image", ".", "shape", "[", "1", ":", "4", "]", "\n", "", "elif", "image_dim", "==", "4", ":", "\n", "            ", "has_channel", "=", "False", "\n", "has_batch", "=", "True", "\n", "input_image_shape", "=", "image", ".", "shape", "[", "1", ":", "4", "]", "\n", "", "elif", "image_dim", "==", "3", ":", "\n", "            ", "has_channel", "=", "False", "\n", "has_batch", "=", "False", "\n", "input_image_shape", "=", "image", ".", "shape", "[", "0", ":", "3", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Resize3d takes input image of dimension 3 or 4 or 5, \"", "\n", "\"corresponding to (dim1, dim2, dim3) \"", "\n", "\"or (batch, dim1, dim2, dim3) \"", "\n", "\"or (batch, dim1, dim2, dim3, channels), \"", "\n", "\"got image shape{}\"", ".", "format", "(", "image", ".", "shape", ")", "\n", ")", "\n", "\n", "# no need of resize", "\n", "", "if", "input_image_shape", "==", "tuple", "(", "self", ".", "_shape", ")", ":", "\n", "            ", "return", "image", "\n", "\n", "# expand to five dimensions", "\n", "", "if", "not", "has_batch", ":", "\n", "            ", "image", "=", "tf", ".", "expand_dims", "(", "image", ",", "axis", "=", "0", ")", "\n", "", "if", "not", "has_channel", ":", "\n", "            ", "image", "=", "tf", ".", "expand_dims", "(", "image", ",", "axis", "=", "-", "1", ")", "\n", "", "assert", "len", "(", "image", ".", "shape", ")", "==", "5", "# (batch, dim1, dim2, dim3, channels)", "\n", "image_shape", "=", "tf", ".", "shape", "(", "image", ")", "\n", "\n", "# merge axis 0 and 1", "\n", "output", "=", "tf", ".", "reshape", "(", "\n", "image", ",", "(", "-", "1", ",", "image_shape", "[", "2", "]", ",", "image_shape", "[", "3", "]", ",", "image_shape", "[", "4", "]", ")", "\n", ")", "# (batch * dim1, dim2, dim3, channels)", "\n", "\n", "# resize dim2 and dim3", "\n", "output", "=", "tf", ".", "image", ".", "resize", "(", "\n", "images", "=", "output", ",", "size", "=", "self", ".", "_shape", "[", "1", ":", "3", "]", ",", "method", "=", "self", ".", "_method", "\n", ")", "# (batch * dim1, out_dim2, out_dim3, channels)", "\n", "\n", "# split axis 0 and merge axis 3 and 4", "\n", "output", "=", "tf", ".", "reshape", "(", "\n", "output", ",", "\n", "shape", "=", "(", "-", "1", ",", "image_shape", "[", "1", "]", ",", "self", ".", "_shape", "[", "1", "]", ",", "self", ".", "_shape", "[", "2", "]", "*", "image_shape", "[", "4", "]", ")", ",", "\n", ")", "# (batch, dim1, out_dim2, out_dim3 * channels)", "\n", "\n", "# resize dim1 and dim2", "\n", "output", "=", "tf", ".", "image", ".", "resize", "(", "\n", "images", "=", "output", ",", "size", "=", "self", ".", "_shape", "[", ":", "2", "]", ",", "method", "=", "self", ".", "_method", "\n", ")", "# (batch, out_dim1, out_dim2, out_dim3 * channels)", "\n", "\n", "# reshape", "\n", "output", "=", "tf", ".", "reshape", "(", "\n", "output", ",", "shape", "=", "[", "-", "1", ",", "*", "self", ".", "_shape", ",", "image_shape", "[", "4", "]", "]", "\n", ")", "# (batch, out_dim1, out_dim2, out_dim3, channels)", "\n", "\n", "# squeeze to original dimension", "\n", "if", "not", "has_batch", ":", "\n", "            ", "output", "=", "tf", ".", "squeeze", "(", "output", ",", "axis", "=", "0", ")", "\n", "", "if", "not", "has_channel", ":", "\n", "            ", "output", "=", "tf", ".", "squeeze", "(", "output", ",", "axis", "=", "-", "1", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Resize3d.get_config": [[217, 223], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", "[", "\"shape\"", "]", "=", "self", ".", "_shape", "\n", "config", "[", "\"method\"", "]", "=", "self", ".", "_method", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Warping.__init__": [[235, 249], ["tensorflow.Layer.__init__", "deepreg.model.layer_util.get_reference_grid"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_reference_grid"], ["def", "__init__", "(", "self", ",", "fixed_image_size", ":", "tuple", ",", "name", ":", "str", "=", "\"warping\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param fixed_image_size: shape = (f_dim1, f_dim2, f_dim3)\n             or (f_dim1, f_dim2, f_dim3, ch) with the last channel for features\n        :param name: name of the layer\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "self", ".", "_fixed_image_size", "=", "fixed_image_size", "\n", "# shape = (1, f_dim1, f_dim2, f_dim3, 3)", "\n", "self", ".", "grid_ref", "=", "layer_util", ".", "get_reference_grid", "(", "grid_size", "=", "fixed_image_size", ")", "[", "\n", "None", ",", "...", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Warping.call": [[251, 262], ["deepreg.model.layer_util.resample"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.resample"], ["", "def", "call", "(", "self", ",", "inputs", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        :param inputs: (ddf, image)\n\n          - ddf, shape = (batch, f_dim1, f_dim2, f_dim3, 3)\n          - image, shape = (batch, m_dim1, m_dim2, m_dim3)\n        :param kwargs: additional arguments.\n        :return: shape = (batch, f_dim1, f_dim2, f_dim3)\n        \"\"\"", "\n", "ddf", ",", "image", "=", "inputs", "\n", "return", "layer_util", ".", "resample", "(", "vol", "=", "image", ",", "loc", "=", "self", ".", "grid_ref", "+", "ddf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Warping.get_config": [[263, 268], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", "[", "\"fixed_image_size\"", "]", "=", "self", ".", "_fixed_image_size", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.ResidualBlock.__init__": [[275, 309], ["tensorflow.Layer.__init__", "dict", "tensorflow.Activation", "tensorflow.Activation", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "layer_name", ":", "str", ",", "\n", "num_layers", ":", "int", "=", "2", ",", "\n", "norm_name", ":", "str", "=", "\"batch\"", ",", "\n", "activation", ":", "str", "=", "\"relu\"", ",", "\n", "name", ":", "str", "=", "\"res_block\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param layer_name: class of the layer to be wrapped.\n        :param num_layers: number of layers/blocks.\n        :param norm_name: class of the normalization layer.\n        :param activation: name of activation.\n        :param name: name of the block layer.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_num_layers", "=", "num_layers", "\n", "self", ".", "_config", "=", "dict", "(", "\n", "layer_name", "=", "layer_name", ",", "\n", "num_layers", "=", "num_layers", ",", "\n", "norm_name", "=", "norm_name", ",", "\n", "activation", "=", "activation", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "_layers", "=", "[", "\n", "LAYER_DICT", "[", "layer_name", "]", "(", "use_bias", "=", "False", ",", "**", "kwargs", ")", "for", "_", "in", "range", "(", "num_layers", ")", "\n", "]", "\n", "self", ".", "_norms", "=", "[", "NORM_DICT", "[", "norm_name", "]", "(", ")", "for", "_", "in", "range", "(", "num_layers", ")", "]", "\n", "self", ".", "_acts", "=", "[", "tfkl", ".", "Activation", "(", "activation", "=", "activation", ")", "for", "_", "in", "range", "(", "num_layers", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.ResidualBlock.call": [[310, 329], ["range"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "None", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Forward.\n\n        :param inputs: inputs for the layer\n        :param training: training flag for normalization layers (default: None)\n        :param kwargs: additional arguments.\n        :return:\n        \"\"\"", "\n", "\n", "output", "=", "inputs", "\n", "for", "i", "in", "range", "(", "self", ".", "_num_layers", ")", ":", "\n", "            ", "output", "=", "self", ".", "_layers", "[", "i", "]", "(", "inputs", "=", "output", ")", "\n", "output", "=", "self", ".", "_norms", "[", "i", "]", "(", "inputs", "=", "output", ",", "training", "=", "training", ")", "\n", "if", "i", "==", "self", ".", "_num_layers", "-", "1", ":", "\n", "# last block", "\n", "                ", "output", "=", "output", "+", "inputs", "\n", "", "output", "=", "self", ".", "_acts", "[", "i", "]", "(", "output", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.ResidualBlock.get_config": [[330, 335], ["super().get_config", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "self", ".", "_config", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.ResidualConv3dBlock.__init__": [[342, 354], ["layer.ResidualBlock.__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", "=", "\"conv3d_res_block\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param name: name of the layer\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "layer_name", "=", "\"conv3d\"", ",", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.IntDVF.__init__": [[366, 386], ["tensorflow.Layer.__init__", "layer.Warping", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "fixed_image_size", ":", "tuple", ",", "\n", "num_steps", ":", "int", "=", "7", ",", "\n", "name", ":", "str", "=", "\"int_dvf\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param fixed_image_size: tuple, (f_dim1, f_dim2, f_dim3)\n        :param num_steps: int, number of steps for integration\n        :param name: name of the layer\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "assert", "len", "(", "fixed_image_size", ")", "==", "3", "\n", "self", ".", "_fixed_image_size", "=", "fixed_image_size", "\n", "self", ".", "_num_steps", "=", "num_steps", "\n", "self", ".", "_warping", "=", "Warping", "(", "fixed_image_size", "=", "fixed_image_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.IntDVF.call": [[387, 397], ["range", "layer.IntDVF._warping"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ":", "tf", ".", "Tensor", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        :param inputs: dvf, shape = (batch, f_dim1, f_dim2, f_dim3, 3)\n        :param kwargs: additional arguments.\n        :return: ddf, shape = (batch, f_dim1, f_dim2, f_dim3, 3)\n        \"\"\"", "\n", "ddf", "=", "inputs", "/", "(", "2", "**", "self", ".", "_num_steps", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "_num_steps", ")", ":", "\n", "            ", "ddf", "+=", "self", ".", "_warping", "(", "inputs", "=", "[", "ddf", ",", "ddf", "]", ")", "\n", "", "return", "ddf", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.IntDVF.get_config": [[398, 404], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", "[", "\"fixed_image_size\"", "]", "=", "self", ".", "_fixed_image_size", "\n", "config", "[", "\"num_steps\"", "]", "=", "self", ".", "_num_steps", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.ResizeCPTransform.__init__": [[412, 431], ["tensorflow.Layer.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "control_point_spacing", ":", "Union", "[", "List", "[", "int", "]", ",", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param control_point_spacing: list or int\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "if", "isinstance", "(", "control_point_spacing", ",", "int", ")", ":", "\n", "            ", "control_point_spacing", "=", "[", "control_point_spacing", "]", "*", "3", "\n", "\n", "", "self", ".", "kernel_sigma", "=", "[", "\n", "0.44", "*", "cp", "for", "cp", "in", "control_point_spacing", "\n", "]", "# 0.44 = ln(4)/pi", "\n", "self", ".", "cp_spacing", "=", "control_point_spacing", "\n", "self", ".", "kernel", "=", "None", "\n", "self", ".", "_output_shape", "=", "None", "\n", "self", ".", "_resize", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.ResizeCPTransform.build": [[432, 442], ["super().build", "deepreg.model.layer_util.gaussian_filter_3d", "tuple", "layer.Resize3d", "tensorflow.cast", "tensorflow.cast", "zip", "tensorflow.math.ceil", "tensorflow.math.ceil"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.build", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.gaussian_filter_3d"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "build", "(", "input_shape", "=", "input_shape", ")", "\n", "\n", "self", ".", "kernel", "=", "layer_util", ".", "gaussian_filter_3d", "(", "self", ".", "kernel_sigma", ")", "\n", "output_shape", "=", "tuple", "(", "\n", "tf", ".", "cast", "(", "tf", ".", "math", ".", "ceil", "(", "v", "/", "c", ")", "+", "3", ",", "tf", ".", "int32", ")", "\n", "for", "v", ",", "c", "in", "zip", "(", "input_shape", "[", "1", ":", "-", "1", "]", ",", "self", ".", "cp_spacing", ")", "\n", ")", "\n", "self", ".", "_output_shape", "=", "output_shape", "\n", "self", ".", "_resize", "=", "Resize3d", "(", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.ResizeCPTransform.call": [[443, 449], ["tensorflow.nn.conv3d", "tensorflow.nn.conv3d", "layer.ResizeCPTransform._resize"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "output", "=", "tf", ".", "nn", ".", "conv3d", "(", "\n", "inputs", ",", "self", ".", "kernel", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", ",", "padding", "=", "\"SAME\"", "\n", ")", "\n", "output", "=", "self", ".", "_resize", "(", "inputs", "=", "output", ")", "# type: ignore", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.__init__": [[460, 482], ["tensorflow.Layer.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "cp_spacing", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "output_shape", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param cp_spacing: int or tuple of three ints specifying the spacing (in pixels)\n            in each dimension. When a single int is used,\n            the same spacing to all dimensions is used\n        :param output_shape: (batch_size, dim0, dim1, dim2, 3) of the high resolution\n            deformation fields.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "self", ".", "_output_shape", "=", "output_shape", "\n", "if", "isinstance", "(", "cp_spacing", ",", "int", ")", ":", "\n", "            ", "cp_spacing", "=", "(", "cp_spacing", ",", "cp_spacing", ",", "cp_spacing", ")", "\n", "", "self", ".", "cp_spacing", "=", "cp_spacing", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.build": [[483, 537], ["super().build", "numpy.zeros", "list", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "numpy.arange", "numpy.arange", "numpy.arange", "itertools.product", "range", "numpy.float64", "numpy.float64", "numpy.float64", "numpy.float64", "range"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.build"], ["", "def", "build", "(", "self", ",", "input_shape", ":", "tuple", ")", ":", "\n", "        ", "\"\"\"\n        :param input_shape: tuple with the input shape\n        :return: None\n        \"\"\"", "\n", "\n", "super", "(", ")", ".", "build", "(", "input_shape", "=", "input_shape", ")", "\n", "\n", "b", "=", "{", "\n", "0", ":", "lambda", "u", ":", "np", ".", "float64", "(", "(", "1", "-", "u", ")", "**", "3", "/", "6", ")", ",", "\n", "1", ":", "lambda", "u", ":", "np", ".", "float64", "(", "(", "3", "*", "(", "u", "**", "3", ")", "-", "6", "*", "(", "u", "**", "2", ")", "+", "4", ")", "/", "6", ")", ",", "\n", "2", ":", "lambda", "u", ":", "np", ".", "float64", "(", "(", "-", "3", "*", "(", "u", "**", "3", ")", "+", "3", "*", "(", "u", "**", "2", ")", "+", "3", "*", "u", "+", "1", ")", "/", "6", ")", ",", "\n", "3", ":", "lambda", "u", ":", "np", ".", "float64", "(", "u", "**", "3", "/", "6", ")", ",", "\n", "}", "\n", "\n", "filters", "=", "np", ".", "zeros", "(", "\n", "(", "\n", "4", "*", "self", ".", "cp_spacing", "[", "0", "]", ",", "\n", "4", "*", "self", ".", "cp_spacing", "[", "1", "]", ",", "\n", "4", "*", "self", ".", "cp_spacing", "[", "2", "]", ",", "\n", "3", ",", "\n", "3", ",", "\n", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ",", "\n", ")", "\n", "\n", "u_arange", "=", "1", "-", "np", ".", "arange", "(", "\n", "1", "/", "(", "2", "*", "self", ".", "cp_spacing", "[", "0", "]", ")", ",", "1", ",", "1", "/", "self", ".", "cp_spacing", "[", "0", "]", "\n", ")", "\n", "v_arange", "=", "1", "-", "np", ".", "arange", "(", "\n", "1", "/", "(", "2", "*", "self", ".", "cp_spacing", "[", "1", "]", ")", ",", "1", ",", "1", "/", "self", ".", "cp_spacing", "[", "1", "]", "\n", ")", "\n", "w_arange", "=", "1", "-", "np", ".", "arange", "(", "\n", "1", "/", "(", "2", "*", "self", ".", "cp_spacing", "[", "2", "]", ")", ",", "1", ",", "1", "/", "self", ".", "cp_spacing", "[", "2", "]", "\n", ")", "\n", "\n", "filter_idx", "=", "[", "[", "0", ",", "1", ",", "2", ",", "3", "]", "for", "_", "in", "range", "(", "3", ")", "]", "\n", "filter_coord", "=", "list", "(", "itertools", ".", "product", "(", "*", "filter_idx", ")", ")", "\n", "\n", "for", "f_idx", "in", "filter_coord", ":", "\n", "            ", "for", "it_dim", "in", "range", "(", "3", ")", ":", "\n", "                ", "filters", "[", "\n", "f_idx", "[", "0", "]", "*", "self", ".", "cp_spacing", "[", "0", "]", ":", "(", "f_idx", "[", "0", "]", "+", "1", ")", "*", "self", ".", "cp_spacing", "[", "0", "]", ",", "\n", "f_idx", "[", "1", "]", "*", "self", ".", "cp_spacing", "[", "1", "]", ":", "(", "f_idx", "[", "1", "]", "+", "1", ")", "*", "self", ".", "cp_spacing", "[", "1", "]", ",", "\n", "f_idx", "[", "2", "]", "*", "self", ".", "cp_spacing", "[", "2", "]", ":", "(", "f_idx", "[", "2", "]", "+", "1", ")", "*", "self", ".", "cp_spacing", "[", "2", "]", ",", "\n", "it_dim", ",", "\n", "it_dim", ",", "\n", "]", "=", "(", "\n", "b", "[", "f_idx", "[", "0", "]", "]", "(", "u_arange", ")", "[", ":", ",", "None", ",", "None", "]", "\n", "*", "b", "[", "f_idx", "[", "1", "]", "]", "(", "v_arange", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "*", "b", "[", "f_idx", "[", "2", "]", "]", "(", "w_arange", ")", "[", "None", ",", "None", ",", ":", "]", "\n", ")", "\n", "\n", "", "", "self", ".", "filter", "=", "tf", ".", "convert_to_tensor", "(", "filters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.interpolate": [[538, 555], ["tuple", "tensorflow.nn.conv3d_transpose", "tensorflow.nn.conv3d_transpose", "zip"], "methods", ["None"], ["", "def", "interpolate", "(", "self", ",", "field", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        :param field: tf.Tensor with shape=number_of_control_points_per_dim\n        :return: interpolated_field: tf.Tensor\n        \"\"\"", "\n", "\n", "image_shape", "=", "tuple", "(", "\n", "[", "(", "a", "-", "1", ")", "*", "b", "+", "4", "*", "b", "for", "a", ",", "b", "in", "zip", "(", "field", ".", "shape", "[", "1", ":", "-", "1", "]", ",", "self", ".", "cp_spacing", ")", "]", "\n", ")", "\n", "\n", "output_shape", "=", "(", "field", ".", "shape", "[", "0", "]", ",", ")", "+", "image_shape", "+", "(", "3", ",", ")", "\n", "return", "tf", ".", "nn", ".", "conv3d_transpose", "(", "\n", "field", ",", "\n", "self", ".", "filter", ",", "\n", "output_shape", "=", "output_shape", ",", "\n", "strides", "=", "self", ".", "cp_spacing", ",", "\n", "padding", "=", "\"VALID\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.call": [[557, 571], ["layer.BSplines3DTransform.interpolate", "int"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.BSplines3DTransform.interpolate"], ["", "def", "call", "(", "self", ",", "inputs", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        :param inputs: tf.Tensor defining a low resolution free-form deformation field\n        :param kwargs: additional arguments.\n        :return: interpolated_field: tf.Tensor of shape=self.input_shape\n        \"\"\"", "\n", "high_res_field", "=", "self", ".", "interpolate", "(", "inputs", ")", "\n", "\n", "index", "=", "[", "int", "(", "3", "*", "c", ")", "for", "c", "in", "self", ".", "cp_spacing", "]", "\n", "return", "high_res_field", "[", "\n", ":", ",", "\n", "index", "[", "0", "]", ":", "index", "[", "0", "]", "+", "self", ".", "_output_shape", "[", "0", "]", ",", "\n", "index", "[", "1", "]", ":", "index", "[", "1", "]", "+", "self", ".", "_output_shape", "[", "1", "]", ",", "\n", "index", "[", "2", "]", ":", "index", "[", "2", "]", "+", "self", ".", "_output_shape", "[", "2", "]", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Extraction.__init__": [[575, 610], ["tensorflow.Layer.__init__", "max", "tensorflow.keras.Sequential", "tensorflow.keras.Sequential", "tensorflow.Conv3D", "tensorflow.Conv3D", "layer.Resize3d"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "out_channels", ":", "int", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", "name", ":", "str", "=", "\"Extraction\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param image_size: such as (dim1, dim2, dim3)\n        :param extract_levels: number of extraction levels.\n        :param out_channels: number of channels for the extractions\n        :param out_kernel_initializer: initializer to use for kernels.\n        :param out_activation: activation to use at end layer.\n        :param name: name of the layer\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "extract_levels", "=", "extract_levels", "\n", "self", ".", "max_level", "=", "max", "(", "extract_levels", ")", "\n", "self", ".", "layers", "=", "[", "\n", "tf", ".", "keras", ".", "Sequential", "(", "\n", "[", "\n", "tfkl", ".", "Conv3D", "(", "\n", "filters", "=", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "strides", "=", "1", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "activation", "=", "out_activation", ",", "\n", ")", ",", "\n", "Resize3d", "(", "shape", "=", "image_size", ")", ",", "\n", "]", "\n", ")", "\n", "for", "_", "in", "extract_levels", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer.Extraction.call": [[612, 627], ["len", "tensorflow.add_n", "tensorflow.add_n", "len", "enumerate"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ":", "List", "[", "tf", ".", "Tensor", "]", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Calculate the mean over some selected inputs.\n\n        :param inputs: a list of tensors\n        :param kwargs:\n        :return:\n        \"\"\"", "\n", "outputs", "=", "[", "\n", "self", ".", "layers", "[", "idx", "]", "(", "inputs", "=", "inputs", "[", "self", ".", "max_level", "-", "level", "]", ")", "\n", "for", "idx", ",", "level", "in", "enumerate", "(", "self", ".", "extract_levels", ")", "\n", "]", "\n", "if", "len", "(", "self", ".", "extract_levels", ")", "==", "1", ":", "\n", "            ", "return", "outputs", "[", "0", "]", "\n", "", "return", "tf", ".", "add_n", "(", "outputs", ")", "/", "len", "(", "self", ".", "extract_levels", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.optimizer.build_optimizer": [[8, 20], ["getattr", "getattr."], "function", ["None"], ["def", "build_optimizer", "(", "optimizer_config", ":", "dict", ")", "->", "tf", ".", "optimizers", ".", "Optimizer", ":", "\n", "    ", "\"\"\"\n    Parsing the optimiser options and parameters\n    from config dictionary.\n\n    :param optimizer_config: has key name and other required arguments\n    :return: optimizer instant\n    \"\"\"", "\n", "\n", "optimizer_cls", "=", "getattr", "(", "tf", ".", "keras", ".", "optimizers", ",", "optimizer_config", "[", "\"name\"", "]", ")", "\n", "optimizer", "=", "optimizer_cls", "(", "**", "optimizer_config", ")", "\n", "return", "optimizer", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.global_net.AffineHead.__init__": [[15, 33], ["tensorflow.Layer.__init__", "deepreg.model.layer_util.get_reference_grid", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.Flatten", "tensorflow.Flatten", "tensorflow.Dense", "tensorflow.Dense", "list", "numpy.eye().reshape", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.get_reference_grid"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "image_size", ":", "tuple", ",", "\n", "name", ":", "str", "=", "\"AffineHead\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param image_size: such as (dim1, dim2, dim3)\n        :param name: name of the layer\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "reference_grid", "=", "layer_util", ".", "get_reference_grid", "(", "image_size", ")", "\n", "self", ".", "transform_initial", "=", "tf", ".", "constant_initializer", "(", "\n", "value", "=", "list", "(", "np", ".", "eye", "(", "4", ",", "3", ")", ".", "reshape", "(", "(", "-", "1", ")", ")", ")", "\n", ")", "\n", "self", ".", "_flatten", "=", "tfkl", ".", "Flatten", "(", ")", "\n", "self", ".", "_dense", "=", "tfkl", ".", "Dense", "(", "units", "=", "12", ",", "bias_initializer", "=", "self", ".", "transform_initial", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.global_net.AffineHead.call": [[34, 54], ["isinstance", "global_net.AffineHead._dense", "tensorflow.reshape", "tensorflow.reshape", "deepreg.model.layer_util.warp_grid", "global_net.AffineHead._flatten"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.warp_grid"], ["", "def", "call", "(", "\n", "self", ",", "inputs", ":", "Union", "[", "tf", ".", "Tensor", ",", "List", "]", ",", "**", "kwargs", "\n", ")", "->", "Tuple", "[", "tf", ".", "Tensor", ",", "tf", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n\n        :param inputs: a tensor or a list of tensor with length 1\n        :param kwargs: additional args\n        :return: ddf and theta\n\n            - ddf has shape (batch, dim1, dim2, dim3, 3)\n            - theta has shape (batch, 4, 3)\n        \"\"\"", "\n", "if", "isinstance", "(", "inputs", ",", "list", ")", ":", "\n", "            ", "inputs", "=", "inputs", "[", "0", "]", "\n", "", "theta", "=", "self", ".", "_dense", "(", "self", ".", "_flatten", "(", "inputs", ")", ")", "\n", "theta", "=", "tf", ".", "reshape", "(", "theta", ",", "shape", "=", "(", "-", "1", ",", "4", ",", "3", ")", ")", "\n", "# warp the reference grid with affine parameters to output a ddf", "\n", "grid_warped", "=", "layer_util", ".", "warp_grid", "(", "self", ".", "reference_grid", ",", "theta", ")", "\n", "ddf", "=", "grid_warped", "-", "self", ".", "reference_grid", "\n", "return", "ddf", ",", "theta", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.global_net.AffineHead.get_config": [[55, 60], ["super().get_config", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "image_size", "=", "self", ".", "reference_grid", ".", "shape", "[", ":", "3", "]", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.global_net.GlobalNet.__init__": [[78, 118], ["deepreg.model.backbone.u_net.UNet.__init__", "max", "ValueError"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "image_size", ":", "tuple", ",", "\n", "num_channel_initial", ":", "int", ",", "\n", "extract_levels", ":", "Optional", "[", "Tuple", "[", "int", ",", "...", "]", "]", "=", "None", ",", "\n", "depth", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "name", ":", "str", "=", "\"GlobalNet\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Image is encoded gradually, i from level 0 to E.\n        Then, a densely-connected layer outputs an affine\n        transformation.\n\n        :param image_size: tuple, such as (dim1, dim2, dim3)\n        :param num_channel_initial: int, number of initial channels\n        :param extract_levels: list, which levels from net to extract, deprecated.\n            If depth is not given, depth = max(extract_levels) will be used.\n        :param depth: depth of the encoder. If given, extract_levels is not used.\n        :param name: name of the backbone.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "if", "depth", "is", "None", ":", "\n", "            ", "if", "extract_levels", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"GlobalNet requires `depth` or `extract_levels` \"", "\n", "\"to define the depth of encoder. \"", "\n", "\"If `depth` is not given, \"", "\n", "\"the maximum value of `extract_levels` will be used.\"", "\n", "\"However the argument `extract_levels` is deprecated \"", "\n", "\"and will be removed in future release.\"", "\n", ")", "\n", "", "depth", "=", "max", "(", "extract_levels", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "\n", "image_size", "=", "image_size", ",", "\n", "num_channel_initial", "=", "num_channel_initial", ",", "\n", "depth", "=", "depth", ",", "\n", "extract_levels", "=", "(", "depth", ",", ")", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.global_net.GlobalNet.build_output_block": [[120, 142], ["global_net.AffineHead"], "methods", ["None"], ["", "def", "build_output_block", "(", "\n", "self", ",", "\n", "image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "out_channels", ":", "int", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for output.\n\n        The input to this block is a list of length 1.\n        The output has two tensors.\n\n        :param image_size: such as (dim1, dim2, dim3)\n        :param extract_levels: not used\n        :param out_channels: not used\n        :param out_kernel_initializer: not used\n        :param out_activation: not used\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "return", "AffineHead", "(", "image_size", "=", "image_size", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.interface.Backbone.__init__": [[11, 39], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["from", "deepreg", "import", "log", "\n", "from", "deepreg", ".", "dataset", ".", "loader", ".", "util", "import", "normalize_array", "\n", "from", "deepreg", ".", "dataset", ".", "preprocess", "import", "resize_inputs", "\n", "from", "deepreg", ".", "dataset", ".", "util", "import", "get_label_indices", "\n", "from", "deepreg", ".", "registry", "import", "REGISTRY", "\n", "\n", "logger", "=", "log", ".", "get", "(", "__name__", ")", "\n", "\n", "\n", "class", "DataLoader", ":", "\n", "    ", "\"\"\"\n    loads data to feed to model.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "labeled", ":", "Optional", "[", "bool", "]", ",", "\n", "num_indices", ":", "Optional", "[", "int", "]", ",", "\n", "sample_label", ":", "Optional", "[", "str", "]", ",", "\n", "seed", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param labeled: bool corresponding to labels provided or omitted\n        :param num_indices:\n        :param sample_label:\n        :param seed:\n        \"\"\"", "\n", "assert", "labeled", "in", "[", "\n", "True", ",", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.interface.Backbone.call": [[40, 50], ["None"], "methods", ["None"], ["False", ",", "\n", "None", ",", "\n", "]", ",", "f\"labeled must be boolean, True or False or None, got {labeled}\"", "\n", "assert", "sample_label", "in", "[", "\n", "\"sample\"", ",", "\n", "\"all\"", ",", "\n", "None", ",", "\n", "]", ",", "f\"sample_label must be sample, all or None, got {sample_label}\"", "\n", "assert", "(", "\n", "num_indices", "is", "None", "or", "num_indices", ">=", "1", "\n", ")", ",", "f\"num_indices must be int >=1 or None, got {num_indices}\"", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.interface.Backbone.get_config": [[51, 60], ["dict"], "methods", ["None"], ["assert", "seed", "is", "None", "or", "isinstance", "(", "\n", "seed", ",", "int", "\n", ")", ",", "f\"seed must be None or int, got {seed}\"", "\n", "\n", "self", ".", "labeled", "=", "labeled", "\n", "self", ".", "num_indices", "=", "num_indices", "# number of indices to identify a sample", "\n", "self", ".", "sample_label", "=", "sample_label", "\n", "self", ".", "seed", "=", "seed", "# used for sampling", "\n", "\n", "", "@", "property", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.local_net.AdditiveUpsampling.__init__": [[15, 45], ["tensorflow.Layer.__init__", "deepreg.model.layer.Deconv3dBlock", "deepreg.model.layer.Resize3d"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "filters", ":", "int", ",", "\n", "output_padding", ":", "Union", "[", "int", ",", "Tuple", ",", "List", "]", ",", "\n", "kernel_size", ":", "Union", "[", "int", ",", "Tuple", ",", "List", "]", ",", "\n", "padding", ":", "str", ",", "\n", "strides", ":", "Union", "[", "int", ",", "Tuple", ",", "List", "]", ",", "\n", "output_shape", ":", "Tuple", ",", "\n", "name", ":", "str", "=", "\"AdditiveUpsampling\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Addictive up-sampling layer.\n\n        :param filters: number of channels for output\n        :param output_padding: padding for output\n        :param kernel_size: arg for deconv3d\n        :param padding: arg for deconv3d\n        :param strides: arg for deconv3d\n        :param output_shape: shape of the output tensor\n        :param name: name of the layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "deconv3d", "=", "layer", ".", "Deconv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "output_padding", "=", "output_padding", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n", "self", ".", "resize", "=", "layer", ".", "Resize3d", "(", "shape", "=", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.local_net.AdditiveUpsampling.call": [[46, 51], ["local_net.AdditiveUpsampling.deconv3d", "local_net.AdditiveUpsampling.resize", "tensorflow.add_n", "tensorflow.add_n", "tensorflow.split", "tensorflow.split"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "deconved", "=", "self", ".", "deconv3d", "(", "inputs", ")", "\n", "resized", "=", "self", ".", "resize", "(", "inputs", ")", "\n", "resized", "=", "tf", ".", "add_n", "(", "tf", ".", "split", "(", "resized", ",", "num_or_size_splits", "=", "2", ",", "axis", "=", "4", ")", ")", "\n", "return", "deconved", "+", "resized", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.local_net.AdditiveUpsampling.get_config": [[52, 65], ["super().get_config", "local_net.AdditiveUpsampling.deconv3d.get_config", "super().get_config.update", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "deconv_config", "=", "self", ".", "deconv3d", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "\n", "filters", "=", "deconv_config", "[", "\"filters\"", "]", ",", "\n", "output_padding", "=", "deconv_config", "[", "\"output_padding\"", "]", ",", "\n", "kernel_size", "=", "deconv_config", "[", "\"kernel_size\"", "]", ",", "\n", "strides", "=", "deconv_config", "[", "\"strides\"", "]", ",", "\n", "padding", "=", "deconv_config", "[", "\"padding\"", "]", ",", "\n", ")", "\n", "config", ".", "update", "(", "output_shape", "=", "self", ".", "resize", ".", "_shape", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.local_net.LocalNet.__init__": [[86, 143], ["deepreg.model.backbone.u_net.UNet.__init__", "max"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "image_size", ":", "tuple", ",", "\n", "num_channel_initial", ":", "int", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", "out_channels", ":", "int", ",", "\n", "depth", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "use_additive_upsampling", ":", "bool", "=", "True", ",", "\n", "pooling", ":", "bool", "=", "True", ",", "\n", "concat_skip", ":", "bool", "=", "False", ",", "\n", "name", ":", "str", "=", "\"LocalNet\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        Image is encoded gradually, i from level 0 to D,\n        then it is decoded gradually, j from level D to 0.\n        Some of the decoded levels are used for generating extractions.\n\n        So, extract_levels are between [0, D].\n\n        :param image_size: such as (dim1, dim2, dim3)\n        :param num_channel_initial: number of initial channels.\n        :param extract_levels: from which depths the output will be built.\n        :param out_kernel_initializer: initializer to use for kernels.\n        :param out_activation: activation to use at end layer.\n        :param out_channels: number of channels for the extractions\n        :param depth: depth of the encoder.\n            If depth is not given, depth = max(extract_levels) will be used.\n        :param use_additive_upsampling: whether use additive up-sampling layer\n            for decoding.\n        :param pooling: for down-sampling, use non-parameterized\n                        pooling if true, otherwise use conv3d\n        :param concat_skip: when up-sampling, concatenate skipped\n                            tensor if true, otherwise use addition\n        :param name: name of the backbone.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "self", ".", "_use_additive_upsampling", "=", "use_additive_upsampling", "\n", "if", "depth", "is", "None", ":", "\n", "            ", "depth", "=", "max", "(", "extract_levels", ")", "\n", "", "kwargs", "[", "\"encode_kernel_sizes\"", "]", "=", "[", "7", "]", "+", "[", "3", "]", "*", "depth", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "image_size", "=", "image_size", ",", "\n", "num_channel_initial", "=", "num_channel_initial", ",", "\n", "depth", "=", "depth", ",", "\n", "extract_levels", "=", "extract_levels", ",", "\n", "out_kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "out_activation", "=", "out_activation", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "pooling", "=", "pooling", ",", "\n", "concat_skip", "=", "concat_skip", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.local_net.LocalNet.build_bottom_block": [[145, 161], ["deepreg.model.layer.Conv3dBlock"], "methods", ["None"], ["", "def", "build_bottom_block", "(", "\n", "self", ",", "filters", ":", "int", ",", "kernel_size", ":", "int", ",", "padding", ":", "str", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for bottom layer.\n\n        This block do not change the tensor shape (width, height, depth),\n        it only changes the number of channels.\n\n        :param filters: number of channels for output\n        :param kernel_size: arg for conv3d\n        :param padding: arg for conv3d\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "return", "layer", ".", "Conv3dBlock", "(", "\n", "filters", "=", "filters", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.local_net.LocalNet.build_up_sampling_block": [[163, 203], ["deepreg.model.layer.Deconv3dBlock", "local_net.AdditiveUpsampling"], "methods", ["None"], ["", "def", "build_up_sampling_block", "(", "\n", "self", ",", "\n", "filters", ":", "int", ",", "\n", "output_padding", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "kernel_size", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "padding", ":", "str", ",", "\n", "strides", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "output_shape", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for up-sampling.\n\n        This block changes the tensor shape (width, height, depth),\n        but it does not changes the number of channels.\n\n        :param filters: number of channels for output\n        :param output_padding: padding for output\n        :param kernel_size: arg for deconv3d\n        :param padding: arg for deconv3d\n        :param strides: arg for deconv3d\n        :param output_shape: shape of the output tensor\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "\n", "if", "self", ".", "_use_additive_upsampling", ":", "\n", "            ", "return", "AdditiveUpsampling", "(", "\n", "filters", "=", "filters", ",", "\n", "output_padding", "=", "output_padding", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "output_shape", "=", "output_shape", ",", "\n", ")", "\n", "\n", "", "return", "layer", ".", "Deconv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "output_padding", "=", "output_padding", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.local_net.LocalNet.build_output_block": [[205, 231], ["deepreg.model.layer.Extraction"], "methods", ["None"], ["", "def", "build_output_block", "(", "\n", "self", ",", "\n", "image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "out_channels", ":", "int", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for output.\n\n        The input to this block is a list of tensors.\n\n        :param image_size: such as (dim1, dim2, dim3)\n        :param extract_levels: number of extraction levels.\n        :param out_channels: number of channels for the extractions\n        :param out_kernel_initializer: initializer to use for kernels.\n        :param out_activation: activation to use at end layer.\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "return", "Extraction", "(", "\n", "image_size", "=", "image_size", ",", "\n", "extract_levels", "=", "extract_levels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "out_activation", "=", "out_activation", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.local_net.LocalNet.get_config": [[233, 238], ["super().get_config", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "use_additive_upsampling", "=", "self", ".", "_use_additive_upsampling", ")", "\n", "return", "config", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.__init__": [[28, 122], ["deepreg.model.backbone.interface.Backbone.__init__", "u_net.UNet.build_layers", "max"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_layers"], ["def", "__init__", "(", "\n", "self", ",", "\n", "image_size", ":", "tuple", ",", "\n", "num_channel_initial", ":", "int", ",", "\n", "depth", ":", "int", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", "out_channels", ":", "int", ",", "\n", "extract_levels", ":", "Tuple", "=", "(", "0", ",", ")", ",", "\n", "pooling", ":", "bool", "=", "True", ",", "\n", "concat_skip", ":", "bool", "=", "False", ",", "\n", "encode_kernel_sizes", ":", "Union", "[", "int", ",", "List", "[", "int", "]", "]", "=", "3", ",", "\n", "decode_kernel_sizes", ":", "Union", "[", "int", ",", "List", "[", "int", "]", "]", "=", "3", ",", "\n", "encode_num_channels", ":", "Optional", "[", "Tuple", "]", "=", "None", ",", "\n", "decode_num_channels", ":", "Optional", "[", "Tuple", "]", "=", "None", ",", "\n", "strides", ":", "int", "=", "2", ",", "\n", "padding", ":", "str", "=", "\"same\"", ",", "\n", "name", ":", "str", "=", "\"Unet\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialise UNet.\n\n        :param image_size: (dim1, dim2, dim3), dims of input image.\n        :param num_channel_initial: number of initial channels\n        :param depth: input is at level 0, bottom is at level depth.\n        :param out_kernel_initializer: kernel initializer for the last layer\n        :param out_activation: activation at the last layer\n        :param out_channels: number of channels for the output\n        :param extract_levels: list, which levels from net to extract.\n        :param pooling: for down-sampling, use non-parameterized\n                        pooling if true, otherwise use conv3d\n        :param concat_skip: when up-sampling, concatenate skipped\n                            tensor if true, otherwise use addition\n        :param encode_kernel_sizes: kernel size for down-sampling\n        :param decode_kernel_sizes: kernel size for up-sampling\n        :param encode_num_channels: filters/channels for down-sampling,\n            by default it is doubled at each layer during down-sampling\n        :param decode_num_channels: filters/channels for up-sampling,\n            by default it is the same as encode_num_channels\n        :param strides: strides for down-sampling\n        :param padding: padding mode for all conv layers\n        :param name: name of the backbone.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "image_size", "=", "image_size", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "num_channel_initial", "=", "num_channel_initial", ",", "\n", "out_kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "out_activation", "=", "out_activation", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "# save parameters", "\n", "assert", "max", "(", "extract_levels", ")", "<=", "depth", "\n", "self", ".", "_extract_levels", "=", "extract_levels", "\n", "self", ".", "_depth", "=", "depth", "\n", "\n", "# save extra parameters", "\n", "self", ".", "_concat_skip", "=", "concat_skip", "\n", "self", ".", "_pooling", "=", "pooling", "\n", "self", ".", "_encode_kernel_sizes", "=", "encode_kernel_sizes", "\n", "self", ".", "_decode_kernel_sizes", "=", "decode_kernel_sizes", "\n", "self", ".", "_encode_num_channels", "=", "encode_num_channels", "\n", "self", ".", "_decode_num_channels", "=", "decode_num_channels", "\n", "self", ".", "_strides", "=", "strides", "\n", "self", ".", "_padding", "=", "padding", "\n", "\n", "# init layers", "\n", "# all lists start with d = 0", "\n", "self", ".", "_encode_convs", ":", "List", "[", "tfkl", ".", "Layer", "]", "=", "[", "]", "\n", "self", ".", "_encode_pools", ":", "List", "[", "tfkl", ".", "Layer", "]", "=", "[", "]", "\n", "self", ".", "_bottom_block", "=", "None", "\n", "self", ".", "_decode_deconvs", ":", "List", "[", "tfkl", ".", "Layer", "]", "=", "[", "]", "\n", "self", ".", "_decode_convs", ":", "List", "[", "tfkl", ".", "Layer", "]", "=", "[", "]", "\n", "self", ".", "_output_block", "=", "None", "\n", "\n", "# build layers", "\n", "self", ".", "build_layers", "(", "\n", "image_size", "=", "image_size", ",", "\n", "num_channel_initial", "=", "num_channel_initial", ",", "\n", "depth", "=", "depth", ",", "\n", "extract_levels", "=", "extract_levels", ",", "\n", "encode_kernel_sizes", "=", "encode_kernel_sizes", ",", "\n", "decode_kernel_sizes", "=", "decode_kernel_sizes", ",", "\n", "encode_num_channels", "=", "encode_num_channels", ",", "\n", "decode_num_channels", "=", "decode_num_channels", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "out_kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "out_activation", "=", "out_activation", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_encode_conv_block": [[124, 149], ["tensorflow.keras.Sequential", "tensorflow.keras.Sequential", "deepreg.model.layer.Conv3dBlock", "deepreg.model.layer.ResidualConv3dBlock"], "methods", ["None"], ["", "def", "build_encode_conv_block", "(", "\n", "self", ",", "filters", ":", "int", ",", "kernel_size", ":", "int", ",", "padding", ":", "str", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a conv block for down-sampling\n\n        This block do not change the tensor shape (width, height, depth),\n        it only changes the number of channels.\n\n        :param filters: number of channels for output\n        :param kernel_size: arg for conv3d\n        :param padding: arg for conv3d\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "return", "tf", ".", "keras", ".", "Sequential", "(", "\n", "[", "\n", "layer", ".", "Conv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", ")", ",", "\n", "layer", ".", "ResidualConv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_down_sampling_block": [[153, 178], ["tensorflow.MaxPool3D", "tensorflow.MaxPool3D", "deepreg.model.layer.Conv3dBlock"], "methods", ["None"], ["", "def", "build_down_sampling_block", "(", "\n", "self", ",", "filters", ":", "int", ",", "kernel_size", ":", "int", ",", "padding", ":", "str", ",", "strides", ":", "int", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for down-sampling.\n\n        This block changes the tensor shape (width, height, depth),\n        but it does not changes the number of channels.\n\n        :param filters: number of channels for output, arg for conv3d\n        :param kernel_size: arg for pool3d or conv3d\n        :param padding: arg for pool3d or conv3d\n        :param strides: arg for pool3d or conv3d\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "if", "self", ".", "_pooling", ":", "\n", "            ", "return", "tfkl", ".", "MaxPool3D", "(", "\n", "pool_size", "=", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "layer", ".", "Conv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_bottom_block": [[180, 205], ["tensorflow.keras.Sequential", "tensorflow.keras.Sequential", "deepreg.model.layer.Conv3dBlock", "deepreg.model.layer.ResidualConv3dBlock"], "methods", ["None"], ["", "", "def", "build_bottom_block", "(", "\n", "self", ",", "filters", ":", "int", ",", "kernel_size", ":", "int", ",", "padding", ":", "str", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for bottom layer.\n\n        This block do not change the tensor shape (width, height, depth),\n        it only changes the number of channels.\n\n        :param filters: number of channels for output\n        :param kernel_size: arg for conv3d\n        :param padding: arg for conv3d\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "return", "tf", ".", "keras", ".", "Sequential", "(", "\n", "[", "\n", "layer", ".", "Conv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", ")", ",", "\n", "layer", ".", "ResidualConv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_up_sampling_block": [[209, 238], ["deepreg.model.layer.Deconv3dBlock"], "methods", ["None"], ["", "def", "build_up_sampling_block", "(", "\n", "self", ",", "\n", "filters", ":", "int", ",", "\n", "output_padding", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "kernel_size", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "padding", ":", "str", ",", "\n", "strides", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "int", "]", ",", "\n", "output_shape", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for up-sampling.\n\n        This block changes the tensor shape (width, height, depth),\n        but it does not changes the number of channels.\n\n        :param filters: number of channels for output\n        :param output_padding: padding for output\n        :param kernel_size: arg for deconv3d\n        :param padding: arg for deconv3d\n        :param strides: arg for deconv3d\n        :param output_shape: shape of the output tensor\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "return", "layer", ".", "Deconv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "output_padding", "=", "output_padding", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_skip_block": [[240, 255], ["tensorflow.Concatenate", "tensorflow.Concatenate", "tensorflow.Add", "tensorflow.Add"], "methods", ["None"], ["", "def", "build_skip_block", "(", "self", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for combining skipped tensor and up-sampled one.\n\n        This block do not change the tensor shape (width, height, depth),\n        it only changes the number of channels.\n\n        The input to this block is a list of tensors.\n\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "if", "self", ".", "_concat_skip", ":", "\n", "            ", "return", "tfkl", ".", "Concatenate", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "tfkl", ".", "Add", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_decode_conv_block": [[256, 281], ["tensorflow.keras.Sequential", "tensorflow.keras.Sequential", "deepreg.model.layer.Conv3dBlock", "deepreg.model.layer.ResidualConv3dBlock"], "methods", ["None"], ["", "", "def", "build_decode_conv_block", "(", "\n", "self", ",", "filters", ":", "int", ",", "kernel_size", ":", "int", ",", "padding", ":", "str", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a conv block for up-sampling\n\n        This block do not change the tensor shape (width, height, depth),\n        it only changes the number of channels.\n\n        :param filters: number of channels for output\n        :param kernel_size: arg for conv3d\n        :param padding: arg for conv3d\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "return", "tf", ".", "keras", ".", "Sequential", "(", "\n", "[", "\n", "layer", ".", "Conv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", ")", ",", "\n", "layer", ".", "ResidualConv3dBlock", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_output_block": [[285, 311], ["deepreg.model.layer.Extraction"], "methods", ["None"], ["", "def", "build_output_block", "(", "\n", "self", ",", "\n", "image_size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "out_channels", ":", "int", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", ")", "->", "Union", "[", "tf", ".", "keras", ".", "Model", ",", "tfkl", ".", "Layer", "]", ":", "\n", "        ", "\"\"\"\n        Build a block for output.\n\n        The input to this block is a list of tensors.\n\n        :param image_size: such as (dim1, dim2, dim3)\n        :param extract_levels: number of extraction levels.\n        :param out_channels: number of channels for the extractions\n        :param out_kernel_initializer: initializer to use for kernels.\n        :param out_activation: activation to use at end layer.\n        :return: a block consists of one or multiple layers\n        \"\"\"", "\n", "return", "Extraction", "(", "\n", "image_size", "=", "image_size", ",", "\n", "extract_levels", "=", "extract_levels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "out_activation", "=", "out_activation", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_layers": [[313, 388], ["u_net.UNet.build_encode_layers", "u_net.UNet.build_decode_layers", "tuple", "len", "len", "ValueError", "range"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_encode_layers", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_decode_layers"], ["", "def", "build_layers", "(", "\n", "self", ",", "\n", "image_size", ":", "tuple", ",", "\n", "num_channel_initial", ":", "int", ",", "\n", "depth", ":", "int", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "encode_kernel_sizes", ":", "Union", "[", "int", ",", "List", "[", "int", "]", "]", ",", "\n", "decode_kernel_sizes", ":", "Union", "[", "int", ",", "List", "[", "int", "]", "]", ",", "\n", "encode_num_channels", ":", "Optional", "[", "Tuple", "]", ",", "\n", "decode_num_channels", ":", "Optional", "[", "Tuple", "]", ",", "\n", "strides", ":", "int", ",", "\n", "padding", ":", "str", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", "out_channels", ":", "int", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Build layers that will be used in call.\n\n        :param image_size: (dim1, dim2, dim3).\n        :param num_channel_initial: number of initial channels.\n        :param depth: network starts with d = 0, and the bottom has d = depth.\n        :param extract_levels: from which depths the output will be built.\n        :param encode_kernel_sizes: kernel size for down-sampling\n        :param decode_kernel_sizes: kernel size for up-sampling\n        :param encode_num_channels: filters/channels for down-sampling,\n            by default it is doubled at each layer during down-sampling\n        :param decode_num_channels: filters/channels for up-sampling,\n            by default it is the same as encode_num_channels\n        :param strides: strides for down-sampling\n        :param padding: padding mode for all conv layers\n        :param out_kernel_initializer: initializer to use for kernels.\n        :param out_activation: activation to use at end layer.\n        :param out_channels: number of channels for the extractions\n        \"\"\"", "\n", "if", "encode_num_channels", "is", "None", ":", "\n", "            ", "assert", "num_channel_initial", ">=", "1", "\n", "encode_num_channels", "=", "tuple", "(", "\n", "num_channel_initial", "*", "(", "2", "**", "d", ")", "for", "d", "in", "range", "(", "depth", "+", "1", ")", "\n", ")", "\n", "", "assert", "len", "(", "encode_num_channels", ")", "==", "depth", "+", "1", "\n", "if", "decode_num_channels", "is", "None", ":", "\n", "            ", "decode_num_channels", "=", "encode_num_channels", "\n", "", "assert", "len", "(", "decode_num_channels", ")", "==", "depth", "+", "1", "\n", "if", "not", "self", ".", "_concat_skip", ":", "\n", "# in case of adding skip tensors, the channels should match", "\n", "            ", "if", "decode_num_channels", "!=", "encode_num_channels", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"For UNet, if the skipped tensor is added \"", "\n", "\"instead of being concatenated, \"", "\n", "\"the encode_num_channels and decode_num_channels \"", "\n", "\"should be the same. \"", "\n", "f\"But got encode_num_channels = {encode_num_channels},\"", "\n", "f\"decode_num_channels = {decode_num_channels}.\"", "\n", ")", "\n", "", "", "tensor_shapes", "=", "self", ".", "build_encode_layers", "(", "\n", "image_size", "=", "image_size", ",", "\n", "num_channels", "=", "encode_num_channels", ",", "\n", "depth", "=", "depth", ",", "\n", "encode_kernel_sizes", "=", "encode_kernel_sizes", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n", "self", ".", "build_decode_layers", "(", "\n", "tensor_shapes", "=", "tensor_shapes", ",", "\n", "image_size", "=", "image_size", ",", "\n", "num_channels", "=", "decode_num_channels", ",", "\n", "depth", "=", "depth", ",", "\n", "extract_levels", "=", "extract_levels", ",", "\n", "decode_kernel_sizes", "=", "decode_kernel_sizes", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "out_kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "out_activation", "=", "out_activation", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_encode_layers": [[390, 453], ["isinstance", "range", "u_net.UNet.build_bottom_block", "len", "u_net.UNet.build_encode_conv_block", "u_net.UNet.build_down_sampling_block", "tuple", "u_net.UNet._encode_convs.append", "u_net.UNet._encode_pools.append", "tensor_shapes.append", "tensorflow.python.keras.utils.conv_utils.conv_output_length", "tensorflow.python.keras.utils.conv_utils.conv_output_length"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_bottom_block", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_encode_conv_block", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_down_sampling_block"], ["", "def", "build_encode_layers", "(", "\n", "self", ",", "\n", "image_size", ":", "Tuple", ",", "\n", "num_channels", ":", "Tuple", ",", "\n", "depth", ":", "int", ",", "\n", "encode_kernel_sizes", ":", "Union", "[", "int", ",", "List", "[", "int", "]", "]", ",", "\n", "strides", ":", "int", ",", "\n", "padding", ":", "str", ",", "\n", ")", "->", "List", "[", "Tuple", "]", ":", "\n", "        ", "\"\"\"\n        Build layers for encoding.\n\n        :param image_size: (dim1, dim2, dim3).\n        :param num_channels: number of channels for each layer,\n            starting from the top layer.\n        :param depth: network starts with d = 0, and the bottom has d = depth.\n        :param encode_kernel_sizes: kernel size for down-sampling\n        :param strides: strides for down-sampling\n        :param padding: padding mode for all conv layers\n        :return: list of tensor shapes starting from d = 0\n        \"\"\"", "\n", "if", "isinstance", "(", "encode_kernel_sizes", ",", "int", ")", ":", "\n", "            ", "encode_kernel_sizes", "=", "[", "encode_kernel_sizes", "]", "*", "(", "depth", "+", "1", ")", "\n", "", "assert", "len", "(", "encode_kernel_sizes", ")", "==", "depth", "+", "1", "\n", "\n", "# encoding / down-sampling", "\n", "self", ".", "_encode_convs", "=", "[", "]", "\n", "self", ".", "_encode_pools", "=", "[", "]", "\n", "tensor_shape", "=", "image_size", "\n", "tensor_shapes", "=", "[", "tensor_shape", "]", "\n", "for", "d", "in", "range", "(", "depth", ")", ":", "\n", "            ", "encode_conv", "=", "self", ".", "build_encode_conv_block", "(", "\n", "filters", "=", "num_channels", "[", "d", "]", ",", "\n", "kernel_size", "=", "encode_kernel_sizes", "[", "d", "]", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n", "encode_pool", "=", "self", ".", "build_down_sampling_block", "(", "\n", "filters", "=", "num_channels", "[", "d", "]", ",", "\n", "kernel_size", "=", "strides", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n", "tensor_shape", "=", "tuple", "(", "\n", "conv_utils", ".", "conv_output_length", "(", "\n", "input_length", "=", "x", ",", "\n", "filter_size", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "stride", "=", "strides", ",", "\n", "dilation", "=", "1", ",", "\n", ")", "\n", "for", "x", "in", "tensor_shape", "\n", ")", "\n", "self", ".", "_encode_convs", ".", "append", "(", "encode_conv", ")", "\n", "self", ".", "_encode_pools", ".", "append", "(", "encode_pool", ")", "\n", "tensor_shapes", ".", "append", "(", "tensor_shape", ")", "\n", "\n", "# bottom layer", "\n", "", "self", ".", "_bottom_block", "=", "self", ".", "build_bottom_block", "(", "\n", "filters", "=", "num_channels", "[", "depth", "]", ",", "\n", "kernel_size", "=", "encode_kernel_sizes", "[", "depth", "]", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n", "return", "tensor_shapes", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_decode_layers": [[454, 527], ["min", "isinstance", "range", "u_net.UNet.build_output_block", "len", "deepreg.model.layer_util.deconv_output_padding", "u_net.UNet.build_up_sampling_block", "u_net.UNet.build_decode_conv_block"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_output_block", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.model.layer_util.deconv_output_padding", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_up_sampling_block", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_decode_conv_block"], ["", "def", "build_decode_layers", "(", "\n", "self", ",", "\n", "tensor_shapes", ":", "List", "[", "Tuple", "]", ",", "\n", "image_size", ":", "Tuple", ",", "\n", "num_channels", ":", "Tuple", ",", "\n", "depth", ":", "int", ",", "\n", "extract_levels", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "decode_kernel_sizes", ":", "Union", "[", "int", ",", "List", "[", "int", "]", "]", ",", "\n", "strides", ":", "int", ",", "\n", "padding", ":", "str", ",", "\n", "out_kernel_initializer", ":", "str", ",", "\n", "out_activation", ":", "str", ",", "\n", "out_channels", ":", "int", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Build layers for decoding.\n\n        :param tensor_shapes: shapes calculated in encoder\n        :param image_size: (dim1, dim2, dim3).\n        :param num_channels: number of channels for each layer,\n            starting from the top layer.\n        :param depth: network starts with d = 0, and the bottom has d = depth.\n        :param extract_levels: from which depths the output will be built.\n        :param decode_kernel_sizes: kernel size for up-sampling\n        :param strides: strides for down-sampling\n        :param padding: padding mode for all conv layers\n        :param out_kernel_initializer: initializer to use for kernels.\n        :param out_activation: activation to use at end layer.\n        :param out_channels: number of channels for the extractions\n        \"\"\"", "\n", "# init params", "\n", "min_extract_level", "=", "min", "(", "extract_levels", ")", "\n", "if", "isinstance", "(", "decode_kernel_sizes", ",", "int", ")", ":", "\n", "            ", "decode_kernel_sizes", "=", "[", "decode_kernel_sizes", "]", "*", "depth", "\n", "", "assert", "len", "(", "decode_kernel_sizes", ")", "==", "depth", "\n", "\n", "# decoding / up-sampling", "\n", "self", ".", "_decode_deconvs", "=", "[", "]", "\n", "self", ".", "_decode_convs", "=", "[", "]", "\n", "for", "d", "in", "range", "(", "depth", "-", "1", ",", "min_extract_level", "-", "1", ",", "-", "1", ")", ":", "\n", "            ", "kernel_size", "=", "decode_kernel_sizes", "[", "d", "]", "\n", "output_padding", "=", "layer_util", ".", "deconv_output_padding", "(", "\n", "input_shape", "=", "tensor_shapes", "[", "d", "+", "1", "]", ",", "\n", "output_shape", "=", "tensor_shapes", "[", "d", "]", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", ")", "\n", "decode_deconv", "=", "self", ".", "build_up_sampling_block", "(", "\n", "filters", "=", "num_channels", "[", "d", "]", ",", "\n", "output_padding", "=", "output_padding", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "output_shape", "=", "tensor_shapes", "[", "d", "]", ",", "\n", ")", "\n", "decode_conv", "=", "self", ".", "build_decode_conv_block", "(", "\n", "filters", "=", "num_channels", "[", "d", "]", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", "\n", ")", "\n", "self", ".", "_decode_deconvs", "=", "[", "decode_deconv", "]", "+", "self", ".", "_decode_deconvs", "\n", "self", ".", "_decode_convs", "=", "[", "decode_conv", "]", "+", "self", ".", "_decode_convs", "\n", "", "if", "min_extract_level", ">", "0", ":", "\n", "# add Nones to make lists have length depth - 1", "\n", "            ", "self", ".", "_decode_deconvs", "=", "[", "None", "]", "*", "min_extract_level", "+", "self", ".", "_decode_deconvs", "\n", "self", ".", "_decode_convs", "=", "[", "None", "]", "*", "min_extract_level", "+", "self", ".", "_decode_convs", "\n", "\n", "# extraction", "\n", "", "self", ".", "_output_block", "=", "self", ".", "build_output_block", "(", "\n", "image_size", "=", "image_size", ",", "\n", "extract_levels", "=", "extract_levels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "out_kernel_initializer", "=", "out_kernel_initializer", ",", "\n", "out_activation", "=", "out_activation", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.call": [[529, 562], ["range", "u_net.UNet._bottom_block", "range", "u_net.UNet._output_block", "skips.append", "min", "u_net.UNet.build_skip_block"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.build_skip_block"], ["", "def", "call", "(", "self", ",", "inputs", ":", "tf", ".", "Tensor", ",", "training", "=", "None", ",", "mask", "=", "None", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build compute graph based on built layers.\n\n        :param inputs: image batch, shape = (batch, f_dim1, f_dim2, f_dim3, ch)\n        :param training: None or bool.\n        :param mask: None or tf.Tensor.\n        :return: shape = (batch, f_dim1, f_dim2, f_dim3, out_channels)\n        \"\"\"", "\n", "\n", "# encoding / down-sampling", "\n", "skips", "=", "[", "]", "\n", "encoded", "=", "inputs", "\n", "for", "d", "in", "range", "(", "self", ".", "_depth", ")", ":", "\n", "            ", "skip", "=", "self", ".", "_encode_convs", "[", "d", "]", "(", "inputs", "=", "encoded", ",", "training", "=", "training", ")", "\n", "encoded", "=", "self", ".", "_encode_pools", "[", "d", "]", "(", "inputs", "=", "skip", ",", "training", "=", "training", ")", "\n", "skips", ".", "append", "(", "skip", ")", "\n", "\n", "# bottom", "\n", "", "decoded", "=", "self", ".", "_bottom_block", "(", "inputs", "=", "encoded", ",", "training", "=", "training", ")", "# type: ignore", "\n", "\n", "# decoding / up-sampling", "\n", "outs", "=", "[", "decoded", "]", "\n", "for", "d", "in", "range", "(", "self", ".", "_depth", "-", "1", ",", "min", "(", "self", ".", "_extract_levels", ")", "-", "1", ",", "-", "1", ")", ":", "\n", "            ", "decoded", "=", "self", ".", "_decode_deconvs", "[", "d", "]", "(", "inputs", "=", "decoded", ",", "training", "=", "training", ")", "\n", "decoded", "=", "self", ".", "build_skip_block", "(", ")", "(", "[", "decoded", ",", "skips", "[", "d", "]", "]", ")", "\n", "decoded", "=", "self", ".", "_decode_convs", "[", "d", "]", "(", "inputs", "=", "decoded", ",", "training", "=", "training", ")", "\n", "outs", "=", "[", "decoded", "]", "+", "outs", "\n", "\n", "# output", "\n", "", "output", "=", "self", ".", "_output_block", "(", "outs", ")", "# type: ignore", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.backbone.u_net.UNet.get_config": [[563, 579], ["super().get_config", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "\n", "depth", "=", "self", ".", "_depth", ",", "\n", "extract_levels", "=", "self", ".", "_extract_levels", ",", "\n", "pooling", "=", "self", ".", "_pooling", ",", "\n", "concat_skip", "=", "self", ".", "_concat_skip", ",", "\n", "encode_kernel_sizes", "=", "self", ".", "_encode_kernel_sizes", ",", "\n", "decode_kernel_sizes", "=", "self", ".", "_decode_kernel_sizes", ",", "\n", "encode_num_channels", "=", "self", ".", "_encode_num_channels", ",", "\n", "decode_num_channels", "=", "self", ".", "_decode_num_channels", ",", "\n", "strides", "=", "self", ".", "_strides", ",", "\n", "padding", "=", "self", ".", "_padding", ",", "\n", ")", "\n", "return", "config", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_v011": [[9, 39], ["copy.deepcopy", "v011.parse_data", "new_config[].pop", "v011.parse_loss", "v011.parse_preprocess", "v011.parse_optimizer", "v011.parse_model", "new_config[].update"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_data", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_preprocess", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_optimizer", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_model"], ["def", "parse_v011", "(", "old_config", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Transform configuration from V0.1.1 format to the latest format.\n\n    V0.1.1 to latest.\n\n    :param old_config:\n    :return: transformed config\n    \"\"\"", "\n", "\n", "new_config", "=", "deepcopy", "(", "old_config", ")", "\n", "\n", "new_config", "[", "\"dataset\"", "]", "=", "parse_data", "(", "data_config", "=", "new_config", "[", "\"dataset\"", "]", ")", "\n", "\n", "model_config", "=", "new_config", "[", "\"train\"", "]", ".", "pop", "(", "\"model\"", ",", "None", ")", "\n", "if", "model_config", "is", "not", "None", ":", "\n", "        ", "model_config", "=", "parse_model", "(", "model_config", "=", "model_config", ")", "\n", "new_config", "[", "\"train\"", "]", ".", "update", "(", "model_config", ")", "\n", "\n", "", "new_config", "[", "\"train\"", "]", "[", "\"loss\"", "]", "=", "parse_loss", "(", "loss_config", "=", "new_config", "[", "\"train\"", "]", "[", "\"loss\"", "]", ")", "\n", "\n", "new_config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", "=", "parse_preprocess", "(", "\n", "preprocess_config", "=", "new_config", "[", "\"train\"", "]", "[", "\"preprocess\"", "]", "\n", ")", "\n", "\n", "new_config", "[", "\"train\"", "]", "[", "\"optimizer\"", "]", "=", "parse_optimizer", "(", "\n", "opt_config", "=", "new_config", "[", "\"train\"", "]", "[", "\"optimizer\"", "]", "\n", ")", "\n", "\n", "return", "new_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_data": [[41, 66], ["data_config.pop", "data_config.pop", "data_config.pop"], "function", ["None"], ["", "def", "parse_data", "(", "data_config", ":", "dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Parse the data configuration.\n\n    :param data_config: potentially outdated config\n    :return: latest config\n    \"\"\"", "\n", "if", "\"format\"", "not", "in", "data_config", ":", "\n", "# up-to-date", "\n", "        ", "return", "data_config", "\n", "\n", "# define format and labeled in each split", "\n", "", "dir", "=", "data_config", ".", "pop", "(", "\"dir\"", ")", "\n", "format", "=", "data_config", ".", "pop", "(", "\"format\"", ")", "\n", "labeled", "=", "data_config", ".", "pop", "(", "\"labeled\"", ")", "\n", "# get dir for each split", "\n", "for", "split", "in", "KNOWN_DATA_SPLITS", ":", "\n", "        ", "if", "split", "not", "in", "dir", ":", "\n", "            ", "continue", "\n", "", "data_config", "[", "split", "]", "=", "{", "\n", "\"dir\"", ":", "dir", "[", "split", "]", ",", "\n", "\"format\"", ":", "format", ",", "\n", "\"labeled\"", ":", "labeled", ",", "\n", "}", "\n", "", "return", "data_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_model": [[68, 96], ["isinstance", "backbone_config.pop", "max"], "function", ["None"], ["", "def", "parse_model", "(", "model_config", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Parse the model configuration.\n\n    :param model_config: potentially outdated config\n    :return: latest config\n    \"\"\"", "\n", "# remove model layer", "\n", "if", "\"model\"", "in", "model_config", ":", "\n", "        ", "model_config", "=", "model_config", "[", "\"model\"", "]", "\n", "\n", "", "if", "isinstance", "(", "model_config", "[", "\"backbone\"", "]", ",", "dict", ")", ":", "\n", "# up-to-date", "\n", "        ", "return", "model_config", "\n", "\n", "", "backbone_name", "=", "model_config", "[", "\"backbone\"", "]", "\n", "\n", "# backbone_config is the backbone name", "\n", "backbone_config", "=", "{", "\"name\"", ":", "backbone_name", ",", "**", "model_config", "[", "backbone_name", "]", "}", "\n", "\n", "if", "backbone_name", "==", "\"global\"", ":", "\n", "# global net use depth instead of extract_levels", "\n", "        ", "if", "\"extract_levels\"", "in", "backbone_config", ":", "\n", "            ", "extract_levels", "=", "backbone_config", ".", "pop", "(", "\"extract_levels\"", ")", "\n", "backbone_config", "[", "\"depth\"", "]", "=", "max", "(", "extract_levels", ")", "\n", "\n", "", "", "model_config", "=", "{", "\"method\"", ":", "model_config", "[", "\"method\"", "]", ",", "\"backbone\"", ":", "backbone_config", "}", "\n", "return", "model_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_image_loss": [[98, 126], ["isinstance", "image_loss_config.update", "loss_config[].get"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "def", "parse_image_loss", "(", "loss_config", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Parse the image loss part in loss configuration.\n\n    :param loss_config: potentially outdated config\n    :return: latest config\n    \"\"\"", "\n", "if", "\"image\"", "not", "in", "loss_config", ":", "\n", "# no image loss", "\n", "        ", "return", "loss_config", "\n", "\n", "", "if", "isinstance", "(", "loss_config", "[", "\"image\"", "]", ",", "list", ")", ":", "\n", "# config up-to-date", "\n", "        ", "return", "loss_config", "\n", "\n", "", "image_loss_name", "=", "loss_config", "[", "\"image\"", "]", "[", "\"name\"", "]", "\n", "\n", "if", "image_loss_name", "not", "in", "loss_config", "[", "\"image\"", "]", ":", "\n", "# config up-to-date", "\n", "        ", "return", "loss_config", "\n", "\n", "", "image_loss_config", "=", "{", "\n", "\"name\"", ":", "image_loss_name", ",", "\n", "\"weight\"", ":", "loss_config", "[", "\"image\"", "]", ".", "get", "(", "\"weight\"", ",", "1.0", ")", ",", "\n", "}", "\n", "image_loss_config", ".", "update", "(", "loss_config", "[", "\"image\"", "]", "[", "image_loss_name", "]", ")", "\n", "loss_config", "[", "\"image\"", "]", "=", "image_loss_config", "\n", "return", "loss_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_label_loss": [[128, 170], ["isinstance", "loss_config[].pop", "loss_config[].get", "loss_config[].get"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "def", "parse_label_loss", "(", "loss_config", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Parse the label loss part in loss configuration.\n\n    :param loss_config: potentially outdated config\n    :return: latest config\n    \"\"\"", "\n", "if", "\"label\"", "not", "in", "loss_config", ":", "\n", "# no label loss", "\n", "        ", "return", "loss_config", "\n", "\n", "", "if", "isinstance", "(", "loss_config", "[", "\"label\"", "]", ",", "list", ")", ":", "\n", "# config up-to-date", "\n", "        ", "return", "loss_config", "\n", "\n", "", "label_loss_name", "=", "loss_config", "[", "\"label\"", "]", "[", "\"name\"", "]", "\n", "if", "label_loss_name", "==", "\"single_scale\"", ":", "\n", "        ", "loss_config", "[", "\"label\"", "]", "=", "{", "\n", "\"name\"", ":", "loss_config", "[", "\"label\"", "]", "[", "\"single_scale\"", "]", "[", "\"loss_type\"", "]", ",", "\n", "\"weight\"", ":", "loss_config", "[", "\"label\"", "]", ".", "get", "(", "\"weight\"", ",", "1.0", ")", ",", "\n", "}", "\n", "", "elif", "label_loss_name", "==", "\"multi_scale\"", ":", "\n", "        ", "loss_config", "[", "\"label\"", "]", "=", "{", "\n", "\"name\"", ":", "loss_config", "[", "\"label\"", "]", "[", "\"multi_scale\"", "]", "[", "\"loss_type\"", "]", ",", "\n", "\"weight\"", ":", "loss_config", "[", "\"label\"", "]", ".", "get", "(", "\"weight\"", ",", "1.0", ")", ",", "\n", "\"scales\"", ":", "loss_config", "[", "\"label\"", "]", "[", "\"multi_scale\"", "]", "[", "\"loss_scales\"", "]", ",", "\n", "}", "\n", "\n", "# mean-squared renamed to ssd", "\n", "", "if", "loss_config", "[", "\"label\"", "]", "[", "\"name\"", "]", "==", "\"mean-squared\"", ":", "\n", "        ", "loss_config", "[", "\"label\"", "]", "[", "\"name\"", "]", "=", "\"ssd\"", "\n", "\n", "# dice_generalized merged into dice", "\n", "", "if", "loss_config", "[", "\"label\"", "]", "[", "\"name\"", "]", "==", "\"dice_generalized\"", ":", "\n", "        ", "loss_config", "[", "\"label\"", "]", "[", "\"name\"", "]", "=", "\"dice\"", "\n", "\n", "# rename neg_weight to background_weight", "\n", "", "if", "\"neg_weight\"", "in", "loss_config", "[", "\"label\"", "]", ":", "\n", "        ", "background_weight", "=", "loss_config", "[", "\"label\"", "]", ".", "pop", "(", "\"neg_weight\"", ")", "\n", "loss_config", "[", "\"label\"", "]", "[", "\"background_weight\"", "]", "=", "background_weight", "\n", "\n", "", "return", "loss_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_reg_loss": [[172, 204], ["isinstance", "loss_config[].get"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["", "def", "parse_reg_loss", "(", "loss_config", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Parse the regularization loss part in loss configuration.\n\n    :param loss_config: potentially outdated config\n    :return: latest config\n    \"\"\"", "\n", "if", "\"regularization\"", "not", "in", "loss_config", ":", "\n", "# no regularization loss", "\n", "        ", "return", "loss_config", "\n", "\n", "", "if", "isinstance", "(", "loss_config", "[", "\"regularization\"", "]", ",", "list", ")", ":", "\n", "# config up-to-date", "\n", "        ", "return", "loss_config", "\n", "\n", "", "if", "\"energy_type\"", "not", "in", "loss_config", "[", "\"regularization\"", "]", ":", "\n", "# up-to-date", "\n", "        ", "return", "loss_config", "\n", "\n", "", "energy_type", "=", "loss_config", "[", "\"regularization\"", "]", "[", "\"energy_type\"", "]", "\n", "reg_config", "=", "{", "\"weight\"", ":", "loss_config", "[", "\"regularization\"", "]", ".", "get", "(", "\"weight\"", ",", "1.0", ")", "}", "\n", "if", "energy_type", "==", "\"bending\"", ":", "\n", "        ", "reg_config", "[", "\"name\"", "]", "=", "\"bending\"", "\n", "", "elif", "energy_type", "==", "\"gradient-l2\"", ":", "\n", "        ", "reg_config", "[", "\"name\"", "]", "=", "\"gradient\"", "\n", "reg_config", "[", "\"l1\"", "]", "=", "False", "\n", "", "elif", "energy_type", "==", "\"gradient-l1\"", ":", "\n", "        ", "reg_config", "[", "\"name\"", "]", "=", "\"gradient\"", "\n", "reg_config", "[", "\"l1\"", "]", "=", "True", "\n", "", "loss_config", "[", "\"regularization\"", "]", "=", "reg_config", "\n", "\n", "return", "loss_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_loss": [[206, 223], ["v011.parse_image_loss", "v011.parse_label_loss", "v011.parse_reg_loss", "parse_reg_loss.pop", "parse_reg_loss.update"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_image_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_label_loss", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_reg_loss"], ["", "def", "parse_loss", "(", "loss_config", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Parse the loss configuration.\n\n    :param loss_config: potentially outdated config\n    :return: latest config\n    \"\"\"", "\n", "# remove dissimilarity layer", "\n", "if", "\"dissimilarity\"", "in", "loss_config", ":", "\n", "        ", "dissim_config", "=", "loss_config", ".", "pop", "(", "\"dissimilarity\"", ")", "\n", "loss_config", ".", "update", "(", "dissim_config", ")", "\n", "\n", "", "loss_config", "=", "parse_image_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "loss_config", "=", "parse_label_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "loss_config", "=", "parse_reg_loss", "(", "loss_config", "=", "loss_config", ")", "\n", "\n", "return", "loss_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_preprocess": [[225, 235], ["None"], "function", ["None"], ["", "def", "parse_preprocess", "(", "preprocess_config", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Parse the preprocess configuration.\n\n    :param preprocess_config: potentially outdated config\n    :return: latest config\n    \"\"\"", "\n", "if", "\"data_augmentation\"", "not", "in", "preprocess_config", ":", "\n", "        ", "preprocess_config", "[", "\"data_augmentation\"", "]", "=", "{", "\"name\"", ":", "\"affine\"", "}", "\n", "", "return", "preprocess_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_optimizer": [[237, 256], ["dict"], "function", ["None"], ["", "def", "parse_optimizer", "(", "opt_config", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Parse the optimizer configuration.\n\n    :param opt_config: potentially outdated config\n    :return: latest config\n    \"\"\"", "\n", "name", "=", "opt_config", "[", "\"name\"", "]", "\n", "if", "name", "not", "in", "opt_config", ":", "\n", "# up-to-date", "\n", "        ", "return", "opt_config", "\n", "\n", "", "name_dict", "=", "dict", "(", "\n", "adam", "=", "\"Adam\"", ",", "\n", "sgd", "=", "\"SGD\"", ",", "\n", "rms", "=", "\"RMSprop\"", ",", "\n", ")", "\n", "new_name", "=", "name_dict", "[", "name", "]", "\n", "return", "{", "\"name\"", ":", "new_name", ",", "**", "opt_config", "[", "name", "]", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict": [[12, 29], ["u.items", "isinstance", "parser.update_nested_dict", "d.get"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.deepreg.log.get"], ["def", "update_nested_dict", "(", "d", ":", "Dict", ",", "u", ":", "Dict", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Merge two dicts.\n\n    https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth\n\n    :param d: dict to be overwritten in case of conflicts.\n    :param u: dict to be merged into d.\n    :return:\n    \"\"\"", "\n", "\n", "for", "k", ",", "v", "in", "u", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "            ", "d", "[", "k", "]", "=", "update_nested_dict", "(", "d", ".", "get", "(", "k", ",", "{", "}", ")", ",", "v", ")", "\n", "", "else", ":", "\n", "            ", "d", "[", "k", "]", "=", "v", "\n", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.load_configs": [[31, 61], ["isinstance", "parser.config_sanity_check", "os.path.expanduser", "parser.update_nested_dict", "os.path.split", "parser.save", "logger.error", "open", "yaml.load", "os.path.join"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.config_sanity_check", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.update_nested_dict", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save"], ["", "def", "load_configs", "(", "config_path", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ")", "->", "Dict", ":", "\n", "    ", "\"\"\"\n    Load multiple configs and update the nested dictionary.\n\n    :param config_path: list of paths or one path.\n    :return: the loaded config\n    \"\"\"", "\n", "if", "isinstance", "(", "config_path", ",", "str", ")", ":", "\n", "        ", "config_path", "=", "[", "config_path", "]", "\n", "# replace ~ with user home path", "\n", "", "config_path", "=", "[", "os", ".", "path", ".", "expanduser", "(", "x", ")", "for", "x", "in", "config_path", "]", "\n", "config", ":", "Dict", "=", "{", "}", "\n", "for", "config_path_i", "in", "config_path", ":", "\n", "        ", "with", "open", "(", "config_path_i", ")", "as", "file", ":", "\n", "            ", "config_i", "=", "yaml", ".", "load", "(", "file", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "", "config", "=", "update_nested_dict", "(", "d", "=", "config", ",", "u", "=", "config_i", ")", "\n", "", "loaded_config", "=", "config_sanity_check", "(", "config", ")", "\n", "\n", "if", "loaded_config", "!=", "config", ":", "\n", "# config got updated", "\n", "        ", "head", ",", "tail", "=", "os", ".", "path", ".", "split", "(", "config_path", "[", "0", "]", ")", "\n", "filename", "=", "\"updated_\"", "+", "tail", "\n", "save", "(", "config", "=", "loaded_config", ",", "out_dir", "=", "head", ",", "filename", "=", "filename", ")", "\n", "logger", ".", "error", "(", "\n", "\"The provided configuration file is outdated. \"", "\n", "\"An updated version has been saved at %s.\"", ",", "\n", "os", ".", "path", ".", "join", "(", "head", ",", "filename", ")", ",", "\n", ")", "\n", "\n", "", "return", "loaded_config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.save": [[63, 74], ["filename.endswith", "open", "f.write", "os.path.join", "yaml.dump"], "function", ["None"], ["", "def", "save", "(", "config", ":", "dict", ",", "out_dir", ":", "str", ",", "filename", ":", "str", "=", "\"config.yaml\"", ")", ":", "\n", "    ", "\"\"\"\n    Save the config into a yaml file.\n\n    :param config: configuration to be outputed\n    :param out_dir: directory of the output file\n    :param filename: name of the output file\n    \"\"\"", "\n", "assert", "filename", ".", "endswith", "(", "\".yaml\"", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "out_dir", ",", "filename", ")", ",", "\"w+\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "yaml", ".", "dump", "(", "config", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.parser.config_sanity_check": [[76, 94], ["deepreg.config.v011.parse_v011", "ValueError"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.config.v011.parse_v011"], ["", "", "def", "config_sanity_check", "(", "config", ":", "dict", ")", "->", "dict", ":", "\n", "    ", "\"\"\"\n    Check if the given config satisfies the requirements.\n\n    :param config: entire config.\n    \"\"\"", "\n", "\n", "# back compatibility support", "\n", "config", "=", "parse_v011", "(", "config", ")", "\n", "\n", "# check model", "\n", "if", "config", "[", "\"train\"", "]", "[", "\"method\"", "]", "==", "\"conditional\"", ":", "\n", "        ", "if", "config", "[", "\"dataset\"", "]", "[", "\"train\"", "]", "[", "\"labeled\"", "]", "is", "False", ":", "# unlabeled", "\n", "            ", "raise", "ValueError", "(", "\n", "\"For conditional model, data have to be labeled, got unlabeled data.\"", "\n", ")", "\n", "\n", "", "", "return", "config", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.rectangular_kernel1d": [[6, 16], ["tensorflow.ones"], "function", ["None"], ["def", "rectangular_kernel1d", "(", "kernel_size", ":", "int", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Return a the 1D rectangular kernel for LocalNormalizedCrossCorrelation.\n\n    :param kernel_size: scalar, size of the 1-D kernel\n    :return: kernel_weights, of shape (kernel_size, )\n    \"\"\"", "\n", "\n", "kernel", "=", "tf", ".", "ones", "(", "shape", "=", "(", "kernel_size", ",", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.triangular_kernel1d": [[18, 50], ["tensorflow.constant", "tensorflow.ones", "tensorflow.nn.conv1d", "math.floor", "math.ceil"], "function", ["None"], ["", "def", "triangular_kernel1d", "(", "kernel_size", ":", "int", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Return a the 1D triangular kernel for LocalNormalizedCrossCorrelation.\n\n    Assume kernel_size is odd, it will be a smoothed from\n    a kernel which center part is zero.\n    Then length of the ones will be around half kernel_size.\n    The weight scale of the kernel does not matter as LNCC will normalize it.\n\n    :param kernel_size: scalar, size of the 1-D kernel\n    :return: kernel_weights, of shape (kernel_size, )\n    \"\"\"", "\n", "assert", "kernel_size", ">=", "3", "\n", "assert", "kernel_size", "%", "2", "!=", "0", "\n", "\n", "padding", "=", "kernel_size", "//", "2", "\n", "kernel", "=", "tf", ".", "constant", "(", "\n", "[", "0", "]", "*", "math", ".", "ceil", "(", "padding", "/", "2", ")", "\n", "+", "[", "1", "]", "*", "(", "kernel_size", "-", "padding", ")", "\n", "+", "[", "0", "]", "*", "math", ".", "floor", "(", "padding", "/", "2", ")", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", ")", "\n", "\n", "# (padding*2, )", "\n", "filters", "=", "tf", ".", "ones", "(", "shape", "=", "(", "kernel_size", "-", "padding", ",", "1", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "# (kernel_size, 1, 1)", "\n", "kernel", "=", "tf", ".", "nn", ".", "conv1d", "(", "\n", "kernel", "[", "None", ",", ":", ",", "None", "]", ",", "filters", "=", "filters", ",", "stride", "=", "[", "1", ",", "1", ",", "1", "]", ",", "padding", "=", "\"SAME\"", "\n", ")", "\n", "\n", "return", "kernel", "[", "0", ",", ":", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.gaussian_kernel1d_size": [[52, 66], ["tensorflow.range", "tensorflow.exp", "tensorflow.square"], "function", ["None"], ["", "def", "gaussian_kernel1d_size", "(", "kernel_size", ":", "int", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Return a the 1D Gaussian kernel for LocalNormalizedCrossCorrelation.\n\n    :param kernel_size: scalar, size of the 1-D kernel\n    :return: filters, of shape (kernel_size, )\n    \"\"\"", "\n", "mean", "=", "(", "kernel_size", "-", "1", ")", "/", "2.0", "\n", "sigma", "=", "kernel_size", "/", "3", "\n", "\n", "grid", "=", "tf", ".", "range", "(", "0", ",", "kernel_size", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "filters", "=", "tf", ".", "exp", "(", "-", "tf", ".", "square", "(", "grid", "-", "mean", ")", "/", "(", "2", "*", "sigma", "**", "2", ")", ")", "\n", "\n", "return", "filters", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.gaussian_kernel1d_sigma": [[68, 81], ["int", "tensorflow.exp", "tensorflow.reduce_sum", "range"], "function", ["None"], ["", "def", "gaussian_kernel1d_sigma", "(", "sigma", ":", "int", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Calculate a gaussian kernel.\n\n    :param sigma: number defining standard deviation for\n                  gaussian kernel.\n    :return: shape = (dim, )\n    \"\"\"", "\n", "assert", "sigma", ">", "0", "\n", "tail", "=", "int", "(", "sigma", "*", "3", ")", "\n", "kernel", "=", "tf", ".", "exp", "(", "[", "-", "0.5", "*", "x", "**", "2", "/", "sigma", "**", "2", "for", "x", "in", "range", "(", "-", "tail", ",", "tail", "+", "1", ")", "]", ")", "\n", "kernel", "=", "kernel", "/", "tf", ".", "reduce_sum", "(", "kernel", ")", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.kernel.cauchy_kernel1d": [[83, 95], ["int", "tensorflow.math.reciprocal", "tensorflow.reduce_sum", "range"], "function", ["None"], ["", "def", "cauchy_kernel1d", "(", "sigma", ":", "int", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Approximating cauchy kernel in 1d.\n\n    :param sigma: int, defining standard deviation of kernel.\n    :return: shape = (dim, )\n    \"\"\"", "\n", "assert", "sigma", ">", "0", "\n", "tail", "=", "int", "(", "sigma", "*", "5", ")", "\n", "k", "=", "tf", ".", "math", ".", "reciprocal", "(", "[", "(", "(", "x", "/", "sigma", ")", "**", "2", "+", "1", ")", "for", "x", "in", "range", "(", "-", "tail", ",", "tail", "+", "1", ")", "]", ")", "\n", "k", "=", "k", "/", "tf", ".", "reduce_sum", "(", "k", ")", "\n", "return", "k", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.SumSquaredDifference.__init__": [[19, 32], ["super().__init__", "tensorflow.keras.layers.Flatten"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", "=", "\"SumSquaredDifference\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param name: name of the loss.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "self", ".", "flatten", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.SumSquaredDifference.call": [[33, 44], ["tensorflow.math.squared_difference", "label.SumSquaredDifference.flatten", "tensorflow.reduce_mean"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return mean squared different for a batch.\n\n        :param y_true: shape = (batch, ...)\n        :param y_pred: shape = (batch, ...)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "loss", "=", "tf", ".", "math", ".", "squared_difference", "(", "y_true", ",", "y_pred", ")", "\n", "loss", "=", "self", ".", "flatten", "(", "loss", ")", "\n", "return", "tf", ".", "reduce_mean", "(", "loss", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.DiceScore.__init__": [[76, 107], ["super().__init__", "tensorflow.keras.layers.Flatten", "ValueError"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "binary", ":", "bool", "=", "False", ",", "\n", "background_weight", ":", "float", "=", "0.0", ",", "\n", "smooth_nr", ":", "float", "=", "EPS", ",", "\n", "smooth_dr", ":", "float", "=", "EPS", ",", "\n", "name", ":", "str", "=", "\"DiceScore\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param binary: if True, project y_true, y_pred to 0 or 1.\n        :param background_weight: weight for background, where y == 0.\n        :param smooth_nr: small constant added to numerator in case of zero covariance.\n        :param smooth_dr: small constant added to denominator in case of zero variance.\n        :param name: name of the loss.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "if", "background_weight", "<", "0", "or", "background_weight", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"The background weight for Dice Score must be \"", "\n", "f\"within [0, 1], got {background_weight}.\"", "\n", ")", "\n", "\n", "", "self", ".", "binary", "=", "binary", "\n", "self", ".", "background_weight", "=", "background_weight", "\n", "self", ".", "smooth_nr", "=", "smooth_nr", "\n", "self", ".", "smooth_dr", "=", "smooth_dr", "\n", "self", ".", "flatten", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.DiceScore.call": [[108, 143], ["label.DiceScore.flatten", "label.DiceScore.flatten", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.cast", "tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.ones_like"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return loss for a batch.\n\n        :param y_true: shape = (batch, ...)\n        :param y_pred: shape = (batch, ...)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "if", "self", ".", "binary", ":", "\n", "            ", "y_true", "=", "tf", ".", "cast", "(", "y_true", ">=", "0.5", ",", "dtype", "=", "y_true", ".", "dtype", ")", "\n", "y_pred", "=", "tf", ".", "cast", "(", "y_pred", ">=", "0.5", ",", "dtype", "=", "y_pred", ".", "dtype", ")", "\n", "\n", "# (batch, ...) -> (batch, d)", "\n", "", "y_true", "=", "self", ".", "flatten", "(", "y_true", ")", "\n", "y_pred", "=", "self", ".", "flatten", "(", "y_pred", ")", "\n", "\n", "# for foreground class", "\n", "y_prod", "=", "tf", ".", "reduce_sum", "(", "y_true", "*", "y_pred", ",", "axis", "=", "1", ")", "\n", "y_sum", "=", "tf", ".", "reduce_sum", "(", "y_true", "+", "y_pred", ",", "axis", "=", "1", ")", "\n", "\n", "if", "self", ".", "background_weight", ">", "0", ":", "\n", "# generalized", "\n", "            ", "vol", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "ones_like", "(", "y_true", ")", ",", "axis", "=", "1", ")", "\n", "numerator", "=", "2", "*", "(", "\n", "y_prod", "-", "self", ".", "background_weight", "*", "y_sum", "+", "self", ".", "background_weight", "*", "vol", "\n", ")", "\n", "denominator", "=", "(", "\n", "1", "-", "2", "*", "self", ".", "background_weight", "\n", ")", "*", "y_sum", "+", "2", "*", "self", ".", "background_weight", "*", "vol", "\n", "", "else", ":", "\n", "# foreground only", "\n", "            ", "numerator", "=", "2", "*", "y_prod", "\n", "denominator", "=", "y_sum", "\n", "\n", "", "return", "(", "numerator", "+", "self", ".", "smooth_nr", ")", "/", "(", "denominator", "+", "self", ".", "smooth_dr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.DiceScore.get_config": [[144, 154], ["super().get_config", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "\n", "binary", "=", "self", ".", "binary", ",", "\n", "background_weight", "=", "self", ".", "background_weight", ",", "\n", "smooth_nr", "=", "self", ".", "smooth_nr", ",", "\n", "smooth_dr", "=", "self", ".", "smooth_dr", ",", "\n", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.CrossEntropy.__init__": [[169, 196], ["super().__init__", "tensorflow.keras.layers.Flatten", "ValueError"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "binary", ":", "bool", "=", "False", ",", "\n", "background_weight", ":", "float", "=", "0.0", ",", "\n", "smooth", ":", "float", "=", "EPS", ",", "\n", "name", ":", "str", "=", "\"CrossEntropy\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param binary: if True, project y_true, y_pred to 0 or 1\n        :param background_weight: weight for background, where y == 0.\n        :param smooth: smooth constant for log.\n        :param name: name of the loss.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "if", "background_weight", "<", "0", "or", "background_weight", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"The background weight for Cross Entropy must be \"", "\n", "f\"within [0, 1], got {background_weight}.\"", "\n", ")", "\n", "", "self", ".", "binary", "=", "binary", "\n", "self", ".", "background_weight", "=", "background_weight", "\n", "self", ".", "smooth", "=", "smooth", "\n", "self", ".", "flatten", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.CrossEntropy.call": [[197, 223], ["label.CrossEntropy.flatten", "label.CrossEntropy.flatten", "tensorflow.cast", "tensorflow.cast", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.math.log", "tensorflow.math.log"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return loss for a batch.\n\n        :param y_true: shape = (batch, ...)\n        :param y_pred: shape = (batch, ...)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "if", "self", ".", "binary", ":", "\n", "            ", "y_true", "=", "tf", ".", "cast", "(", "y_true", ">=", "0.5", ",", "dtype", "=", "y_true", ".", "dtype", ")", "\n", "y_pred", "=", "tf", ".", "cast", "(", "y_pred", ">=", "0.5", ",", "dtype", "=", "y_pred", ".", "dtype", ")", "\n", "\n", "# (batch, ...) -> (batch, d)", "\n", "", "y_true", "=", "self", ".", "flatten", "(", "y_true", ")", "\n", "y_pred", "=", "self", ".", "flatten", "(", "y_pred", ")", "\n", "\n", "loss_fg", "=", "-", "tf", ".", "reduce_mean", "(", "y_true", "*", "tf", ".", "math", ".", "log", "(", "y_pred", "+", "self", ".", "smooth", ")", ",", "axis", "=", "1", ")", "\n", "if", "self", ".", "background_weight", ">", "0", ":", "\n", "            ", "loss_bg", "=", "-", "tf", ".", "reduce_mean", "(", "\n", "(", "1", "-", "y_true", ")", "*", "tf", ".", "math", ".", "log", "(", "1", "-", "y_pred", "+", "self", ".", "smooth", ")", ",", "axis", "=", "1", "\n", ")", "\n", "return", "(", "\n", "1", "-", "self", ".", "background_weight", "\n", ")", "*", "loss_fg", "+", "self", ".", "background_weight", "*", "loss_bg", "\n", "", "else", ":", "\n", "            ", "return", "loss_fg", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.CrossEntropy.get_config": [[224, 233], ["super().get_config", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "\n", "binary", "=", "self", ".", "binary", ",", "\n", "background_weight", "=", "self", ".", "background_weight", ",", "\n", "smooth", "=", "self", ".", "smooth", ",", "\n", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.JaccardIndex.__init__": [[261, 287], ["label.DiceScore.__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "binary", ":", "bool", "=", "False", ",", "\n", "background_weight", ":", "float", "=", "0.0", ",", "\n", "smooth_nr", ":", "float", "=", "EPS", ",", "\n", "smooth_dr", ":", "float", "=", "EPS", ",", "\n", "name", ":", "str", "=", "\"JaccardIndex\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param binary: if True, project y_true, y_pred to 0 or 1.\n        :param background_weight: weight for background, where y == 0.\n        :param smooth_nr: small constant added to numerator in case of zero covariance.\n        :param smooth_dr: small constant added to denominator in case of zero variance.\n        :param name: name of the loss.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "binary", "=", "binary", ",", "\n", "background_weight", "=", "background_weight", ",", "\n", "smooth_nr", "=", "smooth_nr", ",", "\n", "smooth_dr", "=", "smooth_dr", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.JaccardIndex.call": [[289, 326], ["label.JaccardIndex.flatten", "label.JaccardIndex.flatten", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.cast", "tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.ones_like"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return loss for a batch.\n\n        :param y_true: shape = (batch, ...)\n        :param y_pred: shape = (batch, ...)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "if", "self", ".", "binary", ":", "\n", "            ", "y_true", "=", "tf", ".", "cast", "(", "y_true", ">=", "0.5", ",", "dtype", "=", "y_true", ".", "dtype", ")", "\n", "y_pred", "=", "tf", ".", "cast", "(", "y_pred", ">=", "0.5", ",", "dtype", "=", "y_pred", ".", "dtype", ")", "\n", "\n", "# (batch, ...) -> (batch, d)", "\n", "", "y_true", "=", "self", ".", "flatten", "(", "y_true", ")", "\n", "y_pred", "=", "self", ".", "flatten", "(", "y_pred", ")", "\n", "\n", "# for foreground class", "\n", "y_prod", "=", "tf", ".", "reduce_sum", "(", "y_true", "*", "y_pred", ",", "axis", "=", "1", ")", "\n", "y_sum", "=", "tf", ".", "reduce_sum", "(", "y_true", "+", "y_pred", ",", "axis", "=", "1", ")", "\n", "\n", "if", "self", ".", "background_weight", ">", "0", ":", "\n", "# generalized", "\n", "            ", "vol", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "ones_like", "(", "y_true", ")", ",", "axis", "=", "1", ")", "\n", "numerator", "=", "(", "\n", "y_prod", "-", "self", ".", "background_weight", "*", "y_sum", "+", "self", ".", "background_weight", "*", "vol", "\n", ")", "\n", "denominator", "=", "(", "\n", "(", "1", "-", "self", ".", "background_weight", ")", "*", "y_sum", "\n", "-", "y_prod", "\n", "+", "self", ".", "background_weight", "*", "vol", "\n", ")", "\n", "", "else", ":", "\n", "# foreground only", "\n", "            ", "numerator", "=", "y_prod", "\n", "denominator", "=", "y_sum", "-", "y_prod", "\n", "\n", "", "return", "(", "numerator", "+", "self", ".", "smooth_nr", ")", "/", "(", "denominator", "+", "self", ".", "smooth_dr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.compute_centroid": [[333, 350], ["tensorflow.expand_dims", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "len", "len", "tensorflow.cast"], "function", ["None"], ["", "def", "compute_centroid", "(", "mask", ":", "tf", ".", "Tensor", ",", "grid", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Calculate the centroid of the mask.\n    :param mask: shape = (batch, dim1, dim2, dim3)\n    :param grid: shape = (1, dim1, dim2, dim3, 3)\n    :return: shape = (batch, 3), batch of vectors denoting\n             location of centroids.\n    \"\"\"", "\n", "assert", "len", "(", "mask", ".", "shape", ")", "==", "4", "\n", "assert", "len", "(", "grid", ".", "shape", ")", "==", "5", "\n", "bool_mask", "=", "tf", ".", "expand_dims", "(", "\n", "tf", ".", "cast", "(", "mask", ">=", "0.5", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "axis", "=", "4", "\n", ")", "# (batch, dim1, dim2, dim3, 1)", "\n", "masked_grid", "=", "bool_mask", "*", "grid", "# (batch, dim1, dim2, dim3, 3)", "\n", "numerator", "=", "tf", ".", "reduce_sum", "(", "masked_grid", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "# (batch, 3)", "\n", "denominator", "=", "tf", ".", "reduce_sum", "(", "bool_mask", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "# (batch, 1)", "\n", "return", "(", "numerator", "+", "EPS", ")", "/", "(", "denominator", "+", "EPS", ")", "# (batch, 3)", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.compute_centroid_distance": [[352, 365], ["label.compute_centroid", "label.compute_centroid", "tensorflow.sqrt", "tensorflow.reduce_sum"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.compute_centroid", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.compute_centroid"], ["", "def", "compute_centroid_distance", "(", "\n", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ",", "grid", ":", "tf", ".", "Tensor", "\n", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Calculate the L2-distance between two tensors' centroids.\n    :param y_true: tensor, shape = (batch, dim1, dim2, dim3)\n    :param y_pred: tensor, shape = (batch, dim1, dim2, dim3)\n    :param grid: tensor, shape = (1, dim1, dim2, dim3, 3)\n    :return: shape = (batch,)\n    \"\"\"", "\n", "centroid_1", "=", "compute_centroid", "(", "mask", "=", "y_pred", ",", "grid", "=", "grid", ")", "# (batch, 3)", "\n", "centroid_2", "=", "compute_centroid", "(", "mask", "=", "y_true", ",", "grid", "=", "grid", ")", "# (batch, 3)", "\n", "return", "tf", ".", "sqrt", "(", "tf", ".", "reduce_sum", "(", "(", "centroid_1", "-", "centroid_2", ")", "**", "2", ",", "axis", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.label.foreground_proportion": [[367, 376], ["tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.ones_like"], "function", ["None"], ["", "def", "foreground_proportion", "(", "y", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Calculate the percentage of foreground vs background per 3d volume.\n    :param y: shape = (batch, dim1, dim2, dim3), a 3D label tensor\n    :return: shape = (batch,)\n    \"\"\"", "\n", "y", "=", "tf", ".", "cast", "(", "y", ">=", "0.5", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "y", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "/", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "ones_like", "(", "y", ")", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.MultiScaleMixin.__init__": [[21, 44], ["super().__init__", "ValueError", "isinstance", "list", "util.MultiScaleMixin.kernel_fn_dict.keys"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["y", "=", "np", ".", "asarray", "(", "y", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# check shape", "\n", "if", "x", ".", "shape", "!=", "y", ".", "shape", ":", "\n", "        ", "return", "False", "\n", "\n", "# check nan values", "\n", "# support case some values are nan", "\n", "", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "x", ")", "!=", "np", ".", "isnan", "(", "y", ")", ")", ":", "\n", "        ", "return", "False", "\n", "", "x", "=", "np", ".", "nan_to_num", "(", "x", ")", "\n", "y", "=", "np", ".", "nan_to_num", "(", "y", ")", "\n", "\n", "# check values", "\n", "return", "np", ".", "all", "(", "np", ".", "isclose", "(", "x", ",", "y", ",", "atol", "=", "atol", ")", ")", "\n", "\n", "\n", "", "def", "is_equal_tf", "(", "\n", "x", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "y", ":", "Union", "[", "tf", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "]", ",", "\n", "atol", ":", "float", "=", "EPS", ",", "\n", ")", "->", "bool", ":", "\n", "    "]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.MultiScaleMixin.call": [[45, 80], ["tensorflow.add_n", "super().call", "len", "losses.append", "losses.append", "super().call", "super().call", "util.separable_filter", "util.separable_filter", "tensorflow.expand_dims", "kernel_fn", "tensorflow.expand_dims", "kernel_fn"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter"], ["\n", "x", "=", "tf", ".", "cast", "(", "x", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "y", "=", "tf", ".", "cast", "(", "y", ",", "dtype", "=", "tf", ".", "float32", ")", ".", "numpy", "(", ")", "\n", "return", "is_equal_np", "(", "x", "=", "x", ",", "y", "=", "y", ",", "atol", "=", "atol", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.MultiScaleMixin.get_config": [[81, 87], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.NegativeLossMixin.__init__": [[92, 100], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.NegativeLossMixin.call": [[101, 110], ["super().call"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter": [[112, 146], ["tensorflow.cast", "tensorflow.nn.conv3d", "tensorflow.nn.conv3d", "tensorflow.nn.conv3d", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape"], "function", ["None"], []], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.GlobalMutualInformation.__init__": [[21, 39], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_bins", ":", "int", "=", "23", ",", "\n", "sigma_ratio", ":", "float", "=", "0.5", ",", "\n", "name", ":", "str", "=", "\"GlobalMutualInformation\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param num_bins: number of bins for intensity, the default value is empirical.\n        :param sigma_ratio: a hyper param for gaussian function\n        :param name: name of the loss\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "self", ".", "num_bins", "=", "num_bins", "\n", "self", ".", "sigma_ratio", "=", "sigma_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.GlobalMutualInformation.call": [[40, 93], ["tensorflow.clip_by_value", "tensorflow.clip_by_value", "tensorflow.linspace", "tensorflow.cast", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.math.exp", "tensorflow.reduce_sum", "tensorflow.transpose", "tensorflow.reduce_mean", "tensorflow.math.exp", "tensorflow.reduce_sum", "tensorflow.reduce_mean", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.reduce_sum", "len", "tensorflow.expand_dims", "tensorflow.expand_dims", "len", "len", "tensorflow.reduce_mean", "tensorflow.math.square", "tensorflow.math.square", "tensorflow.math.square", "tensorflow.math.log"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return loss for a batch.\n\n        :param y_true: shape = (batch, dim1, dim2, dim3)\n            or (batch, dim1, dim2, dim3, ch)\n        :param y_pred: shape = (batch, dim1, dim2, dim3)\n            or (batch, dim1, dim2, dim3, ch)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "# adjust", "\n", "if", "len", "(", "y_true", ".", "shape", ")", "==", "4", ":", "\n", "            ", "y_true", "=", "tf", ".", "expand_dims", "(", "y_true", ",", "axis", "=", "4", ")", "\n", "y_pred", "=", "tf", ".", "expand_dims", "(", "y_pred", ",", "axis", "=", "4", ")", "\n", "", "assert", "len", "(", "y_true", ".", "shape", ")", "==", "len", "(", "y_pred", ".", "shape", ")", "==", "5", "\n", "\n", "# intensity is split into bins between 0, 1", "\n", "y_true", "=", "tf", ".", "clip_by_value", "(", "y_true", ",", "0", ",", "1", ")", "\n", "y_pred", "=", "tf", ".", "clip_by_value", "(", "y_pred", ",", "0", ",", "1", ")", "\n", "bin_centers", "=", "tf", ".", "linspace", "(", "0.0", ",", "1.0", ",", "self", ".", "num_bins", ")", "# (num_bins,)", "\n", "bin_centers", "=", "tf", ".", "cast", "(", "bin_centers", ",", "dtype", "=", "y_true", ".", "dtype", ")", "\n", "bin_centers", "=", "bin_centers", "[", "None", ",", "None", ",", "...", "]", "# (1, 1, num_bins)", "\n", "sigma", "=", "(", "\n", "tf", ".", "reduce_mean", "(", "bin_centers", "[", ":", ",", ":", ",", "1", ":", "]", "-", "bin_centers", "[", ":", ",", ":", ",", ":", "-", "1", "]", ")", "\n", "*", "self", ".", "sigma_ratio", "\n", ")", "# scalar, sigma in the Gaussian function (weighting function W)", "\n", "preterm", "=", "1", "/", "(", "2", "*", "tf", ".", "math", ".", "square", "(", "sigma", ")", ")", "# scalar", "\n", "batch", ",", "w", ",", "h", ",", "z", ",", "c", "=", "y_true", ".", "shape", "\n", "y_true", "=", "tf", ".", "reshape", "(", "y_true", ",", "[", "batch", ",", "w", "*", "h", "*", "z", "*", "c", ",", "1", "]", ")", "# (batch, nb_voxels, 1)", "\n", "y_pred", "=", "tf", ".", "reshape", "(", "y_pred", ",", "[", "batch", ",", "w", "*", "h", "*", "z", "*", "c", ",", "1", "]", ")", "# (batch, nb_voxels, 1)", "\n", "nb_voxels", "=", "y_true", ".", "shape", "[", "1", "]", "*", "1.0", "# w * h * z, number of voxels", "\n", "\n", "# each voxel contributes continuously to a range of histogram bin", "\n", "ia", "=", "tf", ".", "math", ".", "exp", "(", "\n", "-", "preterm", "*", "tf", ".", "math", ".", "square", "(", "y_true", "-", "bin_centers", ")", "\n", ")", "# (batch, nb_voxels, num_bins)", "\n", "ia", "/=", "tf", ".", "reduce_sum", "(", "ia", ",", "-", "1", ",", "keepdims", "=", "True", ")", "# (batch, nb_voxels, num_bins)", "\n", "ia", "=", "tf", ".", "transpose", "(", "ia", ",", "(", "0", ",", "2", ",", "1", ")", ")", "# (batch, num_bins, nb_voxels)", "\n", "pa", "=", "tf", ".", "reduce_mean", "(", "ia", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "# (batch, num_bins, 1)", "\n", "\n", "ib", "=", "tf", ".", "math", ".", "exp", "(", "\n", "-", "preterm", "*", "tf", ".", "math", ".", "square", "(", "y_pred", "-", "bin_centers", ")", "\n", ")", "# (batch, nb_voxels, num_bins)", "\n", "ib", "/=", "tf", ".", "reduce_sum", "(", "ib", ",", "-", "1", ",", "keepdims", "=", "True", ")", "# (batch, nb_voxels, num_bins)", "\n", "pb", "=", "tf", ".", "reduce_mean", "(", "ib", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "# (batch, 1, num_bins)", "\n", "\n", "papb", "=", "tf", ".", "matmul", "(", "pa", ",", "pb", ")", "# (batch, num_bins, num_bins)", "\n", "pab", "=", "tf", ".", "matmul", "(", "ia", ",", "ib", ")", "# (batch, num_bins, num_bins)", "\n", "pab", "/=", "nb_voxels", "\n", "\n", "# MI: sum(P_ab * log(P_ab/P_ap_b))", "\n", "div", "=", "(", "pab", "+", "EPS", ")", "/", "(", "papb", "+", "EPS", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "pab", "*", "tf", ".", "math", ".", "log", "(", "div", "+", "EPS", ")", ",", "axis", "=", "[", "1", ",", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.GlobalMutualInformation.get_config": [[94, 100], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", "[", "\"num_bins\"", "]", "=", "self", ".", "num_bins", "\n", "config", "[", "\"sigma_ratio\"", "]", "=", "self", ".", "sigma_ratio", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.LocalNormalizedCrossCorrelation.__init__": [[147, 185], ["super().__init__", "image.LocalNormalizedCrossCorrelation.kernel_fn", "tensorflow.reduce_sum", "image.LocalNormalizedCrossCorrelation.kernel_fn_dict.keys", "ValueError", "image.LocalNormalizedCrossCorrelation.kernel_fn_dict.keys"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "kernel_size", ":", "int", "=", "9", ",", "\n", "kernel_type", ":", "str", "=", "\"rectangular\"", ",", "\n", "smooth_nr", ":", "float", "=", "EPS", ",", "\n", "smooth_dr", ":", "float", "=", "EPS", ",", "\n", "name", ":", "str", "=", "\"LocalNormalizedCrossCorrelation\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param kernel_size: int. Kernel size or kernel sigma for kernel_type='gauss'.\n        :param kernel_type: str, rectangular, triangular or gaussian\n        :param smooth_nr: small constant added to numerator in case of zero covariance.\n        :param smooth_dr: small constant added to denominator in case of zero variance.\n        :param name: name of the loss.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "if", "kernel_type", "not", "in", "self", ".", "kernel_fn_dict", ".", "keys", "(", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Wrong kernel_type {kernel_type} for LNCC loss type. \"", "\n", "f\"Feasible values are {self.kernel_fn_dict.keys()}\"", "\n", ")", "\n", "", "self", ".", "kernel_fn", "=", "self", ".", "kernel_fn_dict", "[", "kernel_type", "]", "\n", "self", ".", "kernel_type", "=", "kernel_type", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "smooth_nr", "=", "smooth_nr", "\n", "self", ".", "smooth_dr", "=", "smooth_dr", "\n", "\n", "# (kernel_size, )", "\n", "self", ".", "kernel", "=", "self", ".", "kernel_fn", "(", "kernel_size", "=", "self", ".", "kernel_size", ")", "\n", "# E[1] = sum_i(w_i), ()", "\n", "self", ".", "kernel_vol", "=", "tf", ".", "reduce_sum", "(", "\n", "self", ".", "kernel", "[", ":", ",", "None", ",", "None", "]", "\n", "*", "self", ".", "kernel", "[", "None", ",", ":", ",", "None", "]", "\n", "*", "self", ".", "kernel", "[", "None", ",", "None", ",", ":", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.LocalNormalizedCrossCorrelation.calc_ncc": [[187, 236], ["deepreg.loss.util.separable_filter", "deepreg.loss.util.separable_filter", "deepreg.loss.util.separable_filter", "deepreg.loss.util.separable_filter", "deepreg.loss.util.separable_filter", "tensorflow.maximum", "tensorflow.maximum"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.util.separable_filter"], ["", "def", "calc_ncc", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return NCC for a batch.\n\n        The kernel should not be normalized, as normalizing them leads to computation\n        with small values and the precision will be reduced.\n        Here both numerator and denominator are actually multiplied by kernel volume,\n        which helps the precision as well.\n        However, when the variance is zero, the obtained value might be negative due to\n        machine error. Therefore a hard-coded clipping is added to\n        prevent division by zero.\n\n        :param y_true: shape = (batch, dim1, dim2, dim3, 1)\n        :param y_pred: shape = (batch, dim1, dim2, dim3, 1)\n        :return: shape = (batch, dim1, dim2, dim3. 1)\n        \"\"\"", "\n", "\n", "# t = y_true, p = y_pred", "\n", "# (batch, dim1, dim2, dim3, 1)", "\n", "t2", "=", "y_true", "*", "y_true", "\n", "p2", "=", "y_pred", "*", "y_pred", "\n", "tp", "=", "y_true", "*", "y_pred", "\n", "\n", "# sum over kernel", "\n", "# (batch, dim1, dim2, dim3, 1)", "\n", "t_sum", "=", "separable_filter", "(", "y_true", ",", "kernel", "=", "self", ".", "kernel", ")", "# E[t] * E[1]", "\n", "p_sum", "=", "separable_filter", "(", "y_pred", ",", "kernel", "=", "self", ".", "kernel", ")", "# E[p] * E[1]", "\n", "t2_sum", "=", "separable_filter", "(", "t2", ",", "kernel", "=", "self", ".", "kernel", ")", "# E[tt] * E[1]", "\n", "p2_sum", "=", "separable_filter", "(", "p2", ",", "kernel", "=", "self", ".", "kernel", ")", "# E[pp] * E[1]", "\n", "tp_sum", "=", "separable_filter", "(", "tp", ",", "kernel", "=", "self", ".", "kernel", ")", "# E[tp] * E[1]", "\n", "\n", "# average over kernel", "\n", "# (batch, dim1, dim2, dim3, 1)", "\n", "t_avg", "=", "t_sum", "/", "self", ".", "kernel_vol", "# E[t]", "\n", "p_avg", "=", "p_sum", "/", "self", ".", "kernel_vol", "# E[p]", "\n", "\n", "# shape = (batch, dim1, dim2, dim3, 1)", "\n", "cross", "=", "tp_sum", "-", "p_avg", "*", "t_sum", "# E[tp] * E[1] - E[p] * E[t] * E[1]", "\n", "t_var", "=", "t2_sum", "-", "t_avg", "*", "t_sum", "# V[t] * E[1]", "\n", "p_var", "=", "p2_sum", "-", "p_avg", "*", "p_sum", "# V[p] * E[1]", "\n", "\n", "# ensure variance >= 0", "\n", "t_var", "=", "tf", ".", "maximum", "(", "t_var", ",", "0", ")", "\n", "p_var", "=", "tf", ".", "maximum", "(", "p_var", ",", "0", ")", "\n", "\n", "# (E[tp] - E[p] * E[t]) ** 2 / V[t] / V[p]", "\n", "ncc", "=", "(", "cross", "*", "cross", "+", "self", ".", "smooth_nr", ")", "/", "(", "t_var", "*", "p_var", "+", "self", ".", "smooth_dr", ")", "\n", "\n", "return", "ncc", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.LocalNormalizedCrossCorrelation.call": [[237, 265], ["image.LocalNormalizedCrossCorrelation.calc_ncc", "tensorflow.reduce_mean", "len", "tensorflow.expand_dims", "ValueError", "len", "tensorflow.expand_dims", "ValueError"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.LocalNormalizedCrossCorrelation.calc_ncc"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return loss for a batch.\n\n        TODO: support channel axis dimension > 1.\n\n        :param y_true: shape = (batch, dim1, dim2, dim3)\n            or (batch, dim1, dim2, dim3, 1)\n        :param y_pred: shape = (batch, dim1, dim2, dim3)\n            or (batch, dim1, dim2, dim3, 1)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "# sanity checks", "\n", "if", "len", "(", "y_true", ".", "shape", ")", "==", "4", ":", "\n", "            ", "y_true", "=", "tf", ".", "expand_dims", "(", "y_true", ",", "axis", "=", "4", ")", "\n", "", "if", "y_true", ".", "shape", "[", "4", "]", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Last dimension of y_true is not one. \"", "f\"y_true.shape = {y_true.shape}\"", "\n", ")", "\n", "", "if", "len", "(", "y_pred", ".", "shape", ")", "==", "4", ":", "\n", "            ", "y_pred", "=", "tf", ".", "expand_dims", "(", "y_pred", ",", "axis", "=", "4", ")", "\n", "", "if", "y_pred", ".", "shape", "[", "4", "]", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Last dimension of y_pred is not one. \"", "f\"y_pred.shape = {y_pred.shape}\"", "\n", ")", "\n", "\n", "", "ncc", "=", "self", ".", "calc_ncc", "(", "y_true", "=", "y_true", ",", "y_pred", "=", "y_pred", ")", "\n", "return", "tf", ".", "reduce_mean", "(", "ncc", ",", "axis", "=", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.LocalNormalizedCrossCorrelation.get_config": [[266, 276], ["super().get_config", "super().get_config.update"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", ".", "update", "(", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "kernel_type", "=", "self", ".", "kernel_type", ",", "\n", "smooth_nr", "=", "self", ".", "smooth_nr", ",", "\n", "smooth_dr", "=", "self", ".", "smooth_dr", ",", "\n", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.GlobalNormalizedCrossCorrelation.__init__": [[299, 311], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", "=", "\"GlobalNormalizedCrossCorrelation\"", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param name: name of the loss\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.image.GlobalNormalizedCrossCorrelation.call": [[312, 331], ["tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.math.reduce_variance", "tensorflow.math.reduce_variance", "tensorflow.abs", "tensorflow.reduce_mean", "range", "len"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "y_true", ":", "tf", ".", "Tensor", ",", "y_pred", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return loss for a batch.\n\n        :param y_true: shape = (batch, ...)\n        :param y_pred: shape = (batch, ...)\n        :return: shape = (batch,)\n        \"\"\"", "\n", "\n", "axis", "=", "[", "a", "for", "a", "in", "range", "(", "1", ",", "len", "(", "y_true", ".", "shape", ")", ")", "]", "\n", "mu_pred", "=", "tf", ".", "reduce_mean", "(", "y_pred", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "mu_true", "=", "tf", ".", "reduce_mean", "(", "y_true", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "var_pred", "=", "tf", ".", "math", ".", "reduce_variance", "(", "y_pred", ",", "axis", "=", "axis", ")", "\n", "var_true", "=", "tf", ".", "math", ".", "reduce_variance", "(", "y_true", ",", "axis", "=", "axis", ")", "\n", "numerator", "=", "tf", ".", "abs", "(", "\n", "tf", ".", "reduce_mean", "(", "(", "y_pred", "-", "mu_pred", ")", "*", "(", "y_true", "-", "mu_true", ")", ",", "axis", "=", "axis", ")", "\n", ")", "\n", "\n", "return", "(", "numerator", "*", "numerator", "+", "EPS", ")", "/", "(", "var_pred", "*", "var_true", "+", "EPS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.__init__": [[69, 79], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "self", ",", "l1", ":", "bool", "=", "False", ",", "name", ":", "str", "=", "\"GradientNorm\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param l1: bool true if calculate L1 norm, otherwise L2 norm\n        :param name: name of the loss\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "l1", "=", "l1", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.call": [[80, 100], ["deform.gradient_dxyz", "deform.gradient_dxyz", "deform.gradient_dxyz", "tensorflow.reduce_mean", "len", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz"], ["", "def", "call", "(", "self", ",", "inputs", ":", "tf", ".", "Tensor", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return a scalar loss.\n\n        :param inputs: shape = (batch, m_dim1, m_dim2, m_dim3, 3)\n        :param kwargs: additional arguments.\n        :return: shape = (batch, )\n        \"\"\"", "\n", "assert", "len", "(", "inputs", ".", "shape", ")", "==", "5", "\n", "ddf", "=", "inputs", "\n", "# first order gradient", "\n", "# (batch, m_dim1-2, m_dim2-2, m_dim3-2, 3)", "\n", "dfdx", "=", "gradient_dxyz", "(", "ddf", ",", "gradient_dx", ")", "\n", "dfdy", "=", "gradient_dxyz", "(", "ddf", ",", "gradient_dy", ")", "\n", "dfdz", "=", "gradient_dxyz", "(", "ddf", ",", "gradient_dz", ")", "\n", "if", "self", ".", "l1", ":", "\n", "            ", "norms", "=", "tf", ".", "abs", "(", "dfdx", ")", "+", "tf", ".", "abs", "(", "dfdy", ")", "+", "tf", ".", "abs", "(", "dfdz", ")", "\n", "", "else", ":", "\n", "            ", "norms", "=", "dfdx", "**", "2", "+", "dfdy", "**", "2", "+", "dfdz", "**", "2", "\n", "", "return", "tf", ".", "reduce_mean", "(", "norms", ",", "axis", "=", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config": [[101, 106], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.GradientNorm.get_config"], ["", "def", "get_config", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Return the config dictionary for recreating this class.\"\"\"", "\n", "config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "config", "[", "\"l1\"", "]", "=", "self", ".", "l1", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__": [[116, 124], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "str", "=", "\"BendingEnergy\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Init.\n\n        :param name: name of the loss.\n        :param kwargs: additional arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.BendingEnergy.call": [[125, 154], ["deform.gradient_dxyz", "deform.gradient_dxyz", "deform.gradient_dxyz", "deform.gradient_dxyz", "deform.gradient_dxyz", "deform.gradient_dxyz", "deform.gradient_dxyz", "deform.gradient_dxyz", "deform.gradient_dxyz", "tensorflow.reduce_mean", "len"], "methods", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz"], ["", "def", "call", "(", "self", ",", "inputs", ":", "tf", ".", "Tensor", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return a scalar loss.\n\n        :param inputs: shape = (batch, m_dim1, m_dim2, m_dim3, 3)\n        :param kwargs: additional arguments.\n        :return: shape = (batch, )\n        \"\"\"", "\n", "assert", "len", "(", "inputs", ".", "shape", ")", "==", "5", "\n", "ddf", "=", "inputs", "\n", "# first order gradient", "\n", "# (batch, m_dim1-2, m_dim2-2, m_dim3-2, 3)", "\n", "dfdx", "=", "gradient_dxyz", "(", "ddf", ",", "gradient_dx", ")", "\n", "dfdy", "=", "gradient_dxyz", "(", "ddf", ",", "gradient_dy", ")", "\n", "dfdz", "=", "gradient_dxyz", "(", "ddf", ",", "gradient_dz", ")", "\n", "\n", "# second order gradient", "\n", "# (batch, m_dim1-4, m_dim2-4, m_dim3-4, 3)", "\n", "dfdxx", "=", "gradient_dxyz", "(", "dfdx", ",", "gradient_dx", ")", "\n", "dfdyy", "=", "gradient_dxyz", "(", "dfdy", ",", "gradient_dy", ")", "\n", "dfdzz", "=", "gradient_dxyz", "(", "dfdz", ",", "gradient_dz", ")", "\n", "dfdxy", "=", "gradient_dxyz", "(", "dfdx", ",", "gradient_dy", ")", "\n", "dfdyz", "=", "gradient_dxyz", "(", "dfdy", ",", "gradient_dz", ")", "\n", "dfdxz", "=", "gradient_dxyz", "(", "dfdx", ",", "gradient_dz", ")", "\n", "\n", "# (dx + dy + dz) ** 2 = dxx + dyy + dzz + 2*(dxy + dyz + dzx)", "\n", "energy", "=", "dfdxx", "**", "2", "+", "dfdyy", "**", "2", "+", "dfdzz", "**", "2", "\n", "energy", "+=", "2", "*", "dfdxy", "**", "2", "+", "2", "*", "dfdxz", "**", "2", "+", "2", "*", "dfdyz", "**", "2", "\n", "return", "tf", ".", "reduce_mean", "(", "energy", ",", "axis", "=", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dx": [[9, 20], ["None"], "function", ["None"], ["def", "gradient_dx", "(", "fx", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Calculate gradients on x-axis of a 3D tensor using central finite difference.\n\n    It moves the tensor along axis 1 to calculate the approximate gradient, the x axis,\n    dx[i] = (x[i+1] - x[i-1]) / 2.\n\n    :param fx: shape = (batch, m_dim1, m_dim2, m_dim3)\n    :return: shape = (batch, m_dim1-2, m_dim2-2, m_dim3-2)\n    \"\"\"", "\n", "return", "(", "fx", "[", ":", ",", "2", ":", ",", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", "-", "fx", "[", ":", ",", ":", "-", "2", ",", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dy": [[22, 33], ["None"], "function", ["None"], ["", "def", "gradient_dy", "(", "fy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Calculate gradients on y-axis of a 3D tensor using central finite difference.\n\n    It moves the tensor along axis 2 to calculate the approximate gradient, the y axis,\n    dy[i] = (y[i+1] - y[i-1]) / 2.\n\n    :param fy: shape = (batch, m_dim1, m_dim2, m_dim3)\n    :return: shape = (batch, m_dim1-2, m_dim2-2, m_dim3-2)\n    \"\"\"", "\n", "return", "(", "fy", "[", ":", ",", "1", ":", "-", "1", ",", "2", ":", ",", "1", ":", "-", "1", "]", "-", "fy", "[", ":", ",", "1", ":", "-", "1", ",", ":", "-", "2", ",", "1", ":", "-", "1", "]", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dz": [[35, 46], ["None"], "function", ["None"], ["", "def", "gradient_dz", "(", "fz", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Calculate gradients on z-axis of a 3D tensor using central finite difference.\n\n    It moves the tensor along axis 3 to calculate the approximate gradient, the z axis,\n    dz[i] = (z[i+1] - z[i-1]) / 2.\n\n    :param fz: shape = (batch, m_dim1, m_dim2, m_dim3)\n    :return: shape = (batch, m_dim1-2, m_dim2-2, m_dim3-2)\n    \"\"\"", "\n", "return", "(", "fz", "[", ":", ",", "1", ":", "-", "1", ",", "1", ":", "-", "1", ",", "2", ":", "]", "-", "fz", "[", ":", ",", "1", ":", "-", "1", ",", "1", ":", "-", "1", ",", ":", "-", "2", "]", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dxyz": [[48, 59], ["tensorflow.stack", "deform.gradient_dx", "deform.gradient_dy", "deform.gradient_dz", "deform.gradient_dx", "deform.gradient_dy", "deform.gradient_dz", "deform.gradient_dx", "deform.gradient_dy", "deform.gradient_dz", "deform.gradient_dy", "deform.gradient_dz", "deform.gradient_dz"], "function", ["home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dx", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dy", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dx", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dy", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dx", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dy", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dy", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dz", "home.repos.pwc.inspect_result.DeepRegNet_DeepReg.loss.deform.gradient_dz"], ["", "def", "gradient_dxyz", "(", "fxyz", ":", "tf", ".", "Tensor", ",", "fn", ":", "Callable", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Calculate gradients on x,y,z-axis of a tensor using central finite difference.\n\n    The gradients are calculated along x, y, z separately then stacked together.\n\n    :param fxyz: shape = (..., 3)\n    :param fn: function to call\n    :return: shape = (..., 3)\n    \"\"\"", "\n", "return", "tf", ".", "stack", "(", "[", "fn", "(", "fxyz", "[", "...", ",", "i", "]", ")", "for", "i", "in", "[", "0", ",", "1", ",", "2", "]", "]", ",", "axis", "=", "4", ")", "\n", "\n"]]}